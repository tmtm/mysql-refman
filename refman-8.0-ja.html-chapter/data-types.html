<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第 11 章 データ型</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="MySQL 8.0 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 8.0 リファレンスマニュアル"><link rel="prev" href="charset.html" title="第 10 章 文字セット、照合順序、Unicode"><link rel="next" href="functions.html" title="第 12 章 関数と演算子"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 11 章 データ型</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="charset.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="functions.html">次へ</a></td></tr></table><hr></div><div class="status-header"><p class="alert">このページは機械翻訳したものです。</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="data-types"></a>第 11 章 データ型</h1></div></div></div><div class="toc"><p><b>目次</b></p><dl class="toc"><dt><span class="section"><a href="data-types.html#numeric-types">11.1 数値データ型</a></span></dt><dd><dl><dt><span class="section"><a href="data-types.html#numeric-type-syntax">11.1.1 数値データ型の構文</a></span></dt><dt><span class="section"><a href="data-types.html#integer-types">11.1.2 整数型 (真数値) - INTEGER、INT、SMALLINT、TINYINT、MEDIUMINT、BIGINT</a></span></dt><dt><span class="section"><a href="data-types.html#fixed-point-types">11.1.3 固定小数点型 (真数値) - DECIMAL、NUMERIC</a></span></dt><dt><span class="section"><a href="data-types.html#floating-point-types">11.1.4 浮動小数点型 (概数値) - FLOAT、DOUBLE</a></span></dt><dt><span class="section"><a href="data-types.html#bit-type">11.1.5 ビット値型 - BIT</a></span></dt><dt><span class="section"><a href="data-types.html#numeric-type-attributes">11.1.6 数値型の属性</a></span></dt><dt><span class="section"><a href="data-types.html#out-of-range-and-overflow">11.1.7 範囲外およびオーバーフローの処理</a></span></dt></dl></dd><dt><span class="section"><a href="data-types.html#date-and-time-types">11.2 日時データ型</a></span></dt><dd><dl><dt><span class="section"><a href="data-types.html#date-and-time-type-syntax">11.2.1 日時データ型の構文</a></span></dt><dt><span class="section"><a href="data-types.html#datetime">11.2.2 DATE、DATETIME、および TIMESTAMP 型</a></span></dt><dt><span class="section"><a href="data-types.html#time">11.2.3 TIME 型</a></span></dt><dt><span class="section"><a href="data-types.html#year">11.2.4 YEAR 型</a></span></dt><dt><span class="section"><a href="data-types.html#timestamp-initialization">11.2.5 TIMESTAMP および DATETIME の自動初期化および更新機能</a></span></dt><dt><span class="section"><a href="data-types.html#fractional-seconds">11.2.6 時間値での小数秒</a></span></dt><dt><span class="section"><a href="data-types.html#date-and-time-type-conversion">11.2.7 日付と時間型間での変換</a></span></dt><dt><span class="section"><a href="data-types.html#two-digit-years">11.2.8 日付の 2 桁の年</a></span></dt></dl></dd><dt><span class="section"><a href="data-types.html#string-types">11.3 文字列データ型</a></span></dt><dd><dl><dt><span class="section"><a href="data-types.html#string-type-syntax">11.3.1 文字列データ型の構文</a></span></dt><dt><span class="section"><a href="data-types.html#char">11.3.2 CHAR および VARCHAR 型</a></span></dt><dt><span class="section"><a href="data-types.html#binary-varbinary">11.3.3 BINARY および VARBINARY 型</a></span></dt><dt><span class="section"><a href="data-types.html#blob">11.3.4 BLOB 型と TEXT 型</a></span></dt><dt><span class="section"><a href="data-types.html#enum">11.3.5 ENUM 型</a></span></dt><dt><span class="section"><a href="data-types.html#set">11.3.6 SET 型</a></span></dt></dl></dd><dt><span class="section"><a href="data-types.html#spatial-types">11.4 空間データ型</a></span></dt><dd><dl><dt><span class="section"><a href="data-types.html#spatial-type-overview">11.4.1 空間データ型</a></span></dt><dt><span class="section"><a href="data-types.html#opengis-geometry-model">11.4.2 OpenGIS ジオメトリモデル</a></span></dt><dt><span class="section"><a href="data-types.html#gis-data-formats">11.4.3 サポートされる空間データ形式</a></span></dt><dt><span class="section"><a href="data-types.html#geometry-well-formedness-validity">11.4.4 ジオメトリの整形式と妥当性</a></span></dt><dt><span class="section"><a href="data-types.html#spatial-reference-systems">11.4.5 空間参照システムのサポート</a></span></dt><dt><span class="section"><a href="data-types.html#creating-spatial-columns">11.4.6 空間カラムの作成</a></span></dt><dt><span class="section"><a href="data-types.html#populating-spatial-columns">11.4.7 空間カラムへのデータ移入</a></span></dt><dt><span class="section"><a href="data-types.html#fetching-spatial-data">11.4.8 空間データのフェッチ</a></span></dt><dt><span class="section"><a href="data-types.html#optimizing-spatial-analysis">11.4.9 空間分析の最適化</a></span></dt><dt><span class="section"><a href="data-types.html#creating-spatial-indexes">11.4.10 空間インデックスの作成</a></span></dt><dt><span class="section"><a href="data-types.html#using-spatial-indexes">11.4.11 空間インデックスの使用</a></span></dt></dl></dd><dt><span class="section"><a href="data-types.html#json">11.5 JSON データ型</a></span></dt><dt><span class="section"><a href="data-types.html#data-type-defaults">11.6 データ型デフォルト値</a></span></dt><dt><span class="section"><a href="data-types.html#storage-requirements">11.7 データ型のストレージ要件</a></span></dt><dt><span class="section"><a href="data-types.html#choosing-types">11.8 カラムに適した型の選択</a></span></dt><dt><span class="section"><a href="data-types.html#other-vendor-data-types">11.9 その他のデータベースエンジンのデータ型の使用</a></span></dt></dl></div><p>
    MySQL では、複数のカテゴリの <a class="link" href="glossary.html#glos_sql" title="SQL">SQL</a> データ型がサポートされています: 数値型、日時型、文字列 (文字およびバイト) 型、空間型および <code class="literal">JSON</code> データ型。 この章では、各カテゴリのタイプのプロパティの概要と詳細、およびデータ型の記憶域要件の概要について説明します。 最初の概要は意図的に簡単です。 値を指定できる許容形式など、特定のデータ型に関する追加情報は、より詳細な説明を参照してください。 
  </p><a class="indexterm" name="idm45661465477584"></a><a class="indexterm" name="idm45661465476128"></a><a class="indexterm" name="idm45661465474096"></a><a class="indexterm" name="idm45661465472064"></a><p>
    データ型の説明では、次の規則を使用しています。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        整数型の場合、<em class="replaceable"><code>M</code></em> は最大表示幅を示します。 浮動小数点型と固定小数点型の場合、<em class="replaceable"><code>M</code></em> は格納可能な桁数の合計 (精度) です。 文字列型の場合は、<em class="replaceable"><code>M</code></em> は最大長です。 <em class="replaceable"><code>M</code></em> の許可される最大値は、データ型によって異なります。 
      </p><a class="indexterm" name="idm45661465466336"></a><a class="indexterm" name="idm45661465464992"></a><a class="indexterm" name="idm45661465463072"></a><a class="indexterm" name="idm45661465461616"></a><a class="indexterm" name="idm45661465459696"></a><a class="indexterm" name="idm45661465458240"></a></li><li class="listitem"><p>
        <a class="indexterm" name="idm45661465455680"></a> <a class="indexterm" name="idm45661465454224"></a> <a class="indexterm" name="idm45661465452192"></a> <a class="indexterm" name="idm45661465450848"></a> <em class="replaceable"><code>D</code></em> は、浮動小数点型と固定小数点型に適用され、小数点以下の桁数 (スケール) を表します。 指定可能な最大値は 30 ですが、<em class="replaceable"><code>M</code></em>−2 以下にしてください。 
      </p></li><li class="listitem"><p>
        <em class="replaceable"><code>fsp</code></em> は、<code class="literal">TIME</code>、<code class="literal">DATETIME</code> および <code class="literal">TIMESTAMP</code> タイプに適用され、小数秒精度、つまり秒の小数部の小数点以下の桁数を表します。 <em class="replaceable"><code>fsp</code></em> 値を指定する場合、0 から 6 の範囲にする必要があります。 0 の値は、小数部がないことを表します。 省略した場合、デフォルトの精度は 0 です。 (これは、以前の MySQL バージョンと互換性を保つため、標準 SQL のデフォルトである 6 とは異なっています。) 
      </p><a class="indexterm" name="idm45661465442864"></a><a class="indexterm" name="idm45661465441392"></a></li><li class="listitem"><p>
        角カッコ (<code class="literal">[</code>および<code class="literal">]</code>) は、型定義のオプション部分を示します。
      </p><a class="indexterm" name="idm45661465437136"></a><a class="indexterm" name="idm45661465434992"></a></li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="numeric-types"></a>11.1 数値データ型</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="data-types.html#numeric-type-syntax">11.1.1 数値データ型の構文</a></span></dt><dt><span class="section"><a href="data-types.html#integer-types">11.1.2 整数型 (真数値) - INTEGER、INT、SMALLINT、TINYINT、MEDIUMINT、BIGINT</a></span></dt><dt><span class="section"><a href="data-types.html#fixed-point-types">11.1.3 固定小数点型 (真数値) - DECIMAL、NUMERIC</a></span></dt><dt><span class="section"><a href="data-types.html#floating-point-types">11.1.4 浮動小数点型 (概数値) - FLOAT、DOUBLE</a></span></dt><dt><span class="section"><a href="data-types.html#bit-type">11.1.5 ビット値型 - BIT</a></span></dt><dt><span class="section"><a href="data-types.html#numeric-type-attributes">11.1.6 数値型の属性</a></span></dt><dt><span class="section"><a href="data-types.html#out-of-range-and-overflow">11.1.7 範囲外およびオーバーフローの処理</a></span></dt></dl></div><a class="indexterm" name="idm45661465432352"></a><a class="indexterm" name="idm45661465430576"></a><a class="indexterm" name="idm45661465428544"></a><p>
      MySQL はすべての標準 SQL 数値データ型をサポートします。 これらの型は、概数値データ型 (<code class="literal">FLOAT</code>、<code class="literal">REAL</code>、<code class="literal">DOUBLE PRECISION</code>) だけでなく、真数値データ型 (<code class="literal">INTEGER</code>、<code class="literal">SMALLINT</code>、<code class="literal">DECIMAL</code>、<code class="literal">NUMERIC</code>) を含みます。 キーワード <code class="literal">INT</code> は <code class="literal">INTEGER</code> のシノニムで、キーワード <code class="literal">DEC</code> および <code class="literal">FIXED</code> は <code class="literal">DECIMAL</code> のシノニムです。 MySQL では、<code class="literal">DOUBLE</code> は <code class="literal">DOUBLE PRECISION</code> (非標準の拡張) のシノニムと見なされます。 また、<code class="literal">REAL_AS_FLOAT</code> SQL モードが有効でないかぎり、<code class="literal">REAL</code> は <code class="literal">DOUBLE PRECISION</code> (非標準のバリエーション) のシノニムと見なされます。 
    </p><p>
      <code class="literal">BIT</code> データ型はビット値を格納し、<code class="literal">MyISAM</code>, <code class="literal">MEMORY</code>, <code class="literal">InnoDB</code> および <code class="literal">NDB</code> テーブルでサポートされます。
    </p><p>
      範囲外の値のカラムへの割り当てと、式の評価中のオーバーフローに対する MySQL での処理の詳細は、<a class="xref" href="data-types.html#out-of-range-and-overflow" title="11.1.7 範囲外およびオーバーフローの処理">セクション11.1.7「範囲外およびオーバーフローの処理」</a>を参照してください。
    </p><p>
      数値データ型の記憶域要件の詳細は、<a class="xref" href="data-types.html#storage-requirements" title="11.7 データ型のストレージ要件">セクション11.7「データ型のストレージ要件」</a> を参照してください。
    </p><p>
      数値を操作する関数の説明は、<a class="xref" href="functions.html#numeric-functions" title="12.6 数値関数と演算子">セクション12.6「数値関数と演算子」</a> を参照してください。 数値オペランドで計算の結果に使用されるデータ型は、オペランドの型と実行される演算によって異なります。 詳細は、<a class="xref" href="functions.html#arithmetic-functions" title="12.6.1 算術演算子">セクション12.6.1「算術演算子」</a>を参照してください。 
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="numeric-type-syntax"></a>11.1.1 数値データ型の構文</h3></div></div></div><a class="indexterm" name="idm45661465397344"></a><a class="indexterm" name="idm45661465396032"></a><a class="indexterm" name="idm45661465394688"></a><p>
        整数データ型の場合、<em class="replaceable"><code>M</code></em> は最大表示幅を示します。 最大表示幅は 255 です。 表示幅は、<a class="xref" href="data-types.html#numeric-type-attributes" title="11.1.6 数値型の属性">セクション11.1.6「数値型の属性」</a> で説明されているように、型が格納できる値の範囲とは無関係です。 
      </p><p>
        浮動小数点データ型および固定小数点データ型の場合、<em class="replaceable"><code>M</code></em> は格納できる合計桁数です。
      </p><p>
        MySQL 8.0.17 では、整数データ型の表示幅属性は非推奨になりました。将来のバージョンの MySQL ではサポートされなくなる予定です。
      </p><p>
        数値カラムに対して <code class="literal">ZEROFILL</code> を指定すると、MySQL は自動的にそのカラムに <code class="literal">UNSIGNED</code> 属性を追加します。
      </p><p>
        MySQL 8.0.17 では、<code class="literal">ZEROFILL</code> 属性は数値データ型では非推奨です。将来のバージョンの MySQL ではサポートされなくなる予定です。 この属性の効果を生成する別の方法の使用を検討してください。 たとえば、アプリケーションでは、<code class="literal">LPAD()</code> 関数を使用して、必要な幅まで数値をゼロ埋めたり、書式設定された数値を <code class="literal">CHAR</code> カラムに格納したりできます。 
      </p><p>
        <code class="literal">UNSIGNED</code> 属性を許可している数値データ型は、<code class="literal">SIGNED</code> も許可します。 ただし、このデータ型はデフォルトで符号付きになっているため、<code class="literal">SIGNED</code> 属性を指定しても効果はありません。 
      </p><p>
        MySQL 8.0.17 では、<code class="literal">FLOAT</code>、<code class="literal">DOUBLE</code> および <code class="literal">DECIMAL</code>(およびすべてのシノニム) タイプのカラムに対して <code class="literal">UNSIGNED</code> 属性は非推奨になりました。将来のバージョンの MySQL ではサポートされなくなる予定です。 このようなカラムには、かわりに単純な <code class="literal">CHECK</code> 制約の使用を検討してください。 
      </p><p>
        <code class="literal">SERIAL</code> は <code class="literal">BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE</code> のエイリアスです。
      </p><p>
        整数カラム定義の中の <code class="literal">SERIAL DEFAULT VALUE</code> は <code class="literal">NOT NULL AUTO_INCREMENT UNIQUE</code> のエイリアスです。
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          一方が <code class="literal">UNSIGNED</code> 型のときに 2 つの整数値の間で減算を行うと、<code class="literal">NO_UNSIGNED_SUBTRACTION</code> SQL モードが有効でないかぎり、結果の値は符号なしになります。 <a class="xref" href="functions.html#cast-functions" title="12.11 キャスト関数と演算子">セクション12.11「キャスト関数と演算子」</a>を参照してください。 
        </p></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="indexterm" name="idm45661465365456"></a> <a class="indexterm" name="idm45661465363984"></a> <code class="literal">BIT[(<em class="replaceable"><code>M</code></em>)]</code>
          </p><p>
            ビット値型。 <em class="replaceable"><code>M</code></em> は、値あたりのビット数 (1 から 64) を表します。 <em class="replaceable"><code>M</code></em> を省略した場合のデフォルトは 1 です。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661465355872"></a> <a class="indexterm" name="idm45661465354384"></a> <code class="literal">TINYINT[(<em class="replaceable"><code>M</code></em>)] [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            非常に小さい整数。 符号付きの範囲は <code class="literal">-128</code> から <code class="literal">127</code> です。 符号なしの範囲は <code class="literal">0</code> から <code class="literal">255</code> です。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661465344352"></a> <a class="indexterm" name="idm45661465342864"></a> <a class="indexterm" name="idm45661465341504"></a> <a class="indexterm" name="idm45661465339584"></a> <code class="literal">BOOL</code>、<code class="literal">BOOLEAN</code>
          </p><p>
            これらの型は <code class="literal">TINYINT(1)</code> のシノニムです。 ゼロの値は false と見なされます。 ゼロ以外の値は true と見なされます。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT IF(0, 'true', 'false');</code></strong>
+------------------------+
| IF(0, 'true', 'false') |
+------------------------+
| false                  |
+------------------------+

mysql&gt; <strong class="userinput"><code>SELECT IF(1, 'true', 'false');</code></strong>
+------------------------+
| IF(1, 'true', 'false') |
+------------------------+
| true                   |
+------------------------+

mysql&gt; <strong class="userinput"><code>SELECT IF(2, 'true', 'false');</code></strong>
+------------------------+
| IF(2, 'true', 'false') |
+------------------------+
| true                   |
+------------------------+
</pre><p>
            ただし、ここに示されているように、<code class="literal">TRUE</code> 値と <code class="literal">FALSE</code> 値はそれぞれ、<code class="literal">1</code> と <code class="literal">0</code> の単なるエイリアスです。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT IF(0 = FALSE, 'true', 'false');</code></strong>
+--------------------------------+
| IF(0 = FALSE, 'true', 'false') |
+--------------------------------+
| true                           |
+--------------------------------+

mysql&gt; <strong class="userinput"><code>SELECT IF(1 = TRUE, 'true', 'false');</code></strong>
+-------------------------------+
| IF(1 = TRUE, 'true', 'false') |
+-------------------------------+
| true                          |
+-------------------------------+

mysql&gt; <strong class="userinput"><code>SELECT IF(2 = TRUE, 'true', 'false');</code></strong>
+-------------------------------+
| IF(2 = TRUE, 'true', 'false') |
+-------------------------------+
| false                         |
+-------------------------------+

mysql&gt; <strong class="userinput"><code>SELECT IF(2 = FALSE, 'true', 'false');</code></strong>
+--------------------------------+
| IF(2 = FALSE, 'true', 'false') |
+--------------------------------+
| false                          |
+--------------------------------+
</pre><p>
            最後の 2 つのステートメントは、<code class="literal">2</code> が <code class="literal">1</code> とも <code class="literal">0</code> とも等しくないために示される結果を表示します。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661465315536"></a> <a class="indexterm" name="idm45661465314032"></a> <code class="literal">SMALLINT[(<em class="replaceable"><code>M</code></em>)] [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            小さい整数。 符号付きの範囲は <code class="literal">-32768</code> から <code class="literal">32767</code> です。 符号なしの範囲は <code class="literal">0</code> から <code class="literal">65535</code> です。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661465303952"></a> <a class="indexterm" name="idm45661465302448"></a> <code class="literal">MEDIUMINT[(<em class="replaceable"><code>M</code></em>)] [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            中間サイズの整数。 符号付きの範囲は <code class="literal">-8388608</code> から <code class="literal">8388607</code> です。 符号なしの範囲は <code class="literal">0</code> から <code class="literal">16777215</code> です。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661465292368"></a> <a class="indexterm" name="idm45661465290896"></a> <code class="literal">INT[(<em class="replaceable"><code>M</code></em>)] [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            普通サイズの整数。 符号付きの範囲は <code class="literal">-2147483648</code> から <code class="literal">2147483647</code> です。 符号なしの範囲は <code class="literal">0</code> から <code class="literal">4294967295</code> です。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661465281552"></a> <a class="indexterm" name="idm45661465280064"></a> <code class="literal">INTEGER[(<em class="replaceable"><code>M</code></em>)] [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            この型は <code class="literal">INT</code> のシノニムです。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661465271952"></a> <a class="indexterm" name="idm45661465270480"></a> <a class="indexterm" name="idm45661465268560"></a> <code class="literal">BIGINT[(<em class="replaceable"><code>M</code></em>)] [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            大きい整数。 符号付きの範囲は <code class="literal">-9223372036854775808</code> から <code class="literal">9223372036854775807</code> です。 符号なしの範囲は <code class="literal">0</code> から <code class="literal">18446744073709551615</code> です。 
          </p><p>
            <code class="literal">SERIAL</code> は <code class="literal">BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE</code> のエイリアスです。
          </p><p>
            <code class="literal">BIGINT</code> カラムについて注意の必要な点は、次のとおりです。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <a class="indexterm" name="idm45661465257488"></a> すべての演算は符号付きの <code class="literal">BIGINT</code> 値または <code class="literal">DOUBLE</code> 値を使用して行われるため、ビット関数を使用しないかぎり、<code class="literal">9223372036854775807</code> (63 ビット) よりも大きい符号なしの整数を使用しないでください。 そのようにした場合、<code class="literal">BIGINT</code> 値から <code class="literal">DOUBLE</code> 値への変換時に、丸め誤差のために結果の最後の数桁に誤差が生じる可能性があります。 
              </p><p>
                MySQL は、次の場合に、<code class="literal">BIGINT</code> を扱うことができます。
              </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                    符号なしの大きな値を <code class="literal">BIGINT</code> カラムに格納するために整数を使用するとき。
                  </p></li><li class="listitem"><p>
                    <code class="literal">MIN(<em class="replaceable"><code>col_name</code></em>)</code> または <code class="literal">MAX(<em class="replaceable"><code>col_name</code></em>)</code> 内。ここで <em class="replaceable"><code>col_name</code></em> は <code class="literal">BIGINT</code> カラムを指します。
                  </p></li><li class="listitem"><p>
                    演算子 (<code class="literal">+</code>、<code class="literal">-</code>、<code class="literal">*</code> など) を使用する場合。ここで両方のオペランドは整数です。
                  </p></li></ul></div></li><li class="listitem"><p>
                文字列を使用して格納すると、いつでも正確な整数値を <code class="literal">BIGINT</code> カラムに格納できます。 この場合、MySQL は、中間倍精度表現を含まない文字列から数値に変換します。 
              </p></li><li class="listitem"><p>
                両方のオペランドが整数値の場合、<code class="literal">-</code>、<code class="literal">+</code>、および <code class="literal">*</code> の演算子は、<code class="literal">BIGINT</code> 演算を使用します。 これは、2 つの大きい整数 (または整数を返す関数からの結果) を掛け合わした場合、その結果が <code class="literal">9223372036854775807</code> より大きいときには、予期しない結果になるということを意味します。 
              </p></li></ul></div></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661465224880"></a> <a class="indexterm" name="idm45661465223392"></a> <code class="literal">DECIMAL[(<em class="replaceable"><code>M</code></em>[,<em class="replaceable"><code>D</code></em>])] [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            パックされた<span class="quote">「<span class="quote">正確な</span>」</span>固定小数点数。 <em class="replaceable"><code>M</code></em> は桁数の合計 (精度) で、<em class="replaceable"><code>D</code></em> は小数点以下の桁数 (スケール) です。 小数点と、負の数に対する<code class="literal">-</code>の記号は <em class="replaceable"><code>M</code></em> にはカウントされません。 <em class="replaceable"><code>D</code></em> が 0 のときは、小数点や小数部はありません。 <code class="literal">DECIMAL</code> の最大桁数 (<em class="replaceable"><code>M</code></em>) は 65 です。 サポートされる小数部の最大桁数 (<em class="replaceable"><code>D</code></em>) は 30 です。 <em class="replaceable"><code>D</code></em> が省略された場合のデフォルトは 0 です。 <em class="replaceable"><code>M</code></em> が省略された場合のデフォルトは 10 です。 (<code class="literal">DECIMAL</code> リテラルのテキストの長さには制限もあります。<a class="xref" href="functions.html#precision-math-expressions" title="12.25.3 式の処理">セクション12.25.3「式の処理」</a> を参照してください。) 
          </p><p>
            <code class="literal">UNSIGNED</code> が指定されている場合、負の値は許可されません。 MySQL 8.0.17 では、<code class="literal">DECIMAL</code> 型のカラム (およびシノニム) の <code class="literal">UNSIGNED</code> 属性は非推奨になりました。将来のバージョンの MySQL ではサポートされなくなる予定です。 このようなカラムには、かわりに単純な <code class="literal">CHECK</code> 制約の使用を検討してください。 
          </p><p>
            <code class="literal">DECIMAL</code> カラムを使用したすべての基本的な計算 (<code class="literal">+, -, *, /</code>) は、65 桁の精度で行われます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661465201120"></a> <a class="indexterm" name="idm45661465199648"></a> <a class="indexterm" name="idm45661465198272"></a> <a class="indexterm" name="idm45661465196912"></a> <a class="indexterm" name="idm45661465195056"></a> <a class="indexterm" name="idm45661465193024"></a> <code class="literal">DEC[(<em class="replaceable"><code>M</code></em>[,<em class="replaceable"><code>D</code></em>])] [UNSIGNED] [ZEROFILL]</code>, <code class="literal">NUMERIC[(<em class="replaceable"><code>M</code></em>[,<em class="replaceable"><code>D</code></em>])] [UNSIGNED] [ZEROFILL]</code>, <code class="literal">FIXED[(<em class="replaceable"><code>M</code></em>[,<em class="replaceable"><code>D</code></em>])] [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            これらの型は <code class="literal">DECIMAL</code> のシノニムです。 <code class="literal">FIXED</code> シノニムは、ほかのデータベースシステムとの互換性のために使用できます。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661465179680"></a> <a class="indexterm" name="idm45661465178208"></a> <code class="literal">FLOAT[(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)] [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            小さい (単精度) 浮動小数点数。 許可される値は、<code class="literal">-3.402823466E+38</code> から <code class="literal">-1.175494351E-38</code>、<code class="literal">0</code>、および <code class="literal">1.175494351E-38</code> から <code class="literal">3.402823466E+38</code> です。 これらは、IEEE スタンダードに基づいた理論的な限度です。 使用しているハードウェアまたはオペレーティングシステムによっては、実際の範囲は少し小さくなる場合があります。 
          </p><p>
            <em class="replaceable"><code>M</code></em> は桁数の合計で、<em class="replaceable"><code>D</code></em> は小数点以下の桁数です。 <em class="replaceable"><code>M</code></em> と <em class="replaceable"><code>D</code></em> を省略した場合、値はハードウェアで許可された限度まで格納されます。 単精度小数点数はおおよそ小数第 7 位まで正確です。 
          </p><p>
            <code class="literal">FLOAT(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code> は、非標準の MySQL 拡張機能です。 MySQL 8.0.17 では、この構文は非推奨であり、将来のバージョンの MySQL ではサポートされなくなる予定です。 
          </p><p>
            <code class="literal">UNSIGNED</code> が指定されている場合、負の値は許可されません。 MySQL 8.0.17 では、<code class="literal">FLOAT</code> 型のカラム (およびシノニム) の <code class="literal">UNSIGNED</code> 属性は非推奨になっており、将来のバージョンの MySQL ではサポートされなくなる予定です。 このようなカラムには、かわりに単純な <code class="literal">CHECK</code> 制約の使用を検討してください。 
          </p><p>
            MySQL ではすべての計算が倍精度で行われているので、<code class="literal">FLOAT</code> を使用すると、予想外の問題が起きることがあります。 <a class="xref" href="error-handling.html#no-matching-rows" title="B.3.4.7 一致する行がない場合の問題の解決">セクションB.3.4.7「一致する行がない場合の問題の解決」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661465156992"></a> <a class="indexterm" name="idm45661465155520"></a> <a class="indexterm" name="idm45661465154160"></a> <code class="literal">FLOAT(<em class="replaceable"><code>p</code></em>) [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            浮動小数点数です。<em class="replaceable"><code>p</code></em> は精度をビットで表現しますが、MySQL は、結果として得られるデータ型に対して <code class="literal">FLOAT</code> または <code class="literal">DOUBLE</code> のどちらを使用するかを決めるためだけにこの値を使用します。 <em class="replaceable"><code>p</code></em> が 0 から 24 のとき、そのデータ型は <em class="replaceable"><code>M</code></em> 値も <em class="replaceable"><code>D</code></em> 値もない <code class="literal">FLOAT</code> になります。 <em class="replaceable"><code>p</code></em> が 25 から 53 のとき、そのデータ型は <em class="replaceable"><code>M</code></em> 値も <em class="replaceable"><code>D</code></em> 値もない <code class="literal">DOUBLE</code> になります。 結果となるカラムの範囲は、このセクションで前述した単精度 <code class="literal">FLOAT</code> または倍精度 <code class="literal">DOUBLE</code> データ型の場合と同じです。 
          </p><p>
            <code class="literal">UNSIGNED</code> が指定されている場合、負の値は許可されません。 MySQL 8.0.17 では、<code class="literal">FLOAT</code> 型のカラム (およびシノニム) の <code class="literal">UNSIGNED</code> 属性は非推奨になっており、将来のバージョンの MySQL ではサポートされなくなる予定です。 このようなカラムには、かわりに単純な <code class="literal">CHECK</code> 制約の使用を検討してください。 
          </p><p>
            <a class="indexterm" name="idm45661465135968"></a> <a class="indexterm" name="idm45661465134464"></a> <code class="literal">FLOAT(<em class="replaceable"><code>p</code></em>)</code> 構文は ODBC との互換性を確保するために用意されています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661465128176"></a> <a class="indexterm" name="idm45661465126704"></a> <a class="indexterm" name="idm45661465125344"></a> <a class="indexterm" name="idm45661465123424"></a> <code class="literal">DOUBLE[(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)] [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            普通サイズ (倍精度) の浮動小数点数。 許可されている値は、<code class="literal">-1.7976931348623157E+308</code> から <code class="literal">-2.2250738585072014E-308</code>、<code class="literal">0</code>、および <code class="literal">2.2250738585072014E-308</code> から <code class="literal">1.7976931348623157E+308</code> です。 これらは、IEEE スタンダードに基づいた理論的な限度です。 使用しているハードウェアまたはオペレーティングシステムによっては、実際の範囲は少し小さくなる場合があります。 
          </p><p>
            <em class="replaceable"><code>M</code></em> は桁数の合計で、<em class="replaceable"><code>D</code></em> は小数点以下の桁数です。 <em class="replaceable"><code>M</code></em> と <em class="replaceable"><code>D</code></em> を省略した場合、値はハードウェアで許可された限度まで格納されます。 倍精度小数点数はおおよそ小数第 15 位まで正確です。 
          </p><p>
            <code class="literal">DOUBLE(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code> は、非標準の MySQL 拡張機能です。 MySQL 8.0.17 では、この構文は非推奨であり、将来のバージョンの MySQL ではサポートされなくなる予定です。 
          </p><p>
            <code class="literal">UNSIGNED</code> が指定されている場合、負の値は許可されません。 MySQL 8.0.17 では、<code class="literal">DOUBLE</code> 型のカラム (およびシノニム) の <code class="literal">UNSIGNED</code> 属性は非推奨になっており、将来のバージョンの MySQL ではサポートされなくなる予定です。 このようなカラムには、かわりに単純な <code class="literal">CHECK</code> 制約の使用を検討してください。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661465103296"></a> <a class="indexterm" name="idm45661465101776"></a> <a class="indexterm" name="idm45661465100416"></a> <a class="indexterm" name="idm45661465098496"></a> <code class="literal">DOUBLE PRECISION[(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)] [UNSIGNED] [ZEROFILL]</code>, <code class="literal">REAL[(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)] [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            これらの型は <code class="literal">DOUBLE</code> のシノニムです。 例外: <code class="literal">REAL_AS_FLOAT</code> SQL モードが有効な場合は、<code class="literal">DOUBLE</code> ではなく <code class="literal">REAL</code> が <code class="literal">FLOAT</code> のシノニムになります。 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="integer-types"></a>11.1.2 整数型 (真数値) - INTEGER、INT、SMALLINT、TINYINT、MEDIUMINT、BIGINT</h3></div></div></div><p>
        MySQL では、<code class="literal">INTEGER</code> (または <code class="literal">INT</code>) および <code class="literal">SMALLINT</code> の SQL 標準整数型をサポートします。 標準に対する拡張として、MySQL では、<code class="literal">TINYINT</code>、<code class="literal">MEDIUMINT</code>、および <code class="literal">BIGINT</code> の整数型もサポートします。 次の表に、整数型ごとの必要なストレージと範囲を示します。 
      </p><div class="table"><a name="integer-type-storage-and-range"></a><p class="title"><b>表 11.1 MySQL でサポートされる整数型に必要な記憶域および範囲</b></p><div class="table-contents"><table summary="Required storage and range for integer types supported by MySQL. Information includes the integer type, the storage size in bytes, the minimum signed and unsigned values, and the maximum signed and unsigned values."><col style="width: 16%"><col style="width: 16%"><col style="width: 16%"><col style="width: 16%"><col style="width: 16%"><col style="width: 16%"><thead><tr>
            <th scope="col">型</th>
            <th scope="col">記憶域 (バイト)</th>
            <th scope="col">署名済最小値</th>
            <th scope="col">最小未署名値</th>
            <th scope="col">署名された最大値</th>
            <th scope="col">最大未署名値</th>
          </tr></thead><tbody><tr>
            <th scope="row"><code class="literal">TINYINT</code></th>
            <td>1</td>
            <td><code class="literal">-128</code></td>
            <td><code class="literal">0</code></td>
            <td><code class="literal">127</code></td>
            <td><code class="literal">255</code></td>
          </tr><tr>
            <th scope="row"><code class="literal">SMALLINT</code></th>
            <td>2</td>
            <td><code class="literal">-32768</code></td>
            <td><code class="literal">0</code></td>
            <td><code class="literal">32767</code></td>
            <td><code class="literal">65535</code></td>
          </tr><tr>
            <th scope="row"><code class="literal">MEDIUMINT</code></th>
            <td>3</td>
            <td><code class="literal">-8388608</code></td>
            <td><code class="literal">0</code></td>
            <td><code class="literal">8388607</code></td>
            <td><code class="literal">16777215</code></td>
          </tr><tr>
            <th scope="row"><code class="literal">INT</code></th>
            <td>4</td>
            <td><code class="literal">-2147483648</code></td>
            <td><code class="literal">0</code></td>
            <td><code class="literal">2147483647</code></td>
            <td><code class="literal">4294967295</code></td>
          </tr><tr>
            <th scope="row"><code class="literal">BIGINT</code></th>
            <td>8</td>
            <td><code class="literal">-2<sup>63</sup></code></td>
            <td><code class="literal">0</code></td>
            <td><code class="literal">2<sup>63</sup>-1</code></td>
            <td><code class="literal">2<sup>64</sup>-1</code></td>
          </tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="fixed-point-types"></a>11.1.3 固定小数点型 (真数値) - DECIMAL、NUMERIC</h3></div></div></div><p>
        <code class="literal">DECIMAL</code> および <code class="literal">NUMERIC</code> 型は真数値データ値を格納します。 これらの型は、金銭データを扱う場合など、正確な精度を保持することが重要な場合に使用されます。 MySQL では、<code class="literal">NUMERIC</code> は <code class="literal">DECIMAL</code> として実装されるので、<code class="literal">DECIMAL</code> に関する次の注意事項が <code class="literal">NUMERIC</code> にも同様に適用されます。 
      </p><p>
        MySQL は、<code class="literal">DECIMAL</code> 値をバイナリ形式で格納します。 <a class="xref" href="functions.html#precision-math" title="12.25 高精度計算">セクション12.25「高精度計算」</a>を参照してください。 
      </p><p>
        <code class="literal">DECIMAL</code> のカラム宣言では、精度とスケールを指定できます (通常は指定します)。 例: 
      </p><pre class="programlisting">salary DECIMAL(5,2)
</pre><p>
        この例では、<code class="literal">5</code> が精度で、<code class="literal">2</code> がスケールです。 精度は、その値に格納された有効な桁数を表し、スケールは小数点以下に格納できる桁数を表しています。 
      </p><p>
        標準 SQL では、<code class="literal">DECIMAL(5,2)</code> には小数部が 2 桁の合計 5 桁の値を格納できる必要があるので、<code class="literal">salary</code> カラムに格納できる値は、<code class="literal">-999.99</code> から <code class="literal">999.99</code> の範囲になります。
      </p><p>
        標準 SQL では、構文 <code class="literal">DECIMAL(<em class="replaceable"><code>M</code></em>)</code> は、<code class="literal">DECIMAL(<em class="replaceable"><code>M</code></em>,0)</code> と同等です。 同様に、構文 <code class="literal">DECIMAL</code> は <code class="literal">DECIMAL(<em class="replaceable"><code>M</code></em>,0)</code> と同等です。<em class="replaceable"><code>M</code></em> の値を決定するために、実装は許可されています。 MySQL は、<code class="literal">DECIMAL</code> 構文のこれらのバリアント形式をどちらもサポートします。 <em class="replaceable"><code>M</code></em> のデフォルト値は 10 です。 
      </p><p>
        スケールが 0 の場合、<code class="literal">DECIMAL</code> 値には小数点も小数部も含まれません。
      </p><p>
        <code class="literal">DECIMAL</code> の最大桁数は 65 ですが、指定した <code class="literal">DECIMAL</code> カラムの実際の範囲は、その指定したカラムの精度またはスケールによって制約される場合があります。 指定のスケールで許可されている数より多くの桁が小数点以下にある値が、このようなカラムに割り当てられた場合、値はそのスケールに変換されます。 (正確な動作はオペレーティングシステム固有ですが、一般的には効果は許可されている桁数に切り捨てられます。) 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="floating-point-types"></a>11.1.4 浮動小数点型 (概数値) - FLOAT、DOUBLE</h3></div></div></div><p>
        <code class="literal">FLOAT</code> および <code class="literal">DOUBLE</code> 型は概数値データ値を表します。 MySQL は、単精度値には 4 バイトを、倍精度値には 8 バイトを使用します。 
      </p><p>
        <code class="literal">FLOAT</code> の場合、SQL 標準では、カッコで囲まれたキーワード <code class="literal">FLOAT</code> の後のビット単位の精度 (指数の範囲ではない) をオプションで指定できます。つまり、<code class="literal">FLOAT(<em class="replaceable"><code>p</code></em>)</code> です。 MySQL では、このオプションの精度指定もサポートされていますが、<code class="literal">FLOAT(<em class="replaceable"><code>p</code></em>)</code> の精度値は記憶域サイズの決定にのみ使用されます。 0 から 23 の精度は、4 バイト単精度の <code class="literal">FLOAT</code> カラムになります。 24 から 53 の精度は、8 バイト倍精度の <code class="literal">DOUBLE</code> カラムになります。 
      </p><p>
        MySQL は、<code class="literal">FLOAT(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code> または <code class="literal">REAL(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code> または <code class="literal">DOUBLE PRECISION(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code> の非標準の構文を許可します。 ここで、<code class="literal">(<em class="replaceable"><code>M</code></em>、<em class="replaceable"><code>D</code></em>)</code> は、値は合計で <em class="replaceable"><code>M</code></em> 桁まで格納でき、そのうちの <em class="replaceable"><code>D</code></em> 桁は小数点以下です。 たとえば、<code class="literal">FLOAT(7,4)</code> として定義されたカラムは、<code class="literal">-999.9999</code> として表示されます。 MySQL は、値を格納するときに丸めを行うので、<code class="literal">FLOAT(7,4)</code> カラムに <code class="literal">999.00009</code> を挿入すると、近似の結果は <code class="literal">999.0001</code> になります。 
      </p><p>
        MySQL 8.0.17 では、非標準の <code class="literal">FLOAT(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code> および <code class="literal">DOUBLE(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code> 構文は非推奨であり、将来のバージョンの MySQL ではサポートされなくなる予定です。
      </p><p>
        浮動小数点値は概数値であり、真数値としては格納されないので、比較で値を真数値として扱おうとすると、問題が発生することがあります。 これらはまた、プラットフォームまたは実装の依存関係にも従います。 詳細は、<a class="xref" href="error-handling.html#problems-with-float" title="B.3.4.8 浮動小数点値に関する問題">セクションB.3.4.8「浮動小数点値に関する問題」</a>を参照してください。 
      </p><p>
        移植性を最大にするために、概数値データ値のストレージを必要とするコードでは、精度または桁数が指定されていない <code class="literal">FLOAT</code> または <code class="literal">DOUBLE PRECISION</code> を使用する必要があります。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="bit-type"></a>11.1.5 ビット値型 - BIT</h3></div></div></div><p>
        <code class="literal">BIT</code> データ型は、ビット値の格納に使用されます。 <code class="literal">BIT(<em class="replaceable"><code>M</code></em>)</code> の型は、<em class="replaceable"><code>M</code></em> ビット値のストレージを有効にします。 <em class="replaceable"><code>M</code></em> の範囲は 1 から 64 までが可能です。 
      </p><p>
        ビット値を指定するには、<code class="literal">b'<em class="replaceable"><code>value</code></em>'</code> 表記を使用できます。<em class="replaceable"><code>value</code></em> は、0 と 1 で書かれたバイナリ値です。 たとえば、<code class="literal">b'111'</code> と <code class="literal">b'10000000'</code> はそれぞれ 7 と 128 を表しています。 <a class="xref" href="language-structure.html#bit-value-literals" title="9.1.5 ビット値リテラル">セクション9.1.5「ビット値リテラル」</a>を参照してください。 
      </p><p>
        <em class="replaceable"><code>M</code></em> ビット長よりも短い <code class="literal">BIT(<em class="replaceable"><code>M</code></em>)</code> カラムに値を割り当てた場合、その値の左側はゼロで埋められます。 たとえば、<code class="literal">b'101'</code> という値を <code class="literal">BIT(6)</code> カラムに割り当てると、実際には <code class="literal">b'000101'</code> を割り当てた場合と同じことになります。 
      </p><p><b>NDB Cluster. </b>
          特定の <code class="literal">NDB</code> テーブルで使用されるすべての <code class="literal">BIT</code> カラムの最大合計サイズは 4096 ビットを超えることはできません。
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="numeric-type-attributes"></a>11.1.6 数値型の属性</h3></div></div></div><a class="indexterm" name="idm45661464950160"></a><a class="indexterm" name="idm45661464948816"></a><a class="indexterm" name="idm45661464947472"></a><p>
        MySQL では、整数データ型の基本キーワードに続く括弧内で、その型の表示幅をオプションで指定する拡張をサポートしています。 たとえば、<code class="literal">INT(4)</code> は、4 桁の表示幅の <code class="literal">INT</code> を指定しています。 このオプションの表示幅は、左側をスペースでパディングすることによって、カラムに対して指定された幅よりも狭く整数値を表示するために、アプリケーションで使用される場合があります。 (つまり、この幅は結果セットで返されるメタデータの中にあります。 使用されるかどうかはアプリケーションによって決まります。) 
      </p><p>
        表示幅は、カラムに格納できない値の範囲を制約<span class="emphasis"><em>しません</em></span>。 カラムの表示幅より広い値が正しく表示されなくなることもありません。 たとえば、<code class="literal">SMALLINT(3)</code> として指定されたカラムには、<code class="literal">-32768</code> から <code class="literal">32767</code> の通常の <code class="literal">SMALLINT</code> 範囲があり、3 桁が許可されたこの範囲外の値は、4 桁以上を使用してすべて表示されます。 
      </p><p>
        オプションの (非標準の) <code class="literal">ZEROFILL</code> 属性とともに使用すると、空白のデフォルトの埋込みがゼロに置き換えられます。 たとえば、<code class="literal">INT(4) ZEROFILL</code> として宣言されたカラムの場合、<code class="literal">5</code> の値は <code class="literal">0005</code> として取得されます。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          式または <code class="literal">UNION</code> クエリーに含まれるカラムでは、<code class="literal">ZEROFILL</code> 属性は無視されます。
        </p><p>
          <code class="literal">ZEROFILL</code> 属性を持つ整数カラムに表示幅より大きな値を格納した場合、MySQL が一部の複雑な結合に対して一時テーブルを生成するときに問題が発生することがあります。 これらの場合、MySQL は、カラムの表示幅内でデータ値が適合すると想定します。 
        </p></div><p>
        MySQL 8.0.17 では、整数データ型の表示幅属性と同様に、数値データ型の <code class="literal">ZEROFILL</code> 属性は非推奨になりました。 <code class="literal">ZEROFILL</code> のサポートおよび整数データ型の表示幅は、将来のバージョンの MySQL で削除される予定です。 これらの属性の効果を生成する別の方法の使用を検討してください。 たとえば、アプリケーションでは、<code class="literal">LPAD()</code> 関数を使用して、必要な幅まで数値をゼロ埋めしたり、書式設定された数値を <code class="literal">CHAR</code> カラムに格納したりできます。 
      </p><p>
        すべての整数型は、オプション (非標準) の <code class="literal">UNSIGNED</code> 属性を持つことができます。 符号なし型を使用すると、カラムに負でない数値のみを許可したり、カラムの上限の数値範囲を大きくする必要がある場合に使用できます。 たとえば、<code class="literal">INT</code> カラムが <code class="literal">UNSIGNED</code> の場合、カラム範囲のサイズは同じですが、そのエンドポイントは <code class="literal">-2147483648</code> および <code class="literal">2147483647</code> から <code class="literal">0</code> および <code class="literal">4294967295</code> にシフトします。 
      </p><p>
        浮動小数点と固定小数点も <code class="literal">UNSIGNED</code> になり得ます。 整数型と同じように、この属性は負の値がカラムに格納されるのを防ぎます。 整数型とは異なり、カラム値の上限範囲は変わりません。 MySQL 8.0.17 では、<code class="literal">FLOAT</code>、<code class="literal">DOUBLE</code> および <code class="literal">DECIMAL</code>(およびすべてのシノニム) タイプのカラムに対して <code class="literal">UNSIGNED</code> 属性は非推奨であり、将来のバージョンの MySQL でサポートされなくなる予定です。 このようなカラムには、かわりに単純な <code class="literal">CHECK</code> 制約の使用を検討してください。 
      </p><p>
        数値カラムに <code class="literal">ZEROFILL</code> を指定すると、MySQL によって <code class="literal">UNSIGNED</code> 属性が自動的に追加されます。
      </p><p>
        整数または浮動小数点データ型は、<code class="literal">AUTO_INCREMENT</code> 属性を持つことができます。 インデックス付けされた <code class="literal">AUTO_INCREMENT</code> カラムに <code class="literal">NULL</code> の値を挿入すると、そのカラムは次の順序値に設定されます。 通常、これは <code class="literal"><em class="replaceable"><code>value</code></em>+1</code> です。ここで <em class="replaceable"><code>value</code></em> は現在テーブルにあるカラムの最大値です。 (<code class="literal">AUTO_INCREMENT</code> の順序は <code class="literal">1</code> で始まります。) 
      </p><p>
        <code class="literal">AUTO_INCREMENT</code> カラムへの <code class="literal">0</code> の格納は、<code class="literal">NO_AUTO_VALUE_ON_ZERO</code> SQL モードが有効になっていないかぎり、<code class="literal">NULL</code> の格納と同じ効果があります。
      </p><p>
        <code class="literal">AUTO_INCREMENT</code> 値を生成するために <code class="literal">NULL</code> を挿入する場合、カラムを <code class="literal">NOT NULL</code> と宣言する必要があります。 カラムが <code class="literal">NULL</code> として宣言されている場合、<code class="literal">NULL</code> を挿入すると <code class="literal">NULL</code> が格納されます。 他の値を <code class="literal">AUTO_INCREMENT</code> カラムに挿入すると、カラムはその値に設定され、次に自動的に生成される値が挿入された値から順番に続くように順序がリセットされます。 
      </p><p>
        <code class="literal">AUTO_INCREMENT</code> カラムの負の値はサポートされていません。
      </p><p>
        <code class="literal">CHECK</code> 制約は、<code class="literal">AUTO_INCREMENT</code> 属性を持つカラムを参照することも、<code class="literal">CHECK</code> 制約で使用される既存のカラムに <code class="literal">AUTO_INCREMENT</code> 属性を追加することもできません。
      </p><p>
        MySQL 8.0.17 では、<code class="literal">FLOAT</code> および <code class="literal">DOUBLE</code> カラムに対する <code class="literal">AUTO_INCREMENT</code> のサポートは非推奨になりました。将来のバージョンの MySQL で削除される予定です。 このようなカラムから <code class="literal">AUTO_INCREMENT</code> 属性を削除するか、整数型に変換することを検討してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="out-of-range-and-overflow"></a>11.1.7 範囲外およびオーバーフローの処理</h3></div></div></div><a class="indexterm" name="idm45661464883008"></a><a class="indexterm" name="idm45661464881584"></a><p>
        MySQL が、カラムデータ型の許可できる範囲外にある数値カラムに値を格納すると、結果は、その時点で有効な SQL モードによって異なります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            厳密な SQL モードが有効な場合、SQL 標準に従って、MySQL は範囲外の値を拒否してエラーを表示し、挿入は失敗します。
          </p></li><li class="listitem"><p>
            制限モードが有効になっていない場合、MySQL はカラムのデータ型範囲の適切なエンドポイントに値をクリップし、かわりに結果の値を格納します。
          </p><p>
            範囲外の値が整数カラムに割り当てられると、MySQL は、カラムデータ型の範囲の対応する終点を表す値を格納します。
          </p><p>
            浮動小数点または固定小数点カラムに、指定された (またはデフォルトの) 精度とスケールによって暗示された範囲を超えた値が割り当てられると、MySQL はその範囲の対応する終点を表す値を格納します。
          </p></li></ul></div><p>
        テーブル <code class="literal">t1</code> に次の定義があるとします。
      </p><pre class="programlisting">CREATE TABLE t1 (i1 TINYINT, i2 TINYINT UNSIGNED);
</pre><p>
        厳密な SQL モードを有効にすると、範囲外エラーが発生します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET sql_mode = 'TRADITIONAL';</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t1 (i1, i2) VALUES(256, 256);</code></strong>
ERROR 1264 (22003): Out of range value for column 'i1' at row 1
mysql&gt; <strong class="userinput"><code>SELECT * FROM t1;</code></strong>
Empty set (0.00 sec)
</pre><p>
        厳密な SQL モードが有効になっていない場合、警告付きでクリッピングが発生します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET sql_mode = '';</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t1 (i1, i2) VALUES(256, 256);</code></strong>
mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+---------+------+---------------------------------------------+
| Level   | Code | Message                                     |
+---------+------+---------------------------------------------+
| Warning | 1264 | Out of range value for column 'i1' at row 1 |
| Warning | 1264 | Out of range value for column 'i2' at row 1 |
+---------+------+---------------------------------------------+
mysql&gt; <strong class="userinput"><code>SELECT * FROM t1;</code></strong>
+------+------+
| i1   | i2   |
+------+------+
|  127 |  255 |
+------+------+
</pre><p>
        厳密な SQL モードが有効になっていない場合、クリッピングによって発生するカラム割当て変換は、<code class="literal">ALTER TABLE</code>, <code class="literal">LOAD DATA</code>, <code class="literal">UPDATE</code> および複数行の <code class="literal">INSERT</code> ステートメントの警告としてレポートされます。 厳密モードでは、これらのステートメントは失敗し、テーブルがトランザクションテーブルかどうかやその他の要因に応じて、一部またはすべての値が挿入または変更されません。 詳細は、<a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a>を参照してください。 
      </p><p>
        数値式の評価中にオーバーフローすると、エラーが発生します。 たとえば、符号付きの <code class="literal">BIGINT</code> の最大値は 9223372036854775807 なので、次の式ではエラーが発生します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT 9223372036854775807 + 1;</code></strong>
ERROR 1690 (22003): BIGINT value is out of range in '(9223372036854775807 + 1)'
</pre><p>
        この場合に演算を成功させるには、値を符号なしに変換します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT CAST(9223372036854775807 AS UNSIGNED) + 1;</code></strong>
+-------------------------------------------+
| CAST(9223372036854775807 AS UNSIGNED) + 1 |
+-------------------------------------------+
|                       9223372036854775808 |
+-------------------------------------------+
</pre><p>
        オーバーフローが起きるかどうかはオペランドの範囲に応じて異なります。したがって、前述の式を処理するもう 1 つの方法として、<code class="literal">DECIMAL</code> 値に整数より大きな範囲があるので正確な値の演算を使用します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT 9223372036854775807.0 + 1;</code></strong>
+---------------------------+
| 9223372036854775807.0 + 1 |
+---------------------------+
|     9223372036854775808.0 |
+---------------------------+
</pre><p>
        一方が <code class="literal">UNSIGNED</code> 型のときに 2 つの整数値の間で減算を行うと、デフォルトでは符号なしの結果が生成されます。 それ以外の場合は、エラーが発生します: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET sql_mode = '';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT CAST(0 AS UNSIGNED) - 1;</code></strong>
<span class="errortext">ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in '(cast(0 as unsigned) - 1)'</span>
</pre><p>
        <code class="literal">NO_UNSIGNED_SUBTRACTION</code> SQL モードが有効な場合は、結果は負になります。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET sql_mode = 'NO_UNSIGNED_SUBTRACTION';</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT CAST(0 AS UNSIGNED) - 1;</code></strong>
+-------------------------+
| CAST(0 AS UNSIGNED) - 1 |
+-------------------------+
|                      -1 |
+-------------------------+
</pre><p>
        このような演算の結果を使用して <code class="literal">UNSIGNED</code> 整数カラムが更新されると、結果はそのカラム型の最大値に切り落とされます。<code class="literal">NO_UNSIGNED_SUBTRACTION</code> が有効になっている場合は、0 に切り落とされます。 厳密な SQL モードが有効になっている場合は、エラーが発生し、カラムは変わりません。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="date-and-time-types"></a>11.2 日時データ型</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="data-types.html#date-and-time-type-syntax">11.2.1 日時データ型の構文</a></span></dt><dt><span class="section"><a href="data-types.html#datetime">11.2.2 DATE、DATETIME、および TIMESTAMP 型</a></span></dt><dt><span class="section"><a href="data-types.html#time">11.2.3 TIME 型</a></span></dt><dt><span class="section"><a href="data-types.html#year">11.2.4 YEAR 型</a></span></dt><dt><span class="section"><a href="data-types.html#timestamp-initialization">11.2.5 TIMESTAMP および DATETIME の自動初期化および更新機能</a></span></dt><dt><span class="section"><a href="data-types.html#fractional-seconds">11.2.6 時間値での小数秒</a></span></dt><dt><span class="section"><a href="data-types.html#date-and-time-type-conversion">11.2.7 日付と時間型間での変換</a></span></dt><dt><span class="section"><a href="data-types.html#two-digit-years">11.2.8 日付の 2 桁の年</a></span></dt></dl></div><a class="indexterm" name="idm45661464835200"></a><a class="indexterm" name="idm45661464833056"></a><a class="indexterm" name="idm45661464831024"></a><p>
      時間値を表すための日時データ型は、<code class="literal">DATE</code>, <code class="literal">TIME</code>, <code class="literal">DATETIME</code>, <code class="literal">TIMESTAMP</code> および <code class="literal">YEAR</code> です。 それぞれの時間型には、一定範囲の有効な値のほかに、MySQL では表すことのできない無効な値の指定時に使用できる<span class="quote">「<span class="quote">ゼロ</span>」</span>値があります。 <code class="literal">TIMESTAMP</code> および <code class="literal">DATETIME</code> タイプには、<a class="xref" href="data-types.html#timestamp-initialization" title="11.2.5 TIMESTAMP および DATETIME の自動初期化および更新機能">セクション11.2.5「TIMESTAMP および DATETIME の自動初期化および更新機能」</a> で説明されている特別な自動更新動作があります。 
    </p><p>
      時間データ型の記憶域要件の詳細は、<a class="xref" href="data-types.html#storage-requirements" title="11.7 データ型のストレージ要件">セクション11.7「データ型のストレージ要件」</a> を参照してください。
    </p><p>
      時間値を演算する関数の説明については、<a class="xref" href="functions.html#date-and-time-functions" title="12.7 日付および時間関数">セクション12.7「日付および時間関数」</a>を参照してください。
    </p><p>
      日付と時間型を処理するときに、次の考慮事項に留意してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          MySQL は、標準出力形式で所定の日付または時間型の値を取得しますが、(たとえば、日付または時間型に割り当てたり、比較したりする値を指定するときに) 入力した入力値に対してさまざまな形式を解釈しようとします。 日付と時間型に許可されている形式の説明については、<a class="xref" href="language-structure.html#date-and-time-literals" title="9.1.3 日付リテラルと時間リテラル">セクション9.1.3「日付リテラルと時間リテラル」</a>を参照してください。 有効な値を入力する必要があります。 ほかの形式で値を使用すると、予期しない結果が生じることがあります。 
        </p></li><li class="listitem"><p>
          MySQL は、複数の形式で値を解釈しようとしますが、日付の部分は、ほかでは一般的に使用される月-日-年や日-月-年の順 (<code class="literal">'09-04-98'</code> や <code class="literal">'04-09-98'</code> など) ではなく、年-月-日の順 (<code class="literal">'98-09-04'</code> など) で常に指定する必要があります。 他の順序の文字列を年 - 月 - 日の順序に変換するには、<code class="literal">STR_TO_DATE()</code> 関数が役立つ場合があります。 
        </p></li><li class="listitem"><p>
          世紀が不明であるため、2 桁の年の値を含む日付はあいまいです。 MySQL は、次のルールを使用して 2 桁の年の値を解釈します: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">70-99</code> の範囲内の年の値は <code class="literal">1970-1999</code> になります。
            </p></li><li class="listitem"><p>
              <code class="literal">00-69</code> の範囲内の年の値は <code class="literal">2000-2069</code> になります。
            </p></li></ul></div><p>
          <a class="xref" href="data-types.html#two-digit-years" title="11.2.8 日付の 2 桁の年">セクション11.2.8「日付の 2 桁の年」</a>も参照してください。
        </p></li><li class="listitem"><p>
          ある時間型から別の時間型への値の変換は、<a class="xref" href="data-types.html#date-and-time-type-conversion" title="11.2.7 日付と時間型間での変換">セクション11.2.7「日付と時間型間での変換」</a>でのルールに従って行われます。
        </p></li><li class="listitem"><p>
          値が数値コンテキストで使用されている場合、MySQL は日付または時間の値を数値に自動的に変換します。逆の場合も同様です。
        </p></li><li class="listitem"><p>
          デフォルトで MySQL は、日付または時間型の値で、範囲外であるか、それ以外で型にとって無効である値を見つけた場合、値をその型の<span class="quote">「<span class="quote">ゼロ</span>」</span>値に変換します。 その例外では、範囲外の <code class="literal">TIME</code> 値は <code class="literal">TIME</code> 範囲の適切な終点に切り落とされます。 
        </p></li><li class="listitem"><p>
          SQL モードを適切な値に設定することで、MySQL がサポートする日付の種類をより正確に指定できます。 (<a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a>を参照してください。) <code class="literal">ALLOW_INVALID_DATES</code> SQL モードを有効にすることによって、<code class="literal">'2009-11-31'</code> などの特定の日付を MySQL に受け入れさせることができます。 これは、ユーザーが今後の処理のために、(たとえば Web フォームで) 指定した<span class="quote">「<span class="quote">間違っている可能性のある</span>」</span>値をデータベースに格納するときに役立ちます。 このモードでは、MySQL は、月が 1 から 12 までの範囲にあることと、日付が 1 から 31 までの範囲にあることのみ検証します。 
        </p></li><li class="listitem"><p>
          MySQL では、<code class="literal">DATE</code> または <code class="literal">DATETIME</code> カラムに、日がゼロ、または月および日がゼロである日付の格納を許可しています。 これは、正確な日付がわかっていない可能性のある生年月日を格納する必要があるアプリケーションで役立ちます。 この場合は、単に日付を <code class="literal">'2009-00-00'</code> または <code class="literal">'2009-01-00'</code> として格納します。 ただし、これらのような日付を使用すると、完全な日付を必要とする <code class="literal">DATE_SUB()</code> や <code class="literal">DATE_ADD()</code> などの関数の正しい結果が得られないようにする必要があります。 日付にゼロの月または日の部分を許可しないようにするには、<code class="literal">NO_ZERO_IN_DATE</code> モードを有効にします。 
        </p></li><li class="listitem"><p>
          MySQL では、<span class="quote">「<span class="quote">ダミーの日付</span>」</span>として <code class="literal">'0000-00-00'</code> の<span class="quote">「<span class="quote">ゼロ</span>」</span>の値を格納できます。 場合によっては、これは <code class="literal">NULL</code> 値を使用するよりも便利であり、使用するデータおよびインデックス領域が少なくなることがあります。 <code class="literal">'0000-00-00'</code>を禁止するには、<code class="literal">NO_ZERO_DATE</code> モードを有効にします。 
        </p></li><li class="listitem"><p>
          Connector/ODBC で使用される<span class="quote">「<span class="quote">ゼロ</span>」</span>の日付または時間の値は、ODBC がこのような値を処理できないため、<code class="literal">NULL</code> に自動的に変換されます。
        </p></li></ul></div><p>
      次の表に、それぞれの型の<span class="quote">「<span class="quote">ゼロ</span>」</span>値の形式を示します。 <span class="quote">「<span class="quote">ゼロ</span>」</span>値は特別ですが、表に示されている値を使用して、格納したり、明示的に参照したりできます。 また、より簡単に記述できる <code class="literal">'0'</code> や <code class="literal">0</code> の値を使用してこれを行うこともできます。 日付部分 (<code class="literal">DATE</code>、<code class="literal">DATETIME</code> および <code class="literal">TIMESTAMP</code>) を含む時間型の場合、これらの値を使用すると警告またはエラーが発生する可能性があります。 正確な動作は、厳密および <code class="literal">NO_ZERO_DATE</code> SQL モードが有効になっているかどうかによって異なります。<a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a> を参照してください。 
    </p><div class="informaltable"><table summary="Format of the zero value for temporal data types."><col style="width: 30%"><col style="width: 40%"><thead><tr>
          <th>データ型</th>
          <th><span class="quote">「<span class="quote">ゼロ</span>」</span>値</th>
        </tr></thead><tbody><tr>
          <td><code class="literal">DATE</code></td>
          <td><code class="literal">'0000-00-00'</code></td>
        </tr><tr>
          <td><code class="literal">TIME</code></td>
          <td><code class="literal">'00:00:00'</code></td>
        </tr><tr>
          <td><code class="literal">DATETIME</code></td>
          <td><code class="literal">'0000-00-00 00:00:00'</code></td>
        </tr><tr>
          <td><code class="literal">TIMESTAMP</code></td>
          <td><code class="literal">'0000-00-00 00:00:00'</code></td>
        </tr><tr>
          <td><code class="literal">YEAR</code></td>
          <td><code class="literal">0000</code></td>
        </tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="date-and-time-type-syntax"></a>11.2.1 日時データ型の構文</h3></div></div></div><p>
        時間値を表すための日時データ型は、<code class="literal">DATE</code>, <code class="literal">TIME</code>, <code class="literal">DATETIME</code>, <code class="literal">TIMESTAMP</code> および <code class="literal">YEAR</code> です。
      </p><p>
        <code class="literal">DATE</code> および <code class="literal">DATETIME</code> 範囲の説明では、<span class="quote">「<span class="quote">サポートされている</span>」</span>とは、以前の値は機能するが、保証はないことを意味します。
      </p><a class="indexterm" name="idm45661464736192"></a><a class="indexterm" name="idm45661464734720"></a><p>
        MySQL では、マイクロ秒 (6 桁) までの精度で、<code class="literal">TIME</code>、<code class="literal">DATETIME</code> および <code class="literal">TIMESTAMP</code> の値に小数秒を使用できます。 小数秒部を含むカラムを定義するには、<code class="literal"><em class="replaceable"><code>type_name</code></em>(<em class="replaceable"><code>fsp</code></em>)</code> の構文を使用します。ここで、<em class="replaceable"><code>type_name</code></em> は <code class="literal">TIME</code>、<code class="literal">DATETIME</code>、または <code class="literal">TIMESTAMP</code> であり、<em class="replaceable"><code>fsp</code></em> は小数秒の精度です。 例: 
      </p><pre class="programlisting">CREATE TABLE t1 (t TIME(3), dt DATETIME(6), ts TIMESTAMP(0));
</pre><p>
        <em class="replaceable"><code>fsp</code></em> 値を指定する場合、0 から 6 の範囲にする必要があります。 0 の値は、小数部がないことを表します。 省略した場合、デフォルトの精度は 0 です。 (これは、以前の MySQL バージョンと互換性を保つため、標準 SQL のデフォルトである 6 とは異なっています。) 
      </p><p>
        テーブル内の <code class="literal">TIMESTAMP</code> または <code class="literal">DATETIME</code> カラムには、自動初期化および自動更新プロパティを設定できます。<a class="xref" href="data-types.html#timestamp-initialization" title="11.2.5 TIMESTAMP および DATETIME の自動初期化および更新機能">セクション11.2.5「TIMESTAMP および DATETIME の自動初期化および更新機能」</a> を参照してください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="indexterm" name="idm45661464715136"></a> <a class="indexterm" name="idm45661464713664"></a> <code class="literal">DATE</code>
          </p><p>
            日付です。 サポートしている範囲は <code class="literal">'1000-01-01'</code> から <code class="literal">'9999-12-31'</code> です。 MySQL では、<code class="literal">DATE</code> 値は<code class="literal">'<em class="replaceable"><code>YYYY-MM-DD</code></em>'</code>形式で表示されますが、文字列または数値を使用した <code class="literal">DATE</code> カラムへの値の割当ては許可されます。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661464702896"></a> <a class="indexterm" name="idm45661464701440"></a> <code class="literal">DATETIME[(<em class="replaceable"><code>fsp</code></em>)]</code>
          </p><p>
            日付と時間の組み合わせです。 サポートしている範囲は <code class="literal">'1000-01-01 00:00:00.000000'</code> から <code class="literal">'9999-12-31 23:59:59.999999'</code> です。 MySQL では、<code class="literal">DATETIME</code> 値は<code class="literal">'<em class="replaceable"><code>YYYY-MM-DD hh:mm:ss</code></em>[.<em class="replaceable"><code>fraction</code></em>]'</code>形式で表示されますが、文字列または数値を使用した <code class="literal">DATETIME</code> カラムへの値の割当ては許可されます。 
          </p><p>
            小数秒精度を指定するには、0 から 6 の範囲のオプションの <em class="replaceable"><code>fsp</code></em> 値を指定できます。 0 の値は、小数部がないことを表します。 省略した場合、デフォルトの精度は 0 です。 
          </p><p>
            <a class="xref" href="data-types.html#timestamp-initialization" title="11.2.5 TIMESTAMP および DATETIME の自動初期化および更新機能">セクション11.2.5「TIMESTAMP および DATETIME の自動初期化および更新機能」</a> で説明されているように、<code class="literal">DEFAULT</code> および <code class="literal">ON UPDATE</code> のカラム定義句を使用して、<code class="literal">DATETIME</code> カラムの現在の日時への自動初期化および更新を指定できます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661464683920"></a> <a class="indexterm" name="idm45661464682464"></a> <code class="literal">TIMESTAMP[(<em class="replaceable"><code>fsp</code></em>)]</code>
          </p><a class="indexterm" name="idm45661464679072"></a><p>
            タイムスタンプです。 範囲は <code class="literal">'1970-01-01 00:00:01.000000'</code> UTC から <code class="literal">'2038-01-19 03:14:07.999999'</code> UTC です。 <code class="literal">TIMESTAMP</code> 値は、エポック (<code class="literal">'1970-01-01 00:00:00'</code> UTC) からの秒数として格納されます。 <code class="literal">TIMESTAMP</code> は、<code class="literal">'1970-01-01 00:00:00'</code> という値を表すことはできません。これは、エポックからの秒数が 0 であることと同等で、0 という値は <code class="literal">'0000-00-00 00:00:00'</code>、つまり<span class="quote">「<span class="quote">ゼロ</span>」</span>の <code class="literal">TIMESTAMP</code> 値を表すために予約されているからです。 
          </p><p>
            小数秒精度を指定するには、0 から 6 の範囲のオプションの <em class="replaceable"><code>fsp</code></em> 値を指定できます。 0 の値は、小数部がないことを表します。 省略した場合、デフォルトの精度は 0 です。 
          </p><p>
            サーバーで <code class="literal">TIMESTAMP</code> 定義をどのように扱うかは、<code class="literal">explicit_defaults_for_timestamp</code> システム変数の値によって異なります (<a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>を参照してください)。
          </p><p>
            <code class="literal">explicit_defaults_for_timestamp</code> が有効な場合、すべての <code class="literal">TIMESTAMP</code> カラムへの <code class="literal">DEFAULT CURRENT_TIMESTAMP</code> または <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> 属性の自動的な割り当ては行われません。 これらはカラム定義に明示的に含める必要があります。 また、<code class="literal">NOT NULL</code> として明示的に宣言されていないすべての <code class="literal">TIMESTAMP</code> は、<code class="literal">NULL</code> 値を許可します。 
          </p><p>
            <code class="literal">explicit_defaults_for_timestamp</code> が無効になっている場合、サーバーは次のように <code class="literal">TIMESTAMP</code> を処理します:
          </p><p>
            特に指定されていないかぎり、テーブル内の最初の <code class="literal">TIMESTAMP</code> カラムは、明示的に値が割り当てられていなければもっとも新しい変更の日時に自動的に設定されるように定義されています。 これにより、<code class="literal">TIMESTAMP</code> は、<code class="literal">INSERT</code> または <code class="literal">UPDATE</code> 操作のタイムスタンプの記録に役立ちます。 <code class="literal">NULL</code> 値を許可するように <code class="literal">NULL</code> 属性で定義されていないかぎり、<code class="literal">NULL</code> 値を割り当てることによって、すべての <code class="literal">TIMESTAMP</code> カラムを現在の日付と時間に設定することもできます。 
          </p><p>
            自動初期化および現在の日付と時間への自動更新は、<code class="literal">DEFAULT CURRENT_TIMESTAMP</code> および <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> カラム定義句を使用して指定できます。 デフォルトでは、前述のように最初の <code class="literal">TIMESTAMP</code> カラムにこれらのプロパティーが含まれます。 ただし、テーブル内の <code class="literal">TIMESTAMP</code> カラムは、これらのプロパティを持つように定義できます。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661464640096"></a> <a class="indexterm" name="idm45661464638624"></a> <code class="literal">TIME[(<em class="replaceable"><code>fsp</code></em>)]</code>
          </p><p>
            時間です。 範囲は、<code class="literal">'-838:59:59.000000'</code> から <code class="literal">'838:59:59.000000'</code> です。 MySQL では、<code class="literal">TIME</code> 値は<code class="literal">'<em class="replaceable"><code>hh:mm:ss</code></em>[.<em class="replaceable"><code>fraction</code></em>]'</code>形式で表示されますが、文字列または数値を使用した <code class="literal">TIME</code> カラムへの値の割当ては許可されます。 
          </p><p>
            小数秒精度を指定するには、0 から 6 の範囲のオプションの <em class="replaceable"><code>fsp</code></em> 値を指定できます。 0 の値は、小数部がないことを表します。 省略した場合、デフォルトの精度は 0 です。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661464625792"></a> <a class="indexterm" name="idm45661464624320"></a> <code class="literal">YEAR[(4)]</code>
          </p><p>
            4 桁形式の年。 MySQL では、<code class="literal">YEAR</code> 値は <em class="replaceable"><code>YYYY</code></em> 形式で表示されますが、文字列または数値を使用した <code class="literal">YEAR</code> カラムへの値の割当ては許可されます。 値は、<code class="literal">1901</code> から <code class="literal">2155</code> または <code class="literal">0000</code> として表示されます。 
          </p><p>
            入力値の <code class="literal">YEAR</code> の表示形式および解釈に関する追加情報については、<a class="xref" href="data-types.html#year" title="11.2.4 YEAR 型">セクション11.2.4「YEAR 型」</a>を参照してください。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              MySQL 8.0.19 では、明示的な表示幅を持つ <code class="literal">YEAR(4)</code> データ型は非推奨になりました。将来のバージョンの MySQL ではサポートされなくなる予定です。 かわりに、同じ意味を持つ表示幅を指定せずに <code class="literal">YEAR</code> を使用してください。 
            </p><p>
              MySQL 8.0 では、古いバージョンの MySQL で許可されている 2 桁の <code class="literal">YEAR(2)</code> データ型はサポートされていません。 4 桁の <code class="literal">YEAR</code> に変換する手順は、<a class="ulink" href="https://dev.mysql.com/doc/refman/5.7/en/" target="_top">MySQL 5.7 Reference Manual</a> の <a class="ulink" href="https://dev.mysql.com/doc/refman/5.7/en/migrating-from-year2.html" target="_top">2-Digit YEAR(2) Limitations and Migrating to 4-Digit YEAR</a> を参照してください。 
            </p></div></li></ul></div><p>
        <code class="literal">SUM()</code> および <code class="literal">AVG()</code> 集計関数は時間値を扱いません。 (これらは値を数字に変換するので、最初の数字以外の文字のあとのすべての情報が失われます。) この問題を回避するには、数値単位に変換し、集計操作を実行してから、時間値に戻します。 例: 
      </p><pre class="programlisting">SELECT SEC_TO_TIME(SUM(TIME_TO_SEC(<em class="replaceable"><code>time_col</code></em>))) FROM <em class="replaceable"><code>tbl_name</code></em>;
SELECT FROM_DAYS(SUM(TO_DAYS(<em class="replaceable"><code>date_col</code></em>))) FROM <em class="replaceable"><code>tbl_name</code></em>;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="datetime"></a>11.2.2 DATE、DATETIME、および TIMESTAMP 型</h3></div></div></div><a class="indexterm" name="idm45661464597952"></a><a class="indexterm" name="idm45661464596480"></a><a class="indexterm" name="idm45661464595120"></a><a class="indexterm" name="idm45661464593728"></a><a class="indexterm" name="idm45661464591808"></a><a class="indexterm" name="idm45661464589776"></a><p>
        <code class="literal">DATE</code>、<code class="literal">DATETIME</code>、および <code class="literal">TIMESTAMP</code> 型は関連しています。 このセクションでは、これらの特徴、似ている点、および異なる点について説明します。 MySQL は、<a class="xref" href="language-structure.html#date-and-time-literals" title="9.1.3 日付リテラルと時間リテラル">セクション9.1.3「日付リテラルと時間リテラル」</a>で説明している複数の形式で、<code class="literal">DATE</code>、<code class="literal">DATETIME</code>、および <code class="literal">TIMESTAMP</code> 値を認識します。 <code class="literal">DATE</code> および <code class="literal">DATETIME</code> 範囲の説明では、<span class="quote">「<span class="quote">サポートされている</span>」</span>とは、以前の値は機能するが、保証はないということを意味します。 
      </p><p>
        <code class="literal">DATE</code> 型は、日付部分を含むが時間部分は含まない値に使用されます。 MySQL は、<code class="literal">DATE</code> 値を<code class="literal">'<em class="replaceable"><code>YYYY-MM-DD</code></em>'</code>形式で取得して表示します。 サポートしている範囲は <code class="literal">'1000-01-01'</code> から <code class="literal">'9999-12-31'</code> です。 
      </p><p>
        <code class="literal">DATETIME</code> 型は、日付と時間の両方の部分を含む値に使用されます。 MySQL は、<code class="literal">DATETIME</code> 値を<code class="literal">'<em class="replaceable"><code>YYYY-MM-DD hh:mm:ss</code></em>'</code>形式で取得して表示します。 サポートしている範囲は <code class="literal">'1000-01-01 00:00:00'</code> から <code class="literal">'9999-12-31 23:59:59'</code> です。 
      </p><p>
        <code class="literal">TIMESTAMP</code> データ型は、日付と時間の両方の部分を含む値に使用されます。 <code class="literal">TIMESTAMP</code> には、<code class="literal">'1970-01-01 00:00:01'</code> UTC から <code class="literal">'2038-01-19 03:14:07'</code> UTC の範囲があります。 
      </p><p>
        <code class="literal">DATETIME</code> または <code class="literal">TIMESTAMP</code> 値には、マイクロ秒 (6 桁) までの精度で後続の小数秒部分を含めることができます。 特に、<code class="literal">DATETIME</code> または <code class="literal">TIMESTAMP</code> カラムに挿入された値の小数部は、破棄されるのではなく格納されます。 小数部が含まれている場合、これらの値の書式は<code class="literal">'<em class="replaceable"><code>YYYY-MM-DD hh:mm:ss</code></em>[.<em class="replaceable"><code>fraction</code></em>]'</code>、<code class="literal">DATETIME</code> 値の範囲は<code class="literal">'1000-01-01 00:00:00.000000'</code>から<code class="literal">'9999-12-31 23:59:59.999999'</code>、<code class="literal">TIMESTAMP</code> 値の範囲は<code class="literal">'1970-01-01 00:00:01.000000'</code>から<code class="literal">'2038-01-19 03:14:07.999999'</code>です。 小数部は、常に時間の残りの部分から小数点で区分する必要があります。これ以外の小数秒区切り文字は認識されません。 MySQL の小数秒のサポートの詳細は、<a class="xref" href="data-types.html#fractional-seconds" title="11.2.6 時間値での小数秒">セクション11.2.6「時間値での小数秒」</a>を参照してください。 
      </p><p>
        <code class="literal">TIMESTAMP</code> および <code class="literal">DATETIME</code> データ型は、現在の日時への自動初期化および更新を提供します。 詳細は、<a class="xref" href="data-types.html#timestamp-initialization" title="11.2.5 TIMESTAMP および DATETIME の自動初期化および更新機能">セクション11.2.5「TIMESTAMP および DATETIME の自動初期化および更新機能」</a>を参照してください。 
      </p><p>
        MySQL は、<code class="literal">TIMESTAMP</code> 値を、ストレージでは現在のタイムゾーンを UTC に変換し、取得では UTC から現在のタイムゾーンに戻します。 (<code class="literal">DATETIME</code> などのほかの型ではこれは行われません。) デフォルトでは、接続ごとの現在のタイムゾーンはサーバーの時間です。 タイムゾーンは接続ごとに設定できます。 タイムゾーン設定が一定であるかぎり、格納した値と同じ値に戻すことができます。 <code class="literal">TIMESTAMP</code> 値を格納したあとで、タイムゾーンを変更して値を取り出すと、取り出された値は格納した値とは異なります。 これは、同じタイムゾーンが両方向への変換に使用されなかったために起こります。 現在のタイムゾーンは、<code class="literal">time_zone</code> システム変数の値として使用できます。 詳細は、<a class="xref" href="server-administration.html#time-zone-support" title="5.1.15 MySQL Server でのタイムゾーンのサポート">セクション5.1.15「MySQL Server でのタイムゾーンのサポート」</a>を参照してください。 
      </p><p>
        MySQL 8.0.19 では、<code class="literal">TIMESTAMP</code> および <code class="literal">DATETIME</code> の値をテーブルに挿入するときにタイムゾーンオフセットを指定できます。 オフセットは、内部スペースを使用せずに日時リテラルの時間部分に追加され、<code class="literal">time_zone</code> システム変数の設定に使用されるのと同じ書式を使用しますが、次の例外があります: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            10 未満の時間値の場合、先行するゼロが必要です。
          </p></li><li class="listitem"><p>
            値<code class="literal">'-00:00'</code>は拒否されます。
          </p></li><li class="listitem"><p>
            <code class="literal">'EET'</code>や<code class="literal">'Asia/Shanghai'</code>などのタイムゾーン名は使用できません。このコンテキストでは<code class="literal">'SYSTEM'</code>も使用できません。
          </p></li></ul></div><p>
        挿入される値は、月、日、またはその両方の部分に対してゼロを持つことはできません。 これは、サーバーの SQL モードの設定に関係なく、MySQL 8.0.22 以降で強制されます。 
      </p><p>
        この例では、異なる <code class="literal">time_zone</code> 設定を使用してタイムゾーンオフセットを含む日時値を <code class="literal">TIMESTAMP</code> および <code class="literal">DATETIME</code> カラムに挿入し、それらを取得する方法を示します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE ts (</code></strong>
    -&gt;     <strong class="userinput"><code>id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,</code></strong>
    -&gt;     <strong class="userinput"><code>col TIMESTAMP NOT NULL</code></strong>
    -&gt; <strong class="userinput"><code>) AUTO_INCREMENT = 1;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE dt (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,</code></strong>
    -&gt;     <strong class="userinput"><code>col DATETIME NOT NULL</code></strong>
    -&gt; <strong class="userinput"><code>) AUTO_INCREMENT = 1;</code></strong>

mysql&gt; <strong class="userinput"><code>SET @@time_zone = 'SYSTEM';</code></strong>

mysql&gt; <strong class="userinput"><code>INSERT INTO ts (col) VALUES ('2020-01-01 10:10:10'),</code></strong>
    -&gt;     <strong class="userinput"><code>('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00');</code></strong>

mysql&gt; <strong class="userinput"><code>SET @@time_zone = '+00:00';</code></strong>

mysql&gt; <strong class="userinput"><code>INSERT INTO ts (col) VALUES ('2020-01-01 10:10:10'),</code></strong>
    -&gt;     <strong class="userinput"><code>('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00');</code></strong>

mysql&gt; <strong class="userinput"><code>SET @@time_zone = 'SYSTEM';</code></strong>

mysql&gt; <strong class="userinput"><code>INSERT INTO dt (col) VALUES ('2020-01-01 10:10:10'),</code></strong>
    -&gt;     <strong class="userinput"><code>('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00');</code></strong>

mysql&gt; <strong class="userinput"><code>SET @@time_zone = '+00:00';</code></strong>

mysql&gt; <strong class="userinput"><code>INSERT INTO dt (col) VALUES ('2020-01-01 10:10:10'),</code></strong>
    -&gt;     <strong class="userinput"><code>('2020-01-01 10:10:10+05:30'), ('2020-01-01 10:10:10-08:00');</code></strong>

mysql&gt; <strong class="userinput"><code>SET @@time_zone = 'SYSTEM';</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT @@system_time_zone;</code></strong>
+--------------------+
| @@system_time_zone |
+--------------------+
| EST                |
+--------------------+

mysql&gt; <strong class="userinput"><code>SELECT col, UNIX_TIMESTAMP(col) FROM dt ORDER BY id;</code></strong>
+---------------------+---------------------+
| col                 | UNIX_TIMESTAMP(col) |
+---------------------+---------------------+
| 2020-01-01 10:10:10 |          1577891410 |
| 2019-12-31 23:40:10 |          1577853610 |
| 2020-01-01 13:10:10 |          1577902210 |
| 2020-01-01 10:10:10 |          1577891410 |
| 2020-01-01 04:40:10 |          1577871610 |
| 2020-01-01 18:10:10 |          1577920210 |
+---------------------+---------------------+

mysql&gt; <strong class="userinput"><code>SELECT col, UNIX_TIMESTAMP(col) FROM ts ORDER BY id;</code></strong>
+---------------------+---------------------+
| col                 | UNIX_TIMESTAMP(col) |
+---------------------+---------------------+
| 2020-01-01 10:10:10 |          1577891410 |
| 2019-12-31 23:40:10 |          1577853610 |
| 2020-01-01 13:10:10 |          1577902210 |
| 2020-01-01 05:10:10 |          1577873410 |
| 2019-12-31 23:40:10 |          1577853610 |
| 2020-01-01 13:10:10 |          1577902210 |
+---------------------+---------------------+
</pre><p>
        日時値の選択時にオフセットが使用された場合でも、オフセットは表示されません。
      </p><p>
        サポートされるオフセット値の範囲は、<code class="literal">-14:00</code> から <code class="literal">+14:00</code> までです。
      </p><p>
        タイムゾーンオフセットを含む日時リテラルは、プリペアドステートメントによってパラメータ値として受け入れられます。
      </p><p>
        SQL モードでこの変換が許可されている場合、無効な <code class="literal">DATE</code>、<code class="literal">DATETIME</code> または <code class="literal">TIMESTAMP</code> 値は適切なタイプ (<code class="literal">'0000-00-00'</code>または<code class="literal">'0000-00-00 00:00:00'</code>) の<span class="quote">「<span class="quote">「ゼロ」</span>」</span>値に変換されます。 正確な動作は、厳密な SQL モードと <code class="literal">NO_ZERO_DATE</code> SQL モードのいずれかが有効かどうかによって異なります。<a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a> を参照してください。 
      </p><p>
        MySQL 8.0.22 以降では、次に示すように <code class="literal">CAST()</code> を <code class="literal">AT TIME ZONE</code> 演算子とともに使用して取得するときに、<code class="literal">TIMESTAMP</code> 値を UTC <code class="literal">DATETIME</code> 値に変換できます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT col,</code></strong>
     &gt;     <strong class="userinput"><code>CAST(col AT TIME ZONE INTERVAL '+00:00' AS DATETIME) AS ut</code></strong>
     &gt;     <strong class="userinput"><code>FROM ts ORDER BY id;</code></strong>
+---------------------+---------------------+
| col                 | ut                  |
+---------------------+---------------------+
| 2020-01-01 10:10:10 | 2020-01-01 15:10:10 |
| 2019-12-31 23:40:10 | 2020-01-01 04:40:10 |
| 2020-01-01 13:10:10 | 2020-01-01 18:10:10 |
| 2020-01-01 10:10:10 | 2020-01-01 15:10:10 |
| 2020-01-01 04:40:10 | 2020-01-01 09:40:10 |
| 2020-01-01 18:10:10 | 2020-01-01 23:10:10 |
+---------------------+---------------------+
</pre><p>
        構文およびその他の例の詳細は、<code class="literal">CAST()</code> 関数の説明を参照してください。
      </p><a class="indexterm" name="idm45661464494992"></a><a class="indexterm" name="idm45661464492848"></a><p>
        MySQL では日付値解釈の特定のプロパティーに注意してください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL は、文字列として指定された値に、<span class="quote">「<span class="quote">緩やかな</span>」</span>形式を使用でき、この形式では、どの句読点文字でも日付部分と時間部分の区切り文字として使用できます。 場合によっては、この構文は偽りになることがあります。 たとえば、<code class="literal">'10:11:12'</code>などの値は、<code class="literal">:</code>が原因で時間値のように見えますが、日付コンテキストで使用されている場合は<code class="literal">'2010-11-12'</code>年として解釈されます。 値 <code class="literal">'10:45:15'</code> は、<code class="literal">'45'</code> が有効な月ではないので、<code class="literal">'0000-00-00'</code> に変換されます。 
          </p><p>
            日付および時間の部分と小数秒部分との間の区切り文字として認識される唯一の文字が小数点です。
          </p></li><li class="listitem"><p>
            サーバーは、月と日の値が、それぞれが 1 から 12 と 1 から 31 の範囲内にあるだけではなく、有効である必要があります。 厳密モードが無効になっていると、<code class="literal">'2004-04-31'</code> のような無効な日付は <code class="literal">'0000-00-00'</code> に変換され、警告メッセージが表示されます。 厳密モードが有効なときは、無効な日付によってエラーが発生します。 このような日付を許可するには、<code class="literal">ALLOW_INVALID_DATES</code> を有効にします。 詳細は、<a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            MySQL は、日または月カラムにゼロを含んだ <code class="literal">TIMESTAMP</code> 値や、無効な日付の値を受け入れません。 SQL モードでこの値が許可されている場合、このルールの唯一の例外は、特別な<span class="quote">「<span class="quote">「ゼロ」</span>」</span>値<code class="literal">'0000-00-00 00:00:00'</code>です。 正確な動作は、厳密な SQL モードと <code class="literal">NO_ZERO_DATE</code> SQL モードのいずれかが有効かどうかによって異なります。<a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a> を参照してください。 
          </p></li><li class="listitem"><p>
            世紀が不明であるため、2 桁の年の値を含む日付はあいまいです。 MySQL は、次のルールを使用して 2 桁の年の値を解釈します: 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">00-69</code> の範囲内の年の値は <code class="literal">2000-2069</code> になります。
              </p></li><li class="listitem"><p>
                <code class="literal">70-99</code> の範囲内の年の値は <code class="literal">1970-1999</code> になります。
              </p></li></ul></div><p>
            <a class="xref" href="data-types.html#two-digit-years" title="11.2.8 日付の 2 桁の年">セクション11.2.8「日付の 2 桁の年」</a>も参照してください。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="time"></a>11.2.3 TIME 型</h3></div></div></div><a class="indexterm" name="idm45661464464704"></a><a class="indexterm" name="idm45661464463232"></a><p>
        MySQL では、<code class="literal">TIME</code> 値が<em class="replaceable"><code>'hh:mm:ss'</code></em>形式 (大きい時間値の場合は<em class="replaceable"><code>'hhh:mm:ss'</code></em>形式) で取得および表示されます。 <code class="literal">TIME</code> 値の範囲は、<code class="literal">'-838:59:59'</code> から <code class="literal">'838:59:59'</code> です。 <code class="literal">TIME</code> 型は、時間 (24 時間以下にする必要があります) を表すだけでなく、経過時間や、2 つのイベント間の時間 (24 時間よりも非常に長くなる場合も、負になる場合もあります) を表すこともできるので、時間の部分は非常に大きくなる可能性があります。 
      </p><p>
        MySQL が <code class="literal">TIME</code> 値を認識する形式は複数あり、そのいくつかにはマイクロ秒 (6 秒) までの精度で後続の小数秒部分を含めることができます。 <a class="xref" href="language-structure.html#date-and-time-literals" title="9.1.3 日付リテラルと時間リテラル">セクション9.1.3「日付リテラルと時間リテラル」</a>を参照してください。 MySQL の小数秒のサポートの詳細は、<a class="xref" href="data-types.html#fractional-seconds" title="11.2.6 時間値での小数秒">セクション11.2.6「時間値での小数秒」</a>を参照してください。 特に、<code class="literal">TIME</code> カラムに挿入された値の小数部は、破棄されるのではなく格納されます。 小数部が含まれている場合、<code class="literal">TIME</code> 値の範囲は <code class="literal">'-838:59:59.000000'</code> から <code class="literal">'838:59:59.000000'</code> です。 
      </p><p>
        <code class="literal">TIME</code> カラムに省略された値を割り当てる場合は注意してください。 MySQL は、コロン付きの省略された <code class="literal">TIME</code> 値を時間と解釈します。 つまり、<code class="literal">'11:12'</code> は <code class="literal">'00:11:12'</code> ではなく <code class="literal">'11:12:00'</code> を意味します。 MySQL は、右端の 2 桁が秒を表すという仮定を使用して (つまり、時間としてではなく経過時間として)、コロンのない省略された値を解釈します。 たとえば、<code class="literal">'1112'</code> と <code class="literal">1112</code> は <code class="literal">'11:12:00'</code> (11 時 12 分) を表すように見えますが、MySQL では <code class="literal">'00:11:12'</code> (11 分 12 秒) と解釈されます。 同様に、<code class="literal">'12'</code> や <code class="literal">12</code> は <code class="literal">'00:00:12'</code> と解釈されます。 
      </p><p>
        時間部分と小数秒部分との間の区切り文字として認識される唯一の文字が小数点です。
      </p><p>
        デフォルトでは、<code class="literal">TIME</code> 範囲外にあるが、それ以外は有効な値は、範囲のもっとも近い終点に切り落とされます。 たとえば、<code class="literal">'-850:00:00'</code> と <code class="literal">'850:00:00'</code> は、それぞれ <code class="literal">'-838:59:59'</code> と <code class="literal">'838:59:59'</code> に変換されます。 無効な <code class="literal">TIME</code> 値は、<code class="literal">'00:00:00'</code> に変換されます。 <code class="literal">'00:00:00'</code> はそれ自体が有効な <code class="literal">TIME</code> 値なので、元の値が <code class="literal">'00:00:00'</code> と指定されたのかどうか、無効であったかどうか、テーブルに格納された <code class="literal">'00:00:00'</code> の値から判断できません。 
      </p><p>
        無効な <code class="literal">TIME</code> 値の制限を厳しくするには、エラーが発生するように厳密な SQL モードを有効にしてください。 <a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="year"></a>11.2.4 YEAR 型</h3></div></div></div><a class="indexterm" name="idm45661464426448"></a><a class="indexterm" name="idm45661464424976"></a><p>
        <code class="literal">YEAR</code> 型は年の値を表すために使用される 1 バイトの型です。 これは、4 文字の暗黙的な表示幅で <code class="literal">YEAR</code> として宣言することも、明示的な表示幅で <code class="literal">YEAR(4)</code> と同等に宣言することもできます。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL 8.0.19 では、明示的な表示幅を持つ <code class="literal">YEAR(4)</code> データ型は非推奨であり、将来のバージョンの MySQL ではサポートされなくなる予定です。 かわりに、同じ意味を持つ表示幅を指定せずに <code class="literal">YEAR</code> を使用してください。 
        </p><p>
          MySQL 8.0 では、古いバージョンの MySQL で許可されている 2 桁の <code class="literal">YEAR(2)</code> データ型はサポートされていません。 4 桁の <code class="literal">YEAR</code> に変換する手順は、<a class="ulink" href="https://dev.mysql.com/doc/refman/5.7/en/" target="_top">MySQL 5.7 Reference Manual</a> の <a class="ulink" href="https://dev.mysql.com/doc/refman/5.7/en/migrating-from-year2.html" target="_top">2-Digit YEAR(2) Limitations and Migrating to 4-Digit YEAR</a> を参照してください。 
        </p></div><p>
        MySQL では、<code class="literal">YEAR</code> 値が <code class="literal">1901</code> から <code class="literal">2155</code> および <code class="literal">0000</code> の範囲で <em class="replaceable"><code>YYYY</code></em> 形式で表示されます。
      </p><p>
        <code class="literal">YEAR</code> は、次のような様々な形式で入力値を受け入れます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">'1901'</code>から<code class="literal">'2155'</code>の範囲の 4 桁の文字列として。
          </p></li><li class="listitem"><p>
            <code class="literal">1901</code> から <code class="literal">2155</code> までの範囲の 4 桁の数値として。
          </p></li><li class="listitem"><p>
            <code class="literal">'0'</code>から<code class="literal">'99'</code>までの範囲の 1 桁または 2 桁の文字列として。 MySQL は、<code class="literal">'0'</code> から <code class="literal">'69'</code> と <code class="literal">'70'</code> から <code class="literal">'99'</code> の範囲の値を、<code class="literal">2000</code> から <code class="literal">2069</code> と <code class="literal">1970</code> から <code class="literal">1999</code> の範囲の <code class="literal">YEAR</code> 値に変換します。 
          </p></li><li class="listitem"><p>
            <code class="literal">0</code> から <code class="literal">99</code> までの範囲の 1 桁または 2 桁の数値として。 MySQL は、<code class="literal">1</code> から <code class="literal">69</code> と <code class="literal">70</code> から <code class="literal">99</code> の範囲の値を、<code class="literal">2001</code> から <code class="literal">2069</code> と <code class="literal">1970</code> から <code class="literal">1999</code> の範囲の <code class="literal">YEAR</code> 値に変換します。 
          </p><p>
            数値 <code class="literal">0</code> を挿入した結果の表示値は <code class="literal">0000</code> で、内部値は <code class="literal">0000</code> です。 ゼロを挿入して <code class="literal">2000</code> として解釈するには、文字列<code class="literal">'0'</code>または<code class="literal">'00'</code>として指定します。 
          </p></li><li class="listitem"><p>
            <code class="literal">NOW()</code> などの <code class="literal">YEAR</code> コンテキストで許容される値を返す関数の結果として。
          </p></li></ul></div><p>
        厳密な SQL モードが有効になっていない場合、MySQL は無効な <code class="literal">YEAR</code> 値を <code class="literal">0000</code> に変換します。 厳密な SQL モードでは、無効な <code class="literal">YEAR</code> 値を挿入しようとするとエラーが発生します。 
      </p><p>
        <a class="xref" href="data-types.html#two-digit-years" title="11.2.8 日付の 2 桁の年">セクション11.2.8「日付の 2 桁の年」</a>も参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="timestamp-initialization"></a>11.2.5 TIMESTAMP および DATETIME の自動初期化および更新機能</h3></div></div></div><a class="indexterm" name="idm45661464371632"></a><p>
        <code class="literal">TIMESTAMP</code> および <code class="literal">DATETIME</code> のカラムは、自動的に初期化して現在の日時 (つまり、現在のタイムスタンプ) に更新できます。
      </p><p>
        テーブル内のあらゆる <code class="literal">TIMESTAMP</code> または <code class="literal">DATETIME</code> カラムに対して、デフォルト値または自動更新値、あるいはその両方として、現在のタイムスタンプを割り当てることができます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            自動初期化されたカラムは、カラムに値を指定しない挿入行に対して現在のタイムスタンプに設定されます。
          </p></li><li class="listitem"><p>
            自動更新されたカラムは、行内のほかのカラムの値がその現在の値から変更されると、現在のタイムスタンプに自動的に更新されます。 自動更新されたカラムは、ほかのすべてのカラムがその現在の値に設定されていれば、変更されないまま保持されます。 ほかのカラムが変更したときに、自動更新したカラムが更新しないようにするには、明示的にこれを現在の値に設定します。 ほかのカラムが変更しない場合でも、自動更新カラムを更新するには、明示的にこれを必要な値に設定します (たとえば <code class="literal">CURRENT_TIMESTAMP</code> に設定します)。 
          </p></li></ul></div><p>
        また、<code class="literal">explicit_defaults_for_timestamp</code> システム変数が無効になっている場合は、<code class="literal">NULL</code> 値を許可するように <code class="literal">NULL</code> 属性で定義されていないかぎり、<code class="literal">NULL</code> 値を割り当てることで、任意の <code class="literal">TIMESTAMP</code> (<code class="literal">DATETIME</code> 以外) カラムを現在の日時に初期化または更新できます。
      </p><p>
        自動プロパティーを指定するには、カラム定義で <code class="literal">DEFAULT CURRENT_TIMESTAMP</code> および <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> 句を使用します。 句の順序は関係ありません。 両方がカラム定義にある場合、どちらも最初に実行できます。 <code class="literal">CURRENT_TIMESTAMP</code> のシノニムのいずれも、<code class="literal">CURRENT_TIMESTAMP</code> と同じ意味があります。 これらは、<code class="literal">CURRENT_TIMESTAMP()</code>、<code class="literal">NOW()</code>、<code class="literal">LOCALTIME</code>、<code class="literal">LOCALTIME()</code>、<code class="literal">LOCALTIMESTAMP</code>、および <code class="literal">LOCALTIMESTAMP()</code> です。 
      </p><p>
        <code class="literal">DEFAULT CURRENT_TIMESTAMP</code> および <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> の使用は、<code class="literal">TIMESTAMP</code> および <code class="literal">DATETIME</code> に固有です。 <code class="literal">DEFAULT</code> 句を使用して、定数 (非自動) のデフォルト値 (<code class="literal">DEFAULT 0</code> や <code class="literal">DEFAULT '2000-01-01 00:00:00'</code>など) を指定することもできます。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          次の例では、厳密な SQL モードと <code class="literal">NO_ZERO_DATE</code> SQL モードのどちらが有効になっているかに応じて警告またはエラーを生成できるデフォルトの <code class="literal">DEFAULT 0</code> を使用します。 <code class="literal">TRADITIONAL</code> SQL モードには、厳密モードおよび <code class="literal">NO_ZERO_DATE</code> が含まれることに注意してください。 <a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a>を参照してください。 
        </p></div><p>
        <code class="literal">TIMESTAMP</code> または <code class="literal">DATETIME</code> カラム定義では、現在のタイムスタンプをデフォルト値と自動更新値の両方に対して指定することも、どちらか一方について指定することも、両方について指定しないこともできます。 異なるカラムは、自動プロパティーの別々の組み合わせを持つことができます。 次のルールは可能性のある場合について記述しています。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">DEFAULT CURRENT_TIMESTAMP</code> と <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> の両方を使用した場合、カラムは、デフォルト値が現在のタイムスタンプになり、現在のタイムスタンプに自動的に更新されます。
          </p><pre class="programlisting">CREATE TABLE t1 (
  ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  dt DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
</pre></li><li class="listitem"><p>
            <code class="literal">DEFAULT</code> 句を使用するが <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> 句を使用しない場合、カラムには所定のデフォルト値が設定され、現在のタイムスタンプに自動的に更新されません。
          </p><p>
            デフォルトは、<code class="literal">DEFAULT</code> 句で <code class="literal">CURRENT_TIMESTAMP</code> を指定するか定数値を指定するかに応じて異なります。 <code class="literal">CURRENT_TIMESTAMP</code> を使用した場合、デフォルトは現在のタイムスタンプになります。 
          </p><pre class="programlisting">CREATE TABLE t1 (
  ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  dt DATETIME DEFAULT CURRENT_TIMESTAMP
);
</pre><p>
            定数を使用した場合、デフォルトは所定の値になります。 この場合、カラムには自動的なプロパティーはありません。 
          </p><pre class="programlisting">CREATE TABLE t1 (
  ts TIMESTAMP DEFAULT 0,
  dt DATETIME DEFAULT 0
);
</pre></li><li class="listitem"><p>
            <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> 句と定数の <code class="literal">DEFAULT</code> 句を使用した場合、カラムは、現在のタイムスタンプに自動的に更新され、所定の定数のデフォルト値があります。
          </p><pre class="programlisting">CREATE TABLE t1 (
  ts TIMESTAMP DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP,
  dt DATETIME DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP
);
</pre></li><li class="listitem"><p>
            <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> 句を使用するが <code class="literal">DEFAULT</code> 句を使用しない場合、カラムは、自動的に現在のタイムスタンプに更新され、そのデフォルト値に現在のタイムスタンプは使用されません。
          </p><p>
            この場合のデフォルトは型により異なります。 <code class="literal">TIMESTAMP</code> は、<code class="literal">NULL</code> 属性を使用して定義されていないかぎり (この場合はデフォルトは <code class="literal">NULL</code> です)、デフォルトは 0 です。 
          </p><pre class="programlisting">CREATE TABLE t1 (
  ts1 TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,     -- default 0
  ts2 TIMESTAMP NULL ON UPDATE CURRENT_TIMESTAMP -- default NULL
);
</pre><p>
            <code class="literal">DATETIME</code> は、<code class="literal">NOT NULL</code> 属性で定義されていないかぎり (この場合、デフォルトは 0 です)、デフォルトは <code class="literal">NULL</code> です。
          </p><pre class="programlisting">CREATE TABLE t1 (
  dt1 DATETIME ON UPDATE CURRENT_TIMESTAMP,         -- default NULL
  dt2 DATETIME NOT NULL ON UPDATE CURRENT_TIMESTAMP -- default 0
);
</pre></li></ul></div><p>
        <code class="literal">TIMESTAMP</code> および <code class="literal">DATETIME</code> のカラムには、明示的に指定しないかぎり、自動プロパティはありませんが、この例外があります: <code class="literal">explicit_defaults_for_timestamp</code> システム変数が無効になっている場合、<span class="emphasis"><em>first</em></span> <code class="literal">TIMESTAMP</code> カラムに <code class="literal">DEFAULT CURRENT_TIMESTAMP</code> と <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> の両方が含まれます (どちらも明示的に指定されていない場合)。 最初の <code class="literal">TIMESTAMP</code> カラムについて自動プロパティーを抑制するには、次のいずれかの戦略を使用します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">explicit_defaults_for_timestamp</code> システム変数を有効にします。 この場合、自動初期化および自動更新を指定する <code class="literal">DEFAULT CURRENT_TIMESTAMP</code> 句および <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> 句は使用できますが、カラム定義に明示的に含まれていないかぎり、<code class="literal">TIMESTAMP</code> カラムには割り当てられません。 
          </p></li><li class="listitem"><p>
            または、<code class="literal">explicit_defaults_for_timestamp</code> が無効になっている場合は、次のいずれかを実行します:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                定数のデフォルト値を指定する <code class="literal">DEFAULT</code> 句を含むカラムを定義します。
              </p></li><li class="listitem"><p>
                <code class="literal">NULL</code> 属性を指定します。 またこれにより、カラムで <code class="literal">NULL</code> 値が許可されます。つまり、カラムを <code class="literal">NULL</code> に設定することによって現在のタイムスタンプを割り当てることができなくなります。 <code class="literal">NULL</code> を割り当てると、カラムは現在のタイムスタンプではなく <code class="literal">NULL</code> に設定されます。 現在のタイムスタンプを割り当てるには、カラムを <code class="literal">CURRENT_TIMESTAMP</code> または <code class="literal">NOW()</code> などのシノニムに設定します。 
              </p></li></ul></div></li></ul></div><p>
        次のテーブル定義を考慮してください。
      </p><pre class="programlisting">CREATE TABLE t1 (
  ts1 TIMESTAMP DEFAULT 0,
  ts2 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                ON UPDATE CURRENT_TIMESTAMP);
CREATE TABLE t2 (
  ts1 TIMESTAMP NULL,
  ts2 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                ON UPDATE CURRENT_TIMESTAMP);
CREATE TABLE t3 (
  ts1 TIMESTAMP NULL DEFAULT 0,
  ts2 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                ON UPDATE CURRENT_TIMESTAMP);
</pre><p>
        テーブルには次のプロパティーがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            各テーブル定義において、最初の <code class="literal">TIMESTAMP</code> カラムには、自動初期化または更新機能はありません。
          </p></li><li class="listitem"><p>
            各テーブルでは、<code class="literal">ts1</code> カラムで <code class="literal">NULL</code> 値を処理する方法が異なります。 <code class="literal">t1</code> の場合、<code class="literal">ts1</code> は <code class="literal">NOT NULL</code> であり、これに <code class="literal">NULL</code> の値を割り当てると、現在のタイムスタンプに設定されます。 <code class="literal">t2</code> と <code class="literal">t3</code> の場合、<code class="literal">ts1</code> では <code class="literal">NULL</code> を使用でき、これに <code class="literal">NULL</code> の値を割り当てると、<code class="literal">NULL</code> に設定されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">t2</code> と <code class="literal">t3</code> では、<code class="literal">ts1</code> のデフォルト値が異なります。 <code class="literal">t2</code> の場合、<code class="literal">ts1</code> は、<code class="literal">NULL</code> を許可するように定義されているので、明示的な <code class="literal">DEFAULT</code> 句がない場合はデフォルトも <code class="literal">NULL</code> です。 <code class="literal">t3</code> の場合、<code class="literal">ts1</code> は <code class="literal">NULL</code> を使用できますが、明示的なデフォルトは 0 です。 
          </p></li></ul></div><p>
        <code class="literal">TIMESTAMP</code> または <code class="literal">DATETIME</code> カラム定義のいずれかの場所に明示的な小数秒精度値が含まれる場合、カラム定義全体で同じ値を使用する必要があります。 次の場合は許可されます。 
      </p><pre class="programlisting">CREATE TABLE t1 (
  ts TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6)
);
</pre><p>
        次の場合は許可されません。
      </p><pre class="programlisting">CREATE TABLE t1 (
  ts TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP(3)
);
</pre><h4><a name="idm45661464247888"></a>TIMESTAMP の初期化と NULL 属性</h4><p>
        <code class="literal">explicit_defaults_for_timestamp</code> システム変数が無効になっている場合、<code class="literal">TIMESTAMP</code> カラムはデフォルトで <code class="literal">NOT NULL</code> であり、<code class="literal">NULL</code> 値を含めることはできず、<code class="literal">NULL</code> を割り当てると現在のタイムスタンプが割り当てられます。 <code class="literal">NULL</code> を含めるように <code class="literal">TIMESTAMP</code> カラムを許可するには、<code class="literal">NULL</code> 属性で明示的に宣言します。 この場合、別のデフォルト値を指定する <code class="literal">DEFAULT</code> 句でオーバーライドされないかぎり、デフォルト値も <code class="literal">NULL</code> になります。 <code class="literal">DEFAULT NULL</code> を使用すると、デフォルト値として <code class="literal">NULL</code> を明示的に指定できます。 (<code class="literal">NULL</code> 属性が宣言されていない <code class="literal">TIMESTAMP</code> カラムの場合、<code class="literal">DEFAULT NULL</code> は無効です。) <code class="literal">TIMESTAMP</code> カラムで <code class="literal">NULL</code> 値を許可する場合、<code class="literal">NULL</code> を割り当てると、このカラムは現在のタイムスタンプではなく <code class="literal">NULL</code> に設定されます。 
      </p><p>
        次のテーブルには、<code class="literal">NULL</code> 値を許可している複数の <code class="literal">TIMESTAMP</code> カラムが含まれています。
      </p><pre class="programlisting">CREATE TABLE t
(
  ts1 TIMESTAMP NULL DEFAULT NULL,
  ts2 TIMESTAMP NULL DEFAULT 0,
  ts3 TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP
);
</pre><p>
        <code class="literal">NULL</code> 値を許可する <code class="literal">TIMESTAMP</code> カラムは、次のいずれかの状況に当てはまる場合を除き、挿入時に現在のタイムスタンプを取り<span class="emphasis"><em>ません</em></span>。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            デフォルト値が <code class="literal">CURRENT_TIMESTAMP</code> と定義され、カラムに対して値が指定されていない
          </p></li><li class="listitem"><p>
            <code class="literal">CURRENT_TIMESTAMP</code>、または<code class="literal">NOW()</code> などのそのいずれかのシノニムが明示的にカラムに挿入されている
          </p></li></ul></div><p>
        つまり、<code class="literal">NULL</code> 値を許可するように定義されている <code class="literal">TIMESTAMP</code> カラムは、その定義に <code class="literal">DEFAULT CURRENT_TIMESTAMP</code> が含まれている場合にのみ自動初期化します。
      </p><pre class="programlisting">CREATE TABLE t (ts TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP);
</pre><p>
        <code class="literal">TIMESTAMP</code> カラムで <code class="literal">NULL</code> 値を許可しているが、定義に <code class="literal">DEFAULT CURRENT_TIMESTAMP</code> が含まれていない場合、現在の日付と時間に対応する値を明示的に挿入する必要があります。 <code class="literal">t1</code> および <code class="literal">t2</code> テーブルに次の定義があるとします。 
      </p><pre class="programlisting">CREATE TABLE t1 (ts TIMESTAMP NULL DEFAULT '0000-00-00 00:00:00');
CREATE TABLE t2 (ts TIMESTAMP NULL DEFAULT NULL);
</pre><p>
        挿入時にどちらかのテーブルの <code class="literal">TIMESTAMP</code> カラムを現在のタイムスタンプに設定するには、明示的にそのカラムにこの値を割り当てます。 例: 
      </p><pre class="programlisting">INSERT INTO t2 VALUES (CURRENT_TIMESTAMP);
INSERT INTO t1 VALUES (NOW());
</pre><p>
        <code class="literal">explicit_defaults_for_timestamp</code> システム変数が有効になっている場合、<code class="literal">TIMESTAMP</code> カラムで <code class="literal">NULL</code> 値が許可されるのは、<code class="literal">NULL</code> 属性で宣言されている場合のみです。 また、<code class="literal">TIMESTAMP</code> カラムでは、<code class="literal">NULL</code> または <code class="literal">NOT NULL</code> 属性で宣言されているかどうかにかかわらず、<code class="literal">NULL</code> を割り当てて現在のタイムスタンプを割り当てることはできません。 現在のタイムスタンプを割り当てるには、カラムを <code class="literal">CURRENT_TIMESTAMP</code> または <code class="literal">NOW()</code> などのシノニムに設定します。 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="fractional-seconds"></a>11.2.6 時間値での小数秒</h3></div></div></div><p>
        MySQL では、マイクロ秒 (6 桁) までの精度で、<code class="literal">TIME</code>、<code class="literal">DATETIME</code> および <code class="literal">TIMESTAMP</code> 値の小数秒がサポートされています:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            小数秒部を含むカラムを定義するには、<code class="literal"><em class="replaceable"><code>type_name</code></em>(<em class="replaceable"><code>fsp</code></em>)</code> の構文を使用します。ここで、<em class="replaceable"><code>type_name</code></em> は <code class="literal">TIME</code>、<code class="literal">DATETIME</code>、または <code class="literal">TIMESTAMP</code> であり、<em class="replaceable"><code>fsp</code></em> は小数秒の精度です。 例: 
          </p><pre class="programlisting">CREATE TABLE t1 (t TIME(3), dt DATETIME(6));
</pre><p>
            <em class="replaceable"><code>fsp</code></em> 値を指定する場合、0 から 6 の範囲にする必要があります。 0 の値は、小数部がないことを表します。 省略した場合、デフォルトの精度は 0 です。 (これは、以前の MySQL バージョンと互換性を保つため、標準 SQL のデフォルトである 6 とは異なっています。) 
          </p></li><li class="listitem"><p>
            小数秒の部分を含む <code class="literal">TIME</code>、<code class="literal">DATE</code> または <code class="literal">TIMESTAMP</code> 値を同じタイプのカラムに挿入すると、小数点以下の桁数が少なくなります。 次のように作成および移入されたテーブルについて考えてみます: 
          </p><pre class="programlisting">CREATE TABLE fractest( c1 TIME(2), c2 DATETIME(2), c3 TIMESTAMP(2) );
INSERT INTO fractest VALUES
('17:51:04.777', '2018-09-08 17:51:04.777', '2018-09-08 17:51:04.777');
</pre><p>
            時間値は丸めでテーブルに挿入されます:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM fractest;</code></strong>
+-------------+------------------------+------------------------+
| c1          | c2                     | c3                     |
+-------------+------------------------+------------------------+
| 17:51:04.78 | 2018-09-08 17:51:04.78 | 2018-09-08 17:51:04.78 |
+-------------+------------------------+------------------------+
</pre><p>
            このような丸め行われたときに、警告やエラーは表示されません。 この動作は SQL 標準に従います。 
          </p><p>
            かわりに切捨てを使用して値を挿入するには、<code class="literal">TIME_TRUNCATE_FRACTIONAL</code> SQL モードを有効にします:
          </p><pre class="programlisting">SET @@sql_mode = sys.list_add(@@sql_mode, 'TIME_TRUNCATE_FRACTIONAL');
</pre><p>
            この SQL モードを有効にすると、時間値は切捨てとともに挿入されます:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM fractest;</code></strong>
+-------------+------------------------+------------------------+
| c1          | c2                     | c3                     |
+-------------+------------------------+------------------------+
| 17:51:04.77 | 2018-09-08 17:51:04.77 | 2018-09-08 17:51:04.77 |
+-------------+------------------------+------------------------+
</pre></li><li class="listitem"><p>
            時間引数を取る関数は、小数秒を含む値を受け入れます。 時間関数からの戻り値には、必要に応じて小数秒が含まれます。 たとえば、引数を付けない <code class="literal">NOW()</code> は、小数部のない現在の日付と時間を返しますが、0 から 6 のオプション引数を取って、その桁数の小数秒部が戻り値に含まれていることを指定します。 
          </p></li><li class="listitem"><p>
            時間リテラルの構文は、<code class="literal">DATE '<em class="replaceable"><code>str</code></em>'</code>、<code class="literal">TIME '<em class="replaceable"><code>str</code></em>'</code>、および <code class="literal">TIMESTAMP '<em class="replaceable"><code>str</code></em>'</code> の時間値と ODBC 構文同等の値を生み出します。 指定されている場合、結果の値には後続の小数秒部分が含まれます。 以前は、時間型キーワードは無視され、これらの構造は文字列値を生成していました。 <a class="xref" href="language-structure.html#date-and-time-standard-sql-literals" title="標準 SQL と ODBC の日付および時間リテラル">標準 SQL と ODBC の日付および時間リテラル</a>を参照してください 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="date-and-time-type-conversion"></a>11.2.7 日付と時間型間での変換</h3></div></div></div><p>
        ある程度まで、ある時間型から別の時間型に値を変換できます。 ただし、値の変更や情報の損失が生じることがあります。 どの場合でも、時間型間の変換は、変換される型で有効な値の範囲に依存します。 たとえば、<code class="literal">DATE</code>、<code class="literal">DATETIME</code>、および <code class="literal">TIMESTAMP</code> 値はすべて、同じセットの形式を使用して指定できますが、すべての型で値の範囲が同じであるわけではありません。 <code class="literal">TIMESTAMP</code> 値は、<code class="literal">1970</code> UTC より古い値にしたり、<code class="literal">'2038-01-19 03:14:07'</code> UTC より新しい値にしたりできません。 つまり、<code class="literal">'1968-01-01'</code> などの日付は、<code class="literal">DATE</code> または <code class="literal">DATETIME</code> 値としては有効ですが、<code class="literal">TIMESTAMP</code> 値としては有効ではなく、<code class="literal">0</code> に変換されます。 
      </p><p>
        <code class="literal">DATE</code> 値の変換:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">DATE</code> 値には時間情報が含まれないので、<code class="literal">DATETIME</code> または <code class="literal">TIMESTAMP</code> 値に変換すると、<code class="literal">'00:00:00'</code> の時間部分が追加されます。
          </p></li><li class="listitem"><p>
            <code class="literal">TIME</code> 値への変換は有用ではありません。結果は <code class="literal">'00:00:00'</code> になります。
          </p></li></ul></div><p>
        <code class="literal">DATETIME</code> および <code class="literal">TIMESTAMP</code> 値の変換:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">DATE</code> 値への変換では、小数秒が考慮され、時間部分が丸められます。 たとえば、<code class="literal">'1999-12-31 23:59:59.499'</code>は<code class="literal">'1999-12-31'</code>になり、<code class="literal">'1999-12-31 23:59:59.500'</code>は<code class="literal">'2000-01-01'</code>になります。 
          </p></li><li class="listitem"><p>
            <code class="literal">TIME</code> 型には日付情報が含まれないので、<code class="literal">TIME</code> 値に変換すると日付部分が破棄されます。
          </p></li></ul></div><p>
        <code class="literal">TIME</code> 値を他の時間型に変換する場合、<code class="literal">CURRENT_DATE()</code> の値が日付部分に使用されます。 <code class="literal">TIME</code> は (時間ではなく) 経過時間として解釈され、日付に追加されます。 これは、時間値が <code class="literal">'00:00:00'</code> から <code class="literal">'23:59:59'</code> の範囲から外れている場合に、結果の日付部分が現在の日付と異なることを意味します。 
      </p><p>
        現在の日付が <code class="literal">'2012-01-01'</code> であるとします。 <code class="literal">'12:00:00'</code>、<code class="literal">'24:00:00'</code>、<code class="literal">'-12:00:00'</code> の <code class="literal">TIME</code> 値は、<code class="literal">DATETIME</code> または <code class="literal">TIMESTAMP</code> 値に変換されると、それぞれ <code class="literal">'2012-01-01 12:00:00'</code>、<code class="literal">'2012-01-02 00:00:00'</code>、<code class="literal">'2011-12-31 12:00:00'</code> になります。 
      </p><p>
        <code class="literal">TIME</code> から <code class="literal">DATE</code> への変換も同様ですが、結果から時間部分が破棄され、それぞれ <code class="literal">'2012-01-01'</code>、<code class="literal">'2012-01-02'</code>、<code class="literal">'2011-12-31'</code> になります。
      </p><p>
        明示的な変換を使用して暗黙的な変換をオーバーライドできます。 たとえば、<code class="literal">DATE</code> および <code class="literal">DATETIME</code> 値の比較で、<code class="literal">DATE</code> 値は、<code class="literal">'00:00:00'</code> の時間部分を追加することにより、強制的に <code class="literal">DATETIME</code> 型に変更されます。 代わりに <code class="literal">DATETIME</code> 値の時間部分を無視して比較を実行するには、次の方法で <code class="literal">CAST()</code> 関数を使用します。 
      </p><pre class="programlisting"><em class="replaceable"><code>date_col</code></em> = CAST(<em class="replaceable"><code>datetime_col</code></em> AS DATE)
</pre><p>
        <code class="literal">TIME</code> および <code class="literal">DATETIME</code> 値の数値形式への変換 (<code class="literal">+0</code> の追加など) は、値に小数秒部分が含まれているかどうかによって異なります。 <code class="literal">TIME(<em class="replaceable"><code>N</code></em>)</code> または <code class="literal">DATETIME(<em class="replaceable"><code>N</code></em>)</code> は、<em class="replaceable"><code>N</code></em> が 0 (または省略) の場合は整数に変換され、<em class="replaceable"><code>N</code></em> が 0 より大きい場合は <em class="replaceable"><code>N</code></em> 小数点を含む <code class="literal">DECIMAL</code> 値に変換されます: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT CURTIME(), CURTIME()+0, CURTIME(3)+0;</code></strong>
+-----------+-------------+--------------+
| CURTIME() | CURTIME()+0 | CURTIME(3)+0 |
+-----------+-------------+--------------+
| 09:28:00  |       92800 |    92800.887 |
+-----------+-------------+--------------+
mysql&gt; <strong class="userinput"><code>SELECT NOW(), NOW()+0, NOW(3)+0;</code></strong>
+---------------------+----------------+--------------------+
| NOW()               | NOW()+0        | NOW(3)+0           |
+---------------------+----------------+--------------------+
| 2012-08-15 09:28:00 | 20120815092800 | 20120815092800.889 |
+---------------------+----------------+--------------------+
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="two-digit-years"></a>11.2.8 日付の 2 桁の年</h3></div></div></div><p>
        世紀が不明であるため、年が 2 桁の日付値はあいまいです。 MySQL では 4 桁を使用して内部的に年が格納されるため、このような値は 4 桁の形式に解釈する必要があります。 
      </p><p>
        <code class="literal">DATETIME</code>、<code class="literal">DATE</code>、および <code class="literal">TIMESTAMP</code> 型では、MySQL は、次のルールを使用して、あいまいな年の値で指定された日付を変換します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">00-69</code> の範囲内の年の値は <code class="literal">2000-2069</code> になります。
          </p></li><li class="listitem"><p>
            <code class="literal">70-99</code> の範囲内の年の値は <code class="literal">1970-1999</code> になります。
          </p></li></ul></div><p>
        <code class="literal">YEAR</code> ではルールは同じですが、<code class="literal">YEAR</code> に挿入された数値 <code class="literal">00</code> は <code class="literal">2000</code> ではなく <code class="literal">0000</code> になります。 <code class="literal">YEAR</code> にゼロを指定し、これを <code class="literal">2000</code> として解釈させるには、文字列 <code class="literal">'0'</code> または <code class="literal">'00'</code> としてこれを指定します。 
      </p><p>
        これらのルールは、データ値が何を表すかを妥当に推測する単なる経験則であることを覚えておいてください。 MySQL で使用されるルールで必要な値が生成されない場合は、4 桁の年の値を含む明確な入力を指定する必要があります。 
      </p><p>
        <code class="literal">ORDER BY</code> では、年が 2 桁の <code class="literal">YEAR</code> 値が適切にソートされます。
      </p><p>
        <code class="literal">MIN()</code> や <code class="literal">MAX()</code> などの一部の関数は、<code class="literal">YEAR</code> を数値に変換します。 つまり、年が 2 桁の値は、これらの関数では正しく機能しません。 この場合の修正は、<code class="literal">YEAR</code> を 4 桁の年形式に変換することです。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="string-types"></a>11.3 文字列データ型</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="data-types.html#string-type-syntax">11.3.1 文字列データ型の構文</a></span></dt><dt><span class="section"><a href="data-types.html#char">11.3.2 CHAR および VARCHAR 型</a></span></dt><dt><span class="section"><a href="data-types.html#binary-varbinary">11.3.3 BINARY および VARBINARY 型</a></span></dt><dt><span class="section"><a href="data-types.html#blob">11.3.4 BLOB 型と TEXT 型</a></span></dt><dt><span class="section"><a href="data-types.html#enum">11.3.5 ENUM 型</a></span></dt><dt><span class="section"><a href="data-types.html#set">11.3.6 SET 型</a></span></dt></dl></div><a class="indexterm" name="idm45661464061152"></a><a class="indexterm" name="idm45661464059376"></a><a class="indexterm" name="idm45661464057344"></a><a class="indexterm" name="idm45661464055888"></a><a class="indexterm" name="idm45661464054528"></a><a class="indexterm" name="idm45661464053168"></a><a class="indexterm" name="idm45661464051792"></a><a class="indexterm" name="idm45661464049872"></a><p>
      文字列データ型は、<code class="literal">CHAR</code>, <code class="literal">VARCHAR</code>, <code class="literal">BINARY</code>, <code class="literal">VARBINARY</code>, <code class="literal">BLOB</code>, <code class="literal">TEXT</code>, <code class="literal">ENUM</code> および <code class="literal">SET</code> です。
    </p><p>
      文字列データ型の記憶域要件の詳細は、<a class="xref" href="data-types.html#storage-requirements" title="11.7 データ型のストレージ要件">セクション11.7「データ型のストレージ要件」</a> を参照してください。
    </p><p>
      文字列値を操作する関数については、<a class="xref" href="functions.html#string-functions" title="12.8 文字列関数および演算子">セクション12.8「文字列関数および演算子」</a> を参照してください。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="string-type-syntax"></a>11.3.1 文字列データ型の構文</h3></div></div></div><p>
        文字列データ型は、<code class="literal">CHAR</code>, <code class="literal">VARCHAR</code>, <code class="literal">BINARY</code>, <code class="literal">VARBINARY</code>, <code class="literal">BLOB</code>, <code class="literal">TEXT</code>, <code class="literal">ENUM</code> および <code class="literal">SET</code> です。
      </p><p>
        MySQL は、文字列カラムを <code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントで与えられている型とは異なる型に変更することがあります。 <a class="xref" href="sql-statements.html#silent-column-changes" title="13.1.20.7 暗黙のカラム指定の変更">セクション13.1.20.7「暗黙のカラム指定の変更」</a>を参照してください。 
      </p><p>
        文字列カラム (<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code> および <code class="literal">TEXT</code> 型) の定義では、MySQL は長さの指定を文字単位で解釈します。 バイナリ文字列カラム (<code class="literal">BINARY</code>、<code class="literal">VARBINARY</code> および <code class="literal">BLOB</code> 型) の定義では、MySQL は長さの指定をバイト単位で解釈します。 
      </p><p>
        文字列データ型 <code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、<code class="literal">TEXT</code> 型、<code class="literal">ENUM</code>、<code class="literal">SET</code> および任意のシノニムのカラム定義では、カラムの文字セットおよび照合順序を指定できます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CHARACTER SET</code> では、文字セットを指定します。 必要に応じて、文字セットの照合順序を <code class="literal">COLLATE</code> 属性とともに他の属性とともに指定できます。 例: 
          </p><pre class="programlisting">CREATE TABLE t
(
    c1 VARCHAR(20) CHARACTER SET utf8,
    c2 TEXT CHARACTER SET latin1 COLLATE latin1_general_cs
);
</pre><p>
            このテーブル定義では、<code class="literal">c1</code> という名前のカラムを作成します。このカラムには、その文字セットのデフォルト照合順序を持つ <code class="literal">utf8</code> の文字セットと、<code class="literal">latin1</code> という文字セットおよび大/小文字を区別する (<code class="literal">_cs</code>) 照合順序を持つ <code class="literal">c2</code> という名前のカラムがあります。
          </p><p>
            <code class="literal">CHARACTER SET</code> と <code class="literal">COLLATE</code> 属性のいずれかまたは両方が欠落している場合に文字セットと照合順序を割り当てるためのルールは、<a class="xref" href="charset.html#charset-column" title="10.3.5 カラム文字セットおよび照合順序">セクション10.3.5「カラム文字セットおよび照合順序」</a> で説明されています。
          </p><p>
            <code class="literal">CHARSET</code> は <code class="literal">CHARACTER SET</code> のシノニムです。
          </p></li><li class="listitem"><p>
            文字列データ型に <code class="literal">CHARACTER SET binary</code> 属性を指定すると、対応するバイナリ文字列データ型としてカラムが作成されます: <code class="literal">CHAR</code> は <code class="literal">BINARY</code>、<code class="literal">VARCHAR</code> は <code class="literal">VARBINARY</code>、<code class="literal">TEXT</code> は <code class="literal">BLOB</code> になります。 <code class="literal">ENUM</code> および <code class="literal">SET</code> データ型では、これは行われず、宣言されたとおりに作成されます。 この定義を使用して、テーブルを指定したとします。 
          </p><pre class="programlisting">CREATE TABLE t
(
  c1 VARCHAR(10) CHARACTER SET binary,
  c2 TEXT CHARACTER SET binary,
  c3 ENUM('a','b','c') CHARACTER SET binary
);
</pre><p>
            結果のテーブルには、この定義が含まれています。
          </p><pre class="programlisting">CREATE TABLE t
(
  c1 VARBINARY(10),
  c2 BLOB,
  c3 ENUM('a','b','c') CHARACTER SET binary
);
</pre></li><li class="listitem"><p>
            <code class="literal">BINARY</code> 属性は、カラム文字セット (またはカラム文字セットが指定されていない場合はテーブルのデフォルト文字セット) のバイナリ (<code class="literal">_bin</code>) 照合順序を指定するための短縮形である非標準の MySQL 拡張機能です。 この場合、比較およびソートは数値文字コード値に基づきます。 この定義を使用して、テーブルを指定したとします。 
          </p><pre class="programlisting">CREATE TABLE t
(
  c1 VARCHAR(10) CHARACTER SET latin1 BINARY,
  c2 TEXT BINARY
) CHARACTER SET utf8mb4;
</pre><p>
            結果のテーブルには、この定義が含まれています。
          </p><pre class="programlisting">CREATE TABLE t (
  c1 VARCHAR(10) CHARACTER SET latin1 COLLATE latin1_bin,
  c2 TEXT CHARACTER SET utf8mb4 COLLATE utf8mb4_bin
) CHARACTER SET utf8mb4;
</pre><p>
            MySQL 8.0 では、<code class="literal">utf8mb4</code> 文字セットに複数の<code class="literal">_bin</code> 照合順序があるため、<code class="literal">BINARY</code> 属性のこの非標準の使用はあいまいです。 MySQL 8.0.17 では、<code class="literal">BINARY</code> 属性は非推奨であり、将来のバージョンの MySQL でサポートが削除される予定です。 かわりに、明示的な<code class="literal">_bin</code> 照合を使用するようにアプリケーションを調整する必要があります。 
          </p><p>
            <code class="literal">BINARY</code> を使用してデータ型または文字セットを指定する方法は変わりません。
          </p></li><li class="listitem"><p>
            <code class="literal">ASCII</code> 属性は <code class="literal">CHARACTER SET latin1</code> の短縮形です。
          </p></li><li class="listitem"><p>
            <code class="literal">UNICODE</code> 属性は <code class="literal">CHARACTER SET ucs2</code> の短縮形です。
          </p></li></ul></div><p>
        文字カラムの比較およびソートは、カラムに割り当てられた照合に基づきます。 <code class="literal">CHAR</code>, <code class="literal">VARCHAR</code>, <code class="literal">TEXT</code>, <code class="literal">ENUM</code> および <code class="literal">SET</code> データ型の場合は、バイナリ (<code class="literal">_bin</code>) 照合順序または <code class="literal">BINARY</code> 属性を使用してカラムを宣言し、比較およびソートで字句順序ではなく基礎となる文字コード値を使用できます。 
      </p><p>
        MySQL での文字セットの使用の詳細は、<a class="xref" href="charset.html" title="第 10 章 文字セット、照合順序、Unicode">第10章「<i>文字セット、照合順序、Unicode</i>」</a> を参照してください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="indexterm" name="idm45661463957904"></a> <a class="indexterm" name="idm45661463956432"></a> <a class="indexterm" name="idm45661463955040"></a> <a class="indexterm" name="idm45661463953680"></a> <a class="indexterm" name="idm45661463952288"></a> <a class="indexterm" name="idm45661463950368"></a> <a class="indexterm" name="idm45661463948336"></a> <a class="indexterm" name="idm45661463946304"></a> <code class="literal">[NATIONAL] CHAR[(<em class="replaceable"><code>M</code></em>)] [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]</code>
          </p><p>
            格納時に必ず、指定された長さになるように右側がスペースで埋められる固定長文字列です。 <em class="replaceable"><code>M</code></em> はカラムの長さを文字数で表します。 <em class="replaceable"><code>M</code></em> の範囲は 0 から 255 です。 <em class="replaceable"><code>M</code></em> を省略すると、長さは 1 になります。 
          </p><a class="indexterm" name="idm45661463939968"></a><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">PAD_CHAR_TO_FULL_LENGTH</code> SQL モードが有効になっていないかぎり、<code class="literal">CHAR</code> 値が取り出されるときに末尾のスペースは削除されます。
            </p></div><p>
            <code class="literal">CHAR</code> は <code class="literal">CHARACTER</code> の短縮形です。 <code class="literal">NATIONAL CHAR</code> (またはそれと同等の短縮形である <code class="literal">NCHAR</code>) は、<code class="literal">CHAR</code> カラムが事前に定義された文字セットを使用する必要があることを定義する標準 SQL の方法です。 MySQL では、この事前定義済文字セットとして <code class="literal">utf8</code> を使用します。<a class="xref" href="charset.html#charset-national" title="10.3.7 各国語文字セット">セクション10.3.7「各国語文字セット」</a>。 
          </p><p>
            <code class="literal">CHAR BYTE</code> データ型は <code class="literal">BINARY</code> データ型のエイリアスです。 これは互換性機能です。 
          </p><p>
            MySQL では、<code class="literal">CHAR(0)</code> の型のカラムを作成できます。 これは主に、カラムの存在に依存するが、実際にはその値を使用しない古いアプリケーションに準拠する必要がある場合に役立ちます。 <code class="literal">CHAR(0)</code> は、2 つの値しか取れないカラムが必要な場合にも非常に便利です。<code class="literal">CHAR(0) NULL</code> として定義されたカラムは 1 ビットだけを占め、<code class="literal">NULL</code> と <code class="literal">''</code> (空の文字列) 値だけを取ることができます。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661463914704"></a> <a class="indexterm" name="idm45661463913216"></a> <a class="indexterm" name="idm45661463911808"></a> <a class="indexterm" name="idm45661463910416"></a> <a class="indexterm" name="idm45661463909024"></a> <a class="indexterm" name="idm45661463907616"></a> <a class="indexterm" name="idm45661463906224"></a> <a class="indexterm" name="idm45661463904304"></a> <a class="indexterm" name="idm45661463902272"></a> <a class="indexterm" name="idm45661463900240"></a> <a class="indexterm" name="idm45661463898208"></a> <a class="indexterm" name="idm45661463896176"></a> <code class="literal">[NATIONAL] VARCHAR(<em class="replaceable"><code>M</code></em>) [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]</code>
          </p><a class="indexterm" name="idm45661463892048"></a><p>
            可変長文字列です。 <em class="replaceable"><code>M</code></em> はカラムの最大長を文字数で表します。 <em class="replaceable"><code>M</code></em> の範囲は 0 から 65,535 です。 <code class="literal">VARCHAR</code> の有効な最大長は、最大行サイズ (65,535 バイト、すべてのカラムで共有されます) と使用される文字セットによって決まります。 たとえば、<code class="literal">utf8</code> の文字は 1 文字につき最大 3 バイトを必要とする場合があるため、<code class="literal">utf8</code> の文字セットを使用する <code class="literal">VARCHAR</code> カラムは、最大 21,844 文字になるように宣言できます。 <a class="xref" href="optimization.html#column-count-limit" title="8.4.7 テーブルカラム数と行サイズの制限">セクション8.4.7「テーブルカラム数と行サイズの制限」</a>を参照してください。 
          </p><p>
            MySQL は、<code class="literal">VARCHAR</code> 値を 1 バイトまたは 2 バイト長のプリフィクスが付いたデータとして格納します。 長さプリフィクスは、値に含まれるバイト数を示します。 <code class="literal">VARCHAR</code> カラムは、格納できる値が 255 バイト以下の場合は 1 バイト長のプリフィクスを使用し、255 バイトより大きい場合は 2 バイト長のプリフィクスを使用します。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              MySQL は標準の SQL 仕様に準拠しており、<code class="literal">VARCHAR</code> 値の末尾の空白は削除されません。
            </p></div><p>
            <code class="literal">VARCHAR</code> は <code class="literal">CHARACTER VARYING</code> の短縮形です。 <code class="literal">NATIONAL VARCHAR</code> は、<code class="literal">VARCHAR</code> カラムが事前定義された文字セットを使用する必要があることを定義するための標準 SQL の方法です。 MySQL では、この事前定義済文字セットとして <code class="literal">utf8</code> を使用します。<a class="xref" href="charset.html#charset-national" title="10.3.7 各国語文字セット">セクション10.3.7「各国語文字セット」</a>。 <code class="literal">NVARCHAR</code> は <code class="literal">NATIONAL VARCHAR</code> の短縮形です。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661463867824"></a> <a class="indexterm" name="idm45661463866352"></a> <code class="literal">BINARY[(<em class="replaceable"><code>M</code></em>)]</code>
          </p><p>
            <code class="literal">BINARY</code> 型は <code class="literal">CHAR</code> 型と似ていますが、非バイナリ文字列ではなく、バイナリバイト文字列を格納します。 オプションの長さの <em class="replaceable"><code>M</code></em> は、カラムの長さをバイト単位で表します。 省略すると、<em class="replaceable"><code>M</code></em> はデフォルトで 1 になります。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661463856752"></a> <a class="indexterm" name="idm45661463855248"></a> <code class="literal">VARBINARY(<em class="replaceable"><code>M</code></em>)</code>
          </p><p>
            <code class="literal">VARBINARY</code> 型は <code class="literal">VARCHAR</code> 型と似ていますが、非バイナリ文字列ではなく、バイナリバイト文字列を格納します。 <em class="replaceable"><code>M</code></em> はカラムの最大の長さをバイト数で表します。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661463846208"></a> <a class="indexterm" name="idm45661463844704"></a> <code class="literal">TINYBLOB</code>
          </p><p>
            最大長が 255 (2<sup>8</sup> − 1) バイトの <code class="literal">BLOB</code> カラム。 各 <code class="literal">TINYBLOB</code> 値は、値のバイト数を示す 1 バイト長のプリフィクスを使用して格納されます。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661463836064"></a> <a class="indexterm" name="idm45661463834560"></a> <code class="literal">TINYTEXT [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]</code>
          </p><p>
            最大長が 255 (2<sup>8</sup> − 1) 文字の <code class="literal">TEXT</code> カラム。 値にマルチバイト文字が含まれる場合、有効な最大長は少なくなります。 各 <code class="literal">TINYTEXT</code> 値は、値のバイト数を示す 1 バイト長のプリフィクスを使用して格納されます。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661463824576"></a> <a class="indexterm" name="idm45661463823104"></a> <code class="literal">BLOB[(<em class="replaceable"><code>M</code></em>)]</code>
          </p><p>
            最大長が 65,535 (2<sup>16</sup> − 1) バイトの <code class="literal">BLOB</code> カラム。 各 <code class="literal">BLOB</code> 値は、値のバイト数を示す 2 バイト長のプリフィクスを使用して格納されます。 
          </p><p>
            この型には、オプションの長さ <em class="replaceable"><code>M</code></em> を指定できます。 これが行われた場合、MySQL は <em class="replaceable"><code>M</code></em> バイトの長さの値を保持するのに十分な最小の <code class="literal">BLOB</code> 型としてカラムを作成します。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661463811424"></a> <a class="indexterm" name="idm45661463809952"></a> <code class="literal">TEXT[(<em class="replaceable"><code>M</code></em>)] [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]</code>
          </p><p>
            最大長が 65,535 (2<sup>16</sup> − 1) 文字の <code class="literal">TEXT</code> カラム。 値にマルチバイト文字が含まれる場合、有効な最大長は少なくなります。 各 <code class="literal">TEXT</code> 値は、値のバイト数を示す 2 バイト長のプリフィクスを使用して格納されます。 
          </p><p>
            この型には、オプションの長さ <em class="replaceable"><code>M</code></em> を指定できます。 これが行われた場合、MySQL は <em class="replaceable"><code>M</code></em> 文字の長さの値を保持するのに十分な最小 <code class="literal">TEXT</code> 型としてカラムを作成します。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661463797200"></a> <a class="indexterm" name="idm45661463795696"></a> <code class="literal">MEDIUMBLOB</code>
          </p><p>
            最大長が 16,777,215 (2<sup>24</sup> − 1) バイトの <code class="literal">BLOB</code> カラム。 各 <code class="literal">MEDIUMBLOB</code> 値は、値のバイト数を示す 3 バイト長のプリフィクスを使用して格納されます。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661463786992"></a> <a class="indexterm" name="idm45661463785488"></a> <code class="literal">MEDIUMTEXT [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]</code>
          </p><p>
            最大長が 16,777,215 (2<sup>24</sup> − 1) 文字の <code class="literal">TEXT</code> カラム。 値にマルチバイト文字が含まれる場合、有効な最大長は少なくなります。 各 <code class="literal">MEDIUMTEXT</code> 値は、値のバイト数を示す 3 バイト長のプリフィクスを使用して格納されます。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661463774800"></a> <a class="indexterm" name="idm45661463773296"></a> <code class="literal">LONGBLOB</code>
          </p><p>
            最大長が 4,294,967,295 または 4G バイト (2<sup>32</sup> − 1) バイトの <code class="literal">BLOB</code> カラム。 <code class="literal">LONGBLOB</code> カラムの有効な最大長は、クライアント/サーバープロトコルと使用可能なメモリー内の構成済み最大パケットサイズにより決まります。 各 <code class="literal">LONGBLOB</code> 値は、値のバイト数を示す 4 バイト長のプリフィクスを使用して格納されます。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661463763232"></a> <a class="indexterm" name="idm45661463761728"></a> <code class="literal">LONGTEXT [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]</code>
          </p><p>
            最大長が 4,294,967,295 または 4G バイト (2<sup>32</sup> − 1) 文字の <code class="literal">TEXT</code> カラム。 値にマルチバイト文字が含まれる場合、有効な最大長は少なくなります。 <code class="literal">LONGTEXT</code> カラムの有効な最大長もまた、クライアント/サーバープロトコルと使用可能メモリー内の構成済みの最大パケットサイズにより決まります。 各 <code class="literal">LONGTEXT</code> 値は、値のバイト数を示す 4 バイト長のプリフィクスを使用して格納されます。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661463749776"></a> <a class="indexterm" name="idm45661463748304"></a> <code class="literal">ENUM('<em class="replaceable"><code>value1</code></em>','<em class="replaceable"><code>value2</code></em>',...) [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]</code>
          </p><p>
            列挙です。 <code class="literal">'<em class="replaceable"><code>value1</code></em>'</code>、<code class="literal">'<em class="replaceable"><code>value2</code></em>'</code>、<code class="literal">...</code> の値、<code class="literal">NULL</code>、または特殊な <code class="literal">''</code> エラー値のリストから選択された値を 1 つだけを持つことができる文字列オブジェクトです。 <code class="literal">ENUM</code> 値は、内部では整数として表されます。 
          </p><p>
            <code class="literal">ENUM</code> カラムには、最大 65,535 個の個別の要素を含めることができます。
          </p><p>
            個々の <code class="literal">ENUM</code> 要素でサポートされる最大長は、<em class="replaceable"><code>M</code></em> &lt;= 255 および (<em class="replaceable"><code>M</code></em> x <em class="replaceable"><code>w</code></em>) &lt;= 1020 です。<code class="literal">M</code> は要素リテラルの長さ、<em class="replaceable"><code>w</code></em> は文字セットの最大長文字に必要なバイト数です。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661463729520"></a> <a class="indexterm" name="idm45661463728048"></a> <code class="literal">SET('<em class="replaceable"><code>value1</code></em>','<em class="replaceable"><code>value2</code></em>',...) [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]</code>
          </p><p>
            セットです。 ゼロ個以上の値を持つことができる文字列オブジェクトであり、そのそれぞれの値は、<code class="literal">'<em class="replaceable"><code>value1</code></em>'</code>、<code class="literal">'<em class="replaceable"><code>value2</code></em>'</code>、<code class="literal">...</code> 値のリストから選択する必要があります。<code class="literal">SET</code> 値は整数として内部で表されます。 
          </p><p>
            <code class="literal">SET</code> カラムには最大 64 個の個別のメンバーを含めることができます。
          </p><p>
            個々の <code class="literal">SET</code> 要素でサポートされる最大長は、<em class="replaceable"><code>M</code></em> &lt;= 255 および (<em class="replaceable"><code>M</code></em> x <em class="replaceable"><code>w</code></em>) &lt;= 1020 です。<code class="literal">M</code> は要素リテラルの長さ、<em class="replaceable"><code>w</code></em> は文字セットの最大長文字に必要なバイト数です。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="char"></a>11.3.2 CHAR および VARCHAR 型</h3></div></div></div><a class="indexterm" name="idm45661463711248"></a><a class="indexterm" name="idm45661463709232"></a><a class="indexterm" name="idm45661463707184"></a><p>
        <code class="literal">CHAR</code> 型と <code class="literal">VARCHAR</code> 型は似ていますが、格納および取得方法が異なります。 また、最大長と、末尾のスペースが保持されるかどうかという点でも異なります。 
      </p><p>
        <code class="literal">CHAR</code> 型と <code class="literal">VARCHAR</code> 型には、格納する最大文字数を表す長さが宣言されています。 たとえば、<code class="literal">CHAR(30)</code> には最大 30 文字を格納できます。 
      </p><p>
        <code class="literal">CHAR</code> カラムの長さは、テーブルを作成したときに宣言した長さに修正されます。 この長さには、0 から 255 までの任意の値を指定できます。 <code class="literal">CHAR</code> 値は格納されると、指定された長さになるように右側がスペースで埋められます。 <code class="literal">PAD_CHAR_TO_FULL_LENGTH</code> SQL モードが有効になっていないかぎり、<code class="literal">CHAR</code> 値が取り出されるときに、末尾のスペースが削除されます。 
      </p><p>
        <code class="literal">VARCHAR</code> カラム内の値は可変長の文字列です。 長さは 0 から 65,535 までの値で指定できます。 <code class="literal">VARCHAR</code> カラムの有効な最大長は、最大行サイズ (65,535 バイト、すべてのカラムで共有される) と使用される文字セットによって決まります。 <a class="xref" href="optimization.html#column-count-limit" title="8.4.7 テーブルカラム数と行サイズの制限">セクション8.4.7「テーブルカラム数と行サイズの制限」</a>を参照してください。 
      </p><p>
        <code class="literal">CHAR</code> とは対照的に、<code class="literal">VARCHAR</code> 値は、1 バイトまたは 2 バイト長のプリフィクスの付いたデータとして格納されます。 長さプリフィクスは、値に含まれるバイト数を示します。 255 バイト以下の値を格納するカラムでは 1 バイト長のプリフィクスを使用し、255 バイトよりも大きい値を格納するカラムでは 2 バイト長のプリフィクスを使用します。 
      </p><p>
        厳密な SQL モードが有効でない場合に、<code class="literal">CHAR</code> または <code class="literal">VARCHAR</code> カラムにその最大長を超える値を割り当てると、その値はカラムの最大長に合わせて切り捨てられ、警告メッセージが表示されます。 スペース以外の文字の切り捨てに関しては、厳密な SQL モードを使用することで、警告ではなくエラーを発生させて、その値の挿入を抑制できます。 <a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a>を参照してください。 
      </p><p>
        <code class="literal">VARCHAR</code> カラムの場合、使用している SQL モードに関係なく、カラム長を超える末尾のスペースは挿入前に切り捨てられ、警告メッセージが表示されます。 <code class="literal">CHAR</code> カラムの場合、SQL モードに関係なく、超過した末尾のスペースは通知なしに挿入される値から切り捨てられます。 
      </p><p>
        <code class="literal">VARCHAR</code> 値は格納されるときに埋められません。 標準 SQL に従い、値を格納し取り出すときに末尾のスペースは保持されます。 
      </p><p>
        次の表は、<code class="literal">CHAR(4)</code> カラムと <code class="literal">VARCHAR(4)</code> カラムにさまざまな文字列値を格納した結果を表示して、<code class="literal">CHAR</code> と <code class="literal">VARCHAR</code> の違いを示しています (カラムには <code class="literal">latin1</code> などのシングルバイト文字セットを使用するものとします)。
      </p><div class="informaltable"><table summary="Illustration of the difference between CHAR and VARCHAR storage requirements by showing the required storage for various string values in CHAR(4) and VARCHAR(4) columns."><col style="width: 15%"><col style="width: 15%"><col style="width: 20%"><col style="width: 15%"><col style="width: 20%"><thead><tr>
            <th scope="col">値</th>
            <th scope="col"><code class="literal">CHAR(4)</code></th>
            <th scope="col">必要なストレージ</th>
            <th scope="col"><code class="literal">VARCHAR(4)</code></th>
            <th scope="col">必要なストレージ</th>
          </tr></thead><tbody><tr>
            <th scope="row"><code class="literal">''</code></th>
            <td><code class="literal">' '</code></td>
            <td>4 バイト</td>
            <td><code class="literal">''</code></td>
            <td>1 バイト</td>
          </tr><tr>
            <th scope="row"><code class="literal">'ab'</code></th>
            <td><code class="literal">'ab  '</code></td>
            <td>4 バイト</td>
            <td><code class="literal">'ab'</code></td>
            <td>3 バイト</td>
          </tr><tr>
            <th scope="row"><code class="literal">'abcd'</code></th>
            <td><code class="literal">'abcd'</code></td>
            <td>4 バイト</td>
            <td><code class="literal">'abcd'</code></td>
            <td>5 バイト</td>
          </tr><tr>
            <th scope="row"><code class="literal">'abcdefgh'</code></th>
            <td><code class="literal">'abcd'</code></td>
            <td>4 バイト</td>
            <td><code class="literal">'abcd'</code></td>
            <td>5 バイト</td>
          </tr></tbody></table></div><p>
        テーブルの最後の行に格納されている値が<span class="emphasis"><em>厳密な SQL モードを使用していない場合のみ</em></span>を適用します。厳密モードが有効な場合、カラムの長さを超える値は<span class="emphasis"><em>保管されていません</em></span>であり、エラーが発生します。
      </p><p>
        <code class="literal">InnoDB</code> では、768 バイト以上の固定長フィールドが可変長フィールドとしてエンコードされ、オフページに格納できます。 たとえば、<code class="literal">utf8mb4</code> と同様に、文字セットの最大バイト長が 3 より大きい場合、<code class="literal">CHAR(255)</code> カラムは 768 バイトを超えることがあります。 
      </p><p>
        所定の値が <code class="literal">CHAR(4)</code> および <code class="literal">VARCHAR(4)</code> カラムに格納されると、取り出しのときに末尾のスペースが <code class="literal">CHAR</code> カラムから削除されるので、カラムから取り出された値は必ずしも同じではありません。 次の例はこの違いを示しています。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE vc (v VARCHAR(4), c CHAR(4));</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO vc VALUES ('ab  ', 'ab  ');</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;</code></strong>
+---------------------+---------------------+
| CONCAT('(', v, ')') | CONCAT('(', c, ')') |
+---------------------+---------------------+
| (ab  )              | (ab)                |
+---------------------+---------------------+
1 row in set (0.06 sec)
</pre><p>
        <code class="literal">CHAR</code>、<code class="literal">VARCHAR</code> および <code class="literal">TEXT</code> カラムの値は、カラムに割り当てられた文字セット照合に従ってソートおよび比較されます。
      </p><a class="indexterm" name="idm45661463626128"></a><a class="indexterm" name="idm45661463623984"></a><a class="indexterm" name="idm45661463622064"></a><a class="indexterm" name="idm45661463620544"></a><a class="indexterm" name="idm45661463618624"></a><p>
        MySQL 照合には、UCA 9.0.0 以上に基づく Unicode 照合以外の <code class="literal">PAD SPACE</code> のパッド属性があり、これには <code class="literal">NO PAD</code> のパッド属性があります。(<a class="xref" href="charset.html#charset-unicode-sets" title="10.10.1 Unicode 文字セット">セクション10.10.1「Unicode 文字セット」</a> を参照)。
      </p><p>
        照合のパッド属性を決定するには、<code class="literal">PAD_ATTRIBUTE</code> カラムを含む <code class="literal">INFORMATION_SCHEMA</code> <code class="literal">COLLATIONS</code> テーブルを使用します。
      </p><p>
        非バイナリ文字列 (<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code> および <code class="literal">TEXT</code> 値) の場合、文字列照合パッド属性によって、文字列の末尾にある末尾の空白の比較での処理が決定されます。 <code class="literal">NO PAD</code> 照合順序では、他の文字と同様に、比較で末尾のスペースが重要として扱われます。 <code class="literal">PAD SPACE</code> 照合順序では、比較で末尾のスペースは重要ではありません。文字列は末尾のスペースに関係なく比較されます。 <a class="xref" href="charset.html#charset-binary-collations-trailing-space-comparisons" title="比較での後続領域の処理">比較での後続領域の処理</a>を参照してください。 サーバーの SQL モードは、末尾の空白に関する比較動作には影響しません。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL の文字セットおよび照合順序の詳細は、<a class="xref" href="charset.html" title="第 10 章 文字セット、照合順序、Unicode">第10章「<i>文字セット、照合順序、Unicode</i>」</a>を参照してください。 ストレージ要件の追加情報については、<a class="xref" href="data-types.html#storage-requirements" title="11.7 データ型のストレージ要件">セクション11.7「データ型のストレージ要件」</a>を参照してください。 
        </p></div><p>
        後続パッド文字が削除または比較される場合、一意の値を必要とするインデックスがカラムにあると、後続パッド文字の数のみが異なるカラム値に挿入すると重複キーエラーが発生します。 たとえば、テーブルに <code class="literal">'a'</code> が含まれている場合、<code class="literal">'a '</code> を格納しようとすると、重複キーエラーが発生します。 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="binary-varbinary"></a>11.3.3 BINARY および VARBINARY 型</h3></div></div></div><a class="indexterm" name="idm45661463599440"></a><a class="indexterm" name="idm45661463598000"></a><a class="indexterm" name="idm45661463596608"></a><a class="indexterm" name="idm45661463594688"></a><p>
        <code class="literal">BINARY</code> および <code class="literal">VARBINARY</code> 型は、非バイナリ文字列ではなくバイナリ文字列を格納する点を除き、<code class="literal">CHAR</code> および <code class="literal">VARCHAR</code> と似ています。 つまり、文字列ではなくバイト文字列が格納されます。 これは、<code class="literal">binary</code> 文字セットと照合順序があり、比較とソートは値のバイトの数値に基づいていることを意味します。 
      </p><p>
        <code class="literal">BINARY</code> および <code class="literal">VARBINARY</code> の最大許容長は、<code class="literal">CHAR</code> および <code class="literal">VARCHAR</code> の場合と同じですが、<code class="literal">BINARY</code> および <code class="literal">VARBINARY</code> の長さは文字ではなくバイト単位で測定されます。
      </p><p>
        <code class="literal">BINARY</code> および <code class="literal">VARBINARY</code> データ型は <code class="literal">CHAR BINARY</code> および <code class="literal">VARCHAR BINARY</code> データ型とは異なります。 後者の型は、<code class="literal">BINARY</code> 属性によってカラムがバイナリ文字列カラムとして扱われることはありません。 代わりに、カラム文字セット (またはカラム文字セットが指定されていない場合はテーブルのデフォルト文字セット) のバイナリ (<code class="literal">_bin</code>) 照合順序が使用され、カラム自体にバイナリバイト文字列ではなく非バイナリ文字列が格納されます。 たとえば、デフォルトの文字セットが <code class="literal">utf8mb4</code> の場合、<code class="literal">CHAR(5) BINARY</code> は <code class="literal">CHAR(5) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin</code> として扱われます。 これは、<code class="literal">binary</code> 文字セットおよび照合順序を持つ 5 バイトのバイナリ文字列を格納する <code class="literal">BINARY(5)</code> とは異なります。 <code class="literal">binary</code> 文字セットの <code class="literal">binary</code> 照合順序と非バイナリ文字セットの<code class="literal">_bin</code> 照合順序の違いについては、<a class="xref" href="charset.html#charset-binary-collations" title="10.8.5 バイナリ照合順序と_bin 照合順序">セクション10.8.5「バイナリ照合順序と_bin 照合順序」</a> を参照してください。 
      </p><p>
        厳密な SQL モードが有効でない場合に、<code class="literal">BINARY</code> または <code class="literal">VARBINARY</code> カラムにその最大長を超える値を割り当てると、その値はカラムの最大長に合わせて切り捨てられ、警告メッセージが表示されます。 切捨ての場合、(警告ではなく) エラーが発生し、値の挿入を抑制するには、厳密な SQL モードを使用します。 <a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a>を参照してください。 
      </p><p>
        <code class="literal">BINARY</code> 値は格納されると、特定の長さまで右側がパッド値で埋められます。 パッド値は <code class="literal">0x00</code> (ゼロバイト) です。 値は挿入のために <code class="literal">0x00</code> で右パディングされ、取得のために後続のバイトは削除されません。 <code class="literal">ORDER BY</code> および <code class="literal">DISTINCT</code> 操作を含むすべてのバイトが比較で重要です。<code class="literal">0x00</code> と領域の比較は異なり、<code class="literal">0x00</code> は領域の前にソートされます。 
      </p><p>
        例: <code class="literal">BINARY(3)</code> カラムの場合、<code class="literal">'a '</code> は挿入時に <code class="literal">'a \0'</code> になります。<code class="literal">'a\0'</code> は挿入時に <code class="literal">'a\0\0'</code> になります。 挿入された両方の値は変更されずに取得されます。 
      </p><p>
        <code class="literal">VARBINARY</code> の場合、挿入用のパディングはなく、取得用のバイトは削除されません。 <code class="literal">ORDER BY</code> および <code class="literal">DISTINCT</code> 操作を含むすべてのバイトが比較で重要です。<code class="literal">0x00</code> と領域の比較は異なり、<code class="literal">0x00</code> は領域の前にソートされます。 
      </p><p>
        後続パッドバイトが削除または比較される場合、それらは無視され、カラムに一意の値を必要とするインデックスがあると、後続パッドバイト数のみが異なるカラムに値を挿入すると重複キーエラーが発生します。 たとえば、テーブルに <code class="literal">'a'</code> が含まれている場合、<code class="literal">'a\0'</code> を格納しようとすると、重複キーエラーが発生します。 
      </p><p>
        バイナリデータの格納に <code class="literal">BINARY</code> データ型を使用する予定であり、取り出した値を格納した値とまったく同じにする必要がある場合は、先行のパディングと削除文字を考慮する必要があります。 次の例は、<code class="literal">BINARY</code> 値の <code class="literal">0x00</code> パディングによって、カラム値の比較がどのような影響を受けるかについて示しています。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t (c BINARY(3));</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO t SET c = 'a';</code></strong>
Query OK, 1 row affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>SELECT HEX(c), c = 'a', c = 'a\0\0' from t;</code></strong>
+--------+---------+-------------+
| HEX(c) | c = 'a' | c = 'a\0\0' |
+--------+---------+-------------+
| 610000 |       0 |           1 |
+--------+---------+-------------+
1 row in set (0.09 sec)
</pre><p>
        取り出される値を、パディングなしのストレージに指定した値と同じにする必要がある場合は、代わりに <code class="literal">VARBINARY</code> か、いずれかの <code class="literal">BLOB</code> データ型を使用することをお勧めします。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="blob"></a>11.3.4 BLOB 型と TEXT 型</h3></div></div></div><a class="indexterm" name="idm45661463536704"></a><a class="indexterm" name="idm45661463535232"></a><a class="indexterm" name="idm45661463533872"></a><a class="indexterm" name="idm45661463531952"></a><a class="indexterm" name="idm45661463529920"></a><a class="indexterm" name="idm45661463528448"></a><p>
        <code class="literal">BLOB</code> はさまざまな容量のデータを保持できる大きなバイナリオブジェクトです。 <code class="literal">BLOB</code> 型は、<code class="literal">TINYBLOB</code>、<code class="literal">BLOB</code>、<code class="literal">MEDIUMBLOB</code>、および <code class="literal">LONGBLOB</code> の 4 つがあります。 これらの違いは、保持できる値の最大長だけです。 <code class="literal">TEXT</code> 型は、<code class="literal">TINYTEXT</code>、<code class="literal">TEXT</code>、<code class="literal">MEDIUMTEXT</code>、および <code class="literal">LONGTEXT</code> の 4 つがあります。 これらは 4 つの <code class="literal">BLOB</code> 型に対応し、最大長とストレージ要件は同じです。 <a class="xref" href="data-types.html#storage-requirements" title="11.7 データ型のストレージ要件">セクション11.7「データ型のストレージ要件」</a>を参照してください。 
      </p><p>
        <code class="literal">BLOB</code> 値はバイナリ文字列 (バイトの文字列) として扱われます。 これらには <code class="literal">binary</code> 文字セットと照合順序があり、比較とソートはカラム値のバイトの数値に基づきます。 <code class="literal">TEXT</code> 値は非バイナリ文字列 (文字の文字列) として扱われます。 これらには <code class="literal">binary</code> 以外の文字セットがあり、値は文字セットの照合に基づいてソートおよび比較されます。 
      </p><p>
        厳密な SQL モードが有効でない場合に、<code class="literal">BLOB</code> または <code class="literal">TEXT</code> カラムにその最大長を超える値を割り当てると、その値はカラムの最大長に合わせて切り捨てられ、警告メッセージが表示されます。 スペース以外の文字の切り捨てに関しては、厳密な SQL モードを使用することで、警告ではなくエラーを発生させて、その値の挿入を抑制できます。 <a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a>を参照してください。 
      </p><p>
        <code class="literal">TEXT</code> カラムに挿入される値から、超過した末尾のスペースを切り捨てると、SQL モードには関係なく、常に警告が生成されます。
      </p><p>
        <code class="literal">TEXT</code> および <code class="literal">BLOB</code> カラムでは、挿入時にパディングは行われず、選択時にバイトは削除されません。
      </p><p>
        <code class="literal">TEXT</code> カラムにインデックスが設定されている場合、インデックスエントリの比較では末尾がスペースで埋められます。 つまり、インデックスに一意の値が必要な場合は、末尾のスペースの数のみが異なる値に対して重複キーエラーが発生します。 たとえば、テーブルに <code class="literal">'a'</code> が含まれている場合、<code class="literal">'a '</code> を格納しようとすると、重複キーエラーが発生します。 これは <code class="literal">BLOB</code> カラムには当てはまりません。 
      </p><p>
        ほとんどの点で、<code class="literal">BLOB</code> カラムを、任意の長さに設定できる <code class="literal">VARBINARY</code> カラムと見なすことができます。 同様に、<code class="literal">TEXT</code> カラムを <code class="literal">VARCHAR</code> カラムと見なすことができます。 <code class="literal">BLOB</code> と <code class="literal">TEXT</code> は、次の点で <code class="literal">VARBINARY</code> と <code class="literal">VARCHAR</code> とは異なっています。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">BLOB</code> と <code class="literal">TEXT</code> カラムのインデックスには、インデックスプリフィクス長を指定する必要があります。 <code class="literal">CHAR</code> と <code class="literal">VARCHAR</code> では、プリフィクス長はオプションです。 <a class="xref" href="optimization.html#column-indexes" title="8.3.5 カラムインデックス">セクション8.3.5「カラムインデックス」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661463486816"></a> <a class="indexterm" name="idm45661463484640"></a> <a class="indexterm" name="idm45661463482592"></a> <code class="literal">BLOB</code> および <code class="literal">TEXT</code> カラムに <code class="literal">DEFAULT</code> 値を含めることはできません。
          </p></li></ul></div><p>
        <code class="literal">BINARY</code> 属性を <code class="literal">TEXT</code> データ型とともに使用する場合、カラムにはカラム文字セットのバイナリ (<code class="literal">_bin</code>) 照合順序が割り当てられます。
      </p><p>
        <code class="literal">LONG</code> と <code class="literal">LONG VARCHAR</code> は <code class="literal">MEDIUMTEXT</code> データ型にマップします。 これは互換性機能です。 
      </p><p>
        MySQL Connector/ODBC は <code class="literal">BLOB</code> 値を <code class="literal">LONGVARBINARY</code> として、<code class="literal">TEXT</code> 値を <code class="literal">LONGVARCHAR</code> として定義します。
      </p><p>
        <code class="literal">BLOB</code> 値と <code class="literal">TEXT</code> 値は非常に長くなる可能性があるので、使用するときに次の制約が生じることがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ソート時には、カラムの <code class="literal">max_sort_length</code> バイトだけが使用されます。 <code class="literal">max_sort_length</code> のデフォルト値は 1024 です。 サーバーの起動時または実行時に、<code class="literal">max_sort_length</code> の値を増やすことによって、ソートまたはグループ化に影響するバイトを増やすことができます。 すべてのクライアントで <code class="literal">max_sort_length</code> セッション変数の値を変更できます。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET max_sort_length = 2000;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT id, comment FROM t</code></strong>
    -&gt; <strong class="userinput"><code>ORDER BY comment;</code></strong>
</pre></li><li class="listitem"><p>
            一時テーブルを使用して処理されるクエリーの結果に <code class="literal">BLOB</code> カラムまたは <code class="literal">TEXT</code> カラムのインスタンスがあると、<code class="literal">MEMORY</code> ストレージエンジンがこれらのデータ型をサポートしていないので、サーバーはメモリー内ではなくディスク上でテーブルを使用します (<a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4 MySQL での内部一時テーブルの使用">セクション8.4.4「MySQL での内部一時テーブルの使用」</a>を参照してください)。 ディスクの使用はパフォーマンスの低下を伴うので、クエリーの結果に <code class="literal">BLOB</code> カラムまたは <code class="literal">TEXT</code> カラムを含めるのは必要な場合に限定してください。 たとえば、<code class="literal">SELECT *</code> はすべてのカラムを選択するので使用しないでください。 
          </p></li><li class="listitem"><p>
            <code class="literal">BLOB</code> または <code class="literal">TEXT</code> オブジェクトの最大サイズはその型で決まりますが、クライアントとサーバー間で実際に送信できる最大値は、使用可能なメモリーの容量と通信バッファーのサイズで決まります。 <code class="literal">max_allowed_packet</code> 変数の値を変更することでメッセージバッファーサイズを変更できますが、サーバーとクライアントプログラムの両方で変更する必要があります。 たとえば、<span class="command"><strong>mysql</strong></span> と <span class="command"><strong>mysqldump</strong></span> のどちらを使用しても、クライアント側の <code class="literal">max_allowed_packet</code> 値を変更できます。 <a class="xref" href="server-administration.html#server-configuration" title="5.1.1 サーバーの構成">セクション5.1.1「サーバーの構成」</a>、<a class="xref" href="programs.html#mysql" title="4.5.1 mysql — MySQL コマンドラインクライアント">セクション4.5.1「mysql — MySQL コマンドラインクライアント」</a>、および<a class="xref" href="programs.html#mysqldump" title="4.5.4 mysqldump — データベースバックアッププログラム">セクション4.5.4「mysqldump — データベースバックアッププログラム」</a>を参照してください。 パケットサイズおよびソートしているデータオブジェクトのサイズを、ストレージ要件と比較することもできます。<a class="xref" href="data-types.html#storage-requirements" title="11.7 データ型のストレージ要件">セクション11.7「データ型のストレージ要件」</a>を参照してください。 
          </p></li></ul></div><p>
        <code class="literal">BLOB</code> 値または <code class="literal">TEXT</code> 値はそれぞれ、別々に割り当てられたオブジェクトによって内部的に表現されます。 これは、テーブルが開かれるときにカラムごとに一度ストレージが割り当てられる、ほかのすべてのデータ型と対照的です。 
      </p><p>
        メディアファイルなどのバイナリデータを <code class="literal">BLOB</code> または <code class="literal">TEXT</code> カラムに格納するほうがよい場合もあります。 このようなデータの処理には、MySQL の文字列操作関数が役立つことがあります。 <a class="xref" href="functions.html#string-functions" title="12.8 文字列関数および演算子">セクション12.8「文字列関数および演算子」</a>を参照してください。 セキュリティーなどの理由のために、通常は、アプリケーションユーザーに <code class="literal">FILE</code> 権限を与えるのではなく、アプリケーションコードを使用して実行することをお勧めします。 MySQL フォーラム (<a class="ulink" href="http://forums.mysql.com/" target="_top">http://forums.mysql.com/</a>) では、さまざまな言語やプラットフォームの詳細について話し合うことができます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="enum"></a>11.3.5 ENUM 型</h3></div></div></div><a class="indexterm" name="idm45661463432192"></a><a class="indexterm" name="idm45661463430720"></a><p>
        <code class="literal">ENUM</code> は、テーブル作成時にカラム仕様に明示的に列挙された、許可されている値のリストから選択された値を持つ文字列オブジェクトです。
      </p><p>
        <code class="literal">ENUM</code> 型の構文および長さの制限については、<a class="xref" href="data-types.html#string-type-syntax" title="11.3.1 文字列データ型の構文">セクション11.3.1「文字列データ型の構文」</a> を参照してください。
      </p><p>
        <code class="literal">ENUM</code> タイプには、次の利点があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            指定可能な値のセットがカラムで制限されている状況でのコンパクトなデータストレージ。 入力値として指定した文字列は自動的に数値としてエンコードされます。 <code class="literal">ENUM</code> タイプの記憶域要件については、<a class="xref" href="data-types.html#storage-requirements" title="11.7 データ型のストレージ要件">セクション11.7「データ型のストレージ要件」</a> を参照してください。 
          </p></li><li class="listitem"><p>
            読みやすいクエリーと出力。 数値は、クエリー結果で対応する文字列に戻されます。 
          </p></li></ul></div><p>
        また、次のような考慮が必要な問題が生じる可能性があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="xref" href="data-types.html#enum-limits" title="列挙の制限">列挙の制限</a>で説明しているように、数値のように見える列挙値を作成した場合、リテラル値とその内部インデックス番号を混同しやすくなります。
          </p></li><li class="listitem"><p>
            <a class="xref" href="data-types.html#enum-sorting" title="列挙のソート">列挙のソート</a>で説明しているように、<code class="literal">ORDER BY</code> 句で <code class="literal">ENUM</code> カラムを使用するには特に注意が必要です。
          </p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="data-types.html#enum-using" title="ENUM カラムの作成と使用">ENUM カラムの作成と使用</a></p></li><li class="listitem"><p><a class="xref" href="data-types.html#enum-indexes" title="列挙リテラルのインデックス値">列挙リテラルのインデックス値</a></p></li><li class="listitem"><p><a class="xref" href="data-types.html#enum-literals" title="列挙リテラルの処理">列挙リテラルの処理</a></p></li><li class="listitem"><p><a class="xref" href="data-types.html#enum-nulls" title="空または NULL の列挙値">空または NULL の列挙値</a></p></li><li class="listitem"><p><a class="xref" href="data-types.html#enum-sorting" title="列挙のソート">列挙のソート</a></p></li><li class="listitem"><p><a class="xref" href="data-types.html#enum-limits" title="列挙の制限">列挙の制限</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="enum-using"></a>ENUM カラムの作成と使用</h4></div></div></div><p>
          列挙値は引用符で囲んだ文字列リテラルにする必要があります。 たとえば、次のように <code class="literal">ENUM</code> カラムを持つテーブルを作成できます。 
        </p><pre class="programlisting">CREATE TABLE shirts (
    name VARCHAR(40),
    size ENUM('x-small', 'small', 'medium', 'large', 'x-large')
);
INSERT INTO shirts (name, size) VALUES ('dress shirt','large'), ('t-shirt','medium'),
  ('polo shirt','small');
SELECT name, size FROM shirts WHERE size = 'medium';
+---------+--------+
| name    | size   |
+---------+--------+
| t-shirt | medium |
+---------+--------+
UPDATE shirts SET size = 'small' WHERE size = 'large';
COMMIT;
</pre><p>
          <code class="literal">'medium'</code> の値を持つ 100 万個の行をこのテーブルに挿入するには、100 万バイトのストレージが必要ですが、実際の文字列 <code class="literal">'medium'</code> を <code class="literal">VARCHAR</code> カラムに格納した場合は、600 万バイト必要になります。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="enum-indexes"></a>列挙リテラルのインデックス値</h4></div></div></div><p>
          それぞれの列挙値にはインデックスが設定されています。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              カラム仕様にリストされている要素には、1 から始まるインデックス番号が割り当てられています。
            </p></li><li class="listitem"><p>
              空の文字列エラー値のインデックス値は 0 です。 つまり、次の <code class="literal">SELECT</code> ステートメントを使用して、無効な <code class="literal">ENUM</code> 値が割り当てられた行を検索できます。 
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>enum_col</code></em>=0;</code></strong>
</pre></li><li class="listitem"><p>
              <code class="literal">NULL</code> 値のインデックスは <code class="literal">NULL</code> です。
            </p></li><li class="listitem"><p>
              ここでの<span class="quote">「<span class="quote">インデックス</span>」</span>という語は、列挙値のリスト内での位置を示します。 これは、テーブルインデックスとはまったく関係ありません。 
            </p></li></ul></div><p>
          たとえば、<code class="literal">ENUM('Mercury', 'Venus', 'Earth')</code> と指定されたカラムには、次に示すどの値でも含めることができます。 それぞれの値のインデックスも示しています。 
        </p><div class="informaltable"><table summary="Possible values for a column specified as ENUM('Mercury', 'Venus', 'Earth'). The table also shows the index of each value."><col style="width: 15%"><col style="width: 15%"><thead><tr>
              <th>値</th>
              <th>インデックス</th>
            </tr></thead><tbody><tr>
              <td><code class="literal">NULL</code></td>
              <td><code class="literal">NULL</code></td>
            </tr><tr>
              <td><code class="literal">''</code></td>
              <td>0</td>
            </tr><tr>
              <td><code class="literal">'Mercury'</code></td>
              <td>1</td>
            </tr><tr>
              <td><code class="literal">'Venus'</code></td>
              <td>2</td>
            </tr><tr>
              <td><code class="literal">'Earth'</code></td>
              <td>3</td>
            </tr></tbody></table></div><p>
          <code class="literal">ENUM</code> カラムには、最大 65,535 個の個別の要素を含めることができます。
        </p><p>
          <code class="literal">ENUM</code> 値を数値コンテキストで取得した場合、カラム値のインデックスが返されます。 たとえば、次のように <code class="literal">ENUM</code> カラムから数値を取得できます。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT <em class="replaceable"><code>enum_col</code></em>+0 FROM <em class="replaceable"><code>tbl_name</code></em>;</code></strong>
</pre><p>
          数値引数を取る <code class="literal">SUM()</code> や <code class="literal">AVG()</code> などの関数は、必要に応じて引数を数値にキャストします。 <code class="literal">ENUM</code> 値の計算にはインデックス番号が使用されます。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="enum-literals"></a>列挙リテラルの処理</h4></div></div></div><a class="indexterm" name="idm45661463356800"></a><p>
          テーブルが作成されるときに、テーブル定義内の <code class="literal">ENUM</code> メンバー値から末尾のスペースが自動的に削除されます。
        </p><p>
          <code class="literal">ENUM</code> カラムに格納された値は、取得されたときに、カラム定義で使用された大文字/小文字で表示されます。 <code class="literal">ENUM</code> カラムには文字セットと照合順序を割り当てられています。 バイナリ照合順序、または大文字と小文字を区別する照合順序の場合、カラムに値を割り当てるときに、大文字/小文字が考慮されます。 
        </p><p>
          <code class="literal">ENUM</code> カラムに数字を格納すると、その数字は指定可能な値のインデックスとして扱われ、格納された値がそのインデックスを持つ列挙メンバーとなります。 (ただし、これはすべての入力を文字列として扱う <code class="literal">LOAD DATA</code> では機能 <span class="emphasis"><em>しません</em></span>。) 数値が引用符で囲まれている場合、列挙値のリストに一致する文字列がなければ、そのままインデックスとして解釈されます。 これらの理由により、<code class="literal">ENUM</code> カラムを数字のように見える列挙値で定義することは、混乱を招きやすくなるのでお勧めできません。 たとえば、次のカラムには <code class="literal">'0'</code>、<code class="literal">'1'</code>、および <code class="literal">'2'</code> の文字列値を持つ列挙メンバーが指定されていますが、数値インデックス値は <code class="literal">1</code>、<code class="literal">2</code>、および <code class="literal">3</code> です。 
        </p><pre class="programlisting">numbers ENUM('0','1','2')
</pre><p>
          <code class="literal">2</code> を格納すると、それはインデックス値と解釈され、<code class="literal">'1'</code> (インデックス 2 の値) になります。 <code class="literal">'2'</code> を格納すると、それは列挙値と一致するので、<code class="literal">'2'</code> として格納されます。 <code class="literal">'3'</code> を格納すると、どの列挙値とも一致しないのでインデックスとして扱われ、<code class="literal">'2'</code> (インデックス 3 の値) になります。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO t (numbers) VALUES(2),('2'),('3');</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM t;</code></strong>
+---------+
| numbers |
+---------+
| 1       |
| 2       |
| 2       |
+---------+
</pre><p>
          <code class="literal">ENUM</code> カラムのすべての指定可能な値を特定するには、<code class="literal">SHOW COLUMNS FROM <em class="replaceable"><code>tbl_name</code></em> LIKE '<em class="replaceable"><code>enum_col</code></em>'</code> を使用して、出力の <code class="literal">Type</code> カラム内の <code class="literal">ENUM</code> 定義を構文解析します。
        </p><p>
          C API では、<code class="literal">ENUM</code> 値は文字列として返されます。 結果セットのメタデータを使用してこれらをほかの文字列から区別する方法については、<a class="ulink" href="https://dev.mysql.com/doc/c-api/8.0/en/c-api-data-structures.html" target="_top">C API Basic Data Structures</a>を参照してください。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="enum-nulls"></a>空または NULL の列挙値</h4></div></div></div><p>
          以下のような特定の状況下では、列挙値は、空の文字列 (<code class="literal">''</code>) や <code class="literal">NULL</code> になることもあります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">ENUM</code> に無効な値 (つまり、許可された値のリストに存在しない文字列) を挿入すると、特殊なエラー値として空の文字列が代わりに挿入されます。 この文字列は、この文字列に 0 の数値が含まれていることで、<span class="quote">「<span class="quote">通常</span>」</span>の空の文字列と区別できます。 列挙値の数値インデックスの詳細は、<a class="xref" href="data-types.html#enum-indexes" title="列挙リテラルのインデックス値">列挙リテラルのインデックス値</a>を参照してください。 
            </p><p>
              厳密な SQL モードが有効な場合は、無効な <code class="literal">ENUM</code> 値を挿入しようとするとエラーが発生します。
            </p></li><li class="listitem"><p>
              <code class="literal">ENUM</code> カラムが <code class="literal">NULL</code> を許可するように宣言されている場合、<code class="literal">NULL</code> 値は、そのカラムに対して有効な値であり、デフォルト値は <code class="literal">NULL</code> になります。 <code class="literal">ENUM</code> カラムが <code class="literal">NOT NULL</code> として宣言されている場合、デフォルト値は許可されている値のリストの最初の要素になります。 
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="enum-sorting"></a>列挙のソート</h4></div></div></div><p>
          <code class="literal">ENUM</code> 値は、インデックス番号に基づいてソートされますが、この数値は、カラム仕様で列挙メンバーがリストされていた順序に従います。 たとえば、<code class="literal">ENUM('b', 'a')</code> の場合、<code class="literal">'b'</code> は <code class="literal">'a'</code> の前にソートされます。 空の文字列は空ではない文字列の前にソートされ、<code class="literal">NULL</code> 値はその他のすべての列挙値の前にソートされます。 
        </p><p>
          <code class="literal">ENUM</code> カラムで <code class="literal">ORDER BY</code> 句の使用時に予想外の結果になることを回避するには、次のいずれかの手法を使用します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              アルファベット順で <code class="literal">ENUM</code> リストを指定します。
            </p></li><li class="listitem"><p>
              <code class="literal">ORDER BY CAST(<em class="replaceable"><code>col</code></em> AS CHAR)</code> または <code class="literal">ORDER BY CONCAT(<em class="replaceable"><code>col</code></em>)</code> をコード化することにより、カラムがインデックス番号ではなく、辞書順でソートされることを確認します。
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="enum-limits"></a>列挙の制限</h4></div></div></div><p>
          列挙値は、文字列値に評価されるものであっても、式にはできません。
        </p><p>
          たとえば、次の <code class="literal">CREATE TABLE</code> ステートメントは、<code class="literal">CONCAT</code> 関数を列挙値の構築に使用できないので、機能<span class="emphasis"><em>しません</em></span>。
        </p><pre class="programlisting">CREATE TABLE sizes (
    size ENUM('small', CONCAT('med','ium'), 'large')
);
</pre><p>
          ユーザー変数を列挙値として使用することもできません。 次のステートメントのペアは機能<span class="emphasis"><em>しません</em></span>。 
        </p><pre class="programlisting">SET @mysize = 'medium';

CREATE TABLE sizes (
    size ENUM('small', @mysize, 'large')
);
</pre><p>
          数字を列挙値として使用<span class="emphasis"><em>しない</em></span>ことを強くお勧めします。これは、適切な <code class="literal">TINYINT</code> または <code class="literal">SMALLINT</code> 型よりもストレージを節約するわけでもなく、<code class="literal">ENUM</code> 値を間違って引用符で囲んだ場合には、文字列とベースになる数値とを混同しやすくなる (同じでない場合もあります) からです。 数字を列挙値として使用する場合は、必ず引用符で囲んでください。 引用符を省略した場合は、その数字はインデックスと見なされます。 <a class="xref" href="data-types.html#enum-literals" title="列挙リテラルの処理">列挙リテラルの処理</a>を参照して、引用符で囲まれた数字でも間違って数字のインデックス値として使用されるか場合について確認してください。 
        </p><p>
          定義の中に重複した値が含まれていると、警告 (厳密な SQL モードが有効になっている場合はエラー) が発生します。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="set"></a>11.3.6 SET 型</h3></div></div></div><a class="indexterm" name="idm45661463284000"></a><a class="indexterm" name="idm45661463282528"></a><p>
        <code class="literal">SET</code> は、ゼロ以上の値を取ることができる文字列オブジェクトであり、それぞれの値は、テーブルの作成時に指定された許可される値のリストから選択する必要があります。 <code class="literal">SET</code> カラム値が複数のセットメンバーで構成される場合は、各メンバーはカンマ (<code class="literal">,</code>) で区切って指定されます。 このため、<code class="literal">SET</code> メンバーの値自体にはカンマを含めないでください。 
      </p><p>
        たとえば、<code class="literal">SET('one', 'two') NOT NULL</code> として指定したカラムは、次に示す値のいずれかを取ります。
      </p><pre class="programlisting">''
'one'
'two'
'one,two'
</pre><p>
        <code class="literal">SET</code> カラムには最大 64 個の個別のメンバーを含めることができます。
      </p><p>
        定義の中に重複した値が含まれていると、警告 (厳密な SQL モードが有効になっている場合はエラー) が発生します。
      </p><a class="indexterm" name="idm45661463272048"></a><p>
        テーブルが作成されるときに、テーブル定義内の <code class="literal">SET</code> メンバー値から末尾のスペースが自動的に削除されます。
      </p><p>
        <code class="literal">SET</code> タイプの記憶域要件については、<a class="xref" href="data-types.html#data-types-storage-reqs-strings" title="文字列型の格納要件">文字列型の格納要件</a> を参照してください。
      </p><p>
        <code class="literal">SET</code> 型の構文および長さの制限については、<a class="xref" href="data-types.html#string-type-syntax" title="11.3.1 文字列データ型の構文">セクション11.3.1「文字列データ型の構文」</a> を参照してください。
      </p><p>
        <code class="literal">SET</code> カラムに格納された値は、取得されるときに、カラム定義で使用されていた大文字/小文字で表示されます。 <code class="literal">SET</code> カラムには、文字セットと照合順序を割り当てることができます。 バイナリ照合順序、または大文字と小文字を区別する照合順序の場合、カラムに値を割り当てるときに、大文字/小文字が考慮されます。 
      </p><p>
        MySQL は、最初のセットメンバーに対応する格納値の低位ビットを使用して <code class="literal">SET</code> 値を数値で格納します。 <code class="literal">SET</code> 値を数値コンテキストで取得した場合、その取得された値には、カラム値を構成するセットメンバーに対応するビットセットが含まれます。 たとえば、次のように <code class="literal">SET</code> カラムから数値を取得できます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT <em class="replaceable"><code>set_col</code></em>+0 FROM <em class="replaceable"><code>tbl_name</code></em>;</code></strong>
</pre><p>
        メンバーが <code class="literal">SET</code> カラムに格納されると、その数字のバイナリ表現に設定されているビットからカラム値のセットメンバーが特定されます。 カラムが <code class="literal">SET('a','b','c','d')</code> として指定されている場合、セットメンバーは次の 10 進値と 2 進値を持ちます。 
      </p><div class="informaltable"><table summary="Decimal and binary values for members of a column specified as SET('a','b','c','d')."><col style="width: 15%"><col style="width: 20%"><col style="width: 20%"><thead><tr>
            <th scope="col"><code class="literal">SET</code> メンバー</th>
            <th scope="col">10 進値</th>
            <th scope="col">2 進値</th>
          </tr></thead><tbody><tr>
            <th scope="row"><code class="literal">'a'</code></th>
            <td><code class="literal">1</code></td>
            <td><code class="literal">0001</code></td>
          </tr><tr>
            <th scope="row"><code class="literal">'b'</code></th>
            <td><code class="literal">2</code></td>
            <td><code class="literal">0010</code></td>
          </tr><tr>
            <th scope="row"><code class="literal">'c'</code></th>
            <td><code class="literal">4</code></td>
            <td><code class="literal">0100</code></td>
          </tr><tr>
            <th scope="row"><code class="literal">'d'</code></th>
            <td><code class="literal">8</code></td>
            <td><code class="literal">1000</code></td>
          </tr></tbody></table></div><p>
        このカラムに <code class="literal">9</code> の値を割り当てた場合、2 進数では <code class="literal">1001</code> となるため、<code class="literal">SET</code> 値の最初と 4 番目のメンバーである <code class="literal">'a'</code> と <code class="literal">'d'</code> が選択され、結果として得られる値は <code class="literal">'a,d'</code> になります。
      </p><p>
        1 つ以上の <code class="literal">SET</code> 要素を含む値には、値を挿入するときに要素がどの順序でリストされているかは関係ありません。 また、所定の要素が値の中で何回リストされているかも関係ありません。 あとから値を取得するときに、値内のそれぞれの要素は、テーブル作成時に指定された順序に従って、一度表示されます。 カラムが <code class="literal">SET('a','b','c','d')</code> として指定されているとします: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE myset (col SET('a', 'b', 'c', 'd'));</code></strong>
</pre><p>
        <code class="literal">'a,d'</code>、<code class="literal">'d,a'</code>、<code class="literal">'a,d,d'</code>、<code class="literal">'a,d,a'</code>、および <code class="literal">'d,a,d'</code> の値を挿入した場合、
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO myset (col) VALUES </code></strong>
-&gt; ('a,d'), ('d,a'), ('a,d,a'), ('a,d,d'), ('d,a,d');
Query OK, 5 rows affected (0.01 sec)
Records: 5  Duplicates: 0  Warnings: 0
</pre><p>
        これらの値はすべて、取得されるときに <code class="literal">'a,d'</code> と表示されます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT col FROM myset;</code></strong>
+------+
| col  |
+------+
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
+------+
5 rows in set (0.04 sec)
</pre><p>
        サポートされていない値に <code class="literal">SET</code> カラムを設定すると、その値は無視され警告が表示されます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO myset (col) VALUES ('a,d,d,s');</code></strong>
Query OK, 1 row affected, 1 warning (0.03 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+---------+------+------------------------------------------+
| Level   | Code | Message                                  |
+---------+------+------------------------------------------+
| Warning | 1265 | Data truncated for column 'col' at row 1 |
+---------+------+------------------------------------------+
1 row in set (0.04 sec)

mysql&gt; <strong class="userinput"><code>SELECT col FROM myset;</code></strong>
+------+
| col  |
+------+
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
+------+
6 rows in set (0.01 sec)
</pre><p>
        厳密な SQL モードが有効な場合、無効な <code class="literal">SET</code> 値を挿入しようとするとエラーが発生します。
      </p><p>
        <code class="literal">SET</code> 値は数値でソートされます。 <code class="literal">NULL</code> 値は非 <code class="literal">NULL</code> <code class="literal">SET</code> 値の前にソートされます。 
      </p><p>
        数値引数を取る <code class="literal">SUM()</code> や <code class="literal">AVG()</code> などの関数は、必要に応じて引数を数値にキャストします。 <code class="literal">SET</code> 値の場合は、キャスト操作によって数値が使用されます。 
      </p><p>
        通常は、<code class="literal">FIND_IN_SET()</code> 関数か <code class="literal">LIKE</code> 演算子を使用して <code class="literal">SET</code> 値を検索します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE FIND_IN_SET('<em class="replaceable"><code>value</code></em>',<em class="replaceable"><code>set_col</code></em>)&gt;0;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>set_col</code></em> LIKE '%<em class="replaceable"><code>value</code></em>%';</code></strong>
</pre><p>
        最初のステートメントは <em class="replaceable"><code>set_col</code></em> が <em class="replaceable"><code>value</code></em> セットメンバーを含む行を見つけます。 2 番目も似ていますが、同じではありません。ほかのセットメンバーの部分文字列としてであっても、<em class="replaceable"><code>set_col</code></em> が <em class="replaceable"><code>value</code></em> を含む行を見つけます。 
      </p><p>
        次のステートメントも使用できます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>set_col</code></em> &amp; 1;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>set_col</code></em> = '<em class="replaceable"><code>val1</code></em>,<em class="replaceable"><code>val2</code></em>';</code></strong>
</pre><p>
        これらのうち最初のステートメントが最初のセットメンバーを含む値を探します。 2 番目のステートメントは正確に一致する値を探します。 2 番目の型は慎重に比較してください。 セット値を <code class="literal">'<em class="replaceable"><code>val1</code></em>,<em class="replaceable"><code>val2</code></em>'</code> と比較すると、値を <code class="literal">'<em class="replaceable"><code>val2</code></em>,<em class="replaceable"><code>val1</code></em>'</code> と比較した場合とは異なる結果が返されます。 カラム定義にリストされている順序どおりに値を指定する必要があります。 
      </p><p>
        <code class="literal">SET</code> カラムの指定可能な値をすべて特定するには、<code class="literal">SHOW COLUMNS FROM <em class="replaceable"><code>tbl_name</code></em> LIKE <em class="replaceable"><code>set_col</code></em></code> を使用して、出力の <code class="literal">Type</code> カラム内の <code class="literal">SET</code> 定義を構文解析します。
      </p><p>
        C API では、<code class="literal">SET</code> 値は文字列として返されます。 結果セットのメタデータを使用してこれらをほかの文字列から区別する方法については、<a class="ulink" href="https://dev.mysql.com/doc/c-api/8.0/en/c-api-data-structures.html" target="_top">C API Basic Data Structures</a>を参照してください。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spatial-types"></a>11.4 空間データ型</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="data-types.html#spatial-type-overview">11.4.1 空間データ型</a></span></dt><dt><span class="section"><a href="data-types.html#opengis-geometry-model">11.4.2 OpenGIS ジオメトリモデル</a></span></dt><dt><span class="section"><a href="data-types.html#gis-data-formats">11.4.3 サポートされる空間データ形式</a></span></dt><dt><span class="section"><a href="data-types.html#geometry-well-formedness-validity">11.4.4 ジオメトリの整形式と妥当性</a></span></dt><dt><span class="section"><a href="data-types.html#spatial-reference-systems">11.4.5 空間参照システムのサポート</a></span></dt><dt><span class="section"><a href="data-types.html#creating-spatial-columns">11.4.6 空間カラムの作成</a></span></dt><dt><span class="section"><a href="data-types.html#populating-spatial-columns">11.4.7 空間カラムへのデータ移入</a></span></dt><dt><span class="section"><a href="data-types.html#fetching-spatial-data">11.4.8 空間データのフェッチ</a></span></dt><dt><span class="section"><a href="data-types.html#optimizing-spatial-analysis">11.4.9 空間分析の最適化</a></span></dt><dt><span class="section"><a href="data-types.html#creating-spatial-indexes">11.4.10 空間インデックスの作成</a></span></dt><dt><span class="section"><a href="data-types.html#using-spatial-indexes">11.4.11 空間インデックスの使用</a></span></dt></dl></div><a class="indexterm" name="idm45661463167632"></a><a class="indexterm" name="idm45661463166160"></a><a class="indexterm" name="idm45661463164768"></a><a class="indexterm" name="idm45661463163808"></a><a class="indexterm" name="idm45661463162720"></a><a class="indexterm" name="idm45661463161600"></a><p>
      <a class="ulink" href="http://www.opengeospatial.org" target="_top">Open Geospatial Consortium</a> (OGC) は、公開されている概念ソリューションの開発に参加している 250 を超える企業、機関および大学の国際コンソーシアムであり、空間データを管理するあらゆる種類のアプリケーションで役立ちます。
    </p><p>
      空間データをサポートするように SQL RDBMS を拡張するための複数の概念的な方法を提案したドキュメントとして、Open Geospatial Consortium から「<em class="citetitle">OpenGIS® Implementation Standard for Geographic information - Simple feature access - Part 2: SQL option</em>」が発行されています。 この仕様は、OGC の web サイト (<a class="ulink" href="http://www.opengeospatial.org/standards/sfs" target="_top">http://www.opengeospatial.org/standards/sfs</a>) から入手できます。 
    </p><p>
      MySQL は、OGC の仕様書に従って、<span class="bold"><strong>ジオメトリ型を含む SQL</strong></span> 環境のサブセットとして空間拡張を実装しています。 この用語は、一連のジオメトリ型で拡張された SQL 環境を意味しています。 ジオメトリ値を含む SQL カラムは、ジオメトリ型のカラムとして実装されています。 仕様書では、一連の SQL ジオメトリ型のほか、ジオメトリ値を作成し分析するためにこれらの型に対して行われる関数について説明しています。 
    </p><p>
      MySQL 空間拡張により、地理的特性の生成、ストレージ、および分析が可能になります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          空間値を表すデータ型
        </p></li><li class="listitem"><p>
          空間値を操作する関数
        </p></li><li class="listitem"><p>
          空間カラムへのアクセス時間を改善するための空間インデックス設定
        </p></li></ul></div><p>
      空間データ型および空間関数は、<code class="literal">MyISAM</code>, <code class="literal">InnoDB</code>, <code class="literal">NDB</code> テーブルおよび <code class="literal">ARCHIVE</code> テーブルで使用できます。 空間カラムのインデックス付けの場合、<code class="literal">MyISAM</code> および <code class="literal">InnoDB</code> では <code class="literal">SPATIAL</code> インデックスと <code class="literal">SPATIAL</code> 以外のインデックスの両方がサポートされます。 その他のストレージエンジンは、<a class="xref" href="sql-statements.html#create-index" title="13.1.15 CREATE INDEX ステートメント">セクション13.1.15「CREATE INDEX ステートメント」</a>で説明しているように、非 <code class="literal">SPATIAL</code> インデックスをサポートします。 
    </p><a class="indexterm" name="idm45661463140768"></a><p>
      <span class="bold"><strong>地理的特性</strong></span>とは、位置を特定できる世界中のあらゆるもののことです。 特性は次のいずれかになります。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          実体。 山、池、都市など。 
        </p></li><li class="listitem"><p>
          領域。 町の区域や熱帯地域など。 
        </p></li><li class="listitem"><p>
          定義可能な位置。 2 つの道路が交差する特定の場所となる交差点など。 
        </p></li></ul></div><a class="indexterm" name="idm45661463134976"></a><p>
      ドキュメントによっては、<span class="bold"><strong>地理空間特性</strong></span>という用語を地理的特性の意味で使用している場合もあります。
    </p><a class="indexterm" name="idm45661463132336"></a><p>
      <span class="bold"><strong>ジオメトリ</strong></span>も地理的特性を表す用語です。 <span class="bold"><strong>ジオメトリ</strong></span>という用語はもともと、地球の測量を意味していました。 地図作成者が世界のマッピングに使用するジオメトリ特性を指す別の意味は、地図作成の分野からのものです。 
    </p><p>
      ここでの説明では、<span class="bold"><strong>地理的特性</strong></span>、<span class="bold"><strong>地理空間特性</strong></span>、<span class="bold"><strong>特性</strong></span>、<span class="bold"><strong>ジオメトリ</strong></span>の用語をシノニムと見なします。 もっともよく使用される用語は<span class="bold"><strong>ジオメトリ</strong></span>であり、<span class="emphasis"><em>位置を特定できる世界中のあらゆるものを表す点または点の集合</em></span>として定義されています。 
    </p><p>
      次の資料では次のトピックを取り上げます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          MySQL モデルに実装された空間データ型
        </p></li><li class="listitem"><p>
          OpenGIS ジオメトリモデルでの空間拡張の基本
        </p></li><li class="listitem"><p>
          空間データを表現するためのデータ形式
        </p></li><li class="listitem"><p>
          MySQL で空間データを使用する方法
        </p></li><li class="listitem"><p>
          空間データのインデックスの使用方法
        </p></li><li class="listitem"><p>
          OpenGIS 仕様と MySQL 実装との差異
        </p></li></ul></div><p>
      空間データを演算する関数の詳細は、<a class="xref" href="functions.html#spatial-analysis-functions" title="12.17 空間分析関数">セクション12.17「空間分析関数」</a>を参照してください。
    </p><h3><a name="idm45661463116272"></a>追加のリソース</h3><p>
      空間操作の MySQL 実装では、次の標準が重要です:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          SQL/MM パート 3: Spatial.
        </p></li><li class="listitem"><p>
          <a class="ulink" href="http://www.opengeospatial.org" target="_top">Open Geospatial Consortium</a> は、空間データをサポートするために SQL RDBMS を拡張するいくつかの概念的な方法を提案するドキュメントである <em class="citetitle">OpenGIS® Implementation Standard for Geographic information</em> を公開します。 特定の簡易機能アクセスを参照してください - パート 1: 共通アーキテクチャおよび単純な機能アクセス - パート 2: SQL オプション。 Open Geospatial Consortium (OGC) は、<a class="ulink" href="http://www.opengeospatial.org/" target="_top">http://www.opengeospatial.org/</a> の web サイトを管理します。 仕様書は <a class="ulink" href="http://www.opengeospatial.org/standards/sfs" target="_top">http://www.opengeospatial.org/standards/sfs</a> で入手できます。 ここでの資料に関連した追加情報が用意されています。 
        </p></li><li class="listitem"><p>
          <a class="link" href="data-types.html#spatial-reference-systems" title="11.4.5 空間参照システムのサポート">spatial reference system</a> (SRS) 定義の文法は、<em class="citetitle">「OpenGIS 実装仕様: 座標変換サービス」</em>, Revision 1.00、OGC 01-009, January 12, 2001, Section 7.2 で定義されている文法に基づいています。 この仕様は、<a class="ulink" href="http://www.opengeospatial.org/standards/ct" target="_top">http://www.opengeospatial.org/standards/ct</a> で入手できます。 MySQL に実装されている SRS 定義の仕様との相違点については、<a class="xref" href="sql-statements.html#create-spatial-reference-system" title="13.1.19 CREATE SPATIAL REFERENCE SYSTEM ステートメント">セクション13.1.19「CREATE SPATIAL REFERENCE SYSTEM ステートメント」</a> を参照してください。 
        </p></li></ul></div><p>
      MySQL に対する空間拡張の使用について質問や関心がある場合は、GIS フォーラム (<a class="ulink" href="https://forums.mysql.com/list.php?23" target="_top">https://forums.mysql.com/list.php?23</a>) で議論できます。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="spatial-type-overview"></a>11.4.1 空間データ型</h3></div></div></div><a class="indexterm" name="idm45661463102864"></a><a class="indexterm" name="idm45661463101360"></a><a class="indexterm" name="idm45661463100000"></a><a class="indexterm" name="idm45661463098608"></a><a class="indexterm" name="idm45661463097232"></a><a class="indexterm" name="idm45661463095840"></a><a class="indexterm" name="idm45661463094432"></a><a class="indexterm" name="idm45661463093040"></a><a class="indexterm" name="idm45661463091632"></a><a class="indexterm" name="idm45661463089712"></a><a class="indexterm" name="idm45661463087680"></a><a class="indexterm" name="idm45661463085648"></a><a class="indexterm" name="idm45661463083616"></a><a class="indexterm" name="idm45661463081584"></a><a class="indexterm" name="idm45661463079552"></a><a class="indexterm" name="idm45661463077520"></a><a class="indexterm" name="idm45661463075488"></a><a class="indexterm" name="idm45661463073328"></a><p>
        MySQL には、OpenGIS クラスに対応する空間データ型があります。 これらのタイプの基礎は、<a class="xref" href="data-types.html#opengis-geometry-model" title="11.4.2 OpenGIS ジオメトリモデル">セクション11.4.2「OpenGIS ジオメトリモデル」</a> で説明されています。 
      </p><p>
        空間データ型の中には、単一のジオメトリ値を保持するものがあります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">GEOMETRY</code>
          </p></li><li class="listitem"><p>
            <code class="literal">POINT</code>
          </p></li><li class="listitem"><p>
            <code class="literal">LINESTRING</code>
          </p></li><li class="listitem"><p>
            <code class="literal">POLYGON</code>
          </p></li></ul></div><p>
        <code class="literal">GEOMETRY</code> にはどの型のジオメトリ値でも格納できます。 その他の単一値型 (<code class="literal">POINT</code>、<code class="literal">LINESTRING</code>、および <code class="literal">POLYGON</code>) では、特定のジオメトリ型に値が制限されます。 
      </p><p>
        他の空間データ型には、次の値のコレクションが保持されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">MULTIPOINT</code>
          </p></li><li class="listitem"><p>
            <code class="literal">MULTILINESTRING</code>
          </p></li><li class="listitem"><p>
            <code class="literal">MULTIPOLYGON</code>
          </p></li><li class="listitem"><p>
            <code class="literal">GEOMETRYCOLLECTION</code>
          </p></li></ul></div><p>
        <code class="literal">GEOMETRYCOLLECTION</code> には、任意の型のオブジェクトのコレクションを格納できます。 他のコレクション型 (<code class="literal">MULTIPOINT</code>、<code class="literal">MULTILINESTRING</code> および <code class="literal">MULTIPOLYGON</code>) では、コレクションメンバーは特定のジオメトリタイプを持つメンバーに制限されます。 
      </p><p>
        例: 任意のジオメトリタイプの値を格納できる <code class="literal">g</code> という名前のカラムを持つ <code class="literal">geom</code> という名前のテーブルを作成するには、次のステートメントを使用します:
      </p><pre class="programlisting">CREATE TABLE geom (g GEOMETRY);
</pre><p>
        空間データ型のカラムには、カラムに格納されている値の空間参照システム (SRS) を明示的に示す <code class="literal">SRID</code> 属性を指定できます。 例: 
      </p><pre class="programlisting">CREATE TABLE geom (
    p POINT SRID 0,
    g GEOMETRY NOT NULL SRID 4326
);
</pre><p>
        <code class="literal">SPATIAL</code> インデックスは、<code class="literal">NOT NULL</code> で特定の SRID を持つ空間カラムに作成できるため、そのカラムをインデックス付けする場合は、<code class="literal">NOT NULL</code> および <code class="literal">SRID</code> 属性を使用して宣言します:
      </p><pre class="programlisting">CREATE TABLE geom (g GEOMETRY NOT NULL SRID 4326);
</pre><p>
        <code class="literal">InnoDB</code> テーブルでは、デカルトおよび地理的 SRS の <code class="literal">SRID</code> 値が許可されます。 <code class="literal">MyISAM</code> テーブルでは、デカルト SRS の <code class="literal">SRID</code> 値が許可されます。 
      </p><p>
        <code class="literal">SRID</code> 属性を使用すると、空間カラム SRID が制限され、次のような影響があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            カラムには、指定した SRID の値のみを含めることができます。 SRID が異なる値を挿入しようとすると、エラーが発生します。 
          </p></li><li class="listitem"><p>
            オプティマイザは、カラムにつけられた <code class="literal">SPATIAL</code> インデックスを使用できます。 <a class="xref" href="optimization.html#spatial-index-optimization" title="8.3.3 SPATIAL インデックス最適化">セクション8.3.3「SPATIAL インデックス最適化」</a>を参照してください。 
          </p></li></ul></div><p>
        <code class="literal">SRID</code> 属性のない空間カラムは、SRID に制限されず、SRID の値を受け入れます。 ただし、オプティマイザは、カラム定義が <code class="literal">SRID</code> 属性を含むように変更されるまで、<code class="literal">SPATIAL</code> インデックスを使用できません。これには、すべての値が同じ SRID を持つように、最初にカラムの内容を変更する必要がある場合があります。 
      </p><p>
        MySQL で空間データ型を使用する方法を示すその他の例は、<a class="xref" href="data-types.html#creating-spatial-columns" title="11.4.6 空間カラムの作成">セクション11.4.6「空間カラムの作成」</a> を参照してください。 空間参照システムの詳細は、<a class="xref" href="data-types.html#spatial-reference-systems" title="11.4.5 空間参照システムのサポート">セクション11.4.5「空間参照システムのサポート」</a> を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="opengis-geometry-model"></a>11.4.2 OpenGIS ジオメトリモデル</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="data-types.html#gis-geometry-class-hierarchy">11.4.2.1 ジオメトリクラスの階層</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-geometry">11.4.2.2 Geometry クラス</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-point">11.4.2.3 Point クラス</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-curve">11.4.2.4 Curve クラス</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-linestring">11.4.2.5 LineString クラス</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-surface">11.4.2.6 Surface クラス</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-polygon">11.4.2.7 Polygon クラス</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-geometrycollection">11.4.2.8 GeometryCollection クラス</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-multipoint">11.4.2.9 MultiPoint クラス</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-multicurve">11.4.2.10 MultiCurve クラス</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-multilinestring">11.4.2.11 MultiLineString クラス</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-multisurface">11.4.2.12 MultiSurface クラス</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-multipolygon">11.4.2.13 MultiPolygon クラス</a></span></dt></dl></div><p>
        OGC の<span class="bold"><strong>ジオメトリ型を含む SQL</strong></span> 環境で提案されている一連のジオメトリ型は、<span class="bold"><strong>OpenGIS ジオメトリモデル</strong></span>に基づいています。 このモデルの各ジオメトリオブジェクトには、次のような一般的なプロパティーがあります。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            オブジェクトが定義されている座標空間を記述する空間参照システムに関連付けられます。
          </p></li><li class="listitem"><p>
            特定のジオメトリクラスに属しています。
          </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-geometry-class-hierarchy"></a>11.4.2.1 ジオメトリクラスの階層</h4></div></div></div><p>
          ジオメトリクラスの階層は次のように定義されています。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">Geometry</code> (インスタンス化不可能)
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">Point</code> (インスタンス化可能)
                </p></li><li class="listitem"><p>
                  <code class="literal">Curve</code> (インスタンス化不可能)
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                      <code class="literal">LineString</code> (インスタンス化可能)
                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                          <code class="literal">Line</code>
                        </p></li><li class="listitem"><p>
                          <code class="literal">LinearRing</code>
                        </p></li></ul></div></li></ul></div></li><li class="listitem"><p>
                  <code class="literal">Surface</code> (インスタンス化不可能)
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                      <code class="literal">Polygon</code> (インスタンス化可能)
                    </p></li></ul></div></li><li class="listitem"><p>
                  <code class="literal">GeometryCollection</code> (インスタンス化可能)
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                      <code class="literal">MultiPoint</code> (インスタンス化可能)
                    </p></li><li class="listitem"><p>
                      <code class="literal">MultiCurve</code> (インスタンス化不可能)
                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                          <code class="literal">MultiLineString</code> (インスタンス化可能)
                        </p></li></ul></div></li><li class="listitem"><p>
                      <code class="literal">MultiSurface</code> (インスタンス化不可能)
                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                          <code class="literal">MultiPolygon</code> (インスタンス化可能)
                        </p></li></ul></div></li></ul></div></li></ul></div></li></ul></div><p>
          インスタンス化不可能なクラスのオブジェクトは作成できません。 インスタンス化可能なクラスのオブジェクトは作成できます。 どのクラスもプロパティーを持ちますが、インスタンス化可能なクラスはさらに表明 (有効なクラスインスタンスを定義するルール) も持つことができます。 
        </p><p>
          <code class="literal">Geometry</code> は基本クラスです。 これは抽象クラスです。 <code class="literal">Geometry</code> のインスタンス化可能なサブクラスは、2 次元座標空間内に存在する 0 次元、1 次元、および 2 次元のジオメトリオブジェクトに限定されます。 インスタンス化可能なジオメトリクラスはすべて、ジオメトリクラスの有効なインスタンスが位相的に閉じている (つまり、定義されたすべてのジオメトリに境界が含まれる) ように定義されています。 
        </p><p>
          <code class="literal">Geometry</code> 基本クラスには、<code class="literal">Point</code>、<code class="literal">Curve</code>、<code class="literal">Surface</code>、および <code class="literal">GeometryCollection</code> のサブクラスがあります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">Point</code> は 0 次元のオブジェクトを表します。
            </p></li><li class="listitem"><p>
              <code class="literal">Curve</code> は 1 次元のオブジェクトを表し、そのサブクラス <code class="literal">LineString</code> は、<code class="literal">Line</code> と <code class="literal">LinearRing</code> をサブクラスに持ちます。
            </p></li><li class="listitem"><p>
              <code class="literal">Surface</code> は 2 次元のオブジェクト用に設計されたもので、<code class="literal">Polygon</code> をサブクラスに持ちます。
            </p></li><li class="listitem"><p>
              <code class="literal">GeometryCollection</code> には <code class="literal">MultiPoint</code>、<code class="literal">MultiLineString</code>、<code class="literal">MultiPolygon</code> という 0、1、2 次元の特殊化コレクションクラスが用意されており、それぞれ <code class="literal">Points</code>、<code class="literal">LineStrings</code>、<code class="literal">Polygons</code> のコレクションに対応するジオメトリをモデル化しています。 <code class="literal">MultiCurve</code> と <code class="literal">MultiSurface</code> は、このコレクションインタフェースを汎化して <code class="literal">Curves</code> および <code class="literal">Surfaces</code> を処理できるよう抽象スーパークラスとして導入されたものです。 
            </p></li></ul></div><p>
          <code class="literal">Geometry</code>、<code class="literal">Curve</code>、<code class="literal">Surface</code>、<code class="literal">MultiCurve</code>、および <code class="literal">MultiSurface</code> は、インスタンス化不可能なクラスとして定義されています。 これらはサブクラスに共通する一連のメソッドを定義しており、今後の拡張に含められます。 
        </p><p>
          <code class="literal">Point</code>、<code class="literal">LineString</code>、<code class="literal">Polygon</code>、<code class="literal">GeometryCollection</code>、<code class="literal">MultiPoint</code>、<code class="literal">MultiLineString</code>、および <code class="literal">MultiPolygon</code> はインスタンス化可能なクラスです。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-geometry"></a>11.4.2.2 Geometry クラス</h4></div></div></div><p>
          <code class="literal">Geometry</code> は階層のルートクラスです。 これはインスタンス化不可能なクラスですが、次のリストに説明しているように、<code class="literal">Geometry</code> サブクラスのいずれかから作成したすべてのジオメトリ値に共通である多数のプロパティーがあります。 個々のサブクラスも独自のプロパティーを備えていますが、これについては後述します。 
        </p><p>
          <span class="bold"><strong>Geometry のプロパティー</strong></span>
        </p><p>
          ジオメトリ値に含まれるプロパティーは次のとおりです。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              その<span class="bold"><strong>型</strong></span>。 各ジオメトリは、階層内のインスタンス化可能クラスのいずれかに属します。 
            </p></li><li class="listitem"><p>
              <span class="bold"><strong>SRID</strong></span> または空間参照識別子。 この値は、ジオメトリオブジェクトが定義されている座標空間を記述する空間参照システムに関連付けられているジオメトリを識別します。 
            </p><p>
              MySQL の SRID 値は、ジオメトリ値に関連付けられた整数です。 使用可能な SRID の最大値は 2<sup>32</sup>−1 です。 より大きな値が指定されると、低位の 32 ビットだけが使用されます。 
            </p><p>
              SRID 0 は、軸に単位が割り当てられていない無限平坦なデカルト平面を表します。 SRID 0 の動作を保証するには、SRID 0 を使用してジオメトリ値を作成します。 SRID 0 は、SRID が指定されていない場合の新しいジオメトリ値のデフォルトです。 
            </p><p>
              複数のジオメトリ値の計算では、すべての値が同じ SRID を持つ必要があり、そうでない場合はエラーが発生します。
            </p></li><li class="listitem"><p>
              空間参照システムでの<span class="bold"><strong>座標</strong></span>で、倍精度 (8 バイト) 数値で表されます。 空でないジオメトリには必ず、(X,Y) 座標ペアが少なくとも 1 つ含まれます。 空のジオメトリには座標は含まれません。 
            </p><p>
              座標は SRID に対する相対的なものです。 たとえば、座標系が異なると、<span class="bold"><strong>平面</strong></span>座標系上の距離と<span class="bold"><strong>測地</strong></span>システム上の距離 (地球表面上の座標) が異なるため、オブジェクトが同じ座標を持つ場合でも、2 つのオブジェクト間の距離が異なる場合があります。 
            </p></li><li class="listitem"><p>
              <span class="bold"><strong>内部</strong></span>、<span class="bold"><strong>境界</strong></span>、<span class="bold"><strong>外部</strong></span>。
            </p><p>
              ジオメトリは必ず、ある位置の領域を占有します。 ジオメトリの外部とは、そのジオメトリによって占有されていないすべての領域のことです。 内部とは、そのジオメトリによって占有されている領域のことです。 境界とは、ジオメトリの内部と外部が接する部分のことです。 
            </p></li><li class="listitem"><p>
              その <span class="bold"><strong>MBR</strong></span> (最小境界矩形)、またはエンベロープ。 これは範囲を規定するジオメトリであり、次のように最小および最大の (X,Y) 座標から形成されます。 
            </p><pre class="programlisting">((MINX MINY, MAXX MINY, MAXX MAXY, MINX MAXY, MINX MINY))
</pre></li><li class="listitem"><p>
              値が<span class="bold"><strong>単純である</strong></span>、<span class="bold"><strong>単純でない</strong></span>のいずれであるか。 <code class="literal">LineString</code>、<code class="literal">MultiPoint</code>、<code class="literal">MultiLineString</code> の型のジオメトリ値は「単純である」、「単純でない」のいずれかになります。 「単純である」、「単純でない」のいずれであるかの表明は、型ごとに決定されます。 
            </p></li><li class="listitem"><p>
              値が<span class="bold"><strong>閉じている</strong></span>、<span class="bold"><strong>閉じていない</strong></span>のいずれであるか。 <code class="literal">LineString</code>、<code class="literal">MultiString</code> の型のジオメトリ値は「閉じている」「閉じていない」のいずれかになります。 「閉じている」、「閉じていない」のいずれであるかの表明は、型ごとに決定されます。 
            </p></li><li class="listitem"><p>
              値が<span class="bold"><strong>空である</strong></span>、<span class="bold"><strong>空でない</strong></span>のいずれであるか。点を 1 つも含まないジオメトリは空です。 空のジオメトリの外部、内部、および境界は定義されていません (つまり、それらは <code class="literal">NULL</code> 値で表されます)。 空のジオメトリは、常に単純で面積が 0 になるように定義されています。 
            </p></li><li class="listitem"><p>
              その<span class="bold"><strong>次元</strong></span>。 ジオメトリには −1、0、1、または 2 の次元があります。 
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  −1 は、空のジオメトリを表します。
                </p></li><li class="listitem"><p>
                  0 は長さも面積も持たないジオメトリを表します。
                </p></li><li class="listitem"><p>
                  1 は、長さがゼロ以外で面積がゼロのジオメトリを表します。
                </p></li><li class="listitem"><p>
                  2 は、面積がゼロ以外のジオメトリを表します。
                </p></li></ul></div><p>
              <code class="literal">Point</code> オブジェクトの次元は 0 です。 <code class="literal">LineString</code> オブジェクトの次元は 1 です。 <code class="literal">Polygon</code> オブジェクトの次元は 2 です。 <code class="literal">MultiPoint</code>、<code class="literal">MultiLineString</code>、および <code class="literal">MultiPolygon</code> オブジェクトの次元は、構成要素の次元と同じになります。 
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-point"></a>11.4.2.3 Point クラス</h4></div></div></div><p>
          <code class="literal">Point</code> は、座標空間内の単一の位置を表すジオメトリです。
        </p><p>
          <span class="bold"><strong><code class="literal">Point</code> の例</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              多数の都市を含む大規模な世界地図を想像してください。 <code class="literal">Point</code> オブジェクトは各都市を表すことができます。 
            </p></li><li class="listitem"><p>
              市内地図で、<code class="literal">Point</code> オブジェクトはバス停を表すことができます。
            </p></li></ul></div><p>
          <span class="bold"><strong><code class="literal">Point</code> のプロパティー</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              X 座標値。
            </p></li><li class="listitem"><p>
              Y 座標値。
            </p></li><li class="listitem"><p>
              <code class="literal">Point</code> は 0 次元のジオメトリとして定義されています。
            </p></li><li class="listitem"><p>
              <code class="literal">Point</code> の境界は空セットになります。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-curve"></a>11.4.2.4 Curve クラス</h4></div></div></div><p>
          <code class="literal">Curve</code> は 1 次元のジオメトリであり、通常は一連の点で表されます。 点の間の補間方法は、<code class="literal">Curve</code> の特定のサブクラスで定義されています。 <code class="literal">Curve</code> はインスタンス化不可能なクラスです。 
        </p><p>
          <span class="bold"><strong><code class="literal">Curve</code> のプロパティー</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">Curve</code> はその点の座標を持ちます。
            </p></li><li class="listitem"><p>
              <code class="literal">Curve</code> は 1 次元のジオメトリとして定義されています。
            </p></li><li class="listitem"><p>
              <code class="literal">Curve</code> は、同じポイントを 2 回通過しない場合は単純ですが、開始ポイントと終了ポイントが同じ場合でも曲線は単純になります。
            </p></li><li class="listitem"><p>
              始点と終点が等しい場合、<code class="literal">Curve</code> は閉じています。
            </p></li><li class="listitem"><p>
              閉じた <code class="literal">Curve</code> の境界は、空になります。
            </p></li><li class="listitem"><p>
              閉じていない <code class="literal">Curve</code> の境界は、その 2 つの端点から構成されます。
            </p></li><li class="listitem"><p>
              単純で閉じた <code class="literal">Curve</code> としては、<code class="literal">LinearRing</code> が挙げられます。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-linestring"></a>11.4.2.5 LineString クラス</h4></div></div></div><p>
          <code class="literal">LineString</code> は、点の間を直線で補間した <code class="literal">Curve</code> です。
        </p><p>
          <span class="bold"><strong><code class="literal">LineString</code> の例</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              世界地図で、<code class="literal">LineString</code> オブジェクトは河川を表すことができます。
            </p></li><li class="listitem"><p>
              市内地図で、<code class="literal">LineString</code> オブジェクトは通りを表すことができます。
            </p></li></ul></div><p>
          <span class="bold"><strong><code class="literal">LineString</code> のプロパティー</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">LineString</code> は、隣り合う 1 対の点で定義される各線分の座標を持ちます。
            </p></li><li class="listitem"><p>
              ちょうど 2 つの点から構成されている場合、<code class="literal">LineString</code> は <code class="literal">Line</code> になります。
            </p></li><li class="listitem"><p>
              閉じていて、かつ単純である場合は、<code class="literal">LineString</code> は <code class="literal">LinearRing</code> になります。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-surface"></a>11.4.2.6 Surface クラス</h4></div></div></div><p>
          <code class="literal">Surface</code> は 2 次元のジオメトリです。 これはインスタンス化不可能なクラスです。 その唯一のインスタンス化可能なサブクラスは、<code class="literal">Polygon</code> です。 
        </p><p>
          <span class="bold"><strong><code class="literal">Surface</code> のプロパティー</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">Surface</code> は 2 次元のジオメトリとして定義されています。
            </p></li><li class="listitem"><p>
              OpenGIS 仕様では、単純な <code class="literal">Surface</code> が、1 個の外側の境界と 0 個以上の内側の境界に関連付けられた単一の<span class="quote">「<span class="quote">パッチ</span>」</span>からなるジオメトリとして定義されています。
            </p></li><li class="listitem"><p>
              単純な <code class="literal">Surface</code> の境界は、その外側と内側の境界に対応する一連の閉じた曲線になります。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-polygon"></a>11.4.2.7 Polygon クラス</h4></div></div></div><p>
          <code class="literal">Polygon</code> は、多辺のジオメトリを表す平面 <code class="literal">Surface</code> です。 これは 1 個の外側の境界と 0 個以上の内側の境界で定義されますが、それらの内側の各境界によって <code class="literal">Polygon</code> 内の 1 個の穴が定義されます。 
        </p><p>
          <span class="bold"><strong><code class="literal">Polygon</code> の例</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              地域マップで、<code class="literal">Polygon</code> オブジェクトは森林や区域などを表すことができます。
            </p></li></ul></div><p>
          <span class="bold"><strong><code class="literal">Polygon</code> の表明</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">Polygon</code> の境界は、外側と内側の境界を構成する一連の <code class="literal">LinearRing</code> オブジェクト (つまり、単純かつ閉じた <code class="literal">LineString</code> オブジェクト) から構成されます。
            </p></li><li class="listitem"><p>
              <code class="literal">Polygon</code> のリングは交差しません。 <code class="literal">Polygon</code> の境界に含まれるリングは、<code class="literal">Point</code> で交わりますが、接することしかできません。 
            </p></li><li class="listitem"><p>
              <code class="literal">Polygon</code> には線分、突起、亀裂は含まれません。
            </p></li><li class="listitem"><p>
              <code class="literal">Polygon</code> は、連続した点集合からなる内部を持ちます。
            </p></li><li class="listitem"><p>
              <code class="literal">Polygon</code> は穴を持つことができます。 穴のある <code class="literal">Polygon</code> の外部は、連続していません。 それぞれの穴が、連続した 1 つの外部コンポーネントを定義します。 
            </p></li></ul></div><p>
          以上の表明により、<code class="literal">Polygon</code> は単純なジオメトリになります。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-geometrycollection"></a>11.4.2.8 GeometryCollection クラス</h4></div></div></div><p>
          <code class="literal">GeomCollection</code> は、任意のクラスのゼロ個以上のジオメトリの集合であるジオメトリです。
        </p><p>
          <code class="literal">GeomCollection</code> と <code class="literal">GeometryCollection</code> は同義であり、<code class="literal">GeomCollection</code> を優先する型名とします。
        </p><p>
          ジオメトリコレクション内のすべての要素は、同じ空間参照システム (つまり、同じ座標系) 内にある必要があります。 ジオメトリコレクションの要素には他の制約はありませんが、次のセクションで説明する <code class="literal">GeomCollection</code> のサブクラスによってメンバーシップが制限される場合があります。 これらの制限は次の情報に基づくことがあります。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              要素の型 (たとえば、<code class="literal">MultiPoint</code> に格納できるのは <code class="literal">Point</code> 要素だけです)
            </p></li><li class="listitem"><p>
              次元
            </p></li><li class="listitem"><p>
              要素間の空間的な重なり具合に関する制約
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-multipoint"></a>11.4.2.9 MultiPoint クラス</h4></div></div></div><p>
          <code class="literal">MultiPoint</code> は、<code class="literal">Point</code> 要素から構成されるジオメトリコレクションです。 点の接続や順序付けは一切行われません。 
        </p><p>
          <span class="bold"><strong><code class="literal">MultiPoint</code> の例</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              世界地図で、<code class="literal">MultiPoint</code> は一連の小さな島々を表すことができます。
            </p></li><li class="listitem"><p>
              市内地図で、<code class="literal">MultiPoint</code> はチケットオフィスの系列店を表すことができます。
            </p></li></ul></div><p>
          <span class="bold"><strong><code class="literal">MultiPoint</code> のプロパティー</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">MultiPoint</code> は 0 次元のジオメトリです。
            </p></li><li class="listitem"><p>
              この 2 つの <code class="literal">Point</code> の値 (座標値) が等しくない場合は、<code class="literal">MultiPoint</code> は単純になります。
            </p></li><li class="listitem"><p>
              <code class="literal">MultiPoint</code> の境界は空セットになります。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-multicurve"></a>11.4.2.10 MultiCurve クラス</h4></div></div></div><p>
          <code class="literal">MultiCurve</code> は、<code class="literal">Curve</code> 要素から構成されるジオメトリコレクションです。 <code class="literal">MultiCurve</code> はインスタンス化不可能なクラスです。 
        </p><p>
          <span class="bold"><strong><code class="literal">MultiCurve</code> のプロパティー</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">MultiCurve</code> は 1 次元のジオメトリです。
            </p></li><li class="listitem"><p>
              <code class="literal">MultiCurve</code> が単純になるのは、そのすべての要素が単純である場合だけです。2 つの要素の唯一の交点は、両方の要素の境界上にある点になります。
            </p></li><li class="listitem"><p>
              <code class="literal">MultiCurve</code> 境界は、<span class="quote">「<span class="quote">「mod 2 共用体ルール」</span>」</span> (<span class="quote">「<span class="quote">「奇数偶数ルール」</span>」</span>とも呼ばれる) を適用することによって取得されます: ポイントが奇数の <code class="literal">Curve</code> 要素の境界内にある場合、そのポイントは <code class="literal">MultiCurve</code> の境界内にあります。
            </p></li><li class="listitem"><p>
              すべての要素が閉じている場合、<code class="literal">MultiCurve</code> は閉じています。
            </p></li><li class="listitem"><p>
              閉じた <code class="literal">MultiCurve</code> の境界は、常に空になります。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-multilinestring"></a>11.4.2.11 MultiLineString クラス</h4></div></div></div><p>
          <code class="literal">MultiLineString</code> は、<code class="literal">LineString</code> 要素から構成される <code class="literal">MultiCurve</code> ジオメトリコレクションです。
        </p><p>
          <span class="bold"><strong><code class="literal">MultiLineString</code> の例</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              地域マップで、<code class="literal">MultiLineString</code> は河川系や高速道路システムを表すことができます。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-multisurface"></a>11.4.2.12 MultiSurface クラス</h4></div></div></div><p>
          <code class="literal">MultiSurface</code> は、面要素から構成されるジオメトリコレクションです。 <code class="literal">MultiSurface</code> はインスタンス化不可能なクラスです。 その唯一のインスタンス化可能なサブクラスは、<code class="literal">MultiPolygon</code> です。 
        </p><p>
          <span class="bold"><strong><code class="literal">MultiSurface</code> の表明</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">MultiSurface</code> 内のサーフェスには、交差する内部がありません。
            </p></li><li class="listitem"><p>
              <code class="literal">MultiSurface</code> 内のサーフェスには、最大で有限のポイント数と交差する境界があります。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-multipolygon"></a>11.4.2.13 MultiPolygon クラス</h4></div></div></div><p>
          <code class="literal">MultiPolygon</code> は、<code class="literal">Polygon</code> 要素から構成される <code class="literal">MultiSurface</code> オブジェクトです。
        </p><p>
          <span class="bold"><strong><code class="literal">MultiPolygon</code> の例</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              地域マップで、<code class="literal">MultiPolygon</code> は湖の系列を表すことができます。
            </p></li></ul></div><p>
          <span class="bold"><strong><code class="literal">MultiPolygon</code> の表明</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">MultiPolygon</code> のどの 2 つの <code class="literal">Polygon</code> 要素も、交差する内部を持つことはありません。
            </p></li><li class="listitem"><p>
              <code class="literal">MultiPolygon</code> のどの 2 つの <code class="literal">Polygon</code> 要素も、交差したり (交差は 1 つ前の表明でも禁止されています)、無限個の点で接したりしません。
            </p></li><li class="listitem"><p>
              <code class="literal">MultiPolygon</code> にカットライン、突起、亀裂を含めることはできません。 <code class="literal">MultiPolygon</code> は通常の閉じた点集合です。 
            </p></li><li class="listitem"><p>
              複数の <code class="literal">Polygon</code> を含む <code class="literal">MultiPolygon</code> は、連続していない内部を持ちます。 <code class="literal">MultiPolygon</code> の連続する内部コンポーネントの個数は、<code class="literal">MultiPolygon</code> 内の <code class="literal">Polygon</code> 値の数と等しくなります。 
            </p></li></ul></div><p>
          <span class="bold"><strong><code class="literal">MultiPolygon</code> のプロパティー</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">MultiPolygon</code> は 2 次元のジオメトリです。
            </p></li><li class="listitem"><p>
              <code class="literal">MultiPolygon</code> の境界は、その <code class="literal">Polygon</code> 要素の境界に対応する一連の閉じた曲線 (<code class="literal">LineString</code> 値) になります。
            </p></li><li class="listitem"><p>
              <code class="literal">MultiPolygon</code> の境界に含まれる各 <code class="literal">Curve</code> は、どれか 1 つの <code class="literal">Polygon</code> 要素の境界にのみ含まれます。
            </p></li><li class="listitem"><p>
              <code class="literal">Polygon</code> 要素の境界に含まれる <code class="literal">Curve</code> は必ず、<code class="literal">MultiPolygon</code> の境界にも含まれます。
            </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gis-data-formats"></a>11.4.3 サポートされる空間データ形式</h3></div></div></div><p>
        クエリーでジオメトリオブジェクトを表現するために、次の 2 つの標準空間データ形式が使用されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            WKT (Well-Known Text) 形式
          </p></li><li class="listitem"><p>
            WKB (Well-Known Binary) 形式
          </p></li></ul></div><p>
        MySQL の内部では、WKT、WKB のどちらの形式とも異なる形式でジオメトリ値が格納されます。 (内部形式は WKB と似ていますが、SRID を示す最初の 4 バイトがあります。) 
      </p><p>
        異なるデータ形式間の変換に使用できる関数があります。<a class="xref" href="functions.html#gis-format-conversion-functions" title="12.17.6 ジオメトリ形式変換関数">セクション12.17.6「ジオメトリ形式変換関数」</a>を参照してください。
      </p><p>
        次の各セクションでは、MySQL で使用される空間データフォーマットについて説明します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="data-types.html#gis-wkt-format" title="WKT (Well-Known Text) 形式">WKT (Well-Known Text) 形式</a></p></li><li class="listitem"><p><a class="xref" href="data-types.html#gis-wkb-format" title="WKB (Well-Known Binary) 形式">WKB (Well-Known Binary) 形式</a></p></li><li class="listitem"><p><a class="xref" href="data-types.html#gis-internal-format" title="内部ジオメトリ記憶形式">内部ジオメトリ記憶形式</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="gis-wkt-format"></a>WKT (Well-Known Text) 形式</h4></div></div></div><a class="indexterm" name="idm45661462706064"></a><a class="indexterm" name="idm45661462703952"></a><a class="indexterm" name="idm45661462701856"></a><p>
          ジオメトリ値の WKT (Well-Known Text) 表現は、ASCII 形式のジオメトリデータを交換するために設計されています。 OpenGIS 仕様書には、WKT 値を書き込むための公式の運用ルールを指定するバッカス-ナウア記法が用意されています (<a class="xref" href="data-types.html#spatial-types" title="11.4 空間データ型">セクション11.4「空間データ型」</a>を参照してください)。 
        </p><p>
          ジオメトリオブジェクトの WKT 表現の例: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">Point</code>:
            </p><pre class="programlisting">POINT(15 20)
</pre><p>
              点の座標は、区切り用のカンマなしに指定されます。 これは、座標間にカンマを必要とする SQL <code class="literal">Point()</code> 関数の構文とは異なります。 特定の空間演算のコンテキストに適した構文を慎重に使用してください。 たとえば、次のステートメントはどちらも <code class="literal">ST_X()</code> を使用して <code class="literal">Point</code> オブジェクトから X 座標を抽出します。 最初の場合は、<code class="literal">Point()</code> 関数を直接使用してオブジェクトを生成します。 2 番目は、<code class="literal">ST_GeomFromText()</code> を使用して <code class="literal">Point</code> に変換された WKT 表現を使用します。 
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT ST_X(Point(15, 20));</code></strong>
+---------------------+
| ST_X(POINT(15, 20)) |
+---------------------+
|                  15 |
+---------------------+

mysql&gt; <strong class="userinput"><code>SELECT ST_X(ST_GeomFromText('POINT(15 20)'));</code></strong>
+---------------------------------------+
| ST_X(ST_GeomFromText('POINT(15 20)')) |
+---------------------------------------+
|                                    15 |
+---------------------------------------+
</pre></li><li class="listitem"><p>
              4 つの点を含む <code class="literal">LineString</code>:
            </p><pre class="programlisting">LINESTRING(0 0, 10 10, 20 25, 50 60)
</pre><p>
              点の座標のペアはカンマで区切られます。
            </p></li><li class="listitem"><p>
              外側のリングと内側のリングを 1 つずつ含む <code class="literal">Polygon</code>:
            </p><pre class="programlisting">POLYGON((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5))
</pre></li><li class="listitem"><p>
              3 つの <code class="literal">Point</code> 値を含む <code class="literal">MultiPoint</code>:
            </p><pre class="programlisting">MULTIPOINT(0 0, 20 20, 60 60)
</pre><p>
              <code class="literal">MultiPoint</code> 値の WKT 形式表現を受け入れる <code class="literal">ST_MPointFromText()</code> や <code class="literal">ST_GeomFromText()</code> などの空間関数では、値内の個々のポイントをカッコで囲むことができます。 たとえば、次の関数コールは両方とも有効です: 
            </p><pre class="programlisting">ST_MPointFromText('MULTIPOINT (1 1, 2 2, 3 3)')
ST_MPointFromText('MULTIPOINT ((1 1), (2 2), (3 3))')
</pre></li><li class="listitem"><p>
              2 つの <code class="literal">LineString</code> 値を含む <code class="literal">MultiLineString</code>:
            </p><pre class="programlisting">MULTILINESTRING((10 10, 20 20), (15 15, 30 15))
</pre></li><li class="listitem"><p>
              2 つの <code class="literal">Polygon</code> 値を含む <code class="literal">MultiPolygon</code>:
            </p><pre class="programlisting">MULTIPOLYGON(((0 0,10 0,10 10,0 10,0 0)),((5 5,7 5,7 7,5 7, 5 5)))
</pre></li><li class="listitem"><p>
              2 つの <code class="literal">Point</code> 値と 1 つの <code class="literal">LineString</code> から構成された <code class="literal">GeometryCollection</code>:
            </p><pre class="programlisting">GEOMETRYCOLLECTION(POINT(10 10), POINT(30 30), LINESTRING(15 15, 20 20))
</pre></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="gis-wkb-format"></a>WKB (Well-Known Binary) 形式</h4></div></div></div><a class="indexterm" name="idm45661462657008"></a><a class="indexterm" name="idm45661462654896"></a><a class="indexterm" name="idm45661462652800"></a><p>
          ジオメトリ値の WKB (Well-Known Binary) 表現は、ジオメトリ WKB 情報を含む <code class="literal">BLOB</code> 値によって表現されたバイナリストリームとしてジオメトリデータを交換するために使用されます。 この形式は、OpenGIS 仕様によって定義されています (<a class="xref" href="data-types.html#spatial-types" title="11.4 空間データ型">セクション11.4「空間データ型」</a>を参照してください)。 これはまた、ISO の <em class="citetitle">SQL/MM Part 3: Spatial</em> 標準でも定義されています。 
        </p><p>
          WKB は、1 バイトの符号なしの整数、4 バイトの符号なしの整数、および 8 バイトの倍精度数 (IEEE 754 形式) を使用します。 1 バイトは 8 ビットです。 
        </p><p>
          たとえば、<code class="literal">POINT(1 -1)</code> に対応する WKB 値は、21 バイトのシーケンスで構成され、それぞれが 2 桁の 16 進数で表されます:
        </p><pre class="programlisting">0101000000000000000000F03F000000000000F0BF
</pre><p>
          順序は、次のテーブルに示すコンポーネントで構成されます。
        </p><div class="table"><a name="wkb-components-example-table"></a><p class="title"><b>表 11.2 WKB コンポーネントの例</b></p><div class="table-contents"><table summary="Example showing component in WKB values."><col style="width: 30%"><col style="width: 30%"><col style="width: 40%"><thead><tr>
              <th scope="col">コンポーネント</th>
              <th scope="col">Size</th>
              <th scope="col">値</th>
            </tr></thead><tbody><tr>
              <th scope="row">バイト順</th>
              <td>1 バイト</td>
              <td><code class="literal">01</code></td>
            </tr><tr>
              <th scope="row">WKB タイプ</th>
              <td>4 バイト</td>
              <td><code class="literal">01000000</code></td>
            </tr><tr>
              <th scope="row">X 座標</th>
              <td>8 バイト</td>
              <td><code class="literal">000000000000F03F</code></td>
            </tr><tr>
              <th scope="row">Y 座標</th>
              <td>8 バイト</td>
              <td><code class="literal">000000000000F0BF</code></td>
            </tr></tbody></table></div></div><br class="table-break"><p>
          各コンポーネントが表す内容は次のとおりです。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              バイト順序インジケータは 1 または 0 で、リトルエンディアンまたはビッグエンディアンの記憶域を示します。 リトルエンディアンバイト順序、ビッグエンディアンバイト順序はそれぞれ NDR (Network Data Representation)、XDR (External Data Representation) とも呼ばれます。 
            </p></li><li class="listitem"><p>
              WKB 型はジオメトリ型を示すコードです。 MySQL は、1 から 7 までの値を使用して、<code class="literal">Point</code>, <code class="literal">LineString</code>, <code class="literal">Polygon</code>, <code class="literal">MultiPoint</code>, <code class="literal">MultiLineString</code>, <code class="literal">MultiPolygon</code> および <code class="literal">GeometryCollection</code> を示します。 
            </p></li><li class="listitem"><p>
              <code class="literal">Point</code> 値には X 座標と Y 座標が含まれますが、それぞれ倍精度値として表現されます。
            </p></li></ul></div><p>
          さらに複雑なジオメトリ値の WKB 値は、OpenGIS 仕様書に詳しく記されているように、より複雑なデータ構造になります。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="gis-internal-format"></a>内部ジオメトリ記憶形式</h4></div></div></div><a class="indexterm" name="idm45661462608256"></a><a class="indexterm" name="idm45661462606128"></a><p>
          MySQL では、SRID の後に WKB 表現の値が続くことを示す 4 バイトを使用してジオメトリ値が格納されます。 WKB 形式については、<a class="xref" href="data-types.html#gis-wkb-format" title="WKB (Well-Known Binary) 形式">WKB (Well-Known Binary) 形式</a>を参照してください。 
        </p><p>
          WKB 部分では、次の MySQL 固有の考慮事項が適用されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              MySQL ではジオメトリがリトルエンディアン値として格納されるため、バイト順序インジケータバイトは 1 です。
            </p></li><li class="listitem"><p>
              MySQL は、<code class="literal">Point</code>, <code class="literal">LineString</code>, <code class="literal">Polygon</code>, <code class="literal">MultiPoint</code>, <code class="literal">MultiLineString</code>, <code class="literal">MultiPolygon</code> および <code class="literal">GeometryCollection</code> のジオメトリタイプをサポートしています。 その他のジオメトリタイプはサポートされていません。 
            </p></li><li class="listitem"><p>
              空にできるのは <code class="literal">GeometryCollection</code> のみです。 このような値は 0 個の要素で格納されます。 
            </p></li><li class="listitem"><p>
              Polygon リングは時計回りと反時計回りの両方で指定できます。 MySQL は、データの読取り時にリングを自動的に反転します。 
            </p></li></ul></div><p>
          デカルト座標は空間参照システムの長さ単位で格納され、X 座標に X 値、Y 座標に Y 値が格納されます。 軸方向は、空間参照システムによって指定された方向です。 
        </p><p>
          地理座標は空間参照システムの角度単位で格納され、経度は X 座標に、緯度は Y 座標に格納されます。 軸方向と子午線は、空間参照システムによって指定された方向です。 
        </p><p>
          <code class="literal">LENGTH()</code> 関数は、値の格納に必要な領域をバイト単位で返します。 例: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET @g = ST_GeomFromText('POINT(1 -1)');</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT LENGTH(@g);</code></strong>
+------------+
| LENGTH(@g) |
+------------+
|         25 |
+------------+
mysql&gt; <strong class="userinput"><code>SELECT HEX(@g);</code></strong>
+----------------------------------------------------+
| HEX(@g)                                            |
+----------------------------------------------------+
| 000000000101000000000000000000F03F000000000000F0BF |
+----------------------------------------------------+
</pre><p>
          値の長さは 25 バイトで、次のコンポーネントで構成されます (16 進数値から確認できます):
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              SRID を示す整数 4 バイト (0)
            </p></li><li class="listitem"><p>
              バイトオーダーを示す整数 1 バイト (1 = リトルエンディアン)
            </p></li><li class="listitem"><p>
              型情報を示す整数 4 バイト (1 = <code class="literal">Point</code>)
            </p></li><li class="listitem"><p>
              X 座標を示す倍精度 8 バイト (1)
            </p></li><li class="listitem"><p>
              Y 座標を示す倍精度 8 バイト (−1)
            </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="geometry-well-formedness-validity"></a>11.4.4 ジオメトリの整形式と妥当性</h3></div></div></div><a class="indexterm" name="idm45661462576992"></a><a class="indexterm" name="idm45661462574832"></a><a class="indexterm" name="idm45661462572784"></a><a class="indexterm" name="idm45661462570752"></a><a class="indexterm" name="idm45661462568720"></a><a class="indexterm" name="idm45661462566672"></a><a class="indexterm" name="idm45661462564624"></a><a class="indexterm" name="idm45661462562592"></a><a class="indexterm" name="idm45661462560560"></a><a class="indexterm" name="idm45661462558512"></a><p>
        ジオメトリ値の場合、MySQL では、構文的に整形式の概念とジオメトリ学的に有効な概念が区別されます。
      </p><p>
        ジオメトリは、次の (完全でない) リストのような条件を満たす場合、構文的に整形式になります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            Linestring には少なくとも 2 つの点があります
          </p></li><li class="listitem"><p>
            Polygon に少なくとも 1 つのリングがあります
          </p></li><li class="listitem"><p>
            Polygon リングが閉じています (最初と最後のポイントが同じです)
          </p></li><li class="listitem"><p>
            Polygon リングには少なくとも 4 つの点があります (最小 polygon は最初と最後の点が同じ三角形です)
          </p></li><li class="listitem"><p>
            コレクションが空でない (<code class="literal">GeometryCollection</code> を除く)
          </p></li></ul></div><p>
        ジオメトリは、構文的に整形式で、次の (完全でない) リストのような条件を満たしている場合、ジオメトリ学的に有効です:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            Polygon が自己交差していません
          </p></li><li class="listitem"><p>
            Polygon 内部リングは外部リングの内側にあります
          </p></li><li class="listitem"><p>
            Multipolygons に重なり合う Polygon がありません
          </p></li></ul></div><p>
        ジオメトリが構文的に整形式でない場合、空間関数は失敗します。 WKT 値または WKB 値を解析する空間インポート関数では、構文的に整形式でないジオメトリを作成しようとするとエラーが発生します。 また、ジオメトリをテーブルに格納しようとする構文の整形式もチェックされます。 
      </p><p>
        ジオメトリ学的に無効なジオメトリの挿入、選択および更新は許可されますが、構文的に整形式である必要があります。 計算費用のため、MySQL はジオメトリ学的な有効性を明示的にチェックしません。 空間計算では、無効なジオメトリが検出されてエラーが発生する場合がありますが、無効性を検出せずに未定義の結果が返されることもあります。 地理的に有効なジオメトリを必要とするアプリケーションでは、<code class="literal">ST_IsValid()</code> 関数を使用してジオメトリをチェックする必要があります。 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="spatial-reference-systems"></a>11.4.5 空間参照システムのサポート</h3></div></div></div><p>
        空間データの空間参照システム (SRS) は、地理的位置の調整ベースのシステムです。
      </p><p>
        空間参照システムには様々なタイプがあります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            投影 SRS は、地球を平面に投影したものです; すなわち、平面の地図です。 たとえば、地球の周囲の紙の円柱を照らす地球の内側の電球は、地図を紙に投影します。 結果は地理参照されます: 各ポイントは地球上の場所にマッピングされます。 その平面上の座標系は、経度と緯度ではなく長さの単位 (メートル、フィートなど) を使用したデカルト座標です。 
          </p><p>
            この場合の地球はは楕円体、すなわち押しつぶされた球体です。 地球は、東西の軸よりも北西の軸が少し短いため、正確にはわずかに押しつぶされた球体ですが、完全な球体を使用すると計算速度は速くなります。 
          </p></li><li class="listitem"><p>
            地理 SRS は、楕円体上の経度 - 緯度 (または緯度 - 経度) 座標を任意の角度単位で表す非投影 SRS です。
          </p></li><li class="listitem"><p>
            SRID 0 によって MySQL で示される SRS は、軸に単位が割り当てられていない無限の平らなデカルト平面を表します。 投影 SRS とは異なり、地理参照されず、必ずしも地球を表すわけではありません。 これは、任意の用途に使用できる抽象平面です。 SRID 0 は、MySQL の空間データのデフォルト SRID です。 
          </p></li></ul></div><p>
        MySQL では、空間データに使用可能な空間参照システムに関する情報がデータディクショナリの <code class="literal">mysql.st_spatial_reference_systems</code> テーブルに保持されます。このテーブルには、投影 SR および地理 SRS のエントリを格納できます。 このデータディクショナリテーブルは非表示ですが、SRS エントリの内容は、<code class="literal">mysql.st_spatial_reference_systems</code> 上のビューとして実装された <code class="literal">INFORMATION_SCHEMA</code> <code class="literal">ST_SPATIAL_REFERENCE_SYSTEMS</code> テーブルを介して使用できます (<a class="xref" href="information-schema.html#information-schema-st-spatial-reference-systems-table" title="26.36 INFORMATION_SCHEMA ST_SPATIAL_REFERENCE_SYSTEMS テーブル">セクション26.36「INFORMATION_SCHEMA ST_SPATIAL_REFERENCE_SYSTEMS テーブル」</a> を参照)。 
      </p><p>
        SRS エントリの例を次に示します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.ST_SPATIAL_REFERENCE_SYSTEMS</code></strong>
       <strong class="userinput"><code>WHERE SRS_ID = 4326\G</code></strong>
*************************** 1. row ***************************
                SRS_NAME: WGS 84
                  SRS_ID: 4326
            ORGANIZATION: EPSG
ORGANIZATION_COORDSYS_ID: 4326
              DEFINITION: GEOGCS["WGS 84",DATUM["World Geodetic System 1984",
                          SPHEROID["WGS 84",6378137,298.257223563,
                          AUTHORITY["EPSG","7030"]],AUTHORITY["EPSG","6326"]],
                          PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],
                          UNIT["degree",0.017453292519943278,
                          AUTHORITY["EPSG","9122"]],
                          AXIS["Lat",NORTH],AXIS["Long",EAST],
                          AUTHORITY["EPSG","4326"]]
             DESCRIPTION:
</pre><p>
        このエントリでは、GPS システムに使用される SRS について説明します。 名前 (<code class="literal">SRS_NAME</code>) は WGS 84 で、ID (<code class="literal">SRS_ID</code>) は 4326 で、これは<a class="ulink" href="http://epsg.org" target="_top">「欧州石油調査グループ」</a> (EPSG) で使用される ID です。 
      </p><p>
        <code class="literal">DEFINITION</code> カラムの SRS 定義は WKT 値であり、<a class="ulink" href="http://www.opengeospatial.org" target="_top">Open Geospatial Consortium</a> 文書 <a class="ulink" href="http://docs.opengeospatial.org/is/12-063r5/12-063r5.html" target="_top">OGC 12-063r5</a> で指定されています。
      </p><p>
        <code class="literal">SRS_ID</code> 値は、ジオメトリ値の SRID と同じ種類の値を表すか、SRID 引数として空間関数に渡されます。 SRID 0 (単位なしデカルト平面) は特殊です。 常に有効な空間参照システム ID であり、SRID 値に依存する空間データの計算に使用できます。 
      </p><p>
        複数のジオメトリ値の計算では、すべての値が同じ SRID を持つ必要があり、そうでない場合はエラーが発生します。
      </p><p>
        SRS 定義解析は、GIS 関数で定義が必要な場合にオンデマンドで実行されます。 解析された定義は、再利用を可能にし、SRS 情報を必要とするすべてのステートメントの解析オーバーヘッドが発生しないように、データディクショナリキャッシュに格納されます。 
      </p><p>
        データディクショナリに格納されている SRS エントリの操作を可能にするために、MySQL には次の SQL ステートメントが用意されています:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CREATE SPATIAL REFERENCE SYSTEM</code>: <a class="xref" href="sql-statements.html#create-spatial-reference-system" title="13.1.19 CREATE SPATIAL REFERENCE SYSTEM ステートメント">セクション13.1.19「CREATE SPATIAL REFERENCE SYSTEM ステートメント」</a> を参照してください。 このステートメントの説明には、SRS 構成部品に関する追加情報が含まれます。 
          </p></li><li class="listitem"><p>
            <code class="literal">DROP SPATIAL REFERENCE SYSTEM</code>: <a class="xref" href="sql-statements.html#drop-spatial-reference-system" title="13.1.31 DROP SPATIAL REFERENCE SYSTEM ステートメント">セクション13.1.31「DROP SPATIAL REFERENCE SYSTEM ステートメント」</a> を参照してください。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="creating-spatial-columns"></a>11.4.6 空間カラムの作成</h3></div></div></div><p>
        MySQL には、<code class="literal">CREATE TABLE</code> や <code class="literal">ALTER TABLE</code> を使用する方法など、ジオメトリ型の空間カラムを作成するための標準的な方法が用意されています。 空間カラムは、<code class="literal">MyISAM</code>、<code class="literal">InnoDB</code>、<code class="literal">NDB</code>、および <code class="literal">ARCHIVE</code> テーブルでサポートされています。 <a class="xref" href="data-types.html#creating-spatial-indexes" title="11.4.10 空間インデックスの作成">セクション11.4.10「空間インデックスの作成」</a>の空間インデックスに関するノートも参照してください。 
      </p><p>
        空間データ型のカラムに SRID 属性を指定して、カラムに格納されている値の空間参照システム (SRS) を明示的に指定できます。 SRID 制限カラムの意味については、<a class="xref" href="data-types.html#spatial-type-overview" title="11.4.1 空間データ型">セクション11.4.1「空間データ型」</a> を参照してください。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            空間カラムを含むテーブルを作成するには、<code class="literal">CREATE TABLE</code> ステートメントを使用します。
          </p><pre class="programlisting">CREATE TABLE geom (g GEOMETRY);
</pre></li><li class="listitem"><p>
            既存のテーブルに対して空間カラムの追加や削除を行うには、<code class="literal">ALTER TABLE</code> ステートメントを使用します。
          </p><pre class="programlisting">ALTER TABLE geom ADD pt POINT;
ALTER TABLE geom DROP pt;
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="populating-spatial-columns"></a>11.4.7 空間カラムへのデータ移入</h3></div></div></div><p>
        空間カラムを作成し終わったら、空間データを移入できます。
      </p><p>
        値は内部ジオメトリ形式で格納する必要がありますが、WKT (Well-Known Text)、WKB (Well-Known Binary) のいずれの形式からでも、その形式に値を変換できます。 次の例は、WKT 値を内部ジオメトリ形式に変換することによって、ジオメトリ値をテーブルに挿入する方法を示しています。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            次のように <code class="literal">INSERT</code> ステートメント内で直接変換を実行します。
          </p><pre class="programlisting">INSERT INTO geom VALUES (ST_GeomFromText('POINT(1 1)'));

SET @g = 'POINT(1 1)';
INSERT INTO geom VALUES (ST_GeomFromText(@g));
</pre></li><li class="listitem"><p>
            次のように <code class="literal">INSERT</code> の前に変換を実行します。
          </p><pre class="programlisting">SET @g = ST_GeomFromText('POINT(1 1)');
INSERT INTO geom VALUES (@g);
</pre></li></ul></div><p>
        次の例では、より複雑なジオメトリをテーブルに挿入しています。
      </p><pre class="programlisting">SET @g = 'LINESTRING(0 0,1 1,2 2)';
INSERT INTO geom VALUES (ST_GeomFromText(@g));

SET @g = 'POLYGON((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5))';
INSERT INTO geom VALUES (ST_GeomFromText(@g));

SET @g =
'GEOMETRYCOLLECTION(POINT(1 1),LINESTRING(0 0,1 1,2 2,3 3,4 4))';
INSERT INTO geom VALUES (ST_GeomFromText(@g));
</pre><p>
        前述の例では、<code class="literal">ST_GeomFromText()</code> を使用してジオメトリ値を作成しています。 次のように型に固有の関数を使用することもできます。 
      </p><pre class="programlisting">SET @g = 'POINT(1 1)';
INSERT INTO geom VALUES (ST_PointFromText(@g));

SET @g = 'LINESTRING(0 0,1 1,2 2)';
INSERT INTO geom VALUES (ST_LineStringFromText(@g));

SET @g = 'POLYGON((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5))';
INSERT INTO geom VALUES (ST_PolygonFromText(@g));

SET @g =
'GEOMETRYCOLLECTION(POINT(1 1),LINESTRING(0 0,1 1,2 2,3 3,4 4))';
INSERT INTO geom VALUES (ST_GeomCollFromText(@g));
</pre><p>
        ジオメトリ値の WKB 表現を使用するクライアントアプリケーションプログラムが、クエリーで正しく作成された WKB のサーバーへの送信を担います。 この要件を満たす方法は複数あります。 例: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            次のように、16 進リテラル構文を使用して、<code class="literal">POINT(1 1)</code> 値を挿入します。
          </p><pre class="programlisting">INSERT INTO geom VALUES
(ST_GeomFromWKB(X'0101000000000000000000F03F000000000000F03F'));
</pre></li><li class="listitem"><p>
            ODBC アプリケーションは、<code class="literal">BLOB</code> 型の引数を使用して WKB 表現をプレースホルダにバインドし、WKB 表現を送信できます。
          </p><pre class="programlisting">INSERT INTO geom VALUES (ST_GeomFromWKB(?))
</pre><p>
            ほかのプログラミングインタフェースも似たようなプレースホルダメカニズムをサポートしている可能性があります。
          </p></li><li class="listitem"><p>
            C プログラムでは、<code class="literal">mysql_real_escape_string_quote()</code> を使用してバイナリ値をエスケープし、サーバーに送信されるクエリー文字列に結果を含めることができます。 <a class="ulink" href="https://dev.mysql.com/doc/c-api/8.0/en/mysql-real-escape-string-quote.html" target="_top">mysql_real_escape_string_quote()</a>を参照してください。 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="fetching-spatial-data"></a>11.4.8 空間データのフェッチ</h3></div></div></div><p>
        テーブルに格納されたジオメトリ値は内部形式でフェッチできます。 WKT 形式から WKB 形式に変換することもできます。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            内部形式での空間データのフェッチ:
          </p><p>
            内部形式でジオメトリ値をフェッチする方法は、テーブル間でデータの転送を行う場合に便利です。
          </p><pre class="programlisting">CREATE TABLE geom2 (g GEOMETRY) SELECT g FROM geom;
</pre></li><li class="listitem"><p>
            WKT 形式での空間データのフェッチ:
          </p><p>
            <code class="literal">ST_AsText()</code> 関数は、ジオメトリを内部形式から WKT 文字列に変換します。
          </p><pre class="programlisting">SELECT ST_AsText(g) FROM geom;
</pre></li><li class="listitem"><p>
            WKB 形式での空間データのフェッチ:
          </p><p>
            <code class="literal">ST_AsBinary()</code> 関数は、ジオメトリを内部形式から WKB 値を含む <code class="literal">BLOB</code> に変換します。
          </p><pre class="programlisting">SELECT ST_AsBinary(g) FROM geom;
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-spatial-analysis"></a>11.4.9 空間分析の最適化</h3></div></div></div><p>
        <code class="literal">MyISAM</code> および <code class="literal">InnoDB</code> テーブルの場合、空間データを含むカラムでの検索操作は、<code class="literal">SPATIAL</code> インデックスを使用して最適化できます。 もっとも典型的な操作は次のとおりです。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            指定された点を含むすべてのオブジェクトを検索する点クエリー
          </p></li><li class="listitem"><p>
            所定の領域と重なるすべてのオブジェクトを検索する領域クエリー
          </p></li></ul></div><p>
        MySQL では、<span class="bold"><strong>2 次分割 R ツリー</strong></span>を使用して空間カラムの <code class="literal">SPATIAL</code> インデックスが実装されています。 <code class="literal">SPATIAL</code> インデックスは、ジオメトリの最小境界矩形 (MBR) を使用して構築されます。 大部分のジオメトリでは、MBR はそのジオメトリを囲む最小矩形となります。 水平または垂直方向のライン文字列では、MBR は矩形からライン文字列に縮退します。 点の場合、MBR は矩形から点に縮退します。 
      </p><p>
        空間カラムに通常のインデックスを作成することも可能です。 非 <code class="literal">SPATIAL</code> インデックスでは、<code class="literal">POINT</code> カラムを除くすべての空間カラムでプリフィクスを宣言する必要があります。 
      </p><p>
        <code class="literal">MyISAM</code> および <code class="literal">InnoDB</code> では、<code class="literal">SPATIAL</code> インデックスと <code class="literal">SPATIAL</code> 以外のインデックスの両方がサポートされます。 その他のストレージエンジンは<a class="xref" href="sql-statements.html#create-index" title="13.1.15 CREATE INDEX ステートメント">セクション13.1.15「CREATE INDEX ステートメント」</a>で説明しているように、非 <code class="literal">SPATIAL</code> インデックスをサポートします。 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="creating-spatial-indexes"></a>11.4.10 空間インデックスの作成</h3></div></div></div><p>
        <code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> テーブルの場合、MySQL では、通常のインデックスを作成する場合と同様の構文を使用して空間インデックスを作成できますが、<code class="literal">SPATIAL</code> キーワードを使用します。 空間インデックスのカラムは、<code class="literal">NOT NULL</code> と宣言する必要があります。 次の各例では空間インデックスの作成方法を示します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CREATE TABLE</code> を使用する場合:
          </p><pre class="programlisting">CREATE TABLE geom (g GEOMETRY NOT NULL SRID 4326, SPATIAL INDEX(g));
</pre></li><li class="listitem"><p>
            <code class="literal">ALTER TABLE</code> を使用する場合:
          </p><pre class="programlisting">CREATE TABLE geom (g GEOMETRY NOT NULL SRID 4326);
ALTER TABLE geom ADD SPATIAL INDEX(g);
</pre></li><li class="listitem"><p>
            <code class="literal">CREATE INDEX</code> を使用する場合:
          </p><pre class="programlisting">CREATE TABLE geom (g GEOMETRY NOT NULL SRID 4326);
CREATE SPATIAL INDEX g ON geom (g);
</pre></li></ul></div><p>
        <code class="literal">SPATIAL INDEX</code> は R ツリーインデックスを作成します。 空間カラムの非空間インデックスをサポートするストレージエンジンでは、B ツリーインデックスが作成されます。 空間値に対する B ツリーインデックスは、正確な値の検索に役立ちますが、範囲スキャンには役立ちません。 
      </p><p>
        オプティマイザは、SRID 制限のあるカラムに定義された空間インデックスを使用できます。 詳細は、<a class="xref" href="data-types.html#spatial-type-overview" title="11.4.1 空間データ型">セクション11.4.1「空間データ型」</a>および<a class="xref" href="optimization.html#spatial-index-optimization" title="8.3.3 SPATIAL インデックス最適化">セクション8.3.3「SPATIAL インデックス最適化」</a>を参照してください。 
      </p><p>
        空間カラムのインデックス作成の詳細については、<a class="xref" href="sql-statements.html#create-index" title="13.1.15 CREATE INDEX ステートメント">セクション13.1.15「CREATE INDEX ステートメント」</a>を参照してください。
      </p><p>
        空間インデックスを削除するには、次のように <code class="literal">ALTER TABLE</code> または <code class="literal">DROP INDEX</code> を使用します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">ALTER TABLE</code> を使用する場合:
          </p><pre class="programlisting">ALTER TABLE geom DROP INDEX g;
</pre></li><li class="listitem"><p>
            <code class="literal">DROP INDEX</code> を使用する場合:
          </p><pre class="programlisting">DROP INDEX g ON geom;
</pre></li></ul></div><p>
        例: テーブル <code class="literal">geom</code> に 32,000 件を超えるジオメトリが含まれていて、それらの図形が型 <code class="literal">GEOMETRY</code> のカラム <code class="literal">g</code> に格納されているものとします。 またこのテーブルには、オブジェクト ID の値を格納するための <code class="literal">AUTO_INCREMENT</code> カラム <code class="literal">fid</code> も含まれています。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>DESCRIBE geom;</code></strong>
+-------+----------+------+-----+---------+----------------+
| Field | Type     | Null | Key | Default | Extra          |
+-------+----------+------+-----+---------+----------------+
| fid   | int(11)  |      | PRI | NULL    | auto_increment |
| g     | geometry |      |     |         |                |
+-------+----------+------+-----+---------+----------------+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT COUNT(*) FROM geom;</code></strong>
+----------+
| count(*) |
+----------+
|    32376 |
+----------+
1 row in set (0.00 sec)
</pre><p>
        カラム <code class="literal">g</code> に空間インデックスを追加するには、次のステートメントを使用します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE geom ADD SPATIAL INDEX(g);</code></strong>
Query OK, 32376 rows affected (4.05 sec)
Records: 32376  Duplicates: 0  Warnings: 0
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="using-spatial-indexes"></a>11.4.11 空間インデックスの使用</h3></div></div></div><p>
        オプティマイザは、<code class="literal">WHERE</code> 句で <code class="literal">MBRContains()</code> や <code class="literal">MBRWithin()</code> などの関数が使用されているクエリーの検索に、使用可能な空間インデックスを含めることができるかどうかを調べます。 次のクエリーは、所定の矩形に含まれるすべてのオブジェクトを検索します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET @poly =</code></strong>
    -&gt; <strong class="userinput"><code>'Polygon((30000 15000,
                 31000 15000,
                 31000 16000,
                 30000 16000,
                 30000 15000))';</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT fid,ST_AsText(g) FROM geom WHERE</code></strong>
    -&gt; <strong class="userinput"><code>MBRContains(ST_GeomFromText(@poly),g);</code></strong>
+-----+---------------------------------------------------------------+
| fid | ST_AsText(g)                                                  |
+-----+---------------------------------------------------------------+
|  21 | LINESTRING(30350.4 15828.8,30350.6 15845,30333.8 15845,30 ... |
|  22 | LINESTRING(30350.6 15871.4,30350.6 15887.8,30334 15887.8, ... |
|  23 | LINESTRING(30350.6 15914.2,30350.6 15930.4,30334 15930.4, ... |
|  24 | LINESTRING(30290.2 15823,30290.2 15839.4,30273.4 15839.4, ... |
|  25 | LINESTRING(30291.4 15866.2,30291.6 15882.4,30274.8 15882. ... |
|  26 | LINESTRING(30291.6 15918.2,30291.6 15934.4,30275 15934.4, ... |
| 249 | LINESTRING(30337.8 15938.6,30337.8 15946.8,30320.4 15946. ... |
|   1 | LINESTRING(30250.4 15129.2,30248.8 15138.4,30238.2 15136. ... |
|   2 | LINESTRING(30220.2 15122.8,30217.2 15137.8,30207.6 15136, ... |
|   3 | LINESTRING(30179 15114.4,30176.6 15129.4,30167 15128,3016 ... |
|   4 | LINESTRING(30155.2 15121.4,30140.4 15118.6,30142 15109,30 ... |
|   5 | LINESTRING(30192.4 15085,30177.6 15082.2,30179.2 15072.4, ... |
|   6 | LINESTRING(30244 15087,30229 15086.2,30229.4 15076.4,3024 ... |
|   7 | LINESTRING(30200.6 15059.4,30185.6 15058.6,30186 15048.8, ... |
|  10 | LINESTRING(30179.6 15017.8,30181 15002.8,30190.8 15003.6, ... |
|  11 | LINESTRING(30154.2 15000.4,30168.6 15004.8,30166 15014.2, ... |
|  13 | LINESTRING(30105 15065.8,30108.4 15050.8,30118 15053,3011 ... |
| 154 | LINESTRING(30276.2 15143.8,30261.4 15141,30263 15131.4,30 ... |
| 155 | LINESTRING(30269.8 15084,30269.4 15093.4,30258.6 15093,30 ... |
| 157 | LINESTRING(30128.2 15011,30113.2 15010.2,30113.6 15000.4, ... |
+-----+---------------------------------------------------------------+
20 rows in set (0.00 sec)
</pre><p>
        このクエリーがどのように実行されているのかを、<code class="literal">EXPLAIN</code> を使用して確認します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET @poly =</code></strong>
    -&gt; <strong class="userinput"><code>'Polygon((30000 15000,
                 31000 15000,
                 31000 16000,
                 30000 16000,
                 30000 15000))';</code></strong>
mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT fid,ST_AsText(g) FROM geom WHERE</code></strong>
    -&gt; <strong class="userinput"><code>MBRContains(ST_GeomFromText(@poly),g)\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: geom
         type: range
possible_keys: g
          key: g
      key_len: 32
          ref: NULL
         rows: 50
        Extra: Using where
1 row in set (0.00 sec)
</pre><p>
        空間インデックスがないとどうなるのかを確認します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET @poly =</code></strong>
    -&gt; <strong class="userinput"><code>'Polygon((30000 15000,
                 31000 15000,
                 31000 16000,
                 30000 16000,
                 30000 15000))';</code></strong>
mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT fid,ST_AsText(g) FROM g IGNORE INDEX (g) WHERE</code></strong>
    -&gt; <strong class="userinput"><code>MBRContains(ST_GeomFromText(@poly),g)\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: geom
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 32376
        Extra: Using where
1 row in set (0.00 sec)
</pre><p>
        空間インデックスを使用せずに <code class="literal">SELECT</code> ステートメントを実行しても結果は同じになりますが、実行時間は 0.00 秒から 0.46 秒に増大します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET @poly =</code></strong>
    -&gt; <strong class="userinput"><code>'Polygon((30000 15000,
                 31000 15000,
                 31000 16000,
                 30000 16000,
                 30000 15000))';</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT fid,ST_AsText(g) FROM geom IGNORE INDEX (g) WHERE</code></strong>
    -&gt; <strong class="userinput"><code>MBRContains(ST_GeomFromText(@poly),g);</code></strong>
+-----+---------------------------------------------------------------+
| fid | ST_AsText(g)                                                  |
+-----+---------------------------------------------------------------+
|   1 | LINESTRING(30250.4 15129.2,30248.8 15138.4,30238.2 15136. ... |
|   2 | LINESTRING(30220.2 15122.8,30217.2 15137.8,30207.6 15136, ... |
|   3 | LINESTRING(30179 15114.4,30176.6 15129.4,30167 15128,3016 ... |
|   4 | LINESTRING(30155.2 15121.4,30140.4 15118.6,30142 15109,30 ... |
|   5 | LINESTRING(30192.4 15085,30177.6 15082.2,30179.2 15072.4, ... |
|   6 | LINESTRING(30244 15087,30229 15086.2,30229.4 15076.4,3024 ... |
|   7 | LINESTRING(30200.6 15059.4,30185.6 15058.6,30186 15048.8, ... |
|  10 | LINESTRING(30179.6 15017.8,30181 15002.8,30190.8 15003.6, ... |
|  11 | LINESTRING(30154.2 15000.4,30168.6 15004.8,30166 15014.2, ... |
|  13 | LINESTRING(30105 15065.8,30108.4 15050.8,30118 15053,3011 ... |
|  21 | LINESTRING(30350.4 15828.8,30350.6 15845,30333.8 15845,30 ... |
|  22 | LINESTRING(30350.6 15871.4,30350.6 15887.8,30334 15887.8, ... |
|  23 | LINESTRING(30350.6 15914.2,30350.6 15930.4,30334 15930.4, ... |
|  24 | LINESTRING(30290.2 15823,30290.2 15839.4,30273.4 15839.4, ... |
|  25 | LINESTRING(30291.4 15866.2,30291.6 15882.4,30274.8 15882. ... |
|  26 | LINESTRING(30291.6 15918.2,30291.6 15934.4,30275 15934.4, ... |
| 154 | LINESTRING(30276.2 15143.8,30261.4 15141,30263 15131.4,30 ... |
| 155 | LINESTRING(30269.8 15084,30269.4 15093.4,30258.6 15093,30 ... |
| 157 | LINESTRING(30128.2 15011,30113.2 15010.2,30113.6 15000.4, ... |
| 249 | LINESTRING(30337.8 15938.6,30337.8 15946.8,30320.4 15946. ... |
+-----+---------------------------------------------------------------+
20 rows in set (0.46 sec)
</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="json"></a>11.5 JSON データ型</h2></div></div></div><a class="indexterm" name="idm45661462362320"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="data-types.html#json-values" title="JSON 値の作成">JSON 値の作成</a></p></li><li class="listitem"><p><a class="xref" href="data-types.html#json-normalization" title="JSON 値の正規化、マージおよび自動ラップ">JSON 値の正規化、マージおよび自動ラップ</a></p></li><li class="listitem"><p><a class="xref" href="data-types.html#json-paths" title="JSON 値の検索および変更">JSON 値の検索および変更</a></p></li><li class="listitem"><p><a class="xref" href="data-types.html#json-path-syntax" title="JSON パス構文">JSON パス構文</a></p></li><li class="listitem"><p><a class="xref" href="data-types.html#json-comparison" title="JSON 値の比較および順序付け">JSON 値の比較および順序付け</a></p></li><li class="listitem"><p><a class="xref" href="data-types.html#json-converting-between-types" title="JSON 値と非 JSON 値の間の変換">JSON 値と非 JSON 値の間の変換</a></p></li><li class="listitem"><p><a class="xref" href="data-types.html#json-aggregation" title="JSON 値の集計">JSON 値の集計</a></p></li></ul></div><p>
      MySQL は、JSON (JavaScript Object Notation) ドキュメント内のデータへの効率的なアクセスを可能にする、<a class="ulink" href="https://tools.ietf.org/html/rfc7159" target="_top">RFC 7159</a> によって定義されたネイティブ <code class="literal">JSON</code> データ型をサポートしています。 <code class="literal">JSON</code> データ型には、JSON 形式の文字列を文字列カラムに格納するよりも、次の利点があります: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">JSON</code> カラムに格納されている JSON ドキュメントの自動検証。 無効なドキュメントではエラーが発生します。 
        </p></li><li class="listitem"><p>
          最適化された記憶域形式。 <code class="literal">JSON</code> カラムに格納された JSON ドキュメントは、ドキュメント要素へのクイック読取りアクセスを許可する内部形式に変換されます。 サーバーが後でこのバイナリ形式で格納された JSON 値を読み取る必要がある場合、テキスト表現から値を解析する必要はありません。 バイナリ形式は、サーバーがドキュメント内のサブオブジェクトまたはネストされた値の前後のすべての値を読み取ることなく、キーまたは配列インデックスによって直接サブオブジェクトまたはネストされた値を検索できるように構造化されています。 
        </p></li></ul></div><p>
      MySQL 8.0 では、<code class="literal">JSON_MERGE_PATCH()</code> 関数を使用して <a class="ulink" href="https://tools.ietf.org/html/rfc7396" target="_top">RFC 7396</a> で定義された<span class="emphasis"><em>JSON マージパッチ</em></span>形式もサポートされます。 例および詳細は、この関数の説明および <a class="xref" href="data-types.html#json-normalization" title="JSON 値の正規化、マージおよび自動ラップ">JSON 値の正規化、マージおよび自動ラップ</a> を参照してください。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        この説明では、monotype で <code class="literal">JSON</code> を使用して特に JSON データ型を示し、JSON データ全般を示す通常のフォントで <span class="quote">「<span class="quote">JSON</span>」</span> を使用します。
      </p></div><p>
      <code class="literal">JSON</code> ドキュメントの格納に必要な領域は、<code class="literal">LONGBLOB</code> または <code class="literal">LONGTEXT</code> の場合とほぼ同じです。詳細は、<a class="xref" href="data-types.html#storage-requirements" title="11.7 データ型のストレージ要件">セクション11.7「データ型のストレージ要件」</a> を参照してください。 <code class="literal">JSON</code> カラムに格納される JSON ドキュメントのサイズは、<code class="literal">max_allowed_packet</code> システム変数の値に制限されることに注意してください。 (サーバーが JSON 値をメモリー内で内部的に操作している場合、これより大きくなることがあります。制限は、サーバーが JSON 値を格納するときに適用されます。) JSON ドキュメントの格納に必要な領域の量は、<code class="literal">JSON_STORAGE_SIZE()</code> 関数を使用して取得できます。<code class="literal">JSON</code> カラムの場合、記憶域サイズ、つまり、部分更新が実行される前にこの関数によって使用された値 (このセクションで後述する JSON 部分更新最適化の説明を参照)。 
    </p><p>
      MySQL 8.0.13 より前は、<code class="literal">JSON</code> カラムに <code class="literal">NULL</code> 以外のデフォルト値を含めることはできません。
    </p><p>
      <code class="literal">JSON</code> データ型とともに、作成、操作、検索などの JSON 値に対する操作を可能にする一連の SQL 関数を使用できます。 次に、これらの操作の例を示します。 個々の関数の詳細は、<a class="xref" href="functions.html#json-functions" title="12.18 JSON 関数">セクション12.18「JSON 関数」</a> を参照してください。 
    </p><p>
      GeoJSON 値を操作するための一連の空間関数も使用できます。 <a class="xref" href="functions.html#spatial-geojson-functions" title="12.17.11 空間 GeoJSON 関数">セクション12.17.11「空間 GeoJSON 関数」</a>を参照してください。 
    </p><p>
      他のバイナリ型のカラムと同様に、<code class="literal">JSON</code> カラムは直接インデックス付けされません。かわりに、<code class="literal">JSON</code> カラムからスカラー値を抽出するインデックスを生成されたカラムに作成できます。 詳細な例は、<a class="xref" href="sql-statements.html#json-column-indirect-index" title="JSON カラムインデックスを提供するための生成されたカラムのインデックス付け">JSON カラムインデックスを提供するための生成されたカラムのインデックス付け</a> を参照してください。 
    </p><p>
      MySQL オプティマイザは、JSON 式に一致する仮想カラムの互換性のあるインデックスも検索します。
    </p><p>
      MySQL 8.0.17 以降では、<code class="literal">InnoDB</code> ストレージエンジンは JSON 配列で複数値インデックスをサポートします。 <a class="xref" href="sql-statements.html#create-index-multi-valued" title="複数値インデックス">複数値インデックス</a>を参照してください。 
    </p><p>
      MySQL NDB Cluster 8.0 は、<code class="literal">JSON</code> カラムおよび MySQL JSON 関数をサポートしています。これには、<code class="literal">JSON</code> カラムにインデックスを作成できないための回避方法として、<code class="literal">JSON</code> カラムから生成されたカラムに対するインデックスの作成が含まれます。 <code class="literal">NDB</code> テーブルごとに最大 3 つの <code class="literal">JSON</code> カラムがサポートされます。 
    </p><h3><a name="json-partial-updates"></a>JSON 値の部分更新</h3><p>
      MySQL 8.0 では、オプティマイザは、古いドキュメントを削除して新しいドキュメント全体をカラムに書き込むかわりに、<code class="literal">JSON</code> カラムの部分的なインプレース更新を実行できます。 この最適化は、次の条件を満たす更新に対して実行できます: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          更新するカラムが <code class="literal">JSON</code> として宣言されました。
        </p></li><li class="listitem"><p>
          <code class="literal">UPDATE</code> ステートメントでは、<code class="literal">JSON_SET()</code>、<code class="literal">JSON_REPLACE()</code> または <code class="literal">JSON_REMOVE()</code> のいずれかの関数を使用してカラムを更新します。 カラム値の直接割当て (<code class="literal">UPDATE mytable SET jcol = '{"a": 10, "b": 25}'</code>など) は、部分更新として実行できません。 
        </p><p>
          単一の <code class="literal">UPDATE</code> ステートメントでの複数の <code class="literal">JSON</code> カラムの更新は、この方法で最適化できます。MySQL では、前述の 3 つの関数を使用して値が更新されるカラムのみの部分更新を実行できます。
        </p></li><li class="listitem"><p>
          入力カラムとターゲットカラムは同じカラムである必要があります。<code class="literal">UPDATE mytable SET jcol1 = JSON_SET(jcol2, '$.a', 100)</code> などのステートメントは部分更新として実行できません。
        </p><p>
          更新では、入力カラムとターゲットカラムが同じであるかぎり、前の項目にリストされている関数へのネストされたコールを任意の組合せで使用できます。
        </p></li><li class="listitem"><p>
          すべての変更により、既存の配列またはオブジェクト値が新しい配列またはオブジェクト値に置き換えられ、新しい要素は親オブジェクトまたは配列に追加されません。
        </p></li><li class="listitem"><p>
          置換する値は、少なくとも置換値と同じ大きさである必要があります。 つまり、新しい値を古い値より大きくすることはできません。 
        </p><p>
          この要件で発生する可能性がある例外は、以前の部分更新で大きい値のための十分な領域が残っている場合に発生します。 <code class="literal">JSON_STORAGE_FREE()</code> 関数を使用すると、<code class="literal">JSON</code> カラムの部分更新によって解放された領域の量を確認できます。 
        </p></li></ul></div><p>
      このような部分更新は、領域を節約するコンパクトな形式を使用してバイナリログに書き込むことができます。これは、<code class="literal">binlog_row_value_options</code> システム変数を <code class="literal">PARTIAL_JSON</code> に設定することで有効にできます。 詳細は、この変数の説明を参照してください。 
    </p><p>
      次のいくつかのセクションでは、JSON 値の作成および操作に関する基本情報を示します。
    </p><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="json-values"></a>JSON 値の作成</h3></div></div></div><a class="indexterm" name="idm45661462288192"></a><a class="indexterm" name="idm45661462286448"></a><a class="indexterm" name="idm45661462284672"></a><a class="indexterm" name="idm45661462282896"></a><a class="indexterm" name="idm45661462281120"></a><a class="indexterm" name="idm45661462278960"></a><a class="indexterm" name="idm45661462277024"></a><a class="indexterm" name="idm45661462274864"></a><a class="indexterm" name="idm45661462272928"></a><a class="indexterm" name="idm45661462270768"></a><a class="indexterm" name="idm45661462268832"></a><a class="indexterm" name="idm45661462266688"></a><a class="indexterm" name="idm45661462264768"></a><a class="indexterm" name="idm45661462262992"></a><a class="indexterm" name="idm45661462261216"></a><a class="indexterm" name="idm45661462259072"></a><p>
        JSON 配列には、カンマで区切られ、<code class="literal">[</code>および<code class="literal">]</code>文字で囲まれた値のリストが含まれます:
      </p><pre class="programlisting">["abc", 10, null, true, false]
</pre><p>
        JSON オブジェクトには、カンマで区切られ、<code class="literal">{</code>および<code class="literal">}</code> 文字で囲まれたキーと値のペアのセットが含まれます:
      </p><pre class="programlisting">{"k1": "value", "k2": 10}
</pre><p>
        例に示すように、JSON 配列およびオブジェクトには、文字列または数値、JSON null リテラルまたは JSON ブール true または false リテラルであるスカラー値を含めることができます。 JSON オブジェクトのキーは文字列である必要があります。 時間的 (日付、時間または日時) スカラー値も使用できます: 
      </p><pre class="programlisting">["12:18:29.000000", "2015-07-29", "2015-07-29 12:18:29.000000"]
</pre><p>
        ネストは、JSON 配列要素および JSON オブジェクトキー値内で許可されます:
      </p><pre class="programlisting">[99, {"id": "HK500", "cost": 75.99}, ["hot", "cold"]]
{"k1": "value", "k2": [10, 20]}
</pre><p>
        この目的 (<a class="xref" href="functions.html#json-creation-functions" title="12.18.2 JSON 値を作成する関数">セクション12.18.2「JSON 値を作成する関数」</a> を参照) のために MySQL によって提供される多数の関数から JSON 値を取得したり、<code class="literal">CAST(<em class="replaceable"><code>value</code></em> AS JSON)</code> (<a class="xref" href="data-types.html#json-converting-between-types" title="JSON 値と非 JSON 値の間の変換">JSON 値と非 JSON 値の間の変換</a> を参照) を使用して他のタイプの値を <code class="literal">JSON</code> タイプにキャストすることもできます。 次のいくつかの段落では、MySQL が入力として提供される JSON 値を処理する方法について説明します。 
      </p><a class="indexterm" name="idm45661462242656"></a><a class="indexterm" name="idm45661462241232"></a><p>
        MySQL では、JSON 値は文字列として書き込まれます。 MySQL は、JSON 値を必要とするコンテキストで使用される文字列を解析し、JSON として有効でない場合はエラーを生成します。 次の例に示すように、これらのコンテキストには、<code class="literal">JSON</code> データ型を持つカラムへの値の挿入、および JSON 値を想定する関数への引数の受渡し (通常は MySQL JSON 関数のドキュメントで <em class="replaceable"><code>json_doc</code></em> または <em class="replaceable"><code>json_val</code></em> として示されています) が含まれます: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            値を <code class="literal">JSON</code> カラムに挿入しようとすると、その値が有効な JSON 値である場合は成功しますが、そうでない場合は失敗します:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (jdoc JSON);</code></strong>
Query OK, 0 rows affected (0.20 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES('{"key1": "value1", "key2": "value2"}');</code></strong>
Query OK, 1 row affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES('[1, 2,');</code></strong>
ERROR 3140 (22032) at line 2: Invalid JSON text:
"Invalid value." at position 6 in value (or column) '[1, 2,'.
</pre><p>
            このようなエラーメッセージ内の<span class="quote">「<span class="quote">「位置 <em class="replaceable"><code>N</code></em>」</span>」</span>の位置は 0 ベースですが、値の問題が実際に発生する場所を大まかに示すものとみなす必要があります。
          </p></li><li class="listitem"><p>
            <code class="literal">JSON_TYPE()</code> 関数は、JSON 引数を想定し、JSON 値に解析しようとします。 値 JSON 型が有効な場合はそれを返し、それ以外の場合はエラーを生成します: 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_TYPE('["a", "b", 1]');</code></strong>
+----------------------------+
| JSON_TYPE('["a", "b", 1]') |
+----------------------------+
| ARRAY                      |
+----------------------------+

mysql&gt; <strong class="userinput"><code>SELECT JSON_TYPE('"hello"');</code></strong>
+----------------------+
| JSON_TYPE('"hello"') |
+----------------------+
| STRING               |
+----------------------+

mysql&gt; <strong class="userinput"><code>SELECT JSON_TYPE('hello');</code></strong>
ERROR 3146 (22032): Invalid data type for JSON data in argument 1
to function json_type; a JSON string or JSON type is required.
</pre></li></ul></div><p>
        MySQL は、<code class="literal">utf8mb4</code> 文字セットおよび <code class="literal">utf8mb4_bin</code> 照合順序を使用して、JSON コンテキストで使用される文字列を処理します。 他の文字セットの文字列は、必要に応じて <code class="literal">utf8mb4</code> に変換されます。 (<code class="literal">ascii</code> および <code class="literal">utf8</code> は <code class="literal">utf8mb4</code> のサブセットであるため、<code class="literal">ascii</code> または <code class="literal">utf8</code> 文字セットの文字列の場合、変換は必要ありません。) 
      </p><p>
        リテラル文字列を使用して JSON 値を記述するかわりに、コンポーネント要素から JSON 値を構成するための関数が存在します。 <code class="literal">JSON_ARRAY()</code> は、(空の可能性がある) 値リストを取得し、これらの値を含む JSON 配列を返します: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_ARRAY('a', 1, NOW());</code></strong>
+----------------------------------------+
| JSON_ARRAY('a', 1, NOW())              |
+----------------------------------------+
| ["a", 1, "2015-07-27 09:43:47.000000"] |
+----------------------------------------+
</pre><p>
        <code class="literal">JSON_OBJECT()</code> は、キーと値のペアの (空の可能性がある) リストを取得し、それらのペアを含む JSON オブジェクトを返します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_OBJECT('key1', 1, 'key2', 'abc');</code></strong>
+---------------------------------------+
| JSON_OBJECT('key1', 1, 'key2', 'abc') |
+---------------------------------------+
| {"key1": 1, "key2": "abc"}            |
+---------------------------------------+
</pre><p>
        <code class="literal">JSON_MERGE_PRESERVE()</code> は、複数の JSON ドキュメントを取得し、結合された結果を返します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_MERGE_PRESERVE('["a", 1]', '{"key": "value"}');</code></strong>
+-----------------------------------------------------+
| JSON_MERGE_PRESERVE('["a", 1]', '{"key": "value"}') |
+-----------------------------------------------------+
| ["a", 1, {"key": "value"}]                          |
+-----------------------------------------------------+
1 row in set (0.00 sec)
</pre><p>
        マージルールの詳細は、<a class="xref" href="data-types.html#json-normalization" title="JSON 値の正規化、マージおよび自動ラップ">JSON 値の正規化、マージおよび自動ラップ</a> を参照してください。
      </p><p>
        (MySQL 8.0.3 以降では、動作が多少異なる <code class="literal">JSON_MERGE_PATCH()</code> もサポートされます。 これらの関数の違いの詳細は、<a class="xref" href="functions.html#json-merge-patch-json-merge-preserve-compared" title="JSON_MERGE_PATCH() と JSON_MERGE_PRESERVE() の比較">JSON_MERGE_PATCH() と JSON_MERGE_PRESERVE() の比較</a> を参照してください。) 
      </p><p>
        JSON 値はユーザー定義変数に割り当てることができます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET @j = JSON_OBJECT('key', 'value');</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT @j;</code></strong>
+------------------+
| @j               |
+------------------+
| {"key": "value"} |
+------------------+
</pre><p>
        ただし、ユーザー定義変数は <code class="literal">JSON</code> データ型にできないため、前述の例の<code class="literal">@j</code> は JSON 値のように見え、JSON 値と同じ文字セットおよび照合順序を持ちますが、<code class="literal">JSON</code> データ型は持ちません。 かわりに、<code class="literal">JSON_OBJECT()</code> からの結果は、変数に割り当てられるときに文字列に変換されます。 
      </p><p>
        JSON 値の変換によって生成される文字列には、<code class="literal">utf8mb4</code> の文字セットと <code class="literal">utf8mb4_bin</code> の照合順序があります:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT CHARSET(@j), COLLATION(@j);</code></strong>
+-------------+---------------+
| CHARSET(@j) | COLLATION(@j) |
+-------------+---------------+
| utf8mb4     | utf8mb4_bin   |
+-------------+---------------+
</pre><p>
        <code class="literal">utf8mb4_bin</code> はバイナリ照合であるため、JSON 値の比較では大/小文字が区別されます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_ARRAY('x') = JSON_ARRAY('X');</code></strong>
+-----------------------------------+
| JSON_ARRAY('x') = JSON_ARRAY('X') |
+-----------------------------------+
|                                 0 |
+-----------------------------------+
</pre><a class="indexterm" name="idm45661462187216"></a><p>
        大/小文字の区別は、JSON <code class="literal">null</code>、<code class="literal">true</code> および <code class="literal">false</code> リテラルにも適用され、常に小文字で記述する必要があります:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_VALID('null'), JSON_VALID('Null'), JSON_VALID('NULL');</code></strong>
+--------------------+--------------------+--------------------+
| JSON_VALID('null') | JSON_VALID('Null') | JSON_VALID('NULL') |
+--------------------+--------------------+--------------------+
|                  1 |                  0 |                  0 |
+--------------------+--------------------+--------------------+

mysql&gt; <strong class="userinput"><code>SELECT CAST('null' AS JSON);</code></strong>
+----------------------+
| CAST('null' AS JSON) |
+----------------------+
| null                 |
+----------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT CAST('NULL' AS JSON);</code></strong>
ERROR 3141 (22032): Invalid JSON text in argument 1 to function cast_as_json:
"Invalid value." at position 0 in 'NULL'.
</pre><p>
        JSON リテラルの大/小文字の区別は、任意の文字で記述できる SQL <code class="literal">NULL</code>、<code class="literal">TRUE</code> および <code class="literal">FALSE</code> リテラルの区別とは異なります:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT ISNULL(null), ISNULL(Null), ISNULL(NULL);</code></strong>
+--------------+--------------+--------------+
| ISNULL(null) | ISNULL(Null) | ISNULL(NULL) |
+--------------+--------------+--------------+
|            1 |            1 |            1 |
+--------------+--------------+--------------+
</pre><a class="indexterm" name="idm45661462173552"></a><p>
        JSON ドキュメントに引用符文字 (<code class="literal">"</code>または<code class="literal">'</code>) を挿入する必要がある場合や望ましい場合があります。 この例では、次に示す SQL ステートメントを使用して作成されたテーブルに、それぞれ適切なキーワードとペアになっている MySQL に関するファクトを示すステートメントを表す文字列を含む JSON オブジェクトを挿入するとします: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE facts (sentence JSON);</code></strong>
</pre><p>
        キーワードと文のペアは次のとおりです:
      </p><pre class="programlisting">mascot: The MySQL mascot is a dolphin named "Sakila".
</pre><p>
        これを JSON オブジェクトとして <code class="literal">facts</code> テーブルに挿入する方法の 1 つは、MySQL <code class="literal">JSON_OBJECT()</code> 関数を使用することです。 この場合、次に示すように、バックスラッシュを使用して各引用符文字をエスケープする必要があります: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO facts VALUES</code></strong>
     &gt;   <strong class="userinput"><code>(JSON_OBJECT("mascot", "Our mascot is a dolphin named \"Sakila\"."));</code></strong>
</pre><p>
        JSON オブジェクトリテラルとして値を挿入する場合、これは同じように機能しません。この場合、次のように二重のバックスラッシュエスケープシーケンスを使用する必要があります:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO facts VALUES</code></strong>
     &gt;   <strong class="userinput"><code>('{"mascot": "Our mascot is a dolphin named \\"Sakila\\"."}');</code></strong>
</pre><p>
        二重バックスラッシュを使用すると、MySQL はエスケープシーケンス処理を実行せず、代わりに文字列リテラルを処理のためにストレージエンジンに渡します。 前述のいずれかの方法で JSON オブジェクトを挿入した後、次のように単純な <code class="literal">SELECT</code> を実行することで、JSON カラム値にバックスラッシュが存在することを確認できます: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT sentence FROM facts;</code></strong>
+---------------------------------------------------------+
| sentence                                                |
+---------------------------------------------------------+
| {"mascot": "Our mascot is a dolphin named \"Sakila\"."} |
+---------------------------------------------------------+
</pre><p>
        <code class="literal">mascot</code> をキーとして使用するこの特定の文を検索するには、次に示すように、カラムパス演算子 <code class="literal">-&gt;</code> を使用できます:
      </p><pre class="programlisting">mysql&gt; SELECT col-&gt;"$.mascot" FROM qtest;
+---------------------------------------------+
| col-&gt;"$.mascot"                             |
+---------------------------------------------+
| "Our mascot is a dolphin named \"Sakila\"." |
+---------------------------------------------+
1 row in set (0.00 sec)
</pre><p>
        これにより、バックスラッシュは引用符とともにそのまま残ります。 <code class="literal">mascot</code> をキーとして使用し、引用符やエスケープを含めずに目的の値を表示するには、次のようにインラインパス演算子 <code class="literal">-&gt;&gt;</code> を使用します: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT sentence-&gt;&gt;"$.mascot" FROM facts;</code></strong>
+-----------------------------------------+
| sentence-&gt;&gt;"$.mascot"                   |
+-----------------------------------------+
| Our mascot is a dolphin named "Sakila". |
+-----------------------------------------+
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          前述の例は、<code class="literal">NO_BACKSLASH_ESCAPES</code> サーバーの SQL モードが有効になっている場合は動作しません。 このモードが設定されている場合、ダブルバックスラッシュのかわりに単一のバックスラッシュを使用して JSON オブジェクトリテラルを挿入でき、バックスラッシュは保持されます。 挿入の実行時に <code class="literal">JSON_OBJECT()</code> 関数を使用し、このモードが設定されている場合は、次のように一重引用符および二重引用符を使用する必要があります: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO facts VALUES</code></strong>
     &gt; <strong class="userinput"><code>(JSON_OBJECT('mascot', 'Our mascot is a dolphin named "Sakila".'));</code></strong>
</pre><p>
          JSON 値のエスケープ文字に対するこのモードの影響の詳細は、<code class="literal">JSON_UNQUOTE()</code> 関数の説明を参照してください。
        </p></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="json-normalization"></a>JSON 値の正規化、マージおよび自動ラップ</h3></div></div></div><a class="indexterm" name="idm45661462135008"></a><a class="indexterm" name="idm45661462132896"></a><a class="indexterm" name="idm45661462131520"></a><a class="indexterm" name="idm45661462129488"></a><a class="indexterm" name="idm45661462128112"></a><a class="indexterm" name="idm45661462126048"></a><p>
        文字列が解析され、有効な JSON ドキュメントであることが判明すると、文字列も正規化されます。 つまり、ドキュメントの後半で見つかったキーを複製するキーを持つメンバーは、左から右に読み取られて破棄されます。 次の <code class="literal">JSON_OBJECT()</code> コールによって生成されるオブジェクト値には、次に示すように、そのキー名が値の前に出現するため、2 番目の <code class="literal">key1</code> 要素のみが含まれます: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_OBJECT('key1', 1, 'key2', 'abc', 'key1', 'def');</code></strong>
+------------------------------------------------------+
| JSON_OBJECT('key1', 1, 'key2', 'abc', 'key1', 'def') |
+------------------------------------------------------+
| {"key1": "def", "key2": "abc"}                       |
+------------------------------------------------------+
</pre><p>
        正規化は、次に示すように、値が JSON カラムに挿入されるときにも実行されます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 JSON);</code></strong>

mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES</code></strong>
     &gt;     <strong class="userinput"><code>('{"x": 17, "x": "red"}'),</code></strong>
     &gt;     <strong class="userinput"><code>('{"x": 17, "x": "red", "x": [3, 5, 7]}');</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT c1 FROM t1;</code></strong>
+------------------+
| c1               |
+------------------+
| {"x": "red"}     |
| {"x": [3, 5, 7]} |
+------------------+
</pre><p>
        この<span class="quote">「<span class="quote">「最後の重複キー優先」</span>」</span>の動作は、<a class="ulink" href="https://tools.ietf.org/html/rfc7159" target="_top">RFC 7159</a> によって推奨され、ほとんどの JavaScript パーサーによって実装されます。 (Bug #86866、Bug #26369555) 
      </p><p>
        8.0.3 より前のバージョンの MySQL では、ドキュメント内で以前に見つかったキーを複製したキーを持つメンバーは破棄されました。 次の <code class="literal">JSON_OBJECT()</code> コールによって生成されたオブジェクト値には、2 番目の <code class="literal">key1</code> 要素は含まれません。これは、そのキー名が値の前にあるためです: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_OBJECT('key1', 1, 'key2', 'abc', 'key1', 'def');</code></strong>
+------------------------------------------------------+
| JSON_OBJECT('key1', 1, 'key2', 'abc', 'key1', 'def') |
+------------------------------------------------------+
| {"key1": 1, "key2": "abc"}                           |
+------------------------------------------------------+
</pre><p>
        MySQL 8.0.3 より前は、この<span class="quote">「<span class="quote">「最初の重複キー優先」</span>」</span>正規化は JSON カラムに値を挿入するときにも実行されていました。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 JSON);</code></strong>

mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES</code></strong>
     &gt;     <strong class="userinput"><code>('{"x": 17, "x": "red"}'),</code></strong>
     &gt;     <strong class="userinput"><code>('{"x": 17, "x": "red", "x": [3, 5, 7]}');</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT c1 FROM t1;</code></strong>
+-----------+
| c1        |
+-----------+
| {"x": 17} |
| {"x": 17} |
+-----------+
</pre><p>
        MySQL では、元の JSON ドキュメント内のキー、値または要素間の余分な空白も破棄され、各カンマ (<code class="literal">,</code>) またはコロン (<code class="literal">:</code>) の後に単一の空白が表示されたままになります (または必要に応じて挿入されます)。 これは、読みやすさを高めるために行われます。 
      </p><p>
        JSON 値を生成する MySQL 関数 (<a class="xref" href="functions.html#json-creation-functions" title="12.18.2 JSON 値を作成する関数">セクション12.18.2「JSON 値を作成する関数」</a> を参照) は、常に正規化された値を返します。
      </p><p>
        ルックアップをより効率的にするために、MySQL では JSON オブジェクトのキーもソートされます。 <span class="emphasis"><em>この順序付けの結果は変更される可能性があり、リリース間での一貫性が保証されないことに注意してください</em></span>。 
      </p><h4><a name="json-merging"></a>JSON 値のマージ</h4><a class="indexterm" name="idm45661462095680"></a><a class="indexterm" name="idm45661462094304"></a><a class="indexterm" name="idm45661462093328"></a><a class="indexterm" name="idm45661462092240"></a><p>
        関数 <code class="literal">JSON_MERGE_PRESERVE()</code> および <code class="literal">JSON_MERGE_PATCH()</code> によって実装される MySQL 8.0.3 (以降) では、2 つのマージアルゴリズムがサポートされています。 重複キーの処理方法が異なります: <code class="literal">JSON_MERGE_PRESERVE()</code> では重複キーの値が保持されますが、<code class="literal">JSON_MERGE_PATCH()</code> では最後の値以外のすべての値が破棄されます。 次のいくつかの段落では、これら 2 つの関数のそれぞれが JSON ドキュメント (つまり、オブジェクトと配列) の様々な組合せのマージを処理する方法について説明します。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">JSON_MERGE_PRESERVE()</code> は、以前のバージョンの MySQL (MySQL 8.0.3 で名前が変更された) で検出された <code class="literal">JSON_MERGE()</code> 関数と同じです。 <code class="literal">JSON_MERGE()</code> は、MySQL 8.0 で <code class="literal">JSON_MERGE_PRESERVE()</code> のエイリアスとして引き続きサポートされていますが、非推奨であり、将来のリリースで削除される可能性があります。 
        </p></div><p><b>配列のマージ. </b>
          複数の配列を組み合せるコンテキストでは、配列は単一の配列にマージされます。 <code class="literal">JSON_MERGE_PRESERVE()</code> では、後で名前を付けた配列を最初の配列の最後に連結することで、これを行います。 <code class="literal">JSON_MERGE_PATCH()</code> は、各引数を単一の要素で構成される配列とみなし (したがって、インデックスとして 0 を持つ)、<span class="quote">「<span class="quote">「最後の重複キー優先」</span>」</span>ロジックを適用して最後の引数のみを選択します。 次のクエリーで表示される結果を比較できます: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT</code></strong>
    -&gt;   <strong class="userinput"><code>JSON_MERGE_PRESERVE('[1, 2]', '["a", "b", "c"]', '[true, false]') AS Preserve,</code></strong>
    -&gt;   <strong class="userinput"><code>JSON_MERGE_PATCH('[1, 2]', '["a", "b", "c"]', '[true, false]') AS Patch\G</code></strong>
*************************** 1. row ***************************
Preserve: [1, 2, "a", "b", "c", true, false]
   Patch: [true, false]
</pre><p>
        マージ時に複数のオブジェクトを使用すると、単一のオブジェクトが生成されます。 <code class="literal">JSON_MERGE_PRESERVE()</code> は、配列内のそのキーの一意の値をすべて組み合せることで、同じキーを持つ複数のオブジェクトを処理します。この配列は、結果でそのキーの値として使用されます。 <code class="literal">JSON_MERGE_PATCH()</code> では、左から右に向かって重複キーが見つかった値が破棄されるため、結果にはそのキーの最後の値のみが含まれます。 次のクエリーは、重複キー <code class="literal">a</code> の結果の違いを示しています: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT</code></strong>
    -&gt;   <strong class="userinput"><code>JSON_MERGE_PRESERVE('{"a": 1, "b": 2}', '{"c": 3, "a": 4}', '{"c": 5, "d": 3}') AS Preserve,</code></strong>
    -&gt;   <strong class="userinput"><code>JSON_MERGE_PATCH('{"a": 3, "b": 2}', '{"c": 3, "a": 4}', '{"c": 5, "d": 3}') AS Patch\G</code></strong>
*************************** 1. row ***************************
Preserve: {"a": [1, 4], "b": 2, "c": [3, 5], "d": 3}
   Patch: {"a": 4, "b": 2, "c": 5, "d": 3}
</pre><p>
        配列値を必要とするコンテキストで使用される非配列値は、自動ラップされます: この値は、配列に変換するために<code class="literal">[</code>および<code class="literal">]</code>文字で囲まれています。 次のステートメントでは、各引数が配列 (<code class="literal">[1]</code>、<code class="literal">[2]</code>) として自動ラップされます。 これらはマージされて単一の結果配列が生成されます。前述の 2 つの場合と同様に、<code class="literal">JSON_MERGE_PRESERVE()</code> は同じキーを持つ値を結合し、<code class="literal">JSON_MERGE_PATCH()</code> は最後のキーを除くすべての重複キーの値を破棄します: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT</code></strong>
	  -&gt;   <strong class="userinput"><code>JSON_MERGE_PRESERVE('1', '2') AS Preserve,</code></strong>
	  -&gt;   <strong class="userinput"><code>JSON_MERGE_PATCH('1', '2') AS Patch\G</code></strong>
*************************** 1. row ***************************
Preserve: [1, 2]
   Patch: 2
</pre><p>
        配列およびオブジェクト値をマージするには、次の例に示すように、オブジェクトを配列として自動ラップし、マージ機能の選択に従って値を組み合せるか、<span class="quote">「<span class="quote">「最後の重複キー優先」</span>」</span>によって配列をマージします (それぞれ <code class="literal">JSON_MERGE_PRESERVE()</code> または <code class="literal">JSON_MERGE_PATCH()</code>):
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT</code></strong>
	  -&gt;   <strong class="userinput"><code>JSON_MERGE_PRESERVE('[10, 20]', '{"a": "x", "b": "y"}') AS Preserve,</code></strong>
	  -&gt;   <strong class="userinput"><code>JSON_MERGE_PATCH('[10, 20]', '{"a": "x", "b": "y"}') AS Patch\G</code></strong>
*************************** 1. row ***************************
Preserve: [10, 20, {"a": "x", "b": "y"}]
   Patch: {"a": "x", "b": "y"}
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="json-paths"></a>JSON 値の検索および変更</h3></div></div></div><p>
        JSON パス式は、JSON ドキュメント内の値を選択します。
      </p><p>
        パス式は、JSON ドキュメントの一部を抽出または変更して、そのドキュメント内のどこで操作するかを指定する関数で役立ちます。 たとえば、次のクエリーは、<code class="literal">name</code> キーを持つメンバーの値を JSON ドキュメントから抽出します: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_EXTRACT('{"id": 14, "name": "Aztalan"}', '$.name');</code></strong>
+---------------------------------------------------------+
| JSON_EXTRACT('{"id": 14, "name": "Aztalan"}', '$.name') |
+---------------------------------------------------------+
| "Aztalan"                                               |
+---------------------------------------------------------+
</pre><p>
        パス構文では、検討中の JSON ドキュメントを表すために先頭の <code class="literal">$</code> 文字が使用され、オプションで、ドキュメントの連続して具体的な部分を示すセレクタが続きます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ピリオドの後にキー名を指定すると、オブジェクト内のメンバーに特定のキーが付けられます。 引用符のない名前がパス式内で有効でない場合 (たとえば、空白が含まれている場合)、キー名は二重引用符で囲む必要があります。 
          </p></li><li class="listitem"><p>
            配列を選択する <em class="replaceable"><code>path</code></em> に追加された<code class="literal">[<em class="replaceable"><code>N</code></em>]</code>は、配列内の <em class="replaceable"><code>N</code></em> の位置にある値に名前を付けます。 配列の位置はゼロで始まる整数です。 <em class="replaceable"><code>path</code></em> が配列値を選択しない場合、<em class="replaceable"><code>path</code></em> [0]は <em class="replaceable"><code>path</code></em> と同じ値に評価されます: 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_SET('"x"', '$[0]', 'a');</code></strong>
+------------------------------+
| JSON_SET('"x"', '$[0]', 'a') |
+------------------------------+
| "a"                          |
+------------------------------+
1 row in set (0.00 sec)
</pre></li><li class="listitem"><p>
            <code class="literal">[<em class="replaceable"><code>M</code></em> to <em class="replaceable"><code>N</code></em>]</code>では、位置 <em class="replaceable"><code>M</code></em> の値で始まり、位置 <em class="replaceable"><code>N</code></em> の値で終わる配列値のサブセットまたは範囲を指定します。
          </p><p>
            <code class="literal">last</code> は、右端の配列要素のインデックスのシノニムとしてサポートされています。 配列要素の相対アドレス指定もサポートされています。 <em class="replaceable"><code>path</code></em> が配列値を選択しない場合、このセクションの後半に示すように、<em class="replaceable"><code>path</code></em>[ last]は <em class="replaceable"><code>path</code></em> と同じ値に評価されます (<a class="xref" href="data-types.html#json-paths-last" title="右端の配列要素">右端の配列要素</a> を参照)。 
          </p></li><li class="listitem"><p>
            パスには、<code class="literal">*</code> または <code class="literal">**</code> ワイルドカードを含めることができます:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">.[*]</code>は、JSON オブジェクトのすべてのメンバーの値に評価されます。
              </p></li><li class="listitem"><p>
                <code class="literal">[*]</code>は、JSON 配列内のすべての要素の値に評価されます。
              </p></li><li class="listitem"><p>
                <code class="literal"><em class="replaceable"><code>prefix</code></em>**<em class="replaceable"><code>suffix</code></em></code> は、名前付き接頭辞で始まり、名前付き接尾辞で終わるすべてのパスに評価されます。
              </p></li></ul></div></li><li class="listitem"><p>
            ドキュメントに存在しないパス (存在しないデータに評価される) は、<code class="literal">NULL</code> に評価されます。
          </p></li></ul></div><p>
        <code class="literal">$</code> では、次の 3 つの要素を使用してこの JSON 配列を参照します:
      </p><pre class="programlisting">[3, {"a": [5, 6], "b": 10}, [99, 100]]
</pre><p>
        このとき、次のようになります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">$[0]</code>は、<code class="literal">3</code> に評価されます。
          </p></li><li class="listitem"><p>
            <code class="literal">$[1]</code>は、<code class="literal">{"a": [5, 6], "b": 10}</code> に評価されます。
          </p></li><li class="listitem"><p>
            <code class="literal">$[2]</code>は、<code class="literal">[99, 100]</code>に評価されます。
          </p></li><li class="listitem"><p>
            <code class="literal">$[3]</code>は <code class="literal">NULL</code> に評価されます (存在しない 4 番目の配列要素を参照します)。
          </p></li></ul></div><p>
        <code class="literal">$[1]</code>および <code class="literal">$[2]</code>は非スカラー値と評価されるため、ネストされた値を選択するより具体的なパス式の基礎として使用できます。 例: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">$[1].a</code> は、<code class="literal">[5, 6]</code>に評価されます。
          </p></li><li class="listitem"><p>
            <code class="literal">$[1].a[1]</code>は、<code class="literal">6</code> に評価されます。
          </p></li><li class="listitem"><p>
            <code class="literal">$[1].b</code> は、<code class="literal">10</code> に評価されます。
          </p></li><li class="listitem"><p>
            <code class="literal">$[2][0]</code>は、<code class="literal">99</code> に評価されます。
          </p></li></ul></div><p>
        前述のように、引用符で囲まれていないキー名がパス式で有効でない場合は、キーに名前を付けるパスコンポーネントを引用符で囲む必要があります。 <code class="literal">$</code> がこの値を参照するようにします: 
      </p><pre class="programlisting">{"a fish": "shark", "a bird": "sparrow"}
</pre><p>
        キーにはスペースが含まれているため、引用符で囲む必要があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">$."a fish"</code>は、<code class="literal">shark</code> に評価されます。
          </p></li><li class="listitem"><p>
            <code class="literal">$."a bird"</code>は、<code class="literal">sparrow</code> に評価されます。
          </p></li></ul></div><p>
        ワイルドカードを使用するパスは、複数の値を含むことができる配列に評価されます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.*');</code></strong>
+---------------------------------------------------------+
| JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.*') |
+---------------------------------------------------------+
| [1, 2, [3, 4, 5]]                                       |
+---------------------------------------------------------+
mysql&gt; <strong class="userinput"><code>SELECT JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.c[*]');</code></strong>
+------------------------------------------------------------+
| JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.c[*]') |
+------------------------------------------------------------+
| [3, 4, 5]                                                  |
+------------------------------------------------------------+
</pre><p>
        次の例では、<code class="literal">$**.b</code> が複数のパス (<code class="literal">$.a.b</code> および <code class="literal">$.c.b</code>) に評価し、一致するパス値の配列を生成します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_EXTRACT('{"a": {"b": 1}, "c": {"b": 2}}', '$**.b');</code></strong>
+---------------------------------------------------------+
| JSON_EXTRACT('{"a": {"b": 1}, "c": {"b": 2}}', '$**.b') |
+---------------------------------------------------------+
| [1, 2]                                                  |
+---------------------------------------------------------+
</pre><p><a name="json-paths-ranges"></a><b>JSON 配列からの範囲. </b>
          範囲を <code class="literal">to</code> キーワードとともに使用して、JSON 配列のサブセットを指定できます。 たとえば、次に示すように、<code class="literal">$[1 to 3]</code>には配列の 2 番目、3 番目および 4 番目の要素が含まれます: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_EXTRACT('[1, 2, 3, 4, 5]', '$[1 to 3]');</code></strong>
+----------------------------------------------+
| JSON_EXTRACT('[1, 2, 3, 4, 5]', '$[1 to 3]') |
+----------------------------------------------+
| [2, 3, 4]                                    |
+----------------------------------------------+
1 row in set (0.00 sec)
</pre><p>
        構文は <code class="literal"><em class="replaceable"><code>M</code></em> to <em class="replaceable"><code>N</code></em></code> です。ここで、<em class="replaceable"><code>M</code></em> と <em class="replaceable"><code>N</code></em> はそれぞれ、JSON 配列の要素の範囲の最初と最後のインデックスです。 <em class="replaceable"><code>N</code></em> は <em class="replaceable"><code>M</code></em> より大きい必要があります。<em class="replaceable"><code>M</code></em> は 0 以上である必要があります。 配列要素は 0 から始まるインデックス付けされます。 
      </p><p>
        ワイルドカードがサポートされているコンテキストで範囲を使用できます。
      </p><p><a name="json-paths-last"></a><b>右端の配列要素. </b>
          <code class="literal">last</code> キーワードは、配列の最後の要素のインデックスのシノニムとしてサポートされています。 <code class="literal">last - <em class="replaceable"><code>N</code></em></code> 形式の式は、次のように、相対アドレス指定および範囲定義内で使用できます: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_EXTRACT('[1, 2, 3, 4, 5]', '$[last-3 to last-1]');</code></strong>
+--------------------------------------------------------+
| JSON_EXTRACT('[1, 2, 3, 4, 5]', '$[last-3 to last-1]') |
+--------------------------------------------------------+
| [2, 3, 4]                                              |
+--------------------------------------------------------+
1 row in set (0.01 sec)
</pre><p>
        パスが配列ではない値に対して評価される場合、評価の結果は値が単一要素配列にラップされた場合と同じです:
      </p><pre class="programlisting">mysql&gt; SELECT JSON_REPLACE('"Sakila"', '$[last]', 10);
+-----------------------------------------+
| JSON_REPLACE('"Sakila"', '$[last]', 10) |
+-----------------------------------------+
| 10                                      |
+-----------------------------------------+
1 row in set (0.00 sec)
</pre><p>
        <code class="literal"><em class="replaceable"><code>column</code></em>-&gt;<em class="replaceable"><code>path</code></em></code> は、JSON カラム識別子および JSON パス式とともに <code class="literal">JSON_EXTRACT(<em class="replaceable"><code>column</code></em>, <em class="replaceable"><code>path</code></em>)</code> のシノニムとして使用できます。 詳しくは<a class="xref" href="functions.html#json-search-functions" title="12.18.3 JSON 値を検索する関数">セクション12.18.3「JSON 値を検索する関数」</a>,をご覧ください。 <a class="xref" href="sql-statements.html#json-column-indirect-index" title="JSON カラムインデックスを提供するための生成されたカラムのインデックス付け">JSON カラムインデックスを提供するための生成されたカラムのインデックス付け</a>も参照してください。 
      </p><p>
        一部の関数では、既存の JSON ドキュメントを取得し、なんらかの方法で変更して、結果として変更されたドキュメントを戻します。 パス式は、変更を加えるドキュメント内の場所を示します。 たとえば、<code class="literal">JSON_SET()</code>、<code class="literal">JSON_INSERT()</code> および <code class="literal">JSON_REPLACE()</code> の各関数は、JSON ドキュメントに加えて、ドキュメントを変更する場所と使用する値を記述する 1 つ以上のパスと値のペアを取ります。 関数は、ドキュメント内の既存の値と存在しない値の処理方法が異なります。 
      </p><p>
        このドキュメントについて考えてみます:
      </p><pre class="programlisting">mysql&gt; SET @j = '["a", {"b": [true, false]}, [10, 20]]';
</pre><p>
        <code class="literal">JSON_SET()</code> は、存在するパスの値を置き換え、存在しないパスの値を追加します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_SET(@j, '$[1].b[0]', 1, '$[2][2]', 2);</code></strong>
+--------------------------------------------+
| JSON_SET(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+--------------------------------------------+
| ["a", {"b": [1, false]}, [10, 20, 2]]      |
+--------------------------------------------+
</pre><p>
        この場合、パス <code class="literal">$[1].b[0]</code>は既存の値 (<code class="literal">true</code>) を選択します。これは、パス引数 (<code class="literal">1</code>) の後の値に置き換えられます。 パス <code class="literal">$[2][2]</code>が存在しないため、<code class="literal">$[2]</code>によって選択された値に対応する値 (<code class="literal">2</code>) が追加されます。 
      </p><p>
        <code class="literal">JSON_INSERT()</code> によって新しい値が追加されますが、既存の値は置換されません:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_INSERT(@j, '$[1].b[0]', 1, '$[2][2]', 2);</code></strong>
+-----------------------------------------------+
| JSON_INSERT(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+-----------------------------------------------+
| ["a", {"b": [true, false]}, [10, 20, 2]]      |
+-----------------------------------------------+
</pre><p>
        <code class="literal">JSON_REPLACE()</code> は既存の値を置換し、新しい値を無視します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_REPLACE(@j, '$[1].b[0]', 1, '$[2][2]', 2);</code></strong>
+------------------------------------------------+
| JSON_REPLACE(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+------------------------------------------------+
| ["a", {"b": [1, false]}, [10, 20]]             |
+------------------------------------------------+
</pre><p>
        パスと値のペアは左から右に評価されます。 あるペアを評価して生成されたドキュメントは、次のペアが評価される新しい値になります。 
      </p><p>
        <code class="literal">JSON_REMOVE()</code> は、JSON ドキュメントと、ドキュメントから削除する値を指定する 1 つ以上のパスを取ります。 戻り値は、元のドキュメントから、ドキュメント内に存在するパスによって選択された値を引いたものです: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT JSON_REMOVE(@j, '$[2]', '$[1].b[1]', '$[1].b[1]');</code></strong>
+---------------------------------------------------+
| JSON_REMOVE(@j, '$[2]', '$[1].b[1]', '$[1].b[1]') |
+---------------------------------------------------+
| ["a", {"b": [true]}]                              |
+---------------------------------------------------+
</pre><p>
        パスには次の効果があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">$[2]</code>は、<code class="literal">[10, 20]</code>を照合して削除します。
          </p></li><li class="listitem"><p>
            <code class="literal">$[1].b[1]</code>の最初のインスタンスは、<code class="literal">b</code> 要素内の <code class="literal">false</code> と一致し、削除されます。
          </p></li><li class="listitem"><p>
            <code class="literal">$[1].b[1]</code>の 2 番目のインスタンスが一致しません: その要素はすでに削除されており、パスは存在せず、効果もありません。
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="json-path-syntax"></a>JSON パス構文</h3></div></div></div><p>
        MySQL でサポートされ、このマニュアルの他の場所で説明されている JSON 関数の多く (<a class="xref" href="functions.html#json-functions" title="12.18 JSON 関数">セクション12.18「JSON 関数」</a> を参照) では、JSON ドキュメント内の特定の要素を識別するためにパス式が必要です。 パスは、パススコープとそれに続く 1 つ以上のパスレッグで構成されます。 MySQL JSON 関数で使用されるパスの場合、有効範囲は常に検索または操作されるドキュメントで、先頭の <code class="literal">$</code> 文字で表されます。 パスレグはピリオド文字 (<code class="literal">.</code>) で区切られます。 配列内のセルは<code class="literal">[<em class="replaceable"><code>N</code></em>]</code>で表され、<em class="replaceable"><code>N</code></em> は負でない整数です。 キーの名前は、二重引用符で囲まれた文字列または有効な ECMAScript 識別子である必要があります (<em class="citetitle">「ECMAScript 言語仕様」</em>の<a class="ulink" href="http://www.ecma-international.org/ecma-262/5.1/#sec-7.6" target="_top">「<em class="citetitle">識別子名および識別子</em>」</a>を参照)。 JSON テキストなどのパス式は、<code class="literal">ascii</code>、<code class="literal">utf8</code> または <code class="literal">utf8mb4</code> 文字セットを使用してエンコードする必要があります。 その他の文字エンコーディングは、暗黙的に <code class="literal">utf8mb4</code> に強制変換されます。 完全な構文は次のとおりです: 
      </p><pre class="programlisting"><em class="replaceable"><code>pathExpression</code></em>:
    <em class="replaceable"><code>scope</code></em>[(<em class="replaceable"><code>pathLeg</code></em>)*]

<em class="replaceable"><code>pathLeg</code></em>:
    <em class="replaceable"><code>member</code></em> | <em class="replaceable"><code>arrayLocation</code></em> | <em class="replaceable"><code>doubleAsterisk</code></em>

<em class="replaceable"><code>member</code></em>:
    <em class="replaceable"><code>period</code></em> ( <em class="replaceable"><code>keyName</code></em> | <em class="replaceable"><code>asterisk</code></em> )

<em class="replaceable"><code>arrayLocation</code></em>:
    <em class="replaceable"><code>leftBracket</code></em> ( <em class="replaceable"><code>nonNegativeInteger</code></em> | <em class="replaceable"><code>asterisk</code></em> ) <em class="replaceable"><code>rightBracket</code></em>

<em class="replaceable"><code>keyName</code></em>:
    <a class="ulink" href="http://www.ecma-international.org/ecma-262/5.1/#sec-7.6" target="_top"><em class="replaceable"><code>ESIdentifier</code></em></a> | <em class="replaceable"><code>doubleQuotedString</code></em>

<em class="replaceable"><code>doubleAsterisk</code></em>:
    '**'

<em class="replaceable"><code>period</code></em>:
    '.'

<em class="replaceable"><code>asterisk</code></em>:
    '*'

<em class="replaceable"><code>leftBracket</code></em>:
    '['

<em class="replaceable"><code>rightBracket</code></em>:
    ']'
</pre><p>
        前述のように、MySQL では、パスのスコープは常に操作対象のドキュメントで、<code class="literal">$</code> として表されます。 <code class="literal">'$'</code>を JSON パス式のドキュメントの構文として使用できます。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          一部の実装では、JSON パスのスコープのカラム参照がサポートされています。現在、MySQL ではこれらはサポートされていません。
        </p></div><p>
        ワイルドカード <code class="literal">*</code> および <code class="literal">**</code> トークンは、次のように使用されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">.*</code> は、オブジェクト内のすべてのメンバーの値を表します。
          </p></li><li class="listitem"><p>
            <code class="literal">[*]</code>は、配列内のすべてのセルの値を表します。
          </p></li><li class="listitem"><p>
            <code class="literal">[<em class="replaceable"><code>prefix</code></em>]**<em class="replaceable"><code>suffix</code></em></code> は、<em class="replaceable"><code>prefix</code></em> で始まり <em class="replaceable"><code>suffix</code></em> で終わるすべてのパスを表します。<em class="replaceable"><code>prefix</code></em> はオプションですが、<em class="replaceable"><code>suffix</code></em> は必須です。つまり、パスが <code class="literal">**</code> で終わることはできません。
          </p><p>
            また、パスに順序 <code class="literal">***</code> が含まれていない場合もあります。
          </p></li></ul></div><p>
        パス構文の例は、<code class="literal">JSON_CONTAINS_PATH()</code>、<code class="literal">JSON_SET()</code>、<code class="literal">JSON_REPLACE()</code> などの引数としてパスを取る様々な JSON 関数の説明を参照してください。 <code class="literal">*</code> および <code class="literal">**</code> ワイルドカードの使用を含む例は、<code class="literal">JSON_SEARCH()</code> 関数の説明を参照してください。 
      </p><p>
        MySQL 8.0.2 以降では、<code class="literal">to</code> キーワード (<code class="literal">$[2 to 10]</code>など) を使用した JSON 配列のサブセットの範囲表記、および配列の右端の要素のシノニムとして <code class="literal">last</code> キーワードもサポートされています。 詳細および例については、<a class="xref" href="data-types.html#json-paths" title="JSON 値の検索および変更">JSON 値の検索および変更</a>を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="json-comparison"></a>JSON 値の比較および順序付け</h3></div></div></div><p>
        JSON 値は、<code class="literal">=</code>, <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>, <code class="literal">&gt;</code>, <code class="literal">&gt;=</code>, <code class="literal">&lt;&gt;</code>, <code class="literal">!=</code> および <code class="literal">&lt;=&gt;</code> 演算子を使用して比較できます。
      </p><p>
        次の比較演算子および関数は、JSON 値ではまだサポートされていません:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">BETWEEN</code>
          </p></li><li class="listitem"><p>
            <code class="literal">IN()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">GREATEST()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">LEAST()</code>
          </p></li></ul></div><p>
        リストされている比較演算子および関数の回避策は、JSON 値をネイティブの MySQL 数値または文字列データ型にキャストして、JSON 以外のスカラー型が一貫しているようにすることです。
      </p><p>
        JSON 値の比較は 2 つのレベルで行われます。 最初のレベルの比較は、比較された値の JSON 型に基づきます。 タイプが異なる場合、比較結果は優先順位の高いタイプによってのみ決定されます。 2 つの値が同じ JSON 型である場合、2 つ目のレベルの比較は型固有のルールを使用して行われます。 
      </p><p>
        次のリストは、JSON 型の優先順位の高いものから低いものへの優先順位を示しています。 (型名は、<code class="literal">JSON_TYPE()</code> 関数によって戻される型名です。) 行にまとめて表示されるタイプの優先順位は同じです。 リストの前半にリストされている JSON 型を持つ値は、リストの後半にリストされている JSON 型を持つ値よりも大きく比較されます。 
      </p><pre class="programlisting">BLOB
BIT
OPAQUE
DATETIME
TIME
DATE
BOOLEAN
ARRAY
OBJECT
STRING
INTEGER, DOUBLE
NULL
</pre><p>
        同じ優先順位の JSON 値の場合、比較ルールはタイプ固有です:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">BLOB</code>
          </p><p>
            2 つの値の最初の <em class="replaceable"><code>N</code></em> バイトが比較されます。ここで、<em class="replaceable"><code>N</code></em> は短い値のバイト数です。 2 つの値の最初の <em class="replaceable"><code>N</code></em> バイトが同一の場合、短い方の値が長い方の値の前に順序付けされます。 
          </p></li><li class="listitem"><p>
            <code class="literal">BIT</code>
          </p><p>
            <code class="literal">BLOB</code> と同じルール。
          </p></li><li class="listitem"><p>
            <code class="literal">OPAQUE</code>
          </p><p>
            <code class="literal">BLOB</code> と同じルール。 <code class="literal">OPAQUE</code> 値は、他のタイプのいずれにも分類されない値です。 
          </p></li><li class="listitem"><p>
            <code class="literal">DATETIME</code>
          </p><p>
            以前のポイントインタイムを表す値は、後のポイントインタイムを表す値の前に順序付けられます。 最初に MySQL <code class="literal">DATETIME</code> 型と <code class="literal">TIMESTAMP</code> 型の値がそれぞれ同じ時点を表す場合、それらは等しくなります。 
          </p></li><li class="listitem"><p>
            <code class="literal">TIME</code>
          </p><p>
            2 つの時間値のうち小さい方が大きい方の値の前に順序付けられます。
          </p></li><li class="listitem"><p>
            <code class="literal">DATE</code>
          </p><p>
            以前の日付は、より新しい日付より前にオーダーされます。
          </p></li><li class="listitem"><p>
            <code class="literal">ARRAY</code>
          </p><p>
            長さが同じで、配列内の対応する位置の値が等しい場合、2 つの JSON 配列は等しくなります。
          </p><p>
            配列が等しくない場合、配列の順序は、違いがある最初の位置の要素によって決まります。 その位置の値が小さい配列が最初に順序付けられます。 短い配列のすべての値が長い配列の対応する値と等しい場合は、短い配列が最初に順序付けられます。 
          </p><p>
            例:
          </p><pre class="programlisting">[] &lt; ["a"] &lt; ["ab"] &lt; ["ab", "cd", "ef"] &lt; ["ab", "ef"]
</pre></li><li class="listitem"><p>
            <code class="literal">BOOLEAN</code>
          </p><p>
            JSON false リテラルが JSON true リテラルより小さい場合。
          </p></li><li class="listitem"><p>
            <code class="literal">OBJECT</code>
          </p><p>
            2 つの JSON オブジェクトは、同じキーセットを持ち、各キーが両方のオブジェクトで同じ値を持つ場合に等しくなります。
          </p><p>
            例:
          </p><pre class="programlisting">{"a": 1, "b": 2} = {"b": 2, "a": 1}
</pre><p>
            等しくない 2 つのオブジェクトの順序は指定されませんが、決定的です。
          </p></li><li class="listitem"><p>
            <code class="literal">STRING</code>
          </p><p>
            文字列は、比較される 2 つの文字列の <code class="literal">utf8mb4</code> 表現の最初の <em class="replaceable"><code>N</code></em> バイトで字句的に順序付けされます (<em class="replaceable"><code>N</code></em> は短い文字列の長さです)。 2 つの文字列の最初の <em class="replaceable"><code>N</code></em> バイトが同一の場合、短い文字列は長い文字列より小さいとみなされます。 
          </p><p>
            例:
          </p><pre class="programlisting">"a" &lt; "ab" &lt; "b" &lt; "bc"
</pre><p>
            この順序付けは、照合 <code class="literal">utf8mb4_bin</code> を使用した SQL 文字列の順序付けと同等です。 <code class="literal">utf8mb4_bin</code> はバイナリ照合であるため、JSON 値の比較では大/小文字が区別されます: 
          </p><pre class="programlisting">"A" &lt; "a"
</pre></li><li class="listitem"><p>
            <code class="literal">INTEGER</code>, <code class="literal">DOUBLE</code>
          </p><p>
            JSON 値には、正確な値の数値および近似値の数値を含めることができます。 これらのタイプの数値の概要は、<a class="xref" href="language-structure.html#number-literals" title="9.1.2 数値リテラル">セクション9.1.2「数値リテラル」</a> を参照してください。 
          </p><p>
            ネイティブ MySQL 数値型を比較するためのルールは <a class="xref" href="functions.html#type-conversion" title="12.3 式評価での型変換">セクション12.3「式評価での型変換」</a> で説明されていますが、JSON 値内の数値を比較するためのルールは多少異なります:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                ネイティブの MySQL <code class="literal">INT</code> 数値型と <code class="literal">DOUBLE</code> 数値型を使用する 2 つのカラムの比較では、すべての比較に整数と double が含まれることがわかっているため、すべての行で整数が double に変換されます。 つまり、正確な値の数値は近似値の数値に変換されます。 
              </p></li><li class="listitem"><p>
                一方、クエリーで数値を含む 2 つの JSON カラムを比較する場合、数値が整数であるか倍精度であるかは事前にわかりません。 すべての行で最も一貫性のある動作を提供するために、MySQL は近似値の数値を正確な値の数値に変換します。 結果の順序付けは一貫性があり、正確な値の数値の精度は失われません。 たとえば、スカラー 9223372036854775805、9223372036854775806、9223372036854775807 および 9.223372036854776 e18 の場合、順序は次のようになります: 
              </p><pre class="programlisting">9223372036854775805 &lt; 9223372036854775806 &lt; 9223372036854775807
&lt; 9.223372036854776e18 = 9223372036854776000 &lt; 9223372036854776001
</pre></li></ul></div><p>
            JSON 以外の数値比較ルールを使用するための JSON 比較では、順序に一貫性がない可能性があります。 数値の通常の MySQL 比較ルールでは、次の順序付けが行われます: 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                整数比較:
              </p><pre class="programlisting">9223372036854775805 &lt; 9223372036854775806 &lt; 9223372036854775807
</pre><p>
                (9.223372036854776 e18 には定義されていません)
              </p></li><li class="listitem"><p>
                二重比較:
              </p><pre class="programlisting">9223372036854775805 = 9223372036854775806 = 9223372036854775807 = 9.223372036854776e18
</pre></li></ul></div></li></ul></div><p>
        JSON 値を SQL <code class="literal">NULL</code> と比較する場合、結果は <code class="literal">UNKNOWN</code> になります。
      </p><p>
        JSON 値と非 JSON 値を比較するために、非 JSON 値は次のテーブルのルールに従って JSON に変換されてから、前述のように比較されます。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="json-converting-between-types"></a>JSON 値と非 JSON 値の間の変換</h3></div></div></div><p>
        次のテーブルに、JSON 値と他のタイプの値の間のキャスト時に MySQL が従うルールのサマリーを示します:
      </p><div class="oracle-all"><a name="json-conversion-rules"></a><p class="title"><b>表 11.3 JSON 変換ルール</b></p><div class="oracle-all-contents"><table summary="Conversion rules for the JSON data type"><col style="width: 20%"><col style="width: 40%"><col style="width: 40%"><thead><tr>
            <th scope="col">その他のタイプ</th>
            <th scope="col">CAST(other type AS JSON)</th>
            <th scope="col">CAST(JSON AS other type)</th>
          </tr></thead><tbody><tr>
            <th scope="row">JSON</th>
            <td>変更なし</td>
            <td>変更なし</td>
          </tr><tr>
            <th scope="row">utf8 文字 (<code class="literal">utf8mb4</code>, <code class="literal">utf8</code>, <code class="literal">ascii</code>)</th>
            <td>文字列は JSON 値に解析されます。</td>
            <td>JSON 値は <code class="literal">utf8mb4</code> 文字列にシリアライズされます。</td>
          </tr><tr>
            <th scope="row">その他の文字タイプ</th>
            <td>その他の文字エンコーディングは、暗黙的に <code class="literal">utf8mb4</code> に変換され、utf8 文字タイプで説明されているように扱われます。</td>
            <td>JSON 値は <code class="literal">utf8mb4</code> 文字列にシリアライズされ、他の文字エンコーディングにキャストされます。 結果が意味を持たない場合があります。 </td>
          </tr><tr>
            <th scope="row"><code class="literal">NULL</code></th>
            <td>JSON 型の <code class="literal">NULL</code> 値になります。</td>
            <td>該当なし。</td>
          </tr><tr>
            <th scope="row">ジオメトリタイプ</th>
            <td>ジオメトリ値は、<code class="literal">ST_AsGeoJSON()</code> をコールして JSON ドキュメントに変換されます。</td>
            <td>不正な操作です。 回避策: <code class="literal">CAST(<em class="replaceable"><code>json_val</code></em> AS CHAR)</code> の結果を <code class="literal">ST_GeomFromGeoJSON()</code> に渡します。 </td>
          </tr><tr>
            <th scope="row">その他すべてのタイプ</th>
            <td>単一のスカラー値で構成される JSON ドキュメントになります。</td>
            <td>JSON ドキュメントがターゲット型の単一のスカラー値で構成され、そのスカラー値をターゲット型にキャストできる場合は成功します。 それ以外の場合は、<code class="literal">NULL</code> を返し、警告を生成します。 </td>
          </tr></tbody></table></div></div><br class="oracle-all-break"><p>
        JSON 値の <code class="literal">ORDER BY</code> および <code class="literal">GROUP BY</code> は、次の原則に従って機能します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            スカラー JSON 値の順序付けでは、前述のルールと同じルールが使用されます。
          </p></li><li class="listitem"><p>
            昇順ソートの場合、SQL <code class="literal">NULL</code> は JSON null リテラルを含むすべての JSON 値の前に順序付けられます。降順ソートの場合、SQL <code class="literal">NULL</code> は JSON null リテラルを含むすべての JSON 値の後に順序付けされます。
          </p></li><li class="listitem"><p>
            JSON 値のソートキーは <code class="literal">max_sort_length</code> システム変数の値によってバインドされるため、最初の <code class="literal">max_sort_length</code> バイトの後にのみ異なるキーは等しいと比較されます。
          </p></li><li class="listitem"><p>
            非スカラー値のソートは現在サポートされておらず、警告が発生します。
          </p></li></ul></div><p>
        ソートの場合、JSON スカラーを他のネイティブ MySQL 型にキャストすると便利です。 たとえば、<code class="literal">jdoc</code> という名前のカラムに、<code class="literal">id</code> キーと負でない値で構成されるメンバーを持つ JSON オブジェクトが含まれる場合、次の式を使用して <code class="literal">id</code> 値でソートします: 
      </p><pre class="programlisting">ORDER BY CAST(JSON_EXTRACT(jdoc, '$.id') AS UNSIGNED)
</pre><p>
        生成されたカラムが <code class="literal">ORDER BY</code> と同じ式を使用するように定義されている場合、MySQL オプティマイザはそれを認識し、クエリー実行計画のインデックスの使用を検討します。 <a class="xref" href="optimization.html#generated-column-index-optimizations" title="8.3.11 生成されたカラムインデックスのオプティマイザによる使用">セクション8.3.11「生成されたカラムインデックスのオプティマイザによる使用」</a>を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="json-aggregation"></a>JSON 値の集計</h3></div></div></div><p>
        JSON 値の集計では、SQL <code class="literal">NULL</code> 値は他のデータ型と同様に無視されます。 <code class="literal">NULL</code> 以外の値は数値型に変換され、<code class="literal">MIN()</code>、<code class="literal">MAX()</code> および <code class="literal">GROUP_CONCAT()</code> を除いて集計されます。 数値への変換では、数値スカラーである JSON 値に対して意味のある結果が生成される必要がありますが、(値によっては) 精度の切捨ておよび損失が発生する可能性があります。 他の JSON 値の数に変換しても、意味のある結果が得られない場合があります。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="data-type-defaults"></a>11.6 データ型デフォルト値</h2></div></div></div><a class="indexterm" name="idm45661461723280"></a><a class="indexterm" name="idm45661461721856"></a><a class="indexterm" name="idm45661461719824"></a><a class="indexterm" name="idm45661461718448"></a><a class="indexterm" name="idm45661461716416"></a><a class="indexterm" name="idm45661461715040"></a><p>
      データ型指定には、明示的または暗黙的なデフォルト値を指定できます。
    </p><p>
      データ型指定の <code class="literal">DEFAULT <em class="replaceable"><code>value</code></em></code> 句は、カラムのデフォルト値を明示的に示します。 例: 
    </p><pre class="programlisting">CREATE TABLE t1 (
  i     INT DEFAULT -1,
  c     VARCHAR(10) DEFAULT '',
  price DOUBLE(16,2) DEFAULT 0.00
);
</pre><a class="indexterm" name="idm45661461710528"></a><p>
      <code class="literal">SERIAL DEFAULT VALUE</code> は特殊なケースです。 整数カラムの定義では、これは <code class="literal">NOT NULL AUTO_INCREMENT UNIQUE</code> のエイリアスです。 
    </p><p>
      明示的な <code class="literal">DEFAULT</code> 句の処理の一部の側面は、次に説明するように、バージョンに依存します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="data-types.html#data-type-defaults-explicit" title="MySQL 8.0.13 での明示的なデフォルト処理">MySQL 8.0.13 での明示的なデフォルト処理</a></p></li><li class="listitem"><p><a class="xref" href="data-types.html#data-type-defaults-explicit-old" title="MySQL 8.0.13 より前の明示的なデフォルト処理">MySQL 8.0.13 より前の明示的なデフォルト処理</a></p></li><li class="listitem"><p><a class="xref" href="data-types.html#data-type-defaults-implicit" title="暗黙的なデフォルト処理">暗黙的なデフォルト処理</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="data-type-defaults-explicit"></a>MySQL 8.0.13 での明示的なデフォルト処理</h3></div></div></div><p>
        <code class="literal">DEFAULT</code> 句で指定されるデフォルト値は、リテラル定数または式です。 例外として、式のデフォルト値をカッコで囲み、リテラル定数のデフォルト値と区別します。 例: 
      </p><pre class="programlisting">CREATE TABLE t1 (
  -- literal defaults
  i INT         DEFAULT 0,
  c VARCHAR(10) DEFAULT '',
  -- expression defaults
  f FLOAT       DEFAULT (RAND() * RAND()),
  b BINARY(16)  DEFAULT (UUID_TO_BIN(UUID())),
  d DATE        DEFAULT (CURRENT_DATE + INTERVAL 1 YEAR),
  p POINT       DEFAULT (Point(0,0)),
  j JSON        DEFAULT (JSON_ARRAY())
);
</pre><p>
        ただし、<code class="literal">TIMESTAMP</code> カラムおよび <code class="literal">DATETIME</code> カラムの場合は、カッコを囲まずに <code class="literal">CURRENT_TIMESTAMP</code> 関数をデフォルトとして指定できます。 <a class="xref" href="data-types.html#timestamp-initialization" title="11.2.5 TIMESTAMP および DATETIME の自動初期化および更新機能">セクション11.2.5「TIMESTAMP および DATETIME の自動初期化および更新機能」</a>を参照してください。 
      </p><p>
        <code class="literal">BLOB</code>, <code class="literal">TEXT</code>, <code class="literal">GEOMETRY</code> および <code class="literal">JSON</code> データ型にデフォルト値を割り当てることができるのは、式の値がリテラルの場合でも、値が式として書き込まれる場合のみです:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            これは許可されています (式として指定されたリテラルのデフォルト):
          </p><pre class="programlisting">CREATE TABLE t2 (b BLOB DEFAULT ('abc'));
</pre></li><li class="listitem"><p>
            これにより、エラーが生成されます (リテラルのデフォルトが式として指定されていません):
          </p><pre class="programlisting">CREATE TABLE t2 (b BLOB DEFAULT 'abc');
</pre></li></ul></div><p>
        式のデフォルト値は、次のルールに従う必要があります。 許可されていない構造が式に含まれている場合は、エラーが発生します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            リテラル、組込み関数 (決定的および非決定的の両方)、および演算子が許可されます。
          </p></li><li class="listitem"><p>
            サブクエリー、パラメータ、変数、ストアドファンクションおよびユーザー定義関数は使用できません。
          </p></li><li class="listitem"><p>
            式のデフォルト値は、<code class="literal">AUTO_INCREMENT</code> 属性を持つカラムに依存できません。
          </p></li><li class="listitem"><p>
            あるカラムの式のデフォルト値は他のテーブルのカラムを参照できますが、生成されたカラムまたは式のデフォルト値を持つカラムへの参照は、テーブル定義の前半で発生したカラムにする必要があります。 つまり、式のデフォルト値には、生成されたカラムまたは式のデフォルト値を持つカラムへのフォワード参照を含めることはできません。 
          </p><p>
            順序付け制約は、<code class="literal">ALTER TABLE</code> を使用してテーブルのカラムを並べ替える場合にも適用されます。 結果のテーブルに、式のデフォルト値を持つ生成されたカラムまたはカラムへのフォワード参照を含む式のデフォルト値が含まれる場合、ステートメントは失敗します。 
          </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          式のデフォルト値のいずれかのコンポーネントが SQL モードに依存している場合、すべての使用中に SQL モードが同じでないかぎり、テーブルの使用方法によって異なる結果が発生する可能性があります。
        </p></div><p>
        <code class="literal">CREATE TABLE ... LIKE</code> および <code class="literal">CREATE TABLE ... SELECT</code> の場合、宛先テーブルには元のテーブルの式のデフォルト値が保持されます。
      </p><p>
        式のデフォルト値が非決定的関数を参照している場合、式を評価するステートメントはステートメントベースレプリケーションでは安全ではありません。 これには、<code class="literal">INSERT</code> や <code class="literal">UPDATE</code> などのステートメントが含まれます。 この場合、バイナリロギングが無効になっていると、ステートメントは通常どおりに実行されます。 バイナリロギングが有効で、<code class="literal">binlog_format</code> が <code class="literal">STATEMENT</code> に設定されている場合、ステートメントはログに記録されて実行されますが、レプリケーションスレーブが相違する可能性があるため、警告メッセージがエラーログに書き込まれます。 <code class="literal">binlog_format</code> が <code class="literal">MIXED</code> または <code class="literal">ROW</code> に設定されている場合、ステートメントは通常どおりに実行されます。 
      </p><p>
        新しい行を挿入する場合、式 default を持つカラムのデフォルト値を挿入するには、カラム名を省略するか、カラムを <code class="literal">DEFAULT</code> として指定します (リテラル default を持つカラムの場合と同様):
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t4 (uid BINARY(16) DEFAULT (UUID_TO_BIN(UUID())));</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t4 () VALUES();</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t4 () VALUES(DEFAULT);</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT BIN_TO_UUID(uid) AS uid FROM t4;</code></strong>
+--------------------------------------+
| uid                                  |
+--------------------------------------+
| f1109174-94c9-11e8-971d-3bf1095aa633 |
| f110cf9a-94c9-11e8-971d-3bf1095aa633 |
+--------------------------------------+
</pre><p>
        ただし、名前付きカラムのデフォルト値を指定するための <code class="literal">DEFAULT(<em class="replaceable"><code>col_name</code></em>)</code> の使用は、リテラルのデフォルト値を持つカラムにのみ許可され、式のデフォルト値を持つカラムには許可されません。
      </p><p>
        すべてのストレージエンジンが式のデフォルト値を許可するわけではありません。 そうでない場合は、<code class="literal">ER_UNSUPPORTED_ACTION_ON_DEFAULT_VAL_GENERATED</code> エラーが発生します。 
      </p><p>
        デフォルト値が宣言されたカラム型とは異なるデータ型に評価された場合、宣言された型への暗黙的な強制は、通常の MySQL 型変換ルールに従って行われます。 <a class="xref" href="functions.html#type-conversion" title="12.3 式評価での型変換">セクション12.3「式評価での型変換」</a>を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="data-type-defaults-explicit-old"></a>MySQL 8.0.13 より前の明示的なデフォルト処理</h3></div></div></div><p>
        例外として、<code class="literal">DEFAULT</code> 句で指定されるデフォルト値はリテラル定数である必要があります。関数または式は使用できません。 これは、たとえば日付カラムのデフォルト値に <code class="literal">NOW()</code> や <code class="literal">CURRENT_DATE</code> などの関数の値を設定できないことを意味します。 ただし、<code class="literal">TIMESTAMP</code> カラムおよび <code class="literal">DATETIME</code> カラムの場合は、<code class="literal">CURRENT_TIMESTAMP</code> をデフォルトとして指定できます。 <a class="xref" href="data-types.html#timestamp-initialization" title="11.2.5 TIMESTAMP および DATETIME の自動初期化および更新機能">セクション11.2.5「TIMESTAMP および DATETIME の自動初期化および更新機能」</a>を参照してください。 
      </p><p>
        <code class="literal">BLOB</code>, <code class="literal">TEXT</code>, <code class="literal">GEOMETRY</code> および <code class="literal">JSON</code> データ型にデフォルト値を割り当てることはできません。
      </p><p>
        デフォルト値が宣言されたカラム型とは異なるデータ型に評価された場合、宣言された型への暗黙的な強制は、通常の MySQL 型変換ルールに従って行われます。 <a class="xref" href="functions.html#type-conversion" title="12.3 式評価での型変換">セクション12.3「式評価での型変換」</a>を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="data-type-defaults-implicit"></a>暗黙的なデフォルト処理</h3></div></div></div><p>
        データ型指定に明示的な <code class="literal">DEFAULT</code> 値が含まれていない場合、MySQL は次のようにデフォルト値を決定します:
      </p><p>
        <code class="literal">NULL</code> を値として取ることができる場合は、そのカラムは明示的な <code class="literal">DEFAULT NULL</code> 句で定義ができます。
      </p><p>
        カラムが値として <code class="literal">NULL</code> を取ることができない場合、MySQL は明示的な <code class="literal">DEFAULT</code> 句を使用せずにカラムを定義します。
      </p><p>
        明示的な <code class="literal">DEFAULT</code> 句のない <code class="literal">NOT NULL</code> カラムに対するデータエントリでは、<code class="literal">INSERT</code> または <code class="literal">REPLACE</code> ステートメントにカラムの値を含まれていない場合、または <code class="literal">UPDATE</code> ステートメントがカラムを <code class="literal">NULL</code> に設定する場合、MySQL はその時点で有効な SQL モードに従ってカラムを処理します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            厳密な SQL モードを有効にした場合、トランザクションテーブルに対してエラーが発生し、ステートメントがロールバックされます。 非トランザクションテーブルではエラーが発生しますが、これが複数行ステートメントの 2 行目または後続の行で発生した場合は、前の行が挿入されます。 
          </p></li><li class="listitem"><p>
            厳密モードが有効でない場合、MySQL はカラムデータ型の暗黙的なデフォルト値にカラムを設定します。
          </p></li></ul></div><p>
        テーブル <code class="literal">t</code> が次のように定義されるとします。
      </p><pre class="programlisting">CREATE TABLE t (i INT NOT NULL);
</pre><p>
        この場合、<code class="literal">i</code> は明示的なデフォルトがないので、厳密モードでは次のそれぞれはステートメントはエラーになり、行は挿入されません。 厳密モードを使用しない場合、3 番目のステートメントだけでエラーが発生します。最初の 2 つのステートメントでは暗黙のデフォルトが挿入されますが、<code class="literal">DEFAULT(i)</code> が値を生成できないので 3 番目のステートメントは失敗します。 
      </p><pre class="programlisting">INSERT INTO t VALUES();
INSERT INTO t VALUES(DEFAULT);
INSERT INTO t VALUES(DEFAULT(i));
</pre><p>
        <a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a>を参照してください。
      </p><p>
        特定のテーブルについて、<code class="literal">SHOW CREATE TABLE</code> ステートメントは明示的な <code class="literal">DEFAULT</code> 句を持つカラムを表示します。
      </p><p>
        暗黙的なデフォルトは次のように定義されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            数値型のデフォルトは <code class="literal">0</code> です。ただし、例外として <code class="literal">AUTO_INCREMENT</code> 属性で宣言された整数型または浮動小数点型のデフォルトは、そのシーケンスの次の値になります。
          </p></li><li class="listitem"><p>
            <code class="literal">TIMESTAMP</code> 以外の日付と時間型のデフォルトには、<span class="quote">「<span class="quote">ゼロ</span>」</span>値が適切です。 <code class="literal">explicit_defaults_for_timestamp</code> システム変数が有効な場合、これは <code class="literal">TIMESTAMP</code> にも当てはまります (<a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>を参照してください)。 それ以外の場合、テーブルの最初の <code class="literal">TIMESTAMP</code> カラムのデフォルト値は現在の日付と時間になります。 <a class="xref" href="data-types.html#date-and-time-types" title="11.2 日時データ型">セクション11.2「日時データ型」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">ENUM</code> ではない文字列型のデフォルト値は空の文字列です。 <code class="literal">ENUM</code> のデフォルトは、最初の列挙値です。 
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="storage-requirements"></a>11.7 データ型のストレージ要件</h2></div></div></div><a class="indexterm" name="idm45661461597680"></a><a class="indexterm" name="idm45661461595552"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="data-types.html#data-types-storage-reqs-innodb" title="InnoDB テーブルの記憶域要件">InnoDB テーブルの記憶域要件</a></p></li><li class="listitem"><p><a class="xref" href="data-types.html#data-types-storage-reqs-ndb" title="NDB テーブルのストレージ要件">NDB テーブルのストレージ要件</a></p></li><li class="listitem"><p><a class="xref" href="data-types.html#data-types-storage-reqs-numeric" title="数値型の記憶域要件">数値型の記憶域要件</a></p></li><li class="listitem"><p><a class="xref" href="data-types.html#data-types-storage-reqs-date-time" title="日時型の格納要件">日時型の格納要件</a></p></li><li class="listitem"><p><a class="xref" href="data-types.html#data-types-storage-reqs-strings" title="文字列型の格納要件">文字列型の格納要件</a></p></li><li class="listitem"><p><a class="xref" href="data-types.html#data-types-storage-reqs-gis" title="空間型の記憶域要件">空間型の記憶域要件</a></p></li><li class="listitem"><p><a class="xref" href="data-types.html#data-types-storage-reqs-json" title="JSON 記憶域の要件">JSON 記憶域の要件</a></p></li></ul></div><p>
      ディスク上のテーブルデータのストレージ要件は、複数の要因によって異なります。 別々のストレージエンジンは異なる方法でデータ型を表し、ローデータを格納します。 カラムか行全体のどちらかでテーブルデータを圧縮できますが、テーブルまたはカラムのストレージ要件の計算が複雑になります。 
    </p><p>
      ディスク上のストレージレイアウトが違っていても、テーブル行に関する情報を通信および交換する内部 MySQL API は、すべてのストレージエンジンにわたって適用される一貫したデータ構造を使用します。
    </p><p>
      このセクションでは、データ型の固定サイズ表現を使用するストレージエンジンの内部形式およびサイズを含め、MySQL がサポートするデータ型ごとのストレージ要件に関するガイドラインおよび情報について説明します。 情報はカテゴリまたはストレージエンジンごとに示します。 
    </p><a class="indexterm" name="idm45661461582736"></a><p>
      テーブルの内部表現の最大行サイズは 65,535 バイトであり、ストレージエンジンがこれ以上のサイズの行をサポートできる場合でもこのサイズになります。 <code class="literal">BLOB</code> または <code class="literal">TEXT</code> カラムはこのサイズに 9 から 12 バイトしか関与しないので、これらのカラムはこのサイズに含まれません。 <code class="literal">BLOB</code> および <code class="literal">TEXT</code> データについての情報は、行バッファーとは異なるメモリー領域に内部的に格納されます。 それぞれのストレージエンジンは、対応する型の処理に使用する方法に従って異なる方法で、このデータの割り当ておよびストレージを扱います。 詳細は、<a class="xref" href="storage-engines.html" title="第 16 章 代替ストレージエンジン">第16章「<i>代替ストレージエンジン</i>」</a>および<a class="xref" href="optimization.html#column-count-limit" title="8.4.7 テーブルカラム数と行サイズの制限">セクション8.4.7「テーブルカラム数と行サイズの制限」</a>を参照してください。 
    </p><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="data-types-storage-reqs-innodb"></a>InnoDB テーブルの記憶域要件</h3></div></div></div><a class="indexterm" name="idm45661461572512"></a><a class="indexterm" name="idm45661461570416"></a><p>
        <code class="literal">InnoDB</code> テーブルのストレージ要件の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="15.10 InnoDB の行フォーマット">セクション15.10「InnoDB の行フォーマット」</a>を参照してください。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="data-types-storage-reqs-ndb"></a>NDB テーブルのストレージ要件</h3></div></div></div><a class="indexterm" name="idm45661461565232"></a><a class="indexterm" name="idm45661461563152"></a><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          <code class="literal">NDB</code> テーブルは、<span class="firstterm">4 バイトアライメント</span>を使用します。すべての <code class="literal">NDB</code> データストレージは、4 バイトの倍数で行われます。 したがって、通常であれば 15 バイトを使用するカラム値は、<code class="literal">NDB</code> テーブルでは 16 バイトを必要とします。 たとえば、<code class="literal">NDB</code> テーブルでは、<code class="literal">TINYINT</code>、<code class="literal">SMALLINT</code>、<code class="literal">MEDIUMINT</code>、および <code class="literal">INTEGER</code> (<code class="literal">INT</code>) カラム型はそれぞれ、アライメント係数により、レコードあたり 4 バイトのストレージが必要になります。 
        </p><p>
          各 <code class="literal">BIT(<em class="replaceable"><code>M</code></em>)</code> カラムは <em class="replaceable"><code>M</code></em> ビットのストレージ領域を使用します。 各 <code class="literal">BIT</code> カラムは 4 バイトアライメントが行われて<span class="emphasis"><em>いません</em></span>が、<code class="literal">NDB</code> は、<code class="literal">BIT</code> カラムに必要な最初の 1 から 32 ビットに行あたり 4 バイト (32 ビット) を、33 から 64 ビットに別の 4 ビットを、というように予約します。 
        </p><p>
          <code class="literal">NULL</code> 自体には記憶域領域は必要ありませんが、テーブル定義に <code class="literal">NULL</code> を許可するカラムが含まれている場合、<code class="literal">NDB</code> は行ごとに最大 32 の <code class="literal">NULL</code> カラムを予約します。 (「NDB Cluster」テーブルに 32 を超える <code class="literal">NULL</code> カラムが定義されている場合、行当たり 8 バイトが予約されます。) 
        </p></div><p>
        <code class="literal">NDB</code> ストレージエンジンを使用するすべてのテーブルで主キーが必要になります。主キーを定義していない場合、<span class="quote">「<span class="quote">非表示</span>」</span>の主キーが <code class="literal">NDB</code> によって作成されます。 この非表示の主キーはテーブルレコードあたり 31 から 35 バイトを消費します。 
      </p><a class="indexterm" name="idm45661461536624"></a><p>
        <span class="command"><strong>ndb_size.pl</strong></span> Perl スクリプトを使用して、<code class="literal">NDB</code> ストレージ要件を評価します。 現在の MySQL (NDB Cluster ではない) データベースに接続し、データベースが <code class="literal">NDB</code> ストレージエンジンを使用した場合に必要となる領域の量に関するレポートを作成します。 詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-programs-ndb-size-pl" title="23.4.28 ndb_size.pl — NDBCLUSTER サイズ要件エスティメータ">セクション23.4.28「ndb_size.pl — NDBCLUSTER サイズ要件エスティメータ」</a>を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="data-types-storage-reqs-numeric"></a>数値型の記憶域要件</h3></div></div></div><a class="indexterm" name="idm45661461529568"></a><a class="indexterm" name="idm45661461527392"></a><div class="informaltable"><table summary="Storage required for numeric data types."><col style="width: 40%"><col style="width: 60%"><thead><tr>
            <th>データ型</th>
            <th>必要なストレージ</th>
          </tr></thead><tbody><tr>
            <td><code class="literal">TINYINT</code></td>
            <td>1 バイト</td>
          </tr><tr>
            <td><code class="literal">SMALLINT</code></td>
            <td>2 バイト</td>
          </tr><tr>
            <td><code class="literal">MEDIUMINT</code></td>
            <td>3 バイト</td>
          </tr><tr>
            <td><code class="literal">INT</code>、<code class="literal">INTEGER</code></td>
            <td>4 バイト</td>
          </tr><tr>
            <td><code class="literal">BIGINT</code></td>
            <td>8 バイト</td>
          </tr><tr>
            <td><code class="literal">FLOAT(<em class="replaceable"><code>p</code></em>)</code></td>
            <td>0 &lt;= <em class="replaceable"><code>p</code></em> &lt;= 24 の場合は 4 バイト、25 &lt;= <em class="replaceable"><code>p</code></em> &lt;= 53 の場合は 8 バイト</td>
          </tr><tr>
            <td><code class="literal">FLOAT</code></td>
            <td>4 バイト</td>
          </tr><tr>
            <td><code class="literal">DOUBLE [PRECISION]</code>、<code class="literal">REAL</code></td>
            <td>8 バイト</td>
          </tr><tr>
            <td><code class="literal">DECIMAL(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code>、<code class="literal">NUMERIC(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code></td>
            <td>変動; 次の説明を参照</td>
          </tr><tr>
            <td><code class="literal">BIT(<em class="replaceable"><code>M</code></em>)</code></td>
            <td>約 (<em class="replaceable"><code>M</code></em>+7)/8 バイト</td>
          </tr></tbody></table></div><p>
        <code class="literal">DECIMAL</code> (および <code class="literal">NUMERIC</code>) カラムの値は、9 桁の 10 進数 (10 進法) を 4 バイトにパックするバイナリ形式を使用して表現されます。 各値の整数部と小数部のストレージは、個別に決定されます。 9 桁の倍ごとに 4 バイトが必要であり、<span class="quote">「<span class="quote">余りの</span>」</span>桁には 4 バイトのうちの一部が必要です。 余りの桁に必要なストレージ要件を次の表に示します。 
      </p><div class="informaltable"><table summary="Storage required by excess/leftover digits in DECIMAL values."><col style="width: 25%"><col style="width: 25%"><thead><tr>
            <th>余りの桁</th>
            <th>バイト数</th>
          </tr></thead><tbody><tr>
            <td>0</td>
            <td>0</td>
          </tr><tr>
            <td>1</td>
            <td>1</td>
          </tr><tr>
            <td>2</td>
            <td>1</td>
          </tr><tr>
            <td>3</td>
            <td>2</td>
          </tr><tr>
            <td>4</td>
            <td>2</td>
          </tr><tr>
            <td>5</td>
            <td>3</td>
          </tr><tr>
            <td>6</td>
            <td>3</td>
          </tr><tr>
            <td>7</td>
            <td>4</td>
          </tr><tr>
            <td>8</td>
            <td>4</td>
          </tr></tbody></table></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="data-types-storage-reqs-date-time"></a>日時型の格納要件</h3></div></div></div><a class="indexterm" name="idm45661461457472"></a><a class="indexterm" name="idm45661461455296"></a><a class="indexterm" name="idm45661461453232"></a><a class="indexterm" name="idm45661461451168"></a><p>
        <code class="literal">TIME</code>、<code class="literal">DATETIME</code>、および <code class="literal">TIMESTAMP</code> カラムの場合、MySQL 5.6.4 よりも前に作成されたテーブルに必要なストレージは、5.6.4 以降で作成されたテーブルとは異なります。 これは、5.6.4 で、0 から 3 バイトを必要とする小数部をこれらの型が持つことを許可するように変更されたためです。 
      </p><div class="informaltable"><table summary="Storage required for date and time data types before MySQL 5.6.4 and as of MySQL 5.6.4."><col style="width: 20%"><col style="width: 40%"><col style="width: 40%"><thead><tr>
            <th scope="col">データ型</th>
            <th scope="col">MySQL 5.6.4 より前で必要なストレージ</th>
            <th scope="col">MySQL 5.6.4 以降で必要なストレージ</th>
          </tr></thead><tbody><tr>
            <th scope="row"><code class="literal">YEAR</code></th>
            <td>1 バイト</td>
            <td>1 バイト</td>
          </tr><tr>
            <th scope="row"><code class="literal">DATE</code></th>
            <td>3 バイト</td>
            <td>3 バイト</td>
          </tr><tr>
            <th scope="row"><code class="literal">TIME</code></th>
            <td>3 バイト</td>
            <td>3 バイト + 小数秒ストレージ</td>
          </tr><tr>
            <th scope="row"><code class="literal">DATETIME</code></th>
            <td>8 バイト</td>
            <td>5 バイト + 小数秒ストレージ</td>
          </tr><tr>
            <th scope="row"><code class="literal">TIMESTAMP</code></th>
            <td>4 バイト</td>
            <td>4 バイト + 小数秒ストレージ</td>
          </tr></tbody></table></div><p>
        MySQL 5.6.4 以降、<code class="literal">YEAR</code> および <code class="literal">DATE</code> のストレージは変更ありません。 ただし、<code class="literal">TIME</code>、<code class="literal">DATETIME</code>、および <code class="literal">TIMESTAMP</code> は異なって表現されます。 <code class="literal">DATETIME</code> はより効率的にパックされ、非小数部に必要なバイト数は 8 バイトではなく 5 バイトであり、3 つの部分すべてに、格納値の小数秒精度に応じて 0 から 3 バイトが必要な小数部があります。 
      </p><div class="informaltable"><table summary="Required storage for fractional seconds precision."><col style="width: 50%"><col style="width: 50%"><thead><tr>
            <th>小数秒精度</th>
            <th>必要なストレージ</th>
          </tr></thead><tbody><tr>
            <td>0</td>
            <td>0 バイト</td>
          </tr><tr>
            <td>1、2</td>
            <td>1 バイト</td>
          </tr><tr>
            <td>3、4</td>
            <td>2 バイト</td>
          </tr><tr>
            <td>5、6</td>
            <td>3 バイト</td>
          </tr></tbody></table></div><p>
        たとえば、<code class="literal">TIME(0)</code>、<code class="literal">TIME(2)</code>、<code class="literal">TIME(4)</code>、および <code class="literal">TIME(6)</code> はそれぞれ 3、4、5、6 バイトを使用します。 <code class="literal">TIME</code> と <code class="literal">TIME(0)</code> は同等で、必要なストレージは同じです。 
      </p><p>
        時間値の内部表現の詳細は、「<a class="ulink" href="https://dev.mysql.com/doc/internals/en/algorithms.html" target="_top">MySQL Internals: Important Algorithms and Structures</a>」を参照してください。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="data-types-storage-reqs-strings"></a>文字列型の格納要件</h3></div></div></div><a class="indexterm" name="idm45661461387312"></a><a class="indexterm" name="idm45661461385136"></a><p>
        次の表では、<em class="replaceable"><code>M</code></em> は宣言されたカラムの長さを、非バイナリ文字列型の場合は文字数で、バイナリ文字列型の場合はバイト数で表します。 <em class="replaceable"><code>L</code></em> は指定された文字列値の実際の長さをバイト数で表します。 
      </p><div class="informaltable"><table summary="Storage required for string types."><col style="width: 40%"><col style="width: 60%"><thead><tr>
            <th>データ型</th>
            <th>必要なストレージ</th>
          </tr></thead><tbody><tr>
            <td><code class="literal">CHAR(<em class="replaceable"><code>M</code></em>)</code></td>
            <td>InnoDB 行形式のコンパクトファミリは、可変長文字セットの記憶域を最適化します。 <a class="xref" href="innodb-storage-engine.html#innodb-compact-row-format-characteristics" title="COMPACT 行形式の格納特性">COMPACT 行形式の格納特性</a>を参照してください。 それ以外の場合は、<em class="replaceable"><code>M</code></em>× <em class="replaceable"><code>w</code></em> バイト、<code class="literal">&lt;= <em class="replaceable"><code>M</code></em> &lt;=</code> 255。ここで、<em class="replaceable"><code>w</code></em> は、文字セット内の最大長文字に必要なバイト数です。 </td>
          </tr><tr>
            <td><code class="literal">BINARY(<em class="replaceable"><code>M</code></em>)</code></td>
            <td><em class="replaceable"><code>M</code></em> バイト、0 <code class="literal">&lt;= <em class="replaceable"><code>M</code></em> &lt;=</code> 255</td>
          </tr><tr>
            <td><code class="literal">VARCHAR(<em class="replaceable"><code>M</code></em>)</code>、<code class="literal">VARBINARY(<em class="replaceable"><code>M</code></em>)</code></td>
            <td>カラム値が 0 から 255 バイトを必要とする場合は、<em class="replaceable"><code>L</code></em> + 1 バイト、値が 255 バイト以上を必要とする可能性のある場合は、<em class="replaceable"><code>L</code></em> + 2 バイト</td>
          </tr><tr>
            <td><code class="literal">TINYBLOB</code>、<code class="literal">TINYTEXT</code></td>
            <td><em class="replaceable"><code>L</code></em> + 1 バイト、ここで <em class="replaceable"><code>L</code></em> &lt; 2<sup>8</sup></td>
          </tr><tr>
            <td><code class="literal">BLOB</code>、<code class="literal">TEXT</code></td>
            <td><em class="replaceable"><code>L</code></em> + 2 バイト、ここで <em class="replaceable"><code>L</code></em> &lt; 2<sup>16</sup></td>
          </tr><tr>
            <td><code class="literal">MEDIUMBLOB</code>、<code class="literal">MEDIUMTEXT</code></td>
            <td><em class="replaceable"><code>L</code></em> + 3 バイト、ここで <em class="replaceable"><code>L</code></em> &lt; 2<sup>24</sup></td>
          </tr><tr>
            <td><code class="literal">LONGBLOB</code>、<code class="literal">LONGTEXT</code></td>
            <td><em class="replaceable"><code>L</code></em> + 4 バイト、ここで <em class="replaceable"><code>L</code></em> &lt; 2<sup>32</sup></td>
          </tr><tr>
            <td><code class="literal">ENUM('<em class="replaceable"><code>value1</code></em>','<em class="replaceable"><code>value2</code></em>',...)</code></td>
            <td>列挙値の数 (最大 65,535 個の値) により 1 または 2 バイト</td>
          </tr><tr>
            <td><code class="literal">SET('<em class="replaceable"><code>value1</code></em>','<em class="replaceable"><code>value2</code></em>',...)</code></td>
            <td>セットメンバーの数 (最大 64 メンバー) により、1、2、3、4、または 8 バイト</td>
          </tr></tbody></table></div><p>
        可変長の文字列型は、長さプリフィクスが付いたデータを使用して格納されます。 長さプリフィクスにはデータ型に応じて 1 から 4 バイトが必要で、プリフィクスの値は <em class="replaceable"><code>L</code></em> (文字列のバイト長) です。 たとえば、<code class="literal">MEDIUMTEXT</code> 値のストレージには、値を格納するための <em class="replaceable"><code>L</code></em> バイトに加えて、値の長さを格納するための 3 バイトが必要です。 
      </p><p>
        特定の <code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、または <code class="literal">TEXT</code> カラム値の格納に使用されるバイト数を計算するには、そのカラムに使用される文字セットと、値にマルチバイト文字が含まれるかどうかを考慮する必要があります。 特に、<code class="literal">utf8</code> Unicode 文字セットを使用する場合は、すべての文字が同じバイト数を使用するわけではないことに注意する必要があります。<code class="literal">utf8mb3</code> および <code class="literal">utf8mb4</code> の文字セットには、それぞれ最大 3 バイトと 4 バイトが必要です。 様々なカテゴリの <code class="literal">utf8mb3</code> または <code class="literal">utf8mb4</code> 文字に使用される記憶域の内訳は、<a class="xref" href="charset.html#charset-unicode" title="10.9 Unicode のサポート">セクション10.9「Unicode のサポート」</a> を参照してください。 
      </p><a class="indexterm" name="idm45661461321584"></a><a class="indexterm" name="idm45661461319456"></a><a class="indexterm" name="idm45661461317424"></a><p>
        <code class="literal">VARCHAR</code>、<code class="literal">VARBINARY</code>、および <code class="literal">BLOB</code> と <code class="literal">TEXT</code> 型は可変長型です。 それぞれのストレージ要件は次の要因によって決まります。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            カラム値の実際の長さ
          </p></li><li class="listitem"><p>
            カラムの可能な最大の長さ
          </p></li><li class="listitem"><p>
            カラムに使用される文字セット。一部の文字セットにはマルチバイト文字が含まれるため。
          </p></li></ul></div><p>
        たとえば、<code class="literal">VARCHAR(255)</code> カラムには最大 255 文字の長さの文字列を格納できます。 そのカラムが <code class="literal">latin1</code> 文字セット (1 文字あたり 1 バイト) を使用すると仮定すると、実際に必要なストレージは文字列の長さ (<em class="replaceable"><code>L</code></em>) に、文字列の長さを記録するための 1 バイトを加えた大きさとなります。 文字列 <code class="literal">'abcd'</code> の場合、<em class="replaceable"><code>L</code></em> は 4 で、ストレージ要件は 5 バイトになります。 同じカラムが代わりにダブルバイト文字セット <code class="literal">ucs2</code> を使用するように宣言されている場合、ストレージ要件は 10 バイトになります。<code class="literal">'abcd'</code> の長さは 8 バイトで、カラムの最大長が 255 よりも大きい (最大 510 バイト) ため、長さを格納するために 2 バイト必要になります。 
      </p><p>
        <code class="literal">VARCHAR</code> または <code class="literal">VARBINARY</code> カラムに格納できる有効な最大<span class="emphasis"><em>バイト数</em></span>は最大行サイズ (65,535 バイト、すべてのカラムで共有される) によって決まります。 複数バイト文字を格納する <code class="literal">VARCHAR</code> カラムの場合、<span class="emphasis"><em>文字</em></span>の有効な最大数は少なくなります。 たとえば、<code class="literal">utf8mb4</code> 文字には文字ごとに最大 4 バイトが必要な場合があるため、<code class="literal">utf8mb4</code> 文字セットを使用する <code class="literal">VARCHAR</code> カラムは 16,383 文字まで宣言できます。 <a class="xref" href="optimization.html#column-count-limit" title="8.4.7 テーブルカラム数と行サイズの制限">セクション8.4.7「テーブルカラム数と行サイズの制限」</a>を参照してください。 
      </p><p>
        <code class="literal">InnoDB</code> では、768 バイト以上の固定長フィールドが可変長フィールドとしてエンコードされ、オフページに格納できます。 たとえば、<code class="literal">utf8mb4</code> と同様に、文字セットの最大バイト長が 3 より大きい場合、<code class="literal">CHAR(255)</code> カラムは 768 バイトを超えることがあります。 
      </p><p>
        <code class="literal">NDB</code> ストレージエンジンは可変幅カラムをサポートします。 つまり、「NDB Cluster」テーブルの <code class="literal">VARCHAR</code> カラムには、ほかのストレージエンジンと同じ量のストレージが必要ですが、このような値が 4 バイトに整列されている点が異なります。 したがって、<code class="literal">latin1</code> 文字セットを使用して <code class="literal">VARCHAR(50)</code> カラムに格納された文字列 <code class="literal">'abcd'</code> は、(<code class="literal">MyISAM</code> テーブル内の同じカラム値に対する 5 バイトではなく) 8 バイトを必要とします。 
      </p><p>
        <code class="literal">NDB</code> では、<code class="literal">TEXT</code> カラムと <code class="literal">BLOB</code> カラムは異なる方法で実装されます。<code class="literal">TEXT</code> カラムの各行は、2 つの部分で構成されます。 そのうちの 1 つは固定サイズ (256 バイト) で、実際に元のテーブルに格納されます。 もう 1 つは 256 バイトを超えるデータで構成され、非表示のテーブルに格納されます。 2 番目のテーブルの行の長さは常に 2000 バイトです。 これは、<em class="replaceable"><code>size</code></em> &lt;= 256 (<em class="replaceable"><code>size</code></em> は行のサイズを表す) の場合、<code class="literal">TEXT</code> カラムのサイズが 256 であることを意味します。それ以外の場合、サイズは 256 + <em class="replaceable"><code>size</code></em> + (2000 × (<em class="replaceable"><code>size</code></em> − 256) % 2000) です。 
      </p><a class="indexterm" name="idm45661461276496"></a><p>
        <code class="literal">ENUM</code> オブジェクトのサイズは異なる列挙値の数によって決まります。 最大 255 の値を持つ列挙に 1 バイトが使用されます。 256 から 65,535 の値を持つ列挙に 2 バイトが使用されます。 <a class="xref" href="data-types.html#enum" title="11.3.5 ENUM 型">セクション11.3.5「ENUM 型」</a>を参照してください。 
      </p><a class="indexterm" name="idm45661461271904"></a><p>
        <code class="literal">SET</code> オブジェクトのサイズは異なるセットメンバーの数によって決まります。 セットサイズが <em class="replaceable"><code>N</code></em> である場合、オブジェクトは 1、2、3、4、または 8 バイトに丸められた <code class="literal">(<em class="replaceable"><code>N</code></em>+7)/8</code> バイトを占めます。 <code class="literal">SET</code> は最大 64 メンバーを持つことができます。 <a class="xref" href="data-types.html#set" title="11.3.6 SET 型">セクション11.3.6「SET 型」</a>を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="data-types-storage-reqs-gis"></a>空間型の記憶域要件</h3></div></div></div><a class="indexterm" name="idm45661461263680"></a><a class="indexterm" name="idm45661461261536"></a><a class="indexterm" name="idm45661461259472"></a><p>
        MySQL では、SRID の後に WKB 表現の値が続くことを示す 4 バイトを使用してジオメトリ値が格納されます。 <code class="literal">LENGTH()</code> 関数は、値の格納に必要な領域をバイト単位で返します。 
      </p><p>
        WKB および空間値の内部記憶域形式の詳細は、<a class="xref" href="data-types.html#gis-data-formats" title="11.4.3 サポートされる空間データ形式">セクション11.4.3「サポートされる空間データ形式」</a> を参照してください。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="data-types-storage-reqs-json"></a>JSON 記憶域の要件</h3></div></div></div><p>
        一般に、<code class="literal">JSON</code> カラムの記憶域要件は、<code class="literal">LONGBLOB</code> または <code class="literal">LONGTEXT</code> カラムの場合とほぼ同じです。つまり、JSON ドキュメントによって消費される領域は、これらのいずれかの型のカラムに格納されるドキュメント文字列表現の場合とほぼ同じです。 ただし、JSON ドキュメントに格納されている個々の値のメタデータやディクショナリなど、バイナリエンコーディングによるオーバーヘッドがあります。 たとえば、JSON ドキュメントに格納されている文字列には、文字列の長さおよび格納されているオブジェクトまたは配列のサイズに応じて、4 から 10 バイトの追加記憶域が必要です。 
      </p><p>
        また、MySQL では、<code class="literal">max_allowed_packet</code> の値より大きくできないように、<code class="literal">JSON</code> カラムに格納される JSON ドキュメントのサイズに制限が課されます。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="choosing-types"></a>11.8 カラムに適した型の選択</h2></div></div></div><a class="indexterm" name="idm45661461244848"></a><a class="indexterm" name="idm45661461242736"></a><p>
      最適なストレージのために、毎回もっとも正確な型を使用するよう試みる必要があります。 たとえば、整数カラムを <code class="literal">1</code> から <code class="literal">99999</code> の範囲の値に使用する場合、<code class="literal">MEDIUMINT UNSIGNED</code> が最適な型になります。 必要なすべての値を表す型の中で、これが、使用するストレージの容量がもっとも少ない型になります。 
    </p><p>
      <code class="literal">DECIMAL</code> カラムを使用した基本的なすべての計算 (<code class="literal">+</code>、<code class="literal">-</code>、<code class="literal">*</code>、および <code class="literal">/</code>) は、65 桁 (10 進法) の精度で行われます。 <a class="xref" href="data-types.html#numeric-type-syntax" title="11.1.1 数値データ型の構文">セクション11.1.1「数値データ型の構文」</a>を参照してください。 
    </p><p>
      精度がそれほど重要でない場合や、スピードが最優先事項である場合は、<code class="literal">DOUBLE</code> 型で十分と考えられます。 精度を高めるために、<code class="literal">BIGINT</code> に格納されている固定小数点型にいつでも変換できます。 これにより、64 ビット整数のすべての計算を行い、続いて必要に応じて結果を浮動小数点値に戻すことができます。 
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="other-vendor-data-types"></a>11.9 その他のデータベースエンジンのデータ型の使用</h2></div></div></div><a class="indexterm" name="idm45661461227856"></a><a class="indexterm" name="idm45661461225744"></a><a class="indexterm" name="idm45661461223712"></a><a class="indexterm" name="idm45661461221680"></a><a class="indexterm" name="idm45661461219760"></a><p>
      ほかのベンダーからの SQL 実装用に作成されたコードを使用しやすくするために、次の表に示すように、MySQL はデータ型をマップします。 これらのマッピングにより、ほかのデータベースシステムから MySQL へのテーブル定義の取り込みが簡単に行えるようになります。 
    </p><div class="informaltable"><table summary="Mapping of MySQL data types to data types from other vendors."><col style="width: 35%"><col style="width: 55%"><thead><tr>
          <th>その他のベンダーの型</th>
          <th>MySQL の型</th>
        </tr></thead><tbody><tr>
          <td><code class="literal">BOOL</code></td>
          <td><code class="literal">TINYINT</code></td>
        </tr><tr>
          <td><code class="literal">BOOLEAN</code></td>
          <td><code class="literal">TINYINT</code></td>
        </tr><tr>
          <td><code class="literal">CHARACTER VARYING(<em class="replaceable"><code>M</code></em>)</code></td>
          <td><code class="literal">VARCHAR(<em class="replaceable"><code>M</code></em>)</code></td>
        </tr><tr>
          <td><code class="literal">FIXED</code></td>
          <td><code class="literal">DECIMAL</code></td>
        </tr><tr>
          <td><code class="literal">FLOAT4</code></td>
          <td><code class="literal">FLOAT</code></td>
        </tr><tr>
          <td><code class="literal">FLOAT8</code></td>
          <td><code class="literal">DOUBLE</code></td>
        </tr><tr>
          <td><code class="literal">INT1</code></td>
          <td><code class="literal">TINYINT</code></td>
        </tr><tr>
          <td><code class="literal">INT2</code></td>
          <td><code class="literal">SMALLINT</code></td>
        </tr><tr>
          <td><code class="literal">INT3</code></td>
          <td><code class="literal">MEDIUMINT</code></td>
        </tr><tr>
          <td><code class="literal">INT4</code></td>
          <td><code class="literal">INT</code></td>
        </tr><tr>
          <td><code class="literal">INT8</code></td>
          <td><code class="literal">BIGINT</code></td>
        </tr><tr>
          <td><code class="literal">LONG VARBINARY</code></td>
          <td><code class="literal">MEDIUMBLOB</code></td>
        </tr><tr>
          <td><code class="literal">LONG VARCHAR</code></td>
          <td><code class="literal">MEDIUMTEXT</code></td>
        </tr><tr>
          <td><code class="literal">LONG</code></td>
          <td><code class="literal">MEDIUMTEXT</code></td>
        </tr><tr>
          <td><code class="literal">MIDDLEINT</code></td>
          <td><code class="literal">MEDIUMINT</code></td>
        </tr><tr>
          <td><code class="literal">NUMERIC</code></td>
          <td><code class="literal">DECIMAL</code></td>
        </tr></tbody></table></div><p>
      データ型のマッピングはテーブル作成時に行われ、作成後に元の型の仕様は破棄されます。 ほかのベンダーで使用されている型でテーブルを作成したあとで、<code class="literal">DESCRIBE <em class="replaceable"><code>tbl_name</code></em></code> ステートメントを発行した場合、MySQL は、その型と同等の MySQL の型を使用したテーブル構造をレポートします。 例: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t (a BOOL, b FLOAT8, c LONG VARCHAR, d NUMERIC);</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>DESCRIBE t;</code></strong>
+-------+---------------+------+-----+---------+-------+
| Field | Type          | Null | Key | Default | Extra |
+-------+---------------+------+-----+---------+-------+
| a     | tinyint(1)    | YES  |     | NULL    |       |
| b     | double        | YES  |     | NULL    |       |
| c     | mediumtext    | YES  |     | NULL    |       |
| d     | decimal(10,0) | YES  |     | NULL    |       |
+-------+---------------+------+-----+---------+-------+
4 rows in set (0.01 sec)
</pre></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="charset.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="functions.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第 10 章 文字セット、照合順序、Unicode </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第 12 章 関数と演算子</td></tr></table></div><div class="copyright-footer"></div></body></html>
