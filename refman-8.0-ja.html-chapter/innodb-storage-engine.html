<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第 15 章 InnoDB ストレージエンジン</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="MySQL 8.0 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 8.0 リファレンスマニュアル"><link rel="prev" href="data-dictionary.html" title="第 14 章 MySQL データディクショナリ"><link rel="next" href="storage-engines.html" title="第 16 章 代替ストレージエンジン"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 15 章 InnoDB ストレージエンジン</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="data-dictionary.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="storage-engines.html">次へ</a></td></tr></table><hr></div><div class="status-header"><p class="alert">このページは機械翻訳したものです。</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="innodb-storage-engine"></a>第 15 章 InnoDB ストレージエンジン</h1></div></div></div><div class="toc"><p><b>目次</b></p><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-introduction">15.1 InnoDB 入門</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-benefits">15.1.1 InnoDB テーブルを使用する利点</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-best-practices">15.1.2 InnoDB テーブルのベストプラクティス</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-check-availability">15.1.3 InnoDB がデフォルトのストレージエンジンであるかどうかの確認</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-benchmarking">15.1.4 InnoDB を使用したテストおよびベンチマーク</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#mysql-acid">15.2 InnoDB および ACID モデル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-multi-versioning">15.3 InnoDB マルチバージョン</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-architecture">15.4 InnoDB のアーキテクチャ</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-in-memory-structures">15.5 InnoDB インメモリー構造</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-buffer-pool">15.5.1 バッファプール</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-change-buffer">15.5.2 変更バッファ</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-adaptive-hash">15.5.3 適応型ハッシュインデックス</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-redo-log-buffer">15.5.4 ログバッファ</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-on-disk-structures">15.6 InnoDB オンディスク構造</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-tables">15.6.1 テーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-indexes">15.6.2 インデックス</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-tablespace">15.6.3 テーブルスペース</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-doublewrite-buffer">15.6.4 二重書き込みバッファー</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-redo-log">15.6.5 redo ログ</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-undo-logs">15.6.6 undo ログ</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-locking-transaction-model">15.7 InnoDB のロックおよびトランザクションモデル</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-locking">15.7.1 InnoDB ロック</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-transaction-model">15.7.2 InnoDB トランザクションモデル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-locks-set">15.7.3 InnoDB のさまざまな SQL ステートメントで設定されたロック</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-next-key-locking">15.7.4 ファントム行</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-deadlocks">15.7.5 InnoDB のデッドロック</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-transaction-scheduling">15.7.6 トランザクションスケジューリング</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-configuration">15.8 InnoDB の構成</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-init-startup-configuration">15.8.1 InnoDB の起動構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-read-only-instance">15.8.2 読み取り専用操作用の InnoDB の構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-buffer-pool">15.8.3 InnoDB バッファープールの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-thread_concurrency">15.8.4 InnoDB のスレッド並列性の構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-multiple_io_threads">15.8.5 InnoDB バックグラウンド I/O スレッドの数の構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-linux-native-aio">15.8.6 Linux での非同期 I/O の使用</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-configuring-io-capacity">15.8.7 InnoDB I/O Capacity の構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-spin_lock_polling">15.8.8 スピンロックのポーリングの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-purge-configuration">15.8.9 パージ構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-optimizer-statistics">15.8.10 InnoDB のオプティマイザ統計の構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#index-page-merge-threshold">15.8.11 インデックスページのマージしきい値の構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-dedicated-server">15.8.12 専用 MySQL Server の自動構成の有効化</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression">15.9 InnoDB のテーブルおよびページの圧縮</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-table-compression">15.9.1 InnoDB テーブルの圧縮</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-page-compression">15.9.2 InnoDB ページ圧縮</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-row-format">15.10 InnoDB の行フォーマット</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-disk-management">15.11 InnoDB のディスク I/O とファイル領域管理</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-disk-io">15.11.1 InnoDB ディスク I/O</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-space">15.11.2 ファイル領域管理</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-checkpoints">15.11.3 InnoDB チェックポイント</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-defragmenting">15.11.4 テーブルのデフラグ</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-truncate-table-reclaim-space">15.11.5 TRUNCATE TABLE によるディスク領域の再利用</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl">15.12 InnoDB とオンライン DDL</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-operations">15.12.1 オンライン DDL 操作</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-performance">15.12.2 オンライン DDL のパフォーマンスと同時実行性</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-space-requirements">15.12.3 オンライン DDL 領域の要件</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-single-multi">15.12.4 オンライン DDL を使用した DDL ステートメントの簡略化</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-failure-conditions">15.12.5 オンライン DDL 失敗条件</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-limitations">15.12.6 オンライン DDL の制限事項</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-data-encryption">15.13 InnoDB 保存データ暗号化</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-parameters">15.14 InnoDB の起動オプションおよびシステム変数</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema">15.15 InnoDB INFORMATION_SCHEMA テーブル</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-compression-tables">15.15.1 圧縮に関する InnoDB INFORMATION_SCHEMA テーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-transactions">15.15.2 InnoDB INFORMATION_SCHEMA トランザクションおよびロック情報</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-system-tables">15.15.3 InnoDB INFORMATION_SCHEMA スキーマオブジェクトテーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-fulltext_index-tables">15.15.4 InnoDB INFORMATION_SCHEMA FULLTEXT インデックステーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-buffer-pool-tables">15.15.5 InnoDB INFORMATION_SCHEMA バッファープールテーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-metrics-table">15.15.6 InnoDB INFORMATION_SCHEMA メトリックテーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-temp-table-info">15.15.7 InnoDB INFORMATION_SCHEMA 一時テーブル情報テーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-files-table">15.15.8 INFORMATION_SCHEMA.FILES からの InnoDB テーブルスペースメタデータの取得</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-schema">15.16 InnoDB の MySQL パフォーマンススキーマとの統合</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#monitor-alter-table-performance-schema">15.16.1 パフォーマンススキーマを使用した InnoDB テーブルの ALTER TABLE の進行状況のモニタリング</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#monitor-innodb-mutex-waits-performance-schema">15.16.2 パフォーマンススキーマを使用した InnoDB Mutex 待機のモニタリング</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-monitors">15.17 InnoDB モニター</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-monitor-types">15.17.1 InnoDB モニターのタイプ</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-enabling-monitors">15.17.2 InnoDB モニターの有効化</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-standard-monitor">15.17.3 InnoDB 標準モニターおよびロックモニターの出力</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-backup-recovery">15.18 InnoDB のバックアップとリカバリ</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-backup">15.18.1 InnoDB バックアップ</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-recovery">15.18.2 InnoDB のリカバリ</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-and-mysql-replication">15.19 InnoDB と MySQL レプリケーション</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached">15.20 InnoDB memcached プラグイン</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-benefits">15.20.1 InnoDB memcached プラグインの利点</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-intro">15.20.2 InnoDB memcached のアーキテクチャー</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-setup">15.20.3 InnoDB memcached プラグインの設定</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-multiple-get-range-query">15.20.4 InnoDB memcached の複数の get および Range クエリーのサポート</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-security">15.20.5 InnoDB memcached プラグインのセキュリティーに関する考慮事項</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-developing">15.20.6 InnoDB memcached プラグイン用のアプリケーションの記述</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-replication">15.20.7 InnoDB memcached プラグインとレプリケーション</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-internals">15.20.8 InnoDB memcached プラグインの内部</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-troubleshoot">15.20.9 InnoDB memcached プラグインのトラブルシューティング</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-troubleshooting">15.21 InnoDB のトラブルシューティング</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#error-creating-innodb">15.21.1 InnoDB の I/O に関する問題のトラブルシューティング</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#forcing-innodb-recovery">15.21.2 InnoDB のリカバリの強制的な実行</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-troubleshooting-datadict">15.21.3 InnoDB データディクショナリの操作のトラブルシューティング</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-error-handling">15.21.4 InnoDB のエラー処理</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-limits">15.22 InnoDB の制限</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-restrictions-limitations">15.23 InnoDB の制限および制限事項</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-introduction"></a>15.1 InnoDB 入門</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-benefits">15.1.1 InnoDB テーブルを使用する利点</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-best-practices">15.1.2 InnoDB テーブルのベストプラクティス</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-check-availability">15.1.3 InnoDB がデフォルトのストレージエンジンであるかどうかの確認</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-benchmarking">15.1.4 InnoDB を使用したテストおよびベンチマーク</a></span></dt></dl></div><a class="indexterm" name="idm44761365725456"></a><a class="indexterm" name="idm44761365723424"></a><a class="indexterm" name="idm44761365721904"></a><a class="indexterm" name="idm44761365719984"></a><a class="indexterm" name="idm44761365718640"></a><a class="indexterm" name="idm44761365716464"></a><a class="indexterm" name="idm44761365715056"></a><a class="indexterm" name="idm44761365713824"></a><a class="indexterm" name="idm44761365712352"></a><p>
    <code class="literal">InnoDB</code> は、高い信頼性と高いパフォーマンスとのバランスをとる汎用のストレージエンジンです。 MySQL 8.0 では、<code class="literal">InnoDB</code> がデフォルトの MySQL ストレージエンジンです。 別のデフォルトのストレージエンジンを構成していないかぎり、<code class="literal">ENGINE=</code> 句を指定せずに <code class="literal">CREATE TABLE</code> ステートメントを発行すると、<code class="literal">InnoDB</code> テーブルが作成されます。 
  </p><h3><a name="innodb-key-advantages"></a>InnoDB の主要な利点</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        その <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> 操作は、<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>にユーザーデータを保護するための<a class="link" href="glossary.html#glos_commit" title="コミット">コミット</a>、<a class="link" href="glossary.html#glos_rollback" title="ロールバック">ロールバック</a>、および<a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>機能が備わっている <a class="link" href="glossary.html#glos_acid" title="ACID">ACID</a> モデルに従っています。 詳しくは<a class="xref" href="innodb-storage-engine.html#mysql-acid" title="15.2 InnoDB および ACID モデル">セクション15.2「InnoDB および ACID モデル」</a>をご覧ください。 
      </p></li><li class="listitem"><p>
        行レベルの<a class="link" href="glossary.html#glos_locking" title="ロック">ロック</a>と Oracle スタイルの<a class="link" href="glossary.html#glos_consistent_read" title="一貫性読み取り">一貫性読み取り</a>を使用すると、複数ユーザーの並列性およびパフォーマンスが向上します。 詳しくは<a class="xref" href="innodb-storage-engine.html#innodb-locking-transaction-model" title="15.7 InnoDB のロックおよびトランザクションモデル">セクション15.7「InnoDB のロックおよびトランザクションモデル」</a>をご覧ください。 
      </p></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> テーブルでは、<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>に基づいてクエリーが最適化されるように、ディスク上のデータが整列されます。 各 <code class="literal">InnoDB</code> テーブルには、主キー検索用の I/O を最小限に抑えるためにデータを編成する <a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">clustered index</a> と呼ばれる主キーインデックスがあります。 詳しくは<a class="xref" href="innodb-storage-engine.html#innodb-index-types" title="15.6.2.1 クラスタインデックスとセカンダリインデックス">セクション15.6.2.1「クラスタインデックスとセカンダリインデックス」</a>をご覧ください。 
      </p></li><li class="listitem"><p>
        データ <a class="link" href="glossary.html#glos_referential_integrity" title="参照整合性">integrity</a> をメンテナンスするために、<code class="literal">InnoDB</code> では <a class="link" href="glossary.html#glos_foreign_key" title="外部キー"><code class="literal">FOREIGN KEY</code></a> 制約がサポートされています。 外部キーでは、挿入、更新および削除がチェックされ、異なるテーブル間で不整合が発生しないことが確認されます。 詳しくは<a class="xref" href="sql-statements.html#create-table-foreign-keys" title="13.1.20.5 FOREIGN KEY の制約">セクション13.1.20.5「FOREIGN KEY の制約」</a>をご覧ください。 
      </p></li></ul></div><div class="table"><a name="idm44761365683808"></a><p class="title"><b>表 15.1 「InnoDB ストレージエンジンの機能」</b></p><div class="table-contents"><table frame="box" rules="all" summary="「InnoDB ストレージエンジンでサポートされる機能。」"><col style="width: 60%"><col style="width: 40%"><thead><tr><th>機能</th>
<th>Support</th>
</tr></thead><tbody><tr><td><span class="bold"><strong>B ツリーインデックス</strong></span></td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>MVCC</strong></span></td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>T ツリーインデックス</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>インデックスキャッシュ</strong></span></td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>クラスタデータベースのサポート</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>クラスタ化されたインデックス</strong></span></td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>ストレージの制限</strong></span></td>
<td>64TB</td>
</tr><tr><td><span class="bold"><strong>データキャッシュ</strong></span></td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>データディクショナリ向け更新統計</strong></span></td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>トランザクション</strong></span></td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>ハッシュインデックス</strong></span></td>
<td>いいえ (InnoDB は、アダプティブハッシュインデックス機能に対して、内部的にハッシュインデックスを利用します。)</td>
</tr><tr><td><span class="bold"><strong>バックアップ/ポイントインタイムリカバリ</strong></span> (ストレージエンジン内ではなくサーバー内で実装されています。)</td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>レプリケーションのサポート</strong></span> (ストレージエンジン内ではなくサーバー内で実装されています。)</td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>ロック粒度</strong></span></td>
<td>行</td>
</tr><tr><td><span class="bold"><strong>全文検索インデックス</strong></span></td>
<td>はい (FULLTEXT インデックスに対する InnoDB サポートは、MySQL 5.6 以降で使用できます。)</td>
</tr><tr><td><span class="bold"><strong>圧縮データ</strong></span></td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>地理空間インデックスのサポート</strong></span></td>
<td>はい (InnoDB での地理空間インデックス付けのサポートは、MySQL 5.7 以降で使用できます。)</td>
</tr><tr><td><span class="bold"><strong>地理空間データ型のサポート</strong></span></td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>外部キーのサポート</strong></span></td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>暗号化データ</strong></span></td>
<td>はい (暗号化機能を介してサーバーに実装されます。MySQL 5.7 以降では、保存データのテーブルスペース暗号化がサポートされます。)</td>
</tr></tbody></table></div></div><br class="table-break"><p>
    <code class="literal">InnoDB</code> の機能と MySQL で提供されているその他のストレージエンジンを比較する方法については、<a class="xref" href="storage-engines.html" title="第 16 章 代替ストレージエンジン">第16章「<i>代替ストレージエンジン</i>」</a>の<span class="emphasis"><em>「ストレージエンジンの機能」</em></span>表を参照してください。
  </p><h3><a name="innodb-enhancements"></a>InnoDB の拡張機能と新機能</h3><p>
    <code class="literal">InnoDB</code> の拡張機能および新機能の詳細は、次を参照してください:
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="xref" href="introduction.html#mysql-nutshell" title="1.3 MySQL 8.0 の新機能">セクション1.3「MySQL 8.0 の新機能」</a> の <code class="literal">InnoDB</code> 拡張機能のリスト。
      </p></li><li class="listitem"><p>
        <a class="ulink" href="https://dev.mysql.com/doc/relnotes/mysql/8.0/en/" target="_top">「リリースノート」</a>。
      </p></li></ul></div><h3><a name="innodb-additional-resources"></a>追加の InnoDB 情報およびリソース</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">InnoDB</code> 関連の用語および定義については、<a class="xref" href="glossary.html" title="MySQL 用語集">MySQL 用語集</a> を参照してください。
      </p></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> ストレージエンジン専用のフォーラムについては、<a class="ulink" href="http://forums.mysql.com/list.php?22" target="_top">MySQL Forums::InnoDB</a> を参照してください。
      </p></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> は、MySQL と同じ GNU GPL ライセンスバージョン 2 (1991 年 6 月) によって発行されています。 MySQL ライセンスの詳細は、<a class="ulink" href="http://www.mysql.com/company/legal/licensing/" target="_top">http://www.mysql.com/company/legal/licensing/</a>を参照してください。 
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-benefits"></a>15.1.1 InnoDB テーブルを使用する利点</h3></div></div></div><p>
      <code class="literal">InnoDB</code> テーブルは、次の理由で役立ちます:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ハードウェアまたはソフトウェアの問題が原因でサーバーが予期せず終了した場合は、その時点でデータベースで何が起こっていたかに関係なく、データベースの再起動後に特別な操作を行う必要はありません。 <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>を使用すると自動的に、クラッシュ時の前にコミットされた変更はすべて完了し、処理中だったがコミットされなかった変更はすべて取り消されます。 単に再起動し、終了した場所から続行するだけです。 
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> ストレージエンジンは、データがアクセスされたときにテーブルおよびインデックスデータをメインメモリーにキャッシュする独自の <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> を保持します。 頻繁に使用されるデータは、直接メモリーから処理されます。 このキャッシュは多くのタイプの情報に適用され、処理が高速化されます。 専用データベースサーバーでは、多くの場合、最大 80% の物理メモリーがバッファプールに割り当てられます。 
        </p></li><li class="listitem"><p>
          関連データをさまざまなテーブルに分割すると、強制的に<a class="link" href="glossary.html#glos_referential_integrity" title="参照整合性">参照整合性</a>が適用される<a class="link" href="glossary.html#glos_foreign_key" title="外部キー">外部キー</a>を設定できます。 データを更新または削除すると、ほかのテーブル内の関連データも自動的に更新または削除されます。 プライマリテーブル内に対応するデータが存在しないセカンダリテーブルにデータを挿入しようとすると、自動的に不正なデータが除外されます。 
        </p></li><li class="listitem"><p>
          ディスク上またはメモリー内のデータが破損した場合は、偽のデータを使用する前に、<a class="link" href="glossary.html#glos_checksum" title="チェックサム">チェックサム</a>メカニズムによって警告が発行されます。
        </p></li><li class="listitem"><p>
          テーブルごとに適切な<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>カラムを持つデータベースを設計すると、これらのカラムが関与する操作が自動的に最適化されます。 <code class="literal">WHERE</code> 句、<code class="literal">ORDER BY</code> 句、<code class="literal">GROUP BY</code> 句、および<a class="link" href="glossary.html#glos_join" title="結合">結合</a>操作では、主キーカラムへの参照が非常に高速です。 
        </p></li><li class="listitem"><p>
          挿入、更新および削除は、<a class="link" href="glossary.html#glos_change_buffering" title="変更バッファリング">change buffering</a> と呼ばれる自動メカニズムによって最適化されます。 <code class="literal">InnoDB</code> では、同じテーブルへの並列読み取りおよび書き込みアクセスが許可されているだけでなく、ディスク I/O が効率化されるように変更されたデータがキャッシュに入れられます。 
        </p></li><li class="listitem"><p>
          パフォーマンスの利点は、長時間実行されるクエリーを含む巨大なテーブルだけに限定されません。 同じ行が 1 つのテーブルから何度もアクセスされると、<a class="link" href="glossary.html#glos_adaptive_hash_index" title="適応型ハッシュインデックス">適応型ハッシュインデックス</a>と呼ばれる機能に引き継がれ、ハッシュテーブルから読み取られたかのように、これらの検索がさらに高速になります。 
        </p></li><li class="listitem"><p>
          テーブルおよび関連付けられたインデックスを圧縮できます。
        </p></li><li class="listitem"><p>
          パフォーマンスおよび可用性への影響を大幅に少なくして、インデックスを作成および削除できます。
        </p></li><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースの切捨ては非常に高速で、<code class="literal">InnoDB</code> のみが再利用できる <a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">system tablespace</a> 内の領域を解放するのではなく、オペレーティングシステムが再利用できるようにディスク領域を解放できます。
        </p></li><li class="listitem"><p>
          テーブルデータの記憶域レイアウトは、<a class="link" href="glossary.html#glos_dynamic_row_format" title="動的行フォーマット">DYNAMIC</a> 行形式の <code class="literal">BLOB</code> および長いテキストフィールドより効率的です。
        </p></li><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_information_schema" title="INFORMATION_SCHEMA">INFORMATION_SCHEMA</a> テーブルでクエリーを実行することで、ストレージエンジンの内部動作をモニターできます。
        </p></li><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_performance_schema" title="パフォーマンススキーマ">Performance Schema</a> テーブルをクエリーすることによって、ストレージエンジンのパフォーマンスの詳細をモニターできます。
        </p></li><li class="listitem"><p>
          同じステートメント内でも、<code class="literal">InnoDB</code> のテーブルと別の MySQL ストレージエンジンのテーブルを混在させることができます。 たとえば、<a class="link" href="glossary.html#glos_join" title="結合">結合</a>操作を使用すると、単一のクエリーで <code class="literal">InnoDB</code> テーブルと <code class="literal">MEMORY</code> テーブルのデータを結合できます。 
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> は、大きなデータボリュームを処理する際に、高い CPU の効率性と最大のパフォーマンスが実現されるように設計されています。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> テーブルは、ファイルサイズが 2G バイトに制限されているオペレーティングシステム上でも、大量のデータを処理できます。
        </p></li></ul></div><p>
      アプリケーションコードで適用できる <code class="literal">InnoDB</code> 固有のチューニング技術については、<a class="xref" href="optimization.html#optimizing-innodb" title="8.5 InnoDB テーブルの最適化">セクション8.5「InnoDB テーブルの最適化」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-best-practices"></a>15.1.2 InnoDB テーブルのベストプラクティス</h3></div></div></div><p>
      このセクションでは、<code class="literal">InnoDB</code> テーブルを使用する場合のベストプラクティスについて説明します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          最も頻繁にクエリーするカラムを使用してすべてのテーブルに <a class="link" href="glossary.html#glos_primary_key" title="主キー">primary key</a> を指定するか、明らかな主キーがない場合は <a class="link" href="glossary.html#glos_auto_increment" title="自動インクリメント">auto-increment</a> 値を指定します。
        </p></li><li class="listitem"><p>
          これらのテーブルの同一の ID 値に基づいて複数のテーブルからデータが取得される場合は、<a class="link" href="glossary.html#glos_join" title="結合">joins</a> を使用します。 結合のパフォーマンスを高速にするには、結合カラム上に<a class="link" href="glossary.html#glos_foreign_key" title="外部キー">外部キー</a>を定義し、各テーブル内でそれらのカラムを同じデータ型で宣言します。 外部キーを追加すると、参照カラムが確実にインデックス付けされ、パフォーマンスを向上させることができます。 また、外部キーは、影響を受けるすべてのテーブルに削除または更新を伝播し、対応する ID が親テーブルに存在しない場合に子テーブルへのデータの挿入を防止します。 
        </p></li><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_autocommit" title="自動コミット">autocommit</a> をオフにします。 1 秒間に何百回もコミットすると、パフォーマンスに上限が設定されます (これは、ストレージデバイスの書き込み速度で制限されます)。 
        </p></li><li class="listitem"><p>
          関連する <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> 操作のセットを、<code class="literal">START TRANSACTION</code> および <code class="literal">COMMIT</code> ステートメントでカッコで囲んで <a class="link" href="glossary.html#glos_transaction" title="トランザクション">transactions</a> にグループ化します。 頻繁にはコミットしたくない一方で、コミットなしで何時間も実行される <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、または <code class="literal">DELETE</code> ステートメントの巨大なバッチも発生させたくありません。 
        </p></li><li class="listitem"><p>
          <code class="literal">LOCK TABLES</code> ステートメントを使用しません。 <code class="literal">InnoDB</code> は、一度に同じテーブルへのすべての読み取りおよび書き込みを行うことで、信頼性や高パフォーマンスを犠牲にせずに、複数のセッションを処理できます。 行のセットへの排他的な書き込みアクセス権を取得するには、<code class="literal">SELECT ... FOR UPDATE</code> という構文を使用して、更新対象の行のみをロックします。 
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_file_per_table</code> オプションを有効にするか、一般的なテーブルスペースを使用して、テーブルのデータおよびインデックスを <a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">system tablespace</a> ではなく別々のファイルに配置します。
        </p><p>
          <code class="literal">innodb_file_per_table</code> オプションはデフォルトで有効になっています。
        </p></li><li class="listitem"><p>
          データおよびアクセスパターンが <code class="literal">InnoDB</code> のテーブルまたはページの <a class="link" href="glossary.html#glos_compression" title="圧縮">compression</a> 機能を利用できるかどうかを評価します。 読み取りおよび書き込みの機能を犠牲にせずに、<code class="literal">InnoDB</code> テーブルを圧縮できます。 
        </p></li><li class="listitem"><p>
          オプション <code class="literal">--sql_mode=NO_ENGINE_SUBSTITUTION</code> を指定してサーバーを実行し、<code class="literal">CREATE TABLE</code> の <code class="literal">ENGINE=</code> 句で指定されたエンジンに問題がある場合に、別のストレージエンジンでテーブルが作成されないようにします。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-check-availability"></a>15.1.3 InnoDB がデフォルトのストレージエンジンであるかどうかの確認</h3></div></div></div><p>
      <code class="literal">SHOW ENGINES</code> ステートメントを発行して、使用可能な MySQL ストレージエンジンを表示します。 <code class="literal">InnoDB</code> 行で <code class="literal">DEFAULT</code> を探します。 
    </p><pre class="programlisting">mysql&gt; SHOW ENGINES;
</pre><p>
      または、<code class="literal">INFORMATION_SCHEMA.ENGINES</code> テーブルをクエリーします。
    </p><pre class="programlisting">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.ENGINES;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-benchmarking"></a>15.1.4 InnoDB を使用したテストおよびベンチマーク</h3></div></div></div><p>
      <code class="literal">InnoDB</code> がデフォルトのストレージエンジンでない場合は、コマンド行で <code class="literal">--default-storage-engine=InnoDB</code> を定義してサーバーを再起動するか、MySQL サーバーオプションファイルの<code class="literal">[mysqld]</code>セクションで <code class="literal">default-storage-engine=innodb</code> を定義してサーバーを再起動することによって、データベースサーバーまたはアプリケーションが <code class="literal">InnoDB</code> で正しく動作するかどうかを判断できます。
    </p><p>
      デフォルトのストレージエンジンを変更しても、新たに作成されたテーブルしか影響を受けないため、アプリケーションのインストールおよび設定ステップをすべて実行して、すべてが正しくインストールされたことを確認します。 次に、すべてのアプリケーション機能を実行して、データのロード、編集、およびクエリー機能がすべて動作することを確認します。 テーブルが別のストレージエンジンに固有の機能に依存している場合は、エラーが発生します。エラーを回避するには、<code class="literal">CREATE TABLE</code> ステートメントに <code class="literal">ENGINE=<em class="replaceable"><code>other_engine_name</code></em></code> 句を追加します。 
    </p><p>
      ストレージエンジンに関する意図的な決定を行わず、<code class="literal">InnoDB</code> を使用して作成された特定のテーブルの動作をプレビューする場合は、テーブルごとにコマンド <code class="literal">ALTER TABLE table_name ENGINE=InnoDB;</code>を発行します。 または、元のテーブルを妨げずにテストクエリーおよびその他のステートメントを実行するには、コピーを作成します: 
    </p><pre class="programlisting">CREATE TABLE InnoDB_Table (...) ENGINE=InnoDB AS SELECT * FROM <em class="replaceable"><code>other_engine_table</code></em>;
</pre><p>
      現実的なワークロードで完全なアプリケーションを使用してパフォーマンスを評価するには、最新の MySQL サーバーをインストールし、ベンチマークを実行します。
    </p><p>
      完全なアプリケーションのライフサイクル (インストールから頻繁な使用まで)、およびサーバーの再起動をテストします。 電源障害のシミュレーションを行うために、データベースの負荷が高いときにサーバープロセスを強制終了し、サーバーの再起動時にデータが正常にリカバリされるかどうかを確認します。 
    </p><p>
      特に、ソースサーバーとレプリカで異なる MySQL バージョンとオプションを使用する場合は、レプリケーション構成をテストします。
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mysql-acid"></a>15.2 InnoDB および ACID モデル</h2></div></div></div><a class="indexterm" name="idm44761365497232"></a><p>
    <a class="link" href="glossary.html#glos_acid" title="ACID">ACID</a> モデルは、ビジネスデータおよびミッションクリティカルなアプリケーションで重要となる信頼性の側面が強調されたデータベース設計原則のセットです。 ソフトウェアのクラッシュやハードウェアの誤動作などの例外的な状況でも、データが破損せず、結果が歪曲されないように、MySQL には、ACID モデルに厳密に準拠した <code class="literal">InnoDB</code> ストレージエンジンなどのコンポーネントが含まれています。 ACID に準拠した機能に依存していれば、一貫性チェックおよびクラッシュリカバリのメカニズムを再開発する必要がありません。 追加のソフトウェアの保護手段、信頼性が最高のハードウェア、または少量のデータ損失や不整合に耐えることができるアプリケーションが備わっている場合は、ACID の信頼性の一部と引き換えに、パフォーマンスやスループットが向上するように MySQL の設定を調整できます。 
  </p><p>
    次のセクションでは、どのように MySQL の機能 (特に <code class="literal">InnoDB</code> ストレージエンジン) が ACID モデルのカテゴリとやりとりするのかについて説明します。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <span class="bold"><strong>A</strong></span>: 原子性。
      </p></li><li class="listitem"><p>
        <span class="bold"><strong>C</strong></span>: 一貫性。
      </p></li><li class="listitem"><p>
        <span class="bold"><strong>I:</strong></span>: 分離性。
      </p></li><li class="listitem"><p>
        <span class="bold"><strong>D</strong></span>: 持続性。
      </p></li></ul></div><h3><a name="idm44761365484144"></a>原子性</h3><p>
    ACID モデルの<span class="bold"><strong>原子性</strong></span>の側面には、主に <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>が関与しています。 関連する MySQL の機能は次のとおりです。 
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        自動コミット設定。
      </p></li><li class="listitem"><p>
        <code class="literal">COMMIT</code> ステートメント。
      </p></li><li class="listitem"><p>
        <code class="literal">ROLLBACK</code> ステートメント。
      </p></li><li class="listitem"><p>
        <code class="literal">INFORMATION_SCHEMA</code> テーブルの運用データ。
      </p></li></ul></div><h3><a name="idm44761365473952"></a>一貫性</h3><p>
    ACID モデルの<span class="bold"><strong>一貫性</strong></span>の側面には、主にクラッシュからデータを保護するための内部的な <code class="literal">InnoDB</code> 処理が関与しています。 関連する MySQL の機能は次のとおりです。 
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_doublewrite_buffer" title="二重書き込みバッファー">二重書き込みバッファー</a>。
      </p></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>。
      </p></li></ul></div><h3><a name="idm44761365466128"></a>分離性</h3><p>
    ACID モデルの<span class="bold"><strong>分離性</strong></span>の側面には、主に <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a> (特に、各トランザクションに適用される<a class="link" href="glossary.html#glos_isolation_level" title="分離レベル">分離レベル</a>) が関与しています。 関連する MySQL の機能は次のとおりです。 
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="link" href="glossary.html#glos_autocommit" title="自動コミット">自動コミット</a>設定。
      </p></li><li class="listitem"><p>
        <code class="literal">SET ISOLATION LEVEL</code> ステートメント。
      </p></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_locking" title="ロック">ロック</a>の低レベルの詳細。 これらの詳細は、パフォーマンスチューニング時に <code class="literal">INFORMATION_SCHEMA</code> テーブルから参照します。 
      </p></li></ul></div><h3><a name="idm44761365454912"></a>持続性</h3><p>
    ACID モデルの<span class="bold"><strong>持続性</strong></span>の側面には、特定のハードウェア構成とやりとりする MySQL ソフトウェアの機能が関与しています。 CPU、ネットワーク、およびストレージデバイスの性能に応じて多くの可能性が考えられるため、具体的なガイドラインを示す際は、この側面がもっとも複雑になります。 (これらのガイドラインに従うことは、<span class="quote">「<span class="quote">新しいハードウェア</span>」</span>を購入するという形になる場合があります。) 関連する MySQL の機能は次のとおりです。 
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">innodb_doublewrite</code> 構成オプションでオンとオフが切り替えられる <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_doublewrite_buffer" title="二重書き込みバッファー">二重書き込みバッファー</a>。
      </p></li><li class="listitem"><p>
        <code class="literal">innodb_flush_log_at_trx_commit</code> 構成オプション。
      </p></li><li class="listitem"><p>
        <code class="literal">sync_binlog</code> 構成オプション。
      </p></li><li class="listitem"><p>
        <code class="literal">innodb_file_per_table</code> 構成オプション。
      </p></li><li class="listitem"><p>
        ストレージデバイス内の書き込みバッファー (ディスクドライブ、SSD、RAID アレイなど)。
      </p></li><li class="listitem"><p>
        ストレージデバイス内のバッテリーでバックアップされるキャッシュ。
      </p></li><li class="listitem"><p>
        MySQL を実行する際に使用されるオペレーティングシステム (特に、<code class="literal">fsync()</code> システムコールでのサポート)。
      </p></li><li class="listitem"><p>
        MySQL サーバーを実行し、MySQL データを格納するすべてのコンピュータサーバーおよびストレージデバイスへの電力を保護する無停電電源装置 (UPS)。
      </p></li><li class="listitem"><p>
        バックアップ方針 (頻度、バックアップのタイプ、バックアップの保存期間など)。
      </p></li><li class="listitem"><p>
        分散型またはホスト型のデータアプリケーションの場合、MySQL サーバー用のハードウェアが配置されているデータセンター、およびデータセンター間のネットワーク接続の特定の特性。
      </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-multi-versioning"></a>15.3 InnoDB マルチバージョン</h2></div></div></div><a class="indexterm" name="idm44761365433792"></a><a class="indexterm" name="idm44761365431648"></a><p>
    <code class="literal">InnoDB</code> は<a class="link" href="glossary.html#glos_mvcc" title="MVCC">マルチバージョンストレージエンジン</a>です。並列実行や<a class="link" href="glossary.html#glos_rollback" title="ロールバック">ロールバック</a>などのトランザクション機能をサポートするために、変更された行の古いバージョンに関する情報が保持されます。 この情報は、テーブルスペース内に<a class="link" href="glossary.html#glos_rollback_segment" title="ロールバックセグメント">ロールバックセグメント</a>と呼ばれるデータ構造で (Oracle では類似したデータ構造のあとに) 格納されます。 <code class="literal">InnoDB</code> では、トランザクションのロールバックで必要となる取り消し操作を実行するために、ロールバックセグメント内の情報が使用されます。 また、この情報は、<a class="link" href="glossary.html#glos_consistent_read" title="一貫性読み取り">一貫性読み取り</a>のために行の初期バージョンを構築する際にも使用されます。 
  </p><p>
    <code class="literal">InnoDB</code> は内部的に、データベース内に格納された各行に 3 つのフィールドを追加します。 6 バイトの <code class="literal">DB_TRX_ID</code> フィールドは、行を挿入または更新した最後のトランザクションに対して、トランザクション識別子を指示します。 また、行内の特別ビットが削除されたとマークするように設定されている場合、削除は内部的に更新として処理されます。 各行には、ロールポインタと呼ばれる 7 バイトの <code class="literal">DB_ROLL_PTR</code> フィールドも含まれています。 ロールポインタは、ロールバックセグメントに書き込まれた Undo ログレコードを示しています。 行が更新された場合は、Undo ログレコードに、更新される前の行の内容を再構築するために必要な情報が含まれます。 6 バイトの <code class="literal">DB_ROW_ID</code> フィールドには、新しい行が挿入されると単調に増加する行 ID が含まれています。 <code class="literal">InnoDB</code> によって自動生成されたクラスタ化されたインデックスには、行 ID 値が含まれます。 それ以外の場合、インデックスに <code class="literal">DB_ROW_ID</code> カラムが含まれることはありません。 
  </p><p>
    ロールバックセグメント内の Undo ログは、挿入および更新 Undo ログに分割されます。 挿入 Undo ログはトランザクションロールバックでのみ必要であるため、トランザクションのコミット直後に破棄できます。 更新 Undo ログも一貫性読み取りで使用されますが、<code class="literal">InnoDB</code> によってスナップショットが割り当てられたトランザクションが存在しなくなったあとでのみ破棄できます。更新 Undo ログ内のスナップショット情報は、データベース行の以前のバージョンを構築する際に一貫性読み取りで必要となる可能性があります。 
  </p><p>
    トランザクション (一貫性読み取りのみを発行するトランザクションを含む) を定期的にコミットしてください。 それ以外の場合は、<code class="literal">InnoDB</code> は更新 Undo ログからデータを破棄できないため、ロールバックセグメントが大きくなり過ぎてテーブルスペースがいっぱいになる可能性があります。 
  </p><p>
    一般に、ロールバックセグメント内の Undo ログレコードの物理的サイズは、それに対応する挿入された行や更新された行よりも小さいです。 この情報を使用すると、ロールバックセグメントで必要となる領域を計算できます。 
  </p><p>
    <code class="literal">InnoDB</code> マルチバージョンスキームでは、SQL ステートメントで行を削除しても、その行はすぐにデータベースから物理的に削除されません。 <code class="literal">InnoDB</code> は、削除用に書き込まれた更新 Undo ログレコードが破棄されたときにのみ、対応する行およびそのインデックスレコードを物理的に削除します。 このような削除操作は<a class="link" href="glossary.html#glos_purge" title="パージ">パージ</a>と呼ばれ、非常に高速です。通常は、削除が行われなかった SQL ステートメントと同じ時系列順で実行されます。 
  </p><p>
    テーブル内で小さめのバッチの行をほぼ同じ速度で挿入および削除すると、すべての<span class="quote">「<span class="quote">デッド</span>」</span>行が原因で、パージスレッドが遅延し始め、増加し続ける可能性があります。これにより、すべてにおいてディスクが抑制され、非常に低速になります。 このような場合は、新たな行操作を抑制し、<code class="literal">innodb_max_purge_lag</code> システム変数を調整することで、より多くのリソースをパージスレッドに割り当てます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-parameters" title="15.14 InnoDB の起動オプションおよびシステム変数">セクション15.14「InnoDB の起動オプションおよびシステム変数」</a>を参照してください。 
  </p><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-multi-versioning-secondary-indexes"></a>マルチバージョニングおよびセカンダリインデックス</h3></div></div></div><p>
      <code class="literal">InnoDB</code> multiversion concurrency control (MVCC) は、セカンダリインデックスをクラスタ化されたインデックスとは異なる方法で扱います。 クラスタ化されたインデックス内のレコードはインプレースで更新され、非表示のシステムカラムは undo ログエントリを指し、このエントリから以前のバージョンのレコードを再構築できます。 クラスタ化されたインデックスレコードとは異なり、セカンダリインデックスレコードには非表示のシステムカラムは含まれず、インプレースで更新されません。 
    </p><p>
      セカンダリインデックスカラムが更新されると、古いセカンダリインデックスレコードが削除マークされ、新しいレコードが挿入され、削除マークが付けられたレコードが最終的にパージされます。 セカンダリインデックスレコードが削除マークされるか、新しいトランザクションによってセカンダリインデックスページが更新されると、<code class="literal">InnoDB</code> はクラスタインデックスでデータベースレコードを検索します。 クラスタインデックスでは、読取りトランザクションの開始後にレコードが変更された場合、レコード <code class="literal">DB_TRX_ID</code> がチェックされ、正しいバージョンのレコードが undo ログから取得されます。 
    </p><p>
      セカンダリインデックスレコードが削除対象としてマークされている場合、またはセカンダリインデックスページが新しいトランザクションによって更新されている場合、<a class="link" href="glossary.html#glos_covering_index" title="カバリングインデックス">covering index</a> 手法は使用されません。 <code class="literal">InnoDB</code> は、インデックス構造から値を戻すかわりに、クラスタ化されたインデックス内のレコードを検索します。 
    </p><p>
      ただし、<a class="link" href="optimization.html#index-condition-pushdown-optimization" title="8.2.1.6 インデックスコンディションプッシュダウンの最適化">index condition pushdown (ICP)</a> の最適化が有効で、<code class="literal">WHERE</code> 条件の一部をインデックスのフィールドのみを使用して評価できる場合、MySQL サーバーは <code class="literal">WHERE</code> 条件のこの部分を、インデックスを使用して評価されるストレージエンジンにプッシュダウンします。 一致するレコードが見つからない場合、クラスタインデックスルックアップは回避されます。 一致するレコードが見つかった場合、削除マークが付けられたレコードの中でも、<code class="literal">InnoDB</code> はクラスタ化されたインデックス内のレコードを検索します。 
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-architecture"></a>15.4 InnoDB のアーキテクチャ</h2></div></div></div><a class="indexterm" name="idm44761365390368"></a><p>
      次の図は、<code class="literal">InnoDB</code> ストレージエンジンアーキテクチャーを構成するインメモリーおよびディスク上の構造を示しています。 各構造の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-in-memory-structures" title="15.5 InnoDB インメモリー構造">セクション15.5「InnoDB インメモリー構造」</a> および <a class="xref" href="innodb-storage-engine.html#innodb-on-disk-structures" title="15.6 InnoDB オンディスク構造">セクション15.6「InnoDB オンディスク構造」</a> を参照してください。 
    </p><div class="figure"><a name="innodb-architecture-diagram"></a><p class="title"><b>図 15.1 InnoDB のアーキテクチャ</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/innodb-architecture.png" width="700" height="538" alt="インメモリーおよびディスク上の構造を示す InnoDB アーキテクチャ図。 インメモリー構造には、バッファプール、適応型ハッシュインデックス、変更バッファおよびログバッファが含まれます。 ディスク上の構造には、テーブルスペース、REDO ログおよび二重書込みバッファファイルが含まれます。"></div></div></div><br class="figure-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-in-memory-structures"></a>15.5 InnoDB インメモリー構造</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-buffer-pool">15.5.1 バッファプール</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-change-buffer">15.5.2 変更バッファ</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-adaptive-hash">15.5.3 適応型ハッシュインデックス</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-redo-log-buffer">15.5.4 ログバッファ</a></span></dt></dl></div><a class="indexterm" name="idm44761365376208"></a><p>
    このセクションでは、<code class="literal">InnoDB</code> のインメモリー構造および関連トピックについて説明します。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-buffer-pool"></a>15.5.1 バッファプール</h3></div></div></div><p>
    バッファプールは、<code class="literal">InnoDB</code> がアクセス時にテーブルおよびインデックスデータをキャッシュするメインメモリー内の領域です。 バッファープールを使用すると、頻繁に使用されるデータをメモリーから直接処理できるため、処理速度が向上します。 専用サーバーでは、多くの場合、最大 80% の物理メモリーがバッファプールに割り当てられます。 
  </p><p>
    大容量読み取り操作の効率を高めるため、バッファープールは複数行を保持できる<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>に分割されます。 キャッシュ管理を効率化するために、バッファプールはページのリンクリストとして実装されます。使用頻度が低いデータは、<a class="link" href="glossary.html#glos_lru" title="LRU">LRU</a> アルゴリズムのバリエーションを使用してキャッシュから削除されます。 
  </p><p>
    バッファプールを利用して頻繁にアクセスされるデータをメモリーに保持する方法を理解することは、MySQL チューニングの重要な側面です。
  </p><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-buffer-pool-lru"></a>バッファプール LRU アルゴリズム</h4></div></div></div><p>
      バッファプールは、最低使用頻度 (LRU) アルゴリズムのバリエーションを使用してリストとして管理されます。 バッファプールに新しいページを追加するための領域が必要な場合は、最も最近使用されていないページが削除され、新しいページがリストの中央に追加されます。 このミッドポイント挿入戦略はリストを 2 つのサブリストとして扱います。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          先頭は、最近アクセスされた「新しい」 (<span class="quote">「<span class="quote">若い</span>」</span>) ページのサブリスト
        </p></li><li class="listitem"><p>
          末尾は、最近アクセスされていない「古い」ページのサブリスト
        </p></li></ul></div><div class="figure"><a name="innodb-buffer-pool-list"></a><p class="title"><b>図 15.2 バッファプールリスト</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/innodb-buffer-pool-list.png" width="600" height="616" alt="内容は周囲のテキストで説明されています。"></div></div></div><br class="figure-break"><p>
      このアルゴリズムは、頻繁に使用されるページを新しいサブリストに保持します。 古いサブリストには、あまり頻繁に使用されないページが含まれています。これらのページは <a class="link" href="glossary.html#glos_eviction" title="エビクション">eviction</a> の候補です。 
    </p><p>
      デフォルトでは、アルゴリズムは次のように動作します:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          バッファープールの 3/8 が古いサブリストに割り振られます。
        </p></li><li class="listitem"><p>
          リストのミッドポイントは、新しいサブリストの末尾と古いサブリストの先頭が接する境界です。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> は、バッファプールにページを読み取るときに、最初に中間ポイント (古いサブリストの先頭) にページを挿入します。 ページの読込みは、SQL クエリーなどのユーザーが開始する操作、または <code class="literal">InnoDB</code> によって自動的に実行される<a class="link" href="glossary.html#glos_read_ahead" title="先読み">先読み</a>操作が要求した場合に発生する可能性があります。 
        </p></li><li class="listitem"><p>
          古いサブリストのページにアクセスすると、<span class="quote">「<span class="quote">「若い」</span>」</span>になり、新しいサブリストの先頭に移動します。 ユーザーが開始した操作の要求によるページが読み込まれた場合、最初のアクセスがただちに行われ、ページは若いページになります。 先読み操作のためにページが読み込まれた場合、最初のアクセスはすぐに発生せす、ページが削除されるまでまったく行われない可能性もあります。 
        </p></li><li class="listitem"><p>
          データベースが動作するにつれて、アクセスされないバッファプール内のページは、リストの後方に移動し <span class="quote">「<span class="quote">age</span>」</span> なります。 新しいサブリストと古いサブリストの両方のページは、他のページが新しいページになるとエージングされます。 古いサブリスト内のページも、中間点にページが挿入されると有効になります。 最終的に、未使用のままのページは古いサブリストの末尾に到達し、削除されます。 
        </p></li></ul></div><p>
      デフォルトでは、クエリーによって読み取られたページはすぐに新しいサブリストに移動されます。つまり、これらのページはバッファプールに保持されます。 たとえば、<span class="command"><strong>mysqldump</strong></span> または <code class="literal">WHERE</code> 句のない <code class="literal">SELECT</code> ステートメントなどにおいて実行されるテーブルスキャンは、新しいデータが再度使用されない場合でも、大量のデータをバッファプールに取り込み、同等の量の古いデータを削除する可能性があります。 同様に、先読みバックグラウンドスレッドによってロードされ、一度のみアクセスされるページは、新しいリストの先頭に移動されます。 これらの状況では、頻繁に使用されるページが、削除の対象となる古いサブリストに移動される可能性があります。 この動作の最適化の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-midpoint_insertion" title="15.8.3.3 バッファープールをスキャンに耐えられるようにする">セクション15.8.3.3「バッファープールをスキャンに耐えられるようにする」</a> および <a class="xref" href="innodb-storage-engine.html#innodb-performance-read_ahead" title="15.8.3.4 InnoDB バッファープールのプリフェッチ (先読み) の構成">セクション15.8.3.4「InnoDB バッファープールのプリフェッチ (先読み) の構成」</a> を参照してください。 
    </p><p>
      <code class="literal">InnoDB</code> 標準モニターの出力には、バッファプール LRU アルゴリズムの操作に関する <code class="literal">BUFFER POOL AND MEMORY</code> セクションのいくつかのフィールドが含まれています。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-monitoring" title="InnoDB 標準モニターを使用したバッファープールのモニタリング">InnoDB 標準モニターを使用したバッファープールのモニタリング</a>を参照してください。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-buffer-pool-configuration"></a>バッファプール構成</h4></div></div></div><p>
      バッファプールの様々な側面を構成して、パフォーマンスを向上させることができます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          理想的には、バッファープールのサイズをできるだけ大きな値に設定して、サーバー上のほかのプロセスが過剰なページングなく実行するように、十分なメモリーを残します。 バッファープールが大きいほど、<code class="literal">InnoDB</code> はさらにインメモリーデータベースのように動作し、ディスクから 1 回データを読み取り、後続の読み取り時に、メモリーからデータにアクセスします。 <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-resize" title="15.8.3.1 InnoDB バッファプールサイズの構成">セクション15.8.3.1「InnoDB バッファプールサイズの構成」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          十分なメモリーがある 64 ビットシステムでは、バッファプールを複数の部分に分割して、同時操作間のメモリー構造の競合を最小限に抑えることができます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-multiple-buffer-pools" title="15.8.3.2 複数のバッファープールインスタンスの構成">セクション15.8.3.2「複数のバッファープールインスタンスの構成」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          アクセス頻度が低い大量のデータをバッファプールに取り込むような突然のスパイクに関係なく、頻繁にアクセスされるデータをメモリーに保持することができます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-midpoint_insertion" title="15.8.3.3 バッファープールをスキャンに耐えられるようにする">セクション15.8.3.3「バッファープールをスキャンに耐えられるようにする」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          先読みリクエストを実行してバッファプールにページを非同期的にプリフェッチする方法とタイミングを制御して、ページのニーズが低下することを予測できます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-read_ahead" title="15.8.3.4 InnoDB バッファープールのプリフェッチ (先読み) の構成">セクション15.8.3.4「InnoDB バッファープールのプリフェッチ (先読み) の構成」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          バックグラウンドフラッシュが発生するタイミング、およびフラッシュ率をワークロードに基づいて動的に調整するかどうかを制御できます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-flushing" title="15.8.3.5 バッファープールのフラッシュの構成">セクション15.8.3.5「バッファープールのフラッシュの構成」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          サーバーの再起動後の長いウォームアップ期間を回避するために、<code class="literal">InnoDB</code> が現在のバッファプールの状態を保持する方法を構成できます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="15.8.3.6 バッファープールの状態の保存と復元">セクション15.8.3.6「バッファープールの状態の保存と復元」</a>を参照してください。 
        </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-buffer-pool-monitoring"></a>InnoDB 標準モニターを使用したバッファープールのモニタリング</h4></div></div></div><a class="indexterm" name="idm44761365315408"></a><a class="indexterm" name="idm44761365313936"></a><a class="indexterm" name="idm44761365311904"></a><p>
      <code class="literal">SHOW ENGINE INNODB STATUS</code> を使用してアクセスできる <code class="literal">InnoDB</code> 標準モニターの出力では、バッファプールの操作に関するメトリックが提供されます。 バッファプールメトリックは、<code class="literal">InnoDB</code> 標準モニター出力の <code class="literal">BUFFER POOL AND MEMORY</code> セクションにあり、次のように表示されます: 
    </p><pre class="programlisting">----------------------
BUFFER POOL AND MEMORY
----------------------
Total large memory allocated 2198863872
Dictionary memory allocated 776332
Buffer pool size   131072
Free buffers       124908
Database pages     5720
Old database pages 2071
Modified db pages  910
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 4, not young 0
0.10 youngs/s, 0.00 non-youngs/s
Pages read 197, created 5523, written 5060
0.00 reads/s, 190.89 creates/s, 244.94 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not
0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read
ahead 0.00/s
LRU len: 5720, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
</pre><p>
      次のテーブルでは、<code class="literal">InnoDB</code> 標準モニターによってレポートされるバッファープールメトリックについて説明します。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">InnoDB</code> 標準モニター出力で提供される秒当たりの平均は、<code class="literal">InnoDB</code> 標準モニター出力が最後に出力されてからの経過時間に基づきます。
      </p></div><div class="table"><a name="innodb-buffer-pool-metrics"></a><p class="title"><b>表 15.2 InnoDB バッファプールメトリック</b></p><div class="table-contents"><table summary="InnoDB buffer pool metrics reported by the InnoDB Standard Monitor."><col style="width: 35%"><col style="width: 65%"><thead><tr>
          <th>名前</th>
          <th>説明</th>
        </tr></thead><tbody><tr>
          <td>割り当てられた合計メモリー</td>
          <td>バッファプールに割り当てられた合計メモリー (バイト)。</td>
        </tr><tr>
          <td>割り当てられたディクショナリメモリー</td>
          <td><code class="literal">InnoDB</code> データディクショナリに割り当てられた合計メモリー (バイト)。</td>
        </tr><tr>
          <td>バッファプールサイズ</td>
          <td>バッファプールに割り当てられたページ単位の合計サイズ。</td>
        </tr><tr>
          <td>空きバッファ</td>
          <td>バッファープール空きリストの合計サイズ (ページ数)。</td>
        </tr><tr>
          <td>データベースページ</td>
          <td>バッファプール LRU リストの合計サイズ (ページ数)。</td>
        </tr><tr>
          <td>古いデータベースページ</td>
          <td>バッファプールの古い LRU サブリストの合計サイズ (ページ数)。</td>
        </tr><tr>
          <td>変更された DB ページ</td>
          <td>バッファプールで変更された現在のページ数。</td>
        </tr><tr>
          <td>保留検針</td>
          <td>バッファープールへの読み取りを待機しているバッファープールページの数。</td>
        </tr><tr>
          <td>保留中の書込み LRU</td>
          <td>LRU リストの下部から書き込まれるバッファプール内の古いダーティページの数。</td>
        </tr><tr>
          <td>保留中の書込みフラッシュリスト</td>
          <td>チェックポイント中にフラッシュされるバッファープールページの数。</td>
        </tr><tr>
          <td>保留中の書込み単一ページ</td>
          <td>バッファプール内の保留中の独立したページ書込みの数。</td>
        </tr><tr>
          <td>若いページ</td>
          <td>バッファプール LRU リストで若くなったページの合計数 (<span class="quote">「<span class="quote">new</span>」</span> ページのサブリストの先頭に移動)。</td>
        </tr><tr>
          <td>作成されたページが若くない</td>
          <td>バッファプール LRU リストで若くなっていないページ (若くなっていない <span class="quote">「<span class="quote">old</span>」</span> サブリストに残っているページ) の合計数。</td>
        </tr><tr>
          <td>youngs/s</td>
          <td>ページを若くしたバッファプール LRU リスト内の古いページへのアクセスの秒当たりの平均。 詳細は、このテーブルの後のノートを参照してください。 </td>
        </tr><tr>
          <td>non-youngs/s</td>
          <td>バッファプール LRU リスト内の、ページを若くしなかった古いページへのアクセスの秒当たりの平均。 詳細は、このテーブルの後のノートを参照してください。 </td>
        </tr><tr>
          <td>読み取られたページ</td>
          <td>バッファプールから読み取られたページの合計数。</td>
        </tr><tr>
          <td>作成されたページ</td>
          <td>バッファプール内に作成されたページの合計数。</td>
        </tr><tr>
          <td>書き込まれたページ</td>
          <td>バッファプールから書き込まれたページの合計数。</td>
        </tr><tr>
          <td>reads/s</td>
          <td>バッファプールページ読取り/秒の平均数。</td>
        </tr><tr>
          <td>creates/s</td>
          <td>作成されたバッファプールページの秒当たりの平均数/秒。</td>
        </tr><tr>
          <td>writes/s</td>
          <td>バッファプールページ書込みの秒当たりの平均数。</td>
        </tr><tr>
          <td>バッファプールヒット率</td>
          <td>バッファプールメモリーから読み取られたページとディスク記憶域から読み取られたページのバッファプールページヒット率。</td>
        </tr><tr>
          <td>若いマーキング率</td>
          <td>ページアクセスによってページが若くなった平均ヒット率。 詳細は、このテーブルの後のノートを参照してください。 </td>
        </tr><tr>
          <td>not (若いマーキング率)</td>
          <td>ページアクセスによってページが若くなっていない平均ヒット率。 詳細は、このテーブルの後のノートを参照してください。 </td>
        </tr><tr>
          <td>先読みされたページ</td>
          <td>先読み操作の秒当たりの平均。</td>
        </tr><tr>
          <td>アクセス権なしで削除されたページ</td>
          <td>バッファプールからアクセスせずに削除されたページの秒当たり平均。</td>
        </tr><tr>
          <td>ランダム先読み</td>
          <td>ランダム先読み操作の秒当たりの平均。</td>
        </tr><tr>
          <td>LRU len</td>
          <td>バッファプール LRU リストの合計サイズ (ページ数)。</td>
        </tr><tr>
          <td>unzip_LRU len</td>
          <td>バッファープールの unzip_LRU リストの合計サイズ (ページ数)。</td>
        </tr><tr>
          <td>I/O 合計</td>
          <td>過去 50 秒間にアクセスされたバッファプール LRU リストページの合計数。</td>
        </tr><tr>
          <td>I/O cur</td>
          <td>アクセスしたバッファプール LRU リストページの合計数。</td>
        </tr><tr>
          <td>I/O unzip sum</td>
          <td>アクセスされたバッファプール unzip_LRU リストページの合計数。</td>
        </tr><tr>
          <td>I/O unzip cur</td>
          <td>アクセスされたバッファプール unzip_LRU リストページの合計数。</td>
        </tr></tbody></table></div></div><br class="table-break"><p>
      <span class="bold"><strong>メモ</strong></span>:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">youngs/s</code> メトリックは、古いページにのみ適用できます。 これは、ページ数ではなく、ページへのアクセス数に基づきます。 特定のページへの複数のアクセスが可能で、そのすべてがカウントされます。 大規模なスキャンが発生していないときに非常に低い <code class="literal">youngs/s</code> 値が表示される場合は、遅延時間を短縮するか、古いサブリストに使用されるバッファープールの割合を増やす必要がある場合があります。 パーセンテージを増やすと古いサブリストが大きくなるため、そのサブリスト内のページが末尾に移動するのに時間がかかり、これらのページに再度アクセスして若くなる可能性が高くなります。 
        </p></li><li class="listitem"><p>
          <code class="literal">non-youngs/s</code> メトリックは、古いページにのみ適用できます。 これは、ページ数ではなく、ページへのアクセス数に基づきます。 特定のページへの複数のアクセスが可能で、そのすべてがカウントされます。 大規模なテーブルスキャンの実行時に <code class="literal">non-youngs/s</code> 値が高くない (および <code class="literal">youngs/s</code> 値が大きい) 場合は、遅延値を増やします。 
        </p></li><li class="listitem"><p>
          <code class="literal">young-making</code> レートは、古いサブリスト内のページへのアクセスだけでなく、すべてのバッファープールページへのアクセスを考慮します。 <code class="literal">young-making</code> レートおよび <code class="literal">not</code> レートは、通常、全体的なバッファプールヒット率に加算されません。 古いサブリストのページヒットによってページが新しいサブリストに移動しますが、新しいサブリストのページヒットによってリストの先頭に移動されるのは、先頭から一定の距離がある場合のみです。 
        </p></li><li class="listitem"><p>
          <code class="literal">not (young-making rate)</code> は、<code class="literal">innodb_old_blocks_time</code> で定義された遅延が満たされていないか、ページがヘッドに移動されなかった新しいサブリストのページヒットが原因で、ページアクセスの結果ページが若くなっていない平均ヒット率です。 このレートは、古いサブリスト内のページへのアクセスだけでなく、すべてのバッファープールページへのアクセスを考慮します。 
        </p></li></ul></div><p>
      バッファプール <a class="link" href="server-administration.html#server-status-variables" title="5.1.10 サーバーステータス変数">server status variables</a> と <code class="literal">INNODB_BUFFER_POOL_STATS</code> テーブルには、<code class="literal">InnoDB</code> Standard Monitor の出力と同じバッファプールメトリックが多数用意されています。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-information-schema-buffer-pool-stats-example" title="例 15.10 INNODB_BUFFER_POOL_STATS テーブルのクエリー">例15.10「INNODB_BUFFER_POOL_STATS テーブルのクエリー」</a>を参照してください。 
    </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-change-buffer"></a>15.5.2 変更バッファ</h3></div></div></div><a class="indexterm" name="idm44761365197632"></a><a class="indexterm" name="idm44761365195472"></a><p>
    変更バッファは、<a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">secondary index</a> ページが <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> にない場合に、そのページに対する変更をキャッシュする特別なデータ構造です。 バッファされた変更は、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code> または <code class="literal">DELETE</code> 操作 (DML) によって発生する可能性があり、後で他の読取り操作によってページがバッファプールにロードされるときにマージされます。 
  </p><div class="figure"><a name="innodb-change-buffer-diagram"></a><p class="title"><b>図 15.3 変更バッファ</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/innodb-change-buffer.png" width="700" height="386" alt="内容は周囲のテキストで説明されています。"></div></div></div><br class="figure-break"><p>
    <a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">clustered indexes</a> とは異なり、セカンダリインデックスは通常一意ではなく、セカンダリインデックスへの挿入は比較的ランダムな順序で行われます。 同様に、削除および更新は、インデックスツリーに隣接して配置されていないセカンダリインデックスページに影響する可能性があります。 キャッシュされた変更を後でマージすると、影響を受けるページが他の操作によってバッファープールに読み込まれるときに、セカンダリインデックスページをディスクからバッファープールに読み込むために必要な大量のランダムアクセス I/O が回避されます。 
  </p><p>
    システムがほとんどアイドル状態のとき、または低速シャットダウン中に実行されるパージ操作は、定期的に更新されたインデックスページをディスクに書き込みます。 パージ操作では、各値がすぐにディスクに書き込まれた場合よりも効率的に、一連のインデックス値のディスクブロックを書き込むことができます。 
  </p><p>
    変更バッファのマージでは、影響を受ける行と更新するセカンダリインデックスが多数ある場合、数時間かかることがあります。 この期間中、ディスク I/O が増加し、ディスクバインドされたクエリーの速度が大幅に低下する可能性があります。 変更バッファのマージは、トランザクションがコミットされた後、およびサーバーが停止して再起動された後でも継続して発生する場合があります (詳細は、<a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="15.21.2 InnoDB のリカバリの強制的な実行">セクション15.21.2「InnoDB のリカバリの強制的な実行」</a> を参照してください)。 
  </p><p>
    メモリー内では、変更バッファはバッファプールの一部を占有します。 ディスクでは、変更バッファはシステムテーブルスペースの一部であり、データベースサーバーの停止時にインデックス変更がバッファされます。 
  </p><p>
    変更バッファにキャッシュされるデータのタイプは、<code class="literal">innodb_change_buffering</code> 変数によって制御されます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-change-buffer-configuration" title="変更バッファリングの構成">変更バッファリングの構成</a>を参照してください。 最大変更バッファサイズを構成することもできます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-change-buffer-maximum-size" title="変更バッファの最大サイズの構成">変更バッファの最大サイズの構成</a>を参照してください。 
  </p><p>
    インデックスに降順のインデックスカラムが含まれている場合、または主キーに降順のインデックスカラムが含まれている場合、セカンダリインデックスでは変更バッファリングはサポートされません。
  </p><p>
    変更バッファに関するよくある質問への回答は、<a class="xref" href="faqs.html#faqs-innodb-change-buffer" title="A.16 MySQL 8.0 FAQ : InnoDB 変更バッファ">セクションA.16「MySQL 8.0 FAQ : InnoDB 変更バッファ」</a> を参照してください。
  </p><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-change-buffer-configuration"></a>変更バッファリングの構成</h4></div></div></div><a class="indexterm" name="idm44761365168176"></a><a class="indexterm" name="idm44761365167088"></a><a class="indexterm" name="idm44761365164912"></a><p>
      <code class="literal">INSERT</code>、<code class="literal">UPDATE</code> および <code class="literal">DELETE</code> 操作がテーブルに対して実行される場合、インデックス付けされたカラムの値 (特にセカンダリキーの値) はソートされていない順序であることがよくあり、セカンダリインデックスを最新の状態にするにはかなりの I/O が必要です。 関連する <a class="link" href="glossary.html#glos_page" title="ページ">page</a> が <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> に存在しない場合、<a class="link" href="glossary.html#glos_change_buffer" title="変更バッファー">change buffer</a> はセカンダリインデックスエントリへの変更をキャッシュするため、ディスクからすぐにページを読み取ることなく、高コストの I/O 操作を回避できます。 バッファされた変更は、ページがバッファプールにロードされ、更新されたページが後でディスクにフラッシュされるときにマージされます。 <code class="literal">InnoDB</code> のメインスレッドは、それらのバッファリングされた変更を、サーバーがほぼアイドル状態にあるときと<a class="link" href="glossary.html#glos_slow_shutdown" title="低速シャットダウン">低速シャットダウン</a>中にマージします。 
    </p><p>
      ディスクの読取りおよび書込みが少なくなる可能性があるため、変更バッファ機能は、バルク挿入などの大量の DML 操作を使用するアプリケーションなど、I/O-bound,であるワークロードに最も役立ちます。
    </p><p>
      ただし、変更バッファはバッファプールの一部を占有するため、データページのキャッシュに使用できるメモリーが削減されます。 ワーキングセットがバッファプールにほぼ収まる場合、またはテーブルのセカンダリインデックスが比較的少ない場合は、変更バッファリングを無効にすると便利です。 作業データセットがバッファプール内に完全に収まる場合、変更バッファリングはバッファプールにないページにのみ適用されるため、余分なオーバーヘッドは発生しません。 
    </p><p>
      <code class="literal">innodb_change_buffering</code> 構成パラメータを使用して、<code class="literal">InnoDB</code> が変更バッファリングを実行する範囲を制御できます。 挿入、削除操作 (インデックスレコードが最初に削除対象としてマークされている場合) およびパージ操作 (インデックスレコードが物理的に削除されている場合) のバッファリングを有効または無効にできます。 更新操作は、挿入と削除の組合せです。 デフォルトの <code class="literal">innodb_change_buffering</code> 値は <code class="literal">all</code> です。 
    </p><p>
      許可される <code class="literal">innodb_change_buffering</code> 値は次のとおりです:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <span class="bold"><strong><code class="literal">all</code></strong></span>
        </p><p>
          デフォルト値: バッファーの挿入、削除のマーキング操作、およびパージ。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong><code class="literal">none</code></strong></span>
        </p><p>
          どの操作もバッファリングしません。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong><code class="literal">inserts</code></strong></span>
        </p><p>
          挿入操作をバッファリングします。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong><code class="literal">deletes</code></strong></span>
        </p><p>
          削除のマーキング操作をバッファリングします。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong><code class="literal">changes</code></strong></span>
        </p><p>
          挿入操作と削除マーキング操作の両方をバッファリングします。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong><code class="literal">purges</code></strong></span>
        </p><p>
          バックグラウンドで実行される物理的な削除操作をバッファリングします。
        </p></li></ul></div><p>
      <code class="literal">innodb_change_buffering</code> パラメータは、MySQL オプションファイル (<code class="literal">my.cnf</code> または <code class="literal">my.ini</code>) で設定するか、<code class="literal">SET GLOBAL</code> ステートメントを使用して動的に変更できます。これには、グローバルシステム変数の設定に十分な権限が必要です。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 設定を変更しても、新しい操作のバッファリングに影響します。既存のバッファエントリのマージは影響を受けません。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-change-buffer-maximum-size"></a>変更バッファの最大サイズの構成</h4></div></div></div><p>
      <code class="literal">innodb_change_buffer_max_size</code> 変数を使用すると、変更バッファの最大サイズをバッファプールの合計サイズに対する割合として構成できます。 デフォルトでは、<code class="literal">innodb_change_buffer_max_size</code> は 25 に設定されます。 最大設定は 50 です。 
    </p><p>
      大量の挿入、更新および削除アクティビティがある MySQL サーバーで <code class="literal">innodb_change_buffer_max_size</code> を増やすことを検討してください。この場合、変更バッファのマージは新しい変更バッファエントリに対応しないため、変更バッファは最大サイズ制限に達します。
    </p><p>
      レポートに使用される静的データを使用して MySQL サーバー上の <code class="literal">innodb_change_buffer_max_size</code> を減らすことを検討してください。または、変更バッファがバッファプールと共有されるメモリー領域を大量に消費し、ページが必要以上に早くバッファプールからエージアウトされるようにすることを検討してください。
    </p><p>
      代表的なワークロードを使用して様々な設定をテストし、最適な構成を決定します。 <code class="literal">innodb_change_buffer_max_size</code> 設定は動的で、サーバーを再起動せずに設定を変更できます。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-change-buffer-monitoring"></a>変更バッファの監視</h4></div></div></div><a class="indexterm" name="idm44761365113248"></a><a class="indexterm" name="idm44761365111088"></a><p>
      変更バッファの監視には、次のオプションを使用できます:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">InnoDB</code> 標準モニターの出力には、変更バッファのステータス情報が含まれます。 モニターデータを表示するには、<code class="literal">SHOW ENGINE INNODB STATUS</code> ステートメントを発行します。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW ENGINE INNODB STATUS\G</code></strong>
</pre><p>
          バッファステータスの変更情報は、<code class="literal">INSERT BUFFER AND ADAPTIVE HASH INDEX</code> ヘッダーの下にあり、次のように表示されます:
        </p><pre class="programlisting">-------------------------------------
INSERT BUFFER AND ADAPTIVE HASH INDEX
-------------------------------------
Ibuf: size 1, free list len 0, seg size 2, 0 merges
merged operations:
 insert 0, delete mark 0, delete 0
discarded operations:
 insert 0, delete mark 0, delete 0
Hash table size 4425293, used cells 32, node heap has 1 buffer(s)
13577.57 hash searches/s, 202.47 non-hash searches/s
</pre><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-standard-monitor" title="15.17.3 InnoDB 標準モニターおよびロックモニターの出力">セクション15.17.3「InnoDB 標準モニターおよびロックモニターの出力」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">INFORMATION_SCHEMA.INNODB_METRICS</code> テーブルには、<code class="literal">InnoDB</code> 標準モニターの出力にあるデータポイントのほとんどと、その他のデータポイントが表示されます。 変更バッファメトリックおよびそれぞれの説明を表示するには、次のクエリーを発行します: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT NAME, COMMENT FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME LIKE '%ibuf%'\G</code></strong>
</pre><p>
          <code class="literal">INNODB_METRICS</code> テーブルの使用方法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-information-schema-metrics-table" title="15.15.6 InnoDB INFORMATION_SCHEMA メトリックテーブル">セクション15.15.6「InnoDB INFORMATION_SCHEMA メトリックテーブル」</a> を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code> テーブルには、バッファインデックスの変更やバッファビットマップの変更など、バッファプール内の各ページに関するメタデータが表示されます。 変更バッファページは、<code class="literal">PAGE_TYPE</code> によって識別されます。 <code class="literal">IBUF_INDEX</code> は変更バッファインデックスページのページタイプで、<code class="literal">IBUF_BITMAP</code> は変更バッファビットマップページのページタイプです。 
        </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
            <code class="literal">INNODB_BUFFER_PAGE</code> テーブルをクエリーすると、大幅なパフォーマンスのオーバーヘッドが生じる可能性があります。 パフォーマンスへの影響を回避するために、調査しようとしている問題をテストインスタンスで再現し、テストインスタンスでクエリーを実行してください。 
          </p></div><p>
          たとえば、<code class="literal">INNODB_BUFFER_PAGE</code> テーブルをクエリーして、合計バッファプールページ数に対する <code class="literal">IBUF_INDEX</code> および <code class="literal">IBUF_BITMAP</code> ページの概数を確認できます。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT (SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></strong>
       <strong class="userinput"><code>WHERE PAGE_TYPE LIKE 'IBUF%') AS change_buffer_pages,</code></strong>
       <strong class="userinput"><code>(SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE) AS total_pages,</code></strong>
       <strong class="userinput"><code>(SELECT ((change_buffer_pages/total_pages)*100))</code></strong>
       <strong class="userinput"><code>AS change_buffer_page_percentage;</code></strong>
+---------------------+-------------+-------------------------------+
| change_buffer_pages | total_pages | change_buffer_page_percentage |
+---------------------+-------------+-------------------------------+
|                  25 |        8192 |                        0.3052 |
+---------------------+-------------+-------------------------------+
</pre><p>
          <code class="literal">INNODB_BUFFER_PAGE</code> テーブルで提供されるその他のデータの詳細は、<a class="xref" href="information-schema.html#information-schema-innodb-buffer-page-table" title="26.51.1 INFORMATION_SCHEMA INNODB_BUFFER_PAGE テーブル">セクション26.51.1「INFORMATION_SCHEMA INNODB_BUFFER_PAGE テーブル」</a> を参照してください。 関連する使用方法については、<a class="xref" href="innodb-storage-engine.html#innodb-information-schema-buffer-pool-tables" title="15.15.5 InnoDB INFORMATION_SCHEMA バッファープールテーブル">セクション15.15.5「InnoDB INFORMATION_SCHEMA バッファープールテーブル」</a> を参照してください。 
        </p></li><li class="listitem"><p>
          <a class="link" href="performance-schema.html" title="第 27 章 MySQL パフォーマンススキーマ">Performance Schema</a> には、高度なパフォーマンス監視のための変更バッファ相互排他ロック待機インストゥルメンテーションが用意されています。 変更バッファーインストゥルメンテーションを表示するには、次のクエリーを発行します: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.setup_instruments</code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE '%wait/synch/mutex/innodb/ibuf%';</code></strong>
+-------------------------------------------------------+---------+-------+
| NAME                                                  | ENABLED | TIMED |
+-------------------------------------------------------+---------+-------+
| wait/synch/mutex/innodb/ibuf_bitmap_mutex             | YES     | YES   |
| wait/synch/mutex/innodb/ibuf_mutex                    | YES     | YES   |
| wait/synch/mutex/innodb/ibuf_pessimistic_insert_mutex | YES     | YES   |
+-------------------------------------------------------+---------+-------+
</pre><p>
          <code class="literal">InnoDB</code> mutex 待機の監視の詳細は、<a class="xref" href="innodb-storage-engine.html#monitor-innodb-mutex-waits-performance-schema" title="15.16.2 パフォーマンススキーマを使用した InnoDB Mutex 待機のモニタリング">セクション15.16.2「パフォーマンススキーマを使用した InnoDB Mutex 待機のモニタリング」</a> を参照してください。
        </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-adaptive-hash"></a>15.5.3 適応型ハッシュインデックス</h3></div></div></div><a class="indexterm" name="idm44761365066704"></a><a class="indexterm" name="idm44761365064544"></a><p>
      適応型ハッシュインデックス機能を使用すると、<code class="literal">InnoDB</code> は、トランザクション機能や信頼性を犠牲にすることなく、ワークロードとバッファプールに十分なメモリーを適切に組み合わせたシステム上で、インメモリデータベースのように実行できます。 適応ハッシュインデックス機能は、<code class="literal">innodb_adaptive_hash_index</code> オプションによって有効化され、または <code class="literal">--skip-innodb-adaptive-hash-index</code> オプションにより無効化されます。 
    </p><p>
      検出された検索パターンに基づいて、インデックスキーの接頭辞を使用してハッシュインデックスが作成されます。 接頭辞は任意の長さにでき、B ツリーの一部の値のみがハッシュインデックスに表示される場合があります。 ハッシュインデックスは、頻繁にアクセスされるインデックスのページに対してオンデマンドで作成されます。 
    </p><p>
      テーブルがメインメモリー内にほぼ完全に収容されている場合は、任意の要素の直接検索を有効にし、インデックス値をポインタの一種に変換すると、ハッシュインデックスを使用してクエリーを高速にすることができます。 <code class="literal">InnoDB</code> には、インデックスの検索をモニターするメカニズムが備わっています。 ハッシュインデックスの構築がクエリーにとって有益であると <code class="literal">InnoDB</code> が判断した場合は、自動的にそのインデックスが構築されます。 
    </p><p>
      一部のワークロードでは、ハッシュインデックスの検索による高速化の方が、インデックスの検索をモニターしたり、ハッシュインデックスの構造を保持したりする追加の作業よりも重要です。 適応型ハッシュインデックスへのアクセスは、複数の同時結合など、負荷の高いワークロードで競合の原因になる場合があります。 <code class="literal">LIKE</code> 演算子および <code class="literal">%</code> ワイルドカードを使用したクエリーもメリットが得られない傾向があります。 適応型ハッシュインデックス機能のメリットが得られないワークロードの場合、これをオフにすると不要なパフォーマンスオーバーヘッドが軽減されます。 適応型ハッシュインデックス機能が特定のシステムおよびワークロードに適しているかどうかを事前に予測することは困難であるため、有効化および無効化してベンチマークを実行することを検討してください。 MySQL 5.6 のアーキテクチャの変更により、適応型ハッシュインデックス機能を以前のリリースよりも無効にする方が適しています。 
    </p><p>
      適応ハッシュインデックス機能はパーティション化されています。 各インデックスは特定のパーティションにバインドされ、各パーティションは個別のラッチによって保護されます。 パーティション化は、<code class="literal">innodb_adaptive_hash_index_parts</code> 変数によって制御されます。 <code class="literal">innodb_adaptive_hash_index_parts</code> 変数はデフォルトで 8 に設定されています。 最大設定は 512 です。 
    </p><p>
      <code class="literal">SHOW ENGINE INNODB STATUS</code> 出力の <code class="literal">SEMAPHORES</code> セクションで、適応型ハッシュインデックスの使用および競合を監視できます。 <code class="filename">btr0sea.c</code> で作成された RW バッチを待機しているスレッドが多数ある場合は、適応ハッシュインデックスパーティションの数を増やすか、適応ハッシュインデックス機能を無効にすることを検討してください。 
    </p><p>
      ハッシュインデックスのパフォーマンス特性の詳細は、<a class="xref" href="optimization.html#index-btree-hash" title="8.3.9 B ツリーインデックスとハッシュインデックスの比較">セクション8.3.9「B ツリーインデックスとハッシュインデックスの比較」</a> を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-redo-log-buffer"></a>15.5.4 ログバッファ</h3></div></div></div><p>
      ログバッファは、ディスク上のログファイルに書き込まれるデータを保持するメモリー領域です。 ログバッファサイズは、<code class="literal">innodb_log_buffer_size</code> 変数によって定義されます。 デフォルトのサイズは 16M バイトです。 ログバッファの内容は定期的にディスクにフラッシュされます。 大きいログバッファを使用すると、トランザクションがコミットされる前に redo ログデータをディスクに書き込むことなく、大きなトランザクションを実行できます。 したがって、多数の行を更新、挿入または削除するトランザクションがある場合は、ログバッファのサイズを大きくするとディスク I/O が節約されます。 
    </p><p>
      <code class="literal">innodb_flush_log_at_trx_commit</code> 変数は、ログバッファの内容をディスクに書き込む方法およびフラッシュする方法を制御します。 <code class="literal">innodb_flush_log_at_timeout</code> 変数は、ログのフラッシュ頻度を制御します。 
    </p><p>
      関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-startup-memory-configuration" title="メモリー構成">メモリー構成</a>,および<a class="xref" href="optimization.html#optimizing-innodb-logging" title="8.5.4 InnoDB redo ロギングの最適化">セクション8.5.4「InnoDB redo ロギングの最適化」</a>を参照してください。
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-on-disk-structures"></a>15.6 InnoDB オンディスク構造</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-tables">15.6.1 テーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-indexes">15.6.2 インデックス</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-tablespace">15.6.3 テーブルスペース</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-doublewrite-buffer">15.6.4 二重書き込みバッファー</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-redo-log">15.6.5 redo ログ</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-undo-logs">15.6.6 undo ログ</a></span></dt></dl></div><a class="indexterm" name="idm44761365032560"></a><p>
    このセクションでは、<code class="literal">InnoDB</code> のディスク上の構造および関連項目について説明します。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-tables"></a>15.6.1 テーブル</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#using-innodb-tables">15.6.1.1 InnoDB テーブルの作成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-create-table-external">15.6.1.2 外部でのテーブルの作成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-table-import">15.6.1.3 InnoDB テーブルのインポート</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-migration">15.6.1.4 InnoDB テーブルの移動またはコピー</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#converting-tables-to-innodb">15.6.1.5 MyISAM から InnoDB へのテーブルの変換</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-auto-increment-handling">15.6.1.6 InnoDB での AUTO_INCREMENT 処理</a></span></dt></dl></div><a class="indexterm" name="idm44761365028320"></a><p>
    このセクションでは、<code class="literal">InnoDB</code> テーブルに関連するトピックについて説明します。
  </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="using-innodb-tables"></a>15.6.1.1 InnoDB テーブルの作成</h4></div></div></div><a class="indexterm" name="idm44761365023744"></a><p>
      <code class="literal">InnoDB</code> テーブルを作成するには、<code class="literal">CREATE TABLE</code> ステートメントを使用します。
    </p><pre class="programlisting">CREATE TABLE t1 (a INT, b CHAR (20), PRIMARY KEY (a)) ENGINE=InnoDB;
</pre><p>
      <code class="literal">InnoDB</code> がデフォルトのストレージエンジン (デフォルト) として定義されている場合は、<code class="literal">ENGINE=InnoDB</code> 句を指定する必要はありません。 デフォルトのストレージエンジンを確認するには、次のステートメントを発行します: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@default_storage_engine;</code></strong>
+--------------------------+
| @@default_storage_engine |
+--------------------------+
| InnoDB                   |
+--------------------------+
</pre><p>
      <span class="command"><strong>mysqldump</strong></span> またはレプリケーションを使用して、デフォルトのストレージエンジンが <code class="literal">InnoDB</code> ではないサーバー上で <code class="literal">CREATE TABLE</code> ステートメントをリプレイする場合は、引き続き <code class="literal">ENGINE=InnoDB</code> 句を使用できます。
    </p><p>
      <code class="literal">InnoDB</code> テーブルとそのインデックスは、<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">system tablespace</a>、<a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースまたは <a class="link" href="glossary.html#glos_general_tablespace" title="一般テーブルスペース">general tablespace</a> で作成できます。 <code class="literal">innodb_file_per_table</code> が有効な場合 (デフォルト)、<code class="literal">InnoDB</code> テーブルは個々の file-per-table テーブルスペースに暗黙的に作成されます。 逆に、<code class="literal">innodb_file_per_table</code> を無効にすると、<code class="literal">InnoDB</code> システムテーブルスペースに <code class="literal">InnoDB</code> テーブルが暗黙的に作成されます。 一般的なテーブルスペースにテーブルを作成するには、<code class="literal">CREATE TABLE ... TABLESPACE</code> 構文を使用します。 詳細は、<a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="15.6.3.3 一般テーブルスペース">セクション15.6.3.3「一般テーブルスペース」</a>を参照してください。 
    </p><p>
      file-per-table テーブルスペースにテーブルを作成すると、MySQL はデフォルトで、MySQL データディレクトリの下のデータベースディレクトリに <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibd</a> テーブルスペースファイルを作成します。 <code class="literal">InnoDB</code> システムテーブルスペースに作成されたテーブルは、MySQL データディレクトリに存在する既存の <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">ibdata file</a> に作成されます。 一般テーブルスペースで作成されたテーブルは、既存の一般テーブルスペース <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibd file</a> に作成されます。 一般的なテーブルスペースファイルは、MySQL データディレクトリの内外に作成できます。 詳細は、<a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="15.6.3.3 一般テーブルスペース">セクション15.6.3.3「一般テーブルスペース」</a>を参照してください。 
    </p><p>
      <code class="literal">InnoDB</code> では、内部的に各テーブルのエントリがデータディクショナリに追加されます。 このエントリには、データベース名が含まれます。 たとえば、テーブル <code class="literal">t1</code> が <code class="literal">test</code> データベースに作成されている場合、データベース名のデータディクショナリエントリは<code class="literal">'test/t1'</code>です。 これは、同じ名前 (<code class="literal">t1</code>) のテーブルを別のデータベースに作成でき、テーブル名が <code class="literal">InnoDB</code> 内で衝突しないことを意味します。 
    </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-tables-row-format"></a>InnoDB のテーブルと行の形式</h5></div></div></div><a class="indexterm" name="idm44761364987728"></a><p>
        <code class="literal">InnoDB</code> テーブルのデフォルトの行形式は、<code class="literal">DYNAMIC</code> のデフォルト値を持つ <code class="literal">innodb_default_row_format</code> 構成オプションによって定義されます。 <code class="literal"><a class="link" href="glossary.html#glos_dynamic_row_format" title="動的行フォーマット">Dynamic</a></code> および <code class="literal"><a class="link" href="glossary.html#glos_compressed_row_format" title="圧縮行フォーマット">Compressed</a></code> の行形式を使用すると、テーブル圧縮や長いカラム値の効率的なオフページストレージなどの <code class="literal">InnoDB</code> 機能を利用できます。 これらの行フォーマットを使用するには、<code class="literal">innodb_file_per_table</code> を有効 (デフォルト) にする必要があります。 
      </p><pre class="programlisting">SET GLOBAL innodb_file_per_table=1;
CREATE TABLE t3 (a INT, b CHAR (20), PRIMARY KEY (a)) ROW_FORMAT=DYNAMIC;
CREATE TABLE t4 (a INT, b CHAR (20), PRIMARY KEY (a)) ROW_FORMAT=COMPRESSED;
</pre><p>
        または、<code class="literal">CREATE TABLE ... TABLESPACE</code> 構文を使用して、一般的なテーブルスペースに <code class="literal">InnoDB</code> テーブルを作成することもできます。 一般テーブルスペースでは、すべての行形式がサポートされます。 詳細は、<a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="15.6.3.3 一般テーブルスペース">セクション15.6.3.3「一般テーブルスペース」</a>を参照してください。 
      </p><pre class="programlisting">CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts1 ROW_FORMAT=DYNAMIC;
</pre><p>
        <code class="literal">CREATE TABLE ... TABLESPACE</code> 構文を使用して、<code class="literal">Compact</code> または <code class="literal">Redundant</code> 行形式のテーブルとともに、<code class="literal">Dynamic</code> 行形式の <code class="literal">InnoDB</code> テーブルをシステムテーブルスペースに作成することもできます。
      </p><pre class="programlisting">CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE = innodb_system ROW_FORMAT=DYNAMIC;
</pre><p>
        <code class="literal">InnoDB</code> の行フォーマットの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="15.10 InnoDB の行フォーマット">セクション15.10「InnoDB の行フォーマット」</a> を参照してください。 <code class="literal">InnoDB</code> テーブルの行フォーマットおよび <code class="literal">InnoDB</code> の行フォーマットの物理特性を決定する方法は、<a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="15.10 InnoDB の行フォーマット">セクション15.10「InnoDB の行フォーマット」</a> を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-tables-primary-key"></a>InnoDB テーブルおよび主キー</h5></div></div></div><a class="indexterm" name="idm44761364961008"></a><p>
        <code class="literal">InnoDB</code> テーブルに対して常に <a class="link" href="glossary.html#glos_primary_key" title="主キー">primary key</a> を定義し、次のようなカラムを指定します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            もっとも重要なクエリーで参照される。
          </p></li><li class="listitem"><p>
            ブランクのままになっていない。
          </p></li><li class="listitem"><p>
            重複する値がない。
          </p></li><li class="listitem"><p>
            挿入後に値が変更されるとしても、きわめてまれである。
          </p></li></ul></div><p>
        たとえば、人に関する情報を含むテーブルでは、複数の人が同じ名前を持つ可能性もあり、名字をブランクにしたり、名前を変更したりする人もいるため、<code class="literal">(名、姓)</code> 上には主キーを作成しません。 制約が非常に多く、主キーとして使用する明確なカラムセットがないことも多い場合には、主キーの全部または一部として機能する数値 ID の新しいカラムを作成してください。 行が挿入されると自動的に昇順の値が入力されるように、<a class="link" href="glossary.html#glos_auto_increment" title="自動インクリメント">自動インクリメント</a>カラムを宣言できます。 
      </p><pre class="programlisting"># The value of ID can act like a pointer between related items in different tables.
CREATE TABLE t5 (id INT AUTO_INCREMENT, b CHAR (20), PRIMARY KEY (id));

# The primary key can consist of more than one column. Any autoinc column must come first.
CREATE TABLE t6 (id INT AUTO_INCREMENT, a INT, b CHAR (20), PRIMARY KEY (id,a));
</pre><p>
        主キーを定義しなくてもテーブルは正しく機能しますが、主キーはパフォーマンスの多くの側面に関係し、大規模または頻繁に使用されるテーブルにとって重要な設計面です。 <code class="literal">CREATE TABLE</code> ステートメントでは、常に主キーを指定することをお薦めします。 テーブルを作成し、データをロードしてから、後で <code class="literal">ALTER TABLE</code> を実行して主キーを追加すると、テーブルの作成時に主キーを定義するよりも操作速度が大幅に遅くなります。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-viewing-table-properties"></a>InnoDB テーブルのプロパティの表示</h5></div></div></div><a class="indexterm" name="idm44761364943568"></a><p>
        <code class="literal">InnoDB</code> テーブルのプロパティを表示するには、<code class="literal">SHOW TABLE STATUS</code> ステートメントを発行します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW TABLE STATUS FROM test LIKE 't%' \G;</code></strong>
*************************** 1. row ***************************
           Name: t1
         Engine: InnoDB
        Version: 10
     Row_format: Compact
           Rows: 0
 Avg_row_length: 0
    Data_length: 16384
Max_data_length: 0
   Index_length: 0
      Data_free: 0
 Auto_increment: NULL
    Create_time: 2015-03-16 15:13:31
    Update_time: NULL
     Check_time: NULL
      Collation: utf8mb4_0900_ai_ci
       Checksum: NULL
 Create_options:
        Comment:
</pre><p>
        <code class="literal">SHOW TABLE STATUS</code> 出力の詳細は、<a class="xref" href="sql-statements.html#show-table-status" title="13.7.7.38 SHOW TABLE STATUS ステートメント">セクション13.7.7.38「SHOW TABLE STATUS ステートメント」</a> を参照してください。
      </p><p>
        <code class="literal">InnoDB</code> テーブルのプロパティは、<code class="literal">InnoDB</code> Information Schema システムテーブルを使用してクエリーすることもできます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_TABLES WHERE NAME='test/t1' \G</code></strong>
*************************** 1. row ***************************
     TABLE_ID: 45
         NAME: test/t1
         FLAG: 1
       N_COLS: 5
        SPACE: 35
   ROW_FORMAT: Compact
ZIP_PAGE_SIZE: 0
   SPACE_TYPE: Single
</pre><p>
        詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-information-schema-system-tables" title="15.15.3 InnoDB INFORMATION_SCHEMA スキーマオブジェクトテーブル">セクション15.15.3「InnoDB INFORMATION_SCHEMA スキーマオブジェクトテーブル」</a>を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-create-table-external"></a>15.6.1.2 外部でのテーブルの作成</h4></div></div></div><p>
      <code class="literal">InnoDB</code> テーブルを外部で作成する (つまり、データディレクトリ外でテーブルを作成する) 理由は様々です。 このような理由には、領域管理、I/O の最適化、特定のパフォーマンスまたは容量特性を持つストレージデバイスへのテーブルの配置などがあります。 
    </p><p>
      <code class="literal">InnoDB</code> では、テーブルを外部で作成するために次の方法がサポートされています:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-create-table-external-data-directory" title="DATA DIRECTORY 句の使用">DATA DIRECTORY 句の使用</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-create-table-external-tablespace-syntax" title="CREATE TABLE ... TABLESPACE 構文の使用">CREATE TABLE ... TABLESPACE 構文の使用</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-create-table-external-tablespace" title="外部一般テーブルスペースでのテーブルの作成">外部一般テーブルスペースでのテーブルの作成</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-create-table-external-data-directory"></a>DATA DIRECTORY 句の使用</h5></div></div></div><p>
        外部ディレクトリに <code class="literal">InnoDB</code> テーブルを作成するには、<code class="literal">CREATE TABLE</code> ステートメントで <code class="literal">DATA DIRECTORY</code> 句を指定します。
      </p><pre class="programlisting">CREATE TABLE t1 (c1 INT PRIMARY KEY) DATA DIRECTORY = '<em class="replaceable"><code>/external/directory</code></em>';</pre><p>
        file-per-table テーブルスペースに作成されたテーブルでは、<code class="literal">DATA DIRECTORY</code> 句がサポートされています。 <code class="literal">innodb_file_per_table</code> 変数が有効になっている場合 (デフォルト)、テーブルは file-per-table テーブルスペースに暗黙的に作成されます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@innodb_file_per_table;</code></strong>
+-------------------------+
| @@innodb_file_per_table |
+-------------------------+
|                       1 |
+-------------------------+
</pre><p>
        file-per-table テーブルスペースの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-file-per-table-tablespaces" title="15.6.3.2 File-Per-Table テーブルスペース">セクション15.6.3.2「File-Per-Table テーブルスペース」</a> を参照してください。
      </p><p>
        <code class="literal">CREATE TABLE</code> ステートメントで <code class="literal">DATA DIRECTORY</code> 句を指定すると、指定したディレクトリの下のスキーマディレクトリにテーブルデータファイル (<code class="filename"><em class="replaceable"><code>table_name</code></em>.ibd</code>) が作成されます。
      </p><p>
        MySQL 8.0.21 では、<code class="literal">DATA DIRECTORY</code> 句を使用してデータディレクトリの外部で作成されるテーブルおよびテーブルパーティションは、<code class="literal">InnoDB</code> で認識されるディレクトリに制限されます。 この要件により、データベース管理者はテーブルスペースデータファイルが作成される場所を制御し、リカバリ中にデータファイルを検出できるようになります (<a class="xref" href="innodb-storage-engine.html#innodb-recovery-tablespace-discovery" title="クラッシュリカバリ中のテーブルスペースの検出">クラッシュリカバリ中のテーブルスペースの検出</a> を参照)。 既知のディレクトリは、<code class="literal">datadir</code>、<code class="literal">innodb_data_home_dir</code> および <code class="literal">innodb_directories</code> 変数で定義されているディレクトリです。 次のステートメントを使用して、これらの設定を確認できます: 
      </p><pre class="programlisting">mysql&gt; SELECT @@datadir,@@innodb_data_home_dir,@@innodb_directories;
</pre><p>
        使用するディレクトリが不明な場合は、テーブルを作成する前に <code class="literal">innodb_directories</code> 設定に追加します。 <code class="literal">innodb_directories</code> 変数は読取り専用です。 構成するには、サーバーを再起動する必要があります。 システム変数の設定に関する一般情報は、<a class="xref" href="server-administration.html#using-system-variables" title="5.1.9 システム変数の使用">セクション5.1.9「システム変数の使用」</a> を参照してください。 
      </p><p>
        次の例では、<code class="literal">DATA DIRECTORY</code> 句を使用して外部ディレクトリにテーブルを作成する方法を示します。 <code class="literal">innodb_file_per_table</code> 変数が有効で、ディレクトリが <code class="literal">InnoDB</code> に認識されていることを前提としています。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
Database changed

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT PRIMARY KEY) DATA DIRECTORY = '<em class="replaceable"><code>/external/directory</code></em>';</code></strong>

# MySQL creates the table's data file in a schema directory
# under the external directory

shell&gt; <strong class="userinput"><code>cd /external/directory/test</code></strong>
shell&gt; <strong class="userinput"><code>ls</code></strong>
t1.ibd
</pre><h6><a name="idm44761364888464"></a>使用上の注意:</h6><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL では、最初にテーブルスペースデータファイルが開いた状態で保持されるため、デバイスをディスマウントできませんが、サーバーがビジー状態の場合は最終的にファイルが閉じられる可能性があります。 MySQL の実行中に外部デバイスを誤ってディスマウントしたり、デバイスの切断中に MySQL を起動したりしないように注意してください。 関連付けられたデータファイルがないときにテーブルにアクセスしようとすると、重大なエラーが発生し、サーバーの再起動が必要になります。 
          </p><p>
            必要なパスにデータファイルが見つからない場合、サーバーの再起動が失敗することがあります。 この場合、テーブルスペースデータファイルをバックアップからリストアするか、テーブルを削除して <a class="link" href="glossary.html#glos_data_dictionary" title="データディクショナリ">data dictionary</a> から削除できます。 
          </p></li><li class="listitem"><p>
            NFS マウントされたボリュームにテーブルを配置する前に、<a class="xref" href="optimization.html#disk-issues-nfs" title="MySQL での NFS の使用">MySQL での NFS の使用</a> で概説されている潜在的な問題を確認します。
          </p></li><li class="listitem"><p>
            LVM スナップショット、ファイルコピーまたはその他のファイルベースのメカニズムを使用してテーブルデータファイルをバックアップする場合は、バックアップが発生する前に、必ず <code class="literal">FLUSH TABLES ... FOR EXPORT</code> ステートメントを使用して、メモリーにバッファリングされるすべての変更が <a class="link" href="glossary.html#glos_flush" title="フラッシュ">flushed</a> からディスクになるようにします。
          </p></li><li class="listitem"><p>
            <code class="literal">DATA DIRECTORY</code> 句を使用して外部ディレクトリにテーブルを作成する方法は、<code class="literal">InnoDB</code> でサポートされていない <a class="link" href="optimization.html#symbolic-links" title="8.12.2 シンボリックリンクの使用">symbolic links</a> を使用するかわりに使用する方法です。
          </p></li><li class="listitem"><p>
            <code class="literal">DATA DIRECTORY</code> 句は、ソースとレプリカが同じホストに存在するレプリケーション環境ではサポートされていません。 <code class="literal">DATA DIRECTORY</code> 句には完全なディレクトリパスが必要です。 この場合、パスをレプリケートすると、ソースとレプリカは同じ場所にテーブルを作成します。 
          </p></li><li class="listitem"><p>
            MySQL 8.0.21 の時点では、file-per-table テーブルスペースで作成されたテーブルは、<code class="literal">InnoDB</code> で直接認識されていないかぎり、undo テーブルスペースディレクトリ (<code class="literal">innodb_undo_directory</code>) に作成できなくなりました。 既知のディレクトリは、<code class="literal">datadir</code>、<code class="literal">innodb_data_home_dir</code> および <code class="literal">innodb_directories</code> 変数で定義されているディレクトリです。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-create-table-external-tablespace-syntax"></a>CREATE TABLE ... TABLESPACE 構文の使用</h5></div></div></div><p>
        <code class="literal">CREATE TABLE ... TABLESPACE</code> 構文を <code class="literal">DATA DIRECTORY</code> 句と組み合せて使用すると、外部ディレクトリにテーブルを作成できます。 これを行うには、テーブルスペース名として <code class="literal">innodb_file_per_table</code> を指定します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (c1 INT PRIMARY KEY) TABLESPACE = innodb_file_per_table</code></strong>
       <strong class="userinput"><code>DATA DIRECTORY = '/external/directory';</code></strong>
</pre><p>
        この方法は、file-per-table テーブルスペースで作成されたテーブルでのみサポートされますが、<code class="literal">innodb_file_per_table</code> 変数を有効にする必要はありません。 他のすべての点では、このメソッドは前述の <code class="literal">CREATE TABLE ... DATA DIRECTORY</code> メソッドと同等です。 同じ使用上のノートが適用されます。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-create-table-external-tablespace"></a>外部一般テーブルスペースでのテーブルの作成</h5></div></div></div><p>
        外部ディレクトリに存在する一般的なテーブルスペースにテーブルを作成できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            外部ディレクトリでの一般的なテーブルスペースの作成の詳細は、<a class="xref" href="innodb-storage-engine.html#general-tablespaces-creating" title="一般的なテーブルスペースの作成">一般的なテーブルスペースの作成</a> を参照してください。
          </p></li><li class="listitem"><p>
            一般的なテーブルスペースでのテーブルの作成の詳細は、<a class="xref" href="innodb-storage-engine.html#general-tablespaces-adding-tables" title="一般テーブルスペースへのテーブルの追加">一般テーブルスペースへのテーブルの追加</a> を参照してください。
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-table-import"></a>15.6.1.3 InnoDB テーブルのインポート</h4></div></div></div><a class="indexterm" name="idm44761364847760"></a><a class="indexterm" name="idm44761364846704"></a><a class="indexterm" name="idm44761364844560"></a><p>
      このセクションでは、file-per-table テーブルスペースに存在するテーブル、パーティションテーブルまたは個々のテーブルパーティションのインポートを許可する<span class="emphasis"><em>トランスポータブルテーブルスペース</em></span>機能を使用してテーブルをインポートする方法について説明します。 テーブルをインポートする理由は多数あります: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          本番以外の MySQL サーバーインスタンスでレポートを実行して、本番サーバーに余分な負荷をかけないようにします。
        </p></li><li class="listitem"><p>
          新しいレプリカサーバーにデータをコピーします。
        </p></li><li class="listitem"><p>
          バックアップされたテーブルスペースファイルからテーブルをリストアします。
        </p></li><li class="listitem"><p>
          ダンプファイルをインポートするよりも高速にデータを移動できるため、データを再挿入してインデックスを再構築する必要があります。
        </p></li><li class="listitem"><p>
          ストレージ要件に適したストレージメディアを備えたサーバーにデータを移動する場合。 たとえば、ビジー状態のテーブルを SSD デバイスに移動したり、大容量のテーブルを大容量 HDD デバイスに移動したりできます。 
        </p></li></ul></div><p>
      <span class="emphasis"><em>トランスポータブルテーブルスペース</em></span>機能については、このセクションの次のトピックで説明します:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-table-import-prerequsites" title="前提条件">前提条件</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-table-import-example" title="テーブルのインポート">テーブルのインポート</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-table-import-partitioned-table" title="パーティションテーブルのインポート">パーティションテーブルのインポート</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-table-import-partitions" title="テーブルパーティションのインポート">テーブルパーティションのインポート</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-table-import-limitations" title="制限">制限</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-table-import-usage-notes" title="使用上の注意">使用上の注意</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-table-import-internals" title="内部情報">内部情報</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-table-import-prerequsites"></a>前提条件</h5></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">innodb_file_per_table</code> 変数は、デフォルトで有効になっている必要があります。
          </p></li><li class="listitem"><p>
            テーブルスペースのページサイズは、宛先 MySQL サーバーインスタンスのページサイズと一致する必要があります。 <code class="literal">InnoDB</code> のページサイズは、MySQL サーバーインスタンスの初期化時に構成される <code class="literal">innodb_page_size</code> 変数によって定義されます。 
          </p></li><li class="listitem"><p>
            テーブルが外部キー関係にある場合は、<code class="literal">DISCARD TABLESPACE</code> を実行する前に <code class="literal">foreign_key_checks</code> を無効にする必要があります。 また、<code class="literal">ALTER TABLE ... IMPORT TABLESPACE</code> ではインポートされたデータに外部キー制約が強制されないため、すべての外部キー関連テーブルを同じ論理的な時点でエクスポートする必要があります。 これを行うには、関連するテーブルの更新を停止し、すべてのトランザクションをコミットし、テーブルの共有ロックを取得して、エクスポート操作を実行します。 
          </p></li><li class="listitem"><p>
            別の MySQL サーバーインスタンスからテーブルをインポートする場合、両方の MySQL サーバーインスタンスのステータスは GA (General Availability) であり、同じバージョンである必要があります。 それ以外の場合は、インポート先と同じ MySQL サーバーインスタンスにテーブルを作成する必要があります。 
          </p></li><li class="listitem"><p>
            <code class="literal">CREATE TABLE</code> ステートメントで <code class="literal">DATA DIRECTORY</code> 句を指定して外部ディレクトリにテーブルを作成した場合は、宛先インスタンスで置換するテーブルを同じ <code class="literal">DATA DIRECTORY</code> 句で定義する必要があります。 句が一致しない場合は、スキーマの不一致エラーが報告されます。 ソーステーブルが <code class="literal">DATA DIRECTORY</code> 句で定義されているかどうかを確認するには、<code class="literal">SHOW CREATE TABLE</code> を使用してテーブル定義を表示します。 <code class="literal">DATA DIRECTORY</code> 句の使用の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-create-table-external" title="15.6.1.2 外部でのテーブルの作成">セクション15.6.1.2「外部でのテーブルの作成」</a> を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">ROW_FORMAT</code> オプションがテーブル定義で明示的に定義されていない場合、または <code class="literal">ROW_FORMAT=DEFAULT</code> が使用されている場合、<code class="literal">innodb_default_row_format</code> 設定はソースインスタンスと宛先インスタンスで同じである必要があります。 そうしないと、インポート操作を試行したときにスキーマの不一致エラーが報告されます。 <code class="literal">SHOW CREATE TABLE</code> を使用してテーブル定義を確認します。 <code class="literal">SHOW VARIABLES</code> を使用して、<code class="literal">innodb_default_row_format</code> 設定を確認します。 関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-row-format-defining" title="テーブルの行形式の定義">テーブルの行形式の定義</a>を参照してください。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-table-import-example"></a>テーブルのインポート</h5></div></div></div><p>
        この例では、file-per-table テーブルスペースに存在する通常の非パーティションテーブルをインポートする方法を示します。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            宛先インスタンスで、インポートするテーブルと同じ定義でテーブルを作成します。 (テーブル定義は、<code class="literal">SHOW CREATE TABLE</code> 構文を使用して取得できます。) テーブル定義が一致しない場合は、インポート操作を試行するとスキーマの不一致エラーが報告されます。 
          </p><pre class="programlisting">mysql&gt; USE test;
mysql&gt; CREATE TABLE t1 (c1 INT) ENGINE=INNODB;
</pre></li><li class="listitem"><p>
            宛先インスタンスで、作成したテーブルのテーブルスペースを破棄します。 (インポートする前に、受信側のテーブルのテーブルスペースを破棄する必要があります。) 
          </p><pre class="programlisting">mysql&gt; ALTER TABLE t1 DISCARD TABLESPACE;
</pre></li><li class="listitem"><p>
            ソースインスタンスで、<code class="literal">FLUSH TABLES ... FOR EXPORT</code> を実行して、インポートするテーブルを静止します。 テーブルが静止している場合、テーブルでは読取り専用トランザクションのみが許可されます。 
          </p><pre class="programlisting">mysql&gt; USE test;
mysql&gt; FLUSH TABLES t1 FOR EXPORT;
</pre><p>
            <code class="literal">FLUSH TABLES ... FOR EXPORT</code> は、サーバーの実行中にバイナリテーブルのコピーを作成できるように、指定されたテーブルへの変更がディスクにフラッシュされていることを確認します。 <code class="literal">FLUSH TABLES ... FOR EXPORT</code> を実行すると、<code class="literal">InnoDB</code> によって、テーブルのスキーマディレクトリに <code class="filename">.cfg</code> メタデータファイルが生成されます。 <code class="filename">.cfg</code> ファイルには、インポート操作中のスキーマ検証に使用されるメタデータが含まれています。 
          </p></li><li class="listitem"><p>
            <code class="filename">.ibd</code> ファイルおよび <code class="filename">.cfg</code> メタデータファイルをソースインスタンスから宛先インスタンスにコピーします。 例: 
          </p><pre class="programlisting">shell&gt; scp <em class="replaceable"><code>/path/to/datadir</code></em>/test/t1.{ibd,cfg} destination-server:<em class="replaceable"><code>/path/to/datadir</code></em>/test
</pre><p>
            <code class="filename">.ibd</code> ファイルおよび <code class="filename">.cfg</code> ファイルは、次の手順で示すように、共有ロックを解放する前にコピーする必要があります。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              暗号化されたテーブルスペースからテーブルをインポートする場合、<code class="literal">InnoDB</code> は <code class="filename">.cfg</code> メタデータファイルに加えて <code class="filename">.cfp</code> ファイルを生成します。 <code class="filename">.cfp</code> ファイルは、<code class="filename">.cfg</code> ファイルとともに宛先インスタンスにコピーする必要があります。 <code class="filename">.cfp</code> ファイルには、転送キーと暗号化されたテーブルスペースキーが含まれます。 インポート時に、<code class="literal">InnoDB</code> は転送キーを使用してテーブルスペースキーを復号化します。 関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-data-encryption" title="15.13 InnoDB 保存データ暗号化">セクション15.13「InnoDB 保存データ暗号化」</a>を参照してください。 
            </p></div></li><li class="listitem"><p>
            ソースインスタンスで、<code class="literal">UNLOCK TABLES</code> を使用して、<code class="literal">FLUSH TABLES ... FOR EXPORT</code> ステートメントで取得したロックを解放します:
          </p><pre class="programlisting">mysql&gt; USE test;
mysql&gt; UNLOCK TABLES;
</pre></li><li class="listitem"><p>
            宛先インスタンスで、テーブルスペースをインポートします:
          </p><pre class="programlisting">mysql&gt; USE test;
mysql&gt; ALTER TABLE t1 IMPORT TABLESPACE;
</pre></li></ol></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-table-import-partitioned-table"></a>パーティションテーブルのインポート</h5></div></div></div><p>
        この例では、各テーブルパーティションが file-per-table テーブルスペースに存在するパーティションテーブルをインポートする方法を示します。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            宛先インスタンスで、インポートするパーティションテーブルと同じ定義でパーティションテーブルを作成します。 (テーブル定義は、<code class="literal">SHOW CREATE TABLE</code> 構文を使用して取得できます。) テーブル定義が一致しない場合は、インポート操作を試行するとスキーマの不一致エラーが報告されます。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (i int) ENGINE = InnoDB PARTITION BY KEY (i) PARTITIONS 3;</code></strong>
</pre><p>
            <code class="literal">/<em class="replaceable"><code>datadir</code></em>/test</code> ディレクトリには、3 つのパーティションごとにテーブルスペースの <code class="filename">.ibd</code> ファイルがあります。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>\! ls <em class="replaceable"><code>/path/to/datadir</code></em>/test/</code></strong>
t1.frm  t1#p#p0.ibd  t1#p#p1.ibd  t1#p#p2.ibd
</pre></li><li class="listitem"><p>
            宛先インスタンスで、パーティションテーブルのテーブルスペースを破棄します。 (インポート操作の前に、受信側のテーブルのテーブルスペースを破棄する必要があります。) 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 DISCARD TABLESPACE;</code></strong>
</pre><p>
            パーティションテーブルの 3 つのテーブルスペース <code class="filename">.ibd</code> ファイルが<code class="literal">/<em class="replaceable"><code>datadir</code></em>/test</code> ディレクトリから破棄され、次のファイルが残されます:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>\! ls <em class="replaceable"><code>/path/to/datadir</code></em>/test/</code></strong>
t1.frm
</pre></li><li class="listitem"><p>
            ソースインスタンスで、<code class="literal">FLUSH TABLES ... FOR EXPORT</code> を実行して、インポートするパーティションテーブルを静止します。 テーブルが静止している場合、テーブルでは読取り専用トランザクションのみが許可されます。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>FLUSH TABLES t1 FOR EXPORT;</code></strong>
</pre><p>
            <code class="literal">FLUSH TABLES ... FOR EXPORT</code> では、サーバーの実行中にバイナリテーブルのコピーを作成できるように、指定されたテーブルへの変更がディスクにフラッシュされます。 <code class="literal">FLUSH TABLES ... FOR EXPORT</code> を実行すると、<code class="literal">InnoDB</code> によって、各テーブルスペースファイルのテーブルのスキーマディレクトリに <code class="filename">.cfg</code> メタデータファイルが生成されます。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>\! ls <em class="replaceable"><code>/path/to/datadir</code></em>/test/</code></strong>
t1#p#p0.ibd  t1#p#p1.ibd  t1#p#p2.ibd
t1.frm  t1#p#p0.cfg  t1#p#p1.cfg  t1#p#p2.cfg
</pre><p>
            <code class="filename">.cfg</code> ファイルには、テーブルスペースのインポート時にスキーマ検証に使用されるメタデータが含まれています。 <code class="literal">FLUSH TABLES ... FOR EXPORT</code> は、個々のテーブルパーティションではなく、テーブルでのみ実行できます。 
          </p></li><li class="listitem"><p>
            <code class="filename">.ibd</code> および <code class="filename">.cfg</code> ファイルをソースインスタンスのスキーマディレクトリから宛先インスタンスのスキーマディレクトリにコピーします。 例: 
          </p><pre class="programlisting">shell&gt;scp <strong class="userinput"><code><em class="replaceable"><code>/path/to/datadir</code></em>/test/t1*.{ibd,cfg} destination-server:<em class="replaceable"><code>/path/to/datadir</code></em>/test</code></strong>
</pre><p>
            次のステップで説明するように、共有ロックを解放する前に <code class="filename">.ibd</code> および <code class="filename">.cfg</code> ファイルをコピーする必要があります。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              暗号化されたテーブルスペースからテーブルをインポートする場合、<code class="literal">InnoDB</code> は <code class="filename">.cfg</code> メタデータファイルに加えて <code class="filename">.cfp</code> ファイルを生成します。 <code class="filename">.cfp</code> ファイルは、<code class="filename">.cfg</code> ファイルとともに宛先インスタンスにコピーする必要があります。 <code class="filename">.cfp</code> ファイルには、転送キーと暗号化されたテーブルスペースキーが含まれます。 インポート時に、<code class="literal">InnoDB</code> は転送キーを使用してテーブルスペースキーを復号化します。 関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-data-encryption" title="15.13 InnoDB 保存データ暗号化">セクション15.13「InnoDB 保存データ暗号化」</a>を参照してください。 
            </p></div></li><li class="listitem"><p>
            ソースインスタンスで、<code class="literal">UNLOCK TABLES</code> を使用して、<code class="literal">FLUSH TABLES ... FOR EXPORT</code> によって取得されたロックを解放します:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>UNLOCK TABLES;</code></strong>
</pre></li><li class="listitem"><p>
            宛先インスタンスで、パーティションテーブルのテーブルスペースをインポートします:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 IMPORT TABLESPACE;</code></strong>
</pre></li></ol></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-table-import-partitions"></a>テーブルパーティションのインポート</h5></div></div></div><p>
        この例では、各パーティションが file-per-table テーブルスペースファイルに存在する個々のテーブルパーティションをインポートする方法を示します。
      </p><p>
        次の例では、4 つのパーティションテーブルの 2 つのパーティション (<code class="literal">p2</code> および <code class="literal">p3</code>) がインポートされます。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            宛先インスタンスで、パーティションのインポート元のパーティションテーブルと同じ定義を使用してパーティションテーブルを作成します。 (テーブル定義は、<code class="literal">SHOW CREATE TABLE</code> 構文を使用して取得できます。) テーブル定義が一致しない場合は、インポート操作を試行するとスキーマの不一致エラーが報告されます。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (i int) ENGINE = InnoDB PARTITION BY KEY (i) PARTITIONS 4;</code></strong>
</pre><p>
            <code class="literal">/<em class="replaceable"><code>datadir</code></em>/test</code> ディレクトリには、4 つのパーティションごとにテーブルスペースの <code class="filename">.ibd</code> ファイルがあります。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>\! ls <em class="replaceable"><code>/path/to/datadir</code></em>/test/</code></strong>
t1.frm  t1#p#p0.ibd  t1#p#p1.ibd  t1#p#p2.ibd t1#p#p3.ibd
</pre></li><li class="listitem"><p>
            宛先インスタンスで、ソースインスタンスからインポートするパーティションを破棄します。 (パーティションをインポートする前に、受信側のパーティションテーブルから対応するパーティションを破棄する必要があります。) 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 DISCARD PARTITION p2, p3 TABLESPACE;</code></strong>
</pre><p>
            破棄された 2 つのパーティションのテーブルスペース <code class="literal">.ibd</code> ファイルが宛先インスタンスの<code class="literal">/<em class="replaceable"><code>datadir</code></em>/test</code> ディレクトリから削除され、次のファイルが残されます:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>\! ls <em class="replaceable"><code>/path/to/datadir</code></em>/test/</code></strong>
t1.frm  t1#p#p0.ibd  t1#p#p1.ibd
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              サブパーティションテーブルで <code class="literal">ALTER TABLE ... DISCARD PARTITION ... TABLESPACE</code> を実行する場合、パーティションテーブル名とサブパーティションテーブル名の両方が許可されます。 パーティション名を指定すると、そのパーティションのサブパーティションが操作に含まれます。 
            </p></div></li><li class="listitem"><p>
            ソースインスタンスで、<code class="literal">FLUSH TABLES ... FOR EXPORT</code> を実行してパーティションテーブルを静止します。 テーブルが静止している場合、テーブルでは読取り専用トランザクションのみが許可されます。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>FLUSH TABLES t1 FOR EXPORT;</code></strong>
</pre><p>
            <code class="literal">FLUSH TABLES ... FOR EXPORT</code> では、インスタンスの実行中にバイナリテーブルのコピーを作成できるように、指定されたテーブルへの変更がディスクにフラッシュされます。 <code class="literal">FLUSH TABLES ... FOR EXPORT</code> を実行すると、<code class="literal">InnoDB</code> によって、テーブルのスキーマディレクトリ内のテーブルスペースファイルごとに <code class="filename">.cfg</code> メタデータファイルが生成されます。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>\! ls <em class="replaceable"><code>/path/to/datadir</code></em>/test/</code></strong>
t1#p#p0.ibd  t1#p#p1.ibd  t1#p#p2.ibd t1#p#p3.ibd
t1.frm  t1#p#p0.cfg  t1#p#p1.cfg  t1#p#p2.cfg t1#p#p3.cfg
</pre><p>
            <code class="filename">.cfg</code> ファイルには、インポート操作中のスキーマ検証に使用されるメタデータが含まれています。 <code class="literal">FLUSH TABLES ... FOR EXPORT</code> は、個々のテーブルパーティションではなく、テーブルでのみ実行できます。 
          </p></li><li class="listitem"><p>
            パーティション <code class="literal">p2</code> およびパーティション <code class="literal">p3</code> の <code class="filename">.ibd</code> および <code class="filename">.cfg</code> ファイルを、ソースインスタンスのスキーマディレクトリから宛先インスタンスのスキーマディレクトリにコピーします。
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>scp t1#p#p2.ibd t1#p#p2.cfg t1#p#p3.ibd t1#p#p3.cfg destination-server:<em class="replaceable"><code>/path/to/datadir</code></em>/test</code></strong>
</pre><p>
            次のステップで説明するように、共有ロックを解放する前に <code class="filename">.ibd</code> および <code class="filename">.cfg</code> ファイルをコピーする必要があります。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              暗号化されたテーブルスペースからパーティションをインポートする場合、<code class="literal">InnoDB</code> は <code class="filename">.cfg</code> メタデータファイルに加えて <code class="filename">.cfp</code> ファイルを生成します。 <code class="filename">.cfp</code> ファイルは、<code class="filename">.cfg</code> ファイルとともに宛先インスタンスにコピーする必要があります。 <code class="filename">.cfp</code> ファイルには、転送キーと暗号化されたテーブルスペースキーが含まれます。 インポート時に、<code class="literal">InnoDB</code> は転送キーを使用してテーブルスペースキーを復号化します。 関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-data-encryption" title="15.13 InnoDB 保存データ暗号化">セクション15.13「InnoDB 保存データ暗号化」</a>を参照してください。 
            </p></div></li><li class="listitem"><p>
            ソースインスタンスで、<code class="literal">UNLOCK TABLES</code> を使用して、<code class="literal">FLUSH TABLES ... FOR EXPORT</code> によって取得されたロックを解放します:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>UNLOCK TABLES;</code></strong>
</pre></li><li class="listitem"><p>
            宛先インスタンスで、テーブルパーティション <code class="literal">p2</code> および <code class="literal">p3</code> をインポートします:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 IMPORT PARTITION p2, p3 TABLESPACE;</code></strong>
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              サブパーティションテーブルで <code class="literal">ALTER TABLE ... IMPORT PARTITION ... TABLESPACE</code> を実行する場合、パーティションテーブル名とサブパーティションテーブル名の両方が許可されます。 パーティション名を指定すると、そのパーティションのサブパーティションが操作に含まれます。 
            </p></div></li></ol></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-table-import-limitations"></a>制限</h5></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="emphasis"><em>トランスポータブルテーブルスペース</em></span>機能は、file-per-table テーブルスペースに存在するテーブルでのみサポートされます。 システムテーブルスペースまたは一般テーブルスペースに存在するテーブルではサポートされていません。 共有テーブルスペースのテーブルは静止できません。 
          </p></li><li class="listitem"><p>
            全文検索補助テーブルはフラッシュできないため、<code class="literal">FLUSH TABLES ... FOR EXPORT</code> は <code class="literal">FULLTEXT</code> インデックスのあるテーブルではサポートされていません。 <code class="literal">FULLTEXT</code> インデックスを含むテーブルをインポートした後、<code class="literal">OPTIMIZE TABLE</code> を実行して <code class="literal">FULLTEXT</code> インデックスを再構築します。 または、エクスポート操作の前に <code class="literal">FULLTEXT</code> インデックスを削除し、宛先インスタンスにテーブルをインポートした後にインデックスを再作成します。 
          </p></li><li class="listitem"><p>
            <code class="literal">.cfg</code> メタデータファイルの制限により、パーティションテーブルのインポート時にパーティションタイプまたはパーティション定義の違いについてスキーマの不一致は報告されません。 カラムの差異がレポートされます。 
          </p></li><li class="listitem"><p>
            MySQL 8.0.19 より前では、インデックスキー部分のソート順序情報は、テーブルスペースのインポート操作中に使用される <code class="literal">.cfg</code> メタデータファイルに格納されません。 したがって、インデックスキー部分のソート順序は昇順 (デフォルト) とみなされます。 その結果、インポート操作に関係するテーブルが DESC インデックスキー部分のソート順序で定義されていて、他のテーブルが意図しない順序でレコードがソートされることがあります。 回避策は、影響を受けるインデックスを削除して再作成することです。 インデックスキー部分のソート順序の詳細は、<a class="xref" href="sql-statements.html#create-index" title="13.1.15 CREATE INDEX ステートメント">セクション13.1.15「CREATE INDEX ステートメント」</a> を参照してください。 
          </p><p>
            MySQL 8.0.19 で <code class="literal">.cfg</code> ファイル形式が更新され、インデックスキー部分のソート順情報が含まれるようになりました。 前述の問題は、MySQL 8.0.19 サーバーインスタンス間のインポート操作には影響しません。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-table-import-usage-notes"></a>使用上の注意</h5></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">ALTER TABLE ... IMPORT TABLESPACE</code> では、テーブルをインポートするために <code class="filename">.cfg</code> メタデータファイルは必要ありません。 ただし、<code class="filename">.cfg</code> ファイルなしでインポートする場合、メタデータチェックは実行されず、次のような警告が発行されます: 
          </p><pre class="programlisting">Message: InnoDB: IO Read error: (2, No such file or directory) Error opening '.\
test\t.cfg', will attempt to import without schema verification
1 row in set (0.00 sec)
</pre><p>
            <code class="filename">.cfg</code> メタデータファイルを使用しないテーブルのインポートは、スキーマの不一致が予想されない場合にのみ考慮する必要があります。 <code class="filename">.cfg</code> ファイルなしでインポートする機能は、メタデータにアクセスできないクラッシュリカバリシナリオで役立ちます。 
          </p></li><li class="listitem"><p>
            Windows では、<code class="literal">InnoDB</code> はデータベース、テーブルスペース、およびテーブル名を内部的に小文字で格納します。 Linux や Unix などの大/小文字が区別されるオペレーティングシステムでのインポートの問題を回避するには、小文字の名前を使用してすべてのデータベース、テーブルスペースおよびテーブルを作成します。 名前が小文字で作成されるようにする便利な方法は、サーバーを初期化する前に <code class="literal">lower_case_table_names</code> を 1 に設定することです。 (サーバーの初期化時に使用された設定とは異なる <code class="literal">lower_case_table_names</code> 設定でサーバーを起動することは禁止されています。) 
          </p><pre class="programlisting">[mysqld]
lower_case_table_names=1
</pre></li><li class="listitem"><p>
            サブパーティションテーブルで <code class="literal">ALTER TABLE ... DISCARD PARTITION ... TABLESPACE</code> および <code class="literal">ALTER TABLE ... IMPORT PARTITION ... TABLESPACE</code> を実行する場合、パーティションテーブル名とサブパーティションテーブル名の両方が許可されます。 パーティション名を指定すると、そのパーティションのサブパーティションが操作に含まれます。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-table-import-internals"></a>内部情報</h5></div></div></div><p>
        次の情報では、テーブルのインポート手順中にエラーログに書き込まれる内部およびメッセージについて説明します。
      </p><p>
        <code class="literal">ALTER TABLE ... DISCARD TABLESPACE</code> が目的のインスタンスで実行された場合。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブルは X モードでロックされています。
          </p></li><li class="listitem"><p>
            テーブルスペースがテーブルから切り離されています。
          </p></li></ul></div><p>
        <code class="literal">FLUSH TABLES ... FOR EXPORT</code> がソースインスタンスで実行された場合。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            エクスポートのためにフラッシュされたテーブルが共有モードでロックされています。
          </p></li><li class="listitem"><p>
            パージコーディネータのスレッドが停止しています。
          </p></li><li class="listitem"><p>
            ダーティーページがディスクに同期しています。
          </p></li><li class="listitem"><p>
            テーブルのメタデータがバイナリの <code class="filename">.cfg</code> ファイルに書き込まれました。
          </p></li></ul></div><p>
        この操作で予想されるエラーログメッセージです。
      </p><pre class="programlisting">[Note] InnoDB: Sync to disk of '"test"."t1"' started.
[Note] InnoDB: Stopping purge
[Note] InnoDB: Writing table metadata to './test/t1.cfg'
[Note] InnoDB: Table '"test"."t1"' flushed to disk
</pre><p>
        <code class="literal">UNLOCK TABLES</code> がソースインスタンスで実行された場合。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            バイナリ <code class="literal">.cfg</code> ファイルが削除されます。
          </p></li><li class="listitem"><p>
            インポートされたテーブル (または複数のテーブル) の共有ロックが解放され、パージコーディネータのスレッドが再起動されました。
          </p></li></ul></div><p>
        この操作で予想されるエラーログメッセージです。
      </p><pre class="programlisting">[Note] InnoDB: Deleting the meta-data file './test/t1.cfg'
[Note] InnoDB: Resuming purge
</pre><p>
        <code class="literal">ALTER TABLE ... IMPORT TABLESPACE</code> が目的のインスタンスで実行されると、インポートのアルゴリズムはインポートされたテーブルスペースごとに次の操作を実行します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブルスペースの各ページに破損があるかどうかをチェックします。
          </p></li><li class="listitem"><p>
            各ページのスペース ID とログシーケンス番号 (LSN) が更新されます。
          </p></li><li class="listitem"><p>
            フラグが検証され、ヘッダーページの LSN が更新されます。
          </p></li><li class="listitem"><p>
            B ツリーページが更新されます。
          </p></li><li class="listitem"><p>
            ページの状態は、ディスクに書き込まれるようにダーティに設定されます。
          </p></li></ul></div><p>
        この操作で予想されるエラーログメッセージです。
      </p><pre class="programlisting">[Note] InnoDB: Importing tablespace for table 'test/t1' that was exported
from host '<em class="replaceable"><code>host_name</code></em>'
[Note] InnoDB: Phase I - Update all pages
[Note] InnoDB: Sync to disk
[Note] InnoDB: Sync to disk - done!
[Note] InnoDB: Phase III - Flush changes to disk
[Note] InnoDB: Phase IV - Flush complete</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          テーブルスペースが破棄されたこと (目的のテーブルのテーブルスペースを破棄した場合) を伝える警告、および <code class="filename">.ibd</code> ファイルがないために統計値が計算できなかったことを伝えるメッセージも受け取る場合があります。
        </p><pre class="programlisting">[Warning] InnoDB: Table "test"."t1" tablespace is set as discarded.
7f34d9a37700 InnoDB: cannot calculate statistics for table
"test"."t1" because the .ibd file is missing. For help, please refer to
http://dev.mysql.com/doc/refman/8.0/en/innodb-troubleshooting.html
</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-migration"></a>15.6.1.4 InnoDB テーブルの移動またはコピー</h4></div></div></div><a class="indexterm" name="idm44761364559072"></a><p>
    このセクションでは、一部またはすべての <code class="literal">InnoDB</code> テーブルを別のサーバーまたはインスタンスに移動またはコピーする方法について説明します。 たとえば、MySQL インスタンス全体をより大きい高速なサーバーに移動したり、MySQL インスタンス全体を新しいレプリカサーバーにクローニングしたり、個々のテーブルを別のインスタンスにコピーしてアプリケーションを開発およびテストしたり、データウェアハウスサーバーにコピーしてレポートを生成したりできます。 
  </p><p>
    Windows 上の <code class="literal">InnoDB</code> では常に、データベース名およびテーブル名が内部的に小文字で格納されます。 バイナリ形式のデータベースを Unix から Windows に、または Windows から Unix に移動するには、すべてのデータベースおよびテーブルを小文字の名前を使用して作成します。 これを実現する便利な方法は、データベースやテーブルを作成する前に、<code class="filename">my.cnf</code> または <code class="filename">my.ini</code> ファイルの <code class="literal">[mysqld]</code> セクションに次の行を追加することです。 
  </p><pre class="programlisting">[mysqld]
lower_case_table_names=1
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
      サーバーの初期化時に使用された設定とは異なる <code class="literal">lower_case_table_names</code> 設定でサーバーを起動することは禁止されています。
    </p></div><p>
    <code class="literal">InnoDB</code> テーブルを移動またはコピーするための方法は、次のとおりです。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#copy-tables-import" title="テーブルのインポート">テーブルのインポート</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#copy-tables-meb" title="MySQL Enterprise Backup">MySQL Enterprise Backup</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#copy-tables-cold-backup" title="データファイルのコピー (コールドバックアップ方式)">データファイルのコピー (コールドバックアップ方式)</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#copy-tables-logical-backup" title="論理バックアップからのリストア">論理バックアップからのリストア</a></p></li></ul></div><h5><a name="copy-tables-import"></a>テーブルのインポート</h5><p>
    file-per-table テーブルスペースに存在するテーブルは、別の MySQL サーバーインスタンスから、または<span class="emphasis"><em>トランスポータブルテーブルスペース</em></span>機能を使用してバックアップからインポートできます。 <a class="xref" href="innodb-storage-engine.html#innodb-table-import" title="15.6.1.3 InnoDB テーブルのインポート">セクション15.6.1.3「InnoDB テーブルのインポート」</a>を参照してください。 
  </p><h5><a name="copy-tables-meb"></a>MySQL Enterprise Backup</h5><p>
    MySQL Enterprise Backup 製品を使用すると、操作の中断を最小限に抑えながら、実行中の MySQL データベースをバックアップし、データベースの一貫したスナップショットを生成できます。 MySQL Enterprise Backup がテーブルをコピーしている場合、読取りおよび書込みを続行できます。 また、MySQL Enterprise Backup では、圧縮バックアップファイルを作成し、テーブルのサブセットをバックアップできます。 MySQL のバイナリログと組み合わせると、ポイントインタイムリカバリを実行できます。 MySQL Enterprise Backup は、MySQL Enterprise サブスクリプションの一部として含まれています。 
  </p><p>
    MySQL Enterprise Backup についての詳細は、<a class="xref" href="mysql-enterprise.html#mysql-enterprise-backup" title="30.2 MySQL Enterprise Backup の概要">セクション30.2「MySQL Enterprise Backup の概要」</a>を参照してください。
  </p><h5><a name="copy-tables-cold-backup"></a>データファイルのコピー (コールドバックアップ方式)</h5><p>
    単に、<a class="xref" href="innodb-storage-engine.html#innodb-backup" title="15.18.1 InnoDB バックアップ">セクション15.18.1「InnoDB バックアップ」</a>の「コールドバックアップ」で一覧表示した関連ファイルをすべてコピーするだけで、<code class="literal">InnoDB</code> データベースを移動できます。
  </p><p>
    <code class="literal">InnoDB</code> のデータファイルとログファイルは、同じ浮動小数点数形式を持つすべてのプラットフォームでバイナリ互換です。 浮動小数点形式が異なっている場合でも、テーブル内で <code class="literal">FLOAT</code> または <code class="literal">DOUBLE</code> データ型を使用していなければ、手順は同じです。単に、関連するファイルをコピーするだけです。 
  </p><p>
    file-per-table <code class="filename">.ibd</code> ファイルを移動またはコピーする場合、データベースディレクトリ名はソースシステムと宛先システムで同じである必要があります。 データベース名は、<code class="literal">InnoDB</code> の共有テーブルスペース内に格納されているテーブル定義に含まれています。 テーブルスペースファイル内に格納されているトランザクション ID およびログシーケンス番号も、データベース間で異なります。 
  </p><p>
    あるデータベースから別のデータベースに <code class="filename">.ibd</code> ファイルとそれに関連付けられたテーブルを移動するには、<code class="literal">RENAME TABLE</code> ステートメントを使用します。
  </p><pre class="programlisting">RENAME TABLE <em class="replaceable"><code>db1.tbl_name</code></em> TO <em class="replaceable"><code>db2.tbl_name</code></em>;
</pre><a class="indexterm" name="idm44761364520912"></a><a class="indexterm" name="idm44761364519568"></a><p>
    <code class="filename">.ibd</code> ファイルの<span class="quote">「<span class="quote">クリーンな</span>」</span>バックアップがある場合は、次のように、そのバックアップが生成された MySQL インストールにリストアできます。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        <code class="filename">.ibd</code> ファイルをコピーすると、テーブルスペース内に格納されたテーブル ID が変更されるため、それ以降はテーブルの削除または切り捨ては実行されなかったはずです。
      </p></li><li class="listitem"><p>
        次の <code class="literal">ALTER TABLE</code> ステートメントを発行して、現在の <code class="filename">.ibd</code> ファイルを削除します。
      </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DISCARD TABLESPACE;
</pre></li><li class="listitem"><p>
        バックアップ <code class="filename">.ibd</code> ファイルを適切なデータベースディレクトリにコピーします。
      </p></li><li class="listitem"><p>
        次の <code class="literal">ALTER TABLE</code> ステートメントを発行して、このテーブルで新しい <code class="filename">.ibd</code> ファイルを使用するように <code class="literal">InnoDB</code> に指示します。
      </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> IMPORT TABLESPACE;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">ALTER TABLE ... IMPORT TABLESPACE</code> 機能は、インポートされたデータに対して外部キー制約を課しません。
        </p></div></li></ol></div><p>
    このコンテキストでは、<span class="quote">「<span class="quote">クリーンな</span>」</span> <code class="filename">.ibd</code> バックアップファイルとは、次の要件を満たすファイルです。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="filename">.ibd</code> ファイル内には、トランザクションによってコミットされていない変更はありません。
      </p></li><li class="listitem"><p>
        <code class="filename">.ibd</code> ファイル内にマージされていない挿入バッファーエントリはありません。
      </p></li><li class="listitem"><p>
        パージによって、<code class="filename">.ibd</code> ファイルから削除マークが付けられたすべてのインデックスレコードが削除されました。
      </p></li><li class="listitem"><p>
        <span class="command"><strong>mysqld</strong></span> によって、<code class="filename">.ibd</code> ファイルの変更されたページがすべてバッファープールからファイルにフラッシュされました。
      </p></li></ul></div><p>
    次の方法を使用すると、クリーンなバックアップ <code class="filename">.ibd</code> ファイルを作成できます。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        <span class="command"><strong>mysqld</strong></span> サーバーからのすべてのアクティビティーを停止し、すべてのトランザクションをコミットします。
      </p></li><li class="listitem"><p>
        <code class="literal">SHOW ENGINE INNODB STATUS</code> でデータベース内にアクティブなトランザクションがないことが表示され、<code class="literal">InnoDB</code> のメインスレッドステータスが<code class="literal">「Waiting for server activity」</code>になるまで待機します。 これにより、<code class="filename">.ibd</code> ファイルのコピーを作成できるようになります。 
      </p></li></ol></div><p>
    <code class="filename">.ibd</code> ファイルのクリーンなコピーを作成するためのもう 1 つの方法は、MySQL Enterprise Backup 製品を使用することです。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        MySQL Enterprise Backup を使用して、<code class="literal">InnoDB</code> インストールをバックアップします。
      </p></li><li class="listitem"><p>
        2 番目の <span class="command"><strong>mysqld</strong></span> サーバーをバックアップ上で起動します。そのサーバーで、バックアップ内の <code class="filename">.ibd</code> ファイルがクリーンアップされます。
      </p></li></ol></div><h5><a name="copy-tables-logical-backup"></a>論理バックアップからのリストア</h5><p>
    <span class="command"><strong>mysqldump</strong></span> などのユーティリティを使用して論理バックアップを実行できます。これにより、別の SQL サーバーに転送するために元のデータベースオブジェクト定義およびテーブルデータを再現するために実行できる一連の SQL ステートメントが生成されます。 この方式を使用すれば、形式が異なっているかどうかや、テーブルに浮動小数点データが含まれているかどうかは関係ありません。 
  </p><p>
    この方法のパフォーマンスを向上させるには、データのインポート時に <code class="literal">autocommit</code> を無効にします。 コミットは、テーブル全体またはテーブルのセグメントをインポートした後にのみ実行します。 
  </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="converting-tables-to-innodb"></a>15.6.1.5 MyISAM から InnoDB へのテーブルの変換</h4></div></div></div><a class="indexterm" name="idm44761364469456"></a><a class="indexterm" name="idm44761364466544"></a><p>
    信頼性とスケーラビリティを向上させるために <code class="literal">InnoDB</code> に変換する <code class="literal">MyISAM</code> テーブルがある場合は、変換する前に次のガイドラインとヒントを確認してください。
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
      以前のバージョンの MySQL で作成されたパーティション化された <code class="literal">MyISAM</code> テーブルは、MySQL 8.0 と互換性がありません。 このようなテーブルは、パーティション化を削除するか、<code class="literal">InnoDB</code> に変換して、アップグレード前に準備する必要があります。 詳細は、<a class="xref" href="partitioning.html#partitioning-limitations-storage-engines" title="24.6.2 ストレージエンジンに関連するパーティショニング制限">セクション24.6.2「ストレージエンジンに関連するパーティショニング制限」</a>を参照してください。 
    </p></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-convert-memory-usage" title="MyISAM および InnoDB のメモリー使用量の調整">MyISAM および InnoDB のメモリー使用量の調整</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-convert-transactions" title="Too-Long または Too-Short トランザクションの処理">Too-Long または Too-Short トランザクションの処理</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-convert-deadlock" title="デッドロックの処理">デッドロックの処理</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-convert-plan-storage" title="記憶域レイアウトの計画">記憶域レイアウトの計画</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-convert-convert" title="既存テーブルの変換">既存テーブルの変換</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-convert-clone" title="テーブル構造のクローニング">テーブル構造のクローニング</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-convert-transfer" title="既存データの転送">既存データの転送</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-convert-storage-requirements" title="ストレージ要件">ストレージ要件</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-convert-primary-key" title="各テーブルに対する PRIMARY KEY の定義">各テーブルに対する PRIMARY KEY の定義</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-convert-application-performance" title="アプリケーションのパフォーマンスに関する考慮事項">アプリケーションのパフォーマンスに関する考慮事項</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-convert-understand-files" title="InnoDB テーブルに関連付けられたファイルの理解">InnoDB テーブルに関連付けられたファイルの理解</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-convert-memory-usage"></a>MyISAM および InnoDB のメモリー使用量の調整</h5></div></div></div><a class="indexterm" name="idm44761364444832"></a><p>
      <code class="literal">MyISAM</code> テーブルから移行するときに、結果をキャッシュする際に必要でなくなったメモリーが解放されるように、<code class="literal">key_buffer_size</code> 構成オプションの値を小さくします。 <code class="literal">InnoDB</code> テーブル用のキャッシュメモリー割り当てと同様の役割を担う <code class="literal">innodb_buffer_pool_size</code> 構成オプションの値を大きくします。 <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> では、テーブルデータとインデックスデータの両方がキャッシュされるため、クエリーのルックアップが高速化され、再利用のためにクエリー結果がメモリーに保持されます。 バッファープールサイズの構成に関するガイダンスについては、<a class="xref" href="optimization.html#memory-use" title="8.12.3.1 MySQL のメモリーの使用方法">セクション8.12.3.1「MySQL のメモリーの使用方法」</a> を参照してください。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-convert-transactions"></a>Too-Long または Too-Short トランザクションの処理</h5></div></div></div><a class="indexterm" name="idm44761364434352"></a><p>
      <code class="literal">MyISAM</code> テーブルでは<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>がサポートされていないため、<code class="literal">autocommit</code> 構成オプションと、<code class="literal">COMMIT</code> および <code class="literal">ROLLBACK</code> ステートメントに多くの注意が払われていない可能性があります。 これらのキーワードは、複数のセッションが並列して <code class="literal">InnoDB</code> テーブルの読み取りおよび書き込みを行うことを許可する際に重要となります。これにより、書き込み負荷の高いワークロードで十分な拡張性の利点が得られます。 
    </p><p>
      トランザクションが開いている間は、トランザクションの開始時に見られるようなデータのスナップショットがシステムで保持されます。これにより、未処理のトランザクションが動作し続けている間に、システムで数百万行の挿入、更新、および削除が行われると、相当なオーバーヘッドが発生する可能性があります。 そのため、動作時間が長すぎるトランザクションは回避するように注意してください。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          インタラクティブな実験で <span class="command"><strong>mysql</strong></span> セッションを使用している場合は、完了後に必ず、(変更を完了させる場合は) <code class="literal">COMMIT</code>、または (変更を取り消す場合は) <code class="literal">ROLLBACK</code> を実行します。 トランザクションを誤って長期間オープンしたままにしないように、対話型セッションを長期間オープンしたままにしておくのではなく、クローズします。 
        </p></li><li class="listitem"><p>
          アプリケーション内の任意のエラーハンドラでも、不完全な変更の <code class="literal">ROLLBACK</code> が実行されるか、完了した変更の <code class="literal">COMMIT</code> が実行されることを確認します。
        </p></li><li class="listitem"><p>
          <code class="literal">INSERT</code>、<code class="literal">UPDATE</code> および <code class="literal">DELETE</code> の各操作は <code class="literal">COMMIT</code> より前に <code class="literal">InnoDB</code> テーブルに書き込まれるため、<code class="literal">ROLLBACK</code> は比較的コストの高い操作ですが、ほとんどの変更は正常にコミットされ、ロールバックはまれです。 大量のデータを使用して実験する際は、多数の行に変更を加えてから、それらの変更をロールバックすることは回避してください。 
        </p></li><li class="listitem"><p>
          一連の <code class="literal">INSERT</code> ステートメントを使用して大量のデータをロードする際は、トランザクションが数時間存続することを回避するために、定期的に結果の <code class="literal">COMMIT</code> を実行します。 データウェアハウスの一般的なロード操作では、なんらかの問題が発生した場合、<code class="literal">ROLLBACK</code> を実行するのではなく、(<code class="literal">TRUNCATE TABLE</code> を使用して) テーブルを切り捨てて最初からやり直します。 
        </p></li></ul></div><p>
      前述のヒントを使用すると、長すぎるトランザクション中に無駄になる可能性のあるメモリーおよびディスク容量を節約できます。 トランザクションが本来よりも短い場合は、過剰な I/O が問題となります。 MySQL では、<code class="literal">COMMIT</code> が実行されるたびに、各変更が安全にディスクに記録されていることが確認されます。これには、多少の I/O が伴います。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">InnoDB</code> テーブル上のほとんどの操作では、<code class="literal">autocommit=0</code> の設定を使用するようにしてください。 効率性の観点から見ると、これにより、多数の連続した <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、または <code class="literal">DELETE</code> ステートメントを発行したときの不要な I/O が回避されます。 安全性の観点から見ると、これにより、<span class="command"><strong>mysql</strong></span> コマンド行またはアプリケーションの例外ハンドラに誤りがあった場合に、<code class="literal">ROLLBACK</code> ステートメントを発行することで、失ったデータや文字化けしたデータをリカバリできます。 
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> テーブルに <code class="literal">autocommit=1</code> を設定することが適している状況は、レポートの生成または統計の分析を行うために一連のクエリーを実行するときです。 このような状況では、<code class="literal">COMMIT</code> または <code class="literal">ROLLBACK</code> に関連する I/O ペナルティーが発生せず、<code class="literal">InnoDB</code> は<a class="link" href="optimization.html#innodb-performance-ro-txn" title="8.5.3 InnoDB の読み取り専用トランザクションの最適化">自動的に読み取り専用のワークロードを最適化できます</a>。 
        </p></li><li class="listitem"><p>
          一連の関連する変更を行う場合は、最後に単一の <code class="literal">COMMIT</code> を使用して、すべての変更を一度に確定します。 たとえば、情報の関連部分を複数のテーブルに挿入する場合は、すべての変更を行なったあとに、<code class="literal">COMMIT</code> を 1 回実行します。 また、連続する多数の <code class="literal">INSERT</code> ステートメントを実行する場合は、すべてのデータがロードされたあとに、<code class="literal">COMMIT</code> を 1 回実行します。何百万もの <code class="literal">INSERT</code> ステートメントを実行する場合は、一万または一千レコードごとに <code class="literal">COMMIT</code> を発行することで、巨大なトランザクションを分割することがあります。 
        </p></li><li class="listitem"><p>
          <code class="literal">SELECT</code> ステートメントでもトランザクションが開かれるため、インタラクティブな <span class="command"><strong>mysql</strong></span> セッションで一部のレポートを実行したり、クエリーをデバッグしたりしたあとは、<code class="literal">COMMIT</code> を発行するか、または <span class="command"><strong>mysql</strong></span> セッションを閉じます。
        </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-convert-deadlock"></a>デッドロックの処理</h5></div></div></div><a class="indexterm" name="idm44761364370864"></a><p>
      MySQL のエラーログまたは <code class="literal">SHOW ENGINE INNODB STATUS</code> の出力に、<span class="quote">「<span class="quote">デッドロック</span>」</span>に言及する警告メッセージが表示されることがあります。 <a class="link" href="glossary.html#glos_deadlock" title="デッドロック">デッドロック</a>は、恐ろしい響きの名前にもかかわらず、<code class="literal">InnoDB</code> テーブルにとっては重大な問題でなく、修正アクションは何も必要ありません。 2 つのトランザクションが複数のテーブルを変更し、そのテーブルに別々の順序でアクセスし始めると、各トランザクションが相互に待機し合って、どちらも処理できない状態に達する可能性があります。 <a class="link" href="glossary.html#glos_deadlock_detection" title="デッドロック検出">deadlock detection</a> が有効になっている場合 (デフォルト)、MySQL はこの条件をただちに検出し、<span class="quote">「<span class="quote">「小さい」</span>」</span>トランザクションを取り消して他のトランザクションを続行できるようにします (<a class="link" href="glossary.html#glos_rollback" title="ロールバック">rolls back</a>)。 <code class="literal">innodb_deadlock_detect</code> 構成オプションを使用してデッドロック検出が無効になっている場合、<code class="literal">InnoDB</code> は、デッドロックの場合にトランザクションをロールバックするために <code class="literal">innodb_lock_wait_timeout</code> 設定に依存します。 
    </p><p>
      どちらの方法でも、デッドロックのために強制的に取り消されたトランザクションを再起動するには、アプリケーションにエラー処理ロジックが必要です。 以前と同じ SQL ステートメントを再発行すると、元のタイミングの問題は適用されなくなります。 他のトランザクションがすでに終了して続行できるか、他のトランザクションがまだ進行中で、トランザクションは終了するまで待機します。 
    </p><p>
      デッドロックの警告が常に発生する場合は、アプリケーションコードを再確認して、一貫性のある方法で SQL 操作を再指示したり、トランザクションを短くしたりすることがあります。 <code class="literal">innodb_print_all_deadlocks</code> オプションを有効にしてテストすれば、<code class="literal">SHOW ENGINE INNODB STATUS</code> 出力の最後の警告だけでなく、MySQL のエラーログにもすべてのデッドロックの警告を表示できます。 
    </p><p>
      詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-deadlocks" title="15.7.5 InnoDB のデッドロック">セクション15.7.5「InnoDB のデッドロック」</a>を参照してください。
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-convert-plan-storage"></a>記憶域レイアウトの計画</h5></div></div></div><a class="indexterm" name="idm44761364351936"></a><p>
      <code class="literal">InnoDB</code> テーブルから最高のパフォーマンスを引き出すために、ストレージレイアウトに関連する数多くのパラメータを調整できます。
    </p><p>
      大規模で頻繁にアクセスされる <code class="literal">MyISAM</code> テーブルを変換し、重要なデータを保持する場合は、<code class="literal">CREATE TABLE</code> ステートメントの <code class="literal">innodb_file_per_table</code> および <code class="literal">innodb_page_size</code> の構成オプションと <a class="link" href="innodb-storage-engine.html#innodb-row-format" title="15.10 InnoDB の行フォーマット"><code class="literal">ROW_FORMAT</code> and <code class="literal">KEY_BLOCK_SIZE</code> clauses</a> を調査して検討します。
    </p><p>
      初期の実験時に、もっとも重要となる設定は <code class="literal">innodb_file_per_table</code> です。 この設定を有効にすると (デフォルト)、新しい <code class="literal">InnoDB</code> テーブルが <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースに暗黙的に作成されます。 <code class="literal">InnoDB</code> システムテーブルスペースとは対照的に、file-per-table テーブルスペースを使用すると、テーブルの切捨てまたは削除時にオペレーティングシステムでディスク領域を再利用できます。 File-per-table テーブルスペースでは、テーブル圧縮、長い可変長カラムの効率的なオフページストレージ、大規模なインデックス接頭辞など、<a class="link" href="glossary.html#glos_dynamic_row_format" title="動的行フォーマット">DYNAMIC</a> および <a class="link" href="glossary.html#glos_compressed_row_format" title="圧縮行フォーマット">COMPRESSED</a> の行形式および関連する機能もサポートされます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-file-per-table-tablespaces" title="15.6.3.2 File-Per-Table テーブルスペース">セクション15.6.3.2「File-Per-Table テーブルスペース」</a>を参照してください。 
    </p><p>
      複数のテーブルおよびすべての行形式をサポートする共有一般テーブルスペースに <code class="literal">InnoDB</code> テーブルを格納することもできます。 詳細は、<a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="15.6.3.3 一般テーブルスペース">セクション15.6.3.3「一般テーブルスペース」</a>を参照してください。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-convert-convert"></a>既存テーブルの変換</h5></div></div></div><p>
      <code class="literal">InnoDB</code> を使用するように <code class="literal">InnoDB</code> 以外のテーブルを変換するには、<code class="literal">ALTER TABLE</code> を使用します。
    </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>table_name</code></em> ENGINE=InnoDB;
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-convert-clone"></a>テーブル構造のクローニング</h5></div></div></div><p>
      切り替える前に、<code class="literal">ALTER TABLE</code> を使用して変換を実行するのではなく、MyISAM テーブルのクローンである <code class="literal">InnoDB</code> テーブルを作成して、古いテーブルと新しいテーブルを並べてテストできます。
    </p><p>
      同じカラムとインデックスの定義を持つ空の <code class="literal">InnoDB</code> テーブルを作成します。 <code class="literal">SHOW CREATE TABLE <em class="replaceable"><code>table_name</code></em>\G</code> を使用して、使用する完全な <code class="literal">CREATE TABLE</code> ステートメントを確認します。 <code class="literal">ENGINE</code> 句を <code class="literal">ENGINE=INNODB</code> に変更します。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-convert-transfer"></a>既存データの転送</h5></div></div></div><a class="indexterm" name="idm44761364317024"></a><p>
      前のセクションで示したように、作成された空の <code class="literal">InnoDB</code> テーブルに大量のデータを転送するには、<code class="literal">INSERT INTO <em class="replaceable"><code>innodb_table</code></em> SELECT * FROM <em class="replaceable"><code>myisam_table</code></em> ORDER BY <em class="replaceable"><code>primary_key_columns</code></em></code> を使用して行を挿入します。
    </p><p>
      データを挿入したあとに、<code class="literal">InnoDB</code> テーブル用のインデックスを作成することもできます。 従来、新しいセカンダリインデックスを作成することは、InnoDB にとって低速な操作でしたが、現在は、インデックスの作成ステップで比較的小さいオーバーヘッドでデータがロードされたあとに、インデックスを作成できるようになりました。 
    </p><p>
      副キー上に <code class="literal">UNIQUE</code> 制約がある場合は、インポート操作中に一意性チェックを一時的にオフにすることで、テーブルインポートの速度を上げることができます。
    </p><pre class="programlisting">SET unique_checks=0;
<em class="replaceable"><code>... import operation ...</code></em>
SET unique_checks=1;
</pre><p>
      大きなテーブルの場合、<code class="literal">InnoDB</code> は <a class="link" href="glossary.html#glos_change_buffer" title="変更バッファー">change buffer</a> を使用してセカンダリインデックスレコードをバッチとして書き込むことができるため、これによりディスク I/O が節約されます。 データに重複キーが含まれないようにします。<code class="literal">unique_checks</code> では、ストレージエンジンが重複キーを無視することが許可されていますが、必須ではありません。 
    </p><p>
      挿入プロセスをより適切に制御するために、大きなテーブルをピース単位で挿入できます:
    </p><pre class="programlisting">INSERT INTO newtable SELECT * FROM oldtable
   WHERE yourkey &gt; <em class="replaceable"><code>something</code></em> AND yourkey &lt;= <em class="replaceable"><code>somethingelse</code></em>;
</pre><p>
      すべてのレコードを挿入した後、テーブルの名前を変更できます。
    </p><p>
      ディスク I/O を削減するには、大きなテーブルの変換時に、最大で物理メモリーの 80% まで <code class="literal">InnoDB</code> バッファープールのサイズを大きくします。 <code class="literal">InnoDB</code> ログファイルのサイズを増やすこともできます。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-convert-storage-requirements"></a>ストレージ要件</h5></div></div></div><a class="indexterm" name="idm44761364296592"></a><p>
      変換プロセス中に <code class="literal">InnoDB</code> テーブルのデータの一時コピーを複数作成する場合は、テーブルの削除時にディスク領域を再利用できるように、file-per-table テーブルスペースにテーブルを作成することをお薦めします。 <code class="literal">innodb_file_per_table</code> 構成オプションが有効な場合 (デフォルト)、新しく作成された <code class="literal">InnoDB</code> テーブルは file-per-table テーブルスペースに暗黙的に作成されます。 
    </p><p>
      <code class="literal">MyISAM</code> テーブルを直接変換するのか、クローンの <code class="literal">InnoDB</code> テーブルを作成するのかには関係なく、プロセス中に古いテーブルと新しいテーブルの両方を保持するのに十分なディスク領域があることを確認します。 <span class="bold"><strong><code class="literal">InnoDB</code> テーブルには、<code class="literal">MyISAM</code> テーブルよりも多くのディスク領域が必要です。</strong></span> <code class="literal">ALTER TABLE</code> 操作によって領域が使い果たされると、ロールバックが開始されますが、ディスクバウンドの場合は、数時間かかる可能性があります。 挿入の場合、<code class="literal">InnoDB</code> はバッチ内のインデックスにセカンダリインデックスレコードをマージする際に、挿入バッファーを使用します。 これにより、大量のディスク I/O が節約されます。 ロールバックでは、このようなメカニズムは使用されません。ロールバックは挿入よりも、30 倍長い時間がかかる可能性があります。 
    </p><p>
      ランナウェイロールバックの場合は、データベースに貴重なデータがなければ、何百万ものディスク I/O 操作が完了するまで待機するのではなく、データベースプロセスを強制終了することをお勧めします。 完全な手順については、<a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="15.21.2 InnoDB のリカバリの強制的な実行">セクション15.21.2「InnoDB のリカバリの強制的な実行」</a>を参照してください。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-convert-primary-key"></a>各テーブルに対する PRIMARY KEY の定義</h5></div></div></div><a class="indexterm" name="idm44761364280688"></a><p>
      <code class="literal">PRIMARY KEY</code> 句は、MySQL クエリーのパフォーマンスや、テーブルおよびインデックス用の領域使用量に影響を与える重要な要素です。 主キーは、テーブル内の行を一意に識別します。 テーブル内のすべて行が主キー値を持っている必要があり、2 つの行が同じ主キー値を持つことはできません。 
    </p><p>
      これらは主キーのガイドラインで、その後に詳細な説明が続きます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          テーブルごとに <code class="literal">PRIMARY KEY</code> を宣言します。 一般に、単一の行を検索するときに参照される <code class="literal">WHERE</code> 句内のカラムの中で、もっとも重要なものです。 
        </p></li><li class="listitem"><p>
          あとで <code class="literal">ALTER TABLE</code> ステートメントを使用して追加するのではなく、元の <code class="literal">CREATE TABLE</code> ステートメントで <code class="literal">PRIMARY KEY</code> 句を宣言します。
        </p></li><li class="listitem"><p>
          カラムとそのデータ型は慎重に選択してください。 文字または文字列のカラムよりも、数値のカラムを優先してください。 
        </p></li><li class="listitem"><p>
          別の安定していて、一意で、非 NULL で、数値のカラムが使用できない場合は、自動インクリメントカラムを使用することを検討してください。
        </p></li><li class="listitem"><p>
          主キーカラムの値が変更されたかどうかが疑わしい場合にも、自動インクリメントは適切な選択です。 主キーカラムの値を変更することは、負荷の高い操作であり、テーブル内および各セカンダリインデックス内でデータの再編成が伴う可能性があります。 
        </p></li></ul></div><p>
      <a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>がまだ存在しないテーブルには、追加することを検討してください。 計画されたテーブルの最大サイズに基づいて、現実的な最小の数値型を使用します。 これにより、各行をわずかにコンパクトにすることができ、大きなテーブル用に相当な領域を節約できます。 主キー値は、セカンダリインデックスが入力されるたびに繰り返されるため、テーブルが任意の<a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">セカンダリインデックス</a>を持っている場合は、領域の節約も倍増します。 小さな主キーを使用すると、ディスク上のデータサイズが削減されることに加えて、より多くのデータを<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>内に収容できるため、すべての種類の操作の速度が上がり、並列性が改善されます。 
    </p><p>
      すでにテーブルの多少長いカラム (<code class="literal">VARCHAR</code> など) 上に主キーが存在する場合は、そのカラムがクエリーで参照されていなくても、新しい符号なし <code class="literal">AUTO_INCREMENT</code> カラムを追加し、主キーをそのカラムに切り替えることを検討してください。 このような設計の変更によって、セカンダリインデックス内の相当な領域を節約できます。 以前の主キーカラムを <code class="literal">UNIQUE NOT NULL</code> として指定すると、<code class="literal">PRIMARY KEY</code> 句と同じ制約を強制的に適用できます (つまり、これらのすべてのカラムにわたって重複する値や NULL 値を回避できます)。 
    </p><p>
      関連する情報を複数のテーブルに分散させる場合は、一般に各テーブルで、その主キー用に同じカラムが使用されます。 たとえば、人事部のデータベースには複数のテーブルが含まれ、各テーブルには従業員番号の主キーが含まれている場合があります。 営業部のデータベースには、顧客番号の主キーを含むテーブルや、注文番号の主キーを含むテーブルが含まれている場合があります。 主キーを使用した検索は非常に高速であるため、このようなテーブルには効率的な結合クエリーを構築できます。 
    </p><p>
      <code class="literal">PRIMARY KEY</code> 句を完全に削除すると、MySQL によって自動的に非表示の主キーが作成されます。 これは、必要以上に長くなる可能性のある 6 バイトの値であるため、領域が無駄になります。 これは非表示であるため、クエリーで参照できません。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-convert-application-performance"></a>アプリケーションのパフォーマンスに関する考慮事項</h5></div></div></div><a class="indexterm" name="idm44761364252608"></a><p>
      <code class="literal">InnoDB</code> の信頼性およびスケーラビリティ機能には、同等の <code class="literal">MyISAM</code> テーブルよりも多くのディスク記憶域が必要です。 領域の使用率を改善し、結果セットを処理する際の I/O およびメモリーの消費を削減し、インデックス検索を効率的に使用するクエリーの最適化計画を改善するために、カラムおよびインデックスの定義をわずかに変更することがあります。 
    </p><p>
      主キーに数値の ID カラムを設定する場合 (特に、<a class="link" href="glossary.html#glos_join" title="結合">結合</a>クエリーの場合) は、その値を使用して、その他の任意のテーブル内の関連する値と相互参照します。 たとえば、入力として国名を受け入れ、同じ名前を検索するクエリーを実行するのではなく、国 ID を確認するための検索を 1 回実行してから、複数のテーブルにわたって関連情報を検索するための別のクエリー (または 1 回の結合クエリー) を実行します。 顧客番号またはカタログ項目番号を数字の文字列として格納すると、数バイトを使い果たす可能性があるため、その代わりに、格納およびクエリー用に数値の ID に変換します。 4 バイトの符号なし <code class="literal">INT</code> カラムでは、40 億を超える項目 (アメリカ合衆国での billion の意味: 10 億) にインデックスを付けることができます。 さまざまな整数型の範囲については、<a class="xref" href="data-types.html#integer-types" title="11.1.2 整数型 (真数値) - INTEGER、INT、SMALLINT、TINYINT、MEDIUMINT、BIGINT">セクション11.1.2「整数型 (真数値) - INTEGER、INT、SMALLINT、TINYINT、MEDIUMINT、BIGINT」</a>を参照してください。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-convert-understand-files"></a>InnoDB テーブルに関連付けられたファイルの理解</h5></div></div></div><a class="indexterm" name="idm44761364242208"></a><p>
      <code class="literal">InnoDB</code> ファイルには、<code class="literal">MyISAM</code> ファイルよりも多くの注意と計画が必要です。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>を表す <a class="link" href="glossary.html#glos_ibdata_file" title="ibdata ファイル">ibdata ファイル</a>は削除しないでください。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> テーブルを別のサーバーに移動またはコピーする方法については、<a class="xref" href="innodb-storage-engine.html#innodb-migration" title="15.6.1.4 InnoDB テーブルの移動またはコピー">セクション15.6.1.4「InnoDB テーブルの移動またはコピー」</a> を参照してください。
        </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-auto-increment-handling"></a>15.6.1.6 InnoDB での AUTO_INCREMENT 処理</h4></div></div></div><a class="indexterm" name="idm44761364230768"></a><a class="indexterm" name="idm44761364229712"></a><p>
      <code class="literal">InnoDB</code> には、<code class="literal">AUTO_INCREMENT</code> カラムを含むテーブルに行を追加する SQL ステートメントのスケーラビリティおよびパフォーマンスを大幅に向上させる構成可能なロックメカニズムが用意されています。 <code class="literal">InnoDB</code> テーブルで <code class="literal">AUTO_INCREMENT</code> メカニズムを使用するには、<code class="literal">AUTO_INCREMENT</code> カラムをインデックスの一部として定義して、最大カラム値を取得するためにテーブルでインデックス付けされた <code class="literal">SELECT MAX(<em class="replaceable"><code>ai_col</code></em>)</code> 参照と同等の操作を実行できるようにする必要があります。 一般に、これはカラムをどこかのテーブルインデックスの 1 番目のカラムにすることで実現されます。 
    </p><p>
      このセクションでは、<code class="literal">AUTO_INCREMENT</code> ロックモードの動作、様々な <code class="literal">AUTO_INCREMENT</code> ロックモード設定の使用上の影響、および <code class="literal">InnoDB</code> による <code class="literal">AUTO_INCREMENT</code> カウンタの初期化方法について説明します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-lock-modes" title="InnoDB AUTO_INCREMENT のロックモード">InnoDB AUTO_INCREMENT のロックモード</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-lock-mode-usage-implications" title="InnoDB AUTO_INCREMENT ロックモードの使用上の意味">InnoDB AUTO_INCREMENT ロックモードの使用上の意味</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-initialization" title="InnoDB AUTO_INCREMENT カウンタの初期化">InnoDB AUTO_INCREMENT カウンタの初期化</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-notes" title="メモ">メモ</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-auto-increment-lock-modes"></a>InnoDB AUTO_INCREMENT のロックモード</h5></div></div></div><a class="indexterm" name="idm44761364212096"></a><p>
        このセクションでは、自動増分値の生成に使用される <code class="literal">AUTO_INCREMENT</code> ロックモードの動作と、各ロックモードがレプリケーションに与える影響について説明します。 自動増分ロックモードは、起動時に <code class="literal">innodb_autoinc_lock_mode</code> 構成パラメータを使用して構成されます。 
      </p><p>
        <code class="literal">innodb_autoinc_lock_mode</code> 設定の説明では、次の用語が使用されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="quote">「<span class="quote"><code class="literal">INSERT</code> のような</span>」</span>ステートメント
          </p><p>
            <code class="literal">INSERT</code>、<code class="literal">INSERT ... SELECT</code>、<code class="literal">REPLACE</code>、<code class="literal">REPLACE ... SELECT</code>、<code class="literal">LOAD DATA</code> など、テーブル内に新しい行を生成するすべてのステートメントです。 <span class="quote">「<span class="quote">simple-inserts</span>」</span>、<span class="quote">「<span class="quote">bulk-inserts</span>」</span> および <span class="quote">「<span class="quote">mixed-mode</span>」</span> の挿入が含まれます。 
          </p></li><li class="listitem"><p>
            <span class="quote">「<span class="quote">単純挿入</span>」</span>
          </p><p>
            挿入行数を事前に (ステートメントの初期処理時に) 決定できるステートメントです。 これには、ネストしたサブクエリーを持たない単一行および複数行の <code class="literal">INSERT</code> および <code class="literal">REPLACE</code> ステートメントが含まれますが、<code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> は含まれません。 
          </p></li><li class="listitem"><p>
            <span class="quote">「<span class="quote">一括挿入</span>」</span>
          </p><p>
            挿入行数 (および必要な自動インクリメント値の数) が事前にわからないステートメントです。 これには、<code class="literal">INSERT ... SELECT</code>、<code class="literal">REPLACE ... SELECT</code>、および <code class="literal">LOAD DATA</code> ステートメントが含まれますが、単純な <code class="literal">INSERT</code> は含まれません。 <code class="literal">InnoDB</code> では、各行が処理されるたびに <code class="literal">AUTO_INCREMENT</code> カラムに新しい値が割り当てられます。 
          </p></li><li class="listitem"><p>
            <span class="quote">「<span class="quote">混在モード挿入</span>」</span>
          </p><p>
            これらは、新しい行の一部 (全部ではない) の自動インクリメント値を指定する <span class="quote">「<span class="quote">単純挿入</span>」</span> ステートメントです。 次の例を示します。<code class="literal">c1</code> はテーブル <code class="literal">t1</code> の <code class="literal">AUTO_INCREMENT</code> カラムです。 
          </p><pre class="programlisting">INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');
</pre><p>
            <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> は別のタイプの <span class="quote">「<span class="quote">混在モード挿入</span>」</span> で、最悪の場合には実質 <code class="literal">INSERT</code> のあとに <code class="literal">UPDATE</code> を実行することに相当しますが、<code class="literal">AUTO_INCREMENT</code> カラムに割り当てられた値は、更新フェーズで使用される可能性も使用されない可能性もあります。
          </p></li></ul></div><p>
        <code class="literal">innodb_autoinc_lock_mode</code> 構成パラメータには、3 つの設定が可能です。 <span class="quote">「<span class="quote">「従来型」</span>」</span>、<span class="quote">「<span class="quote">「連続」</span>」</span>または<span class="quote">「<span class="quote">「インターリーブ」</span>」</span>ロックモードの設定は、それぞれ 0、1 または 2 です。 MySQL 8.0 の時点では、インターリーブロックモード (<code class="literal">innodb_autoinc_lock_mode=2</code>) がデフォルト設定です。 MySQL 8.0 より前は、連続ロックモードがデフォルト (<code class="literal">innodb_autoinc_lock_mode=1</code>) です。 
      </p><p>
        MySQL 8.0 のインターリーブロックモードのデフォルト設定は、デフォルトのレプリケーションタイプとして、ステートメントベースのレプリケーションから行ベースのレプリケーションへの変更を反映しています。 ステートメントベースレプリケーションでは、SQL ステートメントの特定のシーケンスに対して自動インクリメント値が予測可能かつ繰り返し可能な順序で割り当てられるように、連続した自動インクリメントロックモードが必要ですが、行ベースレプリケーションは SQL ステートメントの実行順序には影響しません。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="innodb-auto-increment-lock-mode-traditional"></a>
            <code class="literal">innodb_autoinc_lock_mode = 0</code> (<span class="quote">「<span class="quote">従来</span>」</span> ロックモード)
          </p><p>
            従来のロックモードでは、<code class="literal">innodb_autoinc_lock_mode</code> 構成パラメータが MySQL 5.1 で導入される前と同じ動作が提供されます。 従来のロックモードオプションは、セマンティックに違いがある可能性があるため、下位互換性、パフォーマンステストおよび混合モードの挿入に関する問題の回避のために提供されています。 
          </p><p>
            このロックモードでは、すべての <span class="quote">「<span class="quote">INSERT-like</span>」</span> ステートメントは、<code class="literal">AUTO_INCREMENT</code> カラムを含むテーブルに挿入するための特別なテーブルレベルの <code class="literal">AUTO-INC</code> ロックを取得します。 通常、このロックは (トランザクションの最後ではなく) ステートメントの最後に保持され、特定の一連の <code class="literal">INSERT</code> ステートメントに対して予測可能で繰返し可能な順序で自動増分値が割り当てられ、特定のステートメントによって割り当てられた自動増分値が連続していることを確認します。 
          </p><p>
            ステートメントベースレプリケーションの場合、これは、SQL ステートメントがレプリカサーバー上でレプリケートされるときに、ソースサーバー上と同じ値が自動インクリメントカラムに使用されることを意味します。 複数の <code class="literal">INSERT</code> ステートメントの実行結果は決定的で、レプリカはソースと同じデータを再現します。 複数の <code class="literal">INSERT</code> ステートメントによって生成された自動インクリメント値がインターリーブされた場合、2 つの同時 <code class="literal">INSERT</code> ステートメントの結果は非決定的になり、ステートメントベースのレプリケーションを使用してレプリカサーバーに確実に伝播できませんでした。 
          </p><p>
            この点が明確になるように、次のテーブルを使用する例を考えてみましょう。
          </p><pre class="programlisting">CREATE TABLE t1 (
  c1 INT(11) NOT NULL AUTO_INCREMENT,
  c2 VARCHAR(10) DEFAULT NULL,
  PRIMARY KEY (c1)
) ENGINE=InnoDB;
</pre><p>
            実行中のトランザクションが 2 つ存在しており、それぞれ <code class="literal">AUTO_INCREMENT</code> カラムを含むテーブル内に行を挿入しているものとします。 1 つのトランザクションは 1000 行を挿入する <code class="literal">INSERT ... SELECT</code> ステートメントを使用しており、もう 1 つのトランザクションは 1 行を挿入する単純な <code class="literal">INSERT</code> ステートメントを使用しています。 
          </p><pre class="programlisting">Tx1: INSERT INTO t1 (c2) SELECT 1000 rows from another table ...
Tx2: INSERT INTO t1 (c2) VALUES ('xxx');
</pre><p>
            <code class="literal">InnoDB</code> では、Tx1 の <code class="literal">INSERT</code> ステートメントで <code class="literal">SELECT</code> から取得される行数を事前に確認できず、ステートメントの進行に応じて一度に自動増分値が割り当てられます。 ステートメントの終了まで保持されるテーブルレベルロックが存在しているため、ある時点で実行可能な <code class="literal">INSERT</code> ステートメントはテーブル <code class="literal">t1</code> を参照している 1 つのステートメントだけであり、複数ステートメントによって自動インクリメント番号の生成がインターリーブされることはありません。 Tx1 <code class="literal">INSERT ... SELECT</code> ステートメントによって生成される自動インクリメント値は連続しており、Tx2 の <code class="literal">INSERT</code> ステートメントで使用される (単一の) 自動インクリメント値は、最初に実行されるステートメントに応じて、Tx1 で使用されるすべての値より小さくなるか大きくなります。 
          </p><p>
            SQL ステートメントがバイナリログからリプレイされたときに (ステートメントベースレプリケーションを使用している場合、または復旧シナリオで) 同じ順序で実行されているかぎり、結果は Tx1 および Tx2 が最初に実行されたときと同じです。 したがって、ステートメントの終了まで保持されるテーブルレベルロックが存在することで、自動インクリメントを使用する <code class="literal">INSERT</code> ステートメントをステートメントベースのレプリケーションで安全に使用できるようになります。 ただし、複数のトランザクションが同時に INSERT ステートメントを実行している場合、これらのテーブルレベルのロックによって同時実行性およびスケーラビリティが制限されます。 
          </p><p>
            前述の例でテーブルレベルロックが存在しなかった場合、Tx2 の <code class="literal">INSERT</code> で使用される自動インクリメントカラムの値は、ステートメントが実際に実行されるタイミングに応じて変更されます。 Tx1 の <code class="literal">INSERT</code> の (実行前や完了後ではなく) 実行中に、Tx2 の <code class="literal">INSERT</code> が実行された場合、その 2 つの <code class="literal">INSERT</code> ステートメントで割り当てられる具体的な自動インクリメント値は非決定的となり、実行するたびに値が異なる可能性があります。 
          </p><p>
            <a class="link" href="innodb-storage-engine.html#innodb-auto-increment-lock-mode-consecutive">consecutive</a> ロックモードでは、<code class="literal">InnoDB</code> は、行数が事前にわかっている<span class="quote">「<span class="quote">「単純挿入」</span>」</span>ステートメントに対してテーブルレベルの <code class="literal">AUTO-INC</code> ロックを使用せずに、ステートメントベースのレプリケーションの決定論的な実行および安全性を維持できます。
          </p><p>
            バイナリログを使用して SQL ステートメントを回復またはレプリケーションの一部としてリプレイしない場合、<a class="link" href="innodb-storage-engine.html#innodb-auto-increment-lock-mode-interleaved">interleaved</a> ロックモードを使用すると、ステートメントによって割り当てられた自動インクリメント番号のギャップを許可し、同時に実行するステートメントによって割り当てられた番号を保持する可能性がありますが、並列性とパフォーマンスを向上させるために、テーブルレベルの <code class="literal">AUTO-INC</code> ロックのすべての使用を排除できます。
          </p></li><li class="listitem"><p><a name="innodb-auto-increment-lock-mode-consecutive"></a>
            <code class="literal">innodb_autoinc_lock_mode = 1</code> (<span class="quote">「<span class="quote">連続</span>」</span> ロックモード)
          </p><p>
            このモードでは、<span class="quote">「<span class="quote">一括挿入</span>」</span> は特殊な <code class="literal">AUTO-INC</code> テーブルレベルロックを使用し、そのロックをステートメントの終了まで保持します。 これは、<code class="literal">INSERT ... SELECT</code>、<code class="literal">REPLACE ... SELECT</code>、<code class="literal">LOAD DATA</code> のすべてのステートメントに当てはまります。 一度に実行できるステートメントは、<code class="literal">AUTO-INC</code> ロックを保持している 1 つのステートメントだけです。 一括挿入操作のソーステーブルがターゲットテーブルと異なる場合は、ソーステーブルから選択された最初の行で共有ロックが取得された後に、ターゲットテーブルの <code class="literal">AUTO-INC</code> ロックが取得されます。 バルク挿入操作のソースとターゲットが同じテーブルの場合、選択したすべての行で共有ロックが取得された後に <code class="literal">AUTO-INC</code> ロックが取得されます。 
          </p><p>
            <span class="quote">「<span class="quote">「単純な挿入」</span>」</span> (事前に挿入される行数がわかっている) では、ステートメントが完了するまでではなく、割当てプロセスの間のみ保持される mutex (軽量ロック) の制御下で必要な数の自動増分値を取得することで、テーブルレベルの <code class="literal">AUTO-INC</code> ロックを回避します。 <code class="literal">AUTO-INC</code> ロックが別のトランザクションによって保持されていないかぎり、テーブルレベルの <code class="literal">AUTO-INC</code> ロックは使用されません。 別のトランザクションが <code class="literal">AUTO-INC</code> ロックを保持している場合、<span class="quote">「<span class="quote">「単純挿入」</span>」</span>は<span class="quote">「<span class="quote">「一括挿入」</span>」</span>であるかのように <code class="literal">AUTO-INC</code> ロックを待機します。 
          </p><p>
            このロックモードでは、行数が事前にわからない (したがってステートメントの処理中に自動インクリメント番号が割り当てられる) <code class="literal">INSERT</code> ステートメントが存在する場合には、任意の <span class="quote">「<span class="quote"><code class="literal">INSERT</code> のような</span>」</span> ステートメントによって割り当てられたすべての自動インクリメント値が必ず連続した値になるため、その処理は、ステートメントベースのレプリケーションで使用しても安全です。
          </p><p>
            このロックモードを使用すると、ステートメントベースのレプリケーションで安全に使用できるため、スケーラビリティが大幅に向上します。 さらに、<span class="quote">「<span class="quote">従来</span>」</span>ロックモードの場合と同じく、任意のステートメントによって割り当てられた自動インクリメント番号が<span class="emphasis"><em>連続的</em></span>になります。 自動増分を使用するステートメントには、<span class="quote">「<span class="quote">「従来型」</span>」</span>モードと比較してセマンティクスの<span class="emphasis"><em>変更なし</em></span>がありますが、重要な例外があります。 
          </p><p>
            例外は<span class="quote">「<span class="quote">混在モード挿入</span>」</span>です。この挿入では、ユーザーは複数行の<span class="quote">「<span class="quote">単純挿入</span>」</span>で、明示的な値を全部ではなく、一部の行の <code class="literal">AUTO_INCREMENT</code> カラムに指定します。 このような挿入の場合、<code class="literal">InnoDB</code> は挿入される行数より多くの自動インクリメント値を割り当てます。 ただし、自動的に割り当てられる値はすべて連続的に生成されるため、直前に実行されたステートメントによって生成された自動インクリメント値よりも値が大きくなります。 <span class="quote">「<span class="quote">余分</span>」</span>な番号は失われます。 
          </p></li><li class="listitem"><p><a name="innodb-auto-increment-lock-mode-interleaved"></a>
            <code class="literal">innodb_autoinc_lock_mode = 2</code> (<span class="quote">「<span class="quote">インターリーブ</span>」</span> ロックモード)
          </p><p>
            このロックモードでは、テーブルレベル <code class="literal">AUTO-INC</code> ロックを使用する <span class="quote">「<span class="quote"><code class="literal">INSERT</code> のような</span>」</span>ステートメントは 1 つも存在しないため、複数のステートメントを同時に実行できます。 これはもっとも高速で、もっとも拡張性の高いロックモードです。ただし、ステートメントベースのレプリケーションを使用する場合や、リカバリシナリオでバイナリログから SQL ステートメントを再現する際には、<span class="emphasis"><em>安全ではありません</em></span>。 
          </p><p>
            このロックモードでは、自動インクリメント値は一意であり、並列実行されているすべての <span class="quote">「<span class="quote"><code class="literal">INSERT</code> のような</span>」</span>ステートメントにわたって単調に増加することが保証されます。 ただし、複数のステートメントが同時に番号を生成している (つまり番号の割り当てが複数のステートメント間で<span class="emphasis"><em>インターリーブ</em></span>されている) 可能性があるため、任意のステートメントによって挿入される行に対して生成された値が連続的でない可能性があります。 
          </p><p>
            実行中のステートメントが<span class="quote">「<span class="quote">「単純な挿入」</span>」</span>のみで、挿入される行数が事前にわかっている場合、<span class="quote">「<span class="quote">「混合モードの挿入」</span>」</span>を除き、単一のステートメントに対して生成される番号にギャップはありません。 ただし、<span class="quote">「<span class="quote">一括挿入</span>」</span>が実行されると、特定のステートメントで割り当てられた自動インクリメント値にギャップが発生する可能性があります。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-auto-increment-lock-mode-usage-implications"></a>InnoDB AUTO_INCREMENT ロックモードの使用上の意味</h5></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            レプリケーションでの自動インクリメントの使用
          </p><p>
            ステートメントベースレプリケーションを使用している場合は、<code class="literal">innodb_autoinc_lock_mode</code> を 0 または 1 に設定し、ソースとその複製で同じ値を使用します。 <code class="literal">innodb_autoinc_lock_mode</code> = 2 (<span class="quote">「<span class="quote">「インターリーブ」</span>」</span>) またはソースとレプリカが同じロックモードを使用しない構成を使用する場合、レプリカとソースで自動インクリメント値が同じであることは保証されません。 
          </p><p>
            行ベースレプリケーションは SQL ステートメントの実行順序に左右されない (混在形式は、ステートメントベースレプリケーションでは安全でないステートメントで行ベースレプリケーションを使用する) ため、行ベースまたは混在形式レプリケーションを使用している場合は、すべての自動インクリメントロックモードが安全です。
          </p></li><li class="listitem"><p>
            <span class="quote">「<span class="quote">失われた</span>」</span>自動インクリメント値とシーケンスギャップ
          </p><p>
            すべてのロックモード (0、1、および 2) では、自動インクリメント値を生成したトランザクションがロールバックされると、これらの自動インクリメント値が<span class="quote">「<span class="quote">失われます</span>」</span>。 <span class="quote">「<span class="quote"><code class="literal">INSERT</code> のような</span>」</span>ステートメントが完了したかどうか、およびそれを含むトランザクションがロールバックされたかどうかに関係なく、自動インクリメントカラムの値は一度生成されたら、ロールバックできません。 このような失われた値は再使用されません。 したがって、テーブルの <code class="literal">AUTO_INCREMENT</code> カラムに格納されている値にはギャップが存在する可能性があります。 
          </p></li><li class="listitem"><p>
            <code class="literal">AUTO_INCREMENT</code> カラムに NULL または 0 を指定
          </p><p>
            すべてのロックモード (0、1 および 2) で、ユーザーが <code class="literal">INSERT</code> の <code class="literal">AUTO_INCREMENT</code> カラムに NULL または 0 を指定すると、<code class="literal">InnoDB</code> はその行を値が指定されていないかのように処理し、新しい値を生成します。
          </p></li><li class="listitem"><p>
            <code class="literal">AUTO_INCREMENT</code> カラムへの負の値の割当て
          </p><p>
            すべてのロックモード (0、1 および 2) では、<code class="literal">AUTO_INCREMENT</code> カラムに負の値を割り当てる場合、自動増分メカニズムの動作は定義されません。
          </p></li><li class="listitem"><p>
            <code class="literal">AUTO_INCREMENT</code> 値が指定された整数型の最大整数より大きい場合
          </p><p>
            すべてのロックモード (0、1、および 2) では、値が指定された整数型に格納できる最大整数を超えると、自動インクリメントメカニズムの動作は定義されません。
          </p></li><li class="listitem"><p>
            <span class="quote">「<span class="quote">一括挿入</span>」</span>の自動インクリメント値のギャップ
          </p><p>
            <code class="literal">innodb_autoinc_lock_mode</code> が 0 (<span class="quote">「<span class="quote">「従来型」</span>」</span>) または 1 (<span class="quote">「<span class="quote">「連続」</span>」</span>) に設定されている場合、テーブルレベルの <code class="literal">AUTO-INC</code> ロックはステートメントの最後まで保持され、そのようなステートメントのみを一度に実行できるため、特定のステートメントによって生成される自動増分値はギャップなしで連続しています。
          </p><p>
            <code class="literal">innodb_autoinc_lock_mode</code> が 2 (<span class="quote">「<span class="quote">インターリーブ</span>」</span>) に設定されている場合、<span class="quote">「<span class="quote">一括挿入</span>」</span>によって生成された自動インクリメント値にギャップが存在する可能性がありますが、並列実行中の <span class="quote">「<span class="quote"><code class="literal">INSERT</code> のような</span>」</span>ステートメントが存在する場合に限ります。
          </p><p>
            一括挿入では、各ステートメントで必要となる自動インクリメント値の正確な数がわからず、過大評価される可能性があるため、ロックモードが 1 または 2 の場合は、連続したステートメント間でギャップが発生する可能性があります。
          </p></li><li class="listitem"><p>
            <span class="quote">「<span class="quote">混在モード挿入</span>」</span>によって割り当てられる自動インクリメント値
          </p><p>
            <span class="quote">「<span class="quote">単純挿入</span>」</span>が (全部ではなく) 一部の結果行の自動インクリメント値を指定する<span class="quote">「<span class="quote">混在モード挿入</span>」</span>を検討します。 このようなステートメントの動作は、ロックモード 0、1、および 2 で異なります。 たとえば、<code class="literal">c1</code> はテーブル <code class="literal">t1</code> の <code class="literal">AUTO_INCREMENT</code> カラムで、自動生成されたシーケンス番号の最新値が 100 であるとします。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
    -&gt; <strong class="userinput"><code>c1 INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, </code></strong>
    -&gt; <strong class="userinput"><code>c2 CHAR(1)</code></strong>
    -&gt; <strong class="userinput"><code>) ENGINE = INNODB;</code></strong>
</pre><p>
            ここで、次の<span class="quote">「<span class="quote">「混合モードの挿入」</span>」</span>ステートメントについて考えてみます:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');</code></strong>
</pre><p>
            <code class="literal">innodb_autoinc_lock_mode</code> が 0 (<span class="quote">「<span class="quote">「従来型」</span>」</span>) に設定されている場合、4 つの新しい行は次のとおりです:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT c1, c2 FROM t1 ORDER BY c2;</code></strong>
+-----+------+
| c1  | c2   |
+-----+------+
|   1 | a    |
| 101 | b    |
|   5 | c    |
| 102 | d    |
+-----+------+
</pre><p>
            次に使用可能な自動インクリメント値は 103 です。これは、自動インクリメント値が一度に 1 つずつ割り当てられ、ステートメントの実行開始時に一度に割り当てられるわけではないためです。 この結果は、並列実行中の (任意の型の) <span class="quote">「<span class="quote"><code class="literal">INSERT</code> のような</span>」</span>ステートメントが存在するかどうかに左右されません。 
          </p><p>
            <code class="literal">innodb_autoinc_lock_mode</code> を 1 (<span class="quote">「<span class="quote">「連続」</span>」</span>) に設定すると、次の 4 つの新しい行も表示されます:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT c1, c2 FROM t1 ORDER BY c2;</code></strong>
+-----+------+
| c1  | c2   |
+-----+------+
|   1 | a    |
| 101 | b    |
|   5 | c    |
| 102 | d    |
+-----+------+
</pre><p>
            ただし、この場合、次に使用可能な自動増分値は 103 ではなく 105 です。これは、ステートメントの処理時に 4 つの自動増分値が割り当てられるためですが、使用されるのは 2 つのみであるためです。 この結果は、並列実行中の (任意の型の) <span class="quote">「<span class="quote"><code class="literal">INSERT</code> のような</span>」</span>ステートメントが存在するかどうかに左右されません。 
          </p><p>
            <code class="literal">innodb_autoinc_lock_mode</code> がモード 2 (<span class="quote">「<span class="quote">「インターリーブ」</span>」</span>) に設定されている場合、4 つの新しい行は次のとおりです:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT c1, c2 FROM t1 ORDER BY c2;</code></strong>
+-----+------+
| c1  | c2   |
+-----+------+
|   1 | a    |
|   <em class="replaceable"><code>x</code></em> | b    |
|   5 | c    |
|   <em class="replaceable"><code>y</code></em> | d    |
+-----+------+
</pre><p>
            <em class="replaceable"><code>x</code></em> および <em class="replaceable"><code>y</code></em> の値は一意で、以前に生成された行より大きくなります。 ただし、<em class="replaceable"><code>x</code></em> および <em class="replaceable"><code>y</code></em> の特定の値は、同時に実行するステートメントによって生成される自動インクリメント値の数によって異なります。 
          </p><p>
            最後に、最後に生成された順序番号が 100 の場合に発行される次のステートメントについて考えてみます:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (101,'c'), (NULL,'d');</code></strong>
</pre><p>
            <code class="literal">innodb_autoinc_lock_mode</code> 設定では、101 が行 <code class="literal">(NULL, 'b')</code> に割り当てられ、行 <code class="literal">(101, 'c')</code> の挿入が失敗するため、このステートメントによって重複キーエラー 23000 (<code class="literal">Can't write; duplicate key in table</code>) が生成されます。
          </p></li><li class="listitem"><p>
            一連の <code class="literal">INSERT</code> ステートメントの途中での <code class="literal">AUTO_INCREMENT</code> カラム値の変更
          </p><p>
            MySQL 5.7 以前では、一連の <code class="literal">INSERT</code> ステートメントの途中で <code class="literal">AUTO_INCREMENT</code> カラムの値を変更すると、<span class="quote">「<span class="quote">「重複エントリ」</span>」</span>エラーが発生する可能性がありました。 たとえば、<code class="literal">AUTO_INCREMENT</code> カラムの値を現在の最大自動増分値より大きい値に変更する <code class="literal">UPDATE</code> 操作を実行した場合、未使用の自動増分値を指定しなかった後続の <code class="literal">INSERT</code> 操作では<span class="quote">「<span class="quote">「重複エントリ」</span>」</span>エラーが発生する可能性があります。 MySQL 8.0 以降では、<code class="literal">AUTO_INCREMENT</code> カラムの値を現在の最大自動増分値より大きい値に変更すると、新しい値が永続化され、後続の <code class="literal">INSERT</code> 操作では、新しい大きい値から始まる自動増分値が割り当てられます。 この動作を次の例に示します。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
    -&gt; <strong class="userinput"><code>c1 INT NOT NULL AUTO_INCREMENT,</code></strong>
    -&gt; <strong class="userinput"><code>PRIMARY KEY (c1)</code></strong>
    -&gt;  <strong class="userinput"><code>) ENGINE = InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES(0), (0), (3);</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT c1 FROM t1;</code></strong>
+----+
| c1 |
+----+
|  1 |
|  2 |
|  3 |
+----+

mysql&gt; <strong class="userinput"><code>UPDATE t1 SET c1 = 4 WHERE c1 = 1;</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT c1 FROM t1;</code></strong>
+----+
| c1 |
+----+
|  2 |
|  3 |
|  4 |
+----+

mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES(0);</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT c1 FROM t1;</code></strong>
+----+
| c1 |
+----+
|  2 |
|  3 |
|  4 |
|  5 |
+----+
</pre></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-auto-increment-initialization"></a>InnoDB AUTO_INCREMENT カウンタの初期化</h5></div></div></div><a class="indexterm" name="idm44761363988880"></a><p>
        このセクションでは、<code class="literal">InnoDB</code> が <code class="literal">AUTO_INCREMENT</code> カウンタを初期化する方法について説明します。
      </p><p>
        <code class="literal">InnoDB</code> テーブルに <code class="literal">AUTO_INCREMENT</code> カラムを指定した場合、インメモリーテーブルオブジェクトには、カラムに新しい値を割り当てるときに使用される自動増分カウンタと呼ばれる特別なカウンタが含まれます。
      </p><p>
        MySQL 5.7 以前では、自動インクリメントカウンタはメインメモリーにのみ格納され、ディスクには格納されません。 サーバーの再起動後に自動インクリメントカウンタを初期化するために、<code class="literal">InnoDB</code> は、<code class="literal">AUTO_INCREMENT</code> カラムを含むテーブルへの最初の挿入で次のステートメントと同等のステートメントを実行します。 
      </p><pre class="programlisting">SELECT MAX(ai_col) FROM <em class="replaceable"><code>table_name</code></em> FOR UPDATE;
</pre><p>
        MySQL 8.0 では、この動作は変更されています。 現在の最大自動増分カウンタ値は、変更されるたびに redo ログに書き込まれ、各チェックポイントのエンジン専用システムテーブルに保存されます。 これらの変更により、現在の最大自動インクリメントカウンタ値がサーバーの再起動後も保持されます。 
      </p><p>
        通常の停止後のサーバーの再起動時に、<code class="literal">InnoDB</code> は、データディクショナリのシステムテーブルに格納されている現在の最大自動増分値を使用して、インメモリー自動増分カウンタを初期化します。
      </p><p>
        クラッシュリカバリ中のサーバーの再起動時に、<code class="literal">InnoDB</code> は、データディクショナリのシステムテーブルに格納されている現在の最大自動増分値を使用してインメモリー自動増分カウンタを初期化し、最後のチェックポイント以降に書き込まれた自動増分カウンタ値の redo ログをスキャンします。 redo ログ値がインメモリーカウンタ値より大きい場合は、redo ログ値が適用されます。 ただし、予期しないサーバー終了の場合、以前に割り当てられた自動インクリメント値の再利用は保証できません。 <code class="literal">INSERT</code> または <code class="literal">UPDATE</code> 操作のために現在の最大自動増分値が変更されるたびに、新しい値が redo ログに書き込まれますが、redo ログがディスクにフラッシュされる前に予期しない終了が発生した場合は、サーバーの再起動後に自動増分カウンタが初期化されたときに、以前に割り当てられた値を再利用できます。 
      </p><p>
        <code class="literal">InnoDB</code> が <code class="literal">SELECT MAX(ai_col) FROM <em class="replaceable"><code>table_name</code></em> FOR UPDATE</code> ステートメントと同等のものを使用して自動増分カウンタを初期化する唯一の状況は、<code class="filename">.cfg</code> メタデータファイルを使用しない <a class="link" href="innodb-storage-engine.html#innodb-table-import" title="15.6.1.3 InnoDB テーブルのインポート">importing a table</a> の場合です。 それ以外の場合は、現在の最大自動インクリメントカウンタ値が <code class="filename">.cfg</code> メタデータファイルから読み取られます (存在する場合)。 カウンタ値の初期化とは別に、<code class="literal">ALTER TABLE ... AUTO_INCREMENT = <em class="replaceable"><code>N</code></em> FOR UPDATE</code> ステートメントを使用してカウンタ値を永続カウンタ値以下に設定しようとすると、<code class="literal">SELECT MAX(ai_col) FROM <em class="replaceable"><code>table_name</code></em></code> ステートメントと同等のものを使用して、テーブルの現在の最大自動増分カウンタ値が決定されます。 たとえば、一部のレコードを削除した後で、カウンタ値を小さい値に設定しようとする場合があります。 この場合、テーブルを検索して、新しいカウンタ値が実際の現在の最大カウンタ値以下でないことを確認する必要があります。 
      </p><p>
        MySQL 5.7 以前では、サーバーを再起動すると <code class="literal">AUTO_INCREMENT = N</code> テーブルオプションの影響が取り消され、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントで使用して、それぞれ初期カウンタ値を設定したり、既存のカウンタ値を変更したりできます。 MySQL 8.0 では、サーバーを再起動しても <code class="literal">AUTO_INCREMENT = N</code> テーブルオプションの影響は取り消されません。 自動インクリメントカウンタを特定の値に初期化した場合、または自動インクリメントカウンタ値を大きな値に変更した場合、新しい値はサーバーの再起動後も保持されます。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">ALTER TABLE ... AUTO_INCREMENT = N</code> では、自動増分カウンタ値を現在の最大値より大きい値にのみ変更できます。
        </p></div><p>
        MySQL 5.7 以前では、<code class="literal">ROLLBACK</code> 操作の直後にサーバーを再起動すると、以前にロールバックされたトランザクションに割り当てられた自動増分値が再利用され、現在の最大自動増分値が事実上ロールバックされる可能性がありました。 MySQL 8.0 では、現在の最大自動増分値が永続化され、以前に割り当てられた値が再利用されなくなります。 
      </p><p>
        自動増分カウンタが初期化される前に <code class="literal">SHOW TABLE STATUS</code> ステートメントがテーブルを調査する場合、<code class="literal">InnoDB</code> はテーブルを開き、データディクショナリのシステムテーブルに格納されている現在の最大自動増分値を使用してカウンタ値を初期化します。 この値は、後で挿入または更新するためにメモリーに格納されます。 カウンタ値の初期化では、トランザクションの最後まで続くテーブルに対する通常の排他ロック読取りが使用されます。 <code class="literal">InnoDB</code> は、0 より大きいユーザー指定の自動インクリメント値を持つ新しく作成されたテーブルの自動インクリメントカウンタを初期化する場合と同じ手順に従います。 
      </p><p>
        自動インクリメントカウンタの初期化後、行の挿入時に自動インクリメント値を明示的に指定しない場合、<code class="literal">InnoDB</code> は暗黙的にカウンタを増分し、新しい値をカラムに割り当てます。 自動インクリメントカラム値を明示的に指定する行を挿入し、その値が現在の最大カウンタ値より大きい場合、カウンタは指定された値に設定されます。 
      </p><p>
        <code class="literal">InnoDB</code> では、サーバーが実行されていれば、インメモリーの自動インクリメントカウンタが使用されます。 サーバーが停止して再起動されると、<code class="literal">InnoDB</code> は前述のように自動インクリメントカウンタを再初期化します。 
      </p><p>
        <code class="literal">auto_increment_offset</code> 構成オプションによって、<code class="literal">AUTO_INCREMENT</code> カラム値の開始点が決まります。 デフォルト設定は 1 です。 
      </p><p>
        <code class="literal">auto_increment_increment</code> 構成オプションは、連続するカラム値の間隔を制御します。 デフォルト設定は 1 です。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-auto-increment-notes"></a>メモ</h5></div></div></div><a class="indexterm" name="idm44761363940928"></a><a class="indexterm" name="idm44761363939840"></a><p>
        <code class="literal">AUTO_INCREMENT</code> 整数カラムの値を使い果たすと、後続の <code class="literal">INSERT</code> 操作で重複キーエラーが返されます。 これは、MySQL の一般的な動作です。 
      </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-indexes"></a>15.6.2 インデックス</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-index-types">15.6.2.1 クラスタインデックスとセカンダリインデックス</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-physical-structure">15.6.2.2 InnoDB インデックスの物理構造</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#sorted-index-builds">15.6.2.3 ソートされたインデックス構築</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-fulltext-index">15.6.2.4 InnoDB FULLTEXT インデックス</a></span></dt></dl></div><p>
    このセクションでは、<code class="literal">InnoDB</code> インデックスに関連するトピックについて説明します。
  </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-index-types"></a>15.6.2.1 クラスタインデックスとセカンダリインデックス</h4></div></div></div><a class="indexterm" name="idm44761363932352"></a><a class="indexterm" name="idm44761363930288"></a><a class="indexterm" name="idm44761363928080"></a><a class="indexterm" name="idm44761363926128"></a><p>
      すべての <code class="literal">InnoDB</code> テーブルは、行のデータが格納されている<a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">クラスタ化されたインデックス</a>と呼ばれる特別なインデックスを持っています。 一般に、クラスタ化されたインデックスは<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>のシノニムです。 クエリー、挿入およびその他のデータベース操作から最高のパフォーマンスを得るには、<code class="literal">InnoDB</code> がクラスタインデックスを使用して各テーブルの最も一般的な参照および DML 操作を最適化する方法を理解する必要があります。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          テーブル上で <code class="literal">PRIMARY KEY</code> を定義すると、<code class="literal">InnoDB</code> ではそれがクラスタ化されたインデックスとして使用されます。 作成するテーブルごとに主キーを定義します。 論理的に一意で、Null 以外のカラムまたはカラムのセットが存在しない場合は、自動的に値が入力される新しい<a class="link" href="glossary.html#glos_auto_increment" title="自動インクリメント">自動インクリメント</a>カラムを追加します。 
        </p></li><li class="listitem"><p>
          テーブルに <code class="literal">PRIMARY KEY</code> が定義されていない場合、MySQL はすべてのキーカラムが <code class="literal">NOT NULL</code> の <code class="literal">UNIQUE</code> インデックスを最初に検索し、<code class="literal">InnoDB</code> はそれをクラスタ化されたインデックスとして使用します。
        </p></li><li class="listitem"><p>
          テーブルに <code class="literal">PRIMARY KEY</code> インデックスまたは適切な <code class="literal">UNIQUE</code> インデックスがない場合、<code class="literal">InnoDB</code> は、<code class="literal">GEN_CLUST_INDEX</code> という名前の非表示のクラスタインデックスを、行 ID 値を含む合成カラムに内部的に生成します。 そのようなテーブルでは、<code class="literal">InnoDB</code> が行に割り当てる ID に基づいて行の順序付けが行われます。 行 ID は、新しい行が挿入されると単調に増加する 6 バイトのフィールドです。 したがって、行 ID で順序付けられた行が物理的な挿入順になります。 
        </p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-index-types-query-performance"></a>クラスタ化されたインデックスでクエリーを高速にする方法</h5></div></div></div><p>
        クラスタ化されたインデックスから行にアクセスすると、インデックス検索がすべての行データを持つページで直接実行されるため、高速になります。 多くの場合、テーブルのサイズが大きい場合にクラスタ化されたインデックスアーキテクチャーを使用すれば、インデックスレコードとは別のページに行データを格納するストレージ編成と比べて、ディスク I/O 操作を節約できます。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-index-types-secondary-clustered"></a>セカンダリインデックスとクラスタ化されたインデックスとの関係</h5></div></div></div><p>
        クラスタ化されたインデックス以外のインデックスは、すべて<a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">セカンダリインデックス</a>と呼ばれます。 <code class="literal">InnoDB</code> では、セカンダリインデックス内の各レコードに、行の主キーカラム、およびセカンダリインデックスに指定されたカラムが含まれます。 <code class="literal">InnoDB</code> では、クラスタ化されたインデックス内で行を検索する際に、この主キー値が使用されます。 
      </p><p>
        主キーが長くなると、セカンダリインデックスで使用される領域も多くなるため、主キーは短い方が利点があります。
      </p><p>
        <code class="literal">InnoDB</code> のクラスタインデックスおよびセカンダリインデックスを利用するためのガイドラインは、<a class="xref" href="optimization.html#optimization-indexes" title="8.3 最適化とインデックス">セクション8.3「最適化とインデックス」</a> を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-physical-structure"></a>15.6.2.2 InnoDB インデックスの物理構造</h4></div></div></div><a class="indexterm" name="idm44761363894544"></a><a class="indexterm" name="idm44761363892448"></a><a class="indexterm" name="idm44761363890528"></a><a class="indexterm" name="idm44761363888384"></a><a class="indexterm" name="idm44761363886976"></a><p>
      空間インデックスを除き、<code class="literal">InnoDB</code> インデックスは <a class="link" href="glossary.html#glos_b_tree" title="B ツリー">B-tree</a> データ構造です。 空間インデックスでは、多次元データのインデックス付けに特化したデータ構造である <a class="link" href="glossary.html#glos_r_tree" title="R-tree">R-trees</a> を使用します。 インデックスレコードは、B ツリーまたは R ツリーデータ構造のリーフページに格納されます。 インデックスページのデフォルトサイズは 16K バイトです。 
    </p><p>
      新しいレコードが <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">clustered index</a> に挿入されると、<code class="literal">InnoDB</code> は将来のインデックスレコードの挿入および更新のために 1/16 のページを解放しようとします。 インデックスレコードが順次 (昇順または降順) に挿入されると、インデックスページの約 15/16 までがいっぱいになります。 レコードがランダムに挿入された場合は、ページの 1/2 から 15/16 までがいっぱいになります。 
    </p><p>
      <code class="literal">InnoDB</code> では、B ツリーインデックスの作成または再構築時にバルクロードが実行されます。 このインデックス作成方法は、ソートされたインデックス作成と呼ばれます。 <code class="literal">innodb_fill_factor</code> 構成オプションは、ソートされたインデックスの作成時に入力される各 B ツリーページの領域の割合を定義します。残りの領域は、将来のインデックスの増加のために予約されています。 ソートされたインデックス構築は、空間インデックスではサポートされていません。 詳細は、<a class="xref" href="innodb-storage-engine.html#sorted-index-builds" title="15.6.2.3 ソートされたインデックス構築">セクション15.6.2.3「ソートされたインデックス構築」</a>を参照してください。 <code class="literal">innodb_fill_factor</code> を 100 に設定すると、クラスタ化されたインデックスページの領域の 1/16 は将来のインデックスの増加に備えて解放されます。 
    </p><p>
      <code class="literal">InnoDB</code> インデックスページの塗りつぶし係数が <code class="literal">MERGE_THRESHOLD</code> の下にドロップされた場合 (指定されていない場合、デフォルトで 50%)、<code class="literal">InnoDB</code> はインデックスツリーを縮小してページを解放しようとします。 <code class="literal">MERGE_THRESHOLD</code> 設定は、B ツリーインデックスと R ツリーインデックスの両方に適用されます。 詳細は、<a class="xref" href="innodb-storage-engine.html#index-page-merge-threshold" title="15.8.11 インデックスページのマージしきい値の構成">セクション15.8.11「インデックスページのマージしきい値の構成」</a>を参照してください。 
    </p><p>
      MySQL インスタンスを初期化する前に <code class="literal">innodb_page_size</code> 構成オプションを設定することで、MySQL インスタンスのすべての <code class="literal">InnoDB</code> テーブルスペースに対して <a class="link" href="glossary.html#glos_page_size" title="page size">page size</a> を定義できます。 インスタンスのページサイズを定義した後は、インスタンスを再初期化しないと変更できません。 サポートされているサイズは、64KB、32KB、16KB (デフォルト)、8KB および 4KB です。 
    </p><p>
      特定の <code class="literal">InnoDB</code> ページサイズを使用している MySQL インスタンスは、別のページサイズを使用するインスタンスのデータファイルやログファイルを使用できません。
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sorted-index-builds"></a>15.6.2.3 ソートされたインデックス構築</h4></div></div></div><a class="indexterm" name="idm44761363861920"></a><a class="indexterm" name="idm44761363859744"></a><p>
      <code class="literal">InnoDB</code> では、インデックスの作成または再構築時に、インデックスレコードを一度に挿入するかわりにバルクロードが実行されます。 このインデックス作成方法は、ソートされたインデックス作成とも呼ばれます。 ソートされたインデックス構築は、空間インデックスではサポートされていません。 
    </p><p>
      インデックス作成には 3 つのフェーズがあります。 最初のフェーズでは、<a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">clustered index</a> がスキャンされ、インデックスエントリが生成されてソートバッファに追加されます。 <a class="link" href="glossary.html#glos_sort_buffer" title="ソートバッファー">sort buffer</a> がいっぱいになると、エントリはソートされ、一時中間ファイルに書き込まれます。 このプロセスは、<span class="quote">「<span class="quote">run</span>」</span> とも呼ばれます。 2 番目のフェーズでは、1 つ以上の実行が一時中間ファイルに書き込まれ、ファイル内のすべてのエントリに対してマージソートが実行されます。 3 番目と最後のフェーズでは、ソートされたエントリが <a class="link" href="glossary.html#glos_b_tree" title="B ツリー">B-tree</a> に挿入されます。 
    </p><p>
      ソートされたインデックス構築が導入される前に、インデックスエントリは挿入 API を使用して一度に 1 つのレコードを B ツリーに挿入されました。 この方法では、B ツリー <a class="link" href="glossary.html#glos_cursor" title="カーソル">cursor</a> を開いて挿入位置を検索し、<a class="link" href="glossary.html#glos_optimistic" title="オプティミスティック">optimistic</a> 挿入を使用して B ツリーページにエントリを挿入します。 ページがいっぱいであるために挿入が失敗した場合は、<a class="link" href="glossary.html#glos_pessimistic" title="ペシミスティック">pessimistic</a> 挿入が実行されます。これには、B ツリーカーソルをオープンし、必要に応じて B ツリーノードを分割してマージし、エントリの領域を見つけます。 インデックスを作成するこの <span class="quote">「<span class="quote">top-down</span>」</span> メソッドの欠点は、挿入位置の検索と、B ツリーノードの一定の分割およびマージのコストです。 
    </p><p>
      ソートされたインデックス構築では、<span class="quote">「<span class="quote">bottom-up</span>」</span> アプローチを使用してインデックスを構築します。 このアプローチでは、B ツリーのすべてのレベルで右端のリーフページへの参照が保持されます。 必要な B ツリー深度の右端のリーフページが割り当てられ、ソート順に従ってエントリが挿入されます。 リーフページがいっぱいになると、ノードポインタが親ページに追加され、兄弟リーフページが次の挿入用に割り当てられます。 このプロセスは、すべてのエントリが挿入されるまで続行され、ルートレベルまで挿入される可能性があります。 兄弟ページが割り当てられると、以前に固定されたリーフページへの参照が解放され、新しく割り当てられたリーフページが最も右側のリーフページおよび新しいデフォルトの挿入場所になります。 
    </p><h5><a name="idm44761363842912"></a>将来のインデックス増加のための B ツリーページ領域の予約</h5><p>
      将来のインデックス増加のために領域を確保するには、<code class="literal">innodb_fill_factor</code> 構成オプションを使用して、B ツリーページ領域の割合を確保します。 たとえば、<code class="literal">innodb_fill_factor</code> を 80 に設定すると、ソートされたインデックスの作成時に B ツリーページの領域の 20% が予約されます。 この設定は、B ツリーリーフページと非リーフページの両方に適用されます。 <code class="literal">TEXT</code> または <code class="literal">BLOB</code> エントリに使用される外部ページには適用されません。 予約される領域の量は、<code class="literal">innodb_fill_factor</code> 値が強い制限ではなくヒントとして解釈されるため、正確には構成されていない場合があります。 
    </p><h5><a name="idm44761363835424"></a>ソートされたインデックス構築および全文インデックスのサポート</h5><p>
      ソートされたインデックス構築は、<a class="link" href="glossary.html#glos_fulltext_index" title="FULLTEXT インデックス">fulltext indexes</a> でサポートされています。 以前は、SQL を使用して全文インデックスにエントリが挿入されていました。 
    </p><h5><a name="idm44761363832784"></a>ソートされたインデックス作成および圧縮されたテーブル</h5><p>
      <a class="link" href="glossary.html#glos_compression" title="圧縮">compressed tables</a> の場合、以前のインデックス作成方法では、圧縮ページと非圧縮ページの両方にエントリが追加されました。 変更ログ (圧縮されたページの空き領域を表す) がいっぱいになると、圧縮されたページが再圧縮されます。 領域不足のために圧縮に失敗した場合、ページは分割されます。 ソートされたインデックス構築では、エントリは圧縮されていないページにのみ追加されます。 圧縮されていないページがいっぱいになると、圧縮されます。 適応パディングは、ほとんどの場合に圧縮が成功するようにするために使用されますが、圧縮が失敗した場合は、ページが分割され、圧縮が再試行されます。 このプロセスは、圧縮が成功するまで続行されます。 B ツリーページの圧縮の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-compression-internals" title="15.9.1.5 InnoDB テーブルでの圧縮の動作">セクション15.9.1.5「InnoDB テーブルでの圧縮の動作」</a> を参照してください。 
    </p><h5><a name="idm44761363828144"></a>ソートされたインデックスの作成および redo ロギング</h5><p>
      <a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">Redo logging</a> は、ソートされたインデックスの作成中は無効になります。 かわりに、インデックス作成が予期しない終了または障害に耐えることができるようにする <a class="link" href="glossary.html#glos_checkpoint" title="チェックポイント">checkpoint</a> があります。 チェックポイントにより、すべてのダーティページが強制的にディスクに書き込まれます。 ソートされたインデックスの作成中に、チェックポイント操作を迅速に処理できるように、<a class="link" href="glossary.html#glos_dirty_page" title="ダーティーページ">dirty pages</a> をフラッシュするように <a class="link" href="glossary.html#glos_page_cleaner" title="ページクリーナー">page cleaner</a> スレッドに定期的にシグナルが送信されます。 通常、クリーンページ数が設定されたしきい値を下回ると、ページクリーナスレッドはダーティページをフラッシュします。 ソートされたインデックス構築の場合、ダーティページはチェックポイントのオーバーヘッドを削減し、I/O および CPU アクティビティをパラレル化するためにすぐにフラッシュされます。 
    </p><h5><a name="idm44761363821984"></a>ソートされたインデックス構築およびオプティマイザ統計</h5><p>
      ソートされたインデックス構築では、<a class="link" href="glossary.html#glos_optimizer" title="オプティマイザ">optimizer</a> 統計が、前述のインデックス作成方法で生成された統計と異なる場合があります。 ワークロードのパフォーマンスに影響しない統計の違いは、インデックスの移入に使用されるアルゴリズムが異なることが原因です。 
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-fulltext-index"></a>15.6.2.4 InnoDB FULLTEXT インデックス</h4></div></div></div><a class="indexterm" name="idm44761363818048"></a><a class="indexterm" name="idm44761363816000"></a><p>
      <code class="literal">FULLTEXT</code> インデックスは、テキストベースのカラム (<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code> または <code class="literal">TEXT</code> カラム) に作成され、それらのカラムに含まれるデータに対するクエリーおよび DML 操作を高速化し、ストップワードとして定義されている単語を省略します。
    </p><p>
      <code class="literal">FULLTEXT</code> インデックスは、<code class="literal">CREATE TABLE</code> ステートメントの一部として定義されるか、<code class="literal">ALTER TABLE</code> または <code class="literal">CREATE INDEX</code> を使用して既存のテーブルに追加されます。
    </p><p>
      全文検索は、<code class="literal">MATCH() ... AGAINST</code> 構文を使用して実行されます。 使用法については、<a class="xref" href="functions.html#fulltext-search" title="12.10 全文検索関数">セクション12.10「全文検索関数」</a>を参照してください。 
    </p><p>
      <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> インデックスについては、このセクションの次のトピックで説明します:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index-design" title="InnoDB 全文インデックスの設計">InnoDB 全文インデックスの設計</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index-tables" title="InnoDB 全文インデックステーブル">InnoDB 全文インデックステーブル</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index-cache" title="InnoDB 全文インデックスキャッシュ">InnoDB 全文インデックスキャッシュ</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index-docid" title="InnoDB 全文インデックスドキュメント ID および FTS_DOC_ID カラム">InnoDB 全文インデックスドキュメント ID および FTS_DOC_ID カラム</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index-deletion" title="InnoDB による全文インデックスの削除処理">InnoDB による全文インデックスの削除処理</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index-transaction" title="InnoDB による全文インデックスのトランザクション処理">InnoDB による全文インデックスのトランザクション処理</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index-monitoring" title="InnoDB による全文インデックスのモニター">InnoDB による全文インデックスのモニター</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-fulltext-index-design"></a>InnoDB 全文インデックスの設計</h5></div></div></div><p>
        <code class="literal">InnoDB</code> の <code class="literal">FULLTEXT</code> インデックスでは、転置インデックスの設計が使用されています。 転置インデックスには、単語のリスト、および単語ごとに、その単語が出現するドキュメントのリストが格納されます。 近接検索をサポートするために、単語ごとの位置情報もバイトオフセットとして格納されます。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-fulltext-index-tables"></a>InnoDB 全文インデックステーブル</h5></div></div></div><p>
        <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> インデックスを作成すると、次の例に示すように、インデックステーブルのセットが作成されます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE opening_lines (</code></strong>
       <strong class="userinput"><code>id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,</code></strong>
       <strong class="userinput"><code>opening_line TEXT(500),</code></strong>
       <strong class="userinput"><code>author VARCHAR(200),</code></strong>
       <strong class="userinput"><code>title VARCHAR(200),</code></strong>
       <strong class="userinput"><code>FULLTEXT idx (opening_line)</code></strong>
       <strong class="userinput"><code>) ENGINE=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT table_id, name, space from INFORMATION_SCHEMA.INNODB_TABLES</code></strong>
       <strong class="userinput"><code>WHERE name LIKE 'test/%';</code></strong>
+----------+----------------------------------------------------+-------+
| table_id | name                                               | space |
+----------+----------------------------------------------------+-------+
|      333 | test/fts_0000000000000147_00000000000001c9_index_1 |   289 |
|      334 | test/fts_0000000000000147_00000000000001c9_index_2 |   290 |
|      335 | test/fts_0000000000000147_00000000000001c9_index_3 |   291 |
|      336 | test/fts_0000000000000147_00000000000001c9_index_4 |   292 |
|      337 | test/fts_0000000000000147_00000000000001c9_index_5 |   293 |
|      338 | test/fts_0000000000000147_00000000000001c9_index_6 |   294 |
|      330 | test/fts_0000000000000147_being_deleted            |   286 |
|      331 | test/fts_0000000000000147_being_deleted_cache      |   287 |
|      332 | test/fts_0000000000000147_config                   |   288 |
|      328 | test/fts_0000000000000147_deleted                  |   284 |
|      329 | test/fts_0000000000000147_deleted_cache            |   285 |
|      327 | test/opening_lines                                 |   283 |
+----------+----------------------------------------------------+-------+
</pre><p>
        最初の 6 つのテーブルは転置インデックスを表し、近接検索インデックステーブルと呼ばれます。 受信ドキュメントがトークン化されると、個々の単語 (<span class="quote">「<span class="quote">「トークン」</span>」</span>とも呼ばれる) が、位置情報および関連するドキュメント ID (<code class="literal">DOC_ID</code>) とともにインデックステーブルに挿入されます。 単語は、最初の文字の文字セットソートの重みに基づいて、6 つのインデックステーブル間で完全にソートおよびパーティション化されます。 
      </p><p>
        転置インデックスは、インデックスの並列作成をサポートするために、6 つの補助インデックステーブルにパーティション化されます。 デフォルトでは、2 つのスレッドを使用して、単語および関連するデータのトークン化、ソート、およびインデックステーブルへの挿入が実行されます。 スレッドの数は、<code class="literal">innodb_ft_sort_pll_degree</code> オプションを使用することで構成可能です。 大規模なテーブルに <code class="literal">FULLTEXT</code> インデックスを作成する場合は、スレッド数を増やすことを検討してください。 
      </p><p>
        補助インデックステーブル名には接頭辞として <code class="literal">fts_</code>が付き、ポストフィックスとして <code class="literal">index_*</code> が付きます。 各インデックステーブルは、インデックス付きのテーブルの <code class="literal">table_id</code> と一致するインデックステーブル名に含まれる 16 進値によって、インデックス付きのテーブルに関連付けられます。 たとえば、<code class="literal">test/opening_lines</code> テーブルの <code class="literal">table_id</code> は <code class="literal">327</code> (16 進値は 0x147) です。 前述の例で示したように、16 進値の <span class="quote">「<span class="quote">147</span>」</span> は、<code class="literal">test/opening_lines</code> テーブルに関連付けられたインデックステーブルの名前に表示されます。 
      </p><p>
        <code class="literal">FULLTEXT</code> インデックスの <code class="literal">index_id</code> を表す hex 値は、補助インデックステーブル名にも表示されます。 たとえば、補助テーブル名 <code class="literal">test/fts_0000000000000147_00000000000001c9_index_1</code> では、16 進値 <code class="literal">1c9</code> の小数値は 457 です。 <code class="literal">opening_lines</code> テーブル (<code class="literal">idx</code>) に定義されているインデックスは、<code class="literal">INFORMATION_SCHEMA.INNODB_INDEXES</code> テーブルにこの値をクエリーして識別できます (457)。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT index_id, name, table_id, space from INFORMATION_SCHEMA.INNODB_INDEXES</code></strong>
       <strong class="userinput"><code>WHERE index_id=457;</code></strong>
+----------+------+----------+-------+
| index_id | name | table_id | space |
+----------+------+----------+-------+
|      457 | idx  |      327 |   283 |
+----------+------+----------+-------+
</pre><p>
        プライマリテーブルが <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースに作成される場合、インデックステーブルは独自のテーブルスペースに格納されます。
      </p><p>
        前述の例に示されているその他のインデックステーブルは、共通インデックステーブルと呼ばれ、<code class="literal">FULLTEXT</code> インデックスの削除処理および内部状態の格納に使用されます。 全文インデックスごとに作成される逆インデックステーブルとは異なり、このテーブルのセットは、特定のテーブルに作成されるすべての全文インデックスに共通です。 
      </p><p>
        全文インデックスが削除されても、共通の補助テーブルは保持されます。 全文インデックスを削除すると、<code class="literal">FTS_DOC_ID</code> カラムの削除にはテーブルの再構築が必要になるため、インデックスに対して作成された <code class="literal">FTS_DOC_ID</code> カラムは保持されます。 <code class="literal">FTS_DOC_ID</code> カラムを管理するには、共通の軸テーブルが必要です。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">fts_*_deleted</code> および <code class="literal">fts_*_deleted_cache</code>
          </p><p>
            削除されたが、まだ全文インデックスからデータが削除されていないドキュメントのドキュメント ID (DOC_ID) が含まれます。 <code class="literal">fts_*_deleted_cache</code> は、<code class="literal">fts_*_deleted</code> テーブルのインメモリーバージョンです。 
          </p></li><li class="listitem"><p>
            <code class="literal">fts_*_being_deleted</code> および <code class="literal">fts_*_being_deleted_cache</code>
          </p><p>
            削除され、現在全文インデックスからデータが削除されているドキュメントのドキュメント ID (DOC_ID) が含まれます。 <code class="literal">fts_*_being_deleted_cache</code> テーブルは、<code class="literal">fts_*_being_deleted</code> テーブルのインメモリーバージョンです。 
          </p></li><li class="listitem"><p>
            <code class="literal">fts_*_config</code>
          </p><p>
            <code class="literal">FULLTEXT</code> インデックスの内部状態に関する情報を格納します。 もっとも重要な点は、解析され、ディスクにフラッシュされたドキュメントを識別する <code class="literal">FTS_SYNCED_DOC_ID</code> が格納されることです。 クラッシュリカバリの場合、ドキュメントを再解析し、<code class="literal">FULLTEXT</code> インデックスキャッシュに追加し直すことができるように、ディスクにフラッシュされていないドキュメントを識別する際に、<code class="literal">FTS_SYNCED_DOC_ID</code> 値が使用されます。 このテーブル内のデータを表示するには、<code class="literal">INFORMATION_SCHEMA.INNODB_FT_CONFIG</code> テーブルでクエリーを実行します。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-fulltext-index-cache"></a>InnoDB 全文インデックスキャッシュ</h5></div></div></div><p>
        ドキュメントが挿入されると、トークン化され、各単語および関連付けられたデータが <code class="literal">FULLTEXT</code> インデックスに挿入されます。 このプロセスが実行されると、小さなドキュメントの場合でも、補助インデックステーブルへの多数の小規模な挿入が発生します。これにより、競合の発生時に、これらのテーブルへの並列アクセスが発生する可能性があります。 この問題を回避するために、<code class="literal">InnoDB</code> では、最近挿入された行に対するインデックステーブルの挿入を一時的にキャッシュに入れるために、<code class="literal">FULLTEXT</code> インデックスキャッシュが使用されます。 このインメモリーキャッシュの構造では、キャッシュがいっぱいになるまで挿入が保持され、そのあと、ディスク (補助インデックステーブル) にバッチフラッシュされます。 <code class="literal">INFORMATION_SCHEMA.INNODB_FT_INDEX_CACHE</code> テーブルでクエリーを実行すると、最近挿入された行のトークン化されたデータを表示できます。 
      </p><p>
        キャッシュおよびバッチフラッシュの動作によって、補助インデックステーブルへの頻繁な更新が回避されますが、負荷の高い挿入時および更新時に並列アクセスの問題が発生する可能性があります。 また、バッチ技術を使用すると、同じ単語への挿入が複数回発生することも回避され、重複エントリも最小限になります。 各単語を個別にフラッシュする代わりに、同じ単語の挿入がマージされ、単一のエントリとしてディスクにフラッシュされるため、補助インデックステーブルのサイズをできるかぎり小さく保ちながら、挿入の効率性が改善されます。 
      </p><p>
        全文インデックスキャッシュのサイズを (テーブルごとに) 構成するには、<code class="literal">innodb_ft_cache_size</code> 変数が使用されます。これにより、全文インデックスキャッシュがフラッシュされる頻度が影響を受けます。 特定のインスタンスで <code class="literal">innodb_ft_total_cache_size</code> オプションを使用すれば、すべてのテーブルに対応したグローバルな全文インデックスキャッシュのサイズ制限を定義することもできます。 
      </p><p>
        全文インデックスキャッシュには、補助インデックステーブルと同じ情報が格納されます。 ただし、全文インデックスキャッシュでは、最近挿入された行のトークン化されたデータのみがキャッシュに入れられます。 すでにディスク (全文補助テーブル) にフラッシュされているデータは、クエリー時に全文インデックスキャッシュに戻りません。 補助インデックステーブル内のデータは、直接クエリーが実行されます。補助インデックステーブルからの結果は、全文インデックスキャッシュからの結果とマージされてから返されます。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-fulltext-index-docid"></a>InnoDB 全文インデックスドキュメント ID および FTS_DOC_ID カラム</h5></div></div></div><p>
        <code class="literal">InnoDB</code> では、全文インデックス内の単語をその単語が出現するドキュメントレコードとマップする際に、ドキュメント ID (<code class="literal">DOC_ID</code>) と呼ばれる一意のドキュメント識別子が使用されます。 このマッピングには、インデックス付きテーブル上の <code class="literal">FTS_DOC_ID</code> カラムが必要です。 <code class="literal">FTS_DOC_ID</code> カラムが定義されていない場合は、全文インデックスの作成時に、<code class="literal">InnoDB</code> によって自動的に非表示の <code class="literal">FTS_DOC_ID</code> カラムが追加されます。 次の例で、この動作を実演します。 
      </p><p>
        次のテーブル定義には、<code class="literal">FTS_DOC_ID</code> カラムが含まれていません。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE opening_lines (</code></strong>
       <strong class="userinput"><code>id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,</code></strong>
       <strong class="userinput"><code>opening_line TEXT(500),</code></strong>
       <strong class="userinput"><code>author VARCHAR(200),</code></strong>
       <strong class="userinput"><code>title VARCHAR(200)</code></strong>
       <strong class="userinput"><code>) ENGINE=InnoDB;</code></strong>
</pre><p>
        <code class="literal">CREATE FULLTEXT INDEX</code> 構文を使用して、テーブル上に全文インデックスを作成すると、<code class="literal">FTS_DOC_ID</code> カラムが追加されるように <code class="literal">InnoDB</code> がテーブルを再構築していることをレポートする警告が返されます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE FULLTEXT INDEX idx ON opening_lines(opening_line);</code></strong>
Query OK, 0 rows affected, 1 warning (0.19 sec)
Records: 0  Duplicates: 0  Warnings: 1

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+---------+------+--------------------------------------------------+
| Level   | Code | Message                                          |
+---------+------+--------------------------------------------------+
| Warning |  124 | InnoDB rebuilding table to add column FTS_DOC_ID |
+---------+------+--------------------------------------------------+
</pre><p>
        <code class="literal">ALTER TABLE</code> を使用して、<code class="literal">FTS_DOC_ID</code> カラムが存在しないテーブルに全文インデックスを追加するときにも、同じ警告が返されます。 <code class="literal">CREATE TABLE</code> の実行時に全文インデックスを作成する場合に、<code class="literal">FTS_DOC_ID</code> カラムを定義しないと、<code class="literal">InnoDB</code> によって警告なしで、非表示の <code class="literal">FTS_DOC_ID</code> カラムが追加されます。 
      </p><p>
        <code class="literal">CREATE TABLE</code> 時に <code class="literal">FTS_DOC_ID</code> カラムを定義すると、すでにデータがロードされているテーブルに全文インデックスを作成するよりもコストがかかりません。 データをロードする前に、テーブル上に <code class="literal">FTS_DOC_ID</code> カラムが定義されている場合は、新しいカラムが追加されるようにテーブルおよびそのインデックスを再構築する必要がありません。 <code class="literal">CREATE FULLTEXT INDEX</code> のパフォーマンスに関心がない場合は、<code class="literal">InnoDB</code> で自動的に作成されるように、<code class="literal">FTS_DOC_ID</code> カラムを除外します。 <code class="literal">InnoDB</code> では、<code class="literal">FTS_DOC_ID</code> カラムに一意インデックス (<code class="literal">FTS_DOC_ID_INDEX</code>) とともに非表示の <code class="literal">FTS_DOC_ID</code> カラムが作成されます。 独自の <code class="literal">FTS_DOC_ID</code> カラムを作成する場合は、次の例のように、カラムを <code class="literal">BIGINT UNSIGNED NOT NULL</code> として定義し、<code class="literal">FTS_DOC_ID</code> (すべて大文字) という名前を付ける必要があります: 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">FTS_DOC_ID</code> カラムを <code class="literal">AUTO_INCREMENT</code> カラムとして定義する必要はありませんが、<code class="literal">AUTO_INCREMENT</code> を使用するとデータのロードが容易になります。
        </p></div><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE opening_lines (</code></strong>
       <strong class="userinput"><code>FTS_DOC_ID BIGINT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,</code></strong>
       <strong class="userinput"><code>opening_line TEXT(500),</code></strong>
       <strong class="userinput"><code>author VARCHAR(200),</code></strong>
       <strong class="userinput"><code>title VARCHAR(200)</code></strong>
       <strong class="userinput"><code>) ENGINE=InnoDB;</code></strong>
</pre><p>
        <code class="literal">FTS_DOC_ID</code> カラムをユーザー自身で定義するように決定した場合は、空の値や重複する値が回避されるようにカラムを管理することがユーザーの責任となります。 <code class="literal">FTS_DOC_ID</code> 値は再使用できません。つまり、<code class="literal">FTS_DOC_ID</code> 値は増加し続けます。 
      </p><p>
        オプションで、<code class="literal">FTS_DOC_ID</code> カラムに必要な一意の <code class="literal">FTS_DOC_ID_INDEX</code> (すべて大文字) を作成できます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE UNIQUE INDEX FTS_DOC_ID_INDEX on opening_lines(FTS_DOC_ID);</code></strong>
</pre><p>
        <code class="literal">FTS_DOC_ID_INDEX</code> を作成しない場合は、<code class="literal">InnoDB</code> によって自動的に作成されます。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">InnoDB</code> SQL パーサーは降順インデックスを使用しないため、<code class="literal">FTS_DOC_ID_INDEX</code> は降順インデックスとして定義できません。
        </p></div><p>
        最大使用 <code class="literal">FTS_DOC_ID</code> 値と新しい <code class="literal">FTS_DOC_ID</code> 値の間の許容ギャップは 65535 です。
      </p><p>
        テーブルの再構築を回避するために、全文インデックスの削除時に <code class="literal">FTS_DOC_ID</code> カラムが保持されます。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-fulltext-index-deletion"></a>InnoDB による全文インデックスの削除処理</h5></div></div></div><p>
        全文インデックスカラムを含むレコードを削除すると、補助インデックステーブルで多数の小さな削除が発生し、これらのテーブルへの同時アクセスが競合ポイントになる可能性があります。 この問題を回避するために、削除されたドキュメントのドキュメント ID (<code class="literal">DOC_ID</code>) は、インデックス付きテーブルからレコードが削除されるたびに特別な <code class="literal">FTS_*_DELETED</code> テーブルに記録され、インデックス付きレコードは全文インデックスに残ります。 クエリー結果を返す前に、<code class="literal">FTS_*_DELETED</code> テーブルの情報を使用して、削除されたドキュメント ID を除外します。 この設計の利点は、削除が高速で、低負荷であることです。 欠点は、レコードの削除後に、すぐにインデックスのサイズが削減されないことです。 削除されたレコードの全文インデックスエントリを削除するには、<code class="literal">innodb_optimize_fulltext_only=ON</code> を使用してインデックス付けされたテーブルで <code class="literal">OPTIMIZE TABLE</code> を実行し、全文インデックスを再構築します。 詳細は、<a class="xref" href="functions.html#fulltext-optimize" title="InnoDB 全文インデックスの最適化">InnoDB 全文インデックスの最適化</a>を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-fulltext-index-transaction"></a>InnoDB による全文インデックスのトランザクション処理</h5></div></div></div><p>
        <code class="literal">InnoDB</code> の <code class="literal">FULLTEXT</code> インデックスには、そのキャッシュおよびバッチ処理の動作のために、特別なトランザクション処理の特性が備わっています。 特に、<code class="literal">FULLTEXT</code> インデックス上の更新および挿入は、トランザクションのコミット時に処理されます。つまり、<code class="literal">FULLTEXT</code> 検索では、コミットされたデータのみを表示できます。 次の例で、この動作を実演します。 <code class="literal">FULLTEXT</code> 検索では、挿入された行がコミットされたあとにはじめて、結果が返されます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE opening_lines (</code></strong>
       <strong class="userinput"><code>id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,</code></strong>
       <strong class="userinput"><code>opening_line TEXT(500),</code></strong>
       <strong class="userinput"><code>author VARCHAR(200),</code></strong>
       <strong class="userinput"><code>title VARCHAR(200),</code></strong>
       <strong class="userinput"><code>FULLTEXT idx (opening_line)</code></strong>
       <strong class="userinput"><code>) ENGINE=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>BEGIN;</code></strong>

mysql&gt; <strong class="userinput"><code>INSERT INTO opening_lines(opening_line,author,title) VALUES</code></strong>
       <strong class="userinput"><code>('Call me Ishmael.','Herman Melville','Moby-Dick'),</code></strong>
       <strong class="userinput"><code>('A screaming comes across the sky.','Thomas Pynchon','Gravity\'s Rainbow'),</code></strong>
       <strong class="userinput"><code>('I am an invisible man.','Ralph Ellison','Invisible Man'),</code></strong>
       <strong class="userinput"><code>('Where now? Who now? When now?','Samuel Beckett','The Unnamable'),</code></strong>
       <strong class="userinput"><code>('It was love at first sight.','Joseph Heller','Catch-22'),</code></strong>
       <strong class="userinput"><code>('All this happened, more or less.','Kurt Vonnegut','Slaughterhouse-Five'),</code></strong>
       <strong class="userinput"><code>('Mrs. Dalloway said she would buy the flowers herself.','Virginia Woolf','Mrs. Dalloway'),</code></strong>
       <strong class="userinput"><code>('It was a pleasure to burn.','Ray Bradbury','Fahrenheit 451');</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT COUNT(*) FROM opening_lines WHERE MATCH(opening_line) AGAINST('Ishmael');</code></strong>
+----------+
| COUNT(*) |
+----------+
|        0 |
+----------+

mysql&gt; <strong class="userinput"><code>COMMIT;</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT COUNT(*) FROM opening_lines WHERE MATCH(opening_line) AGAINST('Ishmael');</code></strong>
+----------+
| COUNT(*) |
+----------+
|        1 |
+----------+
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-fulltext-index-monitoring"></a>InnoDB による全文インデックスのモニター</h5></div></div></div><a class="indexterm" name="idm44761363626144"></a><a class="indexterm" name="idm44761363624000"></a><p>
        次の <code class="literal">INFORMATION_SCHEMA</code> テーブルでクエリーを実行すると、<code class="literal">InnoDB</code> の <code class="literal">FULLTEXT</code> インデックスの特別なテキスト処理の側面をモニターおよび調査できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">INNODB_FT_CONFIG</code>
          </p></li><li class="listitem"><p>
            <code class="literal">INNODB_FT_INDEX_TABLE</code>
          </p></li><li class="listitem"><p>
            <code class="literal">INNODB_FT_INDEX_CACHE</code>
          </p></li><li class="listitem"><p>
            <code class="literal">INNODB_FT_DEFAULT_STOPWORD</code>
          </p></li><li class="listitem"><p>
            <code class="literal">INNODB_FT_DELETED</code>
          </p></li><li class="listitem"><p>
            <code class="literal">INNODB_FT_BEING_DELETED</code>
          </p></li></ul></div><p>
        <code class="literal">INNODB_INDEXES</code> および <code class="literal">INNODB_TABLES</code> をクエリーして、<code class="literal">FULLTEXT</code> のインデックスおよびテーブルの基本情報を表示することもできます。
      </p><p>
        詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-information-schema-fulltext_index-tables" title="15.15.4 InnoDB INFORMATION_SCHEMA FULLTEXT インデックステーブル">セクション15.15.4「InnoDB INFORMATION_SCHEMA FULLTEXT インデックステーブル」</a>を参照してください。
      </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-tablespace"></a>15.6.3 テーブルスペース</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-system-tablespace">15.6.3.1 システムテーブルスペース</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-per-table-tablespaces">15.6.3.2 File-Per-Table テーブルスペース</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#general-tablespaces">15.6.3.3 一般テーブルスペース</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-undo-tablespaces">15.6.3.4 undo テーブルスペース</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-temporary-tablespace">15.6.3.5 一時テーブルスペース</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-moving-data-files-offline">15.6.3.6 サーバーがオフラインのときのテーブルスペースファイルの移動</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-disabling-tablespace-path-validation">15.6.3.7 テーブルスペースパス検証の無効化</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-optimize-tablespace-page-allocation">15.6.3.8 Linux でのテーブルスペースの領域割当ての最適化</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-tablespace-autoextend-size">15.6.3.9 テーブルスペースの AUTOEXTEND_SIZE 構成</a></span></dt></dl></div><p>
    このセクションでは、<code class="literal">InnoDB</code> テーブルスペースに関連するトピックについて説明します。
  </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-system-tablespace"></a>15.6.3.1 システムテーブルスペース</h4></div></div></div><p>
      システムテーブルスペースは、変更バッファの記憶域です。 file-per-table または一般的なテーブルスペースではなく system テーブルスペースにテーブルが作成されている場合は、テーブルおよびインデックスデータが含まれることもあります。 以前のバージョンの MySQL では、システムテーブルスペースに <code class="literal">InnoDB</code> データディクショナリが含まれていました。 MySQL 8.0 では、<code class="literal">InnoDB</code> は MySQL データディクショナリにメタデータを格納します。 <a class="xref" href="data-dictionary.html" title="第 14 章 MySQL データディクショナリ">第14章「<i>MySQL データディクショナリ</i>」</a>を参照してください。 以前の MySQL リリースでは、システムテーブルスペースに二重書込みバッファ記憶域も含まれていました。 この記憶域は、MySQL 8.0.20 の時点で別々の二重書込みファイルに存在します。 <a class="xref" href="innodb-storage-engine.html#innodb-doublewrite-buffer" title="15.6.4 二重書き込みバッファー">セクション15.6.4「二重書き込みバッファー」</a>を参照してください。 
    </p><p>
      システムテーブルスペースには、1 つ以上のデータファイルを含めることができます。 デフォルトでは、<code class="filename">ibdata1</code> という名前の単一のシステムテーブルスペースデータファイルがデータディレクトリに作成されます。 システムテーブルスペースデータファイルのサイズと数は、<code class="literal">innodb_data_file_path</code> 起動オプションによって定義されます。 構成情報については、<a class="xref" href="innodb-storage-engine.html#innodb-startup-data-file-configuration" title="システムテーブルスペースデータファイル構成">システムテーブルスペースデータファイル構成</a> を参照してください。 
    </p><p>
      システムテーブルスペースの詳細は、このセクションの次のトピックを参照してください:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-resize-system-tablespace" title="システムテーブルスペースのサイズ変更">システムテーブルスペースのサイズ変更</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-raw-devices" title="システムテーブルスペースに対する RAW ディスクパーティションの使用">システムテーブルスペースに対する RAW ディスクパーティションの使用</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-resize-system-tablespace"></a>システムテーブルスペースのサイズ変更</h5></div></div></div><a class="indexterm" name="idm44761363588080"></a><p>
        このセクションでは、システムテーブルスペースのサイズを増減する方法について説明します。
      </p><h6><a name="idm44761363585536"></a>システムテーブルスペースのサイズの増加</h6><p>
        システムテーブルスペースのサイズを増やす最も簡単な方法は、自動拡張するように構成することです。 これを行うには、<code class="literal">innodb_data_file_path</code> 設定で最後のデータファイルの <code class="literal">autoextend</code> 属性を指定し、サーバーを再起動します。 例: 
      </p><pre class="programlisting">innodb_data_file_path=ibdata1:10M:autoextend
</pre><p>
        <code class="literal">autoextend</code> 属性が指定されている場合、データファイルのサイズは、領域が必要になると 8MB ずつ自動的に増加します。 <code class="literal">innodb_autoextend_increment</code> 変数は増分サイズを制御します。 
      </p><p>
        別のデータファイルを追加して、システムテーブルスペースのサイズを増やすこともできます。 これを行うには: 
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            MySQL  Server を停止させます。
          </p></li><li class="listitem"><p>
            <code class="literal">innodb_data_file_path</code> 設定の最後のデータファイルが <code class="literal">autoextend</code> 属性で定義されている場合は、それを削除し、現在のデータファイルサイズを反映するように size 属性を変更します。 指定する適切なデータファイルサイズを決定するには、ファイルシステムでファイルサイズを確認し、その値を最も近い MB 値 (MB は 1024 x 1024) に切り捨てます。 
          </p></li><li class="listitem"><p>
            <code class="literal">innodb_data_file_path</code> 設定に新しいデータファイルを追加し、オプションで <code class="literal">autoextend</code> 属性を指定します。 <code class="literal">autoextend</code> 属性は、<code class="literal">innodb_data_file_path</code> 設定の最後のデータファイルに対してのみ指定できます。 
          </p></li><li class="listitem"><p>
            MySQL Server を起動する
          </p></li></ol></div><p>
        たとえば、このテーブルスペースには自動拡張データファイルが 1 つあります:
      </p><pre class="programlisting">innodb_data_home_dir =
innodb_data_file_path = /ibdata/ibdata1:10M:autoextend
</pre><p>
        データファイルが時間の経過とともに 988MB に増加したとします。 これは、現在のデータファイルサイズを反映するように size 属性を変更した後、および新しい 50MB の自動拡張データファイルを指定した後の <code class="literal">innodb_data_file_path</code> 設定です: 
      </p><pre class="programlisting">innodb_data_home_dir =
innodb_data_file_path = /ibdata/ibdata1:988M;/disk2/ibdata2:50M:autoextend
</pre><p>
        新しいデータファイルを追加する場合は、既存のファイル名を指定しないでください。 <code class="literal">InnoDB</code> では、サーバーの起動時に新しいデータファイルが作成され、初期化されます。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          size 属性を変更して、既存のシステムテーブルスペースデータファイルのサイズを増やすことはできません。 たとえば、<code class="literal">innodb_data_file_path</code> 設定を <code class="literal">ibdata1:10M:autoextend</code> から <code class="literal">ibdata1:12M:autoextend</code> に変更すると、サーバーの起動時に次のエラーが発生します: 
        </p><pre class="programlisting">[ERROR] [MY-012263] [InnoDB] The Auto-extending innodb_system
data file './ibdata1' is of a different size 640 pages (rounded down to MB) than
specified in the .cnf file: initial 768 pages, max 0 (relevant if non-zero) pages!
</pre><p>
          このエラーは、既存のデータファイルサイズ (<code class="literal">InnoDB</code> ページで表示) が構成ファイルで指定されたサイズと異なることを示しています。 このエラーが発生した場合は、以前の <code class="literal">innodb_data_file_path</code> 設定をリストアし、システムテーブルスペースのサイズ変更手順を参照してください。 
        </p><p>
          <code class="literal">InnoDB</code> のページサイズは、<code class="literal">innodb_page_size</code> 変数によって定義されます。 デフォルトは 16384 バイトです。 
        </p></div><h6><a name="idm44761363551152"></a>InnoDB システムテーブルスペースのサイズの縮小</h6><p>
        既存のシステムテーブルスペースのサイズの縮小はサポートされていません。 小さいシステムテーブルスペースを実現する唯一のオプションは、バックアップから目的のシステムテーブルスペース構成で作成された新しい MySQL インスタンスにデータをリストアすることです。 
      </p><p>
        バックアップの作成の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-backup" title="15.18.1 InnoDB バックアップ">セクション15.18.1「InnoDB バックアップ」</a> を参照してください。
      </p><p>
        新しいシステムテーブルスペースのデータファイルの構成の詳細。 <a class="xref" href="innodb-storage-engine.html#innodb-startup-data-file-configuration" title="システムテーブルスペースデータファイル構成">システムテーブルスペースデータファイル構成</a>を参照してください。 
      </p><p>
        大規模なシステムテーブルスペースを回避するには、データに file-per-table テーブルスペースを使用することを検討してください。 File-per-table テーブルスペースはデフォルトのテーブルスペースタイプで、<code class="literal">InnoDB</code> テーブルの作成時に暗黙的に使用されます。 システムテーブルスペースとは異なり、file-per-table テーブルスペースで作成されたテーブルを切り捨てたり削除すると、ディスク領域がオペレーティングシステムに戻されます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-file-per-table-tablespaces" title="15.6.3.2 File-Per-Table テーブルスペース">セクション15.6.3.2「File-Per-Table テーブルスペース」</a>を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-raw-devices"></a>システムテーブルスペースに対する RAW ディスクパーティションの使用</h5></div></div></div><a class="indexterm" name="idm44761363542480"></a><a class="indexterm" name="idm44761363540320"></a><p>
        <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>では、データファイルとして RAW ディスクパーティションを使用できます。 この方法を使用すると、ファイルシステムのオーバーヘッドが発生せずに、Windows 上および一部の Linux と Unix 上でバッファーに入れられない I/O が有効になります。 RAW パーティションを使用する場合と使用しない場合でテストを実行して、この変更によって実際にシステム上のパフォーマンスが改善されるかどうかを確認します。 
      </p><p>
        RAW ディスクパーティションを使用する場合は、MySQL サーバーを実行しているユーザー ID がそのパーティションに対する読み取り権限および書き込み権限を持っていることを確認します。 たとえば、<code class="literal">mysql</code> ユーザーとしてサーバーを実行する場合は、そのパーティションが <code class="literal">mysql</code> によって読み取り可能および書き込み可能である必要があります。 <code class="option">--memlock</code> オプションを付けてサーバーを実行する場合は、サーバーを <code class="literal">root</code> として実行する必要があるため、パーティションが <code class="literal">root</code> によって読み取り可能および書き込み可能である必要があります。 
      </p><p>
        次で説明する手順には、オプションファイルの変更が伴います。 追加情報については、<a class="xref" href="programs.html#option-files" title="4.2.2.2 オプションファイルの使用">セクション4.2.2.2「オプションファイルの使用」</a>を参照してください。 
      </p><h6><a name="idm44761363529040"></a>Linux および Unix システムでの RAW ディスクパーティションの割り当て</h6><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            新しいデータファイルを作成する際は、<code class="literal">innodb_data_file_path</code> オプションのデータファイルサイズの直後に、<code class="literal">newraw</code> というキーワードを指定します。 パーティションは、少なくとも指定したサイズと同じである必要があります。 ディスク指定の 1M バイトは通常 1,000,000 バイトを意味するのに対して、<code class="literal">InnoDB</code> 内の 1M バイトは 1024 × 1024 バイトであることに注意してください。 
          </p><pre class="programlisting">[mysqld]
innodb_data_home_dir=
innodb_data_file_path=/dev/hdd1:3Gnewraw;/dev/hdd2:2Gnewraw
</pre></li><li class="listitem"><p>
            サーバーを再起動します。 <code class="literal">InnoDB</code> によって <code class="literal">newraw</code> キーワードが認識され、新しいパーティションが初期化されます。 ただし、まだ <code class="literal">InnoDB</code> テーブルを作成したり変更したりしないでください。 そうしなければ、サーバーを次に再起動したときに <code class="literal">InnoDB</code> によってパーティションが再初期化され、変更がすべて失われます。 (安全策として、<code class="literal">InnoDB</code> では、<code class="literal">newraw</code> を含むパーティションが指定されたときにユーザーがデータを更新することが回避されます。) 
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> によって新しいパーティションが初期化されたら、サーバーを停止し、データファイルの指定で <code class="literal">newraw</code> を <code class="literal">raw</code> に変更します。
          </p><pre class="programlisting">[mysqld]
innodb_data_home_dir=
innodb_data_file_path=/dev/hdd1:3Graw;/dev/hdd2:2Graw
</pre></li><li class="listitem"><p>
            サーバーを再起動します。 これにより、<code class="literal">InnoDB</code> で変更を行うことが許可されます。 
          </p></li></ol></div><h6><a name="idm44761363509760"></a>Windows での RAW ディスクパーティションの割り当て</h6><p>
        Windows システムでは、Linux および Unix システムで説明したものと同じ手順および付随するガイドラインが適用されます。ただし、Windows では <code class="literal">innodb_data_file_path</code> の設定がわずかに異なります。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            新しいデータファイルを作成する際は、<code class="literal">innodb_data_file_path</code> オプションのデータファイルサイズの直後に、<code class="literal">newraw</code> というキーワードを指定します。
          </p><pre class="programlisting">[mysqld]
innodb_data_home_dir=
innodb_data_file_path=//./D::10Gnewraw
</pre><p>
            <code class="filename">//./</code> は、物理ドライブにアクセスするための Windows の構文 <code class="filename">\\.\</code> に対応しています。 前述の例では、<code class="literal">D:</code> がパーティションのドライブ文字です。 
          </p></li><li class="listitem"><p>
            サーバーを再起動します。 <code class="literal">InnoDB</code> によって <code class="literal">newraw</code> キーワードが認識され、新しいパーティションが初期化されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> によって新しいパーティションが初期化されたら、サーバーを停止し、データファイルの指定で <code class="literal">newraw</code> を <code class="literal">raw</code> に変更します。
          </p><pre class="programlisting">[mysqld]
innodb_data_home_dir=
innodb_data_file_path=//./D::10Graw
</pre></li><li class="listitem"><p>
            サーバーを再起動します。 これにより、<code class="literal">InnoDB</code> で変更を行うことが許可されます。 
          </p></li></ol></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-file-per-table-tablespaces"></a>15.6.3.2 File-Per-Table テーブルスペース</h4></div></div></div><a class="indexterm" name="idm44761363489520"></a><a class="indexterm" name="idm44761363487344"></a><p>
      file-per-table テーブルスペースには、単一の <code class="literal">InnoDB</code> テーブルのデータとインデックスが含まれ、ファイルシステム上の独自のデータファイルに格納されます。
    </p><p>
      File-per-table テーブルスペースの特性については、このセクションの次のトピックで説明します:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-file-per-table-configuration" title="File-Per-Table テーブルスペースの構成">File-Per-Table テーブルスペースの構成</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-file-per-table-data-files" title="File-Per-Table テーブルスペースデータファイル">File-Per-Table テーブルスペースデータファイル</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-file-per-table-advantages" title="テーブルスペースごとのファイルの利点">テーブルスペースごとのファイルの利点</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-file-per-table-disadvantages" title="File-Per-Table テーブルスペースのデメリット">File-Per-Table テーブルスペースのデメリット</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-file-per-table-configuration"></a>File-Per-Table テーブルスペースの構成</h5></div></div></div><p>
        <code class="literal">InnoDB</code> は、デフォルトで file-per-table テーブルスペースにテーブルを作成します。 この動作は、<code class="literal">innodb_file_per_table</code> 変数によって制御されます。 <code class="literal">innodb_file_per_table</code> を無効にすると、<code class="literal">InnoDB</code> によってシステムテーブルスペースにテーブルが作成されます。 
      </p><p>
        <code class="literal">innodb_file_per_table</code> 設定は、オプションファイルで指定するか、<code class="literal">SET GLOBAL</code> ステートメントを使用して実行時に構成できます。 実行時に設定を変更するには、グローバルシステム変数を設定するのに十分な権限が必要です。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 
      </p><p>
        オプションファイル:
      </p><pre class="programlisting">[mysqld]
innodb_file_per_table=ON
</pre><p>
        実行時の <code class="literal">SET GLOBAL</code> の使用:
      </p><pre class="programlisting">mysql&gt; SET GLOBAL innodb_file_per_table=ON;
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-file-per-table-data-files"></a>File-Per-Table テーブルスペースデータファイル</h5></div></div></div><p>
        file-per-table テーブルスペースは、MySQL データディレクトリの下のスキーマディレクトリにある <code class="filename">.idb</code> データファイルに作成されます。 <code class="filename">.ibd</code> ファイルには、テーブル (<code class="filename"><em class="replaceable"><code>table_name</code></em>.ibd</code>) の名前が付けられます。 たとえば、テーブル <code class="literal">test.t1</code> のデータファイルは、MySQL データディレクトリの下の <code class="filename">test</code> ディレクトリに作成されます: 
      </p><pre class="programlisting">mysql&gt; USE test;

mysql&gt; CREATE TABLE t1 (
   id INT PRIMARY KEY AUTO_INCREMENT,
   name VARCHAR(100)
 ) ENGINE = InnoDB;

shell&gt; cd /<em class="replaceable"><code>path</code></em>/<em class="replaceable"><code>to</code></em>/<em class="replaceable"><code>mysql</code></em>/data/test
shell&gt; ls
t1.ibd
</pre><p>
        <code class="literal">CREATE TABLE</code> ステートメントの <code class="literal">DATA DIRECTORY</code> 句を使用して、データディレクトリ外にファイルごとのテーブルスペースデータファイルを暗黙的に作成できます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-create-table-external" title="15.6.1.2 外部でのテーブルの作成">セクション15.6.1.2「外部でのテーブルの作成」</a>を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-file-per-table-advantages"></a>テーブルスペースごとのファイルの利点</h5></div></div></div><p>
        File-per-table テーブルスペースには、システムテーブルスペースや一般テーブルスペースなどの共有テーブルスペースに比べて次の利点があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            file-per-table テーブルスペースで作成されたテーブルを切り捨てるか削除すると、ディスク領域がオペレーティングシステムに戻されます。 共有テーブルスペースに格納されているテーブルを切り捨てるか削除すると、共有テーブルスペースデータファイル内に空き領域が作成され、これは <code class="literal">InnoDB</code> データにのみ使用できます。 つまり、テーブルの切捨てまたは削除後、共有テーブルスペースデータファイルのサイズは縮小されません。 
          </p></li><li class="listitem"><p>
            共有テーブルスペースに存在するテーブルに対するテーブルコピー <code class="literal">ALTER TABLE</code> 操作では、テーブルスペースが占有するディスク領域の量を増やすことができます。 このような操作には、テーブル内のデータとインデックスの追加領域が必要になる場合があります。 この領域は file-per-table テーブルスペース用であるため、オペレーティングシステムに解放されません。 
          </p></li><li class="listitem"><p>
            file-per-table テーブルスペースに存在するテーブルで実行すると、<code class="literal">TRUNCATE TABLE</code> のパフォーマンスが向上します。
          </p></li><li class="listitem"><p>
            File-per-table テーブルスペースデータファイルは、I/O の最適化、領域管理またはバックアップのために、別々のストレージデバイスに作成できます。 <a class="xref" href="innodb-storage-engine.html#innodb-create-table-external" title="15.6.1.2 外部でのテーブルの作成">セクション15.6.1.2「外部でのテーブルの作成」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            file-per-table テーブルスペースに存在するテーブルを別の MySQL インスタンスからインポートできます。 <a class="xref" href="innodb-storage-engine.html#innodb-table-import" title="15.6.1.3 InnoDB テーブルのインポート">セクション15.6.1.3「InnoDB テーブルのインポート」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            file-per-table テーブルスペースで作成されたテーブルは、システムテーブルスペースでサポートされていない <code class="literal">DYNAMIC</code> および <code class="literal">COMPRESSED</code> の行フォーマットに関連付けられた機能をサポートします。 <a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="15.10 InnoDB の行フォーマット">セクション15.10「InnoDB の行フォーマット」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            個々のテーブルスペースデータファイルに格納されたテーブルでは、データ破損が発生した場合、バックアップまたはバイナリログが使用できない場合、または MySQL サーバーインスタンスを再起動できない場合に、時間を節約し、リカバリが成功する可能性を向上させることができます。
          </p></li><li class="listitem"><p>
            MySQL Enterprise Backup を使用すると、他の <code class="literal">InnoDB</code> テーブルの使用を中断することなく、file-per-table テーブルスペースに作成されたテーブルを迅速にバックアップまたはリストアできます。 これは、様々なバックアップスケジュールに関するテーブルや、バックアップの頻度が低いテーブルに役立ちます。 詳細は、<a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/8.0/en/partial.html" target="_top">Making a Partial Backup</a> を参照してください。 
          </p></li><li class="listitem"><p>
            File-per-table テーブルスペースでは、テーブルスペースデータファイルのサイズをモニタリングすることによって、ファイルシステム上のテーブルサイズをモニタリングできます。
          </p></li><li class="listitem"><p>
            <code class="literal">innodb_flush_method</code> が <code class="literal">O_DIRECT</code> に設定されている場合、共通の Linux ファイルシステムでは、共有テーブルスペースデータファイルなどの単一ファイルへの同時書込みは許可されません。 その結果、file-per-table テーブルスペースをこの設定と組み合わせて使用すると、パフォーマンスが向上する可能性があります。 
          </p></li><li class="listitem"><p>
            共有テーブルスペース内のテーブルのサイズは、64TB のテーブルスペースサイズ制限によって制限されます。 比較すると、各 file-per-table テーブルスペースには 64TB のサイズ制限があり、個々のテーブルのサイズを大きくするための十分な容量が提供されます。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-file-per-table-disadvantages"></a>File-Per-Table テーブルスペースのデメリット</h5></div></div></div><p>
        File-per-table テーブルスペースには、システムテーブルスペースや一般テーブルスペースなどの共有テーブルスペースと比較して、次のデメリットがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            file-per-table テーブルスペースでは、同じテーブルの行によってのみ利用できる未使用の領域が各テーブルに存在する可能性があるため、適切に管理されていない場合は領域が無駄になる可能性があります。
          </p></li><li class="listitem"><p>
            <code class="literal">fsync</code> 操作は、単一の共有テーブルスペースデータファイルではなく、複数のファイルごとのデータファイルに対して実行されます。 <code class="literal">fsync</code> 操作はファイル単位であるため、複数のテーブルに対する書込み操作を組み合せることはできないため、<code class="literal">fsync</code> 操作の合計数が増加する可能性があります。 
          </p></li><li class="listitem"><p>
            <span class="command"><strong>mysqld</strong></span> では、file-per-table テーブルスペースごとにオープンファイルハンドルを保持する必要があります。file-per-table テーブルスペースに多数のテーブルがある場合、パフォーマンスに影響する可能性があります。
          </p></li><li class="listitem"><p>
            各テーブルに独自のデータファイルがある場合は、さらにファイル記述子が必要です。
          </p></li><li class="listitem"><p>
            断片化が増える可能性があるため、<code class="literal">DROP TABLE</code> およびテーブルスキャンのパフォーマンスが低下する可能性があります。 ただし、断片化が管理されている場合、file-per-table テーブルスペースを使用すると、これらの操作のパフォーマンスを向上させることができます。 
          </p></li><li class="listitem"><p>
            file-per-table テーブルスペースに存在するテーブルを削除すると、バッファープールがスキャンされます。これは、バッファープールが大きい場合には数秒かかることがあります。 スキャンは広範囲に内部ロックをかけて実行されるため、他の操作を遅らせる場合があります。 
          </p></li><li class="listitem"><p>
            自動拡張共有テーブルスペースファイルがいっぱいになったときにそのサイズを拡張する増分サイズを定義する <code class="literal">innodb_autoextend_increment</code> 変数は、<code class="literal">innodb_autoextend_increment</code> 設定に関係なく自動拡張される file-per-table テーブルスペースファイルには適用されません。 初期 file-per-table テーブルスペース拡張は少量であり、その後、拡張は 4MB 単位で行われます。 
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="general-tablespaces"></a>15.6.3.3 一般テーブルスペース</h4></div></div></div><p>
      一般的なテーブルスペースは、<code class="literal">CREATE TABLESPACE</code> 構文を使用して作成される共有 <code class="literal">InnoDB</code> テーブルスペースです。 テーブルスペースの一般的な機能については、このセクションの次のトピックで説明します: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#general-tablespaces-capabilities" title="一般的なテーブルスペース機能">一般的なテーブルスペース機能</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#general-tablespaces-creating" title="一般的なテーブルスペースの作成">一般的なテーブルスペースの作成</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#general-tablespaces-adding-tables" title="一般テーブルスペースへのテーブルの追加">一般テーブルスペースへのテーブルの追加</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#general-tablespaces-row-format-support" title="一般的なテーブルスペースの行形式のサポート">一般的なテーブルスペースの行形式のサポート</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#general-tablespaces-moving-non-partitioned-tables" title="ALTER TABLE を使用したテーブルスペース間のテーブルの移動">ALTER TABLE を使用したテーブルスペース間のテーブルの移動</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#general-tablespaces-renaming" title="一般テーブルスペースの名前の変更">一般テーブルスペースの名前の変更</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#general-tablespaces-dropping" title="一般テーブルスペースの削除">一般テーブルスペースの削除</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#general-tablespaces-limitations" title="テーブルスペースの一般的な制限事項">テーブルスペースの一般的な制限事項</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="general-tablespaces-capabilities"></a>一般的なテーブルスペース機能</h5></div></div></div><p>
        一般的なテーブルスペース機能には、次の機能があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            システムテーブルスペースと同様に、一般テーブルスペースは、複数のテーブルのデータを格納できる共有テーブルスペースです。
          </p></li><li class="listitem"><p>
            一般的なテーブルスペースには、<a class="link" href="innodb-storage-engine.html#innodb-file-per-table-tablespaces" title="15.6.3.2 File-Per-Table テーブルスペース">file-per-table tablespaces</a> よりも潜在的なメモリー上の利点があります。 サーバーは、テーブルスペースの存続期間中、テーブルスペースメタデータをメモリーに保持します。 一般的なテーブルスペースが少ない複数のテーブルは、個別の file-per-table テーブルスペース内の同じ数のテーブルよりも、テーブルスペースメタデータのメモリー消費量が少なくなります。 
          </p></li><li class="listitem"><p>
            一般的なテーブルスペースデータファイルは、MySQL データディレクトリに対して相対的または独立したディレクトリに配置できます。これにより、<a class="link" href="innodb-storage-engine.html#innodb-file-per-table-tablespaces" title="15.6.3.2 File-Per-Table テーブルスペース">file-per-table tablespaces</a> のデータファイルおよび記憶域管理機能の多くが提供されます。 file-per-table テーブルスペースと同様に、MySQL データディレクトリ外にデータファイルを配置する機能を使用すると、重要なテーブルのパフォーマンスを個別に管理したり、特定のテーブル用に RAID または DRBD を設定したり、テーブルを特定のディスクにバインドしたりできます。 
          </p></li><li class="listitem"><p>
            一般テーブルスペースでは、すべてのテーブルの行フォーマットおよび関連機能がサポートされています。
          </p></li><li class="listitem"><p>
            <code class="literal">TABLESPACE</code> オプションを <code class="literal">CREATE TABLE</code> とともに使用すると、一般的なテーブルスペース、file-per-table テーブルスペースまたは system テーブルスペースにテーブルを作成できます。
          </p></li><li class="listitem"><p>
            <code class="literal">TABLESPACE</code> オプションを <code class="literal">ALTER TABLE</code> とともに使用すると、一般的なテーブルスペース、file-per-table テーブルスペースおよびシステムテーブルスペース間でテーブルを移動できます。 以前は、file-per-table テーブルスペースから system テーブルスペースにテーブルを移動できませんでした。 一般テーブルスペース機能を使用して、これを実行できるようになりました。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="general-tablespaces-creating"></a>一般的なテーブルスペースの作成</h5></div></div></div><p>
        一般テーブルスペースは、<code class="literal">CREATE TABLESPACE</code> 構文を使用して作成されます。
      </p><pre class="programlisting">CREATE TABLESPACE <em class="replaceable"><code>tablespace_name</code></em>
    [ADD DATAFILE '<em class="replaceable"><code>file_name</code></em>']
    [FILE_BLOCK_SIZE = <em class="replaceable"><code>value</code></em>]
        [ENGINE [=] <em class="replaceable"><code>engine_name</code></em>]</pre><p>
        一般的なテーブルスペースは、データディレクトリ内またはその外部に作成できます。 暗黙的に作成された file-per-table テーブルスペースとの競合を回避するために、データディレクトリの下のサブディレクトリに一般テーブルスペースを作成することはサポートされていません。 データディレクトリ外に一般的なテーブルスペースを作成する場合、そのディレクトリが存在し、テーブルスペースを作成する前に <code class="literal">InnoDB</code> で認識されている必要があります。 不明なディレクトリを <code class="literal">InnoDB</code> で認識できるようにするには、ディレクトリを <code class="literal">innodb_directories</code> 引数値に追加します。<code class="literal">innodb_directories</code> は読取り専用の起動オプションです。 構成するには、サーバーを再起動する必要があります。 
      </p><p>
        例:
      </p><p>
        データディレクトリに一般的なテーブルスペースを作成します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts1` ADD DATAFILE 'ts1.ibd' Engine=InnoDB;</code></strong>
</pre><p>
        または
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts1` Engine=InnoDB;</code></strong>
</pre><p>
        <code class="literal">ADD DATAFILE</code> 句は、MySQL 8.0.14 の時点ではオプションであり、その前に必要です。 テーブルスペースの作成時に <code class="literal">ADD DATAFILE</code> 句が指定されていない場合、一意のファイル名を持つテーブルスペースデータファイルが暗黙的に作成されます。 一意のファイル名は、ダッシュ (<em class="replaceable"><code>aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee</code></em>) で区切られた 16 進数の 5 つのグループにフォーマットされた 128 ビット UUID です。 一般的なテーブルスペースデータファイルには、<code class="filename">.ibd</code> ファイル拡張子が含まれます。 レプリケーション環境では、ソースで作成されたデータファイル名は、レプリカで作成されたデータファイル名と同じではありません。 
      </p><p>
        データディレクトリ外のディレクトリに一般テーブルスペースを作成します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts1` ADD DATAFILE '/my/tablespace/directory/ts1.ibd' Engine=InnoDB;</code></strong>
</pre><p>
        テーブルスペースディレクトリがデータディレクトリの下にないかぎり、データディレクトリへの相対パスを指定できます。 この例では、<code class="filename">my_tablespace</code> ディレクトリはデータディレクトリと同じレベルにあります: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts1` ADD DATAFILE '../my_tablespace/ts1.ibd' Engine=InnoDB;</code></strong>
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">ENGINE = InnoDB</code> 句を <code class="literal">CREATE TABLESPACE</code> ステートメントの一部として定義するか、<code class="literal">InnoDB</code> をデフォルトのストレージエンジン (<code class="literal">default_storage_engine=InnoDB</code>) として定義する必要があります。
        </p></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="general-tablespaces-adding-tables"></a>一般テーブルスペースへのテーブルの追加</h5></div></div></div><p>
        <code class="literal">InnoDB</code> の一般テーブルスペースを作成した後、次の例に示すように、<code class="literal">CREATE TABLE <em class="replaceable"><code>tbl_name</code></em> ... TABLESPACE [=] <em class="replaceable"><code>tablespace_name</code></em></code> または <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> TABLESPACE [=] <em class="replaceable"><code>tablespace_name</code></em></code> を使用してテーブルスペースにテーブルを追加できます:
      </p><p>
        <code class="literal">CREATE TABLE</code>:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts1;</code></strong>
</pre><p>
        <code class="literal">ALTER TABLE</code>:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE t2 TABLESPACE ts1;</code></strong>
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          共有テーブルスペースへのテーブルパーティションの追加のサポートは、MySQL 5.7.24 で非推奨になり、MySQL 8.0.13 で削除されました。 共有テーブルスペースには、<code class="literal">InnoDB</code> システムテーブルスペースおよび一般テーブルスペースが含まれます。 
        </p></div><p>
        構文の詳細は、<code class="literal">CREATE TABLE</code> および <code class="literal">ALTER TABLE</code> を参照してください。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="general-tablespaces-row-format-support"></a>一般的なテーブルスペースの行形式のサポート</h5></div></div></div><p>
        一般テーブルスペースでは、物理ページサイズが異なるために圧縮テーブルと非圧縮テーブルを同じ一般テーブルスペースに共存できないという注意事項があるすべてのテーブルの行形式 (<code class="literal">REDUNDANT</code>, <code class="literal">COMPACT</code>, <code class="literal">DYNAMIC</code>, <code class="literal">COMPRESSED</code>) がサポートされています。
      </p><p>
        一般的なテーブルスペースに圧縮テーブル (<code class="literal">ROW_FORMAT=COMPRESSED</code>) を含めるには、<code class="literal">FILE_BLOCK_SIZE</code> を指定する必要があり、<code class="literal">FILE_BLOCK_SIZE</code> 値は <code class="literal">innodb_page_size</code> 値と比較した有効な圧縮ページサイズである必要があります。 また、圧縮テーブル (<code class="literal">KEY_BLOCK_SIZE</code>) の物理ページサイズは <code class="literal">FILE_BLOCK_SIZE/1024</code> と同じである必要があります。 たとえば、<code class="literal">innodb_page_size=16KB</code> および <code class="literal">FILE_BLOCK_SIZE=8K</code> の場合、テーブルの <code class="literal">KEY_BLOCK_SIZE</code> は 8 である必要があります。 
      </p><p>
        次のテーブルに、許可される <code class="literal">innodb_page_size</code>、<code class="literal">FILE_BLOCK_SIZE</code> および <code class="literal">KEY_BLOCK_SIZE</code> の組合せを示します。 <code class="literal">FILE_BLOCK_SIZE</code> 値はバイト単位で指定することもできます。 特定の <code class="literal">FILE_BLOCK_SIZE</code> に対して有効な <code class="literal">KEY_BLOCK_SIZE</code> 値を決定するには、<code class="literal">FILE_BLOCK_SIZE</code> 値を 1024 で除算します。 テーブル圧縮では、32K および 64K の <code class="literal">InnoDB</code> ページサイズはサポートされていません。 <code class="literal">KEY_BLOCK_SIZE</code> の詳細は、<code class="literal">CREATE TABLE</code> および <a class="xref" href="innodb-storage-engine.html#innodb-compression-usage" title="15.9.1.2 圧縮テーブルの作成">セクション15.9.1.2「圧縮テーブルの作成」</a> を参照してください。 
      </p><div class="table"><a name="idm44761363309776"></a><p class="title"><b>表 15.3 圧縮テーブルで許可されるページサイズ、FILE_BLOCK_SIZE および KEY_BLOCK_SIZE の組合せ</b></p><div class="table-contents"><table frame="all"><col style="width: 33%"><col style="width: 33%"><col style="width: 34%"><thead><tr>
            <th scope="col">InnoDB ページサイズ (innodb_page_size)</th>
            <th scope="col">許可される FILE_BLOCK_SIZE 値</th>
            <th scope="col">許可される KEY_BLOCK_SIZE 値</th>
          </tr></thead><tbody><tr>
            <th scope="row">64KB</th>
            <td>64K (65536)</td>
            <td>圧縮はサポートされません</td>
          </tr><tr>
            <th scope="row">32KB</th>
            <td>32K (32768)</td>
            <td>圧縮はサポートされません</td>
          </tr><tr>
            <th scope="row">16KB</th>
            <td>16K (16384)</td>
            <td>N/A: <code class="literal">innodb_page_size</code> が <code class="literal">FILE_BLOCK_SIZE</code> と等しい場合、テーブルスペースに圧縮テーブルを含めることはできません。</td>
          </tr><tr>
            <th scope="row">16KB</th>
            <td>8K (8192)</td>
            <td>8</td>
          </tr><tr>
            <th scope="row">16KB</th>
            <td>4K (4096)</td>
            <td>4</td>
          </tr><tr>
            <th scope="row">16KB</th>
            <td>2K (2048)</td>
            <td>2</td>
          </tr><tr>
            <th scope="row">16KB</th>
            <td>1K (1024)</td>
            <td>1</td>
          </tr><tr>
            <th scope="row">8KB</th>
            <td>8K (8192)</td>
            <td>N/A: <code class="literal">innodb_page_size</code> が <code class="literal">FILE_BLOCK_SIZE</code> と等しい場合、テーブルスペースに圧縮テーブルを含めることはできません。</td>
          </tr><tr>
            <th scope="row">8KB</th>
            <td>4K (4096)</td>
            <td>4</td>
          </tr><tr>
            <th scope="row">8KB</th>
            <td>2K (2048)</td>
            <td>2</td>
          </tr><tr>
            <th scope="row">8KB</th>
            <td>1K (1024)</td>
            <td>1</td>
          </tr><tr>
            <th scope="row">4KB</th>
            <td>4K (4096)</td>
            <td>N/A: <code class="literal">innodb_page_size</code> が <code class="literal">FILE_BLOCK_SIZE</code> と等しい場合、テーブルスペースに圧縮テーブルを含めることはできません。</td>
          </tr><tr>
            <th scope="row">4KB</th>
            <td>2K (2048)</td>
            <td>2</td>
          </tr><tr>
            <th scope="row">4KB</th>
            <td>1K (1024)</td>
            <td>1</td>
          </tr></tbody></table></div></div><br class="table-break"><p>
        この例では、一般的なテーブルスペースを作成し、圧縮テーブルを追加する方法を示します。 この例では、デフォルトの <code class="literal">innodb_page_size</code> が 16KB であると想定しています。 8192 の <code class="literal">FILE_BLOCK_SIZE</code> では、圧縮テーブルの <code class="literal">KEY_BLOCK_SIZE</code> が 8 である必要があります。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts2` ADD DATAFILE 'ts2.ibd' FILE_BLOCK_SIZE = 8192 Engine=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t4 (c1 INT PRIMARY KEY) TABLESPACE ts2 ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=8;</code></strong>
</pre><p>
        一般テーブルスペースの作成時に <code class="literal">FILE_BLOCK_SIZE</code> を指定しない場合、<code class="literal">FILE_BLOCK_SIZE</code> はデフォルトで <code class="literal">innodb_page_size</code> に設定されます。 <code class="literal">FILE_BLOCK_SIZE</code> が <code class="literal">innodb_page_size</code> と等しい場合、テーブルスペースには、圧縮されていない行形式 (<code class="literal">COMPACT</code>、<code class="literal">REDUNDANT</code> および <code class="literal">DYNAMIC</code> の行形式) のテーブルのみを含めることができます。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="general-tablespaces-moving-non-partitioned-tables"></a>ALTER TABLE を使用したテーブルスペース間のテーブルの移動</h5></div></div></div><p>
        <code class="literal">ALTER TABLE</code> を <code class="literal">TABLESPACE</code> オプションとともに使用して、テーブルを既存の一般テーブルスペース、新しい file-per-table テーブルスペースまたはシステムテーブルスペースに移動できます。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          共有テーブルスペースへのテーブルパーティションの配置のサポートは、MySQL 5.7.24 で非推奨になり、MySQL 8.0.13 が削除されました。 共有テーブルスペースには、<code class="literal">InnoDB</code> システムテーブルスペースおよび一般テーブルスペースが含まれます。 
        </p></div><p>
        file-per-table テーブルスペースまたは system テーブルスペースから general テーブルスペースにテーブルを移動するには、general テーブルスペースの名前を指定します。 一般テーブルスペースが存在する必要があります。 詳細は、<code class="literal">CREATE TABLESPACE</code> を参照してください。 
      </p><pre class="programlisting">ALTER TABLE tbl_name TABLESPACE [=] <em class="replaceable"><code>tablespace_name</code></em>;</pre><p>
        一般的なテーブルスペースまたはファイルごとのテーブルスペースからシステムテーブルスペースにテーブルを移動するには、テーブルスペース名として <code class="literal">innodb_system</code> を指定します。
      </p><pre class="programlisting">ALTER TABLE tbl_name TABLESPACE [=] innodb_system;</pre><p>
        システムテーブルスペースまたは一般テーブルスペースから file-per-table テーブルスペースにテーブルを移動するには、テーブルスペース名として <code class="literal">innodb_file_per_table</code> を指定します。
      </p><pre class="programlisting">ALTER TABLE tbl_name TABLESPACE [=] innodb_file_per_table;</pre><p>
        <code class="literal">ALTER TABLE ... TABLESPACE</code> 操作では、<code class="literal">TABLESPACE</code> 属性が以前の値から変更されていない場合でも、常に全テーブルが再構築されます。
      </p><p>
        <code class="literal">ALTER TABLE ... TABLESPACE</code> 構文では、一時テーブルスペースから永続テーブルスペースへのテーブルの移動はサポートされていません。
      </p><p>
        <code class="literal">DATA DIRECTORY</code> 句は <code class="literal">CREATE TABLE ... TABLESPACE=innodb_file_per_table</code> で使用できますが、それ以外の場合は <code class="literal">TABLESPACE</code> オプションと組み合せて使用することはサポートされていません。 MySQL 8.0.21 では、<code class="literal">DATA DIRECTORY</code> 句で指定されたディレクトリは <code class="literal">InnoDB</code> で認識されている必要があります。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-create-table-external-data-directory" title="DATA DIRECTORY 句の使用">DATA DIRECTORY 句の使用</a>を参照してください。 
      </p><p>
        暗号化されたテーブルスペースからテーブルを移動する場合は、制限が適用されます。 <a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-limitations" title="暗号化の制限事項">暗号化の制限事項</a>を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="general-tablespaces-renaming"></a>一般テーブルスペースの名前の変更</h5></div></div></div><p>
        一般的なテーブルスペースの名前変更は、<code class="literal">ALTER TABLESPACE ... RENAME TO</code> 構文を使用してサポートされます。
      </p><pre class="programlisting">ALTER TABLESPACE s1 RENAME TO s2;
</pre><p>
        一般的なテーブルスペースの名前を変更するには、<code class="literal">CREATE TABLESPACE</code> 権限が必要です。
      </p><p>
        <code class="literal">RENAME TO</code> 操作は、<code class="literal">autocommit</code> の設定に関係なく、<code class="literal">autocommit</code> モードで暗黙的に実行されます。
      </p><p>
        テーブルスペースに存在するテーブルに対して <code class="literal">LOCK TABLES</code> または <code class="literal">FLUSH TABLES WITH READ LOCK</code> が有効になっている間は、<code class="literal">RENAME TO</code> 操作を実行できません。
      </p><p>
        排他的 <a class="link" href="glossary.html#glos_metadata_lock" title="メタデータロック">metadata locks</a> は、テーブルスペースの名前が変更されている間、一般的なテーブルスペース内のテーブルに対して取得されるため、同時 DDL が回避されます。 同時 DML がサポートされています。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="general-tablespaces-dropping"></a>一般テーブルスペースの削除</h5></div></div></div><p>
        <code class="literal">DROP TABLESPACE</code> ステートメントを使用して、<code class="literal">InnoDB</code> の一般テーブルスペースを削除します。
      </p><p>
        <code class="literal">DROP TABLESPACE</code> 操作の前に、すべてのテーブルをテーブルスペースから削除する必要があります。 テーブルスペースが空でない場合、<code class="literal">DROP TABLESPACE</code> はエラーを返します。 
      </p><p>
        一般的なテーブルスペースのテーブルを識別するには、次のようなクエリーを使用します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT a.NAME AS space_name, b.NAME AS table_name FROM INFORMATION_SCHEMA.INNODB_TABLESPACES a,</code></strong>
       <strong class="userinput"><code>INFORMATION_SCHEMA.INNODB_TABLES b WHERE a.SPACE=b.SPACE AND a.NAME LIKE 'ts1';</code></strong>
+------------+------------+
| space_name | table_name |
+------------+------------+
| ts1        | test/t1    |
| ts1        | test/t2    |
| ts1        | test/t3    |
+------------+------------+
</pre><p>
        一般的な <code class="literal">InnoDB</code> テーブルスペースは、テーブルスペースの最後のテーブルが削除されても自動的には削除されません。 テーブルスペースは、<code class="literal">DROP TABLESPACE <em class="replaceable"><code>tablespace_name</code></em></code> を使用して明示的に削除する必要があります。 
      </p><p>
        一般テーブルスペースは、特定のデータベースに属していません。 <code class="literal">DROP DATABASE</code> 操作では、一般的なテーブルスペースに属するテーブルを削除できますが、<code class="literal">DROP DATABASE</code> 操作でテーブルスペースに属するすべてのテーブルを削除しても、テーブルスペースは削除できません。 一般テーブルスペースは、<code class="literal">DROP TABLESPACE <em class="replaceable"><code>tablespace_name</code></em></code> を使用して明示的に削除する必要があります。 
      </p><p>
        システムテーブルスペースと同様に、一般テーブルスペースに格納されているテーブルの切捨てまたは削除によって、新しい <code class="literal">InnoDB</code> データにのみ使用できる空き領域が一般テーブルスペース <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibd data file</a> に内部的に作成されます。 <code class="literal">DROP TABLE</code> 操作中に file-per-table テーブルスペースが削除された場合とは異なり、領域はオペレーティングシステムに解放されません。 
      </p><p>
        この例では、<code class="literal">InnoDB</code> の一般テーブルスペースを削除する方法を示します。 一般的なテーブルスペース <code class="literal">ts1</code> は、単一のテーブルで作成されます。 テーブルスペースを削除する前に、テーブルを削除する必要があります。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts1` ADD DATAFILE 'ts1.ibd' Engine=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts1 Engine=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>DROP TABLE t1;</code></strong>

mysql&gt; <strong class="userinput"><code>DROP TABLESPACE ts1;</code></strong>
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal"><em class="replaceable"><code>tablespace_name</code></em></code> は、MySQL では大/小文字が区別される識別子です。
        </p></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="general-tablespaces-limitations"></a>テーブルスペースの一般的な制限事項</h5></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            生成されたテーブルスペースまたは既存のテーブルスペースを一般テーブルスペースに変更することはできません。
          </p></li><li class="listitem"><p>
            一時一般テーブルスペースの作成はサポートされていません。
          </p></li><li class="listitem"><p>
            一般テーブルスペースでは、一時テーブルはサポートされていません。
          </p></li><li class="listitem"><p>
            システムテーブルスペースと同様に、一般テーブルスペースに格納されているテーブルの切捨てまたは削除によって、新しい <code class="literal">InnoDB</code> データにのみ使用できる空き領域が一般テーブルスペース <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibd data file</a> に内部的に作成されます。 領域は、<a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペース用であるため、オペレーティングシステムに解放されません。 
          </p><p>
            また、共有テーブルスペース (一般テーブルスペースまたはシステムテーブルスペース) に存在するテーブルに対するテーブルコピー <code class="literal">ALTER TABLE</code> 操作によって、テーブルスペースで使用される領域の量を増やすことができます。 このような操作には、テーブルのデータとインデックスと同じ追加領域が必要です。 テーブルのコピー <code class="literal">ALTER TABLE</code> 操作に必要な追加領域は、file-per-table テーブルスペース用であるため、オペレーティングシステムに解放されません。 
          </p></li><li class="listitem"><p>
            <code class="literal">ALTER TABLE ... DISCARD TABLESPACE</code> および <code class="literal">ALTER TABLE ...IMPORT TABLESPACE</code> は、一般テーブルスペースに属するテーブルではサポートされていません。
          </p></li><li class="listitem"><p>
            一般的なテーブルスペースへのテーブルパーティションの配置のサポートは、MySQL 5.7.24 で非推奨になり、MySQL 8.0.13 で削除されました。
          </p></li><li class="listitem"><p>
            <code class="literal">ADD DATAFILE</code> 句は、ソースとレプリカが同じホストに存在するレプリケーション環境ではサポートされません。これは、ソースとレプリカが同じ場所に同じ名前のテーブルスペースを作成するためですが、これはサポートされていないためです。 ただし、<code class="literal">ADD DATAFILE</code> 句を省略した場合、テーブルスペースは一意の生成済ファイル名でデータディレクトリに作成されますが、これは許可されます。 
          </p></li><li class="listitem"><p>
            MySQL 8.0.21 では、<code class="literal">InnoDB</code> で直接認識されていないかぎり、undo テーブルスペースディレクトリ (<code class="literal">innodb_undo_directory</code>) に一般テーブルスペースを作成できません。 既知のディレクトリは、<code class="literal">datadir</code>、<code class="literal">innodb_data_home_dir</code> および <code class="literal">innodb_directories</code> 変数で定義されているディレクトリです。 
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-undo-tablespaces"></a>15.6.3.4 undo テーブルスペース</h4></div></div></div><a class="indexterm" name="idm44761363140304"></a><a class="indexterm" name="idm44761363138816"></a><a class="indexterm" name="idm44761363137472"></a><p>
      undo テーブルスペースには undo ログが含まれます。undo ログレコードには、クラスタ化されたインデックスレコードに対するトランザクションによる最新の変更を取り消す方法に関する情報が含まれます。 undo ログは、ロールバックセグメント内に含まれる undo ログセグメント内に存在します。 <code class="literal">innodb_rollback_segments</code> 変数は、各 undo テーブルスペースに割り当てられるロールバックセグメントの数を定義します。 
    </p><p>
      MySQL インスタンスが初期化されると、2 つのデフォルト undo テーブルスペースが作成されます。 SQL ステートメントを受け入れる前に存在する必要があるロールバックセグメントの場所を提供するために、初期化時にデフォルトの undo テーブルスペースが作成されます。 undo テーブルスペースの自動切捨てをサポートするには、2 つ以上の undo テーブルスペースが必要です。 <a class="xref" href="innodb-storage-engine.html#truncate-undo-tablespace" title="undo テーブルスペースの切捨て">undo テーブルスペースの切捨て</a>を参照してください。 
    </p><p>
      デフォルトの undo テーブルスペースは、<code class="literal">innodb_undo_directory</code> 変数で定義された場所に作成されます。 <code class="literal">innodb_undo_directory</code> 変数が定義されていない場合、デフォルトの undo テーブルスペースがデータディレクトリに作成されます。 デフォルトの undo テーブルスペースデータファイルには、<code class="filename">undo_001</code> および <code class="filename">undo_002</code> という名前が付けられます。 データディクショナリに定義されている対応する undo テーブルスペース名は、<code class="literal">innodb_undo_001</code> および <code class="literal">innodb_undo_002</code> です。 
    </p><p>
      MySQL 8.0.14 では、SQL を使用して実行時に追加の undo テーブルスペースを作成できます。 <a class="xref" href="innodb-storage-engine.html#innodb-add-undo-tablespaces" title="undo テーブルスペースの追加">undo テーブルスペースの追加</a>を参照してください。 
    </p><p>
      MySQL 8.0.23 より前のリリースでは、UNDO テーブルスペースの初期サイズは <code class="literal">innodb_page_size</code> の値によって異なります。 デフォルトの 16KB ページサイズの場合、undo テーブルスペースの初期ファイルサイズは 10MiB です。 4KB、8KB、32KB および 64KB のページサイズの場合、初期 undo テーブルスペースファイルサイズはそれぞれ 7MiB、8MiB、20MiB および 40MiB です。 MySQL 8.0.23 では、初期 UNDO テーブルスペースサイズは通常 16MiB です。 切捨て操作によって新しい UNDO テーブルスペースが作成される場合、初期サイズが異なることがあります。 この場合、ファイル拡張子のサイズが 16MB を超え、前のファイル拡張子が最後の秒以内に発生した場合、新しい UNDO テーブルスペースは <code class="literal">innodb_max_undo_log_size</code> 変数で定義されたサイズの四半期に作成されます。 
    </p><p>
      MySQL 8.0.23 より前は、UNDO テーブルスペースは一度に 4 エクステント拡張されます。 MySQL 8.0.23 からは、UNDO テーブルスペースは 16MB 以上拡張されます。 積極的な増加に対処するために、以前のファイル拡張子が 0.1 秒未満になった場合、ファイル拡張子のサイズは倍増します。 拡張サイズの倍増は、最大 256MB まで複数回発生する可能性があります。 以前のファイル拡張子が 0.1 秒より前に発生した場合、拡張子のサイズは半分に縮小されます。これも、複数回出現する可能性があります (16MB 以上)。 UNDO テーブルスペースに <code class="literal">AUTOEXTEND_SIZE</code> オプションが定義されている場合、前述のロジックで決定された <code class="literal">AUTOEXTEND_SIZE</code> 設定および拡張サイズの大きい方によって拡張されます。 <code class="literal">AUTOEXTEND_SIZE</code> オプションの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-tablespace-autoextend-size" title="15.6.3.9 テーブルスペースの AUTOEXTEND_SIZE 構成">セクション15.6.3.9「テーブルスペースの AUTOEXTEND_SIZE 構成」</a> を参照してください。 
    </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-add-undo-tablespaces"></a>undo テーブルスペースの追加</h5></div></div></div><p>
        長時間実行トランザクション中に undo ログが大きくなる可能性があるため、追加の undo テーブルスペースを作成すると、個々の undo テーブルスペースが大きくなりすぎるのを防ぐことができます。 MySQL 8.0.14 では、<code class="literal">CREATE UNDO TABLESPACE</code> 構文を使用して、実行時に追加の undo テーブルスペースを作成できます。 
      </p><pre class="programlisting">CREATE UNDO TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> ADD DATAFILE '<em class="replaceable"><code>file_name</code></em>.ibu';
</pre><p>
        undo テーブルスペースのファイル名には、<code class="filename">.ibu</code> 拡張子が必要です。 undo テーブルスペースファイル名の定義時に相対パスを指定することはできません。 完全修飾パスは許可されますが、パスは <code class="literal">InnoDB</code> で認識されている必要があります。 既知のパスは、<code class="literal">innodb_directories</code> 変数で定義されたパスです。 データの移動またはクローニング時に潜在的なファイル名の競合を回避するために、一意の undo テーブルスペースファイル名をお薦めします。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          レプリケーション環境では、ソースと各レプリカに独自の undo テーブルスペースファイルディレクトリが必要です。 undo テーブルスペースファイルの作成を共通ディレクトリにレプリケートすると、ファイル名の競合が発生します。 
        </p></div><p>
        起動時に、<code class="literal">innodb_directories</code> 変数で定義されたディレクトリで undo テーブルスペースファイルがスキャンされます。 (スキャンはサブディレクトリも走査します。) <code class="literal">innodb_data_home_dir</code>、<code class="literal">innodb_undo_directory</code> および <code class="literal">datadir</code> 変数で定義されたディレクトリは、<code class="literal">innodb_directories</code> 変数が明示的に定義されているかどうかに関係なく、<code class="literal">innodb_directories</code> 値に自動的に追加されます。 したがって、undo テーブルスペースは、これらの変数のいずれかで定義されたパスに存在できます。 
      </p><p>
        undo テーブルスペースのファイル名にパスが含まれていない場合、undo テーブルスペースは <code class="literal">innodb_undo_directory</code> 変数で定義されたディレクトリに作成されます。 この変数が定義されていない場合、undo テーブルスペースはデータディレクトリに作成されます。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">InnoDB</code> リカバリプロセスでは、undo テーブルスペースファイルが既知のディレクトリに存在する必要があります。 コミットされていないトランザクションおよびデータディクショナリの変更をロールバックできるようにするには、undo テーブルスペースファイルを検出してオープンしてから redo リカバリを実行し、他のデータファイルをオープンする必要があります。 リカバリを使用する前に undo テーブルスペースが見つからないため、データベースの不整合が発生する可能性があります。 データディクショナリで認識されている undo テーブルスペースが見つからない場合は、起動時にエラーメッセージがレポートされます。 既知のディレクトリ要件では、undo テーブルスペースの移植性もサポートされます。 <a class="xref" href="innodb-storage-engine.html#innodb-move-undo-tablespaces" title="undo テーブルスペースの移動">undo テーブルスペースの移動</a>を参照してください。 
        </p></div><p>
        データディレクトリからの相対パスに undo テーブルスペースを作成するには、<code class="literal">innodb_undo_directory</code> 変数を相対パスに設定し、undo テーブルスペースの作成時にのみファイル名を指定します。
      </p><p>
        undo テーブルスペースの名前とパスを表示するには、<code class="literal">INFORMATION_SCHEMA.FILES</code> をクエリーします:
      </p><pre class="programlisting">SELECT TABLESPACE_NAME, FILE_NAME FROM INFORMATION_SCHEMA.FILES
  WHERE FILE_TYPE LIKE 'UNDO LOG';
</pre><p>
        MySQL インスタンスでは、MySQL インスタンスの初期化時に作成される 2 つのデフォルト undo テーブルスペースを含む、最大 127 個の undo テーブルスペースがサポートされます。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL 8.0.14 より前は、<code class="literal">innodb_undo_tablespaces</code> 起動変数を構成することで、追加の undo テーブルスペースが作成されます。 この変数は非推奨であり、MySQL 8.0.14 では構成できなくなりました。 
        </p><p>
          MySQL 8.0.14 より前は、<code class="literal">innodb_undo_tablespaces</code> 設定を増やすと、指定した数の undo テーブルスペースが作成され、アクティブな undo テーブルスペースのリストに追加されます。 <code class="literal">innodb_undo_tablespaces</code> 設定を小さくすると、アクティブな undo テーブルスペースのリストから undo テーブルスペースが削除されます。 アクティブリストから削除された undo テーブルスペースは、既存のトランザクションで使用されなくなるまでアクティブなままです。 <code class="literal">innodb_undo_tablespaces</code> 変数は、<code class="literal">SET</code> ステートメントを使用して実行時に構成するか、構成ファイルで定義できます。 
        </p><p>
          MySQL 8.0.14 より前は、非アクティブ化された undo テーブルスペースは削除できません。 undo テーブルスペースファイルは、低速な停止後に手動で削除できますが、非アクティブ化された undo テーブルスペースには、サーバーの停止時にオープントランザクションが存在していた場合、サーバーの再起動後のしばらくの間アクティブ undo ログが含まれる可能性があるため、お薦めしません。 MySQL 8.0.14 では、<code class="literal">DROP UNDO TABALESPACE</code> 構文を使用して undo テーブルスペースを削除できます。 <a class="xref" href="innodb-storage-engine.html#innodb-drop-undo-tablespaces" title="undo テーブルスペースの削除">undo テーブルスペースの削除</a>を参照してください。 
        </p></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-drop-undo-tablespaces"></a>undo テーブルスペースの削除</h5></div></div></div><p>
        MySQL 8.0.14 では、<code class="literal">CREATE UNDO TABLESPACE</code> 構文を使用して作成された undo テーブルスペースは、<code class="literal">DROP UNDO TABALESPACE</code> 構文を使用して実行時に削除できます。
      </p><p>
        undo テーブルスペースは、削除する前に空にする必要があります。 undo テーブルスペースを空にするには、ロールバックセグメントを新しいトランザクションに割り当てるためにテーブルスペースが使用されなくなるように、まず <code class="literal">ALTER UNDO TABLESPACE</code> 構文を使用して undo テーブルスペースを非アクティブとしてマークする必要があります。 
      </p><pre class="programlisting">ALTER UNDO TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> SET INACTIVE;
</pre><p>
        undo テーブルスペースが非アクティブとしてマークされると、undo テーブルスペースのロールバックセグメントを現在使用しているトランザクションは、それらのトランザクションが完了する前に開始されたトランザクションと同様に終了できます。 トランザクションが完了すると、パージシステムによって undo テーブルスペースのロールバックセグメントが解放され、undo テーブルスペースは初期サイズに切り捨てられます。 (undo テーブルスペースを切り捨てる場合も同じプロセスが使用されます。 <a class="xref" href="innodb-storage-engine.html#truncate-undo-tablespace" title="undo テーブルスペースの切捨て">undo テーブルスペースの切捨て</a>を参照してください。) undo テーブルスペースが空の場合は、削除できます。 
      </p><pre class="programlisting">DROP UNDO TABLESPACE <em class="replaceable"><code>tablespace_name</code></em>;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          または、undo テーブルスペースを空の状態のままにし、必要に応じて <code class="literal">ALTER UNDO TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> SET ACTIVE</code> ステートメントを発行して後で再アクティブ化することもできます。
        </p></div><p>
        undo テーブルスペースの状態は、<code class="literal">INFORMATION_SCHEMA.INNODB_TABLESPACES</code> テーブルをクエリーすることで監視できます。
      </p><pre class="programlisting">SELECT NAME, STATE FROM INFORMATION_SCHEMA.INNODB_TABLESPACES
  WHERE NAME LIKE '<em class="replaceable"><code>tablespace_name</code></em>';
</pre><p>
        <code class="literal">inactive</code> の状態は、undo テーブルスペースのロールバックセグメントが新しいトランザクションで使用されなくなったことを示します。 <code class="literal">empty</code> の状態は、undo テーブルスペースが空であり、削除の準備ができているか、<code class="literal">ALTER UNDO TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> SET ACTIVE</code> ステートメントを使用して再度アクティブになったことを示します。 空でない undo テーブルスペースを削除しようとすると、エラーが返されます。 
      </p><p>
        MySQL インスタンスの初期化時に作成されたデフォルトの undo テーブルスペース (<code class="literal">innodb_undo_001</code> および <code class="literal">innodb_undo_002</code>) は削除できません。 ただし、<code class="literal">ALTER UNDO TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> SET INACTIVE</code> ステートメントを使用して非アクティブにすることはできます。 デフォルトの undo テーブルスペースを非アクティブにするには、その前に undo テーブルスペースが必要です。 undo テーブルスペースの自動切捨てをサポートするには、常に 2 つ以上のアクティブ undo テーブルスペースが必要です。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-move-undo-tablespaces"></a>undo テーブルスペースの移動</h5></div></div></div><p>
        <code class="literal">CREATE UNDO TABLESPACE</code> 構文で作成された undo テーブルスペースは、サーバーがオフラインのときに既知のディレクトリに移動できます。 既知のディレクトリは、<code class="literal">innodb_directories</code> 変数で定義されたディレクトリです。 <code class="literal">innodb_data_home_dir</code>、<code class="literal">innodb_undo_directory</code> および <code class="literal">datadir</code> によって定義されたディレクトリは、<code class="literal">innodb_directories</code> 変数が明示的に定義されているかどうかに関係なく、<code class="literal">innodb_directories</code> 値に自動的に追加されます。 これらのディレクトリとそのサブディレクトリでは、undo テーブルスペースファイルが起動時にスキャンされます。 これらのディレクトリに移動された undo テーブルスペースファイルは、起動時に検出され、移動された undo テーブルスペースとみなされます。 
      </p><p>
        MySQL インスタンスの初期化時に作成されるデフォルトの undo テーブルスペース (<code class="literal">innodb_undo_001</code> および <code class="literal">innodb_undo_002</code>) は、<code class="literal">innodb_undo_directory</code> 変数で定義されたディレクトリに常に存在する必要があります。 <code class="literal">innodb_undo_directory</code> 変数が定義されていない場合、デフォルトの undo テーブルスペースはデータディレクトリに存在します。 サーバーがオフラインのときにデフォルトの undo テーブルスペースを移動する場合は、新しいディレクトリに構成された <code class="literal">innodb_undo_directory</code> 変数を使用してサーバーを起動する必要があります。 
      </p><p>
        undo ログの I/O パターンにより、undo テーブルスペースは <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> 記憶域の適切な候補になります。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-undo-tablespace-rollback-segments"></a>ロールバックセグメント数の構成</h5></div></div></div><p>
        <code class="literal">innodb_rollback_segments</code> 変数は、各 undo テーブルスペースおよびグローバル一時テーブルスペースに割り当てられる <a class="link" href="glossary.html#glos_rollback_segment" title="ロールバックセグメント">rollback segments</a> の数を定義します。 <code class="literal">innodb_rollback_segments</code> 変数は、起動時またはサーバーの実行中に構成できます。 
      </p><p>
        <code class="literal">innodb_rollback_segments</code> のデフォルト設定は 128 で、これは最大値でもあります。 ロールバックセグメントがサポートするトランザクションの数の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-undo-logs" title="15.6.6 undo ログ">セクション15.6.6「undo ログ」</a> を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="truncate-undo-tablespace"></a>undo テーブルスペースの切捨て</h5></div></div></div><a class="indexterm" name="idm44761363019792"></a><a class="indexterm" name="idm44761363018368"></a><a class="indexterm" name="idm44761363017008"></a><p>
        undo テーブルスペースを切り捨てる方法は 2 つあり、undo テーブルスペースのサイズを個別に、または組み合せて管理できます。 1 つの方法は自動化され、構成変数を使用して有効化されます。 その他の方法は手動で、SQL ステートメントを使用して実行されます。 
      </p><p>
        自動化された方法では undo テーブルスペースサイズを監視する必要はなく、一度有効にすると、手動操作なしで undo テーブルスペースの非アクティブ化、切捨ておよび再アクティブ化が実行されます。 切捨てのために undo テーブルスペースをオフラインにするタイミングを制御する場合は、手動切捨て方法をお薦めします。 たとえば、ワークロードのピーク時に undo テーブルスペースを切り捨てないようにすることが必要な場合があります。 
      </p><h6><a name="idm44761363013584"></a>自動切捨て</h6><p>
        undo テーブルスペースの自動切捨てには、少なくとも 2 つのアクティブな undo テーブルスペースが必要です。これにより、一方の undo テーブルスペースはアクティブなままになり、もう一方の undo テーブルスペースは切り捨てられます。 デフォルトでは、MySQL インスタンスの初期化時に 2 つの undo テーブルスペースが作成されます。 
      </p><p>
        undo テーブルスペースを自動的に切り捨てるには、<code class="literal">innodb_undo_log_truncate</code> 変数を有効にします。 例: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_undo_log_truncate=ON;</code></strong>
</pre><p>
        <code class="literal">innodb_undo_log_truncate</code> 変数が有効な場合、<code class="literal">innodb_max_undo_log_size</code> 変数で定義されたサイズ制限を超える undo テーブルスペースは切り捨てられる可能性があります。 <code class="literal">innodb_max_undo_log_size</code> 変数は動的で、デフォルト値は 1073741824 バイト (1024 MiB) です。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@innodb_max_undo_log_size;</code></strong>
+----------------------------+
| @@innodb_max_undo_log_size |
+----------------------------+
|                 1073741824 |
+----------------------------+
</pre><p>
        <code class="literal">innodb_undo_log_truncate</code> 変数を有効にすると、次のようになります:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <code class="literal">innodb_max_undo_log_size</code> 設定を超えるデフォルトおよびユーザー定義の undo テーブルスペースは、切捨て対象としてマークされます。 切捨て用の undo テーブルスペースの選択は循環方式で実行され、毎回同じ undo テーブルスペースが切り捨てられないようにします。 
          </p></li><li class="listitem"><p>
            選択した undo テーブルスペースに存在するロールバックセグメントは、新しいトランザクションに割り当てられないように非アクティブになります。 ロールバックセグメントを現在使用している既存のトランザクションは終了できます。 
          </p></li><li class="listitem"><p>
            <a class="link" href="glossary.html#glos_purge" title="パージ">purge</a> システムは、使用されなくなった undo ログを解放することで、ロールバックセグメントを空にします。
          </p></li><li class="listitem"><p>
            undo テーブルスペースのすべてのロールバックセグメントが解放されると、切捨て操作が実行され、undo テーブルスペースが初期サイズに切り捨てられます。
          </p><p>
            切捨て操作後の undo テーブルスペースのサイズは、操作が完了した直後に使用されるため、初期サイズより大きくなる場合があります。
          </p><p>
            <code class="literal">innodb_undo_directory</code> 変数は、デフォルトの undo テーブルスペースファイルの場所を定義します。 <code class="literal">innodb_undo_directory</code> 変数が定義されていない場合、デフォルトの undo テーブルスペースはデータディレクトリに存在します。 <code class="literal">CREATE UNDO TABLESPACE</code> 構文を使用して作成されたユーザー定義の undo テーブルスペースを含むすべての undo テーブルスペースファイルの場所は、<code class="literal">INFORMATION_SCHEMA.FILES</code> テーブルをクエリーすることで確認できます: 
          </p><pre class="programlisting">SELECT TABLESPACE_NAME, FILE_NAME FROM INFORMATION_SCHEMA.FILES WHERE FILE_TYPE LIKE 'UNDO LOG';</pre></li><li class="listitem"><p>
            ロールバックセグメントは、新しいトランザクションに割り当てることができるように再アクティブ化されます。
          </p></li></ol></div><h6><a name="idm44761362985072"></a>手動切捨て</h6><p>
        undo テーブルスペースを手動で切り捨てるには、少なくとも 3 つのアクティブな undo テーブルスペースが必要です。 自動切捨てを有効にするには、常に 2 つのアクティブ undo テーブルスペースが必要です。 undo テーブルスペースを手動でオフラインにすることを許可しながら、少なくとも 3 つの undo テーブルスペースがこの要件を満たしています。 
      </p><p>
        undo テーブルスペースの切捨てを手動で開始するには、次のステートメントを発行して undo テーブルスペースを非アクティブ化します:
      </p><pre class="programlisting">ALTER UNDO TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> SET INACTIVE;
</pre><p>
        undo テーブルスペースが非アクティブとしてマークされると、undo テーブルスペースのロールバックセグメントを現在使用しているトランザクションは、それらのトランザクションが完了する前に開始されたトランザクションと同様に終了できます。 トランザクションが完了すると、パージシステムによって undo テーブルスペースのロールバックセグメントが解放され、undo テーブルスペースが初期サイズに切り捨てられ、undo テーブルスペースの状態が <code class="literal">inactive</code> から <code class="literal">empty</code> に変更されます。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">ALTER UNDO TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> SET INACTIVE</code> ステートメントによって undo テーブルスペースが非アクティブ化されると、パージスレッドは次の機会でその undo テーブルスペースを検索します。 undo テーブルスペースが検出され、切捨てのマークが付けられると、パージスレッドは頻度を上げて戻され、undo テーブルスペースがすぐに空になり、切り捨てられます。 
        </p></div><p>
        undo テーブルスペースの状態を確認するには、<code class="literal">INFORMATION_SCHEMA.INNODB_TABLESPACES</code> テーブルをクエリーします。
      </p><pre class="programlisting">SELECT NAME, STATE FROM INFORMATION_SCHEMA.INNODB_TABLESPACES
  WHERE NAME LIKE '<em class="replaceable"><code>tablespace_name</code></em>';
</pre><p>
        undo テーブルスペースが <code class="literal">empty</code> 状態になると、次のステートメントを発行して undo テーブルスペースを再アクティブ化できます:
      </p><pre class="programlisting">ALTER UNDO TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> SET ACTIVE;
</pre><p>
        <code class="literal">empty</code> 状態の undo テーブルスペースも削除できます。 <a class="xref" href="innodb-storage-engine.html#innodb-drop-undo-tablespaces" title="undo テーブルスペースの削除">undo テーブルスペースの削除</a>を参照してください。 
      </p><h6><a name="idm44761362968352"></a>undo テーブルスペースの自動切捨ての回避</h6><p>
        パージスレッドは、undo テーブルスペースを空にしたり切り捨てたりします。 デフォルトでは、パージスレッドは undo テーブルスペースを検索し、パージが起動されるたびに 128 回切り捨てます。 パージスレッドが切り捨てる undo テーブルスペースを検索する頻度は、<code class="literal">innodb_purge_rseg_truncate_frequency</code> 変数 (デフォルト設定は 128) によって制御されます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@innodb_purge_rseg_truncate_frequency;</code></strong>
+----------------------------------------+
| @@innodb_purge_rseg_truncate_frequency |
+----------------------------------------+
|                                    128 |
+----------------------------------------+
</pre><p>
        この頻度を上げるには、<code class="literal">innodb_purge_rseg_truncate_frequency</code> 設定を減らします。 たとえば、パージスレッドで undo テーブルスペースを 32 回起動するたびに検索するには、<code class="literal">innodb_purge_rseg_truncate_frequency</code> を 32 に設定します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_purge_rseg_truncate_frequency=32;</code></strong>
</pre><h6><a name="idm44761362958848"></a>undo テーブルスペースファイルの切捨てによるパフォーマンスへの影響</h6><p>
        undo テーブルスペースが切り捨てられると、undo テーブルスペースのロールバックセグメントは非アクティブ化されます。 他の undo テーブルスペースのアクティブロールバックセグメントは、システム全体の負荷を前提としているため、パフォーマンスがわずかに低下する可能性があります。 パフォーマンスの低下の量は、いくつかの要因によって異なります: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            undo テーブルスペースの数
          </p></li><li class="listitem"><p>
            undo ログの数
          </p></li><li class="listitem"><p>
            undo テーブルスペースサイズ
          </p></li><li class="listitem"><p>
            I/O 疑わしいシステムの速度
          </p></li><li class="listitem"><p>
            既存の長時間実行トランザクション
          </p></li><li class="listitem"><p>
            システムロード
          </p></li></ul></div><p>
        この潜在的なパフォーマンスの問題を回避する最も簡単な方法は、undo テーブルスペースの数を増やすことです。
      </p><p>
        また、MySQL 8.0.21 より前は、undo テーブルスペースの切捨て操作中に 2 つのフラッシュ操作が実行されます。 最初のフラッシュ操作では、バッファプールから古い undo テーブルスペースページが削除されます。 2 回目のフラッシュ操作では、新しい undo テーブルスペースの初期ページがディスクに書き込まれます。 ビジー状態のシステムでは、削除するページが多数ある場合、特に最初のフラッシュ操作がシステムのパフォーマンスに一時的に影響を与える可能性があります。 MySQL 8.0.21 の時点では、両方のフラッシュ操作が削除されます。 古い undo テーブルスペースページは、最近最も使用されていない状態になるか、次のフルチェックポイントで解放されるため、パッシブに解放されます。 新しい undo テーブルスペースページの初期ページは、切捨て操作中にディスクにフラッシュされるのではなく、redo ログに記録されます。 
      </p><h6><a name="idm44761362948016"></a>undo テーブルスペースの切捨ての監視</h6><p>
        MySQL 8.0.16 では、undo ログの切捨てに関連付けられたバックグラウンドアクティビティを監視するために、<code class="literal">undo</code> および <code class="literal">purge</code> の疑わしいシステムカウンタが提供されています。 カウンタ名と説明については、<code class="literal">INFORMATION_SCHEMA.INNODB_METRICS</code> テーブルをクエリーします。 
      </p><pre class="programlisting">SELECT NAME, SUBSYSTEM, COMMENT FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME LIKE '%truncate%';
</pre><p>
        カウンタの有効化およびカウンタデータのクエリーの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-information-schema-metrics-table" title="15.15.6 InnoDB INFORMATION_SCHEMA メトリックテーブル">セクション15.15.6「InnoDB INFORMATION_SCHEMA メトリックテーブル」</a> を参照してください。
      </p><h6><a name="idm44761362941392"></a>undo テーブルスペースの切捨て制限</h6><p>
        MySQL 8.0.21 の時点では、チェックポイント間の同じ undo テーブルスペースに対する切捨て操作の数は 64 に制限されています。 この制限により、ビジー状態のシステムで <code class="literal">innodb_max_undo_log_size</code> の設定が低すぎる場合などに発生する可能性のある undo テーブルスペースの切捨て操作の数が多すぎることが原因で発生する潜在的な問題が回避されます。 この制限を超えると、undo テーブルスペースは非アクティブにできますが、次のチェックポイントまで切り捨てられません。 MySQL 8.0.22 では、制限は 64 から 50,000 に引き上げられました。 
      </p><h6><a name="idm44761362938176"></a>undo テーブルスペースの切捨てリカバリ</h6><p>
        undo テーブルスペースの切捨て操作では、一時 <code class="filename">undo_<em class="replaceable"><code>space_number</code></em>_trunc.log</code> ファイルがサーバーログディレクトリに作成されます。 そのログディレクトリは、<code class="literal">innodb_log_group_home_dir</code> によって定義されます。 切捨て操作中にシステム障害が発生した場合、一時ログファイルを使用すると、起動プロセスで切り捨てられていた undo テーブルスペースを識別し、操作を続行できます。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-undo-tablespace-status-variables"></a>undo テーブルスペースのステータス変数</h5></div></div></div><p>
        次のステータス変数を使用すると、undo テーブルスペースの合計数、暗黙的 (<code class="literal">InnoDB</code> 作成) undo テーブルスペース、明示的 (ユーザー作成) undo テーブルスペースおよびアクティブ undo テーブルスペースの数を追跡できます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'Innodb_undo_tablespaces%';</code></strong>
+----------------------------------+-------+
| Variable_name                    | Value |
+----------------------------------+-------+
| Innodb_undo_tablespaces_total    | 2     |
| Innodb_undo_tablespaces_implicit | 2     |
| Innodb_undo_tablespaces_explicit | 0     |
| Innodb_undo_tablespaces_active   | 2     |
+----------------------------------+-------+
</pre><p>
        ステータス変数の説明については、<a class="xref" href="server-administration.html#server-status-variables" title="5.1.10 サーバーステータス変数">セクション5.1.10「サーバーステータス変数」</a>を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-temporary-tablespace"></a>15.6.3.5 一時テーブルスペース</h4></div></div></div><p>
      <code class="literal">InnoDB</code> では、セッション一時テーブルスペースおよびグローバル一時テーブルスペースが使用されます。
    </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-session-temporary-tablespaces"></a>セッション一時テーブルスペース</h5></div></div></div><p>
        セッション一時テーブルスペースには、<code class="literal">InnoDB</code> がディスク上の内部一時テーブルの記憶域エンジンとして構成されている場合にオプティマイザによって作成されるユーザー作成一時テーブルおよび内部一時テーブルが格納されます。 MySQL 8.0.16 以降、ディスク上の内部一時テーブルに使用されるストレージエンジンは常に <code class="literal">InnoDB</code> です。 (以前は、ストレージエンジンは <code class="literal">internal_tmp_disk_storage_engine</code> の値によって決定されていました。) 
      </p><p>
        セッション一時テーブルスペースは、ディスク上の一時テーブルを作成する最初のリクエストで、一時テーブルスペースのプールからセッションに割り当てられます。 セッションには最大 2 つのテーブルスペースが割り当てられます。1 つはユーザーが作成した一時テーブル用で、もう 1 つはオプティマイザによって作成された内部一時テーブル用です。 セッションに割り当てられた一時テーブルスペースは、セッションによって作成されたディスク上のすべての一時テーブルに使用されます。 セッションが切断されると、その一時テーブルスペースは切り捨てられ、プールに解放されます。 サーバーの起動時に、10 個の一時テーブルスペースのプールが作成されます。 プールのサイズは縮小されず、必要に応じてテーブルスペースがプールに自動的に追加されます。 一時テーブルスペースのプールは、通常の停止時または中断された初期化時に削除されます。 セッション一時テーブルスペースファイルは、作成時にサイズが 5 ページで、<code class="filename">.ibt</code> ファイル名拡張子が付いています。 
      </p><p>
        400 万の領域 ID の範囲は、セッション一時テーブルスペース用に予約されています。 セッション一時テーブルスペースのプールはサーバーが起動するたびに再作成されるため、セッション一時テーブルスペースの領域 ID はサーバーの停止時に永続化されず、再利用できます。 
      </p><p>
        <code class="literal">innodb_temp_tablespaces_dir</code> 変数は、セッション一時テーブルスペースが作成される場所を定義します。 デフォルトの場所は、データディレクトリ内の<code class="filename">#innodb_temp</code> ディレクトリです。 一時テーブルスペースのプールを作成できない場合、起動は拒否されます。 
      </p><pre class="programlisting">shell&gt; cd <em class="replaceable"><code>BASEDIR</code></em>/data/#innodb_temp
shell&gt; ls
temp_10.ibt  temp_2.ibt  temp_4.ibt  temp_6.ibt  temp_8.ibt
temp_1.ibt   temp_3.ibt  temp_5.ibt  temp_7.ibt  temp_9.ibt
</pre><p>
        ステートメントベースのレプリケーション (SBR) モードでは、レプリカに作成された一時テーブルは、MySQL サーバーの停止時にのみ切り捨てられる単一セッション一時テーブルスペースに存在します。
      </p><p>
        <code class="literal">INNODB_SESSION_TEMP_TABLESPACES</code> テーブルは、セッション一時テーブルスペースに関するメタデータを提供します。
      </p><p>
        <code class="literal">INFORMATION_SCHEMA.INNODB_TEMP_TABLE_INFO</code> テーブルは、<code class="literal">InnoDB</code> インスタンスでアクティブなユーザー作成一時テーブルに関するメタデータを提供します。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-global-temporary-tablespace"></a>グローバル一時テーブルスペース</h5></div></div></div><p>
        グローバル一時テーブルスペース (<code class="filename">ibtmp1</code>) には、ユーザーが作成した一時テーブルに対する変更のロールバックセグメントが格納されます。
      </p><p>
        <code class="literal">innodb_temp_data_file_path</code> 変数は、グローバル一時テーブルスペースデータファイルの相対パス、名前、サイズおよび属性を定義します。 <code class="literal">innodb_temp_data_file_path</code> に値が指定されていない場合、デフォルトの動作では、<code class="filename">ibtmp1</code> という名前の単一の自動拡張データファイルが <code class="literal">innodb_data_home_dir</code> ディレクトリに作成されます。 初期ファイルサイズは 12MB を少し超えています。 
      </p><p>
        グローバル一時テーブルスペースは、通常の停止時または中断された初期化時に削除され、サーバーが起動するたびに再作成されます。 グローバル一時テーブルスペースは、作成時に動的に生成された領域 ID を受け取ります。 グローバル一時テーブルスペースを作成できない場合、起動は拒否されます。 サーバーが予期せず停止した場合、グローバル一時テーブルスペースは削除されません。 この場合、データベース管理者はグローバル一時テーブルスペースを手動で削除するか、MySQL サーバーを再起動できます。 MySQL サーバーを再起動すると、グローバル一時テーブルスペースが自動的に削除され、再作成されます。 
      </p><p>
        グローバル一時テーブルスペースは RAW デバイスに配置できません。
      </p><p>
        <code class="literal">INFORMATION_SCHEMA.FILES</code> は、グローバル一時テーブルスペースに関するメタデータを提供します。 次のようなクエリーを発行して、グローバル一時テーブルスペースメタデータを表示します: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.FILES WHERE TABLESPACE_NAME='innodb_temporary'\G</code></strong>
</pre><p>
        デフォルトでは、グローバル一時テーブルスペースデータファイルは自動拡張され、必要に応じてサイズが大きくなります。
      </p><p>
        グローバル一時テーブルスペースデータファイルが自動拡張されているかどうかを確認するには、<code class="literal">innodb_temp_data_file_path</code> 設定を確認します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@innodb_temp_data_file_path;</code></strong>
+------------------------------+
| @@innodb_temp_data_file_path |
+------------------------------+
| ibtmp1:12M:autoextend        |
+------------------------------+
</pre><p>
        グローバル一時テーブルスペースデータファイルのサイズを確認するには、次のようなクエリーを使用して <code class="literal">INFORMATION_SCHEMA.FILES</code> テーブルをクエリーします:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT FILE_NAME, TABLESPACE_NAME, ENGINE, INITIAL_SIZE, TOTAL_EXTENTS*EXTENT_SIZE</code></strong>
       <strong class="userinput"><code>AS TotalSizeBytes, DATA_FREE, MAXIMUM_SIZE FROM INFORMATION_SCHEMA.FILES</code></strong>
       <strong class="userinput"><code>WHERE TABLESPACE_NAME = 'innodb_temporary'\G</code></strong>
*************************** 1. row ***************************
      FILE_NAME: ./ibtmp1
TABLESPACE_NAME: innodb_temporary
         ENGINE: InnoDB
   INITIAL_SIZE: 12582912
 TotalSizeBytes: 12582912
      DATA_FREE: 6291456
   MAXIMUM_SIZE: NULL
</pre><p>
        <code class="literal">TotalSizeBytes</code> には、グローバル一時テーブルスペースデータファイルの現在のサイズが表示されます。 その他のフィールド値の詳細は、<a class="xref" href="information-schema.html#information-schema-files-table" title="26.15 INFORMATION_SCHEMA FILES テーブル">セクション26.15「INFORMATION_SCHEMA FILES テーブル」</a> を参照してください。 
      </p><p>
        または、オペレーティングシステムのグローバル一時テーブルスペースのデータファイルサイズを確認します。 グローバル一時テーブルスペースデータファイルは、<code class="literal">innodb_temp_data_file_path</code> 変数で定義されたディレクトリにあります。 
      </p><p>
        グローバル一時テーブルスペースデータファイルが占有しているディスク領域を再利用するには、MySQL サーバーを再起動します。 サーバーを再起動すると、<code class="literal">innodb_temp_data_file_path</code> で定義された属性に従ってグローバル一時テーブルスペースデータファイルが削除され、再作成されます。 
      </p><p>
        グローバル一時テーブルスペースデータファイルのサイズを制限するには、最大ファイルサイズを指定するように <code class="literal">innodb_temp_data_file_path</code> を構成します。 例: 
      </p><pre class="programlisting">[mysqld]
innodb_temp_data_file_path=ibtmp1:12M:autoextend:max:500M
</pre><p>
        <code class="literal">innodb_temp_data_file_path</code> を構成するには、サーバーの再起動が必要です。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-moving-data-files-offline"></a>15.6.3.6 サーバーがオフラインのときのテーブルスペースファイルの移動</h4></div></div></div><p>
      起動時にテーブルスペースファイルをスキャンするディレクトリを定義する <code class="literal">innodb_directories</code> オプションでは、サーバーがオフラインのときにテーブルスペースファイルを新しい場所に移動またはリストアできます。 起動時には、検出されたテーブルスペースファイルがデータディクショナリで参照されるファイルのかわりに使用され、再配置されたファイルを参照するようにデータディクショナリが更新されます。 スキャンによって重複するテーブルスペースファイルが検出された場合、起動は失敗し、同じテーブルスペース ID に対して複数のファイルが見つかったことを示すエラーが表示されます。 
    </p><p>
      <code class="literal">innodb_data_home_dir</code>、<code class="literal">innodb_undo_directory</code> および <code class="literal">datadir</code> の構成オプションで定義されたディレクトリは、<code class="literal">innodb_directories</code> 引数値に自動的に追加されます。 これらのディレクトリは、<code class="literal">innodb_directories</code> オプションが明示的に指定されているかどうかに関係なく、起動時にスキャンされます。 これらのディレクトリを暗黙的に追加すると、<code class="literal">innodb_directories</code> 設定を構成せずに、システムテーブルスペースファイル、データディレクトリまたは undo テーブルスペースファイルを移動できます。 ただし、ディレクトリが変更された場合は設定を更新する必要があります。 たとえば、データディレクトリを再配置した後、サーバーを再起動する前に <code class="literal">--datadir</code> 設定を更新する必要があります。 
    </p><p>
      <code class="literal">innodb_directories</code> オプションは、起動コマンドまたは MySQL オプションファイルで指定できます。 一部のコマンドインタプリタではセミコロン (;) は特殊文字として解釈されるため、引数値の前後に引用符が使用されます。 (たとえば UNIX シェルでは、これはコマンド終端記号として扱われます。) 
    </p><p>
      起動コマンド:
    </p><pre class="programlisting">mysqld --innodb-directories="<em class="replaceable"><code>directory_path_1</code></em>;<em class="replaceable"><code>directory_path_2</code></em>"
</pre><p>
      MySQL オプションファイル:
    </p><pre class="programlisting">[mysqld]
innodb_directories="<em class="replaceable"><code>directory_path_1</code></em>;<em class="replaceable"><code>directory_path_2</code></em>"
</pre><p>
      次の手順は、個々の <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> および <a class="link" href="glossary.html#glos_general_tablespace" title="一般テーブルスペース">general tablespace</a> ファイル、<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">system tablespace</a> ファイル、<a class="link" href="glossary.html#glos_undo_tablespace" title="Undo テーブルスペース">undo tablespace</a> ファイルまたはデータディレクトリの移動に適用できます。 ファイルまたはディレクトリを移動する前に、次の使用上のノートを確認してください。 
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          サーバーを停止します。
        </p></li><li class="listitem"><p>
          テーブルスペースファイルまたはディレクトリを移動します。
        </p></li><li class="listitem"><p>
          新しいディレクトリを <code class="literal">InnoDB</code> で認識できるようにします。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              個々の <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> または <a class="link" href="glossary.html#glos_general_tablespace" title="一般テーブルスペース">general tablespace</a> ファイルを移動する場合は、<code class="literal">innodb_directories</code> 値に不明なディレクトリを追加します。
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">innodb_data_home_dir</code>、<code class="literal">innodb_undo_directory</code> および <code class="literal">datadir</code> の構成オプションで定義されたディレクトリは、<code class="literal">innodb_directories</code> 引数値に自動的に追加されるため、これらを指定する必要はありません。
                </p></li><li class="listitem"><p>
                  file-per-table テーブルスペースファイルは、スキーマと同じ名前のディレクトリにのみ移動できます。 たとえば、<code class="literal">actor</code> テーブルが <code class="literal">sakila</code> スキーマに属している場合、<code class="filename">actor.ibd</code> データファイルは <code class="filename">sakila</code> というディレクトリにのみ移動できます。 
                </p></li><li class="listitem"><p>
                  一般テーブルスペースファイルは、データディレクトリまたはデータディレクトリのサブディレクトリに移動できません。
                </p></li></ul></div></li><li class="listitem"><p>
              システムテーブルスペースファイル、undo テーブルスペースまたはデータディレクトリを移動する場合は、必要に応じて <code class="literal">innodb_data_home_dir</code>、<code class="literal">innodb_undo_directory</code> および <code class="literal">datadir</code> の設定を更新します。
            </p></li></ul></div></li><li class="listitem"><p>
          サーバーを再起動します。
        </p></li></ol></div><h5><a name="idm44761362823968"></a>使用上の注意</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ワイルドカード式は、<code class="literal">innodb_directories</code> 引数値では使用できません。
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_directories</code> スキャンは、指定されたディレクトリのサブディレクトリも走査します。 重複するディレクトリおよびサブディレクトリは、スキャンされるディレクトリのリストから破棄されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_directories</code> オプションでは、<code class="literal">InnoDB</code> テーブルスペースファイルの移動のみがサポートされます。 <code class="literal">InnoDB</code> 以外のストレージエンジンに属するファイルの移動はサポートされていません。 この制限は、データディレクトリ全体を移動する場合にも適用されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_directories</code> オプションでは、スキャンしたディレクトリにファイルを移動する際のテーブルスペースファイルの名前変更がサポートされています。 また、サポートされている他のオペレーティングシステムへのテーブルスペースファイルの移動もサポートしています。 
        </p></li><li class="listitem"><p>
          テーブルスペースファイルを別のオペレーティングシステムに移動する場合は、宛先システムで禁止されている文字または特殊文字がテーブルスペースファイル名に含まれていないことを確認してください。
        </p></li><li class="listitem"><p>
          データディレクトリを Windows オペレーティングシステムから Linux オペレーティングシステムに移動する場合は、バイナリログインデックスファイルのバイナリログファイルパスを変更して、スラッシュではなくバックスラッシュを使用します。 デフォルトでは、バイナリログインデックスファイルのベース名はバイナリログファイルと同じで、拡張子は'<code class="filename">.index</code>'です。 バイナリログインデックスファイルの場所は、<code class="option">--log-bin</code> によって定義されます。 デフォルトの場所はデータディレクトリです。 
        </p></li><li class="listitem"><p>
          テーブルスペースファイルを別のオペレーティングシステムに移動すると、クロスプラットフォームのレプリケーションが導入されます。データベース管理者は、プラットフォーム固有のディレクトリを含む DDL ステートメントを適切にレプリケーションする必要があります。 ディレクトリの指定を許可するステートメントには、<code class="literal">CREATE TABLE ... DATA DIRECTORY</code> および <code class="literal">CREATE TABLESPACE ... ADD DATAFILE</code> があります。 
        </p></li><li class="listitem"><p>
          絶対パスを使用して、またはデータディレクトリ外の場所に作成された file-per-table および general テーブルスペースのディレクトリを <code class="literal">innodb_directories</code> 設定に追加します。 そうしないと、<code class="literal">InnoDB</code> はリカバリ中にファイルを検出できません。 関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-recovery-tablespace-discovery" title="クラッシュリカバリ中のテーブルスペースの検出">クラッシュリカバリ中のテーブルスペースの検出</a>を参照してください。 
        </p><p>
          テーブルスペースファイルの場所を表示するには、<code class="literal">INFORMATION_SCHEMA.FILES</code> テーブルをクエリーします:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLESPACE_NAME, FILE_NAME FROM INFORMATION_SCHEMA.FILES \G</code></strong>
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-disabling-tablespace-path-validation"></a>15.6.3.7 テーブルスペースパス検証の無効化</h4></div></div></div><p>
      起動時に、<code class="literal">InnoDB</code> は <code class="literal">innodb_directories</code> 変数で定義されたディレクトリでテーブルスペースファイルをスキャンします。 検出されたテーブルスペースファイルのパスは、データディクショナリに記録されているパスに対して検証されます。 パスが一致しない場合は、データディクショナリ内のパスが更新されます。 
    </p><p>
      MySQL 8.0.21 で導入された <code class="literal">innodb_validate_tablespace_paths</code> 変数を使用すると、テーブルスペースパス検証を無効にできます。 この機能は、テーブルスペースファイルを移動しない環境を対象としています。 パス検証を無効にすると、多数のテーブルスペースファイルがあるシステムでの起動時間が短縮されます。 <code class="literal">log_error_verbosity</code> が 3 に設定されている場合、テーブルスペースパスの検証が無効になると、起動時に次のメッセージが出力されます: 
    </p><pre class="programlisting">[InnoDB] Skipping InnoDB tablespace path validation. 
Manually moved tablespace files will not be detected!
</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
        テーブルスペースファイルの移動後にテーブルスペースパス検証を無効にしてサーバーを起動すると、動作が未定義になる可能性があります。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-optimize-tablespace-page-allocation"></a>15.6.3.8 Linux でのテーブルスペースの領域割当ての最適化</h4></div></div></div><a class="indexterm" name="idm44761362785696"></a><p>
      MySQL 8.0.22 では、<code class="literal">InnoDB</code> が Linux の file-per-table および general テーブルスペースに領域を割り当てる方法を最適化できます。 デフォルトでは、追加の領域が必要な場合、<code class="literal">InnoDB</code> はテーブルスペースにページを割り当て、それらのページに NULL を物理的に書き込みます。 新しいページが頻繁に割り当てられる場合、この動作はパフォーマンスに影響を与える可能性があります。 MySQL 8.0.22 では、Linux システムで <code class="literal">innodb_extend_and_initialize</code> を無効にして、新しく割り当てられたテーブルスペースページに NULL が物理的に書き込まれないようにできます。 <code class="literal">innodb_extend_and_initialize</code> を無効にすると、<code class="literal">posix_fallocate()</code> コールを使用してテーブルスペースファイルに領域が割り当てられ、物理的に NULL を書き込まずに領域が予約されます。 
    </p><p>
      <code class="literal">posix_fallocate()</code> 操作はアトミックではないため、テーブルスペースファイルへの領域の割当てとファイルメタデータの更新の間に障害が発生する可能性があります。 このような障害が発生すると、新しく割り当てられたページは初期化されていない状態のままになり、<code class="literal">InnoDB</code> がこれらのページにアクセスしようとしたときに障害が発生する可能性があります。 このシナリオを回避するために、<code class="literal">InnoDB</code> は新しいテーブルスペースページを割り当てる前に redo ログレコードを書き込みます。 ページ割当て操作が中断されると、リカバリ中に redo ログレコードから操作がリプレイされます。 (redo ログレコードからリプレイされたページ割当て操作は、新しく割り当てられたページに NULL を物理的に書き込みます。) redo ログレコードは、<code class="literal">innodb_extend_and_initialize</code> の設定に関係なく、ページを割り当てる前に書き込まれます。 
    </p><p>
      Linux 以外のシステムおよび Windows では、<code class="literal">InnoDB</code> はテーブルスペースに新しいページを割り当て、それらのページに NULL を物理的に書き込みます (デフォルトの動作)。 これらのシステムで <code class="literal">innodb_extend_and_initialize</code> を無効にしようとすると、次のエラーが返されます: 
    </p><p>
      <span class="errortext">Changing innodb_extend_and_initialize はこのプラットフォームではサポートされていません。 default.</span> へのフォールバック 
    </p><p>
      MySQL 8.0.23 で導入された <code class="literal">AUTOEXTEND_SIZE</code> オプションは、<code class="literal">posix_fallocate()</code> コールによって割り当てられる領域の量を定義します。 領域を大量に割り当てると、断片化の回避に役立ち、大量のデータの収集が容易になります。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-tablespace-autoextend-size" title="15.6.3.9 テーブルスペースの AUTOEXTEND_SIZE 構成">セクション15.6.3.9「テーブルスペースの AUTOEXTEND_SIZE 構成」</a>を参照してください。 
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-tablespace-autoextend-size"></a>15.6.3.9 テーブルスペースの AUTOEXTEND_SIZE 構成</h4></div></div></div><p>
      デフォルトでは、file-per-table または general テーブルスペースに追加の領域が必要な場合、テーブルスペースは次の規則に従って増分的に拡張されます:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          テーブルスペースのサイズがエクステントより小さい場合は、一度に 1 ページずつ拡張されます。
        </p></li><li class="listitem"><p>
          テーブルスペースが 1 エクステントより大きいが、サイズが 32 エクステントより小さい場合は、一度に 1 エクステントずつ拡張されます。
        </p></li><li class="listitem"><p>
          テーブルスペースのサイズが 32 エクステントを超える場合は、一度に 4 エクステント拡張されます。
        </p></li></ul></div><p>
      エクステントサイズの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-file-space" title="15.11.2 ファイル領域管理">セクション15.11.2「ファイル領域管理」</a> を参照してください。
    </p><p>
      MySQL 8.0.23 では、file-per-table または general テーブルスペースを拡張する量は、<code class="literal">AUTOEXTEND_SIZE</code> オプションを指定することで構成できます。 拡張サイズを大きく構成すると、断片化を回避し、大量のデータの収集を容易にすることができます。 
    </p><p>
      file-per-table テーブルスペースの拡張子サイズを構成するには、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントで <code class="literal">AUTOEXTEND_SIZE</code> サイズを指定します:
    </p><pre class="programlisting">CREATE TABLE t1 (c1 INT) AUTOEXTEND_SIZE = 4M;</pre><pre class="programlisting">ALTER TABLE t1 AUTOEXTEND_SIZE = 8M;</pre><p>
      一般的なテーブルスペースの拡張サイズを構成するには、<code class="literal">CREATE TABLESPACE</code> ステートメントまたは <code class="literal">ALTER TABLESPACE</code> ステートメントで <code class="literal">AUTOEXTEND_SIZE</code> サイズを指定します:
    </p><pre class="programlisting">CREATE TABLESPACE ts1 AUTOEXTEND_SIZE = 4M;</pre><pre class="programlisting">ALTER TABLESPACE ts1 AUTOEXTEND_SIZE = 8M;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">AUTOEXTEND_SIZE</code> オプションは、UNDO テーブルスペースの作成時にも使用できますが、UNDO テーブルスペースの拡張動作は異なります。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-undo-tablespaces" title="15.6.3.4 undo テーブルスペース">セクション15.6.3.4「undo テーブルスペース」</a>を参照してください。 
      </p></div><p>
      <code class="literal">AUTOEXTEND_SIZE</code> 設定は 4M の倍数である必要があります。 4M の倍数ではない <code class="literal">AUTOEXTEND_SIZE</code> 設定を指定すると、エラーが返されます。 
    </p><p>
      <code class="literal">AUTOEXTEND_SIZE</code> のデフォルト設定は 0 で、テーブルスペースは前述のデフォルトの動作に従って拡張されます。
    </p><p>
      <code class="literal">AUTOEXTEND_SIZE</code> の最大設定は 64M です。
    </p><p>
      次のテーブルに示すように、<code class="literal">AUTOEXTEND_SIZE</code> の最小設定は <code class="literal">InnoDB</code> ページサイズによって異なります:
    </p><div class="informaltable"><table summary="The minimum AUTOEXTEND_SIZE for each InnoDB page size"><col style="width: 50%"><col style="width: 50%"><thead><tr>
          <th>InnoDB ページサイズ</th>
          <th>最小 AUTOEXTEND_SIZE</th>
        </tr></thead><tbody><tr>
          <td><code class="literal">4K</code></td>
          <td><code class="literal">4M</code></td>
        </tr><tr>
          <td><code class="literal">8K</code></td>
          <td><code class="literal">4M</code></td>
        </tr><tr>
          <td><code class="literal">16K</code></td>
          <td><code class="literal">4M</code></td>
        </tr><tr>
          <td><code class="literal">32K</code></td>
          <td><code class="literal">8M</code></td>
        </tr><tr>
          <td><code class="literal">64K</code></td>
          <td><code class="literal">16M</code></td>
        </tr></tbody></table></div><p>
      デフォルトの <code class="literal">InnoDB</code> ページサイズは 16K (16384 バイト) です。 MySQL インスタンスの <code class="literal">InnoDB</code> ページサイズを確認するには、<code class="literal">innodb_page_size</code> 設定をクエリーします: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@GLOBAL.innodb_page_size;</code></strong>
+---------------------------+
| @@GLOBAL.innodb_page_size |
+---------------------------+
|                     16384 |
+---------------------------+
</pre><p>
      テーブルスペースの <code class="literal">AUTOEXTEND_SIZE</code> 設定が変更されると、後で最初に拡張されるときに、テーブルスペースサイズが <code class="literal">AUTOEXTEND_SIZE</code> 設定の倍数に増加します。 後続の拡張機能は、構成されたサイズです。 
    </p><p>
      ゼロ以外の <code class="literal">AUTOEXTEND_SIZE</code> 設定で file-per-table または general テーブルスペースが作成されると、テーブルスペースは指定された <code class="literal">AUTOEXTEND_SIZE</code> サイズで初期化されます。
    </p><p>
      <code class="literal">ALTER TABLESPACE</code> を使用して file-per-table テーブルスペースの <code class="literal">AUTOEXTEND_SIZE</code> を構成することはできません。 <code class="literal">ALTER TABLE</code> を使用する必要があります。 
    </p><p>
      file-per-table テーブルスペースに作成されたテーブルの場合、<code class="literal">SHOW CREATE TABLE</code> で <code class="literal">AUTOEXTEND_SIZE</code> オプションが表示されるのは、ゼロ以外の値に構成されている場合のみです。
    </p><p>
      <code class="literal">InnoDB</code> テーブルスペースの <code class="literal">AUTOEXTEND_SIZE</code> を確認するには、<code class="literal">INFORMATION_SCHEMA.INNODB_TABLESPACES</code> テーブルをクエリーします。 例: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT NAME, AUTOEXTEND_SIZE FROM INFORMATION_SCHEMA.INNODB_TABLESPACES </code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE 'test/t1';</code></strong>
+---------+-----------------+
| NAME    | AUTOEXTEND_SIZE |
+---------+-----------------+
| test/t1 |         4194304 |
+---------+-----------------+

mysql&gt; <strong class="userinput"><code>SELECT NAME, AUTOEXTEND_SIZE FROM INFORMATION_SCHEMA.INNODB_TABLESPACES </code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE 'ts1';</code></strong>
+------+-----------------+
| NAME | AUTOEXTEND_SIZE |
+------+-----------------+
| ts1  |         4194304 |
+------+-----------------+
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">AUTOEXTEND_SIZE</code> のデフォルト設定である 0 は、テーブルスペースが前述のデフォルトのテーブルスペース拡張動作に従って拡張されることを意味します。
      </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-doublewrite-buffer"></a>15.6.4 二重書き込みバッファー</h3></div></div></div><p>
      二重書込みバッファは、<code class="literal">InnoDB</code> データファイル内の適切な位置にページを書き込む前に、バッファプールからフラッシュされたページを <code class="literal">InnoDB</code> が書き込む記憶域です。 ページ書込み中にオペレーティングシステム、ストレージサブシステムまたは予期しない <span class="command"><strong>mysqld</strong></span> プロセスが終了した場合、<code class="literal">InnoDB</code> はクラッシュリカバリ中に二重書込みバッファからページの適切なコピーを見つけることができます。 
    </p><p>
      データは 2 回書き込まれますが、二重書込みバッファには I/O オーバーヘッドの 2 倍や I/O 操作の 2 倍は必要ありません。 データは、オペレーティングシステムへの単一の <code class="literal">fsync()</code> コールを使用して、大きいシーケンシャルチャンクで二重書込みバッファに書き込まれます (<code class="literal">innodb_flush_method</code> が <code class="literal">O_DIRECT_NO_FSYNC</code> に設定されている場合を除く)。 
    </p><p>
      MySQL 8.0.20 より前は、二重書込みバッファ記憶域は <code class="literal">InnoDB</code> システムテーブルスペースにありました。 MySQL 8.0.20 では、二重書込みバッファ記憶域は二重書込みファイルにあります。 
    </p><p>
      二重書込みバッファ構成には、次の変数が用意されています:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">innodb_doublewrite</code>
        </p><p>
          <code class="literal">innodb_doublewrite</code> 変数は、二重書込みバッファを有効にするかどうかを制御します。 ほとんどの場合、デフォルトで有効になっています。 二重書込みバッファを無効にするには、<code class="literal">innodb_doublewrite</code> を 0 に設定するか、<code class="literal">--skip-innodb-doublewrite</code> でサーバーを起動します。 たとえば、ベンチマークの実行時などのように、データ整合性よりもパフォーマンスに関心がある場合は、二重書込みバッファを無効にすることを検討してください。 
        </p><p>
          二重書き込みバッファーがアトミック書き込みをサポートする Fusion-io デバイス上にある場合、二重書き込みバッファーは自動的に無効になり、代わりに Fusion-io アトミック書き込みを使用してデータファイル書き込みが実行されます。 ただし、<code class="literal">innodb_doublewrite</code> 設定はグローバルであることに注意してください。 二重書き込みバッファーが無効になっている場合、Fusion-io ハードウェア上に存在しないデータファイルを含むすべてのデータファイルに対して無効になります。 この機能は Fusion-io ハードウェアでのみサポートされ、Linux の Fusion-io NVMFS でのみ有効になります。 この機能を最大限に活用するには、<code class="literal">O_DIRECT</code> の <code class="literal">innodb_flush_method</code> 設定をお薦めします。 
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_doublewrite_dir</code>
        </p><p>
          <code class="literal">innodb_doublewrite_dir</code> 変数 (MySQL 8.0.20 で導入) は、<code class="literal">InnoDB</code> が二重書込みファイルを作成するディレクトリを定義します。 ディレクトリが指定されていない場合、二重書込みファイルが <code class="literal">innodb_data_home_dir</code> ディレクトリに作成され、指定されていない場合はデータディレクトリにデフォルト設定されます。 
        </p><p>
          スキーマ名との競合を避けるために、指定されたディレクトリ名の前にハッシュ記号'#'が自動的に付加されます。 ただし、ディレクトリ名に'.'、'#'、または'/'接頭辞が明示的に指定されている場合、ディレクトリ名の前にハッシュ記号'#'は付けられません。 
        </p><p>
          二重書込みディレクトリは、使用可能な最も高速なストレージメディアに配置することが理想的です。
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_doublewrite_files</code>
        </p><p>
          <code class="literal">innodb_doublewrite_files</code> 変数は、二重書込みファイルの数を定義します。 デフォルトでは、バッファプールインスタンスごとに 2 つの二重書込みファイルが作成されます: フラッシュリスト二重書込みファイルおよび LRU リスト二重書込みファイル。 
        </p><p>
          フラッシュリスト二重書き込みファイルは、バッファープールのフラッシュリストからフラッシュされたページ用です。 フラッシュリストの二重書込みファイルのデフォルトサイズは、<code class="literal">InnoDB</code> ページサイズ * 二重書込みページバイトです。 
        </p><p>
          LRU リストの二重書込みファイルは、バッファプール LRU リストからフラッシュされたページ用です。 また、単一ページフラッシュ用のスロットも含まれます。 LRU リスト二重書込みファイルのデフォルトサイズは、<code class="literal">InnoDB</code> ページサイズ * (二重書込みページ + (512 / バッファプールインスタンスの数)) です。512 は、単一ページフラッシュ用に予約されたスロットの合計数です。 
        </p><p>
          少なくとも 2 つの二重書込みファイルがあります。 二重書込みファイルの最大数は、バッファプールインスタンスの 2 倍です。 (バッファープールインスタンスの数は、<code class="literal">innodb_buffer_pool_instances</code> 変数によって制御されます。) 
        </p><p>
          二重書込みファイル名の形式は次のとおりです: <code class="filename">#ib_<em class="replaceable"><code>page_size</code></em>_<em class="replaceable"><code>file_number</code></em>.dblwr</code>。 たとえば、次の二重書込みファイルは、<code class="literal">InnoDB</code> ページサイズが 16KB で単一のバッファプールの MySQL インスタンスに対して作成されます: 
        </p><pre class="programlisting">#ib_16384_0.dblwr
#ib_16384_1.dblwr
</pre><p>
          <code class="literal">innodb_doublewrite_files</code> 変数は、高度なパフォーマンスチューニングを目的としています。 デフォルト設定は、ほとんどのユーザーに適しています。 
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_doublewrite_pages</code>
        </p><p>
          <code class="literal">innodb_doublewrite_pages</code> 変数 (MySQL 8.0.20 で導入) は、スレッド当たりの二重書込みページの最大数を制御します。 値が指定されていない場合、<code class="literal">innodb_doublewrite_pages</code> は <code class="literal">innodb_write_io_threads</code> 値に設定されます。 この変数は高度なパフォーマンスチューニングを目的としています。 デフォルト値は、ほとんどのユーザーに適しています。 
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_doublewrite_batch_size</code>
        </p><p>
          <code class="literal">innodb_doublewrite_batch_size</code> 変数 (MySQL 8.0.20 で導入) は、バッチで書き込む二重書込みページの数を制御します。 この変数は高度なパフォーマンスチューニングを目的としています。 デフォルト値は、ほとんどのユーザーに適しています。 
        </p></li></ul></div><p>
      MySQL 8.0.23 では、<code class="literal">InnoDB</code> は暗号化されたテーブルスペースに属する二重書込みファイルページを自動的に暗号化します (<a class="xref" href="innodb-storage-engine.html#innodb-data-encryption" title="15.13 InnoDB 保存データ暗号化">セクション15.13「InnoDB 保存データ暗号化」</a> を参照)。 同様に、ページ圧縮テーブルスペースに属する二重書込みファイルページも圧縮されます。 その結果、二重書込みファイルには、暗号化されていないページと圧縮されていないページ、暗号化されたページ、圧縮されたページ、暗号化と圧縮の両方を含む様々なページタイプを含めることができます。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-redo-log"></a>15.6.5 redo ログ</h3></div></div></div><a class="indexterm" name="idm44761362634448"></a><a class="indexterm" name="idm44761362632304"></a><p>
      redo ログは、不完全なトランザクションによって書き込まれたデータを修正するためにクラッシュリカバリ中に使用されるディスクベースのデータ構造です。 通常の操作中、redo ログは、SQL ステートメントまたは低レベルの API コールによって発生したテーブルデータを変更するリクエストをエンコードします。 予期しないシャットダウンの前にデータファイルの更新を終了しなかった変更は、初期化中、および接続が受け入れられる前に自動的にリプレイされます。 クラッシュリカバリにおける redo ログの役割の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-recovery" title="15.18.2 InnoDB のリカバリ">セクション15.18.2「InnoDB のリカバリ」</a> を参照してください。 
    </p><p>
      デフォルトでは、redo ログはディスク上で <code class="filename">ib_logfile0</code> および <code class="filename">ib_logfile1</code> という名前の 2 つのファイルによって物理的に表されます。 MySQL は、redo ログファイルに循環して書き込みます。 redo ログ内のデータは、影響を受けるレコードに関してエンコードされます。このデータはまとめて redo と呼ばれます。 redo ログを介したデータの受渡しは、増加する <a class="link" href="glossary.html#glos_lsn" title="LSN">LSN</a> 値で表されます。 
    </p><p>
      関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-startup-log-file-configuration" title="redo ログファイル構成">redo ログファイル構成</a>,および<a class="xref" href="optimization.html#optimizing-innodb-logging" title="8.5.4 InnoDB redo ロギングの最適化">セクション8.5.4「InnoDB redo ロギングの最適化」</a>を参照してください。
    </p><p>
      redo ログの保存データ暗号化の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-redo-log" title="redo ログの暗号化">redo ログの暗号化</a> を参照してください。
    </p><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-redo-log-file-reconfigure"></a>redo ログファイルの数またはサイズの変更</h4></div></div></div><a class="indexterm" name="idm44761362620256"></a><a class="indexterm" name="idm44761362618112"></a><p>
        <a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">redo log</a> ファイルの数またはサイズを変更するには、次のステップを実行します:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            MySQL サーバーを停止し、エラーなしでシャットダウンされることを確認します。
          </p></li><li class="listitem"><p>
            <code class="filename">my.cnf</code> を編集して、ログファイルの構成を変更します。 ログファイルのサイズを変更するには、<code class="literal">innodb_log_file_size</code> を構成します。 ログファイルの数を多くするには、<code class="literal">innodb_log_files_in_group</code> を構成します。 
          </p></li><li class="listitem"><p>
            MySQL サーバーを再起動します。
          </p></li></ol></div><p>
        <code class="literal">InnoDB</code> は、<code class="literal">innodb_log_file_size</code> と redo ログファイルのサイズが異なることを検出すると、ログチェックポイントを書き込み、古いログファイルを閉じて削除し、リクエストされたサイズで新しいログファイルを作成し、新しいログファイルを開きます。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-performance-group_commit"></a>redo ログフラッシュのグループコミット</h4></div></div></div><a class="indexterm" name="idm44761362604592"></a><p>
        <code class="literal">InnoDB</code> は、他の <a class="link" href="glossary.html#glos_acid" title="ACID">ACID</a> 準拠のデータベースエンジンと同様に、コミット前にトランザクションの <a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">redo log</a> をフラッシュします。 <code class="literal">InnoDB</code> では、<a class="link" href="glossary.html#glos_group_commit" title="グループコミット">group commit</a> 機能を使用してこのような複数のフラッシュリクエストをグループ化し、コミットごとに 1 つのフラッシュを回避します。 グループコミットでは、<code class="literal">InnoDB</code> はログファイルに単一の書込みを発行して、ほぼ同時にコミットする複数のユーザートランザクションに対してコミットアクションを実行し、スループットを大幅に向上させます。 
      </p><p>
        <code class="literal">COMMIT</code> やその他のトランザクション操作のパフォーマンスの詳細は、<a class="xref" href="optimization.html#optimizing-innodb-transaction-management" title="8.5.2 InnoDB トランザクション管理の最適化">セクション8.5.2「InnoDB トランザクション管理の最適化」</a>を参照してください。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-redo-log-archiving"></a>redo ログのアーカイブ</h4></div></div></div><a class="indexterm" name="idm44761362593472"></a><p>
        redo ログレコードをコピーするバックアップユーティリティは、バックアップ操作の進行中に redo ログの生成に対応できない場合があり、その結果、それらのレコードが上書きされるために redo ログレコードが失われます。 この問題は、多くの場合、バックアップ操作中に重大な MySQL サーバーアクティビティが発生し、redo ログファイルストレージメディアがバックアップストレージメディアより高速に動作する場合に発生します。 MySQL 8.0.17 で導入された redo ログアーカイブ機能は、redo ログファイルに加えて redo ログレコードをアーカイブファイルに順次書き込むことで、この問題に対処します。 バックアップユーティリティでは、必要に応じてアーカイブファイルから redo ログレコードをコピーできるため、データが失われる可能性を回避できます。 
      </p><p>
        redo ログアーカイブがサーバーで構成されている場合、<a class="ulink" href="https://www.mysql.com/products/enterprise/" target="_top">MySQL Enterprise Edition</a> で使用可能な <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/8.0/en/" target="_top">MySQL Enterprise Backup</a> は、MySQL サーバーのバックアップ時に redo ログアーカイブ機能を使用します。
      </p><p>
        サーバーで redo ログアーカイブを有効にするには、<code class="literal">innodb_redo_log_archive_dirs</code> システム変数の値を設定する必要があります。 この値は、ラベル付き redo ログアーカイブディレクトリのセミコロン区切りリストとして指定されます。 <code class="literal"><em class="replaceable"><code>label:directory</code></em></code> ペアはコロン (<code class="literal">:</code>) で区切られます。 例: 
      </p><pre class="programlisting">mysql&gt; SET GLOBAL innodb_redo_log_archive_dirs='<em class="replaceable"><code>label1</code></em>:<em class="replaceable"><code>directory_path1</code></em>[;<em class="replaceable"><code>label2</code></em>:<em class="replaceable"><code>directory_path2</code></em>;…]';</pre><p>
        <em class="replaceable"><code>label</code></em> は、アーカイブディレクトリの任意の識別子です。 コロン (:) を除いて、任意の文字列を指定できますが、これは許可されません。 空のラベルも使用できますが、この場合もコロン (:) が必要です。 <em class="replaceable"><code>directory_path</code></em> を指定する必要があります。 redo ログアーカイブがアクティブ化されている場合は、redo ログアーカイブファイル用に選択されたディレクトリが存在する必要があります。存在しない場合は、エラーが返されます。 パスにはコロン (':') を含めることができますが、セミコロン (;) は使用できません。 
      </p><p>
        redo ログアーカイブをアクティブ化する前に、<code class="literal">innodb_redo_log_archive_dirs</code> 変数を構成する必要があります。 デフォルト値は <code class="literal">NULL</code> で、redo ログアーカイブのアクティブ化は許可されません。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">メモ</div><p>
          指定するアーカイブディレクトリは、次の要件を満たす必要があります。 (要件は、redo ログアーカイブがアクティブ化されたときに適用されます。): 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              ディレクトリが存在する必要があります。 redo ログアーカイブプロセスでは、ディレクトリは作成されません。 それ以外の場合は、次のエラーが返されます: 
            </p><p>
              <span class="errortext">ERROR 3844 (HY000): redo ログアーカイブディレクトリ'<em class="replaceable"><code>directory_path1</code></em>'が存在しないか、ディレクトリではありません</span>
            </p></li><li class="listitem"><p>
              ディレクトリはワールドアクセス可能にしないでください。 これは、redo ログデータがシステム上の権限のないユーザーに公開されないようにするためです。 それ以外の場合は、次のエラーが返されます: 
            </p><p>
              <span class="errortext">ERROR 3846 (HY000): redo ログアーカイブディレクトリ'<em class="replaceable"><code>directory_path1</code></em>'には、すべての OS ユーザーがアクセスできます</span>
            </p></li><li class="listitem"><p>
              ディレクトリには、<code class="literal">datadir</code>, <code class="literal">innodb_data_home_dir</code>, <code class="literal">innodb_directories</code>, <code class="literal">innodb_log_group_home_dir</code>, <code class="literal">innodb_temp_tablespaces_dir</code>, <code class="literal">innodb_tmpdir</code> <code class="literal">innodb_undo_directory</code> または <code class="literal">secure_file_priv</code> で定義されたディレクトリや、それらのディレクトリの親ディレクトリまたはサブディレクトリを指定できません。 それ以外の場合は、次のようなエラーが返されます: 
            </p><p>
              <span class="errortext">ERROR 3845 (HY000): redo ログアーカイブディレクトリ'<em class="replaceable"><code>directory_path1</code></em>'は、サーバーディレクトリ'datadir'の下または上にあります - ' <em class="replaceable"><code>/path/to/data_directory</code></em> '</span>
            </p></li></ul></div></div><p>
        redo ログアーカイブをサポートするバックアップユーティリティがバックアップを開始すると、バックアップユーティリティは <code class="literal">innodb_redo_log_archive_start()</code> ユーザー定義関数を起動して redo ログアーカイブをアクティブ化します。
      </p><p>
        redo ログのアーカイブをサポートするバックアップユーティリティを使用していない場合は、次に示すように、redo ログのアーカイブを手動でアクティブ化することもできます:
      </p><pre class="programlisting">mysql&gt; SELECT innodb_redo_log_archive_start('<em class="replaceable"><code>label</code></em>', '<em class="replaceable"><code>subdir</code></em>');
+------------------------------------------+
| innodb_redo_log_archive_start('<em class="replaceable"><code>label</code></em>') |
+------------------------------------------+
| 0                                        |
+------------------------------------------+
</pre><p>
        または:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>DO innodb_redo_log_archive_start('<em class="replaceable"><code>label</code></em>', '<em class="replaceable"><code>subdir</code></em>');</code></strong>
Query OK, 0 rows affected (0.09 sec)
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          (<code class="literal">innodb_redo_log_archive_start()</code> を使用して) redo ログアーカイブをアクティブ化する MySQL セッションは、アーカイブ中はオープンのままである必要があります。 同じセッションで (<code class="literal">innodb_redo_log_archive_stop()</code> を使用して) redo ログアーカイブを非アクティブ化する必要があります。 redo ログアーカイブが明示的に非アクティブ化される前にセッションが終了した場合、サーバーは redo ログアーカイブを暗黙的に非アクティブ化し、redo ログアーカイブファイルを削除します。 
        </p></div><p>
        ここで、<em class="replaceable"><code>label</code></em> は <code class="literal">innodb_redo_log_archive_dirs</code> によって定義されたラベルです。<code class="literal">subdir</code> は、アーカイブファイルを保存するために <em class="replaceable"><code>label</code></em> によって識別されるディレクトリのサブディレクトリを指定するためのオプションの引数です。単純なディレクトリ名である必要があります (スラッシュ (/)、バックスラッシュ (\),またはコロン (:) は使用できません)。<code class="literal">subdir</code> は空または null にすることも、省略することもできます。
      </p><p>
        <code class="literal">innodb_redo_log_archive_start()</code> を起動して redo ログアーカイブをアクティブ化するか、<code class="literal">innodb_redo_log_archive_stop()</code> を使用して非アクティブ化できるのは、<code class="literal">INNODB_REDO_LOG_ARCHIVE</code> 権限を持つユーザーのみです。 バックアップユーティリティを実行している MySQL ユーザーまたは redo ログアーカイブを手動でアクティブ化および非アクティブ化する MySQL ユーザーには、この権限が必要です。 
      </p><p>
        redo ログアーカイブファイルのパスは <code class="filename"><em class="replaceable"><code>directory_identified_by_label</code></em>/[<em class="replaceable"><code>subdir</code></em>/]archive.<em class="replaceable"><code>serverUUID</code></em>.000001.log</code> です。ここで、<code class="filename"><em class="replaceable"><code>directory_identified_by_label</code></em></code> は <code class="literal">innodb_redo_log_archive_start()</code> の <code class="literal"><em class="replaceable"><code>label</code></em></code> 引数で識別されるアーカイブディレクトリです。<code class="filename"><em class="replaceable"><code>subdir</code></em></code> は、<code class="literal">innodb_redo_log_archive_start()</code> に使用されるオプションの引数です。
      </p><p>
        たとえば、redo ログアーカイブファイルのフルパスと名前は次のようになります:
      </p><pre class="programlisting">/<em class="replaceable"><code>directory_path</code></em>/<em class="replaceable"><code>subdirectory</code></em>/archive.e71a47dc-61f8-11e9-a3cb-080027154b4d.000001.log
</pre><p>
        バックアップユーティリティは、<code class="literal">InnoDB</code> データファイルのコピーを終了した後、<code class="literal">innodb_redo_log_archive_stop()</code> ユーザー定義関数をコールして redo ログアーカイブを非アクティブ化します。
      </p><p>
        redo ログのアーカイブをサポートするバックアップユーティリティを使用していない場合は、次に示すように、redo ログのアーカイブを手動で非アクティブ化することもできます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT innodb_redo_log_archive_stop();</code></strong>
+--------------------------------+
| innodb_redo_log_archive_stop() |
+--------------------------------+
| 0                              |
+--------------------------------+
</pre><p>
        または:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>DO innodb_redo_log_archive_stop();</code></strong>
Query OK, 0 rows affected (0.01 sec)
</pre><p>
        停止機能が正常に完了すると、バックアップユーティリティはアーカイブファイルから redo ログデータの関連セクションを検索し、それをバックアップにコピーします。
      </p><p>
        バックアップユーティリティが redo ログデータのコピーを終了し、redo ログアーカイブファイルが不要になると、アーカイブファイルは削除されます。
      </p><p>
        アーカイブファイルの削除は、通常の状況ではバックアップユーティリティの役割を果たします。 ただし、<code class="literal">innodb_redo_log_archive_stop()</code> がコールされる前に redo ログのアーカイブ操作が予期せず終了した場合、MySQL サーバーはファイルを削除します。 
      </p><h5><a name="idm44761362517968"></a>パフォーマンスに関する考慮事項</h5><p>
        通常、redo ログアーカイブをアクティブ化すると、書込みアクティビティが追加されるため、パフォーマンスが若干低下します。
      </p><p>
        Unix および Unix に似たオペレーティングシステムでは、パフォーマンスへの影響は、通常、高い更新率が持続しないことを前提としています。 Windows では、通常、パフォーマンスへの影響は少し大きくなります (同じことを前提としています)。 
      </p><p>
        継続的に高い更新率があり、redo ログアーカイブファイルが redo ログファイルと同じ記憶域メディアにある場合、複合書込みアクティビティが原因でパフォーマンスへの影響が大きくなる可能性があります。
      </p><p>
        継続的に高い更新率があり、redo ログアーカイブファイルが redo ログファイルより低速なストレージメディア上にある場合、パフォーマンスには任意の影響があります。
      </p><p>
        redo ログアーカイブファイルへの書込みでは、redo ログアーカイブファイルの記憶域メディアが redo ログファイルの記憶域メディアよりもはるかに低速で動作し、redo ログアーカイブファイルへの書込みを待機している永続 redo ログブロックの大きなバックログがある場合を除き、通常のトランザクションロギングは妨げられません。 この場合、トランザクションロギング率は、redo ログアーカイブファイルが存在する低速の記憶域メディアで管理できるレベルに削減されます。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-disable-redo-logging"></a>redo ロギングの無効化</h4></div></div></div><p>
        MySQL 8.0.21 では、<code class="literal">ALTER INSTANCE DISABLE INNODB REDO_LOG</code> ステートメントを使用して redo ロギングを無効にできます。 この機能は、新しい MySQL インスタンスにデータをロードするためのものです。 redo ロギングを無効にすると、redo ログの書込みおよび二重書込みバッファリングが回避され、データのロードが高速化されます。 
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          この機能は、新しい MySQL インスタンスへのデータのロードのみを目的としています。 <span class="emphasis"><em>本番システムで redo ロギングを無効にしないでください。</em></span> redo ロギングが無効化されている間はサーバーを停止して再起動できますが、redo ロギングが無効化されている間に予期しないサーバーストップページが発生すると、データが失われ、インスタンスが破損する可能性があります。 
        </p><p>
          redo ロギングが無効化されている間に予期しないサーバー停止ページの後にサーバーを再起動しようとすると、次のエラーで拒否されます:
        </p><pre class="programlisting">[ERROR] [MY-013578] [InnoDB] Server was killed when Innodb Redo 
logging was disabled. Data files could be corrupt. You can try 
to restart the database with innodb_force_recovery=6
</pre><p>
          この場合、新しい MySQL インスタンスを初期化し、データロードプロシージャを再度開始します。
        </p></div><p>
        redo ロギングを有効化および無効化するには、<code class="literal">INNODB_REDO_LOG_ENABLE</code> 権限が必要です。
      </p><p>
        <code class="literal">Innodb_redo_log_enabled</code> ステータス変数を使用すると、redo ロギングステータスを監視できます。
      </p><p>
        redo ロギングが無効化されている間は、クローニング操作および redo ログアーカイブは許可されません。その逆も同様です。
      </p><p>
        <code class="literal">ALTER INSTANCE [ENABLE|DISABLE] INNODB REDO_LOG</code> 操作には排他的バックアップメタデータロックが必要で、これにより他の <code class="literal">ALTER INSTANCE</code> 操作が同時に実行されなくなります。 その他の <code class="literal">ALTER INSTANCE</code> 操作は、ロックが解放されるまで待機してから実行する必要があります。 
      </p><p>
        次の手順は、新しい MySQL インスタンスにデータをロードするときに redo ロギングを無効にする方法を示しています。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            新しい MySQL インスタンスで、redo ロギングを無効にするユーザーアカウントに <code class="literal">INNODB_REDO_LOG_ENABLE</code> 権限を付与します。
          </p><pre class="programlisting">mysql&gt; GRANT INNODB_REDO_LOG_ENABLE ON *.* to 'data_load_admin';</pre></li><li class="listitem"><p>
            <code class="literal">data_load_admin</code> ユーザーとして、redo ロギングを無効にします:
          </p><pre class="programlisting">mysql&gt; ALTER INSTANCE DISABLE INNODB REDO_LOG;</pre></li><li class="listitem"><p>
            <code class="literal">Innodb_redo_log_enabled</code> ステータス変数をチェックして、redo ロギングが無効になっていることを確認します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW GLOBAL STATUS LIKE 'Innodb_redo_log_enabled';</code></strong>
+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| Innodb_redo_log_enabled | OFF   |
+-------------------------+-------+
</pre></li><li class="listitem"><p>
            データロード操作を実行します。
          </p></li><li class="listitem"><p>
            <code class="literal">data_load_admin</code> ユーザーとして、データロード操作の終了後に redo ロギングを有効にします:
          </p><pre class="programlisting">mysql&gt; ALTER INSTANCE ENABLE INNODB REDO_LOG;</pre></li><li class="listitem"><p>
            <code class="literal">Innodb_redo_log_enabled</code> ステータス変数をチェックして、redo ロギングが有効になっていることを確認します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW GLOBAL STATUS LIKE 'Innodb_redo_log_enabled';</code></strong>
+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| Innodb_redo_log_enabled | ON    |
+-------------------------+-------+
</pre></li></ol></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-undo-logs"></a>15.6.6 undo ログ</h3></div></div></div><p>
      undo ログは、単一の読取り/書込みトランザクションに関連付けられた undo ログレコードの集合です。 undo ログレコードには、トランザクションによる <a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">clustered index</a> レコードへの最新の変更を元に戻す方法に関する情報が含まれます。 別のトランザクションで読取り一貫性操作の一部として元のデータを参照する必要がある場合、未変更のデータは undo ログレコードから取得されます。 undo ログは、<a class="link" href="glossary.html#glos_rollback_segment" title="ロールバックセグメント">rollback segments</a> 内に含まれる <a class="link" href="glossary.html#glos_undo_log_segment" title="undo ログセグメント">undo log segments</a> 内に存在します。 ロールバックセグメントは、<a class="link" href="glossary.html#glos_undo_tablespace" title="Undo テーブルスペース">undo tablespaces</a> および <a class="link" href="glossary.html#glos_global_temporary_tablespace" title="グローバル一時テーブルスペース">global temporary tablespace</a> にあります。 
    </p><p>
      グローバル一時テーブルスペースに存在する undo ログは、ユーザー定義一時テーブルのデータを変更するトランザクションに使用されます。 これらの undo ログは、クラッシュリカバリに必要ないため、redo ログには記録されません。 これらは、サーバーの実行中のロールバックにのみ使用されます。 このタイプの undo ログは、redo ロギング I/O を回避することでパフォーマンスを向上させます。 
    </p><p>
      undo ログの保存データ暗号化の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-undo-log" title="undo ログの暗号化">undo ログの暗号化</a> を参照してください。
    </p><p>
      各 undo テーブルスペースとグローバル一時テーブルスペースは、それぞれ最大 128 個のロールバックセグメントをサポートします。 <code class="literal">innodb_rollback_segments</code> 変数は、ロールバックセグメントの数を定義します。 
    </p><p>
      ロールバックセグメントでサポートされるトランザクションの数は、ロールバックセグメント内の undo スロットの数および各トランザクションに必要な undo ログの数によって異なります。
    </p><p>
      ロールバックセグメントの undo スロットの数は、<code class="literal">InnoDB</code> のページサイズによって異なります。
    </p><div class="informaltable"><table summary="Number of undo slots in a rollback segment for each InnoDB page size"><col style="width: 50%"><col style="width: 50%"><thead><tr>
          <th>InnoDB ページサイズ</th>
          <th>ロールバックセグメント内の undo スロット数 (InnoDB ページサイズ / 16)</th>
        </tr></thead><tbody><tr>
          <td><code class="literal">4096 (4KB)</code></td>
          <td><code class="literal">256</code></td>
        </tr><tr>
          <td><code class="literal">8192 (8KB)</code></td>
          <td><code class="literal">512</code></td>
        </tr><tr>
          <td><code class="literal">16384 (16KB)</code></td>
          <td><code class="literal">1024</code></td>
        </tr><tr>
          <td><code class="literal">32768 (32KB)</code></td>
          <td><code class="literal">2048</code></td>
        </tr><tr>
          <td><code class="literal">65536 (64KB)</code></td>
          <td><code class="literal">4096</code></td>
        </tr></tbody></table></div><p>
      トランザクションには、次の操作タイプごとに 1 つずつ、最大 4 つの undo ログが割り当てられます:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          ユーザー定義テーブルに対する <code class="literal">INSERT</code> 操作
        </p></li><li class="listitem"><p>
          ユーザー定義テーブルに対する <code class="literal">UPDATE</code> および <code class="literal">DELETE</code> 操作
        </p></li><li class="listitem"><p>
          ユーザー定義一時テーブルに対する <code class="literal">INSERT</code> 操作
        </p></li><li class="listitem"><p>
          ユーザー定義一時テーブルに対する <code class="literal">UPDATE</code> および <code class="literal">DELETE</code> 操作
        </p></li></ol></div><p>
      undo ログは必要に応じて割り当てられます。 たとえば、通常のテーブルおよび一時テーブルに対して <code class="literal">INSERT</code>、<code class="literal">UPDATE</code> および <code class="literal">DELETE</code> 操作を実行するトランザクションには、4 つの undo ログの完全な割当てが必要です。 通常のテーブルに対して <code class="literal">INSERT</code> 操作のみを実行するトランザクションには、単一の undo ログが必要です。 
    </p><p>
      通常のテーブルに対して操作を実行するトランザクションには、割り当てられた undo テーブルスペースロールバックセグメントから undo ログが割り当てられます。 一時テーブルに対して操作を実行するトランザクションには、割り当てられたグローバル一時テーブルスペースロールバックセグメントから undo ログが割り当てられます。 
    </p><p>
      トランザクションに割り当てられた undo ログは、その期間中トランザクションに関連付けられたままになります。 たとえば、通常のテーブルに対する <code class="literal">INSERT</code> 操作のトランザクションに割り当てられた undo ログは、そのトランザクションによって実行される通常のテーブルに対するすべての <code class="literal">INSERT</code> 操作に使用されます。 
    </p><p>
      前述の要因に基づき、次の式を使用して、<code class="literal">InnoDB</code> がサポートできる同時読取り/書込みトランザクションの数を見積もることができます。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">InnoDB</code> がサポートできる同時読取り/書込みトランザクションの数に達する前に、トランザクションで同時トランザクション制限エラーが発生する場合があります。 これは、トランザクションに割り当てられたロールバックセグメントで undo スロットが不足した場合に発生します。 このような場合は、トランザクションを再実行してください。 
      </p><p>
        トランザクションが一時テーブルに対して操作を実行する場合、<code class="literal">InnoDB</code> がサポートできる同時読取り/書込みトランザクションの数は、グローバル一時テーブルスペース (デフォルトで 128) に割り当てられたロールバックセグメントの数によって制約されます。
      </p></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          各トランザクションが <code class="literal">INSERT</code>、<code class="literal">UPDATE</code> または <code class="literal">DELETE</code> のいずれかの操作を実行する場合、<code class="literal">InnoDB</code> がサポートできる同時読取り/書込みトランザクションの数は次のとおりです:
        </p><pre class="programlisting">(innodb_page_size / 16) * innodb_rollback_segments * number of undo tablespaces
</pre></li><li class="listitem"><p>
          各トランザクションが <code class="literal">INSERT</code> および <code class="literal">UPDATE</code> または <code class="literal">DELETE</code> 操作を実行する場合、<code class="literal">InnoDB</code> がサポートできる同時読取り/書込みトランザクションの数は次のとおりです:
        </p><pre class="programlisting">(innodb_page_size / 16 / 2) * innodb_rollback_segments * number of undo tablespaces
</pre></li><li class="listitem"><p>
          各トランザクションが一時テーブルに対して <code class="literal">INSERT</code> 操作を実行する場合、<code class="literal">InnoDB</code> がサポートできる同時読取り/書込みトランザクションの数は次のとおりです:
        </p><pre class="programlisting">(innodb_page_size / 16) * innodb_rollback_segments
</pre></li><li class="listitem"><p>
          各トランザクションが一時テーブルに対して <code class="literal">INSERT</code> および <code class="literal">UPDATE</code> または <code class="literal">DELETE</code> 操作を実行する場合、<code class="literal">InnoDB</code> がサポートできる同時読取り/書込みトランザクションの数は次のとおりです:
        </p><pre class="programlisting">(innodb_page_size / 16 / 2) * innodb_rollback_segments
</pre></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-locking-transaction-model"></a>15.7 InnoDB のロックおよびトランザクションモデル</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-locking">15.7.1 InnoDB ロック</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-transaction-model">15.7.2 InnoDB トランザクションモデル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-locks-set">15.7.3 InnoDB のさまざまな SQL ステートメントで設定されたロック</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-next-key-locking">15.7.4 ファントム行</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-deadlocks">15.7.5 InnoDB のデッドロック</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-transaction-scheduling">15.7.6 トランザクションスケジューリング</a></span></dt></dl></div><a class="indexterm" name="idm44761362393088"></a><a class="indexterm" name="idm44761362390944"></a><a class="indexterm" name="idm44761362388928"></a><a class="indexterm" name="idm44761362387584"></a><p>
    大規模、ビジーまたは信頼性の高いデータベースアプリケーションを実装して、異なるデータベースシステムから大幅なコードを移植したり、MySQL のパフォーマンスをチューニングするには、<code class="literal">InnoDB</code> のロックおよび <code class="literal">InnoDB</code> トランザクションモデルを理解することが重要です。
  </p><p>
    このセクションでは、<code class="literal">InnoDB</code> のロックおよび理解しておく必要がある <code class="literal">InnoDB</code> トランザクションモデルに関連するいくつかのトピックについて説明します。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="xref" href="innodb-storage-engine.html#innodb-locking" title="15.7.1 InnoDB ロック">セクション15.7.1「InnoDB ロック」</a> では、<code class="literal">InnoDB</code> で使用されるロックタイプについて説明します。
      </p></li><li class="listitem"><p>
        <a class="xref" href="innodb-storage-engine.html#innodb-transaction-model" title="15.7.2 InnoDB トランザクションモデル">セクション15.7.2「InnoDB トランザクションモデル」</a> では、トランザクション分離レベルおよびそれぞれで使用されるロック戦略について説明します。 また、<code class="literal">autocommit</code>、一貫性非ロック読取りおよびロック読取りの使用についても説明します。 
      </p></li><li class="listitem"><p>
        <a class="xref" href="innodb-storage-engine.html#innodb-locks-set" title="15.7.3 InnoDB のさまざまな SQL ステートメントで設定されたロック">セクション15.7.3「InnoDB のさまざまな SQL ステートメントで設定されたロック」</a> では、様々なステートメントに対して <code class="literal">InnoDB</code> で設定される特定のタイプのロックについて説明します。
      </p></li><li class="listitem"><p>
        <a class="xref" href="innodb-storage-engine.html#innodb-next-key-locking" title="15.7.4 ファントム行">セクション15.7.4「ファントム行」</a> では、<code class="literal">InnoDB</code> が次のキーロックを使用してファントム行を回避する方法について説明します。
      </p></li><li class="listitem"><p>
        <a class="xref" href="innodb-storage-engine.html#innodb-deadlocks" title="15.7.5 InnoDB のデッドロック">セクション15.7.5「InnoDB のデッドロック」</a> にはデッドロックの例が用意されており、デッドロックの検出について説明し、<code class="literal">InnoDB</code> でデッドロックを最小化および処理するためのヒントを提供しています。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-locking"></a>15.7.1 InnoDB ロック</h3></div></div></div><a class="indexterm" name="idm44761362367200"></a><a class="indexterm" name="idm44761362365088"></a><a class="indexterm" name="idm44761362363168"></a><a class="indexterm" name="idm44761362361024"></a><a class="indexterm" name="idm44761362358976"></a><a class="indexterm" name="idm44761362356944"></a><a class="indexterm" name="idm44761362354880"></a><a class="indexterm" name="idm44761362352848"></a><a class="indexterm" name="idm44761362350784"></a><a class="indexterm" name="idm44761362348704"></a><a class="indexterm" name="idm44761362346656"></a><a class="indexterm" name="idm44761362345296"></a><a class="indexterm" name="idm44761362343952"></a><a class="indexterm" name="idm44761362342576"></a><a class="indexterm" name="idm44761362341232"></a><a class="indexterm" name="idm44761362339856"></a><a class="indexterm" name="idm44761362338464"></a><p>
      このセクションでは、<code class="literal">InnoDB</code> で使用されるロックタイプについて説明します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-shared-exclusive-locks" title="共有ロックと排他ロック">共有ロックと排他ロック</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-intention-locks" title="インテンションロック">インテンションロック</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-record-locks" title="レコードロック">レコードロック</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-gap-locks" title="ギャップロック">ギャップロック</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-next-key-locks" title="ネクストキーロック">ネクストキーロック</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-insert-intention-locks" title="インテンションロックの挿入">インテンションロックの挿入</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-auto-inc-locks" title="AUTO-INC ロック">AUTO-INC ロック</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-predicate-locks" title="空間インデックスの述語ロック">空間インデックスの述語ロック</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-shared-exclusive-locks"></a>共有ロックと排他ロック</h4></div></div></div><p>
        <code class="literal">InnoDB</code> では、2 つのロックタイプ (<a class="link" href="glossary.html#glos_shared_lock" title="共有ロック">共有 (<code class="literal">S</code>) ロック</a>と<a class="link" href="glossary.html#glos_exclusive_lock" title="排他ロック">排他 (<code class="literal">X</code>) ロック</a>) がある標準の行レベルロックが実装されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="link" href="glossary.html#glos_shared_lock" title="共有ロック">共有 (<code class="literal">S</code>) ロック</a>では、ロックを保持するトランザクションによる行の読み取りが許可されます。
          </p></li><li class="listitem"><p>
            <a class="link" href="glossary.html#glos_exclusive_lock" title="排他ロック">排他 (<code class="literal">X</code>) ロック</a>では、ロックを保持するトランザクションによる行の更新または削除が許可されます。
          </p></li></ul></div><p>
        トランザクション <code class="literal">T1</code> が行 <code class="literal">r</code> に対する共有 (<code class="literal">S</code>) ロックを保持している場合、別のトランザクション <code class="literal">T2</code> からの行 <code class="literal">r</code> に対するロック要求は次のように処理されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">T2</code> による <code class="literal">S</code> ロックに対するリクエストは、すぐに付与できます。 結果として、<code class="literal">T1</code> と <code class="literal">T2</code> の両方が <code class="literal">r</code> 上で <code class="literal">S</code> ロックを保持します。 
          </p></li><li class="listitem"><p>
            <code class="literal">T2</code> による <code class="literal">X</code> ロックに対するリクエストは、すぐに付与できません。
          </p></li></ul></div><p>
        トランザクション <code class="literal">T1</code> が行 <code class="literal">r</code> 上で排他 (<code class="literal">X</code>) ロックを保持している場合は、<code class="literal">r</code> 上のいずれかのタイプのロックに対する一部の個別のトランザクション <code class="literal">T2</code> からのリクエストは、すぐに付与できません。 代わりに、トランザクション <code class="literal">T2</code> は、行 <code class="literal">r</code> 上でトランザクション <code class="literal">T1</code> のロックが解放されるまで待機する必要があります。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-intention-locks"></a>インテンションロック</h4></div></div></div><p>
        <code class="literal">InnoDB</code> では、行ロックとテーブルロックの共存を許可する<span class="emphasis"><em>複数粒度ロック</em></span>がサポートされています。 たとえば、<code class="literal">LOCK TABLES ... WRITE</code> などのステートメントは、指定されたテーブルに対して排他ロック (<code class="literal">X</code> ロック) を取得します。 複数の粒度レベルでロックするには、<code class="literal">InnoDB</code> で <a class="link" href="glossary.html#glos_intention_lock" title="インテンションロック">intention locks</a> を使用します。 インテントロックは、トランザクションが後でテーブルの行に必要とするロックのタイプ (共有または排他) を示すテーブルレベルのロックです。 インテントロックには、次の 2 種類があります: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="link" href="glossary.html#glos_intention_shared_lock" title="インテンション共有ロック">intention shared lock</a> (<code class="literal">IS</code>) は、トランザクションがテーブルの個々の行に <span class="emphasis"><em>shared</em></span> ロックを設定することを示します。
          </p></li><li class="listitem"><p>
            <a class="link" href="glossary.html#glos_intention_exclusive_lock" title="インテンション排他ロック">intention exclusive lock</a> (<code class="literal">IX</code>) は、トランザクションがテーブル内の個々の行に排他ロックを設定することを示します。
          </p></li></ul></div><p>
        たとえば、<code class="literal">SELECT ... FOR SHARE</code> は <code class="literal">IS</code> ロックを設定し、<code class="literal">SELECT ... FOR UPDATE</code> は <code class="literal">IX</code> ロックを設定します。
      </p><p>
        インテンションロックの手順は次のとおりです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            トランザクションは、テーブル内の行に対する共有ロックを取得する前に、まず <code class="literal">IS</code> ロックを取得するか、テーブルに対して強いロックを取得する必要があります。
          </p></li><li class="listitem"><p>
            トランザクションは、テーブル内の行に対する排他ロックを取得する前に、まずテーブルに対する <code class="literal">IX</code> ロックを取得する必要があります。
          </p></li></ul></div><p>
        次のマトリックスに、テーブルレベルのロックタイプの互換性の概要を示します。
      </p><div class="informaltable"><table summary='A matrix showing table-level lock type compatibility. Each cell in the matrix is marked as either "Compatible" or "Conflict".'><col style="width: 20%"><col style="width: 20%"><col style="width: 20%"><col style="width: 20%"><col style="width: 20%"><thead><tr>
            <th scope="col"></th>
            <th scope="col"><code class="literal">X</code></th>
            <th scope="col"><code class="literal">IX</code></th>
            <th scope="col"><code class="literal">S</code></th>
            <th scope="col"><code class="literal">IS</code></th>
          </tr></thead><tbody><tr>
            <th scope="row"><code class="literal">X</code></th>
            <td>競合</td>
            <td>競合</td>
            <td>競合</td>
            <td>競合</td>
          </tr><tr>
            <th scope="row"><code class="literal">IX</code></th>
            <td>競合</td>
            <td>互換</td>
            <td>競合</td>
            <td>互換</td>
          </tr><tr>
            <th scope="row"><code class="literal">S</code></th>
            <td>競合</td>
            <td>競合</td>
            <td>互換</td>
            <td>互換</td>
          </tr><tr>
            <th scope="row"><code class="literal">IS</code></th>
            <td>競合</td>
            <td>互換</td>
            <td>互換</td>
            <td>互換</td>
          </tr></tbody></table></div><p>
        ロックに既存のロックとの互換性がある場合は、リクエスト元のトランザクションにロックが付与されますが、既存のロックと競合している場合は、ロックが付与されません。 トランザクションは、競合している既存のロックが解放されるまで待機します。 ロックリクエストが既存のロックと競合し、<a class="link" href="glossary.html#glos_deadlock" title="デッドロック">デッドロック</a>が発生するために付与できない場合は、エラーが発生します。 
      </p><p>
        意図的ロックでは、完全なテーブルリクエスト (<code class="literal">LOCK TABLES ... WRITE</code> など) 以外はブロックされません。 意図的ロックの主な目的は、誰かが行をロックしていること、またはテーブル内の行をロックしていることを示すことです。 
      </p><p>
        インテントロックのトランザクションデータは、<code class="literal">SHOW ENGINE INNODB STATUS</code> および <a class="link" href="innodb-storage-engine.html#innodb-standard-monitor" title="15.17.3 InnoDB 標準モニターおよびロックモニターの出力">InnoDB monitor</a> の出力に次のように表示されます:
      </p><pre class="programlisting">TABLE LOCK table `test`.`t` trx id 10080 lock mode IX
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-record-locks"></a>レコードロック</h4></div></div></div><p>
        レコードロックは、インデックスレコードのロックです。 たとえば、<code class="literal">SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;</code>では、<code class="literal">t.c1</code> の値が <code class="literal">10</code> の場合、他のトランザクションによる行の挿入、更新または削除が防止されます。 
      </p><p>
        レコードロックでは、テーブルにインデックスが定義されていなくても必ず、インデックスレコードがロックされます。 このような場合は、<code class="literal">InnoDB</code> によって非表示のクラスタ化されたインデックスが作成され、このインデックスを使用してレコードロックが行われます。 <a class="xref" href="innodb-storage-engine.html#innodb-index-types" title="15.6.2.1 クラスタインデックスとセカンダリインデックス">セクション15.6.2.1「クラスタインデックスとセカンダリインデックス」</a>を参照してください。 
      </p><p>
        レコードロックのトランザクションデータは、<code class="literal">SHOW ENGINE INNODB STATUS</code> および <a class="link" href="innodb-storage-engine.html#innodb-standard-monitor" title="15.17.3 InnoDB 標準モニターおよびロックモニターの出力">InnoDB monitor</a> 出力に次のように表示されます:
      </p><pre class="programlisting">RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`
trx id 10078 lock_mode X locks rec but not gap
Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 8000000a; asc     ;;
 1: len 6; hex 00000000274f; asc     'O;;
 2: len 7; hex b60000019d0110; asc        ;;
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-gap-locks"></a>ギャップロック</h4></div></div></div><p>
        ギャップロックは、インデックスレコード間のギャップのロック、または最初のインデックスレコードの前または最後のインデックスレコードの後のギャップのロックです。 たとえば、<code class="literal">SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;</code>では、範囲内の既存のすべての値間のギャップがロックされているため、カラムにそのような値がすでに存在するかどうかにかかわらず、他のトランザクションが <code class="literal">15</code> の値をカラム <code class="literal">t.c1</code> に挿入できなくなります。 
      </p><p>
        ギャップは、単一のインデックス値、複数のインデックス値にまたがることも、空にすることもできます。
      </p><p>
        ギャップロックは、パフォーマンスと並列性とのトレードオフの一環であり、一部のトランザクション分離レベルで使用され、ほかでは使用されません。
      </p><p>
        一意のインデックスを使用して一意の行を検索することで行をロックするステートメントでは、ギャップロックは必要ありません。 (これには、検索条件に複数カラムの一意のインデックスの一部のカラムのみが含まれるケースは含まれません。この場合は、ギャップロックが発生します。) たとえば、<code class="literal">id</code> カラムに一意のインデックスが設定されている場合、次のステートメントで使用されるのは <code class="literal">id</code> の値が 100 の行に対するインデックスレコードロックだけとなり、ほかのセッションがそのレコードの前にあるギャップに行を挿入するかどうかは問題ではなくなります。 
      </p><pre class="programlisting">SELECT * FROM child WHERE id = 100;
</pre><p>
        <code class="literal">id</code> にインデックスが設定されていなかったり、一意でないインデックスが設定されていたりすると、このステートメントで先行するギャップがロックされます。
      </p><p>
        さまざまなトランザクションによってギャップ上に競合するロックを保持できることも、ここで注目するべき点です。 たとえば、トランザクション A はギャップ上に共有ギャップロック (ギャップ S ロック) を保持できる一方で、トランザクション B は同じギャップ上に排他ギャップロック (ギャップ X ロック) を保持します。 競合するギャップロックが許可される理由は、レコードがインデックスからパージされる場合に、さまざまなトランザクションによってレコード上に保持されたギャップロックをマージする必要があるためです。 
      </p><p>
        <code class="literal">InnoDB</code> のギャップロックは<span class="quote">「<span class="quote">「純粋に阻害」</span>」</span>です。つまり、その唯一の目的は、他のトランザクションがギャップに挿入されないようにすることです。 ギャップロックは共存できます。 あるトランザクションによって取得されたギャップロックによって、別のトランザクションが同じギャップに対してギャップロックを取得することが妨げられることはありません。 共有ギャップロックと排他ギャップロックに違いはありません。 これらは互いに競合せず、同じ機能を実行します。 
      </p><p>
        ギャップロックは明示的に無効化できます。 これは、トランザクション分離レベルを <code class="literal">READ COMMITTED</code> に変更した場合に発生します。 このような状況では、ギャップロックは検索およびインデックススキャン時に無効化され、外部キー制約チェックおよび重複キーチェック時にのみ使用されます。 
      </p><p>
        <code class="literal">READ COMMITTED</code> 分離レベルの使用には、他にも影響があります。 一致しなかった行のレコードロックは、MySQL による <code class="literal">WHERE</code> 条件の評価後に解除されます。 <code class="literal">UPDATE</code> ステートメントの場合、<code class="literal">InnoDB</code> は最後にコミットされたバージョンが MySQL に返されるように、<span class="quote">「<span class="quote">半一貫性</span>」</span>読み取りを実行します。これにより、MySQL はその行が <code class="literal">UPDATE</code> の <code class="literal">WHERE</code> 条件に一致するかどうかを判断できます。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-next-key-locks"></a>ネクストキーロック</h4></div></div></div><p>
        次のキーロックは、インデックスレコードのレコードロックと、インデックスレコードの前のギャップのギャップロックの組み合わせです。
      </p><p>
        <code class="literal">InnoDB</code> は、テーブルインデックスを検索またはスキャンするときに、生成されたインデックスレコード上に共有ロックまたは排他ロックを設定するという方法で、行レベルロックを実行します。 したがって、行レベルロックは、実際にはインデックスレコードロックです。 インデックスレコードに対する次のキーロックは、そのインデックスレコードの前の <span class="quote">「<span class="quote">gap</span>」</span> にも影響します。 つまり、ネクストキーロックは、インデックスレコードロックと、そのインデックスレコードの前のギャップに対するギャップロックとを組み合わせたものです。 あるセッションがインデックス内のレコード <code class="literal">R</code> 上に共有ロックまたは排他ロックを持っている場合は、別のセッションがインデックスの順番で <code class="literal">R</code> の直前にあるギャップに新しいインデックスレコードを挿入できません。 
      </p><p>
        あるインデックスに値 10、11、13、20 が含まれているとします。 このインデックスで使用可能な次のキーロックは、次の間隔を対象としています。丸カッコは間隔エンドポイントの除外を示し、角カッコはエンドポイントの包含を示します: 
      </p><pre class="programlisting">(negative infinity, 10]
(10, 11]
(11, 13]
(13, 20]
(20, positive infinity)
</pre><p>
        最後の間隔ではネクストキーロックによって、インデックス内の最大値を上回るギャップ、およびインデックス内の実際のどの値よりも大きい値を持つ<span class="quote">「<span class="quote">最小上限</span>」</span>の擬似レコードがロックされます。 最小上限は実際のインデックスレコードではないため、事実上、このネクストキーロックによってロックされるのは、最大インデックス値のあとにあるギャップのみです。 
      </p><p>
        デフォルトでは、<code class="literal">InnoDB</code> は <code class="literal">REPEATABLE READ</code> トランザクション分離レベルで動作します。 この場合、<code class="literal">InnoDB</code> はネクストキーロックを使用して検索およびインデックススキャンを行うため、ファントム行の発生を回避できます (<a class="xref" href="innodb-storage-engine.html#innodb-next-key-locking" title="15.7.4 ファントム行">セクション15.7.4「ファントム行」</a>を参照)。 
      </p><p>
        次のキーロックのトランザクションデータは、<code class="literal">SHOW ENGINE INNODB STATUS</code> および <a class="link" href="innodb-storage-engine.html#innodb-standard-monitor" title="15.17.3 InnoDB 標準モニターおよびロックモニターの出力">InnoDB monitor</a> の出力に次のように表示されます:
      </p><pre class="programlisting">RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`
trx id 10080 lock_mode X
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;

Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 8000000a; asc     ;;
 1: len 6; hex 00000000274f; asc     'O;;
 2: len 7; hex b60000019d0110; asc        ;;
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-insert-intention-locks"></a>インテンションロックの挿入</h4></div></div></div><p>
        挿入意図ロックは、行の挿入前に <code class="literal">INSERT</code> 操作によって設定されるギャップロックのタイプです。 このロックは、同じインデックスギャップに挿入する複数のトランザクションは、そのギャップ内の同じ場所に挿入しなければ相互に待機する必要がないように、意図的に挿入することを示しています。 値が 4 と 7 のインデックスレコードが存在すると仮定します。 5 と 6 の値をそれぞれ挿入しようとする個別のトランザクションでは、挿入された行の排他ロックを取得する前に、挿入意図ロックを使用して 4 と 7 のギャップがロックされますが、行が競合していないため相互にブロックされません。 
      </p><p>
        次の例は、挿入されたレコードの排他ロックを取得する前に挿入意図ロックを取得するトランザクションを示しています。 この例には、A と B の 2 つのクライアントが登場します。 
      </p><p>
        クライアント A は、2 つのインデックスレコード (90 および 102) を含むテーブルを作成し、100 を超える ID を持つインデックスレコードに排他ロックを設定するトランザクションを開始します。 排他ロックには、レコード 102 の前にギャップロックが含まれます: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE child (id int(11) NOT NULL, PRIMARY KEY(id)) ENGINE=InnoDB;</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO child (id) values (90),(102);</code></strong>

mysql&gt; <strong class="userinput"><code>START TRANSACTION;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM child WHERE id &gt; 100 FOR UPDATE;</code></strong>
+-----+
| id  |
+-----+
| 102 |
+-----+
</pre><p>
        クライアント B はトランザクションを開始して、ギャップにレコードを挿入します。 トランザクションは、排他ロックの取得を待機している間、挿入意図ロックを取得します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>START TRANSACTION;</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO child (id) VALUES (101);</code></strong>
</pre><p>
        挿入意図ロックのトランザクションデータは、<code class="literal">SHOW ENGINE INNODB STATUS</code> および <a class="link" href="innodb-storage-engine.html#innodb-standard-monitor" title="15.17.3 InnoDB 標準モニターおよびロックモニターの出力">InnoDB monitor</a> 出力に次のように表示されます:
      </p><pre class="programlisting">RECORD LOCKS space id 31 page no 3 n bits 72 index `PRIMARY` of table `test`.`child`
trx id 8731 lock_mode X locks gap before rec <span class="bold"><strong>insert intention</strong></span> waiting
Record lock, heap no 3 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000066; asc    f;;
 1: len 6; hex 000000002215; asc     " ;;
 2: len 7; hex 9000000172011c; asc     r  ;;...
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-auto-inc-locks"></a>AUTO-INC ロック</h4></div></div></div><p>
        <code class="literal">AUTO-INC</code> ロックは、<code class="literal">AUTO_INCREMENT</code> カラムを含むテーブルに挿入されるトランザクションによって取得される特別なテーブルレベルロックです。 もっとも単純なケースでは、あるトランザクションがテーブルに値を挿入している場合に、ほかのトランザクションはそのテーブルへのそれぞれの挿入を待機する必要があるので、最初のトランザクションによって挿入された行が、連続する主キー値を受け取ります。 
      </p><p>
        <code class="literal">innodb_autoinc_lock_mode</code> 構成オプションは、自動増分ロックに使用されるアルゴリズムを制御します。 これにより、自動増分値の予測可能なシーケンスと挿入操作の最大同時実行性の間のトレードオフ方法を選択できます。 
      </p><p>
        詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-handling" title="15.6.1.6 InnoDB での AUTO_INCREMENT 処理">セクション15.6.1.6「InnoDB での AUTO_INCREMENT 処理」</a>を参照してください。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-predicate-locks"></a>空間インデックスの述語ロック</h4></div></div></div><a class="indexterm" name="idm44761362150944"></a><a class="indexterm" name="idm44761362149472"></a><p>
        <code class="literal">InnoDB</code> では、空間カラムを含むカラムの <code class="literal">SPATIAL</code> インデックス付けがサポートされています (<a class="xref" href="data-types.html#optimizing-spatial-analysis" title="11.4.9 空間分析の最適化">セクション11.4.9「空間分析の最適化」</a> を参照)。
      </p><p>
        <code class="literal">SPATIAL</code> インデックスを含む操作のロックを処理するために、次キーロックは <code class="literal">REPEATABLE READ</code> または <code class="literal">SERIALIZABLE</code> のトランザクション分離レベルをサポートするのに適切に機能しません。 マルチディメンショナルデータには絶対順序付けの概念がないため、<span class="quote">「<span class="quote">next</span>」</span> キーは明確ではありません。 
      </p><p>
        <code class="literal">SPATIAL</code> インデックスを含むテーブルの分離レベルのサポートを有効にするために、<code class="literal">InnoDB</code> では述語ロックを使用します。 <code class="literal">SPATIAL</code> インデックスには最小境界矩形 (MBR) 値が含まれているため、<code class="literal">InnoDB</code> では、クエリーに使用される MBR 値に述語ロックを設定することで、インデックスに対する読取り一貫性が強制されます。 他のトランザクションでは、クエリー条件に一致する行を挿入または変更できません。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-transaction-model"></a>15.7.2 InnoDB トランザクションモデル</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-transaction-isolation-levels">15.7.2.1 トランザクション分離レベル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-autocommit-commit-rollback">15.7.2.2 自動コミット、コミットおよびロールバック</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-consistent-read">15.7.2.3 一貫性非ロック読み取り</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-locking-reads">15.7.2.4 読取りのロック</a></span></dt></dl></div><a class="indexterm" name="idm44761362134672"></a><p>
      <code class="literal">InnoDB</code> トランザクションモデルでの目標は、<a class="link" href="glossary.html#glos_mvcc" title="MVCC">multi-versioning</a> データベースの最適なプロパティを従来の 2 フェーズロックと組み合せることです。 <code class="literal">InnoDB</code> は、行レベルでロックを実行し、Oracle のスタイルでクエリーを非ロック <a class="link" href="glossary.html#glos_consistent_read" title="一貫性読み取り">consistent reads</a> としてデフォルトで実行します。 <code class="literal">InnoDB</code> のロック情報は領域効率に優れて格納されるため、ロックのエスカレーションは必要ありません。 通常、いくつかのユーザーは、<code class="literal">InnoDB</code> メモリーを使い果たさずに、<code class="literal">InnoDB</code> テーブルのすべての行または行のランダムなサブセットをロックできます。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-transaction-isolation-levels"></a>15.7.2.1 トランザクション分離レベル</h4></div></div></div><a class="indexterm" name="idm44761362124992"></a><a class="indexterm" name="idm44761362122848"></a><p>
        トランザクションの分離は、データベース処理の基礎の 1 つです。 分離とは、頭字語の <a class="link" href="glossary.html#glos_acid" title="ACID">ACID</a> における I です。分離レベルは、複数のトランザクションで変更が行われ、クエリーが同時に実行される場合に、パフォーマンスと信頼性、一貫性および結果の再現性のバランスを微調整する設定です。 
      </p><p>
        <code class="literal">InnoDB</code> では、SQL:1992 標準に記載された 4 つのトランザクション分離レベル (<code class="literal">READ UNCOMMITTED</code>、<code class="literal">READ COMMITTED</code>、<code class="literal">REPEATABLE READ</code>、<code class="literal">SERIALIZABLE</code>) がすべて提供されます。 <code class="literal">InnoDB</code> のデフォルトの分離レベルは <code class="literal">REPEATABLE READ</code> です。 
      </p><p>
        ユーザーは <code class="literal">SET TRANSACTION</code> ステートメントを使用して単一のセッションまたは後続のすべての接続の分離レベルを変更できます。 すべての接続に対するサーバーのデフォルトの分離レベルを設定するには、コマンド行上、またはオプションファイル内で <code class="option">--transaction-isolation</code> オプションを使用します。 分離レベルおよびレベル設定構文についての詳細は、<a class="xref" href="sql-statements.html#set-transaction" title="13.3.7 SET TRANSACTION ステートメント">セクション13.3.7「SET TRANSACTION ステートメント」</a>を参照してください。 
      </p><p>
        <code class="literal">InnoDB</code> は、ここで説明されている各トランザクション分離レベルを、異なる<a class="link" href="glossary.html#glos_locking" title="ロック">ロック</a>の方法を使用してサポートしています。 <a class="link" href="glossary.html#glos_acid" title="ACID">ACID</a> 準拠が重要な要件である重要なデータに対する操作の場合は、デフォルトの <code class="literal">REPEATABLE READ</code> レベルを使用して高度な一貫性を適用できます。 あるいは、正確な一貫性や繰り返し可能な結果がロックのためのオーバーヘッドの量の最少化ほど重要でない一括レポートなどの状況では、<code class="literal">READ COMMITTED</code> や場合によっては <code class="literal">READ UNCOMMITTED</code> を使用して一貫性のルールを緩和できます。 <code class="literal">SERIALIZABLE</code> は <code class="literal">REPEATABLE READ</code> よりさらに厳密なルールを適用し、主に <a class="link" href="glossary.html#glos_xa" title="XA">XA</a> トランザクションのほか、並列性や<a class="link" href="glossary.html#glos_deadlock" title="デッドロック">デッドロック</a>に関する問題のトラブルシューティングなどの特殊な状況で使用されます。 
      </p><p>
        次のリストは、MySQL が各種のトランザクションレベルをどのようにサポートするかについて説明しています。 このリストは、もっとも一般的に使用されるレベルから使用頻度の低い順に並べられています。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="isolevel_repeatable-read"></a>
            <code class="literal">REPEATABLE READ</code>
          </p><a class="indexterm" name="idm44761362095088"></a><a class="indexterm" name="idm44761362092944"></a><p>
            これが <code class="literal">InnoDB</code> のデフォルトの分離レベルです。 同じトランザクション内の <a class="link" href="glossary.html#glos_consistent_read" title="一貫性読み取り">Consistent reads</a> は、最初の読取りによって確立された <a class="link" href="glossary.html#glos_snapshot" title="スナップショット">snapshot</a> を読み取ります。 つまり、同じトランザクション内で複数のプレーン (非ロック) <code class="literal">SELECT</code> ステートメントを発行すると、これらの <code class="literal">SELECT</code> ステートメントも互いに一貫性が保たれます。 <a class="xref" href="innodb-storage-engine.html#innodb-consistent-read" title="15.7.2.3 一貫性非ロック読み取り">セクション15.7.2.3「一貫性非ロック読み取り」</a>を参照してください。 
          </p><p>
            <a class="link" href="glossary.html#glos_locking_read" title="ロック読み取り">locking reads</a> (<code class="literal">FOR UPDATE</code> または <code class="literal">FOR SHARE</code> のある <code class="literal">SELECT</code>)、<code class="literal">UPDATE</code> および <code class="literal">DELETE</code> ステートメントの場合、ロックはステートメントが一意の検索条件を持つ一意のインデックスを使用するか、範囲タイプの検索条件を使用するかによって異なります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                一意の検索条件を使用した一意のインデックスの場合、<code class="literal">InnoDB</code> は見つかったインデックスレコードのみをロックし、その前にある<a class="link" href="glossary.html#glos_gap" title="ギャップ">ギャップ</a>はロックしません。
              </p></li><li class="listitem"><p>
                その他の検索条件の場合、<code class="literal">InnoDB</code> は、<a class="link" href="glossary.html#glos_gap_lock" title="ギャップロック">ギャップロック</a>または<a class="link" href="glossary.html#glos_next_key_lock" title="ネクストキーロック">ネクストキーロック</a>を使用して、範囲に含まれるギャップへのほかのセッションによる挿入をブロックすることによって、スキャンされたインデックス範囲をロックします。 ギャップロックおよびネクストキーロックについては、<a class="xref" href="innodb-storage-engine.html#innodb-locking" title="15.7.1 InnoDB ロック">セクション15.7.1「InnoDB ロック」</a> を参照してください。 
              </p></li></ul></div></li><li class="listitem"><p><a name="isolevel_read-committed"></a>
            <code class="literal">READ COMMITTED</code>
          </p><a class="indexterm" name="idm44761362068704"></a><a class="indexterm" name="idm44761362066512"></a><p>
            各読取り一貫性は、同じトランザクション内であっても、独自の新しいスナップショットを設定して読み取ります。 読取り一貫性の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-consistent-read" title="15.7.2.3 一貫性非ロック読み取り">セクション15.7.2.3「一貫性非ロック読み取り」</a> を参照してください。 
          </p><p>
            ロック読取り (<code class="literal">FOR UPDATE</code> または <code class="literal">FOR SHARE</code> を使用した <code class="literal">SELECT</code>)、<code class="literal">UPDATE</code> ステートメントおよび <code class="literal">DELETE</code> ステートメントの場合、<code class="literal">InnoDB</code> はインデックスレコードのみをロックし、その前のギャップはロックしないため、ロックされたレコードの横に新しいレコードを自由に挿入できます。 ギャップロックは、外部キー制約チェックおよび重複キーチェックにのみ使用されます。 
          </p><p>
            ギャップロックが無効になっているため、他のセッションがギャップに新しい行を挿入できるため、ファントムの問題が発生する可能性があります。 ファントムの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-next-key-locking" title="15.7.4 ファントム行">セクション15.7.4「ファントム行」</a> を参照してください。 
          </p><p>
            <code class="literal">READ COMMITTED</code> 分離レベルでは、行ベースのバイナリロギングのみがサポートされます。 <code class="literal">READ COMMITTED</code> を <code class="literal">binlog_format=MIXED</code> とともに使用する場合、サーバーは自動的に行ベースのロギングを使用します。 
          </p><p>
            <code class="literal">READ COMMITTED</code> の使用には、追加の効果があります:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">UPDATE</code> または <code class="literal">DELETE</code> ステートメントでは、<code class="literal">InnoDB</code> は更新または削除の対象となる行に対してのみ、ロックを保持します。 一致しなかった行のレコードロックは、MySQL による <code class="literal">WHERE</code> 条件の評価後に解除されます。 これにより、デッドロックの可能性が大幅に低くなりますが、まだ発生する可能性はあります。 
              </p></li><li class="listitem"><p>
                <code class="literal">UPDATE</code> ステートメントである行がすでにロックされていた場合、<code class="literal">InnoDB</code> は <span class="quote">「<span class="quote">半一貫性</span>」</span> 読み取りを実行し、最後にコミットされたバージョンを MySQL に返すため、MySQL はその行が <code class="literal">UPDATE</code> の <code class="literal">WHERE</code> 条件に一致するかどうかを判断できます。 その行が一致した場合 (その行を更新する必要がある場合)、MySQL はその行を再度読み取り、<code class="literal">InnoDB</code> は今度はその行をロックするか、その行のロックが解除されるまで待機します。 
              </p></li></ul></div><p>
            次のような例について、このテーブルから検討します。
          </p><pre class="programlisting">CREATE TABLE t (a INT NOT NULL, b INT) ENGINE = InnoDB;
INSERT INTO t VALUES (1,2),(2,3),(3,2),(4,3),(5,2);
COMMIT;
</pre><p>
            この場合、テーブルにはインデックスがないため、検索およびインデックススキャンでは、インデックス付けされたカラムではなく、非表示のクラスタインデックスをレコードロックに使用します (<a class="xref" href="innodb-storage-engine.html#innodb-index-types" title="15.6.2.1 クラスタインデックスとセカンダリインデックス">セクション15.6.2.1「クラスタインデックスとセカンダリインデックス」</a> を参照)。
          </p><p>
            あるセッションで、次のステートメントを使用して <code class="literal">UPDATE</code> を実行するとします:
          </p><pre class="programlisting"># Session A
START TRANSACTION;
UPDATE t SET b = 5 WHERE b = 3;
</pre><p>
            また、最初のセッションのステートメントの後に次のステートメントを実行して、別のセッションで <code class="literal">UPDATE</code> を実行するとします:
          </p><pre class="programlisting"># Session B
UPDATE t SET b = 4 WHERE b = 2;
</pre><p>
            <code class="literal">InnoDB</code> は各 <code class="literal">UPDATE</code> を実行する際に、まず各行の排他ロックを取得し、次にその行を変更するかどうかを判断します。 <code class="literal">InnoDB</code> は、行を変更しない場合、ロックを解放します。 それ以外の場合、トランザクションが終了するまで <code class="literal">InnoDB</code> はそのロックを保持します。 これにより、トランザクション処理が次のような影響を受けます。 
          </p><p>
            デフォルトの <code class="literal">REPEATABLE READ</code> 分離レベルを使用する場合、最初の <code class="literal">UPDATE</code> は読取り対象の各行に対して x ロックを取得し、それらのいずれも解放しません:
          </p><pre class="programlisting">x-lock(1,2); retain x-lock
x-lock(2,3); update(2,3) to (2,5); retain x-lock
x-lock(3,2); retain x-lock
x-lock(4,3); update(4,3) to (4,5); retain x-lock
x-lock(5,2); retain x-lock
</pre><p>
            次のように、2 番目の <code class="literal">UPDATE</code> は (1 番目の更新がすべての行のロックを保持しているため)、ロックを取得しようとしてもすぐにブロックされ、1 番目の <code class="literal">UPDATE</code> がコミットまたはロールバックを実行するまで続行されません。
          </p><pre class="programlisting">x-lock(1,2); block and wait for first UPDATE to commit or roll back
</pre><p>
            かわりに <code class="literal">READ COMMITTED</code> が使用されている場合、最初の <code class="literal">UPDATE</code> は読み取る各行で x ロックを取得し、変更しない行の X ロックを解放します:
          </p><pre class="programlisting">x-lock(1,2); unlock(1,2)
x-lock(2,3); update(2,3) to (2,5); retain x-lock
x-lock(3,2); unlock(3,2)
x-lock(4,3); update(4,3) to (4,5); retain x-lock
x-lock(5,2); unlock(5,2)
</pre><p>
            2 番目の <code class="literal">UPDATE</code> では、<code class="literal">InnoDB</code> は <span class="quote">「<span class="quote">semi-consistent</span>」</span> 読取りを実行し、MySQL に読み取られた各行の最新のコミット済バージョンを返して、MySQL がその行が <code class="literal">UPDATE</code> の <code class="literal">WHERE</code> 条件に一致するかどうかを判断できるようにします:
          </p><pre class="programlisting">x-lock(1,2); update(1,2) to (1,4); retain x-lock
x-lock(2,3); unlock(2,3)
x-lock(3,2); update(3,2) to (3,4); retain x-lock
x-lock(4,3); unlock(4,3)
x-lock(5,2); update(5,2) to (5,4); retain x-lock
</pre><p>
            ただし、<code class="literal">WHERE</code> 条件にインデックス付けされたカラムが含まれており、<code class="literal">InnoDB</code> でインデックスが使用されている場合は、レコードロックを取得および保持するときにインデックス付けされたカラムのみが考慮されます。 次の例では、最初の <code class="literal">UPDATE</code> は、b = 2 の各行で x ロックを取得して保持します。 2 番目の <code class="literal">UPDATE</code> は、カラム b に定義されたインデックスも使用するため、同じレコードで x ロックを取得しようとするとブロックされます。 
          </p><pre class="programlisting">CREATE TABLE t (a INT NOT NULL, b INT, c INT, INDEX (b)) ENGINE = InnoDB;
INSERT INTO t VALUES (1,2,3),(2,2,4);
COMMIT;

# Session A
START TRANSACTION;
UPDATE t SET b = 3 WHERE b = 2 AND c = 3;

# Session B
UPDATE t SET b = 4 WHERE b = 2 AND c = 4;
</pre><p>
            <code class="literal">READ COMMITTED</code> 分離レベルは、起動時に設定することも、実行時に変更することもできます。 実行時に、すべてのセッションに対してグローバルに設定することも、セッションごとに個別に設定することもできます。 
          </p></li><li class="listitem"><p><a name="isolevel_read-uncommitted"></a>
            <code class="literal">READ UNCOMMITTED</code>
          </p><a class="indexterm" name="idm44761361998864"></a><a class="indexterm" name="idm44761361996720"></a><p>
            <code class="literal">SELECT</code> ステートメントは非ロックの方法で実行されますが、以前のバージョンの行が使用される可能性もあります。 そのため、この分離レベルを使用すると、このような読み取りには一貫性がありません。 これは、<a class="link" href="glossary.html#glos_dirty_read" title="ダーティー読み取り">ダーティー読み取り</a>とも呼ばれます。 そうでなければ、この分離レベルは <code class="literal">READ COMMITTED</code> のように機能します。 
          </p></li><li class="listitem"><p><a name="isolevel_serializable"></a>
            <code class="literal">SERIALIZABLE</code>
          </p><a class="indexterm" name="idm44761361988928"></a><a class="indexterm" name="idm44761361986736"></a><p>
            このレベルは <code class="literal">REPEATABLE READ</code> と似ていますが、<code class="literal">autocommit</code> が無効になっている場合、<code class="literal">InnoDB</code> はすべてのプレーン <code class="literal">SELECT</code> ステートメントを <code class="literal">SELECT ... FOR SHARE</code> に暗黙的に変換します。 <code class="literal">autocommit</code> が有効な場合、<code class="literal">SELECT</code> は独自のトランザクションです。 したがって、読み取り専用であることがわかっているため、一貫性のある (非ロック) 読み取りとして実行された場合は直列化することができ、ほかのトランザクションのためのブロックは必要ありません。 (選択した行が他のトランザクションによって変更された場合にプレーン <code class="literal">SELECT</code> を強制的にブロックするには、<code class="literal">autocommit</code> を無効にします。) 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              MySQL 8.0.22 の時点では、MySQL からデータを読み取る DML 操作では、分離レベルに関係なく、(結合リストまたはサブクエリーを介して) テーブルが付与されますが、変更はされません。 詳細は、<a class="xref" href="security.html#grant-tables-concurrency" title="テーブル同時実行性の付与">テーブル同時実行性の付与</a>を参照してください。 
            </p></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-autocommit-commit-rollback"></a>15.7.2.2 自動コミット、コミットおよびロールバック</h4></div></div></div><a class="indexterm" name="idm44761361970720"></a><a class="indexterm" name="idm44761361968592"></a><p>
        <code class="literal">InnoDB</code> では、すべてのユーザーアクティビティーがトランザクション内部で発生します。 <code class="literal">autocommit</code> モードが有効な場合、各 SQL ステートメントは単独で単一のトランザクションを形成します。 デフォルトでは、MySQL は、<code class="literal">autocommit</code> が有効になっている新しい接続ごとにセッションを開始するため、MySQL は、SQL ステートメントがエラーを戻さなかった場合に、各 SQL ステートメントの後にコミットを実行します。 ステートメントからエラーが返された場合、コミットまたはロールバックの動作はそのエラーによって異なります。 <a class="xref" href="innodb-storage-engine.html#innodb-error-handling" title="15.21.4 InnoDB のエラー処理">セクション15.21.4「InnoDB のエラー処理」</a>を参照してください。 
      </p><p>
        <code class="literal">autocommit</code> が有効になっているセッションは、明示的な <code class="literal">START TRANSACTION</code> ステートメントまたは <code class="literal">BEGIN</code> ステートメントで開始し、<code class="literal">COMMIT</code> ステートメントまたは <code class="literal">ROLLBACK</code> ステートメントで終了することで、複数ステートメントのトランザクションを実行できます。 <a class="xref" href="sql-statements.html#commit" title="13.3.1 START TRANSACTION、COMMIT および ROLLBACK ステートメント">セクション13.3.1「START TRANSACTION、COMMIT および ROLLBACK ステートメント」</a>を参照してください。 
      </p><p>
        <code class="literal">SET autocommit = 0</code> とのセッション内で <code class="literal">autocommit</code> モードが無効になっている場合、セッションでは常にトランザクションがオープンされています。 <code class="literal">COMMIT</code> または <code class="literal">ROLLBACK</code> ステートメントは現在のトランザクションを終了し、新しいセッションを開始します。 
      </p><p>
        <code class="literal">autocommit</code> が無効になっているセッションが、最終トランザクションを明示的にコミットせずに終了した場合、MySQL はそのトランザクションをロールバックします。
      </p><p>
        一部のステートメントは、ユーザーがそのステートメントの実行前に <code class="literal">COMMIT</code> を実行した場合と同様に、暗黙的にトランザクションを終了します。 詳細は、<a class="xref" href="sql-statements.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。 
      </p><p>
        <code class="literal">COMMIT</code> は、現在のトランザクション内で行われた変更は永続的であり、その他のセッションから表示できることを意味します。 反対に、<code class="literal">ROLLBACK</code> ステートメントは、現在のトランザクションによって行われたすべての変更を取り消します。 <code class="literal">COMMIT</code> と <code class="literal">ROLLBACK</code> は両方とも、現在のトランザクション中に設定されたすべての <code class="literal">InnoDB</code> ロックを解除します。 
      </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-transactions-with-different-apis"></a>トランザクションを使用した DML 操作のグループ化</h5></div></div></div><a class="indexterm" name="idm44761361938048"></a><p>
          デフォルトでは、MySQL サーバーへの接続は、<a class="link" href="glossary.html#glos_autocommit" title="自動コミット">自動コミット</a>モードが有効になっている状態で開始されるため、SQL ステートメントは実行するたびに自動的にコミットされます。 一連の <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> ステートメントを発行し、すべてまとめてコミットまたはロールバックすることが標準操作となっているほかのデータベースシステムの使用経験がある場合は、この操作モードに馴染みがないかもしれません。 
        </p><p>
          複数ステートメントの<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>を使用するには、SQL ステートメント <code class="literal">SET autocommit = 0</code> を使用して自動コミットをオフにして、必要に応じて <code class="literal">COMMIT</code> または <code class="literal">ROLLBACK</code> を使用して各トランザクションを終了します。 自動コミットをオンのままにするには、<code class="literal">START TRANSACTION</code> を使用して各トランザクションを開始し、<code class="literal">COMMIT</code> または <code class="literal">ROLLBACK</code> を使用して終了します。 次の例は 2 つのトランザクションを表しています。 1 番目はコミットされ、2 番目はロールバックされています。 
        </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysql test</code></strong>
</pre><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE customer (a INT, b CHAR (20), INDEX (a));</code></strong>
Query OK, 0 rows affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>-- Do a transaction with autocommit turned on.</code></strong>
mysql&gt; <strong class="userinput"><code>START TRANSACTION;</code></strong>
Query OK, 0 rows affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>INSERT INTO customer VALUES (10, 'Heikki');</code></strong>
Query OK, 1 row affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>COMMIT;</code></strong>
Query OK, 0 rows affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>-- Do another transaction with autocommit turned off.</code></strong>
mysql&gt; <strong class="userinput"><code>SET autocommit=0;</code></strong>
Query OK, 0 rows affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>INSERT INTO customer VALUES (15, 'John');</code></strong>
Query OK, 1 row affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>INSERT INTO customer VALUES (20, 'Paul');</code></strong>
Query OK, 1 row affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>DELETE FROM customer WHERE b = 'Heikki';</code></strong>
Query OK, 1 row affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>-- Now we undo those last 2 inserts and the delete.</code></strong>
mysql&gt; <strong class="userinput"><code>ROLLBACK;</code></strong>
Query OK, 0 rows affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>SELECT * FROM customer;</code></strong>
+------+--------+
| a    | b      |
+------+--------+
|   10 | Heikki |
+------+--------+
1 row in set (0.00 sec)
mysql&gt;
</pre><h6><a name="idm44761361911248"></a>クライアント側言語でのトランザクション</h6><p>
          PHP、Perl DBI、JDBC、ODBC などの API または MySQL の標準 C 呼び出しインタフェースでは、<code class="literal">COMMIT</code> などのトランザクション制御ステートメントを <code class="literal">SELECT</code> や <code class="literal">INSERT</code> などのその他の SQL ステートメントと同様の文字列として、MySQL サーバーに送信できます。 一部の API では、別個の特別なトランザクションコミットおよびロールバックの関数やメソッドも提供されています。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-consistent-read"></a>15.7.2.3 一貫性非ロック読み取り</h4></div></div></div><a class="indexterm" name="idm44761361904848"></a><a class="indexterm" name="idm44761361902720"></a><p>
        <a class="link" href="glossary.html#glos_consistent_read" title="一貫性読み取り">一貫性読み取り</a>とは、<code class="literal">InnoDB</code> がマルチバージョンを使用して、ある時点でのデータベースのスナップショットをクエリーに提供することを意味します。 クエリーには、その時点よりも前にコミットされたトランザクションによる変更のみが表示され、その時点よりもあとのトランザクションまたはコミットされていないトランザクションによる変更は表示されません。 このルールの例外として、同じトランザクション内の以前のステートメントによる変更はクエリーに表示されます。 この例外によって、次のような異常が発生します。テーブル内の一部の行を更新すると、更新された行の最新バージョンが <code class="literal">SELECT</code> に表示されますが、いずれかの行の旧バージョンも表示される可能性があります。 その他のセッションで同じテーブルが同時に更新される場合、その異常は、データベースに存在しない状態でテーブルが表示される可能性があることを意味します。 
      </p><p>
        トランザクション<a class="link" href="glossary.html#glos_isolation_level" title="分離レベル">分離レベル</a>が <code class="literal">REPEATABLE READ</code> (デフォルトのレベル) である場合は、同じトランザクション内のすべての一貫性読み取りで、そのトランザクション内の最初のこのような読み取りで確立されたスナップショットが読み取られます。 現在のトランザクションをコミットしたあとに、新しいクエリーを発行すると、クエリーの新しいスナップショットを取得できます。 
      </p><p>
        分離レベルが <code class="literal">READ COMMITTED</code> の場合は、トランザクション内の各一貫性読み取りで、独自の新しいスナップショットが設定され、読み取られます。
      </p><p>
        一貫性読み取りは、<code class="literal">InnoDB</code> が <code class="literal">READ COMMITTED</code> および <code class="literal">REPEATABLE READ</code> 分離レベルで <code class="literal">SELECT</code> ステートメントを処理する際のデフォルトモードです。 一貫性読み取りではアクセスされるテーブル上にロックが設定されないため、その他のセッションも、そのテーブル上で一貫性読み取りが実行されるときと同時に、それらのテーブルを自由に変更できます。 
      </p><p>
        デフォルトの <code class="literal">REPEATABLE READ</code> 分離レベルで実行していると仮定します。 一貫性読み取り (つまり、通常の <code class="literal">SELECT</code> ステートメント) を発行すると、<code class="literal">InnoDB</code> は、クエリーがデータベースを参照するときの基準となるタイムポイントをトランザクションに付与します。 タイムポイントが割り当てられたあとに、別のトランザクションが行を削除してコミットした場合は、その行が削除済みとして表示されません。 挿入および更新も同様に処理されます。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          データベースの状態のスナップショットは、トランザクション内の <code class="literal">SELECT</code> ステートメントに適用されますが、<a class="link" href="glossary.html#glos_dml" title="DML">DML</a> ステートメントには必ずしも適用されるとは限りません。 一部の行を挿入または変更してから、そのトランザクションをコミットする場合は、そのセッションでクエリーが実行される可能性がない場合でも、別の並列実行 <code class="literal">REPEATABLE READ</code> トランザクションから発行された <code class="literal">DELETE</code> または <code class="literal">UPDATE</code> ステートメントによって、コミットされたばかりの行が影響を受ける可能性があります。 トランザクションによって別のトランザクションでコミットされた行が更新または削除されると、これらの変更を現在のトランザクションに表示できるようになります。 たとえば、次のような状況が発生する可能性があります。 
        </p><pre class="programlisting">SELECT COUNT(c1) FROM t1 WHERE c1 = 'xyz';
-- Returns 0: no rows match.
DELETE FROM t1 WHERE c1 = 'xyz';
-- Deletes several rows recently committed by other transaction.

SELECT COUNT(c2) FROM t1 WHERE c2 = 'abc';
-- Returns 0: no rows match.
UPDATE t1 SET c2 = 'cba' WHERE c2 = 'abc';
-- Affects 10 rows: another txn just committed 10 rows with 'abc' values.
SELECT COUNT(c2) FROM t1 WHERE c2 = 'cba';
-- Returns 10: this txn can now see the rows it just updated.
</pre></div><p>
        トランザクションをコミットしてから、別の <code class="literal">SELECT</code> または <code class="literal">START TRANSACTION WITH CONSISTENT SNAPSHOT</code> を実行すると、タイムポイントを進めることができます。
      </p><p>
        これは、<span class="firstterm">マルチバージョン並列処理制御</span>と呼ばれます。
      </p><p>
        次の例では、セッション B が挿入をコミットし、セッション A も同様にコミットした場合にのみ、B によって挿入された行が A に表示されます。これにより、タイムポイントが B のコミットよりも先に進みます。
      </p><pre class="programlisting">             Session A              Session B

           SET autocommit=0;      SET autocommit=0;
time
|          SELECT * FROM t;
|          empty set
|                                 INSERT INTO t VALUES (1, 2);
|
v          SELECT * FROM t;
           empty set
                                  COMMIT;

           SELECT * FROM t;
           empty set

           COMMIT;

           SELECT * FROM t;
           ---------------------
           |    1    |    2    |
           ---------------------
</pre><p>
        データベースの<span class="quote">「<span class="quote">最新</span>」</span>状態を確認する場合は、<code class="literal">READ COMMITTED</code> 分離レベルと<a class="link" href="glossary.html#glos_locking_read" title="ロック読み取り">ロック読み取り</a>のいずれかを使用します。
      </p><pre class="programlisting">SELECT * FROM t FOR SHARE;
</pre><p>
        分離レベルが <code class="literal">READ COMMITTED</code> の場合は、トランザクション内の各一貫性読み取りで、独自の新しいスナップショットが設定され、読み取られます。 <code class="literal">FOR SHARE</code> では、かわりにロック読取りが発生: <code class="literal">SELECT</code> は、最新の行を含むトランザクションが終了するまでブロックされます (<a class="xref" href="innodb-storage-engine.html#innodb-locking-reads" title="15.7.2.4 読取りのロック">セクション15.7.2.4「読取りのロック」</a> を参照)。 
      </p><p>
        特定の DDL ステートメントでは、一貫性読み取りが機能しません。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">DROP TABLE</code> では、MySQL が削除されたテーブルを使用できず、そのテーブルは <code class="literal">InnoDB</code> によって破棄されるため、一貫性読み取りが機能しません。
          </p></li><li class="listitem"><p>
            読取り一貫性は、元のテーブルの一時コピーを作成し、一時コピーの作成時に元のテーブルを削除する <code class="literal">ALTER TABLE</code> 操作では機能しません。 トランザクション内で一貫性読み取りを再発行しても、新しいテーブル内の行はトランザクションのスナップショット取得されたときには存在していなかったため、表示できません。 この場合、トランザクションはエラーを返します: <code class="literal">ER_TABLE_DEF_CHANGED</code>、<span class="quote">「<span class="quote">テーブル定義が変更されました。トランザクションを再試行してください</span>」</span>。 
          </p></li></ul></div><p>
        読取りのタイプは、<code class="literal">FOR UPDATE</code> または <code class="literal">FOR SHARE</code> を指定しない <code class="literal">INSERT INTO ... SELECT</code>、<code class="literal">UPDATE ... (SELECT)</code> および <code class="literal">CREATE TABLE ... SELECT</code> などの句での選択によって異なります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            デフォルトでは、<code class="literal">InnoDB</code> はこれらのステートメントに対してより強力なロックを使用し、<code class="literal">SELECT</code> 部分は <code class="literal">READ COMMITTED</code> のように動作します。この場合、各読取り一貫性は、同じトランザクション内であっても、独自の新しいスナップショットを設定および読み取ります。
          </p></li><li class="listitem"><p>
            このような場合に非ロック読取りを実行するには、トランザクションの分離レベルを <code class="literal">READ UNCOMMITTED</code> または <code class="literal">READ COMMITTED</code> に設定して、選択したテーブルから読み取られた行にロックを設定しないようにします。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-locking-reads"></a>15.7.2.4 読取りのロック</h4></div></div></div><a class="indexterm" name="idm44761361837264"></a><p>
        データのクエリーを実行してから、同じトランザクション内で関連データを挿入または更新する場合は、通常の <code class="literal">SELECT</code> ステートメントで十分な保護が提供されません。 ほかのトランザクションは、クエリーが実行されたばかりの同じ行を更新または削除できます。 <code class="literal">InnoDB</code> では、追加の安全性が提供される 2 つのタイプの<a class="link" href="glossary.html#glos_locking_read" title="ロック読み取り">ロック読み取り</a>がサポートされています。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">SELECT ... FOR SHARE</code>
          </p><p>
            読み取られる行に共有モードロックを設定します。 ほかのセッションもその行を読み取ることができますが、トランザクションがコミットするまで変更することはできません。 これらの行のいずれかがコミットされていない別のトランザクションによって変更された場合、クエリーはそのトランザクションが終了するまで待機してから、最新の値を使用します。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">SELECT ... FOR SHARE</code> は <code class="literal">SELECT ... LOCK IN SHARE MODE</code> の代替機能ですが、<code class="literal">LOCK IN SHARE MODE</code> は下位互換性のために引き続き使用できます。 ステートメントは同等です。 ただし、<code class="literal">FOR SHARE</code> は <code class="literal">OF <em class="replaceable"><code>table_name</code></em></code>、<code class="literal">NOWAIT</code> および <code class="literal">SKIP LOCKED</code> オプションをサポートしています。 <a class="xref" href="innodb-storage-engine.html#innodb-locking-reads-nowait-skip-locked" title="NOWAIT および SKIP LOCKED による読取り同時実行性のロック">NOWAIT および SKIP LOCKED による読取り同時実行性のロック</a>を参照してください。 
            </p></div><p>
            MySQL 8.0.22 より前は、<code class="literal">SELECT ... FOR SHARE</code> には <code class="literal">SELECT</code> 権限と、<code class="literal">DELETE</code>、<code class="literal">LOCK TABLES</code> または <code class="literal">UPDATE</code> のいずれかの権限が必要です。 MySQL 8.0.22 では、<code class="literal">SELECT</code> 権限のみが必要です。 
          </p><p>
            MySQL 8.0.22 の時点では、<code class="literal">SELECT ... FOR SHARE</code> ステートメントは MySQL 付与テーブルの読取りロックを取得しません。 詳細は、<a class="xref" href="security.html#grant-tables-concurrency" title="テーブル同時実行性の付与">テーブル同時実行性の付与</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">SELECT ... FOR UPDATE</code>
          </p><p>
            検索で検出されたインデックスレコードについては、それらの行に対して <code class="literal">UPDATE</code> ステートメントを発行した場合と同じように、行および関連するインデックスエントリがロックされます。 他のトランザクションは、これらの行の更新、<code class="literal">SELECT ... FOR SHARE</code> の実行、または特定のトランザクション分離レベルでのデータの読取りをブロックされます。 一貫性読み取りでは、読み取られたビュー内に存在するレコードに設定されたロックはすべて無視されます。 (古いバージョンのレコードはロックできません。レコードのインメモリーコピー上の <a class="link" href="glossary.html#glos_undo_log" title="Undo ログ">Undo ログ</a>に適用することで、再構築されます。) 
          </p><p>
            <code class="literal">SELECT ... FOR UPDATE</code> には、<code class="literal">SELECT</code> 権限と、<code class="literal">DELETE</code>、<code class="literal">LOCK TABLES</code> または <code class="literal">UPDATE</code> のいずれかの権限が必要です。
          </p></li></ul></div><p>
        これらの句は、主に、単一のテーブル内または複数のテーブルに分割された状態で、ツリー構造またはグラフ構造のデータを処理する際に役立ちます。 エッジまたはツリー分岐をある場所から別の場所にトラバースしても、これらの<span class="quote">「<span class="quote">ポインタ</span>」</span>に戻ってその値を変更する権利を保有しています。 
      </p><p>
        <code class="literal">FOR SHARE</code> および <code class="literal">FOR UPDATE</code> クエリーによって設定されたすべてのロックは、トランザクションがコミットまたはロールバックされると解放されます。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          ロック読取りは、(<code class="literal">START TRANSACTION</code> でトランザクションを開始するか、<code class="literal">autocommit</code> を 0 に設定することで) 自動コミットが無効になっている場合にのみ可能です。
        </p></div><p>
        外部ステートメントのロック読取り句では、サブクエリーにロック読取り句も指定されていないかぎり、ネストしたサブクエリーのテーブルの行はロックされません。 たとえば、次のステートメントでは、テーブル <code class="literal">t2</code> の行はロックされません。 
      </p><pre class="programlisting">SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2) FOR UPDATE;
</pre><p>
        テーブル <code class="literal">t2</code> の行をロックするには、サブクエリーにロック読取り句を追加します:
      </p><pre class="programlisting">SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2 FOR UPDATE) FOR UPDATE;
</pre><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-locking-reads-examples"></a>読取りロックの例</h5></div></div></div><p>
          <code class="literal">child</code> テーブルに新しい行を挿入し、子の行が <code class="literal">parent</code> テーブル内に親の行を持っていることを確認すると仮定します。 アプリケーションコードを使用して、この操作シーケンス全体の参照整合性を確保できます。 
        </p><p>
          まず、一貫性読み取りを使用して、<code class="literal">PARENT</code> テーブルでクエリーを実行し、親の行が存在することを確認します。 <code class="literal">CHILD</code> テーブルに子の行を安全に挿入できますか。 気付かないうちに、その他の一部のセッションで、<code class="literal">SELECT</code> と <code class="literal">INSERT</code> との間に親の行が削除された可能性もあるため、できません。 
        </p><p>
          この潜在的な問題を回避するには、<code class="literal">FOR SHARE</code> を使用して <code class="literal">SELECT</code> を実行します:
        </p><pre class="programlisting">SELECT * FROM parent WHERE NAME = 'Jones' FOR SHARE;
</pre><p>
          <code class="literal">FOR SHARE</code> クエリーで親<code class="literal">'Jones'</code>が返された後、子レコードを <code class="literal">CHILD</code> テーブルに安全に追加し、トランザクションをコミットできます。 <code class="literal">PARENT</code> テーブルの該当する行で排他ロックを取得しようとするトランザクションは、終了するまで、つまりすべてのテーブルのデータが一貫性のある状態になるまで待機します。 
        </p><p>
          もう 1 つの例では、<code class="literal">CHILD</code> テーブルに追加された各子に一意の識別子を割り当てる際に使用される <code class="literal">CHILD_CODES</code> テーブル内の整数カウンタフィールドを検討します。 一貫性読み取りまたは共有モード読み取りを使用すると、データベースの 2 人のユーザーが同じカウンタ値を参照する可能性があり、2 つのトランザクションが同じ識別子を持つ行を <code class="literal">CHILD</code> テーブルに追加しようとすると、重複キーのエラーが発生するため、カウンタの現在の値を読み取る際には使用しないでください。 
        </p><p>
          ここでは、2 人のユーザーがカウンタを同時に読み取った場合、カウンタを更新しようとすると少なくとも 1 人のユーザーがデッドロックになるため、<code class="literal">FOR SHARE</code> は適切なソリューションではありません。
        </p><p>
          カウンタの読み取りおよび増分を実装するには、まず <code class="literal">FOR UPDATE</code> を使用してカウンタのロック読み取りを実行してから、カウンタを増分します。 例: 
        </p><pre class="programlisting">SELECT counter_field FROM child_codes FOR UPDATE;
UPDATE child_codes SET counter_field = counter_field + 1;
</pre><p>
          <code class="literal">SELECT ... FOR UPDATE</code> は使用可能な最新データを読み取り、読み取られる各行上に排他ロックを設定します。 したがって、検索された SQL <code class="literal">UPDATE</code> によって行上に設定される場合と同じロックが設定されます。 
        </p><p>
          前述の説明は、単に <code class="literal">SELECT ... FOR UPDATE</code> がどのように機能するのかを示した例です。 MySQL では、テーブルへの単一アクセスを使用するだけで、一意の識別子を生成する特定のタスクを実現できます。 
        </p><pre class="programlisting">UPDATE child_codes SET counter_field = LAST_INSERT_ID(counter_field + 1);
SELECT LAST_INSERT_ID();
</pre><p>
          この <code class="literal">SELECT</code> ステートメントは、単に (現在の接続に固有の) 識別子情報を取得するだけです。 どのテーブルにもアクセスしません。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-locking-reads-nowait-skip-locked"></a>NOWAIT および SKIP LOCKED による読取り同時実行性のロック</h5></div></div></div><a class="indexterm" name="idm44761361757104"></a><a class="indexterm" name="idm44761361755664"></a><a class="indexterm" name="idm44761361753712"></a><p>
          行がトランザクションによってロックされている場合、同じロックされた行をリクエストする <code class="literal">SELECT ... FOR UPDATE</code> または <code class="literal">SELECT ... FOR SHARE</code> トランザクションは、ブロックしているトランザクションが行ロックを解放するまで待機する必要があります。 この動作により、トランザクションは、他のトランザクションによる更新をクエリーする行を更新または削除できなくなります。 ただし、リクエストされた行がロックされたときにすぐにクエリーを戻す場合、またはロックされた行を結果セットから除外できる場合は、行ロックの解放を待機する必要はありません。 
        </p><p>
          他のトランザクションによる行ロックの解放を待機しないように、<code class="literal">SELECT ... FOR UPDATE</code> または <code class="literal">SELECT ... FOR SHARE</code> のロック読取りステートメントで <code class="literal">NOWAIT</code> および <code class="literal">SKIP LOCKED</code> オプションを使用できます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">NOWAIT</code>
            </p><p>
              <code class="literal">NOWAIT</code> を使用するロック読取りは、行ロックの取得を待機しません。 クエリーはただちに実行され、リクエストされた行がロックされている場合はエラーで失敗します。 
            </p></li><li class="listitem"><p>
              <code class="literal">SKIP LOCKED</code>
            </p><p>
              <code class="literal">SKIP LOCKED</code> を使用するロック読取りは、行ロックの取得を待機しません。 クエリーはただちに実行され、ロックされた行が結果セットから削除されます。 
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                ロックされた行をスキップするクエリーは、データの一貫性のないビューを返します。 したがって、<code class="literal">SKIP LOCKED</code> は一般的なトランザクション作業には適していません。 ただし、複数のセッションが同じキューに類似したテーブルにアクセスする場合、ロックの競合を回避するために使用できます。 
              </p></div></li></ul></div><p>
          <code class="literal">NOWAIT</code> および <code class="literal">SKIP LOCKED</code> は、行レベルロックにのみ適用されます。
        </p><p>
          <code class="literal">NOWAIT</code> または <code class="literal">SKIP LOCKED</code> を使用するステートメントは、ステートメントベースのレプリケーションでは安全ではありません。
        </p><p>
          次の例は、<code class="literal">NOWAIT</code> および <code class="literal">SKIP LOCKED</code> を示しています。 セッション 1 は、単一のレコードで行ロックを取得するトランザクションを開始します。 セッション 2 は、<code class="literal">NOWAIT</code> オプションを使用して、同じレコードに対するロック読取りを試行します。 リクエストされた行はセッション 1 によってロックされているため、ロック読取りはすぐにエラーとともに返されます。 セッション 3 では、<code class="literal">SKIP LOCKED</code> で読み取られたロックは、セッション 1 でロックされている行を除いて、リクエストされた行を返します。 
        </p><pre class="programlisting"># Session 1:

mysql&gt; <strong class="userinput"><code>CREATE TABLE t (i INT, PRIMARY KEY (i)) ENGINE = InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>INSERT INTO t (i) VALUES(1),(2),(3);</code></strong>

mysql&gt; <strong class="userinput"><code>START TRANSACTION;</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT * FROM t WHERE i = 2 FOR UPDATE;</code></strong>
+---+
| i |
+---+
| 2 |
+---+

# Session 2:

mysql&gt; <strong class="userinput"><code>START TRANSACTION;</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT * FROM t WHERE i = 2 FOR UPDATE NOWAIT;</code></strong>
ERROR 3572 (HY000): Do not wait for lock.

# Session 3:

mysql&gt; <strong class="userinput"><code>START TRANSACTION;</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT * FROM t FOR UPDATE SKIP LOCKED;</code></strong>
+---+
| i |
+---+
| 1 |
| 3 |
+---+
</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-locks-set"></a>15.7.3 InnoDB のさまざまな SQL ステートメントで設定されたロック</h3></div></div></div><a class="indexterm" name="idm44761361719344"></a><a class="indexterm" name="idm44761361717920"></a><p>
      一般に、<a class="link" href="glossary.html#glos_locking_read" title="ロック読み取り">ロック読み取り</a>、<code class="literal">UPDATE</code>、または <code class="literal">DELETE</code> では、SQL ステートメントの処理時にスキャンされるすべてのインデックスレコード上に、レコードロックが設定されます。 行を除外する <code class="literal">WHERE</code> 条件がステートメント内に存在するかどうかは、関係ありません。 <code class="literal">InnoDB</code> には正確な <code class="literal">WHERE</code> 条件が記憶されませんが、スキャンされたインデックスの範囲は認識されます。 通常、ロックはレコードの直前にある<span class="quote">「<span class="quote">ギャップ</span>」</span>への挿入もブロックする<a class="link" href="glossary.html#glos_next_key_lock" title="ネクストキーロック">ネクストキーロック</a>です。 ただし、<a class="link" href="glossary.html#glos_gap_lock" title="ギャップロック">ギャップロック</a>は明示的に無効にすることができます。これにより、ネクストキーロックが使用されなくなります。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-locking" title="15.7.1 InnoDB ロック">セクション15.7.1「InnoDB ロック」</a>を参照してください。 トランザクション分離レベルによって、どのロックが設定されるのかも影響を受けます。<a class="xref" href="innodb-storage-engine.html#innodb-transaction-isolation-levels" title="15.7.2.1 トランザクション分離レベル">セクション15.7.2.1「トランザクション分離レベル」</a>を参照してください。 
    </p><p>
      検索でセカンダリインデックスが使用され、設定されるインデックスレコードのロックが排他的である場合、<code class="literal">InnoDB</code> は対応するクラスタ化されたインデックスレコードを取得し、それらにロックを設定することも行います。
    </p><p>
      ステートメントに適したインデックスがなく、MySQL がステートメントを処理するためにテーブル全体をスキャンする必要がある場合は、テーブルのすべての行がロックされます。その結果、そのテーブルへのほかのユーザーによるすべての挿入がブロックされます。 クエリーで不必要に複数の行がスキャンされないように、適切なインデックスを作成することが重要です。 
    </p><p>
      <code class="literal">InnoDB</code> は、次のように特定のロックタイプを設定します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SELECT ... FROM</code> は一貫性読み取りであり、データベースのスナップショットを読み取り、トランザクションの分離レベルが <code class="literal">SERIALIZABLE</code> に設定されなければロックを設定しません。 <code class="literal">SERIALIZABLE</code> レベルの場合、検索で見つかったインデックスレコード上に共有ネクストキーロックが設定されます。 ただし、一意の行を検索するために一意のインデックスを使用して行をロックするステートメントには、インデックスレコードのロックのみが必要です。 
        </p></li><li class="listitem"><p>
          一意インデックスを使用する <code class="literal">SELECT ... FOR UPDATE</code> および <code class="literal">SELECT ... FOR SHARE</code> ステートメントは、スキャンされた行のロックを取得し、結果セットに含まれない行のロックを解除します (たとえば、<code class="literal">WHERE</code> 句で指定された基準を満たさない場合)。 ただし場合によっては、クエリーの実行中に結果行とその元のソースとの関係が失われたために、行のロックがすぐに解除されない可能性もあります。 たとえば <code class="literal">UNION</code> では、スキャン (およびロック) されたテーブル内の行が、結果セットに含める対象となるかどうかの評価前に、一時テーブルに挿入される可能性があります。 この状況では、一時テーブル内の行と元のテーブル内の行との関係は失われているため、クエリー実行が終了するまで後者の行のロックは解除されません。 
        </p></li><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_locking_read" title="ロック読み取り">locking reads</a> (<code class="literal">SELECT</code> と <code class="literal">FOR UPDATE</code> または <code class="literal">FOR SHARE</code>)、<code class="literal">UPDATE</code> および <code class="literal">DELETE</code> ステートメントの場合、実行されるロックは、ステートメントが一意の検索条件を持つ一意のインデックスを使用するか、範囲タイプの検索条件を使用するかによって異なります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              一意の検索条件を使用した一意のインデックスの場合、<code class="literal">InnoDB</code> は見つかったインデックスレコードのみをロックし、その前にある<a class="link" href="glossary.html#glos_gap" title="ギャップ">ギャップ</a>はロックしません。
            </p></li><li class="listitem"><p>
              他の検索条件および一意でないインデックスの場合、<code class="literal">InnoDB</code> は、<a class="link" href="glossary.html#glos_gap_lock" title="ギャップロック">gap locks</a> または <a class="link" href="glossary.html#glos_next_key_lock" title="ネクストキーロック">next-key locks</a> を使用してスキャンされたインデックス範囲をロックし、他のセッションによる挿入を範囲の対象となるギャップにブロックします。 ギャップロックおよびネクストキーロックについては、<a class="xref" href="innodb-storage-engine.html#innodb-locking" title="15.7.1 InnoDB ロック">セクション15.7.1「InnoDB ロック」</a> を参照してください。 
            </p></li></ul></div></li><li class="listitem"><p>
          検索で検出されたインデックスレコードの場合、<code class="literal">SELECT ... FOR UPDATE</code> は、他のセッションによる <code class="literal">SELECT ... FOR SHARE</code> の実行または特定のトランザクション分離レベルでの読取りをブロックします。 一貫性読み取りでは、読み取られたビュー内に存在するレコードに設定されたロックはすべて無視されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">UPDATE ... WHERE ...</code> は、検索で見つかったすべてのレコード上に排他ネクストキーロックを設定します。 ただし、一意の行を検索するために一意のインデックスを使用して行をロックするステートメントには、インデックスレコードのロックのみが必要です。 
        </p></li><li class="listitem"><p>
          <code class="literal">UPDATE</code> がクラスタ化されたインデックスレコードを変更すると、影響を受けるセカンダリインデックスレコードが暗黙的にロックされます。 <code class="literal">UPDATE</code> 操作では、新しいセカンダリインデックスレコードを挿入する前に重複チェックスキャンを実行するとき、および新しいセカンダリインデックスレコードを挿入するときに、影響を受けるセカンダリインデックスレコードの共有ロックも取得されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">DELETE FROM ... WHERE ...</code> は、検索で見つかったすべてのレコード上に排他ネクストキーロックを設定します。 ただし、一意の行を検索するために一意のインデックスを使用して行をロックするステートメントには、インデックスレコードのロックのみが必要です。 
        </p></li><li class="listitem"><p>
          <code class="literal">INSERT</code> は、挿入される行に排他ロックを設定します。 このロックは、ネクストキーロックではなくインデックスレコードロックである (つまり、ギャップロックが存在しない) ため、ほかのセッションが挿入された行の前にあるギャップに挿入することは回避されません。 
        </p><p>
          行を挿入する前に、挿入意図ギャップロックと呼ばれるギャップロックのタイプが設定されます。 このロックは、同じインデックスギャップに挿入する複数のトランザクションは、そのギャップ内の同じ場所に挿入しなければ相互に待機する必要がないように、意図的に挿入することを示しています。 値が 4 と 7 のインデックスレコードが存在すると仮定します。 それぞれ値 5 と 6 の挿入を試みる別々のトランザクションは、挿入される行の排他ロックを取得する前に挿入インテンションロックを使用して、4 と 7 の間にあるギャップをロックしますが、行の競合が発生しないため相互にブロックされません。 
        </p><p>
          重複キーエラーが発生すると、重複インデックスレコード上の共有ロックが設定されます。 複数のセッションが同じ行を挿入しようとしているときに、別のセッションがすでに排他ロックを取得していた場合は、このように共有ロックを使用することでデッドロックが発生する可能性があります。 これは、別のセッションがその行を削除した場合に発生する可能性があります。 <code class="literal">InnoDB</code> テーブル <code class="literal">t1</code> の構造が次のようになっているとします。 
        </p><pre class="programlisting">CREATE TABLE t1 (i INT, PRIMARY KEY (i)) ENGINE = InnoDB;
</pre><p>
          次に、3 つのセッションが次の処理を順番に実行するものとします。
        </p><p>
          セッション 1:
        </p><pre class="programlisting">START TRANSACTION;
INSERT INTO t1 VALUES(1);
</pre><p>
          セッション 2:
        </p><pre class="programlisting">START TRANSACTION;
INSERT INTO t1 VALUES(1);
</pre><p>
          セッション 3:
        </p><pre class="programlisting">START TRANSACTION;
INSERT INTO t1 VALUES(1);
</pre><p>
          セッション 1:
        </p><pre class="programlisting">ROLLBACK;
</pre><p>
          セッション 1 による最初の処理では、行の排他ロックが取得されます。 セッション 2 と 3 の処理ではどちらも重複キーエラーが発生し、どちらのセッションも行の共有ロックをリクエストします。 セッション 1 はロールバック時に行の排他ロックを解放し、キュー内のセッション 2 と 3 の共有ロックリクエストが付与されます。 この時点でセッション 2 と 3 でデッドロックが発生します。どちらも他方が保持している共有ロックのために、行の排他ロックを取得できません。 
        </p><p>
          キー値が 1 の行がテーブルに含まれている場合も似たような状況が発生し、3 つのセッションが次の処理を順番に実行します。
        </p><p>
          セッション 1:
        </p><pre class="programlisting">START TRANSACTION;
DELETE FROM t1 WHERE i = 1;
</pre><p>
          セッション 2:
        </p><pre class="programlisting">START TRANSACTION;
INSERT INTO t1 VALUES(1);
</pre><p>
          セッション 3:
        </p><pre class="programlisting">START TRANSACTION;
INSERT INTO t1 VALUES(1);
</pre><p>
          セッション 1:
        </p><pre class="programlisting">COMMIT;
</pre><p>
          セッション 1 による最初の処理では、行の排他ロックが取得されます。 セッション 2 と 3 の処理ではどちらも重複キーエラーが発生し、どちらのセッションも行の共有ロックをリクエストします。 セッション 1 はコミット時に行の排他ロックを解放し、キュー内のセッション 2 と 3 の共有ロックリクエストが付与されます。 この時点でセッション 2 と 3 でデッドロックが発生します。どちらも他方が保持している共有ロックのために、行の排他ロックを取得できません。 
        </p></li><li class="listitem"><p>
          <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> は、重複キーエラーが発生したときに更新される行に共有ロックではなく排他ロックが設定されるという点で、単純な <code class="literal">INSERT</code> と異なります。 重複する主キー値に対して排他的なインデックスレコードロックが取得されます。 重複する一意キー値に対して排他的なネクストキーロックが取得されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">REPLACE</code> は、一意のキーが競合していなければ、<code class="literal">INSERT</code> と同様に動作します。 それ以外の場合は、置換される行に排他ネクストキーロックが配置されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">INSERT INTO T SELECT ... FROM S WHERE ...</code> では、<code class="literal">T</code> に挿入された各行に排他的インデックスレコードロック (ギャップロックなし) が設定されます。 トランザクション分離レベルが <code class="literal">READ COMMITTED</code> の場合、<code class="literal">InnoDB</code> は <code class="literal">S</code> で一貫性読取り (ロックなし) として検索を実行します。 それ以外の場合、<code class="literal">InnoDB</code> は <code class="literal">S</code> から取得した行に共有ネクストキーロックを設定します。 後者の場合、<code class="literal">InnoDB</code> はロックを設定する必要があります: ステートメントベースのバイナリログを使用したロールフォワードリカバリ中は、すべての SQL ステートメントを、最初に実行されたのとまったく同じ方法で実行する必要があります。 
        </p><p>
          <code class="literal">CREATE TABLE ... SELECT ...</code> は、<code class="literal">INSERT ... SELECT</code> の場合と同様に、<code class="literal">SELECT</code> を共有ネクストキーロックを使用して実行するか、一貫性読み取りとして実行します。
        </p><p>
          構造文 <code class="literal">REPLACE INTO t SELECT ... FROM s WHERE ...</code> または <code class="literal">UPDATE t ... WHERE col IN (SELECT ... FROM s ...)</code> で <code class="literal">SELECT</code> が使用されると、<code class="literal">InnoDB</code> はテーブル <code class="literal">s</code> の行に共有ネクストキーロックを設定します。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> は、テーブルで以前に指定された <code class="literal">AUTO_INCREMENT</code> カラムを初期化する際に、<code class="literal">AUTO_INCREMENT</code> カラムに関連付けられたインデックスの最後に排他ロックを設定します。
        </p><p>
          <code class="literal">innodb_autoinc_lock_mode=0</code> では、<code class="literal">InnoDB</code> は特別な <code class="literal">AUTO-INC</code> テーブルロックモードを使用します。このモードでは、自動増分カウンタにアクセスしながら、ロックが取得され、(トランザクション全体の最後ではなく) 現在の SQL ステートメントの最後まで保持されます。 <code class="literal">AUTO-INC</code> テーブルロックが保持されている間は、ほかのクライアントはそのテーブルに挿入できません。 <code class="literal">innodb_autoinc_lock_mode=1</code> を使用した<span class="quote">「<span class="quote">「一括挿入」</span>」</span>でも同じ動作が発生します。 テーブルレベルの <code class="literal">AUTO-INC</code> ロックは、<code class="literal">innodb_autoinc_lock_mode=2</code> では使用されません。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-handling" title="15.6.1.6 InnoDB での AUTO_INCREMENT 処理">セクション15.6.1.6「InnoDB での AUTO_INCREMENT 処理」</a> を参照してください。 
        </p><p>
          <code class="literal">InnoDB</code> は、ロックを設定せずに、事前に初期化された <code class="literal">AUTO_INCREMENT</code> カラムの値をフェッチします。
        </p></li><li class="listitem"><p>
          <code class="literal">FOREIGN KEY</code> 制約がテーブル上で定義されている場合は、制約条件をチェックする必要がある挿入、更新、または削除が行われると、制約をチェックするために、参照されるレコード上に共有レコードレベルロックが設定されます。 <code class="literal">InnoDB</code> は、制約が失敗する場合に備えて、これらのロックの設定も行います。 
        </p></li><li class="listitem"><p>
          <code class="literal">LOCK TABLES</code> はテーブルロックを設定しますが、これらのロックを設定する <code class="literal">InnoDB</code> レイヤーよりも上位の MySQL レイヤーです。 <code class="literal">InnoDB</code> は、<code class="literal">innodb_table_locks = 1</code> (デフォルト) かつ <code class="literal">autocommit = 0</code> の場合にテーブルロックを認識し、<code class="literal">InnoDB</code> よりも上位の MySQL レイヤーは、行レベルロックを識別します。 
        </p><p>
          それ以外の場合は、<code class="literal">InnoDB</code> の自動デッドロック検出では、このようなテーブルロックが関与するデッドロックを検出できません。 また、この場合には上位の MySQL レイヤーは行レベルロックを識別しないため、現在別のセッションが行レベルロックを保持しているテーブル上でテーブルロックを取得できます。 ただし、<a class="xref" href="innodb-storage-engine.html#innodb-deadlock-detection" title="15.7.5.2 デッドロック検出">セクション15.7.5.2「デッドロック検出」</a>で説明したように、これによりトランザクションの完全性が危険にさらされることはありません。 
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_table_locks=1</code> (デフォルト) の場合、<code class="literal">LOCK TABLES</code> で各テーブル上に 2 つのロックが取得されます。 MySQL レイヤーでのテーブルロックに加えて、<code class="literal">InnoDB</code> テーブルロックも取得されます。 バージョン 4.1.2 よりも前の MySQL では、<code class="literal">InnoDB</code> テーブルロックが取得されませんでした。この古い動作は、<code class="literal">innodb_table_locks=0</code> を設定すれば選択できます。 <code class="literal">InnoDB</code> テーブルロックが取得されない場合は、テーブルの一部のレコードがほかのトランザクションによってロックされなくても、<code class="literal">LOCK TABLES</code> が完了します。 
        </p><p>
          MySQL 8.0 では、<code class="literal">LOCK TABLES ... WRITE</code> を使用して明示的にロックされたテーブルには、<code class="literal">innodb_table_locks=0</code> が無効です。 <code class="literal">LOCK TABLES ... WRITE</code> で暗黙的に (たとえば、トリガーを使用して)、または <code class="literal">LOCK TABLES ... READ</code> によって、読み取りまたは書き込み用にロックされたテーブルには有効です。 
        </p></li><li class="listitem"><p>
          トランザクションで保持されているすべての <code class="literal">InnoDB</code> ロックは、トランザクションがコミットまたは中止されると解放されます。 したがって、<code class="literal">autocommit=1</code> モードの <code class="literal">InnoDB</code> テーブル上で <code class="literal">LOCK TABLES</code> を呼び出しても、取得された <code class="literal">InnoDB</code> テーブルロックはすぐに解放されてしまうため、まったく意味がありません。 
        </p></li><li class="listitem"><p>
          <code class="literal">LOCK TABLES</code> では暗黙的な <code class="literal">COMMIT</code> および <code class="literal">UNLOCK TABLES</code> が実行されるため、トランザクションの実行中に追加のテーブルをロックできません。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-next-key-locking"></a>15.7.4 ファントム行</h3></div></div></div><a class="indexterm" name="idm44761361547920"></a><a class="indexterm" name="idm44761361546464"></a><a class="indexterm" name="idm44761361544448"></a><a class="indexterm" name="idm44761361542384"></a><a class="indexterm" name="idm44761361540320"></a><a class="indexterm" name="idm44761361538288"></a><a class="indexterm" name="idm44761361536336"></a><a class="indexterm" name="idm44761361534272"></a><a class="indexterm" name="idm44761361532208"></a><p>
      同じクエリーでさまざまな時間にさまざまな行のセットが生成されると、いわゆる<span class="firstterm">ファントム</span>の問題がトランザクション内で発生します。 たとえば、<code class="literal">SELECT</code> が 2 回実行されたが、1 回目には返されなかった行が 2 回目には返された場合、その行が<span class="quote">「<span class="quote">ファントム</span>」</span>行です。 
    </p><p>
      <code class="literal">child</code> テーブルの <code class="literal">id</code> カラム上にインデックスがあり、識別子の値が 100 よりも大きいすべての行をテーブルから読み取り、選択された行の一部のカラムをあとで更新するという意図でロックすると仮定します。
    </p><pre class="programlisting">SELECT * FROM child WHERE id &gt; 100 FOR UPDATE;
</pre><p>
      クエリーでは、<code class="literal">id</code> が 100 よりも大きい最初のレコードからインデックスがスキャンされます。 このテーブルには <code class="literal">id</code> の値が 90 と 102 の行が格納されているものとします。 スキャン範囲内のインデックスレコード上に設定されたロックによって、ギャップ (この場合のギャップは 90 から 102 まで) への挿入がロックアウトされていない場合は、別のセッションが <code class="literal">id</code> が 101 の新しい行をそのテーブルに挿入できます。 同じトランザクション内で同じ <code class="literal">SELECT</code> を実行すると、クエリーから返された結果セット内に、<code class="literal">id</code> が 101 の新しい行 (<span class="quote">「<span class="quote">ファントム</span>」</span>) が含まれています。 一連の行をデータ項目とみなせば、この新しいファントムの子は、「トランザクション中は読み取られるデータが変更されないようにトランザクションを実行できるべきである」というトランザクションの分離原則に違反しています。 
    </p><p>
      ファントムの発生を回避できるように、<code class="literal">InnoDB</code> では通常、インデックス行ロックとギャップロックを組み合わせた<span class="firstterm">ネクストキーロック</span>と呼ばれるアルゴリズムが使用されます。 <code class="literal">InnoDB</code> は、テーブルインデックスを検索またはスキャンするときに、生成されたインデックスレコード上に共有ロックまたは排他ロックを設定するという方法で、行レベルロックを実行します。 したがって、行レベルロックは、実際にはインデックスレコードロックです。 さらに、あるインデックスレコードに対するネクストキーロックによって、そのインデックスレコードの前の<span class="quote">「<span class="quote">ギャップ</span>」</span>も影響を受けます。 つまり、ネクストキーロックは、インデックスレコードロックと、そのインデックスレコードの前のギャップに対するギャップロックとを組み合わせたものです。 あるセッションがインデックス内のレコード <code class="literal">R</code> 上に共有ロックまたは排他ロックを持っている場合は、別のセッションがインデックスの順番で <code class="literal">R</code> の直前にあるギャップに新しいインデックスレコードを挿入できません。 
    </p><p>
      <code class="literal">InnoDB</code> はインデックスをスキャンするときに、インデックス内の最後のレコードのあとのギャップをロックすることもできます。 前述の例では、まさにそれが行われています。<code class="literal">id</code> が 100 よりも大きいテーブルへの挿入が回避されるように、<code class="literal">InnoDB</code> で設定されたロックには、<code class="literal">id</code> 値 102 のあとのギャップに対するロックが含まれています。 
    </p><p>
      ネクストキーロックを使用すると、アプリケーションに一意性チェックを実装できます。共有モードでデータを読み取るときに、挿入される行の重複が見られなければ、行を安全に挿入でき、読み取り中に後続の行に設定されたネクストキーロックによって、任意のユーザーによる重複行の挿入が回避されることを確認できます。 したがって、ネクストキーロックを使用すれば、テーブル内に存在しないものも<span class="quote">「<span class="quote">ロック</span>」</span>できます。 
    </p><p>
      ギャップロックは、<a class="xref" href="innodb-storage-engine.html#innodb-locking" title="15.7.1 InnoDB ロック">セクション15.7.1「InnoDB ロック」</a>で説明した方法で無効にすることができます。 ギャップロックが無効になっていると、ほかのセッションが新しい行をギャップに挿入できるため、ファントムの問題が発生する可能性があります。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-deadlocks"></a>15.7.5 InnoDB のデッドロック</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-deadlock-example">15.7.5.1 InnoDB デッドロックの例</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-deadlock-detection">15.7.5.2 デッドロック検出</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-deadlocks-handling">15.7.5.3 デッドロックを最小化および処理する方法</a></span></dt></dl></div><a class="indexterm" name="idm44761361502848"></a><a class="indexterm" name="idm44761361500736"></a><a class="indexterm" name="idm44761361497984"></a><a class="indexterm" name="idm44761361495872"></a><p>
      デッドロックとは、それぞれが他の必要なロックを保持しているために、異なるトランザクションを続行できない状況です。 両方のトランザクションがリソースが使用可能になるのを待機しているため、保持しているロックは解放されません。 
    </p><p>
      デッドロックは、(<code class="literal">UPDATE</code> や <code class="literal">SELECT ... FOR UPDATE</code> などのステートメントを使用して) 複数のテーブルの行をトランザクションがロックするときに発生する可能性がありますが、逆の順序で発生します。 デッドロックは、このようなステートメントがインデックスレコードとギャップの範囲をロックし、各トランザクションが一部のロックを取得するけれども、タイミングの問題によりほかを取得しない場合にも発生することがあります。 デッドロックの例については、<a class="xref" href="innodb-storage-engine.html#innodb-deadlock-example" title="15.7.5.1 InnoDB デッドロックの例">セクション15.7.5.1「InnoDB デッドロックの例」</a> を参照してください。 
    </p><p>
      デッドロックの可能性を減らすには、<code class="literal">LOCK TABLES</code> ステートメントではなくトランザクションを使用します。データを挿入または更新するトランザクションのサイズは、長期間オープンしたままにしないでください。異なるトランザクションが複数のテーブルまたは行の範囲を更新する場合は、各トランザクションで同じ順序 (<code class="literal">SELECT ... FOR UPDATE</code> など) を使用し、<code class="literal">SELECT ... FOR UPDATE</code> ステートメントおよび <code class="literal">UPDATE ... WHERE</code> ステートメントで使用されるカラムにインデックスを作成します。 デッドロックの可能性は、分離レベルに影響を受けません。分離レベルは読み取り操作の動作を変更し、デッドロックは書き込み操作のために発生するからです。 デッドロック状態からの回避およびリカバリの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-deadlocks-handling" title="15.7.5.3 デッドロックを最小化および処理する方法">セクション15.7.5.3「デッドロックを最小化および処理する方法」</a> を参照してください。 
    </p><p>
      デッドロック検出が有効 (デフォルト) でデッドロックが発生した場合、<code class="literal">InnoDB</code> は条件を検出し、いずれかのトランザクション (被害者) をロールバックします。 <code class="literal">innodb_deadlock_detect</code> 構成オプションを使用してデッドロック検出が無効になっている場合、<code class="literal">InnoDB</code> は、デッドロックの場合にトランザクションをロールバックするために <code class="literal">innodb_lock_wait_timeout</code> 設定に依存します。 したがって、アプリケーションロジックが正しい場合でも、トランザクションを再試行する必要があるケースを処理する必要があります。 <code class="literal">InnoDB</code> ユーザートランザクションの最後のデッドロックを表示するには、<code class="literal">SHOW ENGINE INNODB STATUS</code> コマンドを使用します。 デッドロックが頻繁に発生して、トランザクション構造やアプリケーションエラー処理に問題があるらしいと思われる場合は、<span class="command"><strong>mysqld</strong></span> エラーログにすべてのデッドロックに関する情報を出力するために、<code class="literal">innodb_print_all_deadlocks</code> 設定を有効にした状態で実行してください。 デッドロックが自動的に検出および処理される方法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-deadlock-detection" title="15.7.5.2 デッドロック検出">セクション15.7.5.2「デッドロック検出」</a> を参照してください。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-deadlock-example"></a>15.7.5.1 InnoDB デッドロックの例</h4></div></div></div><a class="indexterm" name="idm44761361470128"></a><a class="indexterm" name="idm44761361468032"></a><p>
        次の例は、ロックリクエストによってデッドロックが発生したときに、どのようにエラーが発生するのかを示しています。 この例には、A と B の 2 つのクライアントが登場します。 
      </p><p>
        最初に、クライアント A が行を 1 つ含むテーブルを作成し、トランザクションを開始します。 トランザクション内で、A は共有モードで選択した行で <code class="literal">S</code> ロックを取得します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t (i INT) ENGINE = InnoDB;</code></strong>
Query OK, 0 rows affected (1.07 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO t (i) VALUES(1);</code></strong>
Query OK, 1 row affected (0.09 sec)

mysql&gt; <strong class="userinput"><code>START TRANSACTION;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t WHERE i = 1 FOR SHARE;</code></strong>
+------+
| i    |
+------+
|    1 |
+------+
</pre><p>
        次に、クライアント B がトランザクションを開始し、テーブルから行を削除しようとします。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>START TRANSACTION;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>DELETE FROM t WHERE i = 1;</code></strong>
</pre><p>
        削除操作を行うには、<code class="literal">X</code> ロックが必要です。 クライアント A が保持している <code class="literal">S</code> ロックとの互換性がないために、ロックを付与できません。そのため、リクエストはその行のロックリクエストのキューに入れられ、クライアント B はブロックされます。 
      </p><p>
        最後に、クライアント A もテーブルから行を削除しようとします。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>DELETE FROM t WHERE i = 1;</code></strong>
ERROR 1213 (40001): Deadlock found when trying to get lock;
try restarting transaction
</pre><p>
        クライアント A は行を削除するために <code class="literal">X</code> ロックが必要であるため、ここでデッドロックが発生します。 ただし、クライアント B はすでに <code class="literal">X</code> ロックに対するリクエストを持っていて、クライアント A がその <code class="literal">S</code> ロックを解放するまで待機しているため、そのロックリクエストを付与することはできません。 B による <code class="literal">X</code> ロックに対する以前のリクエストが原因で、A が保持している <code class="literal">S</code> ロックを <code class="literal">X</code> ロックにアップグレードすることもできません。 その結果、<code class="literal">InnoDB</code> はクライアントのいずれかに対してエラーを生成し、そのロックを解放します。 クライアントは、次のエラーを返します。 
      </p><pre class="programlisting">ERROR 1213 (40001): Deadlock found when trying to get lock;
try restarting transaction
</pre><p>
        この時点で、ほかのクライアントに対するロックリクエストを付与できるようになり、テーブルから行が削除されます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-deadlock-detection"></a>15.7.5.2 デッドロック検出</h4></div></div></div><a class="indexterm" name="idm44761361442512"></a><a class="indexterm" name="idm44761361440368"></a><a class="indexterm" name="idm44761361439024"></a><a class="indexterm" name="idm44761361436960"></a><a class="indexterm" name="idm44761361434208"></a><a class="indexterm" name="idm44761361432096"></a><p>
        <a class="link" href="glossary.html#glos_deadlock_detection" title="デッドロック検出">deadlock detection</a> が有効な場合 (デフォルト)、<code class="literal">InnoDB</code> はトランザクション <a class="link" href="glossary.html#glos_deadlock" title="デッドロック">deadlocks</a> を自動的に検出し、デッドロックを解消するためにトランザクションをロールバックします。 <code class="literal">InnoDB</code> は、小さいトランザクションを選択してロールバックしようと試みます。トランザクションのサイズは、挿入、更新、または削除された行数によって決定されます。 
      </p><p>
        <code class="literal">InnoDB</code> は、<code class="literal">innodb_table_locks = 1</code> (デフォルト) かつ <code class="literal">autocommit = 0</code> の場合にテーブルロックを認識し、それよりも上位の MySQL レイヤーは、行レベルロックを識別します。 それ以外の場合、<code class="literal">InnoDB</code> は、MySQL <code class="literal">LOCK TABLES</code> ステートメントで設定されたテーブルロックまたは <code class="literal">InnoDB</code> 以外のストレージエンジンで設定されたロックが関連しているデッドロックを検出できません。 このような状況を解決するには、<code class="literal">innodb_lock_wait_timeout</code> システム変数の値を設定します。 
      </p><p>
        <code class="literal">InnoDB</code> Monitor 出力の <code class="literal">LATEST DETECTED DEADLOCK</code> セクションに<span class="errortext">「グラフのロックテーブルの検索が深すぎるか長すぎます。次のトランザクションをロールバック」</span>というメッセージが含まれている場合、これは、キャンセル待ちリストのトランザクション数が 200 の制限に達したことを示します。 200 個のトランザクションを超える待機リストはデッドロックとして処理され、待機リストをチェックしようとするトランザクションはロールバックされます。 ロックスレッドが待機リストのトランザクションが所有する 1,000,000 を超えるロックを参照する必要がある場合も、同じエラーが発生する可能性があります。 
      </p><p>
        デッドロックを回避するためにデータベース操作を編成する方法については、<a class="xref" href="innodb-storage-engine.html#innodb-deadlocks" title="15.7.5 InnoDB のデッドロック">セクション15.7.5「InnoDB のデッドロック」</a>を参照してください。
      </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-disable-deadlock-detection"></a>デッドロック検出の無効化</h5></div></div></div><p>
          同時実行性の高いシステムでは、多数のスレッドが同じロックを待機している場合、デッドロック検出によって速度が低下する可能性があります。 デッドロック検出を無効にし、デッドロック発生時のトランザクションロールバックの <code class="literal">innodb_lock_wait_timeout</code> 設定に依存する方が効率的な場合があります。 デッドロック検出は、<code class="literal">innodb_deadlock_detect</code> 構成オプションを使用して無効にできます。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-deadlocks-handling"></a>15.7.5.3 デッドロックを最小化および処理する方法</h4></div></div></div><p>
        このセクションは、<a class="xref" href="innodb-storage-engine.html#innodb-deadlock-detection" title="15.7.5.2 デッドロック検出">セクション15.7.5.2「デッドロック検出」</a>に示したデッドロックに関する概念情報に基づいています。 ここでは、デッドロックが最小限になるようにデータベース操作を編成する方法、およびアプリケーションで必要となる後続のエラー処理について説明します。 
      </p><p>
        <a class="link" href="glossary.html#glos_deadlock" title="デッドロック">デッドロック</a>は、トランザクションデータベースの古典的な問題ですが、特定のトランザクションをまったく実行できないほど発生頻度が高くなければ、危険ではありません。 通常は、デッドロックが発生したためにトランザクションがロールバックされた場合に、それを再発行できる準備が常にできているようにアプリケーションを作成する必要があります。 
      </p><p>
        <code class="literal">InnoDB</code> では自動行レベルロックが使用されます。 単一の行を挿入または削除するだけのトランザクションの場合でも、デッドロックが発生する可能性があります。 その原因は、これらの操作が実際には<span class="quote">「<span class="quote">原子的</span>」</span>でないためです。これらの操作では自動的に、挿入または削除される行のインデックスレコード (複数の可能性あり) にロックが設定されます。 
      </p><p>
        次の方法を使用すれば、デッドロックに対処し、発生の可能性を減らすことができます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            いつでも、<code class="literal">SHOW ENGINE INNODB STATUS</code> コマンドを発行して、最近のデッドロックの原因を特定してください。 これは、デッドロックが回避されるようにアプリケーションを調整する際に役立ちます。 
          </p></li><li class="listitem"><p>
            デッドロック警告が頻繁に発生することが懸念される場合は、<code class="literal">innodb_print_all_deadlocks</code> 構成オプションを有効にして、より広範なデバッグ情報を収集します。 MySQL の<a class="link" href="glossary.html#glos_error_log" title="エラーログ">エラーログ</a>には、最近のデッドロックだけでなく、各デッドロックに関する情報が記録されます。 デバッグが完了したら、このオプションを無効にします。 
          </p></li><li class="listitem"><p>
            デッドロックが原因でトランザクションに失敗した場合に、そのトランザクションを再発行できるように常に準備しておきます。 デッドロックは危険ではありません。 再度試してください。 
          </p></li><li class="listitem"><p>
            トランザクションが競合する可能性を低くするために、トランザクションのサイズを小さく、期間を短く保ってください。
          </p></li><li class="listitem"><p>
            トランザクションが競合する可能性を低くするために、関連する一連の変更を行なった直後にトランザクションをコミットしてください。 特に、コミットされていないトランザクションを含むインタラクティブな <span class="command"><strong>mysql</strong></span> セッションは、長時間開いたままにしないでください。 
          </p></li><li class="listitem"><p>
            <a class="link" href="glossary.html#glos_locking_read" title="ロック読み取り">locking reads</a> (<code class="literal">SELECT ... FOR UPDATE</code> または <code class="literal">SELECT ... FOR SHARE</code>) を使用する場合は、<code class="literal">READ COMMITTED</code> などのより低い分離レベルを使用してみてください。
          </p></li><li class="listitem"><p>
            トランザクション内の複数のテーブルを変更する場合や、同じテーブル内のさまざまな行のセットを変更する場合は、毎回、これらの操作を一貫性のある順序で実行してください。 その結果、トランザクションで明示的に定義されたキューが生成され、デッドロックは発生しません。 たとえば、さまざまな場所で同様の <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> ステートメントのシーケンスを複数回コーディングするのではなく、データベース操作をアプリケーション内の関数に編成したり、ストアドルーチンを呼び出したりします。 
          </p></li><li class="listitem"><p>
            テーブルに適切なインデックスを追加してください。 これにより、クエリーでスキャンする必要のあるインデックスレコード数が減少するため、ロックの設定も減少します。 MySQL サーバーがクエリーに最適であるとみなすインデックスを特定するために、<code class="literal">EXPLAIN SELECT</code> を使用してください。 
          </p></li><li class="listitem"><p>
            ロックの使用を減らしてください。 <code class="literal">SELECT</code> が古いスナップショットからデータを返すことを許可できる場合は、<code class="literal">FOR UPDATE</code> または <code class="literal">FOR SHARE</code> 句を追加しないでください。 同じトランザクション内の各一貫性読み取りでは、独自の新しいスナップショットから読み取られるため、<code class="literal">READ COMMITTED</code> 分離レベルを使用することが適切な方法です。 
          </p></li><li class="listitem"><p>
            ほかに方法がなければ、テーブルレベルロックを使用してトランザクションを直列化してください。 <code class="literal">InnoDB</code> テーブルなどのトランザクションテーブルで <code class="literal">LOCK TABLES</code> を使用する正しい方法は、(<code class="literal">START TRANSACTION</code> ではなく) <code class="literal">SET autocommit = 0</code> でトランザクションを開始し、そのあと <code class="literal">LOCK TABLES</code> を実行し、<code class="literal">UNLOCK TABLES</code> を呼び出す前にそのトランザクションを明示的にコミットすることです。 たとえば、テーブル <code class="literal">t1</code> に書き込み、テーブル <code class="literal">t2</code> から読み取る必要がある場合は、次のように実行できます。 
          </p><pre class="programlisting">SET autocommit=0;
LOCK TABLES t1 WRITE, t2 READ, ...;
<em class="replaceable"><code>... do something with tables t1 and t2 here ...</code></em>
COMMIT;
UNLOCK TABLES;
</pre><p>
            テーブルレベルロックを使用すると、テーブルへの並列更新が抑制されるため、デッドロックが回避されますが、負荷の高いシステムで応答性が低くなるという犠牲が伴います。
          </p></li><li class="listitem"><p>
            トランザクションを直列化する別の方法は、単一行だけを含む補助<span class="quote">「<span class="quote">セマフォー</span>」</span>テーブルを作成することです。 ほかのテーブルにアクセスする前に、各トランザクションでその行を更新してください。 これにより、すべてのトランザクションが直列方式で発生します。 直列化ロックは行レベルロックであるため、この場合、<code class="literal">InnoDB</code> のインスタントデッドロック検出アルゴリズムも機能することに注意してください。 MySQL のテーブルレベルロックを使用してデッドロックを解決するには、タイムアウト方式を使用する必要があります。 
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-transaction-scheduling"></a>15.7.6 トランザクションスケジューリング</h3></div></div></div><p>
      <code class="literal">InnoDB</code> では、競合対応トランザクションスケジューリング (CATS) アルゴリズムを使用して、ロックを待機しているトランザクションに優先順位を付けます。 複数のトランザクションが同じオブジェクトのロックを待機している場合、CATS アルゴリズムは最初にロックを受信するトランザクションを決定します。 
    </p><p>
      CATS アルゴリズムは、トランザクションがブロックするトランザクションの数に基づいて計算されるスケジューリング加重を割り当てることで、待機中のトランザクションに優先順位を付けます。 たとえば、2 つのトランザクションが同じオブジェクトのロックを待機している場合、ほとんどのトランザクションをブロックするトランザクションには、より大きなスケジューリング加重が割り当てられます。 重みが等しい場合、最も長い待機トランザクションに優先度が与えられます。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        MySQL 8.0.20 より前の <code class="literal">InnoDB</code> では、トランザクションのスケジュールに先入れ先出し (FIFO) アルゴリズムも使用され、CATS アルゴリズムはロック競合が多い場合にのみ使用されていました。 MySQL 8.0.20 の CATS アルゴリズムの拡張により、FIFO アルゴリズムが冗長になり、削除が許可されました。 FIFO アルゴリズムによって以前に実行されたトランザクションスケジューリングは、MySQL 8.0.20 の時点で CATS アルゴリズムによって実行されます。 場合によっては、この変更がトランザクションにロックが付与される順序に影響することがあります。 
      </p></div><p>
      <code class="literal">INFORMATION_SCHEMA.INNODB_TRX</code> テーブルの <code class="literal">TRX_SCHEDULE_WEIGHT</code> カラムをクエリーすることで、トランザクションスケジューリング加重を表示できます。 重みは、待機中のトランザクションに対してのみ計算されます。 待機中のトランザクションは、<code class="literal">TRX_STATE</code> カラムでレポートされる <code class="literal">LOCK WAIT</code> トランザクション実行状態のトランザクションです。 ロックを待機していないトランザクションは、NULL の <code class="literal">TRX_SCHEDULE_WEIGHT</code> 値を報告します。 
    </p><p>
      <code class="literal">INNODB_METRICS</code> カウンタは、コードレベルのトランザクションスケジューリングイベントを監視するために用意されています。 <code class="literal">INNODB_METRICS</code> カウンタの使用の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-information-schema-metrics-table" title="15.15.6 InnoDB INFORMATION_SCHEMA メトリックテーブル">セクション15.15.6「InnoDB INFORMATION_SCHEMA メトリックテーブル」</a> を参照してください。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">lock_rec_release_attempts</code>
        </p><p>
          レコードロックの解放の試行回数。 単一の構造にゼロ個以上のレコードロックが存在する可能性があるため、単一の試行によってゼロ個以上のレコードロックが解放される場合があります。 
        </p></li><li class="listitem"><p>
          <code class="literal">lock_rec_grant_attempts</code>
        </p><p>
          レコードロックの付与を試行する回数。 単一回試行すると、ゼロ個以上のレコードロックが付与される場合があります。 
        </p></li><li class="listitem"><p>
          <code class="literal">lock_schedule_refreshes</code>
        </p><p>
          スケジュール済トランザクションの重みを更新するために待機グラフが分析された回数。
        </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-configuration"></a>15.8 InnoDB の構成</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-init-startup-configuration">15.8.1 InnoDB の起動構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-read-only-instance">15.8.2 読み取り専用操作用の InnoDB の構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-buffer-pool">15.8.3 InnoDB バッファープールの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-thread_concurrency">15.8.4 InnoDB のスレッド並列性の構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-multiple_io_threads">15.8.5 InnoDB バックグラウンド I/O スレッドの数の構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-linux-native-aio">15.8.6 Linux での非同期 I/O の使用</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-configuring-io-capacity">15.8.7 InnoDB I/O Capacity の構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-spin_lock_polling">15.8.8 スピンロックのポーリングの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-purge-configuration">15.8.9 パージ構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-optimizer-statistics">15.8.10 InnoDB のオプティマイザ統計の構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#index-page-merge-threshold">15.8.11 インデックスページのマージしきい値の構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-dedicated-server">15.8.12 専用 MySQL Server の自動構成の有効化</a></span></dt></dl></div><p>
    このセクションでは、<code class="literal">InnoDB</code> の初期化、起動、および <code class="literal">InnoDB</code> ストレージエンジンのさまざまなコンポーネントと機能の構成情報と手順について説明します。 <code class="literal">InnoDB</code> テーブルのデータベース操作の最適化の詳細は、<a class="xref" href="optimization.html#optimizing-innodb" title="8.5 InnoDB テーブルの最適化">セクション8.5「InnoDB テーブルの最適化」</a> を参照してください。 
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-init-startup-configuration"></a>15.8.1 InnoDB の起動構成</h3></div></div></div><p>
      <code class="literal">InnoDB</code> 構成に関する最初の決定には、データファイル、ログファイル、ページサイズおよびメモリーバッファの構成が含まれます。 <code class="literal">InnoDB</code> インスタンスを作成する前に、データファイル、ログファイルおよびページサイズの構成を定義することをお薦めします。 <code class="literal">InnoDB</code> インスタンスの作成後にデータファイルまたはログファイルの構成を変更するには、簡単でない手順が必要になる場合があり、ページサイズを定義できるのは、<code class="literal">InnoDB</code> インスタンスが最初に初期化されたときのみです。 
    </p><p>
      これらのトピックに加えて、このセクションでは、構成ファイルでの <code class="literal">InnoDB</code> オプションの指定、<code class="literal">InnoDB</code> 初期化情報の表示、および記憶域に関する重要な考慮事項について説明します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-startup-mysql-configuration-file" title="MySQL 構成ファイルでのオプションの指定">MySQL 構成ファイルでのオプションの指定</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-startup-initialization-information" title="InnoDB 初期化情報の表示">InnoDB 初期化情報の表示</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-startup-storage-considerations" title="記憶域に関する重要な考慮事項">記憶域に関する重要な考慮事項</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-startup-data-file-configuration" title="システムテーブルスペースデータファイル構成">システムテーブルスペースデータファイル構成</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-startup-doublewrite-file-config" title="InnoDB 二重書込みバッファファイルの構成">InnoDB 二重書込みバッファファイルの構成</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-startup-log-file-configuration" title="redo ログファイル構成">redo ログファイル構成</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-startup-undo-tablespace" title="undo テーブルスペースの構成">undo テーブルスペースの構成</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-startup-temporary-tablespace" title="グローバル一時テーブルスペース構成">グローバル一時テーブルスペース構成</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-startup-session-temporary-tablespaces" title="セッション一時テーブルスペース構成">セッション一時テーブルスペース構成</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-startup-page-size" title="ページサイズ構成">ページサイズ構成</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-startup-memory-configuration" title="メモリー構成">メモリー構成</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-startup-mysql-configuration-file"></a>MySQL 構成ファイルでのオプションの指定</h4></div></div></div><p>
        MySQL はデータファイル、ログファイルおよびページサイズの構成設定を使用して <code class="literal">InnoDB</code> インスタンスを初期化するため、<code class="literal">InnoDB</code> を初めて初期化する前に、MySQL が起動時に読み取る構成ファイルでこれらの設定を定義することをお薦めします。 <code class="literal">InnoDB</code> は MySQL サーバーの起動時に初期化され、<code class="literal">InnoDB</code> の最初の初期化は通常、MySQL サーバーの初回起動時に行われます。 
      </p><p>
        サーバーの起動時に読み取られる任意のオプションファイルの <code class="literal">[mysqld]</code> グループ内に、<code class="literal">InnoDB</code> オプションを配置できます。 MySQL オプションファイルの場所は、<a class="xref" href="programs.html#option-files" title="4.2.2.2 オプションファイルの使用">セクション4.2.2.2「オプションファイルの使用」</a> で説明されています。 
      </p><p>
        <span class="command"><strong>mysqld</strong></span> が特定のファイル (および <code class="filename">mysqld-auto.cnf</code>) からのみオプションを読み取るようにするには、サーバーの起動時にコマンド行で最初のオプションとして <code class="option">--defaults-file</code> オプションを使用します:
      </p><pre class="programlisting">mysqld --defaults-file=<em class="replaceable"><code>path_to_configuration_file</code></em>
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-startup-initialization-information"></a>InnoDB 初期化情報の表示</h4></div></div></div><p>
        起動時に <code class="literal">InnoDB</code> の初期化情報を表示するには、コマンドプロンプトから <span class="command"><strong>mysqld</strong></span> を起動します。 コマンドプロンプトから <span class="command"><strong>mysqld</strong></span> を起動すると、初期化情報がコンソールに出力されます。 
      </p><p>
        たとえば、Windows では、<span class="command"><strong>mysqld</strong></span> が <code class="filename">C:\Program Files\MySQL\MySQL Server 8.0\bin</code> にある場合、次のように MySQL サーバーを起動します:
      </p><pre class="programlisting">C:\&gt; <strong class="userinput"><code>"C:\Program Files\MySQL\MySQL Server 8.0\bin\mysqld" --console</code></strong>
</pre><p>
        Unix に似たシステムでは、<span class="command"><strong>mysqld</strong></span> は MySQL インストールの <code class="filename">bin</code> ディレクトリにあります:
      </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>bin/mysqld --user=mysql &amp;</code></strong>
</pre><p>
        サーバー出力をコンソールに送信しない場合は、起動後にエラーログを確認して、起動プロセス中に <code class="literal">InnoDB</code> によって出力された初期化情報を確認します。
      </p><p>
        他の方法を使用した MySQL の起動の詳細は、<a class="xref" href="installing.html#automatic-start" title="2.10.5 MySQL を自動的に起動および停止する">セクション2.10.5「MySQL を自動的に起動および停止する」</a> を参照してください。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">InnoDB</code> では、起動時にすべてのユーザーテーブルおよび関連データファイルが開かれるわけではありません。 ただし、<code class="literal">InnoDB</code> では、データディクショナリで参照されるテーブルスペースファイル (<code class="filename">*.ibd</code> ファイル) の存在がチェックされます。 テーブルスペースファイルが見つからない場合、<code class="literal">InnoDB</code> はエラーをログに記録し、起動順序を続行します。 redo ログで参照されるテーブルスペースファイルは、redo アプリケーションのクラッシュリカバリ中に開くことができます。 
        </p></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-startup-storage-considerations"></a>記憶域に関する重要な考慮事項</h4></div></div></div><a class="indexterm" name="idm44761361276608"></a><a class="indexterm" name="idm44761361274640"></a><p>
        起動構成を続行する前に、次の記憶域関連の考慮事項を確認してください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            場合によっては、一部のデータが同じ物理ディスク上に配置されてない場合に、データベースのパフォーマンスが改善されることがあります。 非常に多くの場合、ログファイルをデータとは別のディスク上に配置すると、パフォーマンスの改善に役立ちます。 たとえば、システムテーブルスペースデータファイルとログファイルを異なるディスクに配置できます。 <code class="literal">InnoDB</code> データファイルに RAW ディスクパーティション (RAW デバイス) を使用して、I/O を高速化することもできます。 <a class="xref" href="innodb-storage-engine.html#innodb-raw-devices" title="システムテーブルスペースに対する RAW ディスクパーティションの使用">システムテーブルスペースに対する RAW ディスクパーティションの使用</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> はトランザクションセーフな (ACID に準拠した) MySQL 用のストレージエンジンであり、ユーザーデータを保護するためのコミット、ロールバック、およびクラッシュリカバリ機能を備えています。 ただし、ベースとなるオペレーティングシステムやハードウェアが公表どおりに機能しない場合は、<span class="bold"><strong>実行できません</strong></span>。 多くのオペレーティングシステムやディスクサブシステムでは、パフォーマンスを改善するために書き込み操作が遅延したり、再指示されたりする可能性があります。 一部のオペレーティングシステムでは、まさに <code class="literal">fsync()</code> システムコールは、ファイルのすべての未書き込みデータがフラッシュされるまで待機するべきですが、実際には、データが安定したストレージにフラッシュされる前に返される可能性があります。 このため、オペレーティングシステムのクラッシュや停電によって最近コミットされたデータが破損したり、さらに最悪の場合、書き込み操作が再指示されたためにデータベースが破損したりすることもあります。 データの完全性が重要である場合は、本番環境で何かを使用する前に、何らかの形で<span class="quote">「<span class="quote">電源プラグを抜く</span>」</span>テストを実行してください。 macOS では、<code class="literal">InnoDB</code> は特別な <code class="literal">fcntl()</code> ファイルフラッシュ方法を使用します。 Linux では、<span class="bold"><strong>ライトバックキャッシュを無効にする</strong></span>ことが推奨されています。 
          </p><p>
            ATA/SATA ディスクドライブ上で <code class="literal">hdparm -W0 /dev/hda</code> のようなコマンドを使用すると、ライトバックキャッシュを無効にできる場合があります。 <span class="bold"><strong>一部のドライブやディスクコントローラでは、ライトバックキャッシュを無効にできない可能性があることに注意してください。</strong></span> 
          </p></li><li class="listitem"><p>
            ユーザーを保護する <code class="literal">InnoDB</code> のリカバリ機能に関しては、<code class="literal">InnoDB</code> では<a class="link" href="glossary.html#glos_doublewrite_buffer" title="二重書き込みバッファー">二重書き込みバッファー</a>と呼ばれる構造に関連したファイルフラッシュ技術が使用されています。これは、デフォルトで有効になっています (<code class="literal">innodb_doublewrite=ON</code>)。 二重書込みバッファを使用すると、予期しない終了または停電後のリカバリの安全性が向上し、<code class="literal">fsync()</code> 操作の必要性を減らすことで、ほとんどの Unix のパフォーマンスが向上します。 データの完全性またはエラーの可能性に関心がある場合は、<code class="literal">innodb_doublewrite</code> オプションを有効のままにすることが推奨されています。 二重書き込みバッファーの追加情報については、<a class="xref" href="innodb-storage-engine.html#innodb-disk-io" title="15.11.1 InnoDB ディスク I/O">セクション15.11.1「InnoDB ディスク I/O」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> で NFS を使用する前に、<a class="xref" href="optimization.html#disk-issues-nfs" title="MySQL での NFS の使用">MySQL での NFS の使用</a> で概説されている潜在的な問題を確認してください。
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-startup-data-file-configuration"></a>システムテーブルスペースデータファイル構成</h4></div></div></div><p>
        <code class="literal">innodb_data_file_path</code> の起動オプションでは、<code class="literal">InnoDB</code> システムテーブルスペースデータファイルの名前、サイズおよび属性を定義します。 MySQL サーバーを初期化する前にこのオプションを構成しない場合、デフォルトの動作では、12MB を少し超える単一の自動拡張データファイルが <code class="filename">ibdata1</code> という名前で作成されます: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'innodb_data_file_path';</code></strong>
+-----------------------+------------------------+
| Variable_name         | Value                  |
+-----------------------+------------------------+
| innodb_data_file_path | ibdata1:12M:autoextend |
+-----------------------+------------------------+
</pre><p>
        完全なデータファイル指定構文には、ファイル名、ファイルサイズ、<code class="literal">autoextend</code> 属性および <code class="literal">max</code> 属性が含まれます:
      </p><pre class="programlisting"><em class="replaceable"><code>file_name</code></em>:<em class="replaceable"><code>file_size</code></em>[:autoextend[:max:<em class="replaceable"><code>max_file_size</code></em>]]
</pre><p>
        ファイルサイズは、<code class="literal">K</code>、<code class="literal">M</code> または <code class="literal">G</code> をサイズ値に追加することで、KB、MB または GB 単位で指定します。 データファイルのサイズを KB 単位で指定する場合は、1024 の倍数で指定します。 それ以外の場合、キロバイト値はもっとも近いメガバイト (MB) 境界に丸められます。 ファイルサイズの合計は、12MB 以上である必要があります。 
      </p><p>
        セミコロンで区切られたリストを使用して、複数のデータファイルを指定できます。 例: 
      </p><pre class="programlisting">[mysqld]
innodb_data_file_path=ibdata1:50M;ibdata2:50M:autoextend
</pre><p>
        <code class="literal">autoextend</code> および <code class="literal">max</code> 属性は、最後に指定されたデータファイルにのみ使用できます。
      </p><p>
        <code class="literal">autoextend</code> 属性が指定されている場合、データファイルのサイズは領域が必要になると 64MB ずつ自動的に増加します。 <code class="literal">innodb_autoextend_increment</code> 変数は増分サイズを制御します。 
      </p><p>
        自動拡張データファイルの最大サイズを指定するには、<code class="literal">autoextend</code> 属性のあとに <code class="literal">max</code> 属性を使用してください。 <code class="literal">max</code> 属性は、ディスク使用量の制約が重要な場合にのみ使用します。 次の構成では、<code class="filename">ibdata1</code> を 500MB の制限まで拡大できます: 
      </p><pre class="programlisting">[mysqld]
innodb_data_file_path=ibdata1:12M:autoextend:max:500M
</pre><p>
        二重書込みバッファページ用の十分な領域が確保されるように、<span class="emphasis"><em>first</em></span> システムのテーブルスペースデータファイルには最小ファイルサイズが適用されます。 次のテーブルに、各 <code class="literal">InnoDB</code> ページサイズの最小ファイルサイズを示します。 デフォルトの <code class="literal">InnoDB</code> ページサイズは 16384 (16KB) です。 
      </p><div class="informaltable"><table summary="The minimum system tablespace data file for each InnoDB page size."><col style="width: 30%"><col style="width: 30%"><thead><tr>
            <th>ページサイズ (innodb_page_size)</th>
            <th>最小ファイルサイズ</th>
          </tr></thead><tbody><tr>
            <td>16384 (16KB) 以下</td>
            <td>3MB</td>
          </tr><tr>
            <td>32768 (32KB)</td>
            <td>6MB</td>
          </tr><tr>
            <td>65536 (64KB)</td>
            <td>12MB</td>
          </tr></tbody></table></div><p>
        ディスクがいっぱいになった場合は、別のディスクにデータファイルを追加できます。 その手順は、<a class="xref" href="innodb-storage-engine.html#innodb-resize-system-tablespace" title="システムテーブルスペースのサイズ変更">システムテーブルスペースのサイズ変更</a>を参照してください。 
      </p><p>
        個々のファイルのサイズ制限は、オペレーティングシステムによって決まります。 大規模ファイルをサポートするオペレーティングシステムでは、ファイルサイズを 4GB を超える値に設定できます。 データファイルとして生のディスクパーティションを使用することもできます。 <a class="xref" href="innodb-storage-engine.html#innodb-raw-devices" title="システムテーブルスペースに対する RAW ディスクパーティションの使用">システムテーブルスペースに対する RAW ディスクパーティションの使用</a>を参照してください。 
      </p><p>
        <code class="literal">InnoDB</code> ではファイルシステムの最大ファイルサイズが認識されないため、最大ファイルサイズが 2G バイトのような小さい値になっているファイルシステムでは注意してください。
      </p><p>
        システムテーブルスペースファイルは、デフォルトでデータディレクトリ (<code class="literal">datadir</code>) に作成されます。 別の場所を指定するには、<code class="literal">innodb_data_home_dir</code> オプションを使用できます。 たとえば、<code class="filename">myibdata</code> という名前のディレクトリにシステムテーブルスペースデータファイルを作成するには、次の構成を使用します: 
      </p><pre class="programlisting">[mysqld]
innodb_data_home_dir = /myibdata/
innodb_data_file_path=ibdata1:50M:autoextend
</pre><p>
        <code class="literal">innodb_data_home_dir</code> の値を指定する場合は、末尾にスラッシュが必要です。 <code class="literal">InnoDB</code> ではディレクトリが作成されないため、サーバーを起動する前に、指定したディレクトリが存在することを確認してください。 また、MySQL サーバーに、ディレクトリにファイルを作成するための適切なアクセス権があることを確認してください。 
      </p><p>
        <code class="literal">InnoDB</code> は、<code class="literal">innodb_data_home_dir</code> の値をデータファイル名にテキストで連結することで、各データファイルのディレクトリパスを形成します。 <code class="literal">innodb_data_home_dir</code> が定義されていない場合、デフォルト値は <span class="quote">「<span class="quote">./</span>」</span>(データディレクトリ) です。 (MySQL サーバーは、実行を開始すると現在の作業ディレクトリをデータディレクトリに変更します。) 
      </p><p>
        または、システムテーブルスペースデータファイルの絶対パスを指定することもできます。 次の構成は、前述の構成と同等です: 
      </p><pre class="programlisting">[mysqld]
innodb_data_file_path=/myibdata/ibdata1:50M:autoextend
</pre><p>
        <code class="literal">innodb_data_file_path</code> の絶対パスを指定すると、設定は <code class="literal">innodb_data_home_dir</code> 設定と連結されません。 システムテーブルスペースファイルは、指定した絶対パスに作成されます。 サーバーを起動する前に、指定したディレクトリが存在している必要があります。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-startup-doublewrite-file-config"></a>InnoDB 二重書込みバッファファイルの構成</h4></div></div></div><p>
        MySQL 8.0.20 の時点では、二重書込みバッファ記憶域は二重書込みファイルに存在し、二重書込みページの記憶域の場所に対する柔軟性を提供します。 以前のリリースでは、二重書込みバッファ記憶域はシステムテーブルスペースに存在していました。 <code class="literal">innodb_doublewrite_dir</code> 変数は、<code class="literal">InnoDB</code> が起動時に二重書込みファイルを作成するディレクトリを定義します。 ディレクトリが指定されていない場合、二重書込みファイルが <code class="literal">innodb_data_home_dir</code> ディレクトリに作成され、指定されていない場合はデータディレクトリにデフォルト設定されます。 
      </p><p>
        二重書込みファイルを <code class="literal">innodb_data_home_dir</code> ディレクトリ以外の場所に作成するには、<code class="literal">innodb_doublewrite_dir</code> 変数を構成します。 例: 
      </p><pre class="programlisting">innodb_doublewrite_dir=<em class="replaceable"><code>/path/to/doublewrite_directory</code></em>
</pre><p>
        その他の二重書込みバッファ変数では、二重書込みファイルの数、スレッド当たりのページ数および二重書込みバッチサイズを定義できます。 二重書込みバッファ構成の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-doublewrite-buffer" title="15.6.4 二重書き込みバッファー">セクション15.6.4「二重書き込みバッファー」</a> を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-startup-log-file-configuration"></a>redo ログファイル構成</h4></div></div></div><p>
        デフォルトでは、<code class="literal">InnoDB</code> は <code class="filename">ib_logfile0</code> および <code class="filename">ib_logfile1</code> という名前のデータディレクトリに 2 つの 5MB redo ログファイルを作成します。
      </p><p>
        次のオプションを使用して、デフォルトの構成を変更できます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">innodb_log_group_home_dir</code> は、<code class="literal">InnoDB</code> ログファイル (redo ログ) へのディレクトリパスを定義します。 このオプションが構成されていない場合、<code class="literal">InnoDB</code> ログファイルは MySQL データディレクトリ (<code class="literal">datadir</code>) に作成されます。 
          </p><p>
            このオプションを使用すると、潜在的な I/O リソースの競合を回避するために、<code class="literal">InnoDB</code> ログファイルを <code class="literal">InnoDB</code> データファイルとは異なる物理記憶域の場所に配置できます。 例: 
          </p><pre class="programlisting">[mysqld]
innodb_log_group_home_dir = /dr3/iblogs
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">InnoDB</code> ではディレクトリが作成されないため、サーバーを起動する前にログディレクトリが存在することを確認してください。 必要なディレクトリを作成するには、Unix または DOS の <code class="literal">mkdir</code> コマンドを使用します。 
            </p><p>
              MySQL サーバーに、ログディレクトリにファイルを作成するための適切なアクセス権があることを確認します。 より一般的に、サーバーは、ログファイルを作成する必要があるディレクトリでアクセス権を持っている必要があります。 
            </p></div></li><li class="listitem"><p>
            <code class="literal">innodb_log_files_in_group</code> は、ロググループ内のログファイルの数を定義します。 デフォルトおよび推奨値は 2 です。 
          </p></li><li class="listitem"><p>
            <code class="literal">innodb_log_file_size</code> は、ロググループ内の各ログファイルのサイズをバイト単位で定義します。 ログファイルを結合したサイズ (<code class="literal">innodb_log_file_size</code> * <code class="literal">innodb_log_files_in_group</code>) は、512G バイトよりもわずかに小さい最大値を上回ることができません。 たとえば、255 GB のログファイルのペアは制限に近づいていますが、それを超えていません。 デフォルトのログファイルサイズは 48MB です。 一般に、ログファイルの合計サイズは、サーバーがワークロードアクティビティのピークおよびトラブルをスムーズにできる十分な大きさである必要があります。これは、書込みアクティビティを 1 時間以上処理するための十分な redo ログ領域があることを意味することがよくあります。 値を大きくするほど、バッファープール内で必要となるチェックポイントフラッシュアクティビティーの数が少なくなるため、ディスク I/O を節約できます。 追加情報については <a class="xref" href="optimization.html#optimizing-innodb-logging" title="8.5.4 InnoDB redo ロギングの最適化">セクション8.5.4「InnoDB redo ロギングの最適化」</a>を参照してください。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-startup-undo-tablespace"></a>undo テーブルスペースの構成</h4></div></div></div><p>
        デフォルトでは、undo ログは、MySQL インスタンスの初期化時に作成される 2 つの undo テーブルスペースに存在します。 undo ログの I/O パターンにより、undo テーブルスペースは <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> 記憶域の適切な候補になります。 
      </p><p>
        <code class="literal">innodb_undo_directory</code> 変数は、<code class="literal">InnoDB</code> がデフォルトの undo テーブルスペースを作成するパスを定義します。 この変数が定義されていない場合、デフォルトの undo テーブルスペースがデータディレクトリに作成されます。 <code class="literal">innodb_undo_directory</code> 変数は動的ではありません。 構成するには、サーバーを再起動する必要があります。 
      </p><p>
        追加の undo テーブルスペースの構成の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-undo-tablespaces" title="15.6.3.4 undo テーブルスペース">セクション15.6.3.4「undo テーブルスペース」</a> を参照してください。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-startup-temporary-tablespace"></a>グローバル一時テーブルスペース構成</h4></div></div></div><p>
        グローバル一時テーブルスペースには、ユーザー作成一時テーブルに対する変更のロールバックセグメントが格納されます。
      </p><p>
        デフォルトでは、<code class="literal">InnoDB</code> は、<code class="filename">ibtmp1</code> という名前の単一の自動拡張グローバル一時テーブルスペースデータファイルを <code class="literal">innodb_data_home_dir</code> ディレクトリに作成します。 初期ファイルサイズは 12MB を少し超えています。 
      </p><p>
        <code class="literal">innodb_temp_data_file_path</code> 変数は、グローバル一時テーブルスペースデータファイルのパス、ファイル名およびファイルサイズを指定します。 ファイルサイズは、サイズ値に K、M または G を追加して KB、MB または GB で指定します。 ファイルのサイズの合計は、12MB より少し大きくする必要があります。 
      </p><p>
        グローバル一時テーブルスペースデータファイルの代替の場所を指定するには、起動時に <code class="literal">innodb_temp_data_file_path</code> 変数を構成します。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-startup-session-temporary-tablespaces"></a>セッション一時テーブルスペース構成</h4></div></div></div><p>
        MySQL 8.0.15 以前では、<code class="literal">InnoDB</code> が内部一時テーブル (<code class="literal">internal_tmp_disk_storage_engine=InnoDB</code>) のディスク上の記憶域エンジンとして構成されている場合、セッション一時テーブルスペースには、オプティマイザによって作成されたユーザー作成一時テーブルおよび内部一時テーブルが格納されます。 MySQL 8.0.16 以降では、<code class="literal">InnoDB</code> ストレージエンジンは常にディスク上の内部一時テーブルに使用されます。 
      </p><p>
        <code class="literal">innodb_temp_tablespaces_dir</code> 変数は、<code class="literal">InnoDB</code> がセッション一時テーブルスペースを作成する場所を定義します。 デフォルトの場所は、データディレクトリ内の<code class="filename">#innodb_temp</code> ディレクトリです。 
      </p><p>
        セッション一時テーブルスペースに別の場所を指定するには、起動時に <code class="literal">innodb_temp_tablespaces_dir</code> 変数を構成します。 データディレクトリに対する完全修飾パスまたは相対パスが許可されます。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-startup-page-size"></a>ページサイズ構成</h4></div></div></div><p>
        <code class="literal">innodb_page_size</code> オプションでは、MySQL インスタンス内のすべての <code class="literal">InnoDB</code> テーブルスペースのページサイズを指定します。 この値は、インスタンスの作成時に設定され、その後は一定のままです。 有効な値は、64KB、32KB、16KB (デフォルト)、8KB および 4KB です。 または、ページサイズをバイト単位で指定できます (65536、32768、16384、8192、4096)。 
      </p><p>
        16KB のデフォルトページサイズは、広範囲のワークロードに適しています。特に、バルク更新を伴うテーブルスキャンおよび DML 操作を含むクエリーに適しています。 ページサイズが小さいほど、多くの小規模な書き込みを伴う OLTP ワークロードの効率性が高くなる可能性があります。その一方で、単一のページに数多くの行が含まれる場合は、競合の問題が発生する可能性もあります。 ページを小さくすると、一般に小さなブロックサイズが使用される SSD ストレージデバイスの効率性が高くなる可能性もあります。 <code class="literal">InnoDB</code> のページサイズをストレージデバイスのブロックサイズに近づけると、ディスクに再度書き込まれる未変更データの量が最小限になります。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-startup-memory-configuration"></a>メモリー構成</h4></div></div></div><p>
        MySQL は、様々なキャッシュおよびバッファにメモリーを割り当てて、データベース操作のパフォーマンスを向上させます。 <code class="literal">InnoDB</code> にメモリーを割り当てる場合は、常にオペレーティングシステムに必要なメモリー、他のアプリケーションに割り当てられたメモリー、および他の MySQL バッファとキャッシュに割り当てられたメモリーを考慮してください。 たとえば、<code class="literal">MyISAM</code> テーブルを使用する場合は、キーバッファ (<code class="literal">key_buffer_size</code>) に割り当てられるメモリー量を考慮してください。 MySQL バッファおよびキャッシュの概要は、<a class="xref" href="optimization.html#memory-use" title="8.12.3.1 MySQL のメモリーの使用方法">セクション8.12.3.1「MySQL のメモリーの使用方法」</a> を参照してください。 
      </p><p>
        <code class="literal">InnoDB</code> に固有のバッファは、次のパラメータを使用して構成されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">innodb_buffer_pool_size</code> は、バッファプールのサイズを定義します。バッファプールは、<code class="literal">InnoDB</code> テーブル、インデックスおよびその他の補助バッファのキャッシュデータを保持するメモリー領域です。 バッファプールのサイズはシステムパフォーマンスにとって重要であり、通常、<code class="literal">innodb_buffer_pool_size</code> はシステムメモリーの 50 から 75% に構成することをお薦めします。 デフォルトのバッファープールサイズは 128MB です。 その他のガイダンスは、<a class="xref" href="optimization.html#memory-use" title="8.12.3.1 MySQL のメモリーの使用方法">セクション8.12.3.1「MySQL のメモリーの使用方法」</a> を参照してください。 <code class="literal">InnoDB</code> バッファープールサイズを構成する方法については、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-resize" title="15.8.3.1 InnoDB バッファプールサイズの構成">セクション15.8.3.1「InnoDB バッファプールサイズの構成」</a> を参照してください。 バッファープールサイズは、起動時または動的に構成できます。 
          </p><p>
            メモリーが大量にあるシステムでは、バッファプールを複数のバッファプールインスタンスに分割することで同時実行性を向上させることができます。 バッファープールインスタンスの数は、<code class="literal">innodb_buffer_pool_instances</code> オプションによって制御されます。 デフォルトでは、<code class="literal">InnoDB</code> はバッファプールインスタンスを 1 つ作成します。 バッファープールインスタンスの数は起動時に構成できます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-multiple-buffer-pools" title="15.8.3.2 複数のバッファープールインスタンスの構成">セクション15.8.3.2「複数のバッファープールインスタンスの構成」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">innodb_log_buffer_size</code> は、<code class="literal">InnoDB</code> がディスク上のログファイルへの書込みに使用するバッファのサイズをバイト単位で定義します。 デフォルトのサイズは 16M バイトです。 ログバッファーを大きくすると、トランザクションがコミットする前にディスクにログを書き込まなくても、大規模なトランザクションを実行できます。 多数の行を更新、挿入または削除するトランザクションがある場合は、ログバッファのサイズを増やしてディスク I/O を節約することを検討してください。<code class="literal">innodb_log_buffer_size</code> は起動時に構成できます。 関連情報については、<a class="xref" href="optimization.html#optimizing-innodb-logging" title="8.5.4 InnoDB redo ロギングの最適化">セクション8.5.4「InnoDB redo ロギングの最適化」</a>を参照してください。 
          </p></li></ul></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          32 ビット版の GNU/Linux x86 では、高すぎるメモリー使用率を設定しないように注意してください。<code class="literal">glibc</code> では、プロセスヒープがスレッドスタック上で増加することが許可されている可能性があるため、サーバーがクラッシュします。 グローバルおよびスレッドごとのバッファおよびキャッシュ用に <span class="command"><strong>mysqld</strong></span> プロセスに割り当てられたメモリーが 2GB に近いか、それを超えるとリスクがあります。 
        </p><p>
          MySQL のグローバルおよびスレッドごとのメモリー割当てを計算する次のような式を使用して、MySQL メモリー使用量を見積もることができます。 MySQL のバージョンおよび構成でバッファおよびキャッシュを考慮するように式を変更する必要がある場合があります。 MySQL バッファおよびキャッシュの概要は、<a class="xref" href="optimization.html#memory-use" title="8.12.3.1 MySQL のメモリーの使用方法">セクション8.12.3.1「MySQL のメモリーの使用方法」</a> を参照してください。 
        </p><pre class="programlisting">innodb_buffer_pool_size
+ key_buffer_size
+ max_connections*(sort_buffer_size+read_buffer_size+binlog_cache_size)
+ max_connections*2MB
</pre><p>
          各スレッドではスタックが使用され (多くの場合は 2M バイトですが、Oracle Corporation が提供する MySQL バイナリでは 256K バイトだけです)、最悪のケースでは、<code class="literal">sort_buffer_size + read_buffer_size</code> の追加メモリーも使用されます。
        </p></div><p>
        Linux では、カーネルでラージページサポートが有効になっている場合、<code class="literal">InnoDB</code> はラージページを使用してバッファプールにメモリーを割り当てることができます。 <a class="xref" href="optimization.html#large-page-support" title="8.12.3.2 ラージページのサポートの有効化">セクション8.12.3.2「ラージページのサポートの有効化」</a>を参照してください。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-read-only-instance"></a>15.8.2 読み取り専用操作用の InnoDB の構成</h3></div></div></div><p>
      サーバーの起動時に <code class="literal">--innodb-read-only</code> 構成オプションを有効にすることで、MySQL データディレクトリが読取り専用メディアにある <code class="literal">InnoDB</code> テーブルをクエリーすることができます。
    </p><h4><a name="idm44761361078032"></a>有効にする方法</h4><p>
      読み取り操作用にインスタンスを準備するには、必要なすべての情報が読み取り専用メディア上に格納される前に、データファイルに<a class="link" href="glossary.html#glos_flush" title="フラッシュ">フラッシュ</a>されることを確認します。 変更バッファーが無効になっている (<code class="literal">innodb_change_buffering=0</code>) サーバーを実行し、<a class="link" href="glossary.html#glos_slow_shutdown" title="低速シャットダウン">低速シャットダウン</a>を実行します。 
    </p><p>
      MySQL インスタンス全体にわたって読み取り専用モードを有効にするには、サーバーの起動時に次の構成オプションを指定します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">--innodb-read-only=1</code>
        </p></li><li class="listitem"><p>
          インスタンスが DVD や CD などの読み取り専用メディア上にある場合、または <code class="filename">/var</code> ディレクトリがすべてのユーザーから書き込み可能でない場合: <code class="literal">--pid-file=<em class="replaceable"><code>path_on_writeable_media</code></em></code> および <code class="literal">--event-scheduler=disabled</code>
        </p></li><li class="listitem"><p>
          <code class="literal">--innodb-temp-data-file-path</code>。 このオプションは、<code class="literal">InnoDB</code> 一時テーブルスペースデータファイルのパス、ファイル名およびファイルサイズを指定します。 デフォルト設定は <code class="literal">ibtmp1:12M:autoextend</code> で、<code class="filename">ibtmp1</code> 一時テーブルスペースデータファイルがデータディレクトリに作成されます。 読取り専用操作のためにインスタンスを準備するには、<code class="literal">innodb_temp_data_file_path</code> をデータディレクトリ外の場所に設定します。 パスは、データディレクトリに対する相対パスである必要があります。 例: 
        </p><pre class="programlisting">--innodb-temp-data-file-path=../../../tmp/ibtmp1:12M:autoextend
</pre></li></ul></div><p>
      MySQL 8.0 の時点では、<code class="literal">innodb_read_only</code> を有効にすると、すべてのストレージエンジンのテーブルの作成および削除操作が防止されます。 これらの操作により、<code class="literal">mysql</code> システムデータベースのデータディクショナリテーブルが変更されますが、これらのテーブルは <code class="literal">InnoDB</code> ストレージエンジンを使用し、<code class="literal">innodb_read_only</code> が有効な場合は変更できません。 <code class="literal">ANALYZE TABLE</code>、<code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ENGINE=<em class="replaceable"><code>engine_name</code></em></code> など、データディクショナリテーブルを変更する操作にも同じ制限が適用されます。 
    </p><p>
      また、<code class="literal">mysql</code> システムデータベースの他のテーブルでは、MySQL 8.0 の <code class="literal">InnoDB</code> ストレージエンジンが使用されます。 これらのテーブルを読取り専用にすると、テーブルを変更する操作が制限されます。 たとえば、<code class="literal">CREATE USER</code>, <code class="literal">GRANT</code>, <code class="literal">REVOKE</code> および <code class="literal">INSTALL PLUGIN</code> 操作は読取り専用モードでは許可されません。 
    </p><h4><a name="idm44761361045632"></a>使用シナリオ</h4><p>
      この操作モードは、次のような状況に適しています。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          DVD や CD などの読み取り専用ストレージメディア上に、MySQL アプリケーションまたは MySQL データセットを配布する。
        </p></li><li class="listitem"><p>
          (一般に、データウェアハウス構成で) 同じデータディレクトリで同時にクエリーを実行する複数の MySQL インスタンス。 この方法を使用すれば、負荷の高い MySQL インスタンスで発生する可能性のある<a class="link" href="glossary.html#glos_bottleneck" title="ボトルネック">ボトルネック</a>を回避したり、さまざまなインスタンスに対してさまざまな構成オプションを使用して、特定の種類のクエリーを個別に調整したりできる場合があります。 
        </p></li><li class="listitem"><p>
          安全性またはデータの完全性の理由により読み取り専用の状態になったデータ (アーカイブされたバックアップデータなど) のクエリーを実行する。
        </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        この機能の目的は、読み取り専用の側面に基づいた生のパフォーマンスではなく、主に配布および配備する際の柔軟性です。 サーバー全体を読み取り専用にする必要なしで、読み取り専用クエリーのパフォーマンスを調整する方法については、<a class="xref" href="optimization.html#innodb-performance-ro-txn" title="8.5.3 InnoDB の読み取り専用トランザクションの最適化">セクション8.5.3「InnoDB の読み取り専用トランザクションの最適化」</a>を参照してください。 
      </p></div><h4><a name="idm44761361037120"></a>動作</h4><p>
      <code class="literal">--innodb-read-only</code> オプションを使用して、サーバーが読み取り専用モードで実行されると、特定の <code class="literal">InnoDB</code> 機能およびコンポーネントが減少したり、完全に無効になったりします。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_change_buffering" title="変更バッファリング">変更バッファー</a> (特に、変更バッファーからのマージ) は実行されません。 読み取り専用操作用にインスタンスを準備するときに、変更バッファーが空になっていることを確認するには、変更バッファーを無効にして (<code class="literal">innodb_change_buffering=0</code>)、まず<a class="link" href="glossary.html#glos_slow_shutdown" title="低速シャットダウン">低速シャットダウン</a>を実行します。 
        </p></li><li class="listitem"><p>
          起動時には<a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>フェーズがありません。 インスタンスを読み取り専用状態にする前に、<a class="link" href="glossary.html#glos_slow_shutdown" title="低速シャットダウン">低速シャットダウン</a>が実行されている必要があります。 
        </p></li><li class="listitem"><p>
          読み取り専用操作では <a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">Redo ログ</a>が使用されないため、インスタンスを読み取り専用にする前に、<code class="literal">innodb_log_file_size</code> を最小限のサイズ (1M バイト) に設定できます。
        </p></li><li class="listitem"><p>
          ほとんどのバックグラウンドスレッドはオフになります。 I/O の読取りスレッドと、読取り専用モードで許可される一時ファイルへの書込み用の I/O 書込みスレッドおよびページフラッシュコーディネータスレッドは残ります。 バッファプールのサイズ変更スレッドもアクティブなままになり、バッファプールのオンラインサイズ変更が可能になります。 
        </p></li><li class="listitem"><p>
          デッドロックに関する情報やモニターの出力などは、一時ファイルに書き込まれません。 その結果、<code class="literal">SHOW ENGINE INNODB STATUS</code> で出力が生成されなくなります。 
        </p></li><li class="listitem"><p>
          構成オプションの設定を変更すると、通常は書き込み操作の動作が変更されますが、サーバーが読み取り専用モードになっている場合は影響がありません。
        </p></li><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_isolation_level" title="分離レベル">分離レベル</a>を強制的に適用する <a class="link" href="glossary.html#glos_mvcc" title="MVCC">MVCC</a> 処理が無効になります。 更新も削除もできないため、すべてのクエリーで最新バージョンのレコードが読み取られます。 
        </p></li><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_undo_log" title="Undo ログ">Undo ログ</a>は使用されません。 <code class="literal">innodb_undo_tablespaces</code> および <code class="literal">innodb_undo_directory</code> 構成オプションの設定を無効にします。 
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-performance-buffer-pool"></a>15.8.3 InnoDB バッファープールの構成</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-buffer-pool-resize">15.8.3.1 InnoDB バッファプールサイズの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-multiple-buffer-pools">15.8.3.2 複数のバッファープールインスタンスの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-midpoint_insertion">15.8.3.3 バッファープールをスキャンに耐えられるようにする</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-read_ahead">15.8.3.4 InnoDB バッファープールのプリフェッチ (先読み) の構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-buffer-pool-flushing">15.8.3.5 バッファープールのフラッシュの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-preload-buffer-pool">15.8.3.6 バッファープールの状態の保存と復元</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-buffer-pool-in-core-file">15.8.3.7 コアファイルからのバッファープールページの除外</a></span></dt></dl></div><p>
      このセクションでは、<code class="literal">InnoDB</code> バッファプールの構成およびチューニングについて説明します。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-buffer-pool-resize"></a>15.8.3.1 InnoDB バッファプールサイズの構成</h4></div></div></div><a class="indexterm" name="idm44761361008576"></a><a class="indexterm" name="idm44761361007104"></a><a class="indexterm" name="idm44761361005728"></a><p>
        <code class="literal">InnoDB</code> バッファプールのサイズは、オフラインまたはサーバーの実行中に構成できます。 このセクションで説明する動作は、両方の方法に適用されます。 バッファープールサイズをオンラインで構成する方法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-online-resize" title="オンラインでの InnoDB バッファープールサイズの構成">オンラインでの InnoDB バッファープールサイズの構成</a> を参照してください。 
      </p><p>
        <code class="literal">innodb_buffer_pool_size</code> を増減すると、操作はチャンク単位で実行されます。 チャンクサイズは、デフォルトの <code class="literal">128M</code> を持つ <code class="literal">innodb_buffer_pool_chunk_size</code> 構成オプションによって定義されます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-chunk-size" title="InnoDB バッファプールのチャンクサイズの構成">InnoDB バッファプールのチャンクサイズの構成</a>を参照してください。 
      </p><p>
        バッファプールサイズは、常に <code class="literal">innodb_buffer_pool_chunk_size</code> * <code class="literal">innodb_buffer_pool_instances</code> と等しいか倍数である必要があります。 <code class="literal">innodb_buffer_pool_size</code> を <code class="literal">innodb_buffer_pool_chunk_size</code> * <code class="literal">innodb_buffer_pool_instances</code> と等しくない値または倍数に構成すると、バッファープールサイズは <code class="literal">innodb_buffer_pool_chunk_size</code> * <code class="literal">innodb_buffer_pool_instances</code> と等しいか倍数の値に自動的に調整されます。 
      </p><p>
        次の例では、<code class="literal">innodb_buffer_pool_size</code> が <code class="literal">8G</code> に設定され、<code class="literal">innodb_buffer_pool_instances</code> が <code class="literal">16</code> に設定されます。<code class="literal">innodb_buffer_pool_chunk_size</code> は <code class="literal">128M</code> で、これがデフォルト値です。
      </p><p>
        <code class="literal">8G</code> は <code class="literal">innodb_buffer_pool_instances=16</code> * <code class="literal">innodb_buffer_pool_chunk_size=128M</code> の倍数 (<code class="literal">2G</code>) であるため、<code class="literal">8G</code> は有効な <code class="literal">innodb_buffer_pool_size</code> 値です。
      </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqld --innodb-buffer-pool-size=8G --innodb-buffer-pool-instances=16</code></strong>
</pre><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_size/1024/1024/1024;</code></strong>
+------------------------------------------+
| @@innodb_buffer_pool_size/1024/1024/1024 |
+------------------------------------------+
|                           8.000000000000 |
+------------------------------------------+
</pre><p>
        この例では、<code class="literal">innodb_buffer_pool_size</code> は <code class="literal">9G</code> に設定され、<code class="literal">innodb_buffer_pool_instances</code> は <code class="literal">16</code> に設定されます。<code class="literal">innodb_buffer_pool_chunk_size</code> は <code class="literal">128M</code> で、これがデフォルト値です。 この場合、<code class="literal">9G</code> は <code class="literal">innodb_buffer_pool_instances=16</code> * <code class="literal">innodb_buffer_pool_chunk_size=128M</code> の倍数ではないため、<code class="literal">innodb_buffer_pool_size</code> は <code class="literal">10G</code>(<code class="literal">innodb_buffer_pool_chunk_size</code> * <code class="literal">innodb_buffer_pool_instances</code> の倍数) に調整されます。 
      </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqld --innodb-buffer-pool-size=9G --innodb-buffer-pool-instances=16</code></strong>
</pre><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_size/1024/1024/1024;</code></strong>
+------------------------------------------+
| @@innodb_buffer_pool_size/1024/1024/1024 |
+------------------------------------------+
|                          10.000000000000 |
+------------------------------------------+
</pre><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-buffer-pool-chunk-size"></a>InnoDB バッファプールのチャンクサイズの構成</h5></div></div></div><p>
          <code class="literal">innodb_buffer_pool_chunk_size</code> は 1MB (1048576 バイト) 単位で増減できますが、起動時、コマンドライン文字列または MySQL 構成ファイルでのみ変更できます。
        </p><p>
          コマンドライン:
        </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqld --innodb-buffer-pool-chunk-size=134217728</code></strong>
</pre><p>
          構成ファイル:
        </p><pre class="programlisting">[mysqld]
innodb_buffer_pool_chunk_size=134217728
</pre><p>
          <code class="literal">innodb_buffer_pool_chunk_size</code> を変更する場合は、次の条件が適用されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              バッファプールの初期化時に、新しい<code class="literal"> innodb_buffer_pool_chunk_size</code> 値 * <code class="literal">innodb_buffer_pool_instances</code> が現在のバッファプールサイズより大きい場合、<code class="literal">innodb_buffer_pool_chunk_size</code> は <code class="literal">innodb_buffer_pool_size</code> / <code class="literal">innodb_buffer_pool_instances</code> に切り捨てられます。
            </p><p>
              たとえば、バッファプールが <code class="literal">2GB</code> (2147483648 バイト)、<code class="literal">4</code> バッファプールインスタンスおよびチャンクサイズ <code class="literal">1GB</code> (1073741824 バイト) で初期化されている場合、次に示すようにチャンクサイズは <code class="literal">innodb_buffer_pool_size</code> / <code class="literal">innodb_buffer_pool_instances</code> と等しい値に切り捨てられます:
            </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqld --innodb-buffer-pool-size=2147483648 --innodb-buffer-pool-instances=4</code></strong>
<strong class="userinput"><code>--innodb-buffer-pool-chunk-size=1073741824;</code></strong>
</pre><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_size;</code></strong>
+---------------------------+
| @@innodb_buffer_pool_size |
+---------------------------+
|                2147483648 |
+---------------------------+

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_instances;</code></strong>
+--------------------------------+
| @@innodb_buffer_pool_instances |
+--------------------------------+
|                              4 |
+--------------------------------+

# Chunk size was set to 1GB (1073741824 bytes) on startup but was
# truncated to innodb_buffer_pool_size / innodb_buffer_pool_instances

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_chunk_size;</code></strong>
+---------------------------------+
| @@innodb_buffer_pool_chunk_size |
+---------------------------------+
|                       536870912 |
+---------------------------------+
</pre></li><li class="listitem"><p>
              バッファプールサイズは、常に <code class="literal">innodb_buffer_pool_chunk_size</code> * <code class="literal">innodb_buffer_pool_instances</code> と等しいか倍数である必要があります。 <code class="literal">innodb_buffer_pool_chunk_size</code> を変更すると、<code class="literal">innodb_buffer_pool_size</code> は <code class="literal">innodb_buffer_pool_chunk_size</code> * <code class="literal">innodb_buffer_pool_instances</code> と等しいか倍数の値に自動的に調整されます。 調整は、バッファープールが初期化されたときに行われます。 この動作を次の例に示します: 
            </p><pre class="programlisting"># The buffer pool has a default size of 128MB (134217728 bytes)

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_size;</code></strong>
+---------------------------+
| @@innodb_buffer_pool_size |
+---------------------------+
|                 134217728 |
+---------------------------+

# The chunk size is also 128MB (134217728 bytes)

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_chunk_size;</code></strong>
+---------------------------------+
| @@innodb_buffer_pool_chunk_size |
+---------------------------------+
|                       134217728 |
+---------------------------------+

# There is a single buffer pool instance

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_instances;</code></strong>
+--------------------------------+
| @@innodb_buffer_pool_instances |
+--------------------------------+
|                              1 |
+--------------------------------+

# Chunk size is decreased by 1MB (1048576 bytes) at startup
# (134217728 - 1048576 = 133169152):

shell&gt; <strong class="userinput"><code>mysqld --innodb-buffer-pool-chunk-size=133169152</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_chunk_size;</code></strong>
+---------------------------------+
| @@innodb_buffer_pool_chunk_size |
+---------------------------------+
|                       133169152 |
+---------------------------------+

# Buffer pool size increases from 134217728 to 266338304
# Buffer pool size is automatically adjusted to a value that is equal to
# or a multiple of innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_size;</code></strong>
+---------------------------+
| @@innodb_buffer_pool_size |
+---------------------------+
|                 266338304 |
+---------------------------+</pre><p>
              この例では、同じ動作を示しますが、複数のバッファプールインスタンスがあります:
            </p><pre class="programlisting"># The buffer pool has a default size of 2GB (2147483648 bytes)

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_size;</code></strong>
+---------------------------+
| @@innodb_buffer_pool_size |
+---------------------------+
|                2147483648 |
+---------------------------+

# The chunk size is .5 GB (536870912 bytes)

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_chunk_size;</code></strong>
+---------------------------------+
| @@innodb_buffer_pool_chunk_size |
+---------------------------------+
|                       536870912 |
+---------------------------------+

# There are 4 buffer pool instances

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_instances;</code></strong>
+--------------------------------+
| @@innodb_buffer_pool_instances |
+--------------------------------+
|                              4 |
+--------------------------------+

# Chunk size is decreased by 1MB (1048576 bytes) at startup
# (536870912 - 1048576 = 535822336):

shell&gt; <strong class="userinput"><code>mysqld --innodb-buffer-pool-chunk-size=535822336</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_chunk_size;</code></strong>
+---------------------------------+
| @@innodb_buffer_pool_chunk_size |
+---------------------------------+
|                       535822336 |
+---------------------------------+

# Buffer pool size increases from 2147483648 to 4286578688
# Buffer pool size is automatically adjusted to a value that is equal to
# or a multiple of innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances

mysql&gt; <strong class="userinput"><code>SELECT @@innodb_buffer_pool_size;</code></strong>
+---------------------------+
| @@innodb_buffer_pool_size |
+---------------------------+
|                4286578688 |
+---------------------------+
</pre><p>
              前述の例に示すように、この値を変更するとバッファプールのサイズが増加する可能性があるため、<code class="literal">innodb_buffer_pool_chunk_size</code> を変更する場合は注意が必要です。 <code class="literal">innodb_buffer_pool_chunk_size</code> を変更する前に、<code class="literal">innodb_buffer_pool_size</code> への影響を計算して、結果のバッファプールサイズが許容範囲内であることを確認します。 
            </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            潜在的なパフォーマンスの問題を回避するには、チャンク (<code class="literal">innodb_buffer_pool_size</code> / <code class="literal">innodb_buffer_pool_chunk_size</code>) の数が 1000 を超えないようにする必要があります。
          </p></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-buffer-pool-online-resize"></a>オンラインでの InnoDB バッファープールサイズの構成</h5></div></div></div><p>
          <code class="literal">innodb_buffer_pool_size</code> 構成オプションは、<code class="literal">SET</code> ステートメントを使用して動的に設定でき、サーバーを再起動せずにバッファープールのサイズを変更できます。 例: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_buffer_pool_size=402653184;</code></strong>
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            バッファープールサイズは <code class="literal">innodb_buffer_pool_chunk_size</code> * <code class="literal">innodb_buffer_pool_instances</code> と等しいか、倍数である必要があります。 これらの変数設定を変更するには、サーバーを再起動する必要があります。 
          </p></div><p>
          バッファプールのサイズを変更する前に、<code class="literal">InnoDB</code> API を介して実行されるアクティブなトランザクションおよび操作を完了する必要があります。 サイズ変更操作を開始しても、すべてのアクティブなトランザクションが完了するまで操作は開始されません。 サイズ変更操作が進行中になると、バッファプールへのアクセスを必要とする新しいトランザクションおよび操作は、サイズ変更操作が終了するまで待機する必要があります。 ルールの例外は、バッファープールがデフラグされている間はバッファープールへの同時アクセスが許可され、バッファープールサイズが小さくなるとページが取り下げられることです。 同時アクセスを許可するという欠点は、ページの取下げ中に一時的に使用可能なページが不足する可能性があることです。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            バッファプールのサイズ変更操作の開始後に開始された場合、ネストされたトランザクションは失敗する可能性があります。
          </p></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-buffer-pool-online-resize-monitoring"></a>オンラインバッファプールのサイズ変更の進行状況の監視</h5></div></div></div><a class="indexterm" name="idm44761360887456"></a><a class="indexterm" name="idm44761360885312"></a><p>
          <code class="literal">Innodb_buffer_pool_resize_status</code> では、バッファプールのサイズ変更の進行状況がレポートされます。 例: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS WHERE Variable_name='InnoDB_buffer_pool_resize_status';</code></strong>
+----------------------------------+----------------------------------+
| Variable_name                    | Value                            |
+----------------------------------+----------------------------------+
| Innodb_buffer_pool_resize_status | Resizing also other hash tables. |
+----------------------------------+----------------------------------+
</pre><p>
          バッファプールのサイズ変更の進行状況も、サーバーエラーログに記録されます。 次の例は、バッファープールのサイズを増やすとログに記録されるノートを示しています: 
        </p><pre class="programlisting">[Note] InnoDB: Resizing buffer pool from 134217728 to 4294967296. (unit=134217728)
[Note] InnoDB: disabled adaptive hash index.
[Note] InnoDB: buffer pool 0 : 31 chunks (253952 blocks) was added.
[Note] InnoDB: buffer pool 0 : hash tables were resized.
[Note] InnoDB: Resized hash tables at lock_sys, adaptive hash index, dictionary.
[Note] InnoDB: completed to resize buffer pool from 134217728 to 4294967296.
[Note] InnoDB: re-enabled adaptive hash index.
</pre><p>
          次の例は、バッファープールのサイズを小さくしたときに記録されるノートを示しています:
        </p><pre class="programlisting">[Note] InnoDB: Resizing buffer pool from 4294967296 to 134217728. (unit=134217728)
[Note] InnoDB: disabled adaptive hash index.
[Note] InnoDB: buffer pool 0 : start to withdraw the last 253952 blocks.
[Note] InnoDB: buffer pool 0 : withdrew 253952 blocks from free list. tried to relocate 0 pages.
(253952/253952)
[Note] InnoDB: buffer pool 0 : withdrawn target 253952 blocks.
[Note] InnoDB: buffer pool 0 : 31 chunks (253952 blocks) was freed.
[Note] InnoDB: buffer pool 0 : hash tables were resized.
[Note] InnoDB: Resized hash tables at lock_sys, adaptive hash index, dictionary.
[Note] InnoDB: completed to resize buffer pool from 4294967296 to 134217728.
[Note] InnoDB: re-enabled adaptive hash index.
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-buffer-pool-online-resize-internals"></a>オンラインバッファプールの内部サイズ変更</h5></div></div></div><p>
          サイズ変更操作はバックグラウンドスレッドによって実行されます。 バッファプールのサイズを増やすと、サイズ変更操作は次のようになります: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">chunks</code> にページを追加します (チャンクサイズは <code class="literal">innodb_buffer_pool_chunk_size</code> によって定義されます)
            </p></li><li class="listitem"><p>
              メモリー内の新しいアドレスを使用するためのハッシュテーブル、リスト、およびポインタをカバー
            </p></li><li class="listitem"><p>
              空きリストに新規ページを追加
            </p></li></ul></div><p>
          これらの操作の進行中、他のスレッドはバッファプールへのアクセスをブロックされます。
        </p><p>
          バッファプールのサイズを小さくすると、サイズ変更操作は次のようになります:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              バッファプールをデフラグし、ページを取り下げます (解放します)
            </p></li><li class="listitem"><p>
              <code class="literal">chunks</code> 内のページを削除します (チャンクサイズは <code class="literal">innodb_buffer_pool_chunk_size</code> によって定義されます)
            </p></li><li class="listitem"><p>
              ハッシュテーブル、リストおよびポインタをメモリー内の新しいアドレスを使用するように変換
            </p></li></ul></div><p>
          これらの操作のうち、バッファプールをデフラグしてページを取り下げるだけで、他のスレッドがバッファプールに同時にアクセスできます。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-multiple-buffer-pools"></a>15.8.3.2 複数のバッファープールインスタンスの構成</h4></div></div></div><a class="indexterm" name="idm44761360860384"></a><a class="indexterm" name="idm44761360858912"></a><a class="indexterm" name="idm44761360857568"></a><p>
        バッファープールが数 G バイトの範囲にあるシステムでは、バッファープールを個別のインスタンスに分割すると、キャッシュされたページに対して異なるスレッドが読み取りおよび書き込みを行うときの競合が減るため、並列性が向上する場合があります。 この機能は通常、<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>のサイズが数 G バイトの範囲にあるシステムを対象にしています。 複数のバッファープールインスタンスは <code class="literal">innodb_buffer_pool_instances</code> 構成オプションを使用して構成され、また <code class="literal">innodb_buffer_pool_size</code> 値を調整することもできます。 
      </p><p>
        <code class="literal">InnoDB</code> バッファプールが大きい場合、メモリーから取得することで多くのデータリクエストを満たすことができます。 複数のスレッドが一度にバッファープールにアクセスしようとした場合は、ボトルネックが発生する可能性があります。 この競合を最小限に抑えるために、複数のバッファープールを有効にすることができます。 バッファープールに格納されるか、またはバッファープールから読み取られる各ページは、ハッシュ関数を使用して、いずれかのバッファープールにランダムに割り当てられます。 各バッファプールは、バッファプールに接続されている独自の空きリスト、フラッシュリスト、LRU およびその他のすべてのデータ構造を管理します。 MySQL 8.0 より前は、各バッファープールは独自のバッファープール相互排他ロックによって保護されていました。 MySQL 8.0 以降では、競合を減らすために、バッファープール mutex が複数のリストおよびハッシュ保護 mutex に置き換えられました。 
      </p><p>
        複数のバッファープールインスタンスを有効にするには、<code class="literal">innodb_buffer_pool_instances</code> 構成オプションを 1 (デフォルト) より大きく 64 (最大) までの値に設定します。 このオプションは、<code class="literal">innodb_buffer_pool_size</code> を 1GB 以上のサイズに設定した場合にのみ有効になります。 指定した合計サイズは、すべてのバッファープール間で分割されます。 最高の効率を得るには、<code class="literal">innodb_buffer_pool_instances</code> と <code class="literal">innodb_buffer_pool_size</code> の組み合わせを、各バッファープールインスタンスが少なくとも 1G バイトになるように指定します。 
      </p><p>
        <code class="literal">InnoDB</code> バッファープールサイズの変更については、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-resize" title="15.8.3.1 InnoDB バッファプールサイズの構成">セクション15.8.3.1「InnoDB バッファプールサイズの構成」</a> を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-performance-midpoint_insertion"></a>15.8.3.3 バッファープールをスキャンに耐えられるようにする</h4></div></div></div><a class="indexterm" name="idm44761360840896"></a><a class="indexterm" name="idm44761360839424"></a><a class="indexterm" name="idm44761360838080"></a><a class="indexterm" name="idm44761360836704"></a><a class="indexterm" name="idm44761360835328"></a><a class="indexterm" name="idm44761360834352"></a><a class="indexterm" name="idm44761360833264"></a><p>
        厳密な <a class="link" href="glossary.html#glos_lru" title="LRU">LRU</a> アルゴリズムを使用するかわりに、<code class="literal">InnoDB</code> では、<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> に取り込まれ、再度アクセスされないデータ量を最小限に抑える手法を使用します。 目標は、<a class="link" href="glossary.html#glos_read_ahead" title="先読み">先読み</a>や<a class="link" href="glossary.html#glos_full_table_scan" title="テーブルの完全スキャン">フルテーブルスキャン</a>によって、その後アクセスされるかどうかわからない新しいブロックが読み取られた場合でも、頻繁にアクセスされるページ (<span class="quote">「<span class="quote">ホットページ</span>」</span>) が確実にバッファープール内に残るようにすることです。 
      </p><p>
        新しく読み取られたブロックは、LRU リストの途中に挿入されます。 新しく読み取られたページはすべて、デフォルトでは LRU リストの末尾から <code class="literal">3/8</code> にあたる場所に挿入されます。 これらのページは、はじめてバッファープール内でアクセスされたときに、リストの前面 (直近で使用された端) に移動されます。 したがって、アクセスされないページでは LRU リストの先頭部分にアクセスされず、<span class="quote">「<span class="quote">「エージアウト」</span>」</span>は厳密な LRU アプローチより早くアクセスされます。 この配置では、LRU リストが 2 つのセグメントに分割されます。つまり、挿入ポイントの下流にあるページは<span class="quote">「<span class="quote">古い</span>」</span>とみなされ、LRU のエビクションの望ましい対象になります。 
      </p><p>
        <code class="literal">InnoDB</code> バッファプールの内部動作および LRU アルゴリズムの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool" title="15.5.1 バッファプール">セクション15.5.1「バッファプール」</a> を参照してください。
      </p><p>
        LRU リストの挿入ポイントを制御し、テーブルスキャンまたはインデックススキャンによってバッファプールに入れられたブロックに <code class="literal">InnoDB</code> が同じ最適化を適用するかどうかを選択できます。 構成パラメータ <code class="literal">innodb_old_blocks_pct</code> は、LRU リスト内の<span class="quote">「<span class="quote">古い</span>」</span>ブロックの割合 (%) を制御します。 <code class="literal">innodb_old_blocks_pct</code> のデフォルト値は <code class="literal">37</code> であり、元の固定された 3/8 の比率に対応します。 この値の範囲は、<code class="literal">5</code> (バッファープール内の新しいページが非常に早く古くなります) から <code class="literal">95</code> (バッファープールの 5% しかホットページとして予約されないため、アルゴリズムがなじみのある LRU の方法に近くなります) までです。 
      </p><p>
        バッファープールを先読みによって混乱した状態にならないように維持する最適化は、テーブルまたはインデックススキャンによる同様の問題も回避できます。 これらのスキャンでは通常、データページはすばやく連続して数回アクセスされ、それ以降は二度とアクセスされません。 構成パラメータ <code class="literal">innodb_old_blocks_time</code> は、あるページにはじめてアクセスしたあと、そのページが LRU リストの前面 (直近で使用された端) に移動されることなくアクセス可能になっている時間ウィンドウ (ミリ秒単位) を指定します。 <code class="literal">innodb_old_blocks_time</code> のデフォルト値は <code class="literal">1000</code> です。 この値を大きくすると、より多くのブロックがバッファープールから早く古くなる可能性があります。 
      </p><p>
        <code class="literal">innodb_old_blocks_pct</code> と <code class="literal">innodb_old_blocks_time</code> の両方を MySQL オプションファイル (<code class="literal">my.cnf</code> または <code class="literal">my.ini</code>) で指定するか、<code class="literal">SET GLOBAL</code> ステートメントを使用して実行時に変更できます。 実行時に値を変更するには、グローバルシステム変数を設定するのに十分な権限が必要です。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 
      </p><p>
        これらのパラメータの設定の影響を測定するために、<code class="literal">SHOW ENGINE INNODB STATUS</code> コマンドはバッファプール統計をレポートします。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-monitoring" title="InnoDB 標準モニターを使用したバッファープールのモニタリング">InnoDB 標準モニターを使用したバッファープールのモニタリング</a>を参照してください。 
      </p><p>
        これらのパラメータの効果はハードウェア構成、使用しているデータ、およびワークロードの詳細によって大幅に異なる場合があるため、パフォーマンスが重要な環境や本番環境でこれらの設定を変更する前には、常にベンチマークによってその有効性を確認してください。
      </p><p>
        ほとんどのアクティビティーが、大規模なスキャンにつながる定期的なバッチレポートクエリーを含む OLTP タイプである混在ワークロード環境では、バッチの実行中に <code class="literal">innodb_old_blocks_time</code> の値を設定すると、通常のワークロードのワーキングセットをバッファープール内に維持するのに役立つ場合があります。
      </p><p>
        バッファープール内に完全には収まらない大きなテーブルをスキャンする場合は、<code class="literal">innodb_old_blocks_pct</code> を小さな値に設定すると、1 回しか読み取られないデータがバッファープールの大きな部分を消費することはなくなります。 たとえば、<code class="literal">innodb_old_blocks_pct=5</code> を設定すると、1 回しか読み取られないこのデータがバッファープールの 5% に制限されます。 
      </p><p>
        メモリーに収まる小さなテーブルをスキャンする場合は、バッファープール内でページを移動するためのオーバーヘッドが低いため、<code class="literal">innodb_old_blocks_pct</code> をデフォルト値のままにするか、あるいは場合によっては (<code class="literal">innodb_old_blocks_pct=50</code> などと) 増やすこともできます。
      </p><p>
        <code class="literal">innodb_old_blocks_time</code> パラメータの効果は、比較的効果の小さい <code class="literal">innodb_old_blocks_pct</code> パラメータに比べて予測が困難であり、ワークロードによる変動も大きくなります。 最適な値に到達するには、<code class="literal">innodb_old_blocks_pct</code> の調整によるパフォーマンス向上が不十分な場合は独自のベンチマークを実施してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-performance-read_ahead"></a>15.8.3.4 InnoDB バッファープールのプリフェッチ (先読み) の構成</h4></div></div></div><a class="indexterm" name="idm44761360786512"></a><a class="indexterm" name="idm44761360785040"></a><a class="indexterm" name="idm44761360783696"></a><a class="indexterm" name="idm44761360782688"></a><a class="indexterm" name="idm44761360780544"></a><p>
        <a class="link" href="glossary.html#glos_read_ahead" title="先読み">read-ahead</a> リクエストは、<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> の複数のページを非同期にプリフェッチするための I/O リクエストであり、これらのページの必要性が低下することが予想されます。 これらの要求によって、すべてのページが 1 つの<a class="link" href="glossary.html#glos_extent" title="エクステント">エクステント</a>内に移動されます。 <code class="literal">InnoDB</code> では、I/O のパフォーマンスを向上させるために、次の 2 つの先読みアルゴリズムを使用します: 
      </p><p>
        <span class="strong"><strong>線形</strong></span>先読みは、順次にアクセスされているバッファープール内のページに基づいて、どのページがすぐに必要になる可能性があるかを予測する手法です。 <code class="literal">InnoDB</code> が先読み操作を実行するタイミングを制御するには、構成パラメータ <code class="literal">innodb_read_ahead_threshold</code> を使用して、非同期読取りリクエストのトリガーに必要な順次ページアクセスの数を調整します。 このパラメータが追加される前に、<code class="literal">InnoDB</code> は、現行エクステントの最後のページを読み取ったときに、次のエクステント全体に対して非同期プリフェッチリクエストを発行するかどうかのみを計算します。 
      </p><p>
        構成パラメータ <code class="literal">innodb_read_ahead_threshold</code> は、<code class="literal">InnoDB</code> が順次ページアクセスのパターンを検出する方法を制御します。 エクステントから順次読み取られるページ数が <code class="literal">innodb_read_ahead_threshold</code> 以上の場合、<code class="literal">InnoDB</code> は次のエクステント全体の非同期先読み操作を開始します。<code class="literal">innodb_read_ahead_threshold</code> は、0-64 の任意の値に設定できます。 デフォルト値は 56 です。 この値が大きいほど、アクセスパターンのチェックは厳密になります。 たとえば、値を 48 に設定すると、現在のエクステント内の 48 ページが順次アクセスされた場合にのみ、<code class="literal">InnoDB</code> によって線形先読みリクエストがトリガーされます。 値が 8 の場合、エクステント内の 8 ページが順次アクセスされていても、<code class="literal">InnoDB</code> は非同期先読みをトリガーします。 このパラメータの値は、MySQL <a class="link" href="glossary.html#glos_configuration_file" title="構成ファイル">configuration file</a> で設定することも、グローバルシステム変数を設定するのに十分な権限を必要とする <code class="literal">SET GLOBAL</code> ステートメントを使用して動的に変更することもできます。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 
      </p><p>
        <span class="strong"><strong>ランダム</strong></span>先読みは、すでにバッファープール内に存在するページに基づいて、これらのページが読み取られた順序には関係なく、ページがいつ必要になる可能性があるかを予測する手法です。 同じエクステントから 13 個の連続ページがバッファプールに見つかった場合、<code class="literal">InnoDB</code> はエクステントの残りのページをプリフェッチするリクエストを非同期的に発行します。 この機能を有効にするには、構成変数 <code class="literal">innodb_random_read_ahead</code> を <code class="literal">ON</code> に設定します。 
      </p><p>
        <code class="literal">SHOW ENGINE INNODB STATUS</code> コマンドは、先読みアルゴリズムの有効性を評価するのに役立つ統計を表示します。 統計には、次のグローバルステータス変数のカウンタ情報が含まれます: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Innodb_buffer_pool_read_ahead</code>
          </p></li><li class="listitem"><p>
            <code class="literal">Innodb_buffer_pool_read_ahead_evicted</code>
          </p></li><li class="listitem"><p>
            <code class="literal">Innodb_buffer_pool_read_ahead_rnd</code>
          </p></li></ul></div><p>
        これらの情報は、<code class="literal">innodb_random_read_ahead</code> 設定を微調整する場合に役立つことがあります。
      </p><p>
        I/O パフォーマンスの詳細は、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8 InnoDB ディスク I/O の最適化">セクション8.5.8「InnoDB ディスク I/O の最適化」</a>および<a class="xref" href="optimization.html#disk-issues" title="8.12.1 ディスク I/O の最適化">セクション8.12.1「ディスク I/O の最適化」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-buffer-pool-flushing"></a>15.8.3.5 バッファープールのフラッシュの構成</h4></div></div></div><a class="indexterm" name="idm44761360741888"></a><a class="indexterm" name="idm44761360740464"></a><p>
        <code class="literal">InnoDB</code> は、バッファプールからのダーティページのフラッシュなど、特定のタスクをバックグラウンドで実行します。 ダーティページは、変更されたが、まだディスク上のデータファイルに書き込まれていないページです。 
      </p><p>
        MySQL 8.0 では、バッファプールのフラッシュはページクリーナスレッドによって実行されます。 ページクリーナスレッドの数は、<code class="literal">innodb_page_cleaners</code> 変数 (デフォルト値は 4) によって制御されます。 ただし、ページクリーナスレッドの数がバッファプールインスタンスの数を超えると、<code class="literal">innodb_page_cleaners</code> は自動的に <code class="literal">innodb_buffer_pool_instances</code> と同じ値に設定されます。 
      </p><p>
        ダーティページの割合が <code class="literal">innodb_max_dirty_pages_pct_lwm</code> 変数で定義された最低水位標値に達すると、バッファプールのフラッシュが開始されます。 デフォルトの最低水位標はバッファープールページの 10% です。 <code class="literal">innodb_max_dirty_pages_pct_lwm</code> 値が 0 の場合、この早期フラッシュ動作は無効になります。 
      </p><p>
        <code class="literal">innodb_max_dirty_pages_pct_lwm</code> のしきい値の目的は、バッファプール内のダーティページの割合を制御し、ダーティページの量が <code class="literal">innodb_max_dirty_pages_pct</code> 変数で定義されたしきい値 (デフォルト値 90) に到達しないようにすることです。 バッファプール内のダーティページの割合が <code class="literal">innodb_max_dirty_pages_pct</code> しきい値に達した場合、<code class="literal">InnoDB</code> はバッファプールページを積極的にフラッシュします。 
      </p><p>
        追加の変数により、バッファープールのフラッシュ動作を微調整できます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">innodb_flush_neighbors</code> 変数は、バッファープールからページをフラッシュすると、同じエクステント内のほかのダーティーページもフラッシュするかどうかを定義します。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                デフォルト設定の 0 は、<code class="literal">innodb_flush_neighbors</code> を無効にします。 同じエクステント内のダーティページはフラッシュされません。 シーク時間が重要な要因ではない非定期ストレージ (SSD) デバイスには、この設定をお勧めします。 
              </p></li><li class="listitem"><p>
                1 に設定すると、連続したダーティページが同じエクステントにフラッシュされます。
              </p></li><li class="listitem"><p>
                2 に設定すると、ダーティページが同じエクステントでフラッシュされます。
              </p></li></ul></div><p>
            テーブルデータが従来の <a class="link" href="glossary.html#glos_hdd" title="HDD">HDD</a> ストレージデバイスに格納されている場合、隣接するページをある操作でフラッシュすると、個々のページを異なるタイミングでフラッシュする場合と比較して、I/O のオーバーヘッド (主にディスクシーク操作用) が削減されます。 <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> に格納されているテーブルデータの場合、シーク時間は重要な要因ではなく、この設定を無効にして書込み操作を分散できます。 
          </p></li><li class="listitem"><p>
            <code class="literal">innodb_lru_scan_depth</code> 変数は、バッファプールインスタンスごとに、フラッシュするダーティページを検索するページクリーナスレッドスキャンをバッファプール LRU リストのどれだけ下に表示するかを指定します。 これは、ページクリーナスレッドによって毎秒 1 回実行されるバックグラウンド操作です。 
          </p><p>
            デフォルトより小さい設定は、通常、ほとんどのワークロードに適しています。 必要以上の値を指定すると、パフォーマンスに影響する可能性があります。 通常のワークロードでスペア I/O 容量がある場合のみ、値を増やすことを検討してください。 逆に、書込み集中型のワークロードが I/O の容量を満たしている場合は、特に大きなバッファプールの場合に値を減らします。 
          </p><p>
            <code class="literal">innodb_lru_scan_depth</code> をチューニングする場合は、小さい値から始めて、ゼロの空きページが表示されることがほとんどないという目標で設定を上方に構成します。 また、<code class="literal">innodb_lru_scan_depth</code> * <code class="literal">innodb_buffer_pool_instances</code> は毎秒ページクリーナスレッドによって実行される作業量を定義するため、バッファプールインスタンスの数を変更するときに <code class="literal">innodb_lru_scan_depth</code> を調整することを検討してください。 
          </p></li></ul></div><p>
        <code class="literal">innodb_flush_neighbors</code> および <code class="literal">innodb_lru_scan_depth</code> 変数は、主に書込み集中型のワークロードを対象としています。 DML アクティビティが重い場合、フラッシュが十分に積極的でないとフラッシュが遅れる可能性があります。または、フラッシュが過度に積極的であると、ディスク書込みが I/O の容量を満たす可能性があります。 理想的な設定は、ワークロード、データのアクセスパターン、およびストレージ構成 (たとえば、データが HDD または SSD デバイスのどちらに格納されているか) によって異なります。 
      </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-adaptive-flushing"></a>適応型フラッシュ</h5></div></div></div><p>
          <code class="literal">InnoDB</code> では、適応型フラッシュアルゴリズムを使用して、redo ログ生成の速度および現在のフラッシュ率に基づいてフラッシュ率を動的に調整します。 この目的は、フラッシュアクティビティが現在のワークロードに対応できるようにすることで、全体的なパフォーマンスをスムーズ化することです。 フラッシュレートを自動的に調整すると、バッファープールのフラッシュによる I/O アクティビティーのバーストが通常の読み取りおよび書き込みアクティビティーで使用可能な I/O 容量に影響する場合に発生する可能性があるスループットの急激なディップを回避するのに役立ちます。 
        </p><p>
          多くの redo エントリを生成する書込み集中型のワークロードに通常関連付けられているシャープなチェックポイントは、スループットの急激な変更を引き起こす可能性があります。 シャープなチェックポイントは、<code class="literal">InnoDB</code> がログファイルの一部を再利用する場合に発生します。 これを行う前に、ログファイルのその部分に redo エントリがあるすべてのダーティページをフラッシュする必要があります。 ログファイルがいっぱいになると、シャープなチェックポイントが発生し、スループットが一時的に低下します。 このシナリオは、<code class="literal">innodb_max_dirty_pages_pct</code> のしきい値に達していない場合でも発生する可能性があります。 
        </p><p>
          適応型フラッシュアルゴリズムは、バッファプール内のダーティページの数と redo ログレコードが生成される割合を追跡することで、このようなシナリオを回避するのに役立ちます。 この情報に基づいて、バッファプールから毎秒フラッシュするダーティページの数が決定され、ワークロードの突然の変更を管理できます。 
        </p><p>
          <code class="literal">innodb_adaptive_flushing_lwm</code> 変数は、redo ログ容量の最低水位標を定義します。 このしきい値を超えると、<code class="literal">innodb_adaptive_flushing</code> 変数が無効になっていても適応型フラッシュが有効になります。 
        </p><p>
          内部ベンチマークは、アルゴリズムが一定期間スループットを維持するだけでなく、全体的なスループットを大幅に向上させることもできることを示しています。 ただし、適応型フラッシュはワークロードの I/O パターンに大きく影響を与える可能性があり、すべての場合に適切であるとはかぎりません。 これがもっとも大きな利点をもたらすのは、Redo ログがいっぱいになるおそれがある場合です。 適応型フラッシュがワークロードの特性に適していない場合は、無効にできます。 適応型フラッシュは、デフォルトで有効になっている <code class="literal">innodb_adaptive_flushing</code> 変数によって制御されます。 
        </p><p>
          <code class="literal">innodb_flushing_avg_loops</code> は、<code class="literal">InnoDB</code> が以前に計算したフラッシュ状態のスナップショットを保持する反復回数を定義し、適応型フラッシュがフォアグラウンドのワークロード変更にどの程度迅速に応答するかを制御します。 <code class="literal">innodb_flushing_avg_loops</code> 値が高いほど、<code class="literal">InnoDB</code> は以前に計算されたスナップショットを長く保持するため、適応型フラッシュの応答が遅くなります。 高い値を設定する場合は、redo ログ使用率が 75% (非同期フラッシュが開始されるハードコードされた制限) に達しないようにし、<code class="literal">innodb_max_dirty_pages_pct</code> のしきい値によってダーティページの数がワークロードに適したレベルに維持されるようにすることが重要です。 
        </p><p>
          一貫性のあるワークロードを持つシステム、大きなログファイルサイズ (<code class="literal">innodb_log_file_size</code>) および 75% のログ領域使用率に達しない小さなスパイクでは、フラッシュをできるだけスムーズに保つために高い <code class="literal">innodb_flushing_avg_loops</code> 値を使用する必要があります。 負荷が非常に高いスパイクまたはログファイルが領域を多く提供しないシステムでは、フラッシュを小さくするとワークロードの変更を密接に追跡でき、75% のログ領域使用率への到達を回避できます。 
        </p><p>
          フラッシュが遅れた場合、バッファープールのフラッシュ率は、<code class="literal">innodb_io_capacity</code> 設定で定義されているように、<code class="literal">InnoDB</code> で使用可能な I/O 容量を超えることがあります。 このような状況では、I/O アクティビティのスパイクがサーバーの I/O 容量全体を消費しないように、<code class="literal">innodb_io_capacity_max</code> 値によって I/O 容量の上限が定義されます。 
        </p><p>
          <code class="literal">innodb_io_capacity</code> 設定は、すべてのバッファープールインスタンスに適用できます。 ダーティーページがフラッシュされると、I/O 容量はバッファープールインスタンス間で均等に分割されます。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-limit-flushing-rate"></a>アイドル期間中のバッファフラッシュの制限</h5></div></div></div><p>
          MySQL 8.0.18 の時点では、<code class="literal">innodb_idle_flush_pct</code> 変数を使用して、アイドル期間 (データベースページが変更されない期間) 中のバッファプールのフラッシュ率を制限できます。 <code class="literal">innodb_idle_flush_pct</code> 値は、<code class="literal">InnoDB</code> で使用可能な I/O 操作数/秒を定義する <code class="literal">innodb_io_capacity</code> 設定の割合です。 デフォルトの <code class="literal">innodb_idle_flush_pct</code> 値は 100 で、これは <code class="literal">innodb_io_capacity</code> 設定の 100% です。 アイドル期間中のフラッシュを制限するには、100 未満の <code class="literal">innodb_idle_flush_pct</code> 値を定義します。 
        </p><p>
          アイドル期間中のページフラッシュの制限は、ソリッドステートストレージデバイスの寿命を延長するのに役立ちます。 アイドル期間中のページフラッシュの制限の副作用には、長時間のアイドル期間後の停止時間が長くなり、サーバー障害が発生した場合のリカバリ期間が長くなることがあります。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-preload-buffer-pool"></a>15.8.3.6 バッファープールの状態の保存と復元</h4></div></div></div><a class="indexterm" name="idm44761360660464"></a><a class="indexterm" name="idm44761360658992"></a><p>
        サーバーの再起動後の <a class="link" href="glossary.html#glos_warm_up" title="ウォームアップ">warmup</a> 期間を短縮するために、<code class="literal">InnoDB</code> では、サーバーの停止時にバッファプールごとに最近使用されたページの割合が保存され、サーバーの起動時にこれらのページがリストアされます。 最近使用されたページのうち、格納されたページの割合は、<code class="literal">innodb_buffer_pool_dump_pct</code> 構成オプションによって定義されます。 
      </p><p>
        ビジー状態のサーバーを再起動した後、バッファプール内にあったディスクページがメモリーに戻されるため (同じデータがクエリー、更新などされるため)、通常はスループットが急激に向上するウォームアップ期間があります。 起動時にバッファプールをリストアする機能により、DML 操作が対応する行にアクセスするのを待機するのではなく、再起動前にバッファプールにあったディスクページをリロードすることでウォームアップ期間が短縮されます。 また、I/O リクエストは大規模なバッチで実行できるため、I/O 全体が高速になります。 ページのロードはバックグラウンドで行われ、データベースの起動は遅延しません。 
      </p><p>
        停止時にバッファプールの状態を保存して起動時にリストアする以外に、サーバーの実行中にいつでもバッファプールの状態を保存およびリストアできます。 たとえば、安定したスループットに達した後、安定したワークロードでバッファプールの状態を保存できます。 また、レポートまたはメンテナンスジョブを実行した後、これらの操作のみに必要なデータページをバッファプールに移動した後、またはその他の非標準ワークロードを実行した後に、以前のバッファプールの状態をリストアすることもできます。 
      </p><p>
        バッファプールのサイズは GB ですが、<code class="literal">InnoDB</code> がディスクに保存するバッファプールデータは比較によって小さいです。 該当するページを見つけるために必要なテーブルスペース ID とページ ID だけがディスクに保存されます。 この情報は、<code class="literal">INNODB_BUFFER_PAGE_LRU</code> <code class="literal">INFORMATION_SCHEMA</code> テーブルから取得されます。 デフォルトでは、テーブルスペース ID とページ ID のデータは、<code class="literal">InnoDB</code> データディレクトリに保存される <code class="filename">ib_buffer_pool</code> という名前のファイル内に保存されます。 ファイル名と場所は、<code class="literal">innodb_buffer_pool_filename</code> 構成パラメータを使用して変更できます。 
      </p><p>
        データは通常のデータベース操作と同様にキャッシュされ、バッファプールからエージアウトされるため、ディスクページが最近更新された場合や、ロードされていないデータが DML 操作に含まれている場合は、問題はありません。 ロードメカニズムは、すでに存在しないリクエストされたページをスキップします。 
      </p><p>
        ベースとなるメカニズムには、ダンプおよびロード操作を実行するためにディスパッチされるバックグラウンドスレッドが含まれています。
      </p><p>
        圧縮テーブルからのディスクページは、その圧縮された形式でバッファープールにロードされます。 DML 操作中にページコンテンツにアクセスすると、ページは通常どおりに圧縮解除されます。 ページの圧縮解除は CPU を大量に消費するプロセスであるため、バッファプールのリストア操作を実行する単一のスレッドではなく、接続スレッドで操作を実行すると同時実行性が向上します。 
      </p><p>
        バッファープールの状態の保存と復元に関連する操作については、次のトピックで説明します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool-dump-pct" title="バッファープールページのダンプ率の構成">バッファープールページのダンプ率の構成</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool-offline" title="シャットダウン時のバッファープールの状態の保存と起動時の復元">シャットダウン時のバッファープールの状態の保存と起動時の復元</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool-online" title="バッファープールの状態をオンラインで保存および復元">バッファープールの状態をオンラインで保存および復元</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool-dump-progress" title="バッファープールのダンプの進行状況の表示">バッファープールのダンプの進行状況の表示</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool-load-progress" title="バッファープールのロードの進行状況の表示">バッファープールのロードの進行状況の表示</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool-abort-load" title="バッファープールのロード操作の中止">バッファープールのロード操作の中止</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#monitor-buffer-pool-load-performance-schema" title="パフォーマンススキーマを使用したバッファプールのロード進行状況の監視">パフォーマンススキーマを使用したバッファプールのロード進行状況の監視</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-preload-buffer-pool-dump-pct"></a>バッファープールページのダンプ率の構成</h5></div></div></div><p>
          バッファープールからページをダンプする前に、<code class="literal">innodb_buffer_pool_dump_pct</code> オプションを設定することによって、ダンプする最後に使用されたバッファープールページの割合を構成できます。 サーバーの実行中にバッファープールページをダンプする場合は、このオプションを動的に構成できます: 
        </p><pre class="programlisting">SET GLOBAL innodb_buffer_pool_dump_pct=40;
</pre><p>
          サーバーの停止時にバッファープールページをダンプする場合は、構成ファイルで <code class="literal">innodb_buffer_pool_dump_pct</code> を設定します。
        </p><pre class="programlisting">[mysqld]
innodb_buffer_pool_dump_pct=40
</pre><p>
          <code class="literal">innodb_buffer_pool_dump_pct</code> のデフォルト値は 25 です (最近使用されたページの 25% をダンプします)。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-preload-buffer-pool-offline"></a>シャットダウン時のバッファープールの状態の保存と起動時の復元</h5></div></div></div><p>
          サーバーの停止時にバッファプールの状態を保存するには、サーバーを停止する前に次のステートメントを発行します:
        </p><pre class="programlisting">SET GLOBAL innodb_buffer_pool_dump_at_shutdown=ON;
</pre><p>
          <code class="literal">innodb_buffer_pool_dump_at_shutdown</code> はデフォルトで有効になっています。
        </p><p>
          サーバーの起動時にバッファープールの状態を復元するには、サーバーの起動時に <code class="literal">--innodb-buffer-pool-load-at-startup</code> オプションを指定します:
        </p><pre class="programlisting">mysqld --innodb-buffer-pool-load-at-startup=ON;
</pre><p>
          <code class="literal">innodb_buffer_pool_load_at_startup</code> はデフォルトで有効になっています。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-preload-buffer-pool-online"></a>バッファープールの状態をオンラインで保存および復元</h5></div></div></div><p>
          MySQL サーバーの実行中にバッファープールの状態を保存するには、次のステートメントを発行します:
        </p><pre class="programlisting">SET GLOBAL innodb_buffer_pool_dump_now=ON;
</pre><p>
          MySQL の実行中にバッファープールの状態を復元するには、次のステートメントを発行します:
        </p><pre class="programlisting">SET GLOBAL innodb_buffer_pool_load_now=ON;
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-preload-buffer-pool-dump-progress"></a>バッファープールのダンプの進行状況の表示</h5></div></div></div><p>
          バッファープールの状態をディスクに保存するときの進行状況を表示するには、次のステートメントを発行します:
        </p><pre class="programlisting">SHOW STATUS LIKE 'Innodb_buffer_pool_dump_status';
</pre><p>
          操作がまだ開始されていない場合は、<span class="quote">「<span class="quote">not started</span>」</span> が返されます。 操作が完了している場合は、完了時間が出力されます (たとえば、Finished at 110505 12:18:02)。 操作が進行中である場合は、ステータス情報が表示されます (たとえば、Dumping buffer pool 5/7, page 237/2873)。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-preload-buffer-pool-load-progress"></a>バッファープールのロードの進行状況の表示</h5></div></div></div><p>
          バッファープールのロード時に進行状況を表示するには、次のステートメントを発行します:
        </p><pre class="programlisting">SHOW STATUS LIKE 'Innodb_buffer_pool_load_status';
</pre><p>
          操作がまだ開始されていない場合は、<span class="quote">「<span class="quote">not started</span>」</span> が返されます。 操作が完了している場合は、完了時間が出力されます (たとえば、Finished at 110505 12:23:24)。 操作が進行中である場合は、ステータス情報が表示されます (たとえば、Loaded 123/22301 pages)。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-preload-buffer-pool-abort-load"></a>バッファープールのロード操作の中止</h5></div></div></div><p>
          バッファープールのロード操作を中止するには、次のステートメントを発行します:
        </p><pre class="programlisting">SET GLOBAL innodb_buffer_pool_load_abort=ON;
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="monitor-buffer-pool-load-performance-schema"></a>パフォーマンススキーマを使用したバッファプールのロード進行状況の監視</h5></div></div></div><a class="indexterm" name="idm44761360596768"></a><a class="indexterm" name="idm44761360594624"></a><p>
          <a class="link" href="performance-schema.html" title="第 27 章 MySQL パフォーマンススキーマ">Performance Schema</a> を使用して、バッファープールのロードの進行状況をモニターできます。
        </p><p>
          次の例は、<code class="literal">stage/innodb/buffer pool load</code> ステージイベントインストゥルメントおよび関連するコンシューマテーブルを有効にして、バッファプールのロード進行状況を監視する方法を示しています。
        </p><p>
          この例で使用されるバッファープールのダンプおよびロード手順については、<a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="15.8.3.6 バッファープールの状態の保存と復元">セクション15.8.3.6「バッファープールの状態の保存と復元」</a> を参照してください。 パフォーマンススキーマステージイベントインストゥルメントおよび関連コンシューマについては、<a class="xref" href="performance-schema.html#performance-schema-stage-tables" title="27.12.5 パフォーマンススキーマステージイベントテーブル">セクション27.12.5「パフォーマンススキーマステージイベントテーブル」</a> を参照してください。 
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              <code class="literal">stage/innodb/buffer pool load</code> インストゥルメントを有効にします:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE performance_schema.setup_instruments SET ENABLED = 'YES' </code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE 'stage/innodb/buffer%';</code></strong>
</pre></li><li class="listitem"><p>
              ステージイベントコンシューマテーブル (<code class="literal">events_stages_current</code>、<code class="literal">events_stages_history</code> および <code class="literal">events_stages_history_long</code> を含む) を有効にします。
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE performance_schema.setup_consumers SET ENABLED = 'YES' </code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE '%stages%';</code></strong>
</pre></li><li class="listitem"><p>
              <code class="literal">innodb_buffer_pool_dump_now</code> を有効にして、現在のバッファープールの状態をダンプします。
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_buffer_pool_dump_now=ON;</code></strong>
</pre></li><li class="listitem"><p>
              バッファープールダンプステータスをチェックして、操作が完了したことを確認します。
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'Innodb_buffer_pool_dump_status'\G</code></strong>
*************************** 1. row ***************************
Variable_name: Innodb_buffer_pool_dump_status
        Value: Buffer pool(s) dump completed at 150202 16:38:58
</pre></li><li class="listitem"><p>
              <code class="literal">innodb_buffer_pool_load_now</code> を有効にしてバッファプールをロードします:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_buffer_pool_load_now=ON;</code></strong>
</pre></li><li class="listitem"><p>
              パフォーマンススキーマ <code class="literal">events_stages_current</code> テーブルをクエリーして、バッファープールのロード操作の現在のステータスを確認します。 <code class="literal">WORK_COMPLETED</code> カラムには、ロードされたバッファプールページの数が表示されます。 <code class="literal">WORK_ESTIMATED</code> カラムには、残りの作業の推定がページ単位で表示されます。 
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT EVENT_NAME, WORK_COMPLETED, WORK_ESTIMATED</code></strong>
       <strong class="userinput"><code>FROM performance_schema.events_stages_current;</code></strong>
+-------------------------------+----------------+----------------+
| EVENT_NAME                    | WORK_COMPLETED | WORK_ESTIMATED |
+-------------------------------+----------------+----------------+
| stage/innodb/buffer pool load |           5353 |           7167 |
+-------------------------------+----------------+----------------+
</pre><p>
              バッファプールのロード操作が完了すると、<code class="literal">events_stages_current</code> テーブルは空のセットを返します。 この場合、<code class="literal">events_stages_history</code> テーブルをチェックして、完了したイベントのデータを表示できます。 例: 
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT EVENT_NAME, WORK_COMPLETED, WORK_ESTIMATED </code></strong>
       <strong class="userinput"><code>FROM performance_schema.events_stages_history;</code></strong>
+-------------------------------+----------------+----------------+
| EVENT_NAME                    | WORK_COMPLETED | WORK_ESTIMATED |
+-------------------------------+----------------+----------------+
| stage/innodb/buffer pool load |           7167 |           7167 |
+-------------------------------+----------------+----------------+
</pre></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">innodb_buffer_pool_load_at_startup</code> を使用して起動時にバッファープールをロードするときに、パフォーマンススキーマを使用してバッファープールのロードの進行状況をモニターすることもできます。 この場合、起動時に <code class="literal">stage/innodb/buffer pool load</code> インストゥルメントおよび関連コンシューマを有効にする必要があります。 詳細については、<a class="xref" href="performance-schema.html#performance-schema-startup-configuration" title="27.3 パフォーマンススキーマ起動構成">セクション27.3「パフォーマンススキーマ起動構成」</a>を参照してください。 
          </p></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-buffer-pool-in-core-file"></a>15.8.3.7 コアファイルからのバッファープールページの除外</h4></div></div></div><a class="indexterm" name="idm44761360548960"></a><a class="indexterm" name="idm44761360546816"></a><a class="indexterm" name="idm44761360545472"></a><a class="indexterm" name="idm44761360544064"></a><p>
        コアファイルには、実行中のプロセスのステータスとメモリーイメージが記録されます。 バッファープールはメインメモリー内に存在し、実行中のプロセスのメモリーイメージがコアファイルにダンプされるため、<span class="command"><strong>mysqld</strong></span> プロセスが終了すると、バッファープールが大きいシステムで大きなコアファイルが生成される可能性があります。 
      </p><p>
        大規模なコアファイルは、書込みにかかる時間、それらが消費するディスク領域の量、大規模なファイルの転送に関連する課題など、様々な理由で問題になる可能性があります。
      </p><p>
        コアファイルサイズを減らすには、<code class="literal">innodb_buffer_pool_in_core_file</code> 変数を無効にして、コアダンプからバッファプールページを省略します。 <code class="literal">innodb_buffer_pool_in_core_file</code> 変数は MySQL 8.0.14 で導入され、デフォルトで有効になっています。 
      </p><p>
        デバッグ目的で組織内外で共有される可能性のあるコアファイルにデータベースページをダンプすることに懸念がある場合は、セキュリティの観点からバッファプールページを除外することも望ましい場合があります。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          一部のデバッグシナリオでは、<span class="command"><strong>mysqld</strong></span> プロセスの停止時にバッファプールページに存在するデータへのアクセスが有益な場合があります。 バッファープールページを含めるか除外するかが疑わしい場合は、MySQL サポートに問い合わせてください。 
        </p></div><p>
        <code class="literal">innodb_buffer_pool_in_core_file</code> の無効化は、<code class="literal">core_file</code> 変数が有効で、オペレーティングシステムが <a class="ulink" href="http://man7.org/linux/man-pages/man2/madvise.2.html" target="_top">madvise()</a> システムコールに対する <code class="literal">MADV_DONTDUMP</code> の POSIX 以外の拡張機能をサポートしている場合にのみ有効になります。これは Linux 3.4 以降でサポートされています。 <code class="literal">MADV_DONTDUMP</code> 拡張機能を使用すると、指定した範囲のページがコアダンプから除外されます。 
      </p><p>
        オペレーティングシステムで <code class="literal">MADV_DONTDUMP</code> 拡張機能がサポートされている場合は、<code class="option">--core-file</code> および <code class="literal">--innodb-buffer-pool-in-core-file=OFF</code> オプションを使用してサーバーを起動し、バッファプールページなしでコアファイルを生成します。
      </p><pre class="programlisting">shell&gt; mysqld --core-file --innodb-buffer-pool-in-core-file=OFF</pre><p>
        <code class="literal">core_file</code> 変数は読取り専用で、デフォルトで無効になっています。 これを有効にするには、起動時に <code class="option">--core-file</code> オプションを指定します。 <code class="literal">innodb_buffer_pool_in_core_file</code> 変数は動的です。 起動時に指定するか、<code class="literal">SET</code> ステートメントを使用して実行時に構成できます。 
      </p><pre class="programlisting">mysql&gt; SET GLOBAL innodb_buffer_pool_in_core_file=OFF;</pre><p>
        <code class="literal">innodb_buffer_pool_in_core_file</code> 変数が無効になっているが、<code class="literal">MADV_DONTDUMP</code> がオペレーティングシステムでサポートされていない場合、または <code class="literal">madvise()</code> 障害が発生した場合は、MySQL サーバーのエラーログに警告が書き込まれ、<code class="literal">core_file</code> 変数は、意図せずバッファープールページを含むコアファイルが書き込まれないように無効になります。 読取り専用 <code class="literal">core_file</code> 変数が無効になった場合は、サーバーを再起動して再度有効にする必要があります。 
      </p><p>
        次のテーブルに、コアファイルが生成されるかどうか、およびコアファイルにバッファープールページが含まれるかどうかを決定する構成シナリオと <code class="literal">MADV_DONTDUMP</code> サポートシナリオを示します。
      </p><div class="table"><a name="innodb-buffer-pool-in-core-file-configuration-scenarios"></a><p class="title"><b>表 15.4 コアファイルの構成シナリオ</b></p><div class="table-contents"><table summary="Core file configuration and         MADV_DONTDUMP support scenarios."><col style="width: 20%"><col style="width: 20%"><col style="width: 20%"><col style="width: 40%"><thead><tr>
            <th scope="col"><code class="literal">core_file</code> 変数</th>
            <th scope="col"><code class="literal">innodb_buffer_pool_in_core_file</code> 変数</th>
            <th scope="col">madvise() MADV_DONTDUMP のサポート</th>
            <th scope="col">結果</th>
          </tr></thead><tbody><tr>
            <th scope="row">OFF (デフォルト)</th>
            <td>結果に関連しない</td>
            <td>結果に関連しない</td>
            <td>コアファイルは生成されません</td>
          </tr><tr>
            <th scope="row">ON</th>
            <td>ON (デフォルト)</td>
            <td>結果に関連しない</td>
            <td>コアファイルはバッファプールページで生成されます</td>
          </tr><tr>
            <th scope="row">ON</th>
            <td>OFF</td>
            <td>はい</td>
            <td>コアファイルはバッファプールページなしで生成されます</td>
          </tr><tr>
            <th scope="row">ON</th>
            <td>OFF</td>
            <td>いいえ</td>
            <td>コアファイルが生成されず、<code class="literal">core_file</code> が無効になり、サーバーエラーログに警告が書き込まれます</td>
          </tr></tbody></table></div></div><br class="table-break"><p>
        <code class="literal">innodb_buffer_pool_in_core_file</code> 変数を無効にして達成されるコアファイルサイズの縮小は、バッファプールのサイズによって異なりますが、<code class="literal">InnoDB</code> ページサイズの影響も受けます。 ページサイズが小さいほど、同じ量のデータに必要なページが増え、ページが多いほどページメタデータが増えます。 次のテーブルに、ページサイズが異なる 1GB バッファプールで表示されるサイズ削減の例を示します。 
      </p><div class="table"><a name="innodb-buffer-pool-in-core-file-size-examples"></a><p class="title"><b>表 15.5 バッファープールページが含まれ、除外されているコアファイルのサイズ</b></p><div class="table-contents"><table summary="Core file size reduction examples for different pages sizes."><col style="width: 20%"><col style="width: 20%"><col style="width: 20%"><thead><tr>
            <th scope="col"><code class="literal">innodb_page_size</code> 設定</th>
            <th scope="col">含まれるバッファプールページ (<code class="literal">innodb_buffer_pool_in_core_file=ON</code>)</th>
            <th scope="col">除外されたバッファープールページ (<code class="literal">innodb_buffer_pool_in_core_file=OFF</code>)</th>
          </tr></thead><tbody><tr>
            <th scope="row">4KB</th>
            <td>2.1GB</td>
            <td>0.9GB</td>
          </tr><tr>
            <th scope="row">64KB</th>
            <td>1.7GB</td>
            <td>0.7GB</td>
          </tr></tbody></table></div></div><br class="table-break"></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-performance-thread_concurrency"></a>15.8.4 InnoDB のスレッド並列性の構成</h3></div></div></div><a class="indexterm" name="idm44761360457856"></a><a class="indexterm" name="idm44761360456784"></a><a class="indexterm" name="idm44761360455664"></a><a class="indexterm" name="idm44761360454544"></a><p>
      <code class="literal">InnoDB</code> は、オペレーティングシステム<a class="link" href="glossary.html#glos_thread" title="スレッド">スレッド</a>を使用して、ユーザートランザクションからの要求を処理します。 (トランザクションは、コミットまたはロールバックする前に、<code class="literal">InnoDB</code> に多数の要求を発行する可能性があります。) コンテキストスイッチングが効率的な、マルチコアプロセッサを備えた最新のオペレーティングシステムおよびサーバーでは、並列スレッドの数を制限することなく、ほとんどのワークロードが適切に動作します。 
    </p><p>
      スレッド間のコンテキストスイッチングを最小限に抑えることが役立つ状況では、<code class="literal">InnoDB</code> はいくつかの手法を使用して、並列実行中のオペレーティングシステムスレッドの数 (したがって、一度に処理される要求の数) を制限できます。 <code class="literal">InnoDB</code> がユーザーセッションからの新しい要求を受信したとき、並列実行中のスレッドの数が事前に定義された制限に達している場合、その新しい要求は再試行の前に短時間だけスリープします。 スリープのあとに再スケジュールできない要求は先入れ先出しキューに入れられ、最終的に処理されます。 ロックを待機しているスレッドは、並列実行中のスレッドの数にカウントされません。 
    </p><p>
      並列スレッドの数は、構成パラメータ <code class="literal">innodb_thread_concurrency</code> を設定することによって制限できます。 実行中のスレッドの数がこの制限に達すると、追加のスレッドはキューに入れられる前に、構成パラメータ <code class="literal">innodb_thread_sleep_delay</code> で設定されたマイクロ秒数だけスリープします。 
    </p><p>
      構成オプション <code class="literal">innodb_adaptive_max_sleep_delay</code> を <code class="literal">innodb_thread_sleep_delay</code> に許可する最大値に設定すると、<code class="literal">InnoDB</code> は現在のスレッドスケジュールアクティビティに応じて <code class="literal">innodb_thread_sleep_delay</code> を自動的に上下に調整します。 この動的な調整は、システムにかかる負荷が軽い期間や、システムがほぼ容量いっぱいで動作している期間に、スレッドスケジューリングメカニズムがスムーズに機能するのに役立ちます。 
    </p><p>
      <code class="literal">innodb_thread_concurrency</code> のデフォルト値や、並列スレッドの数に対する暗黙的なデフォルトの制限は、MySQL および <code class="literal">InnoDB</code> のさまざまなリリースで変更されてきました。 <code class="literal">innodb_thread_concurrency</code> のデフォルト値は <code class="literal">0</code> であるため、デフォルトでは同時に実行するスレッドの数に制限はありません。 
    </p><p>
      <code class="literal">InnoDB</code> では、同時スレッド数が制限されている場合にのみスレッドがスリープします。 スレッドの数に対して制限がない場合は、すべてが均等に競合してスケジュールされます。 つまり、<code class="literal">innodb_thread_concurrency</code> が <code class="literal">0</code> である場合は、<code class="literal">innodb_thread_sleep_delay</code> の値は無視されます。 
    </p><p>
      スレッドの数に対して制限がある (<code class="literal">innodb_thread_concurrency</code> &gt; 0 である) 場合、<code class="literal">InnoDB</code> は、<span class="emphasis"><em>1 つの SQL ステートメント</em></span>の実行中に発行された複数の要求が <code class="literal">innodb_thread_concurrency</code> で設定された制限に従うことなく <code class="literal">InnoDB</code> に入ることを許可することによって、コンテキストスイッチングのオーバーヘッドを削減します。 SQL ステートメント (結合など) は <code class="literal">InnoDB</code> 内の複数の行操作で構成されている可能性があるため、<code class="literal">InnoDB</code> は、スレッドが最小限のオーバーヘッドで繰り返しスケジュールされることを許可する指定された数の<span class="quote">「<span class="quote">チケット</span>」</span>を割り当てます。 
    </p><p>
      新しい SQL ステートメントが開始されたとき、スレッドにはチケットがないため、<code class="literal">innodb_thread_concurrency</code> に従う必要があります。 スレッドが <code class="literal">InnoDB</code> に入ることを許可されると、そのスレッドには、行操作を実行するためにあとで <code class="literal">InnoDB</code> に入るときに使用できる複数のチケットが割り当てられます。 それらのチケットが使い果たされた場合、スレッドは削除され、ふたたび <code class="literal">innodb_thread_concurrency</code> に従います。それにより、そのスレッドが、待機中のスレッドの先入れ先出しキューに戻される可能性があります。 スレッドがふたたび <code class="literal">InnoDB</code> に入ることを許可されると、チケットが再度割り当てられます。 割り当てられるチケットの数は、グローバルオプション <code class="literal">innodb_concurrency_tickets</code>(デフォルトは 5000) によって指定されます。 ロックを待機しているスレッドには、そのロックが使用可能になるとチケットが 1 つ与えられます。 
    </p><p>
      これらの変数の正しい値は、環境やワークロードによって異なります。 アプリケーションでどのような値が機能するかを確認するには、さまざまな値を試してください。 並列実行中のスレッドの数を制限する前に、マルチコアおよびマルチプロセッサコンピュータ上の <code class="literal">InnoDB</code> のパフォーマンスを向上させる可能性のある構成オプション (<code class="literal">innodb_adaptive_hash_index</code> など) を確認してください。 
    </p><p>
      MySQL のスレッド処理に関する一般的なパフォーマンス情報については、<a class="xref" href="server-administration.html#connection-interfaces" title="5.1.12.1 接続インタフェース">セクション5.1.12.1「接続インタフェース」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-performance-multiple_io_threads"></a>15.8.5 InnoDB バックグラウンド I/O スレッドの数の構成</h3></div></div></div><a class="indexterm" name="idm44761360408448"></a><a class="indexterm" name="idm44761360407392"></a><a class="indexterm" name="idm44761360406304"></a><a class="indexterm" name="idm44761360404288"></a><p>
      <code class="literal">InnoDB</code> では、バックグラウンド <a class="link" href="glossary.html#glos_thread" title="スレッド">threads</a> を使用して様々なタイプの I/O リクエストを処理します。 <code class="literal">innodb_read_io_threads</code> および <code class="literal">innodb_write_io_threads</code> 構成パラメータを使用して、データページで I/O の読取りおよび書込みを行うバックグラウンドスレッドの数を構成できます。 これらのパラメータは、読取りおよび書込みリクエストにそれぞれ使用されるバックグラウンドスレッドの数を示します。 これらは、サポートされるすべてのプラットフォームで有効です。 これらのパラメータの値は、MySQL オプションファイル (<code class="literal">my.cnf</code> または <code class="literal">my.ini</code>) で設定できます。値を動的に変更することはできません。 これらのパラメータのデフォルト値は <code class="literal">4</code> で、許容値の範囲は <code class="literal">1-64</code> です。 
    </p><p>
      ハイエンドシステムで <code class="literal">InnoDB</code> をよりスケーラブルにするためのこれらの構成オプションの目的。 各バックグラウンドスレッドは、保留中の I/O 要求を最大 256 個処理できます。 バックグラウンド I/O の主なソースは、<a class="link" href="glossary.html#glos_read_ahead" title="先読み">read-ahead</a> リクエストです。 <code class="literal">InnoDB</code> は、ほとんどのバックグラウンドスレッドが同じように動作するように、受信リクエストのロードバランシングを試みます。 また、<code class="literal">InnoDB</code> は、同じエクステントから同じスレッドに読取りリクエストを割り当てようとし、リクエストを結合する可能性を高めます。 ハイエンドの I/O サブシステムがあり、<code class="literal">SHOW ENGINE INNODB STATUS</code> 出力に 64× <code class="literal">innodb_read_io_threads</code> を超える保留中の読取りリクエストが表示される場合、<code class="literal">innodb_read_io_threads</code> の値を増やすことでパフォーマンスが向上する可能性があります。 
    </p><p>
      Linux システムでは、<code class="literal">InnoDB</code> はデフォルトで非同期 I/O サブシステムを使用して、データファイルページの先読みおよび書込みリクエストを実行します。これにより、<code class="literal">InnoDB</code> バックグラウンドスレッドがこれらのタイプの I/O リクエストを処理する方法が変更されます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-linux-native-aio" title="15.8.6 Linux での非同期 I/O の使用">セクション15.8.6「Linux での非同期 I/O の使用」</a>を参照してください。 
    </p><p>
      <code class="literal">InnoDB</code> I/O のパフォーマンスの詳細は、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8 InnoDB ディスク I/O の最適化">セクション8.5.8「InnoDB ディスク I/O の最適化」</a> を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-linux-native-aio"></a>15.8.6 Linux での非同期 I/O の使用</h3></div></div></div><a class="indexterm" name="idm44761360380000"></a><a class="indexterm" name="idm44761360377888"></a><a class="indexterm" name="idm44761360376224"></a><a class="indexterm" name="idm44761360374768"></a><p>
      <code class="literal">InnoDB</code> は、Linux で非同期 I/O サブシステム (ネイティブ AIO) を使用して、データファイルページの先読みおよび書込みリクエストを実行します。 この動作は、Linux システムにのみ適用され、デフォルトで有効になっている <code class="literal">innodb_use_native_aio</code> 構成オプションによって制御されます。 他の Unix に似たシステムでは、<code class="literal">InnoDB</code> は同期 I/O のみを使用します。 従来、<code class="literal">InnoDB</code> では、Windows システムで非同期 I/O のみが使用されていました。 Linux で非同期 I/O サブシステムを使用するには、<code class="literal">libaio</code> ライブラリが必要です。 
    </p><p>
      同期 I/O,クエリースレッドは I/O リクエストをキューに入れ、<code class="literal">InnoDB</code> バックグラウンドスレッドはキューに入れられたリクエストを一度に 1 つずつ取得し、それぞれに対して同期 I/O コールを発行します。 I/O リクエストが完了し、I/O コールが返されると、リクエストを処理している <code class="literal">InnoDB</code> バックグラウンドスレッドは I/O 完了ルーチンをコールし、次のリクエストを処理するために戻ります。 パラレルに処理できるリクエストの数は <em class="replaceable"><code>n</code></em> で、<em class="replaceable"><code>n</code></em> は <code class="literal">InnoDB</code> バックグラウンドスレッドの数です。 <code class="literal">InnoDB</code> バックグラウンドスレッドの数は、<code class="literal">innodb_read_io_threads</code> および <code class="literal">innodb_write_io_threads</code> によって制御されます。 <a class="xref" href="innodb-storage-engine.html#innodb-performance-multiple_io_threads" title="15.8.5 InnoDB バックグラウンド I/O スレッドの数の構成">セクション15.8.5「InnoDB バックグラウンド I/O スレッドの数の構成」</a>を参照してください。 
    </p><p>
      ネイティブ AIO では、クエリースレッドは I/O リクエストをオペレーティングシステムに直接ディスパッチするため、バックグラウンドスレッドの数によって課される制限は削除されます。 <code class="literal">InnoDB</code> バックグラウンドスレッドは、I/O イベントが完了したリクエストを通知するのを待機します。 リクエストが完了すると、バックグラウンドスレッドは I/O 完了ルーチンを呼び出し、I/O イベントの待機を再開します。 
    </p><p>
      ネイティブ AIO の利点は、多くの保留中の読取り/書込みを <code class="literal">SHOW ENGINE INNODB STATUS\G</code> 出力に表示する I/O-bound システムのスケーラビリティです。 ネイティブ AIO を使用する場合の並列処理の増加は、I/O スケジューラのタイプまたはディスクアレイコントローラのプロパティーが I/O のパフォーマンスに大きく影響することを意味します。 
    </p><p>
      大量の I/O-bound システムに対するネイティブ AIO の潜在的なデメリットは、オペレーティングシステムに一度にディスパッチされる I/O 書込みリクエストの数を制御できないことです。 パラレル処理のためにオペレーティングシステムにディスパッチされた I/O 書込みリクエストが多すぎると、I/O アクティビティおよびシステム機能の量に応じて、I/O 読取り文が発生する場合があります。 
    </p><p>
      OS の非同期 I/O サブシステムに問題があるために <code class="literal">InnoDB</code> を起動できない場合は、<code class="literal">innodb_use_native_aio=0</code> を使用してサーバーを起動できます。 このオプションは、<code class="literal">tmpfs</code> で非同期 I/O をサポートしていない <code class="literal">tmpdir</code> の場所、<code class="literal">tmpfs</code> ファイルシステム、Linux カーネルの組合せなどの潜在的な問題が <code class="literal">InnoDB</code> によって検出された場合にも、起動時に自動的に無効になることがあります。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-configuring-io-capacity"></a>15.8.7 InnoDB I/O Capacity の構成</h3></div></div></div><a class="indexterm" name="idm44761360347936"></a><a class="indexterm" name="idm44761360346848"></a><p>
      <code class="literal">InnoDB</code> マスタースレッドおよびその他のスレッドは、さまざまなタスクをバックグラウンドで実行します。これらのほとんどは、バッファープールからダーティーページをフラッシュしたり、変更バッファーから適切なセカンダリインデックスに変更を書き込みたりするなど、I/O に関連しています。 <code class="literal">InnoDB</code> は、サーバーの通常の動作に悪影響を与えない方法でこれらのタスクを実行しようとします。 使用可能な I/O 帯域幅を見積もり、そのアクティビティをチューニングして使用可能な容量を利用しようとします。 
    </p><p>
      <code class="literal">innodb_io_capacity</code> 変数は、<code class="literal">InnoDB</code> で使用可能な全体的な I/O 容量を定義します。 これは、システムが秒当たりに実行できる I/O 操作の数 (IOPS) におよそ設定する必要があります。 <code class="literal">innodb_io_capacity</code> が設定されている場合、<code class="literal">InnoDB</code> は、設定された値に基づいてバックグラウンドタスクに使用可能な I/O 帯域幅を見積もります。 
    </p><p>
      <code class="literal">innodb_io_capacity</code> は 100 以上の値に設定できます。 デフォルト値は <code class="literal">200</code> です。 通常、100 付近の値は、最大 7200 RPM のハードドライブなどのコンシューマレベルのストレージデバイスに適しています。 より高速なハードドライブ、RAID 構成、およびソリッドステートドライブ (SSD) は、より高い値からメリットを得られます。 
    </p><p>
      理想的には、設定を実用的なものとして低く保ちますが、バックグラウンドアクティビティが遅れるほど低くしないでください。 値が大きすぎる場合、データはバッファプールから削除され、キャッシュするにはバッファの変更が早すぎるため、大きな利点があります。 I/O レートが高いビジーシステムの場合は、高い値を設定すると、高い行変更率に関連付けられたバックグラウンドメンテナンス作業をサーバーが処理できるようになります。 通常、この値は、<code class="literal">InnoDB</code> I/O に使用されるドライブ数の関数として増やすことができます。 たとえば、複数のディスクまたは SSD を使用するシステムで値を増やすことができます。 
    </p><p>
      通常、デフォルト設定の 200 は、ローエンド SSD には十分です。 高エンドのバス接続 SSD の場合は、1000 などのより高い設定を検討してください。 個々の 5400 RPM または 7200 RPM ドライブを搭載したシステムでは、値を 100 に減らすことができます。これは、約 100 IOPS を実行できる古い世代のディスクドライブで使用可能な秒あたりの I/O 操作数 (IOPS) の推定比率を表します。 
    </p><p>
      百万などの高い値を指定できますが、実際にはこのような大きな値の利点はほとんどありません。 通常、ワークロードに対して低い値が不十分であることが確実でないかぎり、20000 より大きい値はお薦めしません。 
    </p><p>
      <code class="literal">innodb_io_capacity</code> をチューニングする場合は、書込みワークロードを検討してください。 書込みワークロードが大きいシステムでは、設定を大きくするとメリットが得られる可能性があります。 書込みワークロードが小さいシステムでは、低い設定で十分な場合があります。 
    </p><p>
      <code class="literal">innodb_io_capacity</code> 設定はバッファプールごとのインスタンス設定ではありません。 使用可能な I/O 容量は、アクティビティーをフラッシュするためにバッファープールインスタンス間で均等に分散されます。 
    </p><p>
      <code class="literal">innodb_io_capacity</code> の値は、MySQL オプションファイル (<code class="literal">my.cnf</code> または <code class="literal">my.ini</code>) で設定するか、<code class="literal">SET GLOBAL</code> ステートメントを使用して実行時に変更できます。これには、グローバルシステム変数の設定に十分な権限が必要です。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 
    </p><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-ignore-io-capacity"></a>チェックポイントでの I/O 容量の無視</h4></div></div></div><p>
        <code class="literal">innodb_flush_sync</code> 変数はデフォルトで有効になっており、<a class="link" href="glossary.html#glos_checkpoint" title="チェックポイント">checkpoints</a> で発生する I/O アクティビティのバースト中に <code class="literal">innodb_io_capacity</code> 設定が無視されます。 <code class="literal">innodb_io_capacity</code> 設定で定義された I/O レートに準拠するには、<code class="literal">innodb_flush_sync</code> を無効にします。 
      </p><p>
        <code class="literal">innodb_flush_sync</code> の値は、MySQL オプションファイル (<code class="literal">my.cnf</code> または <code class="literal">my.ini</code>) で設定するか、<code class="literal">SET GLOBAL</code> ステートメントを使用して実行時に変更できます。これには、グローバルシステム変数の設定に十分な権限が必要です。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-io-capacity-maximum"></a>I/O 容量の最大値の構成</h4></div></div></div><p>
        フラッシュアクティビティが遅れている場合、<code class="literal">InnoDB</code> は <code class="literal">innodb_io_capacity</code> 変数で定義されているよりも高い速度の I/O 操作/秒 (IOPS) で、より積極的にフラッシュできます。 <code class="literal">innodb_io_capacity_max</code> 変数は、このような状況で <code class="literal">InnoDB</code> バックグラウンドタスクによって実行される IOPS の最大数を定義します。 
      </p><p>
        起動時に <code class="literal">innodb_io_capacity</code> 設定を指定し、<code class="literal">innodb_io_capacity_max</code> の値を指定しない場合、<code class="literal">innodb_io_capacity_max</code> のデフォルトは <code class="literal">innodb_io_capacity</code> または 2000 のどちらか大きい方の値の 2 倍になります。
      </p><p>
        <code class="literal">innodb_io_capacity_max</code> を構成する場合、多くの場合、<code class="literal">innodb_io_capacity</code> が適切な開始点になります。 デフォルト値 2000 は、SSD または複数の通常のディスクドライブを使用するワークロードを対象としています。 SSD または複数のディスクドライブを使用しないワークロードでは、2000 の設定が高すぎる可能性があり、フラッシュが多すぎる可能性があります。 単一の標準ディスクドライブの場合は、200 から 400 の間の設定をお薦めします。 ハイエンドのバス接続 SSD の場合は、2500 などの高い設定を検討してください。 <code class="literal">innodb_io_capacity</code> 設定と同様に、この設定は実用的ではなく、<code class="literal">InnoDB</code> が IOPS の速度を <code class="literal">innodb_io_capacity</code> 設定を超えて十分に拡張できないように低くしてください。 
      </p><p>
        <code class="literal">innodb_io_capacity_max</code> をチューニングする場合は、書込みワークロードを検討してください。 書込みワークロードが大きいシステムでは、設定を大きくするとメリットが得られる場合があります。 書込みワークロードが小さいシステムでは、低い設定で十分な場合があります。 
      </p><p>
        <code class="literal">innodb_io_capacity_max</code> は、<code class="literal">innodb_io_capacity</code> 値より小さい値に設定できません。
      </p><p>
        <code class="literal">SET</code> ステートメント (<code class="literal">SET GLOBAL innodb_io_capacity_max=DEFAULT</code>) を使用して <code class="literal">innodb_io_capacity_max</code> を <code class="literal">DEFAULT</code> に設定すると、<code class="literal">innodb_io_capacity_max</code> が最大値に設定されます。
      </p><p>
        <code class="literal">innodb_io_capacity_max</code> 制限は、すべてのバッファープールインスタンスに適用されます。 バッファプールごとのインスタンス設定ではありません。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-performance-spin_lock_polling"></a>15.8.8 スピンロックのポーリングの構成</h3></div></div></div><a class="indexterm" name="idm44761360279328"></a><a class="indexterm" name="idm44761360277888"></a><a class="indexterm" name="idm44761360276912"></a><p>
      <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_mutex" title="相互排他ロック">mutexes</a> および <a class="link" href="glossary.html#glos_rw_lock" title="rw ロック (読み書きロック)">rw-locks</a> は通常、短い間隔で予約されています。 マルチコアシステムでは、スレッドがスリープする前に mutex または rw-lock を一定期間取得できるかどうかを継続的にチェックする方が効率的です。 mutex または rw-lock がこの期間中に使用可能になった場合、スレッドは同じタイムスライスですぐに続行できます。 ただし、相互排他ロックや rw-lock などの共有オブジェクトを複数のスレッドで頻繁にポーリングすると、<span class="quote">「<span class="quote">cache ping pong</span>」</span> が発生する可能性があり、その結果プロセッサは互いの一部を無効にします。 <code class="literal">InnoDB</code> では、ポーリング間のランダムな遅延を強制してポーリングアクティビティを非同期化することで、この問題を最小限に抑えます。 ランダム遅延はスピン待機ループとして実装されます。 
    </p><p>
      スピン待機ループの継続時間は、ループ内で発生する PAUSE 命令の数によって決まります。 その数値を生成するには、0 から <code class="literal">innodb_spin_wait_delay</code> 値までの整数をランダムに選択し、その値に 50 を掛けます。 (乗数値 50 は、MySQL 8.0.16 の前にハードコードされ、その後構成できます。) たとえば、<code class="literal">innodb_spin_wait_delay</code> 設定が 6 の場合、整数は次の範囲からランダムに選択されます: 
    </p><pre class="programlisting">{0,1,2,3,4,5}</pre><p>
      選択した整数に 50 が乗算されるため、PAUSE 命令の値は 6 つのいずれかになります:
    </p><pre class="programlisting">{0,50,100,150,200,250}</pre><p>
      この値セットの場合、250 はスピン待機ループで発生する PAUSE 命令の最大数です。 <code class="literal">innodb_spin_wait_delay</code> を 5 に設定すると、使用可能な 5 つの値の <code class="literal">{0,50,100,150,200}</code> のセットになります。200 は PAUSE 命令の最大数などです。 このように、<code class="literal">innodb_spin_wait_delay</code> 設定はスピンロックポーリング間の最大遅延を制御します。 
    </p><p>
      すべてのプロセッサコアが高速なキャッシュメモリーを共有するシステムでは、この最大の遅延を短くするか、または <code class="literal">innodb_spin_wait_delay=0</code> を設定してビジーループを完全に無効にすることができます。 複数のプロセッサチップを備えたシステムでは、キャッシュを無効にすると重大な影響を与える場合があるため、最大の遅延を増やすことができます。 
    </p><p>
      100MHz Pentium 紀元では、<code class="literal">innodb_spin_wait_delay</code> ユニットはマイクロ秒に相当するように調整されました。 この時間等価は保持されませんでしたが、PAUSE 命令が比較的長いプロセッサの Skylake 生成が導入されるまで、ほかの CPU 命令と比較してプロセッササイクルの観点から PAUSE 命令の期間はかなり一定のままでした。 <code class="literal">innodb_spin_wait_pause_multiplier</code> 変数は、PAUSE 命令の期間の違いを説明する方法を提供するために、MySQL 8.0.16 で導入されました。 
    </p><p>
      <code class="literal">innodb_spin_wait_pause_multiplier</code> 変数は、PAUSE 命令の値のサイズを制御します。 たとえば、<code class="literal">innodb_spin_wait_delay</code> 設定が 6 の場合、<code class="literal">innodb_spin_wait_pause_multiplier</code> 値を 50 (デフォルトおよび以前にハードコードされた値) から 5 に減らすと、小さい PAUSE 命令値のセットが生成されます: 
    </p><pre class="programlisting">{0,5,10,15,20,25}</pre><p>
      PAUSE 命令の値を増減できるため、プロセッサアーキテクチャーごとに <code class="literal">InnoDB</code> を微調整できます。 たとえば、PAUSE 命令の値が小さいほど、PAUSE 命令が比較的長いプロセッサアーキテクチャーに適しています。 
    </p><p>
      <code class="literal">innodb_spin_wait_delay</code> および <code class="literal">innodb_spin_wait_pause_multiplier</code> 変数は動的です。 これらは、MySQL オプションファイルで指定することも、<code class="literal">SET GLOBAL</code> ステートメントを使用して実行時に変更することもできます。 実行時に変数を変更するには、グローバルシステム変数を設定するのに十分な権限が必要です。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-purge-configuration"></a>15.8.9 パージ構成</h3></div></div></div><a class="indexterm" name="idm44761360242496"></a><a class="indexterm" name="idm44761360241408"></a><a class="indexterm" name="idm44761360239952"></a><p>
      <code class="literal">InnoDB</code> では、SQL ステートメントを使用して行を削除しても、データベースからすぐには行が物理的に削除されません。 行とそのインデックスレコードは、削除のために書き込まれた undo ログレコードが <code class="literal">InnoDB</code> によって破棄された場合にのみ物理的に削除されます。 この削除操作は、行がマルチバージョン同時実行性制御 (MVCC) またはロールバックに不要になった後にのみ実行され、パージと呼ばれます。 
    </p><p>
      パージは定期的に実行されます。 履歴リストから undo ログページを解析して処理します。これは、<code class="literal">InnoDB</code> トランザクションシステムによってメンテナンスされるコミット済トランザクションの undo ログページのリストです。 パージすると、undo ログページは処理後に履歴リストから解放されます。 
    </p><h4><a name="idm44761360233840"></a>パージスレッドの構成</h4><p>
      パージ操作は、1 つ以上のパージスレッドによってバックグラウンドで実行されます。 パージスレッドの数は、<code class="literal">innodb_purge_threads</code> 変数によって制御されます。 デフォルト値は 4 です。 DML アクションが単一のテーブルまたはいくつかのテーブルに集中している場合は、スレッドがテーブルにアクセスするために互いに競合しないように、設定を低くしておきます。 DML 操作が多数のテーブルに分散している場合は、この設定を増やします。 パージスレッドの最大数は 32 です。 
    </p><p>
      <code class="literal">innodb_purge_threads</code> 設定は、許可されるパージスレッドの最大数です。 パージシステムは、必要に応じてパージスレッドの数を自動的に調整します。 
    </p><h4><a name="idm44761360229088"></a>パージバッチサイズの構成</h4><p>
      <code class="literal">innodb_purge_batch_size</code> 変数は、履歴リストから一度に解析および処理をパージする undo ログページの数を定義します。 デフォルト値は 300 です。 マルチスレッドパージ構成では、コーディネータパージスレッドは <code class="literal">innodb_purge_batch_size</code> を <code class="literal">innodb_purge_threads</code> で除算し、その数のページを各パージスレッドに割り当てます。 
    </p><p>
      パージシステムでは、不要になった undo ログページも解放されます。 undo ログを使用して 128 回ずつ反復します。 <code class="literal">innodb_purge_batch_size</code> 変数では、バッチで解析および処理される undo ログページの数の定義に加えて、undo ログを介して 128 回反復するたびにパージによって解放される undo ログページの数を定義します。 
    </p><p>
      <code class="literal">innodb_purge_batch_size</code> 変数は、高度なパフォーマンスチューニングおよび実験を目的としています。 ほとんどのユーザーは、<code class="literal">innodb_purge_batch_size</code> をデフォルト値から変更する必要はありません。 
    </p><h4><a name="idm44761360219376"></a>最大パージラグの構成</h4><p>
      <code class="literal">innodb_max_purge_lag</code> 変数は、必要な最大パージラグを定義します。 パージラグが <code class="literal">innodb_max_purge_lag</code> のしきい値を超えると、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code> および <code class="literal">DELETE</code> 操作に遅延が課され、パージ操作がキャッチアップされる時間が許可されます。 デフォルト値は 0 です。これは、最大パージラグおよび遅延がないことを意味します。 
    </p><p>
      <code class="literal">InnoDB</code> トランザクションシステムでは、<code class="literal">UPDATE</code> または <code class="literal">DELETE</code> 操作で削除のマークが付けられたインデックスレコードを含むトランザクションのリストが保持されます。 リストの長さはパージラグです。 MySQL 8.0.14 より前では、パージラグ遅延は次の式によって計算されるため、最小遅延は 5000 マイクロ秒になりました: 
    </p><pre class="programlisting">(purge lag/innodb_max_purge_lag - 0.5) * 10000</pre><p>
      MySQL 8.0.14 では、パージラグ遅延は次の改訂された式によって計算され、最小遅延が 5 マイクロ秒に削減されます。 5 マイクロ秒の遅延は、最新のシステムに適しています。 
    </p><pre class="programlisting">(purge_lag/innodb_max_purge_lag - 0.9995) * 10000</pre><p>
      遅延は、パージバッチの開始時に計算されます。
    </p><p>
      問題のあるワークロードの一般的な <code class="literal">innodb_max_purge_lag</code> 設定は 1000000 (100 万) で、トランザクションが小さく、サイズが 100 バイトのみで、100MB のパージされていないテーブルの行を持つことができると想定されます。
    </p><p>
      パージラグは、<code class="literal">SHOW ENGINE INNODB STATUS</code> 出力の <code class="literal">TRANSACTIONS</code> セクションに <code class="literal">History list length</code> 値として表示されます。
    </p><pre class="programlisting">mysql&gt; SHOW ENGINE INNODB STATUS;
...
------------
TRANSACTIONS
------------
Trx id counter 0 290328385
Purge done for trx's n:o &lt; 0 290315608 undo n:o &lt; 0 17
History list length 20
</pre><p>
      通常、<code class="literal">History list length</code> は低い値で、通常は数千未満ですが、書込み負荷の高いワークロードまたは長時間実行中のトランザクションは、読取り専用のトランザクションの場合でも増加する可能性があります。 長時間実行トランザクションが原因で <code class="literal">History list length</code> が増加する理由は、<code class="literal">REPEATABLE READ</code> などの読取り一貫性トランザクション分離レベルでは、トランザクションの読取りビューが作成されたときと同じ結果を返す必要があるためです。 したがって、<code class="literal">InnoDB</code> マルチバージョン同時実行性制御 (MVCC) システムは、そのデータに依存するすべてのトランザクションが完了するまで、undo ログにデータのコピーを保持する必要があります。 次に、<code class="literal">History list length</code> が増加する可能性のある長時間実行トランザクションの例を示します: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          大量の同時 DML があるときに <code class="option">--single-transaction</code> オプションを使用する <span class="command"><strong>mysqldump</strong></span> 操作。
        </p></li><li class="listitem"><p>
          <code class="literal">autocommit</code> を無効にし、明示的な <code class="literal">COMMIT</code> または <code class="literal">ROLLBACK</code> の発行を忘れた後の <code class="literal">SELECT</code> クエリーの実行。
        </p></li></ul></div><p>
      パージラグが膨大になる極端な状況での過剰な遅延を防ぐために、<code class="literal">innodb_max_purge_lag_delay</code> 変数を設定して遅延を制限できます。 <code class="literal">innodb_max_purge_lag_delay</code> 変数は、<code class="literal">innodb_max_purge_lag</code> しきい値を超えた場合に課される遅延の最大遅延をマイクロ秒単位で指定します。 指定された <code class="literal">innodb_max_purge_lag_delay</code> 値は、<code class="literal">innodb_max_purge_lag</code> 式で計算された遅延期間の上限です。 
    </p><h4><a name="idm44761360179840"></a>パージおよび undo テーブルスペースの切捨て</h4><p>
      パージシステムは、undo テーブルスペースの切捨ても行います。 パージシステムが切り捨てる undo テーブルスペースを検索する頻度を制御するように <code class="literal">innodb_purge_rseg_truncate_frequency</code> 変数を構成できます。 詳細は、<a class="xref" href="innodb-storage-engine.html#truncate-undo-tablespace" title="undo テーブルスペースの切捨て">undo テーブルスペースの切捨て</a>を参照してください。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-performance-optimizer-statistics"></a>15.8.10 InnoDB のオプティマイザ統計の構成</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-persistent-stats">15.8.10.1 永続的オプティマイザ統計のパラメータの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-statistics-estimation">15.8.10.2 非永続的オプティマイザ統計のパラメータの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-analyze-table-complexity">15.8.10.3 InnoDB テーブルに対する ANALYZE TABLE の複雑さの推定</a></span></dt></dl></div><p>
      このセクションでは、<code class="literal">InnoDB</code> テーブルの永続オプティマイザ統計および非永続オプティマイザ統計を構成する方法について説明します。
    </p><p>
      永続オプティマイザ統計はサーバーの再起動後も永続化されるため、<a class="link" href="glossary.html#glos_plan_stability" title="計画安定性">plan stability</a> の向上とクエリーのパフォーマンスの一貫性が向上します。 永続オプティマイザ統計には、次のような利点があり、制御と柔軟性もあります: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">innodb_stats_auto_recalc</code> 構成オプションを使用して、テーブルに対する大幅な変更後に統計を自動的に更新するかどうかを制御できます。
        </p></li><li class="listitem"><p>
          <code class="literal">STATS_PERSISTENT</code>、<code class="literal">STATS_AUTO_RECALC</code> および <code class="literal">STATS_SAMPLE_PAGES</code> 句を <code class="literal">CREATE TABLE</code> および <code class="literal">ALTER TABLE</code> ステートメントとともに使用して、個々のテーブルのオプティマイザ統計を構成できます。
        </p></li><li class="listitem"><p>
          <code class="literal">mysql.innodb_table_stats</code> テーブルおよび <code class="literal">mysql.innodb_index_stats</code> テーブルのオプティマイザ統計データをクエリーすることができます。
        </p></li><li class="listitem"><p>
          <code class="literal">mysql.innodb_table_stats</code> テーブルおよび <code class="literal">mysql.innodb_index_stats</code> テーブルの <code class="literal">last_update</code> カラムを表示して、統計が最後に更新された日時を確認できます。
        </p></li><li class="listitem"><p>
          <code class="literal">mysql.innodb_table_stats</code> テーブルおよび <code class="literal">mysql.innodb_index_stats</code> テーブルを手動で変更して、特定のクエリー最適化計画を強制したり、データベースを変更せずに代替計画をテストできます。
        </p></li></ul></div><p>
      永続オプティマイザ統計機能は、デフォルトで有効になっています (<code class="literal">innodb_stats_persistent=ON</code>)。
    </p><p>
      非永続オプティマイザ統計は、各サーバーの再起動時および他の操作後にクリアされ、次のテーブルアクセスで再計算されます。 その結果、統計の再計算時に異なる見積りが生成され、実行計画の選択肢やクエリーパフォーマンスの変動が生じる可能性があります。 
    </p><p>
      このセクションでは、正確な統計と <code class="literal">ANALYZE TABLE</code> 実行時間のバランスを取る場合に役立つ可能性のある、<code class="literal">ANALYZE TABLE</code> の複雑さの見積りについても説明します。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-persistent-stats"></a>15.8.10.1 永続的オプティマイザ統計のパラメータの構成</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-persistent-stats-auto-recalc">15.8.10.1.1 永続オプティマイザ統計の自動統計計算の構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-persistent-stats-table-configuration">15.8.10.1.2 個々のテーブルのオプティマイザ統計パラメータの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-persistent-stats-pages-sampled">15.8.10.1.3 InnoDB オプティマイザ統計でサンプリングされるページの数の構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-persistent-stats-delete-marked">15.8.10.1.4 永続統計計算への削除マーク付きレコードの組込み</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-persistent-stats-tables">15.8.10.1.5 InnoDB 永続的統計テーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-persistent-stats-tables-example">15.8.10.1.6 InnoDB 永続的統計テーブルの例</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-persistent-stats-tables-index-size">15.8.10.1.7 innodb_index_stats テーブルを使用したインデックスサイズの取得</a></span></dt></dl></div><a class="indexterm" name="idm44761360149184"></a><a class="indexterm" name="idm44761360146976"></a><a class="indexterm" name="idm44761360144848"></a><a class="indexterm" name="idm44761360142720"></a><a class="indexterm" name="idm44761360140592"></a><p>
        永続オプティマイザ統計機能は、統計をディスクに格納し、サーバーの再起動後も永続させることで <a class="link" href="glossary.html#glos_plan_stability" title="計画安定性">plan stability</a> を改善し、<a class="link" href="glossary.html#glos_optimizer" title="オプティマイザ">optimizer</a> が特定のクエリーに対して一貫性のある選択を行う可能性を高めます。
      </p><p>
        オプティマイザ統計は、<code class="literal">innodb_stats_persistent=ON</code> または個々のテーブルが <code class="literal">STATS_PERSISTENT=1</code> で定義されている場合、ディスクに永続化されます。<code class="literal">innodb_stats_persistent</code> はデフォルトで有効になっています。
      </p><p>
        以前は、サーバーの再起動時および他のタイプの操作後にオプティマイザ統計がクリアされ、次のテーブルアクセスで再計算されていました。 したがって、統計を再計算すると、クエリー実行計画の選択肢やクエリーパフォーマンスの変動につながる様々な見積りが生成される可能性があります。 
      </p><p>
        永続統計は、<code class="literal">mysql.innodb_table_stats</code> テーブルおよび <code class="literal">mysql.innodb_index_stats</code> テーブルに格納されます。 <a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats-tables" title="15.8.10.1.5 InnoDB 永続的統計テーブル">セクション15.8.10.1.5「InnoDB 永続的統計テーブル」</a>を参照してください。 
      </p><p>
        オプティマイザ統計をディスクに永続化しない場合は、<a class="xref" href="innodb-storage-engine.html#innodb-statistics-estimation" title="15.8.10.2 非永続的オプティマイザ統計のパラメータの構成">セクション15.8.10.2「非永続的オプティマイザ統計のパラメータの構成」</a> を参照してください
      </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-persistent-stats-auto-recalc"></a>15.8.10.1.1 永続オプティマイザ統計の自動統計計算の構成</h5></div></div></div><p>
          デフォルトで有効になっている <code class="literal">innodb_stats_auto_recalc</code> 変数は、テーブルが 10% を超える行に変更された場合に統計を自動的に計算するかどうかを制御します。 テーブルの作成または変更時に <code class="literal">STATS_AUTO_RECALC</code> 句を指定して、個々のテーブルの自動統計再計算を構成することもできます。 
        </p><p>
          自動統計再計算はバックグラウンドで行われるため、<code class="literal">innodb_stats_auto_recalc</code> が有効な場合でも、10% を超えるテーブルに影響を与える DML 操作を実行した直後に統計が再計算されないことがあります。 場合によっては、統計の再計算が数秒遅れることがあります。 最新の統計がすぐに必要な場合は、<code class="literal">ANALYZE TABLE</code> を実行して統計の同期 (フォアグラウンド) 再計算を開始します。 
        </p><p>
          <code class="literal">innodb_stats_auto_recalc</code> が無効になっている場合は、インデックス付けされたカラムを大幅に変更した後に <code class="literal">ANALYZE TABLE</code> ステートメントを実行することで、オプティマイザ統計の正確性を確保できます。 データのロード後に実行する設定スクリプトに <code class="literal">ANALYZE TABLE</code> を追加し、アクティビティが少ないときにスケジュールで <code class="literal">ANALYZE TABLE</code> を実行することも検討できます。 
        </p><p>
          既存のテーブルにインデックスを追加する場合、またはカラムを追加または削除する場合、<code class="literal">innodb_stats_auto_recalc</code> の値に関係なく、インデックス統計が計算されて <code class="literal">innodb_index_stats</code> テーブルに追加されます。
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-persistent-stats-table-configuration"></a>15.8.10.1.2 個々のテーブルのオプティマイザ統計パラメータの構成</h5></div></div></div><p>
          <code class="literal">innodb_stats_persistent</code>、<code class="literal">innodb_stats_auto_recalc</code> および <code class="literal">innodb_stats_persistent_sample_pages</code> はグローバル変数です。 これらのシステム全体の設定をオーバーライドし、個々のテーブルのオプティマイザ統計パラメータを構成するには、<code class="literal">CREATE TABLE</code> ステートメントまたは <code class="literal">ALTER TABLE</code> ステートメントで <code class="literal">STATS_PERSISTENT</code>、<code class="literal">STATS_AUTO_RECALC</code> および <code class="literal">STATS_SAMPLE_PAGES</code> 句を定義します。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">STATS_PERSISTENT</code> では、<code class="literal">InnoDB</code> テーブルに対して <a class="link" href="glossary.html#glos_persistent_statistics" title="永続的統計">persistent statistics</a> を有効にするかどうかを指定します。 値が <code class="literal">DEFAULT</code> の場合、テーブルの永続統計設定は <code class="literal">innodb_stats_persistent</code> 設定によって決定されます。 <code class="literal">1</code> の値を指定するとテーブルの永続統計が有効になり、<code class="literal">0</code> の値を指定するとこの機能は無効になります。 個々のテーブルの永続統計を有効にした後、<code class="literal">ANALYZE TABLE</code> を使用して、テーブルデータのロード後に統計を計算します。 
            </p></li><li class="listitem"><p>
              <code class="literal">STATS_AUTO_RECALC</code> では、<a class="link" href="glossary.html#glos_persistent_statistics" title="永続的統計">persistent statistics</a> を自動的に再計算するかどうかを指定します。 値が <code class="literal">DEFAULT</code> の場合、テーブルの永続統計設定は <code class="literal">innodb_stats_auto_recalc</code> 設定によって決定されます。 <code class="literal">1</code> の値を指定すると、テーブルデータの 10% が変更されたときに統計が再計算されます。 値が <code class="literal">0</code> の場合、テーブルの自動再計算は行われません。 値 0 を使用する場合は、テーブルに大幅な変更を加えた後、<code class="literal">ANALYZE TABLE</code> を使用して統計を再計算します。 
            </p></li><li class="listitem"><p>
              <code class="literal">STATS_SAMPLE_PAGES</code> では、<code class="literal">ANALYZE TABLE</code> 操作などによって、インデックス付けされたカラムのカーディナリティおよびその他の統計が計算される場合にサンプリングするインデックスページの数を指定します。
            </p></li></ul></div><p>
          次の <code class="literal">CREATE TABLE</code> の例では、3 つの句がすべて指定されています:
        </p><pre class="programlisting">CREATE TABLE `t1` (
`id` int(8) NOT NULL auto_increment,
`data` varchar(255),
`date` datetime,
PRIMARY KEY  (`id`),
INDEX `DATE_IX` (`date`)
) ENGINE=InnoDB,
  STATS_PERSISTENT=1,
  STATS_AUTO_RECALC=1,
  STATS_SAMPLE_PAGES=25;
</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-persistent-stats-pages-sampled"></a>15.8.10.1.3 InnoDB オプティマイザ統計でサンプリングされるページの数の構成</h5></div></div></div><p>
          オプティマイザは、キー配分に関する推定 <a class="link" href="glossary.html#glos_statistics" title="統計">statistics</a> を使用して、インデックスの相対 <a class="link" href="glossary.html#glos_selectivity" title="選択性">selectivity</a> に基づいて実行計画のインデックスを選択します。 <code class="literal">ANALYZE TABLE</code> などの操作を行うと、<code class="literal">InnoDB</code> は、インデックスの<a class="link" href="glossary.html#glos_cardinality" title="カーディナリティー">カーディナリティー</a>を推定するためにテーブル上の各インデックスからランダムなページをサンプリングします。 このサンプリング手法は、<a class="link" href="glossary.html#glos_random_dive" title="ランダムダイブ">random dive</a> と呼ばれます。 
        </p><p>
          <code class="literal">innodb_stats_persistent_sample_pages</code> は、サンプリングされるページの数を制御します。 実行時に設定を調整して、オプティマイザで使用される統計の見積りの品質を管理できます。 デフォルト値は 20 です。 次の問題が発生した場合は、設定の変更を検討してください: 
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              <span class="emphasis"><em>統計が十分ではなく、オプティマイザが最適でない計画を選択しています</em></span> (<code class="literal">EXPLAIN</code> 出力を参照)。 インデックスの実際のカーディナリティ (インデックスカラムで <code class="literal">SELECT DISTINCT</code> を実行して決定) を <code class="literal">mysql.innodb_index_stats</code> テーブルの見積りと比較することで、統計の正確性をチェックできます。 
            </p><p>
              統計の精度が十分でないことが確認された場合は、統計の推定値が十分な精度になるまで <code class="literal">innodb_stats_persistent_sample_pages</code> の値を増やすようにしてください。 ただし、<code class="literal">innodb_stats_persistent_sample_pages</code> を大きくしすぎると、<code class="literal">ANALYZE TABLE</code> の実行が遅くなる可能性があります。 
            </p></li><li class="listitem"><p>
              <span class="emphasis"><em><code class="literal">ANALYZE TABLE</code> が遅すぎる</em></span>。 この場合は、<code class="literal">ANALYZE TABLE</code> の実行時間が許容可能になるまで <code class="literal">innodb_stats_persistent_sample_pages</code> を減らすようにしてください。 ただし、この値を小さくしすぎると、精度の低い統計および次善のクエリー実行計画という最初の問題につながる可能性があります。 
            </p><p>
              統計の精度と <code class="literal">ANALYZE TABLE</code> の実行時間のバランスをとることができない場合は、<code class="literal">ANALYZE TABLE</code> の複雑さを減らすためにテーブル内のインデックス付きカラムの数を減らすか、またはパーティションの数を制限することを考慮してください。 主キーカラムは一意でない各インデックスに追加されるため、テーブルの主キーのカラム数も考慮することが重要です。 
            </p><p>
              関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-analyze-table-complexity" title="15.8.10.3 InnoDB テーブルに対する ANALYZE TABLE の複雑さの推定">セクション15.8.10.3「InnoDB テーブルに対する ANALYZE TABLE の複雑さの推定」</a>を参照してください。
            </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-persistent-stats-delete-marked"></a>15.8.10.1.4 永続統計計算への削除マーク付きレコードの組込み</h5></div></div></div><a class="indexterm" name="idm44761360051104"></a><a class="indexterm" name="idm44761360049504"></a><p>
          デフォルトでは、<code class="literal">InnoDB</code> は統計の計算時にコミットされていないデータを読み取ります。 テーブルから行を削除するコミットされていないトランザクションの場合、行の見積りおよびインデックス統計の計算時に削除マークが付けられたレコードが除外されるため、<code class="literal">READ UNCOMMITTED</code> 以外のトランザクション分離レベルを使用してテーブルで同時に操作している他のトランザクションの実行計画が最適でなくなる可能性があります。 このシナリオを回避するために、<code class="literal">innodb_stats_include_delete_marked</code> を有効にして、永続オプティマイザ統計の計算時に削除マーク付きレコードが含まれるようにできます。 
        </p><p>
          <code class="literal">innodb_stats_include_delete_marked</code> が有効な場合、<code class="literal">ANALYZE TABLE</code> では、統計の再計算時に削除マークが付けられたレコードが考慮されます。
        </p><p>
          <code class="literal">innodb_stats_include_delete_marked</code> は、すべての <code class="literal">InnoDB</code> テーブルに影響するグローバル設定で、永続オプティマイザ統計にのみ適用されます。
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-persistent-stats-tables"></a>15.8.10.1.5 InnoDB 永続的統計テーブル</h5></div></div></div><p>
          永続的統計機能は、<code class="literal">innodb_table_stats</code> および <code class="literal">innodb_index_stats</code> という名前の、<code class="literal">mysql</code> データベース内の内部的に管理されているテーブルに依存します。 これらのテーブルは、すべてのインストール、アップグレード、およびソースからのビルド手順で自動的に設定されます。 
        </p><div class="table"><a name="innodb-table-stats-table"></a><p class="title"><b>表 15.6 innodb_table_stats のカラム</b></p><div class="table-contents"><table summary="Columns of the mysql.innodb_table_stats table."><col style="width: 30%"><col style="width: 70%"><thead><tr>
              <th>カラム名</th>
              <th>説明</th>
            </tr></thead><tbody><tr>
              <td><code class="literal">database_name</code></td>
              <td>データベース名</td>
            </tr><tr>
              <td><code class="literal">table_name</code></td>
              <td>テーブル名、パーティション名、またはサブパーティション名</td>
            </tr><tr>
              <td><code class="literal">last_update</code></td>
              <td><code class="literal">InnoDB</code> が最後にこの行を更新した時間を示すタイムスタンプ</td>
            </tr><tr>
              <td><code class="literal">n_rows</code></td>
              <td>テーブル内の行数</td>
            </tr><tr>
              <td><code class="literal">clustered_index_size</code></td>
              <td>プライマリインデックスのサイズ (ページ数)</td>
            </tr><tr>
              <td><code class="literal">sum_of_other_index_sizes</code></td>
              <td>その他の (プライマリ以外の) インデックスの合計サイズ (ページ数)</td>
            </tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="innodb-index-stats-table"></a><p class="title"><b>表 15.7 innodb_index_stats のカラム</b></p><div class="table-contents"><table summary="Columns of the mysql.innodb_index_stats table."><col style="width: 30%"><col style="width: 70%"><thead><tr>
              <th>カラム名</th>
              <th>説明</th>
            </tr></thead><tbody><tr>
              <td><code class="literal">database_name</code></td>
              <td>データベース名</td>
            </tr><tr>
              <td><code class="literal">table_name</code></td>
              <td>テーブル名、パーティション名、またはサブパーティション名</td>
            </tr><tr>
              <td><code class="literal">index_name</code></td>
              <td>インデックス名</td>
            </tr><tr>
              <td><code class="literal">last_update</code></td>
              <td>行が最後に更新された時刻を示すタイムスタンプ</td>
            </tr><tr>
              <td><code class="literal">stat_name</code></td>
              <td><code class="literal">stat_value</code> カラムに値がレポートされている統計の名前</td>
            </tr><tr>
              <td><code class="literal">stat_value</code></td>
              <td><code class="literal">stat_name</code> カラムで名前が指定されている統計の値</td>
            </tr><tr>
              <td><code class="literal">sample_size</code></td>
              <td><code class="literal">stat_value</code> カラムに示されている推定値のサンプリングされるページの数</td>
            </tr><tr>
              <td><code class="literal">stat_description</code></td>
              <td><code class="literal">stat_name</code> カラムで名前が指定されている統計の説明</td>
            </tr></tbody></table></div></div><br class="table-break"><p>
          <code class="literal">innodb_table_stats</code> テーブルおよび <code class="literal">innodb_index_stats</code> テーブルには、インデックス統計が最後に更新された日時を示す <code class="literal">last_update</code> カラムが含まれます:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM innodb_table_stats \G</code></strong>
*************************** 1. row ***************************
           database_name: sakila
              table_name: actor
             last_update: 2014-05-28 16:16:44
                  n_rows: 200
    clustered_index_size: 1
sum_of_other_index_sizes: 1
...</pre><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM innodb_index_stats \G</code></strong>
*************************** 1. row ***************************
   database_name: sakila
      table_name: actor
      index_name: PRIMARY
     last_update: 2014-05-28 16:16:44
       stat_name: n_diff_pfx01
      stat_value: 200
     sample_size: 1
     ...</pre><p>
          <code class="literal">innodb_table_stats</code> テーブルおよび <code class="literal">innodb_index_stats</code> テーブルは手動で更新できるため、データベースを変更せずに特定のクエリー最適化計画を強制的に実行したり、代替計画をテストできます。 統計を手動で更新する場合は、<code class="literal">FLUSH TABLE <em class="replaceable"><code>tbl_name</code></em></code> ステートメントを使用して更新された統計をロードします。 
        </p><p>
          永続統計はサーバーインスタンスに関連するため、ローカル情報とみなされます。 したがって、自動統計再計算が行われた場合、<code class="literal">innodb_table_stats</code> テーブルおよび <code class="literal">innodb_index_stats</code> テーブルはレプリケートされません。 <code class="literal">ANALYZE TABLE</code> を実行して統計の同期再計算を開始すると、ステートメントはレプリケートされ (ロギングを抑制していないかぎり)、レプリカで再計算が行われます。 
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-persistent-stats-tables-example"></a>15.8.10.1.6 InnoDB 永続的統計テーブルの例</h5></div></div></div><p>
          <code class="literal">innodb_table_stats</code> テーブルには、テーブルごとに 1 つの行が含まれます。 次の例は、収集されるデータのタイプを示しています。 
        </p><p>
          テーブル <code class="literal">t1</code> には、プライマリインデックス (カラム <code class="literal">a</code>、<code class="literal">b</code>)、セカンダリインデックス (カラム <code class="literal">c</code>、<code class="literal">d</code>)、および一意のインデックス (カラム <code class="literal">e</code>、<code class="literal">f</code>) が含まれています。
        </p><pre class="programlisting">CREATE TABLE t1 (
a INT, b INT, c INT, d INT, e INT, f INT,
PRIMARY KEY (a, b), KEY i1 (c, d), UNIQUE KEY i2uniq (e, f)
) ENGINE=INNODB;
</pre><p>
          5 行のサンプルデータを挿入すると、テーブル <code class="literal">t1</code> は次のように表示されます:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM t1;</code></strong>
+---+---+------+------+------+------+
| a | b | c    | d    | e    | f    |
+---+---+------+------+------+------+
| 1 | 1 |   10 |   11 |  100 |  101 |
| 1 | 2 |   10 |   11 |  200 |  102 |
| 1 | 3 |   10 |   11 |  100 |  103 |
| 1 | 4 |   10 |   12 |  200 |  104 |
| 1 | 5 |   10 |   12 |  100 |  105 |
+---+---+------+------+------+------+
</pre><p>
          統計をただちに更新するには、<code class="literal">ANALYZE TABLE</code> を実行します (<code class="literal">innodb_stats_auto_recalc</code> が有効になっている場合、変更されるテーブル行の 10% のしきい値に達したと仮定すると、統計は数秒以内に自動的に更新されます)。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ANALYZE TABLE t1;</code></strong>
+---------+---------+----------+----------+
| Table   | Op      | Msg_type | Msg_text |
+---------+---------+----------+----------+
| test.t1 | analyze | status   | OK       |
+---------+---------+----------+----------+
</pre><p>
          テーブル <code class="literal">t1</code> のテーブル統計には、<code class="literal">InnoDB</code> が最後にテーブル統計を更新した時間 (<code class="literal">2014-03-14 14:36:34</code>)、テーブル内の行数 (<code class="literal">5</code>)、クラスタ化されたインデックスのサイズ (<code class="literal">1</code> ページ)、およびほかのインデックスの合計サイズ (<code class="literal">2</code> ページ) が示されます。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM mysql.innodb_table_stats WHERE table_name like 't1'\G</code></strong>
*************************** 1. row ***************************
           database_name: test
              table_name: t1
             last_update: 2014-03-14 14:36:34
                  n_rows: 5
    clustered_index_size: 1
sum_of_other_index_sizes: 2
</pre><p>
          <code class="literal">innodb_index_stats</code> テーブルには、インデックスごとに複数の行が含まれています。 <code class="literal">innodb_index_stats</code> テーブル内の各行は、<code class="literal">stat_name</code> カラムで名前が指定され、<code class="literal">stat_description</code> カラムで説明されている特定のインデックス統計に関連したデータを示します。 例: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT index_name, stat_name, stat_value, stat_description</code></strong>
       <strong class="userinput"><code>FROM mysql.innodb_index_stats WHERE table_name like 't1';</code></strong>
+------------+--------------+------------+-----------------------------------+
| index_name | stat_name    | stat_value | stat_description                  |
+------------+--------------+------------+-----------------------------------+
| PRIMARY    | n_diff_pfx01 |          1 | a                                 |
| PRIMARY    | n_diff_pfx02 |          5 | a,b                               |
| PRIMARY    | n_leaf_pages |          1 | Number of leaf pages in the index |
| PRIMARY    | size         |          1 | Number of pages in the index      |
| i1         | n_diff_pfx01 |          1 | c                                 |
| i1         | n_diff_pfx02 |          2 | c,d                               |
| i1         | n_diff_pfx03 |          2 | c,d,a                             |
| i1         | n_diff_pfx04 |          5 | c,d,a,b                           |
| i1         | n_leaf_pages |          1 | Number of leaf pages in the index |
| i1         | size         |          1 | Number of pages in the index      |
| i2uniq     | n_diff_pfx01 |          2 | e                                 |
| i2uniq     | n_diff_pfx02 |          5 | e,f                               |
| i2uniq     | n_leaf_pages |          1 | Number of leaf pages in the index |
| i2uniq     | size         |          1 | Number of pages in the index      |
+------------+--------------+------------+-----------------------------------+
</pre><p>
          <code class="literal">stat_name</code> カラムには、次のタイプの統計が示されます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">size</code>: <code class="literal">stat_name</code>=<code class="literal">size</code> である場合、<code class="literal">stat_value</code> カラムには、インデックス内のページの総数が表示されます。
            </p></li><li class="listitem"><p>
              <code class="literal">n_leaf_pages</code>: <code class="literal">stat_name</code>=<code class="literal">n_leaf_pages</code> である場合、<code class="literal">stat_value</code> カラムには、インデックス内のリーフページの数が表示されます。
            </p></li><li class="listitem"><p>
              <code class="literal">n_diff_pfx<em class="replaceable"><code>NN</code></em></code>: <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx01</code> である場合、<code class="literal">stat_value</code> カラムには、インデックスの最初のカラム内の固有の値の数が表示されます。 <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx02</code> である場合、<code class="literal">stat_value</code> カラムには、インデックスの最初の 2 つのカラム内の固有の値の数が表示されます。以下も同様です。 <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx<em class="replaceable"><code>NN</code></em></code> の場合、<code class="literal">stat_description</code> カラムには、カウントされるインデックスカラムのカンマ区切りリストが表示されます。 
            </p></li></ul></div><p>
          カーディナリティデータを提供する <code class="literal">n_diff_pfx<em class="replaceable"><code>NN</code></em></code> 統計をさらに詳しく説明するために、前に紹介した <code class="literal">t1</code> テーブルの例をもう一度検討してください。 次に示すように、<code class="literal">t1</code> テーブルは、プライマリインデックス (カラム <code class="literal">a</code>、<code class="literal">b</code>)、セカンダリインデックス (カラム <code class="literal">c</code>、<code class="literal">d</code>)、および一意のインデックス (カラム <code class="literal">e</code>、<code class="literal">f</code>) で作成されます。 
        </p><pre class="programlisting">CREATE TABLE t1 (
  a INT, b INT, c INT, d INT, e INT, f INT,
  PRIMARY KEY (a, b), KEY i1 (c, d), UNIQUE KEY i2uniq (e, f)
) ENGINE=INNODB;
</pre><p>
          5 行のサンプルデータを挿入すると、テーブル <code class="literal">t1</code> は次のように表示されます:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM t1;</code></strong>
+---+---+------+------+------+------+
| a | b | c    | d    | e    | f    |
+---+---+------+------+------+------+
| 1 | 1 |   10 |   11 |  100 |  101 |
| 1 | 2 |   10 |   11 |  200 |  102 |
| 1 | 3 |   10 |   11 |  100 |  103 |
| 1 | 4 |   10 |   12 |  200 |  104 |
| 1 | 5 |   10 |   12 |  100 |  105 |
+---+---+------+------+------+------+
</pre><p>
          <code class="literal">stat_name LIKE 'n_diff%'</code> である <code class="literal">index_name</code>、<code class="literal">stat_name</code>、<code class="literal">stat_value</code>、および <code class="literal">stat_description</code>, をクエリーすると、次の結果セットが返されます。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT index_name, stat_name, stat_value, stat_description</code></strong>
       <strong class="userinput"><code>FROM mysql.innodb_index_stats</code></strong>
       <strong class="userinput"><code>WHERE table_name like 't1' AND stat_name LIKE 'n_diff%';</code></strong>
+------------+--------------+------------+------------------+
| index_name | stat_name    | stat_value | stat_description |
+------------+--------------+------------+------------------+
| PRIMARY    | n_diff_pfx01 |          1 | a                |
| PRIMARY    | n_diff_pfx02 |          5 | a,b              |
| i1         | n_diff_pfx01 |          1 | c                |
| i1         | n_diff_pfx02 |          2 | c,d              |
| i1         | n_diff_pfx03 |          2 | c,d,a            |
| i1         | n_diff_pfx04 |          5 | c,d,a,b          |
| i2uniq     | n_diff_pfx01 |          2 | e                |
| i2uniq     | n_diff_pfx02 |          5 | e,f              |
+------------+--------------+------------+------------------+
</pre><p>
          <code class="literal">PRIMARY</code> インデックスの場合は、2 つの <code class="literal">n_diff%</code> 行があります。 行数は、インデックス内のカラム数に等しくなります。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            一意でないインデックスの場合、<code class="literal">InnoDB</code> は主キーのカラムを追加します。
          </p></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">index_name</code>=<code class="literal">PRIMARY</code> および <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx01</code> である場合、<code class="literal">stat_value</code> は <code class="literal">1</code> です。これは、インデックスの最初のカラム (カラム <code class="literal">a</code>) 内に固有の値が 1 つ存在することを示します。 カラム <code class="literal">a</code> 内の固有の値の数は、テーブル <code class="literal">t1</code> 内のカラム <code class="literal">a</code> のデータを表示することによって確認されます。ここには、固有の値が 1 つ存在します (<code class="literal">1</code>)。 カウントされるカラム (<code class="literal">a</code>) は、結果セットの <code class="literal">stat_description</code> カラムに示されています。 
            </p></li><li class="listitem"><p>
              <code class="literal">index_name</code>=<code class="literal">PRIMARY</code> および <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx02</code> である場合、<code class="literal">stat_value</code> は <code class="literal">5</code> です。これは、インデックスの 2 つのカラム (<code class="literal">a,b</code>) 内に固有の値が 5 つ存在することを示します。 カラム <code class="literal">a</code> および <code class="literal">b</code> 内の固有の値の数は、テーブル <code class="literal">t1</code> 内のカラム <code class="literal">a</code> および <code class="literal">b</code> のデータを表示することによって確認されます。ここには、固有の値が 5 つ存在します: (<code class="literal">1,1</code>)、(<code class="literal">1,2</code>)、(<code class="literal">1,3</code>)、(<code class="literal">1,4</code>)、および (<code class="literal">1,5</code>)。 カウントされるカラム (<code class="literal">a,b</code>) は、結果セットの <code class="literal">stat_description</code> カラムに示されています。 
            </p></li></ul></div><p>
          セカンダリインデックス (<code class="literal">i1</code>) の場合は、4 つの <code class="literal">n_diff%</code> 行があります。 セカンダリインデックス (<code class="literal">c,d</code>) には 2 つのカラムのみが定義されていますが、<code class="literal">InnoDB</code> では一意でないすべてのインデックスに主キーが接尾辞として付加されるため、セカンダリインデックスには 4 つの <code class="literal">n_diff%</code> 行があります。 その結果、セカンダリインデックスカラム (<code class="literal">c,d</code>) と主キーカラム (<code class="literal">a,b</code>) の両方を反映して、2 つではなく 4 つの <code class="literal">n_diff%</code> 行があります。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">index_name</code>=<code class="literal">i1</code> および <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx01</code> である場合、<code class="literal">stat_value</code> は <code class="literal">1</code> です。これは、インデックスの最初のカラム (カラム <code class="literal">c</code>) 内に固有の値が 1 つ存在することを示します。 カラム <code class="literal">c</code> 内の固有の値の数は、テーブル <code class="literal">t1</code> 内のカラム <code class="literal">c</code> のデータを表示することによって確認されます。ここには、固有の値が 1 つ存在します: (<code class="literal">10</code>)。 カウントされるカラム (<code class="literal">c</code>) は、結果セットの <code class="literal">stat_description</code> カラムに示されています。 
            </p></li><li class="listitem"><p>
              <code class="literal">index_name</code>=<code class="literal">i1</code> および <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx02</code> である場合、<code class="literal">stat_value</code> は <code class="literal">2</code> です。これは、インデックスの最初の 2 つのカラム (<code class="literal">c,d</code>) 内に固有の値が 2 つ存在することを示します。 カラム <code class="literal">c</code> および <code class="literal">d</code> 内の固有の値の数は、テーブル <code class="literal">t1</code> 内のカラム <code class="literal">c</code> および <code class="literal">d</code> のデータを表示することによって確認されます。ここには、固有の値が 2 つ存在します: (<code class="literal">10,11</code>) および (<code class="literal">10,12</code>)。 カウントされるカラム (<code class="literal">c,d</code>) は、結果セットの <code class="literal">stat_description</code> カラムに示されています。 
            </p></li><li class="listitem"><p>
              <code class="literal">index_name</code>=<code class="literal">i1</code> および <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx03</code> である場合、<code class="literal">stat_value</code> は <code class="literal">2</code> です。これは、インデックスの最初の 3 つのカラム (<code class="literal">c,d,a</code>) 内に固有の値が 2 つ存在することを示します。 カラム <code class="literal">c</code>、<code class="literal">d</code>、および <code class="literal">a</code> 内の固有の値の数は、テーブル <code class="literal">t1</code> 内のカラム <code class="literal">c</code>、<code class="literal">d</code>、および <code class="literal">a</code> のデータを表示することによって確認されます。ここには、固有の値が 2 つ存在します: (<code class="literal">10,11,1</code>) および (<code class="literal">10,12,1</code>)。 カウントされるカラム (<code class="literal">c,d,a</code>) は、結果セットの <code class="literal">stat_description</code> カラムに示されています。 
            </p></li><li class="listitem"><p>
              <code class="literal">index_name</code>=<code class="literal">i1</code> および <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx04</code> である場合、<code class="literal">stat_value</code> は <code class="literal">5</code> です。これは、インデックスの 4 つのカラム (<code class="literal">c,d,a,b</code>) 内に固有の値が 5 つ存在することを示します。 カラム <code class="literal">c</code>, <code class="literal">d</code>, <code class="literal">a</code> および <code class="literal">b</code> の個別値の数を確認するには、カラム <code class="literal">c</code>, <code class="literal">d</code>, <code class="literal">a</code> のデータおよびテーブル <code class="literal">t1</code> の <code class="literal">b</code> を表示します。これらには 5 つの個別値があります: (<code class="literal">10,11,1,1</code>)、(<code class="literal">10,11,1,2</code>)、(<code class="literal">10,11,1,3</code>)、(<code class="literal">10,12,1,4</code>) および (<code class="literal">10,12,1,5</code>)。 カウントされるカラム (<code class="literal">c,d,a,b</code>) は、結果セットの <code class="literal">stat_description</code> カラムに示されています。 
            </p></li></ul></div><p>
          一意のインデックス (<code class="literal">i2uniq</code>) の場合は、2 つの <code class="literal">n_diff%</code> 行があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">index_name</code>=<code class="literal">i2uniq</code> および <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx01</code> である場合、<code class="literal">stat_value</code> は <code class="literal">2</code> です。これは、インデックスの最初のカラム (カラム <code class="literal">e</code>) 内に固有の値が 2 つ存在することを示します。 カラム <code class="literal">e</code> 内の固有の値の数は、テーブル <code class="literal">t1</code> 内のカラム <code class="literal">e</code> のデータを表示することによって確認されます。ここには、固有の値が 2 つ存在します: (<code class="literal">100</code>) および (<code class="literal">200</code>)。 カウントされるカラム (<code class="literal">e</code>) は、結果セットの <code class="literal">stat_description</code> カラムに示されています。 
            </p></li><li class="listitem"><p>
              <code class="literal">index_name</code>=<code class="literal">i2uniq</code> および <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx02</code> である場合、<code class="literal">stat_value</code> は <code class="literal">5</code> です。これは、インデックスの 2 つのカラム (<code class="literal">e,f</code>) 内に固有の値が 5 つ存在することを示します。 カラム <code class="literal">e</code> および <code class="literal">f</code> の個別値の数を確認するには、テーブル <code class="literal">t1</code> のカラム <code class="literal">e</code> および <code class="literal">f</code> のデータを表示します。これらには 5 つの個別値があります: (<code class="literal">100,101</code>)、(<code class="literal">200,102</code>)、(<code class="literal">100,103</code>)、(<code class="literal">200,104</code>) および (<code class="literal">100,105</code>)。 カウントされるカラム (<code class="literal">e,f</code>) は、結果セットの <code class="literal">stat_description</code> カラムに示されています。 
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-persistent-stats-tables-index-size"></a>15.8.10.1.7 innodb_index_stats テーブルを使用したインデックスサイズの取得</h5></div></div></div><p>
          <code class="literal">innodb_index_stats</code> テーブルを使用して、テーブル、パーティションまたはサブパーティションのインデックスサイズを取得できます。 次の例では、テーブル <code class="literal">t1</code> のインデックスサイズが取得されています。 テーブル <code class="literal">t1</code> の定義および対応するインデックス統計については、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats-tables-example" title="15.8.10.1.6 InnoDB 永続的統計テーブルの例">セクション15.8.10.1.6「InnoDB 永続的統計テーブルの例」</a>を参照してください。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT SUM(stat_value) pages, index_name,</code></strong>
       <strong class="userinput"><code>SUM(stat_value)*@@innodb_page_size size</code></strong>
       <strong class="userinput"><code>FROM mysql.innodb_index_stats WHERE table_name='t1'</code></strong>
       <strong class="userinput"><code>AND stat_name = 'size' GROUP BY index_name;</code></strong>
+-------+------------+-------+
| pages | index_name | size  |
+-------+------------+-------+
|     1 | PRIMARY    | 16384 |
|     1 | i1         | 16384 |
|     1 | i2uniq     | 16384 |
+-------+------------+-------+
</pre><p>
          パーティションまたはサブパーティションの場合は、変更された <code class="literal">WHERE</code> 句で同じクエリーを使用してインデックスサイズを取得できます。 たとえば、次のクエリーは、テーブル <code class="literal">t1</code> のパーティションのインデックスサイズを取得します。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT SUM(stat_value) pages, index_name,</code></strong>
       <strong class="userinput"><code>SUM(stat_value)*@@innodb_page_size size</code></strong>
       <strong class="userinput"><code>FROM mysql.innodb_index_stats WHERE table_name like 't1#P%'</code></strong>
       <strong class="userinput"><code>AND stat_name = 'size' GROUP BY index_name;</code></strong>
</pre></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-statistics-estimation"></a>15.8.10.2 非永続的オプティマイザ統計のパラメータの構成</h4></div></div></div><a class="indexterm" name="idm44761359758336"></a><a class="indexterm" name="idm44761359756896"></a><a class="indexterm" name="idm44761359755888"></a><p>
        このセクションでは、非永続オプティマイザ統計を構成する方法について説明します。 オプティマイザ統計は、<code class="literal">innodb_stats_persistent=OFF</code> の場合、または個々のテーブルが <code class="literal">STATS_PERSISTENT=0</code> で作成または変更された場合、ディスクに永続化されません。 かわりに、統計はメモリーに格納され、サーバーの停止時に失われます。 統計は、特定の操作および特定の条件下で定期的に更新されます。 
      </p><p>
        オプティマイザ統計はデフォルトでディスクに永続化され、<code class="literal">innodb_stats_persistent</code> 構成オプションによって有効化されます。 永続的オプティマイザ統計については、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="15.8.10.1 永続的オプティマイザ統計のパラメータの構成">セクション15.8.10.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。 
      </p><h5><a name="innodb-statistics-estimation-update"></a>オプティマイザ統計の更新</h5><p>
        非永続オプティマイザ統計は、次の場合に更新されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">ANALYZE TABLE</code> の実行。
          </p></li><li class="listitem"><p>
            <code class="literal">SHOW TABLE STATUS</code>、<code class="literal">SHOW INDEX</code> を実行するか、<code class="literal">innodb_stats_on_metadata</code> オプションを有効にして <code class="literal">INFORMATION_SCHEMA.TABLES</code> または <code class="literal">INFORMATION_SCHEMA.STATISTICS</code> テーブルをクエリーします。
          </p><p>
            <code class="literal">innodb_stats_on_metadata</code> のデフォルト設定は <code class="literal">OFF</code> です。 <code class="literal">innodb_stats_on_metadata</code> を有効にすると、多数のテーブルまたはインデックスを持つスキーマのアクセス速度が低下し、<code class="literal">InnoDB</code> テーブルを含むクエリーの実行計画の安定性が低下する可能性があります。<code class="literal">innodb_stats_on_metadata</code> は、<code class="literal">SET</code> ステートメントを使用してグローバルに構成されます。 
          </p><pre class="programlisting">SET GLOBAL innodb_stats_on_metadata=ON
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">innodb_stats_on_metadata</code> は、オプティマイザ <a class="link" href="glossary.html#glos_statistics" title="統計">statistics</a> が非永続として構成されている場合 (<code class="literal">innodb_stats_persistent</code> が無効な場合) にのみ適用されます。
            </p></div></li><li class="listitem"><p>
            デフォルトの <code class="option">--auto-rehash</code> オプションを有効にして <span class="command"><strong>mysql</strong></span> クライアントを起動します。 <code class="option">auto-rehash</code> オプションを使用すると、すべての <code class="literal">InnoDB</code> テーブルがオープンされ、オープンしているテーブルの操作によって統計が再計算されます。 
          </p><p>
            <span class="command"><strong>mysql</strong></span> クライアントの起動時間を改善し、統計を更新するには、<code class="option">--disable-auto-rehash</code> オプションを使用して <code class="option">auto-rehash</code> をオフにします。 <code class="option">auto-rehash</code> 機能は、対話ユーザーのためのデータベース、テーブル、およびカラム名の自動名前補完を有効にします。 
          </p></li><li class="listitem"><p>
            最初にテーブルが開かれます。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> は、統計が最後に更新されてから 1 / 16 のテーブルが変更されたことを検出します。
          </p></li></ul></div><h5><a name="idm44761359716304"></a>サンプルページ数の構成</h5><p>
        MySQL クエリーオプティマイザは、インデックスの相対的な<a class="link" href="glossary.html#glos_selectivity" title="選択性">選択性</a>に基づいて、キー分布に関する推定された<a class="link" href="glossary.html#glos_statistics" title="統計">統計</a>を使用して実行計画のためのインデックスを選択します。 <code class="literal">InnoDB</code> でオプティマイザ統計が更新されると、テーブルの各インデックスからランダムページがサンプリングされ、インデックスの <a class="link" href="glossary.html#glos_cardinality" title="カーディナリティー">cardinality</a> が見積もられます。 (この手法は、<a class="link" href="glossary.html#glos_random_dive" title="ランダムダイブ">ランダムダイブ</a>と呼ばれます。) 
      </p><p>
        統計の推定値の品質を制御する (それにより、クエリーオプティマイザへの情報を改善する) ために、パラメータ <code class="literal">innodb_stats_transient_sample_pages</code> を使用して、サンプリングされるページの数を変更できます。 サンプリングされるページのデフォルト数は 8 です。これは、正確な推定値を生成するには十分ではなく、クエリーオプティマイザによる不適切なインデックス選択につながる可能性があります。 この手法は、大きなテーブルや、<a class="link" href="glossary.html#glos_join" title="結合">結合</a>で使用されるテーブルの場合に特に重要です。 このようなテーブルに対する不必要な<a class="link" href="glossary.html#glos_full_table_scan" title="テーブルの完全スキャン">フルテーブルスキャン</a>が、パフォーマンスの重大な問題になる場合があります。 このようなクエリーのチューニングのヒントは、<a class="xref" href="optimization.html#table-scan-avoidance" title="8.2.1.23 全テーブルスキャンの回避">セクション8.2.1.23「全テーブルスキャンの回避」</a> を参照してください。<code class="literal">innodb_stats_transient_sample_pages</code> は、実行時に設定できるグローバルパラメータです。 
      </p><p>
        <code class="literal">innodb_stats_persistent=0</code> である場合は、<code class="literal">innodb_stats_transient_sample_pages</code> の値がすべての <code class="literal">InnoDB</code> テーブルおよびインデックスのインデックスサンプリングに影響を与えます。 インデックスサンプルサイズを変更する場合、次のような大きな影響がある可能性があることに注意してください: 

        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              1 や 2 などの小さな値では、カーディナリティーの不正確な推定値が生成される可能性があります。
            </p></li><li class="listitem"><p>
              <code class="literal">innodb_stats_transient_sample_pages</code> 値を大きくすると、必要なディスク読み取りが増える可能性があります。 8 よりもはるかに大きい値 (100 など) を指定すると、テーブルのオープンまたは <code class="literal">SHOW TABLE STATUS</code> の実行にかかる時間が大幅に遅くなる可能性があります。 
            </p></li><li class="listitem"><p>
              オプティマイザが、インデックスの選択性の異なる推定値に基づいて、非常に異なるクエリー計画を選択する可能性があります。
            </p></li></ul></div><p>
      </p><p>
        あるシステムで <code class="literal">innodb_stats_transient_sample_pages</code> のどのような値が最適に機能したとしても、このオプションを設定し、その値のままにします。 過剰な I/O を必要とせずに、データベース内のすべてのテーブルに対して適度に正確な推定値を生成する値を選択してください。 統計は <code class="literal">ANALYZE TABLE</code> の実行時以外のさまざまな時間に自動的に再計算されるため、インデックスのサンプルサイズを増やし、<code class="literal">ANALYZE TABLE</code> を実行してから、サンプルサイズをふたたび減らしても意味がありません。 
      </p><p>
        通常、小さいテーブルでは、大きいテーブルよりも必要なインデックスサンプルが少なくなります。 データベースに多数の大きなテーブルが含まれている場合は、ほとんどが小さなテーブルである場合より大きな <code class="literal">innodb_stats_transient_sample_pages</code> 値を使用することを考慮してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-analyze-table-complexity"></a>15.8.10.3 InnoDB テーブルに対する ANALYZE TABLE の複雑さの推定</h4></div></div></div><p>
        <code class="literal">InnoDB</code> テーブルに対する <code class="literal">ANALYZE TABLE</code> の複雑さは、次のものに依存します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">innodb_stats_persistent_sample_pages</code> で定義される、サンプリングされるページの数。
          </p></li><li class="listitem"><p>
            テーブル内のインデックス付きカラムの数
          </p></li><li class="listitem"><p>
            パーティションの数。 テーブルにパーティションが存在しない場合、パーティションの数は 1 であるとみなされます。 
          </p></li></ul></div><p>
        これらのパラメータを使用すると、<code class="literal">ANALYZE TABLE</code> の複雑さを推定するための概略の計算式は次のようになります。
      </p><p>
        <code class="literal">innodb_stats_persistent_sample_pages</code> の値 * テーブル内のインデックス付きカラムの数 * パーティションの数
      </p><p>
        通常は、この結果の値が大きいほど、<code class="literal">ANALYZE TABLE</code> の実行時間も大きくなります。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">innodb_stats_persistent_sample_pages</code> は、グローバルレベルでサンプリングされるページの数を定義します。 個々のテーブルのサンプリングされるページの数を設定するには、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> で <code class="literal">STATS_SAMPLE_PAGES</code> オプションを使用します。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="15.8.10.1 永続的オプティマイザ統計のパラメータの構成">セクション15.8.10.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。 
        </p><p>
          <code class="literal">innodb_stats_persistent=OFF</code> である場合、サンプリングされるページの数は <code class="literal">innodb_stats_transient_sample_pages</code> で定義されます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-statistics-estimation" title="15.8.10.2 非永続的オプティマイザ統計のパラメータの構成">セクション15.8.10.2「非永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。 
        </p></div><p>
        <code class="literal">ANALYZE TABLE</code> の複雑さを推定するためのより詳細なアプローチを示すために、次の例を考えてみます。
      </p><p>
        <a class="ulink" href="http://en.wikipedia.org/wiki/Big_O_notation" target="_top">ビッグオー表記</a>では、<code class="literal">ANALYZE TABLE</code> の複雑さは次のように記述されます。
      </p><pre class="programlisting"> O(n_sample
  * (n_cols_in_uniq_i
     + n_cols_in_non_uniq_i
     + n_cols_in_pk * (1 + n_non_uniq_i))
  * n_part)
</pre><p>
        ここでは:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">n_sample</code> は、サンプリングされるページの数 (<code class="literal">innodb_stats_persistent_sample_pages</code> で定義されます)
          </p></li><li class="listitem"><p>
            <code class="literal">n_cols_in_uniq_i</code> は、すべての一意のインデックス内のすべてのカラムの総数 (主キーカラムはカウントしない)
          </p></li><li class="listitem"><p>
            <code class="literal">n_cols_in_non_uniq_i</code> は、すべての非一意インデックスのすべてのカラムの合計数です
          </p></li><li class="listitem"><p>
            <code class="literal">n_cols_in_pk</code> は、主キー内のカラム数 (主キーが定義されていない場合、<code class="literal">InnoDB</code> は単一カラムの主キーを内部的に作成します)
          </p></li><li class="listitem"><p>
            <code class="literal">n_non_uniq_i</code> は、テーブル内の一意でないインデックスの数です
          </p></li><li class="listitem"><p>
            <code class="literal">n_part</code> は、パーティションの数。 パーティションが定義されていない場合、そのテーブルは単一パーティションであるとみなされます。 
          </p></li></ul></div><p>
        ここで、主キー (2 つのカラム)、一意インデックス (2 つのカラム) および 2 つの非一意インデックス (それぞれ 2 つのカラム) を持つ次のテーブル (テーブル <code class="literal">t</code>) について考えてみます:
      </p><pre class="programlisting">CREATE TABLE t (
  a INT,
  b INT,
  c INT,
  d INT,
  e INT,
  f INT,
  g INT,
  h INT,
  PRIMARY KEY (a, b),
  UNIQUE KEY i1uniq (c, d),
  KEY i2nonuniq (e, f),
  KEY i3nonuniq (g, h)
);
</pre><p>
        上で説明したアルゴリズムに必要なカラムとインデックスデータについて、テーブル <code class="literal">t</code> の <code class="literal">mysql.innodb_index_stats</code> 永続的インデックス統計テーブルにクエリーします。 <code class="literal">n_diff_pfx%</code> の統計には、各インデックスに対してカウントされるカラムが示されます。 たとえば、カラム <code class="literal">a</code> および <code class="literal">b</code> は、主キーのインデックスに対してカウントされます。 一意でないインデックスの場合、主キーカラム (a,b) は、ユーザー定義カラムに加えてカウントされます。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">InnoDB</code> 永続的統計テーブルの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="15.8.10.1 永続的オプティマイザ統計のパラメータの構成">セクション15.8.10.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。
        </p></div><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT index_name, stat_name, stat_description</code></strong>
       <strong class="userinput"><code>FROM mysql.innodb_index_stats WHERE</code></strong>
       <strong class="userinput"><code>database_name='test' AND</code></strong>
       <strong class="userinput"><code>table_name='t' AND</code></strong>
       <strong class="userinput"><code>stat_name like 'n_diff_pfx%';</code></strong>
  +------------+--------------+------------------+
  | index_name | stat_name    | stat_description |
  +------------+--------------+------------------+
  | PRIMARY    | n_diff_pfx01 | a                |
  | PRIMARY    | n_diff_pfx02 | a,b              |
  | i1uniq     | n_diff_pfx01 | c                |
  | i1uniq     | n_diff_pfx02 | c,d              |
  | i2nonuniq  | n_diff_pfx01 | e                |
  | i2nonuniq  | n_diff_pfx02 | e,f              |
  | i2nonuniq  | n_diff_pfx03 | e,f,a            |
  | i2nonuniq  | n_diff_pfx04 | e,f,a,b          |
  | i3nonuniq  | n_diff_pfx01 | g                |
  | i3nonuniq  | n_diff_pfx02 | g,h              |
  | i3nonuniq  | n_diff_pfx03 | g,h,a            |
  | i3nonuniq  | n_diff_pfx04 | g,h,a,b          |
  +------------+--------------+------------------+
</pre><p>
        上に示したインデックス統計データとテーブル定義に基づいて、次の値を確認できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">n_cols_in_uniq_i</code> (すべての一意のインデックス内のすべてのカラムの総数、主キーカラムはカウントしない) は 2 (<code class="literal">c</code> および <code class="literal">d</code>)
          </p></li><li class="listitem"><p>
            <code class="literal">n_cols_in_non_uniq_i</code>、一意でないすべてのインデックスのすべてのカラムの合計数は 4 (<code class="literal">e</code>, <code class="literal">f</code>, <code class="literal">g</code> および <code class="literal">h</code>) です
          </p></li><li class="listitem"><p>
            <code class="literal">n_cols_in_pk</code> (主キー内のカラム数) は 2 (<code class="literal">a</code> および <code class="literal">b</code>)
          </p></li><li class="listitem"><p>
            テーブル内の一意でないインデックスの数である <code class="literal">n_non_uniq_i</code> は 2 (<code class="literal">i2nonuniq</code> および <code class="literal">i3nonuniq</code>) です
          </p></li><li class="listitem"><p>
            <code class="literal">n_part</code> (パーティションの数) は 1。
          </p></li></ul></div><p>
        これで、スキャンされるリーフページの数を決定するために <code class="literal">innodb_stats_persistent_sample_pages</code> * (2 + 4 + 2 * (1 + 2)) * 1 を計算できます。 <code class="literal">innodb_stats_persistent_sample_pages</code> が <code class="literal">20</code> のデフォルト値に設定されており、かつページサイズがデフォルトの 16 <code class="literal">KiB</code> (<code class="literal">innodb_page_size</code>=16384) である場合は、テーブル <code class="literal">t</code> に対して 20 * 12 * 16384 <code class="literal">バイト</code>、つまり約 4 <code class="literal">MiB</code> が読み取られると推定できます。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          一部のリーフページはすでにバッファープール内にキャッシュされている可能性があるため、4 <code class="literal">MiB</code> のすべてがディスクから読み取られるとは限りません。
        </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="index-page-merge-threshold"></a>15.8.11 インデックスページのマージしきい値の構成</h3></div></div></div><p>
      インデックスページの <code class="literal">MERGE_THRESHOLD</code> 値を構成できます。 行が削除されたとき、または <code class="literal">UPDATE</code> 操作によって行が短縮されたときに、インデックスページの <span class="quote">「<span class="quote">page-full</span>」</span> 割合が <code class="literal">MERGE_THRESHOLD</code> 値を下回った場合、<code class="literal">InnoDB</code> はインデックスページを隣接するインデックスページとマージしようとします。 デフォルトの <code class="literal">MERGE_THRESHOLD</code> 値は 50 で、これは以前にハードコードされた値です。 <code class="literal">MERGE_THRESHOLD</code> の最小値は 1 で、最大値は 50 です。 
    </p><p>
      インデックスページの <span class="quote">「<span class="quote">page-full</span>」</span> 割合がデフォルトの <code class="literal">MERGE_THRESHOLD</code> 設定である 50% を下回ると、<code class="literal">InnoDB</code> はインデックスページを隣接するページとマージしようとします。 両方のページが 50% に近い場合、ページがマージされた直後にページ分割が発生する可能性があります。 このマージ分割動作が頻繁に発生する場合は、パフォーマンスに悪影響を与える可能性があります。 頻繁なマージスプリットを回避するには、<code class="literal">InnoDB</code> が <span class="quote">「<span class="quote">page-full</span>」</span> の低い割合でページマージを試行するように、<code class="literal">MERGE_THRESHOLD</code> 値を小さくします。 ページフルの割合が低いページをマージすると、インデックスページの空き領域が増え、マージ分割の動作を減らすことができます。 
    </p><p>
      インデックスページ用の <code class="literal">MERGE_THRESHOLD</code> は、テーブルまたは個々のインデックスに対して定義できます。 個々のインデックスに定義された <code class="literal">MERGE_THRESHOLD</code> 値は、テーブルに定義された <code class="literal">MERGE_THRESHOLD</code> 値よりも優先されます。 未定義の場合、<code class="literal">MERGE_THRESHOLD</code> 値はデフォルトで 50 に設定されます。 
    </p><h4><a name="idm44761359592544"></a>テーブルに対する MERGE_THRESHOLD の設定</h4><p>
      <code class="literal">CREATE TABLE</code> ステートメントの <em class="replaceable"><code>table_option</code></em> <code class="literal">COMMENT</code> 句を使用して、テーブルの <code class="literal">MERGE_THRESHOLD</code> 値を設定できます。 例: 
    </p><pre class="programlisting">CREATE TABLE t1 (
   id INT,
  KEY id_index (id)
) COMMENT='MERGE_THRESHOLD=45';
</pre><p>
      <code class="literal">ALTER TABLE</code> で <em class="replaceable"><code>table_option</code></em> <code class="literal">COMMENT</code> 句を使用して、既存のテーブルの <code class="literal">MERGE_THRESHOLD</code> 値を設定することもできます:
    </p><pre class="programlisting">CREATE TABLE t1 (
   id INT,
  KEY id_index (id)
);

ALTER TABLE t1 COMMENT='MERGE_THRESHOLD=40';
</pre><h4><a name="idm44761359583008"></a>個々のインデックスに対する MERGE_THRESHOLD の設定</h4><p>
      個々のインデックスの <code class="literal">MERGE_THRESHOLD</code> 値を設定するには、次の例に示すように、<code class="literal">CREATE TABLE</code>、<code class="literal">ALTER TABLE</code> または <code class="literal">CREATE INDEX</code> で <em class="replaceable"><code>index_option</code></em> <code class="literal">COMMENT</code> 句を使用できます:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">CREATE TABLE</code> を使用した個々のインデックスに対する <code class="literal">MERGE_THRESHOLD</code> の設定:
        </p><pre class="programlisting">CREATE TABLE t1 (
   id INT,
  KEY id_index (id) COMMENT 'MERGE_THRESHOLD=40'
);
</pre></li><li class="listitem"><p>
          <code class="literal">ALTER TABLE</code> を使用した個々のインデックスに対する <code class="literal">MERGE_THRESHOLD</code> の設定:
        </p><pre class="programlisting">CREATE TABLE t1 (
   id INT,
  KEY id_index (id)
);

ALTER TABLE t1 DROP KEY id_index;
ALTER TABLE t1 ADD KEY id_index (id) COMMENT 'MERGE_THRESHOLD=40';
</pre></li><li class="listitem"><p>
          <code class="literal">CREATE INDEX</code> を使用した個々のインデックスに対する <code class="literal">MERGE_THRESHOLD</code> の設定:
        </p><pre class="programlisting">CREATE TABLE t1 (id INT);
CREATE INDEX id_index ON t1 (id) COMMENT 'MERGE_THRESHOLD=40';
</pre></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">GEN_CLUST_INDEX</code> のインデックスレベルで <code class="literal">MERGE_THRESHOLD</code> 値を変更することはできません。これは、<code class="literal">InnoDB</code> テーブルが主キーまたは一意キーインデックスなしで作成されたときに <code class="literal">InnoDB</code> によって作成されるクラスタインデックスです。 <code class="literal">GEN_CLUST_INDEX</code> の <code class="literal">MERGE_THRESHOLD</code> 値は、テーブルに <code class="literal">MERGE_THRESHOLD</code> を設定することによってのみ変更できます。 
      </p></div><h4><a name="idm44761359559072"></a>インデックスの MERGE_THRESHOLD 値のクエリー</h4><p>
      インデックスの現在の <code class="literal">MERGE_THRESHOLD</code> 値は、<code class="literal">INNODB_INDEXES</code> テーブルをクエリーすることで取得できます。 例: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_INDEXES WHERE NAME='id_index' \G</code></strong>
*************************** 1. row ***************************
       INDEX_ID: 91
           NAME: id_index
       TABLE_ID: 68
           TYPE: 0
       N_FIELDS: 1
        PAGE_NO: 4
          SPACE: 57
MERGE_THRESHOLD: 40
</pre><p>
      <em class="replaceable"><code>table_option</code></em> <code class="literal">COMMENT</code> 句を使用して明示的に定義されている場合は、<code class="literal">SHOW CREATE TABLE</code> を使用してテーブルの <code class="literal">MERGE_THRESHOLD</code> 値を表示できます:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t2 \G</code></strong>
*************************** 1. row ***************************
       Table: t2
Create Table: CREATE TABLE `t2` (
  `id` int(11) DEFAULT NULL,
  KEY `id_index` (`id`) COMMENT 'MERGE_THRESHOLD=40'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        インデックスレベルで定義された <code class="literal">MERGE_THRESHOLD</code> 値は、テーブルに定義された <code class="literal">MERGE_THRESHOLD</code> 値よりも優先されます。 未定義の場合、<code class="literal">MERGE_THRESHOLD</code> はデフォルトで 50% (<code class="literal">MERGE_THRESHOLD=50</code>、以前にハードコードされた値) に設定されます。 
      </p></div><p>
      同様に、<em class="replaceable"><code>index_option</code></em> <code class="literal">COMMENT</code> 句を使用して明示的に定義されている場合は、<code class="literal">SHOW INDEX</code> を使用してインデックスの <code class="literal">MERGE_THRESHOLD</code> 値を表示できます:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW INDEX FROM t2 \G</code></strong>
*************************** 1. row ***************************
        Table: t2
   Non_unique: 1
     Key_name: id_index
 Seq_in_index: 1
  Column_name: id
    Collation: A
  Cardinality: 0
     Sub_part: NULL
       Packed: NULL
         Null: YES
   Index_type: BTREE
      Comment:
Index_comment: MERGE_THRESHOLD=40
</pre><h4><a name="idm44761359539264"></a>MERGE_THRESHOLD 設定の影響の測定</h4><p>
      <code class="literal">INNODB_METRICS</code> テーブルには、インデックスページのマージに対する <code class="literal">MERGE_THRESHOLD</code> 設定の影響を測定するために使用できる 2 つのカウンタが用意されています。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT NAME, COMMENT FROM INFORMATION_SCHEMA.INNODB_METRICS</code></strong>
       <strong class="userinput"><code>WHERE NAME like '%index_page_merge%';</code></strong>
+-----------------------------+----------------------------------------+
| NAME                        | COMMENT                                |
+-----------------------------+----------------------------------------+
| index_page_merge_attempts   | Number of index page merge attempts    |
| index_page_merge_successful | Number of successful index page merges |
+-----------------------------+----------------------------------------+
</pre><p>
      <code class="literal">MERGE_THRESHOLD</code> 値を下げる場合の目標は次のとおりです:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ページマージの試行回数が少なく、ページマージが成功しました
        </p></li><li class="listitem"><p>
          同様の数のページマージ試行と成功したページマージ
        </p></li></ul></div><p>
      <code class="literal">MERGE_THRESHOLD</code> 設定が小さすぎると、空のページ領域が過剰になるため、データファイルが大きくなる可能性があります。
    </p><p>
      <code class="literal">INNODB_METRICS</code> カウンタの使用の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-information-schema-metrics-table" title="15.15.6 InnoDB INFORMATION_SCHEMA メトリックテーブル">セクション15.15.6「InnoDB INFORMATION_SCHEMA メトリックテーブル」</a> を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-dedicated-server"></a>15.8.12 専用 MySQL Server の自動構成の有効化</h3></div></div></div><p>
      <code class="literal">innodb_dedicated_server</code> が有効な場合、<code class="literal">InnoDB</code> は次の変数を自動的に構成します:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">innodb_buffer_pool_size</code>
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_log_file_size</code>
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_log_files_in_group</code> (MySQL 8.0.14 の時点)
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_flush_method</code>
        </p></li></ul></div><p>
      MySQL インスタンスが、使用可能なすべてのシステムリソースを使用できる専用サーバーに存在する場合にのみ、<code class="literal">innodb_dedicated_server</code> を有効にすることを検討してください。 たとえば、MySQL のみを実行する Docker コンテナまたは専用 VM で MySQL Server を実行する場合は、有効化を検討してください。 MySQL インスタンスが他のアプリケーションとシステムリソースを共有している場合、<code class="literal">innodb_dedicated_server</code> を有効にすることはお薦めしません。 
    </p><p>
      次の情報では、各変数が自動的に構成される方法について説明します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">innodb_buffer_pool_size</code>
        </p><p>
          バッファプールサイズは、サーバーで検出されたメモリー量に従って構成されます。
        </p><div class="table"><a name="dedicated-server-buffer-pool-size"></a><p class="title"><b>表 15.8 自動的に構成されるバッファプールサイズ</b></p><div class="table-contents"><table summary="The first column shows the amount of detected server memory. The second column shows the automatically configured buffer pool size."><col style="width: 50%"><col style="width: 50%"><thead><tr>
              <th>検出されたサーバーメモリー</th>
              <th>バッファプールサイズ</th>
            </tr></thead><tbody><tr>
              <td>1GB 未満</td>
              <td>128MiB (デフォルト値)</td>
            </tr><tr>
              <td>1GB から 4GB</td>
              <td><em class="replaceable"><code>detected server memory</code></em> * 0.5</td>
            </tr><tr>
              <td>4GB を超える</td>
              <td><em class="replaceable"><code>detected server memory</code></em> * 0.75</td>
            </tr></tbody></table></div></div><br class="table-break"></li><li class="listitem"><p>
          <code class="literal">innodb_log_file_size</code>
        </p><p>
          MySQL 8.0.14 では、ログファイルサイズは自動的に構成されたバッファプールサイズに従って構成されます。
        </p><div class="table"><a name="dedicated-server-log-file-size"></a><p class="title"><b>表 15.9 自動的に構成されるログファイルサイズ</b></p><div class="table-contents"><table summary="The first column shows the buffer pool size. The second column shows the automatically configured log file size."><col style="width: 50%"><col style="width: 50%"><thead><tr>
              <th>バッファプールサイズ</th>
              <th>ログファイルのサイズ</th>
            </tr></thead><tbody><tr>
              <td>8GB 未満</td>
              <td>512MiB</td>
            </tr><tr>
              <td>8GB から 128GB</td>
              <td>1024MiB</td>
            </tr><tr>
              <td>128GB を超える</td>
              <td>2048MiB</td>
            </tr></tbody></table></div></div><br class="table-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            MySQL 8.0.14 より前は、次に示すように、<code class="literal">innodb_log_file_size</code> 変数はサーバーで検出されたメモリー量に従って自動的に構成されていました:
          </p><div class="table"><a name="dedicated-server-log-file-size-old"></a><p class="title"><b>表 15.10 自動的に構成されるログファイルサイズ (MySQL 8.0.13 以前)</b></p><div class="table-contents"><table summary="The first column shows the amount of detected server memory. The second column shows the automatically configured log file size based on the amount of detected server memory."><col style="width: 50%"><col style="width: 50%"><thead><tr>
                <th>検出されたサーバーメモリー</th>
                <th>ログファイルのサイズ</th>
              </tr></thead><tbody><tr>
                <td>&lt; 1GB</td>
                <td>48MiB (デフォルト値)</td>
              </tr><tr>
                <td>&lt;= 4GB</td>
                <td>128MiB</td>
              </tr><tr>
                <td>&lt;= 8GB</td>
                <td>512MiB</td>
              </tr><tr>
                <td>&lt;= 16GB</td>
                <td>1024MiB</td>
              </tr><tr>
                <td>&gt; 16GB</td>
                <td>2048MiB</td>
              </tr></tbody></table></div></div><br class="table-break"></div></li><li class="listitem"><p>
          <code class="literal">innodb_log_files_in_group</code>
        </p><p>
          ログファイルの数は、自動的に構成されたバッファプールサイズ (GB) に従って構成されます。 <code class="literal">innodb_log_files_in_group</code> 変数の自動構成が MySQL 8.0.14 に追加されました。 
        </p><div class="table"><a name="dedicated-server-log-files"></a><p class="title"><b>表 15.11 自動的に構成されるログファイルの数</b></p><div class="table-contents"><table summary="The first column shows the buffer pool size. The second column shows the automatically configured number of log files."><col style="width: 50%"><col style="width: 50%"><thead><tr>
              <th>バッファプールサイズ</th>
              <th>ログファイル数</th>
            </tr></thead><tbody><tr>
              <td>8GB 未満</td>
              <td>ROUND(<em class="replaceable"><code>buffer pool size</code></em>)</td>
            </tr><tr>
              <td>8GB から 128GB</td>
              <td>ROUND(<em class="replaceable"><code>buffer pool size</code></em> * 0.75)</td>
            </tr><tr>
              <td>128GB を超える</td>
              <td>64</td>
            </tr></tbody></table></div></div><br class="table-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            丸められたバッファープールサイズの値が 2G バイト未満の場合、<code class="literal">innodb_log_files_in_group</code> の最小値 2 が適用されます。
          </p></div></li><li class="listitem"><p>
          <code class="literal">innodb_flush_method</code>
        </p><p>
          <code class="literal">innodb_dedicated_server</code> が有効になっている場合、flush メソッドは <code class="literal">O_DIRECT_NO_FSYNC</code> に設定されます。 <code class="literal">O_DIRECT_NO_FSYNC</code> 設定を使用できない場合は、デフォルトの <code class="literal">innodb_flush_method</code> 設定が使用されます。 
        </p><p>
          <code class="literal">InnoDB</code> は、I/O,のフラッシュ中に <code class="literal">O_DIRECT</code> を使用しますが、書込み操作のたびに <code class="literal">fsync()</code> システムコールをスキップします。
        </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
            MySQL 8.0.14 より前では、この設定は XFS や EXT4 などのファイルシステムには適していません。これらのファイルシステムでは、<code class="literal">fsync()</code> システムコールを使用してファイルシステムメタデータの変更を同期する必要があります。
          </p><p>
            MySQL 8.0.14 の時点では、<code class="literal">fsync()</code> は、新しいファイルの作成後、ファイルサイズの増加後およびファイルのクローズ後にコールされ、ファイルシステムメタデータの変更が確実に同期されます。 各書込み操作の後も、<code class="literal">fsync()</code> システムコールはスキップされます。 
          </p><p>
            redo ログファイルとデータファイルが異なるストレージデバイスに存在し、データファイルの書込みがバッテリバックされていないデバイスキャッシュからフラッシュされる前に予期しない終了が発生した場合、データが失われる可能性があります。 redo ログファイルおよびデータファイルに別の記憶域デバイスを使用する場合、およびデータファイルがバッテリバックアップされていないキャッシュを持つデバイスに存在する場合は、かわりに <code class="literal">O_DIRECT</code> を使用します。 
          </p></div></li></ul></div><p>
      自動的に構成されたオプションがオプションファイルまたは他の場所で明示的に構成されている場合は、明示的に指定された設定が使用され、次のような起動警告が <code class="literal">stderr</code> に出力されます:
    </p><p>
      <span class="errortext">[警告] [000000] InnoDB: innodb_buffer_pool_size=134217728 が明示的に指定されているため、innodb_buffer_pool_size ではオプション innodb_dedicated_server は無視されます。</span>
    </p><p>
      あるオプションを明示的に構成しても、他のオプションの自動構成は妨げられません。
    </p><p>
      <code class="literal">innodb_dedicated_server</code> が有効で、<code class="literal">innodb_buffer_pool_size</code> がオプションファイルで明示的に構成されている場合でも、<code class="literal">innodb_log_file_size</code> および <code class="literal">innodb_log_files_in_group</code> は、バッファプールのサイズの構成に使用されていなくても、サーバーで検出されたメモリー量に基づいて計算されたバッファプールサイズ値に基づいて自動的に構成されます。
    </p><p>
      自動的に構成された設定は、MySQL サーバーが起動されるたびに必要に応じて評価および再構成されます。
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-compression"></a>15.9 InnoDB のテーブルおよびページの圧縮</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-table-compression">15.9.1 InnoDB テーブルの圧縮</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-page-compression">15.9.2 InnoDB ページ圧縮</a></span></dt></dl></div><a class="indexterm" name="idm44761359415792"></a><a class="indexterm" name="idm44761359414368"></a><p>
    このセクションでは、<code class="literal">InnoDB</code> テーブルの圧縮および <code class="literal">InnoDB</code> ページの圧縮機能について説明します。 ページ圧縮機能は、<a class="link" href="glossary.html#glos_transparent_page_compression" title="透過的ページ圧縮">transparent page compression</a> とも呼ばれます。 
  </p><p>
    <code class="literal">InnoDB</code> の圧縮機能を使用すると、データが圧縮形式で格納されるテーブルを作成できます。 圧縮を使用すると、生のパフォーマンスと拡張性の両方を改善する際に役立つことがあります。 圧縮とは、ディスクとメモリー間で転送されるデータの量が少なくなり、ディスク上とメモリー内で占有される領域の量が少なくなることを意味します。 インデックスデータも圧縮されるため、<a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">セカンダリインデックス</a>を含むテーブルでは利点も増幅されます。 <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> ストレージデバイスは、<a class="link" href="glossary.html#glos_hdd" title="HDD">HDD</a> デバイスよりも容量が小さくなる傾向があるため、圧縮が特に重要となる可能性があります。 
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-table-compression"></a>15.9.1 InnoDB テーブルの圧縮</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-background">15.9.1.1 テーブル圧縮の概要</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-usage">15.9.1.2 圧縮テーブルの作成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-tuning">15.9.1.3 InnoDB テーブルの圧縮の調整</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-tuning-monitoring">15.9.1.4 実行時の InnoDB テーブル圧縮の監視</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-internals">15.9.1.5 InnoDB テーブルでの圧縮の動作</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-compression-oltp">15.9.1.6 OLTP ワークロードの圧縮</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-syntax-warnings">15.9.1.7 SQL 圧縮構文の警告とエラー</a></span></dt></dl></div><p>
      このセクションでは、<a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file_per_table</a> テーブルスペースまたは <a class="link" href="glossary.html#glos_general_tablespace" title="一般テーブルスペース">general tablespaces</a> に存在する <code class="literal">InnoDB</code> テーブルでサポートされる <code class="literal">InnoDB</code> テーブルの圧縮について説明します。 テーブル圧縮は、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> で <code class="literal">ROW_FORMAT=COMPRESSED</code> 属性を使用して有効にします。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-compression-background"></a>15.9.1.1 テーブル圧縮の概要</h4></div></div></div><a class="indexterm" name="idm44761359396496"></a><p>
        プロセッサおよびキャッシュメモリーは、ディスクストレージデバイスよりも速度が上昇しているため、多くのワークロードが<a class="link" href="glossary.html#glos_disk_bound" title="ディスクバウンド">ディスクバウンド</a>になります。 データ<a class="link" href="glossary.html#glos_compression" title="圧縮">圧縮</a>を使用すると、データベースのサイズが小さくなり、I/O が削減され、スループットが改善されますが、CPU 使用率が上昇するという少しの犠牲が伴います。 圧縮は、頻繁に使用されるデータをメモリー内に保持するために十分な RAM が搭載されたシステム上で、読み取り負荷の高いアプリケーションを実行する際に、特に有効です。 
      </p><p>
        <code class="literal">ROW_FORMAT=COMPRESSED</code> で作成された <code class="literal">InnoDB</code> テーブルでは、構成された <code class="literal">innodb_page_size</code> 値より小さいディスク上の <a class="link" href="glossary.html#glos_page_size" title="page size">page size</a> を使用できます。 ページが小さいほど、ディスクから読み取られる I/O とディスクに書き込まれる I/O が少なくなるため、<a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> デバイスを使用する際に、特に有効です。 
      </p><p>
        圧縮されたページサイズは、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> <code class="literal">KEY_BLOCK_SIZE</code> パラメータを使用して指定します。 システムテーブルスペースに圧縮テーブルを格納できないため、異なるページサイズでは、テーブルを <a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">system tablespace</a> ではなく <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースまたは <a class="link" href="glossary.html#glos_general_tablespace" title="一般テーブルスペース">general tablespace</a> に配置する必要があります。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-file-per-table-tablespaces" title="15.6.3.2 File-Per-Table テーブルスペース">セクション15.6.3.2「File-Per-Table テーブルスペース」</a>および<a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="15.6.3.3 一般テーブルスペース">セクション15.6.3.3「一般テーブルスペース」</a>を参照してください。 
      </p><p>
        圧縮レベルは、<code class="literal">KEY_BLOCK_SIZE</code> の値に関係なく同じです。 <code class="literal">KEY_BLOCK_SIZE</code> に小さい値を指定するほど、徐々にページが小さくなるという I/O の利点が得られます。 ただし、小さすぎる値を指定すると、各ページ内に複数の行を収容できるほど十分にデータ値を圧縮できない場合に、ページを再編成するための追加のオーバーヘッドが発生します。 そのインデックスごとのキーカラムの長さに基づいて、どのくらい小さい <code class="literal">KEY_BLOCK_SIZE</code> をテーブルに指定できるのかについて、ハード制限が課されています。 小さすぎる値を指定すると、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントが失敗します。 
      </p><p>
        バッファープールには、圧縮済みデータが <code class="literal">KEY_BLOCK_SIZE</code> の値に基づいたページサイズの小さなページで保持されます。 MySQL では、カラム値を抽出または更新するために、圧縮されていないデータを含む未圧縮のページもバッファプールに作成されます。 バッファープール内では、非圧縮ページへの更新が同等の圧縮済みページに再度書き込まれます。 圧縮済みページと非圧縮ページの両方の追加データが収容されるように、バッファーページのサイズを変更する必要がある場合もあります。ただし、非圧縮のページは、領域が必要になるとバッファープールから<a class="link" href="glossary.html#glos_eviction" title="エビクション">解放</a>され、次のアクセス時に再度圧縮が解除されます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-compression-usage"></a>15.9.1.2 圧縮テーブルの作成</h4></div></div></div><a class="indexterm" name="idm44761359367920"></a><a class="indexterm" name="idm44761359365728"></a><a class="indexterm" name="idm44761359364752"></a><a class="indexterm" name="idm44761359362976"></a><a class="indexterm" name="idm44761359361888"></a><p>
        圧縮テーブルは、<a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースまたは <a class="link" href="glossary.html#glos_general_tablespace" title="一般テーブルスペース">general tablespaces</a> で作成できます。 テーブル圧縮は、InnoDB <a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">system tablespace</a> では使用できません。 システムテーブルスペース (領域 0、<a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibdata files</a>) には、ユーザーが作成したテーブルを含めることができますが、圧縮されない内部システムデータも含まれます。 したがって、圧縮は file-per-table または general テーブルスペースに格納されているテーブル (およびインデックス) にのみ適用されます。 
      </p><h5><a name="idm44761359355024"></a>File-Per-Table テーブルスペースでの圧縮テーブルの作成</h5><p>
        file-per-table テーブルスペースに圧縮テーブルを作成するには、<code class="literal">innodb_file_per_table</code> を有効にする必要があります (デフォルト)。 このパラメータは、MySQL 構成ファイル (<code class="filename">my.cnf</code> または <code class="filename">my.ini</code>) で設定するか、<code class="literal">SET</code> ステートメントを使用して動的に設定できます。 
      </p><p>
        <code class="literal">innodb_file_per_table</code> オプションの構成後、<code class="literal">CREATE TABLE</code> ステートメントまたは <code class="literal">ALTER TABLE</code> ステートメントで <code class="literal">ROW_FORMAT=COMPRESSED</code> 句または <code class="literal">KEY_BLOCK_SIZE</code> 句 (あるいはその両方) を指定して、file-per-table テーブルスペースに圧縮テーブルを作成します。
      </p><p>
        たとえば、次のステートメントを使用できます:
      </p><pre class="programlisting">SET GLOBAL innodb_file_per_table=1;
CREATE TABLE t1
 (c1 INT PRIMARY KEY)
 ROW_FORMAT=COMPRESSED
 KEY_BLOCK_SIZE=8;
</pre><h5><a name="idm44761359342736"></a>一般テーブルスペースでの圧縮テーブルの作成</h5><p>
        一般的なテーブルスペースに圧縮テーブルを作成するには、テーブルスペースの作成時に指定される一般的なテーブルスペースに対して <code class="literal">FILE_BLOCK_SIZE</code> を定義する必要があります。 <code class="literal">FILE_BLOCK_SIZE</code> 値は、<code class="literal">innodb_page_size</code> 値に関連する有効な圧縮ページサイズである必要があり、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> <code class="literal">KEY_BLOCK_SIZE</code> 句で定義された圧縮テーブルのページサイズは <code class="literal">FILE_BLOCK_SIZE/1024</code> と同じである必要があります。 たとえば、<code class="literal">innodb_page_size=16384</code> および <code class="literal">FILE_BLOCK_SIZE=8192</code> の場合、テーブルの <code class="literal">KEY_BLOCK_SIZE</code> は 8 である必要があります。 詳細は、<a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="15.6.3.3 一般テーブルスペース">セクション15.6.3.3「一般テーブルスペース」</a>を参照してください。 
      </p><p>
        次の例は、一般的なテーブルスペースの作成および圧縮テーブルの追加を示しています。 この例では、デフォルトの <code class="literal">innodb_page_size</code> が 16K であると想定しています。 8192 の <code class="literal">FILE_BLOCK_SIZE</code> では、圧縮テーブルの <code class="literal">KEY_BLOCK_SIZE</code> が 8 である必要があります。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts2` ADD DATAFILE 'ts2.ibd' FILE_BLOCK_SIZE = 8192 Engine=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t4 (c1 INT PRIMARY KEY) TABLESPACE ts2 ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=8;</code></strong>
</pre><h5><a name="idm44761359325792"></a>メモ</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL 8.0 では、圧縮テーブルのテーブルスペースファイルは <code class="literal">InnoDB</code> ページサイズではなく物理ページサイズを使用して作成されるため、空の圧縮テーブルのテーブルスペースファイルの初期サイズは以前の MySQL リリースより小さくなります。
          </p></li><li class="listitem"><p>
            <code class="literal">ROW_FORMAT=COMPRESSED</code> を指定する場合は、<code class="literal">KEY_BLOCK_SIZE</code> を省略できます。<code class="literal">KEY_BLOCK_SIZE</code> 設定のデフォルトは <code class="literal">innodb_page_size</code> 値の半分です。
          </p></li><li class="listitem"><p>
            有効な <code class="literal">KEY_BLOCK_SIZE</code> 値を指定する場合は、<code class="literal">ROW_FORMAT=COMPRESSED</code> を省略できます。圧縮は自動的に有効になります。
          </p></li><li class="listitem"><p>
            <code class="literal">KEY_BLOCK_SIZE,</code>の最適な値を決定するには、通常、この句に異なる値を指定して同じテーブルの複数のコピーを作成し、生成される <code class="filename">.ibd</code> ファイルのサイズを測定して、各ファイルが現実的な <a class="link" href="glossary.html#glos_workload" title="ワークロード">workload</a> でどのように動作するかを確認します。 一般的なテーブルスペースの場合、テーブルを削除しても、一般的なテーブルスペースの <code class="filename">.ibd</code> ファイルのサイズが小さくなることはなく、ディスク領域がオペレーティングシステムに戻されることもないことに注意してください。 詳細は、<a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="15.6.3.3 一般テーブルスペース">セクション15.6.3.3「一般テーブルスペース」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">KEY_BLOCK_SIZE</code> 値は、ヒントとして処理されます。<code class="literal">InnoDB</code> では、必要に応じて異なるサイズが使用される可能性があります。 file-per-table テーブルスペースの場合、<code class="literal">KEY_BLOCK_SIZE</code> は <code class="literal">innodb_page_size</code> 値以下にのみできます。 <code class="literal">innodb_page_size</code> 値を超える値を指定した場合は、指定された値が無視され、警告が発行されます。また、<code class="literal">KEY_BLOCK_SIZE</code> は <code class="literal">innodb_page_size</code> 値の半分に設定されます。 <code class="literal">innodb_strict_mode=ON</code> の場合、無効な <code class="literal">KEY_BLOCK_SIZE</code> 値を指定するとエラーが返されます。 一般的なテーブルスペースの場合、有効な <code class="literal">KEY_BLOCK_SIZE</code> 値はテーブルスペースの <code class="literal">FILE_BLOCK_SIZE</code> 設定によって異なります。 詳細は、<a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="15.6.3.3 一般テーブルスペース">セクション15.6.3.3「一般テーブルスペース」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> は 32KB および 64KB のページサイズをサポートしていますが、これらのページサイズは圧縮をサポートしていません。 詳細は、<code class="literal">innodb_page_size</code> のドキュメントを参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> データ<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>のデフォルトの非圧縮サイズは、16K バイトです。 オプション値の組合せに応じて、MySQL では、テーブルスペースデータファイル (<code class="filename">.ibd</code> ファイル) に 1KB、2KB、4KB、8KB または 16KB のページサイズが使用されます。 実際の圧縮アルゴリズムは、<code class="literal">KEY_BLOCK_SIZE</code> 値の影響を受けません。この値によって、各圧縮済みチャンクの大きさが決定されるため、各圧縮済みページに詰め込むことができる行数が影響を受けます。 
          </p></li><li class="listitem"><p>
            file-per-table テーブルスペースに圧縮テーブルを作成する場合、<code class="literal">KEY_BLOCK_SIZE</code> を <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_page_size" title="page size">page size</a> と同等に設定しても、通常は圧縮があまり発生しません。 たとえば、<code class="literal">InnoDB</code> のページサイズは 16K バイトであるため、一般に <code class="literal">KEY_BLOCK_SIZE=16</code> を設定しても、大量の圧縮は発生しません。 多くの場合、このような値で適切に圧縮されるため、この設定は多くの長い <code class="literal">BLOB</code>、<code class="literal">VARCHAR</code>、または <code class="literal">TEXT</code> カラムを持つテーブルで引き続き役立つことがあります。したがって、<a class="xref" href="innodb-storage-engine.html#innodb-compression-internals" title="15.9.1.5 InnoDB テーブルでの圧縮の動作">セクション15.9.1.5「InnoDB テーブルでの圧縮の動作」</a>で説明したように、必要となる<a class="link" href="glossary.html#glos_overflow_page" title="オーバーフローページ">オーバーフローページ</a>が少なくなる可能性もあります。 一般的なテーブルスペースの場合、<code class="literal">InnoDB</code> ページサイズと等しい <code class="literal">KEY_BLOCK_SIZE</code> 値は許可されません。 詳細は、<a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="15.6.3.3 一般テーブルスペース">セクション15.6.3.3「一般テーブルスペース」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            テーブルのすべてのインデックス (<a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">クラスタ化されたインデックス</a>を含む) は、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントで指定されたものと同じページサイズを使用して圧縮されます。 <code class="literal">ROW_FORMAT</code> や <code class="literal">KEY_BLOCK_SIZE</code> などのテーブル属性は、<code class="literal">InnoDB</code> テーブルの <code class="literal">CREATE INDEX</code> 構文の一部ではなく、指定されている場合は無視されます (ただし、指定されている場合は <code class="literal">SHOW CREATE TABLE</code> ステートメントの出力に表示されます)。 
          </p></li><li class="listitem"><p>
            パフォーマンス関連の構成オプションについては、<a class="xref" href="innodb-storage-engine.html#innodb-compression-tuning" title="15.9.1.3 InnoDB テーブルの圧縮の調整">セクション15.9.1.3「InnoDB テーブルの圧縮の調整」</a> を参照してください。
          </p></li></ul></div><h5><a name="idm44761359269360"></a>圧縮テーブル上の制約</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            圧縮テーブルは、<code class="literal">InnoDB</code> システムテーブルスペースに格納できません。
          </p></li><li class="listitem"><p>
            一般テーブルスペースには複数のテーブルを含めることができますが、圧縮テーブルと非圧縮テーブルを同じ一般テーブルスペース内に共存させることはできません。
          </p></li><li class="listitem"><p>
            句の名前が <code class="literal">ROW_FORMAT</code> であるにもかかわらず、圧縮は個別の行にではなく、テーブル全体およびそれに関連付けられたすべてのインデックスに適用されます。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> では、圧縮一時テーブルはサポートされていません。 <code class="literal">innodb_strict_mode</code> が有効な場合 (デフォルト)、<code class="literal">ROW_FORMAT=COMPRESSED</code> または <code class="literal">KEY_BLOCK_SIZE</code> が指定されていると、<code class="literal">CREATE TEMPORARY TABLE</code> はエラーを返します。 <code class="literal">innodb_strict_mode</code> が無効な場合は、警告が発行され、圧縮されていない行形式を使用して一時テーブルが作成されます。 一時テーブルに対する <code class="literal">ALTER TABLE</code> 操作にも同じ制限が適用されます。 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-compression-tuning"></a>15.9.1.3 InnoDB テーブルの圧縮の調整</h4></div></div></div><a class="indexterm" name="idm44761359254224"></a><a class="indexterm" name="idm44761359252080"></a><p>
        ほとんどの場合、<a class="xref" href="innodb-storage-engine.html#innodb-compression-internals-storage" title="InnoDB データストレージと圧縮">InnoDB データストレージと圧縮</a>で説明した内部的な最適化によって、圧縮済みデータを使用してもシステムは適切に動作します。 ただし、圧縮の効率性はデータの特性によって異なるため、圧縮テーブルのパフォーマンスに影響を与える決定を行うことができます。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            圧縮するテーブル。
          </p></li><li class="listitem"><p>
            使用する圧縮済みページサイズ。
          </p></li><li class="listitem"><p>
            実行時のパフォーマンス特性 (システムでデータの圧縮および圧縮解除に要する時間など) に基づいて、バッファープールのサイズを調整するかどうか。 ワークロードが<a class="link" href="glossary.html#glos_data_warehouse" title="データウェアハウス">データウェアハウス</a> (主にクエリー) または <a class="link" href="glossary.html#glos_oltp" title="OLTP">OLTP</a> システム (クエリーと <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> の混在) に似ているかどうか。 
          </p></li><li class="listitem"><p>
            システムの圧縮テーブル上で DML 操作が実行されているときに、データを配布する方法によって実行時に負荷の高い<a class="link" href="glossary.html#glos_compression_failure" title="圧縮失敗">圧縮が失敗</a>する場合は、追加の高度な構成オプションを調整することがあります。
          </p></li></ul></div><p>
        このセクションのガイドラインを使用すると、このようなアーキテクチャー上および構成上の選択を行う際に役立ちます。 長期間のテストを実施し、圧縮テーブルを本番環境に移行する準備ができたら、これらの選択を現実の状況で行なった場合の効率性を検証する方法について、<a class="xref" href="innodb-storage-engine.html#innodb-compression-tuning-monitoring" title="15.9.1.4 実行時の InnoDB テーブル圧縮の監視">セクション15.9.1.4「実行時の InnoDB テーブル圧縮の監視」</a>を参照してください。 
      </p><h5><a name="innodb-compression-tuning-when"></a>圧縮を使用するタイミング</h5><p>
        一般に、圧縮は、適当な数の文字列カラムが含まれ、データの書き込みよりも読み取りの頻度の方がはるかに高いテーブルで最適に動作します。 特定の状況で圧縮の利点が得られるかどうかを予測するための保証された方法はないため、必ず、代表的な構成で実行する特定の<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>およびデータセットをテストしてください。 圧縮するテーブルを決定する際は、次の要素を検討してください。 
      </p><h5><a name="innodb-compression-tuning-when-data"></a>データの特性と圧縮</h5><a class="indexterm" name="idm44761359233008"></a><p>
        データファイルのサイズを削減する際に圧縮の効率性の決定要因となるものは、データ自体の特性です。 圧縮は、データのブロックで繰り返されるバイト文字列を識別することで動作していることを思い出してください。 完全にランダム化されたデータは、最悪のケースです。 多くの場合、一般的なデータには繰り返し値が含まれているため、効率的に圧縮されます。 <code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、<code class="literal">TEXT</code>、または <code class="literal">BLOB</code> のいずれのカラムに定義されているのかに関係なく、多くの場合、文字列は効率的に圧縮されます。 その一方で、一般に、ほとんどがバイナリデータ (整数または浮動小数) や以前に圧縮されたデータ (<acronym class="acronym">JPEG</acronym> または <acronym class="acronym">PNG</acronym> イメージなど) を含むテーブルは、大幅にまたはまったく効率的に圧縮されない可能性があります。 
      </p><p>
        InnoDB テーブルごとに圧縮を有効にするかどうかを選択します。 テーブルおよびそのすべてのインデックスでは、同じ (圧縮済み) <a class="link" href="glossary.html#glos_page_size" title="page size">ページサイズ</a>が使用されます。 すべてのテーブルカラムのデータを含む<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a> (クラスタ化) インデックスは、セカンダリインデックスよりも効率的に圧縮される可能性があります。 長い行が存在する場合に圧縮を使用すると、<a class="xref" href="innodb-storage-engine.html#innodb-row-format-dynamic" title="DYNAMIC 行フォーマット">DYNAMIC 行フォーマット</a>で説明したように、長いカラム値が<span class="quote">「<span class="quote">オフページ</span>」</span>に格納される可能性があります。 このようなオーバーフローページは、効率的に圧縮される可能性があります。 これらの検討事項を考慮すると、多くのアプリケーションでは、一部のテーブルがその他よりも効率的に圧縮され、圧縮されたテーブルのサブセットを含むワークロードのみが最適に動作する場合もあります。 
      </p><p>
        特定のテーブルを圧縮するかどうかを決定するには、実験を行います。 非圧縮テーブルの <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibd ファイル</a>のコピー上に、LZ77 圧縮 (<code class="literal">gzip</code> や WinZip など) が実装されたユーティリティーを使用すると、データを圧縮する際の効率性の概算見積もりを取得できます。 MySQL では<a class="link" href="glossary.html#glos_page_size" title="page size">ページサイズ</a> (デフォルトは 16K バイト) に基づいたチャンク単位でデータが圧縮されるため、MySQL で圧縮されたテーブルからは、ファイルベースの圧縮ツールよりも低い圧縮率が得られると予測できます。 ページ形式には、ユーザーデータに加えて、圧縮されていない内部システムデータもいくつか含まれます。 ファイルベースの圧縮ユーティリティーでは、さらに大きなデータチャンクを調査できるため、MySQL の各ページで見つかるよりも多くの繰り返し文字列が巨大なファイルで見つかる可能性があります。 
      </p><p>
        特定のテーブルの圧縮をテストする別の方法は、圧縮されていないテーブルの一部のデータを <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペース内の類似した圧縮テーブル (すべて同じインデックスを持つ) にコピーし、結果の <code class="literal">.ibd</code> ファイルのサイズを確認することです。 例: 
      </p><pre class="programlisting">USE test;
SET GLOBAL innodb_file_per_table=1;
SET GLOBAL autocommit=0;

-- Create an uncompressed table with a million or two rows.
CREATE TABLE big_table AS SELECT * FROM information_schema.columns;
INSERT INTO big_table SELECT * FROM big_table;
INSERT INTO big_table SELECT * FROM big_table;
INSERT INTO big_table SELECT * FROM big_table;
INSERT INTO big_table SELECT * FROM big_table;
INSERT INTO big_table SELECT * FROM big_table;
INSERT INTO big_table SELECT * FROM big_table;
INSERT INTO big_table SELECT * FROM big_table;
INSERT INTO big_table SELECT * FROM big_table;
INSERT INTO big_table SELECT * FROM big_table;
INSERT INTO big_table SELECT * FROM big_table;
COMMIT;
ALTER TABLE big_table ADD id int unsigned NOT NULL PRIMARY KEY auto_increment;

SHOW CREATE TABLE big_table\G

select count(id) from big_table;

-- Check how much space is needed for the uncompressed table.
\! ls -l data/test/big_table.ibd

CREATE TABLE key_block_size_4 LIKE big_table;
ALTER TABLE key_block_size_4 key_block_size=4 row_format=compressed;

INSERT INTO key_block_size_4 SELECT * FROM big_table;
commit;

-- Check how much space is needed for a compressed table
-- with particular compression settings.
\! ls -l data/test/key_block_size_4.ibd
</pre><p>
        この実験では、次のような数値が生成されました。当然、テーブル構造やデータによって、数値が大幅に異なる可能性があります。
      </p><pre class="programlisting">-rw-rw----  1 cirrus  staff  310378496 Jan  9 13:44 data/test/big_table.ibd
-rw-rw----  1 cirrus  staff  83886080 Jan  9 15:10 data/test/key_block_size_4.ibd
</pre><p>
        特定の<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>で圧縮が効率的かどうかを確認するには:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            単純なテストでは、その他の圧縮テーブルが含まれない MySQL インスタンスを使用して、<code class="literal">INFORMATION_SCHEMA.INNODB_CMP</code> テーブルに対してクエリーを実行します。
          </p></li><li class="listitem"><p>
            複数の圧縮テーブルが含まれるワークロードが関与するより詳細なテストでは、<code class="literal">INFORMATION_SCHEMA.INNODB_CMP_PER_INDEX</code> テーブルに対してクエリーを実行します。 <code class="literal">INNODB_CMP_PER_INDEX</code> テーブルの統計は収集にコストがかかるため、そのテーブルをクエリーする前に構成オプション <code class="literal">innodb_cmp_per_index_enabled</code> を有効にする必要があり、そのようなテストを開発サーバーまたはクリティカルでないレプリカサーバーに制限できます。 
          </p></li><li class="listitem"><p>
            テスト中の圧縮テーブルに対して、一般的な SQL ステートメントをいくつか実行します。
          </p></li><li class="listitem"><p>
            <code class="literal">INFORMATION_SCHEMA.INNODB_CMP</code> または <code class="literal">INFORMATION_SCHEMA.INNODB_CMP_PER_INDEX</code> テーブルのクエリーを実行し、<code class="literal">COMPRESS_OPS</code> と <code class="literal">COMPRESS_OPS_OK</code> を比較することで、圧縮操作全体に対する正常な圧縮操作の比率を調査します。
          </p></li><li class="listitem"><p>
            圧縮操作が正常に完了した比率が高い場合は、そのテーブルが圧縮対象の候補である可能性が高くなります。
          </p></li><li class="listitem"><p>
            <a class="link" href="glossary.html#glos_compression_failure" title="圧縮失敗">圧縮が失敗</a>する比率が高い場合は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-compression-oltp" title="15.9.1.6 OLTP ワークロードの圧縮">セクション15.9.1.6「OLTP ワークロードの圧縮」</a>で説明したように、<code class="literal">innodb_compression_level</code>、<code class="literal">innodb_compression_failure_threshold_pct</code>、および <code class="literal">innodb_compression_pad_pct_max</code> オプションを調整すれば、さらに詳細なテストを試すことができます。
          </p></li></ul></div><h5><a name="innodb-compression-application"></a>データベースの圧縮とアプリケーションの圧縮</h5><a class="indexterm" name="idm44761359187024"></a><p>
        アプリケーション内とテーブル内のどちらでデータを圧縮するかどうかを決定します。同じデータで両方のタイプの圧縮を使用しないでください。 アプリケーション内でデータを圧縮し、その結果を圧縮テーブルに格納すると、追加の領域が節約される可能性は大幅に低くなり、二重圧縮によって単に CPU サイクルが無駄になるだけです。 
      </p><h5><a name="innodb-compression-in-database"></a>データベース内での圧縮</h5><p>
        これを有効にすると、MySQL テーブルの圧縮は自動的になり、すべてのカラムおよびインデックス値に適用されます。 <code class="literal">LIKE</code> などの演算子を含むカラムも引き続きテストでき、インデックス値が圧縮されている場合でも、ソート操作でインデックスを引き続き使用できます。 多くの場合、インデックスがデータベースの合計サイズの相当な割合を占めるため、圧縮を使用すると、ストレージ、I/O、またはプロセッサ時間が大幅に節約される可能性があります。 圧縮および圧縮解除の操作は、予期される負荷を処理できるようにサイズ変更された強力なシステムとなる可能性が高いデータベースサーバー上で発生します。 
      </p><h5><a name="innodb-compression-in-application"></a>アプリケーション内での圧縮</h5><p>
        テキストなどのデータをアプリケーション内で圧縮してから、データベースに挿入する場合は、一部のカラムは圧縮されるが、その他は圧縮されないことで効率的に圧縮されないデータで、オーバーヘッドが節約される可能性があります。 このアプローチでは、圧縮および圧縮解除用の CPU サイクルがデータベースサーバー上ではなく、クライアントマシン上で使用されるため、多数のクライアントが含まれる分散アプリケーションや、予備の CPU サイクルを備えたクライアントマシンに適している場合があります。 
      </p><h5><a name="innodb-compression-hybrid"></a>ハイブリッドアプローチ</h5><p>
        当然、これらのアプローチは組み合わせることができます。 一部のアプリケーションでは、いくつかの圧縮テーブルといくつかの非圧縮テーブルを使用することが適切である場合があります。 一部のデータを外部で圧縮して (それを非圧縮テーブルに格納して)、アプリケーション内のその他のテーブル (の一部) を MySQL で圧縮できるようにすることが最適な方法である場合もあります。 通常どおり、適切な決定に達するには、事前の設計および現実のテストが重要となります。 
      </p><h5><a name="innodb-compression-tuning-when-workload"></a>ワークロードの特性と圧縮</h5><a class="indexterm" name="idm44761359172640"></a><p>
        圧縮するテーブル (およびページサイズ) を選択することに加えて、ワークロードはもう 1 つのパフォーマンスの主要な決定要因でもあります。 アプリケーションが更新ではなく、読み取りで占有されている場合は、圧縮済みデータ用に MySQL で保持されるページごとの<span class="quote">「<span class="quote">変更ログ</span>」</span>用の空き領域がインデックスページによって使い果たされたあとに、再編成および再圧縮する必要のあるページが少なくなります。 更新によって、インデックスなしのカラムまたはそれらが含まれている <code class="literal">BLOB</code> や、偶然に<span class="quote">「<span class="quote">オフページ</span>」</span>に格納される大きな文字列が主に変更される場合は、圧縮のオーバーヘッドが許容可能になる可能性があります。 単調に増加する主キーを使用する <code class="literal">INSERT</code> がテーブルへの唯一の変更であり、セカンダリインデックスがほとんどない場合は、インデックスページを再編成および再圧縮する必要もほとんどありません。 MySQL では、非圧縮データを変更することで、<span class="quote">「<span class="quote">適切に</span>」</span>、圧縮済みページ上のデータに<span class="quote">「<span class="quote">削除マークを付け</span>」</span>てから削除できるため、テーブル上の <code class="literal">DELETE</code> 操作は比較的効率的に行われます。 
      </p><p>
        環境によっては、データのロードに要する時間がリアルタイム検索と同じくらいに重要である場合があります。 特にデータウェアハウス環境では、数多くのテーブルが読み取り専用または読み取りが大半になっている可能性があります。 このような場合、結果として少数のディスク読み取りとストレージコストの節約が重要である場合を除いて、ロード時間が長くなるという点で圧縮の犠牲を払うことが許容できる場合と、許容できない場合があります。 
      </p><p>
        本来は、データを圧縮および圧縮解除する際に CPU 時間を使用できるときに、圧縮が最適に動作します。 そのため、ワークロードが CPU バウンドではなく、I/O バウンドである場合に、圧縮を使用することで全体的なパフォーマンスを改善できることがわかるでしょう。 さまざまな圧縮構成でアプリケーションのパフォーマンスをテストする際は、計画した本番システム構成と同様のプラットフォーム上でテストしてください。 
      </p><h5><a name="innodb-compression-tuning-when-config"></a>構成の特性と圧縮</h5><a class="indexterm" name="idm44761359160480"></a><p>
        データベース<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>のディスクからの読み取りとディスクへの書き込みは、システムパフォーマンスのもっとも低速な側面です。 圧縮では、CPU 時間を使用してデータを圧縮および圧縮解除することで I/O の削減が試みられるため、プロセッササイクルと比べて、I/O が比較的少ないリソースであるときに、もっとも効率性が高くなります。 
      </p><p>
        多くの場合、これは特に、高速のマルチコア CPU が搭載された複数ユーザー環境で動作しているときに当てはまります。 圧縮テーブルのページがメモリー内にあるときは、MySQL では多くの場合、ページの非圧縮コピー用の<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>内で追加のメモリー (一般に 16K バイト) が使用されます。 適応型 LRU アルゴリズムでは、I/O バウンドと CPU バウンドのどちらの方式でワークロードが動作しているのかに関係なく、考慮される圧縮済みページと非圧縮ページ間でメモリー使用のバランスを調整しようと試みられます。 メモリーが非常に制約されている構成よりも、バッファープール専用のメモリーがより多く搭載された構成の方が、圧縮テーブルを使用するときに適切に動作する傾向があります。 
      </p><h5><a name="innodb-compression-tuning-when-size"></a>圧縮済みページサイズの選択</h5><a class="indexterm" name="idm44761359151984"></a><a class="indexterm" name="idm44761359149952"></a><a class="indexterm" name="idm44761359148032"></a><a class="indexterm" name="idm44761359146000"></a><p>
        圧縮済みページサイズの最適な設定は、テーブルおよびそのインデックスに含まれるデータの型および分布によって異なります。 圧縮済みページのサイズは、常に最大のレコードサイズよりも大きくするようにしてください。そうでなければ、<a class="xref" href="innodb-storage-engine.html#innodb-compression-internals-storage-btree" title="B ツリーページの圧縮">B ツリーページの圧縮</a>で注記したように、操作に失敗する可能性があります。 
      </p><p>
        圧縮済みページサイズの設定が大きすぎると、一部の領域が無駄になりますが、頻繁にページを圧縮する必要はなくなります。 圧縮されたページサイズが小さすぎる場合、挿入または更新に時間のかかる再圧縮が必要になることがあり、<a class="link" href="glossary.html#glos_b_tree" title="B ツリー">B-tree</a> ノードをより頻繁に分割する必要があるため、データファイルが大きくなり、インデックス付けの効率が低下する可能性があります。 
      </p><p>
        一般に、圧縮済みページサイズは 8K バイトまたは 4K バイトに設定されます。 InnoDB テーブルの最大行サイズが約 8K とすれば、通常、<code class="literal">KEY_BLOCK_SIZE=8</code> は安全な選択です。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-compression-tuning-monitoring"></a>15.9.1.4 実行時の InnoDB テーブル圧縮の監視</h4></div></div></div><a class="indexterm" name="idm44761359137520"></a><a class="indexterm" name="idm44761359135376"></a><p>
        アプリケーション全体のパフォーマンス、CPU と I/O の使用率、およびディスクファイルのサイズは、アプリケーションでの圧縮の効率姓を示す適切な指標です。 このセクションは、<a class="xref" href="innodb-storage-engine.html#innodb-compression-tuning" title="15.9.1.3 InnoDB テーブルの圧縮の調整">セクション15.9.1.3「InnoDB テーブルの圧縮の調整」</a>に示したパフォーマンスチューニングのアドバイスに基づいて構成され、初期のテスト時には発生する可能性のない問題を見つける方法を示しています。 
      </p><p>
        圧縮テーブルのパフォーマンス上の考慮事項をさらに深く掘り下げるには、<a class="xref" href="innodb-storage-engine.html#innodb-information-schema-examples-compression" title="例 15.1 圧縮情報スキーマテーブルの使用">例15.1「圧縮情報スキーマテーブルの使用」</a>に記載した<a class="link" href="glossary.html#glos_information_schema" title="INFORMATION_SCHEMA">「情報スキーマ」</a>テーブルを使用すれば、実行時に圧縮のパフォーマンスをモニターできます。 これらのテーブルは、メモリーの内部使用および全体的に使用される圧縮の比率を反映しています。 
      </p><p>
        <code class="literal">INNODB_CMP</code> テーブルには、使用中の圧縮済みページサイズ (<code class="literal">KEY_BLOCK_SIZE</code>) ごとに、圧縮アクティビティーに関する情報がレポートされます。 これらのテーブル内の情報は、システム全体のものであり、データベース内のすべての圧縮テーブルにわたる圧縮の統計を集約したものです。 このデータを使用すると、その他の圧縮テーブルがアクセスしていないときに、これらのテーブルを調査することでテーブルを圧縮するかどうかを決定する際に役立ちます。 これには、サーバー上で比較的小さいオーバーヘッドが伴うため、圧縮失敗の全体的な効率性をチェックするために、本番環境サーバー上で定期的にクエリーを実行することがあります。 
      </p><p>
        <code class="literal">INNODB_CMP_PER_INDEX</code> テーブルには、個別のテーブルおよびインデックスごとに、圧縮アクティビティーに関する情報がレポートされます。 この情報は、圧縮の効率性を評価し、一度に 1 つのテーブルまたはインデックスのパフォーマンス問題を診断する際に、より的を絞ることができ、より役立ちます。 (各 <code class="literal">InnoDB</code> テーブルはクラスタ化されたインデックスとして表されるため、このコンテキストでは、MySQL でテーブルとインデックス間で大きな区別が行われません。) <code class="literal">INNODB_CMP_PER_INDEX</code> テーブルには大量のオーバーヘッドが伴うため、さまざまな<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>、データ、および圧縮設定の効果を分離して比較できる開発サーバーにより適しています。 このモニタリングのオーバーヘッドが誤って課されることを防ぐには、<code class="literal">INNODB_CMP_PER_INDEX</code> テーブルのクエリーを実行する前に、<code class="literal">innodb_cmp_per_index_enabled</code> 構成オプションを有効にする必要があります。 
      </p><p>
        考慮するべき主要な統計は、圧縮および圧縮解除操作の数、および実行に要する時間数です。 MySQL では、変更後に <a class="link" href="glossary.html#glos_b_tree" title="B ツリー">B-tree</a> ノードがいっぱいになりすぎて圧縮データを含めることができない場合に分割されるため、<span class="quote">「<span class="quote">「成功」</span>」</span>圧縮操作の数とそのような操作の数を全体で比較します。 <code class="literal">INNODB_CMP</code> および <code class="literal">INNODB_CMP_PER_INDEX</code> テーブル内の情報、およびアプリケーション全体のパフォーマンスとハードウェアリソースの使用率に基づいて、ハードウェア構成の変更を行なったり、バッファープールのサイズを調整したり、別のページサイズを選択したり、圧縮する別のテーブルセットを選択したりすることがあります。 
      </p><p>
        圧縮および圧縮解除するために必要な CPU 時間の合計が大きい場合は、高速またはマルチコアの CPU に変更すると、同じデータ、アプリケーションのワークロード、および圧縮テーブルのセットを使用してパフォーマンスを改善する際に役立つことがあります。 バッファープールのサイズを大きくすると、パフォーマンスの改善に役立つこともあります。これにより、より多くの非圧縮ページをメモリー内に滞在できるようになるため、圧縮形式でのみメモリー内に存在するページを圧縮解除する必要が少なくなります。 
      </p><p>
        (アプリケーションでの <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> 操作の数、およびデータベースのサイズと比較して) 圧縮操作全体の数が大きい場合は、効率的な圧縮としては、圧縮テーブルの一部が更新される頻度が高すぎることを示している可能性があります。 その場合は、より大きなページサイズを選択するか、圧縮するテーブルをより慎重に選択してください。 
      </p><p>
        <span class="quote">「<span class="quote">正常な</span>」</span>圧縮操作の数 (<code class="literal">COMPRESS_OPS_OK</code>) が圧縮操作の合計数 (<code class="literal">COMPRESS_OPS</code>) の高い比率を占めている場合は、システムが正常に実行されている可能性が高くなります。 比率が低い場合は、MySQL によって理想よりも頻繁に、B ツリーノードの再編成、再圧縮、および分割が行われます。 この場合、一部のテーブルの圧縮を回避するか、圧縮テーブルの一部で <code class="literal">KEY_BLOCK_SIZE</code> を大きくしてください。 テーブルの圧縮をオフにすると、アプリケーション内での<span class="quote">「<span class="quote">圧縮失敗</span>」</span>の数が合計の 1% または 2% を上回る可能性があります。 (このような失敗の比率は、データのロードなどの一時的な操作時には許容範囲内である場合もあります)。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-compression-internals"></a>15.9.1.5 InnoDB テーブルでの圧縮の動作</h4></div></div></div><a class="indexterm" name="idm44761359102896"></a><p>
        このセクションでは、InnoDB テーブルの<a class="link" href="glossary.html#glos_compression" title="圧縮">圧縮</a>に関する一部の内部実装について詳細に説明します。 ここで示す情報は、パフォーマンスを調整する際に役立つことがありますが、圧縮の基本的な使用を理解する必要はありません。 
      </p><h5><a name="innodb-compression-internals-algorithms"></a>圧縮アルゴリズム</h5><a class="indexterm" name="idm44761359097968"></a><p>
        一部のオペレーティングシステムでは、ファイルシステムのレベルで圧縮が実装されています。 一般に、ファイルは、可変サイズのブロックに圧縮される固定サイズのブロックに分割されるため、簡単に断片化されます。 ブロック内部で何かが変更されるたびに、ブロック全体が再圧縮されてからディスクに書き込まれます。 これらのプロパティーを使用すると、この圧縮方法が更新の多いデータベースシステムでの使用には適さなくなります。 
      </p><p>
        MySQL では、LZ77 圧縮アルゴリズムが実装されている有名な <a class="ulink" href="http://www.zlib.net/" target="_top">zlib ライブラリ</a>の支援を得て、圧縮が実装されています。 この圧縮アルゴリズムは十分に発達し、強固であり、CPU の使用率とデータサイズの削減の両方の点で効率的です。 このアルゴリズムは<span class="quote">「<span class="quote">損失なし</span>」</span>であるため、常に、元の非圧縮データを圧縮形式から再構築できます。 LZ77 圧縮は、圧縮されるデータ内で繰り返される一連のデータを見つけることで動作します。 データ内の値のパターンによって、圧縮の効率性が決定されますが、多くの場合、一般的なユーザーデータは 50% 以上圧縮されます。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">InnoDB</code> は、MySQL 8.0 にバンドルされているバージョンであるバージョン 1.2.11 までの <code class="literal">zlib</code> ライブラリをサポートしています。
        </p></div><p>
        アプリケーションで実行される圧縮や、その他の一部のデータベース管理システムの圧縮機能とは異なり、InnoDB の圧縮は、ユーザーデータとインデックスの両方に適用されます。 多くの場合、インデックスがデータベースの合計サイズの 40-50% 以上を占める可能性があるため、この相違点は重要です。 データセットの圧縮が適切に機能している場合、InnoDB データファイル (<a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースまたは <a class="link" href="glossary.html#glos_general_tablespace" title="一般テーブルスペース">general tablespace</a> <code class="literal">.ibd</code> ファイル) のサイズは、圧縮されていないサイズの 25% から 50% 以下になります。 <a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>によっては、このようにデータベースを小さくすることにより、CPU 使用率を少し増加させるだけで I/O を削減してスループットを増加できます。 <code class="literal">innodb_compression_level</code> 構成オプションを変更すると、圧縮のレベルと CPU のオーバーヘッド間のバランスを調整できます。 
      </p><h5><a name="innodb-compression-internals-storage"></a>InnoDB データストレージと圧縮</h5><a class="indexterm" name="idm44761359082400"></a><p>
        InnoDB テーブル内のすべてのユーザーデータは、<a class="link" href="glossary.html#glos_b_tree" title="B ツリー">B ツリー</a>インデックス (<a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">クラスタ化されたインデックス</a>) を構成しているページに格納されます。 その他の一部のデータベースシステムでは、このタイプのインデックスは<span class="quote">「<span class="quote">インデックス編成テーブル</span>」</span>と呼ばれます。 インデックスノード内の各行には、(ユーザーが指定した、またはシステムで生成された) <a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>の値およびテーブルのその他のすべてのカラムが含まれています。 
      </p><p>
        InnoDB テーブル内の<a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">セカンダリインデックス</a>は、値のペア (インデックスキーと、クラスタ化されたインデックス内の行へのポインタ) を含む B ツリーでもあります。 実際は、ポインタはテーブルの主キーの値であり、インデックスキーおよび主キー以外のカラムが必要な場合に、クラスタ化されたインデックスにアクセスする際に使用されます。 常に、セカンダリインデックスのレコードは、B ツリーページ上に収容される必要があります。 
      </p><p>
        次のセクションで説明するように、(クラスタ化インデックスとセカンダリインデックスの両方の) B ツリーノードの圧縮は、長い <code class="literal">VARCHAR</code>、<code class="literal">BLOB</code>、または <code class="literal">TEXT</code> カラムを格納するために使用される<a class="link" href="glossary.html#glos_overflow_page" title="オーバーフローページ">オーバーフロー</a>の圧縮とは異なる方法で処理されます。
      </p><h5><a name="innodb-compression-internals-storage-btree"></a>B ツリーページの圧縮</h5><a class="indexterm" name="idm44761359068752"></a><p>
        B ツリーページは頻繁に更新されるため、特別な処理が必要です。 B ツリーノードが分割される回数を最小限にし、それらの内容を圧縮解除および再圧縮する必要性も最小限にすることが重要となります。 
      </p><p>
        MySQL で使用される技術の 1 つでは、一部のシステム情報が非圧縮形式で B ツリーノード内に保持されるため、特定のインプレース更新が容易になります。 たとえば、これにより、圧縮操作なしで行に削除のマークを付け、その行を削除できます。 
      </p><p>
        さらに、MySQL では、インデックスページが変更されたときに、不要な圧縮解除および再圧縮を回避しようと試みられます。 システムの各 B ツリーページ内には、ページに行われた変更を記録するための非圧縮の<span class="quote">「<span class="quote">変更ログ</span>」</span>が保持されます。 小さいレコードの更新および挿入は、ページ全体を完全に再構築する必要なしで、この変更ログに書き込まれる場合があります。 
      </p><p>
        変更ログ用の領域を使い果たすと、InnoDB によってページが圧縮解除され、変更が適用され、ページが再圧縮されます。 再圧縮に失敗すると (<a class="link" href="glossary.html#glos_compression_failure" title="圧縮失敗">圧縮の失敗</a>と呼ばれる状況)、B ツリーノードが分割され、更新または挿入に成功するまでプロセスが繰り返されます。 
      </p><p>
        <a class="link" href="glossary.html#glos_oltp" title="OLTP">OLTP</a> アプリケーションなどで、書き込み負荷の高いワークロードでの頻繁な圧縮の失敗を回避するために、MySQL では、ページ内にいくつかの空のスペース (パディング) が予約されている場合があります。これにより、変更ログがより早く埋められ、分割を回避するための十分な空き領域がまだある間にページが再圧縮されます。 各ページに残されるパディングスペースの量は、システムでページ分割の頻度が追跡されるにつれて変化します。 圧縮テーブルへの書き込みが頻繁に行われる高負荷のサーバー上では、<code class="literal">innodb_compression_failure_threshold_pct</code> および <code class="literal">innodb_compression_pad_pct_max</code> 構成オプションを調整すると、このメカニズムを微調整できます。 
      </p><p>
        一般に、MySQL では、InnoDB テーブル内の各 B ツリーページに 2 つ以上のレコードを収容できます。 圧縮テーブルに対しては、この要件が緩和されました。 B ツリーノードのリーフページには (主キーとセカンダリインデックスのどちらでも)、1 つのレコードのみが収容される必要がありますが、そのレコードはページごとの変更ログに非圧縮形式で収まる必要があります。 <code class="literal">innodb_strict_mode</code> が <code class="literal">ON</code> の場合は、<code class="literal">CREATE TABLE</code> または <code class="literal">CREATE INDEX</code> の実行中に、MySQL によって行の最大サイズがチェックされます。 行が収まらない場合は、<code class="literal">「ERROR HY000: Too big row」</code>というエラーメッセージが発行されます。 
      </p><p>
        <code class="literal">innodb_strict_mode</code> が OFF のときにテーブルを作成した場合に、後続の <code class="literal">INSERT</code> または <code class="literal">UPDATE</code> ステートメントで圧縮済みページのサイズに収まらないインデックスエントリの作成が試みられると、その操作に失敗し、<code class="literal">「ERROR 42000: Row size too large」</code>というエラーが表示されます。 (このエラーメッセージは、レコードが長すぎるインデックスの名前を示すものでも、その特定のインデックスページ上のインデックスレコードの長さや最大レコードサイズを示すものでもありません。) この問題を解決するには、<code class="literal">ALTER TABLE</code> を使用してテーブルを再構築し、より大きな圧縮済みページサイズ (<code class="literal">KEY_BLOCK_SIZE</code>) を選択して、任意のカラムプリフィクスのインデックスを短くするか、<code class="literal">ROW_FORMAT=DYNAMIC</code> または <code class="literal">ROW_FORMAT=COMPACT</code> を使用して圧縮を完全に無効にします。 
      </p><p>
        <code class="literal">innodb_strict_mode</code> は、圧縮テーブルもサポートする一般的なテーブルスペースには適用できません。 一般的なテーブルスペースのテーブルスペース管理ルールは、<code class="literal">innodb_strict_mode</code> とは無関係に厳密に適用されます。 詳細は、<a class="xref" href="sql-statements.html#create-tablespace" title="13.1.21 CREATE TABLESPACE ステートメント">セクション13.1.21「CREATE TABLESPACE ステートメント」</a>を参照してください。 
      </p><h5><a name="innodb-compression-internals-storage-blobs"></a>BLOB、VARCHAR、および TEXT カラムの圧縮</h5><a class="indexterm" name="idm44761359037456"></a><a class="indexterm" name="idm44761359035392"></a><p>
        InnoDB テーブルでは、主キーの一部ではない <code class="literal">BLOB</code>、<code class="literal">VARCHAR</code>、および <code class="literal">TEXT</code> カラムが、個別に割り当てられた<a class="link" href="glossary.html#glos_overflow_page" title="オーバーフローページ">オーバーフローページ</a>に格納される場合があります。 このようなカラムは、<a class="link" href="glossary.html#glos_off_page_column" title="オフページカラム">オフページカラム</a>と呼ばれています。 これらの値は、オーバーフローページの片方向リストに格納されます。 
      </p><p>
        <code class="literal">ROW_FORMAT=DYNAMIC</code> または <code class="literal">ROW_FORMAT=COMPRESSED</code> で作成されたテーブルでは、カラムの長さおよび行全体の長さによっては、<code class="literal">BLOB</code>、<code class="literal">TEXT</code>、または <code class="literal">VARCHAR</code> カラムの値が完全にオフページに格納される場合もあります。 オフページに格納されるカラムでは、クラスタ化されたインデックスのレコードに、オーバーフローページへの 20 バイトのポインタのみがカラムごとに 1 つずつ含まれます。 カラムがオフページに格納されるかどうかは、ページサイズおよび行の合計サイズによって異なります。 行がクラスタ化されたインデックスのページ内に完全に収まらないほど長い場合は、クラスタ化されたインデックスページ上に行が収まるまで、MySQL によってオフページストレージに合った最長のカラムが選択されます。 前述の注で示したように、行自体が圧縮済みページ上に収まらない場合は、エラーが発生します。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">ROW_FORMAT=DYNAMIC</code> または <code class="literal">ROW_FORMAT=COMPRESSED</code> で作成されたテーブルでは、40 バイト以下の <code class="literal">TEXT</code> および <code class="literal">BLOB</code> カラムは、常にインラインに格納されます。
        </p></div><p>
        <code class="literal">ROW_FORMAT=REDUNDANT</code> および <code class="literal">ROW_FORMAT=COMPACT</code> を使用するテーブルでは、<code class="literal">BLOB</code>、<code class="literal">VARCHAR</code> および <code class="literal">TEXT</code> カラムの最初の 768 バイトが主キーとともにクラスタインデックスレコードに格納されます。 768 バイトのプリフィクスのあとには、残りのカラム値を含むオーバーフローページへの 20 バイトのポインタが続きます。 
      </p><p>
        テーブルの形式が <code class="literal">COMPRESSED</code> である場合は、オーバーフローページに書き込まれるすべてのデータが<span class="quote">「<span class="quote">そのまま</span>」</span>圧縮されます。つまり、MySQL では、データ項目全体に zlib 圧縮アルゴリズムが適用されます。 圧縮済みのオーバーフローページには、データ以外では特に、ページチェックサムを構成する非圧縮のヘッダーとトレーラ、および次のオーバーフローページへのリンクが含まれます。 したがって、テキストデータを使用した場合に多く見られるように、データの圧縮性が高い場合は、長い <code class="literal">BLOB</code>、<code class="literal">TEXT</code>、または <code class="literal">VARCHAR</code> カラムで非常に大幅なストレージの節約が実現されます。 一般に、<code class="literal">JPEG</code> などのイメージデータはすでに圧縮されているため、圧縮テーブルに格納される利点がほとんど得られません。領域の節約がほとんどない、またはまったくない場合は、二重圧縮によって CPU サイクルが無駄になる可能性があります。 
      </p><p>
        オーバーフローページのサイズは、その他のページと同じです。 カラムの合計長が 8K バイトのみである場合でも、オフページに格納される 10 個のカラムを含む行で、10 個のオーバーフローページが占有されます。 非圧縮テーブルでは、10 個の非圧縮オーバーフローページで 160K バイトが占有されます。 ページサイズが 8K の圧縮テーブルでは、80K バイトのみが占有されます。 そのため、長いカラム値を含むテーブルでは、圧縮テーブル形式を使用すると効率性が高くなることが多くあります。 
      </p><p>
        <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースでは、<code class="literal">BLOB</code>、<code class="literal">VARCHAR</code> または <code class="literal">TEXT</code> カラムの記憶域および I/O コストを 16K 圧縮ページサイズを使用すると削減できます。これは、これらのデータが圧縮されることが多いため、B ツリーノード自体が圧縮されていない形式と同じ数のページを使用しても、オーバーフローページが必要になる場合があるためです。 一般テーブルスペースでは、16K 圧縮ページサイズ (<code class="literal">KEY_BLOCK_SIZE</code>) はサポートされていません。 詳細は、<a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="15.6.3.3 一般テーブルスペース">セクション15.6.3.3「一般テーブルスペース」</a>を参照してください。 
      </p><h5><a name="innodb-compression-internals-pool"></a>圧縮と InnoDB バッファープール</h5><a class="indexterm" name="idm44761358995136"></a><a class="indexterm" name="idm44761358993136"></a><p>
        圧縮された <code class="literal">InnoDB</code> テーブルでは、すべての圧縮ページ (1K、2K、4K または 8K) が 16K バイト (<code class="literal">innodb_page_size</code> が設定されている場合は小さいサイズ) の圧縮されていないページに対応します。 ページ内のデータにアクセスするために、MySQL は、圧縮済みページが<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>内にすでに存在しない場合、そのページをディスクから読み取ってから、その元の形式に圧縮解除します。 このセクションでは、<code class="literal">InnoDB</code> が圧縮テーブルのページに関してバッファプールを管理する方法について説明します。 
      </p><p>
        I/O を最小限にして、ページを圧縮解除する必要性を削減するために、バッファープールに圧縮済み形式と非圧縮形式の両方のデータベースページが含まれることがあります。 その他の必要なデータベースページ用の空き領域を作成するために、MySQL ではメモリー内に圧縮済みページを残しながら、バッファープールから非圧縮ページを<a class="link" href="glossary.html#glos_eviction" title="エビクション">エビクション</a>できます。 また、しばらくの間ページがアクセスされていない場合は、その他のデータ用に領域を解放するために、圧縮形式のページがディスクに書き込まれることもあります。 したがって、そのときどきで、バッファープールに圧縮形式と非圧縮形式の両方のページが含まれている場合、圧縮形式のページのみが含まれている場合、どちらも含まれていない場合があります。 
      </p><p>
        MySQL では、<a class="link" href="glossary.html#glos_hot" title="ホット">ホット</a> (頻繁にアクセスされる) データがメモリー内に滞在する傾向となるように、最近もっとも使用されていない (<a class="link" href="glossary.html#glos_lru" title="LRU">LRU</a>) リストを使用して、メモリー内に保持されるページおよび削除されるページが追跡されます。 圧縮テーブルにアクセスすると、MySQL は適応型 LRU アルゴリズムを使用して、メモリー内の圧縮済みページと非圧縮ページの適切なバランスを実現します。 この適応型アルゴリズムは、システムが <a class="link" href="glossary.html#glos_io_bound" title="I/O バウンド">I/O バウンド</a>と <a class="link" href="glossary.html#glos_cpu_bound" title="CPU バウンド">CPU バウンド</a>のどちらの方式で実行されているかどうかの影響を受けやすくなります。 この目的は、CPU の負荷が高いときにページを圧縮解除するために要する処理時間が長くなりすぎることを回避すること、および (メモリー内にすでに存在する可能性のある) 圧縮済みページを圧縮解除するために使用できる予備のサイクルが CPU に備わっているときに過剰な I/O が発生することを回避することです。 システムが I/O バウンドの場合、このアルゴリズムでは、その他のディスクページ用により多くの空き領域を作成することでメモリーが常駐になるように、ページの両方のコピーではなく、非圧縮コピーを削除することが優先されます。 システムが CPU バウンドの場合、MySQL では、<span class="quote">「<span class="quote">ホット</span>」</span>ページ用に使用できるメモリーが多くなり、圧縮形式でのみメモリー内のデータを圧縮解除する必要性が少なくなるように、圧縮済みページと非圧縮ページの両方を削除することが優先されます。 
      </p><h5><a name="innodb-compression-internals-log"></a>圧縮と InnoDB の Redo ログファイル</h5><a class="indexterm" name="idm44761358975104"></a><p>
        圧縮済みページが<a class="link" href="glossary.html#glos_data_files" title="データファイル">データファイル</a>に書き込まれる前に、MySQL によってページのコピーが Redo ログに書き込まれます (最後にデータベースに書き込まれた以降に再圧縮された場合)。 これは、<code class="literal">zlib</code> ライブラリがアップグレードされ、その変更によって圧縮済みデータとの互換性の問題が発生する可能性が低い場合でも、<a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>時に Redo ログを使用できるかどうかを確認するために行われます。 したがって、圧縮の使用時に、<a class="link" href="glossary.html#glos_log_file" title="ログファイル">ログファイル</a>のサイズを多少大きくすること、またはより頻繁に<a class="link" href="glossary.html#glos_checkpoint" title="チェックポイント">チェックポイント</a>を発生させる必要性を多少多くすることが要求される可能性があります。 ログファイルのサイズを大きくする量またはチェックポイントの頻度を多くする数は、再構成および再圧縮が必要となる方法で圧縮済みページが変更される回数によって異なります。 
      </p><p>
        file-per-table テーブルスペースに圧縮テーブルを作成するには、<code class="literal">innodb_file_per_table</code> が有効になっている必要があります。 一般的なテーブルスペースに圧縮テーブルを作成する場合、<code class="literal">innodb_file_per_table</code> 設定には依存しません。 詳細は、<a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="15.6.3.3 一般テーブルスペース">セクション15.6.3.3「一般テーブルスペース」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-performance-compression-oltp"></a>15.9.1.6 OLTP ワークロードの圧縮</h4></div></div></div><p>
        従来、<code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_compression" title="圧縮">圧縮</a>機能は、<a class="link" href="glossary.html#glos_data_warehouse" title="データウェアハウス">データウェアハウス</a>構成などで、主に読み取り専用または読み取りが大半の<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>に対して使用することが推奨されていました。 高速だが比較的小規模でコストがかかる <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> ストレージデバイスの増加により、<code class="literal">OLTP</code> ワークロードにも圧縮が魅力的になります: トラフィック量の多い対話型 web サイトでは、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code> および <code class="literal">DELETE</code> の操作を頻繁に行うアプリケーションで圧縮テーブルを使用することで、ストレージ要件および秒当たりの I/O 操作 (<a class="link" href="glossary.html#glos_iops" title="IOPS">IOPS</a>) を減らすことができます。 
      </p><p>
        これらの構成オプションを使用すると、書込み集中型操作のパフォーマンスとスケーラビリティに重点を置いて、特定の MySQL インスタンスの圧縮方法を調整できます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">innodb_compression_level</code> を使用すると、圧縮の程度を上げたり、下げたりできます。 値を大きくすると、ストレージデバイス上に収容できるデータ量が多くなりますが、圧縮時の CPU オーバーヘッドも多くなるという犠牲が伴います。 値を小さくすると、ストレージ領域がクリティカルでない場合に、CPU のオーバーヘッドを削減できます。それ以外の場合は、データが特に圧縮可能でないと予測されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">innodb_compression_failure_threshold_pct</code> には、圧縮テーブルへの更新時に<a class="link" href="glossary.html#glos_compression_failure" title="圧縮失敗">圧縮が失敗</a>したときのカットオフポイントが指定されます。 このしきい値を超えると、MySQL は、最大で <code class="literal">innodb_compression_pad_pct_max</code> で指定されたページサイズの割合まで空き領域の量を動的に調整することで、新しい各圧縮済みページ内に追加の空き領域を残し始めます。 
          </p></li><li class="listitem"><p>
            <code class="literal">innodb_compression_pad_pct_max</code> を使用すると、ページ全体を再度圧縮する必要なしで、変更を圧縮済み行に記録するための各<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>内に予約されている領域の最大量を調整できます。 値を大きくすると、ページを再度圧縮せずに記録できる変更の量が多くなります。 MySQL では、実行時に指定した割合の圧縮操作に<span class="quote">「<span class="quote"><a class="link" href="glossary.html#glos_compression_failure" title="圧縮失敗">失敗した</a></span>」</span>ときにのみ、各圧縮テーブル内にあるページ用に可変量の空き領域が使用されますが、圧縮済みページを分割するために負荷の高い操作が必要となります。 
          </p></li><li class="listitem"><p>
            <code class="literal">innodb_log_compressed_pages</code> では、<a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">redo log</a> への <a class="link" href="glossary.html#glos_compression" title="圧縮">re-compressed</a> <a class="link" href="glossary.html#glos_page" title="ページ">pages</a> のイメージの書込みを無効にできます。 圧縮されたデータが変更されると、再圧縮が発生する場合があります。 このオプションは、リカバリ時に異なるバージョンの <code class="literal">zlib</code> 圧縮アルゴリズムが使用された場合に発生する可能性がある破損を防ぐために、デフォルトで有効になっています。 <code class="literal">zlib</code> のバージョンが変更されないことが確実な場合は、<code class="literal">innodb_log_compressed_pages</code> を無効にして、圧縮データを変更するワークロードの redo ログ生成を減らします。 
          </p></li></ul></div><p>
        圧縮済みデータを操作すると、圧縮済みと非圧縮の両方のバージョンのページが同時にメモリー内に保持されるため、OLTP スタイルのワークロードで圧縮を使用するときは、<code class="literal">innodb_buffer_pool_size</code> 構成オプションの値を大きくする準備をしてください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-compression-syntax-warnings"></a>15.9.1.7 SQL 圧縮構文の警告とエラー</h4></div></div></div><p>
        このセクションでは、<a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースおよび <a class="link" href="glossary.html#glos_general_tablespace" title="一般テーブルスペース">general tablespaces</a> でテーブル圧縮機能を使用する際に発生する可能性がある構文の警告およびエラーについて説明します。
      </p><h5><a name="idm44761358926272"></a>File-Per-Table テーブルスペースに対する SQL 圧縮構文の警告およびエラー</h5><p>
        <code class="literal">innodb_strict_mode</code> が有効な場合 (デフォルト)、<code class="literal">CREATE TABLE</code> ステートメントまたは <code class="literal">ALTER TABLE</code> ステートメントで <code class="literal">ROW_FORMAT=COMPRESSED</code> または <code class="literal">KEY_BLOCK_SIZE</code> を指定すると、<code class="literal">innodb_file_per_table</code> が無効な場合に次のエラーが生成されます。
      </p><pre class="programlisting">ERROR 1031 (HY000): Table storage engine for 't1' doesn't have this option
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          現在の構成では圧縮テーブルの使用が許可されていないため、テーブルは作成されません。
        </p></div><p>
        <code class="literal">innodb_strict_mode</code> が無効になっている場合、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントで <code class="literal">ROW_FORMAT=COMPRESSED</code> または <code class="literal">KEY_BLOCK_SIZE</code> を指定すると、<code class="literal">innodb_file_per_table</code> が無効になっていると次の警告が生成されます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+---------+------+---------------------------------------------------------------+
| Level   | Code | Message                                                       |
+---------+------+---------------------------------------------------------------+
| Warning | 1478 | InnoDB: KEY_BLOCK_SIZE requires innodb_file_per_table.        |
| Warning | 1478 | InnoDB: ignoring KEY_BLOCK_SIZE=4.                            |
| Warning | 1478 | InnoDB: ROW_FORMAT=COMPRESSED requires innodb_file_per_table. |
| Warning | 1478 | InnoDB: assuming ROW_FORMAT=DYNAMIC.                          |
+---------+------+---------------------------------------------------------------+
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          これらのメッセージは単なる警告であり、エラーではありません。オプションが指定されていない場合と同様に、テーブルは圧縮なしで作成されます。
        </p></div><p>
        <span class="quote">「<span class="quote">厳密でない</span>」</span>動作を使用すると、ソースデータベースに圧縮テーブルが含まれていない場合でも、圧縮テーブルがサポートされていないデータベースに <code class="literal">mysqldump</code> ファイルをインポートできます。 その場合、MySQL は、操作を妨げるかわりに <code class="literal">ROW_FORMAT=DYNAMIC</code> にテーブルを作成します。 
      </p><p>
        ダンプファイルを新しいデータベースにインポートし、元のデータベースに存在するとおりにテーブルを再作成するには、サーバーに <code class="literal">innodb_file_per_table</code> 構成パラメータの適切な設定があることを確認します。
      </p><p>
        <code class="literal">KEY_BLOCK_SIZE</code> 属性は、<code class="literal">ROW_FORMAT</code> が <code class="literal">COMPRESSED</code> として指定されているか、省略されている場合にのみ許可されます。 その他の <code class="literal">ROW_FORMAT</code> とともに <code class="literal">KEY_BLOCK_SIZE</code> を指定すると、<code class="literal">SHOW WARNINGS</code> を使用して表示できる警告が生成されます。 ただし、テーブルは非圧縮です。つまり、指定された <code class="literal">KEY_BLOCK_SIZE</code> は無視されます。 
      </p><div class="informaltable"><table summary="Warning level, error code, and message text for messages that could be generated when using conflicting clauses for InnoDB table compression."><col style="width: 20%"><col style="width: 20%"><col style="width: 60%"><thead><tr>
            <th scope="col">レベル</th>
            <th scope="col">コード</th>
            <th scope="col">メッセージ</th>
          </tr></thead><tbody><tr>
            <th scope="row">警告</th>
            <td>1478</td>
            <td><code class="literal"> InnoDB: ignoring KEY_BLOCK_SIZE=<em class="replaceable"><code>n</code></em> unless ROW_FORMAT=COMPRESSED. </code></td>
          </tr></tbody></table></div><p>
        <code class="literal">innodb_strict_mode</code> が有効になっている状態で実行している場合は、<code class="literal">COMPRESSED</code> 以外の任意の <code class="literal">ROW_FORMAT</code> と <code class="literal">KEY_BLOCK_SIZE</code> を組み合わせると警告ではなく、エラーが生成され、テーブルは作成されません。
      </p><p>
        <a class="xref" href="innodb-storage-engine.html#innodb-compression-create-and-alter-options-table" title="表 15.12 ROW_FORMAT および KEY_BLOCK_SIZE のオプション">表15.12「ROW_FORMAT および KEY_BLOCK_SIZE のオプション」</a> では、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> で使用される <code class="literal">ROW_FORMAT</code> および <code class="literal">KEY_BLOCK_SIZE</code> のオプションの概要を示します。
      </p><div class="table"><a name="innodb-compression-create-and-alter-options-table"></a><p class="title"><b>表 15.12 ROW_FORMAT および KEY_BLOCK_SIZE のオプション</b></p><div class="table-contents"><table summary="ROW_FORMAT and KEY_BLOCK_SIZE option usage notes and descriptions."><col style="width: 20%"><col style="width: 40%"><col style="width: 40%"><thead><tr>
            <th scope="col">オプション</th>
            <th scope="col">使用上の注意</th>
            <th scope="col">説明</th>
          </tr></thead><tbody><tr>
            <th scope="row"><code class="literal">ROW_FORMAT=​REDUNDANT</code></th>
            <td>MySQL 5.0.3 よりも前で使用されていたストレージフォーマット</td>
            <td><code class="literal">ROW_FORMAT=COMPACT</code> よりも効率性が低く、下位互換性を保つためのものです。</td>
          </tr><tr>
            <th scope="row"><code class="literal">ROW_FORMAT=​COMPACT</code></th>
            <td>MySQL 5.0.3 以降でのデフォルトのストレージフォーマット</td>
            <td>クラスタ化されたインデックスページに、768 バイトの長いカラム値のプリフィクスが格納され、残りのバイトはオーバーフローページに格納されます。</td>
          </tr><tr>
            <th scope="row"><code class="literal">ROW_FORMAT=​DYNAMIC</code></th>
            <td></td>
            <td>クラスタ化されたインデックスページ内に収まる場合は、そのページ内に値が保存されます。収まらない場合は、オーバーフローページへの 20 バイトのポインタのみが (プリフィクスなしで) 格納されます。</td>
          </tr><tr>
            <th scope="row"><code class="literal">ROW_FORMAT=​COMPRESSED</code></th>
            <td></td>
            <td>zlib を使用してテーブルとインデックスを圧縮</td>
          </tr><tr>
            <th scope="row"><code class="literal">KEY_BLOCK_​SIZE=<em class="replaceable"><code>n</code></em></code></th>
            <td></td>
            <td>圧縮されたページサイズとして 1、2、4、8 または 16 KB を指定します。これは <code class="literal">ROW_FORMAT=COMPRESSED</code> を意味します。 一般的なテーブルスペースの場合、<code class="literal">InnoDB</code> ページサイズと等しい <code class="literal">KEY_BLOCK_SIZE</code> 値は許可されません。 </td>
          </tr></tbody></table></div></div><br class="table-break"><p>
        <a class="xref" href="innodb-storage-engine.html#innodb-compression-create-and-alter-errors-table" title="表 15.13 InnoDB 厳密モードがオフになっているときの CREATE/ALTER TABLE の警告とエラー">表15.13「InnoDB 厳密モードがオフになっているときの CREATE/ALTER TABLE の警告とエラー」</a>では、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメント上で、構成パラメータとオプションの特定の組み合わせで発生するエラー状況、およびオプションが <code class="literal">SHOW TABLE STATUS</code> の出力に表示される方法について簡単に説明しています。
      </p><p>
        <code class="literal">innodb_strict_mode</code> が <code class="literal">OFF</code> の場合、MySQL によってテーブルが作成または変更されますが、次に示すように特定の設定は無視されます。 警告メッセージは、MySQL エラーログで確認できます。 <code class="literal">innodb_strict_mode</code> が <code class="literal">ON</code> の場合、このような特定のオプションの組み合わせでエラーが生成され、テーブルは作成または変更されません。 エラー状況の完全な説明を参照するには、次に示すように、<code class="literal">SHOW ERRORS</code> ステートメントを発行します。 

</p><pre class="screen">mysql&gt; <strong class="userinput"><code>CREATE TABLE x (id INT PRIMARY KEY, c INT)
</code></strong>
-&gt; <strong class="userinput"><code>ENGINE=INNODB KEY_BLOCK_SIZE=33333;
</code></strong>
ERROR 1005 (HY000): Can't create table 'test.x' (errno: 1478)

mysql&gt; <strong class="userinput"><code>SHOW ERRORS;</code></strong>
+-------+------+-------------------------------------------+
| Level | Code | Message                                   |
+-------+------+-------------------------------------------+
| Error | 1478 | InnoDB: invalid KEY_BLOCK_SIZE=33333.     |
| Error | 1005 | Can't create table 'test.x' (errno: 1478) |
+-------+------+-------------------------------------------+
</pre><p>
      </p><div class="table"><a name="innodb-compression-create-and-alter-errors-table"></a><p class="title"><b>表 15.13 InnoDB 厳密モードがオフになっているときの CREATE/ALTER TABLE の警告とエラー</b></p><div class="table-contents"><table summary="CREATE and ALTER TABLE warnings and errors when InnoDB strict mode is OFF."><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"><thead><tr>
            <th scope="col">構文</th>
            <th scope="col">警告またはエラーの状況</th>
            <th scope="col">結果として <code class="literal">SHOW TABLE STATUS</code> に表示される <code class="literal">ROW_FORMAT</code></th>
          </tr></thead><tbody><tr>
            <th scope="row"><code class="literal">ROW_FORMAT=REDUNDANT</code></th>
            <td>なし</td>
            <td><code class="literal">REDUNDANT</code></td>
          </tr><tr>
            <th scope="row"><code class="literal">ROW_FORMAT=COMPACT</code></th>
            <td>なし</td>
            <td><code class="literal">COMPACT</code></td>
          </tr><tr>
            <th scope="row"><code class="literal">ROW_FORMAT=COMPRESSED</code> または <code class="literal">ROW_FORMAT=DYNAMIC</code>、または <code class="literal">KEY_BLOCK_SIZE</code> が指定されている</th>
            <td><code class="literal">innodb_file_per_table</code> が有効になっていないかぎり、file-per-table テーブルスペースでは無視されます。 一般テーブルスペースでは、すべての行形式がサポートされます。 <a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="15.6.3.3 一般テーブルスペース">セクション15.6.3.3「一般テーブルスペース」</a>を参照してください。 </td>
            <td><code class="literal">the default row format for file-per-table tablespaces; the specified row format for general tablespaces</code></td>
          </tr><tr>
            <th scope="row">無効な <code class="literal">KEY_BLOCK_SIZE</code> (1、2、4、8、または 16 以外) が指定されている</th>
            <td><code class="literal">KEY_BLOCK_SIZE</code> が無視されます。</td>
            <td>指定された行フォーマットまたはデフォルトの行フォーマット</td>
          </tr><tr>
            <th scope="row"><code class="literal">ROW_FORMAT=COMPRESSED</code> および有効な <code class="literal">KEY_BLOCK_SIZE</code> が指定されている</th>
            <td>なし。指定した <code class="literal">KEY_BLOCK_SIZE</code> が使用されます</td>
            <td><code class="literal">COMPRESSED</code></td>
          </tr><tr>
            <th scope="row"><code class="literal">REDUNDANT</code>、<code class="literal">COMPACT</code>、または <code class="literal">DYNAMIC</code> 行フォーマットを使用して <code class="literal">KEY_BLOCK_SIZE</code> が指定されている</th>
            <td><code class="literal">KEY_BLOCK_SIZE</code> が無視されます。</td>
            <td><code class="literal">REDUNDANT</code>、<code class="literal">COMPACT</code>、または <code class="literal">DYNAMIC</code></td>
          </tr><tr>
            <th scope="row"><code class="literal">ROW_FORMAT</code> が <code class="literal">REDUNDANT</code>、<code class="literal">COMPACT</code>、<code class="literal">DYNAMIC</code>、または <code class="literal">COMPRESSED</code> のいずれでもない</th>
            <td>MySQL パーサーで認識される場合は無視されます。 その他の場合は、エラーが発行されます。 </td>
            <td>デフォルトの行フォーマットまたは N/A</td>
          </tr></tbody></table></div></div><br class="table-break"><p>
        <code class="literal">innodb_strict_mode</code> が <code class="literal">ON</code> の場合、MySQL は無効な <code class="literal">ROW_FORMAT</code> または <code class="literal">KEY_BLOCK_SIZE</code> パラメータを拒否し、エラーを発行します。 厳密モードはデフォルトで <code class="literal">ON</code> です。 <code class="literal">innodb_strict_mode</code> が <code class="literal">OFF</code> の場合、MySQL は無視された無効なパラメータに対してエラーではなく警告を発行します。 
      </p><p>
        <code class="literal">SHOW TABLE STATUS</code> を使用して選択した <code class="literal">KEY_BLOCK_SIZE</code> を表示できません。 <code class="literal">SHOW CREATE TABLE</code> ステートメントでは、(テーブルの作成時に無視された場合でも) <code class="literal">KEY_BLOCK_SIZE</code> が表示されます。 テーブルの実際の圧縮済みページサイズは、MySQL では表示できません。 
      </p><h5><a name="idm44761358771040"></a>一般的なテーブルスペースに対する SQL 圧縮構文の警告およびエラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブルスペースの作成時に一般テーブルスペースに対して <code class="literal">FILE_BLOCK_SIZE</code> が定義されていない場合、テーブルスペースに圧縮テーブルを含めることはできません。 圧縮テーブルを追加しようとすると、次の例に示すようにエラーが返されます: 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts1` ADD DATAFILE 'ts1.ibd' Engine=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts1 ROW_FORMAT=COMPRESSED</code></strong>
       <strong class="userinput"><code>KEY_BLOCK_SIZE=8;</code></strong>
ERROR 1478 (HY000): InnoDB: Tablespace `ts1` cannot contain a COMPRESSED table
</pre></li><li class="listitem"><p>
            無効な <code class="literal">KEY_BLOCK_SIZE</code> を含むテーブルを一般テーブルスペースに追加しようとすると、次の例に示すようにエラーが返されます:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts2` ADD DATAFILE 'ts2.ibd' FILE_BLOCK_SIZE = 8192 Engine=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (c1 INT PRIMARY KEY) TABLESPACE ts2 ROW_FORMAT=COMPRESSED</code></strong>
       <strong class="userinput"><code>KEY_BLOCK_SIZE=4;</code></strong>
ERROR 1478 (HY000): InnoDB: Tablespace `ts2` uses block size 8192 and cannot
contain a table with physical page size 4096</pre><p>
            一般的なテーブルスペースの場合、テーブルの <code class="literal">KEY_BLOCK_SIZE</code> は、テーブルスペースの <code class="literal">FILE_BLOCK_SIZE</code> を 1024 で割ったものである必要があります。 たとえば、テーブルスペースの <code class="literal">FILE_BLOCK_SIZE</code> が 8192 の場合、テーブルの <code class="literal">KEY_BLOCK_SIZE</code> は 8 である必要があります。 
          </p></li><li class="listitem"><p>
            圧縮されていない行形式のテーブルを、圧縮テーブルを格納するように構成された一般的なテーブルスペースに追加しようとすると、次の例に示すようにエラーが返されます:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts3` ADD DATAFILE 'ts3.ibd' FILE_BLOCK_SIZE = 8192 Engine=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t3 (c1 INT PRIMARY KEY) TABLESPACE ts3 ROW_FORMAT=COMPACT;</code></strong>
ERROR 1478 (HY000): InnoDB: Tablespace `ts3` uses block size 8192 and cannot
contain a table with physical page size 16384</pre></li></ul></div><p>
        <code class="literal">innodb_strict_mode</code> は、一般的なテーブルスペースには適用できません。 一般的なテーブルスペースのテーブルスペース管理ルールは、<code class="literal">innodb_strict_mode</code> とは無関係に厳密に適用されます。 詳細は、<a class="xref" href="sql-statements.html#create-tablespace" title="13.1.21 CREATE TABLESPACE ステートメント">セクション13.1.21「CREATE TABLESPACE ステートメント」</a>を参照してください。 
      </p><p>
        一般的なテーブルスペースでの圧縮テーブルの使用の詳細は、<a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="15.6.3.3 一般テーブルスペース">セクション15.6.3.3「一般テーブルスペース」</a> を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-page-compression"></a>15.9.2 InnoDB ページ圧縮</h3></div></div></div><a class="indexterm" name="idm44761358745328"></a><a class="indexterm" name="idm44761358744272"></a><p>
      <code class="literal">InnoDB</code> では、<a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースに存在するテーブルのページレベルの圧縮がサポートされます。 この機能は、<span class="emphasis"><em>透過的ページ圧縮</em></span>と呼ばれます。 ページ圧縮を有効にするには、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> で <code class="literal">COMPRESSION</code> 属性を指定します。 サポートされている圧縮アルゴリズムには、<code class="literal">Zlib</code> および <code class="literal">LZ4</code> があります。 
    </p><h4><a name="idm44761358735808"></a>サポートされるプラットフォーム</h4><p>
      ページ圧縮には、スパースファイルおよびホールパンチのサポートが必要です。 ページ圧縮は、NTFS を使用する Windows、およびカーネルレベルでホールパンチングサポートが提供される MySQL-supported Linux プラットフォームの次のサブセットでサポートされます: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          RHEL 7 およびカーネルバージョン 3.10.0-123 以降を使用する派生ディストリビューション
        </p></li><li class="listitem"><p>
          OEL 5.10 (UEK2) カーネルバージョン 2.6.39 以上
        </p></li><li class="listitem"><p>
          OEL 6.5 (UEK3) カーネルバージョン 3.8.13 以上
        </p></li><li class="listitem"><p>
          OEL 7.0 カーネルバージョン 3.8.13 以上
        </p></li><li class="listitem"><p>
          SLE11 カーネルバージョン 3.0-x
        </p></li><li class="listitem"><p>
          SLE12 カーネルバージョン 3.12-x
        </p></li><li class="listitem"><p>
          OES11 カーネルバージョン 3.0-x
        </p></li><li class="listitem"><p>
          Ubuntu 14.0.4 LTS カーネルバージョン 3.13 以上
        </p></li><li class="listitem"><p>
          Ubuntu 12.0.4 LTS カーネルバージョン 3.2 以上
        </p></li><li class="listitem"><p>
          Debian 7 カーネルバージョン 3.2 以上
        </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        特定の Linux ディストリビューションで使用可能なすべてのファイルシステムでホールパンチがサポートされていない場合があります。
      </p></div><h4><a name="idm44761358723088"></a>ページ圧縮の仕組み</h4><p>
      ページが書き込まれると、指定された圧縮アルゴリズムを使用して圧縮されます。 圧縮されたデータはディスクに書き込まれ、ホールパンチングメカニズムによってページの最後から空のブロックが解放されます。 圧縮に失敗すると、データはそのまま書き出されます。 
    </p><h4><a name="idm44761358721344"></a>Linux の穴パンチサイズ</h4><p>
      Linux システムでは、ファイルシステムのブロックサイズはホールパンチに使用される単位サイズです。 したがって、ページ圧縮は、<code class="literal">InnoDB</code> ページサイズからファイルシステムのブロックサイズを引いたサイズ以下のサイズにページデータを圧縮できる場合にのみ機能します。 たとえば、<code class="literal">innodb_page_size=16K</code> でファイルシステムのブロックサイズが 4K の場合、ホールパンチを可能にするには、ページデータを 12K 以下に圧縮する必要があります。 
    </p><h4><a name="idm44761358717360"></a>Windows でのホールパンチングサイズ</h4><p>
      Windows システムでは、疎ファイルの基盤となるインフラストラクチャは NTFS 圧縮に基づいています。 ホールパンチングサイズは NTFS 圧縮ユニットで、NTFS クラスタサイズの 16 倍です。 次のテーブルに、クラスタサイズとその圧縮単位を示します: 
    </p><div class="table"><a name="idm44761358715520"></a><p class="title"><b>表 15.14 Windows NTFS クラスタのサイズと圧縮単位</b></p><div class="table-contents"><table frame="all" summary="Windows NTFS cluster size and compression units."><col style="width: 50%"><col style="width: 50%"><thead><tr>
          <th>クラスタサイズ</th>
          <th>圧縮単位</th>
        </tr></thead><tbody><tr>
          <td>512 バイト</td>
          <td>8 KB</td>
        </tr><tr>
          <td>1 KB</td>
          <td>16 KB</td>
        </tr><tr>
          <td>2 KB</td>
          <td>32 KB</td>
        </tr><tr>
          <td>4 KB</td>
          <td>64 KB</td>
        </tr></tbody></table></div></div><br class="table-break"><p>
      Windows システムでのページ圧縮は、ページデータを <code class="literal">InnoDB</code> ページサイズから圧縮単位サイズを引いた値以下のサイズに圧縮できる場合にのみ機能します。
    </p><p>
      NTFS クラスタのデフォルトサイズは 4KB で、圧縮単位のサイズは 64KB です。 つまり、デフォルトの Windows NTFS 構成では、最大 <code class="literal">innodb_page_size</code> も 64KB であるため、ページ圧縮にメリットはありません。 
    </p><p>
      ページ圧縮を Windows で機能させるには、ファイルシステムを 4K より小さいクラスタサイズで作成し、<code class="literal">innodb_page_size</code> を圧縮ユニットの 2 倍以上のサイズにする必要があります。 たとえば、ページ圧縮が Windows で機能するようにするには、512 バイト (圧縮単位は 8KB) のクラスタサイズでファイルシステムを構築し、16K 以上の <code class="literal">innodb_page_size</code> 値で <code class="literal">InnoDB</code> を初期化します。 
    </p><h4><a name="idm44761358693456"></a>ページ圧縮の有効化</h4><p>
      ページ圧縮を有効にするには、<code class="literal">CREATE TABLE</code> ステートメントで <code class="literal">COMPRESSION</code> 属性を指定します。 例: 
    </p><pre class="programlisting">CREATE TABLE t1 (c1 INT) COMPRESSION="zlib";
</pre><p>
      <code class="literal">ALTER TABLE</code> ステートメントでページ圧縮を有効にすることもできます。 ただし、<code class="literal">ALTER TABLE ... COMPRESSION</code> ではテーブルスペース圧縮属性のみが更新されます。 新しい圧縮アルゴリズムの設定後に発生したテーブルスペースへの書込みでは新しい設定が使用されますが、新しい圧縮アルゴリズムを既存のページに適用するには、<code class="literal">OPTIMIZE TABLE</code> を使用してテーブルを再構築する必要があります。 
    </p><pre class="programlisting">ALTER TABLE t1 COMPRESSION="zlib";
OPTIMIZE TABLE t1;
</pre><h4><a name="idm44761358683968"></a>ページ圧縮の無効化</h4><p>
      ページ圧縮を無効にするには、<code class="literal">ALTER TABLE</code> を使用して <code class="literal">COMPRESSION=None</code> を設定します。 <code class="literal">COMPRESSION=None</code> の設定後に発生するテーブルスペースへの書込みでは、ページ圧縮は使用されなくなりました。 既存のページを解凍するには、<code class="literal">COMPRESSION=None</code> の設定後に <code class="literal">OPTIMIZE TABLE</code> を使用してテーブルを再構築する必要があります。 
    </p><pre class="programlisting">ALTER TABLE t1 COMPRESSION="None";
OPTIMIZE TABLE t1;
</pre><h4><a name="idm44761358677104"></a>ページ圧縮メタデータ</h4><p>
      ページ圧縮メタデータは、<code class="literal">INFORMATION_SCHEMA.INNODB_TABLESPACES</code> テーブルの次のカラムにあります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">FS_BLOCK_SIZE</code>: ホールパンチングに使用される単位サイズであるファイルシステムのブロックサイズ。
        </p></li><li class="listitem"><p>
          <code class="literal">FILE_SIZE</code>: 圧縮解除されたファイルの最大サイズを表す、ファイルの見かけ上のサイズ。
        </p></li><li class="listitem"><p>
          <code class="literal">ALLOCATED_SIZE</code>: ファイルの実際のサイズ。これは、ディスクに割り当てられた領域の量です。
        </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        Unix に似たシステムでは、<code class="literal">ls -l <em class="replaceable"><code>tablespace_name</code></em>.ibd</code> は明らかなファイルサイズ (<code class="literal">FILE_SIZE</code> と同等) をバイト単位で表示します。 ディスクに割り当てられている実際の領域の量 (<code class="literal">ALLOCATED_SIZE</code> と同等) を表示するには、<code class="literal">du --block-size=1 <em class="replaceable"><code>tablespace_name</code></em>.ibd</code> を使用します。 <code class="literal">--block-size=1</code> オプションは、割り当てられた領域をブロックではなくバイト単位で出力するため、<code class="literal">ls -l</code> 出力と比較できます。 
      </p><p>
        <code class="literal">SHOW CREATE TABLE</code> を使用して、現在のページ圧縮設定 (<code class="literal">Zlib</code>、<code class="literal">Lz4</code> または <code class="literal">None</code>) を表示します。 テーブルには、異なる圧縮設定を持つページが混在する場合があります。 
      </p></div><p>
      次の例では、employees テーブルのページ圧縮メタデータが <code class="literal">INFORMATION_SCHEMA.INNODB_TABLESPACES</code> テーブルから取得されます。
    </p><pre class="programlisting"># Create the employees table with Zlib page compression

CREATE TABLE employees (
    emp_no      INT             NOT NULL,
    birth_date  DATE            NOT NULL,
    first_name  VARCHAR(14)     NOT NULL,
    last_name   VARCHAR(16)     NOT NULL,
    gender      ENUM ('M','F')  NOT NULL,
    hire_date   DATE            NOT NULL,
    PRIMARY KEY (emp_no)
) COMPRESSION="zlib";

# Insert data (not shown)

# Query page compression metadata in INFORMATION_SCHEMA.INNODB_TABLESPACES

mysql&gt; <strong class="userinput"><code>SELECT SPACE, NAME, FS_BLOCK_SIZE, FILE_SIZE, ALLOCATED_SIZE FROM</code></strong>
       <strong class="userinput"><code>INFORMATION_SCHEMA.INNODB_TABLESPACES WHERE NAME='employees/employees'\G</code></strong>
*************************** 1. row ***************************
SPACE: 45
NAME: employees/employees
FS_BLOCK_SIZE: 4096
FILE_SIZE: 23068672
ALLOCATED_SIZE: 19415040
</pre><p>
      employees テーブルのページ圧縮メタデータは、明らかなファイルサイズが 23068672 バイトで、実際のファイルサイズ (ページ圧縮あり) が 19415040 バイトであることを示しています。 ファイルシステムのブロックサイズは 4096 バイトで、ホールパンチに使用されるブロックサイズです。 
    </p><h4><a name="idm44761358652448"></a>ページ圧縮を使用したテーブルの識別</h4><p>
      ページ圧縮が有効になっているテーブルを識別するには、<code class="literal">COMPRESSION</code> 属性で定義されているテーブルの <code class="literal">INFORMATION_SCHEMA.TABLES</code> <code class="literal">CREATE_OPTIONS</code> カラムをクエリーします:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, TABLE_SCHEMA, CREATE_OPTIONS FROM INFORMATION_SCHEMA.TABLES </code></strong>
       <strong class="userinput"><code>WHERE CREATE_OPTIONS LIKE '%COMPRESSION=%';</code></strong>
+------------+--------------+--------------------+
| TABLE_NAME | TABLE_SCHEMA | CREATE_OPTIONS     |
+------------+--------------+--------------------+
| employees  | test         | COMPRESSION="zlib" |
+------------+--------------+--------------------+
</pre><p>
      <code class="literal">SHOW CREATE TABLE</code> では、<code class="literal">COMPRESSION</code> 属性も表示されます (使用されている場合)。
    </p><h4><a name="idm44761358643680"></a>ページ圧縮の制限事項と使用上のノート</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ファイルシステムのブロックサイズ (または Windows の場合は圧縮単位サイズ) * 2 &gt; <code class="literal">innodb_page_size</code> の場合、ページ圧縮は無効になります。
        </p></li><li class="listitem"><p>
          システムテーブルスペース、一時テーブルスペースおよび一般テーブルスペースを含む共有テーブルスペースに存在するテーブルでは、ページ圧縮はサポートされていません。
        </p></li><li class="listitem"><p>
          undo ログテーブルスペースではページ圧縮はサポートされていません。
        </p></li><li class="listitem"><p>
          redo ログページでは、ページ圧縮はサポートされていません。
        </p></li><li class="listitem"><p>
          空間インデックスに使用される R ツリーページは圧縮されません。
        </p></li><li class="listitem"><p>
          圧縮テーブル (<code class="literal">ROW_FORMAT=COMPRESSED</code>) に属するページはそのまま残ります。
        </p></li><li class="listitem"><p>
          リカバリ中、更新されたページは圧縮されていない形式で書き出されます。
        </p></li><li class="listitem"><p>
          使用された圧縮アルゴリズムをサポートしていないサーバーにページ圧縮テーブルスペースをロードすると、I/O エラーが発生します。
        </p></li><li class="listitem"><p>
          ページ圧縮をサポートしていない以前のバージョンの MySQL にダウングレードする前に、ページ圧縮機能を使用するテーブルを解凍します。 テーブルを解凍するには、<code class="literal">ALTER TABLE ... COMPRESSION=None</code> および <code class="literal">OPTIMIZE TABLE</code> を実行します。 
        </p></li><li class="listitem"><p>
          ページ圧縮されたテーブルスペースは、使用された圧縮アルゴリズムが両方のサーバーで使用可能な場合、Linux サーバーと Windows サーバーの間でコピーできます。
        </p></li><li class="listitem"><p>
          ページ圧縮されたテーブルスペースファイルをあるホストから別のホストに移動する際にページ圧縮を保持するには、スパースファイルを保持するユーティリティが必要です。
        </p></li><li class="listitem"><p>
          NVMFS はパンチ穴機能を利用するように設計されているため、NVMFS を搭載した Fusion-io ハードウェアでは、他のプラットフォームよりも優れたページ圧縮を実現できます。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> ページサイズが大きく、ファイルシステムのブロックサイズが比較的小さいページ圧縮機能を使用すると、書込み増幅が発生する可能性があります。 たとえば、ファイルシステムのブロックサイズが 4KB の 64KB の最大 <code class="literal">InnoDB</code> ページサイズでは、圧縮が改善されますが、バッファプールに対する需要が増加し、I/O および書込み増幅が増加する可能性があります。 
        </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-row-format"></a>15.10 InnoDB の行フォーマット</h2></div></div></div><p>
    テーブルの行形式によって、その行が物理的に格納される方法が決まり、クエリーおよび DML 操作のパフォーマンスに影響を与える可能性があります。 単一のディスクページに収まる行数が多いほど、クエリーおよびインデックス検索の動作が速くなり、バッファプールに必要なキャッシュメモリーが少なくなり、更新された値を書き出すために必要な I/O が少なくなります。 
  </p><p>
    各テーブルのデータは複数のページに分かれています。 各テーブルを構成するページは、B ツリーインデックスと呼ばれるツリーデータ構造で配置されます。 テーブルデータとセカンダリインデックスはどちらも、このタイプの構造を使用します。 テーブル全体を表す B ツリーインデックスは、クラスタ化されたインデックスと呼ばれます。これは、主キーカラムに従って編成されます。 クラスタ化されたインデックスデータ構造のノードには、行のすべてのカラムの値が含まれます。 セカンダリインデックス構造のノードには、インデックスカラムと主キーカラムの値が含まれます。 
  </p><p>
    可変長カラムは、カラム値が B ツリーインデックスノードに格納されるというルールの例外です。 長すぎて B ツリーページに収まらない可変長カラムは、オーバーフローページと呼ばれる個別に割り当てられたディスクページに格納されます。 このようなカラムは、オフページカラムと呼ばれます。 オフページカラムの値は、オーバーフローページの単一リンクリストに格納され、このような各カラムには 1 つ以上のオーバーフローページの独自のリストがあります。 カラムの長さに応じて、可変長のカラム値のすべてまたは接頭辞が B ツリーに格納され、記憶域が無駄になり、別のページを読み取る必要がなくなります。 
  </p><p>
    <code class="literal">InnoDB</code> ストレージエンジンは 4 つの行フォーマットをサポートしています: <code class="literal">REDUNDANT</code>, <code class="literal">COMPACT</code>, <code class="literal">DYNAMIC</code> および <code class="literal">COMPRESSED</code>。
  </p><div class="table"><a name="innodb-row-format-overview"></a><p class="title"><b>表 15.15 InnoDB の行フォーマットの概要</b></p><div class="table-contents"><table summary="Overview of InnoDB row formats incuding a description, supported features, and supported tablespace types."><col style="width: 10%"><col style="width: 18%"><col style="width: 18%"><col style="width: 18%"><col style="width: 18%"><col style="width: 18%"><thead><tr>
        <th scope="col">行フォーマット</th>
        <th scope="col">コンパクトなストレージ特性</th>
        <th scope="col">可変長カラム記憶域の拡張</th>
        <th scope="col">大きいインデックスキー接頭辞のサポート</th>
        <th scope="col">圧縮のサポート</th>
        <th scope="col">サポートされるテーブルスペースタイプ</th>
      </tr></thead><tbody><tr>
        <th scope="row"><code class="literal">REDUNDANT</code></th>
        <td>いいえ</td>
        <td>いいえ</td>
        <td>いいえ</td>
        <td>いいえ</td>
        <td>システム、file-per-table、一般</td>
      </tr><tr>
        <th scope="row"><code class="literal">COMPACT</code></th>
        <td>はい</td>
        <td>いいえ</td>
        <td>いいえ</td>
        <td>いいえ</td>
        <td>システム、file-per-table、一般</td>
      </tr><tr>
        <th scope="row"><code class="literal">DYNAMIC</code></th>
        <td>はい</td>
        <td>はい</td>
        <td>はい</td>
        <td>いいえ</td>
        <td>システム、file-per-table、一般</td>
      </tr><tr>
        <th scope="row"><code class="literal">COMPRESSED</code></th>
        <td>はい</td>
        <td>はい</td>
        <td>はい</td>
        <td>はい</td>
        <td>file-per-table、general</td>
      </tr></tbody></table></div></div><br class="table-break"><p>
    次のトピックでは、行形式の格納特性と、テーブルの行形式を定義および決定する方法について説明します。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-row-format-redundant" title="REDUNDANT 行形式">REDUNDANT 行形式</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-row-format-compact" title="COMPACT 行フォーマット">COMPACT 行フォーマット</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-row-format-dynamic" title="DYNAMIC 行フォーマット">DYNAMIC 行フォーマット</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-row-format-compressed" title="COMPRESSED 行形式">COMPRESSED 行形式</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-row-format-defining" title="テーブルの行形式の定義">テーブルの行形式の定義</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-row-format-detrmining" title="テーブルの行形式の決定">テーブルの行形式の決定</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-row-format-redundant"></a>REDUNDANT 行形式</h3></div></div></div><a class="indexterm" name="idm44761358562704"></a><a class="indexterm" name="idm44761358560928"></a><p>
      <code class="literal">REDUNDANT</code> 形式は、古いバージョンの MySQL との互換性を提供します。
    </p><p>
      <code class="literal">REDUNDANT</code> 行フォーマットを使用するテーブルでは、可変長カラム値 (<code class="literal">VARCHAR</code>、<code class="literal">VARBINARY</code>、<code class="literal">BLOB</code> および <code class="literal">TEXT</code> タイプ) の最初の 768 バイトが B ツリーノード内のインデックスレコードに格納され、残りはオーバーフローページに格納されます。 768 バイト以上の固定長カラムは可変長カラムとしてエンコードされ、オフページに格納できます。 たとえば、<code class="literal">utf8mb4</code> と同様に、文字セットの最大バイト長が 3 より大きい場合、<code class="literal">CHAR(255)</code> カラムは 768 バイトを超えることがあります。 
    </p><p>
      カラムの値が 768 バイト以下の場合、オーバーフローページは使用されず、値は完全に B ツリーノードに格納されるため、I/O である程度節約できます。 これは比較的短い <code class="literal">BLOB</code> カラム値には適切に機能しますが、B ツリーノードがキー値ではなくデータを埋めるため、効率が低下する可能性があります。 <code class="literal">BLOB</code> カラムが多数あるテーブルでは、B ツリーノードがいっぱいになりすぎて行が少なすぎるため、行が短い場合やカラム値がオフページに格納された場合よりもインデックス全体の効率が低下する可能性があります。 
    </p><h4><a name="innodb-redundant-row-format-characteristics"></a>REDUNDANT 行形式の記憶特性</h4><a class="indexterm" name="idm44761358546112"></a><p>
      <code class="literal">REDUNDANT</code> の行形式には、次のような記憶特性があります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          各インデックスレコードには、6 バイトのヘッダーが含まれています。 ヘッダーは、連続するレコードをリンクし、行レベルロックに使用されます。 
        </p></li><li class="listitem"><p>
          クラスタ化されたインデックス内のレコードには、すべてのユーザー定義カラムのフィールドが含まれます。 さらに、6 バイトのトランザクション ID フィールドと 7 バイトのロールポインタフィールドも含まれています。 
        </p></li><li class="listitem"><p>
          テーブルに主キーが定義されていない場合は、クラスタ化された各インデックスレコードにも 6 バイトの行 ID フィールドが含まれます。
        </p></li><li class="listitem"><p>
          各セカンダリインデックスレコードには、セカンダリインデックスにないクラスタ化されたインデックスキーに定義されたすべての主キーカラムが含まれます。
        </p></li><li class="listitem"><p>
          レコードには、そのレコードの各フィールドへのポインタが含まれます。 レコード内のフィールド長の合計が 128 バイト未満の場合はポインタが 1 バイト、128 バイト以上の場合はポインタが 2 バイトになります。 ポインタの配列はレコードディレクトリと呼ばれます。 ポインタが指す領域は、レコードのデータ部分です。 
        </p></li><li class="listitem"><p>
          <code class="literal">CHAR(10)</code> などの固定長文字カラムは、内部的に固定長形式で格納されます。 末尾の空白は、<code class="literal">VARCHAR</code> カラムから切り捨てられません。 
        </p></li><li class="listitem"><p>
          768 バイト以上の固定長カラムは可変長カラムとしてエンコードされ、オフページに格納できます。 たとえば、<code class="literal">utf8mb4</code> と同様に、文字セットの最大バイト長が 3 より大きい場合、<code class="literal">CHAR(255)</code> カラムは 768 バイトを超えることがあります。 
        </p></li><li class="listitem"><p>
          SQL の <code class="literal">NULL</code> 値では、レコードディレクトリに 1 バイトまたは 2 バイトが予約されます。 SQL <code class="literal">NULL</code> 値は、可変長カラムに格納されている場合、レコードのデータ部分にゼロバイトを予約します。 固定長カラムの場合、カラムの固定長はレコードのデータ部分で予約されます。 <code class="literal">NULL</code> 値の固定領域を予約すると、インデックスページの断片化を発生させることなく、<code class="literal">NULL</code> から <code class="literal">NULL</code> 以外の値にカラムをインプレースで更新できます。 
        </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-row-format-compact"></a>COMPACT 行フォーマット</h3></div></div></div><a class="indexterm" name="idm44761358523680"></a><a class="indexterm" name="idm44761358521904"></a><p>
      <code class="literal">COMPACT</code> の行形式では、<code class="literal">REDUNDANT</code> の行形式と比べて行の記憶領域が約 20% 削減されますが、一部の操作で CPU 使用率が増加します。 ワークロードが、キャッシュヒット率とディスク速度によって制限される通常のワークロードであれば、<code class="literal">COMPACT</code> 形式が高速になる可能性があります。 ワークロードが CPU 速度によって制限されている場合、圧縮形式が遅くなる可能性があります。 
    </p><p>
      <code class="literal">COMPACT</code> 行フォーマットを使用するテーブルでは、可変長カラム値 (<code class="literal">VARCHAR</code>、<code class="literal">VARBINARY</code>、<code class="literal">BLOB</code> および <code class="literal">TEXT</code> タイプ) の最初の 768 バイトが <a class="link" href="glossary.html#glos_b_tree" title="B ツリー">B-tree</a> ノード内のインデックスレコードに格納され、残りはオーバーフローページに格納されます。 768 バイト以上の固定長カラムは可変長カラムとしてエンコードされ、オフページに格納できます。 たとえば、<code class="literal">utf8mb4</code> と同様に、文字セットの最大バイト長が 3 より大きい場合、<code class="literal">CHAR(255)</code> カラムは 768 バイトを超えることがあります。 
    </p><p>
      カラムの値が 768 バイト以下の場合、オーバーフローページは使用されず、値は完全に B ツリーノードに格納されるため、I/O である程度節約できます。 これは比較的短い <code class="literal">BLOB</code> カラム値には適切に機能しますが、B ツリーノードがキー値ではなくデータを埋めるため、効率が低下する可能性があります。 <code class="literal">BLOB</code> カラムが多数あるテーブルでは、B ツリーノードがいっぱいになりすぎて行が少なすぎるため、行が短い場合やカラム値がオフページに格納された場合よりもインデックス全体の効率が低下する可能性があります。 
    </p><h4><a name="innodb-compact-row-format-characteristics"></a>COMPACT 行形式の格納特性</h4><a class="indexterm" name="idm44761358504096"></a><p>
      <code class="literal">COMPACT</code> の行形式には、次のような記憶特性があります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          各インデックスレコードには、前に可変長ヘッダーが付く可能性のある 5 バイトのヘッダーが含まれています。 ヘッダーは、連続するレコードをリンクし、行レベルロックに使用されます。 
        </p></li><li class="listitem"><p>
          レコードヘッダーの可変長部分には、<code class="literal">NULL</code> カラムを示すビットベクトルが含まれています。 <code class="literal">NULL</code> にすることができるインデックス内のカラム数が <em class="replaceable"><code>N</code></em> である場合は、ビットベクトルで <code class="literal">CEILING(<em class="replaceable"><code>N</code></em>/8)</code> バイトが占有されます。 (たとえば、<code class="literal">NULL</code> にすることができるカラムが 9 から 16 までの任意の数だけ存在する場合は、ビットベクトルで 2 バイトが使用されます。) このベクトル内のビット以外の領域は、<code class="literal">NULL</code> のカラムで占有されません。 ヘッダーの可変長部分には、可変長カラムの長さも含まれています。 各長さは、カラムの最大長に応じて、1 バイトと 2 バイトのいずれかになります。 インデックス内のすべてのカラムが <code class="literal">NOT NULL</code> でかつ固定長である場合、レコードヘッダーには可変長部分が含まれません。 
        </p></li><li class="listitem"><p>
          非 <code class="literal">NULL</code> 可変長フィールドごとに、レコードヘッダーに 1 バイトまたは 2 バイトのカラム長が含まれます。 2 バイトが必要なのは、カラムの一部がオーバーフローページに外部的に格納されている場合、または最大長が 255 バイトを超え、実際の長さが 127 バイトを超える場合のみです。 カラムが外部に格納された場合、2 バイトの長さは、内部に格納された部分の長さに、外部に格納された部分への 20 バイトのポインタを加えた長さを示します。 内部の部分は 768 バイトであるため、長さは 768+20 になります。 20 バイトのポインタには、そのカラムの実際の長さが格納されます。 
        </p></li><li class="listitem"><p>
          レコードヘッダーの後に、<code class="literal">NULL</code> 以外のカラムのデータコンテンツが続きます。
        </p></li><li class="listitem"><p>
          クラスタ化されたインデックス内のレコードには、すべてのユーザー定義カラムのフィールドが含まれます。 さらに、6 バイトのトランザクション ID フィールドと 7 バイトのロールポインタフィールドも含まれています。 
        </p></li><li class="listitem"><p>
          テーブルに主キーが定義されていない場合は、クラスタ化された各インデックスレコードにも 6 バイトの行 ID フィールドが含まれます。
        </p></li><li class="listitem"><p>
          各セカンダリインデックスレコードには、セカンダリインデックスにないクラスタ化されたインデックスキーに定義されたすべての主キーカラムが含まれます。 主キーカラムのいずれかが可変長の場合、セカンダリインデックスが固定長カラムに定義されていても、各セカンダリインデックスのレコードヘッダーには長さを記録する可変長部分があります。 
        </p></li><li class="listitem"><p>
          内部的には、可変長文字セットの場合、<code class="literal">CHAR(10)</code> などの固定長文字カラムは固定長形式で格納されます。
        </p><p>
          末尾の空白は、<code class="literal">VARCHAR</code> カラムから切り捨てられません。
        </p></li><li class="listitem"><p>
          内部的に、<code class="literal">utf8mb3</code> や <code class="literal">utf8mb4</code> などの可変長文字セットの場合、<code class="literal">InnoDB</code> は末尾の空白を切り捨てて <code class="literal">CHAR(<em class="replaceable"><code>N</code></em>)</code> を <em class="replaceable"><code>N</code></em> バイトに格納しようとします。 <code class="literal">CHAR(<em class="replaceable"><code>N</code></em>)</code> カラム値のバイト長が <em class="replaceable"><code>N</code></em> バイトを超える場合、後続の空白はカラム値のバイト長の最小値に切り捨てられます。 <code class="literal">CHAR(<em class="replaceable"><code>N</code></em>)</code> カラムの最大長は、最大文字バイト長×<em class="replaceable"><code>N</code></em> です。 
        </p><p>
          <em class="replaceable"><code>N</code></em> の最小バイト数は <code class="literal">CHAR(<em class="replaceable"><code>N</code></em>)</code> 用に予約されています。 多くの場合、<em class="replaceable"><code>N</code></em> の最小領域を予約すると、インデックスページの断片化を発生させずにカラムの更新を実行できます。 比較すると、<code class="literal">CHAR(<em class="replaceable"><code>N</code></em>)</code> カラムは、<code class="literal">REDUNDANT</code> 行形式を使用している場合、最大文字バイト長の <em class="replaceable"><code>N</code></em> を占有します。 
        </p><p>
          768 バイト以上の固定長カラムは可変長フィールドとしてエンコードされ、オフページに格納できます。 たとえば、<code class="literal">utf8mb4</code> と同様に、文字セットの最大バイト長が 3 より大きい場合、<code class="literal">CHAR(255)</code> カラムは 768 バイトを超えることがあります。 
        </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-row-format-dynamic"></a>DYNAMIC 行フォーマット</h3></div></div></div><a class="indexterm" name="idm44761358460800"></a><a class="indexterm" name="idm44761358459024"></a><p>
      <code class="literal">DYNAMIC</code> の行形式では、<code class="literal">COMPACT</code> の行形式と同じ記憶特性が提供されますが、長い可変長カラムの拡張記憶域機能が追加され、大規模なインデックスキー接頭辞がサポートされます。
    </p><p>
      <code class="literal">ROW_FORMAT=DYNAMIC</code> を使用してテーブルを作成する場合、<code class="literal">InnoDB</code> では、オーバーフローページへの 20 バイトポインタのみを含むクラスタインデックスレコードを使用して、長い可変長のカラム値 (<code class="literal">VARCHAR</code>、<code class="literal">VARBINARY</code>、<code class="literal">BLOB</code> および <code class="literal">TEXT</code> タイプの場合) を完全にオフページに格納できます。 768 バイト以上の固定長フィールドは、可変長フィールドとしてエンコードされます。 たとえば、<code class="literal">utf8mb4</code> と同様に、文字セットの最大バイト長が 3 より大きい場合、<code class="literal">CHAR(255)</code> カラムは 768 バイトを超えることがあります。 
    </p><p>
      カラムがオフページに格納されるかどうかは、ページサイズおよび行の合計サイズによって異なります。 行が長すぎる場合、クラスタ化されたインデックスレコードが <a class="link" href="glossary.html#glos_b_tree" title="B ツリー">B-tree</a> ページに収まるまで、最も長いカラムがオフページ記憶域として選択されます。 40 バイト以下の <code class="literal">TEXT</code> および <code class="literal">BLOB</code> カラムは、行に格納されます。 
    </p><p>
      <code class="literal">DYNAMIC</code> の行形式では、(<code class="literal">COMPACT</code> および <code class="literal">REDUNDANT</code> 形式の場合と同様に) インデックスノードに行全体を格納する効率が維持されますが、<code class="literal">DYNAMIC</code> の行形式では、B ツリーノードに大量の長いカラムのデータバイトを入力する問題が回避されます。 <code class="literal">DYNAMIC</code> の行形式は、長いデータ値の一部がオフページに格納されている場合、通常は値全体をオフページに格納する方が効率的です。 <code class="literal">DYNAMIC</code> 形式では、B ツリーノードに短いカラムが残る可能性があるため、特定の行に必要なオーバーフローページの数が最小限に抑えられます。 
    </p><p>
      <code class="literal">DYNAMIC</code> の行形式では、3072 バイトまでのインデックスキー接頭辞がサポートされます。
    </p><p>
      <code class="literal">DYNAMIC</code> 行形式を使用するテーブルは、システムテーブルスペース、file-per-table テーブルスペースおよび一般テーブルスペースに格納できます。 <code class="literal">DYNAMIC</code> テーブルをシステムテーブルスペースに格納するには、<code class="literal">innodb_file_per_table</code> を無効にして通常の <code class="literal">CREATE TABLE</code> ステートメントまたは <code class="literal">ALTER TABLE</code> ステートメントを使用するか、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> で <code class="literal">TABLESPACE [=] innodb_system</code> テーブルオプションを使用します。 <code class="literal">innodb_file_per_table</code> 変数は、一般的なテーブルスペースには適用されず、<code class="literal">TABLESPACE [=] innodb_system</code> テーブルオプションを使用して <code class="literal">DYNAMIC</code> テーブルをシステムテーブルスペースに格納する場合にも適用されません。 
    </p><h4><a name="innodb-dynamic-row-format-characteristics"></a>DYNAMIC 行フォーマットの格納特性</h4><a class="indexterm" name="idm44761358424368"></a><p>
      <code class="literal">DYNAMIC</code> の行フォーマットは、<code class="literal">COMPACT</code> の行フォーマットのバリエーションです。 記憶特性については、<a class="xref" href="innodb-storage-engine.html#innodb-compact-row-format-characteristics" title="COMPACT 行形式の格納特性">COMPACT 行形式の格納特性</a> を参照してください。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-row-format-compressed"></a>COMPRESSED 行形式</h3></div></div></div><a class="indexterm" name="idm44761358418496"></a><a class="indexterm" name="idm44761358416720"></a><p>
      <code class="literal">COMPRESSED</code> の行形式は、<code class="literal">DYNAMIC</code> の行形式と同じ記憶特性および機能を提供しますが、テーブルおよびインデックスのデータ圧縮のサポートが追加されています。
    </p><p>
      <code class="literal">COMPRESSED</code> 行フォーマットは、オフページストレージに関して <code class="literal">DYNAMIC</code> 行フォーマットと同様の内部の詳細を使用するほか、追加のストレージ、圧縮されるテーブルおよびインデックスデータからのパフォーマンスの考慮事項、および小さいページサイズを使用します。 <code class="literal">COMPRESSED</code> の行形式では、<code class="literal">KEY_BLOCK_SIZE</code> オプションによって、クラスタインデックスに格納されるカラムデータの量およびオーバーフローページに配置される量が制御されます。 <code class="literal">COMPRESSED</code> の行形式の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-compression" title="15.9 InnoDB のテーブルおよびページの圧縮">セクション15.9「InnoDB のテーブルおよびページの圧縮」</a> を参照してください。 
    </p><p>
      <code class="literal">COMPRESSED</code> の行形式では、3072 バイトまでのインデックスキー接頭辞がサポートされます。
    </p><p>
      <code class="literal">COMPRESSED</code> 行形式を使用するテーブルは、file-per-table テーブルスペースまたは一般テーブルスペースに作成できます。 システムテーブルスペースは、<code class="literal">COMPRESSED</code> の行形式をサポートしていません。 file-per-table テーブルスペースに <code class="literal">COMPRESSED</code> テーブルを格納するには、<code class="literal">innodb_file_per_table</code> 変数を有効にする必要があります。 <code class="literal">innodb_file_per_table</code> 変数は、一般的なテーブルスペースには適用できません。 一般テーブルスペースでは、物理ページサイズが異なるために圧縮テーブルと非圧縮テーブルを同じ一般テーブルスペースに共存できないという注意事項を含むすべての行形式がサポートされています。 詳細は、<a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="15.6.3.3 一般テーブルスペース">セクション15.6.3.3「一般テーブルスペース」</a>を参照してください。 
    </p><h4><a name="innodb-compressed-row-format-characteristics"></a>圧縮された行形式の格納特性</h4><a class="indexterm" name="idm44761358398112"></a><p>
      <code class="literal">COMPRESSED</code> の行フォーマットは、<code class="literal">COMPACT</code> の行フォーマットのバリエーションです。 記憶特性については、<a class="xref" href="innodb-storage-engine.html#innodb-compact-row-format-characteristics" title="COMPACT 行形式の格納特性">COMPACT 行形式の格納特性</a> を参照してください。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-row-format-defining"></a>テーブルの行形式の定義</h3></div></div></div><a class="indexterm" name="idm44761358392400"></a><a class="indexterm" name="idm44761358390368"></a><a class="indexterm" name="idm44761358388336"></a><p>
      <code class="literal">InnoDB</code> テーブルのデフォルトの行形式は、<code class="literal">DYNAMIC</code> のデフォルト値を持つ <code class="literal">innodb_default_row_format</code> 変数によって定義されます。 デフォルトの行フォーマットは、<code class="literal">ROW_FORMAT</code> テーブルオプションが明示的に定義されていない場合、または <code class="literal">ROW_FORMAT=DEFAULT</code> が指定されている場合に使用されます。 
    </p><p>
      テーブルの行形式は、<code class="literal">CREATE TABLE</code> ステートメントまたは <code class="literal">ALTER TABLE</code> ステートメントの <code class="literal">ROW_FORMAT</code> テーブルオプションを使用して明示的に定義できます。 例: 
    </p><pre class="programlisting">CREATE TABLE t1 (c1 INT) ROW_FORMAT=DYNAMIC;
</pre><p>
      明示的に定義された <code class="literal">ROW_FORMAT</code> 設定は、デフォルトの行フォーマットをオーバーライドします。 <code class="literal">ROW_FORMAT=DEFAULT</code> を指定することは、暗黙のデフォルトを使用することと同じです。 
    </p><p>
      <code class="literal">innodb_default_row_format</code> 変数は動的に設定できます:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_default_row_format=DYNAMIC;</code></strong>
</pre><p>
      有効な <code class="literal">innodb_default_row_format</code> オプションには、<code class="literal">DYNAMIC</code>、<code class="literal">COMPACT</code> および <code class="literal">REDUNDANT</code> があります。 システムテーブルスペースでの使用がサポートされていない <code class="literal">COMPRESSED</code> 行形式は、デフォルトとして定義できません。 これは、<code class="literal">CREATE TABLE</code> ステートメントまたは <code class="literal">ALTER TABLE</code> ステートメントでのみ明示的に指定できます。 <code class="literal">innodb_default_row_format</code> 変数を <code class="literal">COMPRESSED</code> に設定しようとすると、エラーが返されます: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_default_row_format=COMPRESSED;</code></strong>
ERROR 1231 (42000): Variable 'innodb_default_row_format'
can't be set to the value of 'COMPRESSED'
</pre><p>
      新しく作成されたテーブルでは、<code class="literal">ROW_FORMAT</code> オプションが明示的に指定されていない場合、または <code class="literal">ROW_FORMAT=DEFAULT</code> が使用されている場合に、<code class="literal">innodb_default_row_format</code> 変数で定義された行形式が使用されます。 たとえば、次の <code class="literal">CREATE TABLE</code> ステートメントでは、<code class="literal">innodb_default_row_format</code> 変数で定義された行形式が使用されます。 
    </p><pre class="programlisting">CREATE TABLE t1 (c1 INT);
</pre><pre class="programlisting">CREATE TABLE t2 (c1 INT) ROW_FORMAT=DEFAULT;
</pre><p>
      <code class="literal">ROW_FORMAT</code> オプションが明示的に指定されていない場合、または <code class="literal">ROW_FORMAT=DEFAULT</code> が使用されている場合、テーブルを再構築する操作によって、テーブルの行形式が <code class="literal">innodb_default_row_format</code> 変数で定義された形式に暗黙的に変更されます。
    </p><p>
      テーブルの再構築操作には、テーブルの再構築が必要な <code class="literal">ALGORITHM=COPY</code> または <code class="literal">ALGORITHM=INPLACE</code> を使用する <code class="literal">ALTER TABLE</code> 操作が含まれます。 詳しくは<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-operations" title="15.12.1 オンライン DDL 操作">セクション15.12.1「オンライン DDL 操作」</a>をご覧ください。 <code class="literal">OPTIMIZE TABLE</code> は、テーブルの再構築操作でもあります。 
    </p><p>
      次の例は、明示的に定義された行形式なしで作成されたテーブルの行形式を暗黙的に変更するテーブル再構築操作を示しています。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@innodb_default_row_format;</code></strong>
+-----------------------------+
| @@innodb_default_row_format |
+-----------------------------+
| dynamic                     |
+-----------------------------+

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT);</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_TABLES WHERE NAME LIKE 'test/t1' \G</code></strong>
*************************** 1. row ***************************
     TABLE_ID: 54
         NAME: test/t1
         FLAG: 33
       N_COLS: 4
        SPACE: 35
   ROW_FORMAT: Dynamic
ZIP_PAGE_SIZE: 0
   SPACE_TYPE: Single

mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_default_row_format=COMPACT;</code></strong>

mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 ADD COLUMN (c2 INT);</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_TABLES WHERE NAME LIKE 'test/t1' \G</code></strong>
*************************** 1. row ***************************
     TABLE_ID: 55
         NAME: test/t1
         FLAG: 1
       N_COLS: 5
        SPACE: 36
   ROW_FORMAT: Compact
ZIP_PAGE_SIZE: 0
   SPACE_TYPE: Single
</pre><p>
      既存のテーブルの行形式を <code class="literal">REDUNDANT</code> または <code class="literal">COMPACT</code> から <code class="literal">DYNAMIC</code> に変更する前に、次の潜在的な問題を考慮してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">REDUNDANT</code> および <code class="literal">COMPACT</code> の行形式では 767 バイトのインデックスキー接頭辞の最大長がサポートされますが、<code class="literal">DYNAMIC</code> および <code class="literal">COMPRESSED</code> の行形式では 3072 バイトのインデックスキー接頭辞の長さがサポートされます。 レプリケーション環境では、ソースで <code class="literal">innodb_default_row_format</code> 変数が <code class="literal">DYNAMIC</code> に設定され、レプリカで <code class="literal">COMPACT</code> に設定されている場合、行形式を明示的に定義しない次の DDL ステートメントはソースで成功しますが、レプリカでは失敗します: 
        </p><pre class="programlisting">CREATE TABLE t1 (c1 INT PRIMARY KEY, c2 VARCHAR(5000), KEY i1(c2(3070)));
</pre><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-limits" title="15.22 InnoDB の制限">セクション15.22「InnoDB の制限」</a>を参照してください。
        </p></li><li class="listitem"><p>
          行フォーマットを明示的に定義しないテーブルをインポートすると、ソースサーバーの <code class="literal">innodb_default_row_format</code> 設定が宛先サーバーの設定と異なる場合にスキーマの不一致エラーが発生します。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-table-import" title="15.6.1.3 InnoDB テーブルのインポート">セクション15.6.1.3「InnoDB テーブルのインポート」</a>を参照してください。 
        </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-row-format-detrmining"></a>テーブルの行形式の決定</h3></div></div></div><a class="indexterm" name="idm44761358322528"></a><p>
      テーブルの行形式を確認するには、<code class="literal">SHOW TABLE STATUS</code> を使用します:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW TABLE STATUS IN test1\G</code></strong>
*************************** 1. row ***************************
           Name: t1
         Engine: InnoDB
        Version: 10
     Row_format: Dynamic
           Rows: 0
 Avg_row_length: 0
    Data_length: 16384
Max_data_length: 0
   Index_length: 16384
      Data_free: 0
 Auto_increment: 1
    Create_time: 2016-09-14 16:29:38
    Update_time: NULL
     Check_time: NULL
      Collation: utf8mb4_0900_ai_ci
       Checksum: NULL
 Create_options:
        Comment:
</pre><p>
      または、<code class="literal">INFORMATION_SCHEMA.INNODB_TABLES</code> テーブルをクエリーします:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT NAME, ROW_FORMAT FROM INFORMATION_SCHEMA.INNODB_TABLES WHERE NAME='test1/t1';</code></strong>
+----------+------------+
| NAME     | ROW_FORMAT |
+----------+------------+
| test1/t1 | Dynamic    |
+----------+------------+
</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-disk-management"></a>15.11 InnoDB のディスク I/O とファイル領域管理</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-disk-io">15.11.1 InnoDB ディスク I/O</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-space">15.11.2 ファイル領域管理</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-checkpoints">15.11.3 InnoDB チェックポイント</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-defragmenting">15.11.4 テーブルのデフラグ</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-truncate-table-reclaim-space">15.11.5 TRUNCATE TABLE によるディスク領域の再利用</a></span></dt></dl></div><p>
    DBA は、I/O サブシステムが飽和状態にならないようにディスク I/O を管理するとともに、ストレージデバイスがいっぱいにならないようにディスク領域を管理する必要があります。 <a class="link" href="glossary.html#glos_acid" title="ACID">ACID</a> 設計モデルには、冗長に見える可能性はあっても、データの信頼性の確保に役立つ、ある一定の量の I/O が必要です。 これらの制約の中で、<code class="literal">InnoDB</code> は、ディスク I/O の量を最小限に抑えるためにデータベースの動作やディスクファイルの編成を最適化しようとします。 場合によって、I/O は、データベースがビジー状態でなくなるまで、または<a class="link" href="glossary.html#glos_fast_shutdown" title="高速シャットダウン">高速シャットダウン</a>のあとのデータベースの再起動中など、すべてを一貫性のある状態に移行することが必要になるまで延期されます。 
  </p><p>
    このセクションでは、デフォルトの種類の MySQL テーブル (<code class="literal">InnoDB</code> テーブルとも呼ばれます) での I/O とディスク領域に関する主な考慮事項について説明します。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        クエリーパフォーマンスを向上させるために使用されるバックグラウンド I/O の量の制御。
      </p></li><li class="listitem"><p>
        追加の I/O を削減する代わりに耐久性を向上させる機能の有効化または無効化。
      </p></li><li class="listitem"><p>
        テーブルの、多数の小さなファイル、いくつかのより大きなファイル、またはその両方の組み合わせへの編成。
      </p></li><li class="listitem"><p>
        Redo ログファイルのサイズと、ログファイルがいっぱいになったときに発生する I/O アクティビティーとのバランス。
      </p></li><li class="listitem"><p>
        テーブルを最適なクエリーパフォーマンスのために再編成する方法。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-disk-io"></a>15.11.1 InnoDB ディスク I/O</h3></div></div></div><a class="indexterm" name="idm44761358299456"></a><p>
      <code class="literal">InnoDB</code> は、可能であれば、I/O 操作を処理するための複数のスレッドを作成することによって非同期ディスク I/O を使用します。それにより、その I/O がまだ進行中の間もほかのデータベース操作を続行できるようにします。 Linux および Windows プラットフォームでは、<code class="literal">InnoDB</code> は使用可能な OS およびライブラリ関数を使用して <span class="quote">「<span class="quote">native</span>」</span> 非同期 I/O を実行します。 他のプラットフォームでは、<code class="literal">InnoDB</code> は引き続き I/O スレッドを使用しますが、スレッドは実際には I/O リクエストの完了を待機する場合があります。この手法は<span class="quote">「<span class="quote">「シミュレーション」</span>」</span>非同期 I/O と呼ばれます。 
    </p><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-disk-io-read-ahead"></a>先読み</h4></div></div></div><p>
        <code class="literal">InnoDB</code> は、データがすぐに必要になる可能性が高いと判断できる場合、先読み操作を実行して、そのデータをメモリー内で使用できるようにバッファプールに取り込みます。 連続したデータに対しては、いくつかの大きな読み取り要求を作成する方が、複数の拡散した小さな要求を作成するより効率的である場合があります。 <code class="literal">InnoDB</code> には、2 つの先読みヒューリスティックがあります: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            シーケンシャル先読みでは、テーブルスペース内のセグメントへのアクセスパターンがシーケンシャルであることに気付くと、<code class="literal">InnoDB</code> はデータベースページの読み取りのバッチを I/O システムにあらかじめ送信します。
          </p></li><li class="listitem"><p>
            ランダム先読みでは、テーブルスペース内の一部の領域がバッファープールに完全に読み取られている最中であることに気付くと、<code class="literal">InnoDB</code> は残りの読み取りを I/O システムに送信します。
          </p></li></ul></div><p>
        先読みヒューリスティックの構成の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-read_ahead" title="15.8.3.4 InnoDB バッファープールのプリフェッチ (先読み) の構成">セクション15.8.3.4「InnoDB バッファープールのプリフェッチ (先読み) の構成」</a> を参照してください。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-disk-io-doublewrite"></a>二重書き込みバッファー</h4></div></div></div><a class="indexterm" name="idm44761358281872"></a><a class="indexterm" name="idm44761358280384"></a><p>
        <code class="literal">InnoDB</code> では、<a class="link" href="glossary.html#glos_doublewrite_buffer" title="二重書き込みバッファー">doublewrite buffer</a> と呼ばれる構造を含む新しいファイルフラッシュ技術を使用します。これは、ほとんどの場合 (<code class="literal">innodb_doublewrite=ON</code>) でデフォルトで有効になっています。 これにより、予期しない終了または停電後のリカバリの安全性が向上し、<code class="literal">fsync()</code> 操作の必要性が減少するため、ほとんどの種類の Unix のパフォーマンスが向上します。 
      </p><p>
        データファイルにページを書き込む前に、<code class="literal">InnoDB</code> はまず二重書込みバッファと呼ばれる記憶域にページを書き込みます。 二重書き込みバッファーへの書き込みとフラッシュが完了したあとにはじめて、<code class="literal">InnoDB</code> はそれらのページをデータファイル内の適切な位置に書き込みます。 ページ書込み中にオペレーティングシステム、ストレージサブシステムまたは予期しない <span class="command"><strong>mysqld</strong></span> プロセスが終了した場合 (<a class="link" href="glossary.html#glos_torn_page" title="破損ページ">torn page</a> 条件の原因)、<code class="literal">InnoDB</code> は後でリカバリ中に二重書込みバッファからページの適切なコピーを見つけることができます。 
      </p><p>
        二重書込みバッファの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-doublewrite-buffer" title="15.6.4 二重書き込みバッファー">セクション15.6.4「二重書き込みバッファー」</a> を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-file-space"></a>15.11.2 ファイル領域管理</h3></div></div></div><a class="indexterm" name="idm44761358266480"></a><p>
      <code class="literal">innodb_data_file_path</code> 構成オプションを使用して構成ファイルに定義するデータファイルは、<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">system tablespace</a> を形成します。 ファイルは論理的に連結され、システムテーブルスペースを形成します。 ストライピングは使用されません。 システムテーブルスペース内のどこにテーブルを割り当てるかは定義できません。 新しく作成されたシステムテーブルスペースでは、<code class="literal">InnoDB</code> は最初のデータファイルから始まる領域を割り当てます。 
    </p><p>
      システムテーブルスペース内にすべてのテーブルおよびインデックスを格納する際の問題を回避するために、<code class="literal">innodb_file_per_table</code> 構成オプション (デフォルト) を有効にして、新しく作成された各テーブルを個別のテーブルスペースファイル (拡張子 <code class="literal">.ibd</code>) に格納できます。 この方法で格納されたテーブルの場合、ディスクファイル内の断片化は減少し、テーブルが切り捨てられると、その領域は InnoDB によって引き続きシステムテーブルスペース内に予約されるのではなく、オペレーティングシステムに返されます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-file-per-table-tablespaces" title="15.6.3.2 File-Per-Table テーブルスペース">セクション15.6.3.2「File-Per-Table テーブルスペース」</a>を参照してください。 
    </p><p>
      <a class="link" href="glossary.html#glos_general_tablespace" title="一般テーブルスペース">general tablespaces</a> にテーブルを格納することもできます。 一般テーブルスペースは、<code class="literal">CREATE TABLESPACE</code> 構文を使用して作成される共有テーブルスペースです。 これらは MySQL データディレクトリの外部で作成でき、複数のテーブルを保持でき、すべての行形式のテーブルをサポートします。 詳細は、<a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="15.6.3.3 一般テーブルスペース">セクション15.6.3.3「一般テーブルスペース」</a>を参照してください。 
    </p><h4><a name="idm44761358252144"></a>ページ、エクステント、セグメント、およびテーブルスペース</h4><p>
      各テーブルスペースは、データベース<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>で構成されます。 MySQL インスタンス内のテーブルスペースはすべて、同じ<a class="link" href="glossary.html#glos_page_size" title="page size">ページサイズ</a>を持っています。 デフォルトでは、すべてのテーブルスペースが 16K バイトのページサイズを持っています。このページサイズを 8K バイトまたは 4K バイトに減らすには、MySQL インスタンスを作成するときに <code class="literal">innodb_page_size</code> オプションを指定します。 ページサイズを 32KB または 64KB に増やすこともできます。 詳細は、<code class="literal">innodb_page_size</code> のドキュメントを参照してください。 
    </p><p>
      ページは、最大 16K バイトのサイズ (16K バイトの連続した 64 ページ、128 8K バイトのページ、または 256 4K バイトのページ) でサイズ 1M バイトの <a class="link" href="glossary.html#glos_extent" title="エクステント">extents</a> にグループ化されます。 32KB のページサイズの場合、エクステントサイズは 2MB です。 64KB のページサイズの場合、エクステントサイズは 4MB です。 <code class="literal">InnoDB</code> では、テーブルスペース内部の<span class="quote">「<span class="quote">ファイル</span>」</span>を<a class="link" href="glossary.html#glos_segment" title="セグメント">セグメント</a>と呼びます。 (これらのセグメントは、実際に多数のテーブルスペースセグメントが含まれている<a class="link" href="glossary.html#glos_rollback_segment" title="ロールバックセグメント">ロールバックセグメント</a>とは異なります。) 
    </p><p>
      セグメントがテーブルスペース内部で拡張される場合、<code class="literal">InnoDB</code> は、そのセグメントに最初の 32 ページを一度に割り当てます。 そのあと、<code class="literal">InnoDB</code> は、そのセグメントへのすべてのエクステントの割り当てを開始します。 <code class="literal">InnoDB</code> は、データの良好な連続性を保証するために、大きなセグメントには 1 回につき最大 4 つのエクステントを追加できます。 
    </p><p>
      <code class="literal">InnoDB</code> では、各インデックスに 2 つのセグメントが割り当てられます。 一方は <a class="link" href="glossary.html#glos_b_tree" title="B ツリー">B-tree</a> の非リーフノード用で、もう一方はリーフノード用です。 リーフノードをディスク上で連続した状態に維持すると、これらのリーフノードには実際のテーブルデータが含まれているため、シーケンシャル I/O 操作の性能が向上します。 
    </p><p>
      テーブルスペース内の一部のページにはほかのページのビットマップが含まれているため、<code class="literal">InnoDB</code> テーブルスペース内のいくつかのエクステントは全体としてではなく、個々のページとしてのみセグメントに割り当てることができます。
    </p><p>
      <code class="literal">SHOW TABLE STATUS</code> ステートメントを発行することによってテーブルスペース内の使用可能な空き領域を求めると、<code class="literal">InnoDB</code> は、テーブルスペース内の確実に空いているエクステントをレポートします。 <code class="literal">InnoDB</code> は、常にいくつかのエクステントをクリーンアップやその他の内部の目的のために予約します。これらの予約されたエクステントは空き領域に含まれません。 
    </p><p>
      テーブルからデータを削除すると、<code class="literal">InnoDB</code> は、対応する B ツリーインデックスを短くします。 解放された領域をほかのユーザーが使用できるようになるかどうかは、削除のパターンがテーブルスペースに対して個々のページまたはエクステントのどちらを解放するかによって異なります。 テーブルを削除したりテーブルのすべての行を削除したりすると、その領域は確実にほかのユーザーに解放されますが、それらの削除された行は、それの行がトランザクションロールバックまたは一貫性読み取りに必要なくなったあと、しばらくして自動的に発生する<a class="link" href="glossary.html#glos_purge" title="パージ">パージ</a>操作によってのみ物理的に削除されることに注意してください。 (<a class="xref" href="innodb-storage-engine.html#innodb-multi-versioning" title="15.3 InnoDB マルチバージョン">セクション15.3「InnoDB マルチバージョン」</a>を参照してください。) 
    </p><h4><a name="idm44761358225488"></a>ページのテーブル行への関連付け</h4><p>
      行の最大長は、4KB、8KB、16KB および 32KB の <code class="literal">innodb_page_size</code> 設定のデータベースページの半分未満です。 たとえば、デフォルトの 16KB の <code class="literal">InnoDB</code> ページサイズでは、行の最大長は 8KB 未満です。 64KB ページの場合、行の最大長は 16KB 未満です。 
    </p><p>
      行が最大行長を超えない場合、すべての行はページ内にローカルに格納されます。 行が最大行長を超えると、行が最大行長制限内に収まるまで、外部オフページストレージ用に <a class="link" href="glossary.html#glos_variable_length_type" title="可変長型">variable-length columns</a> が選択されます。 可変長カラムの外部オフページストレージは、行形式によって異なります: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <span class="emphasis"><em>COMPACT および REDUNDANT 行フォーマット</em></span>
        </p><p>
          可変長カラムが外部オフページストレージに選択されると、<code class="literal">InnoDB</code> では最初の 768 バイトが行にローカルに格納され、残りはオーバーフローページに外部的に格納されます。 このような各カラムには、オーバーフローページの独自のリストがあります。 768 バイトのプリフィクスには、そのカラムの実際の長さを格納し、値の残りの部分が格納されているオーバーフローページリストを指す 20 バイトの値が付随します。 <a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="15.10 InnoDB の行フォーマット">セクション15.10「InnoDB の行フォーマット」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <span class="emphasis"><em>DYNAMIC および COMPRESSED 行フォーマット</em></span>
        </p><p>
          可変長カラムが外部オフページストレージに選択されると、<code class="literal">InnoDB</code> では 20 バイトのポインタが行にローカルに格納され、残りはオーバーフローページに外部的に格納されます。 <a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="15.10 InnoDB の行フォーマット">セクション15.10「InnoDB の行フォーマット」</a>を参照してください。 
        </p></li></ul></div><p>
      <code class="literal">LONGBLOB</code> および <code class="literal">LONGTEXT</code> カラムは 4G バイト未満である必要があり、<code class="literal">BLOB</code> および <code class="literal">TEXT</code> カラムを含む行全体の長さは 4G バイト未満である必要があります。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-checkpoints"></a>15.11.3 InnoDB チェックポイント</h3></div></div></div><a class="indexterm" name="idm44761358206096"></a><p>
      <a class="link" href="glossary.html#glos_log_file" title="ログファイル">ログファイル</a>を非常に大きくすると、<a class="link" href="glossary.html#glos_checkpoint" title="チェックポイント">チェックポイント設定</a>中のディスク I/O が少なくなる可能性があります。 ログファイルの合計サイズは多くの場合、バッファープールと同じか、またはそれより大きい設定が適切です。 
    </p><h4><a name="idm44761358201632"></a>チェックポイント処理の動作のしくみ</h4><p>
      <code class="literal">InnoDB</code> は、<a class="link" href="glossary.html#glos_fuzzy_checkpointing" title="ファジーチェックポイント">ファジーチェックポイント設定</a>と呼ばれる<a class="link" href="glossary.html#glos_checkpoint" title="チェックポイント">チェックポイント</a>メカニズムを実装しています。 <code class="literal">InnoDB</code> は、変更されたデータベースページをバッファープールから小さなバッチにフラッシュします。 バッファープールを 1 つのバッチにフラッシュする必要はありません。それを行うと、チェックポイント設定プロセス中にユーザーの SQL ステートメントの処理が中断されます。 
    </p><p>
      <a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>中に、<code class="literal">InnoDB</code> は、ログファイルに書き込まれたチェックポイントラベルを探します。 それは、そのラベルの前にあるデータベースへのすべての変更がデータベースのディスクイメージ内に存在することを知っています。 次に、<code class="literal">InnoDB</code> はそのチェックポイントから前方にログファイルをスキャンしながら、ログに記録された変更をデータベースに適用します。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-file-defragmenting"></a>15.11.4 テーブルのデフラグ</h3></div></div></div><a class="indexterm" name="idm44761358191808"></a><a class="indexterm" name="idm44761358188912"></a><p>
      セカンダリインデックスへのランダムな挿入やセカンダリインデックスからのランダムな削除によって、インデックスが断片化される場合があります。 断片化とは、ディスク上のインデックスページの物理的な順序がページ上のレコードのインデックス順序とかけ離れているか、またはインデックスに割り当てられた 64 ページのブロック内に未使用のページが多数存在することを示します。 
    </p><p>
      断片化の 1 つの現象として、あるテーブルが占めている領域が、本来占めている<span class="quote">「<span class="quote">はずの</span>」</span>領域より大きいことがあります。 それが正確にどの程度かを判定するのは困難です。 すべての <code class="literal">InnoDB</code> データおよびインデックスは <a class="link" href="glossary.html#glos_b_tree" title="B ツリー">B-trees</a> に格納され、その <a class="link" href="glossary.html#glos_fill_factor" title="フィルファクタ">fill factor</a> は 50% から 100% まで異なる場合があります。 断片化の別の現象として、次のようなテーブルスキャンにかかる時間が、本来かかる<span class="quote">「<span class="quote">はずの</span>」</span>時間より長いことがあります。 
    </p><pre class="programlisting">SELECT COUNT(*) FROM t WHERE <em class="replaceable"><code>non_indexed_column</code></em> &lt;&gt; 12345;
</pre><p>
      前のクエリーでは、MySQL が、大きなテーブルに対してもっとも遅いタイプのクエリーであるフルテーブルスキャンを実行する必要があります。
    </p><p>
      インデックススキャンを高速化するために、MySQL にテーブルを再構築させる次の<span class="quote">「<span class="quote">null</span>」</span> <code class="literal">ALTER TABLE</code> 操作を定期的に実行できます。
    </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ENGINE=INNODB
</pre><p>
      <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> FORCE</code> を使用して、テーブルを再構築する <span class="quote">「<span class="quote">null</span>」</span> 変更操作を実行することもできます。
    </p><p>
      <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ENGINE=INNODB</code> と <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> FORCE</code> はどちらも <a class="link" href="innodb-storage-engine.html#innodb-online-ddl" title="15.12 InnoDB とオンライン DDL">online DDL</a> を使用します。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl" title="15.12 InnoDB とオンライン DDL">セクション15.12「InnoDB とオンライン DDL」</a>を参照してください。 
    </p><p>
      デフラグ操作を実行するための別の方法として、<span class="command"><strong>mysqldump</strong></span> を使用してテーブルをテキストファイルにダンプし、テーブルを削除してから、それをダンプファイルからリロードする方法があります。
    </p><p>
      インデックスへの挿入が常に昇順であり、かつレコードが末尾からしか削除されない場合は、<code class="literal">InnoDB</code> のファイル領域管理アルゴリズムにより、インデックス内の断片化は発生しないことが保証されます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-truncate-table-reclaim-space"></a>15.11.5 TRUNCATE TABLE によるディスク領域の再利用</h3></div></div></div><p>
      <code class="literal">InnoDB</code> テーブルを<a class="link" href="glossary.html#glos_truncate" title="切り捨て">切り捨てる</a>ときにオペレーティングシステムのディスク領域を再利用するには、そのテーブルが独自の <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibd</a> ファイルに格納されている必要があります。 独自の <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibd</a> ファイルに格納されるテーブルの場合は、そのテーブルを作成するときに <code class="literal">innodb_file_per_table</code> を有効にする必要があります。 さらに、切り捨てられるテーブルとその他のテーブルの間に<a class="link" href="glossary.html#glos_foreign_key" title="外部キー">外部キー</a>制約が存在していてはいけません。そうしないと、<code class="literal">TRUNCATE TABLE</code> 操作は失敗します。 ただし、同じテーブル内の 2 つのカラム間の外部キー制約は許可されます。 
    </p><p>
      テーブルが切り捨てられると、そのテーブルが削除されて新しい <code class="filename">.ibd</code> ファイル内に再作成され、解放された領域はオペレーティングシステムに返されます。 これは、<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">system tablespace</a> 内に格納されている <code class="literal">InnoDB</code> テーブル (<code class="literal">innodb_file_per_table=OFF</code> 時に作成されたテーブル) および共有 <a class="link" href="glossary.html#glos_general_tablespace" title="一般テーブルスペース">general tablespaces</a> に格納されているテーブルを切り捨てることとは対照的で、<code class="literal">InnoDB</code> のみがテーブルの切捨て後に解放された領域を使用できます。 
    </p><p>
      テーブルを切り捨て、そのディスク領域をオペレーティングシステムに返す機能はまた、<a class="link" href="glossary.html#glos_physical_backup" title="物理バックアップ">物理バックアップ</a>を小さくすることもできます。 システムテーブルスペース (<code class="literal">innodb_file_per_table=OFF</code> で作成されたテーブル) または一般テーブルスペースに格納されているテーブルを切り捨てると、テーブルスペース内に未使用領域のブロックが残されます。 
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-online-ddl"></a>15.12 InnoDB とオンライン DDL</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-operations">15.12.1 オンライン DDL 操作</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-performance">15.12.2 オンライン DDL のパフォーマンスと同時実行性</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-space-requirements">15.12.3 オンライン DDL 領域の要件</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-single-multi">15.12.4 オンライン DDL を使用した DDL ステートメントの簡略化</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-failure-conditions">15.12.5 オンライン DDL 失敗条件</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-limitations">15.12.6 オンライン DDL の制限事項</a></span></dt></dl></div><a class="indexterm" name="idm44761358144672"></a><a class="indexterm" name="idm44761358143248"></a><p>
    オンライン DDL 機能では、即時およびインプレースのテーブル変更および同時 DML がサポートされます。 この機能の利点は次のとおりです: 
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        ビジーな本番環境での応答性と可用性が向上し、テーブルを数分間または数時間使用できなくなります。
      </p></li><li class="listitem"><p>
        インプレース操作の場合、<code class="literal">LOCK</code> 句を使用して DDL 操作中のパフォーマンスと同時実行性のバランスを調整する機能。 <a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-locking-options" title="LOCK 句">LOCK 句</a>を参照してください。 
      </p></li><li class="listitem"><p>
        テーブルコピー方法よりもディスク領域の使用量と I/O のオーバーヘッドが少なくなります。
      </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
      <code class="literal">ALGORITHM=INSTANT</code> のサポートは、<code class="literal">ADD COLUMN</code> および MySQL 8.0.12 のその他の操作で使用できます。
    </p></div><p>
    通常、オンライン DDL を有効にするために特別な操作を行う必要はありません。 デフォルトでは、MySQL は操作を許可されているとおりに即時またはインプレースで実行しますが、ロックはできるかぎり少なくなります。 
  </p><p>
    <code class="literal">ALTER TABLE</code> ステートメントの <code class="literal">ALGORITHM</code> 句および <code class="literal">LOCK</code> 句を使用して、DDL 操作の側面を制御できます。 これらの句は、テーブルおよびカラムの指定からカンマで区切ってステートメントの最後に配置されます。 例: 
  </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ADD PRIMARY KEY (<em class="replaceable"><code>column</code></em>), ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
    <code class="literal">LOCK</code> 句は、インプレースで実行される操作に使用でき、操作中のテーブルへの同時アクセスの程度を微調整する場合に役立ちます。 即時に実行される操作では、<code class="literal">LOCK=DEFAULT</code> のみがサポートされます。 <code class="literal">ALGORITHM</code> 句は、主にパフォーマンスの比較と、問題が発生した場合の古いテーブルコピー動作へのフォールバックを目的としています。 例: 
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        インプレースの <code class="literal">ALTER TABLE</code> 操作中に、誤ってテーブルを読取りまたは書込み (あるいはその両方) に使用できないようにするには、<code class="literal">LOCK=NONE</code> (読取りおよび書込みの許可) や <code class="literal">LOCK=SHARED</code> (読取りの許可) などの句を <code class="literal">ALTER TABLE</code> ステートメントに指定します。 要求されたレベルの並列性が使用できない場合、操作はただちに停止します。 
      </p></li><li class="listitem"><p>
        アルゴリズム間でパフォーマンスを比較するには、<code class="literal">ALGORITHM=INSTANT</code>、<code class="literal">ALGORITHM=INPLACE</code> および <code class="literal">ALGORITHM=COPY</code> でステートメントを実行します。 <code class="literal">old_alter_table</code> 構成オプションを有効にしてステートメントを実行し、<code class="literal">ALGORITHM=COPY</code> を強制的に使用することもできます。 
      </p></li><li class="listitem"><p>
        テーブルをコピーする <code class="literal">ALTER TABLE</code> 操作でサーバーがタイアップされないようにするには、<code class="literal">ALGORITHM=INSTANT</code> または <code class="literal">ALGORITHM=INPLACE</code> を含めます。 指定されたアルゴリズムを使用できない場合、ステートメントはただちに停止します。 
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-online-ddl-operations"></a>15.12.1 オンライン DDL 操作</h3></div></div></div><a class="indexterm" name="idm44761358108016"></a><p>
      DDL 操作のオンラインサポートの詳細、構文例および使用上のノートは、このセクションの次のトピックで説明します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#online-ddl-index-operations" title="インデックス操作">インデックス操作</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#online-ddl-primary-key-operations" title="主キーの操作">主キーの操作</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#online-ddl-column-operations" title="カラム操作">カラム操作</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#online-ddl-generated-column-operations" title="生成されたカラム操作">生成されたカラム操作</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#online-ddl-foreign-key-operations" title="外部キー操作">外部キー操作</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#online-ddl-table-operations" title="テーブルの操作">テーブルの操作</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#online-ddl-tablespace-operations" title="テーブルスペースの操作">テーブルスペースの操作</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#online-ddl-partitioning" title="パーティション化操作">パーティション化操作</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="online-ddl-index-operations"></a>インデックス操作</h4></div></div></div><p>
        次のテーブルに、インデックス操作のオンライン DDL サポートの概要を示します。 アスタリスクは、追加情報、例外または依存関係を示します。 詳細は、<a class="xref" href="innodb-storage-engine.html#online-ddl-index-syntax-notes" title="構文および使用上のノート">構文および使用上のノート</a>を参照してください。 
      </p><div class="table"><a name="online-ddl-index-operations-table"></a><p class="title"><b>表 15.16 インデックス操作のオンライン DDL サポート</b></p><div class="table-contents"><table summary="Online DDL support for index operations indicating whether the operation is performed in place, rebuilds the table, permits concurrent DML, or only modifies metadata."><col style="width: 16%" align="left"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><thead><tr>
            <th scope="col">操作</th>
            <th scope="col">インスタント</th>
            <th scope="col">インプレース</th>
            <th scope="col">テーブルの再構築</th>
            <th scope="col">同時 DML の許可</th>
            <th scope="col">メタデータの変更のみ</th>
          </tr></thead><tbody><tr>
            <th scope="row">セカンダリインデックスの作成または追加</th>
            <td>いいえ</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row">インデックスの削除</th>
            <td>いいえ</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
          </tr><tr>
            <th scope="row">インデックスの名前変更</th>
            <td>いいえ</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
          </tr><tr>
            <th scope="row"><code class="literal">FULLTEXT</code> インデックスの追加</th>
            <td>いいえ</td>
            <td>はい*</td>
            <td>いいえ*</td>
            <td>いいえ</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row"><code class="literal">SPATIAL</code> インデックスの追加</th>
            <td>いいえ</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>いいえ</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row">インデックスタイプの変更</th>
            <td>はい</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
          </tr></tbody></table></div></div><br class="table-break"><h5><a name="online-ddl-index-syntax-notes"></a>構文および使用上のノート</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            セカンダリインデックスの作成または追加
          </p><pre class="programlisting">CREATE INDEX <em class="replaceable"><code>name</code></em> ON <em class="replaceable"><code>table</code></em> (<em class="replaceable"><code>col_list</code></em>);
</pre><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ADD INDEX <em class="replaceable"><code>name</code></em> (<em class="replaceable"><code>col_list</code></em>);
</pre><p>
            このテーブルは、インデックスの作成中も読取りおよび書込み操作に使用できます。 <code class="literal">CREATE INDEX</code> ステートメントは、テーブルにアクセスしているすべてのトランザクションが完了した後にのみ終了するため、インデックスの初期状態にはテーブルの最新の内容が反映されます。 
          </p><p>
            セカンダリインデックスを追加するためのオンライン DDL サポートとは、通常、セカンダリインデックスのないテーブルを作成してからデータのロード後にセカンダリインデックスを追加することで、テーブルおよび関連するインデックスの作成およびロードのプロセス全体を高速化できることを意味します。
          </p><p>
            新しく作成されたセカンダリインデックスには、<code class="literal">CREATE INDEX</code> または <code class="literal">ALTER TABLE</code> ステートメントの実行が終了した時点でテーブルにコミットされたデータのみが含まれます。 コミットされていない値や古いバージョンの値、または削除対象としてマークされているが、まだ古いインデックスから削除されていない値は含まれていません。 
          </p><p>
            この操作のパフォーマンス、領域使用量およびセマンティクスに影響する要因もあります。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-limitations" title="15.12.6 オンライン DDL の制限事項">セクション15.12.6「オンライン DDL の制限事項」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            インデックスの削除
          </p><pre class="programlisting">DROP INDEX <em class="replaceable"><code>name</code></em> ON <em class="replaceable"><code>table</code></em>;
</pre><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DROP INDEX <em class="replaceable"><code>name</code></em>;
</pre><p>
            このテーブルは、インデックスの削除中も読取りおよび書込み操作に使用できます。 <code class="literal">DROP INDEX</code> ステートメントは、テーブルにアクセスしているすべてのトランザクションが完了した後にのみ終了するため、インデックスの初期状態にはテーブルの最新の内容が反映されます。 
          </p></li><li class="listitem"><p>
            インデックスの名前変更
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> RENAME INDEX <em class="replaceable"><code>old_index_name</code></em> TO <em class="replaceable"><code>new_index_name</code></em>, ALGORITHM=INPLACE, LOCK=NONE;
</pre></li><li class="listitem"><p>
            <code class="literal">FULLTEXT</code> インデックスの追加
          </p><pre class="programlisting">CREATE FULLTEXT INDEX <em class="replaceable"><code>name</code></em> ON table(<em class="replaceable"><code>column</code></em>);
</pre><p>
            ユーザー定義の <code class="literal">FTS_DOC_ID</code> カラムがない場合は、最初の <code class="literal">FULLTEXT</code> インデックスを追加するとテーブルが再構築されます。 テーブルを再構築せずに、<code class="literal">FULLTEXT</code> インデックスを追加できます。 
          </p></li><li class="listitem"><p>
            <code class="literal">SPATIAL</code> インデックスの追加
          </p><pre class="programlisting">CREATE TABLE geom (g GEOMETRY NOT NULL);
ALTER TABLE geom ADD SPATIAL INDEX(g), ALGORITHM=INPLACE, LOCK=SHARED;
</pre></li><li class="listitem"><p>
            インデックスタイプの変更 (<code class="literal">USING {BTREE | HASH}</code>)
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DROP INDEX i1, ADD INDEX i1(<em class="replaceable"><code>key_part,...</code></em>) USING BTREE, ALGORITHM=INSTANT;
</pre></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="online-ddl-primary-key-operations"></a>主キーの操作</h4></div></div></div><p>
        次のテーブルに、主キー操作のオンライン DDL サポートの概要を示します。 アスタリスクは、追加情報、例外または依存関係を示します。 <a class="xref" href="innodb-storage-engine.html#online-ddl-primary-key-syntax-notes" title="構文および使用上のノート">構文および使用上のノート</a>を参照してください。 
      </p><div class="table"><a name="online-ddl-primary-key-operations-table"></a><p class="title"><b>表 15.17 主キー操作のオンライン DDL サポート</b></p><div class="table-contents"><table summary="Online DDL support for primary key operations indicating whether the operation is performed in place, rebuilds the table, permits concurrent DML, or only modifies metadata."><col style="width: 16%" align="left"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><thead><tr>
            <th scope="col">操作</th>
            <th scope="col">インスタント</th>
            <th scope="col">インプレース</th>
            <th scope="col">テーブルの再構築</th>
            <th scope="col">同時 DML の許可</th>
            <th scope="col">メタデータの変更のみ</th>
          </tr></thead><tbody><tr>
            <th scope="row">主キーの追加</th>
            <td>いいえ</td>
            <td>はい*</td>
            <td>はい*</td>
            <td>はい</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row">主キーの削除</th>
            <td>いいえ</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row">主キーの削除および別の主キーの追加</th>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
            <td>はい</td>
            <td>いいえ</td>
          </tr></tbody></table></div></div><br class="table-break"><h5><a name="online-ddl-primary-key-syntax-notes"></a>構文および使用上のノート</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            主キーの追加
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ADD PRIMARY KEY (<em class="replaceable"><code>column</code></em>), ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
            テーブルを適切に再構築します。 データは大幅に再編成され、コストのかかる操作になります。 カラムを <code class="literal">NOT NULL</code> に変換する必要がある場合、特定の条件下で <code class="literal">ALGORITHM=INPLACE</code> は許可されません。 
          </p><p>
            <a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">clustered index</a> を再構築するには、常にテーブルデータのコピーが必要です。 したがって、後で <code class="literal">ALTER TABLE ... ADD PRIMARY KEY</code> を発行するのではなく、テーブルの作成時に <a class="link" href="glossary.html#glos_primary_key" title="主キー">primary key</a> を定義することをお薦めします。 
          </p><p>
            <code class="literal">UNIQUE</code> または <code class="literal">PRIMARY KEY</code> インデックスを作成したとき、MySQL は、いくつかの追加の作業を行う必要があります。 <code class="literal">UNIQUE</code> インデックスの場合、MySQL は、テーブルに重複したキーの値が含まれていないことをチェックします。 <code class="literal">PRIMARY KEY</code> インデックスの場合も、MySQL は、どの <code class="literal">PRIMARY KEY</code> カラムにも <code class="literal">NULL</code> が含まれていないことをチェックします。 
          </p><p>
            <code class="literal">ALGORITHM=COPY</code> 句を使用して主キーを追加すると、MySQL は関連付けられたカラムの <code class="literal">NULL</code> 値をデフォルト値に変換: 数値の場合は 0、文字ベースのカラムおよび BLOB の場合は空の文字列、<code class="literal">DATETIME</code> の場合は 0000-00-00 00:00:00。 これは非標準の動作であるため、これに依存しないようにすることをお勧めします。 <code class="literal">ALGORITHM=INPLACE</code> を使用した主キーの追加は、<code class="literal">SQL_MODE</code> 設定に <code class="literal">strict_trans_tables</code> または <code class="literal">strict_all_tables</code> フラグが含まれている場合にのみ許可されます。<code class="literal">SQL_MODE</code> 設定が厳密な場合、<code class="literal">ALGORITHM=INPLACE</code> は許可されますが、リクエストされた主キーカラムに <code class="literal">NULL</code> 値が含まれている場合、ステートメントは失敗する可能性があります。 <code class="literal">ALGORITHM=INPLACE</code> の動作は、より標準に準拠しています。 
          </p><p>
            主キーなしでテーブルを作成すると、<code class="literal">InnoDB</code> によってテーブルが選択されます。これは、<code class="literal">NOT NULL</code> カラムに定義されている最初の <code class="literal">UNIQUE</code> キーまたはシステム生成キーです。 余分な非表示カラムの不確実性および潜在的な領域要件を回避するには、<code class="literal">CREATE TABLE</code> ステートメントの一部として <code class="literal">PRIMARY KEY</code> 句を指定します。 
          </p><p>
            MySQL では、既存のデータを元のテーブルから目的のインデックス構造を持つ一時テーブルにコピーすることで、新しいクラスタインデックスが作成されます。 データが一時テーブルに完全にコピーされると、元のテーブルの名前は別の一時テーブル名に変更されます。 新しいクラスタ化されたインデックスで構成される一時テーブルの名前が元のテーブルの名前に変更され、元のテーブルはデータベースから削除されます。 
          </p><p>
            セカンダリインデックスでの操作に適用されるオンラインパフォーマンスの拡張は、主キーインデックスには適用されません。 InnoDB テーブルの行は、<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>に基づいて編成された<a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">クラスタ化されたインデックス</a>に格納されます。これにより、一部のデータベースシステムで<span class="quote">「<span class="quote">インデックス編成テーブル</span>」</span>と呼ばれるものが形成されます。 テーブル構造は主キーに密接に関連付けられているため、主キーを再定義するには引き続きデータをコピーする必要があります。 
          </p><p>
            主キーに対する操作で <code class="literal">ALGORITHM=INPLACE</code> が使用される場合は、データが引き続きコピーされるにもかかわらず、次の理由で <code class="literal">ALGORITHM=COPY</code> を使用するより効率的です。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">ALGORITHM=INPLACE</code> には、Undo ロギングやそれに関連する Redo ロギングが必要ありません。 これらの操作は、<code class="literal">ALGORITHM=COPY</code> を使用する DDL ステートメントのオーバーヘッドを増やします。 
              </p></li><li class="listitem"><p>
                セカンダリインデックスエントリは事前にソートされているため、順番にロードできます。
              </p></li><li class="listitem"><p>
                セカンダリインデックスへのランダムアクセス挿入は存在しないため、変更バッファーは使用されません。
              </p></li></ul></div></li><li class="listitem"><p>
            主キーの削除
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DROP PRIMARY KEY, ALGORITHM=COPY;
</pre><p>
            同じ <code class="literal">ALTER TABLE</code> ステートメントに新しい主キーを追加せずに主キーを削除できるのは、<code class="literal">ALGORITHM=COPY</code> のみです。
          </p></li><li class="listitem"><p>
            主キーの削除および別の主キーの追加
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DROP PRIMARY KEY, ADD PRIMARY KEY (<em class="replaceable"><code>column</code></em>), ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
            データは大幅に再編成され、コストのかかる操作になります。
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="online-ddl-column-operations"></a>カラム操作</h4></div></div></div><p>
        次のテーブルに、カラム操作のオンライン DDL サポートの概要を示します。 アスタリスクは、追加情報、例外または依存関係を示します。 詳細は、<a class="xref" href="innodb-storage-engine.html#online-ddl-column-syntax-notes" title="構文および使用上のノート">構文および使用上のノート</a>を参照してください。 
      </p><div class="table"><a name="online-ddl-column-operations-table"></a><p class="title"><b>表 15.18 カラム操作のオンライン DDL サポート</b></p><div class="table-contents"><table summary="Online DDL support for column operations indicating whether the operation is performed in place, rebuilds the table, permits concurrent DML, or only modifies metadata."><col style="width: 16%" align="left"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><thead><tr>
            <th scope="col">操作</th>
            <th scope="col">インスタント</th>
            <th scope="col">インプレース</th>
            <th scope="col">テーブルの再構築</th>
            <th scope="col">同時 DML の許可</th>
            <th scope="col">メタデータの変更のみ</th>
          </tr></thead><tbody><tr>
            <th scope="row">カラムの追加</th>
            <td>はい*</td>
            <td>はい</td>
            <td>いいえ*</td>
            <td>はい*</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row">カラムの削除</th>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
            <td>はい</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row">カラム名の変更</th>
            <td>いいえ</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>はい*</td>
            <td>はい</td>
          </tr><tr>
            <th scope="row">カラムの並替え</th>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
            <td>はい</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row">カラムのデフォルト値の設定</th>
            <td>はい</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
          </tr><tr>
            <th scope="row">カラムのデータ型の変更</th>
            <td>いいえ</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row"><code class="literal">VARCHAR</code> カラムサイズの拡張</th>
            <td>いいえ</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
          </tr><tr>
            <th scope="row">カラムのデフォルト値の削除</th>
            <td>はい</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
          </tr><tr>
            <th scope="row">自動インクリメント値の変更</th>
            <td>いいえ</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>いいえ*</td>
          </tr><tr>
            <th scope="row">カラムの <code class="literal">NULL</code> 化</th>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい*</td>
            <td>はい</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row">カラムの <code class="literal">NOT NULL</code> 化</th>
            <td>いいえ</td>
            <td>はい*</td>
            <td>はい*</td>
            <td>はい</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row"><code class="literal">ENUM</code> または <code class="literal">SET</code> カラムの定義の変更</th>
            <td>はい</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
          </tr></tbody></table></div></div><br class="table-break"><h5><a name="online-ddl-column-syntax-notes"></a>構文および使用上のノート</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            カラムの追加
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ADD COLUMN <em class="replaceable"><code>column_name</code></em> <em class="replaceable"><code>column_definition</code></em>, ALGORITHM=INSTANT;
</pre><p>
            <code class="literal">INSTANT</code> アルゴリズムを使用してカラムを追加する場合は、次の制限が適用されます:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                カラムの追加は、<code class="literal">ALGORITHM=INSTANT</code> をサポートしない他の <code class="literal">ALTER TABLE</code> アクションと同じステートメントで組み合せることはできません。
              </p></li><li class="listitem"><p>
                カラムは、テーブルの最後のカラムとしてのみ追加できます。 他のカラム間の他の位置へのカラムの追加はサポートされていません。 
              </p></li><li class="listitem"><p>
                <code class="literal">ROW_FORMAT=COMPRESSED</code> を使用するテーブルにはカラムを追加できません。
              </p></li><li class="listitem"><p>
                <code class="literal">FULLTEXT</code> インデックスを含むテーブルにはカラムを追加できません。
              </p></li><li class="listitem"><p>
                カラムは一時テーブルに追加できません。 一時テーブルでは、<code class="literal">ALGORITHM=COPY</code> のみがサポートされます。 
              </p></li><li class="listitem"><p>
                データディクショナリテーブルスペースに存在するテーブルにはカラムを追加できません。
              </p></li><li class="listitem"><p>
                行サイズ制限は、カラムの追加時には評価されません。 ただし、行サイズ制限は、テーブルの行を挿入および更新する DML 操作中にチェックされます。 
              </p></li></ul></div><p>
            同じ <code class="literal">ALTER TABLE</code> ステートメントに複数のカラムを追加できます。 例: 
          </p><pre class="programlisting">ALTER TABLE t1 ADD COLUMN c2 INT, ADD COLUMN c3 INT, ALGORITHM=INSTANT;
</pre><p>
            <code class="literal">INFORMATION_SCHEMA.INNODB_TABLES</code> および <code class="literal">INFORMATION_SCHEMA.INNODB_COLUMNS</code> は、即時に追加されたカラムのメタデータを提供します。 <code class="literal">INFORMATION_SCHEMA.INNODB_TABLES.INSTANT_COLS</code> では、最初のインスタントカラムを追加する前に、テーブルのカラム数が表示されます。 <code class="literal">INFORMATION_SCHEMA.INNODB_COLUMNS.HAS_DEFAULT</code> および <code class="literal">DEFAULT_VALUE</code> は、即時に追加されたカラムのデフォルト値に関するメタデータを提供します。 
          </p><p>
            <a class="link" href="glossary.html#glos_auto_increment" title="自動インクリメント">auto-increment</a> カラムを追加する場合、同時 DML は許可されません。 データは大幅に再編成され、コストのかかる操作になります。 少なくとも、<code class="literal">ALGORITHM=INPLACE, LOCK=SHARED</code> が必要です。 
          </p><p>
            <code class="literal">ALGORITHM=INPLACE</code> を使用してカラムを追加すると、テーブルが再構築されます。
          </p></li><li class="listitem"><p>
            カラムの削除
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DROP COLUMN <em class="replaceable"><code>column_name</code></em>, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
            データは大幅に再編成され、コストのかかる操作になります。
          </p></li><li class="listitem"><p>
            カラム名の変更
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl</code></em> CHANGE <em class="replaceable"><code>old_col_name</code></em> <em class="replaceable"><code>new_col_name</code></em> <em class="replaceable"><code>data_type</code></em>, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
            同時 DML を許可するには、同じデータ型を保持し、カラム名のみを変更します。
          </p><p>
            同じデータ型と<code class="literal">[NOT] NULL</code> 属性を保持し、カラム名の変更のみを行う場合、操作は常にオンラインで実行できます。
          </p><p>
            外部キー制約の一部であるカラムの名前を変更することもできます。 外部キー定義は、新しいカラム名を使用するように自動的に更新されます。 外部キーに参加するカラムの名前の変更は、<code class="literal">ALGORITHM=INPLACE</code> でのみ機能します。 <code class="literal">ALGORITHM=COPY</code> 句を使用した場合、または他のなんらかの状況でコマンドがバックグラウンドで <code class="literal">ALGORITHM=COPY</code> を使用する場合、<code class="literal">ALTER TABLE</code> ステートメントは失敗します。 
          </p><p>
            <code class="literal">ALGORITHM=INPLACE</code> では、<a class="link" href="glossary.html#glos_generated_column" title="生成されるカラム">generated column</a> の名前の変更はサポートされていません。
          </p></li><li class="listitem"><p>
            カラムの並替え
          </p><p>
            カラムの順序を変更するには、<code class="literal">CHANGE</code> または <code class="literal">MODIFY</code> 操作で <code class="literal">FIRST</code> または <code class="literal">AFTER</code> を使用します。
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> MODIFY COLUMN <em class="replaceable"><code>col_name</code></em> <em class="replaceable"><code>column_definition</code></em> FIRST, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
            データは大幅に再編成され、コストのかかる操作になります。
          </p></li><li class="listitem"><p>
            カラムのデータ型の変更
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> CHANGE c1 c1 BIGINT, ALGORITHM=COPY;
</pre><p>
            カラムのデータ型の変更は、<code class="literal">ALGORITHM=COPY</code> でのみサポートされます。
          </p></li><li class="listitem"><p>
            <code class="literal">VARCHAR</code> カラムサイズの拡張
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> CHANGE COLUMN c1 c1 VARCHAR(255), ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
            <code class="literal">VARCHAR</code> カラムに必要な長さバイト数は、同じままにする必要があります。 サイズが 0 から 255 バイトの <code class="literal">VARCHAR</code> カラムの場合、値のエンコードには長さバイトが必要です。 256 バイト以上の <code class="literal">VARCHAR</code> カラムの場合は、長さが 2 バイト必要です。 その結果、インプレース <code class="literal">ALTER TABLE</code> では、<code class="literal">VARCHAR</code> カラムサイズの 0 から 255 バイト、または 256 バイトからそれより大きいサイズへの増加のみがサポートされます。 インプレース <code class="literal">ALTER TABLE</code> では、<code class="literal">VARCHAR</code> カラムのサイズを 256 バイト未満から 256 バイト以上に増やすことはサポートされていません。 この場合、必要な長さバイト数は 1 から 2 に変更され、テーブルコピー (<code class="literal">ALGORITHM=COPY</code>) でのみサポートされます。 たとえば、シングルバイト文字セットの <code class="literal">VARCHAR</code> カラムサイズを、インプレース <code class="literal">ALTER TABLE</code> を使用して VARCHAR(255) から VARCHAR(256) に変更しようとすると、次のエラーが返されます: 
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ALGORITHM=INPLACE, CHANGE COLUMN c1 c1 VARCHAR(256);
ERROR 0A000: ALGORITHM=INPLACE is not supported. Reason: Cannot change
column type INPLACE. Try ALGORITHM=COPY.
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">VARCHAR</code> カラムのバイト長は、文字セットのバイト長によって異なります。
            </p></div><p>
            インプレース <code class="literal">ALTER TABLE</code> を使用した <code class="literal">VARCHAR</code> サイズの縮小はサポートされていません。 <code class="literal">VARCHAR</code> サイズを小さくするには、テーブルコピー (<code class="literal">ALGORITHM=COPY</code>) が必要です。 
          </p></li><li class="listitem"><p>
            カラムのデフォルト値の設定
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ALTER COLUMN <em class="replaceable"><code>col</code></em> SET DEFAULT <em class="replaceable"><code>literal</code></em>, ALGORITHM=INSTANT;
</pre><p>
            テーブルメタデータのみを変更します。 デフォルトのカラム値は <a class="link" href="glossary.html#glos_data_dictionary" title="データディクショナリ">data dictionary</a> に格納されます。 
          </p></li><li class="listitem"><p>
            カラムのデフォルト値の削除
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl</code></em> ALTER COLUMN <em class="replaceable"><code>col</code></em> DROP DEFAULT, ALGORITHM=INSTANT;
</pre></li><li class="listitem"><p>
            自動インクリメント値の変更
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>table</code></em> AUTO_INCREMENT=<em class="replaceable"><code>next_value</code></em>, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
            データファイルではなく、メモリーに格納された値を変更します。
          </p><p>
            レプリケーションまたはシャーディングを使用する分散システムでは、テーブルの自動増分カウンタを特定の値にリセットすることがあります。 テーブルに挿入された次の行は、その自動インクリメントカラムの指定された値を使用します。 この方法は、すべてのテーブルを定期的に空にしてリロードし、自動増分順序を 1 から再開するデータウェアハウス環境でも使用できます。 
          </p></li><li class="listitem"><p>
            カラムの <code class="literal">NULL</code> 化
          </p><pre class="programlisting">ALTER TABLE tbl_name MODIFY COLUMN <em class="replaceable"><code>column_name</code></em> <em class="replaceable"><code>data_type</code></em> NULL, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
            テーブルを適切に再構築します。 データは大幅に再編成され、コストのかかる操作になります。 
          </p></li><li class="listitem"><p>
            カラムの <code class="literal">NOT NULL</code> 化
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> MODIFY COLUMN <em class="replaceable"><code>column_name</code></em> <em class="replaceable"><code>data_type</code></em> NOT NULL, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
            テーブルを適切に再構築します。 操作を成功させるには、<code class="literal">STRICT_ALL_TABLES</code> または <code class="literal">STRICT_TRANS_TABLES</code> <code class="literal">SQL_MODE</code> が必要です。 カラムに NULL 値が含まれている場合、操作は失敗します。 サーバーは、参照整合性が失われる可能性がある外部キーカラムの変更を禁止します。 <a class="xref" href="sql-statements.html#alter-table" title="13.1.9 ALTER TABLE ステートメント">セクション13.1.9「ALTER TABLE ステートメント」</a>を参照してください。 データは大幅に再編成され、コストのかかる操作になります。 
          </p></li><li class="listitem"><p>
            <code class="literal">ENUM</code> または <code class="literal">SET</code> カラムの定義の変更
          </p><pre class="programlisting">CREATE TABLE t1 (c1 ENUM('a', 'b', 'c'));
ALTER TABLE t1 MODIFY COLUMN c1 ENUM('a', 'b', 'c', 'd'), ALGORITHM=INSTANT;
</pre><p>
            新しい列挙を追加するか、有効なメンバー値のリストの <span class="emphasis"><em>end</em></span> にメンバーを設定して、<code class="literal">ENUM</code> または <code class="literal">SET</code> カラムの定義を変更すると、データ型の記憶域サイズが変更されないかぎり、すぐに実行することも、その場で実行することもできます。 たとえば、8 つのメンバーを持つ <code class="literal">SET</code> カラムにメンバーを追加すると、値ごとに必要な記憶域が 1 バイトから 2 バイトに変更されます。これにはテーブルのコピーが必要です。 リストの途中にメンバーを追加すると、既存のメンバーの番号が変更されます。これには、テーブルコピーが必要になります。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="online-ddl-generated-column-operations"></a>生成されたカラム操作</h4></div></div></div><p>
        次のテーブルに、生成されるカラム操作のオンライン DDL サポートの概要を示します。 詳細は、<a class="xref" href="innodb-storage-engine.html#online-ddl-generated-column-syntax-notes" title="構文および使用上のノート">構文および使用上のノート</a>を参照してください。 
      </p><div class="table"><a name="online-ddl-generated-column-operations-table"></a><p class="title"><b>表 15.19 生成されたカラム操作のオンライン DDL サポート</b></p><div class="table-contents"><table summary="Online DDL support for generated column operations indicating whether the operation is performed in place, rebuilds the table, permits concurrent DML, or only modifies metadata."><col style="width: 16%" align="left"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><thead><tr>
            <th scope="col">操作</th>
            <th scope="col">インスタント</th>
            <th scope="col">インプレース</th>
            <th scope="col">テーブルの再構築</th>
            <th scope="col">同時 DML の許可</th>
            <th scope="col">メタデータの変更のみ</th>
          </tr></thead><tbody><tr>
            <th scope="row"><code class="literal">STORED</code> カラムの追加</th>
            <td>いいえ</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row"><code class="literal">STORED</code> カラムの順序の変更</th>
            <td>いいえ</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row"><code class="literal">STORED</code> カラムの削除</th>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
            <td>はい</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row"><code class="literal">VIRTUAL</code> カラムの追加</th>
            <td>はい</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
          </tr><tr>
            <th scope="row"><code class="literal">VIRTUAL</code> カラムの順序の変更</th>
            <td>いいえ</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row"><code class="literal">VIRTUAL</code> カラムの削除</th>
            <td>はい</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
          </tr></tbody></table></div></div><br class="table-break"><h5><a name="online-ddl-generated-column-syntax-notes"></a>構文および使用上のノート</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">STORED</code> カラムの追加
          </p><pre class="programlisting">ALTER TABLE t1 ADD COLUMN (c2 INT GENERATED ALWAYS AS (c1 + 1) STORED), ALGORITHM=COPY;
</pre><p>
            式はサーバーによって評価される必要があるため、<code class="literal">ADD COLUMN</code> はストアドカラムのインプレース操作ではありません (一時テーブルを使用せずに実行されます)。
          </p></li><li class="listitem"><p>
            <code class="literal">STORED</code> カラムの順序の変更
          </p><pre class="programlisting">ALTER TABLE t1 MODIFY COLUMN c2 INT GENERATED ALWAYS AS (c1 + 1) STORED FIRST, ALGORITHM=COPY;
</pre><p>
            テーブルを適切に再構築します。
          </p></li><li class="listitem"><p>
            <code class="literal">STORED</code> カラムの削除
          </p><pre class="programlisting">ALTER TABLE t1 DROP COLUMN c2, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
            テーブルを適切に再構築します。
          </p></li><li class="listitem"><p>
            <code class="literal">VIRTUAL</code> カラムの追加
          </p><pre class="programlisting">ALTER TABLE t1 ADD COLUMN (c2 INT GENERATED ALWAYS AS (c1 + 1) VIRTUAL), ALGORITHM=INSTANT;
</pre><p>
            仮想カラムの追加は、即時に実行することも、パーティション化されていないテーブルに対して適切に実行することもできます。
          </p><p>
            <code class="literal">VIRTUAL</code> の追加は、パーティションテーブルのインプレース操作ではありません。
          </p></li><li class="listitem"><p>
            <code class="literal">VIRTUAL</code> カラムの順序の変更
          </p><pre class="programlisting">ALTER TABLE t1 MODIFY COLUMN c2 INT GENERATED ALWAYS AS (c1 + 1) VIRTUAL FIRST, ALGORITHM=COPY;
</pre></li><li class="listitem"><p>
            <code class="literal">VIRTUAL</code> カラムの削除
          </p><pre class="programlisting">ALTER TABLE t1 DROP COLUMN c2, ALGORITHM=INSTANT;
</pre><p>
            <code class="literal">VIRTUAL</code> カラムの削除は、即時に実行することも、パーティション化されていないテーブルに対して適切に実行することもできます。
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="online-ddl-foreign-key-operations"></a>外部キー操作</h4></div></div></div><p>
        次のテーブルに、外部キー操作のオンライン DDL サポートの概要を示します。 アスタリスクは、追加情報、例外または依存関係を示します。 詳細は、<a class="xref" href="innodb-storage-engine.html#online-ddl-foreign-key-syntax-notes" title="構文および使用上のノート">構文および使用上のノート</a>を参照してください。 
      </p><div class="table"><a name="online-ddl-foreign-key-operations-table"></a><p class="title"><b>表 15.20 外部キー操作のオンライン DDL サポート</b></p><div class="table-contents"><table summary="Online DDL support for foreign key operations indicating whether the operation is performed in place, rebuilds the table, permits concurrent DML, or only modifies metadata."><col style="width: 16%" align="left"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><thead><tr>
            <th scope="col">操作</th>
            <th scope="col">インスタント</th>
            <th scope="col">インプレース</th>
            <th scope="col">テーブルの再構築</th>
            <th scope="col">同時 DML の許可</th>
            <th scope="col">メタデータの変更のみ</th>
          </tr></thead><tbody><tr>
            <th scope="row">外部キー制約の追加</th>
            <td>いいえ</td>
            <td>はい*</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
          </tr><tr>
            <th scope="row">外部キー制約の削除</th>
            <td>いいえ</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
          </tr></tbody></table></div></div><br class="table-break"><h5><a name="online-ddl-foreign-key-syntax-notes"></a>構文および使用上のノート</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            外部キー制約の追加
          </p><p>
            <code class="literal">INPLACE</code> アルゴリズムは、<code class="literal">foreign_key_checks</code> が無効な場合にサポートされます。 それ以外の場合は、<code class="literal">COPY</code> アルゴリズムのみがサポートされます。 
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl1</code></em> ADD CONSTRAINT <em class="replaceable"><code>fk_name</code></em> FOREIGN KEY <em class="replaceable"><code>index</code></em> (<em class="replaceable"><code>col1</code></em>)
  REFERENCES <em class="replaceable"><code>tbl2</code></em>(<em class="replaceable"><code>col2</code></em>) <em class="replaceable"><code>referential_actions</code></em>;
</pre></li><li class="listitem"><p>
            外部キー制約の削除
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl</code></em> DROP FOREIGN KEY <em class="replaceable"><code>fk_name</code></em>;
</pre><p>
            外部キーの削除は、<code class="literal">foreign_key_checks</code> オプションが有効または無効になった状態でオンラインで実行できます。
          </p><p>
            特定のテーブル上の外部キー制約の名前がわからない場合は、次のステートメントを発行し、各外部キーに対する <code class="literal">CONSTRAINT</code> 句で制約名を見つけます。
          </p><pre class="programlisting">SHOW CREATE TABLE <em class="replaceable"><code>table</code></em>\G
</pre><p>
            または、<code class="literal">INFORMATION_SCHEMA.TABLE_CONSTRAINTS</code> テーブルをクエリーして、<code class="literal">CONSTRAINT_NAME</code> カラムおよび <code class="literal">CONSTRAINT_TYPE</code> カラムを使用して外部キー名を識別します。
          </p><p>
            単一のステートメントで外部キーとそれに関連付けられたインデックスを削除することもできます:
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>table</code></em> DROP FOREIGN KEY <em class="replaceable"><code>constraint</code></em>, DROP INDEX <em class="replaceable"><code>index</code></em>;
</pre></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          変更対象のテーブルに <a class="link" href="glossary.html#glos_foreign_key" title="外部キー">foreign keys</a> がすでに存在する場合 (つまり、<code class="literal">FOREIGN KEY ... REFERENCE</code> 句を含む <a class="link" href="glossary.html#glos_child_table" title="子テーブル">child table</a> である場合)、外部キーカラムが直接関係していない場合でも、オンライン DDL 操作に追加の制限が適用されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              親テーブルに対する変更によって、<code class="literal">CASCADE</code> または <code class="literal">SET NULL</code> パラメータを使用した <code class="literal">ON UPDATE</code> または <code class="literal">ON DELETE</code> 句を介して子テーブルの関連する変更が発生した場合、子テーブルの <code class="literal">ALTER TABLE</code> は別のトランザクションがコミットされるのを待機できます。
            </p></li><li class="listitem"><p>
              同様に、テーブルが外部キー関係の <a class="link" href="glossary.html#glos_parent_table" title="親テーブル">parent table</a> である場合、<code class="literal">FOREIGN KEY</code> 句が含まれていなくても、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code> または <code class="literal">DELETE</code> ステートメントによって子テーブルの <code class="literal">ON UPDATE</code> または <code class="literal">ON DELETE</code> アクションが完了するまで <code class="literal">ALTER TABLE</code> を待機できます。
            </p></li></ul></div></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="online-ddl-table-operations"></a>テーブルの操作</h4></div></div></div><p>
        次のテーブルに、テーブル操作のオンライン DDL サポートの概要を示します。 アスタリスクは、追加情報、例外または依存関係を示します。 詳細は、<a class="xref" href="innodb-storage-engine.html#online-ddl-table-syntax-notes" title="構文および使用上のノート">構文および使用上のノート</a>を参照してください。 
      </p><div class="table"><a name="online-ddl-table-operations-table"></a><p class="title"><b>表 15.21 テーブル操作のオンライン DDL サポート</b></p><div class="table-contents"><table summary="Online DDL support for table operations indicating whether the operation is performed in place, rebuilds the table, permits concurrent DML, or only modifies metadata."><col style="width: 16%" align="left"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><thead><tr>
            <th scope="col">操作</th>
            <th scope="col">インスタント</th>
            <th scope="col">インプレース</th>
            <th scope="col">テーブルの再構築</th>
            <th scope="col">同時 DML の許可</th>
            <th scope="col">メタデータの変更のみ</th>
          </tr></thead><tbody><tr>
            <th scope="row"><code class="literal">ROW_FORMAT</code> の変更</th>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
            <td>はい</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row"><code class="literal">KEY_BLOCK_SIZE</code> の変更</th>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
            <td>はい</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row">永続テーブルの統計の設定</th>
            <td>いいえ</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
          </tr><tr>
            <th scope="row">文字セットの指定</th>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい*</td>
            <td>いいえ</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row">文字セットの変換</th>
            <td>いいえ</td>
            <td>いいえ</td>
            <td>はい*</td>
            <td>いいえ</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row">テーブルの最適化</th>
            <td>いいえ</td>
            <td>はい*</td>
            <td>はい</td>
            <td>はい</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row"><code class="literal">FORCE</code> オプションを使用した再構築</th>
            <td>いいえ</td>
            <td>はい*</td>
            <td>はい</td>
            <td>はい</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row">null の再構築の実行</th>
            <td>いいえ</td>
            <td>はい*</td>
            <td>はい</td>
            <td>はい</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row">テーブル名の変更</th>
            <td>はい</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
          </tr></tbody></table></div></div><br class="table-break"><h5><a name="online-ddl-table-syntax-notes"></a>構文および使用上のノート</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">ROW_FORMAT</code> の変更
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ROW_FORMAT = <em class="replaceable"><code>row_format</code></em>, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
            データは大幅に再編成され、コストのかかる操作になります。
          </p><p>
            <code class="literal">ROW_FORMAT</code> オプションの詳細は、<a class="xref" href="sql-statements.html#create-table-options" title="テーブルオプション">テーブルオプション</a> を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">KEY_BLOCK_SIZE</code> の変更
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> KEY_BLOCK_SIZE = <em class="replaceable"><code>value</code></em>, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
            データは大幅に再編成され、コストのかかる操作になります。
          </p><p>
            <code class="literal">KEY_BLOCK_SIZE</code> オプションの詳細は、<a class="xref" href="sql-statements.html#create-table-options" title="テーブルオプション">テーブルオプション</a> を参照してください。
          </p></li><li class="listitem"><p>
            永続テーブル統計オプションの設定
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> STATS_PERSISTENT=0, STATS_SAMPLE_PAGES=20, STATS_AUTO_RECALC=1, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
            テーブルメタデータのみを変更します。
          </p><p>
            永続統計には、<code class="literal">STATS_PERSISTENT</code>、<code class="literal">STATS_AUTO_RECALC</code> および <code class="literal">STATS_SAMPLE_PAGES</code> が含まれます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="15.8.10.1 永続的オプティマイザ統計のパラメータの構成">セクション15.8.10.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            文字セットの指定
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> CHARACTER SET = <em class="replaceable"><code>charset_name</code></em>, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
            新しい文字エンコーディングが別のものである場合は、テーブルを再構築します。
          </p></li><li class="listitem"><p>
            文字セットの変換
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> CONVERT TO CHARACTER SET <em class="replaceable"><code>charset_name</code></em>, ALGORITHM=COPY;
</pre><p>
            新しい文字エンコーディングが別のものである場合は、テーブルを再構築します。
          </p></li><li class="listitem"><p>
            テーブルの最適化
          </p><pre class="programlisting">OPTIMIZE TABLE <em class="replaceable"><code>tbl_name</code></em>;
</pre><p>
            インプレース操作は、<code class="literal">FULLTEXT</code> インデックスのあるテーブルではサポートされていません。 この操作では <code class="literal">INPLACE</code> アルゴリズムを使用しますが、<code class="literal">ALGORITHM</code> および <code class="literal">LOCK</code> 構文は許可されていません。 
          </p></li><li class="listitem"><p>
            <code class="literal">FORCE</code> オプションを使用したテーブルの再構築
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> FORCE, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
            MySQL 5.6.17 <code class="literal"></code>. <code class="literal">ALGORITHM=INPLACE</code> is not supported for tables with <code class="literal">FULLTEXT</code> インデックスの時点で <code class="literal">ALGORITHM=INPLACE</code> を使用します。
          </p></li><li class="listitem"><p>
            「null」再構築の実行
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ENGINE=InnoDB, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
            MySQL 5.6.17 の時点では、<code class="literal">ALGORITHM=INPLACE</code> を使用します。 <code class="literal">ALGORITHM=INPLACE</code> は、<code class="literal">FULLTEXT</code> インデックスのあるテーブルではサポートされていません。 
          </p></li><li class="listitem"><p>
            テーブル名の変更
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>old_tbl_name</code></em> RENAME TO <em class="replaceable"><code>new_tbl_name</code></em>, ALGORITHM=INSTANT;
</pre><p>
            テーブルの名前変更は、即時に実行することも、インプレースで実行することもできます。 MySQL は、コピーを作成せずに、テーブル <em class="replaceable"><code>tbl_name</code></em> に対応するファイルの名前を変更します。 (<code class="literal">RENAME TABLE</code> ステートメントを使用してテーブルの名前を変更することもできます。 <a class="xref" href="sql-statements.html#rename-table" title="13.1.36 RENAME TABLE ステートメント">セクション13.1.36「RENAME TABLE ステートメント」</a>を参照してください。) 名前を変更したテーブル専用に付与された権限は、新しい名前に移行されません。 それらは、手動で変更する必要があります。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="online-ddl-tablespace-operations"></a>テーブルスペースの操作</h4></div></div></div><p>
        次のテーブルに、テーブルスペース操作のオンライン DDL サポートの概要を示します。 詳細は、<a class="xref" href="innodb-storage-engine.html#online-ddl-tablespace-syntax-notes" title="構文および使用上のノート">構文および使用上のノート</a>を参照してください。 
      </p><div class="table"><a name="online-ddl-tablespace-operations-table"></a><p class="title"><b>表 15.22 テーブルスペース操作のオンライン DDL サポート</b></p><div class="table-contents"><table summary="Online DDL support for tablespace operations indicating whether the operation is performed in place, rebuilds tables within the tablespace, permits concurrent DML, or only modifies metadata."><col style="width: 16%" align="left"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><col style="width: 16%" align="center"><thead><tr>
            <th scope="col">操作</th>
            <th scope="col">インスタント</th>
            <th scope="col">インプレース</th>
            <th scope="col">テーブルの再構築</th>
            <th scope="col">同時 DML の許可</th>
            <th scope="col">メタデータの変更のみ</th>
          </tr></thead><tbody><tr>
            <th scope="row">一般テーブルスペースの名前の変更</th>
            <td>いいえ</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
          </tr><tr>
            <th scope="row">一般的なテーブルスペース暗号化の有効化または無効化</th>
            <td>いいえ</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>いいえ</td>
          </tr><tr>
            <th scope="row">file-per-table テーブルスペース暗号化の有効化または無効化</th>
            <td>いいえ</td>
            <td>いいえ</td>
            <td>はい</td>
            <td>いいえ</td>
            <td>いいえ</td>
          </tr></tbody></table></div></div><br class="table-break"><h5><a name="online-ddl-tablespace-syntax-notes"></a>構文および使用上のノート</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            一般テーブルスペースの名前の変更
          </p><pre class="programlisting">ALTER TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> RENAME TO <em class="replaceable"><code>new_tablespace_name</code></em>;
</pre><p>
            <code class="literal">ALTER TABLESPACE ... RENAME TO</code> は <code class="literal">INPLACE</code> アルゴリズムを使用しますが、<code class="literal">ALGORITHM</code> 句はサポートしていません。
          </p></li><li class="listitem"><p>
            一般的なテーブルスペース暗号化の有効化または無効化
          </p><pre class="programlisting">ALTER TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> ENCRYPTION='Y';
</pre><p>
            <code class="literal">ALTER TABLESPACE ... ENCRYPTION</code> は <code class="literal">INPLACE</code> アルゴリズムを使用しますが、<code class="literal">ALGORITHM</code> 句はサポートしていません。
          </p><p>
            関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-data-encryption" title="15.13 InnoDB 保存データ暗号化">セクション15.13「InnoDB 保存データ暗号化」</a>を参照してください。
          </p></li><li class="listitem"><p>
            file-per-table テーブルスペース暗号化の有効化または無効化
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ENCRYPTION='Y', ALGORITHM=COPY;
</pre><p>
            関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-data-encryption" title="15.13 InnoDB 保存データ暗号化">セクション15.13「InnoDB 保存データ暗号化」</a>を参照してください。
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="online-ddl-partitioning"></a>パーティション化操作</h4></div></div></div><p>
        一部の <code class="literal">ALTER TABLE</code> パーティション化句を除き、パーティション化された <code class="literal">InnoDB</code> テーブルのオンライン DDL 操作は、通常の <code class="literal">InnoDB</code> テーブルに適用されるのと同じルールに従います。
      </p><p>
        一部の <code class="literal">ALTER TABLE</code> パーティション化句は、通常の非パーティション <code class="literal">InnoDB</code> テーブルと同じ内部オンライン DDL API を経由しません。 その結果、<code class="literal">ALTER TABLE</code> パーティション化句のオンラインサポートは異なります。 
      </p><p>
        次のテーブルに、各 <code class="literal">ALTER TABLE</code> パーティション化ステートメントのオンラインステータスを示します。 使用されるオンライン DDL API に関係なく、MySQL は可能な場合はデータのコピーおよびロックを最小限に抑えようとします。 
      </p><p>
        <code class="literal">ALGORITHM=COPY</code> を使用するか、<span class="quote">「<span class="quote"><code class="literal">ALGORITHM=DEFAULT, LOCK=DEFAULT</code></span>」</span> のみを許可する <code class="literal">ALTER TABLE</code> パーティション化オプションでは、<code class="literal">COPY</code> アルゴリズムを使用してテーブルを再パーティション化します。 つまり、新しいパーティション化されたテーブルは、新しいパーティション化スキームで作成されます。 新しく作成されたテーブルには、<code class="literal">ALTER TABLE</code> ステートメントによって適用された変更が含まれ、テーブルデータが新しいテーブル構造にコピーされます。 
      </p><div class="table"><a name="innodb-online-ddl-partitioning-clauses"></a><p class="title"><b>表 15.23 パーティション化操作のオンライン DDL サポート</b></p><div class="table-contents"><table summary="Online DDL support for partitioning operations indicating whether the operation is performed in place and permits concurrent DML."><col style="width: 24%" align="left"><col style="width: 8%" align="center"><col style="width: 8%" align="center"><col style="width: 12%" align="center"><col style="width: 32%" align="left"><thead><tr>
            <th scope="col">Partitioning 句</th>
            <th scope="col">インスタント</th>
            <th scope="col">インプレース</th>
            <th scope="col">DML を許可</th>
            <th scope="col">メモ</th>
          </tr></thead><tbody><tr>
            <th scope="row"><code class="literal">PARTITION BY</code></th>
            <td>いいえ</td>
            <td>いいえ</td>
            <td>いいえ</td>
            <td><code class="literal">ALGORITHM=COPY</code>、<code class="literal">LOCK={DEFAULT|SHARED|EXCLUSIVE}</code> を許可</td>
          </tr><tr>
            <th scope="row"><code class="literal">ADD PARTITION</code></th>
            <td>いいえ</td>
            <td>はい*</td>
            <td>はい*</td>
            <td><code class="literal">ALGORITHM=INPLACE, LOCK={DEFAULT|NONE|SHARED|EXCLUSISVE}</code> は、<code class="literal">RANGE</code> および <code class="literal">LIST</code> パーティション、<code class="literal">HASH</code> および <code class="literal">KEY</code> パーティションの <code class="literal">ALGORITHM=INPLACE, LOCK={DEFAULT|SHARED|EXCLUSISVE}</code> およびすべてのパーティションタイプの <code class="literal">ALGORITHM=COPY, LOCK={SHARED|EXCLUSIVE}</code> でサポートされています。 <code class="literal">RANGE</code> または <code class="literal">LIST</code> によってパーティション化されたテーブルの既存のデータはコピーしません。 MySQL は共有ロックを保持しながらデータをコピーするため、<code class="literal">HASH</code> または <code class="literal">LIST</code> によってパーティション化されたテーブルに対して <code class="literal">ALGORITHM=COPY</code> で同時クエリーが許可されます。 </td>
          </tr><tr>
            <th scope="row"><code class="literal">DROP PARTITION</code></th>
            <td>いいえ</td>
            <td>はい*</td>
            <td>はい*</td>
            <td><p>
                <code class="literal">ALGORITHM=INPLACE, LOCK={DEFAULT|NONE|SHARED|EXCLUSIVE}</code> がサポートされています。 <code class="literal">RANGE</code> または <code class="literal">LIST</code> によってパーティション化されたテーブルのデータはコピーしません。 
              </p><p>
                <code class="literal">ALGORITHM=INPLACE</code> を使用した <code class="literal">DROP PARTITION</code> は、パーティションに格納されているデータを削除し、パーティションを削除します。 ただし、<code class="literal">ALGORITHM=COPY</code> または <code class="literal">old_alter_table=ON</code> を使用した <code class="literal">DROP PARTITION</code> では、パーティションテーブルが再構築され、削除されたパーティションから互換性のある <code class="literal">PARTITION ... VALUES</code> 定義を持つ別のパーティションへのデータの移動が試行されます。 別のパーティションに移動できないデータは削除されます。 
              </p></td>
          </tr><tr>
            <th scope="row"><code class="literal">DISCARD PARTITION</code></th>
            <td>いいえ</td>
            <td>いいえ</td>
            <td>いいえ</td>
            <td><code class="literal">ALGORITHM=DEFAULT</code>、<code class="literal">LOCK=DEFAULT</code> のみを許可</td>
          </tr><tr>
            <th scope="row"><code class="literal">IMPORT PARTITION</code></th>
            <td>いいえ</td>
            <td>いいえ</td>
            <td>いいえ</td>
            <td><code class="literal">ALGORITHM=DEFAULT</code>、<code class="literal">LOCK=DEFAULT</code> のみを許可</td>
          </tr><tr>
            <th scope="row"><code class="literal">TRUNCATE PARTITION</code></th>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
            <td>既存のデータをコピーしません。 行を削除するだけで、テーブル自体またはそのパーティションの定義は変更されません。 </td>
          </tr><tr>
            <th scope="row"><code class="literal">COALESCE PARTITION</code></th>
            <td>いいえ</td>
            <td>はい*</td>
            <td>いいえ</td>
            <td><code class="literal">ALGORITHM=INPLACE, LOCK={DEFAULT|SHARED|EXCLUSIVE}</code> がサポートされています。</td>
          </tr><tr>
            <th scope="row"><code class="literal">REORGANIZE PARTITION</code></th>
            <td>いいえ</td>
            <td>はい*</td>
            <td>いいえ</td>
            <td><code class="literal">ALGORITHM=INPLACE, LOCK={DEFAULT|SHARED|EXCLUSIVE}</code> がサポートされています。</td>
          </tr><tr>
            <th scope="row"><code class="literal">EXCHANGE PARTITION</code></th>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
            <td></td>
          </tr><tr>
            <th scope="row"><code class="literal">ANALYZE PARTITION</code></th>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
            <td></td>
          </tr><tr>
            <th scope="row"><code class="literal">CHECK PARTITION</code></th>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
            <td></td>
          </tr><tr>
            <th scope="row"><code class="literal">OPTIMIZE PARTITION</code></th>
            <td>いいえ</td>
            <td>いいえ</td>
            <td>いいえ</td>
            <td><code class="literal">ALGORITHM</code> 句および <code class="literal">LOCK</code> 句は無視されます。 テーブル全体を再構築します。 <a class="xref" href="partitioning.html#partitioning-maintenance" title="24.3.4 パーティションの保守">セクション24.3.4「パーティションの保守」</a>を参照してください。 </td>
          </tr><tr>
            <th scope="row"><code class="literal">REBUILD PARTITION</code></th>
            <td>いいえ</td>
            <td>はい*</td>
            <td>いいえ</td>
            <td><code class="literal">ALGORITHM=INPLACE, LOCK={DEFAULT|SHARED|EXCLUSIVE}</code> がサポートされています。</td>
          </tr><tr>
            <th scope="row"><code class="literal">REPAIR PARTITION</code></th>
            <td>いいえ</td>
            <td>はい</td>
            <td>はい</td>
            <td></td>
          </tr><tr>
            <th scope="row"><code class="literal">REMOVE PARTITIONING</code></th>
            <td>いいえ</td>
            <td>いいえ</td>
            <td>いいえ</td>
            <td><code class="literal">ALGORITHM=COPY</code>、<code class="literal">LOCK={DEFAULT|SHARED|EXCLUSIVE}</code> を許可</td>
          </tr></tbody></table></div></div><br class="table-break"><p>
        パーティションテーブルに対する非パーティション化オンライン <code class="literal">ALTER TABLE</code> 操作は、通常のテーブルに適用されるのと同じルールに従います。 ただし、<code class="literal">ALTER TABLE</code> は各テーブルパーティションに対してオンライン操作を実行するため、複数のパーティションで操作が実行されるため、システムリソースに対する需要が増加します。 
      </p><p>
        <code class="literal">ALTER TABLE</code> パーティション化句の詳細は、<a class="xref" href="sql-statements.html#alter-table-partition-options" title="パーティショニングオプション">パーティショニングオプション</a> および <a class="xref" href="sql-statements.html#alter-table-partition-operations" title="13.1.9.1 ALTER TABLE パーティション操作">セクション13.1.9.1「ALTER TABLE パーティション操作」</a> を参照してください。 一般的なパーティション化については、<a class="xref" href="partitioning.html" title="第 24 章 パーティション化">第24章「<i>パーティション化</i>」</a> を参照してください。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-online-ddl-performance"></a>15.12.2 オンライン DDL のパフォーマンスと同時実行性</h3></div></div></div><a class="indexterm" name="idm44761357224832"></a><p>
      オンライン DDL は、MySQL 操作のいくつかの側面を改善します:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          DDL 操作の進行中にテーブルに対するクエリーおよび DML 操作を続行できるため、テーブルにアクセスするアプリケーションの応答性が向上します。 ロックを削減し、MySQL サーバーリソースを待機すると、DDL 操作に関係しない操作でもスケーラビリティが向上します。 
        </p></li><li class="listitem"><p>
          即時操作では、データディクショナリのメタデータのみが変更されます。 テーブルに対するメタデータロックは行われず、テーブルデータは影響を受けず、操作が即時に行われます。 同時 DML は影響を受けません。 
        </p></li><li class="listitem"><p>
          オンライン操作により、テーブルコピー方法に関連付けられたディスク I/O および CPU サイクルが回避され、データベースの全体的な負荷が最小限に抑えられます。 負荷を最小限に抑えると、DDL 操作中に良好なパフォーマンスと高スループットを維持できます。 
        </p></li><li class="listitem"><p>
          オンライン操作は、テーブルコピー操作より少ないデータをバッファープールに読み取り、頻繁にアクセスされるデータのメモリーからのパージを削減します。 頻繁にアクセスされるデータをパージすると、DDL 操作後に一時的なパフォーマンスが低下する可能性があります。 
        </p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-online-ddl-locking-options"></a>LOCK 句</h4></div></div></div><p>
        デフォルトでは、MySQL は DDL 操作中にできるだけ少ないロックを使用します。 必要に応じて、<code class="literal">LOCK</code> 句をインプレース操作および一部のコピー操作に指定して、より限定的なロックを強制できます。 <code class="literal">LOCK</code> 句で、特定の DDL 操作に許可されている制限レベルより低いロックが指定されている場合、ステートメントはエラーで失敗します。 <code class="literal">LOCK</code> 句については、次に、最も制限の少ないものから順に説明します: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">LOCK=NONE</code>:
          </p><p>
            同時クエリーおよび DML を許可します。
          </p><p>
            たとえば、長い DDL 操作中にテーブルを使用できないようにするには、顧客のサインアップまたは購入を含むテーブルに対してこの句を使用します。
          </p></li><li class="listitem"><p>
            <code class="literal">LOCK=SHARED</code>:
          </p><p>
            同時クエリーは許可されますが、DML はブロックされます。
          </p><p>
            たとえば、データウェアハウステーブルでこの句を使用すると、DDL 操作が終了するまでデータロード操作を遅延できますが、クエリーを長期間遅延することはできません。
          </p></li><li class="listitem"><p>
            <code class="literal">LOCK=DEFAULT</code>:
          </p><p>
            可能なかぎり多くの同時実行性を許可します (同時クエリーまたは DML、あるいはその両方)。 <code class="literal">LOCK</code> 句を省略することは、<code class="literal">LOCK=DEFAULT</code> を指定することと同じです。 
          </p><p>
            DDL ステートメントのデフォルトのロックレベルでテーブルの可用性の問題が発生することが予想されない場合は、この句を使用します。
          </p></li><li class="listitem"><p>
            <code class="literal">LOCK=EXCLUSIVE</code>:
          </p><p>
            同時クエリーおよび DML をブロックします。
          </p><p>
            この句は、主な懸念事項が可能なかぎり短い時間で DDL 操作を終了することで、同時クエリーおよび DML アクセスが不要な場合に使用します。 また、予期しないテーブルアクセスを避けるために、サーバーがアイドル状態であると想定される場合にも、この句を使用できます。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-online-ddl-metadata-locks"></a>オンライン DDL およびメタデータロック</h4></div></div></div><p>
        オンライン DDL 操作は、次の 3 つのフェーズを持つものとして表示できます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="emphasis"><em>フェーズ 1: 初期化</em></span>
          </p><p>
            初期化フェーズでは、サーバーは、ストレージエンジンの機能、ステートメントで指定された操作、およびユーザー指定の <code class="literal">ALGORITHM</code> オプションと <code class="literal">LOCK</code> オプションを考慮して、操作中に許可される同時実行性を決定します。 このフェーズでは、現在のテーブル定義を保護するために、アップグレード可能な共有メタデータロックが取得されます。 
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>フェーズ 2: Execution</em></span>
          </p><p>
            このフェーズでは、ステートメントが準備されて実行されます。 メタデータロックが排他的にアップグレードされるかどうかは、初期化フェーズで評価される要因によって異なります。 排他的メタデータロックが必要な場合は、ステートメントの準備中にのみ簡単に取得されます。 
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>フェーズ 3: テーブル定義のコミット</em></span>
          </p><p>
            テーブル定義のコミットフェーズでは、メタデータロックが排他的にアップグレードされ、古いテーブル定義が削除されて新しい定義がコミットされます。 付与されると、排他的メタデータロックの期間が短くなります。 
          </p></li></ul></div><p>
        前述の排他的メタデータロック要件のため、オンライン DDL 操作では、テーブルのメタデータロックを保持する同時トランザクションがコミットまたはロールバックされるまで待機する必要がある場合があります。 DDL 操作の前または実行中に開始されたトランザクションは、変更されるテーブルのメタデータロックを保持できます。 長時間実行中または非アクティブなトランザクションの場合、オンライン DDL 操作は排他的メタデータロックの待機中にタイムアウトすることがあります。 また、オンライン DDL 操作によってリクエストされた保留中の排他的メタデータロックによって、テーブルの後続のトランザクションがブロックされます。 
      </p><p>
        次の例は、排他的メタデータロックを待機しているオンライン DDL 操作と、保留中のメタデータロックがテーブルの後続のトランザクションをブロックする方法を示しています。
      </p><p>
        セッション 1:
      </p><pre class="programlisting">mysql&gt; CREATE TABLE t1 (c1 INT) ENGINE=InnoDB;
mysql&gt; START TRANSACTION;
mysql&gt; SELECT * FROM t1;
</pre><p>
        セッション 1 の <code class="literal">SELECT</code> ステートメントは、テーブル t1 で共有メタデータロックを取得します。
      </p><p>
        セッション 2:
      </p><pre class="programlisting">mysql&gt; ALTER TABLE t1 ADD COLUMN x INT, ALGORITHM=INPLACE, LOCK=NONE;
</pre><p>
        テーブル定義の変更をコミットするためにテーブル t1 の排他的メタデータロックを必要とするセッション 2 のオンライン DDL 操作は、セッション 1 のトランザクションがコミットまたはロールバックされるまで待機する必要があります。
      </p><p>
        セッション 3:
      </p><pre class="programlisting">mysql&gt; SELECT * FROM t1;
</pre><p>
        セッション 3 で発行された <code class="literal">SELECT</code> ステートメントは、セッション 2 の <code class="literal">ALTER TABLE</code> 操作によってリクエストされた排他的メタデータロックが付与されるのを待機してブロックされます。
      </p><p>
        <code class="literal">SHOW FULL PROCESSLIST</code> を使用して、トランザクションがメタデータロックを待機しているかどうかを確認できます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW FULL PROCESSLIST\G</code></strong>
...
*************************** 2. row ***************************
     Id: 5
   User: root
   Host: localhost
     db: test
Command: Query
   Time: 44
  State: Waiting for table metadata lock
   Info: ALTER TABLE t1 ADD COLUMN x INT, ALGORITHM=INPLACE, LOCK=NONE
...
*************************** 4. row ***************************
     Id: 7
   User: root
   Host: localhost
     db: test
Command: Query
   Time: 5
  State: Waiting for table metadata lock
   Info: SELECT * FROM t1
4 rows in set (0.00 sec)
</pre><p>
        メタデータロック情報は、セッション間のメタデータロックの依存関係、セッションが待機しているメタデータロック、および現在メタデータロックを保持しているセッションに関する情報を提供するパフォーマンススキーマ <code class="literal">metadata_locks</code> テーブルを介しても公開されます。 詳細は、<a class="xref" href="performance-schema.html#performance-schema-metadata-locks-table" title="27.12.13.3 metadata_locks テーブル">セクション27.12.13.3「metadata_locks テーブル」</a>を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-online-ddl-performance-comparison"></a>オンライン DDL パフォーマンス</h4></div></div></div><p>
        DDL 操作のパフォーマンスは、操作が即時に実行されるかどうか、インプレースで実行されるかどうか、およびテーブルを再構築するかどうかによって主に決定されます。
      </p><p>
        DDL 操作の相対パフォーマンスを評価するには、<code class="literal">ALGORITHM=INSTANT</code>、<code class="literal">ALGORITHM=INPLACE</code> および <code class="literal">ALGORITHM=COPY</code> を使用して結果を比較します。 <code class="literal">old_alter_table</code> を有効にしてステートメントを実行し、<code class="literal">ALGORITHM=COPY</code> を強制的に使用することもできます。 
      </p><p>
        テーブルデータを変更する DDL 操作の場合は、コマンドの終了後に表示される<span class="quote">「<span class="quote">「影響を受ける行」</span>」</span>値を参照して、DDL 操作で変更を実行するか、テーブルのコピーを実行するかを決定できます。 例: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            カラムのデフォルト値の変更 (高速、テーブルデータへの影響なし):
          </p><pre class="programlisting">Query OK, 0 rows affected (0.07 sec)
</pre></li><li class="listitem"><p>
            インデックスの追加 (時間はかかりますが、<code class="literal">0 rows affected</code> はテーブルがコピーされないことを示しています):
          </p><pre class="programlisting">Query OK, 0 rows affected (21.42 sec)
</pre></li><li class="listitem"><p>
            カラムのデータ型の変更 (かなりの時間がかかり、テーブルのすべての行を再構築する必要があります):
          </p><pre class="programlisting">Query OK, 1671168 rows affected (1 min 35.54 sec)
</pre></li></ul></div><p>
        大規模なテーブルに対して DDL 操作を実行する前に、次のように操作が高速か低速かを確認します:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            テーブル構造をクローニングします。
          </p></li><li class="listitem"><p>
            クローンテーブルに少量のデータを移入します。
          </p></li><li class="listitem"><p>
            クローニングされたテーブルで DDL 操作を実行します。
          </p></li><li class="listitem"><p>
            <span class="quote">「<span class="quote">rows affected</span>」</span>の値が 0 かどうかをチェックします。 ゼロ以外の値は、特別な計画を必要とする可能性があるテーブルデータがコピーされることを意味します。 たとえば、スケジュールされた停止時間中に DDL 操作を実行したり、各レプリカサーバーで一度に 1 つずつ DDL 操作を実行できます。 
          </p></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          DDL 操作に関連する MySQL 処理をより深く理解するには、DDL 操作の前後に <code class="literal">InnoDB</code> に関連するパフォーマンススキーマおよび <code class="literal">INFORMATION_SCHEMA</code> テーブルを調べて、物理読取り、書込み、メモリー割当てなどの数を確認します。
        </p><p>
          パフォーマンススキーマのステージイベントを使用して、<code class="literal">ALTER TABLE</code> の進行状況をモニターできます。 <a class="xref" href="innodb-storage-engine.html#monitor-alter-table-performance-schema" title="15.16.1 パフォーマンススキーマを使用した InnoDB テーブルの ALTER TABLE の進行状況のモニタリング">セクション15.16.1「パフォーマンススキーマを使用した InnoDB テーブルの ALTER TABLE の進行状況のモニタリング」</a>を参照してください。 
        </p></div><p>
        同時 DML 操作によって行われた変更の記録、最後へのそれらの変更の適用に関連する処理作業がいくつかあるため、オンライン DDL 操作は、他のセッションからのテーブルのアクセスをブロックするテーブルコピーメカニズムよりも全体的に時間がかかる可能性があります。 raw パフォーマンスの低下は、そのテーブルを使用するアプリケーションの応答性の向上とバランスがとれています。 テーブル構造を変更する手法を評価する場合は、web ページのロード時間などの要因に基づいて、エンドユーザーがパフォーマンスを認識することを検討してください。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-online-ddl-space-requirements"></a>15.12.3 オンライン DDL 領域の要件</h3></div></div></div><p>
      インプレースのオンライン DDL 操作の領域要件の概要を次に示します。 領域要件は、即時に実行される操作には適用されません。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          一時ログファイル用の領域
        </p><p>
          一時ログファイルには、オンライン DDL 操作によってインデックスが作成されるか、テーブルが変更されると、同時 DML が記録されます。 一時ログファイルは、<code class="literal">innodb_sort_buffer_size</code> の値によって必要に応じて、<code class="literal">innodb_online_alter_log_max_size</code> で指定された最大値まで拡張されます。 一時ログファイルがサイズ制限を超えると、オンライン DDL 操作は失敗し、コミットされていない同時 DML 操作がロールバックされます。 大規模な <code class="literal">innodb_online_alter_log_max_size</code> 設定では、オンライン DDL 操作中により多くの DML が許可されますが、ログに記録された DML を適用するためにテーブルがロックされている場合、DDL 操作の終了時の期間も延長されます。 
        </p><p>
          操作に時間がかかり、一時ログファイルのサイズが <code class="literal">innodb_online_alter_log_max_size</code> の値を超えるように同時 DML によってテーブルが変更された場合、オンライン DDL 操作は <code class="literal">DB_ONLINE_LOG_TOO_BIG</code> エラーで失敗します。
        </p></li><li class="listitem"><p>
          一時ソートファイル用の領域
        </p><p>
          テーブルを再構築するオンライン DDL 操作では、インデックスの作成時に一時ソートファイルが MySQL 一時ディレクトリ (Unix の場合は <code class="literal">$TMPDIR</code>、Windows の場合は <code class="literal">%TEMP%</code>、<code class="literal">--tmpdir</code> で指定されたディレクトリ) に書き込まれます。 一時ソートファイルは、元のテーブルを含むディレクトリには作成されません。 各一時ソートファイルは、1 つのデータカラムを保持するのに十分な大きさであり、各ソートファイルは、そのデータが最終的なテーブルまたはインデックスにマージされると削除されます。 一時ソートファイルを使用する操作には、テーブルのデータ量にインデックスを加えたものと同じ一時領域が必要になる場合があります。 オンライン DDL 操作で、データディレクトリが存在するファイルシステム上の使用可能なすべてのディスク領域が使用されている場合は、エラーが報告されます。 
        </p><p>
          MySQL 一時ディレクトリがソートファイルを保持するのに十分な大きさでない場合は、<code class="literal">tmpdir</code> を別のディレクトリに設定します。 または、<code class="literal">innodb_tmpdir</code> を使用して、オンライン DDL 操作用に個別の一時ディレクトリを定義します。 このオプションは、大規模な一時ソートファイルの結果として発生する可能性のある一時ディレクトリのオーバーフローを回避するために導入されました。 
        </p></li><li class="listitem"><p>
          中間テーブルファイル用の領域
        </p><p>
          テーブルを再構築する一部のオンライン DDL 操作では、元のテーブルと同じディレクトリに一時中間テーブルファイルが作成されます。 中間テーブルファイルには、元のテーブルのサイズと等しい領域が必要な場合があります。 中間テーブルのファイル名は<code class="filename">#sql-ib</code> 接頭辞で始まり、オンライン DDL 操作中にのみ簡単に表示されます。 
        </p><p>
          <code class="literal">innodb_tmpdir</code> オプションは、中間テーブルファイルには適用されません。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-online-ddl-single-multi"></a>15.12.4 オンライン DDL を使用した DDL ステートメントの簡略化</h3></div></div></div><p>
      <a class="link" href="glossary.html#glos_online_ddl" title="オンライン DDL">オンライン DDL</a> が導入される前は、多くの DDL 操作を 1 つの <code class="literal">ALTER TABLE</code> ステートメントに結合することが一般的な習慣でした。 各 <code class="literal">ALTER TABLE</code> ステートメントにはテーブルのコピーと再構築が含まれていたため、テーブルに対するすべての変更を 1 回の再構築操作で実行できたことから、同じテーブルへのいくつかの変更を一度に行う方が効率的でした。 マイナス面としては、DDL 操作に関連する SQL コードが保守しにくく、別のスクリプトでの再利用も難しい点がありました。 特定の変更が毎回異なっていたとすると、少し異なるシナリオごとに、新しい複雑な <code class="literal">ALTER TABLE</code> の構築が必要になる可能性があります。 
    </p><p>
      オンラインで実行できる DDL 操作の場合は、効率を犠牲にすることなく、スクリプトおよびメンテナンスを容易にするために個々の <code class="literal">ALTER TABLE</code> ステートメントに分割できます。 たとえば、次のような複雑なステートメントを取り上げ、 
    </p><pre class="programlisting">ALTER TABLE t1 ADD INDEX i1(c1), ADD UNIQUE INDEX i2(c2),
  CHANGE c4_old_name c4_new_name INTEGER UNSIGNED;
</pre><p>
      それを独立してテストおよび実行できる、次のようなより簡単な部分に分解することができます。
    </p><pre class="programlisting">ALTER TABLE t1 ADD INDEX i1(c1);
ALTER TABLE t1 ADD UNIQUE INDEX i2(c2);
ALTER TABLE t1 CHANGE c4_old_name c4_new_name INTEGER UNSIGNED NOT NULL;
</pre><p>
      複数の部分からなる <code class="literal">ALTER TABLE</code> ステートメントは、次の目的に引き続き使用できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          特定のシーケンスで実行する必要のある操作。たとえば、インデックスの作成に続けて、そのインデックスを使用する外部キー制約を作成する場合など。
        </p></li><li class="listitem"><p>
          グループとして成功または失敗するようにしたい、すべてが同じ特定の <code class="literal">LOCK</code> 句を使用している操作。
        </p></li><li class="listitem"><p>
          オンラインで実行できない (つまり、引き続き table-copy メソッドを使用する) 操作。
        </p></li><li class="listitem"><p>
          特殊なシナリオでの正確な下位互換性のために必要な場合に強制的にテーブルコピー動作を行うために、<code class="literal">ALGORITHM=COPY</code> または <code class="literal">old_alter_table=1</code> を指定する操作。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-online-ddl-failure-conditions"></a>15.12.5 オンライン DDL 失敗条件</h3></div></div></div><p>
      オンライン DDL 操作の失敗は、通常、次のいずれかの状況が原因です:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">ALGORITHM</code> 句では、特定のタイプの DDL 操作またはストレージエンジンと互換性のないアルゴリズムを指定します。
        </p></li><li class="listitem"><p>
          <code class="literal">LOCK</code> 句では、特定のタイプの DDL 操作と互換性のない低レベルのロック (<code class="literal">SHARED</code> または <code class="literal">NONE</code>) を指定します。
        </p></li><li class="listitem"><p>
          テーブルでの <a class="link" href="glossary.html#glos_exclusive_lock" title="排他ロック">exclusive lock</a> の待機中にタイムアウトが発生し、DDL 操作の初期フェーズおよび最終フェーズで短時間必要になる場合があります。
        </p></li><li class="listitem"><p>
          <code class="literal">tmpdir</code> または <code class="literal">innodb_tmpdir</code> ファイルシステムのディスク領域が不足していますが、MySQL はインデックスの作成中に一時ソートファイルをディスクに書き込みます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-space-requirements" title="15.12.3 オンライン DDL 領域の要件">セクション15.12.3「オンライン DDL 領域の要件」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          操作には時間がかかり、同時 DML は一時オンラインログのサイズが <code class="literal">innodb_online_alter_log_max_size</code> 構成オプションの値を超えるようにテーブルを変更します。 この状態は <code class="literal">DB_ONLINE_LOG_TOO_BIG</code> エラーの原因になります。 
        </p></li><li class="listitem"><p>
          同時 DML は、元のテーブル定義では許可されているが、新しいテーブル定義では許可されていないテーブルに変更を加えます。 この操作は、MySQL がいちばん最後に、並列 DML ステートメントからのすべての変更を適用しようとしたときにのみ失敗します。 たとえば、一意のインデックスの作成中にカラムに重複した値を挿入したり、そのカラムでの<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>のインデックスの作成中にカラムに <code class="literal">NULL</code> 値を挿入したりすることがあります。 並列 DML によって行われた変更が優先され、<code class="literal">ALTER TABLE</code> 操作は実質的に<a class="link" href="glossary.html#glos_rollback" title="ロールバック">ロールバック</a>されます。 
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-online-ddl-limitations"></a>15.12.6 オンライン DDL の制限事項</h3></div></div></div><a class="indexterm" name="idm44761357070752"></a><a class="indexterm" name="idm44761357068608"></a><a class="indexterm" name="idm44761357066560"></a><p>
      オンライン DDL 操作には、次の制限が適用されます:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          このテーブルは、<code class="literal">TEMPORARY TABLE</code> でインデックスを作成するときにコピーされます。
        </p></li><li class="listitem"><p>
          テーブルに <code class="literal">ON...CASCADE</code> または <code class="literal">ON...SET NULL</code> 制約がある場合、<code class="literal">ALTER TABLE</code> 句の <code class="literal">LOCK=NONE</code> は使用できません。
        </p></li><li class="listitem"><p>
          インプレースのオンライン DDL 操作を終了する前に、テーブルのメタデータロックを保持するトランザクションがコミットまたはロールバックされるまで待機する必要があります。 オンライン DDL 操作では、実行フェーズ中にテーブルに対する排他的メタデータロックが短時間必要になる場合があり、テーブル定義の更新時には常に操作の最終フェーズで必要になります。 その結果、テーブルのメタデータロックを保持しているトランザクションによって、オンライン DDL 操作がブロックされる可能性があります。 テーブルのメタデータロックを保持するトランザクションは、オンライン DDL 操作の前または実行中に開始されている可能性があります。 テーブルのメタデータロックを保持する長時間実行中または非アクティブなトランザクションによって、オンライン DDL 操作がタイムアウトする可能性があります。 
        </p></li><li class="listitem"><p>
          インプレースのオンライン DDL 操作を実行する場合、<code class="literal">ALTER TABLE</code> ステートメントを実行するスレッドは、他の接続スレッドから同じテーブルに対して同時に実行された DML 操作のオンラインログを適用します。 これらの DML 操作が適用されると、重複したキーエントリのエラー (<span class="errortext">ERROR 1062 (23000): 重複したエントリ</span>) が発生する可能性があります。これは、重複したエントリが一時的なだけで、オンラインログのあとの方のエントリによって元に戻されるとしても同じです。 これは、トランザクション中は制約を保持する必要のある、<code class="literal">InnoDB</code> での外部キー制約チェックの考え方に似ています。 
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> テーブルに対する <code class="literal">OPTIMIZE TABLE</code> は、テーブルを再構築して、インデックス統計を更新し、クラスタ化されたインデックス内の未使用領域を解放するための <code class="literal">ALTER TABLE</code> 操作にマップされます。 主キーに現れる順序でキーが挿入されるため、セカンダリインデックスはそれほど効率的に作成されません。 <code class="literal">OPTIMIZE TABLE</code> は、通常の <code class="literal">InnoDB</code> テーブルおよびパーティション化された <code class="literal">InnoDB</code> テーブルを再構築するためのオンライン DDL サポートが追加されてサポートされています。 
        </p></li><li class="listitem"><p>
          一時カラム (<code class="literal">DATE</code>、<code class="literal">DATETIME</code> または <code class="literal">TIMESTAMP</code>) を含み、<code class="literal"> ALGORITHM=COPY</code> を使用して再構築されていない MySQL 5.6 より前に作成されたテーブルは、<code class="literal">ALGORITHM=INPLACE</code> をサポートしていません。 この場合は、<code class="literal">ALTER TABLE ... ALGORITHM=INPLACE</code> 操作によって次のエラーが返されます。 
        </p><pre class="programlisting">ERROR 1846 (0A000): ALGORITHM=INPLACE is not supported.
Reason: Cannot change column type INPLACE. Try ALGORITHM=COPY.
</pre></li><li class="listitem"><p>
          通常、テーブルの再構築を伴う大規模なテーブルに対するオンライン DDL 操作には、次の制限が適用されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              オンライン DDL 操作を一時停止したり、オンライン DDL 操作の I/O または CPU 使用率を抑制するメカニズムはありません。
            </p></li><li class="listitem"><p>
              オンライン DDL 操作のロールバックは、操作が失敗した場合にコストがかかる可能性があります。
            </p></li><li class="listitem"><p>
              オンライン DDL 操作を長時間実行すると、レプリケーションラグが発生する可能性があります。 オンライン DDL 操作は、レプリカで実行する前にソースで実行を終了する必要があります。 また、ソースで同時に処理された DML は、レプリカでの DDL 操作が完了した後にのみレプリカで処理されます。 
            </p></li></ul></div><p>
          大規模なテーブルに対するオンライン DDL 操作の実行に関連する追加情報は、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-performance" title="15.12.2 オンライン DDL のパフォーマンスと同時実行性">セクション15.12.2「オンライン DDL のパフォーマンスと同時実行性」</a> を参照してください。
        </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-data-encryption"></a>15.13 InnoDB 保存データ暗号化</h2></div></div></div><a class="indexterm" name="idm44761357025568"></a><a class="indexterm" name="idm44761357024016"></a><a class="indexterm" name="idm44761357023040"></a><a class="indexterm" name="idm44761357021600"></a><a class="indexterm" name="idm44761357020224"></a><a class="indexterm" name="idm44761357018864"></a><a class="indexterm" name="idm44761357017456"></a><a class="indexterm" name="idm44761357016064"></a><p>
    <code class="literal">InnoDB</code> では、<a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペース、<a class="link" href="glossary.html#glos_general_tablespace" title="一般テーブルスペース">general</a> テーブルスペース、<code class="literal">mysql</code> システムテーブルスペース、redo ログおよび undo ログの保存データ暗号化がサポートされています。
  </p><p>
    MySQL 8.0.16 では、スキーマおよび一般テーブルスペースの暗号化デフォルトの設定もサポートされているため、DBA はこれらのスキーマおよびテーブルスペースで作成されたテーブルを暗号化するかどうかを制御できます。
  </p><p>
    <code class="literal">InnoDB</code> の保存データ暗号化の機能については、このセクションの次のトピックで説明します。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-about" title="保存データの暗号化について">保存データの暗号化について</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-encryption-prerequisites" title="暗号化の前提条件">暗号化の前提条件</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-schema-tablespace-encryption-default" title="スキーマおよび一般テーブルスペースの暗号化デフォルトの定義">スキーマおよび一般テーブルスペースの暗号化デフォルトの定義</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-enabling-disabling" title="テーブルごとのファイルテーブルスペースの暗号化">テーブルごとのファイルテーブルスペースの暗号化</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-general-tablespace-encryption-enabling-disabling" title="一般的なテーブルスペース暗号化">一般的なテーブルスペース暗号化</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-doublewrite-file-encryption" title="二重書込みファイル暗号化">二重書込みファイル暗号化</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-mysql-tablespace-encryption-enabling-disabling" title="mysql システムテーブルスペースの暗号化">mysql システムテーブルスペースの暗号化</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-redo-log" title="redo ログの暗号化">redo ログの暗号化</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-undo-log" title="undo ログの暗号化">undo ログの暗号化</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-master-key-rotation" title="マスターキーのローテーション">マスターキーのローテーション</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-recovery" title="暗号化とリカバリ">暗号化とリカバリ</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-exporting" title="暗号化されたテーブルスペースのエクスポート">暗号化されたテーブルスペースのエクスポート</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-replication" title="暗号化とレプリケーション">暗号化とレプリケーション</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-identifying" title="暗号化されたテーブルスペースおよびスキーマの識別">暗号化されたテーブルスペースおよびスキーマの識別</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-progress-monitoring" title="暗号化の進行状況の監視">暗号化の進行状況の監視</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-usage-notes" title="暗号化の使用上のノート">暗号化の使用上のノート</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-limitations" title="暗号化の制限事項">暗号化の制限事項</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-data-encryption-about"></a>保存データの暗号化について</h3></div></div></div><p>
      <code class="literal">InnoDB</code> では、マスター暗号化キーとテーブルスペースキーで構成される 2 層暗号化キーアーキテクチャを使用します。 テーブルスペースが暗号化されると、テーブルスペースキーが暗号化され、テーブルスペースヘッダーに格納されます。 アプリケーションまたは認証済ユーザーが暗号化されたテーブルスペースデータにアクセスする場合、<code class="literal">InnoDB</code> はマスター暗号化キーを使用してテーブルスペースキーを復号化します。 復号化されたバージョンのテーブルスペースキーは変更されませんが、必要に応じてマスター暗号化キーを変更できます。 このアクションは<span class="emphasis"><em>マスターキーのローテーション</em></span>と呼ばれます。 
    </p><p>
      保存データ暗号化機能は、マスター暗号化キー管理のためにキーリングプラグインに依存します。
    </p><p>
      すべての MySQL エディションには、サーバーホストに対してローカルなファイルにキーリングデータを格納する <code class="literal">keyring_file</code> プラグインが用意されています。
    </p><p>
      MySQL Enterprise Edition には、追加のキーリングプラグインが用意されています:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">keyring_encrypted_file</code> は、サーバーホストに対してローカルな暗号化されたファイルにキーリングデータを格納します。
        </p></li><li class="listitem"><p>
          <code class="literal">keyring_okv</code> には、KMIP 互換製品を鍵リングストレージのバックエンドとして使用する KMIP クライアント (KMIP 1.1) が含まれています。 サポートされている KMIP 互換製品には、Oracle Key Vault、Gemalto KeySecure、Thales Vormetric キー管理サーバー、Fornetix Key Orchestration などの一元化された鍵管理ソリューションが含まれます。 
        </p></li><li class="listitem"><p>
          <code class="literal">keyring_aws</code> は、キー生成のバックエンドとして Amazon Web Services Key Management Service (AWS KMS) と通信し、キーの格納にローカルファイルを使用します。
        </p></li><li class="listitem"><p>
          <code class="literal">keyring_hashicorp</code> は、バックエンドストレージのために HashiCorp Vault と通信します。
        </p></li></ul></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
        <code class="literal">keyring_file</code> および <code class="literal">keyring_encrypted file</code> プラグインは、規制コンプライアンスソリューションとしては意図されていません。 PCI、FIPS などのセキュリティ標準では、キーボールトまたはハードウェアセキュリティモジュール (HSM) 内の暗号化キーを保護、管理および保護するためにキー管理システムを使用する必要があります。 
      </p></div><p>
      セキュアで堅牢な暗号化キー管理ソリューションは、セキュリティおよび様々なセキュリティ標準への準拠に不可欠です。 保存データ暗号化機能で一元化されたキー管理ソリューションを使用する場合、この機能は <span class="quote">「<span class="quote">MySQL Enterprise Transparent Data Encryption (TDE)</span>」</span> と呼ばれます。 
    </p><p>
      保存データ暗号化機能は、Advanced Encryption Standard (AES) ブロックベースの暗号化アルゴリズムをサポートしています。 テーブルスペースキー暗号化には電子コードブック (ECB) ブロック暗号化モードを使用し、データ暗号化には暗号ブロックチェーン (CBC) ブロック暗号化モードを使用します。 
    </p><p>
      保存データ暗号化機能に関するよくある質問については、<a class="xref" href="faqs.html#faqs-tablespace-encryption" title="A.17 MySQL 8.0 FAQ : InnoDB 保存データ暗号化">セクションA.17「MySQL 8.0 FAQ : InnoDB 保存データ暗号化」</a> を参照してください。
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-data-encryption-encryption-prerequisites"></a>暗号化の前提条件</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          キーリングプラグインをインストールして構成する必要があります。 キーリングプラグインのインストールは、起動時に <code class="option">early-plugin-load</code> オプションを使用して実行されます。 早期ロードにより、<code class="literal">InnoDB</code> ストレージエンジンを初期化する前にプラグインが使用可能になります。 プラグインのインストールと構成の手順については、<a class="xref" href="security.html#keyring" title="6.4.4 MySQL キーリング">セクション6.4.4「MySQL キーリング」</a> を参照してください。 
        </p><p>
          一度に有効にできるキーリングプラグインは 1 つだけです。 複数のキーリングプラグインの有効化はサポートされていません。 
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
            暗号化されたテーブルスペースが MySQL インスタンスで作成されたら、暗号化されたテーブルスペースの作成時にロードされたキーリングプラグインは、<code class="option">early-plugin-load</code> オプションを使用して起動時に引き続きロードされる必要があります。 そうしないと、サーバーの起動時および <code class="literal">InnoDB</code> のリカバリ時にエラーが発生します。 
          </p></div><p>
          キーリングプラグインがアクティブであることを確認するには、<code class="literal">SHOW PLUGINS</code> ステートメントを使用するか、<code class="literal">INFORMATION_SCHEMA.PLUGINS</code> テーブルをクエリーします。 例: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT PLUGIN_NAME, PLUGIN_STATUS</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PLUGINS</code></strong>
       <strong class="userinput"><code>WHERE PLUGIN_NAME LIKE 'keyring%';</code></strong>
+--------------+---------------+
| PLUGIN_NAME  | PLUGIN_STATUS |
+--------------+---------------+
| keyring_file | ACTIVE        |
+--------------+---------------+
</pre></li><li class="listitem"><p>
          本番データを暗号化する場合は、マスター暗号化キーが失われないようにするステップを実行してください。 <span class="emphasis"><em>マスター暗号化キーが失われた場合、暗号化されたテーブルスペースファイルに格納されているデータはリカバリできません。</em></span> <code class="literal">keyring_file</code> または <code class="literal">keyring_encrypted_file</code> プラグインを使用する場合は、最初の暗号化されたテーブルスペースの作成直後、マスターキーのローテーションの前、およびマスターキーのローテーションの後に、キーリングデータファイルのバックアップを作成します。 <code class="literal">keyring_file_data</code> 構成オプションは、<code class="literal">keyring_file</code> プラグインのキーリングデータファイルの場所を定義します。 <code class="literal">keyring_encrypted_file_data</code> 構成オプションは、<code class="literal">keyring_encrypted_file</code> プラグインのキーリングデータファイルの場所を定義します。 <code class="literal">keyring_okv</code> または <code class="literal">keyring_aws</code> プラグインを使用する場合は、必要な構成が実行されていることを確認します。 その手順は、<a class="xref" href="security.html#keyring" title="6.4.4 MySQL キーリング">セクション6.4.4「MySQL キーリング」</a>を参照してください。 
        </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-schema-tablespace-encryption-default"></a>スキーマおよび一般テーブルスペースの暗号化デフォルトの定義</h3></div></div></div><a class="indexterm" name="idm44761356941632"></a><p>
      MySQL 8.0.16 では、<code class="literal">default_table_encryption</code> システム変数によってスキーマおよび一般テーブルスペースのデフォルトの暗号化設定が定義されます。 <code class="literal">ENCRYPTION</code> 句が明示的に指定されていない場合、<code class="literal">CREATE TABLESPACE</code> および <code class="literal">CREATE SCHEMA</code> 操作によって <code class="literal">default_table_encryption</code> 設定が適用されます。 
    </p><p>
      <code class="literal">ALTER SCHEMA</code> および <code class="literal">ALTER TABLESPACE</code> の操作では、<code class="literal">default_table_encryption</code> 設定は適用されません。 既存のスキーマまたは一般テーブルスペースの暗号化を変更するには、<code class="literal">ENCRYPTION</code> 句を明示的に指定する必要があります。 
    </p><p>
      <code class="literal">default_table_encryption</code> 変数は、個々のクライアント接続に対して設定することも、<code class="literal">SET</code> 構文を使用してグローバルに設定することもできます。 たとえば、次のステートメントは、デフォルトのスキーマおよびテーブルスペースの暗号化をグローバルに有効にします: 
    </p><pre class="programlisting">mysql&gt; SET GLOBAL default_table_encryption=ON;
</pre><p>
      スキーマのデフォルトの暗号化設定は、次の例に示すように、スキーマの作成または変更時に <code class="literal">DEFAULT ENCRYPTION</code> 句を使用して定義することもできます:
    </p><pre class="programlisting">mysql&gt; CREATE SCHEMA test DEFAULT ENCRYPTION = 'Y';
</pre><p>
      スキーマの作成時に <code class="literal">DEFAULT ENCRYPTION</code> 句が指定されていない場合、<code class="literal">default_table_encryption</code> 設定が適用されます。 既存のスキーマのデフォルト暗号化を変更するには、<code class="literal">DEFAULT ENCRYPTION</code> 句を指定する必要があります。 それ以外の場合、スキーマは現在の暗号化設定を保持します。 
    </p><p>
      デフォルトでは、テーブルは作成されたスキーマまたは一般テーブルスペースの暗号化設定を継承します。 たとえば、暗号化対応スキーマで作成されたテーブルは、デフォルトで暗号化されます。 この動作により、DBA は、スキーマおよび一般的なテーブルスペース暗号化のデフォルトを定義して強制することで、テーブル暗号化の使用を制御できます。 
    </p><p>
      暗号化のデフォルトは、<code class="literal">table_encryption_privilege_check</code> システム変数を有効にすることで適用されます。 <code class="literal">table_encryption_privilege_check</code> が有効な場合、<code class="literal">default_table_encryption</code> 設定とは異なる暗号化設定を使用してスキーマまたは一般テーブルスペースを作成または変更するとき、またはデフォルトのスキーマ暗号化とは異なる暗号化設定を使用してテーブルを作成または変更するときに、権限チェックが発生します。 <code class="literal">table_encryption_privilege_check</code> が無効 (デフォルト) の場合、権限チェックは実行されず、前述の操作は警告付きで続行できます。 
    </p><p>
      <code class="literal">table_encryption_privilege_check</code> が有効な場合、デフォルトの暗号化設定をオーバーライドするには、<code class="literal">TABLE_ENCRYPTION_ADMIN</code> 権限が必要です。 DBA は、この権限を付与して、スキーマまたは一般テーブルスペースの作成または変更時にユーザーが <code class="literal">default_table_encryption</code> 設定から逸脱したり、テーブルの作成または変更時にデフォルトのスキーマ暗号化から逸脱できるようにすることができます。 この権限では、テーブルの作成または変更時に一般テーブルスペースの暗号化から逸脱することはできません。 テーブルの暗号化設定は、テーブルが存在する一般テーブルスペースと同じである必要があります。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-data-encryption-enabling-disabling"></a>テーブルごとのファイルテーブルスペースの暗号化</h3></div></div></div><p>
      MySQL 8.0.16 の時点では、file-per-table テーブルスペースは、<code class="literal">CREATE TABLE</code> ステートメントで <code class="literal">ENCRYPTION</code> 句が明示的に指定されていないかぎり、テーブルが作成されるスキーマのデフォルトの暗号化を継承します。 MySQL 8.0.16 より前は、暗号化を有効にするために <code class="literal">ENCRYPTION</code> 句を指定する必要があります。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT) ENCRYPTION = 'Y';</code></strong>
</pre><p>
      既存の file-per-table テーブルスペースの暗号化を変更するには、<code class="literal">ENCRYPTION</code> 句を指定する必要があります。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 ENCRYPTION = 'Y';</code></strong>
</pre><p>
      MySQL 8.0.16 では、<code class="literal">table_encryption_privilege_check</code> 変数が有効になっている場合、デフォルトのスキーマ暗号化とは異なる設定で <code class="literal">ENCRYPTION</code> 句を指定するには、<code class="literal">TABLE_ENCRYPTION_ADMIN</code> 権限が必要です。 <a class="xref" href="innodb-storage-engine.html#innodb-schema-tablespace-encryption-default" title="スキーマおよび一般テーブルスペースの暗号化デフォルトの定義">スキーマおよび一般テーブルスペースの暗号化デフォルトの定義</a>を参照してください。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-general-tablespace-encryption-enabling-disabling"></a>一般的なテーブルスペース暗号化</h3></div></div></div><p>
      MySQL 8.0.16 では、<code class="literal">CREATE TABLESPACE</code> ステートメントで <code class="literal">ENCRYPTION</code> 句が明示的に指定されていないかぎり、<code class="literal">default_table_encryption</code> 変数によって、新しく作成された一般テーブルスペースの暗号化が決定されます。 MySQL 8.0.16 より前は、暗号化を有効にするために <code class="literal">ENCRYPTION</code> 句を指定する必要があります。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts1` ADD DATAFILE 'ts1.ibd' ENCRYPTION = 'Y' Engine=InnoDB;</code></strong>
</pre><p>
      既存の一般テーブルスペースの暗号化を変更するには、<code class="literal">ENCRYPTION</code> 句を指定する必要があります。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLESPACE ts1 ENCRYPTION = 'Y';</code></strong>
</pre><p>
      MySQL 8.0.16 では、<code class="literal">table_encryption_privilege_check</code> 変数が有効になっている場合、<code class="literal">default_table_encryption</code> 設定とは異なる設定で <code class="literal">ENCRYPTION</code> 句を指定するには <code class="literal">TABLE_ENCRYPTION_ADMIN</code> 権限が必要です。 <a class="xref" href="innodb-storage-engine.html#innodb-schema-tablespace-encryption-default" title="スキーマおよび一般テーブルスペースの暗号化デフォルトの定義">スキーマおよび一般テーブルスペースの暗号化デフォルトの定義</a>を参照してください。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-doublewrite-file-encryption"></a>二重書込みファイル暗号化</h3></div></div></div><p>
      二重書込みファイルの暗号化サポートは、MySQL 8.0.23 の時点で使用できます。 <code class="literal">InnoDB</code> では、暗号化されたテーブルスペースに属する二重書込みファイルページが自動的に暗号化されます。 必要なアクションはありません。 二重書込みファイルページは、関連付けられたテーブルスペースの暗号化キーを使用して暗号化されます。 テーブルスペースデータファイルに書き込まれた同じ暗号化ページも二重書込みファイルに書き込まれます。 暗号化されていないテーブルスペースに属するファイルの二重書込みページは、暗号化されないままです。 
    </p><p>
      リカバリ中、暗号化された二重書込みファイルページは暗号化されず、破損がないかどうかチェックされます。
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-mysql-tablespace-encryption-enabling-disabling"></a>mysql システムテーブルスペースの暗号化</h3></div></div></div><p>
      <code class="literal">mysql</code> システムテーブルスペースの暗号化サポートは、MySQL 8.0.16 の時点で使用できます。
    </p><p>
      <code class="literal">mysql</code> システムテーブルスペースには、<code class="literal">mysql</code> システムデータベースおよび MySQL データディクショナリテーブルが含まれます。 デフォルトでは暗号化されていません。 <code class="literal">mysql</code> システムテーブルスペースの暗号化を有効にするには、<code class="literal">ALTER TABLESPACE</code> ステートメントでテーブルスペース名と <code class="literal">ENCRYPTION</code> オプションを指定します。 
    </p><pre class="programlisting">mysql&gt; ALTER TABLESPACE mysql ENCRYPTION = 'Y';
</pre><p>
      <code class="literal">mysql</code> システムテーブルスペースの暗号化を無効にするには、<code class="literal">ALTER TABLESPACE</code> ステートメントを使用して <code class="literal">ENCRYPTION = 'N'</code>を設定します。
    </p><pre class="programlisting">mysql&gt; ALTER TABLESPACE mysql ENCRYPTION = 'N';
</pre><p>
      <code class="literal">mysql</code> システムテーブルスペースの暗号化を有効または無効にするには、インスタンス内のすべてのテーブル (<code class="literal">CREATE TABLESPACE on *.*)</code>) に対する <code class="literal">CREATE TABLESPACE</code> 権限が必要です。
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-data-encryption-redo-log"></a>redo ログの暗号化</h3></div></div></div><p>
      redo ログデータの暗号化は、<code class="literal">innodb_redo_log_encrypt</code> 構成オプションを使用して有効にします。 redo ログの暗号化はデフォルトで無効になっています。 
    </p><p>
      テーブルスペースデータと同様に、redo ログデータの暗号化は redo ログデータがディスクに書き込まれるときに行われ、復号化は redo ログデータがディスクから読み取られるときに行われます。 redo ログデータがメモリーに読み込まれると、暗号化されていない形式になります。 redo ログデータは、テーブルスペース暗号化キーを使用して暗号化および復号化されます。 
    </p><p>
      <code class="literal">innodb_redo_log_encrypt</code> が有効な場合、ディスクに存在する暗号化されていない redo ログページは暗号化されずに残り、新しい redo ログページは暗号化された形式でディスクに書き込まれます。 同様に、<code class="literal">innodb_redo_log_encrypt</code> が無効な場合、ディスクに存在する暗号化された redo ログページは暗号化されたままになり、新しい redo ログページは暗号化されていない形式でディスクに書き込まれます。 
    </p><p>
      テーブルスペース暗号化キーを含む redo ログ暗号化メタデータは、最初の redo ログファイル (<code class="filename">ib_logfile0</code>) のヘッダーに格納されます。 このファイルを削除すると、redo ログの暗号化は無効になります。 
    </p><p>
      redo ログの暗号化が有効になると、<code class="literal">InnoDB</code> は起動時に redo ページをスキャンできる必要があり、redo ログページが暗号化されている場合はスキャンできないため、キーリングプラグインなしまたは暗号化キーなしで通常の再起動はできません。 キーリングプラグインまたは暗号化鍵がない場合は、redo ログ (<code class="literal">SRV_FORCE_NO_LOG_REDO</code>) を使用しない強制的な起動のみが可能です。 <a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="15.21.2 InnoDB のリカバリの強制的な実行">セクション15.21.2「InnoDB のリカバリの強制的な実行」</a>を参照してください。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-data-encryption-undo-log"></a>undo ログの暗号化</h3></div></div></div><p>
      undo ログデータの暗号化は、<code class="literal">innodb_undo_log_encrypt</code> 構成オプションを使用して有効にします。 undo ログの暗号化は、<a class="link" href="glossary.html#glos_undo_tablespace" title="Undo テーブルスペース">undo tablespaces</a> に存在する undo ログに適用されます。 <a class="xref" href="innodb-storage-engine.html#innodb-undo-tablespaces" title="15.6.3.4 undo テーブルスペース">セクション15.6.3.4「undo テーブルスペース」</a>を参照してください。 undo ログデータの暗号化は、デフォルトで無効になっています。 
    </p><p>
      テーブルスペースデータと同様に、undo ログデータの暗号化は undo ログデータがディスクに書き込まれるときに行われ、復号化は undo ログデータがディスクから読み取られるときに行われます。 undo ログデータがメモリーに読み込まれると、暗号化されていない形式になります。 undo ログデータは、テーブルスペース暗号化キーを使用して暗号化および復号化されます。 
    </p><p>
      <code class="literal">innodb_undo_log_encrypt</code> が有効な場合、ディスクに存在する暗号化されていない undo ログページは暗号化されずに残り、新しい undo ログページは暗号化された形式でディスクに書き込まれます。 同様に、<code class="literal">innodb_undo_log_encrypt</code> が無効になっている場合、ディスクに存在する暗号化された undo ログページは暗号化されたままになり、新しい undo ログページは暗号化されていない形式でディスクに書き込まれます。 
    </p><p>
      undo ログ暗号化メタデータ (テーブルスペース暗号化キーを含む) は、undo ログファイルのヘッダーに格納されます。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        undo ログの暗号化が無効になっている場合、サーバーは、暗号化された undo ログデータを含む undo テーブルスペースが切り捨てられるまで、undo ログデータの暗号化に使用されたキーリングプラグインを引き続き必要とします。 (暗号化ヘッダーは、undo テーブルスペースが切り捨てられた場合にのみ undo テーブルスペースから削除されます。) undo テーブルスペースの切捨ての詳細は、<a class="xref" href="innodb-storage-engine.html#truncate-undo-tablespace" title="undo テーブルスペースの切捨て">undo テーブルスペースの切捨て</a> を参照してください。 
      </p></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-data-encryption-master-key-rotation"></a>マスターキーのローテーション</h3></div></div></div><p>
      マスター暗号化キーは、定期的およびキーが危険にさらされた疑いがある場合は常にローテーションする必要があります。
    </p><p>
      マスターキーローテーションは、アトミックなインスタンスレベルの操作です。 マスター暗号化キーがローテーションされるたびに、MySQL インスタンスのすべてのテーブルスペースキーが再暗号化され、それぞれのテーブルスペースヘッダーに保存されます。 アトミック操作として、ローテーション操作が開始されたら、すべてのテーブルスペースキーに対して再暗号化が成功する必要があります。 サーバー障害によってマスターキーのローテーションが中断された場合、<code class="literal">InnoDB</code> はサーバーの再起動時に操作をロールフォワードします。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-recovery" title="暗号化とリカバリ">暗号化とリカバリ</a>を参照してください。 
    </p><p>
      マスター暗号化キーをローテーションすると、マスター暗号化キーのみが変更され、テーブルスペースキーが再暗号化されます。 関連付けられたテーブルスペースデータは復号化または再暗号化されません。 
    </p><p>
      マスター暗号化キーをローテーションするには、<code class="literal">ENCRYPTION_KEY_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。
    </p><p>
      マスター暗号化キーをローテーションするには、次のコマンドを実行します:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER INSTANCE ROTATE INNODB MASTER KEY;</code></strong>
</pre><p>
      <code class="literal">ALTER INSTANCE ROTATE INNODB MASTER KEY</code> では、同時 DML がサポートされます。 ただし、テーブルスペースの暗号化操作と同時に実行することはできず、同時実行によって発生する可能性のある競合を防ぐためにロックが取得されます。 <code class="literal">ALTER INSTANCE ROTATE INNODB MASTER KEY</code> 操作が実行中の場合は、テーブルスペースの暗号化操作を続行する前に操作を終了する必要があり、その逆も同様です。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-data-encryption-recovery"></a>暗号化とリカバリ</h3></div></div></div><p>
      暗号化操作中にサーバー障害が発生した場合、サーバーの再起動時に操作がロールフォワードされます。 一般的なテーブルスペースの場合、暗号化操作は最後に処理されたページからバックグラウンドスレッドで再開されます。 
    </p><p>
      マスターキーのローテーション中にサーバー障害が発生した場合、<code class="literal">InnoDB</code> はサーバーの再起動時に操作を続行します。
    </p><p>
      <code class="literal">InnoDB</code> の初期化およびリカバリアクティビティがテーブルスペースデータにアクセスする前に、テーブルスペースデータページの復号化に必要な情報をテーブルスペースヘッダーから取得できるように、ストレージエンジンの初期化の前にキープラグインをロードする必要があります。 (<a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-encryption-prerequisites" title="暗号化の前提条件">暗号化の前提条件</a>を参照してください。) 
    </p><p>
      <code class="literal">InnoDB</code> の初期化およびリカバリが開始されると、マスターキーのローテーション操作が再開されます。 サーバー障害のため、一部のテーブルスペースキーは新しいマスター暗号化キーを使用してすでに暗号化されている可能性があります。 <code class="literal">InnoDB</code> は各テーブルスペースヘッダーから暗号化データを読み取り、データが古いマスター暗号化キーを使用してテーブルスペースキーが暗号化されていることを示している場合、<code class="literal">InnoDB</code> はキーリングから古いキーを取得し、それを使用してテーブルスペースキーを復号化します。 次に、<code class="literal">InnoDB</code> は新しいマスター暗号化キーを使用してテーブルスペースキーを再暗号化し、再暗号化されたテーブルスペースキーをテーブルスペースヘッダーに保存します。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-data-encryption-exporting"></a>暗号化されたテーブルスペースのエクスポート</h3></div></div></div><p>
      テーブルスペースのエクスポートは、file-per-table テーブルスペースでのみサポートされます。
    </p><p>
      暗号化されたテーブルスペースがエクスポートされると、<code class="literal">InnoDB</code> によって、テーブルスペースキーの暗号化に使用される<span class="emphasis"><em>転送キー</em></span>が生成されます。 暗号化されたテーブルスペースキーおよび転送キーは、<code class="filename"><em class="replaceable"><code>tablespace_name</code></em>.cfp</code> ファイルに格納されます。 インポート操作を実行するには、このファイルと暗号化されたテーブルスペースファイルが必要です。 インポート時に、<code class="literal">InnoDB</code> は転送キーを使用して <code class="filename"><em class="replaceable"><code>tablespace_name</code></em>.cfp</code> ファイルのテーブルスペースキーを復号化します。 関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-table-import" title="15.6.1.3 InnoDB テーブルのインポート">セクション15.6.1.3「InnoDB テーブルのインポート」</a>を参照してください。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-data-encryption-replication"></a>暗号化とレプリケーション</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">ALTER INSTANCE ROTATE INNODB MASTER KEY</code> ステートメントは、ソースおよびレプリカがテーブルスペースの暗号化をサポートするバージョンの MySQL を実行するレプリケーション環境でのみサポートされます。
        </p></li><li class="listitem"><p>
          成功した <code class="literal">ALTER INSTANCE ROTATE INNODB MASTER KEY</code> ステートメントは、レプリカ上のレプリケーションのためにバイナリログに書き込まれます。
        </p></li><li class="listitem"><p>
          <code class="literal">ALTER INSTANCE ROTATE INNODB MASTER KEY</code> ステートメントが失敗した場合、バイナリログに記録されず、レプリカにレプリケートされません。
        </p></li><li class="listitem"><p>
          キーリングプラグインがソースにインストールされているが、レプリカにはインストールされていない場合、<code class="literal">ALTER INSTANCE ROTATE INNODB MASTER KEY</code> 操作のレプリケーションは失敗します。
        </p></li><li class="listitem"><p>
          <code class="literal">keyring_file</code> または <code class="literal">keyring_encrypted_file</code> プラグインがソースとレプリカの両方にインストールされているが、レプリカにキーリングデータファイルがない場合、レプリケートされた <code class="literal">ALTER INSTANCE ROTATE INNODB MASTER KEY</code> ステートメントは、キーリングファイルデータがメモリーにキャッシュされていないと想定して、レプリカにキーリングデータファイルを作成します。 <code class="literal">ALTER INSTANCE ROTATE INNODB MASTER KEY</code> では、メモリーにキャッシュされているキーリングファイルデータが使用されます (使用可能な場合)。 
        </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-data-encryption-identifying"></a>暗号化されたテーブルスペースおよびスキーマの識別</h3></div></div></div><p>
      MySQL 8.0.13 で導入された <code class="literal">INFORMATION_SCHEMA.INNODB_TABLESPACES</code> テーブルには、暗号化されたテーブルスペースの識別に使用できる <code class="literal">ENCRYPTION</code> カラムが含まれています。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT SPACE, NAME, SPACE_TYPE, ENCRYPTION FROM INFORMATION_SCHEMA.INNODB_TABLESPACES</code></strong>
       <strong class="userinput"><code>WHERE ENCRYPTION='Y'\G</code></strong>
*************************** 1. row ***************************
     SPACE: 4294967294
      NAME: mysql
SPACE_TYPE: General
ENCRYPTION: Y
*************************** 2. row ***************************
     SPACE: 2
      NAME: test/t1
SPACE_TYPE: Single
ENCRYPTION: Y
*************************** 3. row ***************************
     SPACE: 3
      NAME: ts1
SPACE_TYPE: General
ENCRYPTION: Y
</pre><p>
      <code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントで <code class="literal">ENCRYPTION</code> オプションが指定されている場合、<code class="literal">INFORMATION_SCHEMA.TABLES</code> の <code class="literal">CREATE_OPTIONS</code> カラムに記録されます。 このカラムをクエリーすると、暗号化された file-per-table テーブルスペースに存在するテーブルを識別できます。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_SCHEMA, TABLE_NAME, CREATE_OPTIONS FROM INFORMATION_SCHEMA.TABLES</code></strong>
       <strong class="userinput"><code>WHERE CREATE_OPTIONS LIKE '%ENCRYPTION%';</code></strong>
+--------------+------------+----------------+
| TABLE_SCHEMA | TABLE_NAME | CREATE_OPTIONS |
+--------------+------------+----------------+
| test         | t1         | ENCRYPTION="Y" |
+--------------+------------+----------------+
</pre><p>
      <code class="literal">INFORMATION_SCHEMA.INNODB_TABLESPACES</code> をクエリーして、特定のスキーマおよびテーブルに関連付けられているテーブルスペースに関する情報を取得します。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT SPACE, NAME, SPACE_TYPE FROM INFORMATION_SCHEMA.INNODB_TABLESPACES WHERE NAME='test/t1';</code></strong>
+-------+---------+------------+
| SPACE | NAME    | SPACE_TYPE |
+-------+---------+------------+
|     3 | test/t1 | Single     |
+-------+---------+------------+
</pre><p>
      <code class="literal">INFORMATION_SCHEMA.SCHEMATA</code> テーブルをクエリーすることで、暗号化対応のスキーマを識別できます。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT SCHEMA_NAME, DEFAULT_ENCRYPTION FROM INFORMATION_SCHEMA.SCHEMATA</code></strong>
       <strong class="userinput"><code>WHERE DEFAULT_ENCRYPTION='YES';</code></strong>
+-------------+--------------------+
| SCHEMA_NAME | DEFAULT_ENCRYPTION |
+-------------+--------------------+
| test        | YES                |
+-------------+--------------------+
</pre><p>
      <code class="literal">SHOW CREATE SCHEMA</code> には、<code class="literal">DEFAULT ENCRYPTION</code> 句も表示されます。
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-data-encryption-progress-monitoring"></a>暗号化の進行状況の監視</h3></div></div></div><a class="indexterm" name="idm44761356759280"></a><a class="indexterm" name="idm44761356757152"></a><p>
      <a class="link" href="performance-schema.html" title="第 27 章 MySQL パフォーマンススキーマ">Performance Schema</a> を使用して、一般的なテーブルスペースおよび <code class="literal">mysql</code> システムテーブルスペースの暗号化の進行状況を監視できます。
    </p><p>
      <code class="literal">stage/innodb/alter tablespace (encryption)</code> ステージイベントインストゥルメントは、一般的なテーブルスペース暗号化操作に関する <code class="literal">WORK_ESTIMATED</code> および <code class="literal">WORK_COMPLETED</code> の情報をレポートします。
    </p><p>
      次の例は、<code class="literal">stage/innodb/alter tablespace (encryption)</code> ステージイベントインストゥルメントおよび関連するコンシューマテーブルを有効にして、一般的なテーブルスペースまたは <code class="literal">mysql</code> システムテーブルスペースの暗号化の進行状況を監視する方法を示しています。 パフォーマンススキーマステージイベントインストゥルメントおよび関連コンシューマについては、<a class="xref" href="performance-schema.html#performance-schema-stage-tables" title="27.12.5 パフォーマンススキーマステージイベントテーブル">セクション27.12.5「パフォーマンススキーマステージイベントテーブル」</a> を参照してください。 
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          <code class="literal">stage/innodb/alter tablespace (encryption)</code> インストゥルメントを有効にします:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>USE performance_schema;</code></strong>
mysql&gt; <strong class="userinput"><code>UPDATE setup_instruments SET ENABLED = 'YES'</code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE 'stage/innodb/alter tablespace (encryption)';</code></strong>
</pre></li><li class="listitem"><p>
          ステージイベントコンシューマテーブル (<code class="literal">events_stages_current</code>、<code class="literal">events_stages_history</code> および <code class="literal">events_stages_history_long</code> を含む) を有効にします。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE setup_consumers SET ENABLED = 'YES' WHERE NAME LIKE '%stages%';</code></strong>
</pre></li><li class="listitem"><p>
          テーブルスペース暗号化操作を実行します。 この例では、<code class="literal">ts1</code> という一般的なテーブルスペースが暗号化されます。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLESPACE ts1 ENCRYPTION = 'Y';</code></strong>
</pre></li><li class="listitem"><p>
          パフォーマンススキーマ <code class="literal">events_stages_current</code> テーブルをクエリーして、暗号化操作の進行状況を確認します。 <code class="literal">WORK_ESTIMATED</code> では、テーブルスペース内のページの合計数がレポートされます。 <code class="literal">WORK_COMPLETED</code> では、処理されたページ数がレポートされます。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT EVENT_NAME, WORK_ESTIMATED, WORK_COMPLETED FROM events_stages_current;</code></strong>
+--------------------------------------------+----------------+----------------+
| EVENT_NAME                                 | WORK_COMPLETED | WORK_ESTIMATED |
+--------------------------------------------+----------------+----------------+
| stage/innodb/alter tablespace (encryption) |           1056 |           1407 |
+--------------------------------------------+----------------+----------------+
</pre><p>
          暗号化操作が完了すると、<code class="literal">events_stages_current</code> テーブルは空のセットを返します。 この場合、<code class="literal">events_stages_history</code> テーブルをチェックして、完了した操作のイベントデータを表示できます。 例: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT EVENT_NAME, WORK_COMPLETED, WORK_ESTIMATED FROM events_stages_history;</code></strong>
+--------------------------------------------+----------------+----------------+
| EVENT_NAME                                 | WORK_COMPLETED | WORK_ESTIMATED |
+--------------------------------------------+----------------+----------------+
| stage/innodb/alter tablespace (encryption) |           1407 |           1407 |
+--------------------------------------------+----------------+----------------+
</pre></li></ol></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-data-encryption-usage-notes"></a>暗号化の使用上のノート</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">ENCRYPTION</code> オプションを使用して既存の file-per-table テーブルスペースを変更する場合は、適切に計画します。 file-per-table テーブルスペースに存在するテーブルは、<code class="literal">COPY</code> アルゴリズムを使用して再構築されます。 <code class="literal">INPLACE</code> アルゴリズムは、一般テーブルスペースまたは <code class="literal">mysql</code> システムテーブルスペースの <code class="literal">ENCRYPTION</code> 属性を変更するときに使用されます。 <code class="literal">INPLACE</code> アルゴリズムでは、一般テーブルスペースに存在するテーブルに対する同時 DML が許可されます。 同時 DDL はブロックされます。 
        </p></li><li class="listitem"><p>
          一般テーブルスペースまたは <code class="literal">mysql</code> システムテーブルスペースが暗号化されると、テーブルスペースに存在するすべてのテーブルが暗号化されます。 同様に、暗号化されたテーブルスペースに作成されたテーブルも暗号化されます。 
        </p></li><li class="listitem"><p>
          通常の操作中にサーバーが終了または停止した場合は、以前に構成したものと同じ暗号化設定を使用してサーバーを再起動することをお薦めします。
        </p></li><li class="listitem"><p>
          最初のマスター暗号化キーは、最初の新規または既存のテーブルスペースが暗号化されるときに生成されます。
        </p></li><li class="listitem"><p>
          マスターキーローテーションでは、テーブルスペースキーは再暗号化されますが、テーブルスペースキー自体は変更されません。 テーブルスペースキーを変更するには、暗号化を無効にして再度有効にする必要があります。 file-per-table テーブルスペースの場合、テーブルスペースの再暗号化はテーブルを再構築する <code class="literal">ALGORITHM=COPY</code> 操作です。 一般テーブルスペースおよび <code class="literal">mysql</code> システムテーブルスペースの場合、これは <code class="literal">ALGORITHM=INPLACE</code> 操作であり、テーブルスペースに存在するテーブルを再構築する必要はありません。 
        </p></li><li class="listitem"><p>
          <code class="literal">COMPRESSION</code> オプションと <code class="literal">ENCRYPTION</code> オプションの両方を使用してテーブルが作成された場合、圧縮はテーブルスペースデータが暗号化される前に実行されます。
        </p></li><li class="listitem"><p>
          キーリングデータファイル (<code class="literal">keyring_file_data</code> または <code class="literal">keyring_encrypted_file_data</code> で指定されたファイル) が空であるか欠落している場合、<code class="literal">ALTER INSTANCE ROTATE INNODB MASTER KEY</code> の最初の実行でマスター暗号化キーが作成されます。
        </p></li><li class="listitem"><p>
          <code class="literal">keyring_file</code> または <code class="literal">keyring_encrypted_file</code> プラグインをアンインストールしても、既存のキーリングデータファイルは削除されません。
        </p></li><li class="listitem"><p>
          キーリングデータファイルは、テーブルスペースデータファイルと同じディレクトリに配置しないことをお薦めします。
        </p></li><li class="listitem"><p>
          実行時またはサーバーの再起動時に <code class="literal">keyring_file_data</code> または <code class="literal">keyring_encrypted_file_data</code> の設定を変更すると、以前に暗号化されたテーブルスペースにアクセスできなくなり、データが失われる可能性があります。
        </p></li><li class="listitem"><p>
          暗号化は、<code class="literal">FULLTEXT</code> インデックスの追加時に暗黙的に作成される <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> インデックステーブルでサポートされますが、暗号化された一般テーブルスペースに存在するテーブルに <code class="literal">FULLTEXT</code> インデックスが作成される場合にのみサポートされます。 この場合、<code class="literal">FULLTEXT</code> インデックステーブルは、同じ暗号化された一般テーブルスペースに作成されます。 関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index-tables" title="InnoDB 全文インデックステーブル">InnoDB 全文インデックステーブル</a>を参照してください。 
        </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-data-encryption-limitations"></a>暗号化の制限事項</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          Advanced Encryption Standard (AES) は、サポートされる唯一の暗号化アルゴリズムです。 <code class="literal">InnoDB</code> テーブルスペース暗号化では、テーブルスペースキー暗号化に電子コードブック (ECB) ブロック暗号化モードを使用し、データ暗号化に暗号ブロックチェーン (CBC) ブロック暗号化モードを使用します。 パディングは CBC ブロック暗号化モードでは使用されません。 かわりに、<code class="literal">InnoDB</code> は暗号化されるテキストがブロックサイズの倍数であることを確認します。 
        </p></li><li class="listitem"><p>
          暗号化は、<a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペース、<a class="link" href="glossary.html#glos_general_tablespace" title="一般テーブルスペース">general</a> テーブルスペースおよび <code class="literal">mysql</code> システムテーブルスペースでのみサポートされます。 一般テーブルスペースの暗号化サポートは、MySQL 8.0.13 で導入されました。 <code class="literal">mysql</code> システムテーブルスペースの暗号化サポートは、MySQL 8.0.16 の時点で使用できます。 暗号化は、<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">system tablespace</a> を含む他のテーブルスペースタイプではサポートされていません。 
        </p></li><li class="listitem"><p>
          暗号化された <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペース、<a class="link" href="glossary.html#glos_general_tablespace" title="一般テーブルスペース">general</a> テーブルスペースまたは <code class="literal">mysql</code> システムテーブルスペースから、暗号化をサポートしないテーブルスペースタイプにテーブルを移動またはコピーすることはできません。
        </p></li><li class="listitem"><p>
          暗号化されたテーブルスペースから暗号化されていないテーブルスペースにテーブルを移動またはコピーすることはできません。 ただし、暗号化されていないテーブルスペースから暗号化されたテーブルスペースへのテーブルの移動は許可されています。 たとえば、暗号化されていない <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> または <a class="link" href="glossary.html#glos_general_tablespace" title="一般テーブルスペース">general</a> テーブルスペースから暗号化された一般テーブルスペースにテーブルを移動またはコピーできます。 
        </p></li><li class="listitem"><p>
          デフォルトでは、テーブルスペースの暗号化はテーブルスペースのデータにのみ適用されます。 redo ログおよび undo ログデータは、<code class="literal">innodb_redo_log_encrypt</code> および <code class="literal">innodb_undo_log_encrypt</code> を有効にすることで暗号化できます。 <a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-redo-log" title="redo ログの暗号化">redo ログの暗号化</a>および<a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-undo-log" title="undo ログの暗号化">undo ログの暗号化</a>を参照してください。 バイナリログファイルとリレーログファイルの暗号化については、<a class="xref" href="replication.html#replication-binlog-encryption" title="17.3.2 バイナリログファイルとリレーログファイルの暗号化">セクション17.3.2「バイナリログファイルとリレーログファイルの暗号化」</a> を参照してください。 
        </p></li><li class="listitem"><p>
          暗号化されたテーブルスペースに存在する、または以前に存在していたテーブルのストレージエンジンを変更することはできません。
        </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-parameters"></a>15.14 InnoDB の起動オプションおよびシステム変数</h2></div></div></div><a class="indexterm" name="idm44761356658416"></a><a class="indexterm" name="idm44761356656336"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          true または false であるシステム変数は、サーバー起動時に変数の名前を指定することで有効にすることができ、<code class="literal">--skip-</code> プリフィクスを使用することで無効にすることができます。 たとえば、<code class="literal">InnoDB</code> 適応ハッシュインデックスを有効または無効にするには、コマンドラインで <code class="option">--innodb-adaptive-hash-index</code> または <code class="option">--skip-innodb-adaptive-hash-index</code> を使用するか、オプションファイルで <code class="literal">innodb_adaptive_hash_index</code> または <code class="literal">skip_innodb_adaptive_hash_index</code> を使用します。 
        </p></li><li class="listitem"><p>
          数値が指定されるシステム変数は、コマンド行で <code class="option">--<em class="replaceable"><code>var_name</code></em>=<em class="replaceable"><code>value</code></em></code> として指定するか、オプションファイルで <code class="literal"><em class="replaceable"><code>var_name</code></em>=<em class="replaceable"><code>value</code></em></code> として指定できます。
        </p></li><li class="listitem"><p>
          多くのシステム変数は、実行時に変更できます (<a class="xref" href="server-administration.html#dynamic-system-variables" title="5.1.9.2 動的システム変数">セクション5.1.9.2「動的システム変数」</a>を参照してください)。
        </p></li><li class="listitem"><p>
          <code class="literal">GLOBAL</code> および <code class="literal">SESSION</code> 変数スコープ修飾子については、<code class="literal">SET</code> ステートメントのドキュメントを参照してください。
        </p></li><li class="listitem"><p>
          特定のオプションでは、<code class="literal">InnoDB</code> データファイルの場所およびレイアウトが制御されます。<a class="xref" href="innodb-storage-engine.html#innodb-init-startup-configuration" title="15.8.1 InnoDB の起動構成">セクション15.8.1「InnoDB の起動構成」</a>では、これらのオプションを使用する方法について説明します。
        </p></li><li class="listitem"><p>
          初期段階では使用しないような一部のオプションは、マシンの処理能力やデータベースの<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>に基づいて、<code class="literal">InnoDB</code> のパフォーマンス特性を調整する際に役立ちます。
        </p></li><li class="listitem"><p>
          オプションおよびシステム変数の指定に関する詳細は、<a class="xref" href="programs.html#program-options" title="4.2.2 プログラムオプションの指定">セクション4.2.2「プログラムオプションの指定」</a>を参照してください。
        </p></li></ul></div><div class="table"><a name="idm44761356631456"></a><p class="title"><b>表 15.24 「InnoDB オプションおよび変数リファレンス」</b></p><div class="table-contents"><table frame="box" rules="all" summary="「InnoDB コマンドラインオプションおよびシステム変数のリファレンス。」"><col style="width: 20%"><col style="width: 15%"><col style="width: 15%"><col style="width: 15%"><col style="width: 15%"><col style="width: 15%"><col style="width: 15%"><thead><tr><th scope="col">名前</th>
<th scope="col">コマンド行</th>
<th scope="col">オプションファイル</th>
<th scope="col">システム変数</th>
<th scope="col">ステータス変数</th>
<th scope="col">変数スコープ</th>
<th scope="col">動的</th>
</tr></thead><tbody><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_enable_binlog">daemon_memcached_enable_binlog</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_engine_lib_name">daemon_memcached_engine_lib_name</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_engine_lib_path">daemon_memcached_engine_lib_path</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_option">daemon_memcached_option</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_r_batch_size">daemon_memcached_r_batch_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_w_batch_size">daemon_memcached_w_batch_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#sysvar_foreign_key_checks">foreign_key_checks</a></th>
<td></td>
<td></td>
<td>はい</td>
<td></td>
<td>両方</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#option_mysqld_innodb">innodb</a></th>
<td>はい</td>
<td>はい</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_flushing">innodb_adaptive_flushing</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_flushing_lwm">innodb_adaptive_flushing_lwm</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_hash_index">innodb_adaptive_hash_index</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_hash_index_parts">innodb_adaptive_hash_index_parts</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_max_sleep_delay">innodb_adaptive_max_sleep_delay</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_bk_commit_interval">innodb_api_bk_commit_interval</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_disable_rowlock">innodb_api_disable_rowlock</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_enable_binlog">innodb_api_enable_binlog</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_enable_mdl">innodb_api_enable_mdl</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_trx_level">innodb_api_trx_level</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoextend_increment">innodb_autoextend_increment</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode">innodb_autoinc_lock_mode</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_background_drop_list_empty">innodb_background_drop_list_empty</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_bytes_data">Innodb_buffer_pool_bytes_data</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_bytes_dirty">Innodb_buffer_pool_bytes_dirty</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size">innodb_buffer_pool_chunk_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_debug">innodb_buffer_pool_debug</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_at_shutdown">innodb_buffer_pool_dump_at_shutdown</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_now">innodb_buffer_pool_dump_now</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_pct">innodb_buffer_pool_dump_pct</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_dump_status">Innodb_buffer_pool_dump_status</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_filename">innodb_buffer_pool_filename</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_in_core_file">innodb_buffer_pool_in_core_file</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances">innodb_buffer_pool_instances</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_abort">innodb_buffer_pool_load_abort</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_at_startup">innodb_buffer_pool_load_at_startup</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_now">innodb_buffer_pool_load_now</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_load_status">Innodb_buffer_pool_load_status</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_pages_data">Innodb_buffer_pool_pages_data</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_pages_dirty">Innodb_buffer_pool_pages_dirty</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_pages_flushed">Innodb_buffer_pool_pages_flushed</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_pages_free">Innodb_buffer_pool_pages_free</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_pages_latched">Innodb_buffer_pool_pages_latched</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_pages_misc">Innodb_buffer_pool_pages_misc</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_pages_total">Innodb_buffer_pool_pages_total</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_read_ahead">Innodb_buffer_pool_read_ahead</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_read_ahead_evicted">Innodb_buffer_pool_read_ahead_evicted</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_read_ahead_rnd">Innodb_buffer_pool_read_ahead_rnd</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_read_requests">Innodb_buffer_pool_read_requests</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_reads">Innodb_buffer_pool_reads</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_resize_status">Innodb_buffer_pool_resize_status</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size">innodb_buffer_pool_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_wait_free">Innodb_buffer_pool_wait_free</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_write_requests">Innodb_buffer_pool_write_requests</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffer_max_size">innodb_change_buffer_max_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffering">innodb_change_buffering</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffering_debug">innodb_change_buffering_debug</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_checkpoint_disabled">innodb_checkpoint_disabled</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_checksum_algorithm">innodb_checksum_algorithm</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_cmp_per_index_enabled">innodb_cmp_per_index_enabled</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_commit_concurrency">innodb_commit_concurrency</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_compress_debug">innodb_compress_debug</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_failure_threshold_pct">innodb_compression_failure_threshold_pct</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_level">innodb_compression_level</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_pad_pct_max">innodb_compression_pad_pct_max</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_concurrency_tickets">innodb_concurrency_tickets</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path">innodb_data_file_path</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_fsyncs">Innodb_data_fsyncs</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir">innodb_data_home_dir</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_pending_fsyncs">Innodb_data_pending_fsyncs</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_pending_reads">Innodb_data_pending_reads</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_pending_writes">Innodb_data_pending_writes</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_read">Innodb_data_read</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_reads">Innodb_data_reads</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_writes">Innodb_data_writes</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_written">Innodb_data_written</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_dblwr_pages_written">Innodb_dblwr_pages_written</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_dblwr_writes">Innodb_dblwr_writes</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ddl_log_crash_reset_debug">innodb_ddl_log_crash_reset_debug</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_deadlock_detect">innodb_deadlock_detect</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_dedicated_server">innodb_dedicated_server</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_default_row_format">innodb_default_row_format</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_directories">innodb_directories</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_disable_sort_file_cache">innodb_disable_sort_file_cache</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_doublewrite">innodb_doublewrite</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_doublewrite_batch_size">innodb_doublewrite_batch_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_doublewrite_dir">innodb_doublewrite_dir</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_doublewrite_files">innodb_doublewrite_files</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_doublewrite_pages">innodb_doublewrite_pages</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_fast_shutdown">innodb_fast_shutdown</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_fil_make_page_dirty_debug">innodb_fil_make_page_dirty_debug</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table">innodb_file_per_table</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_fill_factor">innodb_fill_factor</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_timeout">innodb_flush_log_at_timeout</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_trx_commit">innodb_flush_log_at_trx_commit</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_method">innodb_flush_method</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_neighbors">innodb_flush_neighbors</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_sync">innodb_flush_sync</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flushing_avg_loops">innodb_flushing_avg_loops</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_load_corrupted">innodb_force_load_corrupted</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery">innodb_force_recovery</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_fsync_threshold">innodb_fsync_threshold</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_aux_table">innodb_ft_aux_table</a></th>
<td></td>
<td></td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_cache_size">innodb_ft_cache_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_enable_diag_print">innodb_ft_enable_diag_print</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_enable_stopword">innodb_ft_enable_stopword</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>両方</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_max_token_size">innodb_ft_max_token_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_min_token_size">innodb_ft_min_token_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_num_word_optimize">innodb_ft_num_word_optimize</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_result_cache_limit">innodb_ft_result_cache_limit</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_server_stopword_table">innodb_ft_server_stopword_table</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_sort_pll_degree">innodb_ft_sort_pll_degree</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_total_cache_size">innodb_ft_total_cache_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_user_stopword_table">innodb_ft_user_stopword_table</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>両方</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_have_atomic_builtins">Innodb_have_atomic_builtins</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_idle_flush_pct">innodb_idle_flush_pct</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity">innodb_io_capacity</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity_max">innodb_io_capacity_max</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_limit_optimistic_insert_debug">innodb_limit_optimistic_insert_debug</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_lock_wait_timeout">innodb_lock_wait_timeout</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>両方</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_buffer_size">innodb_log_buffer_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>異なる</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_checkpoint_fuzzy_now">innodb_log_checkpoint_fuzzy_now</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_checkpoint_now">innodb_log_checkpoint_now</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_checksums">innodb_log_checksums</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_compressed_pages">innodb_log_compressed_pages</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_file_size">innodb_log_file_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_files_in_group">innodb_log_files_in_group</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_group_home_dir">innodb_log_group_home_dir</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_spin_cpu_abs_lwm">innodb_log_spin_cpu_abs_lwm</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_spin_cpu_pct_hwm">innodb_log_spin_cpu_pct_hwm</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_wait_for_flush_spin_hwm">innodb_log_wait_for_flush_spin_hwm</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_log_waits">Innodb_log_waits</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_write_ahead_size">innodb_log_write_ahead_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_log_write_requests">Innodb_log_write_requests</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_writer_threads">innodb_log_writer_threads</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_log_writes">Innodb_log_writes</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_lru_scan_depth">innodb_lru_scan_depth</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_dirty_pages_pct">innodb_max_dirty_pages_pct</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_dirty_pages_pct_lwm">innodb_max_dirty_pages_pct_lwm</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag">innodb_max_purge_lag</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag_delay">innodb_max_purge_lag_delay</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_undo_log_size">innodb_max_undo_log_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_merge_threshold_set_all_debug">innodb_merge_threshold_set_all_debug</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_disable">innodb_monitor_disable</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_enable">innodb_monitor_enable</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_reset">innodb_monitor_reset</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_reset_all">innodb_monitor_reset_all</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_num_open_files">Innodb_num_open_files</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_numa_interleave">innodb_numa_interleave</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_pct">innodb_old_blocks_pct</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_time">innodb_old_blocks_time</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_online_alter_log_max_size">innodb_online_alter_log_max_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_open_files">innodb_open_files</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_optimize_fulltext_only">innodb_optimize_fulltext_only</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_os_log_fsyncs">Innodb_os_log_fsyncs</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_os_log_pending_fsyncs">Innodb_os_log_pending_fsyncs</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_os_log_pending_writes">Innodb_os_log_pending_writes</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_os_log_written">Innodb_os_log_written</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_cleaners">innodb_page_cleaners</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_page_size">Innodb_page_size</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size">innodb_page_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_pages_created">Innodb_pages_created</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_pages_read">Innodb_pages_read</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_pages_written">Innodb_pages_written</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_parallel_read_threads">innodb_parallel_read_threads</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>セッション</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_print_all_deadlocks">innodb_print_all_deadlocks</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_print_ddl_logs">innodb_print_ddl_logs</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_batch_size">innodb_purge_batch_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_rseg_truncate_frequency">innodb_purge_rseg_truncate_frequency</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_threads">innodb_purge_threads</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_random_read_ahead">innodb_random_read_ahead</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_ahead_threshold">innodb_read_ahead_threshold</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_io_threads">innodb_read_io_threads</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_only">innodb_read_only</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_redo_log_archive_dirs">innodb_redo_log_archive_dirs</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_redo_log_enabled">Innodb_redo_log_enabled</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_redo_log_encrypt">innodb_redo_log_encrypt</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_replication_delay">innodb_replication_delay</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_on_timeout">innodb_rollback_on_timeout</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments">innodb_rollback_segments</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_row_lock_current_waits">Innodb_row_lock_current_waits</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_row_lock_time">Innodb_row_lock_time</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_row_lock_time_avg">Innodb_row_lock_time_avg</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_row_lock_time_max">Innodb_row_lock_time_max</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_row_lock_waits">Innodb_row_lock_waits</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_rows_deleted">Innodb_rows_deleted</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_rows_inserted">Innodb_rows_inserted</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_rows_read">Innodb_rows_read</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_rows_updated">Innodb_rows_updated</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_saved_page_number_debug">innodb_saved_page_number_debug</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_sort_buffer_size">innodb_sort_buffer_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_spin_wait_delay">innodb_spin_wait_delay</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_spin_wait_pause_multiplier">innodb_spin_wait_pause_multiplier</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_auto_recalc">innodb_stats_auto_recalc</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_include_delete_marked">innodb_stats_include_delete_marked</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_method">innodb_stats_method</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_on_metadata">innodb_stats_on_metadata</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent">innodb_stats_persistent</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent_sample_pages">innodb_stats_persistent_sample_pages</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_transient_sample_pages">innodb_stats_transient_sample_pages</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#option_mysqld_innodb-status-file">innodb-status-file</a></th>
<td>はい</td>
<td>はい</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output">innodb_status_output</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output_locks">innodb_status_output_locks</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode">innodb_strict_mode</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>両方</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_sync_array_size">innodb_sync_array_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_sync_debug">innodb_sync_debug</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_sync_spin_loops">innodb_sync_spin_loops</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_system_rows_deleted">Innodb_system_rows_deleted</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_system_rows_inserted">Innodb_system_rows_inserted</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_system_rows_read">Innodb_system_rows_read</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_table_locks">innodb_table_locks</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>両方</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_data_file_path">innodb_temp_data_file_path</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_tablespaces_dir">innodb_temp_tablespaces_dir</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_concurrency">innodb_thread_concurrency</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_sleep_delay">innodb_thread_sleep_delay</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_tmpdir">innodb_tmpdir</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>両方</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_truncated_status_writes">Innodb_truncated_status_writes</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_trx_purge_view_update_only_debug">innodb_trx_purge_view_update_only_debug</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_trx_rseg_n_slots_debug">innodb_trx_rseg_n_slots_debug</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_directory">innodb_undo_directory</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_log_encrypt">innodb_undo_log_encrypt</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_log_truncate">innodb_undo_log_truncate</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_tablespaces">innodb_undo_tablespaces</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>異なる</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_undo_tablespaces_active">Innodb_undo_tablespaces_active</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_undo_tablespaces_explicit">Innodb_undo_tablespaces_explicit</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_undo_tablespaces_implicit">Innodb_undo_tablespaces_implicit</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#statvar_Innodb_undo_tablespaces_total">Innodb_undo_tablespaces_total</a></th>
<td></td>
<td></td>
<td></td>
<td>はい</td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_use_native_aio">innodb_use_native_aio</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_validate_tablespace_paths">innodb_validate_tablespace_paths</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_version">innodb_version</a></th>
<td></td>
<td></td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_write_io_threads">innodb_write_io_threads</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#sysvar_unique_checks">unique_checks</a></th>
<td></td>
<td></td>
<td>はい</td>
<td></td>
<td>両方</td>
<td>はい</td>
</tr></tbody></table></div></div><br class="table-break"><h3><a name="idm44761354988976"></a>InnoDB コマンドオプション</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_innodb"></a>
          <code class="option">--innodb[=<em class="replaceable"><code>value</code></em>]</code>
        </p><a class="indexterm" name="idm44761354985968"></a><a class="indexterm" name="idm44761354983792"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb[=value]</code></td>
</tr><tr><th>非推奨</th>
<td>はい</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">OFF</code></p><p class="valid-value"><code class="literal">ON</code></p><p class="valid-value"><code class="literal">FORCE</code></p></td>
</tr></tbody></table></div><p>
          サーバーが <code class="literal">InnoDB</code> サポートでコンパイルされた場合に、<code class="literal">InnoDB</code> ストレージエンジンのロードを制御します。 このオプションの形式はトライステートであり、指定可能な値は <code class="literal">OFF</code>、<code class="literal">ON</code>、または <code class="literal">FORCE</code> です。 <a class="xref" href="server-administration.html#plugin-loading" title="5.6.1 プラグインのインストールおよびアンインストール">セクション5.6.1「プラグインのインストールおよびアンインストール」</a>を参照してください。 
        </p><p>
          <code class="literal">InnoDB</code> を無効にするには、<code class="option">--innodb=OFF</code> または <code class="option">--skip-innodb</code> を使用します。 この場合、デフォルトのストレージエンジンは <code class="literal">InnoDB</code> であるため、<code class="option">--default-storage-engine</code> および <code class="option">--default-tmp-storage-engine</code> を使用して永続テーブルと <code class="literal">TEMPORARY</code> テーブルの両方のデフォルトをほかのエンジンに設定しないかぎり、サーバーは起動しません。 
        </p><p>
          <code class="literal">InnoDB</code> ストレージエンジンを無効にすることはできなくなり、<code class="option">--innodb=OFF</code> および <code class="option">--skip-innodb</code> オプションは非推奨であり、効果はありません。 使用すると警告が表示されます。 これらのオプションは、将来の MySQL リリースで削除される予定です。 
        </p></li><li class="listitem"><p><a name="option_mysqld_innodb-status-file"></a>
          <code class="option">--innodb-status-file</code>
        </p><a class="indexterm" name="idm44761354947632"></a><a class="indexterm" name="idm44761354945472"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb-status-file"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-status-file[={OFF|ON}]</code></td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          <code class="option">--innodb-status-file</code> の起動オプションは、<code class="literal">InnoDB</code> が <code class="filename">innodb_status.<em class="replaceable"><code>pid</code></em></code> という名前のファイルをデータディレクトリに作成し、<code class="literal">SHOW ENGINE INNODB STATUS</code> 出力を 15 秒ごとにおよそ書き込むかどうかを制御します。
        </p><p>
          <code class="filename">innodb_status.<em class="replaceable"><code>pid</code></em></code> ファイルはデフォルトでは作成されません。 これを作成するには、<code class="option">--innodb-status-file</code> オプションを指定して <span class="command"><strong>mysqld</strong></span> を起動します。 サーバーが正常に停止すると、<code class="literal">InnoDB</code> によってファイルが削除されます。 異常停止が発生した場合は、ステータスファイルを手動で削除する必要がある場合があります。 
        </p><p>
          <code class="option">--innodb-status-file</code> オプションは一時的な使用を目的としています。これは、<code class="literal">SHOW ENGINE INNODB STATUS</code> の出力生成がパフォーマンスに影響し、<code class="filename">innodb_status.<em class="replaceable"><code>pid</code></em></code> ファイルが時間の経過とともに非常に大きくなる可能性があるためです。
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-enabling-monitors" title="15.17.2 InnoDB モニターの有効化">セクション15.17.2「InnoDB モニターの有効化」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="option">--skip-innodb</code>
        </p><a class="indexterm" name="idm44761354917968"></a><a class="indexterm" name="idm44761354915776"></a><p>
          <code class="literal">InnoDB</code> ストレージエンジンを無効にします。 <code class="option">--innodb</code> の説明を参照してください。 
        </p></li></ul></div><h3><a name="idm44761354911440"></a>InnoDB システム変数</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="sysvar_daemon_memcached_enable_binlog"></a>
          <code class="literal">daemon_memcached_enable_binlog</code>
        </p><a class="indexterm" name="idm44761354908480"></a><a class="indexterm" name="idm44761354906912"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for daemon_memcached_enable_binlog"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--daemon-memcached-enable-binlog[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_enable_binlog">daemon_memcached_enable_binlog</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          MySQL <a class="link" href="glossary.html#glos_binary_log" title="バイナリログ">binary log</a> で <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグイン (<code class="literal">daemon_memcached</code>) を使用するには、ソースサーバーでこのオプションを有効にします。 このオプションは、サーバーの起動時にのみ設定できます。 <code class="literal">--log-bin</code> オプションを使用して、ソースサーバーで MySQL バイナリログを有効にする必要もあります。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-replication" title="15.20.7 InnoDB memcached プラグインとレプリケーション">セクション15.20.7「InnoDB memcached プラグインとレプリケーション」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_daemon_memcached_engine_lib_name"></a>
          <code class="literal">daemon_memcached_engine_lib_name</code>
        </p><a class="indexterm" name="idm44761354876384"></a><a class="indexterm" name="idm44761354874800"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for daemon_memcached_engine_lib_name"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--daemon-memcached-engine-lib-name=file_name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_engine_lib_name">daemon_memcached_engine_lib_name</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>ファイル名</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">innodb_engine.so</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインを実装する共有ライブラリを指定します。
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-setup" title="15.20.3 InnoDB memcached プラグインの設定">セクション15.20.3「InnoDB memcached プラグインの設定」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_daemon_memcached_engine_lib_path"></a>
          <code class="literal">daemon_memcached_engine_lib_path</code>
        </p><a class="indexterm" name="idm44761354847312"></a><a class="indexterm" name="idm44761354845728"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for daemon_memcached_engine_lib_path"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--daemon-memcached-engine-lib-path=dir_name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_engine_lib_path">daemon_memcached_engine_lib_path</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>ディレクトリ名</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">NULL</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインを実装する共有ライブラリを含むディレクトリのパスです。 デフォルト値は、MySQL プラグインディレクトリを表す NULL です。 MySQL プラグインディレクトリの外部にある別のストレージエンジン用の <code class="literal">memcached</code> プラグインを指定しないかぎり、このパラメータを変更する必要はありません。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-setup" title="15.20.3 InnoDB memcached プラグインの設定">セクション15.20.3「InnoDB memcached プラグインの設定」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_daemon_memcached_option"></a>
          <code class="literal">daemon_memcached_option</code>
        </p><a class="indexterm" name="idm44761354817040"></a><a class="indexterm" name="idm44761354815488"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for daemon_memcached_option"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--daemon-memcached-option=options</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_option">daemon_memcached_option</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal"></code></td>
</tr></tbody></table></div><p>
          起動時に、空白文字で区切られた memcached オプションをベースとなる <span class="command"><strong>memcached</strong></span> メモリーオブジェクトのキャッシュデーモンに渡すために使用されます。 たとえば、<span class="command"><strong>memcached</strong></span> がリスニングするポートの変更、同時接続の最大数の削減、キーと値のペアの最大メモリーサイズの変更、またはエラーログのデバッグメッセージの有効化を行うことができます。 
        </p><p>
          使用法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-setup" title="15.20.3 InnoDB memcached プラグインの設定">セクション15.20.3「InnoDB memcached プラグインの設定」</a>を参照してください。 <span class="command"><strong>memcached</strong></span> オプションについては、<span class="command"><strong>memcached</strong></span> のマニュアルページを参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_daemon_memcached_r_batch_size"></a>
          <code class="literal">daemon_memcached_r_batch_size</code>
        </p><a class="indexterm" name="idm44761354786000"></a><a class="indexterm" name="idm44761354784432"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for daemon_memcached_r_batch_size"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--daemon-memcached-r-batch-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_r_batch_size">daemon_memcached_r_batch_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">1</code></td>
</tr></tbody></table></div><p>
          <code class="literal">COMMIT</code> を実行して新しいトランザクションを開始する前に実行する <span class="command"><strong>memcached</strong></span> 読取り操作 (<code class="literal">get</code> 操作) の数を指定します。 <code class="literal">daemon_memcached_w_batch_size</code> の対の片方です。 
        </p><p>
          この値はデフォルトで 1 に設定されているため、SQL ステートメントを介してテーブルに加えられた変更は、<span class="command"><strong>memcached</strong></span> 操作からすぐに参照できます。 ベースとなるテーブルが <span class="command"><strong>memcached</strong></span> インタフェースからのみアクセスされているシステム上で、頻繁なコミットによるオーバーヘッドを削減するために、これを大きくすることがあります。 大きすぎる値を設定すると、Undo データまたは Redo データの量によっては、長時間実行されるトランザクションの場合と同様に、一部のストレージでオーバーヘッドが発生する可能性があります。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-setup" title="15.20.3 InnoDB memcached プラグインの設定">セクション15.20.3「InnoDB memcached プラグインの設定」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_daemon_memcached_w_batch_size"></a>
          <code class="literal">daemon_memcached_w_batch_size</code>
        </p><a class="indexterm" name="idm44761354752144"></a><a class="indexterm" name="idm44761354750576"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for daemon_memcached_w_batch_size"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--daemon-memcached-w-batch-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_w_batch_size">daemon_memcached_w_batch_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">1</code></td>
</tr></tbody></table></div><p>
          <code class="literal">COMMIT</code> を実行して新しいトランザクションを開始する前に実行する、<code class="literal">add</code>、<code class="literal">set</code>、<code class="literal">incr</code> などの <span class="command"><strong>memcached</strong></span> 書込み操作の数を指定します。 <code class="literal">daemon_memcached_r_batch_size</code> の対の一方です。 
        </p><p>
          格納されるデータは停止時に保持することが重要であり、すぐにコミットする必要があると仮定すると、この値はデフォルトで 1 に設定されます。 クリティカルでないデータを格納する場合、頻繁なコミットによるオーバーヘッドを削減するためにこの値を増やすことができますが、予期しない終了が発生すると、最後の <em class="replaceable"><code>N</code></em>-1 のコミットされていない書込み操作が失われる可能性があります。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-setup" title="15.20.3 InnoDB memcached プラグインの設定">セクション15.20.3「InnoDB memcached プラグインの設定」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_adaptive_flushing"></a>
          <code class="literal">innodb_adaptive_flushing</code>
        </p><a class="indexterm" name="idm44761354718080"></a><a class="indexterm" name="idm44761354716528"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_adaptive_flushing"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-adaptive-flushing[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_flushing">innodb_adaptive_flushing</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><a class="indexterm" name="idm44761354694560"></a><p>
          ワークロードに基づいて、<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>内の<a class="link" href="glossary.html#glos_dirty_page" title="ダーティーページ">ダーティーページ</a>をフラッシュする比率を動的に調整するかどうかを指定します。 フラッシュ比率を動的に調整する目的は、I/O アクティビティーのバーストを回避することです。 この設定はデフォルトで有効になっています。 詳しくは<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-flushing" title="15.8.3.5 バッファープールのフラッシュの構成">セクション15.8.3.5「バッファープールのフラッシュの構成」</a>をご覧ください。 一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8 InnoDB ディスク I/O の最適化">セクション8.5.8「InnoDB ディスク I/O の最適化」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_adaptive_flushing_lwm"></a>
          <code class="literal">innodb_adaptive_flushing_lwm</code>
        </p><a class="indexterm" name="idm44761354686304"></a><a class="indexterm" name="idm44761354684736"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_adaptive_flushing_lwm"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-adaptive-flushing-lwm=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_flushing_lwm">innodb_adaptive_flushing_lwm</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">10</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">70</code></td>
</tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_adaptive_flushing" title="適応型フラッシュ">adaptive flushing</a> が有効な <a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">redo log</a> 容量の割合を表す最低水位標を定義します。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-flushing" title="15.8.3.5 バッファープールのフラッシュの構成">セクション15.8.3.5「バッファープールのフラッシュの構成」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_adaptive_hash_index"></a>
          <code class="literal">innodb_adaptive_hash_index</code>
        </p><a class="indexterm" name="idm44761354652608"></a><a class="indexterm" name="idm44761354651040"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_adaptive_hash_index"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-adaptive-hash-index[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_hash_index">innodb_adaptive_hash_index</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_adaptive_hash_index" title="適応型ハッシュインデックス">適応型ハッシュインデックス</a>が有効と無効のどちらになっているのかを示します。 ワークロードに応じて、<a class="link" href="glossary.html#glos_adaptive_hash_index" title="適応型ハッシュインデックス">適応型ハッシュインデックスの作成</a>を動的に有効または無効にして、クエリーのパフォーマンスを改善することが望ましい場合があります。 適応型ハッシュインデックスがすべてのワークロードに役立つとは限らないため、現実的なワークロードを使用して、有効と無効の両方でベンチマークを実施してください。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-adaptive-hash" title="15.5.3 適応型ハッシュインデックス">セクション15.5.3「適応型ハッシュインデックス」</a>を参照してください。 
        </p><p>
          この変数はデフォルトで有効になっています。 <code class="literal">SET GLOBAL</code> ステートメントを使用すると、サーバーを再起動せずに、このパラメータを変更できます。 実行時に設定を変更するには、グローバルシステム変数を設定するのに十分な権限が必要です。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 サーバーの起動時に <code class="option">--skip-innodb-adaptive-hash-index</code> を使用して無効にすることもできます。 
        </p><p>
          適応型ハッシュインデックスを無効にすると、すぐにハッシュテーブルが空になります。 ハッシュテーブルが空になっても通常の操作は続行でき、ハッシュテーブルを使用していた実行中のクエリーは、代わりにインデックスの B ツリーに直接アクセスします。 適応型ハッシュインデックスを再度有効にすると、通常の操作時にハッシュテーブルが再度移入されます。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_adaptive_hash_index_parts"></a>
          <code class="literal">innodb_adaptive_hash_index_parts</code>
        </p><a class="indexterm" name="idm44761354618320"></a><a class="indexterm" name="idm44761354616768"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_adaptive_hash_index_parts"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-adaptive-hash-index-parts=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_hash_index_parts">innodb_adaptive_hash_index_parts</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>数値</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">8</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">512</code></td>
</tr></tbody></table></div><p>
          適応ハッシュインデックス検索システムをパーティション化します。 各インデックスは特定のパーティションにバインドされ、各パーティションは個別のラッチで保護されます。 
        </p><p>
          適応ハッシュインデックス検索システムは、デフォルトで 8 つの部分にパーティション化されています。 最大設定は 512 です。 
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-adaptive-hash" title="15.5.3 適応型ハッシュインデックス">セクション15.5.3「適応型ハッシュインデックス」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_adaptive_max_sleep_delay"></a>
          <code class="literal">innodb_adaptive_max_sleep_delay</code>
        </p><a class="indexterm" name="idm44761354584864"></a><a class="indexterm" name="idm44761354583280"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_adaptive_max_sleep_delay"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-adaptive-max-sleep-delay=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_max_sleep_delay">innodb_adaptive_max_sleep_delay</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">150000</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">1000000</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> で、現在のワークロードに応じて <code class="literal">innodb_thread_sleep_delay</code> の値を自動的に調整できます。 ゼロ以外の値を指定すると、<code class="literal">innodb_adaptive_max_sleep_delay</code> オプションで指定した最大値まで、<code class="literal">innodb_thread_sleep_delay</code> 値の動的な自動調整が可能になります。 値はマイクロ秒数を表しています。 このオプションは、<code class="literal">InnoDB</code> スレッド数が 16 個を上回る高負荷のシステムで役立つことがあります。 (実際には、同時接続数が数百または数千になる MySQL システムの大部分の変数です。) 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-thread_concurrency" title="15.8.4 InnoDB のスレッド並列性の構成">セクション15.8.4「InnoDB のスレッド並列性の構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_api_bk_commit_interval"></a>
          <code class="literal">innodb_api_bk_commit_interval</code>
        </p><a class="indexterm" name="idm44761354547184"></a><a class="indexterm" name="idm44761354545616"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_api_bk_commit_interval"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-api-bk-commit-interval=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_bk_commit_interval">innodb_api_bk_commit_interval</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">5</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">1073741824</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> インタフェースが使用されるアイドル状態の接続が自動コミットされる頻度 (秒単位) です。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-txn" title="15.20.6.4 InnoDB memcached プラグインのトランザクション動作の制御">セクション15.20.6.4「InnoDB memcached プラグインのトランザクション動作の制御」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_api_disable_rowlock"></a>
          <code class="literal">innodb_api_disable_rowlock</code>
        </p><a class="indexterm" name="idm44761354513632"></a><a class="indexterm" name="idm44761354512064"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_api_disable_rowlock"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-api-disable-rowlock[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_disable_rowlock">innodb_api_disable_rowlock</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> が DML 操作を実行するときに行ロックを無効にするには、このオプションを使用します。 デフォルトでは、<code class="literal">innodb_api_disable_rowlock</code> は無効になっています。これは、<span class="command"><strong>memcached</strong></span> が <code class="literal">get</code> および <code class="literal">set</code> 操作の行ロックを要求することを意味します。 <code class="literal">innodb_api_disable_rowlock</code> が有効な場合、<span class="command"><strong>memcached</strong></span> は行ロックではなくテーブルロックを要求します。 
        </p><p>
          <code class="literal">innodb_api_disable_rowlock</code> は動的ではありません。 これは <span class="command"><strong>mysqld</strong></span> コマンド行で指定するか、または MySQL 構成ファイルに入力する必要があります。 構成は、MySQL サーバーの起動時に発生するプラグインのインストール時に有効になります。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-txn" title="15.20.6.4 InnoDB memcached プラグインのトランザクション動作の制御">セクション15.20.6.4「InnoDB memcached プラグインのトランザクション動作の制御」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_api_enable_binlog"></a>
          <code class="literal">innodb_api_enable_binlog</code>
        </p><a class="indexterm" name="idm44761354476800"></a><a class="indexterm" name="idm44761354475248"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_api_enable_binlog"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-api-enable-binlog[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_enable_binlog">innodb_api_enable_binlog</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          MySQL <a class="link" href="glossary.html#glos_binary_log" title="バイナリログ">バイナリログ</a>とともに、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインを使用できます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-replication-enable-binlog" title="InnoDB memcached バイナリログの有効化">InnoDB memcached バイナリログの有効化</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_api_enable_mdl"></a>
          <code class="literal">innodb_api_enable_mdl</code>
        </p><a class="indexterm" name="idm44761354447344"></a><a class="indexterm" name="idm44761354445792"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_api_enable_mdl"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-api-enable-mdl[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_enable_mdl">innodb_api_enable_mdl</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインで使用されるテーブルをロックします。これにより、SQL インタフェースから <a class="link" href="glossary.html#glos_ddl" title="DDL">DDL</a> によって削除または変更できなくなります。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-txn" title="15.20.6.4 InnoDB memcached プラグインのトランザクション動作の制御">セクション15.20.6.4「InnoDB memcached プラグインのトランザクション動作の制御」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_api_trx_level"></a>
          <code class="literal">innodb_api_trx_level</code>
        </p><a class="indexterm" name="idm44761354418032"></a><a class="indexterm" name="idm44761354416480"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_api_trx_level"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-api-trx-level=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_trx_level">innodb_api_trx_level</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr></tbody></table></div><p>
          <span class="command"><strong>memcached</strong></span> インタフェースによって処理されるクエリーのトランザクション <a class="link" href="glossary.html#glos_isolation_level" title="分離レベル">isolation level</a> を制御します。 よく聞く名前に対応する定数は、次のとおりです。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              0 = <code class="literal">READ UNCOMMITTED</code>
            </p></li><li class="listitem"><p>
              1 = <code class="literal">READ COMMITTED</code>
            </p></li><li class="listitem"><p>
              2 = <code class="literal">REPEATABLE READ</code>
            </p></li><li class="listitem"><p>
              3 = <code class="literal">SERIALIZABLE</code>
            </p></li></ul></div><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-txn" title="15.20.6.4 InnoDB memcached プラグインのトランザクション動作の制御">セクション15.20.6.4「InnoDB memcached プラグインのトランザクション動作の制御」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_autoextend_increment"></a>
          <code class="literal">innodb_autoextend_increment</code>
        </p><a class="indexterm" name="idm44761354381552"></a><a class="indexterm" name="idm44761354379984"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_autoextend_increment"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-autoextend-increment=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoextend_increment">innodb_autoextend_increment</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">64</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">1000</code></td>
</tr></tbody></table></div><p>
          自動拡張 <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">system tablespace</a> ファイルがいっぱいになったときにサイズを拡張するための増分サイズ (MB)。 デフォルト値は 64 です。 関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-startup-data-file-configuration" title="システムテーブルスペースデータファイル構成">システムテーブルスペースデータファイル構成</a>,および<a class="xref" href="innodb-storage-engine.html#innodb-resize-system-tablespace" title="システムテーブルスペースのサイズ変更">システムテーブルスペースのサイズ変更</a>を参照してください。 
        </p><p>
          <code class="literal">innodb_autoextend_increment</code> 設定は、<a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースファイルまたは <a class="link" href="glossary.html#glos_general_tablespace" title="一般テーブルスペース">general tablespace</a> ファイルには影響しません。 これらのファイルは、<code class="literal">innodb_autoextend_increment</code> の設定に関係なく自動拡張されます。 拡張は少量で始まり、その後の拡張は増分が 4MB で発生します。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_autoinc_lock_mode"></a>
          <code class="literal">innodb_autoinc_lock_mode</code>
        </p><a class="indexterm" name="idm44761354342624"></a><a class="indexterm" name="idm44761354341072"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_autoinc_lock_mode"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-autoinc-lock-mode=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode">innodb_autoinc_lock_mode</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">2</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">0</code></p><p class="valid-value"><code class="literal">1</code></p><p class="valid-value"><code class="literal">2</code></p></td>
</tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_auto_increment" title="自動インクリメント">自動インクリメント</a>値を生成する際に使用される<a class="link" href="glossary.html#glos_lock_mode" title="lock mode">ロックモード</a>です。 許容値は、従来型、連続型またはインターリーブ型の場合、それぞれ 0、1 または 2 です。 
        </p><p>
          デフォルト設定は、MySQL 8.0 の時点では 2 (インターリーブ)、それより前では 1 (連続) です。 デフォルト設定としてインターリーブロックモードを変更すると、MySQL 5.7 で発生したデフォルトのレプリケーションタイプとして、ステートメントベースから行ベースのレプリケーションへの変更が反映されます。 ステートメントベースレプリケーションでは、SQL ステートメントの特定のシーケンスに対して自動インクリメント値が予測可能かつ繰り返し可能な順序で割り当てられるように、連続した自動インクリメントロックモードが必要ですが、行ベースレプリケーションは SQL ステートメントの実行順序には影響しません。 
        </p><p>
          各ロックモードの特性については、<a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-lock-modes" title="InnoDB AUTO_INCREMENT のロックモード">InnoDB AUTO_INCREMENT のロックモード</a> を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_background_drop_list_empty"></a>
          <code class="literal">innodb_background_drop_list_empty</code>
        </p><a class="indexterm" name="idm44761354306320"></a><a class="indexterm" name="idm44761354304720"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_background_drop_list_empty"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-background-drop-list-empty[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_background_drop_list_empty">innodb_background_drop_list_empty</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          <code class="literal">innodb_background_drop_list_empty</code> デバッグオプションを有効にすると、バックグラウンドドロップリストが空になるまでテーブルの作成が遅延されるため、テストケースの失敗を回避できます。 たとえば、テストケース A がテーブル <code class="literal">t1</code> をバックグラウンドドロップリストに配置する場合、テストケース B はバックグラウンドドロップリストが空になるまで待機してから、テーブル <code class="literal">t1</code> を作成します。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_chunk_size"></a>
          <code class="literal">innodb_buffer_pool_chunk_size</code>
        </p><a class="indexterm" name="idm44761354276816"></a><a class="indexterm" name="idm44761354275248"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_buffer_pool_chunk_size"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-buffer-pool-chunk-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_chunk_size">innodb_buffer_pool_chunk_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">134217728</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1048576</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">innodb_buffer_pool_size / innodb_buffer_pool_instances</code></td>
</tr></tbody></table></div><p>
          <code class="literal">innodb_buffer_pool_chunk_size</code> は、<code class="literal">InnoDB</code> バッファプールのサイズ変更操作のチャンクサイズを定義します。
        </p><p>
          サイズ変更操作中にすべてのバッファプールページがコピーされないようにするために、この操作は <span class="quote">「<span class="quote">chunks</span>」</span> で実行されます。 デフォルトでは、<code class="literal">innodb_buffer_pool_chunk_size</code> は 128MB (134217728 バイト) です。 チャンクに含まれるページ数は、<code class="literal">innodb_page_size</code> の値によって異なります。<code class="literal">innodb_buffer_pool_chunk_size</code> は、1MB (1048576 バイト) 単位で増減できます。 
        </p><p>
          <code class="literal">innodb_buffer_pool_chunk_size</code> 値を変更する場合は、次の条件が適用されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              バッファプールの初期化時に<code class="literal"> innodb_buffer_pool_chunk_size</code>*<code class="literal">innodb_buffer_pool_instances</code> が現在のバッファプールサイズより大きい場合、<code class="literal">innodb_buffer_pool_chunk_size</code> は <code class="literal">innodb_buffer_pool_size</code> / <code class="literal">innodb_buffer_pool_instances</code> に切り捨てられます。
            </p></li><li class="listitem"><p>
              バッファプールサイズは、常に <code class="literal">innodb_buffer_pool_chunk_size</code> * <code class="literal">innodb_buffer_pool_instances</code> と等しいか倍数である必要があります。 <code class="literal">innodb_buffer_pool_chunk_size</code> を変更すると、<code class="literal">innodb_buffer_pool_size</code> は <code class="literal">innodb_buffer_pool_chunk_size</code> * <code class="literal">innodb_buffer_pool_instances</code> と等しいか倍数の値に自動的に丸められます。 調整は、バッファープールが初期化されたときに行われます。 
            </p></li></ul></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
            この値を変更するとバッファプールのサイズが自動的に増加する可能性があるため、<code class="literal">innodb_buffer_pool_chunk_size</code> を変更する場合は注意が必要です。 <code class="literal">innodb_buffer_pool_chunk_size</code> を変更する前に、<code class="literal">innodb_buffer_pool_size</code> への影響を計算して、生成されるバッファープールサイズが受け入れ可能であることを確認します。 
          </p></div><p>
          潜在的なパフォーマンスの問題を回避するには、チャンク (<code class="literal">innodb_buffer_pool_size</code> / <code class="literal">innodb_buffer_pool_chunk_size</code>) の数が 1000 を超えないようにする必要があります。
        </p><p>
          <code class="literal">innodb_buffer_pool_size</code> 変数は動的で、サーバーがオンラインのときにバッファプールのサイズを変更できます。 ただし、バッファプールサイズは <code class="literal">innodb_buffer_pool_chunk_size</code> * <code class="literal">innodb_buffer_pool_instances</code> の倍数である必要があり、これらの変数設定のいずれかを変更するにはサーバーを再起動する必要があります。 
        </p><p>
          詳しくは<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-resize" title="15.8.3.1 InnoDB バッファプールサイズの構成">セクション15.8.3.1「InnoDB バッファプールサイズの構成」</a>をご覧ください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_debug"></a>
          <code class="literal">innodb_buffer_pool_debug</code>
        </p><a class="indexterm" name="idm44761354211680"></a><a class="indexterm" name="idm44761354210560"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_buffer_pool_debug"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-buffer-pool-debug[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_debug">innodb_buffer_pool_debug</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          このオプションを有効にすると、バッファプールのサイズが 1GB 未満の場合に複数のバッファプールインスタンスが許可され、<code class="literal">innodb_buffer_pool_instances</code> に設定されている 1GB の最小バッファプールサイズ制約は無視されます。 <code class="literal">innodb_buffer_pool_debug</code> オプションは、デバッグサポートが <code class="option">WITH_DEBUG</code> <span class="command"><strong>CMake</strong></span> オプションを使用してコンパイルされている場合にのみ使用できます。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_dump_at_shutdown"></a>
          <code class="literal">innodb_buffer_pool_dump_at_shutdown</code>
        </p><a class="indexterm" name="idm44761354181584"></a><a class="indexterm" name="idm44761354179984"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_buffer_pool_dump_at_shutdown"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-buffer-pool-dump-at-shutdown[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_at_shutdown">innodb_buffer_pool_dump_at_shutdown</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
          MySQL サーバーの停止時に <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> にキャッシュされたページを記録して、次回の再起動時に <a class="link" href="glossary.html#glos_warm_up" title="ウォームアップ">warmup</a> プロセスを短縮するかどうかを指定します。 一般に、<code class="literal">innodb_buffer_pool_load_at_startup</code> と組み合わせて使用されます。 <code class="literal">innodb_buffer_pool_dump_pct</code> オプションは、ダンプする最後に使用されたバッファープールページの割合を定義します。 
        </p><p>
          <code class="literal">innodb_buffer_pool_dump_at_shutdown</code> と <code class="literal">innodb_buffer_pool_load_at_startup</code> の両方がデフォルトで有効になっています。
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="15.8.3.6 バッファープールの状態の保存と復元">セクション15.8.3.6「バッファープールの状態の保存と復元」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_dump_now"></a>
          <code class="literal">innodb_buffer_pool_dump_now</code>
        </p><a class="indexterm" name="idm44761354146640"></a><a class="indexterm" name="idm44761354145072"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_buffer_pool_dump_now"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-buffer-pool-dump-now[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_now">innodb_buffer_pool_dump_now</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> にキャッシュされたページをすぐに記録します。 一般に、<code class="literal">innodb_buffer_pool_load_now</code> と組み合わせて使用されます。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="15.8.3.6 バッファープールの状態の保存と復元">セクション15.8.3.6「バッファープールの状態の保存と復元」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_dump_pct"></a>
          <code class="literal">innodb_buffer_pool_dump_pct</code>
        </p><a class="indexterm" name="idm44761354116544"></a><a class="indexterm" name="idm44761354114976"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_buffer_pool_dump_pct"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-buffer-pool-dump-pct=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_pct">innodb_buffer_pool_dump_pct</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">25</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">100</code></td>
</tr></tbody></table></div><p>
          各バッファープールが読み出してダンプする直近で使用されたページの割合を指定。 指定できる範囲は 1～ 100 です。 デフォルト値は 25 です。 たとえば、100 ページのバッファプールが 4 つあり、<code class="literal">innodb_buffer_pool_dump_pct</code> が 25 に設定されている場合、各バッファプールから最近使用された 25 ページがダンプされます。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_filename"></a>
          <code class="literal">innodb_buffer_pool_filename</code>
        </p><a class="indexterm" name="idm44761354083728"></a><a class="indexterm" name="idm44761354082160"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_buffer_pool_filename"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-buffer-pool-filename=file_name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_filename">innodb_buffer_pool_filename</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>ファイル名</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ib_buffer_pool</code></td>
</tr></tbody></table></div><p>
          <code class="literal">innodb_buffer_pool_dump_at_shutdown</code> または <code class="literal">innodb_buffer_pool_dump_now</code> で生成されるテーブルスペース ID およびページ ID のリストを保持するファイルの名前を指定します。 テーブルスペース ID およびページ ID は、<code class="literal">space, page_id</code> という形式で保存されます。 デフォルトでは、ファイルの名前は <code class="filename">ib_buffer_pool</code> で、<code class="literal">InnoDB</code> データディレクトリにあります。 データディレクトリに対してデフォルト以外の場所を指定する必要があります。 
        </p><p>
          <code class="literal">SET</code> ステートメントを使用して、実行時にファイル名を指定できます:
        </p><pre class="programlisting">SET GLOBAL innodb_buffer_pool_filename=<em class="replaceable"><code>'file_name'</code></em>;
</pre><p>
          起動時に、起動文字列または MySQL 構成ファイルでファイル名を指定することもできます。 起動時にファイル名を指定する場合は、ファイルが存在する必要があります。存在しない場合は、そのようなファイルまたはディレクトリがないことを示す起動エラーが <code class="literal">InnoDB</code> によって返されます。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="15.8.3.6 バッファープールの状態の保存と復元">セクション15.8.3.6「バッファープールの状態の保存と復元」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_in_core_file"></a>
          <code class="literal">innodb_buffer_pool_in_core_file</code>
        </p><a class="indexterm" name="idm44761354046464"></a><a class="indexterm" name="idm44761354044880"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_buffer_pool_in_core_file"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-buffer-pool-in-core-file[={OFF|ON}]</code></td>
</tr><tr><th>導入</th>
<td>8.0.14</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_in_core_file">innodb_buffer_pool_in_core_file</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
          <code class="literal">innodb_buffer_pool_in_core_file</code> 変数を無効にすると、<code class="literal">InnoDB</code> バッファープールページが除外され、コアファイルのサイズが小さくなります。 この変数を使用するには、<code class="literal">core_file</code> 変数を有効にし、オペレーティングシステムで <code class="literal">madvise()</code> に対する <code class="literal">MADV_DONTDUMP</code> の POSIX 以外の拡張機能をサポートする必要があります。これは Linux 3.4 以降でサポートされています。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-in-core-file" title="15.8.3.7 コアファイルからのバッファープールページの除外">セクション15.8.3.7「コアファイルからのバッファープールページの除外」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_instances"></a>
          <code class="literal">innodb_buffer_pool_instances</code>
        </p><a class="indexterm" name="idm44761354012608"></a><a class="indexterm" name="idm44761354011040"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_buffer_pool_instances"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-buffer-pool-instances=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances">innodb_buffer_pool_instances</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値 (Windows, 32 ビットプラットフォーム)</th>
<td><code class="literal">(autosized)</code></td>
</tr><tr><th>デフォルト値 (その他)</th>
<td><code class="literal">8 (or 1 if innodb_buffer_pool_size &lt; 1GB</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">64</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>が分割される領域の数です。 バッファープールが数 G バイトの範囲にあるシステムでは、バッファープールを個別のインスタンスに分割すると、キャッシュされたページに対して異なるスレッドが読み取りおよび書き込みを行うときの競合が減るため、並列性が向上する場合があります。 バッファープールに格納される各ページまたはバッファープールから読み取られる各ページは、ハッシュ関数を使用して、バッファープールインスタンスのいずれかにランダムに割り当てられます。 各バッファープールは、独自の空きリスト、<a class="link" href="glossary.html#glos_flush_list" title="フラッシュリスト">フラッシュリスト</a>、<a class="link" href="glossary.html#glos_lru" title="LRU">LRU</a>、およびバッファープールに接続されたその他のすべてのデータ構造を管理し、独自のバッファープール<a class="link" href="glossary.html#glos_mutex" title="相互排他ロック">相互排他ロック</a>によって保護されます。 
        </p><p>
          このオプションは、<code class="literal">innodb_buffer_pool_size</code> を 1GB 以上に設定する場合にのみ有効になります。 バッファプールの合計サイズは、すべてのバッファプールに分割されます。 最高の効率を得るには、<code class="literal">innodb_buffer_pool_instances</code> と <code class="literal">innodb_buffer_pool_size</code> の組み合わせを、各バッファープールインスタンスが少なくとも 1G バイトになるように指定します。 
        </p><p>
          32-bit Windows システムのデフォルト値は、次に説明するように、<code class="literal">innodb_buffer_pool_size</code> の値によって異なります:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">innodb_buffer_pool_size</code> が 1.3G バイトよりも大きい場合は、<code class="literal">innodb_buffer_pool_instances</code> のデフォルトが <code class="literal">innodb_buffer_pool_size</code>/128M バイトになり、チャンクごとに個別のメモリー割り当てリクエストを持ちます。32 ビット版 Windows で単一のバッファープールで必要となる連続したアドレス空間を割り当てることができないという重大なリスクが存在する境界として、1.3G バイトが選択されました。
            </p></li><li class="listitem"><p>
              それ以外の場合、デフォルトは 1 です。
            </p></li></ul></div><p>
          他のすべてのプラットフォームでは、<code class="literal">innodb_buffer_pool_size</code> が 1GB 以上の場合、デフォルト値は 8 です。 それ以外の場合、デフォルトは 1 です。 
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-resize" title="15.8.3.1 InnoDB バッファプールサイズの構成">セクション15.8.3.1「InnoDB バッファプールサイズの構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_load_abort"></a>
          <code class="literal">innodb_buffer_pool_load_abort</code>
        </p><a class="indexterm" name="idm44761353958896"></a><a class="indexterm" name="idm44761353957328"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_buffer_pool_load_abort"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-buffer-pool-load-abort[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_abort">innodb_buffer_pool_load_abort</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          <code class="literal">innodb_buffer_pool_load_at_startup</code> または <code class="literal">innodb_buffer_pool_load_now</code> によってトリガーされた <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> コンテンツをリストアするプロセスを中断します。
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="15.8.3.6 バッファープールの状態の保存と復元">セクション15.8.3.6「バッファープールの状態の保存と復元」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_load_at_startup"></a>
          <code class="literal">innodb_buffer_pool_load_at_startup</code>
        </p><a class="indexterm" name="idm44761353927744"></a><a class="indexterm" name="idm44761353926144"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_buffer_pool_load_at_startup"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-buffer-pool-load-at-startup[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_at_startup">innodb_buffer_pool_load_at_startup</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
          MySQL サーバーの起動時に、以前に保持していたものと同じページをロードすることで、<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> が自動的に <a class="link" href="glossary.html#glos_warm_up" title="ウォームアップ">warmed up</a> になるように指定します。 一般に、<code class="literal">innodb_buffer_pool_dump_at_shutdown</code> と組み合わせて使用されます。 
        </p><p>
          <code class="literal">innodb_buffer_pool_dump_at_shutdown</code> と <code class="literal">innodb_buffer_pool_load_at_startup</code> の両方がデフォルトで有効になっています。
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="15.8.3.6 バッファープールの状態の保存と復元">セクション15.8.3.6「バッファープールの状態の保存と復元」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_load_now"></a>
          <code class="literal">innodb_buffer_pool_load_now</code>
        </p><a class="indexterm" name="idm44761353894064"></a><a class="indexterm" name="idm44761353892496"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_buffer_pool_load_now"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-buffer-pool-load-now[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_now">innodb_buffer_pool_load_now</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          サーバーの再起動を待たずに一連のデータページをロードすることで、<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> を即時に <a class="link" href="glossary.html#glos_warm_up" title="ウォームアップ">warms up</a> します。 ベンチマーク時にキャッシュメモリーを既知の状態に戻したり、レポートやメンテナンスのためにクエリーを実行したあとに、MySQL サーバーの通常のワークロードを再開する準備をしたりする際に役立ちます。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="15.8.3.6 バッファープールの状態の保存と復元">セクション15.8.3.6「バッファープールの状態の保存と復元」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_size"></a>
          <code class="literal">innodb_buffer_pool_size</code>
        </p><a class="indexterm" name="idm44761353863520"></a><a class="indexterm" name="idm44761353861968"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_buffer_pool_size"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-buffer-pool-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size">innodb_buffer_pool_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">134217728</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">5242880</code></td>
</tr><tr><th>最大値 (64 ビットプラットフォーム)</th>
<td><code class="literal">2**64-1</code></td>
</tr><tr><th>最大値 (32 ビットプラットフォーム)</th>
<td><code class="literal">2**32-1</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> がテーブルおよびインデックスのデータをキャッシュするメモリー領域である<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>のサイズ (バイト単位) です。 デフォルト値は 134217728 バイト (128MB) です。 最大値は、CPU アーキテクチャーによって異なります。最大値は、32 ビットシステムでは 4294967295 (2<sup>32</sup>-1)、64 ビットシステムでは 18446744073709551615 (2<sup>64</sup>-1) です。 32 ビットシステムでは、CPU アーキテクチャーおよびオペレーティングシステムに、指定された最大値よりも小さい実用的な最大サイズが課されている可能性があります。 バッファープールのサイズが 1G バイトよりも大きい場合に、<code class="literal">innodb_buffer_pool_instances</code> を 1 よりも大きい値に設定すると、高負荷のサーバーで拡張性を改善できます。 
        </p><p>
          バッファプールを大きくすると、同じテーブルデータに複数回アクセスするために必要なディスク I/O が少なくなります。 専用データベースサーバーでは、バッファプールサイズをマシンの物理メモリーサイズの 80% に設定できます。 バッファープールサイズを構成するときは、次の潜在的な問題に注意し、必要に応じてバッファープールのサイズをスケールバックする準備をしてください。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              物理メモリーの競合により、オペレーティングシステムでページングが発生する可能性があります。
            </p></li><li class="listitem"><p>
              <code class="literal">InnoDB</code> では、バッファおよび制御構造体用に追加のメモリーが予約されるため、割り当てられる領域の合計は、指定されたバッファプールサイズよりも約 10% 大きくなります。
            </p></li><li class="listitem"><p>
              バッファープールのアドレス空間は連続している必要があります。これは、特定のアドレスで DLL をロードする Windows システムで問題になる可能性があります。
            </p></li><li class="listitem"><p>
              バッファープールを初期化する時間は、ほぼそのサイズに比例しています。 バッファプールが大きいインスタンスでは、初期化にかなりの時間がかかる場合があります。 初期化期間を短縮するには、サーバーの停止時にバッファプールの状態を保存し、サーバーの起動時にリストアします。 <a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="15.8.3.6 バッファープールの状態の保存と復元">セクション15.8.3.6「バッファープールの状態の保存と復元」</a>を参照してください。 
            </p></li></ul></div><p>
          バッファープールサイズを増減すると、操作はチャンク単位で実行されます。 チャンクサイズは、<code class="literal">innodb_buffer_pool_chunk_size</code> 変数 (デフォルトは 128 MB) によって定義されます。 
        </p><p>
          バッファプールサイズは、常に <code class="literal">innodb_buffer_pool_chunk_size</code> * <code class="literal">innodb_buffer_pool_instances</code> と等しいか倍数である必要があります。 バッファープールサイズを <code class="literal">innodb_buffer_pool_chunk_size</code>*<code class="literal">innodb_buffer_pool_instances</code> と等しくない値または倍数に変更すると、バッファープールサイズは <code class="literal">innodb_buffer_pool_chunk_size</code> * <code class="literal">innodb_buffer_pool_instances</code> と等しいか倍数の値に自動的に調整されます。 
        </p><p>
          <code class="literal">innodb_buffer_pool_size</code> は動的に設定できるため、サーバーを再起動せずにバッファプールのサイズを変更できます。 <code class="literal">Innodb_buffer_pool_resize_status</code> ステータス変数は、オンラインバッファプールのサイズ変更操作のステータスを報告します。 詳しくは<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-resize" title="15.8.3.1 InnoDB バッファプールサイズの構成">セクション15.8.3.1「InnoDB バッファプールサイズの構成」</a>をご覧ください。 
        </p><p>
          <code class="literal">innodb_dedicated_server</code> が有効な場合、<code class="literal">innodb_buffer_pool_size</code> 値は明示的に定義されていなければ自動的に構成されます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-dedicated-server" title="15.8.12 専用 MySQL Server の自動構成の有効化">セクション15.8.12「専用 MySQL Server の自動構成の有効化」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_change_buffer_max_size"></a>
          <code class="literal">innodb_change_buffer_max_size</code>
        </p><a class="indexterm" name="idm44761353801744"></a><a class="indexterm" name="idm44761353800176"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_change_buffer_max_size"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-change-buffer-max-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffer_max_size">innodb_change_buffer_max_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">25</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">50</code></td>
</tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> の合計サイズに対する <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_change_buffer" title="変更バッファー">change buffer</a> の最大サイズの割合。 この値は、MySQL サーバーで頻繁に挿入、更新、および削除アクティビティーが発生する場合は大きくし、MySQL サーバーでレポート用に使用されるデータが変更されない場合は小さくするとよいでしょう。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-change-buffer" title="15.5.2 変更バッファ">セクション15.5.2「変更バッファ」</a>を参照してください。 一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8 InnoDB ディスク I/O の最適化">セクション8.5.8「InnoDB ディスク I/O の最適化」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_change_buffering"></a>
          <code class="literal">innodb_change_buffering</code>
        </p><a class="indexterm" name="idm44761353766128"></a><a class="indexterm" name="idm44761353764576"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_change_buffering"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-change-buffering=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffering">innodb_change_buffering</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">all</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">none</code></p><p class="valid-value"><code class="literal">inserts</code></p><p class="valid-value"><code class="literal">deletes</code></p><p class="valid-value"><code class="literal">changes</code></p><p class="valid-value"><code class="literal">purges</code></p><p class="valid-value"><code class="literal">all</code></p></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> が<a class="link" href="glossary.html#glos_change_buffering" title="変更バッファリング">バッファリングの変更</a> (I/O 操作を連続して実行できるように、セカンダリインデックスへの書き込み操作を遅延させる最適化) を実行するかどうかを指定します。 次のテーブルに、許可される値を示します。 値は数値で指定することもできます。 
        </p><div class="table"><a name="innodb-change-buffer-permitted-values"></a><p class="title"><b>表 15.25 innodb_change_buffering に許可される値</b></p><div class="table-contents"><table summary="Permitted values for the innodb_chansge_buffering variable. The first column defines the value. The second column describes the option effect."><col style="width: 20%"><col style="width: 20%"><col style="width: 60%"><thead><tr>
              <th scope="col">値</th>
              <th scope="col">数値</th>
              <th scope="col">説明</th>
            </tr></thead><tbody><tr>
              <th scope="row"><code class="literal">none</code></th>
              <td><code class="literal">0</code></td>
              <td>どの操作もバッファリングしません。</td>
            </tr><tr>
              <th scope="row"><code class="literal">inserts</code></th>
              <td><code class="literal">1</code></td>
              <td>挿入操作をバッファリングします。</td>
            </tr><tr>
              <th scope="row"><code class="literal">deletes</code></th>
              <td><code class="literal">2</code></td>
              <td>バッファ削除マーキング操作。厳密に言えば、パージ操作中に後で削除するためにインデックスレコードをマークする書込み。</td>
            </tr><tr>
              <th scope="row"><code class="literal">changes</code></th>
              <td><code class="literal">3</code></td>
              <td>バッファの挿入および削除マーク操作。</td>
            </tr><tr>
              <th scope="row"><code class="literal">purges</code></th>
              <td><code class="literal">4</code></td>
              <td>バックグラウンドで実行される物理的な削除操作をバッファリングします。</td>
            </tr><tr>
              <th scope="row"><code class="literal">all</code></th>
              <td><code class="literal">5</code></td>
              <td>デフォルト。 バッファの挿入、削除マーク操作およびパージ。 </td>
            </tr></tbody></table></div></div><br class="table-break"><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-change-buffer" title="15.5.2 変更バッファ">セクション15.5.2「変更バッファ」</a>を参照してください。 一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8 InnoDB ディスク I/O の最適化">セクション8.5.8「InnoDB ディスク I/O の最適化」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_change_buffering_debug"></a>
          <code class="literal">innodb_change_buffering_debug</code>
        </p><a class="indexterm" name="idm44761353694896"></a><a class="indexterm" name="idm44761353693776"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_change_buffering_debug"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-change-buffering-debug=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffering_debug">innodb_change_buffering_debug</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">2</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> 変更バッファリングのデバッグフラグを設定します。 値 1 を指定すると、変更バッファに対するすべての変更が強制されます。 値 2 を指定すると、マージ時に予期しない終了が発生します。 デフォルト値の 0 は、変更バッファリングデバッグフラグが設定されていないことを示します。 このオプションは、デバッグサポートが <code class="option">WITH_DEBUG</code> <span class="command"><strong>CMake</strong></span> オプションを使用してコンパイルされている場合にのみ使用できます。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_checkpoint_disabled"></a>
          <code class="literal">innodb_checkpoint_disabled</code>
        </p><a class="indexterm" name="idm44761353663760"></a><a class="indexterm" name="idm44761353662192"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_checkpoint_disabled"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-checkpoint-disabled[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_checkpoint_disabled">innodb_checkpoint_disabled</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          これは、エキスパートによるデバッグのみを目的としたデバッグオプションです。 チェックポイントを無効にして、故意のサーバーイグジットが常に <code class="literal">InnoDB</code> リカバリを開始するようにします。 通常は、サーバーの終了後にリカバリが必要な redo ログエントリを書き込む DML 操作を実行する前に、短い間隔でのみ有効にする必要があります。 このオプションは、デバッグサポートが <code class="option">WITH_DEBUG</code> <span class="command"><strong>CMake</strong></span> オプションを使用してコンパイルされている場合にのみ使用できます。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_checksum_algorithm"></a>
          <code class="literal">innodb_checksum_algorithm</code>
        </p><a class="indexterm" name="idm44761353634256"></a><a class="indexterm" name="idm44761353632688"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_checksum_algorithm"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-checksum-algorithm=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_checksum_algorithm">innodb_checksum_algorithm</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">crc32</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">innodb</code></p><p class="valid-value"><code class="literal">crc32</code></p><p class="valid-value"><code class="literal">none</code></p><p class="valid-value"><code class="literal">strict_innodb</code></p><p class="valid-value"><code class="literal">strict_crc32</code></p><p class="valid-value"><code class="literal">strict_none</code></p></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_tablespace" title="テーブルスペース">tablespaces</a> のディスクブロックに格納されている <a class="link" href="glossary.html#glos_checksum" title="チェックサム">checksum</a> を生成および検証する方法を指定します。 <code class="literal">innodb_checksum_algorithm</code> のデフォルト値は <code class="literal">crc32</code> です。 
        </p><p>
          3.8.0 までのバージョンの <a class="link" href="mysql-enterprise.html#mysql-enterprise-backup" title="30.2 MySQL Enterprise Backup の概要">MySQL Enterprise Backup</a> は、CRC32 チェックサムを使用するテーブルスペースのバックアップをサポートしていません。 <a class="link" href="mysql-enterprise.html#mysql-enterprise-backup" title="30.2 MySQL Enterprise Backup の概要">MySQL Enterprise Backup</a> は、CRC32 チェックサムのサポートを 3.8.1 で (いくつかの制限付きで) 追加しています。 詳細は、<a class="link" href="mysql-enterprise.html#mysql-enterprise-backup" title="30.2 MySQL Enterprise Backup の概要">MySQL Enterprise Backup</a> 3.8.1 の変更履歴を参照してください。 
        </p><p>
          値 <code class="literal">innodb</code> は、以前のバージョンの MySQL と下位互換性があります。 値 <code class="literal">crc32</code> では、より高速に、変更されたすべてのブロックのチェックサムを計算し、ディスク読み取りごとにチェックサムをチェックするアルゴリズムが使用されます。 ブロックを一度に 32 ビットスキャンします。これは、ブロックを一度に 8 ビットスキャンする <code class="literal">innodb</code> チェックサムアルゴリズムより高速です。 値 <code class="literal">none</code> では、ブロックデータに基づいて値が計算されるのではなく、チェックサムフィールドに定数値が書き込まれます。 テーブルスペース内のブロックは、データの変更時に徐々に更新される古いチェックサム値と新しいチェックサム値を混在させて使用できます。テーブルスペース内のブロックが <code class="literal">crc32</code> アルゴリズムを使用するように変更されると、関連付けられたテーブルを以前のバージョンの MySQL で読み取ることはできません。 
        </p><p>
          チェックサムアルゴリズムの厳密な形式では、テーブルスペースで有効だが一致しないチェックサム値が検出されると、エラーが報告されます。 テーブルスペースを初めて設定する場合は、新しいインスタンスでのみ厳密な設定を使用することをお薦めします。 厳密な設定は、ディスク読取り時にすべてのチェックサム値を計算する必要がないため、多少高速です。 
        </p><p>
          次のテーブルに、<code class="literal">none</code>、<code class="literal">innodb</code> および <code class="literal">crc32</code> オプションの値とそれぞれに対応する厳密な値の違いを示します。<code class="literal">none</code>、<code class="literal">innodb</code> および <code class="literal">crc32</code> は、指定されたタイプのチェックサム値を各データブロックに書き込みますが、互換性のために、読取り操作中にブロックを検証するときに他のチェックサム値を受け入れます。 厳密な設定も有効なチェックサム値を受け入れますが、一致しない有効なチェックサム値が検出されるとエラーメッセージを出力します。 厳密な形式を使用すると、インスタンス内のすべての <code class="literal">InnoDB</code> データファイルが同一の <code class="literal">innodb_checksum_algorithm</code> 値で作成される場合に、検証が高速になります。 
        </p><div class="table"><a name="innodb-checksum-algorithm-values"></a><p class="title"><b>表 15.26 許可される innodb_checksum_algorithm 値</b></p><div class="table-contents"><table summary="Permitted values for the innodb_checksum_algorithm variable. The first column defines the checksum value. The second column describes the generated checksum. The third column describes compatible checksums."><col style="width: 20%"><col style="width: 40%"><col style="width: 40%"><thead><tr>
              <th scope="col">値</th>
              <th scope="col">生成されるチェックサム (書き込み時)</th>
              <th scope="col">許可されたチェックサム (読取り時)</th>
            </tr></thead><tbody><tr>
              <th scope="row">none</th>
              <td>定数。</td>
              <td><code class="literal">none</code>、<code class="literal">innodb</code>、または <code class="literal">crc32</code> で生成されるチェックサムのいずれか。</td>
            </tr><tr>
              <th scope="row">innodb</th>
              <td>ソフトウェアで <code class="literal">InnoDB</code> の元のアルゴリズムを使用して計算されたチェックサム。</td>
              <td><code class="literal">none</code>、<code class="literal">innodb</code>、または <code class="literal">crc32</code> で生成されるチェックサムのいずれか。</td>
            </tr><tr>
              <th scope="row">crc32</th>
              <td><code class="literal">crc32</code> アルゴリズムを使用して計算されたチェックサム (ハードウェアの支援を得て実行される可能性もあります)。</td>
              <td><code class="literal">none</code>、<code class="literal">innodb</code>、または <code class="literal">crc32</code> で生成されるチェックサムのいずれか。</td>
            </tr><tr>
              <th scope="row">strict_none</th>
              <td>定数</td>
              <td><code class="literal">none</code>、<code class="literal">innodb</code>、または <code class="literal">crc32</code> で生成されるチェックサムのいずれか。 有効だが一致しないチェックサムが検出されると、<code class="literal">InnoDB</code> はエラーメッセージを出力します。 </td>
            </tr><tr>
              <th scope="row">strict_innodb</th>
              <td>ソフトウェアで <code class="literal">InnoDB</code> の元のアルゴリズムを使用して計算されたチェックサム。</td>
              <td><code class="literal">none</code>、<code class="literal">innodb</code>、または <code class="literal">crc32</code> で生成されるチェックサムのいずれか。 有効だが一致しないチェックサムが検出されると、<code class="literal">InnoDB</code> はエラーメッセージを出力します。 </td>
            </tr><tr>
              <th scope="row">strict_crc32</th>
              <td><code class="literal">crc32</code> アルゴリズムを使用して計算されたチェックサム (ハードウェアの支援を得て実行される可能性もあります)。</td>
              <td><code class="literal">none</code>、<code class="literal">innodb</code>、または <code class="literal">crc32</code> で生成されるチェックサムのいずれか。 有効だが一致しないチェックサムが検出されると、<code class="literal">InnoDB</code> はエラーメッセージを出力します。 </td>
            </tr></tbody></table></div></div><br class="table-break"></li><li class="listitem"><p><a name="sysvar_innodb_cmp_per_index_enabled"></a>
          <code class="literal">innodb_cmp_per_index_enabled</code>
        </p><a class="indexterm" name="idm44761353530816"></a><a class="indexterm" name="idm44761353529248"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_cmp_per_index_enabled"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-cmp-per-index-enabled[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_cmp_per_index_enabled">innodb_cmp_per_index_enabled</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          <code class="literal">INFORMATION_SCHEMA.INNODB_CMP_PER_INDEX</code> テーブルでインデックスごとの圧縮関連の統計を有効にします。 これらの統計は収集にコストがかかる可能性があるため、このオプションは、<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_compression" title="圧縮">compressed</a> テーブルに関連するパフォーマンスチューニング中に開発、テストまたはレプリカインスタンスでのみ有効にします。 
        </p><p>
          詳細は、<a class="xref" href="information-schema.html#information-schema-innodb-cmp-per-index-table" title="26.51.7 INFORMATION_SCHEMA INNODB_CMP_PER_INDEX および INNODB_CMP_PER_INDEX_RESET テーブル">セクション26.51.7「INFORMATION_SCHEMA INNODB_CMP_PER_INDEX および INNODB_CMP_PER_INDEX_RESET テーブル」</a>および<a class="xref" href="innodb-storage-engine.html#innodb-compression-tuning-monitoring" title="15.9.1.4 実行時の InnoDB テーブル圧縮の監視">セクション15.9.1.4「実行時の InnoDB テーブル圧縮の監視」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_commit_concurrency"></a>
          <code class="literal">innodb_commit_concurrency</code>
        </p><a class="indexterm" name="idm44761353499392"></a><a class="indexterm" name="idm44761353497824"></a><a class="indexterm" name="idm44761353495856"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_commit_concurrency"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-commit-concurrency=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_commit_concurrency">innodb_commit_concurrency</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">1000</code></td>
</tr></tbody></table></div><p>
          同時に<a class="link" href="glossary.html#glos_commit" title="コミット">コミット</a>できる<a class="link" href="glossary.html#glos_thread" title="スレッド">スレッド</a>の数です。 値を 0 (デフォルト) にすると、任意の数の<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>を同時にコミットすることが許可されます。 
        </p><p>
          <code class="literal">innodb_commit_concurrency</code> の値は、実行時にゼロからゼロ以外 (またはその逆) に変更できません。 ゼロ以外の値から別のゼロ以外の値に変更することはできます。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_compress_debug"></a>
          <code class="literal">innodb_compress_debug</code>
        </p><a class="indexterm" name="idm44761353461840"></a><a class="indexterm" name="idm44761353460752"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_compress_debug"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-compress-debug=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_compress_debug">innodb_compress_debug</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">none</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">none</code></p><p class="valid-value"><code class="literal">zlib</code></p><p class="valid-value"><code class="literal">lz4</code></p><p class="valid-value"><code class="literal">lz4hc</code></p></td>
</tr></tbody></table></div><p>
          テーブルごとに <code class="literal">COMPRESSION</code> 属性を定義せずに、指定された圧縮アルゴリズムを使用してすべてのテーブルを圧縮します。 このオプションは、デバッグサポートが <code class="option">WITH_DEBUG</code> <span class="command"><strong>CMake</strong></span> オプションを使用してコンパイルされている場合にのみ使用できます。 
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-page-compression" title="15.9.2 InnoDB ページ圧縮">セクション15.9.2「InnoDB ページ圧縮」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_compression_failure_threshold_pct"></a>
          <code class="literal">innodb_compression_failure_threshold_pct</code>
        </p><a class="indexterm" name="idm44761353426480"></a><a class="indexterm" name="idm44761353424880"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_compression_failure_threshold_pct"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-compression-failure-threshold-pct=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_failure_threshold_pct">innodb_compression_failure_threshold_pct</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">5</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">100</code></td>
</tr></tbody></table></div><p>
          高コストの <a class="link" href="glossary.html#glos_compression_failure" title="圧縮失敗">compression failures</a> を回避するために MySQL が <a class="link" href="glossary.html#glos_compression" title="圧縮">compressed</a> ページ内でパディングの追加を開始するテーブルの圧縮失敗率のしきい値をパーセンテージで定義します。 このしきい値を超えると、MySQL は、最大で <code class="literal">innodb_compression_pad_pct_max</code> で指定されたページサイズの割合まで空き領域の量を動的に調整することで、新しい各圧縮済みページ内に追加の空き領域を残し始めます。 値をゼロにすると、圧縮の効率性をモニターするメカニズムが無効になり、パディングの量が動的に調整されます。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-compression-oltp" title="15.9.1.6 OLTP ワークロードの圧縮">セクション15.9.1.6「OLTP ワークロードの圧縮」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_compression_level"></a>
          <code class="literal">innodb_compression_level</code>
        </p><a class="indexterm" name="idm44761353390384"></a><a class="indexterm" name="idm44761353388832"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_compression_level"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-compression-level=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_level">innodb_compression_level</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">6</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">9</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_compression" title="圧縮">圧縮された</a>テーブルおよびインデックスで使用される zlib 圧縮のレベルを指定します。 値を大きくすると、ストレージデバイス上に収容できるデータ量が多くなりますが、圧縮時の CPU オーバーヘッドも多くなるという犠牲が伴います。 値を小さくすると、ストレージ領域がクリティカルでない場合に、CPU のオーバーヘッドを削減できます。それ以外の場合は、データが特に圧縮可能でないと予測されます。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-compression-oltp" title="15.9.1.6 OLTP ワークロードの圧縮">セクション15.9.1.6「OLTP ワークロードの圧縮」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_compression_pad_pct_max"></a>
          <code class="literal">innodb_compression_pad_pct_max</code>
        </p><a class="indexterm" name="idm44761353355648"></a><a class="indexterm" name="idm44761353354080"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_compression_pad_pct_max"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-compression-pad-pct-max=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_pad_pct_max">innodb_compression_pad_pct_max</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">50</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">75</code></td>
</tr></tbody></table></div><p>
          圧縮された各<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>内の空き領域として予約できる最大の割合を指定します。これにより、<a class="link" href="glossary.html#glos_compression" title="圧縮">圧縮された</a>テーブルまたはインデックスが更新され、データが再度圧縮される可能性があるときに、ページ内のデータおよび変更ログを再編成する余地が得られます。 <code class="literal">innodb_compression_failure_threshold_pct</code> がゼロ以外の値に設定され、<a class="link" href="glossary.html#glos_compression_failure" title="圧縮失敗">compression failures</a> のレートがカットオフポイントを通過する場合にのみ適用されます。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-compression-oltp" title="15.9.1.6 OLTP ワークロードの圧縮">セクション15.9.1.6「OLTP ワークロードの圧縮」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_concurrency_tickets"></a>
          <code class="literal">innodb_concurrency_tickets</code>
        </p><a class="indexterm" name="idm44761353319568"></a><a class="indexterm" name="idm44761353318000"></a><a class="indexterm" name="idm44761353316032"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_concurrency_tickets"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-concurrency-tickets=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_concurrency_tickets">innodb_concurrency_tickets</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">5000</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
          同時に <code class="literal">InnoDB</code> に入ることができる<a class="link" href="glossary.html#glos_thread" title="スレッド">スレッド</a>の数を決定します。 スレッドが <code class="literal">InnoDB</code> に入ろうとしたときに、すでにスレッド数が並列実行の制限に達している場合は、そのスレッドがキューに配置されます。 スレッドが <code class="literal">InnoDB</code> に入ることを許可されている場合は、<code class="literal">innodb_concurrency_tickets</code> の値と同じ数の<span class="quote">「<span class="quote">「チケット」</span>」</span>が与えられ、チケットを使い切るまでスレッドは <code class="literal">InnoDB</code> に自由に入ることができます。 それ以降は、スレッドが次に <code class="literal">InnoDB</code> に入ろうとしたときに、再度並列実行チェックの対象となります (キューに入る対象となる可能性もあります)。 デフォルト値は 5000 です。 
        </p><p>
          <code class="literal">innodb_concurrency_tickets</code> 値を小さくすると、1、2 行しか処理する必要のない小規模なトランザクションと、多数の行を処理する大規模なトランザクションが競合する可能性が高くなります。 小さい <code class="literal">innodb_concurrency_tickets</code> 値のデメリットは、大規模なトランザクションが完了する前にキューを何度もループする必要があり、これによりタスクの完了に必要な時間が長くなることです。 
        </p><p>
          <code class="literal">innodb_concurrency_tickets</code> 値を大きくすると、大規模なトランザクションで (<code class="literal">innodb_thread_concurrency</code> で制御される) キューの終了時の位置を待機する時間が短くなり、行を取得する時間が長くなります。 また、大規模なトランザクションでは、タスクを完了するために必要なキューとの間の移動も少なくなります。 <code class="literal">innodb_concurrency_tickets</code> 値を大きくする欠点は、同時に実行する大規模なトランザクションの数が非常に多くなることで、小規模なトランザクションが実行されるまでの待機時間が長くなるため、枯渇する可能性がある点です。 
        </p><p>
          ゼロ以外の <code class="literal">innodb_thread_concurrency</code> 値では、<code class="literal">innodb_concurrency_tickets</code> 値を上下に調整して、大規模なトランザクションと小規模なトランザクションの間の最適なバランスを見つける必要がある場合があります。 <code class="literal">SHOW ENGINE INNODB STATUS</code> レポートには、キューを通過する現時点で実行中のトランザクション用に残されているチケットの数が表示されます。 このデータは、<code class="literal">INFORMATION_SCHEMA.INNODB_TRX</code> テーブルの <code class="literal">TRX_CONCURRENCY_TICKETS</code> カラムから取得することもできます。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-thread_concurrency" title="15.8.4 InnoDB のスレッド並列性の構成">セクション15.8.4「InnoDB のスレッド並列性の構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_data_file_path"></a>
          <code class="literal">innodb_data_file_path</code>
        </p><a class="indexterm" name="idm44761353264464"></a><a class="indexterm" name="idm44761353262912"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_data_file_path"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-data-file-path=file_name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path">innodb_data_file_path</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ibdata1:12M:autoextend</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> システムテーブルスペースデータファイルの名前、サイズおよび属性を定義します。 <code class="literal">innodb_data_file_path</code> の値を指定しない場合、デフォルトの動作では、12MB を少し超える単一の自動拡張データファイルが <code class="filename">ibdata1</code> という名前で作成されます。 
        </p><p>
          データファイル指定の完全な構文には、ファイル名、ファイルサイズ、<code class="literal">autoextend</code> 属性および <code class="literal">max</code> 属性が含まれます:
        </p><pre class="programlisting"><em class="replaceable"><code>file_name</code></em>:<em class="replaceable"><code>file_size</code></em>[:autoextend[:max:<em class="replaceable"><code>max_file_size</code></em>]]
</pre><p>
          ファイルサイズは、<code class="literal">K</code>、<code class="literal">M</code> または <code class="literal">G</code> をサイズ値に追加することで、KB、MB または GB 単位で指定します。 データファイルのサイズを KB 単位で指定する場合は、1024 の倍数で指定します。 それ以外の場合、KB 値は最も近いメガバイト (MB) 境界に丸められます。 ファイルサイズの合計は、12MB 以上である必要があります。 
        </p><p>
          その他の構成情報については、<a class="xref" href="innodb-storage-engine.html#innodb-startup-data-file-configuration" title="システムテーブルスペースデータファイル構成">システムテーブルスペースデータファイル構成</a> を参照してください。 サイズ変更の手順は、<a class="xref" href="innodb-storage-engine.html#innodb-resize-system-tablespace" title="システムテーブルスペースのサイズ変更">システムテーブルスペースのサイズ変更</a> を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_data_home_dir"></a>
          <code class="literal">innodb_data_home_dir</code>
        </p><a class="indexterm" name="idm44761353226000"></a><a class="indexterm" name="idm44761353224448"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_data_home_dir"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-data-home-dir=dir_name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir">innodb_data_home_dir</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>ディレクトリ名</td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">system tablespace</a> データファイルのディレクトリパスの共通部分。 デフォルト値は、MySQL の <code class="filename">data</code> ディレクトリです。 設定が絶対パスで定義されていないかぎり、この設定は <code class="literal">innodb_data_file_path</code> 設定と連結されます。 
        </p><p>
          <code class="literal">innodb_data_home_dir</code> の値を指定する場合は、末尾にスラッシュが必要です。 例: 
        </p><pre class="programlisting">[mysqld]
innodb_data_home_dir = /path/to/myibdata/
</pre><p>
          この設定は、<a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースの場所には影響しません。
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-init-startup-configuration" title="15.8.1 InnoDB の起動構成">セクション15.8.1「InnoDB の起動構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_ddl_log_crash_reset_debug"></a>
          <code class="literal">innodb_ddl_log_crash_reset_debug</code>
        </p><a class="indexterm" name="idm44761353193600"></a><a class="indexterm" name="idm44761353192016"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_ddl_log_crash_reset_debug"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-ddl-log-crash-reset-debug[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ddl_log_crash_reset_debug">innodb_ddl_log_crash_reset_debug</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          DDL ログクラッシュインサーションカウンタを 1 にリセットするには、このデバッグオプションを有効にします。 このオプションは、デバッグサポートが <code class="option">WITH_DEBUG</code> <span class="command"><strong>CMake</strong></span> オプションを使用してコンパイルされている場合にのみ使用できます。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_deadlock_detect"></a>
          <code class="literal">innodb_deadlock_detect</code>
        </p><a class="indexterm" name="idm44761353165344"></a><a class="indexterm" name="idm44761353163792"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_deadlock_detect"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-deadlock-detect[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_deadlock_detect">innodb_deadlock_detect</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
          このオプションは、デッドロック検出を無効にするために使用します。 同時実行性の高いシステムでは、多数のスレッドが同じロックを待機している場合、デッドロック検出によって速度が低下する可能性があります。 デッドロック検出を無効にし、デッドロック発生時のトランザクションロールバックの <code class="literal">innodb_lock_wait_timeout</code> 設定に依存する方が効率的な場合があります。 
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-deadlock-detection" title="15.7.5.2 デッドロック検出">セクション15.7.5.2「デッドロック検出」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_dedicated_server"></a>
          <code class="literal">innodb_dedicated_server</code>
        </p><a class="indexterm" name="idm44761353136320"></a><a class="indexterm" name="idm44761353134768"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_dedicated_server"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-dedicated-server[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_dedicated_server">innodb_dedicated_server</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          <code class="literal">innodb_dedicated_server</code> が有効な場合、<code class="literal">InnoDB</code> は次の変数を自動的に構成します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">innodb_buffer_pool_size</code>
            </p></li><li class="listitem"><p>
              <code class="literal">innodb_log_file_size</code>
            </p></li><li class="listitem"><p>
              <code class="literal">innodb_log_files_in_group</code> (MySQL 8.0.14 の時点)
            </p></li><li class="listitem"><p>
              <code class="literal">innodb_flush_method</code>
            </p></li></ul></div><p>
          MySQL インスタンスが、使用可能なすべてのシステムリソースを使用できる専用サーバーに存在する場合にのみ、<code class="literal">innodb_dedicated_server</code> を有効にすることを検討してください。 MySQL インスタンスが他のアプリケーションとシステムリソースを共有している場合、<code class="literal">innodb_dedicated_server</code> を有効にすることはお薦めしません。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-dedicated-server" title="15.8.12 専用 MySQL Server の自動構成の有効化">セクション15.8.12「専用 MySQL Server の自動構成の有効化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_default_row_format"></a>
          <code class="literal">innodb_default_row_format</code>
        </p><a class="indexterm" name="idm44761353096784"></a><a class="indexterm" name="idm44761353095216"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_default_row_format"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-default-row-format=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_default_row_format">innodb_default_row_format</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">DYNAMIC</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">DYNAMIC</code></p><p class="valid-value"><code class="literal">COMPACT</code></p><p class="valid-value"><code class="literal">REDUNDANT</code></p></td>
</tr></tbody></table></div><p>
          <code class="literal">innodb_default_row_format</code> オプションは、<code class="literal">InnoDB</code> テーブルおよびユーザー作成一時テーブルのデフォルトの行形式を定義します。 デフォルト設定は <code class="literal">DYNAMIC</code> です。 許可されるその他の値は、<code class="literal">COMPACT</code> および <code class="literal">REDUNDANT</code> です。 <a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">system tablespace</a> での使用がサポートされていない <code class="literal">COMPRESSED</code> 行フォーマットは、デフォルトとして定義できません。 
        </p><p>
          新しく作成されたテーブルでは、<code class="literal">ROW_FORMAT</code> オプションが明示的に指定されていない場合、または <code class="literal">ROW_FORMAT=DEFAULT</code> が使用されている場合に、<code class="literal">innodb_default_row_format</code> で定義された行形式が使用されます。
        </p><p>
          <code class="literal">ROW_FORMAT</code> オプションが明示的に指定されていない場合、または <code class="literal">ROW_FORMAT=DEFAULT</code> が使用されている場合は、テーブルを再構築する操作によって、テーブルの行形式も <code class="literal">innodb_default_row_format</code> で定義された形式に暗黙的に変更されます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-row-format-defining" title="テーブルの行形式の定義">テーブルの行形式の定義</a>を参照してください。 
        </p><p>
          クエリーを処理するためにサーバーによって作成された内部 <code class="literal">InnoDB</code> 一時テーブルは、<code class="literal">innodb_default_row_format</code> の設定に関係なく、<code class="literal">DYNAMIC</code> 行形式を使用します。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_directories"></a>
          <code class="literal">innodb_directories</code>
        </p><a class="indexterm" name="idm44761353049264"></a><a class="indexterm" name="idm44761353047712"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_directories"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-directories=dir_name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_directories">innodb_directories</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>ディレクトリ名</td>
</tr></tbody></table></div><p>
          起動時にテーブルスペースファイルをスキャンするディレクトリを定義します。 このオプションは、サーバーがオフラインのときにテーブルスペースファイルを新しい場所に移動またはリストアする場合に使用します。 また、絶対パスを使用して作成されたテーブルスペースファイル、またはデータディレクトリの外部にあるテーブルスペースファイルのディレクトリを指定するためにも使用されます。 
        </p><p>
          クラッシュリカバリ中のテーブルスペースの検出は、redo ログで参照されるテーブルスペースを識別するために <code class="literal">innodb_directories</code> 設定に依存します。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-recovery-tablespace-discovery" title="クラッシュリカバリ中のテーブルスペースの検出">クラッシュリカバリ中のテーブルスペースの検出</a>を参照してください。 
        </p><p>
          <code class="literal">innodb_data_home_dir</code>、<code class="literal">innodb_undo_directory</code> および <code class="literal">datadir</code> によって定義されたディレクトリは、<code class="literal">innodb_directories</code> オプションが明示的に指定されているかどうかに関係なく、起動時にスキャンするディレクトリのリストを作成するときに <code class="literal">innodb_directories</code> 引数値に自動的に追加されます。
        </p><p>
          <code class="literal">innodb_directories</code> は、起動コマンドまたは MySQL オプションファイルでオプションとして指定できます。 一部のコマンドインタプリタではセミコロン (;) は特殊文字として解釈されるため、引数値の前後に引用符が使用されます。 (たとえば UNIX シェルでは、これはコマンド終端記号として扱われます。) 
        </p><p>
          起動コマンド:
        </p><pre class="programlisting">mysqld --innodb-directories="<em class="replaceable"><code>directory_path_1</code></em>;<em class="replaceable"><code>directory_path_2</code></em>"
</pre><p>
          MySQL オプションファイル:
        </p><pre class="programlisting">[mysqld]
innodb_directories="<em class="replaceable"><code>directory_path_1</code></em>;<em class="replaceable"><code>directory_path_2</code></em>"
</pre><p>
          ワイルドカード式は、ディレクトリの指定には使用できません。
        </p><p>
          <code class="literal">innodb_directories</code> スキャンは、指定されたディレクトリのサブディレクトリも走査します。 重複するディレクトリおよびサブディレクトリは、スキャンされるディレクトリのリストから破棄されます。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-moving-data-files-offline" title="15.6.3.6 サーバーがオフラインのときのテーブルスペースファイルの移動">セクション15.6.3.6「サーバーがオフラインのときのテーブルスペースファイルの移動」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_disable_sort_file_cache"></a>
          <code class="literal">innodb_disable_sort_file_cache</code>
        </p><a class="indexterm" name="idm44761353006464"></a><a class="indexterm" name="idm44761353004896"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_disable_sort_file_cache"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-disable-sort-file-cache[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_disable_sort_file_cache">innodb_disable_sort_file_cache</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          マージソート一時ファイルのオペレーティングシステムファイルシステムキャッシュを無効にします。 その結果、このようなファイルが <code class="literal">O_DIRECT</code> の同等のものとともに開きます。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_doublewrite"></a>
          <code class="literal">innodb_doublewrite</code>
        </p><a class="indexterm" name="idm44761352979040"></a><a class="indexterm" name="idm44761352977488"></a><a class="indexterm" name="idm44761352975600"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_doublewrite"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-doublewrite[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_doublewrite">innodb_doublewrite</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
          <code class="literal">innodb_doublewrite</code> 変数は、二重書込みバッファを有効にするかどうかを制御します。 ほとんどの場合、デフォルトで有効になっています。 二重書込みバッファを無効にするには、<code class="literal">innodb_doublewrite</code> を 0 に設定するか、<code class="literal">--skip-innodb-doublewrite</code> でサーバーを起動します。 たとえば、ベンチマークの実行時などのように、データ整合性よりもパフォーマンスに関心がある場合は、二重書込みバッファを無効にすることを検討してください。 
        </p><p>
          二重書き込みバッファーがアトミック書き込みをサポートする Fusion-io デバイス上にある場合、二重書き込みバッファーは自動的に無効になり、代わりに Fusion-io アトミック書き込みを使用してデータファイル書き込みが実行されます。 ただし、<code class="literal">innodb_doublewrite</code> 設定はグローバルであることに注意してください。 二重書き込みバッファーが無効になっている場合、Fusion-io ハードウェア上に存在しないデータファイルを含むすべてのデータファイルに対して無効になります。 この機能は Fusion-io ハードウェアでのみサポートされ、Linux の Fusion-io NVMFS でのみ有効になります。 この機能を最大限に活用するには、<code class="literal">O_DIRECT</code> の <code class="literal">innodb_flush_method</code> 設定をお薦めします。 
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-doublewrite-buffer" title="15.6.4 二重書き込みバッファー">セクション15.6.4「二重書き込みバッファー」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_doublewrite_batch_size"></a>
          <code class="literal">innodb_doublewrite_batch_size</code>
        </p><a class="indexterm" name="idm44761352942352"></a><a class="indexterm" name="idm44761352941232"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_doublewrite_batch_size"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-doublewrite-batch-size=#</code></td>
</tr><tr><th>導入</th>
<td>8.0.20</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_doublewrite_batch_size">innodb_doublewrite_batch_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">256</code></td>
</tr></tbody></table></div><p>
          バッチで書き込む二重書込みページの数を定義します。
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-doublewrite-buffer" title="15.6.4 二重書き込みバッファー">セクション15.6.4「二重書き込みバッファー」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_doublewrite_dir"></a>
          <code class="literal">innodb_doublewrite_dir</code>
        </p><a class="indexterm" name="idm44761352908256"></a><a class="indexterm" name="idm44761352907168"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_doublewrite_dir"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-doublewrite-dir=dir_name</code></td>
</tr><tr><th>導入</th>
<td>8.0.20</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_doublewrite_dir">innodb_doublewrite_dir</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>ディレクトリ名</td>
</tr></tbody></table></div><p>
          二重書込みファイルのディレクトリを定義します。 ディレクトリが指定されていない場合、二重書込みファイルが <code class="literal">innodb_data_home_dir</code> ディレクトリに作成され、指定されていない場合はデータディレクトリにデフォルト設定されます。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-doublewrite-buffer" title="15.6.4 二重書き込みバッファー">セクション15.6.4「二重書き込みバッファー」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_doublewrite_files"></a>
          <code class="literal">innodb_doublewrite_files</code>
        </p><a class="indexterm" name="idm44761352880176"></a><a class="indexterm" name="idm44761352879056"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_doublewrite_files"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-doublewrite-files=#</code></td>
</tr><tr><th>導入</th>
<td>8.0.20</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_doublewrite_files">innodb_doublewrite_files</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">innodb_buffer_pool_instances * 2</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">2</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">256</code></td>
</tr></tbody></table></div><p>
          二重書込みファイルの数を定義します。 デフォルトでは、バッファープールインスタンスごとに 2 つの二重書き込みファイルが作成されます。 
        </p><p>
          少なくとも 2 つの二重書込みファイルがあります。 二重書込みファイルの最大数は、バッファプールインスタンスの 2 倍です。 (バッファープールインスタンスの数は、<code class="literal">innodb_buffer_pool_instances</code> 変数によって制御されます。) 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-doublewrite-buffer" title="15.6.4 二重書き込みバッファー">セクション15.6.4「二重書き込みバッファー」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_doublewrite_pages"></a>
          <code class="literal">innodb_doublewrite_pages</code>
        </p><a class="indexterm" name="idm44761352843872"></a><a class="indexterm" name="idm44761352842752"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_doublewrite_pages"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-doublewrite-pages=#</code></td>
</tr><tr><th>導入</th>
<td>8.0.20</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_doublewrite_pages">innodb_doublewrite_pages</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">innodb_write_io_threads value</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">innodb_write_io_threads value</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">512</code></td>
</tr></tbody></table></div><p>
          バッチ書込みのスレッド当たりの二重書込みページの最大数を定義します。 値が指定されていない場合、<code class="literal">innodb_doublewrite_pages</code> は <code class="literal">innodb_write_io_threads</code> 値に設定されます。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-doublewrite-buffer" title="15.6.4 二重書き込みバッファー">セクション15.6.4「二重書き込みバッファー」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_extend_and_initialize"></a>
          <code class="literal">innodb_extend_and_initialize</code>
        </p><a class="indexterm" name="idm44761352807552"></a><a class="indexterm" name="idm44761352805984"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_extend_and_initialize"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb=extend-and-initialize[={OFF|ON}]</code></td>
</tr><tr><th>導入</th>
<td>8.0.22</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_extend_and_initialize">innodb_extend_and_initialize</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
          Linux システムの file-per-table テーブルスペースおよび一般テーブルスペースへの領域の割当て方法を制御します。
        </p><p>
          有効にすると、<code class="literal">InnoDB</code> は新しく割り当てられたページに NULL を書き込みます。 無効にすると、領域は <code class="literal">posix_fallocate()</code> コールを使用して割り当てられます。このコールは、物理的に NULL を書き込まずに領域を予約します。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-optimize-tablespace-page-allocation" title="15.6.3.8 Linux でのテーブルスペースの領域割当ての最適化">セクション15.6.3.8「Linux でのテーブルスペースの領域割当ての最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_fast_shutdown"></a>
          <code class="literal">innodb_fast_shutdown</code>
        </p><a class="indexterm" name="idm44761352775232"></a><a class="indexterm" name="idm44761352773680"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_fast_shutdown"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-fast-shutdown=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_fast_shutdown">innodb_fast_shutdown</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">0</code></p><p class="valid-value"><code class="literal">1</code></p><p class="valid-value"><code class="literal">2</code></p></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_shutdown" title="シャットダウン">シャットダウン</a>モードです。 値が 0 の場合、<code class="literal">InnoDB</code> は、停止前に <a class="link" href="glossary.html#glos_slow_shutdown" title="低速シャットダウン">slow shutdown</a>、完全な <a class="link" href="glossary.html#glos_purge" title="パージ">purge</a> および変更バッファのマージを実行します。 この値を 1 (デフォルト) にすると、<code class="literal">InnoDB</code> はシャットダウン時に、これらの操作をスキップします。このプロセスは、<a class="link" href="glossary.html#glos_fast_shutdown" title="高速シャットダウン">高速シャットダウン</a>と呼ばれます。 この値を 2 にすると、<code class="literal">InnoDB</code> は MySQL がクラッシュした場合と同様に、そのログをフラッシュし、コールドシャットダウンを実行します。コミットされていないトランザクションは失われませんが、<a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>操作によって次回の起動時間が長くなります。 
        </p><p>
          低速シャットダウンには数分間かかる可能性があり、大量のデータがバッファーに存在する極端なケースでは、数時間かかる可能性もあります。 MySQL のメジャーリリース間でアップグレードまたはダウングレードを行う前には、アップグレードプロセスによってファイル形式が更新される場合に備えて、すべてのデータファイルが完全に準備されるように、低速シャットダウン技術を使用してください。 
        </p><p>
          データが破損するリスクがある場合に、完全な最速のシャットダウンを行うには、緊急事態またはトラブルシューティングの状況で <code class="literal">innodb_fast_shutdown=2</code> を使用してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_fil_make_page_dirty_debug"></a>
          <code class="literal">innodb_fil_make_page_dirty_debug</code>
        </p><a class="indexterm" name="idm44761352733488"></a><a class="indexterm" name="idm44761352732368"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_fil_make_page_dirty_debug"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-fil-make-page-dirty-debug=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_fil_make_page_dirty_debug">innodb_fil_make_page_dirty_debug</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">2**32-1</code></td>
</tr></tbody></table></div><p>
          デフォルトでは、<code class="literal">innodb_fil_make_page_dirty_debug</code> をテーブルスペースの ID に設定すると、テーブルスペースの最初のページがすぐに使用済になります。 <code class="literal">innodb_saved_page_number_debug</code> がデフォルト以外の値に設定されている場合、<code class="literal">innodb_fil_make_page_dirty_debug</code> を設定すると、指定したページがダーティになります。 <code class="literal">innodb_fil_make_page_dirty_debug</code> オプションは、デバッグサポートが <code class="option">WITH_DEBUG</code> <span class="command"><strong>CMake</strong></span> オプションを使用してコンパイルされている場合にのみ使用できます。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_file_per_table"></a>
          <code class="literal">innodb_file_per_table</code>
        </p><a class="indexterm" name="idm44761352698880"></a><a class="indexterm" name="idm44761352697328"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_file_per_table"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-file-per-table[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table">innodb_file_per_table</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
          <code class="literal">innodb_file_per_table</code> が有効な場合、テーブルはデフォルトで file-per-table テーブルスペースに作成されます。 無効にすると、デフォルトでシステムテーブルスペースにテーブルが作成されます。 file-per-table テーブルスペースについては、<a class="xref" href="innodb-storage-engine.html#innodb-file-per-table-tablespaces" title="15.6.3.2 File-Per-Table テーブルスペース">セクション15.6.3.2「File-Per-Table テーブルスペース」</a> を参照してください。 <code class="literal">InnoDB</code> システムテーブルスペースの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-system-tablespace" title="15.6.3.1 システムテーブルスペース">セクション15.6.3.1「システムテーブルスペース」</a> を参照してください。 
        </p><p>
          <code class="literal">innodb_file_per_table</code> 変数は、実行時に <code class="literal">SET GLOBAL</code> ステートメントを使用して構成するか、起動時にコマンドラインで指定するか、またはオプションファイルで指定できます。 実行時の構成には、グローバルシステム変数を設定するのに十分な権限 (<a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a> を参照) が必要で、すべての接続の操作にすぐに影響します。 
        </p><p>
          file-per-table テーブルスペースに存在するテーブルが切り捨てられるか削除されると、解放された領域がオペレーティングシステムに戻されます。 システムテーブルスペースに存在するテーブルの切捨てまたは削除では、システムテーブルスペースの領域のみが解放されます。 システムテーブルスペースのデータファイルは縮小しないため、システムテーブルスペースの空き領域は <code class="literal">InnoDB</code> データに再度使用できますが、オペレーティングシステムには戻されません。 
        </p><p>
          <code class="literal">innodb_file_per-table</code> 設定は、一時テーブルの作成には影響しません。 MySQL 8.0.14 では、一時テーブルはセッション一時テーブルスペースに作成され、その前にグローバル一時テーブルスペースに作成されます。 <a class="xref" href="innodb-storage-engine.html#innodb-temporary-tablespace" title="15.6.3.5 一時テーブルスペース">セクション15.6.3.5「一時テーブルスペース」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_fill_factor"></a>
          <code class="literal">innodb_fill_factor</code>
        </p><a class="indexterm" name="idm44761352660112"></a><a class="indexterm" name="idm44761352658560"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_fill_factor"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-fill-factor=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_fill_factor">innodb_fill_factor</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">100</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">10</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">100</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> では、インデックスの作成または再構築時にバルクロードが実行されます。 このインデックス作成方法は、<span class="quote">「<span class="quote">「ソートされたインデックス構築」</span>」</span>と呼ばれます。 
        </p><p>
          <code class="literal">innodb_fill_factor</code> では、ソートされたインデックスの作成時に入力される各 B ツリーページ上の領域の割合が定義され、将来のインデックスの増加のために予約されている残りの領域が使用されます。 たとえば、<code class="literal">innodb_fill_factor</code> を 80 に設定すると、将来のインデックス増加のために各 B ツリーページの領域の 20% が予約されます。 実際の割合は異なる場合があります。 <code class="literal">innodb_fill_factor</code> 設定は、強い制限ではなくヒントとして解釈されます。 
        </p><p>
          <code class="literal">innodb_fill_factor</code> を 100 に設定すると、クラスタ化されたインデックスページの領域の 1/16 は将来のインデックスの増加に備えて解放されます。
        </p><p>
          <code class="literal">innodb_fill_factor</code> は、B ツリーリーフページと非リーフページの両方に適用されます。 <code class="literal">TEXT</code> または <code class="literal">BLOB</code> エントリに使用される外部ページには適用されません。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#sorted-index-builds" title="15.6.2.3 ソートされたインデックス構築">セクション15.6.2.3「ソートされたインデックス構築」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_flush_log_at_timeout"></a>
          <code class="literal">innodb_flush_log_at_timeout</code>
        </p><a class="indexterm" name="idm44761352616144"></a><a class="indexterm" name="idm44761352614576"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_flush_log_at_timeout"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-flush-log-at-timeout=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_timeout">innodb_flush_log_at_timeout</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">2700</code></td>
</tr></tbody></table></div><p>
          <em class="replaceable"><code>N</code></em> 秒ごとにログを書き込み、フラッシュします。<code class="literal">innodb_flush_log_at_timeout</code> では、フラッシュを減らし、バイナリロググループのコミットのパフォーマンスへの影響を回避するために、フラッシュ間のタイムアウト期間を増やすことができます。 <code class="literal">innodb_flush_log_at_timeout</code> のデフォルト設定は 1 秒に 1 回です。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_flush_log_at_trx_commit"></a>
          <code class="literal">innodb_flush_log_at_trx_commit</code>
        </p><a class="indexterm" name="idm44761352582032"></a><a class="indexterm" name="idm44761352580464"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_flush_log_at_trx_commit"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-flush-log-at-trx-commit=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_trx_commit">innodb_flush_log_at_trx_commit</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">0</code></p><p class="valid-value"><code class="literal">1</code></p><p class="valid-value"><code class="literal">2</code></p></td>
</tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_commit" title="コミット">commit</a> 操作に対する厳密な <a class="link" href="glossary.html#glos_acid" title="ACID">ACID</a> コンプライアンスと、コミット関連の I/O 操作がバッチで再配置および実行される場合に可能なパフォーマンスのバランスを制御します。 デフォルト値を変更することでパフォーマンスを向上できますが、クラッシュ時にトランザクションが失われる可能性があります。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              ACID に完全に準拠するには、デフォルト設定の 1 が必要です。 ログは、トランザクションのコミットごとにディスクに書き込まれ、フラッシュされます。 
            </p></li><li class="listitem"><p>
              0 に設定すると、ログは 1 秒に 1 回書き込まれ、ディスクにフラッシュされます。 ログがフラッシュされていないトランザクションはクラッシュ時に失われる可能性があります。 
            </p></li><li class="listitem"><p>
              2 に設定すると、各トランザクションのコミット後にログが書き込まれ、1 秒に 1 回ディスクにフラッシュされます。 ログがフラッシュされていないトランザクションはクラッシュ時に失われる可能性があります。 
            </p></li><li class="listitem"><p>
              設定 0 および 2 の場合、秒単位のフラッシュは 100% 保証されません。 フラッシュは、DDL 変更や、<code class="literal">innodb_flush_log_at_trx_commit</code> 設定とは関係なくログがフラッシュされる原因となるその他の内部 <code class="literal">InnoDB</code> アクティビティが原因で頻繁に発生し、スケジューリングの問題が原因で頻繁に発生しない場合があります。 ログが 1 秒に 1 回フラッシュされると、クラッシュ時に最大 1 秒のトランザクションが失われる可能性があります。 ログが 1 秒に 1 回以上フラッシュされるか、それほど頻繁にフラッシュされない場合、失われる可能性のあるトランザクションの量はそれに応じて異なります。 
            </p></li><li class="listitem"><p>
              ログのフラッシュ頻度は <code class="literal">innodb_flush_log_at_timeout</code> によって制御されます。これにより、ログのフラッシュ頻度を <em class="replaceable"><code>N</code></em> 秒 (<em class="replaceable"><code>N</code></em> は <code class="literal">1 ... 2700</code> で、デフォルト値は 1) に設定できます。 ただし、予期しない <span class="command"><strong>mysqld</strong></span> プロセスの終了によって、最大 <em class="replaceable"><code>N</code></em> 秒のトランザクションが消去される可能性があります。 
            </p></li><li class="listitem"><p>
              DDL 変更およびその他の内部 <code class="literal">InnoDB</code> アクティビティは、<code class="literal">innodb_flush_log_at_trx_commit</code> 設定とは関係なくログをフラッシュします。
            </p></li><li class="listitem"><p>
              <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">crash recovery</a> は、<code class="literal">innodb_flush_log_at_trx_commit</code> の設定に関係なく機能します。 トランザクションは完全に適用されるか、完全に消去されるかのいずれかです。 
            </p></li></ul></div><p>
          トランザクションで <code class="literal">InnoDB</code> が使用されるレプリケーションセットアップの持続性および一貫性を保つ場合:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              バイナリロギングが有効になっている場合は、<code class="literal">sync_binlog=1</code> を設定します。
            </p></li><li class="listitem"><p>
              常に <code class="literal">innodb_flush_log_at_trx_commit=1</code> を設定します。
            </p></li></ul></div><p>
          予期しない停止に対して最も回復可能なレプリカの設定の組合せの詳細は、<a class="xref" href="replication.html#replication-solutions-unexpected-replica-halt" title="17.4.2 レプリカの予期しない停止の処理">セクション17.4.2「レプリカの予期しない停止の処理」</a> を参照してください。
        </p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注意</div><p>
            多くのオペレーティングシステムや一部のディスクハードウェアは、ディスクへのフラッシュ操作を行なったと欺きます。 フラッシュが行われていなくても、行われたと <span class="command"><strong>mysqld</strong></span> に通知される可能性があります。 この場合、推奨設定であってもトランザクションの永続性は保証されず、最悪の場合は停電によって <code class="literal">InnoDB</code> データが破損する可能性があります。 バッテリーバックアップのディスクキャッシュを SCSI ディスクコントローラ内やディスク自体で使用すると、ファイルフラッシュの速度が上がり、操作が安全になります。 ハードウェアキャッシュ内のディスク書き込みのキャッシュを無効にすることもできます。 
          </p></div></li><li class="listitem"><p><a name="sysvar_innodb_flush_method"></a>
          <code class="literal">innodb_flush_method</code>
        </p><a class="indexterm" name="idm44761352518880"></a><a class="indexterm" name="idm44761352517328"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_flush_method"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-flush-method=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_method">innodb_flush_method</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr><tr><th>デフォルト値 (Unix)</th>
<td><code class="literal">fsync</code></td>
</tr><tr><th>デフォルト値 (Windows)</th>
<td><code class="literal">unbuffered</code></td>
</tr><tr><th>有効な値 (Unix)</th>
<td><p class="valid-value"><code class="literal">fsync</code></p><p class="valid-value"><code class="literal">O_DSYNC</code></p><p class="valid-value"><code class="literal">littlesync</code></p><p class="valid-value"><code class="literal">nosync</code></p><p class="valid-value"><code class="literal">O_DIRECT</code></p><p class="valid-value"><code class="literal">O_DIRECT_NO_FSYNC</code></p></td>
</tr><tr><th>有効な値 (Windows)</th>
<td><p class="valid-value"><code class="literal">unbuffered</code></p><p class="valid-value"><code class="literal">normal</code></p></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_data_files" title="データファイル">data files</a> および <a class="link" href="glossary.html#glos_log_file" title="ログファイル">log files</a> への <a class="link" href="glossary.html#glos_flush" title="フラッシュ">flush</a> データに使用される方法を定義します。これは I/O スループットに影響する可能性があります。
        </p><p>
          Unix に似たシステムでは、デフォルト値は <code class="literal">fsync</code> です。 Windows では、デフォルト値は <code class="literal">unbuffered</code> です。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            MySQL 8.0 では、<code class="literal">innodb_flush_method</code> オプションを数値で指定できます。
          </p></div><p>
          Unix に似たシステムの <code class="literal">innodb_flush_method</code> オプションには、次のものがあります:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">fsync</code> または <code class="literal">0</code>: <code class="literal">InnoDB</code> は、<code class="literal">fsync()</code> システムコールを使用して、データファイルとログファイルの両方をフラッシュします。<code class="literal">fsync</code> がデフォルト設定です。
            </p></li><li class="listitem"><p>
              <code class="literal">O_DSYNC</code> または <code class="literal">1</code>: <code class="literal">InnoDB</code> では、<code class="literal">O_SYNC</code> を使用してログファイルをオープンおよびフラッシュし、<code class="literal">fsync()</code> を使用してデータファイルをフラッシュします。 さまざまな種類の Unix で問題が発生しているため、<code class="literal">InnoDB</code> では直接 <code class="literal">O_DSYNC</code> が使用されません。 
            </p></li><li class="listitem"><p>
              <code class="literal">littlesync</code> または <code class="literal">2</code>: このオプションは内部パフォーマンステストに使用され、現在はサポートされていません。 独自のリスクで使用します。 
            </p></li><li class="listitem"><p>
              <code class="literal">nosync</code> または <code class="literal">3</code>: このオプションは内部パフォーマンステストに使用され、現在はサポートされていません。 独自のリスクで使用します。 
            </p></li><li class="listitem"><p>
              <code class="literal">O_DIRECT</code> または <code class="literal">4</code>: <code class="literal">InnoDB</code> では、<code class="literal">O_DIRECT</code> (または Solaris 上の <code class="literal">directio()</code>) を使用してデータファイルを開き、<code class="literal">fsync()</code> を使用してデータファイルとログファイルの両方をフラッシュします。 このオプションは、一部の GNU/Linux バージョン、FreeBSD、および Solaris で使用可能です。 
            </p></li><li class="listitem"><p>
              <code class="literal">O_DIRECT_NO_FSYNC</code>: <code class="literal">InnoDB</code> は、I/O,のフラッシュ中に <code class="literal">O_DIRECT</code> を使用しますが、書込み操作のたびに <code class="literal">fsync()</code> システムコールをスキップします。
            </p><p>
              MySQL 8.0.14 より前では、この設定は XFS や EXT4 などのファイルシステムには適していません。これらのファイルシステムでは、<code class="literal">fsync()</code> システムコールを使用してファイルシステムメタデータの変更を同期する必要があります。 ファイルシステムのメタデータ変更を同期するためにファイルシステムで <code class="literal">fsync()</code> システムコールが必要かどうかがわからない場合は、かわりに <code class="literal">O_DIRECT</code> を使用します。 
            </p><p>
              MySQL 8.0.14 の時点では、<code class="literal">fsync()</code> は、新しいファイルの作成後、ファイルサイズの増加後およびファイルのクローズ後にコールされ、ファイルシステムメタデータの変更が確実に同期されます。 各書込み操作の後も、<code class="literal">fsync()</code> システムコールはスキップされます。 
            </p><p>
              redo ログファイルとデータファイルが異なるストレージデバイスに存在し、データファイルの書込みがバッテリバックされていないデバイスキャッシュからフラッシュされる前に予期しない終了が発生した場合、データが失われる可能性があります。 redo ログファイルおよびデータファイルに別の記憶域デバイスを使用する場合、およびデータファイルがバッテリバックアップされていないキャッシュを持つデバイスに存在する場合は、かわりに <code class="literal">O_DIRECT</code> を使用します。 
            </p></li></ul></div><p>
          Windows システム用の <code class="literal">innodb_flush_method</code> オプションには、次のものがあります:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">unbuffered</code> または <code class="literal">0</code>: <code class="literal">InnoDB</code> は、シミュレートされた非同期 I/O およびバッファなし I/O を使用します。
            </p></li><li class="listitem"><p>
              <code class="literal">normal</code> または <code class="literal">1</code>: <code class="literal">InnoDB</code> は、シミュレートされた非同期 I/O およびバッファされた I/O を使用します。
            </p></li></ul></div><p>
          各設定がパフォーマンスに与える影響は、ハードウェア構成およびワークロードによって異なります。 使用する設定を決定したり、デフォルト設定のままにするかどうかを決定したりするには、特定の構成でベンチマークを実施します。 設定ごとに <code class="literal">fsync()</code> 呼び出しの全体数を確認するには、<code class="literal">Innodb_data_fsyncs</code> ステータス変数を調査します。 ワークロードに読み取り操作と書き込み操作を混在させると、一部の設定での実行が影響を受ける可能性があります。 たとえば、ハードウェア RAID コントローラとバッテリバックアップ式書き込みキャッシュを備えたシステムでは、<code class="literal">O_DIRECT</code> は、<code class="literal">InnoDB</code> バッファープールとオペレーティングシステムのファイルシステムキャッシュの間の二重バッファリングを回避するのに役立ちます。 <code class="literal">InnoDB</code> のデータファイルとログファイルが SAN 上に配置されている一部のシステムでは、大部分の <code class="literal">SELECT</code> ステートメントを含む読み取り負荷の高いワークロードで、デフォルト値または <code class="literal">O_DSYNC</code> の速度が速くなる可能性があります。 このパラメータは、必ず、本番環境が反映されたハードウェアおよびワークロードでテストしてください。 一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8 InnoDB ディスク I/O の最適化">セクション8.5.8「InnoDB ディスク I/O の最適化」</a>を参照してください。 
        </p><p>
          <code class="literal">innodb_dedicated_server</code> が有効な場合、<code class="literal">innodb_flush_method</code> 値は明示的に定義されていなければ自動的に構成されます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-dedicated-server" title="15.8.12 専用 MySQL Server の自動構成の有効化">セクション15.8.12「専用 MySQL Server の自動構成の有効化」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_flush_neighbors"></a>
          <code class="literal">innodb_flush_neighbors</code>
        </p><a class="indexterm" name="idm44761352413872"></a><a class="indexterm" name="idm44761352412320"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_flush_neighbors"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-flush-neighbors=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_neighbors">innodb_flush_neighbors</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">0</code></p><p class="valid-value"><code class="literal">1</code></p><p class="valid-value"><code class="literal">2</code></p></td>
</tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_flush" title="フラッシュ">flushing</a> で、<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> のページが同じ <a class="link" href="glossary.html#glos_extent" title="エクステント">extent</a> の他の <a class="link" href="glossary.html#glos_dirty_page" title="ダーティーページ">dirty pages</a> もフラッシュするかどうかを指定します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              0 に設定すると、<code class="literal">innodb_flush_neighbors</code> が無効になります。 同じエクステント内のダーティページはフラッシュされません。 
            </p></li><li class="listitem"><p>
              1 に設定すると、連続したダーティページが同じエクステントにフラッシュされます。
            </p></li><li class="listitem"><p>
              2 に設定すると、ダーティページが同じエクステントでフラッシュされます。
            </p></li></ul></div><p>
          テーブルデータが従来の <a class="link" href="glossary.html#glos_hdd" title="HDD">HDD</a> ストレージデバイスに格納されている場合は、1 回の操作でこのような<a class="link" href="glossary.html#glos_neighbor_page" title="隣接ページ">隣接ページ</a>をフラッシュすると、さまざまな時間に個々のページをフラッシュする場合と比較して、(主にディスクシーク操作の) I/O オーバーヘッドが削減されます。 <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> に格納されているテーブルデータの場合、シーク時間は重要な要因ではなく、このオプションを 0 に設定して書込み操作を分散できます。 関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-flushing" title="15.8.3.5 バッファープールのフラッシュの構成">セクション15.8.3.5「バッファープールのフラッシュの構成」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_flush_sync"></a>
          <code class="literal">innodb_flush_sync</code>
        </p><a class="indexterm" name="idm44761352369760"></a><a class="indexterm" name="idm44761352368208"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_flush_sync"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-flush-sync[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_sync">innodb_flush_sync</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
          <code class="literal">innodb_flush_sync</code> 変数はデフォルトで有効になっており、<a class="link" href="glossary.html#glos_checkpoint" title="チェックポイント">checkpoints</a> で発生する I/O アクティビティのバースト中に <code class="literal">innodb_io_capacity</code> 設定が無視されます。 <code class="literal">innodb_io_capacity</code> 設定で定義された I/O レートに準拠するには、<code class="literal">innodb_flush_sync</code> を無効にします。 
        </p><p>
          <code class="literal">innodb_flush_sync</code> 変数の構成の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-configuring-io-capacity" title="15.8.7 InnoDB I/O Capacity の構成">セクション15.8.7「InnoDB I/O Capacity の構成」</a> を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_flushing_avg_loops"></a>
          <code class="literal">innodb_flushing_avg_loops</code>
        </p><a class="indexterm" name="idm44761352336336"></a><a class="indexterm" name="idm44761352334768"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_flushing_avg_loops"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-flushing-avg-loops=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flushing_avg_loops">innodb_flushing_avg_loops</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">30</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">1000</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> が以前に計算されたフラッシュ状態のスナップショットを保持し、<a class="link" href="glossary.html#glos_adaptive_flushing" title="適応型フラッシュ">adaptive flushing</a> が <a class="link" href="glossary.html#glos_workload" title="ワークロード">workloads</a> の変更にどのくらい迅速に応答するかを制御する反復の数。 この値を大きくすると、ワークロードが変化するにつれて、<a class="link" href="glossary.html#glos_flush" title="フラッシュ">フラッシュ</a>操作の速度が円滑かつ徐々に変化します。 この値を小さくすると、適応型フラッシュがワークロードの変化にすばやく適応します。これにより、ワークロードが突然に増減した場合に、フラッシュアクティビティーが急増する可能性があります。 
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-flushing" title="15.8.3.5 バッファープールのフラッシュの構成">セクション15.8.3.5「バッファープールのフラッシュの構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_force_load_corrupted"></a>
          <code class="literal">innodb_force_load_corrupted</code>
        </p><a class="indexterm" name="idm44761352299760"></a><a class="indexterm" name="idm44761352298192"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_force_load_corrupted"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-force-load-corrupted[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_load_corrupted">innodb_force_load_corrupted</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          破損としてマークされたテーブルを起動時に <code class="literal">InnoDB</code> がロードできるようにします。 トラブルシューティング時に、何も対処しなければアクセスできないデータをリカバリする際にのみ使用してください。 トラブルシューティングが完了したら、この設定を無効にしてサーバーを再起動します。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_force_recovery"></a>
          <code class="literal">innodb_force_recovery</code>
        </p><a class="indexterm" name="idm44761352272096"></a><a class="indexterm" name="idm44761352270544"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_force_recovery"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-force-recovery=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery">innodb_force_recovery</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">6</code></td>
</tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>モードです。一般に、重大なトラブルシューティングの状況でのみ変更されます。 指定可能な値は 0 から 6 までです。 これらの値の意味および <code class="literal">innodb_force_recovery</code> に関する重要な情報については、<a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="15.21.2 InnoDB のリカバリの強制的な実行">セクション15.21.2「InnoDB のリカバリの強制的な実行」</a>を参照してください。 
        </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
            <code class="literal">InnoDB</code> を起動してテーブルをダンプできるように、緊急時にはこの変数を 0 より大きい値にのみ設定してください。 安全策として、<code class="literal">innodb_force_recovery</code> が 0 より大きい場合、<code class="literal">InnoDB</code> は <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、または <code class="literal">DELETE</code> 操作を回避します。 <code class="literal">innodb_force_recovery</code> 設定が 4 以上の場合、<code class="literal">InnoDB</code> は読取り専用モードになります。 
          </p><p>
            レプリケーションではレプリカステータスログが <code class="literal">InnoDB</code> テーブルに格納されるため、これらの制限により、レプリケーション管理コマンドがエラーで失敗する場合があります。
          </p></div></li><li class="listitem"><p><a name="sysvar_innodb_fsync_threshold"></a>
          <code class="literal">innodb_fsync_threshold</code>
        </p><a class="indexterm" name="idm44761352228352"></a><a class="indexterm" name="idm44761352226800"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_fsync_threshold"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-fsync-threshold=#</code></td>
</tr><tr><th>導入</th>
<td>8.0.13</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_fsync_threshold">innodb_fsync_threshold</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">2**64-1</code></td>
</tr></tbody></table></div><p>
          デフォルトでは、<code class="literal">InnoDB</code> が新しいログファイルやテーブルスペースファイルなどの新しいデータファイルを作成すると、ファイルはディスクにフラッシュされる前にオペレーティングシステムキャッシュに完全に書き込まれるため、大量のディスク書込みアクティビティが一度に発生する可能性があります。 オペレーティングシステムキャッシュから定期的にデータを強制的に小さいフラッシュするには、<code class="literal">innodb_fsync_threshold</code> 変数を使用してしきい値をバイト単位で定義します。 バイトしきい値に達すると、オペレーティングシステムキャッシュの内容がディスクにフラッシュされます。 デフォルト値の 0 では、デフォルトの動作が強制されます。つまり、ファイルがキャッシュに完全に書き込まれた後にのみ、データがディスクにフラッシュされます。 
        </p><p>
          複数の MySQL インスタンスが同じストレージデバイスを使用している場合は、より小さい定期的なフラッシュを強制的に実行するためのしきい値を指定すると有益です。 たとえば、新しい MySQL インスタンスとそれに関連付けられたデータファイルを作成すると、ディスク書込みアクティビティが大きくなり、同じストレージデバイスを使用する他の MySQL インスタンスのパフォーマンスが低下する可能性があります。 しきい値を構成すると、書込みアクティビティでのこのようなサージの回避に役立ちます。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_ft_aux_table"></a>
          <code class="literal">innodb_ft_aux_table</code>
        </p><a class="indexterm" name="idm44761352190592"></a><a class="indexterm" name="idm44761352189040"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_ft_aux_table"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_aux_table">innodb_ft_aux_table</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
          <code class="literal">FULLTEXT</code> インデックスを含む <code class="literal">InnoDB</code> テーブルの修飾名を指定します。 この変数は診断のために使用され、実行時にのみ設定できます。 例: 
        </p><pre class="programlisting">SET GLOBAL innodb_ft_aux_table = 'test/t1';
</pre><p>
          この変数を <code class="literal"><em class="replaceable"><code>db_name</code></em>/<em class="replaceable"><code>table_name</code></em></code> 形式の名前に設定すると、<code class="literal">INFORMATION_SCHEMA</code> テーブル <code class="literal">INNODB_FT_INDEX_TABLE</code>, <code class="literal">INNODB_FT_INDEX_CACHE</code>, <code class="literal">INNODB_FT_CONFIG</code>, <code class="literal">INNODB_FT_DELETED</code> および <code class="literal">INNODB_FT_BEING_DELETED</code> に、指定したテーブルの検索インデックスに関する情報が表示されます。
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-information-schema-fulltext_index-tables" title="15.15.4 InnoDB INFORMATION_SCHEMA FULLTEXT インデックステーブル">セクション15.15.4「InnoDB INFORMATION_SCHEMA FULLTEXT インデックステーブル」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_ft_cache_size"></a>
          <code class="literal">innodb_ft_cache_size</code>
        </p><a class="indexterm" name="idm44761352158064"></a><a class="indexterm" name="idm44761352156512"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_ft_cache_size"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-ft-cache-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_cache_size">innodb_ft_cache_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">8000000</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1600000</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">80000000</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> 検索インデックスキャッシュに割り当てられたメモリー (バイト単位)。これは、<code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> インデックスの作成時にメモリー内に解析済ドキュメントを保持します。 <code class="literal">innodb_ft_cache_size</code> のサイズ制限に達すると、インデックスの挿入および更新のみがディスクにコミットされます。<code class="literal">innodb_ft_cache_size</code> では、キャッシュサイズがテーブルごとに定義されます。 すべてのテーブルにグローバルな制限を設定する方法については、<code class="literal">innodb_ft_total_cache_size</code> を参照してください。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index-cache" title="InnoDB 全文インデックスキャッシュ">InnoDB 全文インデックスキャッシュ</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_ft_enable_diag_print"></a>
          <code class="literal">innodb_ft_enable_diag_print</code>
        </p><a class="indexterm" name="idm44761352119120"></a><a class="indexterm" name="idm44761352117552"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_ft_enable_diag_print"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-ft-enable-diag-print[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_enable_diag_print">innodb_ft_enable_diag_print</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          追加の全文検索 (FTS) 診断の出力を有効にするかどうかを指定します。 このオプションは主に高度な FTS デバッグを目的としており、ほとんどのユーザーにとって重要ではありません。 出力はエラーログに記録され、次のような情報が含まれています。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              FTS インデックス同期の進行状況 (FTS キャッシュ制限に達したとき)。 例: 
            </p><pre class="programlisting">FTS SYNC for table test, deleted count: 100 size: 10000 bytes
SYNC words: 100
</pre></li><li class="listitem"><p>
              FTS 最適化の進行状況。 例: 
            </p><pre class="programlisting">FTS start optimize test
FTS_OPTIMIZE: optimize "mysql"
FTS_OPTIMIZE: processed "mysql"
</pre></li><li class="listitem"><p>
              FTS インデックス構築の進行状況。 例: 
            </p><pre class="programlisting">Number of doc processed: 1000
</pre></li><li class="listitem"><p>
              FTS クエリーでは、クエリー解析のツリー、単語の重み、クエリーの処理時間、およびメモリーの使用状況が出力されます。 例: 
            </p><pre class="programlisting">FTS Search Processing time: 1 secs: 100 millisec: row(s) 10000
Full Search Memory: 245666 (bytes),  Row: 10000
</pre></li></ul></div></li><li class="listitem"><p><a name="sysvar_innodb_ft_enable_stopword"></a>
          <code class="literal">innodb_ft_enable_stopword</code>
        </p><a class="indexterm" name="idm44761352083776"></a><a class="indexterm" name="idm44761352082208"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_ft_enable_stopword"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-ft-enable-stopword[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_enable_stopword">innodb_ft_enable_stopword</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル、セッション</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
          インデックスの作成時に、一連の<a class="link" href="glossary.html#glos_stopword" title="ストップワード">ストップワード</a>が <code class="literal">InnoDB</code> の <code class="literal">FULLTEXT</code> インデックスに関連付けられることを指定します。 <code class="literal">innodb_ft_user_stopword_table</code> オプションが設定されている場合は、そのテーブルからストップワードが取得されます。 そうでなければ、<code class="literal">innodb_ft_server_stopword_table</code> オプションが設定されている場合は、そのテーブルからストップワードが取得されます。 それ以外の場合は、組み込みのデフォルトストップワードセットが使用されます。 
        </p><p>
          詳細は、<a class="xref" href="functions.html#fulltext-stopwords" title="12.10.4 全文ストップワード">セクション12.10.4「全文ストップワード」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_ft_max_token_size"></a>
          <code class="literal">innodb_ft_max_token_size</code>
        </p><a class="indexterm" name="idm44761352051024"></a><a class="indexterm" name="idm44761352049472"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_ft_max_token_size"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-ft-max-token-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_max_token_size">innodb_ft_max_token_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">84</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">10</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">84</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> インデックスに格納される単語の最大文字長。 この値に制限を設定すると、実在の単語ではなく、検索語句になる可能性の低い英字の任意のコレクションや長いキーワードが省略されることで、インデックスのサイズが削減されるため、クエリーの速度が上がります。 
        </p><p>
          詳細は、<a class="xref" href="functions.html#fulltext-fine-tuning" title="12.10.6 MySQL の全文検索の微調整">セクション12.10.6「MySQL の全文検索の微調整」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_ft_min_token_size"></a>
          <code class="literal">innodb_ft_min_token_size</code>
        </p><a class="indexterm" name="idm44761352016896"></a><a class="indexterm" name="idm44761352015344"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_ft_min_token_size"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-ft-min-token-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_min_token_size">innodb_ft_min_token_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">3</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">16</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> インデックスに格納される単語の最小長。 この値を大きくすると、英語の <span class="quote">「<span class="quote">a</span>」</span> や <span class="quote">「<span class="quote">to</span>」</span> などの検索コンテキストで重要ではない一般的な単語が省略されるため、インデックスのサイズが減り、クエリーが高速化されます。 内容で CJK (中国語、日本語、韓国語) 文字セットが使用されている場合は、値 1 を指定します。 
        </p><p>
          詳細は、<a class="xref" href="functions.html#fulltext-fine-tuning" title="12.10.6 MySQL の全文検索の微調整">セクション12.10.6「MySQL の全文検索の微調整」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_ft_num_word_optimize"></a>
          <code class="literal">innodb_ft_num_word_optimize</code>
        </p><a class="indexterm" name="idm44761351981792"></a><a class="indexterm" name="idm44761351980224"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_ft_num_word_optimize"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-ft-num-word-optimize=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_num_word_optimize">innodb_ft_num_word_optimize</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">2000</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1000</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">10000</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> の <code class="literal">FULLTEXT</code> インデックスでの各 <code class="literal">OPTIMIZE TABLE</code> 操作時に処理される単語数です。 全文検索インデックスを含むテーブルへの一括挿入または一括更新操作では、すべての変更を組み込むために大量のインデックスのメンテナンスが必要となる可能性があるため、それぞれが最後に終了した場所から再開する一連の <code class="literal">OPTIMIZE TABLE</code> ステートメントを実行するとよいでしょう。 
        </p><p>
          詳細は、<a class="xref" href="functions.html#fulltext-fine-tuning" title="12.10.6 MySQL の全文検索の微調整">セクション12.10.6「MySQL の全文検索の微調整」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_ft_result_cache_limit"></a>
          <code class="literal">innodb_ft_result_cache_limit</code>
        </p><a class="indexterm" name="idm44761351945392"></a><a class="indexterm" name="idm44761351943824"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_ft_result_cache_limit"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-ft-result-cache-limit=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_result_cache_limit">innodb_ft_result_cache_limit</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">2000000000</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1000000</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">2**32-1</code></td>
</tr></tbody></table></div><p>
          全文検索クエリーまたはスレッド当たりの <code class="literal">InnoDB</code> 全文検索クエリーの結果キャッシュ制限 (バイト単位で定義)。 中間および最終的な <code class="literal">InnoDB</code> 全文検索クエリー結果はメモリー内で処理されます。 <code class="literal">innodb_ft_result_cache_limit</code> を使用して全文検索のクエリー結果キャッシュにサイズ制限を設定し、<code class="literal">InnoDB</code> 全文検索のクエリー結果が非常に大きい場合 (数百万行や数百万行など) にメモリーを過剰に消費しないようにします。 全文検索クエリーの処理時に、必要に応じてメモリーが割り当てられます。 結果のキャッシュサイズ制限に達すると、クエリーで最大限に許可されるメモリー量を超えたことを示すエラーが返されます。 
        </p><p>
          すべてのプラットフォームタイプおよびビットサイズに対する <code class="literal">innodb_ft_result_cache_limit</code> の最大値は、2**32-1 です。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_ft_server_stopword_table"></a>
          <code class="literal">innodb_ft_server_stopword_table</code>
        </p><a class="indexterm" name="idm44761351908208"></a><a class="indexterm" name="idm44761351906624"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_ft_server_stopword_table"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-ft-server-stopword-table=db_name/table_name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_server_stopword_table">innodb_ft_server_stopword_table</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">NULL</code></td>
</tr></tbody></table></div><p>
          このオプションは、すべての <code class="literal">InnoDB</code> テーブルに対応した独自の <code class="literal">InnoDB</code> の <code class="literal">FULLTEXT</code> インデックスストップワードリストを指定する際に使用されます。 特定の <code class="literal">InnoDB</code> テーブルに独自のストップワードリストを構成するには、<code class="literal">innodb_ft_user_stopword_table</code> を使用します。 
        </p><p>
          <code class="literal"><em class="replaceable"><code>db_name</code></em>/<em class="replaceable"><code>table_name</code></em></code> の形式で、<code class="literal">innodb_ft_server_stopword_table</code> をストップワードリストを含むテーブルの名前に設定します。
        </p><p>
          <code class="literal">innodb_ft_server_stopword_table</code> を構成する前に、ストップワードテーブルが存在する必要があります。<code class="literal">FULLTEXT</code> インデックスを作成する前に、<code class="literal">innodb_ft_enable_stopword</code> を有効にし、<code class="literal">innodb_ft_server_stopword_table</code> オプションを構成する必要があります。
        </p><p>
          ストップワードテーブルは、<code class="literal">value</code> という名前の単一の <code class="literal">VARCHAR</code> カラムを含む <code class="literal">InnoDB</code> テーブルである必要があります。
        </p><p>
          詳細は、<a class="xref" href="functions.html#fulltext-stopwords" title="12.10.4 全文ストップワード">セクション12.10.4「全文ストップワード」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_ft_sort_pll_degree"></a>
          <code class="literal">innodb_ft_sort_pll_degree</code>
        </p><a class="indexterm" name="idm44761351866240"></a><a class="indexterm" name="idm44761351864672"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_ft_sort_pll_degree"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-ft-sort-pll-degree=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_sort_pll_degree">innodb_ft_sort_pll_degree</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">2</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">32</code></td>
</tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_search_index" title="検索インデックス">search index</a> の構築時に <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> インデックスのテキストをインデックス付けおよびトークン化するためにパラレルで使用されるスレッドの数。
        </p><p>
          関連情報は、<a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index" title="15.6.2.4 InnoDB FULLTEXT インデックス">セクション15.6.2.4「InnoDB FULLTEXT インデックス」</a> および <code class="literal">innodb_sort_buffer_size</code> を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_ft_total_cache_size"></a>
          <code class="literal">innodb_ft_total_cache_size</code>
        </p><a class="indexterm" name="idm44761351830336"></a><a class="indexterm" name="idm44761351828768"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_ft_total_cache_size"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-ft-total-cache-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_total_cache_size">innodb_ft_total_cache_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">640000000</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">32000000</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">1600000000</code></td>
</tr></tbody></table></div><p>
          すべてのテーブルの <code class="literal">InnoDB</code> 全文検索インデックスキャッシュに割り当てられた合計メモリー (バイト)。 <code class="literal">FULLTEXT</code> 検索インデックスを使用して多数のテーブルを作成すると、使用可能なメモリーの大部分が消費される可能性があります。<code class="literal">innodb_ft_total_cache_size</code> では、過剰なメモリー消費を回避するために、すべての全文検索インデックスに対してグローバルメモリー制限を定義します。 インデックス操作によってグローバル制限に達すると、強制同期がトリガーされます。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index-cache" title="InnoDB 全文インデックスキャッシュ">InnoDB 全文インデックスキャッシュ</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_ft_user_stopword_table"></a>
          <code class="literal">innodb_ft_user_stopword_table</code>
        </p><a class="indexterm" name="idm44761351794448"></a><a class="indexterm" name="idm44761351792880"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_ft_user_stopword_table"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-ft-user-stopword-table=db_name/table_name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_user_stopword_table">innodb_ft_user_stopword_table</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル、セッション</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">NULL</code></td>
</tr></tbody></table></div><p>
          このオプションは、特定のテーブルに独自の <code class="literal">InnoDB</code> の <code class="literal">FULLTEXT</code> インデックスストップワードリストを指定する際に使用されます。 すべての <code class="literal">InnoDB</code> テーブル用に独自のストップワードリストを構成するには、<code class="literal">innodb_ft_server_stopword_table</code> を使用します。 
        </p><p>
          <code class="literal"><em class="replaceable"><code>db_name</code></em>/<em class="replaceable"><code>table_name</code></em></code> の形式で、<code class="literal">innodb_ft_user_stopword_table</code> をストップワードリストを含むテーブルの名前に設定します。
        </p><p>
          <code class="literal">innodb_ft_user_stopword_table</code> を構成する前に、ストップワードテーブルが存在する必要があります。<code class="literal">FULLTEXT</code> インデックスを作成する前に、<code class="literal">innodb_ft_enable_stopword</code> を有効にし、<code class="literal">innodb_ft_user_stopword_table</code> を構成する必要があります。
        </p><p>
          ストップワードテーブルは、<code class="literal">value</code> という名前の単一の <code class="literal">VARCHAR</code> カラムを含む <code class="literal">InnoDB</code> テーブルである必要があります。
        </p><p>
          詳細は、<a class="xref" href="functions.html#fulltext-stopwords" title="12.10.4 全文ストップワード">セクション12.10.4「全文ストップワード」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_idle_flush_pct"></a>
          <code class="literal">innodb_idle_flush_pct</code>
        </p><a class="indexterm" name="idm44761351753216"></a><a class="indexterm" name="idm44761351751664"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_idle_flush_pct"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-idle-flush-pct=#</code></td>
</tr><tr><th>導入</th>
<td>8.0.18</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_idle_flush_pct">innodb_idle_flush_pct</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">100</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">100</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> がアイドル状態の場合のページフラッシュを制限します。 <code class="literal">innodb_idle_flush_pct</code> 値は、<code class="literal">InnoDB</code> で使用可能な I/O 操作数/秒を定義する <code class="literal">innodb_io_capacity</code> 設定の割合です。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-limit-flushing-rate" title="アイドル期間中のバッファフラッシュの制限">アイドル期間中のバッファフラッシュの制限</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_io_capacity"></a>
          <code class="literal">innodb_io_capacity</code>
        </p><a class="indexterm" name="idm44761351715824"></a><a class="indexterm" name="idm44761351714272"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_io_capacity"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-io-capacity=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity">innodb_io_capacity</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">200</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">100</code></td>
</tr><tr><th>最大値 (64 ビットプラットフォーム)</th>
<td><code class="literal">2**64-1</code></td>
</tr><tr><th>最大値 (32 ビットプラットフォーム)</th>
<td><code class="literal">2**32-1</code></td>
</tr></tbody></table></div><p>
          <code class="literal">innodb_io_capacity</code> 変数は、<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> からの <a class="link" href="glossary.html#glos_flush" title="フラッシュ">flushing</a> ページや <a class="link" href="glossary.html#glos_change_buffer" title="変更バッファー">change buffer</a> からのデータのマージなど、<code class="literal">InnoDB</code> バックグラウンドタスクで使用可能な秒当たりの I/O 操作数 (IOPS) を定義します。
        </p><p>
          <code class="literal">innodb_io_capacity</code> 変数の構成の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-configuring-io-capacity" title="15.8.7 InnoDB I/O Capacity の構成">セクション15.8.7「InnoDB I/O Capacity の構成」</a> を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_io_capacity_max"></a>
          <code class="literal">innodb_io_capacity_max</code>
        </p><a class="indexterm" name="idm44761351675696"></a><a class="indexterm" name="idm44761351674144"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_io_capacity_max"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-io-capacity-max=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity_max">innodb_io_capacity_max</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">see description</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">100</code></td>
</tr><tr><th>最大値 (32 ビットプラットフォーム)</th>
<td><code class="literal">2**32-1</code></td>
</tr><tr><th>最大値 (Unix, 64 ビットプラットフォーム)</th>
<td><code class="literal">2**64-1</code></td>
</tr><tr><th>最大値 (Windows, 64 ビットプラットフォーム)</th>
<td><code class="literal">2**32-1</code></td>
</tr></tbody></table></div><p>
          フラッシュアクティビティが遅れている場合、<code class="literal">InnoDB</code> は <code class="literal">innodb_io_capacity</code> 変数で定義されているよりも高い速度の I/O 操作/秒 (IOPS) で、より積極的にフラッシュできます。 <code class="literal">innodb_io_capacity_max</code> 変数は、このような状況で <code class="literal">InnoDB</code> バックグラウンドタスクによって実行される IOPS の最大数を定義します。 
        </p><p>
          <code class="literal">innodb_io_capacity_max</code> 変数の構成の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-configuring-io-capacity" title="15.8.7 InnoDB I/O Capacity の構成">セクション15.8.7「InnoDB I/O Capacity の構成」</a> を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_limit_optimistic_insert_debug"></a>
          <code class="literal">innodb_limit_optimistic_insert_debug</code>
        </p><a class="indexterm" name="idm44761351633440"></a><a class="indexterm" name="idm44761351632320"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_limit_optimistic_insert_debug"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-limit-optimistic-insert-debug=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_limit_optimistic_insert_debug">innodb_limit_optimistic_insert_debug</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">2**32-1</code></td>
</tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_b_tree" title="B ツリー">B-tree</a> ページ当たりのレコード数を制限します。 デフォルト値 0 は、制限が課されないことを意味します。 このオプションは、デバッグサポートが <code class="option">WITH_DEBUG</code> <span class="command"><strong>CMake</strong></span> オプションを使用してコンパイルされている場合にのみ使用できます。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_lock_wait_timeout"></a>
          <code class="literal">innodb_lock_wait_timeout</code>
        </p><a class="indexterm" name="idm44761351599984"></a><a class="indexterm" name="idm44761351598432"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_lock_wait_timeout"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-lock-wait-timeout=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_lock_wait_timeout">innodb_lock_wait_timeout</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル、セッション</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">50</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">1073741824</code></td>
</tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_row_lock" title="行ロック">行ロック</a>が解除されるまで <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>が待機する時間の長さ (秒単位) です。 デフォルト値は 50 秒です。 別の <code class="literal">InnoDB</code> トランザクションでロックされている行へのアクセスを試みるトランザクションは、行への書き込みアクセスを最大でこの秒数間待機してから、次のエラーを発行します。 
        </p><pre class="programlisting">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
</pre><p>
          ロック待機のタイムアウトが発生すると、(トランザクション全体ではなく) 現在のステートメントが<a class="link" href="glossary.html#glos_rollback" title="ロールバック">ロールバック</a>されます。 トランザクション全体をロールバックするには、<code class="option">--innodb-rollback-on-timeout</code> オプションを使用してサーバーを起動します。 <a class="xref" href="innodb-storage-engine.html#innodb-error-handling" title="15.21.4 InnoDB のエラー処理">セクション15.21.4「InnoDB のエラー処理」</a>も参照してください。 
        </p><p>
          高度にインタラクティブなアプリケーションまたは <a class="link" href="glossary.html#glos_oltp" title="OLTP">OLTP</a> システムでは、ユーザーのフィードバックをすばやく表示したり、あとで処理するために更新をキューに入れたりするために、この値を小さくするとよいでしょう。 長時間実行されるバックエンド操作 (その他の大規模な挿入操作や更新操作が完了するまで待機するデータウェアハウスでの変換ステップなど) では、この値を大きくするとよいでしょう。 
        </p><p>
          <code class="literal">innodb_lock_wait_timeout</code> は、<code class="literal">InnoDB</code> の行ロックに適用されます。 MySQL の<a class="link" href="glossary.html#glos_table_lock" title="テーブルロック">テーブルロック</a>は <code class="literal">InnoDB</code> 内部では発生せず、このタイムアウトはテーブルロックの待機には適用されません。 
        </p><p>
          <code class="literal">InnoDB</code> ではデッドロックが即時に検出され、デッドロックされたトランザクションのいずれかがロールバックされるため、<code class="literal">innodb_deadlock_detect</code> が有効な場合 (デフォルト)、ロック待機タイムアウト値は <a class="link" href="glossary.html#glos_deadlock" title="デッドロック">deadlocks</a> には適用されません。 <code class="literal">innodb_deadlock_detect</code> が無効になっている場合、<code class="literal">InnoDB</code> はデッドロック発生時のトランザクションロールバックを <code class="literal">innodb_lock_wait_timeout</code> に依存します。 <a class="xref" href="innodb-storage-engine.html#innodb-deadlock-detection" title="15.7.5.2 デッドロック検出">セクション15.7.5.2「デッドロック検出」</a>を参照してください。 
        </p><p>
          <code class="literal">innodb_lock_wait_timeout</code> は、実行時に <code class="literal">SET GLOBAL</code> または <code class="literal">SET SESSION</code> ステートメントとともに設定できます。 <code class="literal">GLOBAL</code> 設定を変更するには、グローバルシステム変数を設定するのに十分な権限 (<a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a> を参照) が必要であり、その後接続するすべてのクライアントの操作に影響します。 任意のクライアントが <code class="literal">innodb_lock_wait_timeout</code> の <code class="literal">SESSION</code> 設定を変更でき、そのクライアントのみが影響を受けます。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_log_buffer_size"></a>
          <code class="literal">innodb_log_buffer_size</code>
        </p><a class="indexterm" name="idm44761351541312"></a><a class="indexterm" name="idm44761351539760"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_log_buffer_size"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-log-buffer-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_buffer_size">innodb_log_buffer_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">16777216</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1048576</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
          ディスク上の<a class="link" href="glossary.html#glos_log_file" title="ログファイル">ログファイル</a>に書き込む際に <code class="literal">InnoDB</code> で使用されるバッファーのサイズ (バイト単位) です。 デフォルトは 16M バイトです。 大規模な <a class="link" href="glossary.html#glos_log_buffer" title="ログバッファー">log buffer</a> では、トランザクション <a class="link" href="glossary.html#glos_commit" title="コミット">commit</a> の前にログをディスクに書き込むことなく、大規模な <a class="link" href="glossary.html#glos_transaction" title="トランザクション">transactions</a> を実行できます。 したがって、多数の行を更新、挿入、または削除するトランザクションの場合、ログバッファーを大きくすると、ディスク I/O を節約できます。 関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-startup-memory-configuration" title="メモリー構成">メモリー構成</a>,および<a class="xref" href="optimization.html#optimizing-innodb-logging" title="8.5.4 InnoDB redo ロギングの最適化">セクション8.5.4「InnoDB redo ロギングの最適化」</a>を参照してください。 一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8 InnoDB ディスク I/O の最適化">セクション8.5.8「InnoDB ディスク I/O の最適化」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_log_checkpoint_fuzzy_now"></a>
          <code class="literal">innodb_log_checkpoint_fuzzy_now</code>
        </p><a class="indexterm" name="idm44761351503120"></a><a class="indexterm" name="idm44761351501536"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_log_checkpoint_fuzzy_now"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-log-checkpoint-fuzzy-now[={OFF|ON}]</code></td>
</tr><tr><th>導入</th>
<td>8.0.13</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_checkpoint_fuzzy_now">innodb_log_checkpoint_fuzzy_now</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> にファジーチェックポイントの書込みを強制するには、このデバッグオプションを有効にします。 このオプションは、デバッグサポートが <code class="option">WITH_DEBUG</code> <span class="command"><strong>CMake</strong></span> オプションを使用してコンパイルされている場合にのみ使用できます。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_log_checkpoint_now"></a>
          <code class="literal">innodb_log_checkpoint_now</code>
        </p><a class="indexterm" name="idm44761351472208"></a><a class="indexterm" name="idm44761351470640"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_log_checkpoint_now"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-log-checkpoint-now[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_checkpoint_now">innodb_log_checkpoint_now</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> にチェックポイントの書込みを強制するには、このデバッグオプションを有効にします。 このオプションは、デバッグサポートが <code class="option">WITH_DEBUG</code> <span class="command"><strong>CMake</strong></span> オプションを使用してコンパイルされている場合にのみ使用できます。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_log_checksums"></a>
          <code class="literal">innodb_log_checksums</code>
        </p><a class="indexterm" name="idm44761351443376"></a><a class="indexterm" name="idm44761351441824"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_log_checksums"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-log-checksums[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_checksums">innodb_log_checksums</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
          redo ログページのチェックサムを有効または無効にします。
        </p><p>
          <code class="literal">innodb_log_checksums=ON</code> では、redo ログページの <code class="literal">CRC-32C</code> チェックサムアルゴリズムを有効にします。 <code class="literal">innodb_log_checksums</code> が無効な場合、redo ログページのチェックサムフィールドの内容は無視されます。 
        </p><p>
          redo ログヘッダーページおよび redo ログチェックポイントページのチェックサムは無効化されません。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_log_compressed_pages"></a>
          <code class="literal">innodb_log_compressed_pages</code>
        </p><a class="indexterm" name="idm44761351412944"></a><a class="indexterm" name="idm44761351411376"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_log_compressed_pages"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-log-compressed-pages[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_compressed_pages">innodb_log_compressed_pages</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_compression" title="圧縮">re-compressed</a> <a class="link" href="glossary.html#glos_page" title="ページ">pages</a> のイメージを <a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">redo log</a> に書き込むかどうかを指定します。 圧縮されたデータが変更されると、再圧縮が発生する場合があります。 
        </p><p>
          <code class="literal">innodb_log_compressed_pages</code> は、リカバリ時に異なるバージョンの <code class="literal">zlib</code> 圧縮アルゴリズムが使用された場合に発生する可能性がある破損を防ぐために、デフォルトで有効になっています。 <code class="literal">zlib</code> のバージョンが変更されないことが確実な場合は、<code class="literal">innodb_log_compressed_pages</code> を無効にして、圧縮データを変更するワークロードの redo ログ生成を減らすことができます。 
        </p><p>
          <code class="literal">innodb_log_compressed_pages</code> の有効化または無効化の影響を測定するには、同じワークロードで両方の設定の redo ログ生成を比較します。 redo ログ生成の測定オプションには、<code class="literal">SHOW ENGINE INNODB STATUS</code> 出力の <code class="literal">LOG</code> セクションでの <code class="literal">Log sequence number</code> (LSN) の監視、または redo ログファイルに書き込まれたバイト数の <code class="literal">Innodb_os_log_written</code> ステータスの監視が含まれます。 
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-performance-compression-oltp" title="15.9.1.6 OLTP ワークロードの圧縮">セクション15.9.1.6「OLTP ワークロードの圧縮」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_log_file_size"></a>
          <code class="literal">innodb_log_file_size</code>
        </p><a class="indexterm" name="idm44761351372384"></a><a class="indexterm" name="idm44761351370832"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_log_file_size"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-log-file-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_file_size">innodb_log_file_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">50331648</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">4194304</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">512GB / innodb_log_files_in_group</code></td>
</tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_log_group" title="ロググループ">ロググループ</a>内の各<a class="link" href="glossary.html#glos_log_file" title="ログファイル">ログファイル</a>のサイズ (バイト単位) です。 ログファイルを結合したサイズ (<code class="literal">innodb_log_file_size</code> * <code class="literal">innodb_log_files_in_group</code>) は、512G バイトよりもわずかに小さい最大値を上回ることができません。 たとえば、255 GB のログファイルのペアは制限に近づいていますが、それを超えていません。 デフォルト値は 48M バイトです。 
        </p><p>
          一般に、ログファイルの合計サイズは、サーバーがワークロードアクティビティのピークおよびトラブルをスムーズにできる十分な大きさである必要があります。これは、書込みアクティビティを 1 時間以上処理するための十分な redo ログ領域があることを意味することがよくあります。 この値が大きいほど、バッファプールで必要なチェックポイントフラッシュアクティビティが少なくなり、ディスク I/O が節約されます。 ログファイルが大きいほど、<a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">crash recovery</a> も遅くなります。 
        </p><p>
          最小の <code class="literal">innodb_log_file_size</code> は 4MB です。
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-startup-log-file-configuration" title="redo ログファイル構成">redo ログファイル構成</a>を参照してください。 一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8 InnoDB ディスク I/O の最適化">セクション8.5.8「InnoDB ディスク I/O の最適化」</a>を参照してください。 
        </p><p>
          <code class="literal">innodb_dedicated_server</code> が有効な場合、<code class="literal">innodb_log_file_size</code> 値は明示的に定義されていなければ自動的に構成されます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-dedicated-server" title="15.8.12 専用 MySQL Server の自動構成の有効化">セクション15.8.12「専用 MySQL Server の自動構成の有効化」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_log_files_in_group"></a>
          <code class="literal">innodb_log_files_in_group</code>
        </p><a class="indexterm" name="idm44761351327712"></a><a class="indexterm" name="idm44761351326144"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_log_files_in_group"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-log-files-in-group=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_files_in_group">innodb_log_files_in_group</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">2</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">2</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">100</code></td>
</tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_log_group" title="ロググループ">ロググループ</a>内の<a class="link" href="glossary.html#glos_log_file" title="ログファイル">ログファイル</a>の数です。 <code class="literal">InnoDB</code> はファイルに輪状に書き込みをします。 デフォルト (推奨) 値は 2 です。 ファイルの場所は、<code class="literal">innodb_log_group_home_dir</code> によって指定されます。 ログファイルを結合したサイズ (<code class="literal">innodb_log_file_size</code> * <code class="literal">innodb_log_files_in_group</code>) は、最大で 512G バイトにすることができます。 
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-startup-log-file-configuration" title="redo ログファイル構成">redo ログファイル構成</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_log_group_home_dir"></a>
          <code class="literal">innodb_log_group_home_dir</code>
        </p><a class="indexterm" name="idm44761351289664"></a><a class="indexterm" name="idm44761351288096"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_log_group_home_dir"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-log-group-home-dir=dir_name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_group_home_dir">innodb_log_group_home_dir</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>ディレクトリ名</td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> の <a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">Redo ログ</a>ファイルへのディレクトリパスです。この数は、<code class="literal">innodb_log_files_in_group</code> で指定されます。 どの <code class="literal">InnoDB</code> ログ変数も指定しない場合は、デフォルトで、MySQL データディレクトリ内に <code class="filename">ib_logfile0</code> および <code class="filename">ib_logfile1</code> という名前の 2 つのファイルが作成されます。 ログファイルのサイズは、<code class="literal">innodb_log_file_size</code> システム変数によって指定されます。 
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-startup-log-file-configuration" title="redo ログファイル構成">redo ログファイル構成</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_log_spin_cpu_abs_lwm"></a>
          <code class="literal">innodb_log_spin_cpu_abs_lwm</code>
        </p><a class="indexterm" name="idm44761351258432"></a><a class="indexterm" name="idm44761351256864"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_log_spin_cpu_abs_lwm"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-log-spin-cpu-abs-lwm=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_spin_cpu_abs_lwm">innodb_log_spin_cpu_abs_lwm</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">80</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
          フラッシュされた redo の待機中にユーザースレッドがスピンしなくなる CPU 使用率の最小量を定義します。 この値は、CPU コア使用率の合計として表されます。 たとえば、80 のデフォルト値は、単一の CPU コアの 80% です。 マルチコアプロセッサを搭載したシステムでは、150 の値は、1 つの CPU コアの 100% 使用率と 2 つ目の CPU コアの 50% 使用率を表します。 
        </p><p>
          関連情報については、<a class="xref" href="optimization.html#optimizing-innodb-logging" title="8.5.4 InnoDB redo ロギングの最適化">セクション8.5.4「InnoDB redo ロギングの最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_log_spin_cpu_pct_hwm"></a>
          <code class="literal">innodb_log_spin_cpu_pct_hwm</code>
        </p><a class="indexterm" name="idm44761351225584"></a><a class="indexterm" name="idm44761351224016"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_log_spin_cpu_pct_hwm"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-log-spin-cpu-pct-hwm=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_spin_cpu_pct_hwm">innodb_log_spin_cpu_pct_hwm</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">50</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">100</code></td>
</tr></tbody></table></div><p>
          フラッシュされた redo の待機中にユーザースレッドがスピンしなくなる CPU 使用率の最大量を定義します。 この値は、すべての CPU コアの合計処理能力の割合として表されます。 デフォルト値は 50% です。 たとえば、2 つの CPU コアの 100% 使用率は、4 つの CPU コアを持つサーバーでの CPU 処理能力の合計の 50% です。 
        </p><p>
          <code class="literal">innodb_log_spin_cpu_pct_hwm</code> 変数は、プロセッサアフィニティを考慮します。 たとえば、サーバーに 48 個のコアがあり、<span class="command"><strong>mysqld</strong></span> プロセスが 4 個の CPU コアにのみ固定されている場合、他の 44 個の CPU コアは無視されます。 
        </p><p>
          関連情報については、<a class="xref" href="optimization.html#optimizing-innodb-logging" title="8.5.4 InnoDB redo ロギングの最適化">セクション8.5.4「InnoDB redo ロギングの最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_log_wait_for_flush_spin_hwm"></a>
          <code class="literal">innodb_log_wait_for_flush_spin_hwm</code>
        </p><a class="indexterm" name="idm44761351190064"></a><a class="indexterm" name="idm44761351188464"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_log_wait_for_flush_spin_hwm"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-log-wait-for-flush-spin-hwm=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_wait_for_flush_spin_hwm">innodb_log_wait_for_flush_spin_hwm</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">400</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値 (64 ビットプラットフォーム)</th>
<td><code class="literal">2**64-1</code></td>
</tr><tr><th>最大値 (32 ビットプラットフォーム)</th>
<td><code class="literal">2**32-1</code></td>
</tr></tbody></table></div><p>
          フラッシュされた redo の待機中にユーザースレッドがスピンしなくなる最大平均ログフラッシュ時間を定義します。 デフォルト値は 400 マイクロ秒です。 
        </p><p>
          関連情報については、<a class="xref" href="optimization.html#optimizing-innodb-logging" title="8.5.4 InnoDB redo ロギングの最適化">セクション8.5.4「InnoDB redo ロギングの最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_log_write_ahead_size"></a>
          <code class="literal">innodb_log_write_ahead_size</code>
        </p><a class="indexterm" name="idm44761351154864"></a><a class="indexterm" name="idm44761351153296"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_log_write_ahead_size"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-log-write-ahead-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_write_ahead_size">innodb_log_write_ahead_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">8192</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">512 (log file block size)</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">Equal to innodb_page_size</code></td>
</tr></tbody></table></div><p>
          redo ログの先行書込みブロックサイズをバイト単位で定義します。 <span class="quote">「<span class="quote">read-on-write</span>」</span> を回避するには、オペレーティングシステムまたはファイルシステムのキャッシュブロックサイズと一致するように <code class="literal">innodb_log_write_ahead_size</code> を設定します。 デフォルト設定は 8192 バイトです。 読取り/書込みは、redo ログの先行書込みブロックサイズとオペレーティングシステムまたはファイルシステムのキャッシュブロックサイズが一致しないために、redo ログブロックがオペレーティングシステムまたはファイルシステムに完全にキャッシュされない場合に発生します。 
        </p><p>
          <code class="literal">innodb_log_write_ahead_size</code> の有効な値は、<code class="literal">InnoDB</code> ログファイルのブロックサイズ (2 <sup>n</sup>) の倍数です。 最小値は、<code class="literal">InnoDB</code> ログファイルのブロックサイズ (512) です。 最小値が指定されている場合、ライトアヘッドは発生しません。 最大値は <code class="literal">innodb_page_size</code> 値と同じです。 <code class="literal">innodb_log_write_ahead_size</code> に <code class="literal">innodb_page_size</code> 値より大きい値を指定すると、<code class="literal">innodb_log_write_ahead_size</code> 設定は <code class="literal">innodb_page_size</code> 値に切り捨てられます。 
        </p><p>
          オペレーティングシステムまたはファイルシステムのキャッシュブロックサイズに対する <code class="literal">innodb_log_write_ahead_size</code> 値の設定が低すぎると、<span class="quote">「<span class="quote">read-on-write</span>」</span> が発生します。 値を高く設定しすぎると、一度に複数のブロックが書き込まれるため、ログファイル書込みの <code class="literal">fsync</code> パフォーマンスにわずかな影響を与える可能性があります。 
        </p><p>
          関連情報については、<a class="xref" href="optimization.html#optimizing-innodb-logging" title="8.5.4 InnoDB redo ロギングの最適化">セクション8.5.4「InnoDB redo ロギングの最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_log_writer_threads"></a>
          <code class="literal">innodb_log_writer_threads</code>
        </p><a class="indexterm" name="idm44761351107728"></a><a class="indexterm" name="idm44761351106160"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_log_writer_threads"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-log-writer-threads[={OFF|ON}]</code></td>
</tr><tr><th>導入</th>
<td>8.0.22</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_writer_threads">innodb_log_writer_threads</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
          ログバッファからシステムバッファに redo ログレコードを書き込み、システムバッファを redo ログファイルにフラッシュするための専用のログライタースレッドを有効にします。 専用ログライタースレッドを使用すると、同時実行性の高いシステムのパフォーマンスを向上させることができますが、同時実行性の低いシステムでは、専用ログライタースレッドを無効にすると、パフォーマンスが向上します。 
        </p><p>
          詳細は、<a class="xref" href="optimization.html#optimizing-innodb-logging" title="8.5.4 InnoDB redo ロギングの最適化">セクション8.5.4「InnoDB redo ロギングの最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_lru_scan_depth"></a>
          <code class="literal">innodb_lru_scan_depth</code>
        </p><a class="indexterm" name="idm44761351077696"></a><a class="indexterm" name="idm44761351076144"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_lru_scan_depth"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-lru-scan-depth=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_lru_scan_depth">innodb_lru_scan_depth</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">1024</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">100</code></td>
</tr><tr><th>最大値 (64 ビットプラットフォーム)</th>
<td><code class="literal">2**64-1</code></td>
</tr><tr><th>最大値 (32 ビットプラットフォーム)</th>
<td><code class="literal">2**32-1</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>での<a class="link" href="glossary.html#glos_flush" title="フラッシュ">フラッシュ</a>操作のアルゴリズムおよびヒューリスティクスに影響を与えるパラメータです。 主に、I/O インテンシブなワークロードを調整するパフォーマンスの専門家が関心を持つものです。 バッファプールインスタンスごとに、フラッシュする <a class="link" href="glossary.html#glos_dirty_page" title="ダーティーページ">dirty pages</a> を検索するページクリーナスレッドスキャンをバッファプール LRU ページにリストする距離を指定します。 これは、1 秒に 1 回実行されるバックグラウンド操作です。 
        </p><p>
          デフォルトより小さい設定は、通常、ほとんどのワークロードに適しています。 必要以上の値を指定すると、パフォーマンスに影響する可能性があります。 通常のワークロードでスペア I/O 容量がある場合のみ、値を増やすことを検討してください。 逆に、書込み集中型のワークロードが I/O の容量を満たしている場合は、特に大きなバッファプールの場合に値を減らします。 
        </p><p>
          <code class="literal">innodb_lru_scan_depth</code> をチューニングする場合は、小さい値から始めて、ゼロの空きページが表示されることがほとんどないという目標で設定を上方に構成します。 また、<code class="literal">innodb_lru_scan_depth</code> * <code class="literal">innodb_buffer_pool_instances</code> は毎秒ページクリーナスレッドによって実行される作業量を定義するため、バッファプールインスタンスの数を変更するときに <code class="literal">innodb_lru_scan_depth</code> を調整することを検討してください。 
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-flushing" title="15.8.3.5 バッファープールのフラッシュの構成">セクション15.8.3.5「バッファープールのフラッシュの構成」</a>を参照してください。 一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8 InnoDB ディスク I/O の最適化">セクション8.5.8「InnoDB ディスク I/O の最適化」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_max_dirty_pages_pct"></a>
          <code class="literal">innodb_max_dirty_pages_pct</code>
        </p><a class="indexterm" name="idm44761351031776"></a><a class="indexterm" name="idm44761351030208"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_max_dirty_pages_pct"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-max-dirty-pages-pct=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_dirty_pages_pct">innodb_max_dirty_pages_pct</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>数値</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">90</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">99.99</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> は、<a class="link" href="glossary.html#glos_dirty_page" title="ダーティーページ">ダーティーページ</a>の割合がこの値を超えないように、<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>からデータを<a class="link" href="glossary.html#glos_flush" title="フラッシュ">フラッシュ</a>しようと試みます。
        </p><p>
          <code class="literal">innodb_max_dirty_pages_pct</code> 設定は、フラッシュアクティビティーのターゲットを確立します。 フラッシュの頻度には影響を与えません。 フラッシュの頻度の管理については、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-flushing" title="15.8.3.5 バッファープールのフラッシュの構成">セクション15.8.3.5「バッファープールのフラッシュの構成」</a>を参照してください。 
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-flushing" title="15.8.3.5 バッファープールのフラッシュの構成">セクション15.8.3.5「バッファープールのフラッシュの構成」</a>を参照してください。 一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8 InnoDB ディスク I/O の最適化">セクション8.5.8「InnoDB ディスク I/O の最適化」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_max_dirty_pages_pct_lwm"></a>
          <code class="literal">innodb_max_dirty_pages_pct_lwm</code>
        </p><a class="indexterm" name="idm44761350992176"></a><a class="indexterm" name="idm44761350990608"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_max_dirty_pages_pct_lwm"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-max-dirty-pages-pct-lwm=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_dirty_pages_pct_lwm">innodb_max_dirty_pages_pct_lwm</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>数値</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">10</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">99.99</code></td>
</tr></tbody></table></div><p>
          ダーティページ率を制御するために事前フラッシュが有効になる <a class="link" href="glossary.html#glos_dirty_page" title="ダーティーページ">dirty pages</a> の割合を表す最低水位標を定義します。 値 0 を指定すると、事前フラッシュ動作が完全に無効になります。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-flushing" title="15.8.3.5 バッファープールのフラッシュの構成">セクション15.8.3.5「バッファープールのフラッシュの構成」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_max_purge_lag"></a>
          <code class="literal">innodb_max_purge_lag</code>
        </p><a class="indexterm" name="idm44761350959056"></a><a class="indexterm" name="idm44761350957504"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_max_purge_lag"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-max-purge-lag=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag">innodb_max_purge_lag</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
          必要な最大パージラグを定義します。 この値を超えると、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code> および <code class="literal">DELETE</code> 操作に遅延が課され、パージが捕捉されるまでの時間が許可されます。 デフォルト値は 0 です。これは、最大パージラグおよび遅延がないことを意味します。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-purge-configuration" title="15.8.9 パージ構成">セクション15.8.9「パージ構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_max_purge_lag_delay"></a>
          <code class="literal">innodb_max_purge_lag_delay</code>
        </p><a class="indexterm" name="idm44761350923472"></a><a class="indexterm" name="idm44761350921904"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_max_purge_lag_delay"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-max-purge-lag-delay=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag_delay">innodb_max_purge_lag_delay</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">10000000</code></td>
</tr></tbody></table></div><p>
          <code class="literal">innodb_max_purge_lag</code> しきい値を超えた場合に課される遅延の最大遅延をマイクロ秒単位で指定します。 指定された <code class="literal">innodb_max_purge_lag_delay</code> 値は、<code class="literal">innodb_max_purge_lag</code> 式で計算された遅延期間の上限です。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-purge-configuration" title="15.8.9 パージ構成">セクション15.8.9「パージ構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_max_undo_log_size"></a>
          <code class="literal">innodb_max_undo_log_size</code>
        </p><a class="indexterm" name="idm44761350887952"></a><a class="indexterm" name="idm44761350886400"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_max_undo_log_size"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-max-undo-log-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_undo_log_size">innodb_max_undo_log_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">1073741824</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">10485760</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">2**64-1</code></td>
</tr></tbody></table></div><p>
          undo テーブルスペースのしきい値サイズを定義します。 undo テーブルスペースがしきい値を超えると、<code class="literal">innodb_undo_log_truncate</code> が有効になっているときに切り捨てられるようにマークできます。 デフォルト値は 1073741824 バイト (1024 MiB) です。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#truncate-undo-tablespace" title="undo テーブルスペースの切捨て">undo テーブルスペースの切捨て</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_merge_threshold_set_all_debug"></a>
          <code class="literal">innodb_merge_threshold_set_all_debug</code>
        </p><a class="indexterm" name="idm44761350854000"></a><a class="indexterm" name="idm44761350852880"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_merge_threshold_set_all_debug"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-merge-threshold-set-all-debug=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_merge_threshold_set_all_debug">innodb_merge_threshold_set_all_debug</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">50</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">50</code></td>
</tr></tbody></table></div><p>
          ディクショナリキャッシュに現在存在するすべてのインデックスの現在の <code class="literal">MERGE_THRESHOLD</code> 設定をオーバーライドするインデックスページのページフルパーセント値を定義します。 このオプションは、デバッグサポートが <code class="option">WITH_DEBUG</code> <span class="command"><strong>CMake</strong></span> オプションを使用してコンパイルされている場合にのみ使用できます。 関連情報については、<a class="xref" href="innodb-storage-engine.html#index-page-merge-threshold" title="15.8.11 インデックスページのマージしきい値の構成">セクション15.8.11「インデックスページのマージしきい値の構成」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_monitor_disable"></a>
          <code class="literal">innodb_monitor_disable</code>
        </p><a class="indexterm" name="idm44761350819664"></a><a class="indexterm" name="idm44761350818112"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_monitor_disable"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-monitor-disable={counter|module|pattern|all}</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_disable">innodb_monitor_disable</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_metrics_counter" title="メトリックカウンタ">metrics counters</a> を無効にします。 カウンタデータは <code class="literal">INFORMATION_SCHEMA.INNODB_METRICS</code> テーブルを使用してクエリーすることができます。 使用法については、<a class="xref" href="innodb-storage-engine.html#innodb-information-schema-metrics-table" title="15.15.6 InnoDB INFORMATION_SCHEMA メトリックテーブル">セクション15.15.6「InnoDB INFORMATION_SCHEMA メトリックテーブル」</a>を参照してください。 
        </p><p>
          <code class="literal">innodb_monitor_disable='latch'</code>は、<code class="literal">SHOW ENGINE INNODB MUTEX</code> の統計収集を無効にします。 詳細は、<a class="xref" href="sql-statements.html#show-engine" title="13.7.7.15 SHOW ENGINE ステートメント">セクション13.7.7.15「SHOW ENGINE ステートメント」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_monitor_enable"></a>
          <code class="literal">innodb_monitor_enable</code>
        </p><a class="indexterm" name="idm44761350788752"></a><a class="indexterm" name="idm44761350787200"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_monitor_enable"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-monitor-enable={counter|module|pattern|all}</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_enable">innodb_monitor_enable</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_metrics_counter" title="メトリックカウンタ">metrics counters</a> を有効にします。 カウンタデータは <code class="literal">INFORMATION_SCHEMA.INNODB_METRICS</code> テーブルを使用してクエリーすることができます。 使用法については、<a class="xref" href="innodb-storage-engine.html#innodb-information-schema-metrics-table" title="15.15.6 InnoDB INFORMATION_SCHEMA メトリックテーブル">セクション15.15.6「InnoDB INFORMATION_SCHEMA メトリックテーブル」</a>を参照してください。 
        </p><p>
          <code class="literal">innodb_monitor_enable='latch'</code>では、<code class="literal">SHOW ENGINE INNODB MUTEX</code> の統計収集が可能です。 詳細は、<a class="xref" href="sql-statements.html#show-engine" title="13.7.7.15 SHOW ENGINE ステートメント">セクション13.7.7.15「SHOW ENGINE ステートメント」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_monitor_reset"></a>
          <code class="literal">innodb_monitor_reset</code>
        </p><a class="indexterm" name="idm44761350758160"></a><a class="indexterm" name="idm44761350756608"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_monitor_reset"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-monitor-reset={counter|module|pattern|all}</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_reset">innodb_monitor_reset</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">empty string</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">counter</code></p><p class="valid-value"><code class="literal">module</code></p><p class="valid-value"><code class="literal">pattern</code></p><p class="valid-value"><code class="literal">all</code></p></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_metrics_counter" title="メトリックカウンタ">metrics counters</a> のカウント値をゼロにリセットします。 カウンタデータは <code class="literal">INFORMATION_SCHEMA.INNODB_METRICS</code> テーブルを使用してクエリーすることができます。 使用法については、<a class="xref" href="innodb-storage-engine.html#innodb-information-schema-metrics-table" title="15.15.6 InnoDB INFORMATION_SCHEMA メトリックテーブル">セクション15.15.6「InnoDB INFORMATION_SCHEMA メトリックテーブル」</a>を参照してください。 
        </p><p>
          <code class="literal">innodb_monitor_reset='latch'</code>は、<code class="literal">SHOW ENGINE INNODB MUTEX</code> によって報告された統計をリセットします。 詳細は、<a class="xref" href="sql-statements.html#show-engine" title="13.7.7.15 SHOW ENGINE ステートメント">セクション13.7.7.15「SHOW ENGINE ステートメント」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_monitor_reset_all"></a>
          <code class="literal">innodb_monitor_reset_all</code>
        </p><a class="indexterm" name="idm44761350719344"></a><a class="indexterm" name="idm44761350717792"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_monitor_reset_all"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-monitor-reset-all={counter|module|pattern|all}</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_reset_all">innodb_monitor_reset_all</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">empty string</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">counter</code></p><p class="valid-value"><code class="literal">module</code></p><p class="valid-value"><code class="literal">pattern</code></p><p class="valid-value"><code class="literal">all</code></p></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_metrics_counter" title="メトリックカウンタ">metrics counters</a> のすべての値 (最小、最大など) をリセットします。 カウンタデータは <code class="literal">INFORMATION_SCHEMA.INNODB_METRICS</code> テーブルを使用してクエリーすることができます。 使用法については、<a class="xref" href="innodb-storage-engine.html#innodb-information-schema-metrics-table" title="15.15.6 InnoDB INFORMATION_SCHEMA メトリックテーブル">セクション15.15.6「InnoDB INFORMATION_SCHEMA メトリックテーブル」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_numa_interleave"></a>
          <code class="literal">innodb_numa_interleave</code>
        </p><a class="indexterm" name="idm44761350683872"></a><a class="indexterm" name="idm44761350682400"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_numa_interleave"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-numa-interleave[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_numa_interleave">innodb_numa_interleave</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          NUMA インターリーブメモリーポリシーを有効にして、<code class="literal">InnoDB</code> バッファプールを割り当てます。 <code class="literal">innodb_numa_interleave</code> が有効な場合、NUMA メモリーポリシーは <span class="command"><strong>mysqld</strong></span> プロセスに対して <code class="literal">MPOL_INTERLEAVE</code> に設定されます。 <code class="literal">InnoDB</code> バッファプールが割り当てられると、NUMA メモリーポリシーは <code class="literal">MPOL_DEFAULT</code> に戻されます。 <code class="literal">innodb_numa_interleave</code> オプションを使用できるようにするには、NUMA 対応の Linux システムで MySQL をコンパイルする必要があります。 
        </p><p>
          <span class="command"><strong>CMake</strong></span> では、現在のプラットフォームに <code class="literal">NUMA</code> サポートがあるかどうかに基づいて、デフォルトの <code class="option">WITH_NUMA</code> 値が設定されます。 詳細は、<a class="xref" href="installing.html#source-configuration-options" title="2.9.7 MySQL ソース構成オプション">セクション2.9.7「MySQL ソース構成オプション」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_old_blocks_pct"></a>
          <code class="literal">innodb_old_blocks_pct</code>
        </p><a class="indexterm" name="idm44761350647808"></a><a class="indexterm" name="idm44761350646256"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_old_blocks_pct"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-old-blocks-pct=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_pct">innodb_old_blocks_pct</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">37</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">5</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">95</code></td>
</tr></tbody></table></div><p>
          古いブロック<a class="link" href="glossary.html#glos_sublist" title="サブリスト">サブリスト</a>で使用される <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>の概算割合を指定します。 値の範囲は 5 から 95 です。 デフォルト値は 37 (つまり、プールの 3/8 ) です。 多くの場合、<code class="literal">innodb_old_blocks_time</code> と組み合わせて使用されます。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-midpoint_insertion" title="15.8.3.3 バッファープールをスキャンに耐えられるようにする">セクション15.8.3.3「バッファープールをスキャンに耐えられるようにする」</a>を参照してください。 バッファープールの管理、<a class="link" href="glossary.html#glos_lru" title="LRU">LRU</a> アルゴリズム、および <a class="link" href="glossary.html#glos_eviction" title="エビクション">eviction</a> ポリシーについては、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool" title="15.5.1 バッファプール">セクション15.5.1「バッファプール」</a> を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_old_blocks_time"></a>
          <code class="literal">innodb_old_blocks_time</code>
        </p><a class="indexterm" name="idm44761350609376"></a><a class="indexterm" name="idm44761350607824"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_old_blocks_time"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-old-blocks-time=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_time">innodb_old_blocks_time</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">1000</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">2**32-1</code></td>
</tr></tbody></table></div><p>
          ゼロ以外の値は、<a class="link" href="glossary.html#glos_full_table_scan" title="テーブルの完全スキャン">full table scan</a> の実行中など、短い期間のみ参照されるデータによって入力される <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> から保護します。 この値を大きくすると、テーブルの完全スキャンがバッファープール内にキャッシュされたデータとやりとりすることからさらに保護されます。 
        </p><p>
          新しいサブリストに移動する前に、古い <a class="link" href="glossary.html#glos_sublist" title="サブリスト">sublist</a> に挿入されたブロックが最初のアクセス後も保持される必要がある時間をミリ秒単位で指定します。 値を 0 にすると、古いサブリストに挿入されたブロックは、挿入後にどのくらいの期間でアクセスが発生するのかには関係なく、最初のアクセスの直後に新しいサブリストに移動します。 値が 0 より大きい場合、最初のアクセス後に少なくとも何ミリ秒もアクセスが発生するまで、ブロックは古いサブリストに残ります。 たとえば、1000 の値では、ブロックは最初のアクセス後、それらが新しいサブリストに移動される資格を得るまで、1 秒間古いサブリストにとどまります。 
        </p><p>
          デフォルト値は 1000 です。
        </p><p>
          多くの場合、この変数は <code class="literal">innodb_old_blocks_pct</code> と組み合わせて使用されます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-midpoint_insertion" title="15.8.3.3 バッファープールをスキャンに耐えられるようにする">セクション15.8.3.3「バッファープールをスキャンに耐えられるようにする」</a>を参照してください。 バッファープールの管理、<a class="link" href="glossary.html#glos_lru" title="LRU">LRU</a> アルゴリズム、および <a class="link" href="glossary.html#glos_eviction" title="エビクション">eviction</a> ポリシーについては、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool" title="15.5.1 バッファプール">セクション15.5.1「バッファプール」</a> を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_online_alter_log_max_size"></a>
          <code class="literal">innodb_online_alter_log_max_size</code>
        </p><a class="indexterm" name="idm44761350567856"></a><a class="indexterm" name="idm44761350566272"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_online_alter_log_max_size"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-online-alter-log-max-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_online_alter_log_max_size">innodb_online_alter_log_max_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">134217728</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">65536</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">2**64-1</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> テーブルの <a class="link" href="glossary.html#glos_online_ddl" title="オンライン DDL">online DDL</a> 操作中に使用される一時ログファイルのサイズの上限をバイト単位で指定します。 作成されるインデックスまたは変更されるテーブルごとに、このようなログファイルが 1 つ存在します。 このログファイルには、DDL 操作時にテーブルで挿入、更新、または削除されたデータが格納されます。 一時ログファイルは、<code class="literal">innodb_sort_buffer_size</code> の値で必要になったときに、最大で <code class="literal">innodb_online_alter_log_max_size</code> で指定された最大値まで拡張されます。 一時ログファイルが上限サイズを超えると、<code class="literal">ALTER TABLE</code> 操作は失敗し、コミットされていないすべての同時 DML 操作がロールバックされます。 したがって、このオプションの値を大きくすると、オンライン DDL 操作中に発生する DML が増えますが、ログからデータを適用するためにテーブルがロックされているときの DDL 操作の終了時の期間も長くなります。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_open_files"></a>
          <code class="literal">innodb_open_files</code>
        </p><a class="indexterm" name="idm44761350530752"></a><a class="indexterm" name="idm44761350529200"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_open_files"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-open-files=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_open_files">innodb_open_files</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">-1</code> (自動サイズ設定を示します。このリテラル値を割り当てないでください)</td>
</tr><tr><th>最小値</th>
<td><code class="literal">10</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
          この変数は、複数の <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_tablespace" title="テーブルスペース">tablespaces</a> を使用する場合にのみ関連します。 MySQL で一度に開いたままにできる <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル"><code class="filename">.ibd</code> ファイル</a>の最大数が指定されます。 最小値は 10 です。 デフォルト値は、<code class="literal">innodb_file_per_table</code> が有効になっていない場合は 300 で、それ以外の場合は 300 以上および <code class="literal">table_open_cache</code> です。 
        </p><p>
          <code class="filename">.ibd</code> ファイルで使用されるファイルディスクリプタは、<code class="literal">InnoDB</code> テーブルでのみ使用されます。 これらは、<code class="literal">open_files_limit</code> システム変数で指定されたものとは独立しており、テーブルキャッシュの操作には影響しません。 一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8 InnoDB ディスク I/O の最適化">セクション8.5.8「InnoDB ディスク I/O の最適化」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_optimize_fulltext_only"></a>
          <code class="literal">innodb_optimize_fulltext_only</code>
        </p><a class="indexterm" name="idm44761350489920"></a><a class="indexterm" name="idm44761350488352"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_optimize_fulltext_only"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-optimize-fulltext-only[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_optimize_fulltext_only">innodb_optimize_fulltext_only</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> テーブルでの <code class="literal">OPTIMIZE TABLE</code> の動作方法を変更します。 <code class="literal">FULLTEXT</code> インデックスを含む <code class="literal">InnoDB</code> テーブルのメンテナンス操作時に、一時的に有効にするために使用されます。 
        </p><p>
          デフォルトでは、<code class="literal">OPTIMIZE TABLE</code> はテーブルの <a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">clustered index</a> のデータを再編成します。 このオプションを有効にすると、<code class="literal">OPTIMIZE TABLE</code> はテーブルデータの再編成をスキップし、かわりに <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> インデックスに対して新しく追加、削除および更新されたトークンデータを処理します。 詳細は、<a class="xref" href="functions.html#fulltext-optimize" title="InnoDB 全文インデックスの最適化">InnoDB 全文インデックスの最適化</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_page_cleaners"></a>
          <code class="literal">innodb_page_cleaners</code>
        </p><a class="indexterm" name="idm44761350454256"></a><a class="indexterm" name="idm44761350452704"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_page_cleaners"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-page-cleaners=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_cleaners">innodb_page_cleaners</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">4</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">64</code></td>
</tr></tbody></table></div><p>
          バッファープールインスタンスからダーティーページをフラッシュするページクリーナースレッドの数。 ページクリーナスレッドは、フラッシュリストおよび LRU フラッシュを実行します。 ページクリーナスレッドが複数ある場合、バッファプールインスタンスごとにバッファプールのフラッシュタスクがアイドル状態のページクリーナスレッドにディスパッチされます。 <code class="literal">innodb_page_cleaners</code> のデフォルト値は 4 です。 ページクリーナスレッドの数がバッファプールインスタンスの数を超えると、<code class="literal">innodb_page_cleaners</code> は自動的に <code class="literal">innodb_buffer_pool_instances</code> と同じ値に設定されます。 
        </p><p>
          ダーティページをバッファプールインスタンスからデータファイルにフラッシュするときにワークロードが書込み IO バインドされている場合、およびシステムハードウェアに使用可能な容量がある場合は、ページクリーナスレッドの数を増やすと書込み IO スループットの向上に役立つことがあります。
        </p><p>
          マルチスレッドページクリーナのサポートは、停止フェーズおよびリカバリフェーズまで拡張されています。
        </p><p>
          <code class="literal">setpriority()</code> システムコールは、サポートされている Linux プラットフォームで使用され、<span class="command"><strong>mysqld</strong></span> 実行ユーザーが <code class="literal">page_cleaner</code> スレッドに他の MySQL および <code class="literal">InnoDB</code> スレッドよりも優先順位を与えることを認可されている場合、ページフラッシュが現在のワークロードに対応できるようにします。<code class="literal">setpriority()</code> のサポートは、次の <code class="literal">InnoDB</code> 起動メッセージで示されます:
        </p><pre class="programlisting">[Note] InnoDB: If the mysqld execution user is authorized, page cleaner
thread priority can be changed. See the man page of setpriority().
</pre><p>
          サーバーの起動および停止が systemd によって管理されていないシステムでは、<code class="filename">/etc/security/limits.conf</code> で <span class="command"><strong>mysqld</strong></span> 実行ユーザー認可を構成できます。 たとえば、<span class="command"><strong>mysqld</strong></span> が <code class="literal">mysql</code> ユーザーで実行されている場合、次の行を<code class="filename">/etc/security/limits.conf</code> に追加することで <code class="literal">mysql</code> ユーザーを認可できます: 
        </p><pre class="programlisting">mysql              hard    nice       -20
mysql              soft    nice       -20
</pre><p>
          systemd 管理対象システムの場合は、ローカライズされた systemd 構成ファイルで <code class="literal">LimitNICE=-20</code> を指定することで同じことを実現できます。 たとえば、<code class="filename">/etc/systemd/system/mysqld.service.d/override.conf</code> で <code class="filename">override.conf</code> という名前のファイルを作成し、次のエントリを追加します: 
        </p><pre class="programlisting">[Service]
LimitNICE=-20
</pre><p>
          <code class="filename">override.conf</code> を作成または変更した後、systemd 構成をリロードし、MySQL サービスを再起動するように systemd に指示します:
        </p><pre class="programlisting">systemctl daemon-reload
systemctl restart mysqld  # RPM platforms
systemctl restart mysql   # Debian platforms
</pre><p>
          ローカライズされた systemd 構成ファイルの使用の詳細は、<a class="xref" href="installing.html#systemd-mysql-configuration" title="MySQL の systemd の構成">MySQL の systemd の構成</a> を参照してください。
        </p><p>
          <span class="command"><strong>mysqld</strong></span> 実行ユーザーを認可した後、<span class="command"><strong>cat</strong></span> コマンドを使用して、<span class="command"><strong>mysqld</strong></span> プロセスに構成されている <code class="literal">Nice</code> 制限を確認します:
        </p><pre class="programlisting">shell&gt; cat /proc/<em class="replaceable"><code>mysqld_pid</code></em>/limits | grep nice
Max nice priority         18446744073709551596 18446744073709551596
</pre></li><li class="listitem"><p><a name="sysvar_innodb_page_size"></a>
          <code class="literal">innodb_page_size</code>
        </p><a class="indexterm" name="idm44761350391968"></a><a class="indexterm" name="idm44761350390432"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_page_size"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-page-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size">innodb_page_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">16384</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">4096</code></p><p class="valid-value"><code class="literal">8192</code></p><p class="valid-value"><code class="literal">16384</code></p><p class="valid-value"><code class="literal">32768</code></p><p class="valid-value"><code class="literal">65536</code></p></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_tablespace" title="テーブルスペース">tablespaces</a> 用の <a class="link" href="glossary.html#glos_page_size" title="page size">page size</a> を指定します。 値はバイト単位または KB 単位で指定できます。 たとえば、16K バイトのページサイズ値は 16384、16K バイト、または 16K と指定できます。 
        </p><p>
          <code class="literal">innodb_page_size</code> は、MySQL インスタンスの初期化前にのみ構成でき、後で変更することはできません。 値を指定しない場合、インスタンスはデフォルトのページサイズを使用して初期化されます。 <a class="xref" href="innodb-storage-engine.html#innodb-init-startup-configuration" title="15.8.1 InnoDB の起動構成">セクション15.8.1「InnoDB の起動構成」</a>を参照してください。 
        </p><p>
          32KB と 64KB の両方のページサイズで、行の最大長は約 16000 バイトです。 <code class="literal">innodb_page_size</code> が 32KB または 64KB に設定されている場合、<code class="literal">ROW_FORMAT=COMPRESSED</code> はサポートされません。 <code class="literal">innodb_page_size=32KB</code> の場合、エクステントサイズは 2MB です。 <code class="literal">innodb_page_size=64KB</code> の場合、エクステントサイズは 4MB です。32KB または 64KB のページサイズを使用する場合は、<code class="literal">innodb_log_buffer_size</code> を 16M (デフォルト) 以上に設定する必要があります。 
        </p><p>
          デフォルトの 16KB ページサイズ以上は、<a class="link" href="glossary.html#glos_workload" title="ワークロード">workloads</a> の広範囲、特にバルク更新を伴うテーブルスキャンおよび DML 操作を含むクエリーに適しています。 単一ページに多数の行が含まれている場合、競合が問題になる可能性がある多数の小さい書込みを含む <a class="link" href="glossary.html#glos_oltp" title="OLTP">OLTP</a> ワークロードでは、ページサイズを小さくする方が効率的です。 ページを小さくすると、一般に小さなブロックサイズが使用される <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> ストレージデバイスの効率性が高くなる可能性もあります。 <code class="literal">InnoDB</code> のページサイズをストレージデバイスのブロックサイズに近づけると、ディスクに再度書き込まれる未変更データの量が最小限になります。 
        </p><p>
          最初のシステムテーブルスペースデータファイル (<code class="literal">ibdata1</code>) の最小ファイルサイズは、<code class="literal">innodb_page_size</code> の値によって異なります。 詳細は、<code class="literal">innodb_data_file_path</code> オプションの説明を参照してください。 
        </p><p>
          一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8 InnoDB ディスク I/O の最適化">セクション8.5.8「InnoDB ディスク I/O の最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_parallel_read_threads"></a>
          <code class="literal">innodb_parallel_read_threads</code>
        </p><a class="indexterm" name="idm44761350338096"></a><a class="indexterm" name="idm44761350336528"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_parallel_read_threads"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-parallel-read-threads=#</code></td>
</tr><tr><th>導入</th>
<td>8.0.14</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_parallel_read_threads">innodb_parallel_read_threads</a></code></td>
</tr><tr><th>スコープ</th>
<td>セッション</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">4</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">256</code></td>
</tr></tbody></table></div><p>
          パラレルクラスタインデックス読取りに使用できるスレッドの数を定義します。 パーティションのパラレルスキャンは、MySQL 8.0.17 でサポートされています。 パラレル読取りスレッドを使用すると、<code class="literal">CHECK TABLE</code> のパフォーマンスを向上できます。 <code class="literal">InnoDB</code> は、<code class="literal">CHECK TABLE</code> 操作中にクラスタ化されたインデックスを 2 回読み取ります。 2 番目の読取りはパラレルで実行できます。 この機能は、セカンダリインデックススキャンには適用されません。 パラレルクラスタインデックス読取りを実行するには、<code class="literal">innodb_parallel_read_threads</code> セッション変数を 1 より大きい値に設定する必要があります。 パラレルクラスタインデックス読取りの実行に使用されるスレッドの実際の数は、<code class="literal">innodb_parallel_read_threads</code> 設定またはスキャンするインデックスサブツリーの数 (いずれか小さい方) によって決まります。 スキャン中にバッファープールに読み取られたページは、空きバッファープールページが必要なときにすぐに破棄できるように、バッファープール LRU リストの末尾に保持されます。 
        </p><p>
          MySQL 8.0.17 では、パラレル読取りスレッドの最大数 (256) は、すべてのクライアント接続のスレッドの合計数です。 スレッド制限に達すると、接続は単一スレッドの使用にフォールバックします。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_print_all_deadlocks"></a>
          <code class="literal">innodb_print_all_deadlocks</code>
        </p><a class="indexterm" name="idm44761350297168"></a><a class="indexterm" name="idm44761350295600"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_print_all_deadlocks"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-print-all-deadlocks[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_print_all_deadlocks">innodb_print_all_deadlocks</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><a class="indexterm" name="idm44761350273520"></a><p>
          このオプションを有効にすると、<code class="literal">mysqld</code> <a class="link" href="server-administration.html#error-log" title="5.4.2 エラーログ">エラーログ</a>に、<code class="literal">InnoDB</code> のユーザートランザクション内のすべての<a class="link" href="glossary.html#glos_deadlock" title="デッドロック">デッドロック</a>に関する情報が記録されます。 それ以外の場合は、<code class="literal">SHOW ENGINE INNODB STATUS</code> コマンドを使用すると、最後のデッドロックに関する情報のみが表示されます。 状況は <code class="literal">InnoDB</code> によってただちに検出され、いずれかのトランザクションが自動的にロールバックされるため、場合によっては <code class="literal">InnoDB</code> デッドロックは必ずしも問題ではありません。 このオプションを使用して、ロールバックを検出してその操作を再試行するための適切なエラー処理ロジックがアプリケーションにない場合にデッドロックが発生する理由をトラブルシューティングできます。 多数のデッドロックが発生する場合は、各トランザクションが同じ順序でテーブルにアクセスするように (これにより、デッドロックの状況が回避されます)、複数のテーブルに対して <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> または <code class="literal">SELECT ... FOR UPDATE</code> ステートメントを発行するトランザクションを再構築する必要があることを示している可能性があります。 
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-deadlocks" title="15.7.5 InnoDB のデッドロック">セクション15.7.5「InnoDB のデッドロック」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_print_ddl_logs"></a>
          <code class="literal">innodb_print_ddl_logs</code>
        </p><a class="indexterm" name="idm44761350259952"></a><a class="indexterm" name="idm44761350258400"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_print_ddl_logs"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-print-ddl-logs[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_print_ddl_logs">innodb_print_ddl_logs</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          このオプションを有効にすると、MySQL は DDL ログを <code class="literal">stderr</code> に書き込みます。 詳細は、<a class="xref" href="sql-statements.html#atomic-ddl-view-logs" title="DDL ログの表示">DDL ログの表示</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_purge_batch_size"></a>
          <code class="literal">innodb_purge_batch_size</code>
        </p><a class="indexterm" name="idm44761350232240"></a><a class="indexterm" name="idm44761350230688"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_purge_batch_size"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-purge-batch-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_batch_size">innodb_purge_batch_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">300</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">5000</code></td>
</tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_history_list" title="履歴リスト">history list</a> から一度に解析および処理をパージする undo ログページの数を定義します。 マルチスレッドパージ構成では、コーディネータパージスレッドは <code class="literal">innodb_purge_batch_size</code> を <code class="literal">innodb_purge_threads</code> で除算し、その数のページを各パージスレッドに割り当てます。 <code class="literal">innodb_purge_batch_size</code> 変数では、undo ログを 128 回反復するたびに消去する undo ログページの数も定義されます。 
        </p><p>
          <code class="literal">innodb_purge_batch_size</code> オプションは、<code class="literal">innodb_purge_threads</code> 設定と組み合せた高度なパフォーマンスチューニングを目的としています。 ほとんどのユーザーは、<code class="literal">innodb_purge_batch_size</code> をデフォルト値から変更する必要はありません。 
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-purge-configuration" title="15.8.9 パージ構成">セクション15.8.9「パージ構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_purge_threads"></a>
          <code class="literal">innodb_purge_threads</code>
        </p><a class="indexterm" name="idm44761350191568"></a><a class="indexterm" name="idm44761350190016"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_purge_threads"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-purge-threads=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_threads">innodb_purge_threads</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">4</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">32</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_purge" title="パージ">purge</a> 操作専用のバックグラウンドスレッドの数。 この値を大きくすると、追加のパージスレッドが作成されるため、<a class="link" href="glossary.html#glos_dml" title="DML">DML</a> 操作が複数のテーブルで実行されるシステムの効率が向上します。 
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-purge-configuration" title="15.8.9 パージ構成">セクション15.8.9「パージ構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_purge_rseg_truncate_frequency"></a>
          <code class="literal">innodb_purge_rseg_truncate_frequency</code>
        </p><a class="indexterm" name="idm44761350156624"></a><a class="indexterm" name="idm44761350155024"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_purge_rseg_truncate_frequency"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-purge-rseg-truncate-frequency=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_rseg_truncate_frequency">innodb_purge_rseg_truncate_frequency</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">128</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">128</code></td>
</tr></tbody></table></div><p>
          パージが起動された回数に関して、パージシステムがロールバックセグメントを解放する頻度を定義します。 undo テーブルスペースは、ロールバックセグメントが解放されるまで切り捨てられません。 通常、パージシステムは、パージが起動される 128 回ごとにロールバックセグメントを解放します。 デフォルト値は 128 です。 この値を減らすと、パージスレッドがロールバックセグメントを解放する頻度が高くなります。 
        </p><p>
          <code class="literal">innodb_purge_rseg_truncate_frequency</code> は、<code class="literal">innodb_undo_log_truncate</code> での使用を目的としています。 詳細は、<a class="xref" href="innodb-storage-engine.html#truncate-undo-tablespace" title="undo テーブルスペースの切捨て">undo テーブルスペースの切捨て</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_random_read_ahead"></a>
          <code class="literal">innodb_random_read_ahead</code>
        </p><a class="indexterm" name="idm44761350121760"></a><a class="indexterm" name="idm44761350120208"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_random_read_ahead"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-random-read-ahead[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_random_read_ahead">innodb_random_read_ahead</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> の I/O を最適化するために、ランダムな<a class="link" href="glossary.html#glos_read_ahead" title="先読み">先読み</a>技術を有効にします。
        </p><p>
          様々なタイプの先読みリクエストのパフォーマンスに関する考慮事項の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-read_ahead" title="15.8.3.4 InnoDB バッファープールのプリフェッチ (先読み) の構成">セクション15.8.3.4「InnoDB バッファープールのプリフェッチ (先読み) の構成」</a> を参照してください。 一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8 InnoDB ディスク I/O の最適化">セクション8.5.8「InnoDB ディスク I/O の最適化」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_read_ahead_threshold"></a>
          <code class="literal">innodb_read_ahead_threshold</code>
        </p><a class="indexterm" name="idm44761350091712"></a><a class="indexterm" name="idm44761350090144"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_read_ahead_threshold"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-read-ahead-threshold=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_ahead_threshold">innodb_read_ahead_threshold</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">56</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">64</code></td>
</tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>にページをプリフェッチする際に <code class="literal">InnoDB</code> で使用される線形の<a class="link" href="glossary.html#glos_read_ahead" title="先読み">先読み</a>の感度を制御します。 <code class="literal">InnoDB</code> が少なくとも <code class="literal">innodb_read_ahead_threshold</code> ページを<a class="link" href="glossary.html#glos_extent" title="エクステント">エクステント</a> (64 ページ) から連続して読み取る場合は、次のエクステント全体の非同期読み取りが開始されます。 許可される値の範囲は 0 から 64 までです。 値 0 は先読みを無効にします。 デフォルトの 56 では、<code class="literal">InnoDB</code> は次のエクステント全体の非同期読み取りを開始するために、少なくとも 56 ページをエクステントから連続して読み取る必要があります。 
        </p><p>
          先読みメカニズムを使用して読み取られるページの数と、アクセスされずにバッファープールから削除されるページの数を把握しておくと、<code class="literal">innodb_read_ahead_threshold</code> 設定を微調整する場合に役立ちます。 <code class="literal">SHOW ENGINE INNODB STATUS</code> 出力には、<code class="literal">Innodb_buffer_pool_read_ahead</code> および <code class="literal">Innodb_buffer_pool_read_ahead_evicted</code> のグローバルステータス変数からのカウンタ情報が表示されます。これらの変数は、先読みリクエストによって <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> に取り込まれたページ数と、アクセスされたことなくバッファプールから <a class="link" href="glossary.html#glos_eviction" title="エビクション">evicted</a> のそのようなページ数をそれぞれレポートします。 ステータス変数は、最後のサーバー再起動以降のグローバル値を報告します。 
        </p><p>
          <code class="literal">SHOW ENGINE INNODB STATUS</code> には、先読みページが読み取られる速度と、そのようなページがアクセスされずに削除される速度も表示されます。 秒当たりの平均は、<code class="literal">SHOW ENGINE INNODB STATUS</code> の最後の呼出し以降に収集された統計に基づき、<code class="literal">SHOW ENGINE INNODB STATUS</code> 出力の <code class="literal">BUFFER POOL AND MEMORY</code> セクションに表示されます。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-read_ahead" title="15.8.3.4 InnoDB バッファープールのプリフェッチ (先読み) の構成">セクション15.8.3.4「InnoDB バッファープールのプリフェッチ (先読み) の構成」</a>を参照してください。 一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8 InnoDB ディスク I/O の最適化">セクション8.5.8「InnoDB ディスク I/O の最適化」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_read_io_threads"></a>
          <code class="literal">innodb_read_io_threads</code>
        </p><a class="indexterm" name="idm44761350039296"></a><a class="indexterm" name="idm44761350037744"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_read_io_threads"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-read-io-threads=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_io_threads">innodb_read_io_threads</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">4</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">64</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> での読み取り操作で使用される I/O スレッドの数です。 書き込みスレッドで対応するものは、<code class="literal">innodb_write_io_threads</code> です。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-multiple_io_threads" title="15.8.5 InnoDB バックグラウンド I/O スレッドの数の構成">セクション15.8.5「InnoDB バックグラウンド I/O スレッドの数の構成」</a>を参照してください。 一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8 InnoDB ディスク I/O の最適化">セクション8.5.8「InnoDB ディスク I/O の最適化」</a>を参照してください。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            Linux システムでは、デフォルトの <code class="literal">innodb_read_io_threads</code> 設定で複数 (一般には 12 台よりも多く) の MySQL サーバーを実行すると、<code class="literal">innodb_write_io_threads</code> および Linux の <code class="literal">aio-max-nr</code> 設定がシステムの制限を超過する可能性があります。 理想的には、<code class="literal">aio-max-nr</code> 設定を増やします。回避策として、いずれかまたは両方の MySQL 変数の設定を減らすことができます。 
          </p></div></li><li class="listitem"><p><a name="sysvar_innodb_read_only"></a>
          <code class="literal">innodb_read_only</code>
        </p><a class="indexterm" name="idm44761349999952"></a><a class="indexterm" name="idm44761349998416"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_read_only"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-read-only[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_only">innodb_read_only</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> を読取り専用モードで起動します。 読み取り専用メディア上のデータベースアプリケーションまたはデータセットを配布するために使用されます。 複数のインスタンス間で同じデータディレクトリを共有する際に、データウェアハウスで使用することもできます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-read-only-instance" title="15.8.2 読み取り専用操作用の InnoDB の構成">セクション15.8.2「読み取り専用操作用の InnoDB の構成」</a>を参照してください。 
        </p><p>
          以前は、<code class="literal">innodb_read_only</code> システム変数を有効にすると、<code class="literal">InnoDB</code> ストレージエンジンのテーブルの作成および削除のみができなくなりました。 MySQL 8.0 の時点では、<code class="literal">innodb_read_only</code> を有効にすると、すべてのストレージエンジンでこれらの操作が防止されます。 ストレージエンジンのテーブルの作成および削除操作では、<code class="literal">mysql</code> システムデータベース内のデータディクショナリテーブルが変更されますが、これらのテーブルは <code class="literal">InnoDB</code> ストレージエンジンを使用するため、<code class="literal">innodb_read_only</code> が有効になっている場合は変更できません。 データディクショナリテーブルの変更を必要とする他のテーブル操作にも、同じ原則が適用されます。 例: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">innodb_read_only</code> システム変数が有効になっている場合、<code class="literal">InnoDB</code> を使用するデータディクショナリの統計テーブルを更新できないため、<code class="literal">ANALYZE TABLE</code> が失敗することがあります。 キー分散を更新する <code class="literal">ANALYZE TABLE</code> 操作では、操作によってテーブル自体が更新された場合でも (<code class="literal">MyISAM</code> テーブルの場合など)、障害が発生する可能性があります。 更新された分散統計を取得するには、<code class="literal">information_schema_stats_expiry=0</code> を設定します。 
            </p></li><li class="listitem"><p>
              データディクショナリに格納されているストレージエンジンの指定が更新されるため、<code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ENGINE=<em class="replaceable"><code>engine_name</code></em></code> は失敗します。
            </p></li></ul></div><p>
          また、<code class="literal">mysql</code> システムデータベースの他のテーブルでは、MySQL 8.0 の <code class="literal">InnoDB</code> ストレージエンジンが使用されます。 これらのテーブルを読取り専用にすると、テーブルを変更する操作が制限されます。 例: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              付与テーブルで <code class="literal">InnoDB</code> が使用されているため、<code class="literal">CREATE USER</code> や <code class="literal">GRANT</code> などのアカウント管理ステートメントは失敗します。
            </p></li><li class="listitem"><p>
              <code class="literal">mysql.plugin</code> システムテーブルで <code class="literal">InnoDB</code> が使用されているため、<code class="literal">INSTALL PLUGIN</code> および <code class="literal">UNINSTALL PLUGIN</code> プラグイン管理ステートメントは失敗します。
            </p></li><li class="listitem"><p>
              <code class="literal">mysql.func</code> システムテーブルで <code class="literal">InnoDB</code> が使用されているため、<code class="literal">CREATE FUNCTION</code> および <code class="literal">DROP FUNCTION</code> UDF 管理ステートメントは失敗します。
            </p></li></ul></div></li><li class="listitem"><p><a name="sysvar_innodb_redo_log_archive_dirs"></a>
          <code class="literal">innodb_redo_log_archive_dirs</code>
        </p><a class="indexterm" name="idm44761349938288"></a><a class="indexterm" name="idm44761349936720"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_redo_log_archive_dirs"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-redo-log-archive-dirs</code></td>
</tr><tr><th>導入</th>
<td>8.0.17</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_redo_log_archive_dirs">innodb_redo_log_archive_dirs</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">NULL</code></td>
</tr></tbody></table></div><p>
          redo ログアーカイブファイルを作成できるラベル付きディレクトリを定義します。 複数のラベル付きディレクトリをセミコロン区切りリストで定義できます。 例: 
        </p><pre class="programlisting">innodb_redo_log_archive_dirs='label1:/backups1;label2:/backups2'
</pre><p>
          ラベルには任意の文字列を指定できますが、コロン (:) は使用できません。 空のラベルも使用できますが、この場合もコロン (:) が必要です。 
        </p><p>
          パスを指定する必要があり、ディレクトリが存在する必要があります。 パスにはコロン (':') を含めることができますが、セミコロン (;) は使用できません。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_redo_log_encrypt"></a>
          <code class="literal">innodb_redo_log_encrypt</code>
        </p><a class="indexterm" name="idm44761349906928"></a><a class="indexterm" name="idm44761349905376"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_redo_log_encrypt"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-redo-log-encrypt[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_redo_log_encrypt">innodb_redo_log_encrypt</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <a class="link" href="innodb-storage-engine.html#innodb-data-encryption" title="15.13 InnoDB 保存データ暗号化">data-at-rest encryption feature</a> を使用して暗号化されたテーブルの redo ログデータの暗号化を制御します。 redo ログデータの暗号化は、デフォルトで無効になっています。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-redo-log" title="redo ログの暗号化">redo ログの暗号化</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_replication_delay"></a>
          <code class="literal">innodb_replication_delay</code>
        </p><a class="indexterm" name="idm44761349878256"></a><a class="indexterm" name="idm44761349876704"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_replication_delay"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-replication-delay=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_replication_delay">innodb_replication_delay</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
          <code class="literal">innodb_thread_concurrency</code> に到達した場合のレプリカサーバーのレプリケーションスレッド遅延 (ミリ秒)。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_rollback_on_timeout"></a>
          <code class="literal">innodb_rollback_on_timeout</code>
        </p><a class="indexterm" name="idm44761349846048"></a><a class="indexterm" name="idm44761349844480"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_rollback_on_timeout"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-rollback-on-timeout[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_on_timeout">innodb_rollback_on_timeout</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_rollback" title="ロールバック">rolls back</a> では、トランザクションタイムアウトの最後のステートメントのみがデフォルトで実行されます。 <code class="option">--innodb-rollback-on-timeout</code> が指定されている場合、トランザクションタイムアウトにより、<code class="literal">InnoDB</code> はトランザクション全体を中断およびロールバックします。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-error-handling" title="15.21.4 InnoDB のエラー処理">セクション15.21.4「InnoDB のエラー処理」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_rollback_segments"></a>
          <code class="literal">innodb_rollback_segments</code>
        </p><a class="indexterm" name="idm44761349815200"></a><a class="indexterm" name="idm44761349813648"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_rollback_segments"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-rollback-segments=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments">innodb_rollback_segments</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">128</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">128</code></td>
</tr></tbody></table></div><p>
          <code class="literal">innodb_rollback_segments</code> では、undo レコードを生成するトランザクションに対して、各 undo テーブルスペースおよびグローバル一時テーブルスペースに割り当てられる <a class="link" href="glossary.html#glos_rollback_segment" title="ロールバックセグメント">rollback segments</a> の数を定義します。 各ロールバックセグメントでサポートされるトランザクションの数は、<code class="literal">InnoDB</code> のページサイズおよび各トランザクションに割り当てられた undo ログの数によって異なります。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-undo-logs" title="15.6.6 undo ログ">セクション15.6.6「undo ログ」</a>を参照してください。 
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-multi-versioning" title="15.3 InnoDB マルチバージョン">セクション15.3「InnoDB マルチバージョン」</a>を参照してください。 undo テーブルスペースの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-undo-tablespaces" title="15.6.3.4 undo テーブルスペース">セクション15.6.3.4「undo テーブルスペース」</a> を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_saved_page_number_debug"></a>
          <code class="literal">innodb_saved_page_number_debug</code>
        </p><a class="indexterm" name="idm44761349778160"></a><a class="indexterm" name="idm44761349777040"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_saved_page_number_debug"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-saved-page-number-debug=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_saved_page_number_debug">innodb_saved_page_number_debug</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">2**23-1</code></td>
</tr></tbody></table></div><p>
          ページ番号を保存します。 <code class="literal">innodb_fil_make_page_dirty_debug</code> オプションを設定すると、<code class="literal">innodb_saved_page_number_debug</code> で定義されたページがダーティになります。 <code class="literal">innodb_saved_page_number_debug</code> オプションは、デバッグサポートが <code class="option">WITH_DEBUG</code> <span class="command"><strong>CMake</strong></span> オプションを使用してコンパイルされている場合にのみ使用できます。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_sort_buffer_size"></a>
          <code class="literal">innodb_sort_buffer_size</code>
        </p><a class="indexterm" name="idm44761349744880"></a><a class="indexterm" name="idm44761349743328"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_sort_buffer_size"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-sort-buffer-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_sort_buffer_size">innodb_sort_buffer_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">1048576</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">65536</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">67108864</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> インデックスの作成時にデータのソートに使用されるソートバッファのサイズを指定します。 指定されたサイズは、内部ソートのためにメモリーに読み取られ、ディスクに書き込まれるデータの量を定義します。 このプロセスは <span class="quote">「<span class="quote">run</span>」</span> と呼ばれます。 マージフェーズでは、指定したサイズのバッファのペアが読み取られ、マージされます。 設定が大きいほど、実行数が少なくなり、マージされます。 
        </p><p>
          このソート領域は、後続のインデックスのメンテナンス操作時ではなく、インデックスの作成時のマージソートでのみ使用されます。 インデックスの作成が完了すると、バッファーの割り当てが解除されます。 
        </p><p>
          このオプションの値は、<a class="link" href="glossary.html#glos_online_ddl" title="オンライン DDL">online DDL</a> 操作中に同時 DML を記録するために一時ログファイルを拡張する量も制御します。
        </p><p>
          この設定を構成可能にする前は、サイズは 1048576 バイト (1MB) にハードコードされていましたが、これはデフォルトのままです。
        </p><p>
          インデックスを作成する <code class="literal">ALTER TABLE</code> または <code class="literal">CREATE TABLE</code> ステートメントの実行時に、それぞれが、このオプションで定義されたサイズを持つ 3 つのバッファーが割り当てられます。 さらに、ポインタ上でソートを実行できるように、ソートバッファー内の行に補助ポインタが割り当てられます (これは、ソート操作時の行の移動とは異なります)。 
        </p><p>
          一般的なソート操作では、次のような式を使用してメモリー消費量を見積もることができます:
        </p><pre class="programlisting">(6 /*FTS_NUM_AUX_INDEX*/ * (3*@@GLOBAL.innodb_sort_buffer_size)
+ 2 * number_of_partitions * number_of_secondary_indexes_created
* (@@GLOBAL.innodb_sort_buffer_size/dict_index_get_min_size(index)*/)
* 8 /*64-bit sizeof *buf-&gt;tuples*/")
</pre><p>
          <code class="literal">@@GLOBAL.innodb_sort_buffer_size/dict_index_get_min_size(index)</code> は、保持される最大タプル数を示します。<code class="literal">2 * (@@GLOBAL.innodb_sort_buffer_size/*dict_index_get_min_size(index)*/) * 8 /*64-bit size of *buf-&gt;tuples*/</code>は、割り当てられた補助ポインタを示します。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            32 ビットの場合は、8 の代わりに 4 で乗算します。
          </p></div><p>
          全文インデックスでの並列ソートでは、<code class="literal">innodb_ft_sort_pll_degree</code> の設定で乗算します。
        </p><pre class="programlisting">(6 /*FTS_NUM_AUX_INDEX*/ * @@GLOBAL.innodb_ft_sort_pll_degree)
</pre></li><li class="listitem"><p><a name="sysvar_innodb_spin_wait_delay"></a>
          <code class="literal">innodb_spin_wait_delay</code>
        </p><a class="indexterm" name="idm44761349697424"></a><a class="indexterm" name="idm44761349695872"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_spin_wait_delay"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-spin-wait-delay=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_spin_wait_delay">innodb_spin_wait_delay</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">6</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値 (64 ビットプラットフォーム, ≤ 8.0.13)</th>
<td><code class="literal">2**64-1</code></td>
</tr><tr><th>最大値 (32 ビットプラットフォーム, ≤ 8.0.13)</th>
<td><code class="literal">2**32-1</code></td>
</tr><tr><th>最大値 (≥ 8.0.14)</th>
<td><code class="literal">1000</code></td>
</tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_spin" title="スピン">スピン</a>ロックでのポーリング間の最大遅延です。 このメカニズムの低レベルの実装は、ハードウェアとオペレーティングシステムの組み合わせによって異なるため、遅延は一定の時間間隔に対応しません。 
        </p><p>
          スピンロックポーリング遅延の期間をより詳細に制御するために、<code class="literal">innodb_spin_wait_pause_multiplier</code> 変数と組み合せて使用できます。
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-spin_lock_polling" title="15.8.8 スピンロックのポーリングの構成">セクション15.8.8「スピンロックのポーリングの構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_spin_wait_pause_multiplier"></a>
          <code class="literal">innodb_spin_wait_pause_multiplier</code>
        </p><a class="indexterm" name="idm44761349657312"></a><a class="indexterm" name="idm44761349655712"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_spin_wait_pause_multiplier"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-spin-wait-pause-multiplier=#</code></td>
</tr><tr><th>導入</th>
<td>8.0.16</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_spin_wait_pause_multiplier">innodb_spin_wait_pause_multiplier</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">50</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">100</code></td>
</tr></tbody></table></div><p>
          スレッドが mutex または rw-lock の取得を待機するときに発生するスピン待機ループ内の PAUSE 命令の数を決定するために使用される乗数値を定義します。
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-spin_lock_polling" title="15.8.8 スピンロックのポーリングの構成">セクション15.8.8「スピンロックのポーリングの構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_stats_auto_recalc"></a>
          <code class="literal">innodb_stats_auto_recalc</code>
        </p><a class="indexterm" name="idm44761349622656"></a><a class="indexterm" name="idm44761349621104"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_stats_auto_recalc"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-stats-auto-recalc[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_auto_recalc">innodb_stats_auto_recalc</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
          テーブル内のデータが大幅に変更されたあとは、<code class="literal">InnoDB</code> によって自動的に<a class="link" href="glossary.html#glos_persistent_statistics" title="永続的統計">永続的統計</a>が再計算されます。 しきい値は、テーブルの行の 10% です。 この設定は、<code class="literal">innodb_stats_persistent</code> オプションが有効な場合に作成されるテーブルに適用されます。 自動統計再計算は、<code class="literal">CREATE TABLE</code> ステートメントまたは <code class="literal">ALTER TABLE</code> ステートメントで <code class="literal">STATS_PERSISTENT=1</code> を指定して構成することもできます。 統計を生成するためにサンプリングされるデータの量は、<code class="literal">innodb_stats_persistent_sample_pages</code> 変数によって制御されます。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="15.8.10.1 永続的オプティマイザ統計のパラメータの構成">セクション15.8.10.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_stats_include_delete_marked"></a>
          <code class="literal">innodb_stats_include_delete_marked</code>
        </p><a class="indexterm" name="idm44761349588112"></a><a class="indexterm" name="idm44761349586512"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_stats_include_delete_marked"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-stats-include-delete-marked[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_include_delete_marked">innodb_stats_include_delete_marked</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          デフォルトでは、<code class="literal">InnoDB</code> は統計の計算時にコミットされていないデータを読み取ります。 テーブルから行を削除するコミットされていないトランザクションの場合、<code class="literal">InnoDB</code> では、行の見積りおよびインデックス統計の計算時に削除マークが付けられたレコードが除外されるため、<code class="literal">READ UNCOMMITTED</code> 以外のトランザクション分離レベルを使用してテーブルで同時に操作している他のトランザクションの実行計画が最適でなくなる可能性があります。 このシナリオを回避するために、<code class="literal">innodb_stats_include_delete_marked</code> を有効にして、永続オプティマイザ統計の計算時に <code class="literal">InnoDB</code> に削除マーク付きレコードが含まれるようにできます。 
        </p><p>
          <code class="literal">innodb_stats_include_delete_marked</code> が有効な場合、<code class="literal">ANALYZE TABLE</code> では、統計の再計算時に削除マークが付けられたレコードが考慮されます。
        </p><p>
          <code class="literal">innodb_stats_include_delete_marked</code> は、すべての <code class="literal">InnoDB</code> テーブルに影響するグローバル設定です。 永続オプティマイザ統計にのみ適用されます。 
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="15.8.10.1 永続的オプティマイザ統計のパラメータの構成">セクション15.8.10.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_stats_method"></a>
          <code class="literal">innodb_stats_method</code>
        </p><a class="indexterm" name="idm44761349550080"></a><a class="indexterm" name="idm44761349548528"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_stats_method"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-stats-method=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_method">innodb_stats_method</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">nulls_equal</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">nulls_equal</code></p><p class="valid-value"><code class="literal">nulls_unequal</code></p><p class="valid-value"><code class="literal">nulls_ignored</code></p></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> テーブルのインデックス値の分布に関する<a class="link" href="glossary.html#glos_statistics" title="統計">統計</a>を収集するときに、サーバーが <code class="literal">NULL</code> 値を処理する方法です。 許可される値は、<code class="literal">nulls_equal</code>、<code class="literal">nulls_unequal</code> および <code class="literal">nulls_ignored</code> です。 <code class="literal">nulls_equal</code> の場合、すべての <code class="literal">NULL</code> インデックス値は等しいとみなされ、<code class="literal">NULL</code> 値の数と等しいサイズの単一の値グループを形成します。 <code class="literal">nulls_unequal</code> の場合、<code class="literal">NULL</code> 値同士を同等として扱わず、それぞれの <code class="literal">NULL</code> はサイズが 1 の別個のグループを生成します。 <code class="literal">nulls_ignored</code> の場合、<code class="literal">NULL</code> 値は無視されます。 
        </p><p>
          テーブル統計の生成に使用される方法は、<a class="xref" href="optimization.html#index-statistics" title="8.3.8 InnoDB および MyISAM インデックス統計コレクション">セクション8.3.8「InnoDB および MyISAM インデックス統計コレクション」</a> で説明されているように、オプティマイザがクエリーを実行するためにインデックスを選択する方法に影響します。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_stats_on_metadata"></a>
          <code class="literal">innodb_stats_on_metadata</code>
        </p><a class="indexterm" name="idm44761349506736"></a><a class="indexterm" name="idm44761349505184"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_stats_on_metadata"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-stats-on-metadata[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_on_metadata">innodb_stats_on_metadata</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          このオプションは、オプティマイザ <a class="link" href="glossary.html#glos_statistics" title="統計">statistics</a> が非永続として構成されている場合にのみ適用されます。 オプティマイザ統計は、<code class="literal">innodb_stats_persistent</code> が無効な場合、または <code class="literal">STATS_PERSISTENT=0</code> を使用して個々のテーブルが作成または変更された場合、ディスクに永続化されません。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-statistics-estimation" title="15.8.10.2 非永続的オプティマイザ統計のパラメータの構成">セクション15.8.10.2「非永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。 
        </p><p>
          <code class="literal">innodb_stats_on_metadata</code> が有効になっている場合、<code class="literal">SHOW TABLE STATUS</code> などのメタデータステートメントの場合、または <code class="literal">INFORMATION_SCHEMA.TABLES</code> テーブルまたは <code class="literal">INFORMATION_SCHEMA.STATISTICS</code> テーブルにアクセスする場合、<code class="literal">InnoDB</code> は非永続 <a class="link" href="glossary.html#glos_statistics" title="統計">statistics</a> を更新します。 (これらの更新は、<code class="literal">ANALYZE TABLE</code> で実行されるものに似ています。) 無効にすると、これらの操作時に <code class="literal">InnoDB</code> によって統計が更新されません。 この設定を無効のままにすると、多数のテーブルまたはインデックスを持つスキーマのアクセス速度を向上させることができます。 <code class="literal">InnoDB</code> テーブルが関与するクエリーの<a class="link" href="glossary.html#glos_query_execution_plan" title="クエリー実行計画">実行計画</a>の安定性も改善できます。 
        </p><p>
          設定を変更するには、<code class="literal">SET GLOBAL innodb_stats_on_metadata=<em class="replaceable"><code>mode</code></em></code> ステートメントを発行します。ここで、<code class="literal"><em class="replaceable"><code>mode</code></em></code> は <code class="literal">ON</code> と <code class="literal">OFF</code> のいずれか (または <code class="literal">1</code> と <code class="literal">0</code> のいずれか) です。 設定を変更するには、グローバルシステム変数を設定するのに十分な権限 (<a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a> を参照) が必要で、すべての接続の操作にすぐに影響します。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_stats_persistent"></a>
          <code class="literal">innodb_stats_persistent</code>
        </p><a class="indexterm" name="idm44761349459840"></a><a class="indexterm" name="idm44761349458288"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_stats_persistent"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-stats-persistent[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent">innodb_stats_persistent</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> インデックス統計をディスクに永続化するかどうかを指定します。 それ以外の場合は、頻繁に統計が再計算される可能性があります。これにより、<a class="link" href="glossary.html#glos_query_execution_plan" title="クエリー実行計画">クエリーの実行計画</a>が変化する可能性があります。 テーブルが作成されると、この設定が各テーブルとともに格納されます。 テーブルを作成する前にグローバルレベルで <code class="literal">innodb_stats_persistent</code> を設定することも、<code class="literal">CREATE TABLE</code> および <code class="literal">ALTER TABLE</code> ステートメントで <code class="literal">STATS_PERSISTENT</code> 句を使用して、システム全体の設定をオーバーライドし、個々のテーブルの永続的統計を構成することもできます。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="15.8.10.1 永続的オプティマイザ統計のパラメータの構成">セクション15.8.10.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_stats_persistent_sample_pages"></a>
          <code class="literal">innodb_stats_persistent_sample_pages</code>
        </p><a class="indexterm" name="idm44761349426240"></a><a class="indexterm" name="idm44761349424640"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_stats_persistent_sample_pages"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-stats-persistent-sample-pages=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent_sample_pages">innodb_stats_persistent_sample_pages</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">20</code></td>
</tr></tbody></table></div><p>
          インデックス付きカラムの<a class="link" href="glossary.html#glos_cardinality" title="カーディナリティー">カーディナリティー</a>やその他の<a class="link" href="glossary.html#glos_statistics" title="統計">統計</a> (<code class="literal">ANALYZE TABLE</code> で計算された統計など) を見積もるときに、サンプルとして取得されるインデックス<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>の数です。 値を大きくすると、<a class="link" href="glossary.html#glos_query_execution_plan" title="クエリー実行計画">クエリーの実行計画</a>を改善するインデックス統計の精度が改善されますが、<code class="literal">InnoDB</code> テーブルに対する <code class="literal">ANALYZE TABLE</code> の実行時に I/O が増加することになります。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="15.8.10.1 永続的オプティマイザ統計のパラメータの構成">セクション15.8.10.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">innodb_stats_persistent_sample_pages</code> に大きな値を設定すると、<code class="literal">ANALYZE TABLE</code> の実行時間が長くなる可能性があります。 <code class="literal">ANALYZE TABLE</code> によってアクセスされるデータベースページの数を見積もるには、<a class="xref" href="innodb-storage-engine.html#innodb-analyze-table-complexity" title="15.8.10.3 InnoDB テーブルに対する ANALYZE TABLE の複雑さの推定">セクション15.8.10.3「InnoDB テーブルに対する ANALYZE TABLE の複雑さの推定」</a> を参照してください。 
          </p></div><p>
          <code class="literal">innodb_stats_persistent_sample_pages</code> は、テーブルに対して <code class="literal">innodb_stats_persistent</code> が有効になっている場合にのみ適用され、<code class="literal">innodb_stats_persistent</code> が無効になっている場合は、かわりに <code class="literal">innodb_stats_transient_sample_pages</code> が適用されます。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_stats_transient_sample_pages"></a>
          <code class="literal">innodb_stats_transient_sample_pages</code>
        </p><a class="indexterm" name="idm44761349383120"></a><a class="indexterm" name="idm44761349381520"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_stats_transient_sample_pages"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-stats-transient-sample-pages=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_transient_sample_pages">innodb_stats_transient_sample_pages</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">8</code></td>
</tr></tbody></table></div><p>
          インデックス付きカラムの<a class="link" href="glossary.html#glos_cardinality" title="カーディナリティー">カーディナリティー</a>やその他の<a class="link" href="glossary.html#glos_statistics" title="統計">統計</a> (<code class="literal">ANALYZE TABLE</code> で計算された統計など) を見積もるときに、サンプルとして取得されるインデックス<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>の数です。 デフォルト値は 8 です。 値を大きくすると、インデックス統計の精度が改善されます。これにより、<a class="link" href="glossary.html#glos_query_execution_plan" title="クエリー実行計画">クエリーの実行計画</a>を改善できますが、<code class="literal">InnoDB</code> テーブルを開くときや統計を再計算するときに I/O が増加するという犠牲が伴います。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-statistics-estimation" title="15.8.10.2 非永続的オプティマイザ統計のパラメータの構成">セクション15.8.10.2「非永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">innodb_stats_transient_sample_pages</code> に大きな値を設定すると、<code class="literal">ANALYZE TABLE</code> の実行時間が長くなる可能性があります。 <code class="literal">ANALYZE TABLE</code> によってアクセスされるデータベースページの数を見積もるには、<a class="xref" href="innodb-storage-engine.html#innodb-analyze-table-complexity" title="15.8.10.3 InnoDB テーブルに対する ANALYZE TABLE の複雑さの推定">セクション15.8.10.3「InnoDB テーブルに対する ANALYZE TABLE の複雑さの推定」</a> を参照してください。 
          </p></div><p>
          <code class="literal">innodb_stats_transient_sample_pages</code> は、テーブルに対して <code class="literal">innodb_stats_persistent</code> が無効になっている場合にのみ適用され、<code class="literal">innodb_stats_persistent</code> が有効になっている場合は、かわりに <code class="literal">innodb_stats_persistent_sample_pages</code> が適用されます。 <code class="literal">innodb_stats_sample_pages</code> のかわりに使用します。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-statistics-estimation" title="15.8.10.2 非永続的オプティマイザ統計のパラメータの構成">セクション15.8.10.2「非永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_status_output"></a>
          <code class="literal">innodb_status_output</code>
        </p><a class="indexterm" name="idm44761349339088"></a><a class="indexterm" name="idm44761349337536"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_status_output"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-status-output[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output">innodb_status_output</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          標準 <code class="literal">InnoDB</code> モニターの定期出力を有効または無効にします。 また、<code class="literal">InnoDB</code> Lock Monitor の定期的な出力を有効または無効にする際に、<code class="literal">innodb_status_output_locks</code> と組み合わせて使用されます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-enabling-monitors" title="15.17.2 InnoDB モニターの有効化">セクション15.17.2「InnoDB モニターの有効化」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_status_output_locks"></a>
          <code class="literal">innodb_status_output_locks</code>
        </p><a class="indexterm" name="idm44761349309456"></a><a class="indexterm" name="idm44761349307888"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_status_output_locks"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-status-output-locks[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output_locks">innodb_status_output_locks</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> ロックモニターを有効または無効にします。 有効にすると、<code class="literal">InnoDB</code> ロックモニターは、<code class="literal">SHOW ENGINE INNODB STATUS</code> 出力および MySQL エラーログに出力される定期的な出力にロックに関する追加情報を出力します。 <code class="literal">InnoDB</code> ロックモニターの定期的な出力は、標準の <code class="literal">InnoDB</code> モニター出力の一部として出力されます。 したがって、<code class="literal">InnoDB</code> ロックモニターで MySQL エラーログに定期的にデータを出力するには、標準の <code class="literal">InnoDB</code> モニターを有効にする必要があります。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-enabling-monitors" title="15.17.2 InnoDB モニターの有効化">セクション15.17.2「InnoDB モニターの有効化」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_strict_mode"></a>
          <code class="literal">innodb_strict_mode</code>
        </p><a class="indexterm" name="idm44761349276480"></a><a class="indexterm" name="idm44761349274928"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_strict_mode"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-strict-mode[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode">innodb_strict_mode</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル、セッション</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
          <code class="literal">innodb_strict_mode</code> が有効になっている場合、<code class="literal">InnoDB</code> は特定の条件に対して警告ではなくエラーを返します。
        </p><p>
          <a class="link" href="glossary.html#glos_strict_mode" title="厳密モード">厳密モード</a>は、SQL 内の無視できる誤字や構文エラー、または操作モードと SQL ステートメントのさまざまな組み合わせによる意図しないその他の結果から保護する際に役立ちます。 <code class="literal">innodb_strict_mode</code> が有効になっている場合、<code class="literal">InnoDB</code> では、警告を発行して指定されたステートメントを処理するのではなく (おそらく意図しない動作で)、特定のケースでエラー状態が発生します。 これは、MySQL で受け入れられる SQL 構文を制御し、警告なしでエラーを無視するのか、入力構文とデータ値を検証するのかを決定する MySQL の <a class="link" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード"><code class="literal">sql_mode</code></a> と類似しています。 
        </p><p>
          <code class="literal">innodb_strict_mode</code> 設定は、<code class="literal">CREATE TABLE</code>, <code class="literal">ALTER TABLE</code>, <code class="literal">CREATE INDEX</code> および <code class="literal">OPTIMIZE TABLE</code> ステートメントの構文エラーの処理に影響します。<code class="literal">innodb_strict_mode</code> ではレコードサイズチェックも有効になるため、<code class="literal">INSERT</code> または <code class="literal">UPDATE</code> は、選択したページサイズに対してレコードが大きすぎるために失敗することはありません。
        </p><p>
          <code class="literal">CREATE TABLE</code> ステートメント、<code class="literal">ALTER TABLE</code> ステートメントおよび <code class="literal">CREATE INDEX</code> ステートメントで <code class="literal">ROW_FORMAT</code> 句および <code class="literal">KEY_BLOCK_SIZE</code> 句を使用する場合は、Oracle で <code class="literal">innodb_strict_mode</code> を有効にすることをお薦めします。 <code class="literal">innodb_strict_mode</code> が無効になっている場合、<code class="literal">InnoDB</code> は競合する句を無視し、メッセージログに警告のみを表示してテーブルまたはインデックスを作成します。 結果のテーブルには、圧縮テーブルを作成しようとしたときの圧縮サポートの不足など、意図したものとは異なる特性がある場合があります。 <code class="literal">innodb_strict_mode</code> が有効な場合、このような問題により即時エラーが生成され、テーブルまたはインデックスは作成されません。 
        </p><p>
          <code class="literal">innodb_strict_mode</code> は、<code class="literal">mysqld</code> の起動時にコマンドラインで、または MySQL <a class="link" href="glossary.html#glos_configuration_file" title="構成ファイル">configuration file</a> で有効または無効にできます。 <code class="literal">SET [GLOBAL|SESSION] innodb_strict_mode=<em class="replaceable"><code>mode</code></em></code> ステートメントを使用して、実行時に <code class="literal">innodb_strict_mode</code> を有効または無効にすることもできます。ここで、<code class="literal"><em class="replaceable"><code>mode</code></em></code> は <code class="literal">ON</code> または <code class="literal">OFF</code> です。 <code class="literal">GLOBAL</code> 設定を変更するには、グローバルシステム変数を設定するのに十分な権限 (<a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a> を参照) が必要であり、その後接続するすべてのクライアントの操作に影響します。 任意のクライアントが <code class="literal">innodb_strict_mode</code> の <code class="literal">SESSION</code> 設定を変更でき、そのクライアントのみが設定の影響を受けます。 
        </p><p>
          <code class="literal">innodb_strict_mode</code> は、<a class="link" href="glossary.html#glos_general_tablespace" title="一般テーブルスペース">general tablespaces</a> には適用できません。 一般的なテーブルスペースのテーブルスペース管理ルールは、<code class="literal">innodb_strict_mode</code> とは無関係に厳密に適用されます。 詳細は、<a class="xref" href="sql-statements.html#create-tablespace" title="13.1.21 CREATE TABLESPACE ステートメント">セクション13.1.21「CREATE TABLESPACE ステートメント」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_sync_array_size"></a>
          <code class="literal">innodb_sync_array_size</code>
        </p><a class="indexterm" name="idm44761349209824"></a><a class="indexterm" name="idm44761349208272"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_sync_array_size"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-sync-array-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_sync_array_size">innodb_sync_array_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">1024</code></td>
</tr></tbody></table></div><p>
          mutex/lock 待機配列のサイズを定義します。 値を大きくすると、スレッドの調整に使用される内部データ構造が分割され、多数の待機スレッドを持つワークロードの同時実行性が向上します。 この設定は MySQL インスタンスの起動時に構成する必要があり、あとで変更することはできません。 頻繁に多数の待機スレッドを生成するワークロード (通常は 768 を超える) では、値を増やすことをお薦めします。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_sync_spin_loops"></a>
          <code class="literal">innodb_sync_spin_loops</code>
        </p><a class="indexterm" name="idm44761349178256"></a><a class="indexterm" name="idm44761349176704"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_sync_spin_loops"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-sync-spin-loops=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_sync_spin_loops">innodb_sync_spin_loops</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">30</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
          スレッドが中断される前に、<code class="literal">InnoDB</code> 相互排他ロックが開放されるまでスレッドが待機する回数です。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_sync_debug"></a>
          <code class="literal">innodb_sync_debug</code>
        </p><a class="indexterm" name="idm44761349146336"></a><a class="indexterm" name="idm44761349145248"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_sync_debug"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-sync-debug[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_sync_debug">innodb_sync_debug</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> ストレージエンジンの同期デバッグ検査を有効にします。 このオプションは、デバッグサポートが <code class="option">WITH_DEBUG</code> <span class="command"><strong>CMake</strong></span> オプションを使用してコンパイルされている場合にのみ使用できます。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_table_locks"></a>
          <code class="literal">innodb_table_locks</code>
        </p><a class="indexterm" name="idm44761349118064"></a><a class="indexterm" name="idm44761349116512"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_table_locks"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-table-locks[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_table_locks">innodb_table_locks</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル、セッション</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
          <code class="literal">autocommit = 0<code class="literal"> の場合、</code>InnoDB<code class="literal"> は </code>LOCK TABLES</code> の要求を受け入れます。MySQL はすべてのスレッドがテーブルに対するすべてのロックを解放するまで、<code class="literal">LOCK TABLES ... WRITE</code> から戻りません。 <code class="literal">innodb_table_locks</code> のデフォルト値は 1 です。これは、<code class="literal">autocommit = 0</code>. の場合、<code class="literal">LOCK TABLES</code> によって InnoDB がテーブルを内部的にロックすることを意味します。 
        </p><p>
          <code class="literal">innodb_table_locks = 0</code> は、<code class="literal">LOCK TABLES ... WRITE</code> で明示的にロックされたテーブルには影響しません。 <code class="literal">LOCK TABLES ... WRITE</code> で暗黙的に (たとえば、トリガーを使用して)、または <code class="literal">LOCK TABLES ... READ</code> によって、読み取りまたは書き込み用にロックされたテーブルには有効です。 
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-locking-transaction-model" title="15.7 InnoDB のロックおよびトランザクションモデル">セクション15.7「InnoDB のロックおよびトランザクションモデル」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_temp_data_file_path"></a>
          <code class="literal">innodb_temp_data_file_path</code>
        </p><a class="indexterm" name="idm44761349078192"></a><a class="indexterm" name="idm44761349076624"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_temp_data_file_path"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-temp-data-file-path=file_name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_data_file_path">innodb_temp_data_file_path</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ibtmp1:12M:autoextend</code></td>
</tr></tbody></table></div><p>
          グローバル一時テーブルスペースデータファイルの相対パス、名前、サイズおよび属性を定義します。 グローバル一時テーブルスペースには、ユーザー作成一時テーブルに対する変更のロールバックセグメントが格納されます。 
        </p><p>
          <code class="literal">innodb_temp_data_file_path</code> に値が指定されていない場合、デフォルトの動作では、<code class="filename">ibtmp1</code> という名前の単一の自動拡張データファイルが <code class="literal">innodb_data_home_dir</code> ディレクトリに作成されます。 初期ファイルサイズは 12MB を少し超えています。 
        </p><p>
          グローバル一時テーブルスペースのデータファイル指定の構文には、ファイル名、ファイルサイズ、<code class="literal">autoextend</code> および <code class="literal">max</code> 属性が含まれます:
        </p><pre class="programlisting"><em class="replaceable"><code>file_name</code></em>:<em class="replaceable"><code>file_size</code></em>[:autoextend[:max:<em class="replaceable"><code>max_file_size</code></em>]]
</pre><p>
          グローバル一時テーブルスペースデータファイルには、別の <code class="literal">InnoDB</code> データファイルと同じ名前を付けることはできません。 グローバル一時テーブルスペースデータファイルを作成できない場合やエラーが発生した場合は、致命的として扱われ、サーバーの起動は拒否されます。 
        </p><p>
          ファイルサイズは、<code class="literal">K</code>、<code class="literal">M</code> または <code class="literal">G</code> をサイズ値に追加することで、KB、MB または GB で指定します。 ファイルサイズの合計は、12MB より少し大きくする必要があります。 
        </p><p>
          個々のファイルのサイズ制限は、オペレーティングシステムによって決まります。 大規模ファイルをサポートするオペレーティングシステムでは、ファイルサイズが 4GB を超える場合があります。 グローバル一時テーブルスペースデータファイルに対する RAW ディスクパーティションの使用はサポートされていません。 
        </p><p>
          <code class="literal">autoextend</code> および <code class="literal">max</code> 属性は、<code class="literal">innodb_temp_data_file_path</code> 設定で最後に指定されたデータファイルにのみ使用できます。 例: 
        </p><pre class="programlisting">[mysqld]
innodb_temp_data_file_path=ibtmp1:50M;ibtmp2:12M:autoextend:max:500MB
</pre><p>
          <code class="literal">autoextend</code> オプションを使用すると、データファイルの空き領域がなくなると、データファイルのサイズが自動的に増加します。 デフォルトでは、<code class="literal">autoextend</code> の増分は 64MB です。 増分を変更するには、<code class="literal">innodb_autoextend_increment</code> 変数の設定を変更します。 
        </p><p>
          グローバル一時テーブルスペースデータファイルのディレクトリパスは、<code class="literal">innodb_data_home_dir</code> および <code class="literal">innodb_temp_data_file_path</code> で定義されたパスを連結することによって形成されます。
        </p><p>
          <code class="literal">InnoDB</code> を読取り専用モードで実行する前に、<code class="literal">innodb_temp_data_file_path</code> をデータディレクトリ外の場所に設定します。 パスは、データディレクトリに対する相対パスである必要があります。 例: 
        </p><pre class="programlisting">--innodb-temp-data-file-path=../../../tmp/ibtmp1:12M:autoextend
</pre><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-global-temporary-tablespace" title="グローバル一時テーブルスペース">グローバル一時テーブルスペース</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_temp_tablespaces_dir"></a>
          <code class="literal">innodb_temp_tablespaces_dir</code>
        </p><a class="indexterm" name="idm44761349022752"></a><a class="indexterm" name="idm44761349021184"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_temp_tablespaces_dir"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-temp-tablespaces-dir=dir_name</code></td>
</tr><tr><th>導入</th>
<td>8.0.13</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_temp_tablespaces_dir">innodb_temp_tablespaces_dir</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>ディレクトリ名</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">#innodb_temp</code></td>
</tr></tbody></table></div><p>
          起動時に <code class="literal">InnoDB</code> がセッション一時テーブルスペースのプールを作成する場所を定義します。 デフォルトの場所は、データディレクトリ内の<code class="filename">#innodb_temp</code> ディレクトリです。 データディレクトリに対する完全修飾パスまたは相対パスが許可されます。 
        </p><p>
          MySQL 8.0.16 では、セッション一時テーブルスペースには常に、<code class="literal">InnoDB</code> を使用してオプティマイザによって作成されたユーザー作成一時テーブルおよび内部一時テーブルが格納されます。 (以前は、内部一時テーブルのディスク上のストレージエンジンは、サポートされなくなった <code class="literal">internal_tmp_disk_storage_engine</code> システム変数によって決定されていました。 <a class="xref" href="optimization.html#internal-temporary-tables-engines-disk" title="オンディスク内部一時テーブルのストレージエンジン">オンディスク内部一時テーブルのストレージエンジン</a>を参照してください。) 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-session-temporary-tablespaces" title="セッション一時テーブルスペース">セッション一時テーブルスペース</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_thread_concurrency"></a>
          <code class="literal">innodb_thread_concurrency</code>
        </p><a class="indexterm" name="idm44761348987424"></a><a class="indexterm" name="idm44761348985856"></a><a class="indexterm" name="idm44761348983888"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_thread_concurrency"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-thread-concurrency=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_concurrency">innodb_thread_concurrency</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">1000</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> 内で許可されるスレッドの最大数を定義します。 値 0 (デフォルト) は、無限同時実行性 (制限なし) として解釈されます。 この変数は、高同時実行性システムでのパフォーマンスチューニングを目的としています。 
        </p><p>
          <code class="literal">InnoDB</code> は、<code class="literal">InnoDB</code> 内のスレッド数を <code class="literal">innodb_thread_concurrency</code> の制限以下に保つことを試みます。 制限に達すると、待機スレッドの<span class="quote">「<span class="quote">「先入れ先出し」</span>」</span> (FIFO) キューに追加のスレッドが配置されます。 ロックを待機しているスレッドは、並列実行中のスレッドの数にカウントされません。 
        </p><p>
          正しい設定は、ワークロードおよびコンピューティング環境によって異なります。 MySQL インスタンスが CPU リソースを他のアプリケーションと共有している場合、またはワークロードや同時ユーザー数が増加している場合は、この変数の設定を検討してください。 値の範囲をテストして、最適なパフォーマンスを提供する設定を決定します。<code class="literal">innodb_thread_concurrency</code> は動的変数で、ライブテストシステムで様々な設定を試すことができます。 特定の設定でパフォーマンスが低下した場合は、すぐに <code class="literal">innodb_thread_concurrency</code> を 0 に戻してください。 
        </p><p>
          次のガイドラインに従うと、適切な設定を見つけて保持する際に役立ちます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              ワークロードの同時ユーザースレッドの数が一貫して小さく、パフォーマンスに影響しない場合は、<code class="literal">innodb_thread_concurrency=0</code> を設定します (制限なし)。
            </p></li><li class="listitem"><p>
              ワークロードが一貫して大きく、または時々スパイクする場合は、<code class="literal">innodb_thread_concurrency</code> 値を設定し、最適なパフォーマンスを提供するスレッドの数が見つかるまで調整します。 たとえば、システムに通常 40 から 50 人のユーザーがいるが、定期的に 60、70 以上に増加するとします。 テストにより、同時ユーザー数は 80 に制限され、パフォーマンスはほとんど安定したままであることがわかります。 この場合、<code class="literal">innodb_thread_concurrency</code> を 80 に設定します。 
            </p></li><li class="listitem"><p>
              <code class="literal">InnoDB</code> でユーザースレッドに特定の数を超える仮想 CPU (たとえば、20 個の仮想 CPU) を使用しない場合は、<code class="literal">innodb_thread_concurrency</code> をこの数に設定します (パフォーマンステストによっては小さくなる可能性があります)。 MySQL を他のアプリケーションから分離することを目的としている場合は、<code class="literal">mysqld</code> プロセスを仮想 CPU のみにバインドすることを検討してください。 ただし、排他的バインドを使用すると、<code class="literal">mysqld</code> プロセスが一貫してビジー状態でない場合に最適でないハードウェア使用量になる可能性があることに注意してください。 この場合、<code class="literal">mysqld</code> プロセスを仮想 CPU にバインドできますが、他のアプリケーションが一部またはすべての仮想 CPU を使用できるようになります。 
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                オペレーティングシステムの観点からは、リソース管理ソリューションを使用して、<code class="literal">mysqld</code> プロセスをバインドするよりもアプリケーション間で CPU 時間がどのように共有されるかを管理することをお薦めします。 たとえば、他のクリティカルプロセスが実行されていないときに特定のアプリケーションに 90% の仮想 CPU 時間を割り当て、他のクリティカルプロセスが実行されているときにその値を 40% にスケールバックできます。 
              </p></div></li><li class="listitem"><p>
              場合によっては、最適な <code class="literal">innodb_thread_concurrency</code> 設定が仮想 CPU の数より小さいことがあります。
            </p></li><li class="listitem"><p>
              <code class="literal">innodb_thread_concurrency</code> 値が高すぎると、システム内部およびリソースの競合が増加するため、パフォーマンスが低下する可能性があります。
            </p></li><li class="listitem"><p>
              定期的にシステムをモニターし、分析してください。 ワークロード、ユーザー数、またはコンピューティング環境を変更するために、<code class="literal">innodb_thread_concurrency</code> 設定の調整が必要なことがあります。 
            </p></li></ul></div><p>
          値 0 を指定すると、<code class="literal">SHOW ENGINE INNODB STATUS</code> 出力の <code class="literal">ROW OPERATIONS</code> セクションの <code class="literal">queries inside InnoDB</code> および <code class="literal">queries in queue </code>カウンタが無効になります。
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-performance-thread_concurrency" title="15.8.4 InnoDB のスレッド並列性の構成">セクション15.8.4「InnoDB のスレッド並列性の構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_thread_sleep_delay"></a>
          <code class="literal">innodb_thread_sleep_delay</code>
        </p><a class="indexterm" name="idm44761348919088"></a><a class="indexterm" name="idm44761348917520"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_thread_sleep_delay"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-thread-sleep-delay=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_sleep_delay">innodb_thread_sleep_delay</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">10000</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">1000000</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> キューに参加するまでに、<code class="literal">InnoDB</code> スレッドがスリープ状態になる期間 (マイクロ秒単位) です。 デフォルト値は 10000 です。 0 の値はスリープを無効にします。 <code class="literal">innodb_adaptive_max_sleep_delay</code> を <code class="literal">innodb_thread_sleep_delay</code> に許可する最大値に設定すると、<code class="literal">InnoDB</code> は現在のスレッドスケジュールアクティビティに応じて <code class="literal">innodb_thread_sleep_delay</code> を自動的に上下に調整します。 この動的調整は、システムが軽くロードされているとき、またはほぼ全容量で動作しているときに、スレッドスケジューリングメカニズムが円滑に機能するのに役立ちます。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-thread_concurrency" title="15.8.4 InnoDB のスレッド並列性の構成">セクション15.8.4「InnoDB のスレッド並列性の構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_tmpdir"></a>
          <code class="literal">innodb_tmpdir</code>
        </p><a class="indexterm" name="idm44761348880576"></a><a class="indexterm" name="idm44761348879056"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_tmpdir"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-tmpdir=dir_name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_tmpdir">innodb_tmpdir</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル、セッション</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>ディレクトリ名</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">NULL</code></td>
</tr></tbody></table></div><p>
          テーブルを再構築するオンライン <code class="literal">ALTER TABLE</code> 操作中に作成される一時ソートファイルの代替ディレクトリを定義するために使用します。
        </p><p>
          テーブルを再構築するオンライン <code class="literal">ALTER TABLE</code> 操作では、元のテーブルと同じディレクトリに<span class="emphasis"><em>中間</em></span>テーブルファイルも作成されます。 <code class="literal">innodb_tmpdir</code> オプションは、中間テーブルファイルには適用されません。 
        </p><p>
          有効な値は、MySQL データディレクトリパス以外の任意のディレクトリパスです。 値が NULL の場合 (デフォルト)、一時ファイルは MySQL 一時ディレクトリ (Unix の場合は <code class="literal">$TMPDIR</code>、Windows の場合は <code class="literal">%TEMP%</code>、<code class="literal">--tmpdir</code> 構成オプションで指定されたディレクトリ)、作成されます。 ディレクトリが指定されている場合、<code class="literal">SET</code> ステートメントを使用して <code class="literal">innodb_tmpdir</code> が構成されている場合にのみ、ディレクトリの存在と権限がチェックされます。 symlink がディレクトリ文字列に指定されている場合、symlink は解決され、絶対パスとして格納されます。 パスは 512 バイトを超えることはできません。 <code class="literal">innodb_tmpdir</code> が無効なディレクトリに設定されている場合、オンラインの <code class="literal">ALTER TABLE</code> 操作でエラーが報告されます。<code class="literal">innodb_tmpdir</code> は、MySQL <code class="literal">tmpdir</code> 設定をオーバーライドしますが、オンラインの <code class="literal">ALTER TABLE</code> 操作の場合のみです。 
        </p><p>
          <code class="literal">innodb_tmpdir</code> を構成するには、<code class="literal">FILE</code> 権限が必要です。
        </p><p>
          <code class="literal">tmpfs</code> ファイルシステムにある一時ファイルディレクトリのオーバーフローを回避するために、<code class="literal">innodb_tmpdir</code> オプションが導入されました。 このようなオーバーフローは、テーブルを再構築するオンライン <code class="literal">ALTER TABLE</code> 操作中に作成された大規模な一時ソートファイルの結果として発生する可能性があります。 
        </p><p>
          レプリケーション環境では、すべてのサーバーに同じオペレーティングシステム環境がある場合にのみ、<code class="literal">innodb_tmpdir</code> 設定のレプリケートを検討してください。 それ以外の場合、<code class="literal">innodb_tmpdir</code> 設定をレプリケートすると、テーブルを再構築するオンライン <code class="literal">ALTER TABLE</code> 操作の実行時にレプリケーションが失敗する可能性があります。 サーバーの動作環境が異なる場合は、各サーバーで個別に <code class="literal">innodb_tmpdir</code> を構成することをお薦めします。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-space-requirements" title="15.12.3 オンライン DDL 領域の要件">セクション15.12.3「オンライン DDL 領域の要件」</a>を参照してください。 <code class="literal">ALTER TABLE</code> のオンライン操作の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl" title="15.12 InnoDB とオンライン DDL">セクション15.12「InnoDB とオンライン DDL」</a> を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_trx_purge_view_update_only_debug"></a>
          <code class="literal">innodb_trx_purge_view_update_only_debug</code>
        </p><a class="indexterm" name="idm44761348823632"></a><a class="indexterm" name="idm44761348822512"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_trx_purge_view_update_only_debug"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-trx-purge-view-update-only-debug[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_trx_purge_view_update_only_debug">innodb_trx_purge_view_update_only_debug</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          パージビューの更新を許可しながら、削除マーク付きレコードのパージを一時停止します。 このオプションでは、パージビューは更新されますが、パージはまだ実行されていない状況が人為的に作成されます。 このオプションは、デバッグサポートが <code class="option">WITH_DEBUG</code> <span class="command"><strong>CMake</strong></span> オプションを使用してコンパイルされている場合にのみ使用できます。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_trx_rseg_n_slots_debug"></a>
          <code class="literal">innodb_trx_rseg_n_slots_debug</code>
        </p><a class="indexterm" name="idm44761348795600"></a><a class="indexterm" name="idm44761348794480"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_trx_rseg_n_slots_debug"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-trx-rseg-n-slots-debug=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_trx_rseg_n_slots_debug">innodb_trx_rseg_n_slots_debug</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">1024</code></td>
</tr></tbody></table></div><p>
          <code class="literal">TRX_RSEG_N_SLOTS</code> を、undo ログセグメントの空きスロットを検索する <code class="literal">trx_rsegf_undo_find_free</code> 関数の特定の値に制限するデバッグフラグを設定します。 このオプションは、デバッグサポートが <code class="option">WITH_DEBUG</code> <span class="command"><strong>CMake</strong></span> オプションを使用してコンパイルされている場合にのみ使用できます。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_undo_directory"></a>
          <code class="literal">innodb_undo_directory</code>
        </p><a class="indexterm" name="idm44761348763872"></a><a class="indexterm" name="idm44761348762320"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_undo_directory"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-undo-directory=dir_name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_directory">innodb_undo_directory</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>ディレクトリ名</td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> が undo テーブルスペースを作成するパス。 通常、undo テーブルスペースを別のストレージデバイスに配置するために使用されます。 
        </p><p>
          デフォルト値はありません (NULL)。 <code class="literal">innodb_undo_directory</code> 変数が定義されていない場合、undo テーブルスペースはデータディレクトリに作成されます。 
        </p><p>
          MySQL インスタンスの初期化時に作成されるデフォルトの undo テーブルスペース (<code class="filename">innodb_undo_001</code> および <code class="filename">innodb_undo_002</code>) は、<code class="literal">innodb_undo_directory</code> 変数で定義されたディレクトリに常に存在します。
        </p><p>
          別のパスが指定されていない場合、<code class="literal">CREATE UNDO TABLESPACE</code> 構文を使用して作成された undo テーブルスペースは、<code class="literal">innodb_undo_directory</code> 変数で定義されたディレクトリに作成されます。
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-undo-tablespaces" title="15.6.3.4 undo テーブルスペース">セクション15.6.3.4「undo テーブルスペース」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_undo_log_encrypt"></a>
          <code class="literal">innodb_undo_log_encrypt</code>
        </p><a class="indexterm" name="idm44761348730000"></a><a class="indexterm" name="idm44761348728448"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_undo_log_encrypt"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-undo-log-encrypt[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_log_encrypt">innodb_undo_log_encrypt</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <a class="link" href="innodb-storage-engine.html#innodb-data-encryption" title="15.13 InnoDB 保存データ暗号化">data-at-rest encryption feature</a> を使用して暗号化されたテーブルの undo ログデータの暗号化を制御します。 個別の <a class="link" href="glossary.html#glos_undo_tablespace" title="Undo テーブルスペース">undo tablespaces</a> に存在する undo ログにのみ適用されます。 <a class="xref" href="innodb-storage-engine.html#innodb-undo-tablespaces" title="15.6.3.4 undo テーブルスペース">セクション15.6.3.4「undo テーブルスペース」</a>を参照してください。 システムテーブルスペースに存在する undo ログデータの暗号化はサポートされていません。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-undo-log" title="undo ログの暗号化">undo ログの暗号化</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_undo_log_truncate"></a>
          <code class="literal">innodb_undo_log_truncate</code>
        </p><a class="indexterm" name="idm44761348699760"></a><a class="indexterm" name="idm44761348698208"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_undo_log_truncate"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-undo-log-truncate[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_log_truncate">innodb_undo_log_truncate</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
          有効にすると、<code class="literal">innodb_max_undo_log_size</code> で定義されたしきい値を超える undo テーブルスペースに切捨てのマークが付けられます。 undo テーブルスペースのみ切り捨てられます。 システムテーブルスペースに存在する undo ログの切捨てはサポートされていません。 切捨てを実行するには、少なくとも 2 つの undo テーブルスペースが必要です。 
        </p><p>
          <code class="literal">innodb_purge_rseg_truncate_frequency</code> 変数を使用すると、undo テーブルスペースの切捨てを迅速に実行できます。
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#truncate-undo-tablespace" title="undo テーブルスペースの切捨て">undo テーブルスペースの切捨て</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_undo_tablespaces"></a>
          <code class="literal">innodb_undo_tablespaces</code>
        </p><a class="indexterm" name="idm44761348669168"></a><a class="indexterm" name="idm44761348667616"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_undo_tablespaces"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-undo-tablespaces=#</code></td>
</tr><tr><th>非推奨</th>
<td>はい</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_tablespaces">innodb_undo_tablespaces</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">2</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">2</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">127</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> で使用される <a class="link" href="glossary.html#glos_undo_tablespace" title="Undo テーブルスペース">undo tablespaces</a> の数を定義します。 デフォルト値と最小値は 2 です。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">innodb_undo_tablespaces</code> 変数は非推奨であり、MySQL 8.0.14 の時点では構成できなくなりました。 将来のリリースで削除される予定です。 
          </p></div><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-undo-tablespaces" title="15.6.3.4 undo テーブルスペース">セクション15.6.3.4「undo テーブルスペース」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_use_native_aio"></a>
          <code class="literal">innodb_use_native_aio</code>
        </p><a class="indexterm" name="idm44761348631296"></a><a class="indexterm" name="idm44761348629744"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_use_native_aio"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-use-native-aio[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_use_native_aio">innodb_use_native_aio</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
          Linux の非同期 I/O サブシステムを使用するかどうかを指定します。 この変数は Linux システムにのみ適用され、サーバーの実行中は変更できません。 通常、このオプションはデフォルトで有効になっているため、構成する必要はありません。 
        </p><p>
          Windows システムで <code class="literal">InnoDB</code> が持つ <a class="link" href="glossary.html#glos_asynchronous_io" title="非同期 I/O">asynchronous I/O</a> 機能は、Linux システムで使用できます。 (その他の Unix に似たシステムでは、引き続き同期 I/O 呼び出しが使用されます。) この機能により、<code class="literal">SHOW ENGINE INNODB STATUS\G</code> 出力に多くの保留中の読取り/書込みが通常表示される、大量の I/O-bound システムのスケーラビリティが向上します。 
        </p><p>
          大量の <code class="literal">InnoDB</code> I/O スレッドとともに実行すると (特に、同じサーバーマシン上で複数のこのようなインスタンスを実行すると)、Linux システムの能力制限を超える可能性があります。 この場合、次のエラーを受信する可能性があります。 
        </p><pre class="programlisting">EAGAIN: The specified maxevents exceeds the user's limit of available events.
</pre><p>
          一般に、<code class="literal">/proc/sys/fs/aio-max-nr</code> により大きな制限を記述すれば、このエラーに対処できます。
        </p><p>
          ただし、OS の非同期 I/O サブシステムに問題があるために <code class="literal">InnoDB</code> を起動できない場合は、<code class="literal">innodb_use_native_aio=0</code> を使用してサーバーを起動できます。 このオプションは、<code class="literal">tmpfs</code> で AIO をサポートしていない <code class="literal">tmpdir</code> の場所、<code class="literal">tmpfs</code> ファイルシステム、Linux カーネルの組合せなどの潜在的な問題が <code class="literal">InnoDB</code> によって検出された場合にも、起動時に自動的に無効になることがあります。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-linux-native-aio" title="15.8.6 Linux での非同期 I/O の使用">セクション15.8.6「Linux での非同期 I/O の使用」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_validate_tablespace_paths"></a>
          <code class="literal">innodb_validate_tablespace_paths</code>
        </p><a class="indexterm" name="idm44761348590192"></a><a class="indexterm" name="idm44761348588608"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_validate_tablespace_paths"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-validate-tablespace-paths[={OFF|ON}]</code></td>
</tr><tr><th>導入</th>
<td>8.0.21</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_validate_tablespace_paths">innodb_validate_tablespace_paths</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
          テーブルスペースファイルパスの検証を制御します。 起動時に、<code class="literal">InnoDB</code> は、テーブルスペースファイルが別の場所に移動された場合に備えて、データディクショナリに格納されているテーブルスペースファイルパスに対して既知のテーブルスペースファイルのパスを検証します。 <code class="literal">innodb_validate_tablespace_paths</code> 変数を使用すると、テーブルスペースパスの検証を無効にできます。 この機能は、テーブルスペースファイルを移動しない環境を対象としています。 パス検証を無効にすると、多数のテーブルスペースファイルがあるシステムでの起動時間が短縮されます。 
        </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
            テーブルスペースファイルの移動後にテーブルスペースパス検証を無効にしてサーバーを起動すると、動作が未定義になる可能性があります。
          </p></div><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-disabling-tablespace-path-validation" title="15.6.3.7 テーブルスペースパス検証の無効化">セクション15.6.3.7「テーブルスペースパス検証の無効化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_version"></a>
          <code class="literal">innodb_version</code>
        </p><a class="indexterm" name="idm44761348556528"></a><a class="indexterm" name="idm44761348555008"></a><p>
          <code class="literal">InnoDB</code> のバージョン番号です。 MySQL 8.0 では、<code class="literal">InnoDB</code> の個別のバージョン番号は適用されず、この値はサーバーの <code class="literal">version</code> 番号と同じです。 
        </p></li><li class="listitem"><p><a name="sysvar_innodb_write_io_threads"></a>
          <code class="literal">innodb_write_io_threads</code>
        </p><a class="indexterm" name="idm44761348547728"></a><a class="indexterm" name="idm44761348546176"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for innodb_write_io_threads"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--innodb-write-io-threads=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_write_io_threads">innodb_write_io_threads</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">4</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">64</code></td>
</tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> の書き込み操作で使用される I/O スレッドの数です。 デフォルト値は 4 です。 読み取りスレッドで対応するものは、<code class="literal">innodb_read_io_threads</code> です。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-multiple_io_threads" title="15.8.5 InnoDB バックグラウンド I/O スレッドの数の構成">セクション15.8.5「InnoDB バックグラウンド I/O スレッドの数の構成」</a>を参照してください。 一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8 InnoDB ディスク I/O の最適化">セクション8.5.8「InnoDB ディスク I/O の最適化」</a>を参照してください。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            Linux システムでは、デフォルトの <code class="literal">innodb_read_io_threads</code> 設定で複数 (一般には 12 台よりも多く) の MySQL サーバーを実行すると、<code class="literal">innodb_write_io_threads</code> および Linux の <code class="literal">aio-max-nr</code> 設定がシステムの制限を超過する可能性があります。 理想的には、<code class="literal">aio-max-nr</code> 設定を増やします。回避策として、いずれかまたは両方の MySQL 変数の設定を減らすことができます。 
          </p></div><p>
          また、バイナリログとディスクの同期を制御する <code class="literal">sync_binlog</code> の値も考慮してください。
        </p><p>
          一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8 InnoDB ディスク I/O の最適化">セクション8.5.8「InnoDB ディスク I/O の最適化」</a>を参照してください。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-information-schema"></a>15.15 InnoDB INFORMATION_SCHEMA テーブル</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-compression-tables">15.15.1 圧縮に関する InnoDB INFORMATION_SCHEMA テーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-transactions">15.15.2 InnoDB INFORMATION_SCHEMA トランザクションおよびロック情報</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-system-tables">15.15.3 InnoDB INFORMATION_SCHEMA スキーマオブジェクトテーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-fulltext_index-tables">15.15.4 InnoDB INFORMATION_SCHEMA FULLTEXT インデックステーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-buffer-pool-tables">15.15.5 InnoDB INFORMATION_SCHEMA バッファープールテーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-metrics-table">15.15.6 InnoDB INFORMATION_SCHEMA メトリックテーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-temp-table-info">15.15.7 InnoDB INFORMATION_SCHEMA 一時テーブル情報テーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-files-table">15.15.8 INFORMATION_SCHEMA.FILES からの InnoDB テーブルスペースメタデータの取得</a></span></dt></dl></div><a class="indexterm" name="idm44761348505936"></a><p>
    このセクションでは、<code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> テーブルについて、その使用例とともに説明します。
  </p><p>
    <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> テーブルは、<code class="literal">InnoDB</code> ストレージエンジンのさまざまな側面に関するメタデータ、ステータス情報、および統計を提供します。 <code class="literal">INFORMATION_SCHEMA</code> データベースで <code class="literal">SHOW TABLES</code> ステートメントを発行することによって、<code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> テーブルのリストを表示できます。 
  </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW TABLES FROM INFORMATION_SCHEMA LIKE 'INNODB%';</code></strong>
</pre><p>
    テーブル定義については、<a class="xref" href="information-schema.html#innodb-information-schema-tables" title="26.51 INFORMATION_SCHEMA InnoDB テーブル">セクション26.51「INFORMATION_SCHEMA InnoDB テーブル」</a>を参照してください。 <code class="literal">MySQL</code> <code class="literal">INFORMATION_SCHEMA</code> データベースに関連した一般的な情報については、<a class="xref" href="information-schema.html" title="第 26 章 INFORMATION_SCHEMA テーブル">第26章「<i>INFORMATION_SCHEMA テーブル</i>」</a>を参照してください。 
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-information-schema-compression-tables"></a>15.15.1 圧縮に関する InnoDB INFORMATION_SCHEMA テーブル</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-innodb_cmp">15.15.1.1 INNODB_CMP および INNODB_CMP_RESET</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-innodb_cmpmem">15.15.1.2 INNODB_CMPMEM および INNODB_CMPMEM_RESET</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-examples-compression-sect">15.15.1.3 圧縮情報スキーマテーブルの使用</a></span></dt></dl></div><a class="indexterm" name="idm44761348488912"></a><p>
      圧縮が全体としてどれだけ適切に機能しているかを把握するための、圧縮に関する <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> テーブルのペアとして、次の 2 つがあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">INNODB_CMP</code> および <code class="literal">INNODB_CMP_RESET</code> は、圧縮操作の数および圧縮の実行に費やされた時間に関する情報を提供します。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_CMPMEM</code> および <code class="literal">INNODB_CMPMEM_RESET</code> は、圧縮のためのメモリーの割当て方法に関する情報を提供します。
        </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-information-schema-innodb_cmp"></a>15.15.1.1 INNODB_CMP および INNODB_CMP_RESET</h4></div></div></div><a class="indexterm" name="idm44761348477312"></a><a class="indexterm" name="idm44761348475136"></a><p>
        <code class="literal">INNODB_CMP</code> テーブルおよび <code class="literal">INNODB_CMP_RESET</code> テーブルは、<a class="xref" href="innodb-storage-engine.html#innodb-compression" title="15.9 InnoDB のテーブルおよびページの圧縮">セクション15.9「InnoDB のテーブルおよびページの圧縮」</a> で説明されている圧縮テーブルに関連する操作のステータス情報を提供します。 <code class="literal">PAGE_SIZE</code> カラムは、圧縮された<a class="link" href="glossary.html#glos_page_size" title="page size">ページサイズ</a>をレポートします。 
      </p><p>
        これらの 2 つのテーブルの内容は同じですが、<code class="literal">INNODB_CMP_RESET</code> から読み取ると、圧縮および圧縮解除操作に関する統計がリセットされます。 たとえば、<code class="literal">INNODB_CMP_RESET</code> の出力を 60 分に 1 回アーカイブした場合は、1 時間ごとの統計が表示されます。 <code class="literal">INNODB_CMP</code> の出力を監視する場合 (<code class="literal">INNODB_CMP_RESET</code> を読み取らないことを確認)、InnoDB の起動以降の累積統計が表示されます。 
      </p><p>
        テーブル定義については、<a class="xref" href="information-schema.html#information-schema-innodb-cmp-table" title="26.51.5 INFORMATION_SCHEMA INNODB_CMP および INNODB_CMP_RESET テーブル">セクション26.51.5「INFORMATION_SCHEMA INNODB_CMP および INNODB_CMP_RESET テーブル」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-information-schema-innodb_cmpmem"></a>15.15.1.2 INNODB_CMPMEM および INNODB_CMPMEM_RESET</h4></div></div></div><a class="indexterm" name="idm44761348460464"></a><a class="indexterm" name="idm44761348458320"></a><a class="indexterm" name="idm44761348456224"></a><p>
        <code class="literal">INNODB_CMPMEM</code> および <code class="literal">INNODB_CMPMEM_RESET</code> テーブルは、バッファープール内に存在する圧縮されたページに関するステータス情報を提供します。 圧縮テーブルおよびバッファープールの使用の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-compression" title="15.9 InnoDB のテーブルおよびページの圧縮">セクション15.9「InnoDB のテーブルおよびページの圧縮」</a>を参照してください。 <code class="literal">INNODB_CMP</code> および <code class="literal">INNODB_CMP_RESET</code> テーブルでは、圧縮に関するより役立つ統計が提供されます。 
      </p><h5><a name="idm44761348449344"></a>内部の詳細</h5><p>
        <code class="literal">InnoDB</code> は、<a class="link" href="glossary.html#glos_buddy_allocator" title="バディーアロケータ">バディーアロケータ</a>システムを使用して、1K バイトから 16K バイトまでの<a class="link" href="glossary.html#glos_page_size" title="page size">さまざまなサイズのページ</a>に割り当てられたメモリーを管理します。 ここで説明されている 2 つのテーブルの各行は、1 つのページサイズに対応します。 
      </p><p>
        <code class="literal">INNODB_CMPMEM</code> および <code class="literal">INNODB_CMPMEM_RESET</code> テーブルの内容は同じですが、<code class="literal">INNODB_CMPMEM_RESET</code> から読み取ると、再配置操作に関する統計がリセットされます。 たとえば、<code class="literal">INNODB_CMPMEM_RESET</code> の出力を 60 分に 1 回アーカイブした場合は、1 時間ごとの統計が表示されます。 <code class="literal">INNODB_CMPMEM_RESET</code> を読み取らずに <code class="literal">INNODB_CMPMEM</code> の出力を監視した場合、<code class="literal">InnoDB</code> の起動後の累積統計が表示されます。 
      </p><p>
        テーブル定義については、<a class="xref" href="information-schema.html#information-schema-innodb-cmpmem-table" title="26.51.6 INFORMATION_SCHEMA INNODB_CMPMEM および INNODB_CMPMEM_RESET テーブル">セクション26.51.6「INFORMATION_SCHEMA INNODB_CMPMEM および INNODB_CMPMEM_RESET テーブル」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-information-schema-examples-compression-sect"></a>15.15.1.3 圧縮情報スキーマテーブルの使用</h4></div></div></div><div class="example"><a name="innodb-information-schema-examples-compression"></a><p class="title"><b>例 15.1 圧縮情報スキーマテーブルの使用</b></p><div class="example-contents"><p>
          圧縮テーブルを含むデータベースからのサンプル出力を次に示します (<a class="xref" href="innodb-storage-engine.html#innodb-compression" title="15.9 InnoDB のテーブルおよびページの圧縮">セクション15.9「InnoDB のテーブルおよびページの圧縮」</a>、<code class="literal">INNODB_CMP</code>、<code class="literal">INNODB_CMP_PER_INDEX</code>、および <code class="literal">INNODB_CMPMEM</code> を参照してください)。
        </p><p>
          次の表は、軽い<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>下にある <code class="literal">INFORMATION_SCHEMA.INNODB_CMP</code> の内容を示しています。 バッファープールに含まれている唯一の圧縮ページサイズは 8K です。 カラム <code class="literal">COMPRESS_TIME</code> および <code class="literal">UNCOMPRESS_TIME</code> が 0 であるため、ページの圧縮または圧縮解除で消費された時間は統計がリセットされてから 1 秒未満でした。 
        </p><div class="informaltable"><a name="innodb-information-schema-sample-innodb_cmp"></a><table summary="Sample data from the INFORMATION_SCHEMA.INNODB_CMP table, showing the internal workings of InnoDB table compression under a light workload."><col style="width: 15%"><col style="width: 15%"><col style="width: 15%"><col style="width: 15%"><col style="width: 20%"><col style="width: 20%"><thead><tr>
              <th scope="col">page size</th>
              <th scope="col">compress ops</th>
              <th scope="col">compress ops ok</th>
              <th scope="col">compress time</th>
              <th scope="col">uncompress ops</th>
              <th scope="col">uncompress time</th>
            </tr></thead><tbody><tr>
              <th scope="row">1024</th>
              <td>0</td>
              <td>0</td>
              <td>0</td>
              <td>0</td>
              <td>0</td>
            </tr><tr>
              <th scope="row">2048</th>
              <td>0</td>
              <td>0</td>
              <td>0</td>
              <td>0</td>
              <td>0</td>
            </tr><tr>
              <th scope="row">4096</th>
              <td>0</td>
              <td>0</td>
              <td>0</td>
              <td>0</td>
              <td>0</td>
            </tr><tr>
              <th scope="row">8192</th>
              <td>1048</td>
              <td>921</td>
              <td>0</td>
              <td>61</td>
              <td>0</td>
            </tr><tr>
              <th scope="row">16384</th>
              <td>0</td>
              <td>0</td>
              <td>0</td>
              <td>0</td>
              <td>0</td>
            </tr></tbody></table></div><p>
          <code class="literal">INNODB_CMPMEM</code> によると、<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>内には 6169 個の圧縮された 8K バイトページが存在します。 割り当てられているほかのブロックサイズは 64 バイトだけです。 <code class="literal">INNODB_CMPMEM</code> 内のもっとも小さい <code class="literal">PAGE_SIZE</code> は、対応する圧縮解除されたページがバッファープール内に存在しない圧縮ページのブロックディスクリプタとして使用されます。 このようなページが 5910 個存在することがわかります。 また、間接的には、259 (6169-5910) 個の圧縮ページもバッファープール内に圧縮解除された形式で存在することがわかります。 
        </p><p>
          次の表は、軽い<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>下にある <code class="literal">INFORMATION_SCHEMA.INNODB_CMPMEM</code> の内容を示しています。 圧縮ページのためのメモリーアロケータの断片化のために、一部のメモリー <code class="literal">SUM(PAGE_SIZE*PAGES_FREE)=6784</code> は使用できません。 これは、小さなメモリー割り当て要求が、バディーアロケーションシステムを使用して (メインのバッファープールから割り当てられる 16K ブロックから始めて) より大きなブロックを分割することによって満たされるためです。 断片化がこのように少ないのは、より大きな隣接した空きブロックを形成するために、割り当てられた一部のブロックが再配置 (コピー) されたためです。 この <code class="literal">SUM(PAGE_SIZE*RELOCATION_OPS)</code> バイトのコピーで消費された時間は 1 秒未満でした (<code class="literal">(SUM(RELOCATION_TIME)=0)</code>)。 
        </p><div class="informaltable"><a name="innodb-information-schema-sample-innodb_cmpmem"></a><table summary="Sample data from the INFORMATION_SCHEMA.INNODB_CMPMEM table, showing buffer pool memory operations for InnoDB table compression under a light workload."><col style="width: 15%"><col style="width: 15%"><col style="width: 20%"><col style="width: 20%"><col style="width: 20%"><thead><tr>
              <th scope="col">page size</th>
              <th scope="col">pages used</th>
              <th scope="col">pages free</th>
              <th scope="col">relocation ops</th>
              <th scope="col">relocation time</th>
            </tr></thead><tbody><tr>
              <th scope="row">64</th>
              <td>5910</td>
              <td>0</td>
              <td>2436</td>
              <td>0</td>
            </tr><tr>
              <th scope="row">128</th>
              <td>0</td>
              <td>1</td>
              <td>0</td>
              <td>0</td>
            </tr><tr>
              <th scope="row">256</th>
              <td>0</td>
              <td>0</td>
              <td>0</td>
              <td>0</td>
            </tr><tr>
              <th scope="row">512</th>
              <td>0</td>
              <td>1</td>
              <td>0</td>
              <td>0</td>
            </tr><tr>
              <th scope="row">1024</th>
              <td>0</td>
              <td>0</td>
              <td>0</td>
              <td>0</td>
            </tr><tr>
              <th scope="row">2048</th>
              <td>0</td>
              <td>1</td>
              <td>0</td>
              <td>0</td>
            </tr><tr>
              <th scope="row">4096</th>
              <td>0</td>
              <td>1</td>
              <td>0</td>
              <td>0</td>
            </tr><tr>
              <th scope="row">8192</th>
              <td>6169</td>
              <td>0</td>
              <td>5</td>
              <td>0</td>
            </tr><tr>
              <th scope="row">16384</th>
              <td>0</td>
              <td>0</td>
              <td>0</td>
              <td>0</td>
            </tr></tbody></table></div></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-information-schema-transactions"></a>15.15.2 InnoDB INFORMATION_SCHEMA トランザクションおよびロック情報</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-examples">15.15.2.1 InnoDB トランザクションの使用および情報のロック</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-understanding-innodb-locking">15.15.2.2 InnoDB のロックおよびロック待機情報</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-internal-data">15.15.2.3 InnoDB トランザクションおよびロック情報の永続性と一貫性</a></span></dt></dl></div><a class="indexterm" name="idm44761348313696"></a><a class="indexterm" name="idm44761348311584"></a><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        このセクションでは、MySQL 8.0 内の <code class="literal">INFORMATION_SCHEMA</code> <code class="literal">INNODB_LOCKS</code> および <code class="literal">INNODB_LOCK_WAITS</code> テーブルよりも優先される、パフォーマンススキーマ <code class="literal">data_locks</code> および <code class="literal">data_lock_waits</code> テーブルによって公開されるロック情報について説明します。 古い <code class="literal">INFORMATION_SCHEMA</code> テーブルに関して記述されている同様の説明は、<a class="ulink" href="https://dev.mysql.com/doc/refman/5.7/en/" target="_top">MySQL 5.7 Reference Manual</a> の <a class="ulink" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-information-schema-transactions.html" target="_top">InnoDB INFORMATION_SCHEMA Transaction and Locking Information</a> を参照してください。 
      </p></div><p>
      一方の <code class="literal">INFORMATION_SCHEMA</code> テーブルと 2 つの「パフォーマンススキーマ」テーブルを使用すると、<code class="literal">InnoDB</code> トランザクションを監視し、潜在的なロックの問題を診断できます:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">INNODB_TRX</code>: この <code class="literal">INFORMATION_SCHEMA</code> テーブルには、<code class="literal">InnoDB</code> 内で現在実行されているすべてのトランザクションに関する情報が表示されます。これには、トランザクションの状態 (実行中かロック待機中かなど)、トランザクションの開始時期、トランザクションが実行されている特定の SQL ステートメントなどが含まれます。
        </p><a class="indexterm" name="idm44761348294496"></a></li><li class="listitem"><p>
          <code class="literal">data_locks</code> :「このパフォーマンススキーマ」テーブルには、各保留ロックの行と、保留ロックの解放を待機してブロックされる各ロックリクエストが含まれています:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              ロックを保持しているトランザクションの状態 (<code class="literal">INNODB_TRX.TRX_STATE</code> が <code class="literal">RUNNING</code>, <code class="literal">LOCK WAIT</code>, <code class="literal">ROLLING BACK</code> または <code class="literal">COMMITTING</code>) にかかわらず、保持されているロックごとに 1 つの行があります。
            </p></li><li class="listitem"><p>
              別のトランザクションがロックを解放するのを待機している InnoDB 内の各トランザクション (<code class="literal">INNODB_TRX.TRX_STATE</code> は <code class="literal">LOCK WAIT</code>) は、単一のブロッキングロックリクエストによってブロックされます。 そのブロックしているロック要求は、互換性がないモードにある別のトランザクションによって保持されている行ロックまたはテーブルロックに対するものです。 ロック要求には常に、要求をブロックする保持ロックのモード (読み取りと書き込み、共有と排他) と互換性のないモードがあります。 
            </p><p>
              ブロックされたトランザクションは、他のトランザクションがコミットまたはロールバックされ、リクエストされたロックが解放されるまで続行できません。 ブロックされたトランザクションごとに、<code class="literal">data_locks</code> には、トランザクションがリクエストしたロックと待機しているロックを示す行が 1 つ含まれます。 
            </p></li></ul></div><a class="indexterm" name="idm44761348280176"></a></li><li class="listitem"><p>
          <code class="literal">data_lock_waits</code>:「このパフォーマンススキーマ」テーブルには、特定のロックを待機しているトランザクション、または特定のトランザクションが待機しているロックが示されます。 このテーブルには、ブロックされているトランザクションごとに、そのトランザクションが要求したロックと、その要求をブロックしているロックを示す 1 つ以上の行が含まれています。 <code class="literal">REQUESTING_ENGINE_LOCK_ID</code> 値はトランザクションによってリクエストされたロックを参照し、<code class="literal">BLOCKING_ENGINE_LOCK_ID</code> 値は最初のトランザクションの続行を妨げる (別のトランザクションによって保持されている) ロックを参照します。 特定のブロックされたトランザクションについて、<code class="literal">data_lock_waits</code> のすべての行の値は、<code class="literal">REQUESTING_ENGINE_LOCK_ID</code> では同じで、<code class="literal">BLOCKING_ENGINE_LOCK_ID</code> では異なる値になります。 
        </p><a class="indexterm" name="idm44761348271392"></a></li></ul></div><p>
      前述のテーブルの詳細は、<a class="xref" href="information-schema.html#information-schema-innodb-trx-table" title="26.51.29 INFORMATION_SCHEMA INNODB_TRX テーブル">セクション26.51.29「INFORMATION_SCHEMA INNODB_TRX テーブル」</a>、<a class="xref" href="performance-schema.html#performance-schema-data-locks-table" title="27.12.13.1 data_locks テーブル">セクション27.12.13.1「data_locks テーブル」</a> および <a class="xref" href="performance-schema.html#performance-schema-data-lock-waits-table" title="27.12.13.2 data_lock_waits テーブル">セクション27.12.13.2「data_lock_waits テーブル」</a> を参照してください。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-information-schema-examples"></a>15.15.2.1 InnoDB トランザクションの使用および情報のロック</h4></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          このセクションでは、MySQL 8.0 内の <code class="literal">INFORMATION_SCHEMA</code> <code class="literal">INNODB_LOCKS</code> および <code class="literal">INNODB_LOCK_WAITS</code> テーブルよりも優先される、パフォーマンススキーマ <code class="literal">data_locks</code> および <code class="literal">data_lock_waits</code> テーブルによって公開されるロック情報について説明します。 古い <code class="literal">INFORMATION_SCHEMA</code> テーブルに関して記述されている同様の説明は、<a class="ulink" href="https://dev.mysql.com/doc/refman/5.7/en/" target="_top">MySQL 5.7 Reference Manual</a> の <a class="ulink" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-information-schema-examples.html" target="_top">Using InnoDB Transaction and Locking Information</a> を参照してください。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-information-schema-examples-simple-blocking"></a>ブロックしているトランザクションの識別</h5></div></div></div><p>
          どのトランザクションが別のトランザクションをブロックしているかを識別すると役立つ場合があります。 <code class="literal">InnoDB</code> トランザクションおよびデータロックに関する情報を含むテーブルを使用すると、どのトランザクションが別のトランザクションを待機しているか、およびどのリソースがリクエストされているかを判別できます。 (これらのテーブルの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-information-schema-transactions" title="15.15.2 InnoDB INFORMATION_SCHEMA トランザクションおよびロック情報">セクション15.15.2「InnoDB INFORMATION_SCHEMA トランザクションおよびロック情報」</a> を参照してください。) 
        </p><p>
          3 つのセッションが同時に実行されているとします。 各セッションは MySQL スレッドに対応し、あるトランザクションを別のトランザクションの後に実行します。 これらのセッションが次のステートメントを発行したが、まだトランザクションをコミットしていない場合は、システムの状態を考慮してください: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              セッション A:
            </p><pre class="programlisting">BEGIN;
SELECT a FROM t FOR UPDATE;
SELECT SLEEP(100);
</pre></li><li class="listitem"><p>
              セッション B:
            </p><pre class="programlisting">SELECT b FROM t FOR UPDATE;
</pre></li><li class="listitem"><p>
              セッション C:
            </p><pre class="programlisting">SELECT c FROM t FOR UPDATE;
</pre></li></ul></div><p>
          このシナリオでは、次のクエリーを使用して、待機中のトランザクションおよびブロックしているトランザクションを確認します:
        </p><pre class="programlisting">SELECT
  r.trx_id waiting_trx_id,
  r.trx_mysql_thread_id waiting_thread,
  r.trx_query waiting_query,
  b.trx_id blocking_trx_id,
  b.trx_mysql_thread_id blocking_thread,
  b.trx_query blocking_query
FROM       performance_schema.data_lock_waits w
INNER JOIN information_schema.innodb_trx b
  ON b.trx_id = w.blocking_engine_transaction_id
INNER JOIN information_schema.innodb_trx r
  ON r.trx_id = w.requesting_engine_transaction_id;
</pre><p>
          または、より単純に <code class="literal">sys</code> スキーマの <code class="literal">innodb_lock_waits</code> ビューを使用します:
        </p><pre class="programlisting">SELECT
  waiting_trx_id,
  waiting_pid,
  waiting_query,
  blocking_trx_id,
  blocking_pid,
  blocking_query
FROM sys.innodb_lock_waits;
</pre><p>
          ブロッキングクエリーに対して NULL 値がレポートされる場合は、<a class="xref" href="innodb-storage-engine.html#innodb-information-schema-examples-null-blocking-query" title="発行セッションがアイドル状態になった後のブロッキングクエリーの識別">発行セッションがアイドル状態になった後のブロッキングクエリーの識別</a> を参照してください。
        </p><div class="informaltable"><table summary="The result set of a query against the perormance_schema.data_lock_waits and INFORMATION_SCHEMA.INNODB_TRX tables, shown in the preceding text, indicating which InnoDB threads are waiting for which other threads."><col style="width: 9%"><col style="width: 9%"><col style="width: 33%"><col style="width: 10%"><col style="width: 10%"><col style="width: 33%"><thead><tr>
              <th scope="col">waiting trx id</th>
              <th scope="col">waiting thread</th>
              <th scope="col">waiting query</th>
              <th scope="col">blocking trx id</th>
              <th scope="col">blocking thread</th>
              <th scope="col">blocking query</th>
            </tr></thead><tbody><tr>
              <th scope="row"><code class="literal">A4</code></th>
              <td><code class="literal">6</code></td>
              <td><code class="literal">SELECT b FROM t FOR UPDATE</code></td>
              <td><code class="literal">A3</code></td>
              <td><code class="literal">5</code></td>
              <td><code class="literal">SELECT SLEEP(100)</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">A5</code></th>
              <td><code class="literal">7</code></td>
              <td><code class="literal">SELECT c FROM t FOR UPDATE</code></td>
              <td><code class="literal">A3</code></td>
              <td><code class="literal">5</code></td>
              <td><code class="literal">SELECT SLEEP(100)</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">A5</code></th>
              <td><code class="literal">7</code></td>
              <td><code class="literal">SELECT c FROM t FOR UPDATE</code></td>
              <td><code class="literal">A4</code></td>
              <td><code class="literal">6</code></td>
              <td><code class="literal">SELECT b FROM t FOR UPDATE</code></td>
            </tr></tbody></table></div><p>
          前述のテーブルでは、<span class="quote">「<span class="quote">「待機中のクエリー」</span>」</span>カラムまたは<span class="quote">「<span class="quote">「ブロッキングクエリー」</span>」</span>カラムでセッションを識別できます。 次のことがわかります。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              セッション B (trx id <code class="literal">A4</code>、スレッド <code class="literal">6</code>) とセッション C (trx id <code class="literal">A5</code>、スレッド <code class="literal">7</code>) はどちらもセッション A (trx id <code class="literal">A3</code>、スレッド <code class="literal">5</code>) を待機しています。
            </p></li><li class="listitem"><p>
              セッション C はセッション B およびセッション A を待機しています。
            </p></li></ul></div><p>
          基礎となるデータは、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">INNODB_TRX</code> テーブルおよびパフォーマンススキーマの <code class="literal">data_locks</code> および <code class="literal">data_lock_waits</code> テーブルに表示されます。
        </p><p>
          次のテーブルに、<code class="literal">INNODB_TRX</code> テーブルのサンプルコンテンツを示します。
        </p><div class="informaltable"><a name="innodb-information-schema-examples-simple-blocking-trx"></a><table summary="Sample data from the INFORMATION_SCHEMA.INNODB_TRX table, showing the typical types of entries for each column."><col style="width: 10%"><col style="width: 13%"><col style="width: 36%"><col style="width: 30%"><col style="width: 36%"><col style="width: 19%"><col style="width: 23%"><col style="width: 45%"><thead><tr>
              <th scope="col">trx id</th>
              <th scope="col">trx state</th>
              <th scope="col">trx started</th>
              <th scope="col">trx requested lock id</th>
              <th scope="col">trx wait started</th>
              <th scope="col">trx weight</th>
              <th scope="col">trx mysql thread id</th>
              <th scope="col">trx query</th>
            </tr></thead><tbody><tr>
              <th scope="row"><code class="literal">A3</code></th>
              <td><code class="literal">RUN­NING</code></td>
              <td><code class="literal">2008-01-15 16:44:54</code></td>
              <td><code class="literal">NULL</code></td>
              <td><code class="literal">NULL</code></td>
              <td><code class="literal">2</code></td>
              <td><code class="literal">5</code></td>
              <td><code class="literal">SELECT SLEEP(100)</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">A4</code></th>
              <td><code class="literal">LOCK WAIT</code></td>
              <td><code class="literal">2008-01-15 16:45:09</code></td>
              <td><code class="literal">A4:1:3:2</code></td>
              <td><code class="literal">2008-01-15 16:45:09</code></td>
              <td><code class="literal">2</code></td>
              <td><code class="literal">6</code></td>
              <td><code class="literal">SELECT b FROM t FOR UPDATE</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">A5</code></th>
              <td><code class="literal">LOCK WAIT</code></td>
              <td><code class="literal">2008-01-15 16:45:14</code></td>
              <td><code class="literal">A5:1:3:2</code></td>
              <td><code class="literal">2008-01-15 16:45:14</code></td>
              <td><code class="literal">2</code></td>
              <td><code class="literal">7</code></td>
              <td><code class="literal">SELECT c FROM t FOR UPDATE</code></td>
            </tr></tbody></table></div><p>
          次のテーブルに、<code class="literal">data_locks</code> テーブルのサンプルコンテンツを示します。
        </p><div class="informaltable"><a name="innodb-information-schema-examples-simple-blocking-locks"></a><table summary="Sample data from the Performance Schema data_locks table, showing the typical types of entries for each column."><col style="width: 26%"><col style="width: 13%"><col style="width: 14%"><col style="width: 21%"><col style="width: 16%"><col style="width: 15%"><col style="width: 29%"><col style="width: 20%"><thead><tr>
              <th scope="col">lock id</th>
              <th scope="col">lock trx id</th>
              <th scope="col">lock mode</th>
              <th scope="col">lock type</th>
              <th scope="col">スキーマのロック</th>
              <th scope="col">lock table</th>
              <th scope="col">lock index</th>
              <th scope="col">lock data</th>
            </tr></thead><tbody><tr>
              <th scope="row"><code class="literal">A3:1:3:2</code></th>
              <td><code class="literal">A3</code></td>
              <td><code class="literal">X</code></td>
              <td><code class="literal">RECORD</code></td>
              <td><code class="literal">test</code></td>
              <td><code class="literal">t</code></td>
              <td><code class="literal">PRIMARY</code></td>
              <td><code class="literal">0x0200</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">A4:1:3:2</code></th>
              <td><code class="literal">A4</code></td>
              <td><code class="literal">X</code></td>
              <td><code class="literal">RECORD</code></td>
              <td><code class="literal">test</code></td>
              <td><code class="literal">t</code></td>
              <td><code class="literal">PRIMARY</code></td>
              <td><code class="literal">0x0200</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">A5:1:3:2</code></th>
              <td><code class="literal">A5</code></td>
              <td><code class="literal">X</code></td>
              <td><code class="literal">RECORD</code></td>
              <td><code class="literal">test</code></td>
              <td><code class="literal">t</code></td>
              <td><code class="literal">PRIMARY</code></td>
              <td><code class="literal">0x0200</code></td>
            </tr></tbody></table></div><p>
          次のテーブルに、<code class="literal">data_lock_waits</code> テーブルのサンプルコンテンツを示します。
        </p><div class="informaltable"><a name="innodb-information-schema-examples-simple-blocking-waits"></a><table summary="Sample data from the Performance Schema data_lock_waits table, showing the typical types of entries for each column."><col style="width: 10%"><col style="width: 15%"><col style="width: 10%"><col style="width: 15%"><thead><tr>
              <th scope="col">requesting trx id</th>
              <th scope="col">requested lock id</th>
              <th scope="col">blocking trx id</th>
              <th scope="col">blocking lock id</th>
            </tr></thead><tbody><tr>
              <th scope="row"><code class="literal">A4</code></th>
              <td><code class="literal">A4:1:3:2</code></td>
              <td><code class="literal">A3</code></td>
              <td><code class="literal">A3:1:3:2</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">A5</code></th>
              <td><code class="literal">A5:1:3:2</code></td>
              <td><code class="literal">A3</code></td>
              <td><code class="literal">A3:1:3:2</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">A5</code></th>
              <td><code class="literal">A5:1:3:2</code></td>
              <td><code class="literal">A4</code></td>
              <td><code class="literal">A4:1:3:2</code></td>
            </tr></tbody></table></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-information-schema-examples-null-blocking-query"></a>発行セッションがアイドル状態になった後のブロッキングクエリーの識別</h5></div></div></div><p>
          ブロッキングトランザクションを識別するときに、クエリーを発行したセッションがアイドル状態になった場合は、ブロッキングクエリーに対して NULL 値が報告されます。 この場合は、次のステップを使用してブロッキングクエリーを決定します: 
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              ブロッキングトランザクションのプロセスリスト ID を識別します。 <code class="literal">sys.innodb_lock_waits</code> テーブルでは、ブロッキングトランザクションのプロセスリスト ID は <code class="literal">blocking_pid</code> 値です。 
            </p></li><li class="listitem"><p>
              <code class="literal">blocking_pid</code> を使用して、MySQL パフォーマンススキーマの <code class="literal">threads</code> テーブルをクエリーし、ブロックしているトランザクションの <code class="literal">THREAD_ID</code> を判別します。 たとえば、<code class="literal">blocking_pid</code> が 6 の場合は、次のクエリーを発行します: 
            </p><pre class="programlisting">SELECT THREAD_ID FROM performance_schema.threads WHERE PROCESSLIST_ID = 6;
</pre></li><li class="listitem"><p>
              <code class="literal">THREAD_ID</code> を使用して、パフォーマンススキーマ <code class="literal">events_statements_current</code> テーブルをクエリーし、スレッドによって最後に実行されたクエリーを確認します。 たとえば、<code class="literal">THREAD_ID</code> が 28 の場合は、次のクエリーを発行します: 
            </p><pre class="programlisting">SELECT THREAD_ID, SQL_TEXT FROM performance_schema.events_statements_current
WHERE THREAD_ID = 28\G
</pre></li><li class="listitem"><p>
              スレッドによって実行された最後のクエリーが、ロックが保持されている理由を判断するのに十分な情報でない場合は、パフォーマンススキーマ <code class="literal">events_statements_history</code> テーブルをクエリーして、スレッドによって実行された最後の 10 個のステートメントを表示できます。
            </p><pre class="programlisting">SELECT THREAD_ID, SQL_TEXT FROM performance_schema.events_statements_history
WHERE THREAD_ID = 28 ORDER BY EVENT_ID;
</pre></li></ol></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-information-schema-sample-locks"></a>InnoDB トランザクションと MySQL セッションの関連付け</h5></div></div></div><p>
          内部 <code class="literal">InnoDB</code> ロック情報を、MySQL によって保持されるセッションレベルの情報と関連付けると便利な場合があります。 たとえば、特定の <code class="literal">InnoDB</code> トランザクション ID について、対応する MySQL セッション ID とロックを保持している可能性があるセッションの名前を把握し、他のトランザクションをブロックする場合があります。 
        </p><p>
          <code class="literal">INFORMATION_SCHEMA</code> <code class="literal">INNODB_TRX</code> テーブル、パフォーマンススキーマ <code class="literal">data_locks</code> および <code class="literal">data_lock_waits</code> テーブルからの次の出力は、ある程度ロードされたシステムから取得されます。 表示されているように、複数のトランザクションが実行されています。 
        </p><p>
          次の <code class="literal">data_locks</code> テーブルおよび <code class="literal">data_lock_waits</code> テーブルは、次のことを示しています:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              トランザクション <code class="literal">77F</code> (<code class="literal">INSERT</code> を実行中) は、トランザクション <code class="literal">77E</code>、<code class="literal">77D</code>,、および <code class="literal">77B</code> がコミットするのを待機しています。
            </p></li><li class="listitem"><p>
              トランザクション <code class="literal">77E</code> (<code class="literal">INSERT</code> を実行) は、トランザクション <code class="literal">77D</code> および <code class="literal">77B</code> のコミットを待機しています。
            </p></li><li class="listitem"><p>
              トランザクション <code class="literal">77D</code> (<code class="literal">INSERT</code> を実行) は、トランザクション <code class="literal">77B</code> のコミットを待機しています。
            </p></li><li class="listitem"><p>
              トランザクション <code class="literal">77B</code> (<code class="literal">INSERT</code> を実行) は、トランザクション <code class="literal">77A</code> のコミットを待機しています。
            </p></li><li class="listitem"><p>
              トランザクション <code class="literal">77A</code> は実行中であり、現在 <code class="literal">SELECT</code> を実行しています。
            </p></li><li class="listitem"><p>
              トランザクション <code class="literal">E56</code> (<code class="literal">INSERT</code> を実行中) は、トランザクション <code class="literal">E55</code> がコミットするのを待機しています。
            </p></li><li class="listitem"><p>
              トランザクション <code class="literal">E55</code> (<code class="literal">INSERT</code> を実行中) は、トランザクション <code class="literal">19C</code> がコミットするのを待機しています。
            </p></li><li class="listitem"><p>
              トランザクション <code class="literal">19C</code> は実行中であり、現在 <code class="literal">INSERT</code> を実行しています。
            </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">INFORMATION_SCHEMA</code> <code class="literal">PROCESSLIST</code> テーブルと <code class="literal">INNODB_TRX</code> テーブルに表示されるクエリーの間に不整合がある可能性があります。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-information-schema-internal-data" title="15.15.2.3 InnoDB トランザクションおよびロック情報の永続性と一貫性">セクション15.15.2.3「InnoDB トランザクションおよびロック情報の永続性と一貫性」</a> を参照してください。 
          </p></div><p>
          次のテーブルに、重い <a class="link" href="glossary.html#glos_workload" title="ワークロード">workload</a> を実行しているシステムの <code class="literal">PROCESSLIST</code> テーブルの内容を示します。
        </p><div class="informaltable"><a name="innodb-information-schema-sample-processlist"></a><table summary="Sample data from the INFORMATION_SCHEMA.PROCESSLIST table, showing the internal workings of MySQL processes under a heavy workload."><col style="width: 8%"><col style="width: 11%"><col style="width: 21%"><col style="width: 10%"><col style="width: 20%"><col style="width: 10%"><col style="width: 20%"><col style="width: 25%"><thead><tr>
              <th scope="col">ID</th>
              <th scope="col">USER</th>
              <th scope="col">HOST</th>
              <th scope="col">DB</th>
              <th scope="col">COMMAND</th>
              <th scope="col">TIME</th>
              <th scope="col">STATE</th>
              <th scope="col">INFO</th>
            </tr></thead><tbody><tr>
              <th scope="row"><code class="literal">384</code></th>
              <td><code class="literal">root</code></td>
              <td><code class="literal">localhost</code></td>
              <td><code class="literal">test</code></td>
              <td><code class="literal">Query</code></td>
              <td><code class="literal">10</code></td>
              <td><code class="literal">update</code></td>
              <td><code class="literal">INSERT INTO t2 VALUES …</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">257</code></th>
              <td><code class="literal">root</code></td>
              <td><code class="literal">localhost</code></td>
              <td><code class="literal">test</code></td>
              <td><code class="literal">Query</code></td>
              <td><code class="literal">3</code></td>
              <td><code class="literal">update</code></td>
              <td><code class="literal">INSERT INTO t2 VALUES …</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">130</code></th>
              <td><code class="literal">root</code></td>
              <td><code class="literal">localhost</code></td>
              <td><code class="literal">test</code></td>
              <td><code class="literal">Query</code></td>
              <td><code class="literal">0</code></td>
              <td><code class="literal">update</code></td>
              <td><code class="literal">INSERT INTO t2 VALUES …</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">61</code></th>
              <td><code class="literal">root</code></td>
              <td><code class="literal">localhost</code></td>
              <td><code class="literal">test</code></td>
              <td><code class="literal">Query</code></td>
              <td><code class="literal">1</code></td>
              <td><code class="literal">update</code></td>
              <td><code class="literal">INSERT INTO t2 VALUES …</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">8</code></th>
              <td><code class="literal">root</code></td>
              <td><code class="literal">localhost</code></td>
              <td><code class="literal">test</code></td>
              <td><code class="literal">Query</code></td>
              <td><code class="literal">1</code></td>
              <td><code class="literal">update</code></td>
              <td><code class="literal">INSERT INTO t2 VALUES …</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">4</code></th>
              <td><code class="literal">root</code></td>
              <td><code class="literal">localhost</code></td>
              <td><code class="literal">test</code></td>
              <td><code class="literal">Query</code></td>
              <td><code class="literal">0</code></td>
              <td><code class="literal">preparing</code></td>
              <td><code class="literal">SELECT * FROM PROCESSLIST</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">2</code></th>
              <td><code class="literal">root</code></td>
              <td><code class="literal">localhost</code></td>
              <td><code class="literal">test</code></td>
              <td><code class="literal">Sleep</code></td>
              <td><code class="literal">566</code></td>
              <td><code class="literal"></code></td>
              <td><code class="literal">NULL</code></td>
            </tr></tbody></table></div><p>
          次のテーブルに、重い <a class="link" href="glossary.html#glos_workload" title="ワークロード">workload</a> を実行しているシステムの <code class="literal">INNODB_TRX</code> テーブルの内容を示します。
        </p><div class="informaltable"><a name="innodb-information-schema-sample-innodb-trx"></a><table summary="Sample data from the INFORMATION_SCHEMA.INNODB_TRX table, showing the internal workings of InnoDB transactions under a heavy workload."><col style="width: 8%"><col style="width: 10%"><col style="width: 19%"><col style="width: 21%"><col style="width: 19%"><col style="width: 10%"><col style="width: 10%"><col style="width: 31%"><thead><tr>
              <th scope="col">trx id</th>
              <th scope="col">trx state</th>
              <th scope="col">trx started</th>
              <th scope="col">trx requested lock id</th>
              <th scope="col">trx wait started</th>
              <th scope="col">trx weight</th>
              <th scope="col">trx mysql thread id</th>
              <th scope="col">trx query</th>
            </tr></thead><tbody><tr>
              <th scope="row"><code class="literal">77F</code></th>
              <td><code class="literal">LOCK WAIT</code></td>
              <td><code class="literal">2008-01-15 13:10:16</code></td>
              <td><code class="literal">77F</code></td>
              <td><code class="literal">2008-01-15 13:10:16</code></td>
              <td><code class="literal">1</code></td>
              <td><code class="literal">876</code></td>
              <td><code class="literal">INSERT INTO t09 (D, B, C) VALUES …</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">77E</code></th>
              <td><code class="literal">LOCK WAIT</code></td>
              <td><code class="literal">2008-01-15 13:10:16</code></td>
              <td><code class="literal">77E</code></td>
              <td><code class="literal">2008-01-15 13:10:16</code></td>
              <td><code class="literal">1</code></td>
              <td><code class="literal">875</code></td>
              <td><code class="literal">INSERT INTO t09 (D, B, C) VALUES …</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">77D</code></th>
              <td><code class="literal">LOCK WAIT</code></td>
              <td><code class="literal">2008-01-15 13:10:16</code></td>
              <td><code class="literal">77D</code></td>
              <td><code class="literal">2008-01-15 13:10:16</code></td>
              <td><code class="literal">1</code></td>
              <td><code class="literal">874</code></td>
              <td><code class="literal">INSERT INTO t09 (D, B, C) VALUES …</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">77B</code></th>
              <td><code class="literal">LOCK WAIT</code></td>
              <td><code class="literal">2008-01-15 13:10:16</code></td>
              <td><code class="literal">77B:733:12:1</code></td>
              <td><code class="literal">2008-01-15 13:10:16</code></td>
              <td><code class="literal">4</code></td>
              <td><code class="literal">873</code></td>
              <td><code class="literal">INSERT INTO t09 (D, B, C) VALUES …</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">77A</code></th>
              <td><code class="literal">RUN­NING</code></td>
              <td><code class="literal">2008-01-15 13:10:16</code></td>
              <td><code class="literal">NULL</code></td>
              <td><code class="literal">NULL</code></td>
              <td><code class="literal">4</code></td>
              <td><code class="literal">872</code></td>
              <td><code class="literal">SELECT b, c FROM t09 WHERE …</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">E56</code></th>
              <td><code class="literal">LOCK WAIT</code></td>
              <td><code class="literal">2008-01-15 13:10:06</code></td>
              <td><code class="literal">E56:743:6:2</code></td>
              <td><code class="literal">2008-01-15 13:10:06</code></td>
              <td><code class="literal">5</code></td>
              <td><code class="literal">384</code></td>
              <td><code class="literal">INSERT INTO t2 VALUES …</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">E55</code></th>
              <td><code class="literal">LOCK WAIT</code></td>
              <td><code class="literal">2008-01-15 13:10:06</code></td>
              <td><code class="literal">E55:743:38:2</code></td>
              <td><code class="literal">2008-01-15 13:10:13</code></td>
              <td><code class="literal">965</code></td>
              <td><code class="literal">257</code></td>
              <td><code class="literal">INSERT INTO t2 VALUES …</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">19C</code></th>
              <td><code class="literal">RUN­NING</code></td>
              <td><code class="literal">2008-01-15 13:09:10</code></td>
              <td><code class="literal">NULL</code></td>
              <td><code class="literal">NULL</code></td>
              <td><code class="literal">2900</code></td>
              <td><code class="literal">130</code></td>
              <td><code class="literal">INSERT INTO t2 VALUES …</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">E15</code></th>
              <td><code class="literal">RUN­NING</code></td>
              <td><code class="literal">2008-01-15 13:08:59</code></td>
              <td><code class="literal">NULL</code></td>
              <td><code class="literal">NULL</code></td>
              <td><code class="literal">5395</code></td>
              <td><code class="literal">61</code></td>
              <td><code class="literal">INSERT INTO t2 VALUES …</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">51D</code></th>
              <td><code class="literal">RUN­NING</code></td>
              <td><code class="literal">2008-01-15 13:08:47</code></td>
              <td><code class="literal">NULL</code></td>
              <td><code class="literal">NULL</code></td>
              <td><code class="literal">9807</code></td>
              <td><code class="literal">8</code></td>
              <td><code class="literal">INSERT INTO t2 VALUES …</code></td>
            </tr></tbody></table></div><p>
          次のテーブルに、重い <a class="link" href="glossary.html#glos_workload" title="ワークロード">workload</a> を実行しているシステムの <code class="literal">data_lock_waits</code> テーブルの内容を示します。
        </p><div class="informaltable"><a name="innodb-information-schema-sample-innodb-lock-waits"></a><table summary="Sample data from the Performance Schema data_lock_waits table, showing the internal workings of InnoDB locking under a heavy workload."><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><thead><tr>
              <th scope="col">requesting trx id</th>
              <th scope="col">requested lock id</th>
              <th scope="col">blocking trx id</th>
              <th scope="col">blocking lock id</th>
            </tr></thead><tbody><tr>
              <th scope="row"><code class="literal">77F</code></th>
              <td><code class="literal">77F:806</code></td>
              <td><code class="literal">77E</code></td>
              <td><code class="literal">77E:806</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">77F</code></th>
              <td><code class="literal">77F:806</code></td>
              <td><code class="literal">77D</code></td>
              <td><code class="literal">77D:806</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">77F</code></th>
              <td><code class="literal">77F:806</code></td>
              <td><code class="literal">77B</code></td>
              <td><code class="literal">77B:806</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">77E</code></th>
              <td><code class="literal">77E:806</code></td>
              <td><code class="literal">77D</code></td>
              <td><code class="literal">77D:806</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">77E</code></th>
              <td><code class="literal">77E:806</code></td>
              <td><code class="literal">77B</code></td>
              <td><code class="literal">77B:806</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">77D</code></th>
              <td><code class="literal">77D:806</code></td>
              <td><code class="literal">77B</code></td>
              <td><code class="literal">77B:806</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">77B</code></th>
              <td><code class="literal">77B:733:12:1</code></td>
              <td><code class="literal">77A</code></td>
              <td><code class="literal">77A:733:12:1</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">E56</code></th>
              <td><code class="literal">E56:743:6:2</code></td>
              <td><code class="literal">E55</code></td>
              <td><code class="literal">E55:743:6:2</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">E55</code></th>
              <td><code class="literal">E55:743:38:2</code></td>
              <td><code class="literal">19C</code></td>
              <td><code class="literal">19C:743:38:2</code></td>
            </tr></tbody></table></div><p>
          次のテーブルに、重い <a class="link" href="glossary.html#glos_workload" title="ワークロード">workload</a> を実行しているシステムの <code class="literal">data_locks</code> テーブルの内容を示します。
        </p><div class="informaltable"><a name="innodb-information-schema-sample-innodb-locks"></a><table summary="Sample data from the Performance Schema data_locks table, showing the internal workings of InnoDB locking under a heavy workload."><col style="width: 18%"><col style="width: 9%"><col style="width: 12%"><col style="width: 12%"><col style="width: 9%"><col style="width: 8%"><col style="width: 15%"><col style="width: 17%"><thead><tr>
              <th scope="col">lock id</th>
              <th scope="col">lock trx id</th>
              <th scope="col">lock mode</th>
              <th scope="col">lock type</th>
              <th scope="col">スキーマのロック</th>
              <th scope="col">lock table</th>
              <th scope="col">lock index</th>
              <th scope="col">lock data</th>
            </tr></thead><tbody><tr>
              <th scope="row"><code class="literal">77F:806</code></th>
              <td><code class="literal">77F</code></td>
              <td><code class="literal">AUTO_INC</code></td>
              <td><code class="literal">TABLE</code></td>
              <td><code class="literal">test</code></td>
              <td><code class="literal">t09</code></td>
              <td><code class="literal">NULL</code></td>
              <td><code class="literal">NULL</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">77E:806</code></th>
              <td><code class="literal">77E</code></td>
              <td><code class="literal">AUTO_INC</code></td>
              <td><code class="literal">TABLE</code></td>
              <td><code class="literal">test</code></td>
              <td><code class="literal">t09</code></td>
              <td><code class="literal">NULL</code></td>
              <td><code class="literal">NULL</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">77D:806</code></th>
              <td><code class="literal">77D</code></td>
              <td><code class="literal">AUTO_INC</code></td>
              <td><code class="literal">TABLE</code></td>
              <td><code class="literal">test</code></td>
              <td><code class="literal">t09</code></td>
              <td><code class="literal">NULL</code></td>
              <td><code class="literal">NULL</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">77B:806</code></th>
              <td><code class="literal">77B</code></td>
              <td><code class="literal">AUTO_INC</code></td>
              <td><code class="literal">TABLE</code></td>
              <td><code class="literal">test</code></td>
              <td><code class="literal">t09</code></td>
              <td><code class="literal">NULL</code></td>
              <td><code class="literal">NULL</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">77B:733:12:1</code></th>
              <td><code class="literal">77B</code></td>
              <td><code class="literal">X</code></td>
              <td><code class="literal">RECORD</code></td>
              <td><code class="literal">test</code></td>
              <td><code class="literal">t09</code></td>
              <td><code class="literal">PRIMARY</code></td>
              <td><code class="literal">supremum pseudo-record</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">77A:733:12:1</code></th>
              <td><code class="literal">77A</code></td>
              <td><code class="literal">X</code></td>
              <td><code class="literal">RECORD</code></td>
              <td><code class="literal">test</code></td>
              <td><code class="literal">t09</code></td>
              <td><code class="literal">PRIMARY</code></td>
              <td><code class="literal">supremum pseudo-record</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">E56:743:6:2</code></th>
              <td><code class="literal">E56</code></td>
              <td><code class="literal">S</code></td>
              <td><code class="literal">RECORD</code></td>
              <td><code class="literal">test</code></td>
              <td><code class="literal">t2</code></td>
              <td><code class="literal">PRIMARY</code></td>
              <td><code class="literal">0, 0</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">E55:743:6:2</code></th>
              <td><code class="literal">E55</code></td>
              <td><code class="literal">X</code></td>
              <td><code class="literal">RECORD</code></td>
              <td><code class="literal">test</code></td>
              <td><code class="literal">t2</code></td>
              <td><code class="literal">PRIMARY</code></td>
              <td><code class="literal">0, 0</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">E55:743:38:2</code></th>
              <td><code class="literal">E55</code></td>
              <td><code class="literal">S</code></td>
              <td><code class="literal">RECORD</code></td>
              <td><code class="literal">test</code></td>
              <td><code class="literal">t2</code></td>
              <td><code class="literal">PRIMARY</code></td>
              <td><code class="literal">1922, 1922</code></td>
            </tr><tr>
              <th scope="row"><code class="literal">19C:743:38:2</code></th>
              <td><code class="literal">19C</code></td>
              <td><code class="literal">X</code></td>
              <td><code class="literal">RECORD</code></td>
              <td><code class="literal">test</code></td>
              <td><code class="literal">t2</code></td>
              <td><code class="literal">PRIMARY</code></td>
              <td><code class="literal">1922, 1922</code></td>
            </tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-information-schema-understanding-innodb-locking"></a>15.15.2.2 InnoDB のロックおよびロック待機情報</h4></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          このセクションでは、MySQL 8.0 内の <code class="literal">INFORMATION_SCHEMA</code> <code class="literal">INNODB_LOCKS</code> および <code class="literal">INNODB_LOCK_WAITS</code> テーブルよりも優先される、パフォーマンススキーマ <code class="literal">data_locks</code> および <code class="literal">data_lock_waits</code> テーブルによって公開されるロック情報について説明します。 古い <code class="literal">INFORMATION_SCHEMA</code> テーブルに関して記述されている同様の説明は、<a class="ulink" href="https://dev.mysql.com/doc/refman/5.7/en/" target="_top">MySQL 5.7 Reference Manual</a> の <a class="ulink" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-information-schema-understanding-innodb-locking.html" target="_top">InnoDB Lock and Lock-Wait Information</a> を参照してください。 
        </p></div><p>
        トランザクションがテーブル内の行を更新するか、または <code class="literal">SELECT FOR UPDATE</code> でロックする場合、<code class="literal">InnoDB</code> はその行に関するロックのリストまたはキューを確立します。 同様に、テーブルレベルのロックの場合、<code class="literal">InnoDB</code> はテーブルに関するロックのリストを保持します。 2 番目のトランザクションが、互換性がないモードにある以前のトランザクションによってすでにロックされている行の更新またはテーブルのロックを行おうとした場合、<code class="literal">InnoDB</code> はその行に対するロック要求を対応するキューに追加します。 トランザクションによってロックを取得するには、その行またはテーブルのロックキューに以前に入力されたすべての互換性のないロックリクエストを削除する必要があります (これらのロックを保持またはリクエストしているトランザクションがコミットまたはロールバックしたときに発生します)。 
      </p><p>
        トランザクションは、異なる行またはテーブルに対する任意の数のロック要求を保持できます。 トランザクションはいつでも、別のトランザクションによって保持されているロックを要求できますが、そのロックは、その別のトランザクションによってブロックされます。 リクエスト側トランザクションは、ブロッキングロックを保持するトランザクションがコミットまたはロールバックされるまで待機する必要があります。 トランザクションがロックを待機していない場合は、<code class="literal">RUNNING</code> 状態になります。 トランザクションがロックを待機している場合は、<code class="literal">LOCK WAIT</code> 状態になります。 (<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">INNODB_TRX</code> テーブルは、トランザクションの状態の値を示します。) 
      </p><p>
        パフォーマンススキーマ <code class="literal">data_locks</code> テーブルには、<code class="literal">LOCK WAIT</code> トランザクションごとに 1 つ以上の行が保持され、その進行を妨げるロック要求があることを示します。 このテーブルにはまた、特定の行またはテーブルに対して保留されているロックのキュー内の各ロックを記述した 1 行も含まれています。 パフォーマンススキーマ <code class="literal">data_lock_waits</code> テーブルには、ほかのトランザクションによって要求されたロックをブロックしているトランザクションによってすでに保持されているロックが表示されます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-information-schema-internal-data"></a>15.15.2.3 InnoDB トランザクションおよびロック情報の永続性と一貫性</h4></div></div></div><a class="indexterm" name="idm44761347544160"></a><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          このセクションでは、MySQL 8.0 内の <code class="literal">INFORMATION_SCHEMA</code> <code class="literal">INNODB_LOCKS</code> および <code class="literal">INNODB_LOCK_WAITS</code> テーブルよりも優先される、パフォーマンススキーマ <code class="literal">data_locks</code> および <code class="literal">data_lock_waits</code> テーブルによって公開されるロック情報について説明します。 古い <code class="literal">INFORMATION_SCHEMA</code> テーブルに関して記述されている同様の説明は、<a class="ulink" href="https://dev.mysql.com/doc/refman/5.7/en/" target="_top">MySQL 5.7 Reference Manual</a> の <a class="ulink" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-information-schema-internal-data.html" target="_top">Persistence and Consistency of InnoDB Transaction and Locking Information</a> を参照してください。 
        </p></div><p>
        トランザクションテーブルとロックテーブル (<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">INNODB_TRX</code> テーブル、パフォーマンススキーマ <code class="literal">data_locks</code> テーブル、および <code class="literal">data_lock_waits</code> テーブル) によって公開されるデータは、高速変更データの概要を表します。 これは、アプリケーションによって開始された更新が発生した場合にのみデータが変更されるユーザーテーブルとは異なります。 基礎となるデータはシステム管理の内部データであり、非常に迅速に変更できます: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            データは、<code class="literal">INNODB_TRX</code>、<code class="literal">data_locks</code> および <code class="literal">data_lock_waits</code> テーブル間で一貫性がない場合があります。
          </p><p>
            <code class="literal">data_locks</code> および <code class="literal">data_lock_waits</code> テーブルは、<code class="literal">INNODB_TRX</code> テーブル内のトランザクションに関するロック情報を提供するために、<code class="literal">InnoDB</code> ストレージエンジンからライブデータを公開します。 ロックテーブルから取得されたデータは、<code class="literal">SELECT</code> の実行時に存在しますが、クエリー結果がクライアントによって消費されるまでに削除または変更される場合があります。 
          </p><p>
            <code class="literal">data_locks</code> を <code class="literal">data_lock_waits</code> と結合すると、存在しない、またはまだ存在しない <code class="literal">data_locks</code> の親行を識別する <code class="literal">data_lock_waits</code> の行を表示できます。
          </p></li><li class="listitem"><p>
            トランザクションテーブルおよびロックテーブルのデータは、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">PROCESSLIST</code> テーブルまたはパフォーマンススキーマ <code class="literal">threads</code> テーブルのデータと整合性がとれていない可能性があります。
          </p><p>
            たとえば、<code class="literal">InnoDB</code> トランザクションのデータを比較し、テーブルを <code class="literal">PROCESSLIST</code> テーブルのデータとロックする場合は注意が必要です。 1 つの <code class="literal">SELECT</code> (たとえば、<code class="literal">INNODB_TRX</code> と <code class="literal">PROCESSLIST</code> の結合) を発行した場合でも、一般に、これらのテーブルの内容には整合性がありません。 <code class="literal">INNODB_TRX</code> では、<code class="literal">PROCESSLIST</code> に存在しない行や、<code class="literal">INNODB_TRX.TRX_QUERY</code> に表示されているトランザクションの現在実行中の SQL クエリーが <code class="literal">PROCESSLIST.INFO</code> のものと異なる行を参照できます。 
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-information-schema-system-tables"></a>15.15.3 InnoDB INFORMATION_SCHEMA スキーマオブジェクトテーブル</h3></div></div></div><p>
      <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> テーブルを使用して、<code class="literal">InnoDB</code> で管理されるスキーマオブジェクトに関するメタデータを抽出できます。 この情報はデータディクショナリから取得されます。 従来、このタイプの情報は、<a class="xref" href="innodb-storage-engine.html#innodb-monitors" title="15.17 InnoDB モニター">セクション15.17「InnoDB モニター」</a> の手法を使用して取得し、<code class="literal">InnoDB</code> モニターを設定して、<code class="literal">SHOW ENGINE INNODB STATUS</code> ステートメントからの出力を解析します。 <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> テーブルのインタフェースを使用すると、SQL を使用してこのデータをクエリーできます。 
    </p><p>
      <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> スキーマオブジェクトテーブルには、次のテーブルが含まれます。
    </p><pre class="programlisting">INNODB_DATAFILES
INNODB_TABLESTATS
INNODB_FOREIGN
INNODB_COLUMNS
INNODB_INDEXES
INNODB_FIELDS
INNODB_TABLESPACES
INNODB_TABLESPACES_BRIEF
INNODB_FOREIGN_COLS
INNODB_TABLES
</pre><p>
      これらのテーブル名は、提供されるデータのタイプを示しています。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">INNODB_TABLES</code> は、<code class="literal">InnoDB</code> テーブルに関するメタデータを提供します。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_COLUMNS</code> は、<code class="literal">InnoDB</code> テーブルのカラムに関するメタデータを提供します。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_INDEXES</code> は、<code class="literal">InnoDB</code> インデックスに関するメタデータを提供します。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_FIELDS</code> では、<code class="literal">InnoDB</code> インデックスのキーカラム (フィールド) に関するメタデータが提供されます。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_TABLESTATS</code> では、メモリー内データ構造から導出された <code class="literal">InnoDB</code> テーブルに関する低レベルのステータス情報のビューが提供されます。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_DATAFILES</code> では、<code class="literal">InnoDB</code> file-per-table および一般テーブルスペースのデータファイルパス情報が提供されます。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_TABLESPACES</code> は、<code class="literal">InnoDB</code> file-per-table、general および undo テーブルスペースに関するメタデータを提供します。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_TABLESPACES_BRIEF</code> では、<code class="literal">InnoDB</code> テーブルスペースに関するメタデータのサブセットが提供されます。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_FOREIGN</code> は、<code class="literal">InnoDB</code> テーブルに定義されている外部キーに関するメタデータを提供します。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_FOREIGN_COLS</code> では、<code class="literal">InnoDB</code> テーブルに定義されている外部キーのカラムに関するメタデータが提供されます。
        </p></li></ul></div><p>
      <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> スキーマオブジェクトテーブルは、<code class="literal">TABLE_ID</code>、<code class="literal">INDEX_ID</code>、<code class="literal">SPACE</code> などのフィールドを使用して結合できるため、調査または監視するオブジェクトに使用可能なすべてのデータを簡単に取得できます。
    </p><p>
      各テーブルのカラムについては、<code class="literal">InnoDB</code> <a class="link" href="information-schema.html#innodb-information-schema-tables" title="26.51 INFORMATION_SCHEMA InnoDB テーブル">INFORMATION_SCHEMA</a> のドキュメントを参照してください。
    </p><div class="example"><a name="innodb-information-schema-system-tables-example"></a><p class="title"><b>例 15.2 InnoDB INFORMATION_SCHEMA スキーマオブジェクトテーブル</b></p><div class="example-contents"><p>
        この例では、単一のインデックス (<code class="literal">i1</code>) を持つ単純なテーブル (<code class="literal">t1</code>) を使用して、<code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> スキーマオブジェクトテーブルにあるメタデータのタイプを示します。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            テストデータベースとテーブル <code class="literal">t1</code> を作成します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE DATABASE test;</code></strong>

mysql&gt; <strong class="userinput"><code>USE test;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
       <strong class="userinput"><code>col1 INT,</code></strong>
       <strong class="userinput"><code>col2 CHAR(10),</code></strong>
       <strong class="userinput"><code>col3 VARCHAR(10))</code></strong>
       <strong class="userinput"><code>ENGINE = InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE INDEX i1 ON t1(col1);</code></strong>
</pre></li><li class="listitem"><p>
            テーブル <code class="literal">t1</code> を作成した後、<code class="literal">INNODB_TABLES</code> をクエリーして <code class="literal">test/t1</code> のメタデータを検索します:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_TABLES WHERE NAME='test/t1' \G</code></strong>
*************************** 1. row ***************************
     TABLE_ID: 71
         NAME: test/t1
         FLAG: 1
       N_COLS: 6
        SPACE: 57
   ROW_FORMAT: Compact
ZIP_PAGE_SIZE: 0
 INSTANT_COLS: 0
</pre><p>
            テーブル <code class="literal">t1</code> の <code class="literal">TABLE_ID</code> は 71 です。 <code class="literal">FLAG</code> フィールドは、テーブルの形式とストレージの特性に関するビットレベルの情報を提供します。 6 つのカラムがあり、そのうちの 3 つが <code class="literal">InnoDB</code> によって作成された非表示のカラム (<code class="literal">DB_ROW_ID</code>、<code class="literal">DB_TRX_ID</code>、および <code class="literal">DB_ROLL_PTR</code>) です。 このテーブルの <code class="literal">SPACE</code> の ID は 57 です (0 の値は、テーブルがシステムテーブルスペース内に存在することを示します)。 <code class="literal">ROW_FORMAT</code> はコンパクトです。 <code class="literal">ZIP_PAGE_SIZE</code> は、<code class="literal">Compressed</code> 行フォーマットのテーブルにのみ適用されます。 <code class="literal">INSTANT_COLS</code> では、<code class="literal">ALGORITHM=INSTANT</code> で <code class="literal">ALTER TABLE ... ADD COLUMN</code> を使用して最初のインスタントカラムを追加する前に、テーブルのカラム数が表示されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">INNODB_TABLES</code> の <code class="literal">TABLE_ID</code> 情報を使用して、<code class="literal">INNODB_COLUMNS</code> テーブルにテーブルのカラムに関する情報をクエリーします。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_COLUMNS where TABLE_ID = 71\G</code></strong>
*************************** 1. row ***************************
     TABLE_ID: 71
         NAME: col1
          POS: 0
        MTYPE: 6
       PRTYPE: 1027
          LEN: 4
  HAS_DEFAULT: 0
DEFAULT_VALUE: NULL
*************************** 2. row ***************************
     TABLE_ID: 71
         NAME: col2
          POS: 1
        MTYPE: 2
       PRTYPE: 524542
          LEN: 10
  HAS_DEFAULT: 0
DEFAULT_VALUE: NULL
*************************** 3. row ***************************
     TABLE_ID: 71
         NAME: col3
          POS: 2
        MTYPE: 1
       PRTYPE: 524303
          LEN: 10
  HAS_DEFAULT: 0
DEFAULT_VALUE: NULL
</pre><p>
            <code class="literal">TABLE_ID</code> および <code class="literal">NAME</code> カラムに加えて、<code class="literal">INNODB_COLUMNS</code> は、(0 から始まり、順次増分する) 各カラムの順序位置 (<code class="literal">POS</code>)、<code class="literal">MTYPE</code> または<span class="quote">「<span class="quote">「メインタイプ」</span>」</span> (6 = INT, 2 = CHAR, 1 = VARCHAR)、<code class="literal">PRTYPE</code> または<span class="quote">「<span class="quote">「正確な型」</span>」</span> (MySQL データセット、文字セットコード、およびヌル可能性を示すビットを持つバイナリ値) およびコード長を表すリテラル (<code class="literal">LEN</code>) を提供します。 <code class="literal">HAS_DEFAULT</code> および <code class="literal">DEFAULT_VALUE</code> のカラムは、<code class="literal">ALGORITHM=INSTANT</code> とともに <code class="literal">ALTER TABLE ... ADD COLUMN</code> を使用して即時に追加されたカラムにのみ適用されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">INNODB_TABLES</code> の <code class="literal">TABLE_ID</code> 情報を再度使用して、テーブル <code class="literal">t1</code> に関連付けられたインデックスに関する情報を <code class="literal">INNODB_INDEXES</code> にクエリーします。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_INDEXES WHERE TABLE_ID = 71 \G</code></strong>
*************************** 1. row ***************************
       INDEX_ID: 111
           NAME: GEN_CLUST_INDEX
       TABLE_ID: 71
           TYPE: 1
       N_FIELDS: 0
        PAGE_NO: 3
          SPACE: 57
MERGE_THRESHOLD: 50
*************************** 2. row ***************************
       INDEX_ID: 112
           NAME: i1
       TABLE_ID: 71
           TYPE: 0
       N_FIELDS: 1
        PAGE_NO: 4
          SPACE: 57
MERGE_THRESHOLD: 50
</pre><p>
            <code class="literal">INNODB_INDEXES</code> は、2 つのインデックスのデータを返します。 最初のインデックスは <code class="literal">GEN_CLUST_INDEX</code> です。これは、テーブルにユーザー定義のクラスタ化されたインデックスが存在しない場合に <code class="literal">InnoDB</code> によって作成されたクラスタ化されたインデックスです。 2 番目のインデックス (<code class="literal">i1</code>) は、ユーザー定義のセカンダリインデックスです。 
          </p><p>
            <code class="literal">INDEX_ID</code> は、インスタンス内のすべてのデータベースにわたって一意であるインデックスの識別子です。 <code class="literal">TABLE_ID</code> は、そのインデックスが関連付けられているテーブルを識別します。 インデックスの <code class="literal">TYPE</code> 値は、インデックスのタイプ (1 = クラスタ化されたインデックス、0 = セカンダリインデックス) を示します。 <code class="literal">N_FILEDS</code> 値は、このインデックスを構成するフィールドの数です。 <code class="literal">PAGE_NO</code> はインデックスの B ツリーのルートページ番号であり、<code class="literal">SPACE</code> はインデックスが存在するテーブルスペースの ID です。 ゼロ以外の値は、インデックスがシステムテーブルスペースに存在しないことを示します。 <code class="literal">MERGE_THRESHOLD</code> では、インデックスページのデータ量のパーセンテージしきい値を定義します。 行が削除されたとき、または更新操作によって行が短縮されたときに、インデックスページのデータ量がこの値 (デフォルトは 50%) を下回った場合、<code class="literal">InnoDB</code> はインデックスページを隣接するインデックスページとマージしようとします。 
          </p></li><li class="listitem"><p>
            <code class="literal">INNODB_INDEXES</code> の <code class="literal">INDEX_ID</code> 情報を使用して、<code class="literal">INNODB_FIELDS</code> にインデックス <code class="literal">i1</code> のフィールドに関する情報をクエリーします。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_FIELDS where INDEX_ID = 112 \G</code></strong>
*************************** 1. row ***************************
INDEX_ID: 112
    NAME: col1
     POS: 0
</pre><p>
            <code class="literal">INNODB_FIELDS</code> には、インデックス付きフィールドの <code class="literal">NAME</code> と、インデックス内での順序位置が用意されています。 インデックス (i1) が複数のフィールドに定義されている場合、<code class="literal">INNODB_FIELDS</code> はインデックス付けされた各フィールドのメタデータを提供します。 
          </p></li><li class="listitem"><p>
            <code class="literal">INNODB_TABLES</code> の <code class="literal">SPACE</code> 情報を使用して、<code class="literal">INNODB_TABLESPACES</code> テーブルにテーブルのテーブルスペースに関する情報をクエリーします。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_TABLESPACES WHERE SPACE = 57 \G</code></strong>
*************************** 1. row ***************************
          SPACE: 57
          NAME: test/t1
          FLAG: 16417
    ROW_FORMAT: Dynamic
     PAGE_SIZE: 16384
 ZIP_PAGE_SIZE: 0
    SPACE_TYPE: Single
 FS_BLOCK_SIZE: 4096
     FILE_SIZE: 114688
ALLOCATED_SIZE: 98304
AUTOEXTEND_SIZE: 0
SERVER_VERSION: 8.0.23
 SPACE_VERSION: 1
    ENCRYPTION: N
         STATE: normal
</pre><p>
            <code class="literal">INNODB_TABLESPACES</code> では、テーブルスペースの <code class="literal">SPACE</code> ID および関連付けられたテーブルの <code class="literal">NAME</code> に加えて、テーブルスペースのフォーマットおよび記憶特性に関するビットレベルの情報であるテーブルスペース <code class="literal">FLAG</code> データが提供されます。 テーブルスペース <code class="literal">ROW_FORMAT</code>、<code class="literal">PAGE_SIZE</code> およびその他のいくつかのテーブルスペースメタデータ項目も用意されています。 
          </p></li><li class="listitem"><p>
            <code class="literal">INNODB_TABLES</code> の <code class="literal">SPACE</code> 情報を再度使用して、<code class="literal">INNODB_DATAFILES</code> にテーブルスペースデータファイルの場所をクエリーします。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_DATAFILES WHERE SPACE = 57 \G</code></strong>
*************************** 1. row ***************************
SPACE: 57
 PATH: ./test/t1.ibd
</pre><p>
            データファイルは、MySQL の <code class="literal">data</code> ディレクトリの下の <code class="literal">test</code> ディレクトリにあります。 <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースが <code class="literal">CREATE TABLE</code> ステートメントの <code class="literal">DATA DIRECTORY</code> 句を使用して MySQL データディレクトリ以外の場所に作成された場合、テーブルスペースの <code class="literal">PATH</code> は完全修飾のディレクトリパスになります。 
          </p></li><li class="listitem"><p>
            最後のステップとして、テーブル <code class="literal">t1</code> (<code class="literal">TABLE_ID = 71</code>) に行を挿入し、<code class="literal">INNODB_TABLESTATS</code> テーブルのデータを表示します。 このテーブル内のデータは、<code class="literal">InnoDB</code> テーブルのクエリー時に使用するインデックスを決定するために MySQL オプティマイザによって使用されます。 この情報は、インメモリーデータ構造から取得されます。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES(5, 'abc', 'def');</code></strong>
Query OK, 1 row affected (0.06 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_TABLESTATS where TABLE_ID = 71 \G</code></strong>
*************************** 1. row ***************************
         TABLE_ID: 71
             NAME: test/t1
STATS_INITIALIZED: Initialized
         NUM_ROWS: 1
 CLUST_INDEX_SIZE: 1
 OTHER_INDEX_SIZE: 0
 MODIFIED_COUNTER: 1
          AUTOINC: 0
        REF_COUNT: 1
</pre><p>
            <code class="literal">STATS_INITIALIZED</code> フィールドは、このテーブルの統計が収集されているかどうかを示します。 <code class="literal">NUM_ROWS</code> は、現在の推定されるテーブル内の行数です。 <code class="literal">CLUST_INDEX_SIZE</code> および <code class="literal">OTHER_INDEX_SIZE</code> フィールドはそれぞれ、テーブルのクラスタ化されたインデックスとセカンダリインデックスを格納するディスク上のページの数をレポートします。 <code class="literal">MODIFIED_COUNTER</code> 値は、外部キーからの DML 操作およびカスケード操作によって変更された行数を示します。 <code class="literal">AUTOINC</code> 値は、自動インクリメントベースの操作に対して発行される次の番号です。 テーブル <code class="literal">t1</code> では自動インクリメントカラムが定義されていないため、この値は 0 です。 <code class="literal">REF_COUNT</code> 値はカウンタです。 このカウンタが 0 に達すると、テーブルキャッシュからテーブルメタデータを削除できることを示します。 
          </p></li></ol></div></div></div><br class="example-break"><div class="example"><a name="innodb-information-schema-fk-system-tables-example"></a><p class="title"><b>例 15.3 外部キー INFORMATION_SCHEMA スキーマオブジェクトテーブル</b></p><div class="example-contents"><p>
        <code class="literal">INNODB_FOREIGN</code> テーブルおよび <code class="literal">INNODB_FOREIGN_COLS</code> テーブルは、外部キー関係に関するデータを提供します。 この例では、外部キー関係を持つ親テーブルと子テーブルを使用して、<code class="literal">INNODB_FOREIGN</code> テーブルと <code class="literal">INNODB_FOREIGN_COLS</code> テーブルで検出されたデータを示します。 
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            テストデータベースおよび親テーブルと子テーブルを作成します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE DATABASE test;</code></strong>

mysql&gt; <strong class="userinput"><code>USE test;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE parent (id INT NOT NULL,</code></strong>
       <strong class="userinput"><code>PRIMARY KEY (id)) ENGINE=INNODB;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE child (id INT, parent_id INT,</code></strong>
       <strong class="userinput"><code>INDEX par_ind (parent_id),</code></strong>
       <strong class="userinput"><code>CONSTRAINT fk1</code></strong>
       <strong class="userinput"><code>FOREIGN KEY (parent_id) REFERENCES parent(id)</code></strong>
       <strong class="userinput"><code>ON DELETE CASCADE) ENGINE=INNODB;</code></strong>
</pre></li><li class="listitem"><p>
            親テーブルと子テーブルが作成されたら、<code class="literal">INNODB_FOREIGN</code> をクエリーして、<code class="literal">test/child</code> と <code class="literal">test/parent</code> の外部キー関係の外部キーデータを見つけます:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_FOREIGN \G</code></strong>
*************************** 1. row ***************************
      ID: test/fk1
FOR_NAME: test/child
REF_NAME: test/parent
  N_COLS: 1
    TYPE: 1
</pre><p>
            メタデータには、子テーブルで定義された <code class="literal">CONSTRAINT</code> として指定されている外部キー <code class="literal">ID</code> (<code class="literal">fk1</code>) が含まれています。 <code class="literal">FOR_NAME</code> は、外部キーが定義されている子テーブルの名前です。 <code class="literal">REF_NAME</code> は、親テーブル (<span class="quote">「<span class="quote">参照される</span>」</span>テーブル) の名前です。 <code class="literal">N_COLS</code> は、外部キーのインデックス内のカラム数です。 <code class="literal">TYPE</code> は、外部キーカラムに関する追加情報を提供するビットフラグを表す数値です。 この場合、<code class="literal">TYPE</code> 値は 1 です。これは、外部キーに対して <code class="literal">ON DELETE CASCADE</code> オプションが指定されたことを示します。 <code class="literal">TYPE</code> 値の詳細は、<code class="literal">INNODB_FOREIGN</code> テーブルの定義を参照してください。 
          </p></li><li class="listitem"><p>
            外部キー <code class="literal">ID</code> を使用して、<code class="literal">INNODB_FOREIGN_COLS</code> をクエリーして、外部キーのカラムに関するデータを表示します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_FOREIGN_COLS WHERE ID = 'test/fk1' \G</code></strong>
*************************** 1. row ***************************
          ID: test/fk1
FOR_COL_NAME: parent_id
REF_COL_NAME: id
         POS: 0
</pre><p>
            <code class="literal">FOR_COL_NAME</code> は子テーブル内の外部キーカラムの名前であり、<code class="literal">REF_COL_NAME</code> は親テーブル内の参照されるカラムの名前です。 <code class="literal">POS</code> 値は、外部キーのインデックス内のキーフィールドの序数位置です (0 から始まります)。 
          </p></li></ol></div></div></div><br class="example-break"><div class="example"><a name="innodb-information-schema-system-tables-join-example"></a><p class="title"><b>例 15.4 InnoDB INFORMATION_SCHEMA スキーマオブジェクトテーブルの結合</b></p><div class="example-contents"><p>
        この例では、employees サンプルデータベースのテーブルに関するファイル形式、行形式、ページサイズおよびインデックスサイズ情報を収集するために、3 つの <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> スキーマオブジェクトテーブル (<code class="literal">INNODB_TABLES</code>、<code class="literal">INNODB_TABLESPACES</code> および <code class="literal">INNODB_TABLESTATS</code>) を結合する方法を示します。
      </p><p>
        クエリー文字列を短くするために、次のテーブル名のエイリアスが使用されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">INFORMATION_SCHEMA.INNODB_TABLES</code>: a
          </p></li><li class="listitem"><p>
            <code class="literal">INFORMATION_SCHEMA.INNODB_TABLESPACES</code>: b
          </p></li><li class="listitem"><p>
            <code class="literal">INFORMATION_SCHEMA.INNODB_TABLESTATS</code>: c
          </p></li></ul></div><p>
        圧縮テーブルに対応するために、<code class="literal">IF()</code> 制御フロー関数が使用されています。 テーブルが圧縮されている場合、インデックスサイズは <code class="literal">PAGE_SIZE</code> ではなく、<code class="literal">ZIP_PAGE_SIZE</code> を使用して計算されます。 バイト単位でレポートされる <code class="literal">CLUST_INDEX_SIZE</code> および <code class="literal">OTHER_INDEX_SIZE</code> を <code class="literal">1024*1024</code> で割ると、M バイト (MB) 単位のインデックスサイズが得られます。 MB 値は、<code class="literal">ROUND()</code> 関数を使用して小数点以下 0 桁に丸められます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT a.NAME, a.ROW_FORMAT,</code></strong>
        <strong class="userinput"><code>@page_size :=</code></strong>
         <strong class="userinput"><code>IF(a.ROW_FORMAT='Compressed',</code></strong>
          <strong class="userinput"><code>b.ZIP_PAGE_SIZE, b.PAGE_SIZE)</code></strong>
          <strong class="userinput"><code>AS page_size,</code></strong>
         <strong class="userinput"><code>ROUND((@page_size * c.CLUST_INDEX_SIZE)</code></strong>
          <strong class="userinput"><code>/(1024*1024)) AS pk_mb,</code></strong>
         <strong class="userinput"><code>ROUND((@page_size * c.OTHER_INDEX_SIZE)</code></strong>
          <strong class="userinput"><code>/(1024*1024)) AS secidx_mb</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.INNODB_TABLES a</code></strong>
       <strong class="userinput"><code>INNER JOIN INFORMATION_SCHEMA.INNODB_TABLESPACES b on a.NAME = b.NAME</code></strong>
       <strong class="userinput"><code>INNER JOIN INFORMATION_SCHEMA.INNODB_TABLESTATS c on b.NAME = c.NAME</code></strong>
       <strong class="userinput"><code>WHERE a.NAME LIKE 'employees/%'</code></strong>
       <strong class="userinput"><code>ORDER BY a.NAME DESC;</code></strong>
+------------------------+------------+-----------+-------+-----------+
| NAME                   | ROW_FORMAT | page_size | pk_mb | secidx_mb |
+------------------------+------------+-----------+-------+-----------+
| employees/titles       | Dynamic    |     16384 |    20 |        11 |
| employees/salaries     | Dynamic    |     16384 |    93 |        34 |
| employees/employees    | Dynamic    |     16384 |    15 |         0 |
| employees/dept_manager | Dynamic    |     16384 |     0 |         0 |
| employees/dept_emp     | Dynamic    |     16384 |    12 |        10 |
| employees/departments  | Dynamic    |     16384 |     0 |         0 |
+------------------------+------------+-----------+-------+-----------+
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-information-schema-fulltext_index-tables"></a>15.15.4 InnoDB INFORMATION_SCHEMA FULLTEXT インデックステーブル</h3></div></div></div><p>
      次のテーブルに、<code class="literal">FULLTEXT</code> インデックスのメタデータを示します:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW TABLES FROM INFORMATION_SCHEMA LIKE 'INNODB_FT%';</code></strong>
+-------------------------------------------+
| Tables_in_INFORMATION_SCHEMA (INNODB_FT%) |
+-------------------------------------------+
| INNODB_FT_CONFIG                          |
| INNODB_FT_BEING_DELETED                   |
| INNODB_FT_DELETED                         |
| INNODB_FT_DEFAULT_STOPWORD                |
| INNODB_FT_INDEX_TABLE                     |
| INNODB_FT_INDEX_CACHE                     |
+-------------------------------------------+
</pre><div class="itemizedlist"><h4><a name="idm44761347264912"></a>テーブルの概要</h4><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">INNODB_FT_CONFIG</code>: <code class="literal">InnoDB</code> テーブルの <code class="literal">FULLTEXT</code> インデックスおよび関連する処理に関するメタデータを提供します。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_FT_BEING_DELETED</code>: <code class="literal">INNODB_FT_DELETED</code> テーブルのスナップショットを提供します。これは、<code class="literal">OPTIMIZE TABLE</code> メンテナンス操作中にのみ使用されます。 <code class="literal">OPTIMIZE TABLE</code> を実行すると、<code class="literal">INNODB_FT_BEING_DELETED</code> テーブルが空になり、<code class="literal">INNODB_FT_DELETED</code> テーブルから <code class="literal">DOC_ID</code> 値が削除されます。 <code class="literal">INNODB_FT_BEING_DELETED</code> の内容は一般に有効期間が短いため、モニタリングやデバッグでのこのテーブルの有用性は限られます。 <code class="literal">FULLTEXT</code> インデックスを持つテーブルでの <code class="literal">OPTIMIZE TABLE</code> の実行の詳細は、<a class="xref" href="functions.html#fulltext-fine-tuning" title="12.10.6 MySQL の全文検索の微調整">セクション12.10.6「MySQL の全文検索の微調整」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_FT_DELETED</code>: <code class="literal">InnoDB</code> テーブルの <code class="literal">FULLTEXT</code> インデックスから削除された行を格納します。 <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> インデックスに対する DML 操作中の高コストのインデックス再編成を回避するために、新しく削除された単語に関する情報は個別に格納され、テキスト検索の実行時に検索結果から除外され、<code class="literal">InnoDB</code> テーブルに対して <code class="literal">OPTIMIZE TABLE</code> ステートメントを発行した場合にのみメイン検索インデックスから削除されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_FT_DEFAULT_STOPWORD</code>: <code class="literal">InnoDB</code> テーブルに <code class="literal">FULLTEXT</code> インデックスを作成するときにデフォルトで使用される <a class="link" href="glossary.html#glos_stopword" title="ストップワード">stopwords</a> のリストを保持します。
        </p><p>
          <code class="literal">INNODB_FT_DEFAULT_STOPWORD</code> テーブルについては、<a class="xref" href="functions.html#fulltext-stopwords" title="12.10.4 全文ストップワード">セクション12.10.4「全文ストップワード」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_FT_INDEX_TABLE</code>: <code class="literal">InnoDB</code> テーブルの <code class="literal">FULLTEXT</code> インデックスに対するテキスト検索の処理に使用される逆インデックスに関する情報を提供します。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_FT_INDEX_CACHE</code>: <code class="literal">FULLTEXT</code> インデックスに新しく挿入された行に関するトークン情報を提供します。 DML 操作中の高コストのインデックス再編成を回避するために、新しくインデックス付けされたワードに関する情報は個別に格納され、<code class="literal">OPTIMIZE TABLE</code> の実行時、サーバーの停止時、またはキャッシュサイズが <code class="literal">innodb_ft_cache_size</code> または <code class="literal">innodb_ft_total_cache_size</code> システム変数で定義された制限を超えた場合にのみメイン検索インデックスと結合されます。 
        </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">INNODB_FT_DEFAULT_STOPWORD</code> テーブルを除き、これらのテーブルは最初は空です。 これらのいずれかをクエリーする前に、<code class="literal">innodb_ft_aux_table</code> システム変数の値を、<code class="literal">FULLTEXT</code> インデックスを含むテーブルの名前 (<code class="literal">test/articles</code> など) に設定します。 
      </p></div><div class="example"><a name="innodb-information-schema-fulltext-tables-example"></a><p class="title"><b>例 15.5 InnoDB FULLTEXT インデックスの INFORMATION_SCHEMA テーブル</b></p><div class="example-contents"><p>
        この例では、<code class="literal">FULLTEXT</code> インデックスを含むテーブルを使用して、<code class="literal">FULLTEXT</code> インデックスの <code class="literal">INFORMATION_SCHEMA</code> テーブルに含まれているデータを示します。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <code class="literal">FULLTEXT</code> インデックスを含むテーブルを作成し、一部のデータを挿入します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE articles (</code></strong>
         <strong class="userinput"><code>id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,</code></strong>
         <strong class="userinput"><code>title VARCHAR(200),</code></strong>
         <strong class="userinput"><code>body TEXT,</code></strong>
         <strong class="userinput"><code>FULLTEXT (title,body)</code></strong>
       <strong class="userinput"><code>) ENGINE=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>INSERT INTO articles (title,body) VALUES</code></strong>
       <strong class="userinput"><code>('MySQL Tutorial','DBMS stands for DataBase ...'),</code></strong>
       <strong class="userinput"><code>('How To Use MySQL Well','After you went through a ...'),</code></strong>
       <strong class="userinput"><code>('Optimizing MySQL','In this tutorial we show ...'),</code></strong>
       <strong class="userinput"><code>('1001 MySQL Tricks','1. Never run mysqld as root. 2. ...'),</code></strong>
       <strong class="userinput"><code>('MySQL vs. YourSQL','In the following database comparison ...'),</code></strong>
       <strong class="userinput"><code>('MySQL Security','When configured properly, MySQL ...');</code></strong>
</pre></li><li class="listitem"><p>
            <code class="literal">innodb_ft_aux_table</code> 変数を <code class="literal">FULLTEXT</code> インデックスを含むテーブルの名前に設定します。 この変数が設定されていない場合、<code class="literal">INNODB_FT_DEFAULT_STOPWORD</code> を除き、<code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> <code class="literal">INFORMATION_SCHEMA</code> テーブルは空です。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_ft_aux_table = 'test/articles';</code></strong>
</pre></li><li class="listitem"><p>
            <code class="literal">INNODB_FT_INDEX_CACHE</code> テーブルをクエリーします。これにより、<code class="literal">FULLTEXT</code> インデックス内の新しく挿入された行に関する情報が示されます。 DML 操作中の高コストのインデックス再編成を回避するために、新しく挿入された行のデータは、<code class="literal">OPTIMIZE TABLE</code> が実行されるまで (またはサーバーが停止するか、キャッシュ制限を超えるまで)、<code class="literal">FULLTEXT</code> インデックスキャッシュに残ります。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_INDEX_CACHE LIMIT 5;</code></strong>
+------------+--------------+-------------+-----------+--------+----------+
| WORD       | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |
+------------+--------------+-------------+-----------+--------+----------+
| 1001       |            5 |           5 |         1 |      5 |        0 |
| after      |            3 |           3 |         1 |      3 |       22 |
| comparison |            6 |           6 |         1 |      6 |       44 |
| configured |            7 |           7 |         1 |      7 |       20 |
| database   |            2 |           6 |         2 |      2 |       31 |
+------------+--------------+-------------+-----------+--------+----------+
</pre></li><li class="listitem"><p>
            <code class="literal">innodb_optimize_fulltext_only</code> システム変数を有効にし、<code class="literal">FULLTEXT</code> インデックスを含むテーブルで <code class="literal">OPTIMIZE TABLE</code> を実行します。 この操作により、<code class="literal">FULLTEXT</code> インデックスキャッシュの内容がメインの <code class="literal">FULLTEXT</code> インデックスにフラッシュされます。<code class="literal">innodb_optimize_fulltext_only</code> は、<code class="literal">InnoDB</code> テーブルでの <code class="literal">OPTIMIZE TABLE</code> ステートメントの動作方法を変更するものであり、<code class="literal">FULLTEXT</code> インデックスを含む <code class="literal">InnoDB</code> テーブルでの保守操作中に一時的に有効にすることを目的にしています。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_optimize_fulltext_only=ON;</code></strong>

mysql&gt; <strong class="userinput"><code>OPTIMIZE TABLE articles;</code></strong>
+---------------+----------+----------+----------+
| Table         | Op       | Msg_type | Msg_text |
+---------------+----------+----------+----------+
| test.articles | optimize | status   | OK       |
+---------------+----------+----------+----------+
</pre></li><li class="listitem"><p>
            <code class="literal">INNODB_FT_INDEX_TABLE</code> テーブルにクエリーして、メインの <code class="literal">FULLTEXT</code> インデックス内のデータに関する情報 (<code class="literal">FULLTEXT</code> インデックスキャッシュからフラッシュされたばかりのデータに関する情報を含む) を表示します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_INDEX_TABLE LIMIT 5;</code></strong>
+------------+--------------+-------------+-----------+--------+----------+
| WORD       | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |
+------------+--------------+-------------+-----------+--------+----------+
| 1001       |            5 |           5 |         1 |      5 |        0 |
| after      |            3 |           3 |         1 |      3 |       22 |
| comparison |            6 |           6 |         1 |      6 |       44 |
| configured |            7 |           7 |         1 |      7 |       20 |
| database   |            2 |           6 |         2 |      2 |       31 |
+------------+--------------+-------------+-----------+--------+----------+
</pre><p>
            <code class="literal">OPTIMIZE TABLE</code> 操作によって <code class="literal">FULLTEXT</code> インデックスキャッシュがフラッシュされたため、<code class="literal">INNODB_FT_INDEX_CACHE</code> テーブルは空になっています。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_INDEX_CACHE LIMIT 5;</code></strong>
Empty set (0.00 sec)
</pre></li><li class="listitem"><p>
            <code class="literal">test/articles</code> テーブルからいくつかのレコードを削除します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>DELETE FROM test.articles WHERE id &lt; 4;</code></strong>
</pre></li><li class="listitem"><p>
            <code class="literal">INNODB_FT_DELETED</code> テーブルをクエリーします。 このテーブルには、<code class="literal">FULLTEXT</code> インデックスから削除された行が記録されます。 DML 操作中にコストの高いインデックス再編成が行われないようにするために、新しく削除されたレコードに関する情報は個別に格納され、テキスト検索を実行すると検索結果からフィルタで除外され、<code class="literal">OPTIMIZE TABLE</code> を実行するとメインの検索インデックスから削除されます。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_DELETED;</code></strong>
+--------+
| DOC_ID |
+--------+
|      2 |
|      3 |
|      4 |
+--------+
</pre></li><li class="listitem"><p>
            <code class="literal">OPTIMIZE TABLE</code> を実行して、削除されたレコードを消去します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>OPTIMIZE TABLE articles;</code></strong>
+---------------+----------+----------+----------+
| Table         | Op       | Msg_type | Msg_text |
+---------------+----------+----------+----------+
| test.articles | optimize | status   | OK       |
+---------------+----------+----------+----------+
</pre><p>
            これで、<code class="literal">INNODB_FT_DELETED</code> テーブルは空になります。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_DELETED;</code></strong>
Empty set (0.00 sec)
</pre></li><li class="listitem"><p>
            <code class="literal">INNODB_FT_CONFIG</code> テーブルをクエリーします。 このテーブルには、<code class="literal">FULLTEXT</code> インデックスに関するメタデータとそれに関連する処理が含まれています。 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">optimize_checkpoint_limit</code>: <code class="literal">OPTIMIZE TABLE</code> の実行が停止するまでの秒数。
              </p></li><li class="listitem"><p>
                <code class="literal">synced_doc_id</code>: 次に発行される <code class="literal">DOC_ID</code> です。
              </p></li><li class="listitem"><p>
                <code class="literal">stopword_table_name</code>: ユーザー定義のストップワードテーブルの <em class="replaceable"><code>database/table</code></em> 名。 ユーザー定義のストップワードテーブルがない場合、<code class="literal">VALUE</code> カラムは空です。 
              </p></li><li class="listitem"><p>
                <code class="literal">use_stopword</code>: <code class="literal">FULLTEXT</code> インデックスの作成時に定義されるストップワードテーブルを使用するかどうかを示します。
              </p></li></ul></div><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_CONFIG;</code></strong>
+---------------------------+-------+
| KEY                       | VALUE |
+---------------------------+-------+
| optimize_checkpoint_limit | 180   |
| synced_doc_id             | 8     |
| stopword_table_name       |       |
| use_stopword              | 1     |
+---------------------------+-------+
</pre></li><li class="listitem"><p>
            <code class="literal">innodb_optimize_fulltext_only</code> は一時的にのみ有効にすることを意図しているため、無効にします:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_optimize_fulltext_only=OFF;</code></strong>
</pre></li></ol></div></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-information-schema-buffer-pool-tables"></a>15.15.5 InnoDB INFORMATION_SCHEMA バッファープールテーブル</h3></div></div></div><p>
      <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> バッファープールテーブルは、バッファープールのステータス情報、および <code class="literal">InnoDB</code> バッファープール内のページに関するメタデータを提供します。
    </p><p>
      <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> バッファープールテーブルには、下に一覧表示されているものが含まれます。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW TABLES FROM INFORMATION_SCHEMA LIKE 'INNODB_BUFFER%';</code></strong>
+-----------------------------------------------+
| Tables_in_INFORMATION_SCHEMA (INNODB_BUFFER%) |
+-----------------------------------------------+
| INNODB_BUFFER_PAGE_LRU                        |
| INNODB_BUFFER_PAGE                            |
| INNODB_BUFFER_POOL_STATS                      |
+-----------------------------------------------+
</pre><h4><a name="idm44761347121504"></a>テーブルの概要</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">INNODB_BUFFER_PAGE</code>: <code class="literal">InnoDB</code> バッファープール内の各ページに関する情報を保持します。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_BUFFER_PAGE_LRU</code>: <code class="literal">InnoDB</code> バッファープール内のページに関する情報、特に、いっぱいになったときにバッファープールからどのページを削除するかを決定する LRU リスト内の各ページの順序を保持します。 <code class="literal">INNODB_BUFFER_PAGE_LRU</code> テーブルには、<code class="literal">INNODB_BUFFER_PAGE</code> テーブルと同じカラムがありますが、<code class="literal">INNODB_BUFFER_PAGE_LRU</code> テーブルには <code class="literal">BLOCK_ID</code> カラムではなく <code class="literal">LRU_POSITION</code> カラムがある点が異なります。 
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_BUFFER_POOL_STATS</code>: バッファープールのステータス情報を提供します。 同じ情報のほとんどは、<code class="literal">SHOW ENGINE INNODB STATUS</code> の出力で提供されるか、または <code class="literal">InnoDB</code> バッファープールのサーバーステータス変数を使用して取得できます。 
        </p></li></ul></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
        <code class="literal">INNODB_BUFFER_PAGE</code> または <code class="literal">INNODB_BUFFER_PAGE_LRU</code> テーブルをクエリーすると、パフォーマンスに影響する可能性があります。 パフォーマンスへの影響を認識し、許容できると判断した場合を除き、本番システムでこれらのテーブルをクエリーしないでください。 本番システムのパフォーマンスへの影響を回避するには、調査する問題を再現し、テストインスタンスのバッファプール統計をクエリーします。 
      </p></div><div class="example"><a name="innodb-information-schema-buffer-pool-system-data-example"></a><p class="title"><b>例 15.6 INNODB_BUFFER_PAGE テーブル内のシステムデータのクエリー</b></p><div class="example-contents"><p>
        このクエリーでは、<code class="literal">TABLE_NAME</code> 値が <code class="literal">NULL</code> であるページ、またはユーザー定義テーブルを示すスラッシュ<code class="literal">/</code>またはピリオド <code class="literal">.</code> がテーブル名に含まれるページを除外することで、システムデータを含むページの概算数が提供されます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></strong>
       <strong class="userinput"><code>WHERE TABLE_NAME IS NULL OR (INSTR(TABLE_NAME, '/') = 0 AND INSTR(TABLE_NAME, '.') = 0);</code></strong>
+----------+
| COUNT(*) |
+----------+
|     1516 |
+----------+
</pre><p>
        このクエリーは、システムデータを含むページの概数、バッファープールページの総数、およびシステムデータを含むページの概略の割合 (%) を返します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT</code></strong>
       <strong class="userinput"><code>(SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></strong>
       <strong class="userinput"><code>WHERE TABLE_NAME IS NULL OR (INSTR(TABLE_NAME, '/') = 0 AND INSTR(TABLE_NAME, '.') = 0)</code></strong>
       <strong class="userinput"><code>) AS system_pages,</code></strong>
       <strong class="userinput"><code>(</code></strong>
       <strong class="userinput"><code>SELECT COUNT(*)</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></strong>
       <strong class="userinput"><code>) AS total_pages,</code></strong>
       <strong class="userinput"><code>(</code></strong>
       <strong class="userinput"><code>SELECT ROUND((system_pages/total_pages) * 100)</code></strong>
       <strong class="userinput"><code>) AS system_page_percentage;</code></strong>
+--------------+-------------+------------------------+
| system_pages | total_pages | system_page_percentage |
+--------------+-------------+------------------------+
|          295 |        8192 |                      4 |
+--------------+-------------+------------------------+
</pre><p>
        バッファープール内のシステムデータのタイプは、<code class="literal">PAGE_TYPE</code> 値をクエリーすることによって確認できます。 たとえば、次のクエリーは、システムデータを含むページ間の 8 つの個別の <code class="literal">PAGE_TYPE</code> 値を返します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT DISTINCT PAGE_TYPE FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></strong>
       <strong class="userinput"><code>WHERE TABLE_NAME IS NULL OR (INSTR(TABLE_NAME, '/') = 0 AND INSTR(TABLE_NAME, '.') = 0);</code></strong>
+-------------------+
| PAGE_TYPE         |
+-------------------+
| SYSTEM            |
| IBUF_BITMAP       |
| UNKNOWN           |
| FILE_SPACE_HEADER |
| INODE             |
| UNDO_LOG          |
| ALLOCATED         |
+-------------------+
</pre></div></div><br class="example-break"><div class="example"><a name="innodb-information-schema-buffer-pool-user-data-example"></a><p class="title"><b>例 15.7 INNODB_BUFFER_PAGE テーブル内のユーザーデータのクエリー</b></p><div class="example-contents"><p>
        このクエリーでは、<code class="literal">TABLE_NAME</code> 値が <code class="literal">NOT NULL</code> および <code class="literal">NOT LIKE '%INNODB_TABLES%'</code>であるページをカウントすることで、ユーザーデータを含むページの概算数が提供されます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></strong>
       <strong class="userinput"><code>WHERE TABLE_NAME IS NOT NULL AND TABLE_NAME NOT LIKE '%INNODB_TABLES%';</code></strong>
+----------+
| COUNT(*) |
+----------+
|     7897 |
+----------+
</pre><p>
        このクエリーは、ユーザーデータを含むページの概数、バッファープールページの総数、およびユーザーデータを含むページの概略の割合 (%) を返します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT</code></strong>
       <strong class="userinput"><code>(SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></strong>
       WHERE TABLE_NAME IS NOT NULL AND (INSTR(TABLE_NAME, '/') &gt; 0 OR INSTR(TABLE_NAME, '.') &gt; 0)
       <strong class="userinput"><code>) AS user_pages,</code></strong>
       <strong class="userinput"><code>(</code></strong>
       <strong class="userinput"><code>SELECT COUNT(*)</code></strong>
       <strong class="userinput"><code>FROM information_schema.INNODB_BUFFER_PAGE</code></strong>
       <strong class="userinput"><code>) AS total_pages,</code></strong>
       <strong class="userinput"><code>(</code></strong>
       <strong class="userinput"><code>SELECT ROUND((user_pages/total_pages) * 100)</code></strong>
       <strong class="userinput"><code>) AS user_page_percentage;</code></strong>
+------------+-------------+----------------------+
| user_pages | total_pages | user_page_percentage |
+------------+-------------+----------------------+
|       7897 |        8192 |                   96 |
+------------+-------------+----------------------+
</pre><p>
        このクエリーは、バッファープール内のページを含むユーザー定義のテーブルを識別します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT DISTINCT TABLE_NAME FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></strong>
       <strong class="userinput"><code>WHERE TABLE_NAME IS NOT NULL AND (INSTR(TABLE_NAME, '/') &gt; 0 OR INSTR(TABLE_NAME, '.') &gt; 0)</code></strong>
       <strong class="userinput"><code>AND TABLE_NAME NOT LIKE '`mysql`.`innodb_%';</code></strong>
+-------------------------+
| TABLE_NAME              |
+-------------------------+
| `employees`.`salaries`  |
| `employees`.`employees` |
+-------------------------+
</pre></div></div><br class="example-break"><div class="example"><a name="innodb-information-schema-buffer-pool-index-data-example"></a><p class="title"><b>例 15.8 INNODB_BUFFER_PAGE テーブル内のインデックスデータのクエリー</b></p><div class="example-contents"><p>
        インデックスページに関する情報を取得するには、そのインデックスの名前を使用して <code class="literal">INDEX_NAME</code> カラムをクエリーします。 たとえば、次のクエリーは、<code class="literal">employees.salaries</code> テーブルで定義されている <code class="literal">emp_no</code> インデックスのページの数とページの合計データサイズを返します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT INDEX_NAME, COUNT(*) AS Pages,</code></strong>
<strong class="userinput"><code>ROUND(SUM(IF(COMPRESSED_SIZE = 0, @@GLOBAL.innodb_page_size, COMPRESSED_SIZE))/1024/1024)</code></strong>
<strong class="userinput"><code>AS 'Total Data (MB)'</code></strong>
<strong class="userinput"><code>FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></strong>
<strong class="userinput"><code>WHERE INDEX_NAME='emp_no' AND TABLE_NAME = '`employees`.`salaries`';</code></strong>
+------------+-------+-----------------+
| INDEX_NAME | Pages | Total Data (MB) |
+------------+-------+-----------------+
| emp_no     |  1609 |              25 |
+------------+-------+-----------------+
</pre><p>
        このクエリーは、<code class="literal">employees.salaries</code> テーブルで定義されているすべてのインデックスのページの数とページの合計データサイズを返します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT INDEX_NAME, COUNT(*) AS Pages,</code></strong>
       <strong class="userinput"><code>ROUND(SUM(IF(COMPRESSED_SIZE = 0, @@GLOBAL.innodb_page_size, COMPRESSED_SIZE))/1024/1024)</code></strong>
       <strong class="userinput"><code>AS 'Total Data (MB)'</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></strong>
       <strong class="userinput"><code>WHERE TABLE_NAME = '`employees`.`salaries`'</code></strong>
       <strong class="userinput"><code>GROUP BY INDEX_NAME;</code></strong>
+------------+-------+-----------------+
| INDEX_NAME | Pages | Total Data (MB) |
+------------+-------+-----------------+
| emp_no     |  1608 |              25 |
| PRIMARY    |  6086 |              95 |
+------------+-------+-----------------+
</pre></div></div><br class="example-break"><div class="example"><a name="innodb-information-schema-buffer-pool-lru-position-example"></a><p class="title"><b>例 15.9 INNODB_BUFFER_PAGE_LRU テーブル内の LRU_POSITION データのクエリー</b></p><div class="example-contents"><p>
        <code class="literal">INNODB_BUFFER_PAGE_LRU</code> テーブルは、<code class="literal">InnoDB</code> バッファープール内のページに関する情報、特に、いっぱいになったときにバッファープールからどのページを削除するかを決定する各ページの順序を保持しています。 このページの定義は、このテーブルには <code class="literal">BLOCK_ID</code> カラムの代わりに <code class="literal">LRU_POSITION</code> カラムがある点を除き、<code class="literal">INNODB_BUFFER_PAGE</code> の場合と同じです。 
      </p><p>
        このクエリーは、<code class="literal">employees.employees</code> テーブルの各ページによって占有されている LRU リスト内の特定の場所にある位置の数をカウントします。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT COUNT(LRU_POSITION) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE_LRU</code></strong>
       <strong class="userinput"><code>WHERE TABLE_NAME='`employees`.`employees`' AND LRU_POSITION &lt; 3072;</code></strong>
+---------------------+
| COUNT(LRU_POSITION) |
+---------------------+
|                 548 |
+---------------------+
</pre></div></div><br class="example-break"><div class="example"><a name="innodb-information-schema-buffer-pool-stats-example"></a><p class="title"><b>例 15.10 INNODB_BUFFER_POOL_STATS テーブルのクエリー</b></p><div class="example-contents"><p>
        <code class="literal">INNODB_BUFFER_POOL_STATS</code> テーブルは、<code class="literal">SHOW ENGINE INNODB STATUS</code> および <code class="literal">InnoDB</code> バッファープールのステータス変数と同様の情報を提供します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM information_schema.INNODB_BUFFER_POOL_STATS \G</code></strong>
*************************** 1. row ***************************
                         POOL_ID: 0
                       POOL_SIZE: 8192
                    FREE_BUFFERS: 1
                  DATABASE_PAGES: 8173
              OLD_DATABASE_PAGES: 3014
         MODIFIED_DATABASE_PAGES: 0
              PENDING_DECOMPRESS: 0
                   PENDING_READS: 0
               PENDING_FLUSH_LRU: 0
              PENDING_FLUSH_LIST: 0
                PAGES_MADE_YOUNG: 15907
            PAGES_NOT_MADE_YOUNG: 3803101
           PAGES_MADE_YOUNG_RATE: 0
       PAGES_MADE_NOT_YOUNG_RATE: 0
               NUMBER_PAGES_READ: 3270
            NUMBER_PAGES_CREATED: 13176
            NUMBER_PAGES_WRITTEN: 15109
                 PAGES_READ_RATE: 0
               PAGES_CREATE_RATE: 0
              PAGES_WRITTEN_RATE: 0
                NUMBER_PAGES_GET: 33069332
                        HIT_RATE: 0
    YOUNG_MAKE_PER_THOUSAND_GETS: 0
NOT_YOUNG_MAKE_PER_THOUSAND_GETS: 0
         NUMBER_PAGES_READ_AHEAD: 2713
       NUMBER_READ_AHEAD_EVICTED: 0
                 READ_AHEAD_RATE: 0
         READ_AHEAD_EVICTED_RATE: 0
                    LRU_IO_TOTAL: 0
                  LRU_IO_CURRENT: 0
                UNCOMPRESS_TOTAL: 0
              UNCOMPRESS_CURRENT: 0
</pre><p>
        比較のために、同じデータセットに基づいた <code class="literal">SHOW ENGINE INNODB STATUS</code> の出力および <code class="literal">InnoDB</code> バッファープールのステータス変数の出力を次に示します。
      </p><p>
        <code class="literal">SHOW ENGINE INNODB STATUS</code> の出力の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-standard-monitor" title="15.17.3 InnoDB 標準モニターおよびロックモニターの出力">セクション15.17.3「InnoDB 標準モニターおよびロックモニターの出力」</a>を参照してください。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW ENGINE INNODB STATUS \G</code></strong>
...
----------------------
BUFFER POOL AND MEMORY
----------------------
Total large memory allocated 137428992
Dictionary memory allocated 579084
Buffer pool size   8192
Free buffers       1
Database pages     8173
Old database pages 3014
Modified db pages  0
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 15907, not young 3803101
0.00 youngs/s, 0.00 non-youngs/s
Pages read 3270, created 13176, written 15109
0.00 reads/s, 0.00 creates/s, 0.00 writes/s
No buffer pool page gets since the last printout
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 8173, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
...
</pre><p>
        ステータス変数の説明については、<a class="xref" href="server-administration.html#server-status-variables" title="5.1.10 サーバーステータス変数">セクション5.1.10「サーバーステータス変数」</a>を参照してください。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'Innodb_buffer%';</code></strong>
+---------------------------------------+-------------+
| Variable_name                         | Value       |
+---------------------------------------+-------------+
| Innodb_buffer_pool_dump_status        | not started |
| Innodb_buffer_pool_load_status        | not started |
| Innodb_buffer_pool_resize_status      | not started |
| Innodb_buffer_pool_pages_data         | 8173        |
| Innodb_buffer_pool_bytes_data         | 133906432   |
| Innodb_buffer_pool_pages_dirty        | 0           |
| Innodb_buffer_pool_bytes_dirty        | 0           |
| Innodb_buffer_pool_pages_flushed      | 15109       |
| Innodb_buffer_pool_pages_free         | 1           |
| Innodb_buffer_pool_pages_misc         | 18          |
| Innodb_buffer_pool_pages_total        | 8192        |
| Innodb_buffer_pool_read_ahead_rnd     | 0           |
| Innodb_buffer_pool_read_ahead         | 2713        |
| Innodb_buffer_pool_read_ahead_evicted | 0           |
| Innodb_buffer_pool_read_requests      | 33069332    |
| Innodb_buffer_pool_reads              | 558         |
| Innodb_buffer_pool_wait_free          | 0           |
| Innodb_buffer_pool_write_requests     | 11985961    |
+---------------------------------------+-------------+
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-information-schema-metrics-table"></a>15.15.6 InnoDB INFORMATION_SCHEMA メトリックテーブル</h3></div></div></div><p>
      <code class="literal">INNODB_METRICS</code> のテーブルには、<code class="literal">InnoDB</code> のパフォーマンスおよびリソース関連のカウンタに関する情報が表示されます。
    </p><p>
      <code class="literal">INNODB_METRICS</code> テーブルのカラムを次に示します。 カラムの説明は、<a class="xref" href="information-schema.html#information-schema-innodb-metrics-table" title="26.51.22 INFORMATION_SCHEMA INNODB_METRICS テーブル">セクション26.51.22「INFORMATION_SCHEMA INNODB_METRICS テーブル」</a> を参照してください。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME="dml_inserts" \G</code></strong>
*************************** 1. row ***************************
           NAME: dml_inserts
      SUBSYSTEM: dml
          COUNT: 46273
      MAX_COUNT: 46273
      MIN_COUNT: NULL
      AVG_COUNT: 492.2659574468085
    COUNT_RESET: 46273
MAX_COUNT_RESET: 46273
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: NULL
   TIME_ENABLED: 2014-11-28 16:07:53
  TIME_DISABLED: NULL
   TIME_ELAPSED: 94
     TIME_RESET: NULL
         STATUS: enabled
           TYPE: status_counter
        COMMENT: Number of rows inserted
</pre><h4><a name="idm44761347005120"></a>カウンタの有効化、無効化、およびリセット</h4><p>
      次の変数を使用して、カウンタを有効化、無効化およびリセットできます:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">innodb_monitor_enable</code>: カウンタを有効にします。
        </p><pre class="programlisting">SET GLOBAL innodb_monitor_enable = [counter-name|module_name|pattern|all];
</pre></li><li class="listitem"><p>
          <code class="literal">innodb_monitor_disable</code>: カウンタを無効にします。
        </p><pre class="programlisting">SET GLOBAL innodb_monitor_disable = [counter-name|module_name|pattern|all];
</pre></li><li class="listitem"><p>
          <code class="literal">innodb_monitor_reset</code>: カウンタ値をゼロにリセットします。
        </p><pre class="programlisting">SET GLOBAL innodb_monitor_reset = [counter-name|module_name|pattern|all];
</pre></li><li class="listitem"><p>
          <code class="literal">innodb_monitor_reset_all</code>: すべてのカウンタ値をリセットします。 <code class="literal">innodb_monitor_reset_all</code> を使用する前にカウンタを無効にする必要があります。 
        </p><pre class="programlisting">SET GLOBAL innodb_monitor_reset_all = [counter-name|module_name|pattern|all];
</pre></li></ul></div><p>
      カウンタおよびカウンタモジュールは、起動時に MySQL サーバー構成ファイルを使用して有効にすることもできます。 たとえば、<code class="literal">log</code> モジュール、<code class="literal">metadata_table_handles_opened</code> および <code class="literal">metadata_table_handles_closed</code> カウンタを有効にするには、MySQL サーバー構成ファイルの<code class="literal">[mysqld]</code>セクションに次の行を入力します。 
    </p><pre class="programlisting">[mysqld]
innodb_monitor_enable = module_recovery,metadata_table_handles_opened,metadata_table_handles_closed
</pre><p>
      構成ファイルで複数のカウンタまたはモジュールを有効にする場合は、前述のように、<code class="literal">innodb_monitor_enable</code> 変数の後にカウンタ名とモジュール名をカンマで区切って指定します。 構成ファイルで使用できるのは <code class="literal">innodb_monitor_enable</code> 変数のみです。 <code class="literal">innodb_monitor_disable</code> および <code class="literal">innodb_monitor_reset</code> 変数は、コマンドラインでのみサポートされています。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        各カウンタはランタイムオーバーヘッドの程度を追加するため、本番サーバーでカウンタを保守的に使用して、特定の問題を診断したり、特定の機能を監視します。 カウンタをより広範囲に使用するには、テストサーバーまたは開発サーバーをお薦めします。 
      </p></div><h4><a name="idm44761346979472"></a>カウンタ</h4><p>
      使用可能なカウンタのリストは変更される可能性があります。 使用している MySQL サーバーバージョンで使用可能なカウンタを <code class="literal">INFORMATION_SCHEMA.INNODB_METRICS</code> テーブルにクエリーします。 
    </p><p>
      デフォルトで有効になっているカウンタは、<code class="literal">SHOW ENGINE INNODB STATUS</code> 出力に表示されるカウンタに対応しています。 <code class="literal">SHOW ENGINE INNODB STATUS</code> 出力に表示されるカウンタは、常にシステムレベルで有効になりますが、<code class="literal">INNODB_METRICS</code> テーブルでは無効にできます。 カウンタステータスは永続的ではありません。 特に構成されていないかぎり、カウンタはサーバーの再起動時にデフォルトの有効または無効ステータスに戻ります。 
    </p><p>
      カウンタの追加または削除の影響を受けるプログラムを実行する場合は、リリースノートを確認し、<code class="literal">INNODB_METRICS</code> テーブルをクエリーして、それらの変更をアップグレードプロセスの一部として識別することをお薦めします。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT name, subsystem, status FROM INFORMATION_SCHEMA.INNODB_METRICS ORDER BY NAME;</code></strong>
+------------------------------------------+---------------------+----------+
| name                                     | subsystem           | status   |
+------------------------------------------+---------------------+----------+
| adaptive_hash_pages_added                | adaptive_hash_index | disabled |
| adaptive_hash_pages_removed              | adaptive_hash_index | disabled |
| adaptive_hash_rows_added                 | adaptive_hash_index | disabled |
| adaptive_hash_rows_deleted_no_hash_entry | adaptive_hash_index | disabled |
| adaptive_hash_rows_removed               | adaptive_hash_index | disabled |
| adaptive_hash_rows_updated               | adaptive_hash_index | disabled |
| adaptive_hash_searches                   | adaptive_hash_index | enabled  |
| adaptive_hash_searches_btree             | adaptive_hash_index | enabled  |
| buffer_data_reads                        | buffer              | enabled  |
| buffer_data_written                      | buffer              | enabled  |
| buffer_flush_adaptive                    | buffer              | disabled |
| buffer_flush_adaptive_avg_pass           | buffer              | disabled |
| buffer_flush_adaptive_avg_time_est       | buffer              | disabled |
| buffer_flush_adaptive_avg_time_slot      | buffer              | disabled |
| buffer_flush_adaptive_avg_time_thread    | buffer              | disabled |
| buffer_flush_adaptive_pages              | buffer              | disabled |
| buffer_flush_adaptive_total_pages        | buffer              | disabled |
| buffer_flush_avg_page_rate               | buffer              | disabled |
| buffer_flush_avg_pass                    | buffer              | disabled |
| buffer_flush_avg_time                    | buffer              | disabled |
| buffer_flush_background                  | buffer              | disabled |
| buffer_flush_background_pages            | buffer              | disabled |
| buffer_flush_background_total_pages      | buffer              | disabled |
| buffer_flush_batches                     | buffer              | disabled |
| buffer_flush_batch_num_scan              | buffer              | disabled |
| buffer_flush_batch_pages                 | buffer              | disabled |
| buffer_flush_batch_scanned               | buffer              | disabled |
| buffer_flush_batch_scanned_per_call      | buffer              | disabled |
| buffer_flush_batch_total_pages           | buffer              | disabled |
| buffer_flush_lsn_avg_rate                | buffer              | disabled |
| buffer_flush_neighbor                    | buffer              | disabled |
| buffer_flush_neighbor_pages              | buffer              | disabled |
| buffer_flush_neighbor_total_pages        | buffer              | disabled |
| buffer_flush_n_to_flush_by_age           | buffer              | disabled |
| buffer_flush_n_to_flush_requested        | buffer              | disabled |
| buffer_flush_pct_for_dirty               | buffer              | disabled |
| buffer_flush_pct_for_lsn                 | buffer              | disabled |
| buffer_flush_sync                        | buffer              | disabled |
| buffer_flush_sync_pages                  | buffer              | disabled |
| buffer_flush_sync_total_pages            | buffer              | disabled |
| buffer_flush_sync_waits                  | buffer              | disabled |
| buffer_LRU_batches_evict                 | buffer              | disabled |
| buffer_LRU_batches_flush                 | buffer              | disabled |
| buffer_LRU_batch_evict_pages             | buffer              | disabled |
| buffer_LRU_batch_evict_total_pages       | buffer              | disabled |
| buffer_LRU_batch_flush_avg_pass          | buffer              | disabled |
| buffer_LRU_batch_flush_avg_time_est      | buffer              | disabled |
| buffer_LRU_batch_flush_avg_time_slot     | buffer              | disabled |
| buffer_LRU_batch_flush_avg_time_thread   | buffer              | disabled |
| buffer_LRU_batch_flush_pages             | buffer              | disabled |
| buffer_LRU_batch_flush_total_pages       | buffer              | disabled |
| buffer_LRU_batch_num_scan                | buffer              | disabled |
| buffer_LRU_batch_scanned                 | buffer              | disabled |
| buffer_LRU_batch_scanned_per_call        | buffer              | disabled |
| buffer_LRU_get_free_loops                | buffer              | disabled |
| buffer_LRU_get_free_search               | Buffer              | disabled |
| buffer_LRU_get_free_waits                | buffer              | disabled |
| buffer_LRU_search_num_scan               | buffer              | disabled |
| buffer_LRU_search_scanned                | buffer              | disabled |
| buffer_LRU_search_scanned_per_call       | buffer              | disabled |
| buffer_LRU_single_flush_failure_count    | Buffer              | disabled |
| buffer_LRU_single_flush_num_scan         | buffer              | disabled |
| buffer_LRU_single_flush_scanned          | buffer              | disabled |
| buffer_LRU_single_flush_scanned_per_call | buffer              | disabled |
| buffer_LRU_unzip_search_num_scan         | buffer              | disabled |
| buffer_LRU_unzip_search_scanned          | buffer              | disabled |
| buffer_LRU_unzip_search_scanned_per_call | buffer              | disabled |
| buffer_pages_created                     | buffer              | enabled  |
| buffer_pages_read                        | buffer              | enabled  |
| buffer_pages_written                     | buffer              | enabled  |
| buffer_page_read_blob                    | buffer_page_io      | disabled |
| buffer_page_read_fsp_hdr                 | buffer_page_io      | disabled |
| buffer_page_read_ibuf_bitmap             | buffer_page_io      | disabled |
| buffer_page_read_ibuf_free_list          | buffer_page_io      | disabled |
| buffer_page_read_index_ibuf_leaf         | buffer_page_io      | disabled |
| buffer_page_read_index_ibuf_non_leaf     | buffer_page_io      | disabled |
| buffer_page_read_index_inode             | buffer_page_io      | disabled |
| buffer_page_read_index_leaf              | buffer_page_io      | disabled |
| buffer_page_read_index_non_leaf          | buffer_page_io      | disabled |
| buffer_page_read_other                   | buffer_page_io      | disabled |
| buffer_page_read_system_page             | buffer_page_io      | disabled |
| buffer_page_read_trx_system              | buffer_page_io      | disabled |
| buffer_page_read_undo_log                | buffer_page_io      | disabled |
| buffer_page_read_xdes                    | buffer_page_io      | disabled |
| buffer_page_read_zblob                   | buffer_page_io      | disabled |
| buffer_page_read_zblob2                  | buffer_page_io      | disabled |
| buffer_page_written_blob                 | buffer_page_io      | disabled |
| buffer_page_written_fsp_hdr              | buffer_page_io      | disabled |
| buffer_page_written_ibuf_bitmap          | buffer_page_io      | disabled |
| buffer_page_written_ibuf_free_list       | buffer_page_io      | disabled |
| buffer_page_written_index_ibuf_leaf      | buffer_page_io      | disabled |
| buffer_page_written_index_ibuf_non_leaf  | buffer_page_io      | disabled |
| buffer_page_written_index_inode          | buffer_page_io      | disabled |
| buffer_page_written_index_leaf           | buffer_page_io      | disabled |
| buffer_page_written_index_non_leaf       | buffer_page_io      | disabled |
| buffer_page_written_other                | buffer_page_io      | disabled |
| buffer_page_written_system_page          | buffer_page_io      | disabled |
| buffer_page_written_trx_system           | buffer_page_io      | disabled |
| buffer_page_written_undo_log             | buffer_page_io      | disabled |
| buffer_page_written_xdes                 | buffer_page_io      | disabled |
| buffer_page_written_zblob                | buffer_page_io      | disabled |
| buffer_page_written_zblob2               | buffer_page_io      | disabled |
| buffer_pool_bytes_data                   | buffer              | enabled  |
| buffer_pool_bytes_dirty                  | buffer              | enabled  |
| buffer_pool_pages_data                   | buffer              | enabled  |
| buffer_pool_pages_dirty                  | buffer              | enabled  |
| buffer_pool_pages_free                   | buffer              | enabled  |
| buffer_pool_pages_misc                   | buffer              | enabled  |
| buffer_pool_pages_total                  | buffer              | enabled  |
| buffer_pool_reads                        | buffer              | enabled  |
| buffer_pool_read_ahead                   | buffer              | enabled  |
| buffer_pool_read_ahead_evicted           | buffer              | enabled  |
| buffer_pool_read_requests                | buffer              | enabled  |
| buffer_pool_size                         | server              | enabled  |
| buffer_pool_wait_free                    | buffer              | enabled  |
| buffer_pool_write_requests               | buffer              | enabled  |
| compression_pad_decrements               | compression         | disabled |
| compression_pad_increments               | compression         | disabled |
| compress_pages_compressed                | compression         | disabled |
| compress_pages_decompressed              | compression         | disabled |
| ddl_background_drop_indexes              | ddl                 | disabled |
| ddl_background_drop_tables               | ddl                 | disabled |
| ddl_log_file_alter_table                 | ddl                 | disabled |
| ddl_online_create_index                  | ddl                 | disabled |
| ddl_pending_alter_table                  | ddl                 | disabled |
| ddl_sort_file_alter_table                | ddl                 | disabled |
| dml_deletes                              | dml                 | enabled  |
| dml_inserts                              | dml                 | enabled  |
| dml_reads                                | dml                 | disabled |
| dml_updates                              | dml                 | enabled  |
| file_num_open_files                      | file_system         | enabled  |
| ibuf_merges                              | change_buffer       | enabled  |
| ibuf_merges_delete                       | change_buffer       | enabled  |
| ibuf_merges_delete_mark                  | change_buffer       | enabled  |
| ibuf_merges_discard_delete               | change_buffer       | enabled  |
| ibuf_merges_discard_delete_mark          | change_buffer       | enabled  |
| ibuf_merges_discard_insert               | change_buffer       | enabled  |
| ibuf_merges_insert                       | change_buffer       | enabled  |
| ibuf_size                                | change_buffer       | enabled  |
| icp_attempts                             | icp                 | disabled |
| icp_match                                | icp                 | disabled |
| icp_no_match                             | icp                 | disabled |
| icp_out_of_range                         | icp                 | disabled |
| index_page_discards                      | index               | disabled |
| index_page_merge_attempts                | index               | disabled |
| index_page_merge_successful              | index               | disabled |
| index_page_reorg_attempts                | index               | disabled |
| index_page_reorg_successful              | index               | disabled |
| index_page_splits                        | index               | disabled |
| innodb_activity_count                    | server              | enabled  |
| innodb_background_drop_table_usec        | server              | disabled |
| innodb_checkpoint_usec                   | server              | disabled |
| innodb_dblwr_pages_written               | server              | enabled  |
| innodb_dblwr_writes                      | server              | enabled  |
| innodb_dict_lru_count                    | server              | disabled |
| innodb_dict_lru_usec                     | server              | disabled |
| innodb_ibuf_merge_usec                   | server              | disabled |
| innodb_log_flush_usec                    | server              | disabled |
| innodb_master_active_loops               | server              | disabled |
| innodb_master_idle_loops                 | server              | disabled |
| innodb_master_purge_usec                 | server              | disabled |
| innodb_master_thread_sleeps              | server              | disabled |
| innodb_mem_validate_usec                 | server              | disabled |
| innodb_page_size                         | server              | enabled  |
| innodb_rwlock_sx_os_waits                | server              | enabled  |
| innodb_rwlock_sx_spin_rounds             | server              | enabled  |
| innodb_rwlock_sx_spin_waits              | server              | enabled  |
| innodb_rwlock_s_os_waits                 | server              | enabled  |
| innodb_rwlock_s_spin_rounds              | server              | enabled  |
| innodb_rwlock_s_spin_waits               | server              | enabled  |
| innodb_rwlock_x_os_waits                 | server              | enabled  |
| innodb_rwlock_x_spin_rounds              | server              | enabled  |
| innodb_rwlock_x_spin_waits               | server              | enabled  |
| lock_deadlocks                           | lock                | enabled  |
| lock_rec_locks                           | lock                | disabled |
| lock_rec_lock_created                    | lock                | disabled |
| lock_rec_lock_removed                    | lock                | disabled |
| lock_rec_lock_requests                   | lock                | disabled |
| lock_rec_lock_waits                      | lock                | disabled |
| lock_row_lock_current_waits              | lock                | enabled  |
| lock_row_lock_time                       | lock                | enabled  |
| lock_row_lock_time_avg                   | lock                | enabled  |
| lock_row_lock_time_max                   | lock                | enabled  |
| lock_row_lock_waits                      | lock                | enabled  |
| lock_table_locks                         | lock                | disabled |
| lock_table_lock_created                  | lock                | disabled |
| lock_table_lock_removed                  | lock                | disabled |
| lock_table_lock_waits                    | lock                | disabled |
| lock_timeouts                            | lock                | enabled  |
| log_checkpoints                          | recovery            | disabled |
| log_lsn_buf_pool_oldest                  | recovery            | disabled |
| log_lsn_checkpoint_age                   | recovery            | disabled |
| log_lsn_current                          | recovery            | disabled |
| log_lsn_last_checkpoint                  | recovery            | disabled |
| log_lsn_last_flush                       | recovery            | disabled |
| log_max_modified_age_async               | recovery            | disabled |
| log_max_modified_age_sync                | recovery            | disabled |
| log_num_log_io                           | recovery            | disabled |
| log_padded                               | recovery            | enabled  |
| log_pending_checkpoint_writes            | recovery            | disabled |
| log_pending_log_flushes                  | recovery            | disabled |
| log_waits                                | recovery            | enabled  |
| log_writes                               | recovery            | enabled  |
| log_write_requests                       | recovery            | enabled  |
| metadata_table_handles_closed            | metadata            | disabled |
| metadata_table_handles_opened            | metadata            | disabled |
| metadata_table_reference_count           | metadata            | disabled |
| os_data_fsyncs                           | os                  | enabled  |
| os_data_reads                            | os                  | enabled  |
| os_data_writes                           | os                  | enabled  |
| os_log_bytes_written                     | os                  | enabled  |
| os_log_fsyncs                            | os                  | enabled  |
| os_log_pending_fsyncs                    | os                  | enabled  |
| os_log_pending_writes                    | os                  | enabled  |
| os_pending_reads                         | os                  | disabled |
| os_pending_writes                        | os                  | disabled |
| purge_del_mark_records                   | purge               | disabled |
| purge_dml_delay_usec                     | purge               | disabled |
| purge_invoked                            | purge               | disabled |
| purge_resume_count                       | purge               | disabled |
| purge_stop_count                         | purge               | disabled |
| purge_undo_log_pages                     | purge               | disabled |
| purge_upd_exist_or_extern_records        | purge               | disabled |
| trx_active_transactions                  | transaction         | disabled |
| trx_commits_insert_update                | transaction         | disabled |
| trx_nl_ro_commits                        | transaction         | disabled |
| trx_rollbacks                            | transaction         | disabled |
| trx_rollbacks_savepoint                  | transaction         | disabled |
| trx_rollback_active                      | transaction         | disabled |
| trx_ro_commits                           | transaction         | disabled |
| trx_rseg_current_size                    | transaction         | disabled |
| trx_rseg_history_len                     | transaction         | enabled  |
| trx_rw_commits                           | transaction         | disabled |
| trx_undo_slots_cached                    | transaction         | disabled |
| trx_undo_slots_used                      | transaction         | disabled |
+------------------------------------------+---------------------+----------+
235 rows in set (0.01 sec)
</pre><h4><a name="idm44761346939072"></a>カウンタモジュール</h4><p>
      各カウンタは特定のモジュールに関連付けられています。 モジュール名を使用すると、特定のサブシステムのすべてのカウンタを有効化、無効化、またはリセットできます。 たとえば、<code class="literal">dml</code> サブシステムに関連付けられたすべてのカウンタを有効にするには、<code class="literal">module_dml</code> を使用します。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_monitor_enable = module_dml;</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT name, subsystem, status FROM INFORMATION_SCHEMA.INNODB_METRICS</code></strong>
       <strong class="userinput"><code>WHERE subsystem ='dml';</code></strong>
+-------------+-----------+---------+
| name        | subsystem | status  |
+-------------+-----------+---------+
| dml_reads   | dml       | enabled |
| dml_inserts | dml       | enabled |
| dml_deletes | dml       | enabled |
| dml_updates | dml       | enabled |
+-------------+-----------+---------+
</pre><p>
      モジュール名は、<code class="literal">innodb_monitor_enable</code> および関連する変数とともに使用できます。
    </p><p>
      モジュール名および対応する <code class="literal">SUBSYSTEM</code> 名を次に示します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">module_adaptive_hash</code> (サブシステム = <code class="literal">adaptive_hash_index</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_buffer</code> (サブシステム = <code class="literal">buffer</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_buffer_page</code> (subsystem = <code class="literal">buffer_page_io</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_compress</code> (サブシステム = <code class="literal">compression</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_ddl</code> (サブシステム = <code class="literal">ddl</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_dml</code> (サブシステム = <code class="literal">dml</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_file</code> (サブシステム = <code class="literal">file_system</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_ibuf_system</code> (サブシステム = <code class="literal">change_buffer</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_icp</code> (サブシステム = <code class="literal">icp</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_index</code> (サブシステム = <code class="literal">index</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_innodb</code> (subsystem = <code class="literal">innodb</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_lock</code> (サブシステム = <code class="literal">lock</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_log</code> (サブシステム = <code class="literal">recovery</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_metadata</code> (サブシステム = <code class="literal">metadata</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_os</code> (サブシステム = <code class="literal">os</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_purge</code> (サブシステム = <code class="literal">purge</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_trx</code> (サブシステム = <code class="literal">transaction</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_undo</code> (subsystem = <code class="literal">undo</code>)
        </p></li></ul></div><div class="example"><a name="innodb-information-schema-metrics-table-example"></a><p class="title"><b>例 15.11 INNODB_METRICS テーブルのカウンタの操作</b></p><div class="example-contents"><p>
        この例では、カウンタの有効化、無効化、およびリセットと、<code class="literal">INNODB_METRICS</code> テーブル内のカウンタデータのクエリーを示します。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            単純な <code class="literal">InnoDB</code> テーブルを作成します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
Database changed

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT) ENGINE=INNODB;</code></strong>
Query OK, 0 rows affected (0.02 sec)
</pre></li><li class="listitem"><p>
            <code class="literal">dml_inserts</code> カウンタを有効にします。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_monitor_enable = dml_inserts;</code></strong>
Query OK, 0 rows affected (0.01 sec)
</pre><p>
            <code class="literal">dml_inserts</code> カウンタの説明は、<code class="literal">INNODB_METRICS</code> テーブルの <code class="literal">COMMENT</code> カラムで見つけることができます。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT NAME, COMMENT FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME="dml_inserts";</code></strong>
+-------------+-------------------------+
| NAME        | COMMENT                 |
+-------------+-------------------------+
| dml_inserts | Number of rows inserted |
+-------------+-------------------------+
</pre></li><li class="listitem"><p>
            <code class="literal">dml_inserts</code> カウンタデータを取得するために <code class="literal">INNODB_METRICS</code> テーブルをクエリーします。 DML 操作が実行されていないため、カウンタ値は 0 または NULL です。 <code class="literal">TIME_ENABLED</code> および <code class="literal">TIME_ELAPSED</code> の値は、カウンタが最後に有効になった時間と、その時間から経過した秒数を示します。 
          </p><pre class="programlisting">mysql&gt;  <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME="dml_inserts" \G</code></strong>
*************************** 1. row ***************************
           NAME: dml_inserts
      SUBSYSTEM: dml
          COUNT: 0
      MAX_COUNT: 0
      MIN_COUNT: NULL
      AVG_COUNT: 0
    COUNT_RESET: 0
MAX_COUNT_RESET: 0
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: NULL
   TIME_ENABLED: 2014-12-04 14:18:28
  TIME_DISABLED: NULL
   TIME_ELAPSED: 28
     TIME_RESET: NULL
         STATUS: enabled
           TYPE: status_counter
        COMMENT: Number of rows inserted
</pre></li><li class="listitem"><p>
            テーブルに 3 行のデータを挿入します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO t1 values(1);</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO t1 values(2);</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO t1 values(3);</code></strong>
Query OK, 1 row affected (0.00 sec)
</pre></li><li class="listitem"><p>
            <code class="literal">dml_inserts</code> カウンタデータを取得するために再度 <code class="literal">INNODB_METRICS</code> テーブルをクエリーします。 <code class="literal">COUNT</code>、<code class="literal">MAX_COUNT</code>、<code class="literal">AVG_COUNT</code>、<code class="literal">COUNT_RESET</code> など、いくつかのカウンタ値が増分されています。 これらの値の説明については、<code class="literal">INNODB_METRICS</code> テーブルの定義を参照してください。 
          </p><pre class="programlisting">mysql&gt;  <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME="dml_inserts"\G</code></strong>
*************************** 1. row ***************************
           NAME: dml_inserts
      SUBSYSTEM: dml
          COUNT: 3
      MAX_COUNT: 3
      MIN_COUNT: NULL
      AVG_COUNT: 0.046153846153846156
    COUNT_RESET: 3
MAX_COUNT_RESET: 3
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: NULL
   TIME_ENABLED: 2014-12-04 14:18:28
  TIME_DISABLED: NULL
   TIME_ELAPSED: 65
     TIME_RESET: NULL
         STATUS: enabled
           TYPE: status_counter
        COMMENT: Number of rows inserted
</pre></li><li class="listitem"><p>
            <code class="literal">dml_inserts</code> カウンタをリセットし、<code class="literal">INNODB_METRICS</code> テーブルで <code class="literal">dml_inserts</code> カウンタデータを再度クエリーします。 <code class="literal">COUNT_RESET</code> や <code class="literal">MAX_RESET</code> などの、前にレポートされた<code class="literal">%_RESET</code>値が 0 に戻っています。 カウンタが有効になった時点から累積してデータを収集する <code class="literal">COUNT</code>、<code class="literal">MAX_COUNT</code>、<code class="literal">AVG_COUNT</code> などの値はリセットの影響を受けません。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_monitor_reset = dml_inserts;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME="dml_inserts"\G</code></strong>
*************************** 1. row ***************************
           NAME: dml_inserts
      SUBSYSTEM: dml
          COUNT: 3
      MAX_COUNT: 3
      MIN_COUNT: NULL
      AVG_COUNT: 0.03529411764705882
    COUNT_RESET: 0
MAX_COUNT_RESET: 0
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: 0
   TIME_ENABLED: 2014-12-04 14:18:28
  TIME_DISABLED: NULL
   TIME_ELAPSED: 85
     TIME_RESET: 2014-12-04 14:19:44
         STATUS: enabled
           TYPE: status_counter
        COMMENT: Number of rows inserted
</pre></li><li class="listitem"><p>
            すべてのカウンタ値をリセットするには、まずそのカウンタを無効にする必要があります。 カウンタを無効にすると、<code class="literal">STATUS</code> 値が <code class="literal">disabled</code> に設定されます。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_monitor_disable = dml_inserts;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME="dml_inserts"\G</code></strong>
*************************** 1. row ***************************
           NAME: dml_inserts
      SUBSYSTEM: dml
          COUNT: 3
      MAX_COUNT: 3
      MIN_COUNT: NULL
      AVG_COUNT: 0.030612244897959183
    COUNT_RESET: 0
MAX_COUNT_RESET: 0
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: 0
   TIME_ENABLED: 2014-12-04 14:18:28
  TIME_DISABLED: 2014-12-04 14:20:06
   TIME_ELAPSED: 98
     TIME_RESET: NULL
         STATUS: disabled
           TYPE: status_counter
        COMMENT: Number of rows inserted
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              カウンタおよびモジュール名にはワイルドカードマッチングがサポートされています。 たとえば、<code class="literal">dml_inserts</code> カウンタの完全な名前を指定する代わりに、<code class="literal">dml_i%</code>を指定できます。 また、ワイルドカードマッチングを使用して、複数のカウンタまたはモジュールを一度に有効または無効にしたり、リセットしたりすることもできます。 たとえば、<code class="literal">dml_</code>で始まるすべてのカウンタを有効化、無効化またはリセットするには、<code class="literal">dml_%</code> を指定します。 
            </p></div></li><li class="listitem"><p>
            カウンタが無効になったら、<code class="literal">innodb_monitor_reset_all</code> オプションを使用して、すべてのカウンタ値をリセットできます。 すべての値が 0 または NULL に設定されます。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_monitor_reset_all = dml_inserts;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME="dml_inserts"\G</code></strong>
*************************** 1. row ***************************
           NAME: dml_inserts
      SUBSYSTEM: dml
          COUNT: 0
      MAX_COUNT: NULL
      MIN_COUNT: NULL
      AVG_COUNT: NULL
    COUNT_RESET: 0
MAX_COUNT_RESET: NULL
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: NULL
   TIME_ENABLED: NULL
  TIME_DISABLED: NULL
   TIME_ELAPSED: NULL
     TIME_RESET: NULL
         STATUS: disabled
           TYPE: status_counter
        COMMENT: Number of rows inserted
</pre></li></ol></div></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-information-schema-temp-table-info"></a>15.15.7 InnoDB INFORMATION_SCHEMA 一時テーブル情報テーブル</h3></div></div></div><p>
      <code class="literal">INNODB_TEMP_TABLE_INFO</code> は、<code class="literal">InnoDB</code> インスタンスでアクティブなユーザー作成の <code class="literal">InnoDB</code> 一時テーブルに関する情報を提供します。 オプティマイザで使用される内部 <code class="literal">InnoDB</code> 一時テーブルに関する情報は提供されません。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW TABLES FROM INFORMATION_SCHEMA LIKE 'INNODB_TEMP%';</code></strong>
+---------------------------------------------+
| Tables_in_INFORMATION_SCHEMA (INNODB_TEMP%) |
+---------------------------------------------+
| INNODB_TEMP_TABLE_INFO                      |
+---------------------------------------------+
</pre><p>
      テーブル定義については、<a class="xref" href="information-schema.html#information-schema-innodb-temp-table-info-table" title="26.51.28 INFORMATION_SCHEMA INNODB_TEMP_TABLE_INFO テーブル">セクション26.51.28「INFORMATION_SCHEMA INNODB_TEMP_TABLE_INFO テーブル」</a>を参照してください。
    </p><div class="example"><a name="innodb-information-schema-temp-table-info-example"></a><p class="title"><b>例 15.12 INNODB_TEMP_TABLE_INFO</b></p><div class="example-contents"><p>
        この例では、<code class="literal">INNODB_TEMP_TABLE_INFO</code> テーブルの特性を示します。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            単純な <code class="literal">InnoDB</code> 一時テーブルを作成します:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TEMPORARY TABLE t1 (c1 INT PRIMARY KEY) ENGINE=INNODB;</code></strong>
</pre></li><li class="listitem"><p>
            <code class="literal">INNODB_TEMP_TABLE_INFO</code> をクエリーして、一時テーブルのメタデータを表示します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_TEMP_TABLE_INFO\G</code></strong>
*************************** 1. row ***************************
            TABLE_ID: 194
                NAME: #sql7a79_1_0
              N_COLS: 4
               SPACE: 182
</pre><p>
            <code class="literal">TABLE_ID </code>は、一時テーブルの一意の識別子です。 <code class="literal">NAME</code> カラムには、<span class="quote">「<span class="quote">#sql</span>」</span> という接頭辞が付いた一時テーブルのシステム生成名が表示されます。 <code class="literal">InnoDB</code> では常に 3 つの非表示のテーブルのカラム (<code class="literal">DB_ROW_ID</code>、<code class="literal">DB_TRX_ID</code> および <code class="literal">DB_ROLL_PTR</code>) が作成されるため、カラム数 (<code class="literal">N_COLS</code>) は 1 ではなく 4 です。 
          </p></li><li class="listitem"><p>
            MySQL を再起動し、<code class="literal">INNODB_TEMP_TABLE_INFO</code> をクエリーします。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_TEMP_TABLE_INFO\G</code></strong>
</pre><p>
            サーバーの停止時に <code class="literal">INNODB_TEMP_TABLE_INFO</code> とそのデータがディスクに永続化されないため、空のセットが返されます。
          </p></li><li class="listitem"><p>
            新しい一時テーブルを作成します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TEMPORARY TABLE t1 (c1 INT PRIMARY KEY) ENGINE=INNODB;</code></strong>
</pre></li><li class="listitem"><p>
            <code class="literal">INNODB_TEMP_TABLE_INFO</code> をクエリーして、一時テーブルのメタデータを表示します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_TEMP_TABLE_INFO\G</code></strong>
*************************** 1. row ***************************
            TABLE_ID: 196
                NAME: #sql7b0e_1_0
              N_COLS: 4
               SPACE: 184
</pre><p>
            <code class="literal">SPACE</code> ID は、サーバーの起動時に動的に生成されるため、異なる場合があります。
          </p></li></ol></div></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-information-schema-files-table"></a>15.15.8 INFORMATION_SCHEMA.FILES からの InnoDB テーブルスペースメタデータの取得</h3></div></div></div><p>
      <code class="literal">INFORMATION_SCHEMA.FILES</code> テーブルは、<a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table tablespaces</a>、<a class="link" href="glossary.html#glos_general_tablespace" title="一般テーブルスペース">general tablespaces</a>、<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">system tablespace</a>、<a class="link" href="glossary.html#glos_temporary_tablespace" title="一時テーブルスペース">temporary table tablespaces</a>、<a class="link" href="glossary.html#glos_undo_tablespace" title="Undo テーブルスペース">undo tablespaces</a> (存在する場合) など、すべての <code class="literal">InnoDB</code> テーブルスペースタイプに関するメタデータを提供します。
    </p><p>
      このセクションでは、<code class="literal">InnoDB</code> 固有の使用例を示します。 <code class="literal">INFORMATION_SCHEMA.FILES</code> テーブルで提供されるデータの詳細は、<a class="xref" href="information-schema.html#information-schema-files-table" title="26.15 INFORMATION_SCHEMA FILES テーブル">セクション26.15「INFORMATION_SCHEMA FILES テーブル」</a> を参照してください。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">INNODB_TABLESPACES</code> テーブルおよび <code class="literal">INNODB_DATAFILES</code> テーブルでは、<code class="literal">InnoDB</code> テーブルスペースに関するメタデータも提供されますが、データは file-per-table、general および undo テーブルスペースに制限されます。
      </p></div><p>
      このクエリーは、<code class="literal">InnoDB</code> システムテーブルスペースに関するメタデータを、<code class="literal">InnoDB</code> テーブルスペースに関連する <code class="literal">INFORMATION_SCHEMA.FILES</code> テーブルのフィールドから取得します。 <code class="literal">InnoDB</code> に関連しない <code class="literal">INFORMATION_SCHEMA.FILES</code> フィールドは、常に NULL を返し、クエリーから除外されます。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT FILE_ID, FILE_NAME, FILE_TYPE, TABLESPACE_NAME, FREE_EXTENTS,</code></strong>
       <strong class="userinput"><code>TOTAL_EXTENTS,  EXTENT_SIZE, INITIAL_SIZE, MAXIMUM_SIZE, AUTOEXTEND_SIZE, DATA_FREE, STATUS ENGINE</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.FILES WHERE TABLESPACE_NAME LIKE 'innodb_system' \G</code></strong>
*************************** 1. row ***************************
        FILE_ID: 0
      FILE_NAME: ./ibdata1
      FILE_TYPE: TABLESPACE
TABLESPACE_NAME: innodb_system
   FREE_EXTENTS: 0
  TOTAL_EXTENTS: 12
    EXTENT_SIZE: 1048576
   INITIAL_SIZE: 12582912
   MAXIMUM_SIZE: NULL
AUTOEXTEND_SIZE: 67108864
      DATA_FREE: 4194304
         ENGINE: NORMAL
</pre><p>
      このクエリーは、<code class="literal">InnoDB</code> file-per-table および一般テーブルスペースの <code class="literal">FILE_ID</code> (スペース ID と同等) および <code class="literal">FILE_NAME</code> (パス情報を含む) を取得します。 File-per-table および general テーブルスペースには、<code class="filename">.ibd</code> ファイル拡張子が付いています。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT FILE_ID, FILE_NAME FROM INFORMATION_SCHEMA.FILES</code></strong>
       <strong class="userinput"><code>WHERE FILE_NAME LIKE '%.ibd%' ORDER BY FILE_ID;</code></strong>
    +---------+---------------------------------------+
    | FILE_ID | FILE_NAME                             |
    +---------+---------------------------------------+
    |       2 | ./mysql/plugin.ibd                    |
    |       3 | ./mysql/servers.ibd                   |
    |       4 | ./mysql/help_topic.ibd                |
    |       5 | ./mysql/help_category.ibd             |
    |       6 | ./mysql/help_relation.ibd             |
    |       7 | ./mysql/help_keyword.ibd              |
    |       8 | ./mysql/time_zone_name.ibd            |
    |       9 | ./mysql/time_zone.ibd                 |
    |      10 | ./mysql/time_zone_transition.ibd      |
    |      11 | ./mysql/time_zone_transition_type.ibd |
    |      12 | ./mysql/time_zone_leap_second.ibd     |
    |      13 | ./mysql/innodb_table_stats.ibd        |
    |      14 | ./mysql/innodb_index_stats.ibd        |
    |      15 | ./mysql/slave_relay_log_info.ibd      |
    |      16 | ./mysql/slave_master_info.ibd         |
    |      17 | ./mysql/slave_worker_info.ibd         |
    |      18 | ./mysql/gtid_executed.ibd             |
    |      19 | ./mysql/server_cost.ibd               |
    |      20 | ./mysql/engine_cost.ibd               |
    |      21 | ./sys/sys_config.ibd                  |
    |      23 | ./test/t1.ibd                         |
    |      26 | /home/user/test/test/t2.ibd           |
    +---------+---------------------------------------+
</pre><p>
      このクエリーは、<code class="literal">InnoDB</code> グローバル一時テーブルスペースの <code class="literal">FILE_ID</code> および <code class="literal">FILE_NAME</code> を取得します。 グローバル一時テーブルスペースのファイル名には、接頭辞として <code class="literal">ibtmp</code> が付きます。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT FILE_ID, FILE_NAME FROM INFORMATION_SCHEMA.FILES</code></strong>
       <strong class="userinput"><code>WHERE FILE_NAME LIKE '%ibtmp%';</code></strong>
+---------+-----------+
| FILE_ID | FILE_NAME |
+---------+-----------+
|      22 | ./ibtmp1  |
+---------+-----------+
</pre><p>
      同様に、<code class="literal">InnoDB</code> undo テーブルスペースのファイル名には <code class="literal">undo</code> という接頭辞が付きます。 次のクエリーは、<code class="literal">InnoDB</code> undo テーブルスペースの <code class="literal">FILE_ID</code> および <code class="literal">FILE_NAME</code> を戻します。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT FILE_ID, FILE_NAME FROM INFORMATION_SCHEMA.FILES</code></strong>
       <strong class="userinput"><code>WHERE FILE_NAME LIKE '%undo%';</code></strong>
</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-performance-schema"></a>15.16 InnoDB の MySQL パフォーマンススキーマとの統合</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#monitor-alter-table-performance-schema">15.16.1 パフォーマンススキーマを使用した InnoDB テーブルの ALTER TABLE の進行状況のモニタリング</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#monitor-innodb-mutex-waits-performance-schema">15.16.2 パフォーマンススキーマを使用した InnoDB Mutex 待機のモニタリング</a></span></dt></dl></div><a class="indexterm" name="idm44761346742576"></a><p>
    このセクションでは、<code class="literal">InnoDB</code> とパフォーマンススキーマの統合について簡単に説明します。 包括的なパフォーマンススキーマドキュメントについては、<a class="xref" href="performance-schema.html" title="第 27 章 MySQL パフォーマンススキーマ">第27章「<i>MySQL パフォーマンススキーマ</i>」</a> を参照してください。 
  </p><p>
    MySQL <a class="link" href="performance-schema.html" title="第 27 章 MySQL パフォーマンススキーマ">Performance Schema feature</a> を使用して、特定の内部 <code class="literal">InnoDB</code> 操作をプロファイルできます。 このタイプのチューニングは、主に最適化戦略を評価してパフォーマンスボトルネックを克服するエキスパートユーザーを対象としています。 DBA はまた、この機能を容量計画に使用することにより、標準的なワークロードのときに CPU、RAM、およびディスクストレージの特定の組み合わせでパフォーマンスのボトルネックが発生するかどうかを確認し、発生する場合は、システムの一部の容量を増やすことでパフォーマンスを向上させることができるかどうかを判断することもできます。 
  </p><p>
    この機能を使用して <code class="literal">InnoDB</code> のパフォーマンスを調べるには:
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        通常、<a class="link" href="performance-schema.html" title="第 27 章 MySQL パフォーマンススキーマ">Performance Schema feature</a> の使用方法に精通している必要があります。 たとえば、インストゥルメントとコンシューマを有効にする方法、および <code class="literal">performance_schema</code> テーブルをクエリーしてデータを取得する方法を理解する必要があります。 概要については、<a class="xref" href="performance-schema.html#performance-schema-quick-start" title="27.1 パフォーマンススキーマクイックスタート">セクション27.1「パフォーマンススキーマクイックスタート」</a> を参照してください。 
      </p></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> で使用可能なパフォーマンススキーマインストゥルメントに精通している必要があります。 <code class="literal">InnoDB</code> 関連のインストゥルメントを表示するには、<code class="literal">innodb</code> を含むインストゥルメント名を <code class="literal">setup_instruments</code> テーブルにクエリーすることができます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
       <strong class="userinput"><code>FROM performance_schema.setup_instruments</code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE '%innodb%';</code></strong>
+-------------------------------------------------------+---------+-------+
| NAME                                                  | ENABLED | TIMED |
+-------------------------------------------------------+---------+-------+
| wait/synch/mutex/innodb/commit_cond_mutex             | NO      | NO    |
| wait/synch/mutex/innodb/innobase_share_mutex          | NO      | NO    |
| wait/synch/mutex/innodb/autoinc_mutex                 | NO      | NO    |
| wait/synch/mutex/innodb/buf_pool_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/buf_pool_zip_mutex            | NO      | NO    |
| wait/synch/mutex/innodb/cache_last_read_mutex         | NO      | NO    |
| wait/synch/mutex/innodb/dict_foreign_err_mutex        | NO      | NO    |
| wait/synch/mutex/innodb/dict_sys_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/recalc_pool_mutex             | NO      | NO    |
...
| wait/io/file/innodb/innodb_data_file                  | YES     | YES   |
| wait/io/file/innodb/innodb_log_file                   | YES     | YES   |
| wait/io/file/innodb/innodb_temp_file                  | YES     | YES   |
| stage/innodb/alter table (end)                        | YES     | YES   |
| stage/innodb/alter table (flush)                      | YES     | YES   |
| stage/innodb/alter table (insert)                     | YES     | YES   |
| stage/innodb/alter table (log apply index)            | YES     | YES   |
| stage/innodb/alter table (log apply table)            | YES     | YES   |
| stage/innodb/alter table (merge sort)                 | YES     | YES   |
| stage/innodb/alter table (read PK and internal sort)  | YES     | YES   |
| stage/innodb/buffer pool load                         | YES     | YES   |
| memory/innodb/buf_buf_pool                            | NO      | NO    |
| memory/innodb/dict_stats_bg_recalc_pool_t             | NO      | NO    |
| memory/innodb/dict_stats_index_map_t                  | NO      | NO    |
| memory/innodb/dict_stats_n_diff_on_level              | NO      | NO    |
| memory/innodb/other                                   | NO      | NO    |
| memory/innodb/row_log_buf                             | NO      | NO    |
| memory/innodb/row_merge_sort                          | NO      | NO    |
| memory/innodb/std                                     | NO      | NO    |
| memory/innodb/sync_debug_latches                      | NO      | NO    |
| memory/innodb/trx_sys_t::rw_trx_ids                   | NO      | NO    |
...
+-------------------------------------------------------+---------+-------+
155 rows in set (0.00 sec)
</pre><p>
        インストゥルメントされた <code class="literal">InnoDB</code> オブジェクトに関する追加情報については、インストゥルメントされたオブジェクトに関する追加情報を提供するパフォーマンススキーマ <a class="link" href="performance-schema.html#performance-schema-instance-tables" title="27.12.3 パフォーマンススキーマインスタンステーブル">instances tables</a> をクエリーできます。 <code class="literal">InnoDB</code> に関連するインスタンステーブルは次のとおりです: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
            <code class="literal">mutex_instances</code> テーブル
          </p></li><li class="listitem"><p>
            <code class="literal">rwlock_instances</code> テーブル
          </p></li><li class="listitem"><p>
            <code class="literal">cond_instances</code> テーブル
          </p></li><li class="listitem"><p>
            <code class="literal">file_instances</code> テーブル
          </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">InnoDB</code> バッファプールに関連する相互排他ロックおよび RW ロックは、このカバレッジには含まれません。これは、<code class="literal">SHOW ENGINE INNODB MUTEX</code> コマンドの出力にも当てはまります。
        </p></div><p>
        たとえば、ファイル I/O インストゥルメンテーションの実行時にパフォーマンススキーマに表示されるインストゥルメントされた <code class="literal">InnoDB</code> ファイルオブジェクトに関する情報を表示するには、次のクエリーを発行します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
       <strong class="userinput"><code>FROM performance_schema.file_instances</code></strong>
       <strong class="userinput"><code>WHERE EVENT_NAME LIKE '%innodb%'\G</code></strong>
*************************** 1. row ***************************
 FILE_NAME: /path/to/mysql-8.0/data/ibdata1
EVENT_NAME: wait/io/file/innodb/innodb_data_file
OPEN_COUNT: 3
*************************** 2. row ***************************
 FILE_NAME: /path/to/mysql-8.0/data/ib_logfile0
EVENT_NAME: wait/io/file/innodb/innodb_log_file
OPEN_COUNT: 2
*************************** 3. row ***************************
 FILE_NAME: /path/to/mysql-8.0/data/ib_logfile1
EVENT_NAME: wait/io/file/innodb/innodb_log_file
OPEN_COUNT: 2
*************************** 4. row ***************************
 FILE_NAME: /path/to/mysql-8.0/data/mysql/engine_cost.ibd
EVENT_NAME: wait/io/file/innodb/innodb_data_file
OPEN_COUNT: 3
...
</pre></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> イベントデータを格納する <code class="literal">performance_schema</code> テーブルに精通している必要があります。 <code class="literal">InnoDB</code> 関連のイベントに関連するテーブルは次のとおりです: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
            待機イベントを格納する <a class="link" href="performance-schema.html#performance-schema-wait-tables" title="27.12.4 パフォーマンススキーマ待機イベントテーブル">Wait Event</a> テーブル。
          </p></li><li class="listitem"><p>
            <a class="link" href="performance-schema.html#performance-schema-summary-tables" title="27.12.18 パフォーマンススキーマサマリーテーブル">Summary</a> テーブル。時間の経過とともに終了したイベントの集計情報を提供します。 サマリーテーブルには、I/O 操作に関する情報を集計する <a class="link" href="performance-schema.html#performance-schema-file-summary-tables" title="27.12.18.7 ファイル I/O サマリーテーブル">file I/O summary tables</a> が含まれます。 
          </p></li><li class="listitem"><p>
            <a class="link" href="performance-schema.html#performance-schema-stage-tables" title="27.12.5 パフォーマンススキーマステージイベントテーブル">Stage Event</a> テーブル: <code class="literal">InnoDB</code> <code class="literal">ALTER TABLE</code> およびバッファプールロード操作のイベントデータを格納します。 詳細は、<a class="xref" href="innodb-storage-engine.html#monitor-alter-table-performance-schema" title="15.16.1 パフォーマンススキーマを使用した InnoDB テーブルの ALTER TABLE の進行状況のモニタリング">セクション15.16.1「パフォーマンススキーマを使用した InnoDB テーブルの ALTER TABLE の進行状況のモニタリング」</a>および<a class="xref" href="innodb-storage-engine.html#monitor-buffer-pool-load-performance-schema" title="パフォーマンススキーマを使用したバッファプールのロード進行状況の監視">パフォーマンススキーマを使用したバッファプールのロード進行状況の監視</a>を参照してください。 
          </p></li></ul></div><p>
        <code class="literal">InnoDB</code> 関連のオブジェクトのみに関心がある場合は、これらのテーブルをクエリーするときに <code class="literal">WHERE EVENT_NAME LIKE '%innodb%'</code>句または <code class="literal">WHERE NAME LIKE '%innodb%'</code>句を (必要に応じて) 使用します。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="monitor-alter-table-performance-schema"></a>15.16.1 パフォーマンススキーマを使用した InnoDB テーブルの ALTER TABLE の進行状況のモニタリング</h3></div></div></div><a class="indexterm" name="idm44761346681568"></a><a class="indexterm" name="idm44761346679424"></a><p>
      <a class="link" href="performance-schema.html" title="第 27 章 MySQL パフォーマンススキーマ">Performance Schema</a> を使用して、<code class="literal">InnoDB</code> テーブルの <code class="literal">ALTER TABLE</code> 進捗を監視できます。
    </p><p>
      <code class="literal">ALTER TABLE</code> の様々なフェーズを表す 7 つのステージイベントがあります。 各ステージイベントでは、<code class="literal">ALTER TABLE</code> 操作全体の様々なフェーズの進行に応じて、<code class="literal">WORK_COMPLETED</code> および <code class="literal">WORK_ESTIMATED</code> の累積合計がレポートされます。 <code class="literal">WORK_ESTIMATED</code> は、<code class="literal">ALTER TABLE</code> が実行するすべての作業を考慮した式を使用して計算され、<code class="literal">ALTER TABLE</code> の処理中に改訂できます。 <code class="literal">WORK_COMPLETED</code> および <code class="literal">WORK_ESTIMATED</code> の値は、<code class="literal">ALTER TABLE</code> によって実行されるすべての作業の抽象表現です。 
    </p><p>
      発生順に、<code class="literal">ALTER TABLE</code> ステージイベントには次のものが含まれます:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">stage/innodb/alter table (read PK and internal sort)</code>: このステージは、<code class="literal">ALTER TABLE</code> が読取り - 主キーフェーズにある場合にアクティブになります。 これは、主キーの推定ページ数に設定された <code class="literal">WORK_COMPLETED=0</code> および <code class="literal">WORK_ESTIMATED</code> から始まります。 ステージが完了すると、<code class="literal">WORK_ESTIMATED</code> は主キーの実際のページ数に更新されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">stage/innodb/alter table (merge sort)</code>: このステージは、<code class="literal">ALTER TABLE</code> 操作によって追加されたインデックスごとに繰り返されます。
        </p></li><li class="listitem"><p>
          <code class="literal">stage/innodb/alter table (insert)</code>: このステージは、<code class="literal">ALTER TABLE</code> 操作によって追加されたインデックスごとに繰り返されます。
        </p></li><li class="listitem"><p>
          <code class="literal">stage/innodb/alter table (log apply index)</code>: このステージには、<code class="literal">ALTER TABLE</code> の実行中に生成された DML ログの適用が含まれます。
        </p></li><li class="listitem"><p>
          <code class="literal">stage/innodb/alter table (flush)</code>: このステージが開始される前に、フラッシュリストの長さに基づいて、より正確な見積りで <code class="literal">WORK_ESTIMATED</code> が更新されます。
        </p></li><li class="listitem"><p>
          <code class="literal">stage/innodb/alter table (log apply table)</code>: このステージには、<code class="literal">ALTER TABLE</code> の実行中に生成された同時 DML ログの適用が含まれます。 このフェーズの期間は、テーブルの変更の程度によって異なります。 テーブルに対して同時 DML が実行されなかった場合、このフェーズは即時です。 
        </p></li><li class="listitem"><p>
          <code class="literal">stage/innodb/alter table (end)</code>: <code class="literal">ALTER TABLE</code> の実行中にテーブルに対して実行された DML の再適用など、フラッシュフェーズ後に表示された残りの作業が含まれます。
        </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">InnoDB</code> <code class="literal">ALTER TABLE</code> ステージイベントでは、現在空間インデックスの追加は考慮されていません。
      </p></div><h4><a name="idm44761346639024"></a>パフォーマンススキーマを使用した ALTER TABLE のモニタリングの例</h4><p>
      次の例は、<code class="literal">stage/innodb/alter table%</code> ステージイベントインストゥルメントおよび関連するコンシューマテーブルを有効にして <code class="literal">ALTER TABLE</code> の進行状況を監視する方法を示しています。 パフォーマンススキーマステージイベントインストゥルメントおよび関連コンシューマについては、<a class="xref" href="performance-schema.html#performance-schema-stage-tables" title="27.12.5 パフォーマンススキーマステージイベントテーブル">セクション27.12.5「パフォーマンススキーマステージイベントテーブル」</a> を参照してください。 
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          <code class="literal">stage/innodb/alter%</code> インストゥルメントを有効にします:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE performance_schema.setup_instruments</code></strong>
       <strong class="userinput"><code>SET ENABLED = 'YES'</code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE 'stage/innodb/alter%';</code></strong>
Query OK, 7 rows affected (0.00 sec)
Rows matched: 7  Changed: 7  Warnings: 0
</pre></li><li class="listitem"><p>
          ステージイベントコンシューマテーブル (<code class="literal">events_stages_current</code>、<code class="literal">events_stages_history</code> および <code class="literal">events_stages_history_long</code> を含む) を有効にします。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE performance_schema.setup_consumers</code></strong>
       <strong class="userinput"><code>SET ENABLED = 'YES'</code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE '%stages%';</code></strong>
Query OK, 3 rows affected (0.00 sec)
Rows matched: 3  Changed: 3  Warnings: 0
</pre></li><li class="listitem"><p>
          <code class="literal">ALTER TABLE</code> 操作を実行します。 この例では、employees サンプルデータベースの employees テーブルに <code class="literal">middle_name</code> カラムが追加されます。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE employees.employees ADD COLUMN middle_name varchar(14) AFTER first_name;</code></strong>
Query OK, 0 rows affected (9.27 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre></li><li class="listitem"><p>
          パフォーマンススキーマ <code class="literal">events_stages_current</code> テーブルをクエリーして、<code class="literal">ALTER TABLE</code> 操作の進行状況を確認します。 表示されるステージイベントは、現在進行中の <code class="literal">ALTER TABLE</code> フェーズによって異なります。 <code class="literal">WORK_COMPLETED</code> カラムには、完了した作業が表示されます。 <code class="literal">WORK_ESTIMATED</code> カラムには、残りの作業の見積りが表示されます。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT EVENT_NAME, WORK_COMPLETED, WORK_ESTIMATED</code></strong>
       <strong class="userinput"><code>FROM performance_schema.events_stages_current;</code></strong>
+------------------------------------------------------+----------------+----------------+
| EVENT_NAME                                           | WORK_COMPLETED | WORK_ESTIMATED |
+------------------------------------------------------+----------------+----------------+
| stage/innodb/alter table (read PK and internal sort) |            280 |           1245 |
+------------------------------------------------------+----------------+----------------+
1 row in set (0.01 sec)
</pre><p>
          <code class="literal">ALTER TABLE</code> 操作が完了すると、<code class="literal">events_stages_current</code> テーブルは空のセットを返します。 この場合、<code class="literal">events_stages_history</code> テーブルをチェックして、完了した操作のイベントデータを表示できます。 例: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT EVENT_NAME, WORK_COMPLETED, WORK_ESTIMATED</code></strong>
       <strong class="userinput"><code>FROM performance_schema.events_stages_history;</code></strong>
+------------------------------------------------------+----------------+----------------+
| EVENT_NAME                                           | WORK_COMPLETED | WORK_ESTIMATED |
+------------------------------------------------------+----------------+----------------+
| stage/innodb/alter table (read PK and internal sort) |            886 |           1213 |
| stage/innodb/alter table (flush)                     |           1213 |           1213 |
| stage/innodb/alter table (log apply table)           |           1597 |           1597 |
| stage/innodb/alter table (end)                       |           1597 |           1597 |
| stage/innodb/alter table (log apply table)           |           1981 |           1981 |
+------------------------------------------------------+----------------+----------------+
5 rows in set (0.00 sec)
</pre><p>
          前述のように、<code class="literal">WORK_ESTIMATED</code> 値は <code class="literal">ALTER TABLE</code> 処理中に改訂されました。 初期ステージの完了後の見積作業は 1213 です。 <code class="literal">ALTER TABLE</code> の処理が完了すると、<code class="literal">WORK_ESTIMATED</code> は実際の値 (1981) に設定されました。 
        </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="monitor-innodb-mutex-waits-performance-schema"></a>15.16.2 パフォーマンススキーマを使用した InnoDB Mutex 待機のモニタリング</h3></div></div></div><a class="indexterm" name="idm44761346597104"></a><a class="indexterm" name="idm44761346594960"></a><p>
      mutex は、特定の時間に 1 つのスレッドのみが共通リソースにアクセスできるように強制するために、コードで使用される同期メカニズムです。 サーバーで実行されている複数のスレッドが同じリソースにアクセスする必要がある場合、スレッドは互いに競合します。 mutex のロックを取得する最初のスレッドは、ロックが解放されるまで他のスレッドを待機します。 
    </p><p>
      インストゥルメントされた <code class="literal">InnoDB</code> mutex の場合、mutex 待機は <a class="link" href="performance-schema.html" title="第 27 章 MySQL パフォーマンススキーマ">Performance Schema</a> を使用してモニターできます。 「パフォーマンススキーマ」テーブルで収集された待機イベントデータは、たとえば、待機時間が最も多い相互排他ロックや合計待機時間が最も長い相互排他ロックの識別に役立ちます。 
    </p><p>
      次の例は、<code class="literal">InnoDB</code> mutex 待機インストゥルメントを有効にする方法、関連付けられたコンシューマを有効にする方法、および待機イベントデータをクエリーする方法を示しています。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          使用可能な <code class="literal">InnoDB</code> mutex 待機インストゥルメントを表示するには、パフォーマンススキーマ <code class="literal">setup_instruments</code> テーブルをクエリーします。 すべての <code class="literal">InnoDB</code> mutex 待機インストゥルメントはデフォルトで無効になっています。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
       <strong class="userinput"><code>FROM performance_schema.setup_instruments</code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE '%wait/synch/mutex/innodb%';</code></strong>
+---------------------------------------------------------+---------+-------+
| NAME                                                    | ENABLED | TIMED |
+---------------------------------------------------------+---------+-------+
| wait/synch/mutex/innodb/commit_cond_mutex               | NO      | NO    |
| wait/synch/mutex/innodb/innobase_share_mutex            | NO      | NO    |
| wait/synch/mutex/innodb/autoinc_mutex                   | NO      | NO    |
| wait/synch/mutex/innodb/autoinc_persisted_mutex         | NO      | NO    |
| wait/synch/mutex/innodb/buf_pool_flush_state_mutex      | NO      | NO    |
| wait/synch/mutex/innodb/buf_pool_LRU_list_mutex         | NO      | NO    |
| wait/synch/mutex/innodb/buf_pool_free_list_mutex        | NO      | NO    |
| wait/synch/mutex/innodb/buf_pool_zip_free_mutex         | NO      | NO    |
| wait/synch/mutex/innodb/buf_pool_zip_hash_mutex         | NO      | NO    |
| wait/synch/mutex/innodb/buf_pool_zip_mutex              | NO      | NO    |
| wait/synch/mutex/innodb/cache_last_read_mutex           | NO      | NO    |
| wait/synch/mutex/innodb/dict_foreign_err_mutex          | NO      | NO    |
| wait/synch/mutex/innodb/dict_persist_dirty_tables_mutex | NO      | NO    |
| wait/synch/mutex/innodb/dict_sys_mutex                  | NO      | NO    |
| wait/synch/mutex/innodb/recalc_pool_mutex               | NO      | NO    |
| wait/synch/mutex/innodb/fil_system_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/flush_list_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/fts_bg_threads_mutex            | NO      | NO    |
| wait/synch/mutex/innodb/fts_delete_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/fts_optimize_mutex              | NO      | NO    |
| wait/synch/mutex/innodb/fts_doc_id_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/log_flush_order_mutex           | NO      | NO    |
| wait/synch/mutex/innodb/hash_table_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/ibuf_bitmap_mutex               | NO      | NO    |
| wait/synch/mutex/innodb/ibuf_mutex                      | NO      | NO    |
| wait/synch/mutex/innodb/ibuf_pessimistic_insert_mutex   | NO      | NO    |
| wait/synch/mutex/innodb/log_sys_mutex                   | NO      | NO    |
| wait/synch/mutex/innodb/log_sys_write_mutex             | NO      | NO    |
| wait/synch/mutex/innodb/mutex_list_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/page_zip_stat_per_index_mutex   | NO      | NO    |
| wait/synch/mutex/innodb/purge_sys_pq_mutex              | NO      | NO    |
| wait/synch/mutex/innodb/recv_sys_mutex                  | NO      | NO    |
| wait/synch/mutex/innodb/recv_writer_mutex               | NO      | NO    |
| wait/synch/mutex/innodb/redo_rseg_mutex                 | NO      | NO    |
| wait/synch/mutex/innodb/noredo_rseg_mutex               | NO      | NO    |
| wait/synch/mutex/innodb/rw_lock_list_mutex              | NO      | NO    |
| wait/synch/mutex/innodb/rw_lock_mutex                   | NO      | NO    |
| wait/synch/mutex/innodb/srv_dict_tmpfile_mutex          | NO      | NO    |
| wait/synch/mutex/innodb/srv_innodb_monitor_mutex        | NO      | NO    |
| wait/synch/mutex/innodb/srv_misc_tmpfile_mutex          | NO      | NO    |
| wait/synch/mutex/innodb/srv_monitor_file_mutex          | NO      | NO    |
| wait/synch/mutex/innodb/buf_dblwr_mutex                 | NO      | NO    |
| wait/synch/mutex/innodb/trx_undo_mutex                  | NO      | NO    |
| wait/synch/mutex/innodb/trx_pool_mutex                  | NO      | NO    |
| wait/synch/mutex/innodb/trx_pool_manager_mutex          | NO      | NO    |
| wait/synch/mutex/innodb/srv_sys_mutex                   | NO      | NO    |
| wait/synch/mutex/innodb/lock_mutex                      | NO      | NO    |
| wait/synch/mutex/innodb/lock_wait_mutex                 | NO      | NO    |
| wait/synch/mutex/innodb/trx_mutex                       | NO      | NO    |
| wait/synch/mutex/innodb/srv_threads_mutex               | NO      | NO    |
| wait/synch/mutex/innodb/rtr_active_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/rtr_match_mutex                 | NO      | NO    |
| wait/synch/mutex/innodb/rtr_path_mutex                  | NO      | NO    |
| wait/synch/mutex/innodb/rtr_ssn_mutex                   | NO      | NO    |
| wait/synch/mutex/innodb/trx_sys_mutex                   | NO      | NO    |
| wait/synch/mutex/innodb/zip_pad_mutex                   | NO      | NO    |
| wait/synch/mutex/innodb/master_key_id_mutex             | NO      | NO    |
+---------------------------------------------------------+---------+-------+
</pre></li><li class="listitem"><p>
          一部の <code class="literal">InnoDB</code> mutex インスタンスはサーバーの起動時に作成され、関連付けられたインストゥルメントがサーバーの起動時にも有効になっている場合にのみインストゥルメントされます。 すべての <code class="literal">InnoDB</code> mutex インスタンスがインストゥルメントされ、有効になっていることを確認するには、次の <code class="literal">performance-schema-instrument</code> ルールを MySQL 構成ファイルに追加します: 
        </p><pre class="programlisting">performance-schema-instrument='wait/synch/mutex/innodb/%=ON'
</pre><p>
          すべての <code class="literal">InnoDB</code> mutex の待機イベントデータが不要な場合は、MySQL 構成ファイルに <code class="literal">performance-schema-instrument</code> ルールを追加することで、特定のインストゥルメントを無効にできます。 たとえば、全文検索に関連する <code class="literal">InnoDB</code> mutex 待機イベントインストゥルメントを無効にするには、次のルールを追加します: 
        </p><pre class="programlisting">performance-schema-instrument='wait/synch/mutex/innodb/fts%=OFF'
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">wait/synch/mutex/innodb/fts%</code> などの長い接頭辞を持つルールは、<code class="literal">wait/synch/mutex/innodb/%</code> などの短い接頭辞を持つルールよりも優先されます。
          </p></div><p>
          <code class="literal">performance-schema-instrument</code> ルールを構成ファイルに追加した後、サーバーを再起動します。 全文検索に関連するものを除くすべての <code class="literal">InnoDB</code> mutex が有効になります。 確認するには、<code class="literal">setup_instruments</code> テーブルをクエリーします。 有効にしたインストゥルメントの <code class="literal">ENABLED</code> および <code class="literal">TIMED</code> カラムを <code class="literal">YES</code> に設定する必要があります。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
       <strong class="userinput"><code>FROM performance_schema.setup_instruments</code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE '%wait/synch/mutex/innodb%';</code></strong>
+-------------------------------------------------------+---------+-------+
| NAME                                                  | ENABLED | TIMED |
+-------------------------------------------------------+---------+-------+
| wait/synch/mutex/innodb/commit_cond_mutex             | YES     | YES   |
| wait/synch/mutex/innodb/innobase_share_mutex          | YES     | YES   |
| wait/synch/mutex/innodb/autoinc_mutex                 | YES     | YES   |
...
| wait/synch/mutex/innodb/master_key_id_mutex           | YES     | YES   |
+-------------------------------------------------------+---------+-------+
49 rows in set (0.00 sec)
</pre></li><li class="listitem"><p>
          <code class="literal">setup_consumers</code> テーブルを更新して待機イベントコンシューマを有効にします。 待機イベントコンシューマはデフォルトで無効になっています。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE performance_schema.setup_consumers</code></strong>
       <strong class="userinput"><code>SET enabled = 'YES'</code></strong>
       <strong class="userinput"><code>WHERE name like 'events_waits%';</code></strong>
Query OK, 3 rows affected (0.00 sec)
Rows matched: 3  Changed: 3  Warnings: 0
</pre><p>
          待機イベントコンシューマが有効になっていることを確認するには、<code class="literal">setup_consumers</code> テーブルをクエリーします。 <code class="literal">events_waits_current</code>、<code class="literal">events_waits_history</code> および <code class="literal">events_waits_history_long</code> コンシューマを有効にする必要があります。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.setup_consumers;</code></strong>
+----------------------------------+---------+
| NAME                             | ENABLED |
+----------------------------------+---------+
| events_stages_current            | NO      |
| events_stages_history            | NO      |
| events_stages_history_long       | NO      |
| events_statements_current        | YES     |
| events_statements_history        | YES     |
| events_statements_history_long   | NO      |
| events_transactions_current      | YES     |
| events_transactions_history      | YES     |
| events_transactions_history_long | NO      |
| events_waits_current             | YES     |
| events_waits_history             | YES     |
| events_waits_history_long        | YES     |
| global_instrumentation           | YES     |
| thread_instrumentation           | YES     |
| statements_digest                | YES     |
+----------------------------------+---------+
15 rows in set (0.00 sec)
</pre></li><li class="listitem"><p>
          インストゥルメントおよびコンシューマが有効になったら、監視するワークロードを実行します。 この例では、<span class="command"><strong>mysqlslap</strong></span> ロードエミュレーションクライアントを使用してワークロードをシミュレートします。 
        </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>./mysqlslap --auto-generate-sql --concurrency=100 --iterations=10 </code></strong>
       <strong class="userinput"><code>--number-of-queries=1000 --number-char-cols=6 --number-int-cols=6;</code></strong>
</pre></li><li class="listitem"><p>
          待機イベントデータをクエリーします。 この例では、<code class="literal">events_waits_current</code>、<code class="literal">events_waits_history</code> および <code class="literal">events_waits_history_long</code> テーブルで見つかったデータを集計する <code class="literal">events_waits_summary_global_by_event_name</code> テーブルから待機イベントデータをクエリーします。 データは、イベントを生成したインストゥルメントの名前であるイベント名 (<code class="literal">EVENT_NAME</code>) 別に要約されます。 要約されたデータには次のものが含まれます: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">COUNT_STAR</code>
            </p><p>
              要約された待機イベントの数。
            </p></li><li class="listitem"><p>
              <code class="literal">SUM_TIMER_WAIT</code>
            </p><p>
              要約された時間指定待機イベントの合計待機時間。
            </p></li><li class="listitem"><p>
              <code class="literal">MIN_TIMER_WAIT</code>
            </p><p>
              要約された時間指定待機イベントの最小待機時間。
            </p></li><li class="listitem"><p>
              <code class="literal">AVG_TIMER_WAIT</code>
            </p><p>
              要約された時間指定待機イベントの平均待機時間。
            </p></li><li class="listitem"><p>
              <code class="literal">MAX_TIMER_WAIT</code>
            </p><p>
              要約された時間指定待機イベントの最大待機時間。
            </p></li></ul></div><p>
          次のクエリーは、インストゥルメント名 (<code class="literal">EVENT_NAME</code>)、待機イベントの数 (<code class="literal">COUNT_STAR</code>) およびそのインストゥルメントのイベントの合計待機時間 (<code class="literal">SUM_TIMER_WAIT</code>) を返します。 待機はデフォルトでピコ秒 (1 秒に 1 兆) で時間がかかるため、待機時間は 1000000000 で除算され、待機時間がミリ秒単位で表示されます。 データは、集計された待機イベントの数 (<code class="literal">COUNT_STAR</code>) の降順で表示されます。 <code class="literal">ORDER BY</code> 句を調整して、合計待機時間でデータを順序付けできます。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT/1000000000 SUM_TIMER_WAIT_MS</code></strong>
       <strong class="userinput"><code>FROM performance_schema.events_waits_summary_global_by_event_name</code></strong>
       <strong class="userinput"><code>WHERE SUM_TIMER_WAIT &gt; 0 AND EVENT_NAME LIKE 'wait/synch/mutex/innodb/%'</code></strong>
       <strong class="userinput"><code>ORDER BY COUNT_STAR DESC;</code></strong>
+---------------------------------------------------------+------------+-------------------+
| EVENT_NAME                                              | COUNT_STAR | SUM_TIMER_WAIT_MS |
+---------------------------------------------------------+------------+-------------------+
| wait/synch/mutex/innodb/trx_mutex                       |     201111 |           23.4719 |
| wait/synch/mutex/innodb/fil_system_mutex                |      62244 |            9.6426 |
| wait/synch/mutex/innodb/redo_rseg_mutex                 |      48238 |            3.1135 |
| wait/synch/mutex/innodb/log_sys_mutex                   |      46113 |            2.0434 |
| wait/synch/mutex/innodb/trx_sys_mutex                   |      35134 |         1068.1588 |
| wait/synch/mutex/innodb/lock_mutex                      |      34872 |         1039.2589 |
| wait/synch/mutex/innodb/log_sys_write_mutex             |      17805 |         1526.0490 |
| wait/synch/mutex/innodb/dict_sys_mutex                  |      14912 |         1606.7348 |
| wait/synch/mutex/innodb/trx_undo_mutex                  |      10634 |            1.1424 |
| wait/synch/mutex/innodb/rw_lock_list_mutex              |       8538 |            0.1960 |
| wait/synch/mutex/innodb/buf_pool_free_list_mutex        |       5961 |            0.6473 |
| wait/synch/mutex/innodb/trx_pool_mutex                  |       4885 |         8821.7496 |
| wait/synch/mutex/innodb/buf_pool_LRU_list_mutex         |       4364 |            0.2077 |
| wait/synch/mutex/innodb/innobase_share_mutex            |       3212 |            0.2650 |
| wait/synch/mutex/innodb/flush_list_mutex                |       3178 |            0.2349 |
| wait/synch/mutex/innodb/trx_pool_manager_mutex          |       2495 |            0.1310 |
| wait/synch/mutex/innodb/buf_pool_flush_state_mutex      |       1318 |            0.2161 |
| wait/synch/mutex/innodb/log_flush_order_mutex           |       1250 |            0.0893 |
| wait/synch/mutex/innodb/buf_dblwr_mutex                 |        951 |            0.0918 |
| wait/synch/mutex/innodb/recalc_pool_mutex               |        670 |            0.0942 |
| wait/synch/mutex/innodb/dict_persist_dirty_tables_mutex |        345 |            0.0414 |
| wait/synch/mutex/innodb/lock_wait_mutex                 |        303 |            0.1565 |
| wait/synch/mutex/innodb/autoinc_mutex                   |        196 |            0.0213 |
| wait/synch/mutex/innodb/autoinc_persisted_mutex         |        196 |            0.0175 |
| wait/synch/mutex/innodb/purge_sys_pq_mutex              |        117 |            0.0308 |
| wait/synch/mutex/innodb/srv_sys_mutex                   |         94 |            0.0077 |
| wait/synch/mutex/innodb/ibuf_mutex                      |         22 |            0.0086 |
| wait/synch/mutex/innodb/recv_sys_mutex                  |         12 |            0.0008 |
| wait/synch/mutex/innodb/srv_innodb_monitor_mutex        |          4 |            0.0009 |
| wait/synch/mutex/innodb/recv_writer_mutex               |          1 |            0.0005 |
+---------------------------------------------------------+------------+-------------------+
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            前述の結果セットには、起動プロセス中に生成された待機イベントデータが含まれます。 このデータを除外するには、起動直後およびワークロードの実行前に <code class="literal">events_waits_summary_global_by_event_name</code> テーブルを切り捨てることができます。 ただし、切捨て操作自体では、少量の待機イベントデータが生成される場合があります。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>TRUNCATE performance_schema.events_waits_summary_global_by_event_name;</code></strong>
</pre></div></li></ol></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-monitors"></a>15.17 InnoDB モニター</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-monitor-types">15.17.1 InnoDB モニターのタイプ</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-enabling-monitors">15.17.2 InnoDB モニターの有効化</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-standard-monitor">15.17.3 InnoDB 標準モニターおよびロックモニターの出力</a></span></dt></dl></div><a class="indexterm" name="idm44761346496592"></a><a class="indexterm" name="idm44761346495152"></a><p>
    <code class="literal">InnoDB</code> モニターは、<code class="literal">InnoDB</code> の内部状態に関する情報を提供します。 この情報は、パフォーマンスチューニングに役立ちます。 
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-monitor-types"></a>15.17.1 InnoDB モニターのタイプ</h3></div></div></div><a class="indexterm" name="idm44761346490592"></a><a class="indexterm" name="idm44761346489152"></a><p>
      <code class="literal">InnoDB</code> モニターには次の 2 つのタイプがあります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">InnoDB</code> 標準モニターは、次のタイプの情報を表示します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              メインバックグラウンドスレッドによって実行される作業
            </p></li><li class="listitem"><p>
              セマフォ待機
            </p></li><li class="listitem"><p>
              最新の外部キーおよびデッドロックエラーに関するデータ
            </p></li><li class="listitem"><p>
              トランザクションのロック待機
            </p></li><li class="listitem"><p>
              アクティブなトランザクションによって保持されているテーブルおよびレコードのロック
            </p></li><li class="listitem"><p>
              保留中の I/O 操作および関連する統計
            </p></li><li class="listitem"><p>
              挿入バッファおよび適応ハッシュインデックスの統計
            </p></li><li class="listitem"><p>
              redo ログデータ
            </p></li><li class="listitem"><p>
              バッファープールの統計
            </p></li><li class="listitem"><p>
              行操作データ
            </p></li></ul></div></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> ロックモニターは、標準の <code class="literal">InnoDB</code> モニター出力の一部として追加のロック情報を出力します。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-enabling-monitors"></a>15.17.2 InnoDB モニターの有効化</h3></div></div></div><a class="indexterm" name="idm44761346471024"></a><a class="indexterm" name="idm44761346468864"></a><p>
      <code class="literal">InnoDB</code> モニターで定期出力が有効になっている場合、<code class="literal">InnoDB</code> は約 15 秒ごとに <span class="command"><strong>mysqld</strong></span> サーバーの標準エラー出力 (<code class="literal">stderr</code>) に出力を書き込みます。
    </p><p>
      <code class="literal">InnoDB</code> は、潜在的なバッファオーバーフローを回避するために、モニター出力を <code class="literal">stdout</code> または固定サイズのメモリーバッファではなく <code class="literal">stderr</code> に送信します。
    </p><p>
      Windows では、特に構成されていないかぎり、<code class="literal">stderr</code> はデフォルトのログファイルに転送されます。 出力をエラーログではなくコンソールウィンドウに送る場合は、コンソールウィンドウで <code class="option">--console</code> オプションを使用してコマンドプロンプトからサーバーを起動します。 詳細は、<a class="xref" href="server-administration.html#error-log-destination-configuration-windows" title="Windows のデフォルトのエラーログの保存先">Windows のデフォルトのエラーログの保存先</a>を参照してください。 
    </p><p>
      Unix および Unix に似たシステムでは、特に構成されていないかぎり、<code class="literal">stderr</code> は通常端末に送信されます。 詳細は、<a class="xref" href="server-administration.html#error-log-destination-configuration-unix" title="Unix および Unix-Like システムでのデフォルトのエラーログの保存先">Unix および Unix-Like システムでのデフォルトのエラーログの保存先</a>を参照してください。 
    </p><p>
      <code class="literal">InnoDB</code> モニターは、出力生成によってパフォーマンスが低下するため、実際にモニター情報を表示する場合にのみ有効にする必要があります。 また、モニター出力がエラーログに送られた場合、後でモニターを無効にしないと、ログが非常に大きくなる可能性があります。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        トラブルシューティングを支援するために、<code class="literal">InnoDB</code> は、特定の状況で <code class="literal">InnoDB</code> 標準モニターの出力を一時的に有効にします。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-troubleshooting" title="15.21 InnoDB のトラブルシューティング">セクション15.21「InnoDB のトラブルシューティング」</a>を参照してください。 
      </p></div><p>
      <code class="literal">InnoDB</code> モニターの出力は、タイムスタンプとモニター名を含むヘッダーで始まります。 例: 
    </p><pre class="programlisting">=====================================
2014-10-16 18:37:29 0x7fc2a95c1700 INNODB MONITOR OUTPUT
=====================================
</pre><p>
      ロックモニターでは、追加のロック情報が付加された同じ出力が生成されるため、<code class="literal">InnoDB</code> 標準モニターのヘッダー (<code class="literal">INNODB MONITOR OUTPUT</code>) はロックモニターにも使用されます。
    </p><p>
      <code class="literal">innodb_status_output</code> および <code class="literal">innodb_status_output_locks</code> システム変数は、標準の <code class="literal">InnoDB</code> モニターおよび <code class="literal">InnoDB</code> ロックモニターを有効にするために使用されます。
    </p><p>
      <code class="literal">InnoDB</code> モニターを有効または無効にするには、<code class="literal">PROCESS</code> 権限が必要です。
    </p><h4><a name="idm44761346439040"></a>InnoDB 標準モニターの有効化</h4><p>
      <code class="literal">innodb_status_output</code> システム変数を <code class="literal">ON</code> に設定して、標準の <code class="literal">InnoDB</code> モニターを有効にします。
    </p><pre class="programlisting">SET GLOBAL innodb_status_output=ON;
</pre><p>
      <code class="literal">InnoDB</code> 標準モニターを無効にするには、<code class="literal">innodb_status_output</code> を <code class="literal">OFF</code> に設定します。
    </p><p>
      サーバーをシャットダウンすると、<code class="literal">innodb_status_output</code> 変数がデフォルトの <code class="literal">OFF</code> 値に設定されます。
    </p><h4><a name="idm44761346429216"></a>InnoDB ロックモニターの有効化</h4><p>
      <code class="literal">InnoDB</code> ロックモニターのデータは、<code class="literal">InnoDB</code> 標準モニターの出力とともに出力されます。 <code class="literal">InnoDB</code> ロックモニターデータを定期的に印刷するには、<code class="literal">InnoDB</code> 標準モニターと <code class="literal">InnoDB</code> ロックモニターの両方を有効にする必要があります。 
    </p><p>
      <code class="literal">InnoDB</code> ロックモニターを有効にするには、<code class="literal">innodb_status_output_locks</code> システム変数を <code class="literal">ON</code> に設定します。 <code class="literal">InnoDB</code> ロックモニターデータを定期的に印刷するには、<code class="literal">InnoDB</code> 標準モニターと <code class="literal">InnoDB</code> ロックモニターの両方を有効にする必要があります: 
    </p><pre class="programlisting">SET GLOBAL innodb_status_output=ON;
SET GLOBAL innodb_status_output_locks=ON;
</pre><p>
      <code class="literal">InnoDB</code> ロックモニターを無効にするには、<code class="literal">innodb_status_output_locks</code> を <code class="literal">OFF</code> に設定します。 <code class="literal">InnoDB</code> Standard Monitor も無効にするには、<code class="literal">innodb_status_output</code> を <code class="literal">OFF</code> に設定します。 
    </p><p>
      サーバーをシャットダウンすると、<code class="literal">innodb_status_output</code> および <code class="literal">innodb_status_output_locks</code> 変数がデフォルトの <code class="literal">OFF</code> 値に設定されます。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">SHOW ENGINE INNODB STATUS</code> 出力の <code class="literal">InnoDB</code> ロックモニターを有効にするには、<code class="literal">innodb_status_output_locks</code> を有効にする必要があります。
      </p></div><h4><a name="idm44761346404928"></a>オンデマンドでの InnoDB 標準モニターの出力の取得</h4><p>
      <code class="literal">InnoDB</code> 標準モニターでの定期的な出力を有効にする代わりに、出力をクライアントプログラムにフェッチする <code class="literal">SHOW ENGINE INNODB STATUS</code> SQL ステートメントを使用して、オンデマンドで <code class="literal">InnoDB</code> 標準モニターの出力を取得できます。 <span class="command"><strong>mysql</strong></span> 対話型クライアントを使用している場合は、通常のセミコロンのステートメントターミネータを <code class="literal">\G</code> に置き換えると、出力が読み取りやすくなります。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW ENGINE INNODB STATUS\G</code></strong>
</pre><p>
      <code class="literal">InnoDB</code> ロックモニターが有効になっている場合、<code class="literal">SHOW ENGINE INNODB STATUS</code> 出力には <code class="literal">InnoDB</code> ロックモニターデータも含まれます。
    </p><h4><a name="idm44761346393824"></a>標準の InnoDB モニター出力のステータスファイルへの送信</h4><p>
      起動時に <code class="option">--innodb-status-file</code> オプションを指定すると、標準の <code class="literal">InnoDB</code> モニター出力を有効にしてステータスファイルに送ることができます。 このオプションを使用すると、<code class="literal">InnoDB</code> はデータディレクトリに <code class="filename">innodb_status.<em class="replaceable"><code>pid</code></em></code> という名前のファイルを作成し、約 15 秒ごとに出力を書き込みます。 
    </p><p>
      サーバーが正常に停止されると、<code class="literal">InnoDB</code> によってステータスファイルが削除されます。 異常停止が発生した場合は、ステータスファイルを手動で削除する必要がある場合があります。 
    </p><p>
      <code class="option">--innodb-status-file</code> オプションは一時的な使用を目的としています。出力生成はパフォーマンスに影響を与える可能性があり、<code class="filename">innodb_status.<em class="replaceable"><code>pid</code></em></code> ファイルは時間の経過とともに非常に大きくなる可能性があるためです。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-standard-monitor"></a>15.17.3 InnoDB 標準モニターおよびロックモニターの出力</h3></div></div></div><a class="indexterm" name="idm44761346383952"></a><a class="indexterm" name="idm44761346381936"></a><a class="indexterm" name="idm44761346379904"></a><a class="indexterm" name="idm44761346378448"></a><p>
      ロックモニタは、追加のロック情報が含まれている点を除き、標準モニタと同じです。 どちらのモニターの定期的な出力を有効にしても、同じ出力ストリームが有効になりますが、ロックモニターが有効になっている場合は、そのストリームに追加の情報が含まれます。 たとえば、標準モニタとロックモニタをイネーブルにすると、1 つの出力ストリームがオンになります。 ロックモニターを無効にするまで、そのストリームには追加のロック情報が含まれます。 
    </p><p>
      <code class="literal">SHOW ENGINE INNODB STATUS</code> ステートメントを使用して生成される場合、標準モニター出力は 1MB に制限されます。 この制限は、サーバー標準エラー出力 (<code class="literal">stderr</code>) に書き込まれる出力には適用されません。 
    </p><p>
      標準モニターの出力例:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW ENGINE INNODB STATUS\G</code></strong>
*************************** 1. row ***************************
  Type: InnoDB
  Name:
Status:
=====================================
2018-04-12 15:14:08 0x7f971c063700 INNODB MONITOR OUTPUT
=====================================
Per second averages calculated from the last 4 seconds
-----------------
BACKGROUND THREAD
-----------------
srv_master_thread loops: 15 srv_active, 0 srv_shutdown, 1122 srv_idle
srv_master_thread log flush and writes: 0
----------
SEMAPHORES
----------
OS WAIT ARRAY INFO: reservation count 24
OS WAIT ARRAY INFO: signal count 24
RW-shared spins 4, rounds 8, OS waits 4
RW-excl spins 2, rounds 60, OS waits 2
RW-sx spins 0, rounds 0, OS waits 0
Spin rounds per wait: 2.00 RW-shared, 30.00 RW-excl, 0.00 RW-sx
------------------------
LATEST FOREIGN KEY ERROR
------------------------
2018-04-12 14:57:24 0x7f97a9c91700 Transaction:
TRANSACTION 7717, ACTIVE 0 sec inserting
mysql tables in use 1, locked 1
4 lock struct(s), heap size 1136, 3 row lock(s), undo log entries 3
MySQL thread id 8, OS thread handle 140289365317376, query id 14 localhost root update
INSERT INTO child VALUES (NULL, 1), (NULL, 2), (NULL, 3), (NULL, 4), (NULL, 5), (NULL, 6)
Foreign key constraint fails for table `test`.`child`:
,
  CONSTRAINT `child_ibfk_1` FOREIGN KEY (`parent_id`) REFERENCES `parent` (`id`) ON DELETE
  CASCADE ON UPDATE CASCADE
Trying to add in child table, in index par_ind tuple:
DATA TUPLE: 2 fields;
 0: len 4; hex 80000003; asc     ;;
 1: len 4; hex 80000003; asc     ;;

But in parent table `test`.`parent`, in index PRIMARY,
the closest match we can find is record:
PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000004; asc     ;;
 1: len 6; hex 000000001e19; asc       ;;
 2: len 7; hex 81000001110137; asc       7;;

------------
TRANSACTIONS
------------
Trx id counter 7748
Purge done for trx's n:o &lt; 7747 undo n:o &lt; 0 state: running but idle
History list length 19
LIST OF TRANSACTIONS FOR EACH SESSION:
---TRANSACTION 421764459790000, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 7747, ACTIVE 23 sec starting index read
mysql tables in use 1, locked 1
LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s)
MySQL thread id 9, OS thread handle 140286987249408, query id 51 localhost root updating
DELETE FROM t WHERE i = 1
------- TRX HAS BEEN WAITING 23 SEC FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 4 page no 4 n bits 72 index GEN_CLUST_INDEX of table `test`.`t`
trx id 7747 lock_mode X waiting
Record lock, heap no 3 PHYSICAL RECORD: n_fields 4; compact format; info bits 0
 0: len 6; hex 000000000202; asc       ;;
 1: len 6; hex 000000001e41; asc      A;;
 2: len 7; hex 820000008b0110; asc        ;;
 3: len 4; hex 80000001; asc     ;;

------------------
TABLE LOCK table `test`.`t` trx id 7747 lock mode IX
RECORD LOCKS space id 4 page no 4 n bits 72 index GEN_CLUST_INDEX of table `test`.`t`
trx id 7747 lock_mode X waiting
Record lock, heap no 3 PHYSICAL RECORD: n_fields 4; compact format; info bits 0
 0: len 6; hex 000000000202; asc       ;;
 1: len 6; hex 000000001e41; asc      A;;
 2: len 7; hex 820000008b0110; asc        ;;
 3: len 4; hex 80000001; asc     ;;

--------
FILE I/O
--------
I/O thread 0 state: waiting for i/o request (insert buffer thread)
I/O thread 1 state: waiting for i/o request (log thread)
I/O thread 2 state: waiting for i/o request (read thread)
I/O thread 3 state: waiting for i/o request (read thread)
I/O thread 4 state: waiting for i/o request (read thread)
I/O thread 5 state: waiting for i/o request (read thread)
I/O thread 6 state: waiting for i/o request (write thread)
I/O thread 7 state: waiting for i/o request (write thread)
I/O thread 8 state: waiting for i/o request (write thread)
I/O thread 9 state: waiting for i/o request (write thread)
Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,
 ibuf aio reads:, log i/o's:, sync i/o's:
Pending flushes (fsync) log: 0; buffer pool: 0
833 OS file reads, 605 OS file writes, 208 OS fsyncs
0.00 reads/s, 0 avg bytes/read, 0.00 writes/s, 0.00 fsyncs/s
-------------------------------------
INSERT BUFFER AND ADAPTIVE HASH INDEX
-------------------------------------
Ibuf: size 1, free list len 0, seg size 2, 0 merges
merged operations:
 insert 0, delete mark 0, delete 0
discarded operations:
 insert 0, delete mark 0, delete 0
Hash table size 553253, node heap has 0 buffer(s)
Hash table size 553253, node heap has 1 buffer(s)
Hash table size 553253, node heap has 3 buffer(s)
Hash table size 553253, node heap has 0 buffer(s)
Hash table size 553253, node heap has 0 buffer(s)
Hash table size 553253, node heap has 0 buffer(s)
Hash table size 553253, node heap has 0 buffer(s)
Hash table size 553253, node heap has 0 buffer(s)
0.00 hash searches/s, 0.00 non-hash searches/s
---
LOG
---
Log sequence number          19643450
Log buffer assigned up to    19643450
Log buffer completed up to   19643450
Log written up to            19643450
Log flushed up to            19643450
Added dirty pages up to      19643450
Pages flushed up to          19643450
Last checkpoint at           19643450
129 log i/o's done, 0.00 log i/o's/second
----------------------
BUFFER POOL AND MEMORY
----------------------
Total large memory allocated 2198863872
Dictionary memory allocated 409606
Buffer pool size   131072
Free buffers       130095
Database pages     973
Old database pages 0
Modified db pages  0
Pending reads      0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 0, not young 0
0.00 youngs/s, 0.00 non-youngs/s
Pages read 810, created 163, written 404
0.00 reads/s, 0.00 creates/s, 0.00 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 973, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
----------------------
INDIVIDUAL BUFFER POOL INFO
----------------------
---BUFFER POOL 0
Buffer pool size   65536
Free buffers       65043
Database pages     491
Old database pages 0
Modified db pages  0
Pending reads      0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 0, not young 0
0.00 youngs/s, 0.00 non-youngs/s
Pages read 411, created 80, written 210
0.00 reads/s, 0.00 creates/s, 0.00 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 491, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
---BUFFER POOL 1
Buffer pool size   65536
Free buffers       65052
Database pages     482
Old database pages 0
Modified db pages  0
Pending reads      0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 0, not young 0
0.00 youngs/s, 0.00 non-youngs/s
Pages read 399, created 83, written 194
0.00 reads/s, 0.00 creates/s, 0.00 writes/s
No buffer pool page gets since the last printout
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 482, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
--------------
ROW OPERATIONS
--------------
0 queries inside InnoDB, 0 queries in queue
0 read views open inside InnoDB
Process ID=5772, Main thread ID=140286437054208 , state=sleeping
Number of rows inserted 57, updated 354, deleted 4, read 4421
0.00 inserts/s, 0.00 updates/s, 0.00 deletes/s, 0.00 reads/s
----------------------------
END OF INNODB MONITOR OUTPUT
============================
</pre><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-standard-monitor-output-sections"></a>標準モニター出力セクション</h4></div></div></div><a class="indexterm" name="idm44761346355488"></a><p>
        標準モニターによってレポートされる各メトリックの詳細は、<a class="ulink" href="http://dev.mysql.com/doc/mysql-em-plugin/en/" target="_top">「Oracle Enterprise Manager for MySQL データベースユーザーガイド」</a>の<a class="ulink" href="http://dev.mysql.com/doc/mysql-em-plugin/en/myoem-metrics.html" target="_top">「メトリック」</a>の章を参照してください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Status</code>
          </p><p>
            このセクションは、タイムスタンプ、モニター名、および 1 秒あたりの平均の基になる秒数を示します。 この秒数は、現在の時間と <code class="literal">InnoDB</code> モニターの出力が最後に出力された時間の間の経過時間です。 
          </p></li><li class="listitem"><p>
            <code class="literal">BACKGROUND THREAD</code>
          </p><p>
            <code class="literal">srv_master_thread</code> 行は、メインのバックグラウンドスレッドによって実行された作業を示します。
          </p></li><li class="listitem"><p>
            <code class="literal">SEMAPHORES</code>
          </p><p>
            このセクションは、セマフォーを待機しているスレッド、およびスレッドが相互排他ロックまたは読み書きロックセマフォーでスピンまたは待機を必要とした回数に関する統計をレポートします。 多数のスレッドがセマフォーを待機している場合は、ディスク I/O または <code class="literal">InnoDB</code> 内部の競合の問題の結果である可能性があります。 競合は、クエリーの高い並列性、またはオペレーティングシステムのスレッドスケジューリングでの問題が原因である場合があります。 このような状況では、<code class="literal">innodb_thread_concurrency</code> システム変数をデフォルト値より小さい値に設定すると役立つことがあります。 <code class="literal">Spin rounds per wait</code> 行は、相互排他ロックでの OS ウェイトあたりのスピンロックラウンドの数を示します。 
          </p><p>
            相互排他メトリックは、<code class="literal">SHOW ENGINE INNODB MUTEX</code> によってレポートされます。
          </p></li><li class="listitem"><p>
            <code class="literal">LATEST FOREIGN KEY ERROR</code>
          </p><p>
            このセクションは、最新の外部キー制約エラーに関する情報を提供します。 このようなエラーが発生していない場合は存在しません。 その内容には、失敗したステートメントのほか、失敗した制約や、参照されるテーブルと参照するテーブルに関する情報が含まれます。 
          </p></li><li class="listitem"><p>
            <code class="literal">LATEST DETECTED DEADLOCK</code>
          </p><p>
            このセクションは、最新のデッドロックに関する情報を提供します。 デッドロックが発生していない場合は存在しません。 その内容には、関連しているトランザクション、各トランザクションが実行しようとしていたステートメント、それぞれが保持しているロックと必要なロック、およびデッドロックを解消するために <code class="literal">InnoDB</code> がロールバックすることを決定したトランザクションが示されます。 このセクションでレポートされるロックモードについては、<a class="xref" href="innodb-storage-engine.html#innodb-locking" title="15.7.1 InnoDB ロック">セクション15.7.1「InnoDB ロック」</a>で説明されています。 
          </p></li><li class="listitem"><p>
            <code class="literal">TRANSACTIONS</code>
          </p><p>
            このセクションでロック待機がレポートされている場合は、アプリケーションでロック競合が発生している可能性があります。 この出力はまた、トランザクションデッドロックの原因の追跡にも役立つことがあります。 
          </p></li><li class="listitem"><p>
            <code class="literal">FILE I/O</code>
          </p><p>
            このセクションは、<code class="literal">InnoDB</code> がさまざまなタイプの I/O を実行するために使用するスレッドに関する情報を提供します。 このうちの最初の数行は、<code class="literal">InnoDB</code> の一般的な処理に専用に使用されます。 この内容には、保留中の I/O 操作や I/O パフォーマンスの統計に関する情報も表示されます。 
          </p><p>
            これらのスレッドの数は、<code class="literal">innodb_read_io_threads</code> および <code class="literal">innodb_write_io_threads</code> パラメータによって制御されます。 <a class="xref" href="innodb-storage-engine.html#innodb-parameters" title="15.14 InnoDB の起動オプションおよびシステム変数">セクション15.14「InnoDB の起動オプションおよびシステム変数」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">INSERT BUFFER AND ADAPTIVE HASH INDEX</code>
          </p><p>
            このセクションでは、<code class="literal">InnoDB</code> 挿入バッファ (<a class="link" href="glossary.html#glos_change_buffer" title="変更バッファー">change buffer</a> とも呼ばれる) および適応ハッシュインデックスのステータスを示します。
          </p><p>
            関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-change-buffer" title="15.5.2 変更バッファ">セクション15.5.2「変更バッファ」</a>,および<a class="xref" href="innodb-storage-engine.html#innodb-adaptive-hash" title="15.5.3 適応型ハッシュインデックス">セクション15.5.3「適応型ハッシュインデックス」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">LOG</code>
          </p><p>
            このセクションには、<code class="literal">InnoDB</code> のログに関する情報が表示されます。 その内容には、現在のログシーケンス番号、ログがディスクにフラッシュされた範囲、および <code class="literal">InnoDB</code> が最後にチェックポイントを取得した位置が含まれます。 (<a class="xref" href="innodb-storage-engine.html#innodb-checkpoints" title="15.11.3 InnoDB チェックポイント">セクション15.11.3「InnoDB チェックポイント」</a>を参照してください。) このセクションには、保留中の書き込みや書き込みパフォーマンスの統計に関する情報も表示されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">BUFFER POOL AND MEMORY</code>
          </p><p>
            このセクションは、読み取られたページと書き込まれたページに関する統計を提供します。 これらの数値から、現在クエリーが実行しているデータファイル I/O 操作の数を計算できます。 
          </p><p>
            バッファープールの統計情報については、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-monitoring" title="InnoDB 標準モニターを使用したバッファープールのモニタリング">InnoDB 標準モニターを使用したバッファープールのモニタリング</a> を参照してください。 バッファープールの操作の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool" title="15.5.1 バッファプール">セクション15.5.1「バッファプール」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">ROW OPERATIONS</code>
          </p><p>
            このセクションは、メインスレッドが実行している内容 (各タイプの行操作の数とパフォーマンスレートを含む) を示します。
          </p></li></ul></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-backup-recovery"></a>15.18 InnoDB のバックアップとリカバリ</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-backup">15.18.1 InnoDB バックアップ</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-recovery">15.18.2 InnoDB のリカバリ</a></span></dt></dl></div><p>
    このセクションでは、<code class="literal">InnoDB</code> のバックアップおよびリカバリに関連するトピックについて説明します。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">InnoDB</code> に適用可能なバックアップ方法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-backup" title="15.18.1 InnoDB バックアップ">セクション15.18.1「InnoDB バックアップ」</a> を参照してください。
      </p></li><li class="listitem"><p>
        point-in-time リカバリ、ディスク障害または破損からのリカバリ、および <code class="literal">InnoDB</code> によるクラッシュリカバリの実行方法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-recovery" title="15.18.2 InnoDB のリカバリ">セクション15.18.2「InnoDB のリカバリ」</a> を参照してください。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-backup"></a>15.18.1 InnoDB バックアップ</h3></div></div></div><a class="indexterm" name="idm44761346294960"></a><a class="indexterm" name="idm44761346292848"></a><p>
      安全なデータベース管理の鍵は、定期的なバックアップを作成することです。 データ量、MySQL サーバーの数およびデータベースワークロードに応じて、これらのバックアップ手法を単独または組み合せて使用できます: MySQL サーバーの停止中にファイルをコピーして <a class="link" href="glossary.html#glos_hot_backup" title="ホットバックアップ">hot backup</a> with <span class="emphasis"><em>MySQL Enterprise Backup</em></span>; <a class="link" href="glossary.html#glos_cold_backup" title="コールドバックアップ">cold backup</a>; <a class="link" href="glossary.html#glos_logical_backup" title="論理バックアップ">logical backup</a> with <span class="command"><strong>mysqldump</strong></span> for small data volumes or record the structure of schema objects. ホットバックアップとコールドバックアップは、実際のデータファイルをコピーする <a class="link" href="glossary.html#glos_physical_backup" title="物理バックアップ">physical backups</a> です。これは、リストアを高速化するために <span class="command"><strong>mysqld</strong></span> サーバーで直接使用できます。 
    </p><p>
      <code class="literal">InnoDB</code> データをバックアップするには、<span class="emphasis"><em>MySQL Enterprise Backup</em></span> を使用することをお薦めします。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">InnoDB</code> では、サードパーティのバックアップツールを使用してリストアされるデータベースはサポートされていません。
      </p></div><h4><a name="idm44761346280432"></a>ホットバックアップ</h4><p>
      MySQL Enterprise Backup コンポーネントの一部である <span class="command"><strong>mysqlbackup</strong></span> コマンドを使用すると、実行中の MySQL インスタンス (<code class="literal">InnoDB</code> テーブルを含む) を操作の中断を最小限に抑えながらバックアップし、データベースの一貫性のあるスナップショットを生成できます。 <span class="command"><strong>mysqlbackup</strong></span> が <code class="literal">InnoDB</code> テーブルをコピーする場合、<code class="literal">InnoDB</code> テーブルに対する読取りおよび書込みを続行できます。 MySQL Enterprise Backup はまた、圧縮バックアップファイルを作成したり、テーブルやデータベースのサブセットをバックアップしたりすることもできます。 ユーザーは、MySQL バイナリログと組み合わせてポイントインタイムリカバリを実行できます。 MySQL Enterprise Backup は、MySQL Enterprise サブスクリプションの一部です。 詳細は、<a class="xref" href="mysql-enterprise.html#mysql-enterprise-backup" title="30.2 MySQL Enterprise Backup の概要">セクション30.2「MySQL Enterprise Backup の概要」</a>を参照してください。 
    </p><h4><a name="idm44761346273712"></a>コールドバックアップ</h4><p>
      MySQL サーバーを停止できる場合は、<code class="literal">InnoDB</code> がテーブルの管理に使用するすべてのファイルで構成される物理バックアップを作成できます。 次の手順を使用します。 
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          MySQL サーバーの <a class="link" href="glossary.html#glos_slow_shutdown" title="低速シャットダウン">slow shutdown</a> を実行し、エラーなしで停止していることを確認します。
        </p></li><li class="listitem"><p>
          すべての <code class="literal">InnoDB</code> データファイル (<code class="filename">ibdata</code> ファイルおよび <code class="filename">.ibd</code> ファイル) を安全な場所にコピーします。
        </p></li><li class="listitem"><p>
          すべての <code class="literal">InnoDB</code> ログファイル (<code class="filename">ib_logfile</code> ファイル) を安全な場所にコピーします。
        </p></li><li class="listitem"><p>
          1 つまたは複数の <code class="filename">my.cnf</code> 構成ファイルを安全な場所にコピーします。
        </p></li></ol></div><h4><a name="idm44761346261424"></a>mysqldump を使用した論理バックアップ</h4><p>
      物理バックアップに加えて、<span class="command"><strong>mysqldump</strong></span> を使用してテーブルをダンプすることで、論理バックアップを定期的に作成することをお薦めします。 バイナリファイルは、気付かないうちに破損することがあります。 ダンプされたテーブルは人間が読むことのできるテキストファイルに格納されるため、テーブルの破損を見つけることが容易になります。 また、形式が単純であるため、重大なデータ破損につながる可能性も少なくなります。<span class="command"><strong>mysqldump</strong></span> には、ほかのクライアントをロックすることなく、整合性のあるスナップショットを作成するための <code class="option">--single-transaction</code> オプションも用意されています。 <a class="xref" href="backup-and-recovery.html#backup-policy" title="7.3.1 バックアップポリシーの確立">セクション7.3.1「バックアップポリシーの確立」</a>を参照してください。 
    </p><p>
      レプリケーションは <code class="literal">InnoDB</code> テーブルと連携して動作するため、MySQL のレプリケーション機能を使用して、データベースのコピーを高可用性が必要なデータベースサイトに保持できます。 <a class="xref" href="innodb-storage-engine.html#innodb-and-mysql-replication" title="15.19 InnoDB と MySQL レプリケーション">セクション15.19「InnoDB と MySQL レプリケーション」</a>を参照してください。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-recovery"></a>15.18.2 InnoDB のリカバリ</h3></div></div></div><a class="indexterm" name="idm44761346252432"></a><a class="indexterm" name="idm44761346250432"></a><p>
      このセクションでは、<code class="literal">InnoDB</code> のリカバリについて説明します。 内容は次のとおりです: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-recovery-point-in-time" title="Point-in-Time リカバリ">Point-in-Time リカバリ</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-corruption-disk-failure-recovery" title="データ破損またはディスク障害からのリカバリ">データ破損またはディスク障害からのリカバリ</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-crash-recovery" title="InnoDB のクラッシュリカバリ">InnoDB のクラッシュリカバリ</a></p></li><li class="listitem"><p><a class="xref" href="innodb-storage-engine.html#innodb-recovery-tablespace-discovery" title="クラッシュリカバリ中のテーブルスペースの検出">クラッシュリカバリ中のテーブルスペースの検出</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-recovery-point-in-time"></a>Point-in-Time リカバリ</h4></div></div></div><a class="indexterm" name="idm44761346241408"></a><a class="indexterm" name="idm44761346239264"></a><p>
        物理バックアップが作成された時点から <code class="literal">InnoDB</code> データベースをリカバリするには、バックアップを取得する前でも、バイナリロギングを有効にして MySQL サーバーを実行する必要があります。 バックアップをリストアしたあとにポイントインタイムリカバリを実現するには、バックアップが作成されたあとに発生した変更をバイナリログから適用できます。 <a class="xref" href="backup-and-recovery.html#point-in-time-recovery" title="7.5 Point-in-Time (増分) リカバリ">セクション7.5「Point-in-Time (増分) リカバリ」</a>を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-corruption-disk-failure-recovery"></a>データ破損またはディスク障害からのリカバリ</h4></div></div></div><a class="indexterm" name="idm44761346233376"></a><a class="indexterm" name="idm44761346231264"></a><a class="indexterm" name="idm44761346229264"></a><a class="indexterm" name="idm44761346227328"></a><p>
        データベースが破損するか、またはディスク障害が発生した場合は、バックアップを使用してリカバリを実行する必要があります。 破損の場合は、まず、破損していないバックアップを見つけます。 ベースバックアップをリストアしたあと、<span class="command"><strong>mysqlbinlog</strong></span> および <span class="command"><strong>mysql</strong></span> を使用してバイナリログファイルからポイントインタイムリカバリを実行することにより、バックアップが作成されたあとに発生した変更をリストアします。 
      </p><p>
        データベース破損の場合によっては、破損したテーブルの 1 つまたはいくつかをダンプ、削除および再作成するだけで十分です。 <code class="literal">CHECK TABLE</code> ステートメントを使用して、テーブルが破損しているかどうかを確認できますが、<code class="literal">CHECK TABLE</code> では、すべての種類の破損を自然に検出できません。 
      </p><p>
        場合によっては、見た目はデータベースページの破損だが、実際にはオペレーティングシステムによる独自のファイルキャッシュの破損であり、ディスク上のデータは正常であることがあります。 最初にコンピュータを再起動することをお勧めします。 それにより、データベースページの破損に見えたエラーが解消される可能性があります。 <code class="literal">InnoDB</code> の一貫性の問題が原因で MySQL の起動にまだ問題がある場合は、<a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="15.21.2 InnoDB のリカバリの強制的な実行">セクション15.21.2「InnoDB のリカバリの強制的な実行」</a> でインスタンスをリカバリモードで起動するステップを参照してください。これにより、データをダンプできます。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-crash-recovery"></a>InnoDB のクラッシュリカバリ</h4></div></div></div><a class="indexterm" name="idm44761346215072"></a><a class="indexterm" name="idm44761346212928"></a><p>
        予期しない MySQL サーバーの終了からリカバリするには、MySQL サーバーを再起動する必要があります。 <code class="literal">InnoDB</code> はログを自動的にチェックし、データベースの現時点へのロールフォワードを実行します。 <code class="literal">InnoDB</code> は、クラッシュの時点で存在していたコミットされていないトランザクションを自動的にロールバックします。 リカバリ中、<span class="command"><strong>mysqld</strong></span> には次のような出力が表示されます: 
      </p><pre class="programlisting">InnoDB: The log sequence number 664050266 in the system tablespace does not match
the log sequence number 685111586 in the ib_logfiles!
InnoDB: Database was not shutdown normally!
InnoDB: Starting crash recovery.
InnoDB: Using 'tablespaces.open.2' max LSN: 664075228
InnoDB: Doing recovery: scanned up to log sequence number 690354176
InnoDB: Doing recovery: scanned up to log sequence number 695597056
InnoDB: Doing recovery: scanned up to log sequence number 700839936
InnoDB: Doing recovery: scanned up to log sequence number 706082816
InnoDB: Doing recovery: scanned up to log sequence number 711325696
InnoDB: Doing recovery: scanned up to log sequence number 713458156
InnoDB: Applying a batch of 1467 redo log records ...
InnoDB: 10%
InnoDB: 20%
InnoDB: 30%
InnoDB: 40%
InnoDB: 50%
InnoDB: 60%
InnoDB: 70%
InnoDB: 80%
InnoDB: 90%
InnoDB: 100%
InnoDB: Apply batch completed!
InnoDB: 1 transaction(s) which must be rolled back or cleaned up in total 561887 row
operations to undo
InnoDB: Trx id counter is 4096
...
InnoDB: 8.0.1 started; log sequence number 713458156
InnoDB: Waiting for purge to start
InnoDB: Starting in background the rollback of uncommitted transactions
InnoDB: Rolling back trx with id 3596, 561887 rows to undo
...
./mysqld: ready for connections....
</pre><a class="indexterm" name="idm44761346205248"></a><p>
        <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>は、次のいくつかのステップで構成されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブルスペースの検出
          </p><p>
            テーブルスペース検出は、redo ログアプリケーションを必要とするテーブルスペースを識別するために <code class="literal">InnoDB</code> で使用されるプロセスです。 <a class="xref" href="innodb-storage-engine.html#innodb-recovery-tablespace-discovery" title="クラッシュリカバリ中のテーブルスペースの検出">クラッシュリカバリ中のテーブルスペースの検出</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">Redo log</a> アプリケーション
          </p><p>
            redo ログアプリケーションは、接続を受け入れる前に初期化中に実行されます。 停止またはクラッシュ時にすべての変更が <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> から <a class="link" href="glossary.html#glos_tablespace" title="テーブルスペース">tablespaces</a> (<code class="filename">ibdata*</code> および <code class="filename">*.ibd</code> ファイル) にフラッシュされた場合、redo ログアプリケーションはスキップされます。 起動時に redo ログファイルが欠落している場合、<code class="literal">InnoDB</code> は redo ログアプリケーションもスキップします。 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                現在の最大自動増分カウンタ値は、値が変更されるたびに redo ログに書き込まれるため、クラッシュが安全になります。 リカバリ中に、<code class="literal">InnoDB</code> は redo ログをスキャンしてカウンタ値の変更を収集し、インメモリーテーブルオブジェクトに変更を適用します。 
              </p><p>
                <code class="literal">InnoDB</code> による自動増分値の処理方法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-handling" title="15.6.1.6 InnoDB での AUTO_INCREMENT 処理">セクション15.6.1.6「InnoDB での AUTO_INCREMENT 処理」</a> および <a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-initialization" title="InnoDB AUTO_INCREMENT カウンタの初期化">InnoDB AUTO_INCREMENT カウンタの初期化</a> を参照してください。
              </p></li><li class="listitem"><p>
                インデックスツリーの破損が発生すると、<code class="literal">InnoDB</code> は破損フラグを redo ログに書き込み、破損フラグをクラッシュセーフにします。 また、<code class="literal">InnoDB</code> は、インメモリー破損フラグデータを各チェックポイントのエンジン専用システムテーブルに書き込みます。 リカバリ中、<code class="literal">InnoDB</code> は、インメモリーテーブルおよびインデックスオブジェクトを破損としてマークする前に、両方の場所から破損フラグを読み取り、結果をマージします。 
              </p></li><li class="listitem"><p>
                redo ログを削除してリカバリを高速化することは、一部のデータ損失が許容される場合でもお薦めしません。 redo ログの削除は、<code class="literal">innodb_fast_shutdown</code> を <code class="literal">0</code> または <code class="literal">1</code> に設定してクリーンシャットダウンした後にのみ考慮する必要があります。 
              </p></li></ul></div></li><li class="listitem"><p>
            不完全な <a class="link" href="glossary.html#glos_transaction" title="トランザクション">transactions</a> の <a class="link" href="glossary.html#glos_rollback" title="ロールバック">Roll back</a>
          </p><p>
            未完了のトランザクションは、予期しない終了時または <a class="link" href="glossary.html#glos_fast_shutdown" title="高速シャットダウン">fast shutdown</a> でアクティブだったトランザクションです。 未完了のトランザクションをロールバックするためにかかる時間は、サーバーの負荷に応じて、そのトランザクションが中断される前にアクティブであった期間の 3 または 4 倍になる場合があります。 
          </p><p>
            ロールバックされているトランザクションは取り消せません。 極端なケースとして、トランザクションのロールバックに膨大な時間がかかると予測される場合は、<code class="literal">innodb_force_recovery</code> の設定を <code class="literal">3</code> 以上にして <code class="literal">InnoDB</code> を起動した方が速いことがあります。 <a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="15.21.2 InnoDB のリカバリの強制的な実行">セクション15.21.2「InnoDB のリカバリの強制的な実行」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <a class="link" href="glossary.html#glos_change_buffer" title="変更バッファー">Change buffer</a> マージ
          </p><p>
            インデックスページがバッファプールに読み込まれるため、変更バッファ (<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">system tablespace</a> の一部) からセカンダリインデックスのリーフページに変更を適用します。
          </p></li><li class="listitem"><p>
            <a class="link" href="glossary.html#glos_purge" title="パージ">Purge</a>
          </p><p>
            アクティブなトランザクションに表示されなくなった削除マーク付きレコードを削除しています。
          </p></li></ul></div><p>
        Redo ログの適用に続く各ステップは (書き込みのロギングを除き) Redo ログには依存しないため、通常の処理では並列に実行されます。 これらのうち、クラッシュリカバリに固有なのは未完了のトランザクションのロールバックだけです。 挿入バッファーのマージとパージは、通常の処理中に実行されます。 
      </p><p>
        Redo ログの適用のあと、<code class="literal">InnoDB</code> は、ダウンタイムを短縮するために接続をできるだけ早く受け入れようとします。 クラッシュリカバリの一環として、<code class="literal">InnoDB</code> は、サーバーの終了時にコミットされなかったトランザクションまたは <code class="literal">XA PREPARE</code> 状態のトランザクションをロールバックします。 このロールバックは、新しい接続からのトランザクションと並列に実行されているバックグラウンドスレッドによって実行されます。 新しい接続では、ロールバック操作が完了するまで、リカバリされるトランザクションとのロック競合が発生する可能性があります。 
      </p><p>
        ほとんどの状況では、重いアクティビティの途中で MySQL サーバーが予期せず強制終了された場合でも、リカバリプロセスは自動的に実行され、DBA によるアクションは必要ありません。 ハードウェア障害や重大なシステムエラーのために <code class="literal">InnoDB</code> データが破損した場合は、MySQL が起動を拒否する可能性があります。 この場合は、<a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="15.21.2 InnoDB のリカバリの強制的な実行">セクション15.21.2「InnoDB のリカバリの強制的な実行」</a>を参照してください。 
      </p><p>
        バイナリログおよび <code class="literal">InnoDB</code> のクラッシュリカバリについては、<a class="xref" href="server-administration.html#binary-log" title="5.4.4 バイナリログ">セクション5.4.4「バイナリログ」</a>を参照してください。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-recovery-tablespace-discovery"></a>クラッシュリカバリ中のテーブルスペースの検出</h4></div></div></div><a class="indexterm" name="idm44761346152976"></a><a class="indexterm" name="idm44761346150880"></a><p>
        リカバリ中に、最後のチェックポイント以降に書き込まれた redo ログが <code class="literal">InnoDB</code> で検出された場合は、影響を受けるテーブルスペースに redo ログを適用する必要があります。 リカバリ中に影響を受けるテーブルスペースを識別するプロセスは、<span class="emphasis"><em>テーブルスペースの検出</em></span>と呼ばれます。 
      </p><p>
        テーブルスペースの検出は、起動時にテーブルスペースファイルをスキャンするディレクトリを定義する <code class="literal">innodb_directories</code> 設定に依存します。 <code class="literal">innodb_data_home_dir</code>、<code class="literal">innodb_undo_directory</code> および <code class="literal">datadir</code> によって定義されたディレクトリは、<code class="literal">innodb_directories</code> オプションが明示的に構成されているかどうかに関係なく、起動時にスキャンするディレクトリのリストを作成するときに <code class="literal">innodb_directories</code> 引数値に自動的に追加されます。 絶対パスで定義されたテーブルスペースファイル、または <code class="literal">innodb_directories</code> 設定に自動的に追加されたディレクトリの外部に存在するテーブルスペースファイルは、<code class="literal">innodb_directories</code> 設定に追加する必要があります。 redo ログで参照されているテーブルスペースファイルがまだ検出されていない場合、リカバリは終了します。 
      </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-and-mysql-replication"></a>15.19 InnoDB と MySQL レプリケーション</h2></div></div></div><a class="indexterm" name="idm44761346135104"></a><p>
    レプリカ上のストレージエンジンがソース上のストレージエンジンと同じでない方法でレプリケーションを使用できます。 たとえば、ソースの <code class="literal">InnoDB</code> テーブルに対する変更をレプリカの <code class="literal">MyISAM</code> テーブルにレプリケートできます。 詳細は、<a class="xref" href="replication.html#replication-solutions-diffengines" title="17.4.4 異なるソースおよびレプリカのストレージエンジンでのレプリケーションの使用">セクション17.4.4「異なるソースおよびレプリカのストレージエンジンでのレプリケーションの使用」</a> を参照してください。 
  </p><p>
    レプリカの設定の詳細は、<a class="xref" href="replication.html#replication-setup-replicas" title="17.1.2.6 レプリカの設定">セクション17.1.2.6「レプリカの設定」</a> および <a class="xref" href="replication.html#replication-snapshot-method" title="17.1.2.5 データスナップショットの方法の選択">セクション17.1.2.5「データスナップショットの方法の選択」</a> を参照してください。 ソースまたは既存のレプリカを停止せずに新しいレプリカを作成するには、<a class="link" href="mysql-enterprise.html#mysql-enterprise-backup" title="30.2 MySQL Enterprise Backup の概要">MySQL Enterprise Backup</a> 製品を使用します。 
  </p><p>
    ソースで失敗したトランザクションはレプリケーションに影響しません。 MySQL レプリケーションは、データを変更する SQL ステートメントが MySQL によって書き込まれたバイナリログに基づいています。 失敗したトランザクション (外部キー違反やロールバックされたためなど) はバイナリログに書き込まれないため、レプリカには送信されません。 <a class="xref" href="sql-statements.html#commit" title="13.3.1 START TRANSACTION、COMMIT および ROLLBACK ステートメント">セクション13.3.1「START TRANSACTION、COMMIT および ROLLBACK ステートメント」</a>を参照してください。 
  </p><p><b>レプリケーションと CASCADE. </b>
      外部キーリレーションを共有するテーブルがソースとレプリカの両方で <code class="literal">InnoDB</code> を使用する場合、ソース上の <code class="literal">InnoDB</code> テーブルのカスケードアクションはレプリカ<span class="emphasis"><em>のみ</em></span>でレプリケートされます。 これは、ステートメントベースのレプリケーションと行ベースのレプリケーションのどちらを使用している場合にも当てはまります。 レプリケーションを開始し、次の <code class="literal">CREATE TABLE</code> ステートメントを使用して、<code class="literal">InnoDB</code> がデフォルトのストレージエンジンとして定義されているソースに 2 つのテーブルを作成するとします: 
    </p><pre class="programlisting">CREATE TABLE fc1 (
    i INT PRIMARY KEY,
    j INT
);

CREATE TABLE fc2 (
    m INT PRIMARY KEY,
    n INT,
    FOREIGN KEY ni (n) REFERENCES fc1 (i)
        ON DELETE CASCADE
);
</pre><p>
    レプリカにデフォルトのストレージエンジンとして定義された <code class="literal">MyISAM</code> がある場合、レプリカ上に同じテーブルが作成されますが、それらは <code class="literal">MyISAM</code> ストレージエンジンを使用し、<code class="literal">FOREIGN KEY</code> オプションは無視されます。 次に、ソースのテーブルにいくつかの行を挿入します: 
  </p><pre class="programlisting">source&gt; <strong class="userinput"><code>INSERT INTO fc1 VALUES (1, 1), (2, 2);</code></strong>
Query OK, 2 rows affected (0.09 sec)
Records: 2  Duplicates: 0  Warnings: 0

source&gt; <strong class="userinput"><code>INSERT INTO fc2 VALUES (1, 1), (2, 2), (3, 1);</code></strong>
Query OK, 3 rows affected (0.19 sec)
Records: 3  Duplicates: 0  Warnings: 0
</pre><p>
    この時点で、次に示すように、ソースとレプリカの両方で、テーブル <code class="literal">fc1</code> には 2 行、テーブル <code class="literal">fc2</code> には 3 行が含まれます:
  </p><pre class="programlisting">source&gt; <strong class="userinput"><code>SELECT * FROM fc1;</code></strong>
+---+------+
| i | j    |
+---+------+
| 1 |    1 |
| 2 |    2 |
+---+------+
2 rows in set (0.00 sec)

source&gt; <strong class="userinput"><code>SELECT * FROM fc2;</code></strong>
+---+------+
| m | n    |
+---+------+
| 1 |    1 |
| 2 |    2 |
| 3 |    1 |
+---+------+
3 rows in set (0.00 sec)

replica&gt; <strong class="userinput"><code>SELECT * FROM fc1;</code></strong>
+---+------+
| i | j    |
+---+------+
| 1 |    1 |
| 2 |    2 |
+---+------+
2 rows in set (0.00 sec)

replica&gt; <strong class="userinput"><code>SELECT * FROM fc2;</code></strong>
+---+------+
| m | n    |
+---+------+
| 1 |    1 |
| 2 |    2 |
| 3 |    1 |
+---+------+
3 rows in set (0.00 sec)
</pre><p>
    ここで、ソースで次の <code class="literal">DELETE</code> ステートメントを実行するとします:
  </p><pre class="programlisting">source&gt; <strong class="userinput"><code>DELETE FROM fc1 WHERE i=1;</code></strong>
Query OK, 1 row affected (0.09 sec)
</pre><p>
    カスケードのため、ソースのテーブル <code class="literal">fc2</code> には 1 行のみが含まれるようになりました:
  </p><pre class="programlisting">source&gt; <strong class="userinput"><code>SELECT * FROM fc2;</code></strong>
+---+---+
| m | n |
+---+---+
| 2 | 2 |
+---+---+
1 row in set (0.00 sec)
</pre><p>
    ただし、レプリカでは <code class="literal">DELETE</code> for <code class="literal">fc1</code> は <code class="literal">fc2</code> から行を削除しないため、カスケードはレプリカに伝播されません。 <code class="literal">fc2</code> のレプリカコピーには、最初に挿入されたすべての行が引き続き含まれます: 
  </p><pre class="programlisting">replica&gt; <strong class="userinput"><code>SELECT * FROM fc2;</code></strong>
+---+---+
| m | n |
+---+---+
| 1 | 1 |
| 3 | 1 |
| 2 | 2 |
+---+---+
3 rows in set (0.00 sec)
</pre><p>
    この違いは、カスケード削除が、実際には <code class="literal">InnoDB</code> ストレージエンジンによって内部的に処理されることから来ています。つまり、どの変更もログに記録されません。
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-memcached"></a>15.20 InnoDB memcached プラグイン</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-benefits">15.20.1 InnoDB memcached プラグインの利点</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-intro">15.20.2 InnoDB memcached のアーキテクチャー</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-setup">15.20.3 InnoDB memcached プラグインの設定</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-multiple-get-range-query">15.20.4 InnoDB memcached の複数の get および Range クエリーのサポート</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-security">15.20.5 InnoDB memcached プラグインのセキュリティーに関する考慮事項</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-developing">15.20.6 InnoDB memcached プラグイン用のアプリケーションの記述</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-replication">15.20.7 InnoDB memcached プラグインとレプリケーション</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-internals">15.20.8 InnoDB memcached プラグインの内部</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-troubleshoot">15.20.9 InnoDB memcached プラグインのトラブルシューティング</a></span></dt></dl></div><a class="indexterm" name="idm44761346090496"></a><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
      <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインは、MySQL 8.0.22 の時点では非推奨です。将来のバージョンの MySQL ではサポートされなくなる予定です。
    </p></div><p>
    <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグイン (<code class="literal">daemon_memcached</code>) には、<code class="literal">InnoDB</code> テーブルのデータを自動的に格納および取得し、MySQL サーバーを高速<span class="quote">「<span class="quote">「キー/値ストア」</span>」</span>にする統合 <span class="command"><strong>memcached</strong></span> デーモンが用意されています。 SQL でクエリーを作成するかわりに、SQL 解析およびクエリー最適化計画の作成に関連するパフォーマンスオーバーヘッドを回避する単純な <code class="literal">get</code>、<code class="literal">set</code> および <code class="literal">incr</code> 操作を使用できます。 また、便宜上、複雑なクエリー、バルク操作および従来のデータベースソフトウェアのその他の長所のために、SQL を使用して同じ <code class="literal">InnoDB</code> テーブルにアクセスすることもできます。 
  </p><p>
    この <span class="quote">「<span class="quote">NoSQL スタイルの</span>」</span>インタフェースは、<span class="command"><strong>memcached</strong></span> API を使用してデータベース操作を高速化し、<code class="literal">InnoDB</code> がその<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>メカニズムを使用してメモリーキャッシュを処理します。 <code class="literal">add</code>、<code class="literal">set</code>、<code class="literal">incr</code> などの <span class="command"><strong>memcached</strong></span> 操作によって変更されたデータは、<code class="literal">InnoDB</code> テーブルのディスクに格納されます。 <span class="command"><strong>memcached</strong></span> の簡便性と <code class="literal">InnoDB</code> の信頼性および一貫性の組み合わせにより、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-benefits" title="15.20.1 InnoDB memcached プラグインの利点">セクション15.20.1「InnoDB memcached プラグインの利点」</a>で説明されている両方の優れた点がユーザーに提供されます。 アーキテクチャの概要は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-intro" title="15.20.2 InnoDB memcached のアーキテクチャー">セクション15.20.2「InnoDB memcached のアーキテクチャー」</a> を参照してください。 
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-memcached-benefits"></a>15.20.1 InnoDB memcached プラグインの利点</h3></div></div></div><p>
      このセクションでは、<code class="literal">daemon_memcached</code> プラグインの利点について概説します。 <code class="literal">InnoDB</code> テーブルと <span class="command"><strong>memcached</strong></span> を組み合せると、いずれか一方を単独で使用するよりも利点があります。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">InnoDB</code> ストレージエンジンに直接アクセスすることによって、SQL の構文解析およびプランニングのオーバーヘッドを回避できます。
        </p></li><li class="listitem"><p>
          <span class="command"><strong>memcached</strong></span> を MySQL Server と同じプロセス空間で実行することにより、リクエストを受け渡すことによるネットワークオーバーヘッドが回避されます。
        </p></li><li class="listitem"><p>
          <span class="command"><strong>memcached</strong></span> プロトコルを使用して書き込まれたデータは、MySQL SQL レイヤーを経由せずに <code class="literal">InnoDB</code> テーブルに透過的に書き込まれます。 クリティカルでないデータの更新時に RAW パフォーマンスを向上させるために、書込みの頻度を制御できます。 
        </p></li><li class="listitem"><p>
          <span class="command"><strong>memcached</strong></span> プロトコルを介してリクエストされたデータは、MySQL SQL レイヤーを経由せずに、<code class="literal">InnoDB</code> テーブルから透過的にクエリーされます。
        </p></li><li class="listitem"><p>
          同じデータに対する後続のリクエストは <code class="literal">InnoDB</code> バッファープールから提供されます。 バッファープールはインメモリーキャッシュを処理します。 <code class="literal">InnoDB</code> 構成オプションを使用して、データ集中型の操作のパフォーマンスをチューニングできます。 
        </p></li><li class="listitem"><p>
          アプリケーションのタイプに応じて、非構造化データまたは構造化データを使用できます。 データ用に新しいテーブルを作成するか、既存のテーブルを使用できます。 
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> は複数カラムの値を単一の <span class="command"><strong>memcached</strong></span> 項目値に連結したり分解したりできるため、アプリケーションで必要な文字列の構文解釈および連結の量が削減されます。 たとえば、文字列値 <code class="literal">2|4|6|8</code> を <span class="command"><strong>memcached</strong></span> キャッシュに格納し、<code class="literal">InnoDB</code> でセパレータ文字に基づいて値を分割してから、4 つの数値カラムに結果を格納できます。 
        </p></li><li class="listitem"><p>
          メモリーとディスク間の転送は自動的に処理されるため、アプリケーションロジックが簡素化されます。
        </p></li><li class="listitem"><p>
          データは MySQL データベースに格納されることで、クラッシュ、機能停止、および破損から保護されます。
        </p></li><li class="listitem"><p>
          基礎となる <code class="literal">InnoDB</code> テーブルには、レポート、分析、非定型クエリー、バルクロード、マルチステップトランザクション計算、論理和や交差などの集合演算、および SQL の表現と柔軟性に適したその他の操作のために、SQL を介してアクセスできます。
        </p></li><li class="listitem"><p>
          MySQL レプリケーションと組み合せてソースサーバーで <code class="literal">daemon_memcached</code> プラグインを使用することで、高可用性を確保できます。
        </p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <span class="command"><strong>memcached</strong></span> と MySQL の統合により、インメモリーデータを永続的にする方法が提供されるため、より重要な種類のデータに使用できます。 データが失われる可能性があることを気にすることなく、アプリケーションでより多くの <code class="literal">add</code>、<code class="literal">incr</code> および同様の書込み操作を使用できます。 キャッシュされたデータに対する更新を失わずに、<span class="command"><strong>memcached</strong></span> サーバーを停止および起動できます。 予期しない停止から保護するために、<code class="literal">InnoDB</code> のクラッシュリカバリ、レプリケーションおよびバックアップ機能を利用できます。 
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> が高速な<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>検索を実行する方法では、通常 <span class="command"><strong>memcached</strong></span> の単一項目クエリーに適合します。 <code class="literal">daemon_memcached</code> プラグインで使用される直接の低レベルのデータベースアクセスパスは、同等の SQL クエリーよりもキー値ルックアップの方がはるかに効率的です。 
        </p></li><li class="listitem"><p>
          複雑なデータ構造、バイナリファイル、またはコードブロックも格納可能な文字列に変換できる <span class="command"><strong>memcached</strong></span> のシリアライズ機能によって、このようなオブジェクトをデータベースに格納する簡単な方法が提供されます。
        </p></li><li class="listitem"><p>
          基礎となるデータには SQL を介してアクセスできるため、レポートの作成、複数のキーにわたる検索または更新、<span class="command"><strong>memcached</strong></span> データに対する <code class="literal">AVG()</code> や <code class="literal">MAX()</code> などの関数のコールが可能です。 これらの操作はすべて、<span class="command"><strong>memcached</strong></span> を単独で使用するとコストがかかり、複雑になります。 
        </p></li><li class="listitem"><p>
          起動時に <span class="command"><strong>memcached</strong></span> にデータを手動でロードする必要はありません。 特定のキーがアプリケーションによってリクエストされると、値はデータベースから自動的に取得され、<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> を使用してメモリーにキャッシュされます。 
        </p></li><li class="listitem"><p>
          <span class="command"><strong>memcached</strong></span> は CPU の消費が比較的少なく、メモリーフットプリントを管理しやすいため、同じシステム上で MySQL インスタンスとともに快適に実行できます。
        </p></li><li class="listitem"><p>
          データ整合性は通常の <code class="literal">InnoDB</code> テーブルに使用されるメカニズムによって強制されるため、キーが欠落している場合にデータベースをクエリーするために、失効した <span class="command"><strong>memcached</strong></span> データやフォールバックロジックについて心配する必要はありません。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-memcached-intro"></a>15.20.2 InnoDB memcached のアーキテクチャー</h3></div></div></div><a class="indexterm" name="idm44761346012480"></a><p>
      <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインは、MySQL SQL レイヤーをバイパスして <code class="literal">InnoDB</code> ストレージエンジンに直接アクセスする MySQL プラグインデーモンとして <span class="command"><strong>memcached</strong></span> を実装します。
    </p><p>
      次の図は、アプリケーションが SQL と比較して <code class="literal">daemon_memcached</code> プラグインを介してデータにアクセスする方法を示しています。
    </p><div class="figure"><a name="innodb-memcached-architecture-diagram"></a><p class="title"><b>図 15.4 統合 <span class="command">memcached</span> Server を使用した MySQL Server</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/innodb_memcached2.jpg" width="739" height="552" alt="SQL と memcached プロトコルの両方を使用して InnoDB ストレージエンジンのデータにアクセスするアプリケーションを示します。 SQL を使用して、アプリケーションは MySQL Server およびハンドラ API を介してデータにアクセスします。 memcached プロトコルを使用すると、アプリケーションは MySQL Server をバイパスし、memcached プラグインおよび InnoDB API を介してデータにアクセスします。 memcached プラグインは、innodb_memcache インタフェースとオプションのローカルキャッシュで構成されます。"></div></div></div><br class="figure-break"><p>
      <code class="literal">daemon_memcached</code> プラグインの機能:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <span class="command"><strong>mysqld</strong></span> のデーモンプラグインとしての <span class="command"><strong>memcached</strong></span>。 <span class="command"><strong>mysqld</strong></span> と <span class="command"><strong>memcached</strong></span> の両方が同じプロセス領域で実行され、データへの待機時間が非常に短くなります。 
        </p></li><li class="listitem"><p>
          SQL パーサー、オプティマイザ、さらにハンドラ API レイヤーもバイパスして、<code class="literal">InnoDB</code> テーブルに直接アクセスします。
        </p></li><li class="listitem"><p>
          テキストベースのプロトコルおよびバイナリプロトコルを含む標準の <span class="command"><strong>memcached</strong></span> プロトコル。 <code class="literal">daemon_memcached</code> プラグインは、<span class="command"><strong>memcapable</strong></span> コマンドの 55 の互換性テストすべてに合格します。 
        </p></li><li class="listitem"><p>
          Multi-column support. ユーザー指定のセパレータ文字で区切られたカラム値を使用して、複数のカラムをキー値ストアの <span class="quote">「<span class="quote">value</span>」</span> 部分にマップできます。 
        </p></li><li class="listitem"><p>
          デフォルトでは、<span class="command"><strong>memcached</strong></span> プロトコルを使用してデータの読取りおよび <code class="literal">InnoDB</code> への書込みが直接行われるため、MySQL は <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> を使用してインメモリーキャッシュを管理できます。 デフォルト設定は、データベースアプリケーションの高い信頼性と最も低い驚きの組合せを表します。 たとえば、デフォルト設定では、データベース側のコミットされていないデータや、<span class="command"><strong>memcached</strong></span> <code class="literal">get</code> リクエストに対して返される失効データは回避されます。 
        </p></li><li class="listitem"><p>
          上級ユーザーは、システムを従来の <span class="command"><strong>memcached</strong></span> サーバーとして構成し、すべてのデータを <span class="command"><strong>memcached</strong></span> エンジン (メモリーキャッシング) にのみキャッシュすることも、<span class="quote">「<span class="quote">「<span class="command"><strong>memcached</strong></span> エンジン」</span>」</span> (メモリーキャッシング) と <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> エンジン (<code class="literal">InnoDB</code> をバックエンド永続ストレージとして) の組合せを使用することもできます。
        </p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">innodb_api_bk_commit_interval</code>、<code class="literal">daemon_memcached_r_batch_size</code> および <code class="literal">daemon_memcached_w_batch_size</code> 構成オプションを使用して、<code class="literal">InnoDB</code> 操作と <span class="command"><strong>memcached</strong></span> 操作の間でデータがやり取りされる頻度を制御します。 信頼性を最大化するために、バッチサイズオプションのデフォルト値は 1 です。 
        </p></li><li class="listitem"><p>
          <code class="literal">daemon_memcached_option</code> 構成パラメータを使用して <span class="command"><strong>memcached</strong></span> オプションを指定する機能。 たとえば、<span class="command"><strong>memcached</strong></span> がリスニングするポートの変更、同時接続の最大数の削減、キーと値のペアの最大メモリーサイズの変更、またはエラーログのデバッグメッセージの有効化を行うことができます。 
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_api_trx_level</code> 構成オプションは、<span class="command"><strong>memcached</strong></span> で処理されるクエリーのトランザクション <a class="link" href="glossary.html#glos_isolation_level" title="分離レベル">isolation level</a> を制御します。 <span class="command"><strong>memcached</strong></span> には <a class="link" href="glossary.html#glos_transaction" title="トランザクション">transactions</a> の概念はありませんが、このオプションを使用して、<span class="command"><strong>daemon_memcached</strong></span> プラグインで使用されるテーブルに対して発行された SQL ステートメントによって発生した変更を <span class="command"><strong>memcached</strong></span> がすぐに確認する方法を制御できます。 デフォルトでは、<code class="literal">innodb_api_trx_level</code> は <code class="literal">READ UNCOMMITTED</code> に設定されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_api_enable_mdl</code> オプションを使用すると、MySQL レベルでテーブルをロックできるため、マップされたテーブルは <a class="link" href="glossary.html#glos_ddl" title="DDL">DDL</a> で SQL インタフェースを介して削除または変更できません。 ロックがない場合、テーブルは MySQL レイヤーから削除できますが、<span class="command"><strong>memcached</strong></span> または他のユーザーが使用を停止するまで <code class="literal">InnoDB</code> 記憶域に保持されます。 <span class="quote">「<span class="quote">MDL</span>」</span>は<span class="quote">「<span class="quote">メタデータロック</span>」</span>を表します。 
        </p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-compare-contrast"></a>InnoDB memcached と従来の memcached の違い</h4></div></div></div><p>
        <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached.html" target="_top">Using MySQL with <span class="command"><strong>memcached</strong></span></a> で説明されているように、MySQL での <span class="command"><strong>memcached</strong></span> の使用にすでに慣れている場合があります。 このセクションでは、統合された <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインの機能が従来の <code class="literal">memcached</code> とどのように異なるかについて説明します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            インストール: <span class="command"><strong>memcached</strong></span> ライブラリには MySQL サーバーが付属しているため、インストールと設定が比較的簡単です。 インストールには、<span class="command"><strong>memcached</strong></span> で使用する <code class="literal">demo_test</code> テーブルを作成するための <code class="filename">innodb_memcached_config.sql</code> スクリプトの実行、<code class="literal">daemon_memcached</code> プラグインを有効にするための <code class="literal">INSTALL PLUGIN</code> ステートメントの発行、MySQL 構成ファイルまたは起動スクリプトへの必要な <span class="command"><strong>memcached</strong></span> オプションの追加が含まれます。 <span class="command"><strong>memcp</strong></span>、<span class="command"><strong>memcat</strong></span>、<span class="command"><strong>memcapable</strong></span> などの追加ユーティリティ用の従来の <span class="command"><strong>memcached</strong></span> ディストリビューションをインストールすることもできます。 
          </p><p>
            従来の <span class="command"><strong>memcached</strong></span> との比較は、<a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-install.html" target="_top">Installing <span class="command"><strong>memcached</strong></span></a> を参照してください。
          </p></li><li class="listitem"><p>
            デプロイメント: 従来の <span class="command"><strong>memcached</strong></span> では、通常、大量の低容量 <span class="command"><strong>memcached</strong></span> サーバーを実行します。 ただし、<code class="literal">daemon_memcached</code> プラグインの一般的なデプロイメントでは、MySQL がすでに実行されている中程度または高電力のサーバーの数が少なくなります。 この構成の利点は、未使用のメモリーを利用したり、多数のサーバーにルックアップを分散したりするのではなく、個々のデータベースサーバーの効率を向上させることです。 デフォルト構成では、<span class="command"><strong>memcached</strong></span> に使用されるメモリーはほとんどなく、メモリー内ルックアップは <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> から提供されます。これにより、最近頻繁に使用されたデータが自動的にキャッシュされます。 従来の MySQL サーバーインスタンスと同様に、<code class="literal">innodb_buffer_pool_size</code> 構成オプションの値は、メモリー内で可能なかぎり多くの作業が実行されるように、(OS レベルでページングを発生させずに) 実用的な値にしてください。 
          </p><p>
            従来の <span class="command"><strong>memcached</strong></span> との比較は、<a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-using-deployment.html" target="_top"><span class="command"><strong>memcached</strong></span> Deployment</a> を参照してください。
          </p></li><li class="listitem"><p>
            有効期限: デフォルトでは (<code class="literal">innodb_only</code> キャッシュポリシーを使用)、<code class="literal">InnoDB</code> テーブルの最新データが常に返されるため、有効期限オプションは実用的な効果がありません。 キャッシュポリシーを <code class="literal">caching</code> または <code class="literal">cache_only</code> に変更すると、有効期限オプションは通常どおりに機能しますが、メモリーキャッシュから期限切れになる前に基礎となるテーブルで更新された場合、リクエストされたデータは失効する可能性があります。 
          </p><p>
            従来の <span class="command"><strong>memcached</strong></span> との比較は、<a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-using-expiry.html" target="_top">Data Expiry</a> を参照してください。
          </p></li><li class="listitem"><p>
            ネームスペース: <span class="command"><strong>memcached</strong></span> は、ファイルが競合しないようにするために、接頭辞と接尾辞を含む複雑な名前をファイルに付ける大規模なディレクトリに似ています。 <code class="literal">daemon_memcached</code> プラグインでは、キーに対して同様の命名規則を使用できますが、追加の命名規則もあります。 <code class="literal">@@<em class="replaceable"><code>table_id</code></em>.<em class="replaceable"><code>key</code></em></code> 形式のキー名。<em class="replaceable"><code>table_id</code></em> は、<code class="literal">innodb_memcache.containers</code> テーブルのマッピングデータを使用して、特定のテーブルを参照するようにデコードされます。 <em class="replaceable"><code>key</code></em> は指定されたテーブル内で参照されるか、このテーブルに書き込まれます。 
          </p><p>
            <code class="literal">@@</code>表記法は、<code class="literal">get</code>、<code class="literal">add</code> および <code class="literal">set</code> 関数への個々のコールに対してのみ機能し、<code class="literal">incr</code> や <code class="literal">delete</code> などの他のコールに対しては機能しません。 セッション内の後続の <span class="command"><strong>memcached</strong></span> 操作のデフォルトテーブルを指定するには、<code class="literal"><em class="replaceable"><code>table_id</code></em></code> でキー部分を指定せずに<code class="literal">@@</code>テーブル記を使用して <code class="literal">get</code> リクエストを実行します。 例: 
          </p><pre class="programlisting">get @@<em class="replaceable"><code>table_id</code></em>
</pre><p>
            後続の <code class="literal">get</code>, <code class="literal">set</code>, <code class="literal">incr</code>, <code class="literal">delete</code> およびその他の操作では、<code class="literal"><em class="replaceable"><code>table_id</code></em></code> によって <code class="literal">innodb_memcache.containers.name</code> カラムに指定されたテーブルが使用されます。
          </p><p>
            従来の <span class="command"><strong>memcached</strong></span> との比較は、<a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-using-namespaces.html" target="_top">Using Namespaces</a> を参照してください。
          </p></li><li class="listitem"><p>
            ハッシングと分散: <code class="literal">innodb_only</code> キャッシュポリシーを使用するデフォルト構成は、レプリカサーバーのセットなど、すべてのサーバーですべてのデータを使用できる従来のデプロイメント構成に適しています。
          </p><p>
            シャード構成と同様にデータを物理的に分割する場合は、<code class="literal">daemon_memcached</code> プラグインを実行している複数のマシンにデータを分割し、従来の <span class="command"><strong>memcached</strong></span> ハッシュメカニズムを使用してリクエストを特定のマシンにルーティングできます。 通常、MySQL 側では、適切な値が適切なサーバーのデータベースに格納されるように、<code class="literal">add</code> リクエストによってすべてのデータを <span class="command"><strong>memcached</strong></span> に挿入できます。 
          </p><p>
            従来の <span class="command"><strong>memcached</strong></span> との比較は、<a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-using-hashtypes.html" target="_top"><span class="command"><strong>memcached</strong></span> Hashing/Distribution Types</a> を参照してください。
          </p></li><li class="listitem"><p>
            メモリー使用量: デフォルトでは (<code class="literal">innodb_only</code> キャッシュポリシーを使用)、<span class="command"><strong>memcached</strong></span> プロトコルは <code class="literal">InnoDB</code> テーブルとの間で情報をやり取りし、<code class="literal">InnoDB</code> バッファプールは <span class="command"><strong>memcached</strong></span> メモリー使用量の増加および縮小のかわりにメモリー内ルックアップを処理します。 相対的には、<span class="command"><strong>memcached</strong></span> 側ではメモリーをほとんど使用しません。 
          </p><p>
            キャッシングポリシーを <code class="literal">caching</code> または <code class="literal">cache_only</code> に切り替えると、<span class="command"><strong>memcached</strong></span> メモリー使用量の通常のルールが適用されます。 <span class="command"><strong>memcached</strong></span> データ値のメモリーは、<span class="quote">「<span class="quote">「スラブ」</span>」</span>の観点から割り当てられます。 <span class="command"><strong>memcached</strong></span> に使用されるスラブサイズおよび最大メモリーを制御できます。 
          </p><p>
            どちらの方法でも、<span class="command"><strong>telnet</strong></span> セッションなどを介して標準プロトコルを介してアクセスされる使い慣れた <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-stats.html" target="_top">statistics</a> システムを使用して、<code class="literal">daemon_memcached</code> プラグインをモニターおよびトラブルシューティングできます。 <code class="literal">daemon_memcached</code> プラグインには、追加のユーティリティは含まれていません。 <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-stats-memcached-tool.html" target="_top"><code class="literal">memcached-tool</code> script</a> を使用して、完全な <span class="command"><strong>memcached</strong></span> ディストリビューションをインストールできます。 
          </p><p>
            従来の <span class="command"><strong>memcached</strong></span> との比較は、<a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-using-memory.html" target="_top">Memory Allocation within <span class="command"><strong>memcached</strong></span></a> を参照してください。
          </p></li><li class="listitem"><p>
            スレッド使用率: MySQL スレッドと <span class="command"><strong>memcached</strong></span> スレッドは同じサーバー上に共存します。 オペレーティングシステムによってスレッドに課される制限は、スレッドの合計数に適用されます。 
          </p><p>
            従来の <span class="command"><strong>memcached</strong></span> との比較は、<a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-using-threads.html" target="_top"><span class="command"><strong>memcached</strong></span> Thread Support</a> を参照してください。
          </p></li><li class="listitem"><p>
            ログの使用状況: <span class="command"><strong>memcached</strong></span> デーモンは MySQL サーバーとともに実行され、<code class="literal">stderr</code>、<code class="literal">-v</code>、<code class="literal">-vv</code>、<code class="literal">-vvv</code> の各オプションを使用して、書込み出力を MySQL <a class="link" href="glossary.html#glos_error_log" title="エラーログ">error log</a> に書き込みます。
          </p><p>
            従来の <span class="command"><strong>memcached</strong></span> との比較は、<a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-using-logs.html" target="_top"><span class="command"><strong>memcached</strong></span> Logs</a> を参照してください。
          </p></li><li class="listitem"><p>
            <span class="command"><strong>memcached</strong></span> 操作: <code class="literal">get</code>, <code class="literal">set</code>, <code class="literal">add</code>、<code class="literal">delete</code> などの使い慣れた <span class="command"><strong>memcached</strong></span> 操作を使用できます。 シリアライズ (複雑なデータ構造を表す正確な文字列形式) は、言語インタフェースによって異なります。 
          </p><p>
            従来の <span class="command"><strong>memcached</strong></span> との比較は、<a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-operations.html" target="_top">Basic <span class="command"><strong>memcached</strong></span> Operations</a> を参照してください。
          </p></li><li class="listitem"><p>
            MySQL フロントエンドとしての <span class="command"><strong>memcached</strong></span> の使用: これは、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインの主な目的です。 統合 <span class="command"><strong>memcached</strong></span> デーモンを使用すると、アプリケーションのパフォーマンスが向上し、<code class="literal">InnoDB</code> でメモリーとディスク間のデータ転送を処理できるため、アプリケーションロジックが簡略化されます。 
          </p><p>
            従来の <span class="command"><strong>memcached</strong></span> との比較は、<a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-mysql-frontend.html" target="_top">Using <span class="command"><strong>memcached</strong></span> as a MySQL Caching Layer</a> を参照してください。
          </p></li><li class="listitem"><p>
            ユーティリティ: MySQL サーバーには <code class="literal">libmemcached</code> ライブラリが含まれていますが、追加のコマンドラインユーティリティは含まれていません。 <span class="command"><strong>memcp</strong></span>、<span class="command"><strong>memcat</strong></span>、<span class="command"><strong>memcapable</strong></span> コマンドなどのコマンドを使用するには、完全な <span class="command"><strong>memcached</strong></span> ディストリビューションをインストールします。 <span class="command"><strong>memrm</strong></span> および <span class="command"><strong>memflush</strong></span> がキャッシュからアイテムを削除すると、基礎となる <code class="literal">InnoDB</code> テーブルからもアイテムが削除されます。 
          </p><p>
            従来の <span class="command"><strong>memcached</strong></span> との比較は、<a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-interfaces-libmemcached.html#ha-memcached-interfaces-libmemcached-utilities" target="_top"><span class="command"><strong>libmemcached</strong></span> Command-Line Utilities</a> を参照してください。
          </p></li><li class="listitem"><p>
            プログラミングインタフェース: サポートされているすべての言語を使用して、<code class="literal">daemon_memcached</code> プラグインを介して MySQL サーバーにアクセスできます: <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-interfaces-libmemcached.html" target="_top">C and C++</a>, <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-interfaces-java.html" target="_top">Java</a>, <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-interfaces-perl.html" target="_top">Perl</a>, <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-interfaces-python.html" target="_top">Python</a>, <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-interfaces-php.html" target="_top">PHP</a> および <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-interfaces-ruby.html" target="_top">Ruby</a>。 従来の <span class="command"><strong>memcached</strong></span> サーバーと同様に、サーバーのホスト名とポートを指定します。 デフォルトでは、<code class="literal">daemon_memcached</code> プラグインはポート <code class="literal">11211</code> でリスニングします。 <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-interfaces-protocol.html" target="_top">テキストプロトコルとバイナリプロトコル</a>の両方を使用できます。 <span class="command"><strong>memcached</strong></span> 関数の <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-interfaces-libmemcached.html#ha-memcached-interfaces-libmemcached-behaviors" target="_top">behavior</a> は、実行時にカスタマイズできます。 シリアライズ (複雑なデータ構造を表す正確な文字列形式) は、言語インタフェースによって異なります。 
          </p><p>
            従来の <span class="command"><strong>memcached</strong></span> との比較は、<a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-interfaces.html" target="_top">Developing a <span class="command"><strong>memcached</strong></span> Application</a> を参照してください。
          </p></li><li class="listitem"><p>
            よくある質問: MySQL には、従来の <span class="command"><strong>memcached</strong></span> に関する広範な FAQ があります。 FAQ は、<span class="command"><strong>memcached</strong></span> データの記憶域メディアとして <code class="literal">InnoDB</code> テーブルを使用することを除いて、読取り専用キャッシュとしてではなく、以前よりも多くの書込み集中型アプリケーションに <span class="command"><strong>memcached</strong></span> を使用できることを意味します。 
          </p><p>
            <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-faq.html" target="_top"><span class="command"><strong>memcached</strong></span> FAQ</a>を参照してください。
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-memcached-setup"></a>15.20.3 InnoDB memcached プラグインの設定</h3></div></div></div><p>
      このセクションでは、MySQL サーバーで <code class="literal">daemon_memcached</code> プラグインを設定する方法について説明します。 ネットワークトラフィックを回避し、待機時間を最小限に抑えるために、<span class="command"><strong>memcached</strong></span> デーモンは MySQL サーバーと緊密に統合されているため、この機能を使用する各 MySQL インスタンスでこのプロセスを実行します。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">daemon_memcached</code> プラグインを設定する前に、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-security" title="15.20.5 InnoDB memcached プラグインのセキュリティーに関する考慮事項">セクション15.20.5「InnoDB memcached プラグインのセキュリティーに関する考慮事項」</a> を参照して、不正アクセスを防ぐために必要なセキュリティー手順を理解してください。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-prereqs"></a>前提条件</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">daemon_memcached</code> プラグインは、Linux、Solaris および macOS プラットフォームでのみサポートされます。 その他のオペレーティングシステムはサポートされません。 
          </p></li><li class="listitem"><p>
            ソースから MySQL を構築する場合は、<code class="option">-DWITH_INNODB_MEMCACHED=ON</code> を使用して構築する必要があります。 このビルドオプションでは、<code class="literal">daemon_memcached</code> プラグインの実行に必要な 2 つの共有ライブラリが MySQL プラグインディレクトリ (<code class="literal">plugin_dir</code>) に生成されます: 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="filename">libmemcached.so</code>: MySQL に対する <span class="command"><strong>memcached</strong></span> デーモンプラグイン。
              </p></li><li class="listitem"><p>
                <code class="filename">innodb_engine.so</code>: <span class="command"><strong>memcached</strong></span> に対する <code class="literal">InnoDB</code> API プラグイン。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">libevent</code> をインストールする必要があります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                ソースから MySQL をビルドしなかった場合、<code class="literal">libevent</code> ライブラリはインストールに含まれません。 オペレーティングシステムのインストール方法を使用して、<code class="literal">libevent</code> 1.4.12 以上をインストールします。 たとえば、オペレーティングシステムに応じて、<code class="literal">apt-get</code>、<code class="literal">yum</code> または <code class="literal">port install</code> を使用できます。 たとえば、Ubuntu Linux では、次を使用します: 
              </p><pre class="programlisting">sudo apt-get install libevent-dev
</pre></li><li class="listitem"><p>
                MySQL をソースコードリリースからインストールした場合、<code class="literal">libevent</code> 1.4.12 はパッケージにバンドルされ、MySQL ソースコードディレクトリの最上位にあります。 バンドルされているバージョンの <code class="literal">libevent</code> を使用する場合、アクションは必要ありません。 ローカルシステムバージョンの <code class="literal">libevent</code>, を使用する場合、<code class="option">-DWITH_LIBEVENT</code> ビルドオプションを <code class="literal">system</code> または <code class="literal">yes</code> に設定して MySQL をビルドする必要があります。 
              </p></li></ul></div></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-installing"></a>InnoDB memcached プラグインのインストールおよび構成</h4></div></div></div><a class="indexterm" name="idm44761345765680"></a><a class="indexterm" name="idm44761345764208"></a><a class="indexterm" name="idm44761345762832"></a><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <code class="filename"><em class="replaceable"><code>MYSQL_HOME</code></em>/share</code> にある <code class="filename">innodb_memcached_config.sql</code> 構成スクリプトを実行して、<code class="literal">InnoDB</code> テーブルと対話できるように <code class="literal">daemon_memcached</code> プラグインを構成します。 このスクリプトは、<code class="literal">innodb_memcache</code> データベースを必要な 3 つのテーブル (<code class="literal">cache_policies</code>、<code class="literal">config_options</code> および <code class="literal">containers</code>) とともにインストールします。 また、<code class="literal">demo_test</code> サンプルテーブルが <code class="literal">test</code> データベースにインストールされます。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>source <em class="replaceable"><code>MYSQL_HOME</code></em>/share/innodb_memcached_config.sql</code></strong>
</pre><p>
            <code class="filename">innodb_memcached_config.sql</code> スクリプトの実行は単発操作です。 後で <code class="literal">daemon_memcached</code> プラグインをアンインストールして再インストールした場合、テーブルはそのまま残ります。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>USE innodb_memcache;</code></strong>
mysql&gt; <strong class="userinput"><code>SHOW TABLES;</code></strong>
+---------------------------+
| Tables_in_innodb_memcache |
+---------------------------+
| cache_policies            |
| config_options            |
| containers                |
+---------------------------+

mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>SHOW TABLES;</code></strong>
+----------------+
| Tables_in_test |
+----------------+
| demo_test      |
+----------------+
</pre><p>
            これらのテーブルの中で、<code class="literal">innodb_memcache.containers</code> テーブルが最も重要です。 <code class="literal">containers</code> テーブルのエントリは、<code class="literal">InnoDB</code> テーブルのカラムへのマッピングを提供します。 <code class="literal">daemon_memcached</code> プラグインで使用される各 <code class="literal">InnoDB</code> テーブルには、<code class="literal">containers</code> テーブルのエントリが必要です。 
          </p><p>
            <code class="filename">innodb_memcached_config.sql</code> スクリプトは、<code class="literal">demo_test</code> テーブルのマッピングを提供する単一のエントリを <code class="literal">containers</code> テーブルに挿入します。 また、単一行のデータを <code class="literal">demo_test</code> テーブルに挿入します。 このデータを使用すると、設定の完了後すぐにインストールを検証できます。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM innodb_memcache.containers\G</code></strong>
*************************** 1. row ***************************
                  name: aaa
             db_schema: test
              db_table: demo_test
           key_columns: c1
         value_columns: c2
                 flags: c3
            cas_column: c4
    expire_time_column: c5
unique_idx_name_on_key: PRIMARY

mysql&gt; <strong class="userinput"><code>SELECT * FROM test.demo_test;</code></strong>
+----+------------------+------+------+------+
| c1 | c2               | c3   | c4   | c5   |
+----+------------------+------+------+------+
| AA | HELLO, HELLO     |    8 |    0 |    0 |
+----+------------------+------+------+------+
</pre><p>
            <code class="literal">innodb_memcache</code> テーブルおよび <code class="literal">demo_test</code> サンプルテーブルの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-internals" title="15.20.8 InnoDB memcached プラグインの内部">セクション15.20.8「InnoDB memcached プラグインの内部」</a> を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">INSTALL PLUGIN</code> ステートメントを実行して、<code class="literal">daemon_memcached</code> プラグインをアクティブにします:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSTALL PLUGIN daemon_memcached soname "libmemcached.so";</code></strong>
</pre><p>
            プラグインがインストールされると、MySQL サーバーが再起動されるたびに自動的にアクティブ化されます。
          </p></li></ol></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-snifftest"></a>InnoDB および memcached 設定の検証</h4></div></div></div><p>
        <code class="literal">daemon_memcached</code> プラグインの設定を確認するには、<span class="command"><strong>telnet</strong></span> セッションを使用して <span class="command"><strong>memcached</strong></span> コマンドを発行します。 デフォルトでは、<span class="command"><strong>memcached</strong></span> デーモンはポート 11211 でリスニングします。 
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <code class="literal">test.demo_test</code> テーブルからデータを取得します。 <code class="literal">demo_test</code> テーブルの単一行のデータのキー値は <code class="literal">AA</code> です。 
          </p><pre class="programlisting"><strong class="userinput"><code>telnet localhost 11211</code></strong>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
<strong class="userinput"><code>get AA</code></strong>
VALUE AA 8 12
HELLO, HELLO
END
</pre></li><li class="listitem"><p>
            <code class="literal">set</code> コマンドを使用してデータを挿入します。
          </p><pre class="programlisting"><strong class="userinput"><code>set BB 10 0 16</code></strong>
<strong class="userinput"><code>GOODBYE, GOODBYE</code></strong>
STORED
</pre><p>
            ここでは:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">set</code> は、値を格納するコマンドです
              </p></li><li class="listitem"><p>
                <code class="literal">BB</code> がキーです
              </p></li><li class="listitem"><p>
                <code class="literal">10</code> は操作のフラグです。<span class="command"><strong>memcached</strong></span> では無視されますが、任意のタイプの情報を示すためにクライアントで使用できます。未使用の場合は <code class="literal">0</code> を指定
              </p></li><li class="listitem"><p>
                <code class="literal">0</code> は有効期限 (TTL) です。未使用の場合は <code class="literal">0</code> を指定
              </p></li><li class="listitem"><p>
                <code class="literal">16</code> は、指定された値ブロックの長さ (バイト) です
              </p></li><li class="listitem"><p>
                <code class="literal">GOODBYE, GOODBYE</code> は、格納される値です
              </p></li></ul></div></li><li class="listitem"><p>
            MySQL サーバーに接続し、<code class="literal">test.demo_test</code> テーブルをクエリーして、挿入されたデータが MySQL に格納されていることを確認します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM test.demo_test;</code></strong>
+----+------------------+------+------+------+
| c1 | c2               | c3   | c4   | c5   |
+----+------------------+------+------+------+
| AA | HELLO, HELLO     |    8 |    0 |    0 |
| BB | GOODBYE, GOODBYE |   10 |    1 |    0 |
+----+------------------+------+------+------+
</pre></li><li class="listitem"><p>
            telnet セッションに戻り、キー <code class="literal">BB</code> を使用して前に挿入したデータを取得します。
          </p><pre class="programlisting"><strong class="userinput"><code>get BB</code></strong>
VALUE BB 10 16
GOODBYE, GOODBYE
END
<strong class="userinput"><code>quit</code></strong>
</pre></li></ol></div><p>
        統合 <span class="command"><strong>memcached</strong></span> サーバーも停止する MySQL サーバーを停止した場合、<span class="command"><strong>memcached</strong></span> データへのアクセスの試行は接続エラーで失敗します。 通常、この時点では <span class="command"><strong>memcached</strong></span> データも表示されなくなるため、<span class="command"><strong>memcached</strong></span> の再起動時にアプリケーションロジックでデータをメモリーにロードしなおす必要があります。 ただし、このプロセスは <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインによって自動化されます。 
      </p><p>
        MySQL を再起動すると、<code class="literal">get</code> 操作によって、以前の <span class="command"><strong>memcached</strong></span> セッションに格納したキーと値のペアが再度返されます。 キーがリクエストされ、関連付けられた値がメモリーキャッシュに存在しない場合、その値は MySQL <code class="literal">test.demo_test</code> テーブルから自動的に問い合せられます。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-new-table-setup"></a>新しいテーブルとカラムのマッピングの作成</h4></div></div></div><p>
        この例では、<code class="literal">daemon_memcached</code> プラグインを使用して独自の <code class="literal">InnoDB</code> テーブルを設定する方法を示します。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <code class="literal">InnoDB</code> テーブルを作成します。 テーブルには一意のインデックスを持つキーカラムが必要です。 市区町村テーブルのキーカラムは、主キーとして定義されている <code class="literal">city_id</code> です。 テーブルには、<code class="literal">flags</code>、<code class="literal">cas</code> および <code class="literal">expiry</code> 値のカラムも含まれている必要があります。 1 つ以上の値カラムがある場合があります。 <code class="literal">city</code> テーブルには、3 つの値カラム (<code class="literal">name</code>, <code class="literal">state</code>, <code class="literal">country</code>) があります。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              有効なマッピングが <code class="literal">innodb_memcache.containers</code> テーブルに追加されるため、カラム名に関して特別な要件はありません。
            </p></div><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE city (</code></strong>
       <strong class="userinput"><code>city_id VARCHAR(32),</code></strong>
       <strong class="userinput"><code>name VARCHAR(1024),</code></strong>
       <strong class="userinput"><code>state VARCHAR(1024),</code></strong>
       <strong class="userinput"><code>country VARCHAR(1024),</code></strong>
       <strong class="userinput"><code>flags INT,</code></strong>
       <strong class="userinput"><code>cas BIGINT UNSIGNED, </code></strong>
       <strong class="userinput"><code>expiry INT,</code></strong>
       <strong class="userinput"><code>primary key(city_id)</code></strong>
       ) <strong class="userinput"><code>ENGINE=InnoDB;</code></strong>
</pre></li><li class="listitem"><p>
            <code class="literal">daemon_memcached</code> プラグインが <code class="literal">InnoDB</code> テーブルへのアクセス方法を認識できるように、<code class="literal">innodb_memcache.containers</code> テーブルにエントリを追加します。 エントリは、<code class="literal">innodb_memcache.containers</code> テーブル定義を満たす必要があります。 各フィールドの説明は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-internals" title="15.20.8 InnoDB memcached プラグインの内部">セクション15.20.8「InnoDB memcached プラグインの内部」</a> を参照してください。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>DESCRIBE innodb_memcache.containers;</code></strong>
+------------------------+--------------+------+-----+---------+-------+
| Field                  | Type         | Null | Key | Default | Extra |
+------------------------+--------------+------+-----+---------+-------+
| name                   | varchar(50)  | NO   | PRI | NULL    |       |
| db_schema              | varchar(250) | NO   |     | NULL    |       |
| db_table               | varchar(250) | NO   |     | NULL    |       |
| key_columns            | varchar(250) | NO   |     | NULL    |       |
| value_columns          | varchar(250) | YES  |     | NULL    |       |
| flags                  | varchar(250) | NO   |     | 0       |       |
| cas_column             | varchar(250) | YES  |     | NULL    |       |
| expire_time_column     | varchar(250) | YES  |     | NULL    |       |
| unique_idx_name_on_key | varchar(250) | NO   |     | NULL    |       |
+------------------------+--------------+------+-----+---------+-------+
</pre><p>
            city テーブルの <code class="literal">innodb_memcache.containers</code> テーブルエントリは、次のように定義されます:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO `innodb_memcache`.`containers` (</code></strong>
       <strong class="userinput"><code>`name`, `db_schema`, `db_table`, `key_columns`, `value_columns`,</code></strong>
       <strong class="userinput"><code>`flags`, `cas_column`, `expire_time_column`, `unique_idx_name_on_key`)</code></strong>
       <strong class="userinput"><code>VALUES ('default', 'test', 'city', 'city_id', 'name|state|country', </code></strong>
       <strong class="userinput"><code>'flags','cas','expiry','PRIMARY');</code></strong>
</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">containers.name</code> カラムに <code class="literal">default</code> が指定され、<code class="literal">daemon_memcached</code> プラグインで使用されるデフォルトの <code class="literal">InnoDB</code> テーブルとして <code class="literal">city</code> テーブルが構成されます。
              </p></li><li class="listitem"><p>
                <span class="quote">「<span class="quote">|</span>」</span>デリミタを使用して、複数の <code class="literal">InnoDB</code> テーブルのカラム (<code class="literal">name</code>, <code class="literal">state</code>, <code class="literal">country</code>) が <code class="literal">containers.value_columns</code> にマップされます。
              </p></li><li class="listitem"><p>
                <code class="literal">innodb_memcache.containers</code> テーブルの <code class="literal">flags</code>、<code class="literal">cas_column</code> および <code class="literal">expire_time_column</code> フィールドは、通常、<code class="literal">daemon_memcached</code> プラグインを使用するアプリケーションでは重要ではありません。 ただし、それぞれに指定された <code class="literal">InnoDB</code> テーブルのカラムが必要です。 データを挿入するときに、これらのカラムが未使用の場合は <code class="literal">0</code> を指定します。 
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">innodb_memcache.containers</code> テーブルを更新した後、<code class="literal">daemon_memcache</code> プラグインを再起動して変更を適用します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UNINSTALL PLUGIN daemon_memcached;</code></strong>

mysql&gt; <strong class="userinput"><code>INSTALL PLUGIN daemon_memcached soname "libmemcached.so";</code></strong>
</pre></li><li class="listitem"><p>
            telnet を使用して、<span class="command"><strong>memcached</strong></span> <code class="literal">set</code> コマンドを使用して <code class="literal">city</code> テーブルにデータを挿入します。
          </p><pre class="programlisting"><strong class="userinput"><code>telnet localhost 11211</code></strong>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
<strong class="userinput"><code>set B 0 0 22</code></strong>
<strong class="userinput"><code>BANGALORE|BANGALORE|IN</code></strong>
STORED
</pre></li><li class="listitem"><p>
            MySQL を使用して、<code class="literal">test.city</code> テーブルをクエリーして、挿入したデータが格納されていることを確認します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM test.city;</code></strong>
+---------+-----------+-----------+---------+-------+------+--------+
| city_id | name      | state     | country | flags | cas  | expiry |
+---------+-----------+-----------+---------+-------+------+--------+
| B       | BANGALORE | BANGALORE | IN      |     0 |    3 |      0 |
+---------+-----------+-----------+---------+-------+------+--------+
</pre></li><li class="listitem"><p>
            MySQL を使用して、<code class="literal">test.city</code> テーブルに追加データを挿入します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO city VALUES ('C','CHENNAI','TAMIL NADU','IN', 0, 0 ,0);</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO city VALUES ('D','DELHI','DELHI','IN', 0, 0, 0);</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO city VALUES ('H','HYDERABAD','TELANGANA','IN', 0, 0, 0);</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO city VALUES ('M','MUMBAI','MAHARASHTRA','IN', 0, 0, 0);</code></strong>
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">flags</code>、<code class="literal">cas_column</code> および <code class="literal">expire_time_column</code> フィールドが使用されていない場合は、これらのフィールドに <code class="literal">0</code> の値を指定することをお薦めします。
            </p></div></li><li class="listitem"><p>
            telnet を使用して、<span class="command"><strong>memcached</strong></span> <code class="literal">get</code> コマンドを発行し、MySQL を使用して挿入したデータを取得します。
          </p><pre class="programlisting"><strong class="userinput"><code>get H</code></strong>
VALUE H 0 22
HYDERABAD|TELANGANA|IN
END
</pre></li></ol></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-configuration"></a>InnoDB memcached プラグインの構成</h4></div></div></div><p>
        従来の <code class="literal">memcached</code> 構成オプションは、<code class="literal">daemon_memcached_option</code> 構成パラメータの引数でエンコードされた MySQL 構成ファイルまたは <span class="command"><strong>mysqld</strong></span> 起動文字列で指定できます。<code class="literal">memcached</code> 構成オプションは、MySQL サーバーが起動されるたびに発生するプラグインがロードされるときに有効になります。
      </p><p>
        たとえば、<span class="command"><strong>memcached</strong></span> がデフォルトポート 11211 ではなくポート 11222 でリスニングするようにするには、<code class="literal">daemon_memcached_option</code> 構成オプションの引数として <code class="literal">-p11222</code> を指定します:
      </p><pre class="programlisting">mysqld .... --daemon_memcached_option="-p11222"
</pre><p>
        その他の <span class="command"><strong>memcached</strong></span> オプションは、<code class="literal">daemon_memcached_option</code> 文字列でエンコードできます。 たとえば、同時接続の最大数の削減、キーと値のペアの最大メモリーサイズの変更、エラーログのデバッグメッセージの有効化などのオプションを指定できます。 
      </p><p>
        <code class="literal">daemon_memcached</code> プラグインに固有の構成オプションもあります。 これには次のものが含まれます。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">daemon_memcached_engine_lib_name</code>: <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインを実装する共有ライブラリを指定します。 デフォルト設定は <code class="filename">innodb_engine.so</code> です。 
          </p></li><li class="listitem"><p>
            <code class="literal">daemon_memcached_engine_lib_path</code>: <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインを実装する共有ライブラリを含むディレクトリのパス。 デフォルトは NULL で、プラグインディレクトリを表します。 
          </p></li><li class="listitem"><p>
            <code class="literal">daemon_memcached_r_batch_size</code>: 読取り操作 (<code class="literal">get</code>) のバッチコミットサイズを定義します。 <a class="link" href="glossary.html#glos_commit" title="コミット">commit</a> が発生するまでの <span class="command"><strong>memcached</strong></span> 読取り操作の数を指定します。<code class="literal">daemon_memcached_r_batch_size</code> はデフォルトで 1 に設定されているため、データが <span class="command"><strong>memcached</strong></span> を介して更新されたか SQL によって更新されたかに関係なく、すべての <code class="literal">get</code> リクエストが <code class="literal">InnoDB</code> テーブルで最後にコミットされたデータにアクセスします。 値が 1 より大きい場合、読取り操作のカウンタは <code class="literal">get</code> コールごとに増分されます。 <code class="literal">flush_all</code> コールは、読取りカウンタと書込みカウンタの両方をリセットします。 
          </p></li><li class="listitem"><p>
            <code class="literal">daemon_memcached_w_batch_size</code>: 書込み操作 (<code class="literal">set</code>, <code class="literal">replace</code>, <code class="literal">append</code>, <code class="literal">prepend</code>, <code class="literal">incr</code>, <code class="literal">decr</code> など) のバッチコミットサイズを定義します。<code class="literal">daemon_memcached_w_batch_size</code> はデフォルトで 1 に設定されているため、停止時にコミットされていないデータは失われず、基礎となるテーブルに対する SQL クエリーが最新のデータにアクセスします。 値が 1 より大きい場合、書込み操作のカウンタは <code class="literal">add</code>, <code class="literal">set</code>, <code class="literal">incr</code>, <code class="literal">decr</code> および <code class="literal">delete</code> コールごとに増分されます。 <code class="literal">flush_all</code> コールは、読取りカウンタと書込みカウンタの両方をリセットします。 
          </p></li></ul></div><p>
        デフォルトでは、<code class="literal">daemon_memcached_engine_lib_name</code> または <code class="literal">daemon_memcached_engine_lib_path</code> を変更する必要はありません。 たとえば、<span class="command"><strong>memcached</strong></span> に別のストレージエンジン (NDB <span class="command"><strong>memcached</strong></span> エンジンなど) を使用する場合は、これらのオプションを構成できます。 
      </p><p>
        <code class="literal">daemon_memcached</code> プラグイン構成パラメータは、MySQL 構成ファイルまたは <span class="command"><strong>mysqld</strong></span> 起動文字列で指定できます。 これらは、<code class="literal">daemon_memcached</code> プラグインをロードすると有効になります。 
      </p><p>
        <code class="literal">daemon_memcached</code> プラグイン構成を変更する場合は、プラグインをリロードして変更を適用します。 これを行うには、次のステートメントを発行します: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UNINSTALL PLUGIN daemon_memcached;</code></strong>

mysql&gt; <strong class="userinput"><code>INSTALL PLUGIN daemon_memcached soname "libmemcached.so";</code></strong>
</pre><p>
        構成設定、必要なテーブルおよびデータは、プラグインの再起動時に保持されます。
      </p><p>
        プラグインの有効化および無効化についてのその他の情報は、<a class="xref" href="server-administration.html#plugin-loading" title="5.6.1 プラグインのインストールおよびアンインストール">セクション5.6.1「プラグインのインストールおよびアンインストール」</a>を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-memcached-multiple-get-range-query"></a>15.20.4 InnoDB memcached の複数の get および Range クエリーのサポート</h3></div></div></div><p>
      <code class="literal">daemon_memcached</code> プラグインは、複数の get 操作 (単一の <span class="command"><strong>memcached</strong></span> クエリーで複数のキーと値のペアをフェッチ) および範囲クエリーをサポートしています。
    </p><h4><a name="idm44761345539360"></a>複数の get 操作</h4><p>
      単一の <span class="command"><strong>memcached</strong></span> クエリーで複数のキーと値のペアをフェッチする機能により、クライアントとサーバー間の通信トラフィックが削減され、読取りパフォーマンスが向上します。 <code class="literal">InnoDB</code> の場合、トランザクションおよびオープンテーブル操作が少なくなります。 
    </p><p>
      次の例は、複数データセットのサポートを示しています。 この例では、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-new-table-setup" title="新しいテーブルとカラムのマッピングの作成">新しいテーブルとカラムのマッピングの作成</a> で説明されている <code class="literal">test.city</code> テーブルを使用します。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM test.city;</code></strong>
+---------+-----------+-------------+---------+-------+------+--------+
| city_id | name      | state       | country | flags | cas  | expiry |
+---------+-----------+-------------+---------+-------+------+--------+
| B       | BANGALORE | BANGALORE   | IN      |     0 |    1 |      0 |
| C       | CHENNAI   | TAMIL NADU  | IN      |     0 |    0 |      0 |
| D       | DELHI     | DELHI       | IN      |     0 |    0 |      0 |
| H       | HYDERABAD | TELANGANA   | IN      |     0 |    0 |      0 |
| M       | MUMBAI    | MAHARASHTRA | IN      |     0 |    0 |      0 |
+---------+-----------+-------------+---------+-------+------+--------+
</pre><p>
      <code class="literal">get</code> コマンドを実行して、<code class="literal">city</code> テーブルからすべての値を取得します。 結果はキーと値のペアの順序で返されます。 
    </p><pre class="programlisting"><strong class="userinput"><code>telnet 127.0.0.1 11211</code></strong>
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
<strong class="userinput"><code>get B C D H M</code></strong>
VALUE B 0 22
BANGALORE|BANGALORE|IN
VALUE C 0 21
CHENNAI|TAMIL NADU|IN
VALUE D 0 14
DELHI|DELHI|IN
VALUE H 0 22
HYDERABAD|TELANGANA|IN
VALUE M 0 21
MUMBAI|MAHARASHTRA|IN
END
</pre><p>
      単一の <code class="literal">get</code> コマンドで複数の値を取得する場合、(<code class="literal">@@<em class="replaceable"><code>containers.name</code></em></code> テーブル記法を使用して) テーブルを切り替えて最初のキーの値を取得できますが、後続のキーのテーブルを切り替えることはできません。 たとえば、この例のテーブルスイッチは有効です: 
    </p><pre class="programlisting"><strong class="userinput"><code>get @@aaa.AA BB</code></strong>
VALUE @@aaa.AA 8 12
HELLO, HELLO
VALUE BB 10 16
GOODBYE, GOODBYE
END
</pre><p>
      同じ <code class="literal">get</code> コマンドでテーブルの切替えを再試行して別のテーブルからキー値を取得することはサポートされていません。
    </p><p>
      複数の get 操作で取得できるキーの数に制限はありませんが、結果を格納するための 128MB のメモリー制限があります。
    </p><h4><a name="idm44761345519376"></a>範囲クエリー</h4><p>
      範囲クエリーの場合、<code class="literal">daemon_memcached</code> プラグインでは次の比較演算子がサポートされます: <code class="literal">&lt;</code>, <code class="literal">&gt;</code>, <code class="literal">&lt;=</code>, <code class="literal">&gt;=</code>。 演算子の前に<code class="literal">@</code>記号を付ける必要があります。 範囲クエリーで複数の一致するキーと値のペアが見つかった場合、結果はキーと値のペアの順序で返されます。 
    </p><p>
      次の例は、範囲クエリーのサポートを示しています。 この例では、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-new-table-setup" title="新しいテーブルとカラムのマッピングの作成">新しいテーブルとカラムのマッピングの作成</a> で説明されている <code class="literal">test.city</code> テーブルを使用します。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM test.city;</code></strong>
+---------+-----------+-------------+---------+-------+------+--------+
| city_id | name      | state       | country | flags | cas  | expiry |
+---------+-----------+-------------+---------+-------+------+--------+
| B       | BANGALORE | BANGALORE   | IN      |     0 |    1 |      0 |
| C       | CHENNAI   | TAMIL NADU  | IN      |     0 |    0 |      0 |
| D       | DELHI     | DELHI       | IN      |     0 |    0 |      0 |
| H       | HYDERABAD | TELANGANA   | IN      |     0 |    0 |      0 |
| M       | MUMBAI    | MAHARASHTRA | IN      |     0 |    0 |      0 |
+---------+-----------+-------------+---------+-------+------+--------+
</pre><p>
      telnet セッションを開きます:
    </p><pre class="programlisting"><strong class="userinput"><code>telnet 127.0.0.1 11211</code></strong>
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
</pre><p>
      <code class="literal">B</code> より大きいすべての値を取得するには、<code class="literal">get @&gt;B</code> を入力します:
    </p><pre class="programlisting"><strong class="userinput"><code>get @&gt;B</code></strong>
VALUE C 0 21
CHENNAI|TAMIL NADU|IN
VALUE D 0 14
DELHI|DELHI|IN
VALUE H 0 22
HYDERABAD|TELANGANA|IN
VALUE M 0 21
MUMBAI|MAHARASHTRA|IN
END
</pre><p>
      <code class="literal">M</code> より小さいすべての値を取得するには、<code class="literal">get @&lt;M</code> を入力します:
    </p><pre class="programlisting"><strong class="userinput"><code>get @&lt;M</code></strong>
VALUE B 0 22
BANGALORE|BANGALORE|IN
VALUE C 0 21
CHENNAI|TAMIL NADU|IN
VALUE D 0 14
DELHI|DELHI|IN
VALUE H 0 22
HYDERABAD|TELANGANA|IN
END
</pre><p>
      <code class="literal">M</code> 以下のすべての値を取得するには、<code class="literal">get @&lt;=M</code> を入力します:
    </p><pre class="programlisting"><strong class="userinput"><code>get @&lt;=M</code></strong>
VALUE B 0 22
BANGALORE|BANGALORE|IN
VALUE C 0 21
CHENNAI|TAMIL NADU|IN
VALUE D 0 14
DELHI|DELHI|IN
VALUE H 0 22
HYDERABAD|TELANGANA|IN
VALUE M 0 21
MUMBAI|MAHARASHTRA|IN
</pre><p>
      <code class="literal">B</code> より大きく、<code class="literal">M</code> より小さい値を取得するには、<code class="literal">get @&gt;B@&lt;M</code> を入力します:
    </p><pre class="programlisting"><strong class="userinput"><code>get @&gt;B@&lt;M</code></strong>
VALUE C 0 21
CHENNAI|TAMIL NADU|IN
VALUE D 0 14
DELHI|DELHI|IN
VALUE H 0 22
HYDERABAD|TELANGANA|IN
END
</pre><p>
      最大 2 つの比較演算子を解析できます。1 つは次より小さい (<code class="literal">@&lt;</code>) 演算子または次以下 (<code class="literal">@&lt;=</code>) 演算子で、もう 1 つは次より大きい (<code class="literal">@&gt;</code>) 演算子または次以上 (<code class="literal">@&gt;=</code>) 演算子です。 追加の演算子はキーの一部とみなされます。 たとえば、3 つの演算子を使用して <code class="literal">get</code> コマンドを発行すると、3 つ目の演算子 (<code class="literal">@&gt;C</code>) はキーの一部として扱われ、<code class="literal">get</code> コマンドは <code class="literal">M</code> より小さく <code class="literal">B@&gt;C</code> より大きい値を検索します。 
    </p><pre class="programlisting"><strong class="userinput"><code>get @&lt;M@&gt;B@&gt;C</code></strong>
VALUE C 0 21
CHENNAI|TAMIL NADU|IN
VALUE D 0 14
DELHI|DELHI|IN
VALUE H 0 22
HYDERABAD|TELANGANA|IN
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-memcached-security"></a>15.20.5 InnoDB memcached プラグインのセキュリティーに関する考慮事項</h3></div></div></div><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注意</div><p>
        本番サーバー、または MySQL インスタンスに機密データが含まれている場合はテストサーバーに <code class="literal">daemon_memcached</code> プラグインをデプロイする前に、このセクションを参照してください。
      </p></div><p>
      <span class="command"><strong>memcached</strong></span> ではデフォルトで認証メカニズムが使用されず、オプションの SASL 認証は従来の DBMS セキュリティ対策ほど強力ではないため、<code class="literal">daemon_memcached</code> プラグインを使用する MySQL インスタンス内の機密性のないデータのみを保持し、潜在的な侵入者からこの構成を使用するすべてのサーバーからウォールオフにします。 インターネットからこれらのサーバーへの <span class="command"><strong>memcached</strong></span> アクセスを許可しないでください。ファイアウォール付きイントラネット内 (メンバーシップを制限できるサブネットからのみ) からのアクセスを許可してください。 
    </p><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-sasl"></a>SASL を使用した memcached のパスワード保護</h4></div></div></div><a class="indexterm" name="idm44761345474608"></a><a class="indexterm" name="idm44761345473296"></a><a class="indexterm" name="idm44761345471760"></a><a class="indexterm" name="idm44761345469632"></a><a class="indexterm" name="idm44761345467504"></a><p>
        SASL サポートは、<span class="command"><strong>memcached</strong></span> クライアントを介した認証されていないアクセスから MySQL データベースを保護する機能を提供します。 このセクションでは、<code class="literal">daemon_memcached</code> プラグインを使用して SASL を有効にする方法について説明します。 これらのステップは、従来の <span class="command"><strong>memcached</strong></span> サーバーで SASL を有効にするために実行されるステップとほぼ同じです。 
      </p><p>
        SASL は、接続ベースのプロトコルに認証サポートを追加するための標準である<span class="quote">「<span class="quote">「Simple Authentication and Security レイヤー」</span>」</span>を表します。<span class="command"><strong>memcached</strong></span> は、バージョン 1.4.3 で SASL サポートを追加しました。
      </p><p>
        SASL 認証はバイナリプロトコルでのみサポートされます。
      </p><p>
        <span class="command"><strong>memcached</strong></span> クライアントは、<code class="literal">innodb_memcache.containers</code> テーブルに登録されている <code class="literal">InnoDB</code> テーブルにのみアクセスできます。DBA はこのようなテーブルにアクセス制限を設定できますが、<span class="command"><strong>memcached</strong></span> アプリケーションを介したアクセスは制御できません。 このため、SASL サポートは、<code class="literal">daemon_memcached</code> プラグインに関連付けられた <code class="literal">InnoDB</code> テーブルへのアクセスを制御するために提供されます。 
      </p><p>
        次のセクションでは、SASL 対応 <code class="literal">daemon_memcached</code> プラグインを構築、有効化、およびテストする方法を示します。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-sasl-enabling"></a>InnoDB memcached プラグインを使用した SASL の構築と有効化</h4></div></div></div><p>
        SASL 対応の <code class="literal">daemon_memcached</code> プラグインでは SASL ライブラリを使用して <span class="command"><strong>memcached</strong></span> を構築する必要があるため、デフォルトでは、SASL 対応の <code class="literal">daemon_memcached</code> プラグインは MySQL リリースパッケージに含まれていません。 SASL サポートを有効にするには、MySQL ソースをダウンロードし、SASL ライブラリのダウンロード後に <code class="literal">daemon_memcached</code> プラグインを再構築します: 
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            SASL 開発およびユーティリティライブラリをインストールします。 たとえば、Ubuntu では、<span class="command"><strong>apt-get</strong></span> を使用してライブラリを取得します: 
          </p><pre class="programlisting">sudo apt-get -f install libsasl2-2 sasl2-bin libsasl2-2 libsasl2-dev libsasl2-modules
</pre></li><li class="listitem"><p>
            <span class="command"><strong>cmake</strong></span> オプションに <code class="literal">ENABLE_MEMCACHED_SASL=1</code> を追加して、SASL 機能を持つ <code class="literal">daemon_memcached</code> プラグイン共有ライブラリを構築します。<span class="command"><strong>memcached</strong></span> には、テストを容易にする<span class="emphasis"><em>簡易クリアテキストパスワードのサポート</em></span>も用意されています。 簡易クリアテキストパスワードサポートを有効にするには、<code class="literal">ENABLE_MEMCACHED_SASL_PWDB=1</code> <span class="command"><strong>cmake</strong></span> オプションを指定します。 
          </p><p>
            要約すると、次の 3 つの <span class="command"><strong>cmake</strong></span> オプションを追加します:
          </p><pre class="programlisting">cmake ... -DWITH_INNODB_MEMCACHED=1 -DENABLE_MEMCACHED_SASL=1 -DENABLE_MEMCACHED_SASL_PWDB=1
</pre></li><li class="listitem"><p>
            <a class="xref" href="innodb-storage-engine.html#innodb-memcached-setup" title="15.20.3 InnoDB memcached プラグインの設定">セクション15.20.3「InnoDB memcached プラグインの設定」</a> の説明に従って、<code class="literal">daemon_memcached</code> プラグインをインストールします。
          </p></li><li class="listitem"><p>
            ユーザー名とパスワードファイルを構成します。 (この例では、<span class="command"><strong>memcached</strong></span> の簡易クリアテキストパスワードサポートを使用します。) 
          </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>
                ファイルで、<code class="literal">testname</code> という名前のユーザーを作成し、パスワードを <code class="literal">testpasswd</code> として定義します:
              </p><pre class="programlisting">
echo "testname:testpasswd:::::::" &gt;/home/jy/memcached-sasl-db

</pre></li><li class="listitem"><p>
                <code class="literal">memcached</code> にユーザー名とパスワードファイルを通知するように、<code class="literal">MEMCACHED_SASL_PWDB</code> 環境変数を構成します:
              </p><pre class="programlisting">export MEMCACHED_SASL_PWDB=/home/jy/memcached-sasl-db
</pre></li><li class="listitem"><p>
                クリアテキストパスワードが使用されていることを <code class="literal">memcached</code> に通知します:
              </p><pre class="programlisting">
echo "mech_list: plain" &gt; /home/jy/work2/msasl/clients/memcached.conf
export SASL_CONF_PATH=/home/jy/work2/msasl/clients

</pre></li></ol></div></li><li class="listitem"><p>
            <code class="literal">daemon_memcached_option</code> 構成パラメータでエンコードされた <span class="command"><strong>memcached</strong></span> <code class="literal">-S</code> オプションを使用して MySQL サーバーを再起動し、SASL を有効にします:
          </p><pre class="programlisting">mysqld ... --daemon_memcached_option="-S"
</pre></li><li class="listitem"><p>
            設定をテストするには、<a class="ulink" href="https://code.launchpad.net/~trond-norbye/libmemcached/sasl" target="_top">「SASL 対応 libmemcached」</a>などの SASL 対応クライアントを使用します。
          </p><pre class="programlisting">memcp --servers=localhost:11211 --binary  --username=testname
  --password=<em class="replaceable"><code>password</code></em> myfile.txt

memcat --servers=localhost:11211 --binary --username=testname
  --password=<em class="replaceable"><code>password</code></em> myfile.txt
</pre><p>
            間違ったユーザー名またはパスワードを指定すると、操作は拒否され、<code class="literal">memcache error AUTHENTICATION FAILURE</code> メッセージが表示されます。 この場合、<code class="filename">memcached-sasl-db</code> ファイルに設定されているクリアテキストパスワードを調べて、指定した資格証明が正しいことを確認します。 
          </p></li></ol></div><p>
        <span class="command"><strong>memcached</strong></span> を使用して SASL 認証をテストする方法は他にもありますが、前述の方法は最も簡単です。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-memcached-developing"></a>15.20.6 InnoDB memcached プラグイン用のアプリケーションの記述</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-porting-mysql">15.20.6.1 InnoDB memcached プラグイン用の既存の MySQL スキーマの適応</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-porting-memcached">15.20.6.2 InnoDB memcached プラグインに対する memcached アプリケーションの適応</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-tuning">15.20.6.3 InnoDB memcached プラグインのパフォーマンスのチューニング</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-txn">15.20.6.4 InnoDB memcached プラグインのトランザクション動作の制御</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-dml">15.20.6.5 memcached 操作に合わせた DML ステートメントの改変</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-ddl">15.20.6.6 ベースとなる InnoDB テーブルでの DML および DDL ステートメントの実行</a></span></dt></dl></div><p>
      通常、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグイン用のアプリケーションを記述するには、MySQL または <span class="command"><strong>memcached</strong></span> API を使用する既存のコードをある程度書き換えるか適応させます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">daemon_memcached</code> プラグインを使用すると、多くの従来の <span class="command"><strong>memcached</strong></span> サーバーが低消費マシン上で実行されるのではなく、MySQL サーバーと同じ数の <span class="command"><strong>memcached</strong></span> サーバーが、大規模なディスク記憶域およびメモリーを備えた比較的高消費マシン上で実行されます。 <span class="command"><strong>memcached</strong></span> API で動作する既存のコードを再利用できますが、サーバー構成が異なるために適応が必要になる可能性があります。 
        </p></li><li class="listitem"><p>
          <code class="literal">daemon_memcached</code> プラグインを介して格納されたデータは、<code class="literal">VARCHAR</code>、<code class="literal">TEXT</code> または <code class="literal">BLOB</code> カラムに格納され、数値操作を実行するために変換する必要があります。 変換は、アプリケーション側で実行することも、クエリーで <code class="literal">CAST()</code> 関数を使用して実行することもできます。 
        </p></li><li class="listitem"><p>
          データベースバックグラウンドから使用する場合、多くのカラムを備えた汎用の SQL テーブルを使用する場合があります。 <span class="command"><strong>memcached</strong></span> コードによってアクセスされるテーブルには、データ値を保持する単一または少数のカラムしかない可能性があります。 
        </p></li><li class="listitem"><p>
          単一行のクエリー、挿入、更新または削除を実行するアプリケーションの一部を調整して、コードの重要なセクションのパフォーマンスを向上させることができます。 <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> インタフェースを介して実行すると、<a class="link" href="glossary.html#glos_query" title="クエリー">queries</a> (読取り) 操作と <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> (書込み) 操作の両方が大幅に高速になります。 書込みのパフォーマンスの向上は通常、読取りのパフォーマンスの向上よりも大きいため、ロギングを実行するコードの適応や、web サイトでの対話型の選択の記録に焦点を当てる場合があります。 
        </p></li></ul></div><p>
      次の各セクションでは、これらの点について詳しく説明します。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-porting-mysql"></a>15.20.6.1 InnoDB memcached プラグイン用の既存の MySQL スキーマの適応</h4></div></div></div><p>
        既存の MySQL スキーマまたはアプリケーションを <code class="literal">daemon_memcached</code> プラグインを使用するように適応させる場合は、<span class="command"><strong>memcached</strong></span> アプリケーションの次の側面を考慮してください:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="command"><strong>memcached</strong></span> キーに空白や改行を含めることはできません。これらの文字は ASCII プロトコルでセパレータとして使用されるためです。 スペースを含む検索値を使用する場合は、<code class="literal">add()</code>、<code class="literal">set()</code>、<code class="literal">get()</code>, などの呼び出しでこれらをキーとして使用する前に、スペースのない値に変換またはハッシュします。 理論上、これらの文字はバイナリプロトコルを使用するプログラム内の鍵で使用できますが、広範囲のクライアントとの互換性を確保するために、鍵で使用される文字を制限するようにしてください。 
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> テーブルに短い数値の <a class="link" href="glossary.html#glos_primary_key" title="主キー">primary key</a> カラムがある場合は、整数を文字列値に変換して、<span class="command"><strong>memcached</strong></span> の一意の参照キーとして使用します。 <span class="command"><strong>memcached</strong></span> サーバーが複数のアプリケーションに使用されている場合、または複数の <code class="literal">InnoDB</code> テーブルで使用されている場合は、一意になるように名前を変更することを検討してください。 たとえば、数値の前にテーブル名またはデータベース名とテーブル名を付加します。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">daemon_memcached</code> プラグインは、<code class="literal">INTEGER</code> が主キーとして定義されているマップ済 <code class="literal">InnoDB</code> テーブルでの挿入および読取りをサポートしています。
            </p></div></li><li class="listitem"><p>
            <span class="command"><strong>memcached</strong></span> を使用してクエリーまたは格納されたデータには、パーティションテーブルを使用できません。
          </p></li><li class="listitem"><p>
            <span class="command"><strong>memcached</strong></span> プロトコルは数値を文字列として渡します。 <code class="literal">SUM()</code> や <code class="literal">AVG()</code> などの SQL 関数で使用できるカウンタを実装するために、基礎となる <code class="literal">InnoDB</code> テーブルに数値を格納するには、次のようにします: 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                予想される最大数のすべての桁 (さらに該当する場合はマイナス符号、小数点またはその両方に対する追加の文字) を保持するために十分な文字がある <code class="literal">VARCHAR</code> カラムを使用します。
              </p></li><li class="listitem"><p>
                カラム値を使用して算術を実行するクエリーでは、<code class="literal">CAST()</code> 関数を使用して、値を文字列から整数または他の数値型に変換します。 例: 
              </p><pre class="programlisting"># Alphabetic entries are returned as zero.

SELECT CAST(c2 as unsigned integer) FROM demo_test;

# Since there could be numeric values of 0, can't disqualify them.
# Test the string values to find the ones that are integers, and average only those.

SELECT AVG(cast(c2 as unsigned integer)) FROM demo_test
  WHERE c2 BETWEEN '0' and '9999999999';

# Views let you hide the complexity of queries. The results are already converted;
# no need to repeat conversion functions and WHERE clauses each time.

CREATE VIEW numbers AS SELECT c1 KEY, CAST(c2 AS UNSIGNED INTEGER) val
  FROM demo_test WHERE c2 BETWEEN '0' and '9999999999';
SELECT SUM(val) FROM numbers;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                  結果セット内のアルファベット値は、<code class="literal">CAST()</code> のコールによって 0 に変換されます。 結果セット内の行数に依存する <code class="literal">AVG()</code> などの関数を使用する場合は、数値以外の値を除外するための <code class="literal">WHERE</code> 句を含めます。 
                </p></div></li></ul></div></li><li class="listitem"><p>
            キーとして使用される <code class="literal">InnoDB</code> カラムの値が 250 バイトを超える可能性がある場合は、250 バイト未満にハッシュします。
          </p></li><li class="listitem"><p>
            <code class="literal">daemon_memcached</code> プラグインで既存のテーブルを使用するには、<code class="literal">innodb_memcache.containers</code> テーブルにそのテーブルのエントリを定義します。 このテーブルをすべての <span class="command"><strong>memcached</strong></span> リクエストのデフォルトにするには、<code class="literal">name</code> カラムに <code class="literal">default</code> の値を指定し、MySQL サーバーを再起動して変更を有効にします。 異なるクラスの <span class="command"><strong>memcached</strong></span> データに複数のテーブルを使用する場合は、選択した <code class="literal">name</code> 値を使用して <code class="literal">innodb_memcache.containers</code> テーブルに複数のエントリを設定し、アプリケーション内で <code class="literal">get @@<em class="replaceable"><code>name</code></em></code> または <code class="literal">set @@<em class="replaceable"><code>name</code></em></code> の形式で <span class="command"><strong>memcached</strong></span> リクエストを発行して、後続の <span class="command"><strong>memcached</strong></span> リクエストに使用するテーブルを指定します。 
          </p><p>
            事前定義された <code class="literal">test.demo_test</code> テーブル以外のテーブルを使用する例については、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-tutorial-python" title="例 15.13 InnoDB memcached アプリケーションでの独自のテーブルの使用">例15.13「InnoDB memcached アプリケーションでの独自のテーブルの使用」</a>を参照してください。 必要なテーブルレイアウトについては、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-internals" title="15.20.8 InnoDB memcached プラグインの内部">セクション15.20.8「InnoDB memcached プラグインの内部」</a> を参照してください。 
          </p></li><li class="listitem"><p>
            <span class="command"><strong>memcached</strong></span> キーと値のペアで複数の <code class="literal">InnoDB</code> テーブルのカラム値を使用するには、<code class="literal">InnoDB</code> テーブルの <code class="literal">innodb_memcache.containers</code> エントリの <code class="literal">value_columns</code> フィールドに、カンマ、セミコロン、空白またはパイプ文字で区切られたカラム名を指定します。 たとえば、<code class="literal">value_columns</code> フィールドに <code class="literal">col1,col2,col3</code> または <code class="literal">col1|col2|col3</code> を指定します。 
          </p><p>
            <span class="command"><strong>memcached</strong></span> <code class="literal">add</code> または <code class="literal">set</code> コールに文字列を渡す前に、パイプ文字をセパレータとして使用して、カラム値を単一の文字列に連結します。 文字列は、正しいカラムに自動的に解凍されます。 各 <code class="literal">get</code> コールは、パイプ文字で区切られたカラム値を含む単一の文字列を戻します。 適切なアプリケーション言語構文を使用して、値を解凍できます。 
          </p></li></ul></div><div class="example"><a name="innodb-memcached-tutorial-python"></a><p class="title"><b>例 15.13 InnoDB memcached アプリケーションでの独自のテーブルの使用</b></p><div class="example-contents"><p>
          この例では、データ操作に <code class="literal">memcached</code> を使用するサンプル Python アプリケーションで独自のテーブルを使用する方法を示します。
        </p><p>
          この例では、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-setup" title="15.20.3 InnoDB memcached プラグインの設定">セクション15.20.3「InnoDB memcached プラグインの設定」</a> の説明に従って <code class="literal">daemon_memcached</code> プラグインがインストールされていることを前提としています。 また、<code class="literal">python-memcache</code> モジュールを使用する Python スクリプトを実行するようにシステムが構成されていることも前提としています。 
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              母集団、地域およびドライバ側のデータを含む国情報を格納する <code class="literal">multicol</code> テーブルを作成します (右側の場合は<code class="literal">'R'</code>、左側の場合は<code class="literal">'L'</code>)。
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE `multicol` (</code></strong>
        <strong class="userinput"><code>`country` varchar(128) NOT NULL DEFAULT '',</code></strong>
        <strong class="userinput"><code>`population` varchar(10) DEFAULT NULL,</code></strong>
        <strong class="userinput"><code>`area_sq_km` varchar(9) DEFAULT NULL,</code></strong>
        <strong class="userinput"><code>`drive_side` varchar(1) DEFAULT NULL,</code></strong>
        <strong class="userinput"><code>`c3` int(11) DEFAULT NULL,</code></strong>
        <strong class="userinput"><code>`c4` bigint(20) unsigned DEFAULT NULL,</code></strong>
        <strong class="userinput"><code>`c5` int(11) DEFAULT NULL,</code></strong>
        <strong class="userinput"><code>PRIMARY KEY (`country`)</code></strong>
        <strong class="userinput"><code>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</code></strong>
</pre></li><li class="listitem"><p>
              <code class="literal">daemon_memcached</code> プラグインが <code class="literal">multicol</code> テーブルにアクセスできるように、<code class="literal">innodb_memcache.containers</code> テーブルにレコードを挿入します。
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO innodb_memcache.containers</code></strong>
       <strong class="userinput"><code>(name,db_schema,db_table,key_columns,value_columns,flags,cas_column,</code></strong>
       <strong class="userinput"><code>expire_time_column,unique_idx_name_on_key)</code></strong>
       <strong class="userinput"><code>VALUES</code></strong>
       <strong class="userinput"><code>('bbb','test','multicol','country','population,area_sq_km,drive_side',</code></strong>
       <strong class="userinput"><code>'c3','c4','c5','PRIMARY');</code></strong>

mysql&gt; <strong class="userinput"><code>COMMIT;</code></strong>
</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                  <code class="literal">multicol</code> テーブルの <code class="literal">innodb_memcache.containers</code> レコードは、<code class="literal">'bbb'</code>の <code class="literal">name</code> 値 (テーブル識別子) を指定します。
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                    すべての <span class="command"><strong>memcached</strong></span> アプリケーションに単一の <code class="literal">InnoDB</code> テーブルが使用されている場合、<code class="literal">@@</code>テーブル記法を使用してテーブルを切り替えるのを避けるために、<code class="literal">name</code> 値を <code class="literal">default</code> に設定できます。
                  </p></div></li><li class="listitem"><p>
                  <code class="literal">db_schema</code> カラムは、<code class="literal">multicol</code> テーブルが存在するデータベースの名前である <code class="literal">test</code> に設定されます。
                </p></li><li class="listitem"><p>
                  <code class="literal">db_table</code> カラムは、<code class="literal">InnoDB</code> テーブルの名前である <code class="literal">multicol</code> に設定されます。
                </p></li><li class="listitem"><p>
                  <code class="literal">key_columns</code> は、一意の <code class="literal">country</code> カラムに設定されます。 <code class="literal">country</code> カラムは、<code class="literal">multicol</code> テーブル定義で主キーとして定義されます。 
                </p></li><li class="listitem"><p>
                  複合データ値を保持する単一の <code class="literal">InnoDB</code> テーブルのカラムではなく、データは 3 つのテーブルのカラム (<code class="literal">population</code>、<code class="literal">area_sq_km</code> および <code class="literal">drive_side</code>) に分割されます。 複数の値カラムに対応するには、<code class="literal">value_columns</code> フィールドにカンマ区切りのカラムリストを指定します。 <code class="literal">value_columns</code> フィールドに定義されているカラムは、値の格納または取得時に使用されるカラムです。 
                </p></li><li class="listitem"><p>
                  <code class="literal">flags</code>、<code class="literal">expire_time</code> および <code class="literal">cas_column</code> の各フィールドの値は、<code class="literal">demo.test</code> サンプルテーブルで使用されている値に基づきます。 これらのフィールドは通常、<code class="literal">daemon_memcached</code> プラグインを使用するアプリケーションでは重要ではありません。これは、MySQL がデータの同期を維持し、データの期限切れや失効を心配する必要がないためです。 
                </p></li><li class="listitem"><p>
                  <code class="literal">unique_idx_name_on_key</code> フィールドが <code class="literal">PRIMARY</code> に設定され、<code class="literal">multicol</code> テーブルの一意の <code class="literal">country</code> カラムに定義されているプライマリインデックスを参照します。
                </p></li></ul></div></li><li class="listitem"><p>
              サンプル Python アプリケーションをファイルにコピーします。 この例では、サンプルスクリプトが <code class="filename">multicol.py</code> という名前のファイルにコピーされます。 
            </p><p>
              サンプル Python アプリケーションは、<code class="literal">daemon_memcached</code> プラグインを介して <code class="literal">InnoDB</code> テーブルにアクセスする方法を示す、<code class="literal">multicol</code> テーブルにデータを挿入し、すべてのキーのデータを取得します。
            </p><pre class="programlisting">import sys, os
import memcache

def connect_to_memcached():
  memc = memcache.Client(['127.0.0.1:11211'], debug=0);
  print "Connected to memcached."
  return memc

def banner(message):
  print
  print "=" * len(message)
  print message
  print "=" * len(message)

country_data = [
("Canada","34820000","9984670","R"),
("USA","314242000","9826675","R"),
("Ireland","6399152","84421","L"),
("UK","62262000","243610","L"),
("Mexico","113910608","1972550","R"),
("Denmark","5543453","43094","R"),
("Norway","5002942","385252","R"),
("UAE","8264070","83600","R"),
("India","1210193422","3287263","L"),
("China","1347350000","9640821","R"),
]

def switch_table(memc,table):
  key = "@@" + table
  print "Switching default table to '" + table + "' by issuing GET for '" + key + "'."
  result = memc.get(key)

def insert_country_data(memc):
  banner("Inserting initial data via memcached interface")
  for item in country_data:
    country = item[0]
    population = item[1]
    area = item[2]
    drive_side = item[3]

    key = country
    value = "|".join([population,area,drive_side])
    print "Key = " + key
    print "Value = " + value

    if memc.add(key,value):
      print "Added new key, value pair."
    else:
      print "Updating value for existing key."
      memc.set(key,value)

def query_country_data(memc):
  banner("Retrieving data for all keys (country names)")
  for item in country_data:
    key = item[0]
    result = memc.get(key)
    print "Here is the result retrieved from the database for key " + key + ":"
    print result
    (m_population, m_area, m_drive_side) = result.split("|")
    print "Unpacked population value: " + m_population
    print "Unpacked area value      : " + m_area
    print "Unpacked drive side value: " + m_drive_side

if __name__ == '__main__':

  memc = connect_to_memcached()
  switch_table(memc,"bbb")
  insert_country_data(memc)
  query_country_data(memc)

  sys.exit(0)
</pre><p>
              サンプル Python アプリケーションのノート:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                  データ操作は <span class="command"><strong>memcached</strong></span> インタフェースを介して実行されるため、アプリケーションの実行にデータベース認可は必要ありません。 必要な情報は、<span class="command"><strong>memcached</strong></span> デーモンがリスニングするローカルシステム上のポート番号のみです。 
                </p></li><li class="listitem"><p>
                  アプリケーションで <code class="literal">multicol</code> テーブルが使用されるようにするために、<code class="literal">switch_table()</code> 関数がコールされ、<code class="literal">@@</code>テーブル記法を使用してダミーの <code class="literal">get</code> または <code class="literal">set</code> リクエストが実行されます。 リクエストの <code class="literal">name</code> 値は、<code class="literal">innodb_memcache.containers.name</code> フィールドで定義されている <code class="literal">multicol</code> テーブル識別子である <code class="literal">bbb</code> です。 
                </p><p>
                  実際のアプリケーションでは、より説明的な <code class="literal">name</code> 値を使用できます。 この例は、<code class="literal">get @@...</code> リクエストでテーブル名ではなくテーブル識別子が指定されていることを示しています。 
                </p></li><li class="listitem"><p>
                  データの挿入およびクエリーに使用されるユーティリティ関数は、<code class="literal">add</code> または <code class="literal">set</code> リクエストを使用して MySQL にデータを送信するために Python データ構造をパイプ区切りの値に変換する方法、および <code class="literal">get</code> リクエストによって返されるパイプ区切りの値を解凍する方法を示しています。 この追加処理は、単一の <span class="command"><strong>memcached</strong></span> 値を複数の MySQL テーブルのカラムにマップする場合にのみ必要です。 
                </p></li></ul></div></li><li class="listitem"><p>
              サンプル Python アプリケーションを実行します。
            </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>python multicol.py</code></strong>
</pre><p>
              成功した場合、サンプルアプリケーションは次の出力を返します:
            </p><pre class="programlisting">Connected to memcached.
Switching default table to 'bbb' by issuing GET for '@@bbb'.

==============================================
Inserting initial data via memcached interface
==============================================
Key = Canada
Value = 34820000|9984670|R
Added new key, value pair.
Key = USA
Value = 314242000|9826675|R
Added new key, value pair.
Key = Ireland
Value = 6399152|84421|L
Added new key, value pair.
Key = UK
Value = 62262000|243610|L
Added new key, value pair.
Key = Mexico
Value = 113910608|1972550|R
Added new key, value pair.
Key = Denmark
Value = 5543453|43094|R
Added new key, value pair.
Key = Norway
Value = 5002942|385252|R
Added new key, value pair.
Key = UAE
Value = 8264070|83600|R
Added new key, value pair.
Key = India
Value = 1210193422|3287263|L
Added new key, value pair.
Key = China
Value = 1347350000|9640821|R
Added new key, value pair.

============================================
Retrieving data for all keys (country names)
============================================
Here is the result retrieved from the database for key Canada:
34820000|9984670|R
Unpacked population value: 34820000
Unpacked area value      : 9984670
Unpacked drive side value: R
Here is the result retrieved from the database for key USA:
314242000|9826675|R
Unpacked population value: 314242000
Unpacked area value      : 9826675
Unpacked drive side value: R
Here is the result retrieved from the database for key Ireland:
6399152|84421|L
Unpacked population value: 6399152
Unpacked area value      : 84421
Unpacked drive side value: L
Here is the result retrieved from the database for key UK:
62262000|243610|L
Unpacked population value: 62262000
Unpacked area value      : 243610
Unpacked drive side value: L
Here is the result retrieved from the database for key Mexico:
113910608|1972550|R
Unpacked population value: 113910608
Unpacked area value      : 1972550
Unpacked drive side value: R
Here is the result retrieved from the database for key Denmark:
5543453|43094|R
Unpacked population value: 5543453
Unpacked area value      : 43094
Unpacked drive side value: R
Here is the result retrieved from the database for key Norway:
5002942|385252|R
Unpacked population value: 5002942
Unpacked area value      : 385252
Unpacked drive side value: R
Here is the result retrieved from the database for key UAE:
8264070|83600|R
Unpacked population value: 8264070
Unpacked area value      : 83600
Unpacked drive side value: R
Here is the result retrieved from the database for key India:
1210193422|3287263|L
Unpacked population value: 1210193422
Unpacked area value      : 3287263
Unpacked drive side value: L
Here is the result retrieved from the database for key China:
1347350000|9640821|R
Unpacked population value: 1347350000
Unpacked area value      : 9640821
Unpacked drive side value: R
</pre></li><li class="listitem"><p>
              <code class="literal">innodb_memcache.containers</code> テーブルをクエリーして、<code class="literal">multicol</code> テーブルに対して前に挿入したレコードを表示します。 最初のレコードは、<code class="literal">daemon_memcached</code> プラグインの初期設定時に作成される <code class="literal">demo_test</code> テーブルのサンプルエントリです。 2 番目のレコードは、<code class="literal">multicol</code> テーブルに挿入したエントリです。 
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM innodb_memcache.containers\G</code></strong>
*************************** 1. row ***************************
                  name: aaa
             db_schema: test
              db_table: demo_test
           key_columns: c1
         value_columns: c2
                 flags: c3
            cas_column: c4
    expire_time_column: c5
unique_idx_name_on_key: PRIMARY
*************************** 2. row ***************************
                  name: bbb
             db_schema: test
              db_table: multicol
           key_columns: country
         value_columns: population,area_sq_km,drive_side
                 flags: c3
            cas_column: c4
    expire_time_column: c5
unique_idx_name_on_key: PRIMARY
</pre></li><li class="listitem"><p>
              <code class="literal">multicol</code> テーブルをクエリーして、サンプル Python アプリケーションによって挿入されたデータを表示します。 データは MySQL <a class="link" href="glossary.html#glos_query" title="クエリー">queries</a> で使用でき、SQL またはアプリケーション (適切な <a class="link" href="connectors-apis.html" title="第 29 章 Connector および API">MySQL Connector or API</a> を使用) を介して同じデータにアクセスする方法を示します。 
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM test.multicol;</code></strong>
+---------+------------+------------+------------+------+------+------+
| country | population | area_sq_km | drive_side | c3   | c4   | c5   |
+---------+------------+------------+------------+------+------+------+
| Canada  | 34820000   | 9984670    | R          |    0 |   11 |    0 |
| China   | 1347350000 | 9640821    | R          |    0 |   20 |    0 |
| Denmark | 5543453    | 43094      | R          |    0 |   16 |    0 |
| India   | 1210193422 | 3287263    | L          |    0 |   19 |    0 |
| Ireland | 6399152    | 84421      | L          |    0 |   13 |    0 |
| Mexico  | 113910608  | 1972550    | R          |    0 |   15 |    0 |
| Norway  | 5002942    | 385252     | R          |    0 |   17 |    0 |
| UAE     | 8264070    | 83600      | R          |    0 |   18 |    0 |
| UK      | 62262000   | 243610     | L          |    0 |   14 |    0 |
| USA     | 314242000  | 9826675    | R          |    0 |   12 |    0 |
+---------+------------+------------+------------+------+------+------+
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                数値として扱われるカラムの長さを定義する場合は、必要な桁数、小数点、符号文字、先頭のゼロなどを保持するのに十分なサイズを常に許可してください。 <code class="literal">VARCHAR</code> などの文字列カラムの Too-long 値は、意味のない数値を生成する可能性のある一部の文字を削除することによって切り捨てられます。 
              </p></div></li><li class="listitem"><p>
              オプションで、<span class="command"><strong>memcached</strong></span> データを格納する <code class="literal">InnoDB</code> テーブルに対してレポートタイプのクエリーを実行します。
            </p><p>
              <code class="literal">country</code> キーカラムのみでなく、任意のカラムに対して計算およびテストを実行して、SQL クエリーを介してレポートを生成できます。 (次の例では、少数の国のデータのみを使用しているため、数字は説明のみを目的としています。) 次のクエリーは、人々が右側を運転する国の平均人口、および名前が <span class="quote">「<span class="quote">U</span>」</span> で始まる国の平均サイズを返します: 
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT AVG(population) FROM multicol WHERE drive_side = 'R';</code></strong>
+-------------------+
| avg(population)   |
+-------------------+
| 261304724.7142857 |
+-------------------+

mysql&gt; <strong class="userinput"><code>SELECT SUM(area_sq_km) FROM multicol WHERE country LIKE 'U%';</code></strong>
+-----------------+
| sum(area_sq_km) |
+-----------------+
|        10153885 |
+-----------------+
</pre><p>
              <code class="literal">population</code> および <code class="literal">area_sq_km</code> のカラムには強い型指定の数値データではなく文字データが格納されるため、<code class="literal">AVG()</code> や <code class="literal">SUM()</code> などの関数は、最初に各値を数値に変換することによって機能します。 このアプローチでは、<code class="literal">&lt;</code> や <code class="literal">&gt;</code> などの演算子に<span class="emphasis"><em>機能しない</em></span>を使用します。たとえば、<code class="literal">ORDER BY population DESC</code> などの句から想定されていない文字ベースの値 <code class="literal">9 &gt; 1000</code> を比較する場合などです。 もっとも正確な型処理を行うには、数値カラムを適切な型にキャストするビューに対してクエリーを実行します。 この手法を使用すると、キャスト、フィルタリングおよび順序付けが正しいことを確認しながら、データベースアプリケーションから単純な <code class="literal">SELECT *</code> クエリーを発行できます。 次の例は、母集団の降順で上位 3 か国を検索するためにクエリーすることができるビューを示しています。結果には、<code class="literal">multicol</code> テーブルの最新データが反映され、母集団と面積の数値が数値として扱われます: 
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE VIEW populous_countries AS</code></strong>
       <strong class="userinput"><code>SELECT</code></strong>
       <strong class="userinput"><code>country,</code></strong>
       <strong class="userinput"><code>cast(population as unsigned integer) population,</code></strong>
       <strong class="userinput"><code>cast(area_sq_km as unsigned integer) area_sq_km,</code></strong>
       <strong class="userinput"><code>drive_side FROM multicol</code></strong>
       <strong class="userinput"><code>ORDER BY CAST(population as unsigned integer) DESC</code></strong>
       <strong class="userinput"><code>LIMIT 3;</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT * FROM populous_countries;</code></strong>
+---------+------------+------------+------------+
| country | population | area_sq_km | drive_side |
+---------+------------+------------+------------+
| China   | 1347350000 |    9640821 | R          |
| India   | 1210193422 |    3287263 | L          |
| USA     |  314242000 |    9826675 | R          |
+---------+------------+------------+------------+

mysql&gt; <strong class="userinput"><code>DESC populous_countries;</code></strong>
+------------+---------------------+------+-----+---------+-------+
| Field      | Type                | Null | Key | Default | Extra |
+------------+---------------------+------+-----+---------+-------+
| country    | varchar(128)        | NO   |     |         |       |
| population | bigint(10) unsigned | YES  |     | NULL    |       |
| area_sq_km | int(9) unsigned     | YES  |     | NULL    |       |
| drive_side | varchar(1)          | YES  |     | NULL    |       |
+------------+---------------------+------+-----+---------+-------+
</pre></li></ol></div></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-porting-memcached"></a>15.20.6.2 InnoDB memcached プラグインに対する memcached アプリケーションの適応</h4></div></div></div><p>
        <code class="literal">daemon_memcached</code> プラグインを使用するように既存の <span class="command"><strong>memcached</strong></span> アプリケーションを適応させる場合は、MySQL および <code class="literal">InnoDB</code> テーブルの次の側面を考慮してください:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            数バイトを超えるキー値がある場合は、<code class="literal">InnoDB</code> テーブルの <a class="link" href="glossary.html#glos_primary_key" title="主キー">primary key</a> として数値自動増分カラムを使用し、<span class="command"><strong>memcached</strong></span> キー値を含むカラムに一意の <a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">secondary index</a> を作成する方が効率的です。 これは、主キー値が (自動増分値と同様に) ソートされた順序で追加されている場合、<code class="literal">InnoDB</code> が大規模な挿入に最適なパフォーマンスを発揮するためです。 主キー値はセカンダリインデックスに含まれ、主キーが長い文字列値の場合は不要な領域を占有します。 
          </p></li><li class="listitem"><p>
            <span class="command"><strong>memcached</strong></span> を使用して複数の異なるクラスの情報を格納する場合は、データのタイプごとに個別の <code class="literal">InnoDB</code> テーブルを設定することを検討してください。 <code class="literal">innodb_memcache.containers</code> テーブルに追加のテーブル識別子を定義し、<code class="literal">@@<em class="replaceable"><code>table_id</code></em>.<em class="replaceable"><code>key</code></em></code> テーブル記を使用して異なるテーブルのアイテムを格納および取得します。 様々なタイプの情報を物理的に分割することで、最適な領域使用率、パフォーマンスおよび信頼性のために各テーブルの特性をチューニングできます。 たとえば、ブログ投稿を保持するテーブルに対しては <a class="link" href="glossary.html#glos_compression" title="圧縮">compression</a> を有効にできますが、サムネイルイメージを保持するテーブルに対しては有効にできません。 非常に重要なデータが保持されているテーブルは、別のテーブルよりも頻繁にバックアップする場合もあります。 SQL を使用してレポートを生成するために頻繁に使用されるテーブルに追加の <a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">secondary indexes</a> を作成できます。 
          </p></li><li class="listitem"><p>
            できれば、<span class="command"><strong>daemon_memcached</strong></span> プラグインで使用する安定したテーブル定義のセットを構成し、テーブルを永続的に配置したままにします。 <code class="literal">innodb_memcache.containers</code> テーブルへの変更は、<code class="literal">innodb_memcache.containers</code> テーブルへの次回のクエリー時に有効になります。 コンテナテーブルのエントリは起動時に処理され、認識されないテーブル識別子 (<code class="literal">containers.name</code> で定義) が<code class="literal">@@</code>テーブル記を使用してリクエストされるたびに参照されます。 したがって、関連するテーブル識別子を使用するとすぐに新しいエントリが表示されますが、既存のエントリへの変更を有効にするには、サーバーの再起動が必要です。 
          </p></li><li class="listitem"><p>
            デフォルトの <code class="literal">innodb_only</code> キャッシュポリシーを使用すると、<code class="literal">add()</code>, <code class="literal">set()</code>, <code class="literal">incr()</code> のコールは成功しますが、<code class="literal">while expecting 'STORED', got unexpected response 'NOT_STORED</code> などのデバッグメッセージはトリガーされます。 デバッグメッセージが発生するのは、新しい値と更新された値が、<code class="literal">innodb_only</code> キャッシュポリシーのためにメモリーキャッシュに保存されずに <code class="literal">InnoDB</code> テーブルに直接送信されるためです。 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-tuning"></a>15.20.6.3 InnoDB memcached プラグインのパフォーマンスのチューニング</h4></div></div></div><p>
        <code class="literal">InnoDB</code> を <span class="command"><strong>memcached</strong></span> と組み合せて使用すると、すぐに行うか後で行うかにかかわらず、すべてのデータをディスクに書き込む必要があるため、RAW パフォーマンスはそれ自体で <span class="command"><strong>memcached</strong></span> を使用するより多少遅くなることが予想されます。 <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインを使用する場合、同等の SQL 操作よりも優れたパフォーマンスを実現するために、<span class="command"><strong>memcached</strong></span> 操作のチューニング目標に焦点を当てます。 
      </p><p>
        ベンチマークは、<span class="command"><strong>memcached</strong></span> インタフェースを使用するクエリーおよび <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> 操作 (挿入、更新および削除) が従来の SQL より高速であることを示しています。 DML 操作では、通常、改善点が大きくなります。 したがって、最初に <span class="command"><strong>memcached</strong></span> インタフェースを使用するように書込み集中型アプリケーションを調整することを検討してください。 また、信頼性のない高速で軽量なメカニズムを使用する書込み集中型アプリケーションの適応に優先順位を付けることも検討してください。 
      </p><h5><a name="idm44761345140336"></a>SQL クエリーの改変</h5><p>
        単純な <code class="literal">GET</code> リクエストに最も適したクエリーのタイプは、<code class="literal">WHERE</code> 句に単一の句または <code class="literal">AND</code> 条件のセットを含むクエリーです:
      </p><pre class="programlisting">SQL:
SELECT col FROM tbl WHERE key = 'key_value';

memcached:
get key_value

SQL:
SELECT col FROM tbl WHERE col1 = val1 and col2 = val2 and col3 = val3;

memcached:
# Since you must always know these 3 values to look up the key,
# combine them into a unique string and use that as the key
# for all ADD, SET, and GET operations.
key_value = val1 + ":" + val2 + ":" + val3
get key_value

SQL:
SELECT 'key exists!' FROM tbl
  WHERE EXISTS (SELECT col1 FROM tbl WHERE KEY = 'key_value') LIMIT 1;

memcached:
# Test for existence of key by asking for its value and checking if the call succeeds,
# ignoring the value itself. For existence checking, you typically only store a very
# short value such as "1".
get key_value
</pre><h5><a name="idm44761345135920"></a>システムメモリーの使用</h5><p>
        最高のパフォーマンスを得るには、<code class="literal">innodb_buffer_pool_size</code> 構成オプションを使用して、システム RAM の大部分が <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> 専用である一般的なデータベースサーバーとして構成されているマシンに <code class="literal">daemon_memcached</code> プラグインをデプロイします。 マルチギガバイトバッファプールがあるシステムでは、ほとんどの操作にすでにメモリーにキャッシュされているデータが含まれる場合、スループットを最大化するために <code class="literal">innodb_buffer_pool_instances</code> の値を増やすことを検討してください。 
      </p><h5><a name="idm44761345129472"></a>冗長 I/O の削減</h5><p>
        <code class="literal">InnoDB</code> には、高い信頼性 (クラッシュの場合) と高い書込みワークロード中の I/O オーバーヘッドの量のバランスを選択できる多数の設定があります。 たとえば、<code class="literal">innodb_doublewrite</code> を <code class="literal">0</code> に、<code class="literal">innodb_flush_log_at_trx_commit</code> を <code class="literal">2</code> に設定することを検討してください。 様々な <code class="literal">innodb_flush_method</code> 設定でパフォーマンスを測定します。 
      </p><p>
        テーブル操作の I/O を削減したりチューニングしたりするその他の方法については、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8 InnoDB ディスク I/O の最適化">セクション8.5.8「InnoDB ディスク I/O の最適化」</a>を参照してください。
      </p><h5><a name="idm44761345121328"></a>トランザクションオーバーヘッドの削減</h5><p>
        <code class="literal">daemon_memcached_r_batch_size</code> および <code class="literal">daemon_memcached_w_batch_size</code> のデフォルト値の 1 は、格納または更新されたデータの結果の信頼性と安全性を最大限に高めるためのものです。
      </p><p>
        アプリケーションのタイプによっては、これらの設定の 1 つまたは両方を増やすと、頻繁な<a class="link" href="glossary.html#glos_commit" title="コミット">コミット</a>操作によるオーバーヘッドを削減できる場合もあります。 ビジー状態のシステムでは、SQL を介して行われたデータへの変更が <span class="command"><strong>memcached</strong></span> にすぐに表示されないことを知っている (つまり、<em class="replaceable"><code>N</code></em> の <code class="literal">get</code> 操作がさらに処理されるまで) <code class="literal">daemon_memcached_r_batch_size</code> を増やすことができます。 すべての書込み操作を確実に格納する必要があるデータを処理する場合は、<code class="literal">daemon_memcached_w_batch_size</code> を <code class="literal">1</code> に設定したままにします。 統計分析のみを目的とした大量の更新を処理する場合は、予期しない終了での最後の <em class="replaceable"><code>N</code></em> 更新の消失が許容されるリスクである設定を増やします。 
      </p><p>
        たとえば、ビジーブリッジを通過するトラフィックを監視し、毎日約 100,000 台の車両のデータを記録するシステムについて考えてみます。 アプリケーションがトラフィックパターンを分析するために様々なタイプの車両をカウントする場合、<code class="literal">daemon_memcached_w_batch_size</code> を <code class="literal">1</code> から <code class="literal">100</code> に変更すると、コミット操作の I/O オーバーヘッドが 99% 削減されます。 停止の場合、最大 100 個のレコードが失われます。これはエラーの許容マージンである可能性があります。 かわりに、アプリケーションが自動車ごとに自動通話回収を実行した場合は、<code class="literal">daemon_memcached_w_batch_size</code> を <code class="literal">1</code> に設定して、各通話レコードがすぐにディスクに保存されるようにします。 
      </p><p>
        <code class="literal">InnoDB</code> が <span class="command"><strong>memcached</strong></span> キー値をディスク上に編成する方法のため、作成するキーが多数ある場合は、キーを任意の順序で作成するよりも、アプリケーションのキー値でデータ項目をソートし、<code class="literal">add</code> をソート順でソートする方が高速な場合があります。
      </p><p>
        通常の <span class="command"><strong>memcached</strong></span> ディストリビューションの一部であるが、<code class="literal">daemon_memcached</code> プラグインには含まれていない <span class="command"><strong>memslap</strong></span> コマンドは、異なる構成をベンチマークする場合に役立ちます。 また、独自のベンチマークで使用するサンプルのキーと値のペアを生成するためにも使用できます。 詳細は、<a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/ha-memcached-interfaces-libmemcached.html#ha-memcached-interfaces-libmemcached-utilities" target="_top"><span class="command"><strong>libmemcached</strong></span> Command-Line Utilities</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-txn"></a>15.20.6.4 InnoDB memcached プラグインのトランザクション動作の制御</h4></div></div></div><p>
        従来の <span class="command"><strong>memcached</strong></span> とは異なり、<code class="literal">daemon_memcached</code> プラグインを使用すると、<code class="literal">add</code>, <code class="literal">set</code>, <code class="literal">incr</code> のコールによって生成されるデータ値の永続性などを制御できます。 デフォルトでは、<span class="command"><strong>memcached</strong></span> インタフェースを介して書き込まれたデータはディスクに格納され、<code class="literal">get</code> のコールはディスクから最新の値を返します。 デフォルトの動作では最適な RAW パフォーマンスは提供されませんが、<code class="literal">InnoDB</code> テーブルの SQL インタフェースと比べて高速です。 
      </p><p>
        <code class="literal">daemon_memcached</code> プラグインの使用経験があるため、重要でないデータクラスの永続性設定を緩和することを検討できます。ただし、停止時に一部の更新された値が失われたり、若干古いデータが返されるリスクがあります。
      </p><h5><a name="idm44761345086720"></a>コミットの頻度</h5><p>
        永続性と本来のパフォーマンスを両立させる 1 つの条件は、新しいデータや変更されたデータが<a class="link" href="glossary.html#glos_commit" title="コミット">コミット</a>される頻度です。 データが重要な場合は、予期しない終了または停止が発生した場合に安全になるように、すぐにコミットする必要があります。 予期しない終了後にリセットされるカウンタや失われる可能性のあるロギングデータなど、データのクリティカル性が低い場合は、コミットの頻度を低くして使用可能な RAW スループットを高くすることをお薦めします。 
      </p><p>
        <span class="command"><strong>memcached</strong></span> 操作によって基礎となる <code class="literal">InnoDB</code> テーブルのデータが挿入、更新または削除される場合、変更は <code class="literal">InnoDB</code> テーブルに即座に (<code class="literal">daemon_memcached_w_batch_size=1</code> の場合) または後で (<code class="literal">daemon_memcached_w_batch_size</code> 値が 1 より大きい場合) コミットされる可能性があります。 いずれの場合も、変更はロールバックできません。 ビジー時間中に高い I/O オーバーヘッドを回避するために <code class="literal">daemon_memcached_w_batch_size</code> の値を増やすと、ワークロードが減少したときにコミットの頻度が低下する可能性があります。 安全策として、バックグラウンドスレッドで、<span class="command"><strong>memcached</strong></span> API 経由で行なった変更を一定の間隔で自動的にコミットします。 間隔は、<code class="literal">5</code> 秒のデフォルト設定を持つ <code class="literal">innodb_api_bk_commit_interval</code> 構成オプションによって制御されます。 
      </p><p>
        <span class="command"><strong>memcached</strong></span> 操作によって基礎となる <code class="literal">InnoDB</code> テーブルのデータが挿入または更新されると、MySQL 側でまだコミットされていない場合でも、新しい値はメモリーキャッシュに残されるため、変更されたデータは他の <span class="command"><strong>memcached</strong></span> リクエストにすぐに表示されます。
      </p><h5><a name="idm44761345070960"></a>トランザクションの分離</h5><p>
        <code class="literal">get</code> や <code class="literal">incr</code> などの <span class="command"><strong>memcached</strong></span> 操作によって基礎となる <code class="literal">InnoDB</code> テーブルに対するクエリーまたは DML 操作が発生した場合、操作でテーブルに書き込まれた最新のデータ、コミットされたデータのみ、またはトランザクション <a class="link" href="glossary.html#glos_isolation_level" title="分離レベル">isolation level</a> のその他のバリエーションを表示するかどうかを制御できます。 この機能を制御するには、<code class="literal">innodb_api_trx_level</code> 構成オプションを使用します。 このオプションに指定された数値は、<code class="literal">REPEATABLE READ</code> などの分離レベルに対応します。 その他の設定の詳細は、<code class="literal">innodb_api_trx_level</code> オプションの説明を参照してください。 
      </p><p>
        厳密な分離レベルでは、取得したデータが突然ロールバックまたは変更されず、後続のクエリーで異なる値が返されることはありません。 ただし、厳密な分離レベルでは、待機を引き起こす可能性のある <a class="link" href="glossary.html#glos_locking" title="ロック">locking</a> オーバーヘッドの増加が必要になります。 長時間実行トランザクションを使用しない NoSQL 形式のアプリケーションの場合は、通常、デフォルトの分離レベルを使用するか、より厳しくない分離レベルに切り替えることができます。 
      </p><h5><a name="idm44761345059664"></a>memcached DML 操作の行ロックの無効化</h5><p>
        <code class="literal">innodb_api_disable_rowlock</code> オプションを使用すると、<code class="literal">daemon_memcached</code> プラグインを介した <span class="command"><strong>memcached</strong></span> リクエストによって DML 操作が発生した場合に行ロックを無効にできます。 デフォルトでは、<code class="literal">innodb_api_disable_rowlock</code> は <code class="literal">OFF</code> に設定されており、これは <span class="command"><strong>memcached</strong></span> が <code class="literal">get</code> および <code class="literal">set</code> 操作の行ロックを要求することを意味します。 <code class="literal">innodb_api_disable_rowlock</code> を <code class="literal">ON</code> に設定すると、<span class="command"><strong>memcached</strong></span> は行ロックの代わりに、テーブルロックをリクエストします。 
      </p><p>
        <code class="literal">innodb_api_disable_rowlock</code> オプションは動的ではありません。 起動時に <span class="command"><strong>mysqld</strong></span> コマンドラインで指定するか、MySQL 構成ファイルに入力する必要があります。 
      </p><h5><a name="idm44761345047472"></a>DDL の許可または禁止</h5><p>
        デフォルトでは、<code class="literal">daemon_memcached</code> プラグインで使用されるテーブルに対して <code class="literal">ALTER TABLE</code> などの <a class="link" href="glossary.html#glos_ddl" title="DDL">DDL</a> 操作を実行できます。 これらのテーブルが高スループットアプリケーションに使用される場合の潜在的な速度低下を回避するには、起動時に <code class="literal">innodb_api_enable_mdl</code> を有効にして、これらのテーブルに対する DDL 操作を無効にします。 このオプションは、<span class="command"><strong>memcached</strong></span> と SQL の両方を介して同じテーブルにアクセスする場合にはあまり適切ではありません。これは、テーブルに対する <code class="literal">CREATE INDEX</code> ステートメントがブロックされるためです。これは、レポートクエリーの実行に重要な場合があるためです。 
      </p><h5><a name="idm44761345039744"></a>ディスク、メモリーまたはその両方へのデータの格納</h5><p>
        <code class="literal">innodb_memcache.cache_policies</code> テーブルでは、<span class="command"><strong>memcached</strong></span> インタフェースを介してディスクに書き込まれたデータを格納するか (<code class="literal">innodb_only</code>、デフォルト)、従来の <span class="command"><strong>memcached</strong></span> (<code class="literal">cache_only</code>) と同様にメモリー内のみに格納するか、またはその両方 (<code class="literal">caching</code>) を指定します。
      </p><p>
        <code class="literal">caching</code> 設定では、<span class="command"><strong>memcached</strong></span> がメモリー内からキーを検出できない場合、<code class="literal">InnoDB</code> テーブル内から値を検索します。 <code class="literal">InnoDB</code> テーブルのディスクで値が更新されたが、まだメモリーキャッシュから期限切れになっていない場合、<code class="literal">caching</code> 設定で <code class="literal">get</code> コールから返される値は期限切れになる可能性があります。 
      </p><p>
        キャッシュポリシーは、<code class="literal">get</code>、<code class="literal">set</code> (<code class="literal">incr</code> および <code class="literal">decr</code> を含む)、<code class="literal">delete</code>、および <code class="literal">flush</code> 操作で個々に設定できます。
      </p><p>
        たとえば、<code class="literal">get</code> および <code class="literal">set</code> 操作で、テーブルを、および同時に (<code class="literal">caching</code> 設定を使用して)<span class="command"><strong>memcached</strong></span> メモリーキャッシュをクエリーまたは更新でき、一方、<code class="literal">delete</code>、<code class="literal">flush</code>、またはその両方が (<code class="literal">cache_only</code> 設定を使用して) メモリー内コピーでのみ動作するようにします。 このようにして、アイテムを削除またはフラッシュすると、そのアイテムはキャッシュからのみ期限切れになり、アイテムが次回リクエストされたときに <code class="literal">InnoDB</code> テーブルから最新の値が返されます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM innodb_memcache.cache_policies;</code></strong>
+--------------+-------------+-------------+---------------+--------------+
| policy_name  | get_policy  | set_policy  | delete_policy | flush_policy |
+--------------+-------------+-------------+---------------+--------------+
| cache_policy | innodb_only | innodb_only | innodb_only   | innodb_only  |
+--------------+-------------+-------------+---------------+--------------+

mysql&gt; <strong class="userinput"><code>UPDATE innodb_memcache.cache_policies SET set_policy = 'caching'</code></strong>
       <strong class="userinput"><code>WHERE policy_name = 'cache_policy';</code></strong>
</pre><p>
        <code class="literal">innodb_memcache.cache_policies</code> の値は、起動時にのみ読み取られます。 このテーブルの値を変更したら、<code class="literal">daemon_memcached</code> プラグインをアンインストールして再インストールし、変更が有効になるようにします。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UNINSTALL PLUGIN daemon_memcached;</code></strong>

mysql&gt; <strong class="userinput"><code>INSTALL PLUGIN daemon_memcached soname "libmemcached.so";</code></strong>
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-dml"></a>15.20.6.5 memcached 操作に合わせた DML ステートメントの改変</h4></div></div></div><p>
        ベンチマークは、<code class="literal">daemon_memcached</code> プラグインがクエリーを高速化するよりも <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> 操作 (挿入、更新および削除) を高速化することを示しています。 したがって、I/O-bound,である書込み集中型アプリケーションに初期開発作業に焦点を当て、新しい書込み集中型アプリケーション用に <code class="literal">daemon_memcached</code> プラグインとともに MySQL を使用する機会を探すことを検討してください。 
      </p><p>
        単一行 DML ステートメントは、<code class="literal">memcached</code> 操作に変換する最も簡単なタイプのステートメントです。 <code class="literal">INSERT</code> は <code class="literal">add</code> になり、<code class="literal">UPDATE</code> は <code class="literal">set</code>、<code class="literal">incr</code> または <code class="literal">decr</code> になり、<code class="literal">DELETE</code> は <code class="literal">delete</code> になります。 <em class="replaceable"><code>key</code></em> はテーブル内で一意であるため、これらの操作は、<span class="command"><strong>memcached</strong></span> インタフェースを介して発行された場合にのみ影響を受けることが保証されます。 
      </p><p>
        次の SQL の例では、<code class="literal">t1</code> は、<code class="literal">innodb_memcache.containers</code> テーブルの構成に基づいて、<span class="command"><strong>memcached</strong></span> 操作に使用されるテーブルを参照します。<code class="literal">key</code> は <code class="literal">key_columns</code> の下にリストされているカラムを示し、<code class="literal">val</code> は <code class="literal">value_columns</code> の下にリストされているカラムを示します。

</p><pre class="programlisting">INSERT INTO t1 (key,val) VALUES (<em class="replaceable"><code>some_key</code></em>,<em class="replaceable"><code>some_value</code></em>);
SELECT val FROM t1 WHERE key = <em class="replaceable"><code>some_key</code></em>;
UPDATE t1 SET val = <em class="replaceable"><code>new_value</code></em> WHERE key = <em class="replaceable"><code>some_key</code></em>;
UPDATE t1 SET val = val + x WHERE key = <em class="replaceable"><code>some_key</code></em>;
DELETE FROM t1 WHERE key = <em class="replaceable"><code>some_key</code></em>;
</pre><p>
      </p><p>
        テーブルからすべての行を削除する次の <code class="literal">TRUNCATE TABLE</code> および <code class="literal">DELETE</code> ステートメントは、前の例のように <code class="literal">t1</code> が <span class="command"><strong>memcached</strong></span> 操作のテーブルとして構成されている <code class="literal">flush_all</code> 操作に対応しています。
      </p><pre class="programlisting">TRUNCATE TABLE t1;
DELETE FROM t1;
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-ddl"></a>15.20.6.6 ベースとなる InnoDB テーブルでの DML および DDL ステートメントの実行</h4></div></div></div><p>
        基礎となる <code class="literal">InnoDB</code> テーブル (デフォルトでは <code class="literal">test.demo_test</code>) には、標準 SQL インタフェースを介してアクセスできます。 ただし、いくつかの制約があります。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="command"><strong>memcached</strong></span> インタフェースを介してもアクセスされるテーブルをクエリーする場合は、すべての書込み操作の後ではなく、定期的にコミットされるように <span class="command"><strong>memcached</strong></span> 操作を構成できることに注意してください。 この動作は、<code class="literal">daemon_memcached_w_batch_size</code> オプションによって制御されます。 このオプションが <code class="literal">1</code> より大きい値に設定されている場合は、<code class="literal">READ UNCOMMITTED</code> クエリーを使用して、挿入されたばかりの行を検索します。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET SESSSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT * FROM demo_test;</code></strong>
+------+------+------+------+-----------+------+------+------+------+------+------+
| cx   | cy   | c1   | cz   | c2        | ca   | CB   | c3   | cu   | c4   | C5   |
+------+------+------+------+-----------+------+------+------+------+------+------+
| NULL | NULL | a11  | NULL | 123456789 | NULL | NULL |   10 | NULL |    3 | NULL |
+------+------+------+------+-----------+------+------+------+------+------+------+
</pre></li><li class="listitem"><p>
            <span class="command"><strong>memcached</strong></span> インタフェースを介してもアクセスされる SQL を使用してテーブルを変更する場合、読取り操作ごとではなく、新しいトランザクションを定期的に開始するように <span class="command"><strong>memcached</strong></span> 操作を構成できます。 この動作は、<code class="literal">daemon_memcached_r_batch_size</code> オプションによって制御されます。 このオプションが <code class="literal">1</code> より大きい値に設定されている場合、SQL を使用してテーブルに加えられた変更は、<span class="command"><strong>memcached</strong></span> 操作ですぐには表示されません。 
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> テーブルは、IS (インテント共有) または IX (インテント排他) のいずれかで、トランザクション内のすべての操作に対してロックされています。 <code class="literal">daemon_memcached_r_batch_size</code> および <code class="literal">daemon_memcached_w_batch_size</code> を <code class="literal">1</code> のデフォルト値から大幅に増やすと、各操作間でテーブルがロックされる可能性が高くなり、テーブルに対する <a class="link" href="glossary.html#glos_ddl" title="DDL">DDL</a> ステートメントが防止されます。 
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-memcached-replication"></a>15.20.7 InnoDB memcached プラグインとレプリケーション</h3></div></div></div><p>
      <code class="literal">daemon_memcached</code> プラグインは MySQL <a class="link" href="glossary.html#glos_binary_log" title="バイナリログ">binary log</a> をサポートしているため、<span class="command"><strong>memcached</strong></span> インタフェースを介してソースサーバーをレプリケートし、バックアップ、集中型の読取りワークロードおよび高可用性のバランスを取ることができます。 バイナリロギングでは、すべての <span class="command"><strong>memcached</strong></span> コマンドがサポートされます。 
    </p><p>
      レプリカサーバーに <code class="literal">daemon_memcached</code> プラグインを設定する必要はありません。 この構成の主な利点は、ソースでの書込みスループットの向上です。 レプリケーションメカニズムの速度は影響を受けません。 
    </p><p>
      次のセクションでは、MySQL レプリケーションで <code class="literal">daemon_memcached</code> プラグインを使用するときにバイナリログ機能を使用する方法について説明します。 <a class="xref" href="innodb-storage-engine.html#innodb-memcached-setup" title="15.20.3 InnoDB memcached プラグインの設定">セクション15.20.3「InnoDB memcached プラグインの設定」</a> で説明されている設定が完了していることを前提としています。 
    </p><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-replication-enable-binlog"></a>InnoDB memcached バイナリログの有効化</h4></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            MySQL <a class="link" href="glossary.html#glos_binary_log" title="バイナリログ">binary log</a> で <code class="literal">daemon_memcached</code> プラグインを使用するには、ソースサーバーで <code class="literal">innodb_api_enable_binlog</code> 構成オプションを有効にします。 このオプションは、サーバーの起動時にのみ設定できます。 <code class="literal">--log-bin</code> オプションを使用して、ソースサーバーで MySQL バイナリログを有効にする必要もあります。 これらのオプションは、MySQL 構成ファイルまたは <span class="command"><strong>mysqld</strong></span> コマンドラインに追加できます。 
          </p><pre class="programlisting">mysqld ... --log-bin -–innodb_api_enable_binlog=1
</pre></li><li class="listitem"><p>
            <a class="xref" href="replication.html#replication-howto" title="17.1.2 バイナリログファイルの位置ベースのレプリケーションの設定">セクション17.1.2「バイナリログファイルの位置ベースのレプリケーションの設定」</a> の説明に従って、ソースサーバーとレプリカサーバーを構成します。
          </p></li><li class="listitem"><p>
            <span class="command"><strong>mysqldump</strong></span> を使用して、ソースデータスナップショットを作成し、スナップショットをレプリカサーバーに同期します。
          </p><pre class="programlisting">source shell&gt; <strong class="userinput"><code>mysqldump --all-databases --lock-all-tables &gt; dbdump.db</code></strong>
replica shell&gt; <strong class="userinput"><code>mysql &lt; dbdump.db</code></strong>
</pre></li><li class="listitem"><p>
            ソースサーバーで、<code class="literal">SHOW MASTER STATUS</code> を発行してソースバイナリログ座標を取得します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW MASTER STATUS;</code></strong>
</pre></li><li class="listitem"><p>
            レプリカサーバーで、(MySQL 8.0.23 の) <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントまたは (MySQL 8.0.23 の前の) <code class="literal">CHANGE MASTER TO</code> ステートメントを使用して、ソースバイナリログ座標を使用するレプリカサーバーを設定します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO</code></strong>
       <strong class="userinput"><code>MASTER_HOST='localhost',</code></strong>
       <strong class="userinput"><code>MASTER_USER='root',</code></strong>
       <strong class="userinput"><code>MASTER_PASSWORD='',</code></strong>
       <strong class="userinput"><code>MASTER_PORT = 13000,</code></strong>
       <strong class="userinput"><code>MASTER_LOG_FILE='0.000001,</code></strong>
       <strong class="userinput"><code>MASTER_LOG_POS=114;</code></strong>

Or from MySQL 8.0.23:
mysql&gt; <strong class="userinput"><code>CHANGE REPLICATION SOURCE TO</code></strong>
       <strong class="userinput"><code>SOURCE_HOST='localhost',</code></strong>
       <strong class="userinput"><code>SOURCE_USER='root',</code></strong>
       <strong class="userinput"><code>SOURCE_PASSWORD='',</code></strong>
       <strong class="userinput"><code>SOURCE_PORT = 13000,</code></strong>
       <strong class="userinput"><code>SOURCE_LOG_FILE='0.000001,</code></strong>
       <strong class="userinput"><code>SOURCE_LOG_POS=114;</code></strong></pre></li><li class="listitem"><p>
            レプリカを起動します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>START SLAVE;</code></strong>
Or from MySQL 8.0.22:
mysql&gt; <strong class="userinput"><code>START REPLICA;</code></strong>
</pre><p>
            エラーログに次のような出力が出力された場合、レプリカはレプリケーションの準備ができています。
          </p><pre class="programlisting">2013-09-24T13:04:38.639684Z 49 [Note] Replication I/O thread: connected to
source 'root@localhost:13000', replication started in log '0.000001'
at position 114
</pre></li></ol></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-replication-testing"></a>InnoDB memcached レプリケーション構成のテスト</h4></div></div></div><p>
        この例では、<span class="command"><strong>memcached</strong></span> および telnet を使用して <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> レプリケーション構成をテストし、データを挿入、更新および削除する方法を示します。 MySQL クライアントは、ソースサーバーとレプリカサーバーの結果を検証するために使用されます。 
      </p><p>
        この例では、<code class="literal">daemon_memcached</code> プラグインの初期設定時に <code class="filename">innodb_memcached_config.sql</code> 構成スクリプトによって作成された <code class="literal">demo_test</code> テーブルを使用します。 <code class="literal">demo_test</code> テーブルには、単一のサンプルレコードが含まれます。 
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <code class="literal">set</code> コマンドを使用して、キーが <code class="literal">test1</code>、フラグ値が <code class="literal">10</code>、有効期限値が <code class="literal">0</code>、cas 値が 1 および <code class="literal">t1</code> のレコードを挿入します。
          </p><pre class="programlisting"><strong class="userinput"><code>telnet 127.0.0.1 11211</code></strong>
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
<strong class="userinput"><code>set test1 10 0 1</code></strong>
<strong class="userinput"><code>t1</code></strong>
STORED
</pre></li><li class="listitem"><p>
            ソースサーバーで、レコードが <code class="literal">demo_test</code> テーブルに挿入されたことを確認します。 <code class="literal">demo_test</code> テーブルが以前に変更されていないと仮定すると、2 つのレコードがあります。 キーが <code class="literal">AA</code> で、キーが <code class="literal">test1</code> のレコードの例を示します。 <code class="literal">c1</code> カラムはキーに、<code class="literal">c2</code> カラムは値に、<code class="literal">c3</code> カラムはフラグ値に、<code class="literal">c4</code> カラムは cas 値に、<code class="literal">c5</code> カラムは有効期限にマップされます。 有効期限は未使用であるため、0 に設定されました。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM test.demo_test;</code></strong>
+-------+--------------+------+------+------+
| c1    | c2           | c3   | c4   | c5   |
+-------+--------------+------+------+------+
| AA    | HELLO, HELLO |    8 |    0 |    0 |
| test1 | t1           |   10 |    1 |    0 |
+-------+--------------+------+------+------+
</pre></li><li class="listitem"><p>
            同じレコードがレプリカサーバーにレプリケートされたことを確認する場合に選択します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM test.demo_test;</code></strong>
+-------+--------------+------+------+------+
| c1    | c2           | c3   | c4   | c5   |
+-------+--------------+------+------+------+
| AA    | HELLO, HELLO |    8 |    0 |    0 |
| test1 | t1           |   10 |    1 |    0 |
+-------+--------------+------+------+------+
</pre></li><li class="listitem"><p>
            <code class="literal">set</code> コマンドを使用して、キーを <code class="literal">new</code> の値に更新します。
          </p><pre class="programlisting"><strong class="userinput"><code>telnet 127.0.0.1 11211</code></strong>
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
<strong class="userinput"><code>set test1 10 0 2</code></strong>
<strong class="userinput"><code>new</code></strong>
STORED
</pre><p>
            更新はレプリカサーバーにレプリケートされます (<code class="literal">cas</code> 値も更新されます)。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM test.demo_test;</code></strong>
+-------+--------------+------+------+------+
| c1    | c2           | c3   | c4   | c5   |
+-------+--------------+------+------+------+
| AA    | HELLO, HELLO |    8 |    0 |    0 |
| test1 | new          |   10 |    2 |    0 |
+-------+--------------+------+------+------+
</pre></li><li class="listitem"><p>
            <code class="literal">delete</code> コマンドを使用して <code class="literal">test1</code> レコードを削除します。
          </p><pre class="programlisting"><strong class="userinput"><code>telnet 127.0.0.1 11211</code></strong>
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
<strong class="userinput"><code>delete test1</code></strong>
DELETED
</pre><p>
            <code class="literal">delete</code> 操作がレプリカにレプリケートされると、レプリカ上の <code class="literal">test1</code> レコードも削除されます。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM test.demo_test;</code></strong>
+----+--------------+------+------+------+
| c1 | c2           | c3   | c4   | c5   |
+----+--------------+------+------+------+
| AA | HELLO, HELLO |    8 |    0 |    0 |
+----+--------------+------+------+------+
</pre></li><li class="listitem"><p>
            <code class="literal">flush_all</code> コマンドを使用して、テーブルからすべての行を削除します。
          </p><pre class="programlisting"><strong class="userinput"><code>telnet 127.0.0.1 11211</code></strong>
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
<strong class="userinput"><code>flush_all</code></strong>
OK
</pre><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM test.demo_test;</code></strong>
Empty set (0.00 sec)
</pre></li><li class="listitem"><p>
            ソースサーバーに Telnet し、2 つの新しいレコードを入力します。
          </p><pre class="programlisting"><strong class="userinput"><code>telnet 127.0.0.1 11211</code></strong>
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'
<strong class="userinput"><code>set test2 10 0 4</code></strong>
<strong class="userinput"><code>again</code></strong>
STORED
<strong class="userinput"><code>set test3 10 0 5</code></strong>
<strong class="userinput"><code>again1</code></strong>
STORED
</pre></li><li class="listitem"><p>
            2 つのレコードがレプリカサーバーにレプリケートされたことを確認します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM test.demo_test;</code></strong>
+-------+--------------+------+------+------+
| c1    | c2           | c3   | c4   | c5   |
+-------+--------------+------+------+------+
| test2 | again        |   10 |    4 |    0 |
| test3 | again1       |   10 |    5 |    0 |
+-------+--------------+------+------+------+
</pre></li><li class="listitem"><p>
            <code class="literal">flush_all</code> コマンドを使用して、テーブルからすべての行を削除します。
          </p><pre class="programlisting"><strong class="userinput"><code>telnet 127.0.0.1 11211</code></strong>
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
<strong class="userinput"><code>flush_all</code></strong>
OK
</pre></li><li class="listitem"><p>
            <code class="literal">flush_all</code> 操作がレプリカサーバーでレプリケートされたことを確認します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM test.demo_test;</code></strong>
Empty set (0.00 sec)
</pre></li></ol></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-binlog-notes"></a>InnoDB memcached バイナリログノート</h4></div></div></div><p>
        バイナリログ形式:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ほとんどの <span class="command"><strong>memcached</strong></span> 操作は (挿入、削除、更新に類似した) <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> ステートメントにマップされます。 MySQL サーバーでは実際の SQL ステートメントが処理されないため、すべての <span class="command"><strong>memcached</strong></span> コマンド (<code class="literal">flush_all</code> を除く) で行ベースのレプリケーション (RBR) ロギングが使用され、これはサーバーの <code class="literal">binlog_format</code> 設定とは無関係です。 
          </p></li><li class="listitem"><p>
            <span class="command"><strong>memcached</strong></span> <code class="literal">flush_all</code> コマンドは、MySQL 5.7 以前の <code class="literal">TRUNCATE TABLE</code> コマンドにマップされます。 <a class="link" href="glossary.html#glos_ddl" title="DDL">DDL</a> コマンドはステートメントベースのロギングのみを使用できるため、<code class="literal">flush_all</code> コマンドは <code class="literal">TRUNCATE TABLE</code> ステートメントを送信することによってレプリケートされます。 MySQL 8.0 以降では、<code class="literal">flush_all</code> は <code class="literal">DELETE</code> にマップされますが、<code class="literal">TRUNCATE TABLE</code> ステートメントを送信することでレプリケートされます。 
          </p></li></ul></div><p>
        トランザクション:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>の概念は、これまで通常は <span class="command"><strong>memcached</strong></span> アプリケーションの一部をなすものではありませんでした。 パフォーマンスを考慮するために、<code class="literal">daemon_memcached_r_batch_size</code> および <code class="literal">daemon_memcached_w_batch_size</code> を使用して、読取りおよび書込みトランザクションのバッチサイズを制御します。 これらの設定はレプリケーションには影響しません。 基礎となる <code class="literal">InnoDB</code> テーブルに対する各 SQL 操作は、正常に完了した後にレプリケートされます。 
          </p></li><li class="listitem"><p>
            <code class="literal">daemon_memcached_w_batch_size</code> のデフォルト値は <code class="literal">1</code> です。これは、各 <span class="command"><strong>memcached</strong></span> 書込み操作がただちにコミットされることを意味します。 このデフォルト設定では、ソースサーバーとレプリカサーバーに表示されるデータの不整合を回避するために、一定量のパフォーマンスオーバーヘッドが発生します。 レプリケートされたレコードは、常にレプリカサーバーですぐに使用できます。 <code class="literal">daemon_memcached_w_batch_size</code> を <code class="literal">1</code> より大きい値に設定すると、<span class="command"><strong>memcached</strong></span> を介して挿入または更新されたレコードはすぐにソースサーバーに表示されません。コミット前にソースサーバー上のレコードを表示するには、<code class="literal">SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED</code> を発行します。 
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-memcached-internals"></a>15.20.8 InnoDB memcached プラグインの内部</h3></div></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-api"></a>InnoDB memcached プラグイン用の InnoDB API</h4></div></div></div><p>
        <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> エンジンは、埋込み <code class="literal">InnoDB</code> から直接採用された <code class="literal">InnoDB</code> API を介して <code class="literal">InnoDB</code> にアクセスします。 <code class="literal">InnoDB</code> API 関数は、コールバック関数として <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> エンジンに渡されます。 <code class="literal">InnoDB</code> API 関数は、<code class="literal">InnoDB</code> テーブルに直接アクセスします。ほとんどの場合、DML 操作ですが、<code class="literal">TRUNCATE TABLE</code> は例外です。 
      </p><p>
        <span class="command"><strong>memcached</strong></span> コマンドは、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> API を介して実装されます。 次のテーブルに、<span class="command"><strong>memcached</strong></span> コマンドが DML または DDL 操作にどのようにマップされるかを示します。 
      </p><div class="table"><a name="idm44761344791712"></a><p class="title"><b>表 15.27 memcached コマンドおよび関連する DML または DDL 操作</b></p><div class="table-contents"><table frame="all" summary="memcached commands and associated DML or DDL operations."><col style="width: 25%"><col style="width: 75%"><thead><tr>
            <th>memcached コマンド</th>
            <th>DML または DDL 操作</th>
          </tr></thead><tbody><tr>
            <td><code class="literal">get</code></td>
            <td>読み取り/フェッチコマンド</td>
          </tr><tr>
            <td><code class="literal">set</code></td>
            <td><code class="literal">INSERT</code> または <code class="literal">UPDATE</code> が続く検索 (キーが存在するかどうかによる)</td>
          </tr><tr>
            <td><code class="literal">add</code></td>
            <td><code class="literal">INSERT</code> または <code class="literal">UPDATE</code> が続く検索</td>
          </tr><tr>
            <td><code class="literal">replace</code></td>
            <td><code class="literal">UPDATE</code> が続く検索</td>
          </tr><tr>
            <td><code class="literal">append</code></td>
            <td>検索の後に <code class="literal">UPDATE</code> が続きます (<code class="literal">UPDATE</code> の前に結果にデータを追加します)</td>
          </tr><tr>
            <td><code class="literal">prepend</code></td>
            <td>検索の後に <code class="literal">UPDATE</code> が続く (<code class="literal">UPDATE</code> の前にデータを結果の先頭に付加する)</td>
          </tr><tr>
            <td><code class="literal">incr</code></td>
            <td><code class="literal">UPDATE</code> が続く検索</td>
          </tr><tr>
            <td><code class="literal">decr</code></td>
            <td><code class="literal">UPDATE</code> が続く検索</td>
          </tr><tr>
            <td><code class="literal">delete</code></td>
            <td><code class="literal">DELETE</code> が続く検索</td>
          </tr><tr>
            <td><code class="literal">flush_all</code></td>
            <td><code class="literal">TRUNCATE TABLE</code> (DDL)</td>
          </tr></tbody></table></div></div><br class="table-break"></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-config-tables"></a>InnoDB memcached プラグインの構成テーブル</h4></div></div></div><a class="indexterm" name="idm44761344749904"></a><a class="indexterm" name="idm44761344748432"></a><a class="indexterm" name="idm44761344747040"></a><a class="indexterm" name="idm44761344745648"></a><p>
        このセクションでは、<code class="literal">daemon_memcached</code> プラグインで使用される構成テーブルについて説明します。 <code class="literal">cache_policies</code> テーブル、<code class="literal">config_options</code> テーブルおよび <code class="literal">containers</code> テーブルは、<code class="literal">innodb_memcache</code> データベースの <code class="filename">innodb_memcached_config.sql</code> 構成スクリプトによって作成されます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>USE innodb_memcache;</code></strong>
Database changed
mysql&gt; <strong class="userinput"><code>SHOW TABLES;</code></strong>
+---------------------------+
| Tables_in_innodb_memcache |
+---------------------------+
| cache_policies            |
| config_options            |
| containers                |
+---------------------------+
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-cache-policies-table"></a>cache_policies テーブル</h4></div></div></div><p>
        <code class="literal">cache_policies</code> テーブルでは、<code class="literal">InnoDB</code> <code class="literal">memcached</code> インストールのキャッシュポリシーを定義します。 単一のキャッシュポリシー内で、<code class="literal">get</code>, <code class="literal">set</code>, <code class="literal">delete</code> および <code class="literal">flush</code> 操作の個々のポリシーを指定できます。 すべての操作のデフォルト設定は <code class="literal">innodb_only</code> です。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">innodb_only</code>: <code class="literal">InnoDB</code> をデータストアとして使用します。
          </p></li><li class="listitem"><p>
            <code class="literal">cache_only</code>: <span class="command"><strong>memcached</strong></span> エンジンをデータストアとして使用します。
          </p></li><li class="listitem"><p>
            <code class="literal">caching</code>: <code class="literal">InnoDB</code> と <span class="command"><strong>memcached</strong></span> エンジンの両方をデータストアとして使用します。 この状況で、<span class="command"><strong>memcached</strong></span> がメモリー内からキーを検出できない場合、<code class="literal">InnoDB</code> テーブル内から値を検索します。 
          </p></li><li class="listitem"><p>
            <code class="literal">disable</code>: キャッシュを無効にします。
          </p></li></ul></div><div class="table"><a name="idm44761344717520"></a><p class="title"><b>表 15.28 cache_policies カラム</b></p><div class="table-contents"><table frame="all" summary="Columns of the cache_policies table."><col style="width: 50%"><col style="width: 50%"><thead><tr>
            <th>カラム</th>
            <th>説明</th>
          </tr></thead><tbody><tr>
            <td><code class="literal">policy_name</code></td>
            <td>キャッシュポリシーの名前。 デフォルトのキャッシュポリシー名は <code class="literal">cache_policy</code> です。 </td>
          </tr><tr>
            <td><code class="literal">get_policy</code></td>
            <td>get 操作のキャッシュポリシー。 有効な値は、<code class="literal">innodb_only</code>, <code class="literal">cache_only</code>, <code class="literal">caching</code> または <code class="literal">disabled</code> です。 デフォルト設定は <code class="literal">innodb_only</code> です。 </td>
          </tr><tr>
            <td><code class="literal">set_policy</code></td>
            <td>set 操作のキャッシュポリシー。 有効な値は、<code class="literal">innodb_only</code>, <code class="literal">cache_only</code>, <code class="literal">caching</code> または <code class="literal">disabled</code> です。 デフォルト設定は <code class="literal">innodb_only</code> です。 </td>
          </tr><tr>
            <td><code class="literal">delete_policy</code></td>
            <td>delete 操作のキャッシュポリシー。 有効な値は、<code class="literal">innodb_only</code>, <code class="literal">cache_only</code>, <code class="literal">caching</code> または <code class="literal">disabled</code> です。 デフォルト設定は <code class="literal">innodb_only</code> です。 </td>
          </tr><tr>
            <td><code class="literal">flush_policy</code></td>
            <td>flush 操作のキャッシュポリシー。 有効な値は、<code class="literal">innodb_only</code>, <code class="literal">cache_only</code>, <code class="literal">caching</code> または <code class="literal">disabled</code> です。 デフォルト設定は <code class="literal">innodb_only</code> です。 </td>
          </tr></tbody></table></div></div><br class="table-break"></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-config-options-table"></a>config_options テーブル</h4></div></div></div><p>
        <code class="literal">config_options</code> テーブルには、SQL を使用して実行時に変更できる <span class="command"><strong>memcached</strong></span> 関連の設定が格納されます。 サポートされる構成オプションは、<code class="literal">separator</code> および <code class="literal">table_map_delimiter</code> です。 
      </p><div class="table"><a name="idm44761344678240"></a><p class="title"><b>表 15.29 config_options カラム</b></p><div class="table-contents"><table frame="all" summary="Columns of the config_options table."><col style="width: 20%"><col style="width: 80%"><thead><tr>
            <th>カラム</th>
            <th>説明</th>
          </tr></thead><tbody><tr>
            <td><code class="literal">Name</code></td>
            <td><span class="command"><strong>memcached</strong></span> 関連の構成オプションの名前。 <code class="literal">config_options</code> テーブルでは、次の構成オプションがサポートされています: <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">separator</code>: 複数の <code class="literal">value_columns</code> が定義されている場合に、1 つの長い文字列の値を別々の値に分離するために使用します。 デフォルトでは、<code class="literal">separator</code> は <code class="literal">|</code> 文字です。 たとえば、<code class="literal">col1, col2</code> を値カラムとして定義し、<code class="literal">|</code>をセパレータとして定義する場合、次の <span class="command"><strong>memcached</strong></span> コマンドを発行して、<code class="literal">col1</code> および <code class="literal">col2</code> にそれぞれ値を挿入できます: 
                  </p><pre class="programlisting">set keyx 10 0 19
valuecolx|valuecoly
</pre><p>
                    <code class="literal">valuecol1x</code> は <code class="literal">col1</code> に格納され、<code class="literal">valuecoly</code> は <code class="literal">col2</code> に格納されます。
                  </p></li><li class="listitem"><p>
                    <code class="literal">table_map_delimiter</code>: 特定のテーブル内のキーにアクセスするために、キー名に <code class="literal">@@</code> 表記を使用するときの、スキーマ名とテーブル名を区切る文字。 たとえば、<code class="literal">@@t1.some_key</code> と <code class="literal">@@t2.some_key</code> は同じキー値を持っていますが、異なるテーブルに格納されます。 
                  </p></li></ul></div></td>
          </tr><tr>
            <td><code class="literal">値</code></td>
            <td><span class="command"><strong>memcached</strong></span> 関連の構成オプションに割り当てられた値。</td>
          </tr></tbody></table></div></div><br class="table-break"></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-containers-table"></a>containers テーブル</h4></div></div></div><p>
        <code class="literal">containers</code> テーブルは、3 つの構成テーブルの中で最も重要です。 <span class="command"><strong>memcached</strong></span> 値の格納に使用される各 <code class="literal">InnoDB</code> テーブルには、<code class="literal">containers</code> テーブルのエントリが必要です。 このエントリは、<code class="literal">InnoDB</code> テーブルのカラムとコンテナテーブルのカラムの間のマッピングを提供します。これは、<code class="literal">memcached</code> が <code class="literal">InnoDB</code> テーブルを操作するために必要です。 
      </p><p>
        <code class="literal">containers</code> テーブルには、<code class="filename">innodb_memcached_config.sql</code> 構成スクリプトによって作成される <code class="literal">test.demo_test</code> テーブルのデフォルトエントリが含まれています。 独自の <code class="literal">InnoDB</code> テーブルで <code class="literal">daemon_memcached</code> プラグインを使用するには、<code class="literal">containers</code> テーブルにエントリを作成する必要があります。 
      </p><div class="table"><a name="idm44761344635920"></a><p class="title"><b>表 15.30 containers のカラム</b></p><div class="table-contents"><table frame="all" summary="Columns of the containers table."><col style="width: 30%"><col style="width: 70%"><thead><tr>
            <th>カラム</th>
            <th>説明</th>
          </tr></thead><tbody><tr>
            <td><code class="literal">name</code></td>
            <td>コンテナに付与された名前。 <code class="literal">@@</code>テーブル記法を使用して名前で <code class="literal">InnoDB</code> テーブルがリクエストされない場合、<code class="literal">daemon_memcached</code> プラグインは <code class="literal">containers.name</code> 値が <code class="literal">default</code> の <code class="literal">InnoDB</code> テーブルを使用します。 このようなエントリがない場合は、<code class="literal">containers</code> テーブルの最初のエントリが <code class="literal">name</code> (昇順) でアルファベット順に並べられて、デフォルトの <code class="literal">InnoDB</code> テーブルが決定されます。 </td>
          </tr><tr>
            <td><code class="literal">db_schema</code></td>
            <td><code class="literal">InnoDB</code> テーブルが存在するデータベースの名前。 これは必須の値です。 </td>
          </tr><tr>
            <td><code class="literal">db_table</code></td>
            <td><span class="command"><strong>memcached</strong></span> 値を格納する <code class="literal">InnoDB</code> テーブルの名前。 これは必須の値です。 </td>
          </tr><tr>
            <td><code class="literal">key_columns</code></td>
            <td><span class="command"><strong>memcached</strong></span> 操作のための検索キー値を格納する <code class="literal">InnoDB</code> テーブルのカラム。 これは必須の値です。 </td>
          </tr><tr>
            <td><code class="literal">value_columns</code></td>
            <td><code class="literal">memcached</code> データを格納する <code class="literal">InnoDB</code> テーブルのカラム (1 つ以上)。 <code class="literal">innodb_memcached.config_options</code> テーブルで指定されたセパレータ文字を使用して、複数のカラムを指定できます。 デフォルトでは、区切り文字はパイプ文字 (<span class="quote">「<span class="quote">|</span>」</span>) です。 複数カラムを指定するには、定義された区切り文字でカラムを区切ります。 たとえば、<code class="literal">col1|col2|col3</code> となります。 これは必須の値です。 </td>
          </tr><tr>
            <td><code class="literal">flags</code></td>
            <td><span class="command"><strong>memcached</strong></span> のフラグ (メイン値とともに格納および取得されるユーザー定義の数値) として使用される <code class="literal">InnoDB</code> テーブルのカラム。 <span class="command"><strong>memcached</strong></span> 値が複数のカラムにマップされている場合、フラグ値を一部の操作 (<code class="literal">incr</code>、<code class="literal">prepend</code> など) のカラム指定子として使用して、指定したカラムに対して操作を実行できます。 たとえば、<code class="literal">value_columns</code> を 3 つの <code class="literal">InnoDB</code> テーブルのカラムにマップし、一方のカラムに対してのみ増分操作を実行する場合は、<code class="literal">flags</code> カラムを使用してカラムを指定します。 <code class="literal">flags</code> カラムを使用しない場合は、未使用であることを示す <code class="literal">0</code> の値を設定します。 </td>
          </tr><tr>
            <td><code class="literal">cas_column</code></td>
            <td>比較およびスワップ (cas) 値を格納する <code class="literal">InnoDB</code> テーブルのカラム。 <code class="literal">cas_column</code> の値は、<span class="command"><strong>memcached</strong></span> が異なるサーバーにリクエストをハッシュし、データをメモリーにキャッシュする方法に関連しています。 <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインは単一の <span class="command"><strong>memcached</strong></span> デーモンと緊密に統合されており、インメモリーキャッシュメカニズムは MySQL および <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">InnoDB buffer pool</a> によって処理されるため、このカラムはほとんど必要ありません。 このカラムを使用しない場合は、<code class="literal">0</code> の値を設定して未使用であることを示します。 </td>
          </tr><tr>
            <td><code class="literal">expire_time_column</code></td>
            <td>有効期限の値を格納する <code class="literal">InnoDB</code> テーブルのカラム。 <code class="literal">expire_time_column</code> の値は、<span class="command"><strong>memcached</strong></span> が異なるサーバーにリクエストをハッシュし、データをメモリーにキャッシュする方法に関連しています。 <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインは単一の <span class="command"><strong>memcached</strong></span> デーモンと緊密に統合されており、インメモリーキャッシュメカニズムは MySQL および <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">InnoDB buffer pool</a> によって処理されるため、このカラムはほとんど必要ありません。 このカラムを使用しない場合は、<code class="literal">0</code> の値を設定して、カラムが未使用であることを示します。 最大有効期限は、<code class="literal">INT_MAX32</code> または 2147483647 秒 (約 68 年) として定義されます。 </td>
          </tr><tr>
            <td><code class="literal">unique_idx_name_on_key</code></td>
            <td>キーカラムのインデックスの名前。 これは一意のインデックスである必要があります。 これは<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>または<a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">セカンダリインデックス</a>にできます。 できれば、<code class="literal">InnoDB</code> テーブルの主キーを使用してください。 主キーを使用すると、セカンダリインデックスの使用時に実行されるルックアップが回避されます。 <span class="command"><strong>memcached</strong></span> 参照のための<a class="link" href="glossary.html#glos_covering_index" title="カバリングインデックス">カバリングインデックス</a>は作成できません。キーカラムおよび値カラムの両方に複合セカンダリインデックスを定義しようとすると、<code class="literal">InnoDB</code> はエラーを返します。 </td>
          </tr></tbody></table></div></div><br class="table-break"><h5><a name="idm44761344564080"></a>containers テーブルカラムの制約</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">db_schema</code>、<code class="literal">db_name</code>、<code class="literal">key_columns</code>、<code class="literal">value_columns</code>、および <code class="literal">unique_idx_name_on_key</code> の値を指定する必要があります。 <code class="literal">flags</code>、<code class="literal">cas_column</code>、および <code class="literal">expire_time_column</code> が使用されない場合、これらに <code class="literal">0</code> を指定します。 そうしないと、セットアップが失敗する場合があります。 
          </p></li><li class="listitem"><p>
            <code class="literal">key_columns</code>: <span class="command"><strong>memcached</strong></span> で強制される、<span class="command"><strong>memcached</strong></span> キーの最大長は 250 文字です。 マップ済みのキーは、Null 以外の <code class="literal">CHAR</code> または <code class="literal">VARCHAR</code> タイプである必要があります。 
          </p></li><li class="listitem"><p>
            <code class="literal">value_columns</code>: <code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、または <code class="literal">BLOB</code> カラムにマップされる必要があります。 長さに制約はなく、値を NULL に指定できます。 
          </p></li><li class="listitem"><p>
            <code class="literal">cas_column</code>: <code class="literal">cas</code> 値は 64 ビットの整数です。 これは少なくとも 8 バイトの <code class="literal">BIGINT</code> にマップされる必要があります。 このカラムを使用しない場合は、<code class="literal">0</code> の値を設定して未使用であることを示します。 
          </p></li><li class="listitem"><p>
            <code class="literal">expiration_time_column</code>: 少なくとも 4 バイトの <code class="literal">INTEGER</code> にマップされる必要があります。 有効期限は、Unix 時間の 32 ビット整数 (1970 年 1 月 1 日からの秒数の 32 ビット値) として、または現在時間から開始する秒数として定義されます。 後者の場合、秒数は 60*60*24*30 (30 日間の秒数) を超えないようにしてください。 クライアントから送信される数が大きい場合、サーバーはそれを現在の時間からのオフセットではなく、実際の Unix 時間値とみなします。 このカラムを使用しない場合は、<code class="literal">0</code> の値を設定して未使用であることを示します。 
          </p></li><li class="listitem"><p>
            <code class="literal">flags</code>: 少なくとも 32 ビットの <code class="literal">INTEGER</code> にマップする必要があり、NULL に指定できます。 このカラムを使用しない場合は、<code class="literal">0</code> の値を設定して未使用であることを示します。 
          </p></li></ul></div><p>
        カラム制約を強制するために、プラグインのロード時に事前検査が行われます。 不一致が見つかった場合、プラグインはロードされません。 
      </p><h5><a name="idm44761344532864"></a>複数値カラムマッピング</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            プラグインの初期化時に、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> が <code class="literal">containers</code> テーブルで定義された情報で構成されている場合、<code class="literal">containers.value_columns</code> で定義された各マップ済カラムは、マップ済 <code class="literal">InnoDB</code> テーブルに対して検証されます。 複数の <code class="literal">InnoDB</code> テーブルのカラムがマップされている場合は、各カラムが存在し、正しい型であることを確認するチェックがあります。 
          </p></li><li class="listitem"><p>
            実行時に、<code class="literal">memcached</code> の挿入操作では、マップされたカラムの数よりもデリミタ付きの値が多い場合、マップされた値の数のみが取得されます。 たとえば、マッピングされたカラムが 6 つあり、7 つの区切り値が指定されている場合、最初の 6 つの区切り値のみが使用されます。 7 番目の区切り値は無視されます。 
          </p></li><li class="listitem"><p>
            マップされたカラムより区切られた値の方が少ない場合、入力値のないカラムは NULL に設定されます。 未入力のカラムを NULL に設定できない場合、挿入操作は失敗します。 
          </p></li><li class="listitem"><p>
            テーブルにマップされた値より多くのカラムがある場合、余分なカラムは結果に影響しません。
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-demo-test-table"></a>demo_test のサンプルテーブル</h4></div></div></div><p>
        <code class="filename">innodb_memcached_config.sql</code> 構成スクリプトにより、<code class="literal">test</code> データベースに <code class="literal">demo_test</code> テーブルが作成され、これを使用して、設定後すぐに <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインのインストールを検証できます。
      </p><p>
        <code class="filename">innodb_memcached_config.sql</code> 構成スクリプトでは、<code class="literal">innodb_memcache.containers</code> テーブルに <code class="literal">demo_test</code> テーブルのエントリも作成されます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM innodb_memcache.containers\G</code></strong>
*************************** 1. row ***************************
                  name: aaa
             db_schema: test
              db_table: demo_test
           key_columns: c1
         value_columns: c2
                 flags: c3
            cas_column: c4
    expire_time_column: c5
unique_idx_name_on_key: PRIMARY

mysql&gt; <strong class="userinput"><code>SELECT * FROM test.demo_test;</code></strong>
+----+------------------+------+------+------+
| c1 | c2               | c3   | c4   | c5   |
+----+------------------+------+------+------+
| AA | HELLO, HELLO     |    8 |    0 |    0 |
+----+------------------+------+------+------+
</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-memcached-troubleshoot"></a>15.20.9 InnoDB memcached プラグインのトラブルシューティング</h3></div></div></div><p>
      このセクションでは、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインの使用時に発生する可能性のある問題について説明します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          MySQL エラーログで次のエラーが発生した場合、サーバーの起動に失敗する可能性があります:
        </p><p>
          開いているファイルの rlimit を設定する <span class="errortext">failed。 root として実行するか、小さい maxconns value.</span> をリクエストしてください 
        </p><p>
          エラーメッセージは、<span class="command"><strong>memcached</strong></span> デーモンからのものです。 1 つの解決策は、開くファイルの数について OS での制限を引き上げることです。 オープンファイル制限をチェックして増やすためのコマンドは、オペレーティングシステムによって異なります。 この例は、Linux および macOS のコマンドを示しています: 
        </p><pre class="programlisting"># Linux
shell&gt; <strong class="userinput"><code>ulimit -n</code></strong>
1024
shell&gt; <strong class="userinput"><code>ulimit -n 4096</code></strong>
shell&gt; <strong class="userinput"><code>ulimit -n</code></strong>
4096

# macOS
shell&gt; <strong class="userinput"><code>ulimit -n</code></strong>
256
shell&gt; <strong class="userinput"><code>ulimit -n 4096</code></strong>
shell&gt; <strong class="userinput"><code>ulimit -n</code></strong>
4096
</pre><p>
          もう 1 つの解決策は、<span class="command"><strong>memcached</strong></span> デーモンで許可される同時接続の数を減らすことです。 これを行うには、MySQL 構成ファイルの <code class="literal">daemon_memcached_option</code> 構成パラメータで <code class="literal">-c</code> <span class="command"><strong>memcached</strong></span> オプションをエンコードします。 <code class="literal">-c</code> オプションのデフォルト値は 1024 です。 
        </p><pre class="programlisting">[mysqld]
...
loose-daemon_memcached_option='-c 64'
</pre></li><li class="listitem"><p>
          <span class="command"><strong>memcached</strong></span> デーモンが <code class="literal">InnoDB</code> テーブルデータを格納または取得できない問題をトラブルシューティングするには、MySQL 構成ファイルの <code class="literal">daemon_memcached_option</code> 構成パラメータで <code class="literal">-vvv</code> <span class="command"><strong>memcached</strong></span> オプションをエンコードします。 MySQL エラーログを調べて、<span class="command"><strong>memcached</strong></span> 操作に関係するデバッグ出力がないか検査します。 
        </p><pre class="programlisting">[mysqld]
...
loose-daemon_memcached_option='-vvv'
</pre></li><li class="listitem"><p>
          <span class="command"><strong>memcached</strong></span> 値を保持するために指定されたカラムのデータ型が間違っている場合 (文字列型ではなく数値型など)、キーと値のペアを格納しようとすると失敗し、特定のエラーコードまたはメッセージが表示されません。
        </p></li><li class="listitem"><p>
          <code class="literal">daemon_memcached</code> プラグインによって MySQL サーバーの起動の問題が発生した場合は、MySQL 構成ファイルの<code class="literal">[mysqld]</code>グループの下に次の行を追加することで、トラブルシューティング中に <code class="literal">daemon_memcached</code> プラグインを一時的に無効にできます:
        </p><pre class="programlisting">daemon_memcached=OFF
</pre><p>
          たとえば、<code class="filename">innodb_memcached_config.sql</code> 構成スクリプトを実行して必要なデータベースとテーブルを設定する前に <code class="literal">INSTALL PLUGIN</code> ステートメントを実行すると、サーバーが予期せず終了し、起動に失敗することがあります。 <code class="literal">innodb_memcache.containers</code> テーブルのエントリを誤って構成すると、サーバーの起動に失敗する可能性もあります。 
        </p><p>
          MySQL インスタンスの <span class="command"><strong>memcached</strong></span> プラグインをアンインストールするには、次のステートメントを発行します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UNINSTALL PLUGIN daemon_memcached;</code></strong>
</pre></li><li class="listitem"><p>
          各インスタンスで <code class="literal">daemon_memcached</code> プラグインが有効になっている同じマシンで MySQL の複数のインスタンスを実行する場合は、<code class="literal">daemon_memcached_option</code> 構成パラメータを使用して、<code class="literal">daemon_memcached</code> プラグインごとに一意の <span class="command"><strong>memcached</strong></span> ポートを指定します。
        </p></li><li class="listitem"><p>
          SQL ステートメントで <code class="literal">InnoDB</code> テーブルが見つからない場合、またはテーブルにデータが見つからず、<span class="command"><strong>memcached</strong></span> API コールで必要なデータが取得される場合、<code class="literal">innodb_memcache.containers</code> テーブルの <code class="literal">InnoDB</code> テーブルのエントリが欠落しているか、<code class="literal">@@<em class="replaceable"><code>table_id</code></em></code> テーブル記法を使用して <code class="literal">get</code> または <code class="literal">set</code> リクエストを発行して正しい <code class="literal">InnoDB</code> テーブルに切り替えられていない可能性があります。 この問題は、後で MySQL サーバーを再起動せずに <code class="literal">innodb_memcache.containers</code> テーブルの既存のエントリを変更した場合にも発生する可能性があります。 フリーフォーム記憶域メカニズムは柔軟性があるため、デーモンが単一のカラムに値を格納する <code class="literal">test.demo_test</code> テーブルを使用している場合でも、<code class="literal">col1|col2|col3</code> などの複数カラム値を格納または取得するリクエストは引き続き機能します。 
        </p></li><li class="listitem"><p>
          <code class="literal">daemon_memcached</code> プラグインで使用する独自の <code class="literal">InnoDB</code> テーブルを定義し、テーブルのカラムが <code class="literal">NOT NULL</code> として定義されている場合は、<code class="literal">innodb_memcache.containers</code> テーブルにテーブルのレコードを挿入するときに <code class="literal">NOT NULL</code> カラムに値が指定されていることを確認します。 <code class="literal">innodb_memcache.containers</code> レコードの <code class="literal">INSERT</code> ステートメントに含まれるデリミタ付きの値が、マップされたカラムより少ない場合、未入力のカラムは <code class="literal">NULL</code> に設定されます。 <code class="literal">NULL</code> 値を <code class="literal">NOT NULL</code> カラムに挿入しようとすると <code class="literal">INSERT</code> が失敗し、<code class="literal">daemon_memcached</code> プラグインを再初期化して <code class="literal">innodb_memcache.containers</code> テーブルに変更を適用した後にのみ明らかになる場合があります。 
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_memcached.containers</code> テーブルの <code class="literal">cas_column</code> および <code class="literal">expire_time_column</code> フィールドが <code class="literal">NULL</code> に設定されている場合、<span class="command"><strong>memcached</strong></span> プラグインをロードしようとすると次のエラーが返されます:
        </p><pre class="programlisting">InnoDB_Memcached: column 6 in the entry for config table 'containers' in
database 'innodb_memcache' has an invalid NULL value.
</pre><p>
          <span class="command"><strong>memcached</strong></span> プラグインは、<code class="literal">cas_column</code> および <code class="literal">expire_time_column</code> カラムでの <code class="literal">NULL</code> の使用を拒否します。 カラムが使用されていない場合は、これらのカラムの値を <code class="literal">0</code> に設定します。 
        </p></li><li class="listitem"><p>
          <span class="command"><strong>memcached</strong></span> のキーと値の長さが増加するにつれて、サイズと長さの制限が生じる場合があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              キーが 250 バイトを超えると、<span class="command"><strong>memcached</strong></span> 操作はエラーを返します。 これは <span class="command"><strong>memcached</strong></span> 内での現在の固定制限値です。 
            </p></li><li class="listitem"><p>
              <code class="literal">InnoDB</code> テーブルの制限は、サイズが 768 バイト、サイズが 3072 バイトまたは <code class="literal">innodb_page_size</code> 値の半分を超える場合に発生することがあります。 これらの制限は主に、SQL を使用して値カラムにインデックスを作成し、そのカラムに対してレポート生成クエリーを実行する場合に適用されます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-limits" title="15.22 InnoDB の制限">セクション15.22「InnoDB の制限」</a> を参照してください。 
            </p></li><li class="listitem"><p>
              キーと値の組合せの最大サイズは 1 MB です。
            </p></li></ul></div></li><li class="listitem"><p>
          異なるバージョンの MySQL サーバー間で構成ファイルを共有する場合、<code class="literal">daemon_memcached</code> プラグインの最新の構成オプションを使用すると、古い MySQL バージョンで起動エラーが発生する可能性があります。 互換性の問題を回避するには、オプション名とともに <code class="literal">loose</code> 接頭辞を使用します。 たとえば、<code class="literal">daemon_memcached_option='-c 64'</code>のかわりに <code class="literal">loose-daemon_memcached_option='-c 64'</code>を使用します。 
        </p></li><li class="listitem"><p>
          文字セットの設定を検証するための制約もチェックもありません。<span class="command"><strong>memcached</strong></span> は、キーおよび値をバイト形式で格納および取得するため、文字セットの違いは区別されません。 ただし、<span class="command"><strong>memcached</strong></span> クライアントと MySQL テーブルで、同じ文字セットを使用する必要があります。 
        </p></li><li class="listitem"><p>
          <span class="command"><strong>memcached</strong></span> 接続は、インデックス付けされた仮想カラムを含むテーブルへのアクセスをブロックされます。 インデックス付き仮想カラムにアクセスするにはサーバーへのコールバックが必要ですが、<span class="command"><strong>memcached</strong></span> 接続にはサーバーコードへのアクセス権がありません。 
        </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-troubleshooting"></a>15.21 InnoDB のトラブルシューティング</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#error-creating-innodb">15.21.1 InnoDB の I/O に関する問題のトラブルシューティング</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#forcing-innodb-recovery">15.21.2 InnoDB のリカバリの強制的な実行</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-troubleshooting-datadict">15.21.3 InnoDB データディクショナリの操作のトラブルシューティング</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-error-handling">15.21.4 InnoDB のエラー処理</a></span></dt></dl></div><a class="indexterm" name="idm44761344412832"></a><p>
    <code class="literal">InnoDB</code> の問題のトラブルシューティングには、次の一般的なガイドラインが適用されます。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        操作が失敗した場合、またはバグが疑われる場合は、MySQL サーバーのエラーログを参照してください (<a class="xref" href="server-administration.html#error-log" title="5.4.2 エラーログ">セクション5.4.2「エラーログ」</a> を参照)。<a class="ulink" href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html" target="_top">Server Error Message Reference</a> では、発生する可能性のある <code class="literal">InnoDB</code> 固有の一般的なエラーのトラブルシューティング情報が提供されます。
      </p></li><li class="listitem"><p>
        障害が <a class="link" href="glossary.html#glos_deadlock" title="デッドロック">deadlock</a> に関連している場合は、各デッドロックの詳細が MySQL サーバーのエラーログに出力されるように、<code class="literal">innodb_print_all_deadlocks</code> オプションを有効にして実行します。 デッドロックの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-deadlocks" title="15.7.5 InnoDB のデッドロック">セクション15.7.5「InnoDB のデッドロック」</a> を参照してください。 
      </p></li><li class="listitem"><p>
        問題が <code class="literal">InnoDB</code> データディクショナリに関連している場合は、<a class="xref" href="innodb-storage-engine.html#innodb-troubleshooting-datadict" title="15.21.3 InnoDB データディクショナリの操作のトラブルシューティング">セクション15.21.3「InnoDB データディクショナリの操作のトラブルシューティング」</a> を参照してください。
      </p></li><li class="listitem"><p>
        トラブルシューティング時は通常、<span class="command"><strong>mysqld_safe</strong></span> 経由、または Windows サービスとしてではなく、コマンドプロンプトから MySQL サーバーを実行することが最善です。 それにより、<span class="command"><strong>mysqld</strong></span> がコンソールに出力する内容を確認できるため、何が発生しているかをより的確に把握できます。 Windows では、出力先がコンソールウィンドウになるように、<code class="option">--console</code> オプションを付けて <span class="command"><strong>mysqld</strong></span> を起動します。 
      </p></li><li class="listitem"><p>
        <a class="indexterm" name="idm44761344394096"></a> <a class="indexterm" name="idm44761344391952"></a> <code class="literal">InnoDB</code> モニターを有効にして、問題に関する情報を取得します (<a class="xref" href="innodb-storage-engine.html#innodb-monitors" title="15.17 InnoDB モニター">セクション15.17「InnoDB モニター」</a> を参照)。 その問題がパフォーマンスに関するものか、またはサーバーがハングアップしているように見える場合は、<code class="literal">InnoDB</code> の内部状態に関する情報を出力するために、標準モニターを有効にするようにしてください。 問題がロックに関するものである場合は、ロックモニターを有効にします。 テーブルの作成、テーブルスペースまたはデータディクショナリ操作に問題がある場合は、<a class="link" href="innodb-storage-engine.html#innodb-information-schema-system-tables" title="15.15.3 InnoDB INFORMATION_SCHEMA スキーマオブジェクトテーブル">InnoDB Information Schema system tables</a> を参照して <code class="literal">InnoDB</code> 内部データディクショナリの内容を調べます。 
      </p><p>
        <code class="literal">InnoDB</code> は、次の条件の下で <code class="literal">InnoDB</code> 標準モニターの出力を一時的に有効にします。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
            長いセマフォー待機
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> がバッファープール内に空きブロックを見つけることができない
          </p></li><li class="listitem"><p>
            ロックヒープまたはアダプティブハッシュインデックスによってバッファープールの 67% を超える領域が占有されている
          </p></li></ul></div></li><li class="listitem"><p>
        テーブルが破損していると思われる場合は、そのテーブルに対して <code class="literal">CHECK TABLE</code> を実行します。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="error-creating-innodb"></a>15.21.1 InnoDB の I/O に関する問題のトラブルシューティング</h3></div></div></div><a class="indexterm" name="idm44761344375376"></a><p>
      <code class="literal">InnoDB</code> の I/O に関する問題のトラブルシューティング手順は、その問題がいつ、つまり MySQL サーバーの起動中か、あるいは通常の動作中にファイルシステムレベルの問題で DML または DDL ステートメントが失敗したときのどちらで発生したかによって異なります。
    </p><h4><a name="idm44761344370800"></a>初期化の問題</h4><p>
      <code class="literal">InnoDB</code> がそのテーブルスペースまたはログファイルを初期化しようとしたときに問題が発生した場合は、<code class="literal">InnoDB</code> によって作成されたすべてのファイル、つまりすべての <code class="filename">ibdata</code> ファイルおよびすべての <code class="filename">ib_logfile</code> ファイルを削除します。 いくつかの <code class="literal">InnoDB</code> テーブルをすでに作成している場合は、MySQL データベースディレクトリから <code class="filename">.ibd</code> ファイルも削除します。 次に、再度 <code class="literal">InnoDB</code> データベースを作成してみてください。 もっとも簡単なトラブルシューティングとして、何が発生しているかがわかるように、コマンドプロンプトから MySQL サーバーを起動してください。 
    </p><h4><a name="idm44761344363376"></a>実行時の問題</h4><p>
      <code class="literal">InnoDB</code> がファイル操作中にオペレーティングシステムのエラーを出力する場合、通常、この問題には次のいずれかの解決方法があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">InnoDB</code> データファイルディレクトリと <code class="literal">InnoDB</code> ログディレクトリが存在することを確認します。
        </p></li><li class="listitem"><p>
          <span class="command"><strong>mysqld</strong></span> に、これらのディレクトリ内にファイルを作成するためのアクセス権があることを確認します。
        </p></li><li class="listitem"><p>
          指定したオプションで起動できるように、<span class="command"><strong>mysqld</strong></span> が正しい <code class="filename">my.cnf</code> または <code class="filename">my.ini</code> オプションファイルを読み取れることを確認します。
        </p></li><li class="listitem"><p>
          ディスクがいっぱいでなく、かつどのディスク割り当て制限も超えていないことを確認します。
        </p></li><li class="listitem"><p>
          サブディレクトリとデータファイルに指定した名前が衝突していないことを確認します。
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_data_home_dir</code> および <code class="literal">innodb_data_file_path</code> 値の構文を再確認します。 特に、<code class="literal">innodb_data_file_path</code> オプション内の <code class="literal">MAX</code> 値はすべて強い制限値であるため、その制限を超えると致命的エラーが発生します。 
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="forcing-innodb-recovery"></a>15.21.2 InnoDB のリカバリの強制的な実行</h3></div></div></div><a class="indexterm" name="idm44761344345264"></a><a class="indexterm" name="idm44761344342400"></a><a class="indexterm" name="idm44761344340240"></a><p>
      データベースページの破損を調査するために、<code class="literal">SELECT ... INTO OUTFILE</code> を使用して、データベースからテーブルをダンプできます。 通常は、この方法で取得されたデータのほとんどが完全な状態にあります。 重大な破損により、<code class="literal">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em></code> ステートメントまたは <code class="literal">InnoDB</code> バックグラウンド操作が予期せず終了またはアサートされたり、<code class="literal">InnoDB</code> ロールフォワードリカバリがクラッシュする可能性があります。 このような場合は、テーブルをダンプできるように、<code class="literal">innodb_force_recovery</code> オプションを使用して、バックグラウンド操作が実行されないようにして <code class="literal">InnoDB</code> ストレージエンジンを強制的に起動させることができます。 たとえば、サーバーを再起動する前に、オプションファイルの <code class="literal">[mysqld]</code> セクションに次の行を追加できます。 
    </p><pre class="programlisting">[mysqld]
innodb_force_recovery = 1
</pre><p>
      オプションファイルの使用の詳細は、<a class="xref" href="programs.html#option-files" title="4.2.2.2 オプションファイルの使用">セクション4.2.2.2「オプションファイルの使用」</a> を参照してください。
    </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
        <code class="literal">innodb_force_recovery</code> を 0 を超える値に設定するのは、緊急の状況で <code class="literal">InnoDB</code> を起動し、テーブルをダンプできるようにする場合だけにしてください。 それを行う前に、データベースの再作成が必要になった場合に備えて、データベースのバックアップコピーがあることを確認してください。 4 以上の値を指定すると、データファイルが永続的に破損する場合があります。 本番サーバーインスタンスで 4 以上の <code class="literal">innodb_force_recovery</code> 設定を使用するのは、データベースの個別の物理コピーで設定を正常にテストした後のみです。 <code class="literal">InnoDB</code> のリカバリを強制的に実行する場合は、常に <code class="literal">innodb_force_recovery=1</code> から始め、必要がある場合にのみこの値を 1 ずつ増やすようにしてください。 
      </p></div><p>
      <code class="literal">innodb_force_recovery</code> は、デフォルトでは 0 です (リカバリが強制的に実行されない通常の起動)。 <code class="literal">innodb_force_recovery</code> の許可される 0 以外の値は 1 から 6 までです。 大きい方の値には、小さい方の値の機能が含まれています。 たとえば、3 の値には、値 1 と 2 のすべての機能が含まれています。 
    </p><p>
      3 以下の <code class="literal">innodb_force_recovery</code> 値を使用してテーブルをダンプできる場合は、破損した個々のページ上の一部のデータしか失われないため、比較的安全です。 4 以上の値は、データファイルが永続的に破損する場合があるため、危険であるとみなされます。 値 6 は、データベースページが廃止された状態のままであり、<a class="link" href="glossary.html#glos_b_tree" title="B ツリー">B-trees</a> およびその他のデータベース構造が破損する可能性があるため、劇的とみなされます。 
    </p><p>
      安全策として、<code class="literal">innodb_force_recovery</code> が 0 より大きい場合、<code class="literal">InnoDB</code> は <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、または <code class="literal">DELETE</code> 操作を回避します。 <code class="literal">innodb_force_recovery</code> 設定が 4 以上の場合、<code class="literal">InnoDB</code> は読取り専用モードになります。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">1</code> (<code class="literal">SRV_FORCE_IGNORE_CORRUPT</code>)
        </p><p>
          破損した<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>を検出した場合でも、サーバーが動作できるようにします。 <code class="literal">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em></code> での破損したインデックスレコードおよびページの飛び越しを試行します。これが、テーブルのダンプに役立ちます。 
        </p></li><li class="listitem"><p>
          <code class="literal">2</code> (<code class="literal">SRV_FORCE_NO_BACKGROUND</code>)
        </p><p>
          <a class="link" href="glossary.html#glos_master_thread" title="マスタースレッド">マスタースレッド</a>や、すべての<a class="link" href="glossary.html#glos_purge_thread" title="パージスレッド">パージスレッド</a>が実行されないようにします。 <a class="link" href="glossary.html#glos_purge" title="パージ">purge</a> 操作中に予期しない終了が発生した場合、このリカバリ値によってそれが防止されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">3</code> (<code class="literal">SRV_FORCE_NO_TRX_UNDO</code>)
        </p><p>
          <a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>のあとにトランザクション<a class="link" href="glossary.html#glos_rollback" title="ロールバック">ロールバック</a>を実行しません。
        </p></li><li class="listitem"><p>
          <code class="literal">4</code> (<code class="literal">SRV_FORCE_NO_IBUF_MERGE</code>)
        </p><p>
          <a class="link" href="glossary.html#glos_insert_buffer" title="挿入バッファー">挿入バッファー</a>のマージ操作を回避します。 その操作によってクラッシュが発生しそうになった場合は、それが回避されます。 テーブル<a class="link" href="glossary.html#glos_statistics" title="統計">統計</a>を計算しません。 この値を指定すると、データファイルが永続的に破損する場合があります。 この値を使用したあと、すべてのセカンダリインデックスを削除して再作成するように準備してください。 <code class="literal">InnoDB</code> を読取り専用に設定します。 
        </p></li><li class="listitem"><p>
          <code class="literal">5</code> (<code class="literal">SRV_FORCE_NO_UNDO_LOG_SCAN</code>)
        </p><p>
          データベースを起動するときに、<a class="link" href="glossary.html#glos_undo_log" title="Undo ログ">Undo ログ</a>を参照しません。<code class="literal">InnoDB</code> は、未完了のトランザクションでさえコミット済みとして処理します。 この値を指定すると、データファイルが永続的に破損する場合があります。 <code class="literal">InnoDB</code> を読取り専用に設定します。 
        </p></li><li class="listitem"><p>
          <code class="literal">6</code> (<code class="literal">SRV_FORCE_NO_LOG_REDO</code>)
        </p><p>
          リカバリに関連した <a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">Redo ログ</a>のロールフォワードを実行しません。 この値を指定すると、データファイルが永続的に破損する場合があります。 データベースページを廃止された状態のままにし、それによって B ツリーやその他のデータベース構造にさらに多くの破損が発生する可能性があります。 <code class="literal">InnoDB</code> を読取り専用に設定します。 
        </p></li></ul></div><p>
      テーブルから <code class="literal">SELECT</code> を使用してダンプできます。 <code class="literal">innodb_force_recovery</code> 値が 3 以下の場合、<code class="literal">DROP</code> テーブルまたは <code class="literal">CREATE</code> テーブルを使用できます。 <code class="literal">DROP TABLE</code> は、3 より大きい <code class="literal">innodb_force_recovery</code> 値でもサポートされています。 <code class="literal">innodb_force_recovery</code> 値が 4 より大きい場合、<code class="literal">DROP TABLE</code> は許可されません。 
    </p><p>
      特定のテーブルがロールバック時に予期しない終了を引き起こしていることがわかっている場合は、そのテーブルを削除できます。 失敗した大量のインポートまたは <code class="literal">ALTER TABLE</code> によってロールバックの暴走が発生する場合は、<span class="command"><strong>mysqld</strong></span> プロセスを強制終了し、<code class="literal">innodb_force_recovery</code> を <code class="literal">3</code> に設定してロールバックなしでデータベースを起動したあと、ロールバックの暴走の原因になっているテーブルの <code class="literal">DROP</code> を実行することができます。 
    </p><p>
      テーブルデータ内の破損のためにテーブルの内容全体をダンプできない場合は、<code class="literal">ORDER BY <em class="replaceable"><code>primary_key</code></em> DESC</code> 句を含むクエリーで、破損した部分のあとにあるテーブルの部分をダンプできる可能性があります。
    </p><p>
      <code class="literal">InnoDB</code> を起動するために <code class="literal">innodb_force_recovery</code> を大きな値にする必要がある場合は、複雑なクエリー (<code class="literal">WHERE</code>、<code class="literal">ORDER BY</code>、またはその他の句を含むクエリー) を失敗させることがある破損したデータ構造が存在する可能性があります。 この場合は、基本的な <code class="literal">SELECT * FROM t</code> クエリーしか実行できない可能性があります。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-troubleshooting-datadict"></a>15.21.3 InnoDB データディクショナリの操作のトラブルシューティング</h3></div></div></div><a class="indexterm" name="idm44761344255136"></a><p>
      テーブル定義に関する情報は、InnoDB <a class="link" href="glossary.html#glos_data_dictionary" title="データディクショナリ">data dictionary</a> に格納されます。 データファイルを移動すると、ディクショナリデータに一貫性がなくなる可能性があります。 
    </p><p>
      データディクショナリの破損や一貫性の問題によって <code class="literal">InnoDB</code> を起動できない場合は、手動のリカバリに関する情報について、<a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="15.21.2 InnoDB のリカバリの強制的な実行">セクション15.21.2「InnoDB のリカバリの強制的な実行」</a>を参照してください。
    </p><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-cannot-open-data-file-error"></a>データファイルを開けません</h4></div></div></div><a class="indexterm" name="idm44761344247344"></a><p>
        <code class="literal">innodb_file_per_table</code> が有効な場合 (デフォルト)、<a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースファイル (<code class="literal">.ibd</code> ファイル) が欠落していると、起動時に次のメッセージが表示されることがあります:
      </p><pre class="programlisting">[ERROR] InnoDB: Operating system error number 2 in a file operation.
[ERROR] InnoDB: The error means the system cannot find the path specified.
[ERROR] InnoDB: Cannot open datafile for read-only: './test/t1.ibd' OS error: 71
[Warning] InnoDB: Ignoring tablespace `test/t1` because it could not be opened.
</pre><p>
        これらのメッセージに対処するには、<code class="literal">DROP TABLE</code> ステートメントを発行して、欠落しているテーブルに関するデータをデータディクショナリから削除します。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="restoring-orphaned-ibd-files"></a>孤立したファイル/テーブル ibd ファイルの復元</h4></div></div></div><a class="indexterm" name="idm44761344237072"></a><p>
        この手順では、孤立した <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> <code class="filename">.ibd</code> ファイルを別の MySQL インスタンスにリストアする方法について説明します。 システムテーブルスペースが消失またはリカバリ不能で、新しい MySQL インスタンスで <code class="filename">.ibd</code> ファイルのバックアップをリストアする場合は、このプロシージャを使用できます。 
      </p><p>
        プロシージャは、<a class="link" href="glossary.html#glos_general_tablespace" title="一般テーブルスペース">general tablespace</a> <code class="filename">.ibd</code> ファイルではサポートされていません。
      </p><p>
        この手順では、<code class="filename">.ibd</code> ファイルのバックアップのみがあり、孤立した <code class="filename">.ibd</code> ファイルを最初に作成したのと同じバージョンの MySQL にリカバリしており、<code class="filename">.ibd</code> ファイルのバックアップがクリーンであることを前提としています。 クリーンバックアップの作成の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-migration" title="15.6.1.4 InnoDB テーブルの移動またはコピー">セクション15.6.1.4「InnoDB テーブルの移動またはコピー」</a> を参照してください。 
      </p><p>
        この手順には、<a class="xref" href="innodb-storage-engine.html#innodb-table-import" title="15.6.1.3 InnoDB テーブルのインポート">セクション15.6.1.3「InnoDB テーブルのインポート」</a> で概説されているテーブルのインポート制限が適用されます。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            新しい MySQL インスタンスで、同じ名前のデータベースにテーブルを再作成します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE DATABASE sakila;</code></strong>

mysql&gt; <strong class="userinput"><code>USE sakila;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE actor (</code></strong>
         <strong class="userinput"><code>actor_id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,</code></strong>
         <strong class="userinput"><code>first_name VARCHAR(45) NOT NULL,</code></strong>
         <strong class="userinput"><code>last_name VARCHAR(45) NOT NULL,</code></strong>
         <strong class="userinput"><code>last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</code></strong>
         <strong class="userinput"><code>PRIMARY KEY  (actor_id),</code></strong>
         <strong class="userinput"><code>KEY idx_actor_last_name (last_name)</code></strong>
       <strong class="userinput"><code>)ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></strong>
</pre></li><li class="listitem"><p>
            新しく作成したテーブルのテーブルスペースを破棄します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE sakila.actor DISCARD TABLESPACE;</code></strong>
</pre></li><li class="listitem"><p>
            孤立した <code class="literal">.ibd</code> ファイルをバックアップディレクトリから新しいデータベースディレクトリにコピーします。
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>cp /<code class="literal">backup_directory</code>/actor.ibd <em class="replaceable"><code>path/to/mysql-5.7/data</code></em>/sakila/</code></strong>
</pre></li><li class="listitem"><p>
            <code class="filename">.ibd</code> ファイルに必要なファイル権限があることを確認します。
          </p></li><li class="listitem"><p>
            孤立した <code class="literal">.ibd</code> ファイルをインポートします。 <code class="literal">InnoDB</code> がスキーマ検証なしでファイルをインポートしようとしていることを示す警告が発行されます。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE sakila.actor IMPORT TABLESPACE; SHOW WARNINGS;</code></strong>
Query OK, 0 rows affected, 1 warning (0.15 sec)

Warning | 1810 | InnoDB: IO Read error: (2, No such file or directory)
Error opening './sakila/actor.cfg', will attempt to import
without schema verification
</pre></li><li class="listitem"><p>
            テーブルをクエリーして、<code class="literal">.ibd</code> ファイルが正常にリストアされたことを確認します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT COUNT(*) FROM sakila.actor;</code></strong>
+----------+
| count(*) |
+----------+
|      200 |
+----------+
</pre></li></ol></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-error-handling"></a>15.21.4 InnoDB のエラー処理</h3></div></div></div><a class="indexterm" name="idm44761344195488"></a><a class="indexterm" name="idm44761344192640"></a><p>
      次の項目では、<code class="literal">InnoDB</code> がエラー処理を実行する方法について説明します。 <code class="literal">InnoDB</code> では、失敗したステートメントのみがロールバックされ、それ以外の場合はトランザクション全体がロールバックされることがあります。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_tablespace" title="テーブルスペース">テーブルスペース</a>内のファイル領域が不足した場合は、MySQL の <code class="literal">Table is full</code> エラーが発生し、<code class="literal">InnoDB</code> は SQL ステートメントをロールバックします。
        </p></li><li class="listitem"><p>
          トランザクション<a class="link" href="glossary.html#glos_deadlock" title="デッドロック">デッドロック</a>が発生すると、<code class="literal">InnoDB</code> は<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>全体を<a class="link" href="glossary.html#glos_rollback" title="ロールバック">ロールバック</a>します。 これが発生したら、トランザクション全体を再試行します。 
        </p><p>
          ロック待機タイムアウトが発生すると、<code class="literal">InnoDB</code> は現在のステートメント (ロックを待機していてタイムアウトが発生したステートメント) をロールバックします。 トランザクション全体をロールバックするには、<code class="option">--innodb-rollback-on-timeout</code> を有効にしてサーバーを起動します。 デフォルトの動作を使用する場合はステートメントを再試行し、<code class="option">--innodb-rollback-on-timeout</code> が有効な場合はトランザクション全体を再試行します。 
        </p><p>
          デッドロックとロック待機のタイムアウトはどちらもビジー状態のサーバーでは通常のことであり、アプリケーションはそれらが発生する可能性を認識し、発生した場合は再試行によって処理する必要があります。 トランザクション中の最初のデータ変更からコミットまでの間に行う作業をできるだけ少なくして、ロックが可能性のある最短の時間、可能性のある最少の行数に対して保持されるようにすることにより、それらが発生する可能性を少なくすることができます。 場合によっては、異なるトランザクション間での作業の分割が実際的で、かつ役立つことがあります。 
        </p></li><li class="listitem"><p>
          ステートメントで <code class="literal">IGNORE</code> オプションを指定していない場合、重複キーエラーは SQL ステートメントをロールバックします。
        </p></li><li class="listitem"><p>
          <code class="literal">row too long error</code> は、SQL ステートメントをロールバックします。
        </p></li><li class="listitem"><p>
          その他のエラーはほとんど (<code class="literal">InnoDB</code> ストレージエンジンレベルの上にある) コードの MySQL レイヤーによって検出され、対応する SQL ステートメントをロールバックします。 1 つの SQL ステートメントのロールバックでは、ロックは解放されません。 
        </p></li></ul></div><p>
      暗黙的なロールバック中や、明示的な <code class="literal">ROLLBACK</code> SQL ステートメントの実行中に、<code class="literal">SHOW PROCESSLIST</code> は、関連する接続の <code class="literal">State</code> カラムに <code class="literal">Rolling back</code> を表示します。
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-limits"></a>15.22 InnoDB の制限</h2></div></div></div><a class="indexterm" name="idm44761344163392"></a><a class="indexterm" name="idm44761344161392"></a><p>
      このセクションでは、<code class="literal">InnoDB</code> ストレージエンジンの <code class="literal">InnoDB</code> テーブル、インデックス、テーブルスペース、およびその他の側面の制限について説明します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          テーブルには、最大 1017 カラムを含めることができます。 仮想生成カラムはこの制限に含まれます。 
        </p></li><li class="listitem"><p>
          テーブルには、最大で 64 個の<a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">セカンダリインデックス</a>を含めることができます。
        </p></li><li class="listitem"><p>
          <code class="literal"><a class="link" href="glossary.html#glos_dynamic_row_format" title="動的行フォーマット">DYNAMIC</a></code> または <code class="literal"><a class="link" href="glossary.html#glos_compressed_row_format" title="圧縮行フォーマット">COMPRESSED</a></code> の行形式を使用する <code class="literal">InnoDB</code> テーブルでは、インデックスキーの接頭辞の長さの制限は 3072 バイトです。
        </p><p>
          <code class="literal"><a class="link" href="glossary.html#glos_redundant_row_format" title="冗長行フォーマット">REDUNDANT</a></code> または <code class="literal"><a class="link" href="glossary.html#glos_compact_row_format" title="コンパクト行フォーマット">COMPACT</a></code> の行形式を使用する <code class="literal">InnoDB</code> テーブルのインデックスキー接頭辞の長さ制限は 767 バイトです。 たとえば、<code class="literal">utf8mb4</code> 文字セットおよび各文字の最大 4 バイトを想定して、<code class="literal">TEXT</code> または <code class="literal">VARCHAR</code> カラムで 191 文字を超える <a class="link" href="glossary.html#glos_column_prefix" title="カラムプリフィクス">column prefix</a> インデックスを使用して、この制限に達する場合があります。 
        </p><p>
          制限を超えるインデックスキー接頭辞の長さを使用しようとすると、エラーが返されます。
        </p><p>
          MySQL インスタンスの作成時に <code class="literal">innodb_page_size</code> オプションを指定して、<code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_page_size" title="page size">ページサイズ</a>を 8K バイトまたは 4K バイトまで小さくすると、16K バイトのページサイズに対応する 3072 バイトの制限に基づいて、比例的にインデックスキーの最大長も短くなります。 つまり、インデックスキーの最大長は、ページサイズが 8K バイトのときは 1536 バイト、ページサイズが 4K バイトのときは 768 バイトになります。 
        </p><p>
          インデックスキー接頭辞に適用される制限は、フルカラムインデックスキーにも適用されます。
        </p></li><li class="listitem"><p>
          複数カラムインデックスには最大 16 カラムを使用できます。 制限を超えると、エラーが返されます。 
        </p><pre class="programlisting">ERROR 1070 (42000): Too many key parts specified; max 16 parts allowed
</pre></li><li class="listitem"><p>
          オフページに格納されている可変長カラムを除く最大行サイズは、4K バイト、8K バイト、16K バイト、および 32K バイトのページサイズではページの半分よりわずかに小さくなります。 たとえば、デフォルトの <code class="literal">innodb_page_size</code> 16KB の最大行サイズは約 8000 バイトです。 ただし、64KB の <code class="literal">InnoDB</code> ページサイズの場合、最大行サイズは約 16000 バイトです。 <code class="literal">LONGBLOB</code> および <code class="literal">LONGTEXT</code> のカラムは 4GB 未満である必要があり、<code class="literal">BLOB</code> および <code class="literal">TEXT</code> のカラムを含む合計行サイズは 4GB 未満である必要があります。 
        </p><p>
          行の長さが 1 ページの半分より短い場合は、行全体がそのページ内にローカルに格納されます。 <a class="xref" href="innodb-storage-engine.html#innodb-file-space" title="15.11.2 ファイル領域管理">セクション15.11.2「ファイル領域管理」</a>で説明したように、半ページを超える行では、その行が半ページ以内に収まるように、可変長カラムが外部オフページストレージの対象として選択されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> では内部的に 65,535 バイトを超える行サイズがサポートされますが、MySQL 自体では、すべてのカラムの合計サイズに 65,535 の行サイズ制限が課されます。 <a class="xref" href="optimization.html#column-count-limit" title="8.4.7 テーブルカラム数と行サイズの制限">セクション8.4.7「テーブルカラム数と行サイズの制限」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          一部の古いオペレーティングシステムでは、ファイルは 2G バイトよりも小さくする必要があります。 これは <code class="literal">InnoDB</code> の制限ではありません。 大規模なシステムテーブルスペースが必要な場合は、1 つの大規模なデータファイルではなく複数の小規模なデータファイルを使用して構成するか、file-per-table および一般的なテーブルスペースデータファイルにテーブルデータを分散します。 
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> ログファイルの最大サイズの合計は 512GB です。
        </p></li><li class="listitem"><p>
          テーブルスペースの最小サイズは、10M バイトをわずかに超える大きさです。 テーブルスペースの最大サイズは、<code class="literal">InnoDB</code> のページサイズによって異なります。 
        </p><div class="table"><a name="idm44761344117104"></a><p class="title"><b>表 15.31 InnoDB テーブルスペースの最大サイズ</b></p><div class="table-contents"><table summary="The maximum tablespace size for each InnoDB page size."><col style="width: 40%"><col style="width: 60%"><thead><tr>
              <th>InnoDB ページサイズ</th>
              <th>最大テーブルスペースサイズ</th>
            </tr></thead><tbody><tr>
              <td>4KB</td>
              <td>16TB</td>
            </tr><tr>
              <td>8KB</td>
              <td>32TB</td>
            </tr><tr>
              <td>16KB</td>
              <td>64TB</td>
            </tr><tr>
              <td>32KB</td>
              <td>128TB</td>
            </tr><tr>
              <td>64KB</td>
              <td>256TB</td>
            </tr></tbody></table></div></div><br class="table-break"><p>
          最大テーブルスペースサイズは、テーブルの最大サイズでもあります。
        </p></li><li class="listitem"><p>
          ファイル名を含むテーブルスペースファイルのパスは、Windows での <code class="literal">MAX_PATH</code> 制限を超えることはできません。 Windows 10 より前では、<code class="literal">MAX_PATH</code> の制限は 260 文字です。 Windows 10 バージョン 1607 では、<code class="literal">MAX_PATH</code> の制限は共通の Win32 ファイルおよびディレクトリ機能から削除されていますが、新しい動作を有効にする必要があります。 
        </p></li><li class="listitem"><p>
          同時読取り /書込みトランザクションに関連する制限については、<a class="xref" href="innodb-storage-engine.html#innodb-undo-logs" title="15.6.6 undo ログ">セクション15.6.6「undo ログ」</a> を参照してください。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-restrictions-limitations"></a>15.23 InnoDB の制限および制限事項</h2></div></div></div><a class="indexterm" name="idm44761344092736"></a><a class="indexterm" name="idm44761344090736"></a><a class="indexterm" name="idm44761344088592"></a><a class="indexterm" name="idm44761344086672"></a><p>
      このセクションでは、<code class="literal">InnoDB</code> ストレージエンジンの制限事項と制限事項について説明します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          内部 <code class="literal">InnoDB</code> カラム (<code class="literal">DB_ROW_ID</code>、<code class="literal">DB_TRX_ID</code> および <code class="literal">DB_ROLL_PTR</code> を含む) の名前と一致するカラム名を持つテーブルは作成できません。 この制限は、任意の大文字と小文字での名前の使用に適用されます。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, db_row_id INT) ENGINE=INNODB;</code></strong>
ERROR 1166 (42000): Incorrect column name 'db_row_id'
</pre></li><li class="listitem"><p>
          <code class="literal">SHOW TABLE STATUS</code> では、テーブルで予約されている物理サイズを除き、<code class="literal">InnoDB</code> テーブルの正確な統計は提供されません。 行カウントは、単に SQL 最適化で使用される概算見積もりです。 
        </p></li><li class="listitem"><p>
          並列トランザクションでは同時にさまざまな数の行が<span class="quote">「<span class="quote">参照</span>」</span>される可能性があるため、<code class="literal">InnoDB</code> のテーブルには、行の内部的なカウントが保持されません。 したがって、<code class="literal">SELECT COUNT(*)</code> ステートメントでは、現在のトランザクションで参照可能な行のみがカウントされます。 
        </p><p>
          <code class="literal">InnoDB</code> による <code class="literal">SELECT COUNT(*)</code> ステートメントの処理方法の詳細は、<a class="xref" href="functions.html#aggregate-functions" title="12.20.1 集計関数の説明">セクション12.20.1「集計関数の説明」</a> の <code class="literal">COUNT()</code> の説明を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">ROW_FORMAT=COMPRESSED</code> は、16KB を超えるページサイズではサポートされていません。
        </p></li><li class="listitem"><p>
          特定の <code class="literal">InnoDB</code> ページサイズ (<code class="literal">innodb_page_size</code>) を使用する MySQL インスタンスでは、異なるページサイズを使用するインスタンスのデータファイルまたはログファイルを使用できません。
        </p></li><li class="listitem"><p>
          <span class="emphasis"><em>トランスポータブルテーブルスペース</em></span>機能を使用したテーブルのインポートに関連する制限については、<a class="link" href="innodb-storage-engine.html#innodb-statistics-estimation" title="15.8.10.2 非永続的オプティマイザ統計のパラメータの構成">Table Import Limitations</a> を参照してください。
        </p></li><li class="listitem"><p>
          オンライン DDL に関連する制限については、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-limitations" title="15.12.6 オンライン DDL の制限事項">セクション15.12.6「オンライン DDL の制限事項」</a> を参照してください。
        </p></li><li class="listitem"><p>
          一般的なテーブルスペースに関連する制限については、<a class="xref" href="innodb-storage-engine.html#general-tablespaces-limitations" title="テーブルスペースの一般的な制限事項">テーブルスペースの一般的な制限事項</a> を参照してください。
        </p></li><li class="listitem"><p>
          保存データ暗号化に関連する制限については、<a class="xref" href="innodb-storage-engine.html#innodb-data-encryption-limitations" title="暗号化の制限事項">暗号化の制限事項</a> を参照してください。
        </p></li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="data-dictionary.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="storage-engines.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第 14 章 MySQL データディクショナリ </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第 16 章 代替ストレージエンジン</td></tr></table></div><div class="copyright-footer"></div></body></html>
