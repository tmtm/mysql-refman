<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第 17 章 レプリケーション</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="MySQL 8.0 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 8.0 リファレンスマニュアル"><link rel="prev" href="storage-engines.html" title="第 16 章 代替ストレージエンジン"><link rel="next" href="group-replication.html" title="第 18 章 グループレプリケーション"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 17 章 レプリケーション</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="storage-engines.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="group-replication.html">次へ</a></td></tr></table><hr></div><div class="status-header"><p class="alert">このページは機械翻訳したものです。</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="replication"></a>第 17 章 レプリケーション</h1></div></div></div><div class="toc"><p><b>目次</b></p><dl class="toc"><dt><span class="section"><a href="replication.html#replication-configuration">17.1 レプリケーションの構成</a></span></dt><dd><dl><dt><span class="section"><a href="replication.html#binlog-replication-configuration-overview">17.1.1 バイナリログファイルの位置ベースのレプリケーション構成の概要</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto">17.1.2 バイナリログファイルの位置ベースのレプリケーションの設定</a></span></dt><dt><span class="section"><a href="replication.html#replication-gtids">17.1.3 グローバルトランザクション識別子を使用したレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-mode-change-online">17.1.4 オンラインサーバーでの GTID モードの変更</a></span></dt><dt><span class="section"><a href="replication.html#replication-multi-source">17.1.5 MySQL マルチソースレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-options">17.1.6 レプリケーションおよびバイナリロギングのオプションと変数</a></span></dt><dt><span class="section"><a href="replication.html#replication-administration">17.1.7 一般的なレプリケーション管理タスク</a></span></dt></dl></dd><dt><span class="section"><a href="replication.html#replication-implementation">17.2 レプリケーションの実装</a></span></dt><dd><dl><dt><span class="section"><a href="replication.html#replication-formats">17.2.1 レプリケーション形式</a></span></dt><dt><span class="section"><a href="replication.html#replication-channels">17.2.2 レプリケーションチャネル</a></span></dt><dt><span class="section"><a href="replication.html#replication-implementation-details">17.2.3 レプリケーションスレッド</a></span></dt><dt><span class="section"><a href="replication.html#replica-logs">17.2.4 リレーログおよびレプリケーションメタデータリポジトリ</a></span></dt><dt><span class="section"><a href="replication.html#replication-rules">17.2.5 サーバーがレプリケーションフィルタリングルールをどのように評価するか</a></span></dt></dl></dd><dt><span class="section"><a href="replication.html#replication-security">17.3 レプリケーションのセキュリティ</a></span></dt><dd><dl><dt><span class="section"><a href="replication.html#replication-solutions-encrypted-connections">17.3.1 暗号化接続を使用するためのレプリケーションの設定</a></span></dt><dt><span class="section"><a href="replication.html#replication-binlog-encryption">17.3.2 バイナリログファイルとリレーログファイルの暗号化</a></span></dt><dt><span class="section"><a href="replication.html#replication-privilege-checks">17.3.3 レプリケーション権限チェック</a></span></dt></dl></dd><dt><span class="section"><a href="replication.html#replication-solutions">17.4 レプリケーションソリューション</a></span></dt><dd><dl><dt><span class="section"><a href="replication.html#replication-solutions-backups">17.4.1 バックアップ用にレプリケーションを使用する</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-unexpected-replica-halt">17.4.2 レプリカの予期しない停止の処理</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-rbr-monitoring">17.4.3 行ベースのレプリケーションの監視</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-diffengines">17.4.4 異なるソースおよびレプリカのストレージエンジンでのレプリケーションの使用</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-scaleout">17.4.5 スケールアウトのためにレプリケーションを使用する</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-partitioning">17.4.6 異なるレプリカへの異なるデータベースのレプリケート</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-performance">17.4.7 レプリケーションパフォーマンスを改善する</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-switch">17.4.8 フェイルオーバー中のソースの切替え</a></span></dt><dt><span class="section"><a href="replication.html#replication-asynchronous-connection-failover">17.4.9 非同期接続フェイルオーバーによるソースの切替え</a></span></dt><dt><span class="section"><a href="replication.html#replication-semisync">17.4.10 準同期レプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-delayed">17.4.11 遅延レプリケーション</a></span></dt></dl></dd><dt><span class="section"><a href="replication.html#replication-notes">17.5 レプリケーションの注釈とヒント</a></span></dt><dd><dl><dt><span class="section"><a href="replication.html#replication-features">17.5.1 レプリケーションの機能と問題</a></span></dt><dt><span class="section"><a href="replication.html#replication-compatibility">17.5.2 MySQL バージョン間のレプリケーション互換性</a></span></dt><dt><span class="section"><a href="replication.html#replication-upgrade">17.5.3 レプリケーションセットアップをアップグレードする</a></span></dt><dt><span class="section"><a href="replication.html#replication-problems">17.5.4 レプリケーションのトラブルシューティング</a></span></dt><dt><span class="section"><a href="replication.html#replication-bugs">17.5.5 レプリケーションバグまたは問題を報告する方法</a></span></dt></dl></dd></dl></div><a class="indexterm" name="idm46723659289360"></a><a class="indexterm" name="idm46723659287904"></a><a class="indexterm" name="idm46723659285872"></a><a class="indexterm" name="idm46723659283808"></a><p>
    レプリケーションを使用すると、ある MySQL データベースサーバー (ソースと呼ばれる) のデータを、複数の MySQL データベースサーバー (レプリカと呼ばれる) にコピーできます。 レプリケーションはデフォルトで非同期です。ソースから更新を受信するためにレプリカを永続的に接続する必要はありません。 構成に応じて、すべてのデータベース、選択したデータベース、さらにデータベース内の選択したテーブルを複製できます。 
  </p><p>
    MySQL のレプリケーションの長所は次のとおりです。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        スケールアウトソリューション - 複数のレプリカに負荷を分散して、パフォーマンスを向上させます。 この環境では、すべての書込みおよび更新がソースサーバーで実行される必要があります。 ただし、1 つまたは複数のレプリカで読み取りが行われる場合があります。 このモデルでは、(ソースが更新専用であるため) 書込みのパフォーマンスを向上させる一方で、レプリカの数の増加に伴って読取り速度を大幅に向上させることができます。 
      </p></li><li class="listitem"><p>
        データセキュリティ - レプリカはレプリケーションプロセスを一時停止できるため、対応するソースデータを破損させることなくレプリカでバックアップサービスを実行できます。
      </p></li><li class="listitem"><p>
        アナリティクス - ライブデータはソースで作成できますが、情報の分析はソースのパフォーマンスに影響を与えることなくレプリカで実行できます。
      </p></li><li class="listitem"><p>
        長距離データ分散 - レプリケーションを使用すると、ソースに永続的にアクセスせずに、リモートサイトで使用するデータのローカルコピーを作成できます。
      </p></li></ul></div><p>
    このようなシナリオでレプリケーションを使用する方法については、<a class="xref" href="replication.html#replication-solutions" title="17.4 レプリケーションソリューション">セクション17.4「レプリケーションソリューション」</a> を参照してください。
  </p><p>
    MySQL 8.0 は、様々なレプリケーション方法をサポートしています。 従来の方法は、ソースバイナリログからのイベントのレプリケートに基づいており、ソースとレプリカ間で同期するためにログファイルとその中の位置が必要です。 <span class="firstterm">グローバルトランザクション識別子</span> (GTID) に基づく新しい方法はトランザクションであるため、これらのファイル内のログファイルや位置を操作する必要はなく、多くの一般的なレプリケーションタスクが大幅に簡略化されます。 GTID を使用したレプリケーションでは、ソースでコミットされたすべてのトランザクションがレプリカにも適用されているかぎり、ソースとレプリカの間の一貫性が保証されます。 MySQL での GTID および GTID ベースレプリケーションの詳細は、<a class="xref" href="replication.html#replication-gtids" title="17.1.3 グローバルトランザクション識別子を使用したレプリケーション">セクション17.1.3「グローバルトランザクション識別子を使用したレプリケーション」</a> を参照してください。 バイナリログファイルの位置ベースのレプリケーションの使用方法については、<a class="xref" href="replication.html#replication-configuration" title="17.1 レプリケーションの構成">セクション17.1「レプリケーションの構成」</a> を参照してください。 
  </p><p>
    MySQL でのレプリケーションでは、様々なタイプの同期がサポートされます。 元のタイプの同期は、一方向の非同期レプリケーションであり、一方のサーバーはソースとして機能し、もう一方のサーバーはレプリカとして機能します。 これは NDB Cluster の特性である<span class="emphasis"><em>同期</em></span>レプリケーションとは対照的です (<a class="xref" href="mysql-cluster.html" title="第 23 章 MySQL NDB Cluster 8.0">第23章「<i>MySQL NDB Cluster 8.0</i>」</a> を参照)。 MySQL 8.0 では、組込み非同期レプリケーションに加えて、準同期レプリケーションがサポートされています。 準同期レプリケーションでは、トランザクションを実行したセッションに戻る前に、ソースで実行されたコミットは、トランザクションのイベントを受信して記録したことを少なくとも 1 つのレプリカが確認するまでブロックされます。<a class="xref" href="replication.html#replication-semisync" title="17.4.10 準同期レプリケーション">セクション17.4.10「準同期レプリケーション」</a> を参照してください。 MySQL 8.0 は、レプリカが少なくとも指定された時間だけソースから意図的に遅れるような遅延レプリケーションもサポートしています。<a class="xref" href="replication.html#replication-delayed" title="17.4.11 遅延レプリケーション">セクション17.4.11「遅延レプリケーション」</a> を参照してください。 <span class="emphasis"><em>同期</em></span>レプリケーションが必要なシナリオでは、NDB Cluster を使用します (<a class="xref" href="mysql-cluster.html" title="第 23 章 MySQL NDB Cluster 8.0">第23章「<i>MySQL NDB Cluster 8.0</i>」</a> を参照)。 
  </p><p>
    サーバー間のレプリケーションを設定するために使用できるソリューションは多数あり、使用する最適な方法は、使用しているデータの存在とエンジンタイプによって異なります。 利用可能なオプションの詳細については、<a class="xref" href="replication.html#replication-howto" title="17.1.2 バイナリログファイルの位置ベースのレプリケーションの設定">セクション17.1.2「バイナリログファイルの位置ベースのレプリケーションの設定」</a>を参照してください。 
  </p><p>
    レプリケーション形式の主要なタイプは 2 つあり、1 つは、SQL ステートメント全体を複製する Statement Based Replication (SBR: ステートメントベースレプリケーション)、もう 1 つは変更があった行だけを複製する Row Based Replication (RBR: 行ベースレプリケーション) です。 また、3 種類目の混合ベースのレプリケーション (MBR) を使用することもできます。 さまざまなレプリケーション形式の詳細については、<a class="xref" href="replication.html#replication-formats" title="17.2.1 レプリケーション形式">セクション17.2.1「レプリケーション形式」</a>を参照してください。 
  </p><p>
    レプリケーションは、いくつかのオプションと変数によって制御されます。 詳細は、<a class="xref" href="replication.html#replication-options" title="17.1.6 レプリケーションおよびバイナリロギングのオプションと変数">セクション17.1.6「レプリケーションおよびバイナリロギングのオプションと変数」</a>を参照してください。 <a class="xref" href="replication.html#replication-security" title="17.3 レプリケーションのセキュリティ">セクション17.3「レプリケーションのセキュリティ」</a> で説明されているように、レプリケーショントポロジに追加のセキュリティ対策を適用できます。 
  </p><p>
    レプリケーションを使用すると、パフォーマンス、様々なデータベースのバックアップのサポート、システム障害を軽減する大規模なソリューションの一部など、様々な問題を解決できます。 これらの問題の対処方法については、<a class="xref" href="replication.html#replication-solutions" title="17.4 レプリケーションソリューション">セクション17.4「レプリケーションソリューション」</a>を参照してください。 
  </p><p>
    レプリケーション機能の詳細、バージョンの互換性、アップグレード、潜在的な問題とその解決方法など、レプリケーション中の様々なデータ型およびステートメントの処理方法に関するノートおよびヒントは、<a class="xref" href="replication.html#replication-notes" title="17.5 レプリケーションの注釈とヒント">セクション17.5「レプリケーションの注釈とヒント」</a> を参照してください。 MySQL Replication をはじめて使用する人がよくする質問の回答については、<a class="xref" href="faqs.html#faqs-replication" title="A.14 MySQL 8.0 FAQ: レプリケーション">セクションA.14「MySQL 8.0 FAQ: レプリケーション」</a>を参照してください。 
  </p><p>
    レプリケーションの実装、レプリケーションの動作、バイナリログのプロセスと内容、バックグラウンドスレッド、およびステートメントの記録とレプリケート方法を決定するために使用される規則の詳細は、<a class="xref" href="replication.html#replication-implementation" title="17.2 レプリケーションの実装">セクション17.2「レプリケーションの実装」</a> を参照してください。
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="replication-configuration"></a>17.1 レプリケーションの構成</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#binlog-replication-configuration-overview">17.1.1 バイナリログファイルの位置ベースのレプリケーション構成の概要</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto">17.1.2 バイナリログファイルの位置ベースのレプリケーションの設定</a></span></dt><dt><span class="section"><a href="replication.html#replication-gtids">17.1.3 グローバルトランザクション識別子を使用したレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-mode-change-online">17.1.4 オンラインサーバーでの GTID モードの変更</a></span></dt><dt><span class="section"><a href="replication.html#replication-multi-source">17.1.5 MySQL マルチソースレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-options">17.1.6 レプリケーションおよびバイナリロギングのオプションと変数</a></span></dt><dt><span class="section"><a href="replication.html#replication-administration">17.1.7 一般的なレプリケーション管理タスク</a></span></dt></dl></div><p>
    このセクションでは、MySQL で使用可能な様々なタイプのレプリケーションを構成する方法について説明し、レプリケーション環境に必要な設定および構成 (新しいレプリケーション環境を作成するステップを含む) について説明します。 このセクションの主な内容は次のとおりです。 
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        バイナリログファイルの位置を使用してレプリケーション用に複数のサーバーを設定するためのガイドとして、<a class="xref" href="replication.html#replication-howto" title="17.1.2 バイナリログファイルの位置ベースのレプリケーションの設定">セクション17.1.2「バイナリログファイルの位置ベースのレプリケーションの設定」</a> はサーバーの構成を処理し、ソースとレプリカ間でデータをコピーする方法を提供します。
      </p></li><li class="listitem"><p>
        GTID トランザクションを使用したレプリケーション用に複数のサーバーを設定するためのガイドとして、<a class="xref" href="replication.html#replication-gtids" title="17.1.3 グローバルトランザクション識別子を使用したレプリケーション">セクション17.1.3「グローバルトランザクション識別子を使用したレプリケーション」</a> はサーバーの構成を処理します。
      </p></li><li class="listitem"><p>
        バイナリログ内のイベントはいくつかの形式で記録されます。 これらは、ステートメントベースレプリケーション (SBR) または行ベースレプリケーション (RBR) と呼ばれます。 3 つ目のタイプ、混合形式レプリケーション (MIXED) は、SBR または RBR レプリケーションを自動的に使用し、必要に応じて SBR と RBR の両方の形式の利点を活用します。 さまざまな形式については、<a class="xref" href="replication.html#replication-formats" title="17.2.1 レプリケーション形式">セクション17.2.1「レプリケーション形式」</a>を参照してください。 
      </p></li><li class="listitem"><p>
        レプリケーションに適用するさまざまな構成のオプションと変数に関する詳細は、<a class="xref" href="replication.html#replication-options" title="17.1.6 レプリケーションおよびバイナリロギングのオプションと変数">セクション17.1.6「レプリケーションおよびバイナリロギングのオプションと変数」</a>を参照してください。
      </p></li><li class="listitem"><p>
        レプリケーションプロセスが開始されると、管理または監視はほとんど必要ありません。 ただし、実行することが望ましい一般的なタスクに関するアドバイスについては、<a class="xref" href="replication.html#replication-administration" title="17.1.7 一般的なレプリケーション管理タスク">セクション17.1.7「一般的なレプリケーション管理タスク」</a>を参照してください。 
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="binlog-replication-configuration-overview"></a>17.1.1 バイナリログファイルの位置ベースのレプリケーション構成の概要</h3></div></div></div><p>
      このセクションでは、バイナリログファイルの位置方式に基づく MySQL サーバー間のレプリケーションについて説明します。この方法では、(データベースの変更が行われる) ソースとして動作する MySQL インスタンスが、更新および変更を <span class="quote">「<span class="quote">events</span>」</span> としてバイナリログに書き込みます。 バイナリログ内の情報は、記録されているデータベース変更に応じて異なるロギング形式で格納されます。 レプリカは、ソースからバイナリログを読み取り、レプリカローカルデータベース上のバイナリログ内のイベントを実行するように構成されます。 
    </p><p>
      各レプリカは、バイナリログの内容全体のコピーを受け取ります。 バイナリログ内のどのステートメントを実行すべきかを決定するのは、レプリカの役割です。 特に指定しないかぎり、ソースバイナリログ内のすべてのイベントがレプリカで実行されます。 必要に応じて、特定のデータベースまたはテーブルに適用されるイベントのみを処理するようにレプリカを構成できます。 
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        特定のイベントのみを記録するようにソースを構成することはできません。
      </p></div><p>
      各レプリカはバイナリログ座標のレコードを保持: ソースから読み取って処理したファイル内のファイル名と位置。 つまり、複数のレプリカをソースに接続し、同じバイナリログの異なる部分を実行できます。 レプリカはこのプロセスを制御するため、ソース操作に影響を与えることなく、個々のレプリカを接続してサーバーから切断できます。 また、各レプリカはバイナリログ内の現在の位置を記録するため、レプリカを切断し、再接続してから処理を再開できます。 
    </p><p>
      ソースと各レプリカは、(<code class="literal">server_id</code> システム変数を使用して) 一意の ID で構成する必要があります。 また、各レプリカは、ソースホスト名、ログファイル名およびそのファイル内の位置に関する情報で構成する必要があります。 これらの詳細は、レプリカに対する <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 より前) を使用して、MySQL セッション内から制御できます。 詳細は、レプリカ接続メタデータリポジトリ内に格納されます (<a class="xref" href="replication.html#replica-logs" title="17.2.4 リレーログおよびレプリケーションメタデータリポジトリ">セクション17.2.4「リレーログおよびレプリケーションメタデータリポジトリ」</a> を参照)。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-howto"></a>17.1.2 バイナリログファイルの位置ベースのレプリケーションの設定</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-howto-masterbaseconfig">17.1.2.1 レプリケーションソース構成の設定</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto-slavebaseconfig">17.1.2.2 レプリカ構成の設定</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto-repuser">17.1.2.3 レプリケーション用ユーザーの作成</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto-masterstatus">17.1.2.4 レプリケーションソースのバイナリログ座標の取得</a></span></dt><dt><span class="section"><a href="replication.html#replication-snapshot-method">17.1.2.5 データスナップショットの方法の選択</a></span></dt><dt><span class="section"><a href="replication.html#replication-setup-replicas">17.1.2.6 レプリカの設定</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto-slaveinit">17.1.2.7 レプリカでのソース構成の設定</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto-additionalslaves">17.1.2.8 レプリケーション環境へのレプリカの追加</a></span></dt></dl></div><p>
      このセクションでは、バイナリログファイルの位置ベースのレプリケーションを使用するように MySQL サーバーを設定する方法について説明します。 レプリケーションを設定するには様々な方法があり、使用する正確な方法はレプリケーションの設定方法、およびレプリケートするソース上のデータベースにデータがすでにあるかどうかによって異なります。 
    </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">ヒント</div><p>
        MySQL の複数のインスタンスをデプロイするには、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/" target="_top">MySQL Shell</a> で MySQL サーバーインスタンスのグループを簡単に管理できるようにする <a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-innodb-cluster.html" target="_top">InnoDB クラスタ</a> を使用できます。InnoDB クラスタ は MySQL Group Replication をプログラム環境でラップするため、MySQL インスタンスのクラスタを簡単にデプロイして高可用性を実現できます。 また、InnoDB クラスタ は <a class="ulink" href="https://dev.mysql.com/doc/mysql-router/8.0/en/" target="_top">MySQL Router</a> とシームレスにインタフェースするため、アプリケーションは独自のフェイルオーバープロセスを記述せずにクラスタに接続できます。 ただし、高可用性を必要としない同様のユースケースでは、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-innodb-replicaset.html" target="_top">InnoDB ReplicaSet</a> を使用できます。 MySQL Shell のインストール手順は、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-shell-install.html" target="_top">here</a> にあります。 
      </p></div><p>
      すべての設定に共通の汎用タスクがいくつかあります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ソースで、バイナリロギングが有効になっていることを確認し、一意のサーバー ID を構成する必要があります。 これには、サーバーの再起動が必要となる場合があります。 <a class="xref" href="replication.html#replication-howto-masterbaseconfig" title="17.1.2.1 レプリケーションソース構成の設定">セクション17.1.2.1「レプリケーションソース構成の設定」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          ソースに接続する各レプリカで、一意のサーバー ID を構成する必要があります。 これには、サーバーの再起動が必要となる場合があります。 <a class="xref" href="replication.html#replication-howto-slavebaseconfig" title="17.1.2.2 レプリカ構成の設定">セクション17.1.2.2「レプリカ構成の設定」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          必要に応じて、レプリケーション用のバイナリログを読み取るときに、ソースとの認証中にレプリカで使用する別のユーザーを作成します。 <a class="xref" href="replication.html#replication-howto-repuser" title="17.1.2.3 レプリケーション用ユーザーの作成">セクション17.1.2.3「レプリケーション用ユーザーの作成」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          データスナップショットを作成したり、レプリケーションプロセスを開始したりする前に、ソースで現在の位置をバイナリログに記録するようにしてください。 レプリカがイベントの実行を開始するバイナリログ内の場所を認識できるように、レプリカを構成するときにこの情報が必要になります。 <a class="xref" href="replication.html#replication-howto-masterstatus" title="17.1.2.4 レプリケーションソースのバイナリログ座標の取得">セクション17.1.2.4「レプリケーションソースのバイナリログ座標の取得」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          すでにソースにデータがあり、それを使用してレプリカを同期する場合は、データスナップショットを作成してレプリカにデータをコピーする必要があります。 使用しているストレージエンジンは、スナップショットの作成方法に影響します。 <code class="literal">MyISAM</code> を使用している場合は、ソース上のステートメントの処理を停止して読み取りロックを取得し、その現在のバイナリログ座標を取得してそのデータをダンプしてから、ソースがステートメントの実行を続行できるようにする必要があります。 ステートメントの実行を停止しないと、データダンプとソースステータス情報が一致しなくなり、レプリカ上のデータベースの一貫性または破損が発生します。 <code class="literal">MyISAM</code> ソースのレプリケートの詳細は、<a class="xref" href="replication.html#replication-howto-masterstatus" title="17.1.2.4 レプリケーションソースのバイナリログ座標の取得">セクション17.1.2.4「レプリケーションソースのバイナリログ座標の取得」</a> を参照してください。 <code class="literal">InnoDB</code> を使用している場合、読取りロックは必要なく、データスナップショットの転送に十分な長さのトランザクションで十分です。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-and-mysql-replication" title="15.19 InnoDB と MySQL レプリケーション">セクション15.19「InnoDB と MySQL レプリケーション」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          ホスト名、ログイン資格証明、バイナリログファイルの名前と位置など、ソースに接続するための設定でレプリカを構成します。 <a class="xref" href="replication.html#replication-howto-slaveinit" title="17.1.2.7 レプリカでのソース構成の設定">セクション17.1.2.7「レプリカでのソース構成の設定」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          システムに応じて、ソースおよびレプリカにレプリケーション固有のセキュリティ対策を実装します。 <a class="xref" href="replication.html#replication-security" title="17.3 レプリケーションのセキュリティ">セクション17.3「レプリケーションのセキュリティ」</a>を参照してください。 
        </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        セットアッププロセスのあるステップでは、<code class="literal">SUPER</code> 権限が必要です。 この権限がないと、レプリケーションを有効にできない可能性があります。 
      </p></div><p>
      基本オプションを構成したあとは、次のシナリオを選択します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          データを含まないソースおよびレプリカのフレッシュインストールのレプリケーションを設定するには、<a class="xref" href="replication.html#replication-howto-newservers" title="17.1.2.6.1 新しいソースおよびレプリカを使用したレプリケーションの設定">セクション17.1.2.6.1「新しいソースおよびレプリカを使用したレプリケーションの設定」</a> を参照してください。
        </p></li><li class="listitem"><p>
          既存の MySQL サーバーのデータを使用して新しいソースのレプリケーションを設定するには、<a class="xref" href="replication.html#replication-howto-existingdata" title="17.1.2.6.2 既存のデータによるレプリケーションのセットアップ">セクション17.1.2.6.2「既存のデータによるレプリケーションのセットアップ」</a> を参照してください。
        </p></li><li class="listitem"><p>
          既存のレプリケーション環境にレプリカを追加するには、<a class="xref" href="replication.html#replication-howto-additionalslaves" title="17.1.2.8 レプリケーション環境へのレプリカの追加">セクション17.1.2.8「レプリケーション環境へのレプリカの追加」</a> を参照してください。
        </p></li></ul></div><p>
      MySQL レプリケーションサーバーを管理する前に、この章全体を読み、<a class="xref" href="sql-statements.html#replication-statements-master" title="13.4.1 ソースサーバーを制御する SQL ステートメント">セクション13.4.1「ソースサーバーを制御する SQL ステートメント」</a>と<a class="xref" href="sql-statements.html#replication-statements-replica" title="13.4.2 レプリケーションサーバーを制御するための SQL ステートメント">セクション13.4.2「レプリケーションサーバーを制御するための SQL ステートメント」</a>で説明したすべてのステートメントを試みてください。 また、<a class="xref" href="replication.html#replication-options" title="17.1.6 レプリケーションおよびバイナリロギングのオプションと変数">セクション17.1.6「レプリケーションおよびバイナリロギングのオプションと変数」</a>で説明されたレプリケーションの起動オプションについても習得してください。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-howto-masterbaseconfig"></a>17.1.2.1 レプリケーションソース構成の設定</h4></div></div></div><p>
        バイナリログファイルの位置ベースのレプリケーションを使用するようにソースを構成するには、バイナリロギングが有効になっていることを確認し、一意のサーバー ID を確立する必要があります。
      </p><p>
        レプリケーショントポロジ内の各サーバーは、<code class="literal">server_id</code> システム変数を使用して指定できる一意のサーバー ID で構成する必要があります。 このサーバー ID は、レプリケーショントポロジ内の個々のサーバーを識別するために使用され、1 から (2 <sup>32</sup>)−1 までの正の整数である必要があります。 MySQL 8.0 のデフォルトの <code class="literal">server_id</code> 値は 1 です。 次のようなステートメントを発行して、<code class="literal">server_id</code> 値を動的に変更できます: 
      </p><pre class="programlisting">SET GLOBAL server_id = 2;
</pre><p>
        各サーバー ID がレプリケーショントポロジ内の他のサーバーで使用されている他のすべてのサーバー ID と異なるかぎり、サーバー ID を編成して選択する方法が選択されます。 サーバー ID に 0 (以前のリリースではデフォルト) の値が以前に設定されていた場合は、サーバーを再起動して、ソースを新しいゼロ以外のサーバー ID で初期化する必要があります。 それ以外の場合は、サーバー ID を変更するときにサーバーを再起動する必要はありません。ただし、サーバー ID を必要とする他の構成を変更する場合は除きます。 
      </p><p>
        バイナリログはソースからそのレプリカに変更をレプリケートするための基礎であるため、ソースではバイナリロギングが必要です。 バイナリロギングはデフォルトで有効になっています (<code class="literal">log_bin</code> システム変数は ON に設定されています)。 <code class="option">--log-bin</code> オプションは、バイナリログファイルに使用するベース名をサーバーに指示します。 ホスト名が変更された場合でも同じバイナリログファイル名を簡単に使用できるように、バイナリログファイルにデフォルト以外のベース名を付けるには、このオプションを指定することをお勧めします (<a class="xref" href="error-handling.html#known-issues" title="B.3.7 MySQL の既知の問題">セクションB.3.7「MySQL の既知の問題」</a> を参照)。 バイナリロギングが以前に <code class="option">--skip-log-bin</code> オプションを使用してソースで無効になっていた場合は、このオプションを指定せずにサーバーを再起動して有効にする必要があります。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          次のオプションもソースに影響します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">InnoDB</code> とトランザクションを使用したレプリケーション設定で永続性と一貫性を最大限に高めるには、ソース <code class="filename">my.cnf</code> ファイルで <code class="literal">innodb_flush_log_at_trx_commit=1</code> および <code class="literal">sync_binlog=1</code> を使用する必要があります。
            </p></li><li class="listitem"><p>
              ソースで <code class="literal">skip_networking</code> システム変数が有効になっていないことを確認します。 ネットワーキングが無効になっている場合、レプリカはソースと通信できず、レプリケーションは失敗します。 
            </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-howto-slavebaseconfig"></a>17.1.2.2 レプリカ構成の設定</h4></div></div></div><p>
        各レプリカには、<code class="literal">server_id</code> システム変数で指定された一意のサーバー ID が必要です。 複数のレプリカを設定する場合、各レプリカの <code class="literal">server_id</code> 値は、ソースと他のレプリカの値とは異なる一意である必要があります。 レプリカサーバー ID がまだ設定されていない場合、または現在の値がソースまたは別のレプリカに選択した値と競合する場合は、それを変更する必要があります。 
      </p><p>
        デフォルトの <code class="literal">server_id</code> 値は 1 です。 次のようなステートメントを発行して、<code class="literal">server_id</code> 値を動的に変更できます: 
      </p><pre class="programlisting">SET GLOBAL server_id = 21;
</pre><p>
        サーバー ID の値が 0 の場合、レプリカはソースに接続できません。 そのサーバー ID 値 (以前のリリースではデフォルト) が以前に設定されていた場合は、サーバーを再起動して、新しいゼロ以外のサーバー ID でレプリカを初期化する必要があります。 それ以外の場合は、サーバー ID を変更するときにサーバーを再起動する必要はありません。ただし、サーバー ID を必要とする他の構成を変更する場合は除きます。 たとえば、バイナリロギングがサーバーで無効になっていて、それをレプリカに対して有効にする場合、これを有効にするにはサーバーの再起動が必要です。 
      </p><p>
        レプリカサーバーを停止する場合は、構成ファイルの<code class="literal">[mysqld]</code>セクションを編集して、一意のサーバー ID を指定できます。 例: 
      </p><pre class="programlisting">[mysqld]
server-id=21
</pre><p>
        バイナリロギングは、すべてのサーバーでデフォルトで有効になっています。 レプリケーションを実行するために、レプリカでバイナリロギングを有効にする必要はありません。 ただし、レプリカのバイナリロギングとは、レプリカバイナリログをデータバックアップおよびクラッシュ回復に使用できることを意味します。 バイナリロギングが有効になっているレプリカは、より複雑なレプリケーショントポロジの一部としても使用できます。 たとえば、次の連鎖配置を使用してレプリケーションサーバーを設定できます: 
      </p><pre class="programlisting">A -&gt; B -&gt; C
</pre><p>
        ここで、<code class="literal">A</code> はレプリカ <code class="literal">B</code> のソースとして機能し、<code class="literal">B</code> はレプリカ <code class="literal">C</code> のソースとして機能します。 これが機能するには、<code class="literal">B</code> がソースとレプリカの両方である必要があります。 <code class="literal">A</code> から受信した更新を <code class="literal">C</code> に渡すには、<code class="literal">B</code> がバイナリログに記録する必要があります。 バイナリロギングに加えて、このレプリケーショントポロジでは <code class="literal">log_slave_updates</code> システム変数を有効にする必要があります。 レプリカ更新が有効になっている場合、レプリカはソースから受信し、レプリカ SQL スレッドによって実行された更新をレプリカ独自のバイナリログに書き込みます。 <code class="literal">log_slave_updates</code> システム変数はデフォルトで有効になっています。 
      </p><p>
        レプリカでバイナリロギングまたはレプリカ更新ロギングを無効にする必要がある場合は、レプリカの <code class="option">--skip-log-bin</code> および <code class="option">--log-slave-updates=OFF</code> オプションを指定することでこれを行うことができます。 レプリカでこれらの機能を再度有効にする場合は、関連するオプションを削除してサーバーを再起動します。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-howto-repuser"></a>17.1.2.3 レプリケーション用ユーザーの作成</h4></div></div></div><p>
        各レプリカは MySQL のユーザー名とパスワードを使用してソースに接続するため、レプリカが接続に使用できるユーザーアカウントがソースに存在する必要があります。 ユーザー名は、レプリカの設定時に、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23 から) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 から) の <code class="literal">SOURCE_USER</code> | <code class="literal">MASTER_USER</code> オプションによって指定されます。 この操作には、<code class="literal">REPLICATION SLAVE</code> 権限が付与されているすべてのアカウントを使用できます。 レプリカごとに異なるアカウントを作成することも、レプリカごとに同じアカウントを使用してソースに接続することもできます。 
      </p><p>
        レプリケーション専用のアカウントを作成する必要はありませんが、レプリケーションユーザー名とパスワードはレプリカ接続メタデータリポジトリ <code class="literal">mysql.slave_master_info</code> にプレーンテキストで格納されることに注意してください (<a class="xref" href="replication.html#replica-logs-status" title="17.2.4.2 レプリケーションメタデータリポジトリ">セクション17.2.4.2「レプリケーションメタデータリポジトリ」</a> を参照)。 このため、ほかのアカウントのセキュリティーを損なう可能性を最小限に抑えるため、レプリケーションプロセスにのみ権限を持つ別のアカウントを作成することをお勧めします。 
      </p><p>
        新しいアカウントを作成するには、<code class="literal">CREATE USER</code> を使用します。 レプリケーションに必要な権限をこのアカウントに付与するには、<code class="literal">GRANT</code> ステートメントを使用します。 レプリケーションの目的にだけアカウントを作成する場合、そのアカウントには <code class="literal">REPLICATION SLAVE</code> 権限だけが必要です。 たとえば、<code class="literal">example.com</code> ドメイン内の任意のホストからレプリケーション用に接続できる新しいユーザー <code class="literal">repl</code> を設定するには、ソースで次のステートメントを発行します: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE USER 'repl'@'%.example.com' IDENTIFIED BY '<em class="replaceable"><code>password</code></em>';</code></strong>
mysql&gt; <strong class="userinput"><code>GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%.example.com';</code></strong>
</pre><p>
        ユーザーアカウントを操作するためのステートメントの詳細については、<a class="xref" href="sql-statements.html#account-management-statements" title="13.7.1 アカウント管理ステートメント">セクション13.7.1「アカウント管理ステートメント」</a>を参照してください。
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          <code class="literal">caching_sha2_password</code> プラグインで認証するユーザーアカウントを使用してソースに接続するには、<a class="xref" href="replication.html#replication-solutions-encrypted-connections" title="17.3.1 暗号化接続を使用するためのレプリケーションの設定">セクション17.3.1「暗号化接続を使用するためのレプリケーションの設定」</a> の説明に従ってセキュアな接続を設定するか、RSA キーペアを使用したパスワード交換をサポートするように暗号化されていない接続を有効にする必要があります。 <code class="literal">caching_sha2_password</code> 認証プラグインは、MySQL 8.0 から作成された新規ユーザーのデフォルトです (詳細は、<a class="xref" href="security.html#caching-sha2-pluggable-authentication" title="6.4.1.2 SHA-2 プラガブル認証のキャッシュ">セクション6.4.1.2「SHA-2 プラガブル認証のキャッシュ」</a> を参照)。 (<code class="literal">MASTER_USER</code> オプションで指定された) レプリケーション用に作成または使用するユーザーアカウントがこの認証プラグインを使用し、セキュアな接続を使用していない場合は、接続を成功させるために RSA 鍵ペアベースのパスワード交換を有効にする必要があります。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-howto-masterstatus"></a>17.1.2.4 レプリケーションソースのバイナリログ座標の取得</h4></div></div></div><p>
        レプリケーションプロセスを正しい時点で開始するようにレプリカを構成するには、そのバイナリログ内のソースの現在の座標を書き留める必要があります。
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          このプロシージャでは、<code class="literal">InnoDB</code> テーブルの <code class="literal">COMMIT</code> 操作をブロックする <code class="literal">FLUSH TABLES WITH READ LOCK</code> を使用します。
        </p></div><p>
        ソースを停止してデータスナップショットを作成する場合は、オプションでこの手順をスキップし、かわりにバイナリログインデックスファイルのコピーをデータスナップショットとともに格納できます。 その場合、ソースは再起動時に新しいバイナリログファイルを作成します。 したがって、レプリカがレプリケーションプロセスを開始すべきソースのバイナリログ座標は、その新しいファイルの開始点であり、コピーされたバイナリログインデックスファイルにリストされているファイルの次のソースのバイナリログファイルとなります。 
      </p><p>
        ソースバイナリログ座標を取得するには、次のステップに従います:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            コマンドラインクライアントを使用してソースに接続してセッションを開始し、<code class="literal">FLUSH TABLES WITH READ LOCK</code> ステートメントを実行してすべてのテーブルおよびブロック書込みステートメントをフラッシュします:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>FLUSH TABLES WITH READ LOCK;</code></strong>
</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
              読み取りロックを有効のままにするため、<code class="literal">FLUSH TABLES</code> ステートメントを発行したクライアントを実行中のままにしてください。 クライアントを終了すると、ロックは解除されます。 
            </p></div></li><li class="listitem"><p>
            ソース上の別のセッションで、<code class="literal">SHOW MASTER STATUS</code> ステートメントを使用して現在のバイナリログファイルの名前と位置を確認します:
          </p><pre class="programlisting">mysql &gt; <strong class="userinput"><code>SHOW MASTER STATUS;</code></strong>
+------------------+----------+--------------+------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+
| mysql-bin.000003 | 73       | test         | manual,mysql     |
+------------------+----------+--------------+------------------+
</pre><p>
            <code class="literal">File</code> カラムにはログファイルの名前が表示され、<code class="literal">Position</code> カラムにはファイル内の位置が表示されます。 この例では、バイナリログファイルは <code class="literal">mysql-bin.000003</code> で、位置は 73 です。 これらの値を記録します。 これらは、後でレプリカを設定するときに必要になります。 これらは、レプリカがソースからの新しい更新の処理を開始するレプリケーション座標を表します。 
          </p><p>
            ソースがそれまでバイナリロギングを無効にして実行されていた場合、<code class="literal">SHOW MASTER STATUS</code> または <span class="command"><strong>mysqldump --master-data</strong></span> によって表示されるログファイルの名前と位置の値は空です。 その場合、あとでソースバイナリログファイルと位置を指定するときに使用する必要がある値は、空の文字列 (<code class="literal">''</code>) と <code class="literal">4</code> です。 
          </p></li></ol></div><p>
        これで、レプリカがレプリケーションを開始するための正しい場所でソースバイナリログからの読み取りを開始できるようにするために必要な情報が得られました。
      </p><p>
        次のステップは、ソースに既存のデータがあるかどうかによって異なります。 次のいずれかのオプションを選択します: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            レプリケーションを開始する前にレプリカと同期する必要がある既存のデータがある場合は、ロックが維持されるようにクライアントを実行したままにします。 これにより、レプリカにコピーされたデータがソースと同期されるように、それ以上の変更が行われなくなります。 <a class="xref" href="replication.html#replication-snapshot-method" title="17.1.2.5 データスナップショットの方法の選択">セクション17.1.2.5「データスナップショットの方法の選択」</a> に進みます。 
          </p></li><li class="listitem"><p>
            新しいソースとレプリカの組合せを設定する場合は、最初のセッションを終了して読取りロックを解放できます。 手順については、<a class="xref" href="replication.html#replication-howto-newservers" title="17.1.2.6.1 新しいソースおよびレプリカを使用したレプリケーションの設定">セクション17.1.2.6.1「新しいソースおよびレプリカを使用したレプリケーションの設定」</a> を参照してください。 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-snapshot-method"></a>17.1.2.5 データスナップショットの方法の選択</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-howto-mysqldump">17.1.2.5.1 mysqldump を使用したデータスナップショットの作成</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto-rawdata">17.1.2.5.2 ローデータファイルを使用したデータスナップショットの作成</a></span></dt></dl></div><p>
        ソースデータベースに既存のデータが含まれている場合、このデータを各レプリカにコピーする必要があります。 ソースデータベースからデータをダンプするには、様々な方法があります。 次の各セクションでは、使用可能なオプションについて説明します。 
      </p><p>
        データベースをダンプする適切な方法を選択するには、次のいずれかのオプションを選択します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="command"><strong>mysqldump</strong></span> ツールを使用して、レプリケートするすべてのデータベースのダンプを作成します。 これは、特に <code class="literal">InnoDB</code> を使用する場合に推奨される方法です。 
          </p></li><li class="listitem"><p>
            データベースがバイナリポータブルファイルに格納されている場合は、RAW データファイルをレプリカにコピーできます。 これは、<code class="literal">INSERT</code> ステートメントのリプレイ時にインデックスの更新のオーバーヘッドがスキップされるため、<span class="command"><strong>mysqldump</strong></span> を使用して各レプリカにファイルをインポートするよりも効率的です。 <code class="literal">InnoDB</code> などのストレージエンジンでは、これはお勧めしません。 
          </p></li><li class="listitem"><p>
            MySQL Server クローンプラグインを使用して、既存のレプリカからクローンにすべてのデータを転送します。 この方法の使用手順は、<a class="xref" href="server-administration.html#clone-plugin-replication" title="5.6.7.6 レプリケーション用のクローニング">セクション5.6.7.6「レプリケーション用のクローニング」</a> を参照してください。 
          </p></li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">ヒント</div><p>
          MySQL の複数のインスタンスをデプロイするには、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/" target="_top">MySQL Shell</a> で MySQL サーバーインスタンスのグループを簡単に管理できるようにする <a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-innodb-cluster.html" target="_top">InnoDB クラスタ</a> を使用できます。InnoDB クラスタ は MySQL Group Replication をプログラム環境でラップするため、MySQL インスタンスのクラスタを簡単にデプロイして高可用性を実現できます。 また、InnoDB クラスタ は <a class="ulink" href="https://dev.mysql.com/doc/mysql-router/8.0/en/" target="_top">MySQL Router</a> とシームレスにインタフェースするため、アプリケーションは独自のフェイルオーバープロセスを記述せずにクラスタに接続できます。 ただし、高可用性を必要としない同様のユースケースでは、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-innodb-replicaset.html" target="_top">InnoDB ReplicaSet</a> を使用できます。 MySQL Shell のインストール手順は、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-shell-install.html" target="_top">here</a> にあります。 
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="replication-howto-mysqldump"></a>17.1.2.5.1 mysqldump を使用したデータスナップショットの作成</h5></div></div></div><p>
          既存のソースデータベースにデータのスナップショットを作成するには、<span class="command"><strong>mysqldump</strong></span> ツールを使用します。 データダンプが完了したら、レプリケーションプロセスを開始する前に、このデータをレプリカにインポートします。 
        </p><p>
          次の例では、すべてのデータベースを <code class="filename">dbdump.db</code> という名前のファイルにダンプし、レプリケーションプロセスを開始するためにレプリカに必要な <code class="literal">CHANGE REPLICATION SOURCE TO</code>|<code class="literal">CHANGE MASTER TO</code> ステートメントを自動的に追加する <code class="option">--master-data</code> オプションを含めます:
        </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqldump --all-databases --master-data &gt; dbdump.db</code></strong>
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="option">--master-data</code> を使用しない場合は、別のセッションですべてのテーブルを手動でロックする必要があります。 <a class="xref" href="replication.html#replication-howto-masterstatus" title="17.1.2.4 レプリケーションソースのバイナリログ座標の取得">セクション17.1.2.4「レプリケーションソースのバイナリログ座標の取得」</a>を参照してください。 
          </p></div><p>
          <span class="command"><strong>mysqldump</strong></span> ツールを使用して、特定のデータベースをダンプから除外できます。 ダンプに含めるデータベースを選択する場合は、<code class="option">--all-databases</code> を使用しないでください。 次のいずれかのオプションを選択します: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="option">--ignore-table</code> オプションを使用して、データベース内のすべてのテーブルを除外します。
            </p></li><li class="listitem"><p>
              <code class="option">--databases</code> オプションを使用してダンプするデータベースのみに名前を付けます。
            </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            デフォルトでは、GTID がソース (<code class="literal">gtid_mode=ON</code>) で使用されている場合、<span class="command"><strong>mysqldump</strong></span> はソース上の <code class="literal">gtid_executed</code> セットの GTID をダンプ出力に含めて、レプリカ上の <code class="literal">gtid_purged</code> セットに追加します。 特定のデータベースまたはテーブルのみをダンプする場合、<span class="command"><strong>mysqldump</strong></span> に含まれる値には、データベースの抑制された部分を変更したトランザクションや、部分ダンプに含まれていないサーバー上のその他のデータベースであっても、ソース上の <code class="literal">gtid_executed</code> セット内のすべてのトランザクションの GTID が含まれることに注意してください。 mysqldump <code class="option">--set-gtid-purged</code> オプションの説明を確認して、使用している MySQL Server バージョンのデフォルト動作の結果、およびこの結果が状況に適していない場合の動作の変更方法を確認します。 
          </p></div><p>
          詳細は、<a class="xref" href="programs.html#mysqldump" title="4.5.4 mysqldump — データベースバックアッププログラム">セクション4.5.4「mysqldump — データベースバックアッププログラム」</a>を参照してください。
        </p><p>
          データをインポートするには、ダンプファイルをレプリカにコピーするか、レプリカにリモート接続するときにソースからファイルにアクセスします。
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="replication-howto-rawdata"></a>17.1.2.5.2 ローデータファイルを使用したデータスナップショットの作成</h5></div></div></div><p>
          このセクションでは、データベースを構成する RAW ファイルを使用してデータスナップショットを作成する方法について説明します。 複雑なキャッシュまたはロギングアルゴリズムを持つストレージエンジンを使用するテーブルでこの方法を使用するには、完全な<span class="quote">「<span class="quote">「ポイントインタイム」</span>」</span>スナップショットを生成するための追加のステップが必要です: 最初のコピーコマンドでは、グローバル読取りロックを取得した場合でも、キャッシュ情報およびロギング更新を除外できます。 ストレージエンジンがこれにどのように反応するかは、そのクラッシュリカバリ能力によります。 
        </p><p>
          <code class="literal">InnoDB</code> テーブルを使用する場合、MySQL Enterprise Backup コンポーネントから <span class="command"><strong>mysqlbackup</strong></span> コマンドを使用して、一貫性のあるスナップショットを作成できます。 このコマンドは、レプリカで使用されるスナップショットに対応するログ名とオフセットを記録します。 MySQL Enterprise Backup は MySQL Enterprise サブスクリプションの一部として同梱される製品です。 詳細は、<a class="xref" href="mysql-enterprise.html#mysql-enterprise-backup" title="30.2 MySQL Enterprise Backup の概要">セクション30.2「MySQL Enterprise Backup の概要」</a>を参照してください。 
        </p><p>
          この方法は、ソースとレプリカの値が <code class="literal">ft_stopword_file</code>、<code class="literal">ft_min_word_len</code> または <code class="literal">ft_max_word_len</code> で異なり、全文インデックスを持つテーブルをコピーしている場合にも確実に機能しません。
        </p><p>
          前述の例外がデータベースに適用されない場合は、<a class="link" href="glossary.html#glos_cold_backup" title="コールドバックアップ">cold backup</a> 手法を使用して、<code class="literal">InnoDB</code> テーブルの信頼性のあるバイナリスナップショットを取得: MySQL Server の <a class="link" href="glossary.html#glos_slow_shutdown" title="低速シャットダウン">slow shutdown</a> を実行してから、データファイルを手動でコピーします。
        </p><p>
          MySQL データファイルが単一のファイルシステムに存在する場合に <code class="literal">MyISAM</code> テーブルの RAW データスナップショットを作成するには、<span class="command"><strong>cp</strong></span> や <span class="command"><strong>copy</strong></span> などのアーカイブツール、<span class="command"><strong>scp</strong></span> や <span class="command"><strong>rsync</strong></span> などのリモートコピーツール、または <span class="command"><strong>zip</strong></span> または <span class="command"><strong>tar</strong></span>、または <span class="command"><strong>dump</strong></span> のようなファイルシステムスナップショットツールを使用できます。 特定のデータベースだけを複製する場合、それらのテーブルに関係するファイルだけをコピーします。 <code class="literal">InnoDB</code> の場合、<code class="option">innodb_file_per_table</code> オプションを有効にしないかぎり、すべてのデータベースのすべてのテーブルが <a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">system tablespace</a> ファイルに格納されます。 
        </p><p>
          次のファイルはレプリケーションには必要ありません:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">mysql</code> データベースに関連するファイル。
            </p></li><li class="listitem"><p>
              レプリカ接続メタデータリポジトリファイル <code class="literal">master.info</code> が使用されている場合、このファイルの使用は非推奨になりました (<a class="xref" href="replication.html#replica-logs" title="17.2.4 リレーログおよびレプリケーションメタデータリポジトリ">セクション17.2.4「リレーログおよびレプリケーションメタデータリポジトリ」</a> を参照)。
            </p></li><li class="listitem"><p>
              これを使用してレプリカのソースバイナリログ座標を検索する場合は、バイナリログインデックスファイルを除き、ソースリグファイル。
            </p></li><li class="listitem"><p>
              リレーログファイル。
            </p></li></ul></div><p>
          <code class="literal">InnoDB</code> テーブルを使用しているかどうかに応じて、次のいずれかを選択します:
        </p><p>
          <code class="literal">InnoDB</code> テーブルを使用していて、RAW データスナップショットと最も一貫性のある結果を得るには、プロセス中に次のようにソースサーバーを停止します:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              読取りロックを取得し、ソースステータスを取得します。 <a class="xref" href="replication.html#replication-howto-masterstatus" title="17.1.2.4 レプリケーションソースのバイナリログ座標の取得">セクション17.1.2.4「レプリケーションソースのバイナリログ座標の取得」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              別のセッションで、ソースサーバーを停止します:
            </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqladmin shutdown</code></strong>
</pre></li><li class="listitem"><p>
              MySQL データファイルのコピーを作成します。 次の例では、これを行うための一般的な方法を示します。 この中の 1 つだけを選択する必要があります。 
            </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>tar cf <em class="replaceable"><code>/tmp/db.tar</code></em> <em class="replaceable"><code>./data</code></em></code></strong>
shell&gt; <strong class="userinput"><code>zip -r <em class="replaceable"><code>/tmp/db.zip</code></em> <em class="replaceable"><code>./data</code></em></code></strong>
shell&gt; <strong class="userinput"><code>rsync --recursive <em class="replaceable"><code>./data</code></em> <em class="replaceable"><code>/tmp/dbdata</code></em></code></strong>
</pre></li><li class="listitem"><p>
              ソースサーバーを再起動します。
            </p></li></ol></div><p>
          <code class="literal">InnoDB</code> テーブルを使用していない場合は、次の手順で説明するように、サーバーをシャットダウンせずにソースからシステムのスナップショットを取得できます:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              読取りロックを取得し、ソースステータスを取得します。 <a class="xref" href="replication.html#replication-howto-masterstatus" title="17.1.2.4 レプリケーションソースのバイナリログ座標の取得">セクション17.1.2.4「レプリケーションソースのバイナリログ座標の取得」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              MySQL データファイルのコピーを作成します。 次の例では、これを行うための一般的な方法を示します。 この中の 1 つだけを選択する必要があります。 
            </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>tar cf <em class="replaceable"><code>/tmp/db.tar</code></em> <em class="replaceable"><code>./data</code></em></code></strong>
shell&gt; <strong class="userinput"><code>zip -r <em class="replaceable"><code>/tmp/db.zip</code></em> <em class="replaceable"><code>./data</code></em></code></strong>
shell&gt; <strong class="userinput"><code>rsync --recursive <em class="replaceable"><code>./data</code></em> <em class="replaceable"><code>/tmp/dbdata</code></em></code></strong>
</pre></li><li class="listitem"><p>
              読み取りロックを獲得したクライアントでは、ロックを解除します。
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UNLOCK TABLES;</code></strong>
</pre></li></ol></div><p>
          データベースのアーカイブまたはコピーを作成したら、レプリケーションプロセスを開始する前に各レプリカにファイルをコピーします。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-setup-replicas"></a>17.1.2.6 レプリカの設定</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-howto-newservers">17.1.2.6.1 新しいソースおよびレプリカを使用したレプリケーションの設定</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto-existingdata">17.1.2.6.2 既存のデータによるレプリケーションのセットアップ</a></span></dt></dl></div><p>
        次の各セクションでは、レプリカの設定方法について説明します。 続行する前に、次のことを確認してください: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            必要な構成プロパティを使用してソースを構成しました。 <a class="xref" href="replication.html#replication-howto-masterbaseconfig" title="17.1.2.1 レプリケーションソース構成の設定">セクション17.1.2.1「レプリケーションソース構成の設定」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            データスナップショットのシャットダウン中に作成されたソースステータス情報またはソースバイナリログインデックスファイルのコピーを取得しました。 <a class="xref" href="replication.html#replication-howto-masterstatus" title="17.1.2.4 レプリケーションソースのバイナリログ座標の取得">セクション17.1.2.4「レプリケーションソースのバイナリログ座標の取得」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            ソースで、読み取りロックを解放します:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UNLOCK TABLES;</code></strong>
</pre></li><li class="listitem"><p>
            レプリカで、MySQL 構成を編集しました。 <a class="xref" href="replication.html#replication-howto-slavebaseconfig" title="17.1.2.2 レプリカ構成の設定">セクション17.1.2.2「レプリカ構成の設定」</a>を参照してください。 
          </p></li></ul></div><p>
        次のステップは、レプリカにインポートする既存のデータがあるかどうかによって異なります。 詳しくは<a class="xref" href="replication.html#replication-snapshot-method" title="17.1.2.5 データスナップショットの方法の選択">セクション17.1.2.5「データスナップショットの方法の選択」</a>をご覧ください。 次のいずれかを選択します: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            インポートするデータベースのスナップショットがない場合は、<a class="xref" href="replication.html#replication-howto-newservers" title="17.1.2.6.1 新しいソースおよびレプリカを使用したレプリケーションの設定">セクション17.1.2.6.1「新しいソースおよびレプリカを使用したレプリケーションの設定」</a> を参照してください。
          </p></li><li class="listitem"><p>
            インポートするデータベースのスナップショットがある場合は、<a class="xref" href="replication.html#replication-howto-existingdata" title="17.1.2.6.2 既存のデータによるレプリケーションのセットアップ">セクション17.1.2.6.2「既存のデータによるレプリケーションのセットアップ」</a> を参照してください。
          </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="replication-howto-newservers"></a>17.1.2.6.1 新しいソースおよびレプリカを使用したレプリケーションの設定</h5></div></div></div><p>
          インポートする以前のデータベースのスナップショットがない場合は、新しいソースからレプリケーションを開始するようにレプリカを構成します。
        </p><p>
          ソースと新しいレプリカ間のレプリケーションを設定するには:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              レプリカを起動します。
            </p></li><li class="listitem"><p>
              レプリカに対して <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントを実行し、ソース構成を設定します。 <a class="xref" href="replication.html#replication-howto-slaveinit" title="17.1.2.7 レプリカでのソース構成の設定">セクション17.1.2.7「レプリカでのソース構成の設定」</a>を参照してください。 
            </p></li></ol></div><p>
          各レプリカで次のレプリカ設定ステップを実行します。
        </p><p>
          この方法は、新しいサーバーを設定しているが、レプリケーション構成にロードする別のサーバーのデータベースの既存のダンプがある場合にも使用できます。 データを新しいソースにロードすると、データはレプリカに自動的にレプリケートされます。 
        </p><p>
          別の既存のデータベースサーバーのデータを使用して新しいレプリケーション環境を設定して新しいソースを作成する場合は、そのサーバーから生成されたダンプファイルを新しいソースで実行します。 データベース更新はレプリカに自動的に伝播されます: 
        </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysql -h source &lt; fulldb.dump</code></strong>
</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="replication-howto-existingdata"></a>17.1.2.6.2 既存のデータによるレプリケーションのセットアップ</h5></div></div></div><p>
          既存のデータを使用してレプリケーションを設定する場合は、レプリケーションを開始する前に、スナップショットをソースからレプリカに転送します。 レプリカにデータをインポートするプロセスは、ソースでのデータのスナップショットの作成方法によって異なります。 
        </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">ヒント</div><p>
            MySQL の複数のインスタンスをデプロイするには、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/" target="_top">MySQL Shell</a> で MySQL サーバーインスタンスのグループを簡単に管理できるようにする <a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-innodb-cluster.html" target="_top">InnoDB クラスタ</a> を使用できます。InnoDB クラスタ は MySQL Group Replication をプログラム環境でラップするため、MySQL インスタンスのクラスタを簡単にデプロイして高可用性を実現できます。 また、InnoDB クラスタ は <a class="ulink" href="https://dev.mysql.com/doc/mysql-router/8.0/en/" target="_top">MySQL Router</a> とシームレスにインタフェースするため、アプリケーションは独自のフェイルオーバープロセスを記述せずにクラスタに接続できます。 ただし、高可用性を必要としない同様のユースケースでは、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-innodb-replicaset.html" target="_top">InnoDB ReplicaSet</a> を使用できます。 MySQL Shell のインストール手順は、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-shell-install.html" target="_top">here</a> にあります。 
          </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            新しいレプリカを作成するためにコピーするレプリケーションソースサーバーまたは既存のレプリカにスケジュールされたイベントがある場合は、それらが新しいレプリカで無効になっていることを確認してから開始してください。 ソースですでに実行されている新しいレプリカでイベントが実行されると、複製された操作によってエラーが発生します。 イベントスケジューラは、<code class="literal">event_scheduler</code> システム変数によって制御されます。このシステム変数のデフォルトは MySQL 8.0 の <code class="literal">ON</code> であるため、元のサーバーでアクティブなイベントは、新しいレプリカの起動時にデフォルトで実行されます。 新しいレプリカでのすべてのイベントの実行を停止するには、新しいレプリカで <code class="literal">event_scheduler</code> システム変数を <code class="literal">OFF</code> または <code class="literal">DISABLED</code> に設定します。 または、<code class="literal">ALTER EVENT</code> ステートメントを使用して個々のイベントを <code class="literal">DISABLE</code> または <code class="literal">DISABLE ON SLAVE</code> に設定し、新しいレプリカで実行されないようにすることもできます。 <code class="literal">SHOW</code> ステートメントまたは情報スキーマ <code class="literal">EVENTS</code> テーブルを使用して、サーバー上のイベントをリストできます。 詳細は、<a class="xref" href="replication.html#replication-features-invoked" title="17.5.1.16 呼び出される機能のレプリケーション">セクション17.5.1.16「呼び出される機能のレプリケーション」</a>を参照してください。 
          </p></div><p>
          既存のレプリカからクローンにすべてのデータを転送します。 この方法を使用する手順については、次のいずれかの手順を選択してください。 
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              MySQL Server クローンプラグインを使用して既存のレプリカからクローンを作成した場合 (<a class="xref" href="server-administration.html#clone-plugin-replication" title="5.6.7.6 レプリケーション用のクローニング">セクション5.6.7.6「レプリケーション用のクローニング」</a> を参照)、データはすでに転送されています。 それ以外の場合は、次のいずれかの方法を使用してレプリカにデータをインポートします。 
            </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>
                  <span class="command"><strong>mysqldump</strong></span> を使用した場合は、レプリケーションが開始されないように、<code class="option">--skip-slave-start</code> オプションを使用してレプリカを起動します。 次に、ダンプファイルをインポートします: 
                </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysql &lt; fulldb.dump</code></strong>
</pre></li><li class="listitem"><p>
                  RAW データファイルを使用してスナップショットを作成した場合は、データファイルをレプリカデータディレクトリに抽出します。 例: 
                </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>tar xvf dbdump.tar</code></strong>
</pre><p>
                  レプリカサーバーがファイルにアクセスして変更できるように、ファイルに対する権限と所有権の設定が必要になる場合があります。 次に、レプリケーションが開始されないように、<code class="option">--skip-slave-start</code> オプションを使用してレプリカを起動します。 
                </p></li></ol></div></li><li class="listitem"><p>
              ソースのレプリケーション座標を使用してレプリカを構成します。 これにより、レプリケーションを開始する必要があるバイナリログファイルおよびファイル内の位置がレプリカに通知されます。 また、ソースのログイン資格証明とホスト名を使用してレプリカを構成します。 必要な <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントの詳細は、<a class="xref" href="replication.html#replication-howto-slaveinit" title="17.1.2.7 レプリカでのソース構成の設定">セクション17.1.2.7「レプリカでのソース構成の設定」</a> を参照してください。 
            </p></li><li class="listitem"><p>
              <code class="literal">START REPLICA | SLAVE</code> ステートメントを発行してレプリケーションスレッドを起動します。
            </p></li></ol></div><p>
          この手順を実行すると、レプリカはソースに接続し、スナップショットの取得後にソースで発生した更新をレプリケートします。 なんらかの理由でレプリケートできない場合、エラーメッセージがレプリカエラーログに発行されます。 
        </p><p>
          レプリカは、接続メタデータリポジトリおよび適用者メタデータリポジトリに記録された情報を使用して、処理されたソースバイナリログの量を追跡します。 MySQL 8.0 からは、デフォルトで、これらのリポジトリは <code class="literal">mysql</code> データベース内の <code class="literal">slave_master_info</code> および <code class="literal">slave_relay_log_info</code> という名前のテーブルです。 実行内容を正確に把握し、その影響を完全に理解していないかぎり、これらのテーブルを削除または編集しないでください。 その場合でも、レプリケーションパラメータを変更するには、<code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントを使用することをお薦めします。 レプリカは、ステートメントで指定された値を使用して、レプリケーションメタデータリポジトリを自動的に更新します。 詳しくは<a class="xref" href="replication.html#replica-logs" title="17.2.4 リレーログおよびレプリケーションメタデータリポジトリ">セクション17.2.4「リレーログおよびレプリケーションメタデータリポジトリ」</a>,をご覧ください。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            レプリカ接続メタデータリポジトリの内容は、コマンドラインまたは <code class="filename">my.cnf</code> で指定されたサーバーオプションの一部をオーバーライドします。 詳細については、<a class="xref" href="replication.html#replication-options" title="17.1.6 レプリケーションおよびバイナリロギングのオプションと変数">セクション17.1.6「レプリケーションおよびバイナリロギングのオプションと変数」</a>を参照してください。 
          </p></div><p>
          ソースの単一のスナップショットでは、複数のレプリカで十分です。 追加のレプリカを設定するには、同じソーススナップショットを使用して、前述の手順のレプリカ部分に従います。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-howto-slaveinit"></a>17.1.2.7 レプリカでのソース構成の設定</h4></div></div></div><p>
        レプリケーションのソースと通信するようにレプリカを設定するには、必要な接続情報を使用してレプリカを構成します。 これを行うには、レプリカで、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23 の場合) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 の場合) を実行し、オプション値をシステムに関連する実際の値に置き換えます: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO</code></strong>
    -&gt;     <strong class="userinput"><code>MASTER_HOST='<em class="replaceable"><code>source_host_name</code></em>',</code></strong>
    -&gt;     <strong class="userinput"><code>MASTER_USER='<em class="replaceable"><code>replication_user_name</code></em>',</code></strong>
    -&gt;     <strong class="userinput"><code>MASTER_PASSWORD='<em class="replaceable"><code>replication_password</code></em>',</code></strong>
    -&gt;     <strong class="userinput"><code>MASTER_LOG_FILE='<em class="replaceable"><code>recorded_log_file_name</code></em>',</code></strong>
    -&gt;     <strong class="userinput"><code>MASTER_LOG_POS=<em class="replaceable"><code>recorded_log_position</code></em>;</code></strong>

Or from MySQL 8.0.23:
mysql&gt; <strong class="userinput"><code>CHANGE REPLICATION SOURCE TO</code></strong>
    -&gt;     <strong class="userinput"><code>SOURCE_HOST='<em class="replaceable"><code>source_host_name</code></em>',</code></strong>
    -&gt;     <strong class="userinput"><code>SOURCE_USER='<em class="replaceable"><code>replication_user_name</code></em>',</code></strong>
    -&gt;     <strong class="userinput"><code>SOURCE_PASSWORD='<em class="replaceable"><code>replication_password</code></em>',</code></strong>
    -&gt;     <strong class="userinput"><code>SOURCE_LOG_FILE='<em class="replaceable"><code>recorded_log_file_name</code></em>',</code></strong>
    -&gt;     <strong class="userinput"><code>SOURCE_LOG_POS=<em class="replaceable"><code>recorded_log_position</code></em>;</code></strong>
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          レプリケーションでは、Unix ソケットファイルを使用できません。 TCP/IP を使用してソース MySQL サーバーに接続できる必要があります。 
        </p></div><p>
        <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントには、その他のオプションもあります。 たとえば、SSL を使用してセキュアなレプリケーションをセットアップできます。 オプションの完全なリスト、および文字列値オプションに許可された最大長に関する情報については、<a class="xref" href="sql-statements.html#change-master-to" title="13.4.2.1 CHANGE MASTER TO ステートメント">セクション13.4.2.1「CHANGE MASTER TO ステートメント」</a>を参照してください。 
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          <a class="xref" href="replication.html#replication-howto-repuser" title="17.1.2.3 レプリケーション用ユーザーの作成">セクション17.1.2.3「レプリケーション用ユーザーの作成」</a> で説明したように、セキュアな接続を使用せず、<code class="literal">SOURCE_USER</code> | <code class="literal">MASTER_USER</code> オプションで指定されたユーザーアカウントが <code class="literal">caching_sha2_password</code> プラグイン (MySQL 8.0 からのデフォルト) を使用して認証を行う場合は、<code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントの <code class="literal">SOURCE_PUBLIC_KEY_PATH</code> | <code class="literal">MASTER_PUBLIC_KEY_PATH</code> または <code class="literal">GET_SOURCE_PUBLIC_KEY</code> | <code class="literal">GET_MASTER_PUBLIC_KEY</code> オプションを指定して RSA キーペアベースパスワード交換を使用可能にします。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-howto-additionalslaves"></a>17.1.2.8 レプリケーション環境へのレプリカの追加</h4></div></div></div><p>
        ソースサーバーを停止せずに、既存のレプリケーション構成に別のレプリカを追加できます。 これを行うには、既存のレプリカのデータディレクトリをコピーし、新しいレプリカに別のサーバー ID (ユーザー指定) およびサーバー UUID (起動時に生成) を指定して、新しいレプリカを設定します。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          新しいレプリカを作成するためにコピーするレプリケーションソースサーバーまたは既存のレプリカにスケジュールされたイベントがある場合は、それらが新しいレプリカで無効になっていることを確認してから開始してください。 ソースですでに実行されている新しいレプリカでイベントが実行されると、複製された操作によってエラーが発生します。 イベントスケジューラは、<code class="literal">event_scheduler</code> システム変数によって制御されます。このシステム変数のデフォルトは MySQL 8.0 の <code class="literal">ON</code> であるため、元のサーバーでアクティブなイベントは、新しいレプリカの起動時にデフォルトで実行されます。 新しいレプリカでのすべてのイベントの実行を停止するには、新しいレプリカで <code class="literal">event_scheduler</code> システム変数を <code class="literal">OFF</code> または <code class="literal">DISABLED</code> に設定します。 または、<code class="literal">ALTER EVENT</code> ステートメントを使用して個々のイベントを <code class="literal">DISABLE</code> または <code class="literal">DISABLE ON SLAVE</code> に設定し、新しいレプリカで実行されないようにすることもできます。 <code class="literal">SHOW</code> ステートメントまたは情報スキーマ <code class="literal">EVENTS</code> テーブルを使用して、サーバー上のイベントをリストできます。 詳細は、<a class="xref" href="replication.html#replication-features-invoked" title="17.5.1.16 呼び出される機能のレプリケーション">セクション17.5.1.16「呼び出される機能のレプリケーション」</a>を参照してください。 
        </p></div><p>
        この方法で新しいレプリカを作成するかわりに、MySQL Server クローンプラグインを使用して、既存のレプリカからクローンにすべてのデータおよびレプリケーション設定を転送できます。 この方法の使用手順は、<a class="xref" href="server-administration.html#clone-plugin-replication" title="5.6.7.6 レプリケーション用のクローニング">セクション5.6.7.6「レプリケーション用のクローニング」</a> を参照してください。 
      </p><p>
        クローニングせずに既存のレプリカを複製するには、次のステップに従います:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            既存のレプリカを停止し、レプリカステータス情報 (特にソースバイナリログファイルとリレーログファイルの位置) を記録します。 レプリカステータスは、パフォーマンススキーマレプリケーションテーブル (<a class="xref" href="performance-schema.html#performance-schema-replication-tables" title="27.12.11 パフォーマンススキーマレプリケーションテーブル">セクション27.12.11「パフォーマンススキーマレプリケーションテーブル」</a> を参照) で表示するか、次のように <code class="literal">SHOW REPLICA | SLAVE STATUS</code> を発行して表示できます: 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>STOP SLAVE;</code></strong>
mysql&gt; <strong class="userinput"><code>SHOW SLAVE STATUS\G</code></strong>
Or from MySQL 8.0.22:
mysql&gt; <strong class="userinput"><code>STOP REPLICA;</code></strong>
mysql&gt; <strong class="userinput"><code>SHOW REPLICA STATUS\G</code></strong>
</pre></li><li class="listitem"><p>
            既存のレプリカを停止します:
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqladmin shutdown</code></strong>
</pre></li><li class="listitem"><p>
            ログファイルやリレーログファイルなど、既存のレプリカから新しいレプリカにデータディレクトリをコピーします。 これを行うには、<span class="command"><strong>tar</strong></span> または <code class="literal">WinZip</code> を使用してアーカイブを作成するか、<span class="command"><strong>cp</strong></span>、<span class="command"><strong>rsync</strong></span> などのツールを使用して直接コピーを実行します。 
          </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                  コピーする前に、既存のレプリカに関連するすべてのファイルが実際にデータディレクトリに格納されていることを確認します。 たとえば、<code class="literal">InnoDB</code> のシステムテーブルスペース、undo テーブルスペースおよび redo ログを別の場所に格納できます。 <code class="literal">InnoDB</code> テーブルスペースファイルおよび file-per-table テーブルスペースが他のディレクトリに作成されている可能性があります。 レプリカのバイナリログおよびリレーログは、データディレクトリ外の独自のディレクトリに存在する場合があります。 既存のレプリカに設定されているシステム変数を確認し、指定されている代替パスを探します。 見つかった場合は、これらのディレクトリもコピーします。 
                </p></li><li class="listitem"><p>
                  コピー中に、レプリケーションメタデータリポジトリにファイルが使用されている場合 (<a class="xref" href="replication.html#replica-logs" title="17.2.4 リレーログおよびレプリケーションメタデータリポジトリ">セクション17.2.4「リレーログおよびレプリケーションメタデータリポジトリ」</a> を参照)、これらのファイルも既存のレプリカから新しいレプリカにコピーしてください。 リポジトリにテーブルが使用されている場合 (MySQL 8.0 のデフォルト)、テーブルはデータディレクトリにあります。 
                </p></li><li class="listitem"><p>
                  コピー後、新しいレプリカのデータディレクトリのコピーから <code class="filename">auto.cnf</code> ファイルを削除して、生成された別のサーバー UUID で新しいレプリカが開始されるようにします。 サーバー UUID は一意である必要があります。 
                </p></li></ul></div></div><p>
            新しいレプリカの追加時に発生する一般的な問題は、新しいレプリカが次のような一連の警告およびエラーメッセージで失敗することです:
          </p><pre class="programlisting">071118 16:44:10 [Warning] Neither --relay-log nor --relay-log-index were used; so
replication may break when this MySQL server acts as a replica and has his hostname
changed!! Please use '--relay-log=<em class="replaceable"><code>new_replica_hostname</code></em>-relay-bin' to avoid this problem.
<span class="errortext">071118 16:44:10 [ERROR] Failed to open the relay log './<em class="replaceable"><code>old_replica_hostname</code></em>-relay-bin.003525'
(relay_log_pos 22940879)</span>
071118 16:44:10 <span class="errortext">[ERROR] Could not find target log during relay log initialization</span>
071118 16:44:10 <span class="errortext">[ERROR] Failed to initialize the master info structure</span>
</pre><p>
            リレーログファイルにはファイル名の一部としてホスト名が含まれているため、この状況は <code class="literal">relay_log</code> システム変数が指定されていない場合に発生することがあります。 これは、<code class="literal">relay_log_index</code> システム変数が使用されない場合のリレーログインデックスファイルにも当てはまります。 これらの変数の詳細は、<a class="xref" href="replication.html#replication-options" title="17.1.6 レプリケーションおよびバイナリロギングのオプションと変数">セクション17.1.6「レプリケーションおよびバイナリロギングのオプションと変数」</a> を参照してください。 
          </p><p>
            この問題を回避するには、既存のレプリカで使用された新しいレプリカの <code class="literal">relay_log</code> に同じ値を使用します。 このオプションが既存のレプリカで明示的に設定されていない場合は、<code class="literal"><em class="replaceable"><code>existing_replica_hostname</code></em>-relay-bin</code> を使用します。 これが不可能な場合は、既存のレプリカリレーログインデックスファイルを新しいレプリカにコピーし、既存のレプリカで使用されたものと一致するように新しいレプリカの <code class="literal">relay_log_index</code> システム変数を設定します。 このオプションが既存のレプリカで明示的に設定されていない場合は、<code class="literal"><em class="replaceable"><code>existing_replica_hostname</code></em>-relay-bin.index</code> を使用します。 または、このセクションの残りのステップに従って新しいレプリカを起動しようとし、前述のようなエラーが発生した場合は、次のステップを実行します: 
          </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>
                まだ実行していない場合は、新しいレプリカで <code class="literal">STOP REPLICA | SLAVE</code> を発行します。
              </p><p>
                既存のレプリカをすでに再起動している場合は、既存のレプリカでも <code class="literal">STOP REPLICA | SLAVE</code> を発行します。
              </p></li><li class="listitem"><p>
                既存のレプリカリレーログインデックスファイルの内容を新しいレプリカリレーログインデックスファイルにコピーし、ファイル内にすでに存在する内容を上書きしてください。
              </p></li><li class="listitem"><p>
                このセクションの残りの手順に進みます。
              </p></li></ol></div></li><li class="listitem"><p>
            コピーが完了したら、既存のレプリカを再起動します。
          </p></li><li class="listitem"><p>
            新しいレプリカで構成を編集し、新しいレプリカに、ソースまたは既存のレプリカで使用されていない一意のサーバー ID (<code class="literal">server_id</code> システム変数を使用) を指定します。
          </p></li><li class="listitem"><p>
            レプリケーションがまだ開始されないように、<code class="option">--skip-slave-start</code> オプションを指定して新しいレプリカサーバーを起動します。 パフォーマンススキーマレプリケーションテーブルを使用するか、<code class="literal">SHOW REPLICA | SLAVE STATUS</code> を発行して、既存のレプリカと比較して新しいレプリカの設定が正しいことを確認します。 また、サーバー ID とサーバー UUID を表示し、これらが正しいことと、新しいレプリカに対して一意であることを確認します。 
          </p></li><li class="listitem"><p>
            <code class="literal">START REPLICA | SLAVE</code> ステートメントを発行してレプリカスレッドを起動します。 これで、新しいレプリカは接続メタデータリポジトリの情報を使用してレプリケーションプロセスを開始します。 
          </p></li></ol></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-gtids"></a>17.1.3 グローバルトランザクション識別子を使用したレプリケーション</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-gtids-concepts">17.1.3.1 GTID 形式および格納</a></span></dt><dt><span class="section"><a href="replication.html#replication-gtids-lifecycle">17.1.3.2 GTID ライフサイクル</a></span></dt><dt><span class="section"><a href="replication.html#replication-gtids-auto-positioning">17.1.3.3 GTID 自動配置</a></span></dt><dt><span class="section"><a href="replication.html#replication-gtids-howto">17.1.3.4 GTID を使用したレプリケーションのセットアップ</a></span></dt><dt><span class="section"><a href="replication.html#replication-gtids-failover">17.1.3.5 フェイルオーバーおよびスケールアウトでの GTID の使用</a></span></dt><dt><span class="section"><a href="replication.html#replication-gtids-assign-anon">17.1.3.6 GTID のないソースから GTID のあるレプリカへのレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-gtids-restrictions">17.1.3.7 GTID ベースレプリケーションの制約</a></span></dt><dt><span class="section"><a href="replication.html#replication-gtids-functions">17.1.3.8 GTID を操作するストアドファンクションの例</a></span></dt></dl></div><a class="indexterm" name="idm46723658775632"></a><p>
    このセクションでは、<span class="firstterm">グローバルトランザクション識別子</span> (GTID) を使用したトランザクションベースのレプリケーションについて説明します。 GTID を使用している場合、各トランザクションは元のサーバーでコミットされ、レプリカによって適用されるため、識別および追跡できます。つまり、GTID を使用して新しいレプリカの起動時または新しいソースへのフェイルオーバー時に、それらのファイル内のログファイルまたは位置を参照する場合は必要ありません。これにより、これらのタスクが大幅に簡略化されます。 GTID ベースのレプリケーションは完全にトランザクションベースであるため、ソースとレプリカに一貫性があるかどうかを簡単に判断できます。ソースでコミットされたすべてのトランザクションもレプリカでコミットされているかぎり、両者の間の一貫性が保証されます。 ステートメントベースまたは行ベースレプリケーションを GTID に基づいて使用できます (<a class="xref" href="replication.html#replication-formats" title="17.2.1 レプリケーション形式">セクション17.2.1「レプリケーション形式」</a>を参照してください)。ただし、最善の結果を得るには、行ベース形式を使用することをお勧めします。 
  </p><p>
    GTID は常にソースとレプリカの間で保持されます。 つまり、バイナリログを調べることによって、レプリカに適用されているトランザクションのソースをいつでも判別できます。 また、ある GTID のトランザクションがあるサーバーでコミットされると、同じ GTID のそれ以降のトランザクションはそのサーバーで無視されます。 したがって、ソースでコミットされたトランザクションはレプリカに複数回適用でき、一貫性の保証に役立ちます。 
  </p><p>
    このセクションでは、次のトピックについて説明します。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        GTID の定義方法と作成方法、および GTID が MySQL サーバーでどのように表されるか (<a class="xref" href="replication.html#replication-gtids-concepts" title="17.1.3.1 GTID 形式および格納">セクション17.1.3.1「GTID 形式および格納」</a> を参照)。
      </p></li><li class="listitem"><p>
        GTID のライフサイクル (<a class="xref" href="replication.html#replication-gtids-lifecycle" title="17.1.3.2 GTID ライフサイクル">セクション17.1.3.2「GTID ライフサイクル」</a> を参照)。
      </p></li><li class="listitem"><p>
        GTID を使用するレプリカとソースを同期するための自動配置機能 (<a class="xref" href="replication.html#replication-gtids-auto-positioning" title="17.1.3.3 GTID 自動配置">セクション17.1.3.3「GTID 自動配置」</a> を参照)。
      </p></li><li class="listitem"><p>
        GTID ベースレプリケーションをセットアップおよび起動するための一般的な手順 (<a class="xref" href="replication.html#replication-gtids-howto" title="17.1.3.4 GTID を使用したレプリケーションのセットアップ">セクション17.1.3.4「GTID を使用したレプリケーションのセットアップ」</a>を参照してください)。
      </p></li><li class="listitem"><p>
        GTID を使用するときに新しいレプリケーションサーバーをプロビジョニングするために推奨される方法 (<a class="xref" href="replication.html#replication-gtids-failover" title="17.1.3.5 フェイルオーバーおよびスケールアウトでの GTID の使用">セクション17.1.3.5「フェイルオーバーおよびスケールアウトでの GTID の使用」</a>を参照してください)。
      </p></li><li class="listitem"><p>
        GTID ベースレプリケーションを使用するときに留意すべき制約と制限 (<a class="xref" href="replication.html#replication-gtids-restrictions" title="17.1.3.7 GTID ベースレプリケーションの制約">セクション17.1.3.7「GTID ベースレプリケーションの制約」</a>を参照してください)。
      </p></li><li class="listitem"><p>
        GTID の操作に使用できるストアドファンクション (<a class="xref" href="replication.html#replication-gtids-functions" title="17.1.3.8 GTID を操作するストアドファンクションの例">セクション17.1.3.8「GTID を操作するストアドファンクションの例」</a> を参照)。
      </p></li></ul></div><p>
    GTID ベースレプリケーションに関係する MySQL Server オプションおよび変数については、<a class="xref" href="replication.html#replication-options-gtids" title="17.1.6.5 グローバルトランザクション ID システム変数">セクション17.1.6.5「グローバルトランザクション ID システム変数」</a>を参照してください。 GTID と一緒に使用するために MySQL 8.0 がサポートする SQL 関数については、<a class="xref" href="functions.html#gtid-functions" title="12.19 グローバルトランザクション識別子 (GTID) で使用される機能">セクション12.19「グローバルトランザクション識別子 (GTID) で使用される機能」</a>も参照してください。 
  </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-gtids-concepts"></a>17.1.3.1 GTID 形式および格納</h4></div></div></div><a class="indexterm" name="idm46723658752336"></a><p>
      グローバルトランザクション識別子 (GTID) は、発生元のサーバー (ソース) でコミットされた各トランザクションに作成および関連付けられる一意の識別子です。 この識別子は、それが発生したサーバーに対して一意であるだけでなく、特定のレプリケーショントポロジ内のすべてのサーバーで一意です。 
    </p><p>
      GTID 割当では、ソースでコミットされるクライアントトランザクションと、レプリカで再現されるレプリケートトランザクションが区別されます。 クライアントトランザクションがソースでコミットされると、そのトランザクションがバイナリログに書き込まれた場合、新しい GTID が割り当てられます。 クライアントトランザクションでは、生成された番号間のギャップなしで GTID が単調に増加することが保証されます。 クライアントトランザクションがバイナリログに書き込まれない場合 (たとえば、トランザクションがフィルタで除外されたか、またはトランザクションが読み取り専用だったため)、そのトランザクションには起点のサーバー上の GTID は割り当てられません。 
    </p><p>
      レプリケートされたトランザクションは、オリジンのサーバー上のトランザクションに割り当てられた GTID と同じ GTID を保持します。 GTID は、レプリケートされたトランザクションの実行が開始される前に存在し、レプリケートされたトランザクションがレプリカのバイナリログに書き込まれていない場合や、レプリカでフィルタで除外されている場合でも保持されます。 MySQL システムテーブル <code class="literal">mysql.gtid_executed</code> は、現在アクティブなバイナリログファイルに格納されているトランザクションを除き、MySQL サーバーに適用されたすべてのトランザクションの割り当てられた GTID を保持するために使用されます。 
    </p><p>
      GTID の自動スキップ機能は、ソースでコミットされたトランザクションをレプリカに複数回適用でき、一貫性の保証に役立ちます。 指定された GTID を持つトランザクションが指定されたサーバーでコミットされると、同じ GTID を持つ後続のトランザクションを実行しようとする試みはそのサーバーによって無視されます。 エラーは発生せず、トランザクション内のステートメントは実行されません。 
    </p><p>
      指定された GTID を持つトランザクションがサーバー上で実行を開始したが、まだコミットまたはロールバックされていない場合、同じ GTID ブロックを持つサーバー上で同時トランザクションを開始しようとする試みはすべて行われます。 サーバーは、同時トランザクションの実行を開始せず、クライアントに制御を返しません。 トランザクションでの最初の試行がコミットまたはロールバックされると、同じ GTID でブロックしていた同時セッションが続行される可能性があります。 最初の試行がロールバックされた場合、1 つのコンカレントセッションがトランザクションの試行を続行し、同じ GTID でブロックしていた他のコンカレントセッションはブロックされたままになります。 最初の試行がコミットされると、すべての同時セッションがブロックされなくなり、トランザクションのすべてのステートメントが自動スキップされます。 
    </p><p>
      GTID は座標のペアとして表現され、次に示すように、コロン文字 (<code class="literal">:</code>) で区切られます。
    </p><pre class="programlisting">GTID = <em class="replaceable"><code>source_id</code></em>:<em class="replaceable"><code>transaction_id</code></em>
</pre><p>
      <em class="replaceable"><code>source_id</code></em> は発生元サーバーを識別します。 通常、この目的にはソース <code class="literal">server_uuid</code> が使用されます。 <em class="replaceable"><code>transaction_id</code></em> は、ソースでトランザクションがコミットされた順序によって決定される順序番号です。 たとえば、コミットされる最初のトランザクションには <em class="replaceable"><code>transaction_id</code></em> として <code class="literal">1</code> があり、同じオリジンサーバーでコミットされる 10 番目のトランザクションには <code class="literal">10</code> の <em class="replaceable"><code>transaction_id</code></em> が割り当てられます。 トランザクションに、GTID のシーケンス番号として <code class="literal">0</code> を割り当てることはできません。 たとえば、UUID が <code class="literal">3E11FA47-71CA-11E1-9E33-C80AA9429562</code> の発生元サーバーでコミットされた 23 番目のトランザクションの GTID は次のとおりです。 
    </p><pre class="programlisting">3E11FA47-71CA-11E1-9E33-C80AA9429562:23
</pre><p>
      サーバーインスタンス上の GTID の順序番号の上限は、符号付き 64 ビット整数 (2 から 63-1 の累乗、つまり 9,223,372,036,854,775,807) の負でない値の数です。 GTID が不足すると、サーバーは <code class="literal">binlog_error_action</code> によって指定されたアクションを実行します。 MySQL 8.0.23 からは、サーバーインスタンスが制限に近づいたときに警告メッセージが発行されます。 
    </p><p>
      トランザクションの GTID は、<span class="command"><strong>mysqlbinlog</strong></span> からの出力に表示され、<code class="literal">replication_applier_status_by_worker</code> などのパフォーマンススキーマレプリケーションステータステーブル内の個々のトランザクションを識別するために使用されます。 <code class="literal">gtid_next</code> システム変数 (<code class="literal">@@GLOBAL.gtid_next</code>) によって格納される値は単一 GTID です。 
    </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-gtids-concepts-gtid-sets"></a>GTID セット</h5></div></div></div><a class="indexterm" name="idm46723658722544"></a><p>
        GTID セットは、1 つ以上の GTID または GTID の範囲で構成されるセットです。 GTID セットは、いくつかの方法で MySQL サーバーで使用されます。 たとえば、<code class="literal">gtid_executed</code> および <code class="literal">gtid_purged</code> システム変数によって格納される値は GTID セットです。 <code class="literal">START REPLICA | SLAVE</code> 句 <code class="literal">UNTIL SQL_BEFORE_GTIDS</code> および <code class="literal">UNTIL SQL_AFTER_GTIDS</code> を使用すると、GTID セット内の最初の GTID までのレプリカプロセストランザクションのみを作成したり、GTID セット内の最後の GTID の後に停止したりできます。 <code class="literal">GTID_SUBSET()</code> および <code class="literal">GTID_SUBTRACT()</code> の組み込み関数には、GTID セットが入力として必要です。 
      </p><p>
        次に示すように、同じサーバーから発生した GTID の範囲を単一の式に縮小できます:
      </p><pre class="programlisting">3E11FA47-71CA-11E1-9E33-C80AA9429562:1-5
</pre><p>
        前述の例は、<code class="literal">server_uuid</code> が <code class="literal">3E11FA47-71CA-11E1-9E33-C80AA9429562</code> である MySQL サーバーで発生した最初から 5 番目のトランザクションを表しています。 次の例のように、GTID または範囲をコロンで区切って、同じサーバーから発生した GTID の複数の単一 GTID または範囲を単一の式に含めることもできます: 
      </p><pre class="programlisting">3E11FA47-71CA-11E1-9E33-C80AA9429562:1-3:11:47-49
</pre><p>
        GTID セットには、単一 GTID と GTID の範囲の任意の組合せを含めることができ、異なるサーバーから発生した GTID を含めることができます。 この例は、複数のソースからトランザクションを適用したレプリカの <code class="literal">gtid_executed</code> システム変数 (<code class="literal">@@GLOBAL.gtid_executed</code>) に格納されている GTID セットを示しています: 
      </p><pre class="programlisting">2174B383-5441-11E8-B90A-C80AA9429562:1-3, 24DA167-0C0C-11E8-8442-00059A3C7B00:1-19
</pre><p>
        GTID セットがサーバー変数から返されると、UUID はアルファベット順になり、数値間隔がマージされて昇順になります。
      </p><p>
        GTID セットの構文は次のとおりです:
      </p><pre class="programlisting"><em class="replaceable"><code>gtid_set</code></em>:
    <em class="replaceable"><code>uuid_set</code></em> [, <em class="replaceable"><code>uuid_set</code></em>] ...
    | ''

<em class="replaceable"><code>uuid_set</code></em>:
    <em class="replaceable"><code>uuid</code></em>:<em class="replaceable"><code>interval</code></em>[:<em class="replaceable"><code>interval</code></em>]...

<em class="replaceable"><code>uuid</code></em>:
    <em class="replaceable"><code>hhhhhhhh</code></em>-<em class="replaceable"><code>hhhh</code></em>-<em class="replaceable"><code>hhhh</code></em>-<em class="replaceable"><code>hhhh</code></em>-<em class="replaceable"><code>hhhhhhhhhhhh</code></em>

<em class="replaceable"><code>h</code></em>:
    [0-9|A-F]

<em class="replaceable"><code>interval</code></em>:
    <em class="replaceable"><code>n</code></em>[-<em class="replaceable"><code>n</code></em>]

    (<em class="replaceable"><code>n</code></em> &gt;= 1)
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-gtids-gtid-executed-table"></a>mysql.gtid_executed テーブル</h5></div></div></div><a class="indexterm" name="idm46723658692208"></a><a class="indexterm" name="idm46723658690736"></a><a class="indexterm" name="idm46723658688624"></a><a class="indexterm" name="idm46723658686512"></a><a class="indexterm" name="idm46723658684848"></a><p>
        GTID は、<code class="literal">mysql</code> データベースの <code class="literal">gtid_executed</code> という名前のテーブルに格納されます。 このテーブルの行には、GTID または GTID が表す GTID のセットごとに、元のサーバーの UUID、およびセットの開始トランザクション ID と終了トランザクション ID が含まれます。単一 GTID のみを参照する行の場合、これらの最後の 2 つの値は同じです。 
      </p><p>
        <code class="literal">mysql.gtid_executed</code> テーブルは、MySQL Server のインストールまたはアップグレード時に、次に示すような <code class="literal">CREATE TABLE</code> ステートメントを使用して作成されます (まだ存在しない場合):
      </p><pre class="programlisting">CREATE TABLE gtid_executed (
    source_uuid CHAR(36) NOT NULL,
    interval_start BIGINT(20) NOT NULL,
    interval_end BIGINT(20) NOT NULL,
    PRIMARY KEY (source_uuid, interval_start)
)
</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          他の MySQL システムテーブルと同様に、このテーブルを自分で作成または変更しないでください。
        </p></div><a class="indexterm" name="idm46723658674736"></a><p>
        <code class="literal">mysql.gtid_executed</code> テーブルは、MySQL サーバーによる内部使用のために提供されています。 これにより、レプリカでバイナリロギングが無効になっているときにレプリカが GTID を使用できるようになり、バイナリログが失われたときに GTID 状態の保持が有効になります。 <code class="literal">RESET MASTER</code> を発行すると、<code class="literal">mysql.gtid_executed</code> テーブルがクリアされることに注意してください。 
      </p><p>
        GTID は、<code class="literal">gtid_mode</code> が <code class="literal">ON</code> または <code class="literal">ON_PERMISSIVE</code> の場合にのみ <code class="literal">mysql.gtid_executed</code> テーブルに格納されます。 バイナリロギングが無効になっている (<code class="literal">log_bin</code> が <code class="literal">OFF</code>)、または <code class="literal">log_slave_updates</code> が無効になっている場合、サーバーは、トランザクションのコミット時に、各トランザクションに属する GTID を <code class="literal">mysql.gtid_executed</code> テーブルにトランザクションとともに格納します。 また、<a class="xref" href="replication.html#replication-gtids-gtid-executed-table-compression" title="mysql.gtid_executed テーブル圧縮">mysql.gtid_executed テーブル圧縮</a> で説明されているように、テーブルはユーザーが構成可能なレートで定期的に圧縮されます。 
      </p><p>
        バイナリロギングが有効になっている (<code class="literal">log_bin</code> が <code class="literal">ON</code>)、<code class="literal">InnoDB</code> ストレージエンジンの MySQL 8.0.17 からのみ、サーバーはバイナリロギングまたはレプリカ更新ロギングが無効になっている場合と同じ方法で <code class="literal">mysql.gtid_executed</code> テーブルを更新し、トランザクションのコミット時にトランザクションごとに GTID を格納します。 ただし、MySQL 8.0.17 より前のリリースやその他のストレージエンジンでは、バイナリログがローテーションされるか、サーバーがシャットダウンされたときにのみ、サーバーは <code class="literal">mysql.gtid_executed</code> テーブルを更新します。 この時点で、サーバーは、前のバイナリログに書き込まれたすべてのトランザクションの GTID を <code class="literal">mysql.gtid_executed</code> テーブルに書き込みます。 この状況は、MySQL 8.0.17 より前のソース、バイナリロギングが有効になっている MySQL 8.0.17 より前のレプリカ、または <code class="literal">InnoDB</code> 以外のストレージエンジンでは、次のような結果になります: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            サーバーが予期せず停止した場合、現在のバイナリログファイルから GTID のセットは <code class="literal">mysql.gtid_executed</code> テーブルに保存されません。 これらの GTID は、レプリケーションを続行できるように、回復中にバイナリログファイルからテーブルに追加されます。 ただし、(<code class="option">--skip-log-bin</code> または <code class="option">--disable-log-bin</code> を使用して) サーバーの再起動時にバイナリロギングを無効にした場合は例外です。 その場合、サーバーはバイナリログファイルにアクセスして GTID を回復できないため、レプリケーションを開始できません。 
          </p></li><li class="listitem"><p>
            <code class="literal">mysql.gtid_executed</code> テーブルには、実行されたすべてのトランザクションの GTID の完全なレコードは保持されません。 この情報は、<code class="literal">gtid_executed</code> システム変数のグローバル値によって提供されます。 MySQL 8.0.17 より前のリリースおよび <code class="literal">InnoDB</code> 以外のストレージエンジンでは、<code class="literal">mysql.gtid_executed</code> テーブルをクエリーする代わりに、コミットのたびに更新される<code class="literal">@@GLOBAL.gtid_executed</code> を使用して、MySQL サーバーの GTID 状態を表します。 
          </p></li></ul></div><p>
        MySQL サーバーは、サーバーが読取り専用モードまたはスーパー読取り専用モードの場合でも、<code class="literal">mysql.gtid_executed</code> テーブルに書き込むことができます。 MySQL 8.0.17 より前のリリースでは、これらのモードでバイナリログファイルをローテーションできます。 書き込みのために <code class="literal">mysql.gtid_executed</code> テーブルにアクセスできず、バイナリログファイルが最大ファイルサイズ (<code class="literal">max_binlog_size</code>) に達しない理由でローテーションされた場合、現在のバイナリログファイルが引き続き使用されます。 ローテーションをリクエストしたクライアントにエラーメッセージが返され、サーバーに警告が記録されます。 書込みのために <code class="literal">mysql.gtid_executed</code> テーブルにアクセスできず、<code class="literal">max_binlog_size</code> に到達した場合、サーバーは <code class="literal">binlog_error_action</code> 設定に従って応答します。 <code class="literal">IGNORE_ERROR</code> が設定されている場合、サーバーにエラーが記録され、バイナリロギングが停止されます。または、<code class="literal">ABORT_SERVER</code> が設定されている場合、サーバーはシャットダウンします。 

      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-gtids-gtid-executed-table-compression"></a>mysql.gtid_executed テーブル圧縮</h5></div></div></div><a class="indexterm" name="idm46723658633088"></a><a class="indexterm" name="idm46723658630992"></a><a class="indexterm" name="idm46723658629872"></a><a class="indexterm" name="idm46723658627744"></a><p>
        この間、<code class="literal">mysql.gtid_executed</code> テーブルには、同じサーバー上で発生し、次に示すような範囲を構成するトランザクション ID を持つ個々の GTID を参照する多数の行を入力できます:
      </p><pre class="programlisting">+--------------------------------------+----------------+--------------+
| source_uuid                          | interval_start | interval_end |
|--------------------------------------+----------------+--------------|
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 37             | 37           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 38             | 38           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 39             | 39           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 40             | 40           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 41             | 41           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 42             | 42           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 43             | 43           |
...
</pre><p>
        領域を節約するために、MySQL サーバーでは、<code class="literal">mysql.gtid_executed</code> テーブルを定期的に圧縮できます。このような行の各セットを、次のようなトランザクション識別子の間隔全体にわたる単一行に置き換えます:
      </p><pre class="programlisting">+--------------------------------------+----------------+--------------+
| source_uuid                          | interval_start | interval_end |
|--------------------------------------+----------------+--------------|
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 37             | 43           |
...
</pre><p>
        サーバーは、<code class="literal">thread/sql/compress_gtid_table</code> という専用のフォアグラウンドスレッドを使用して圧縮を実行できます。 このスレッドは <code class="literal">SHOW PROCESSLIST</code> の出力にはリストされませんが、次に示すように、<code class="literal">threads</code> テーブルの行として表示できます: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.threads WHERE NAME LIKE '%gtid%'\G</code></strong>
*************************** 1. row ***************************
          THREAD_ID: 26
               NAME: thread/sql/compress_gtid_table
               TYPE: FOREGROUND
     PROCESSLIST_ID: 1
   PROCESSLIST_USER: NULL
   PROCESSLIST_HOST: NULL
     PROCESSLIST_DB: NULL
PROCESSLIST_COMMAND: Daemon
   PROCESSLIST_TIME: 1509
  PROCESSLIST_STATE: Suspending
   PROCESSLIST_INFO: NULL
   PARENT_THREAD_ID: 1
               ROLE: NULL
       INSTRUMENTED: YES
            HISTORY: YES
    CONNECTION_TYPE: NULL
       THREAD_OS_ID: 18677
</pre><p>
        サーバーでバイナリロギングが有効になっている場合、この圧縮方法は使用されず、代わりに <code class="literal">mysql.gtid_executed</code> テーブルはバイナリログのローテーションごとに圧縮されます。 ただし、バイナリロギングがサーバーで無効になっている場合、<code class="literal">thread/sql/compress_gtid_table</code> スレッドは指定された数のトランザクションが実行されるまでスリープしてから、<code class="literal">mysql.gtid_executed</code> テーブルの圧縮を実行するためにウェイクアップします。 その後、同じ数のトランザクションが発生するまでスリープしてから、圧縮を再度実行するためにウェイクアップし、このループを無期限に繰り返します。 テーブルが圧縮される前に経過したトランザクションの数、つまり圧縮率は、<code class="literal">gtid_executed_compression_period</code> システム変数の値によって制御されます。 この値を 0 に設定すると、スレッドはウェイクアップしません。つまり、この明示的な圧縮方法は使用されません。 かわりに、圧縮は必要に応じて暗黙的に行われます。 
      </p><p>
        MySQL 8.0.17 から、<code class="literal">InnoDB</code> トランザクションは <code class="literal">InnoDB</code> 以外のトランザクションに対する個別のプロセスによって <code class="literal">mysql.gtid_executed</code> テーブルに書き込まれます。 このプロセスは、別のスレッドである <code class="literal">innodb/clone_gtid_thread</code> によって制御されます。 この GTID 永続スレッドは GTID をグループ単位で収集し、<code class="literal">mysql.gtid_executed</code> テーブルにフラッシュしてから、テーブルを圧縮します。 サーバーに、<code class="literal">mysql.gtid_executed</code> テーブルに個別に書き込まれる <code class="literal">InnoDB</code> トランザクションと <code class="literal">InnoDB</code> 以外のトランザクションが混在している場合、<code class="literal">compress_gtid_table</code> スレッドによって実行される圧縮は GTID 永続スレッドの作業を妨げ、大幅に遅くなる可能性があります。 このため、このリリースからは、<code class="literal">compress_gtid_table</code> スレッドがアクティブ化されないように、<code class="literal">gtid_executed_compression_period</code> を 0 に設定することをお薦めします。 
      </p><p>
        MySQL 8.0.23 からは、<code class="literal">gtid_executed_compression_period</code> のデフォルト値は 0 で、<code class="literal">InnoDB</code> トランザクションと <code class="literal">InnoDB</code> 以外のトランザクションの両方が GTID 永続性スレッドによって <code class="literal">mysql.gtid_executed</code> テーブルに書き込まれます。
      </p><p>
        MySQL 8.0.17 より前のリリースでは、<code class="literal">gtid_executed_compression_period</code> のデフォルト値 1000 を使用できます。つまり、1000 トランザクションごとにテーブルの圧縮が実行されるか、別の値を選択できます。 これらのリリースでは、値 0 を設定し、バイナリロギングが無効になっている場合、<code class="literal">mysql.gtid_executed</code> テーブルで明示的な圧縮は実行されないため、これを行うと、テーブルで必要になる可能性のあるディスク容量が大幅に増加する可能性がある準備をするようにしてください。 
      </p><p>
        サーバーインスタンスの起動時に、<code class="literal">gtid_executed_compression_period</code> がゼロ以外の値に設定され、<code class="literal">thread/sql/compress_gtid_table</code> スレッドが起動された場合、ほとんどのサーバー構成では、<code class="literal">mysql.gtid_executed</code> テーブルに対して明示的な圧縮が実行されます。 MySQL 8.0.17 より前のリリースでは、バイナリロギングが有効になっている場合、圧縮は起動時にローテーションされるバイナリログによってトリガーされます。 MySQL 8.0.20 からのリリースでは、圧縮はスレッドの起動によってトリガーされます。 介在するリリースでは、圧縮は起動時に行われません。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-gtids-lifecycle"></a>17.1.3.2 GTID ライフサイクル</h4></div></div></div><a class="indexterm" name="idm46723658585360"></a><p>
      GTID のライフサイクルは、次のステップで構成されます:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          トランザクションが実行され、ソースでコミットされます。 このクライアントトランザクションには、ソース UUID と、このサーバーでまだ使用されていないゼロ以外の最小のトランザクションシーケンス番号で構成される GTID が割り当てられます。 GTID はソースバイナリログ (ログ内のトランザクション自体の直前) に書き込まれます。 クライアントトランザクションがバイナリログに書き込まれない場合 (たとえば、トランザクションがフィルタで除外されたか、トランザクションが読み取り専用だったため)、GTID は割り当てられません。 
        </p></li><li class="listitem"><p>
          GTID がトランザクションに割り当てられている場合、GTID はトランザクションの開始時にバイナリログに (<code class="literal">Gtid_log_event</code> として) 書き込むことによって、コミット時に原子的に永続化されます。 バイナリログがローテーションされるか、サーバーがシャットダウンされるたびに、サーバーは以前のバイナリログファイルに書き込まれたすべてのトランザクションの GTID を <code class="literal">mysql.gtid_executed</code> テーブルに書き込みます。 
        </p></li><li class="listitem"><p>
          GTID がトランザクションに割り当てられている場合、GTID は <code class="literal">gtid_executed</code> システム変数 (<code class="literal">@@GLOBAL.gtid_executed</code>) の GTID のセットに追加することで、非原子的に (トランザクションのコミット直後に) 外部化されます。 この GTID セットには、コミットされたすべての GTID トランザクションのセットの表現が含まれ、サーバーの状態を表すトークンとしてレプリケーションで使用されます。 バイナリロギングが有効になっている (ソースに必要な) 場合、<code class="literal">gtid_executed</code> システム変数内の GTID のセットは適用されるトランザクションの完全なレコードですが、最新の履歴がまだ現在のバイナリログファイル内にあるため、<code class="literal">mysql.gtid_executed</code> テーブルは適用されません。 
        </p></li><li class="listitem"><p>
          バイナリログデータがレプリカに転送され、レプリカリレーログに格納されたあと (このプロセスで確立されたメカニズムを使用して、<a class="xref" href="replication.html#replication-implementation" title="17.2 レプリケーションの実装">セクション17.2「レプリケーションの実装」</a> を参照)、レプリカは GTID を読み取り、その <code class="literal">gtid_next</code> システム変数の値を GTID として設定します。 これは、この GTID を使用して次のトランザクションをログに記録する必要があることをレプリカに通知します。 レプリカはセッションコンテキストで <code class="literal">gtid_next</code> を設定することに注意してください。 
        </p></li><li class="listitem"><p>
          レプリカは、トランザクションを処理するために、<code class="literal">gtid_next</code> で GTID の所有権を取得しているスレッドがないことを検証します。 レプリケートされたトランザクション GTID を最初に読み取ってチェックすることで、トランザクション自体を処理する前に、レプリカは、この GTID を持つ以前のトランザクションがレプリカに適用されていないことだけでなく、この GTID をまだ読み取っていないが、関連付けられたトランザクションをまだコミットしていないことも保証します。 そのため、複数のクライアントが同時に同じトランザクションを適用しようとすると、サーバーはいずれか一方のクライアントのみを実行できるようにしてこれを解決します。 レプリカの <code class="literal">gtid_owned</code> システム変数 (<code class="literal">@@GLOBAL.gtid_owned</code>) には、現在使用中の各 GTID とそれを所有するスレッドの ID が表示されます。 GTID がすでに使用されている場合、エラーは発生せず、自動スキップ機能を使用してトランザクションが無視されます。 
        </p></li><li class="listitem"><p>
          GTID が使用されていない場合、レプリカはレプリケートされたトランザクションを適用します。 <code class="literal">gtid_next</code> はソースによってすでに割り当てられている GTID に設定されているため、レプリカはこのトランザクションに対して新しい GTID を生成しようとせず、かわりに <code class="literal">gtid_next</code> に格納されている GTID を使用します。 
        </p></li><li class="listitem"><p>
          バイナリロギングがレプリカで有効になっている場合、GTID はトランザクションの開始時にバイナリログに (<code class="literal">Gtid_log_event</code> として) 書き込むことによって、コミット時に原子的に永続化されます。 バイナリログがローテーションされるか、サーバーがシャットダウンされるたびに、サーバーは以前のバイナリログファイルに書き込まれたすべてのトランザクションの GTID を <code class="literal">mysql.gtid_executed</code> テーブルに書き込みます。 
        </p></li><li class="listitem"><p>
          バイナリロギングがレプリカで無効になっている場合、GTID は <code class="literal">mysql.gtid_executed</code> テーブルに直接書き込むことによって原子的に永続化されます。 MySQL は、GTID をテーブルに挿入するステートメントをトランザクションに追加します。 MySQL 8.0 からは、この操作は DDL ステートメントおよび DML ステートメントに対してアトミックです。 この状況では、<code class="literal">mysql.gtid_executed</code> テーブルはレプリカに適用されるトランザクションの完全なレコードです。 
        </p></li><li class="listitem"><p>
          レプリケートされたトランザクションがレプリカでコミットされるとすぐに、GTID はレプリカの <code class="literal">gtid_executed</code> システム変数 (<code class="literal">@@GLOBAL.gtid_executed</code>) 内の GTID のセットに追加され、非原子的に外部化されます。 ソースに関して、この GTID セットには、コミットされた GTID トランザクションのセットの表現が含まれます。 レプリカでバイナリロギングが無効になっている場合、<code class="literal">mysql.gtid_executed</code> テーブルはレプリカに適用されたトランザクションの完全なレコードでもあります。 バイナリロギングがレプリカで有効になっている場合、つまり一部の GTID がバイナリログにのみ記録される場合、<code class="literal">gtid_executed</code> システム変数内の GTID のセットのみが完全なレコードになります。 
        </p></li></ol></div><p>
      ソースで完全にフィルタで除外されたクライアントトランザクションに GTID が割り当てられていないため、<code class="literal">gtid_executed</code> システム変数のトランザクションセットに追加されたり、<code class="literal">mysql.gtid_executed</code> テーブルに追加されることはありません。 ただし、レプリカで完全にフィルタで除外されたレプリケートされたトランザクションの GTID は永続化されます。 バイナリロギングがレプリカで有効になっている場合、フィルタリングされたトランザクションは <code class="literal">Gtid_log_event</code> としてバイナリログに書き込まれ、その後に <code class="literal">BEGIN</code> および <code class="literal">COMMIT</code> ステートメントのみを含む空のトランザクションが続きます。 バイナリロギングが無効になっている場合は、フィルタ処理されたトランザクションの GTID が <code class="literal">mysql.gtid_executed</code> テーブルに書き込まれます。 フィルタ処理されたトランザクションの GTID を保持することで、<code class="literal">mysql.gtid_executed</code> テーブルおよび GTID のセットを <code class="literal">gtid_executed</code> システム変数に確実に圧縮できます。 また、<a class="xref" href="replication.html#replication-gtids-auto-positioning" title="17.1.3.3 GTID 自動配置">セクション17.1.3.3「GTID 自動配置」</a> で説明されているように、レプリカがソースに再接続した場合、フィルタで除外されたトランザクションが再度取得されないようにします。 
    </p><p>
      マルチスレッドレプリカ (<code class="literal">slave_parallel_workers &gt; 0</code> を使用) では、トランザクションをパラレルに適用できるため、レプリケートされたトランザクションは順序どおりにコミットできません (<code class="literal">slave_preserve_commit_order=1</code> が設定されていない場合)。 その場合、<code class="literal">gtid_executed</code> システム変数内の GTID のセットには、GTID 間にギャップがある複数の GTID 範囲が含まれます。 (ソースまたはシングルスレッドレプリカでは、数値間のギャップなしで GTID が単調に増加します。) マルチスレッドのレプリカのギャップは、最後に適用されたトランザクション間でのみ発生し、レプリケーションの進行に応じて埋められます。 <code class="literal">STOP REPLICA | SLAVE</code> ステートメントを使用してレプリケーションスレッドが正常に停止されると、ギャップが埋められるように進行中のトランザクションが適用されます。 サーバー障害や <code class="literal">KILL</code> ステートメントを使用してレプリケーションスレッドを停止した場合、ギャップが残ることがあります。 
    </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-gtids-assign"></a>GTID にはどのような変更が割り当てられますか。</h5></div></div></div><p>
        一般的なシナリオは、サーバーがコミットされたトランザクションに対して新しい GTID を生成することです。 ただし、GTID はトランザクション以外の他の変更にも割り当てることができ、場合によっては単一のトランザクションに複数の GTID を割り当てることができます。 
      </p><p>
        バイナリログに書き込まれるすべてのデータベース変更 (DDL または DML) に GTID が割り当てられます。 これには、自動コミットされる変更と、<code class="literal">BEGIN</code> および <code class="literal">COMMIT</code> または <code class="literal">START TRANSACTION</code> ステートメントを使用してコミットされる変更が含まれます。 GTID は、データベースの作成、変更または削除、およびプロシージャ、ファンクション、トリガー、イベント、ビュー、ユーザー、ロールまたは付与などのテーブル以外のデータベースオブジェクトにも割り当てられます。 
      </p><p>
        非トランザクション更新およびトランザクション更新に GTID が割り当てられます。 また、非トランザクション更新では、バイナリログキャッシュへの書き込み中にディスク書き込み障害が発生し、そのためバイナリログにギャップが作成された場合、生成されるインシデントログイベントに GTID が割り当てられます。 
      </p><p>
        バイナリログ内の生成されたステートメントによってテーブルが自動的に削除されると、GTID がステートメントに割り当てられます。 レプリカが開始したばかりのソースからイベントの適用を開始し、ステートメントベースレプリケーションが使用中 (<code class="literal">binlog_format=STATEMENT</code>) で、開いている一時テーブルを持つユーザーセッションが切断されると、一時テーブルは自動的に削除されます。 <code class="literal">MEMORY</code> ストレージエンジンを使用するテーブルは、サーバーの起動後にはじめてアクセスされたときに自動的に削除されます。これは、シャットダウン中に行が失われた可能性があるためです。 
      </p><p>
        トランザクションが起点のサーバー上のバイナリログに書き込まれない場合、サーバーは GTID を割り当てません。 これには、ロールバックされたトランザクションと、バイナリロギング中に実行されたトランザクションがオリジンのサーバーでグローバルに (サーバー構成で <code class="literal">--skip-log-bin</code> が指定された状態で) またはセッションに対して (<code class="literal">SET @@SESSION.sql_log_bin = 0</code>) 無効化された状態で含まれます。 これには、行ベースレプリケーションが使用されている場合の no-op トランザクションも含まれます (<code class="literal">binlog_format=ROW</code>)。 
      </p><p>
        XA トランザクションには、トランザクションの <code class="literal">XA PREPARE</code> フェーズおよびトランザクションの <code class="literal">XA COMMIT</code> または <code class="literal">XA ROLLBACK</code> フェーズ用に個別の GTID が割り当てられます。 XA トランザクションは、障害発生時にユーザーがコミットまたはロールバックできるように永続的に準備されます (レプリケーショントポロジでは、別のサーバーへのフェイルオーバーが含まれる場合があります)。 したがって、トランザクションの 2 つの部分は個別にレプリケートされるため、ロールバックされる非 XA トランザクションに GTID がなくても、独自の GTID が必要です。 
      </p><p>
        次の特殊なケースでは、単一のステートメントで複数のトランザクションを生成できるため、複数の GTID を割り当てることができます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            複数のトランザクションをコミットするストアドプロシージャが起動されます。 プロシージャがコミットするトランザクションごとに GTID が 1 つ生成されます。 
          </p></li><li class="listitem"><p>
            複数テーブルの <code class="literal">DROP TABLE</code> ステートメントは、異なるタイプのテーブルを削除します。 いずれかのテーブルがアトミック DDL をサポートしていないストレージエンジンを使用している場合、またはいずれかのテーブルが一時テーブルである場合は、複数の GTID を生成できます。 
          </p></li><li class="listitem"><p>
            <code class="literal">CREATE TABLE ... SELECT</code> ステートメントは、行ベースのレプリケーションが使用中 (<code class="literal">binlog_format=ROW</code>) の場合に発行されます。 <code class="literal">CREATE TABLE</code> 処理に対して GTID が生成され、行挿入処理に対して GTID が生成されます。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-gtids-gtid-next"></a><code class="literal">gtid_next</code> システム変数</h5></div></div></div><p>
        デフォルトでは、ユーザーセッションでコミットされた新しいトランザクションの場合、サーバーは自動的に新しい GTID を生成して割り当てます。 トランザクションがレプリカに適用されると、オリジンのサーバーからの GTID が保持されます。 この動作は、<code class="literal">gtid_next</code> システム変数のセッション値を設定することで変更できます: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">gtid_next</code> が <code class="literal">AUTOMATIC</code>(デフォルト) に設定され、トランザクションがコミットされてバイナリログに書き込まれると、サーバーは自動的に新しい GTID を生成して割り当てます。 トランザクションが別の理由でロールバックされるか、バイナリログに書き込まれない場合、サーバーは GTID を生成して割り当てません。 
          </p></li><li class="listitem"><p>
            <code class="literal">gtid_next</code> を有効な GTID (コロンで区切られた UUID とトランザクション順序番号で構成) に設定すると、サーバーはその GTID をトランザクションに割り当てます。 この GTID は、トランザクションがバイナリログに書き込まれない場合や、トランザクションが空の場合でも、<code class="literal">gtid_executed</code> に割り当てられて追加されます。 
          </p></li></ul></div><p>
        <code class="literal">gtid_next</code> を特定の GTID に設定し、トランザクションがコミットまたはロールバックされた後、明示的な <code class="literal">SET @@SESSION.gtid_next</code> ステートメントを他のステートメントの前に発行する必要があります。 GTID を明示的に割り当てない場合は、GTID 値を <code class="literal">AUTOMATIC</code> に戻すためにこれを使用できます。 
      </p><p>
        レプリケーションアプライヤスレッドがレプリケートされたトランザクションを適用する場合、この手法を使用して、<code class="literal">@@SESSION.gtid_next</code> をオリジンサーバーに割り当てられているレプリケートされたトランザクションの GTID に明示的に設定します。 これは、レプリカによって生成および割り当てられる新しい GTID ではなく、起点のサーバーからの GTID が保持されることを意味します。 また、バイナリロギングまたはレプリカ更新ロギングがレプリカで無効になっている場合、またはトランザクションが no-op であるかレプリカでフィルタで除外されている場合でも、GTID がレプリカ上の <code class="literal">gtid_executed</code> に追加されることを意味します。 
      </p><p>
        クライアントは、トランザクションを実行する前に<code class="literal">@@SESSION.gtid_next</code> を特定の GTID に設定することで、レプリケートされたトランザクションをシミュレートできます。 この手法は、GTID を保持するためにクライアントがリプレイできるバイナリログのダンプを生成するために、<span class="command"><strong>mysqlbinlog</strong></span> によって使用されます。 クライアントを介してコミットされたシミュレートされたレプリケートされたトランザクションは、レプリケーションアプライヤスレッドを介してコミットされたレプリケートされたトランザクションと完全に同等であり、実際には区別できません。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-gtids-gtid-purged"></a><code class="literal">gtid_purged</code> システム変数</h5></div></div></div><a class="indexterm" name="idm46723658477248"></a><a class="indexterm" name="idm46723658475216"></a><p>
        <code class="literal">gtid_purged</code> システム変数 (<code class="literal">@@GLOBAL.gtid_purged</code>) 内の GTID のセットには、サーバー上でコミットされたが、サーバー上のバイナリログファイルには存在しないすべてのトランザクションの GTID が含まれています。<code class="literal">gtid_purged</code> は、<code class="literal">gtid_executed</code> のサブセットです。 GTID の次のカテゴリが <code class="literal">gtid_purged</code> にあります: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            レプリカでバイナリロギングを無効にしてコミットされたレプリケートされたトランザクションの GTID。
          </p></li><li class="listitem"><p>
            現在パージされているバイナリログファイルに書き込まれたトランザクションの GTID。
          </p></li><li class="listitem"><p>
            ステートメント <code class="literal">SET @@GLOBAL.gtid_purged</code> によってセットに明示的に追加された GTID。
          </p></li></ul></div><p>
        特定の GTID セット内のトランザクションが適用されたことをサーバーに記録するために、<code class="literal">gtid_purged</code> の値を変更できますが、それらはサーバー上のバイナリログには存在しません。 GTID を <code class="literal">gtid_purged</code> に追加すると、<code class="literal">gtid_executed</code> にも追加されます。 このアクションのユースケースの例は、サーバー上の 1 つ以上のデータベースのバックアップをリストアするが、サーバー上のトランザクションを含む関連するバイナリログがない場合です。 MySQL 8.0 より前は、<code class="literal">gtid_executed</code> (および <code class="literal">gtid_purged</code>) が空の場合にのみ、<code class="literal">gtid_purged</code> の値を変更できました。 MySQL 8.0 からは、この制限は適用されず、<code class="literal">gtid_purged</code> 内の GTID セット全体を指定された GTID セットに置き換えるか、指定された GTID セットを <code class="literal">gtid_purged</code> 内の GTID に追加するかを選択することもできます。 これを行う方法の詳細は、<code class="literal">gtid_purged</code> の説明を参照してください。 
      </p><p>
        <code class="literal">gtid_executed</code> および <code class="literal">gtid_purged</code> システム変数内の GTID のセットは、サーバーの起動時に初期化されます。 すべてのバイナリログファイルは、以前のすべてのバイナリログファイル (前のファイル <code class="literal">Previous_gtids_log_event</code> の GTID および前のファイル自体のすべての <code class="literal">Gtid_log_event</code> の GTID から構成される) 内の GTID のセットを含むイベント <code class="literal">Previous_gtids_log_event</code> から始まります。 もっとも古いバイナリログファイルと最新のバイナリログファイル内の <code class="literal">Previous_gtids_log_event</code> の内容は、サーバーの起動時に <code class="literal">gtid_executed</code> および <code class="literal">gtid_purged</code> セットを計算するために使用されます: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">gtid_executed</code> は、最新のバイナリログファイル内の <code class="literal">Previous_gtids_log_event</code> 内の GTID、そのバイナリログファイル内のトランザクションの GTID、および <code class="literal">mysql.gtid_executed</code> テーブルに格納されている GTID の結合として計算されます。 この GTID セットには、現在サーバー上のバイナリログファイル内にあるかどうかに関係なく、サーバー上で使用された (または <code class="literal">gtid_purged</code> に明示的に追加された) GTID がすべて含まれます。 サーバー (<code class="literal">@@GLOBAL.gtid_owned</code>) で現在処理されているトランザクションの GTID は含まれません。 
          </p></li><li class="listitem"><p>
            <code class="literal">gtid_purged</code> は、まず最新のバイナリログファイルに <code class="literal">Previous_gtids_log_event</code> の GTID を追加し、そのバイナリログファイルにトランザクションの GTID を追加することによって計算されます。 この手順では、サーバー (<code class="literal">gtids_in_binlog</code>) のバイナリログに現在記録されている GTID、または一度も記録されていた GTID のセットを提供します。 次に、もっとも古いバイナリログファイル内の <code class="literal">Previous_gtids_log_event</code> 内の GTID が <code class="literal">gtids_in_binlog</code> から差し引かれます。 この手順では、サーバー (<code class="literal">gtids_in_binlog_not_purged</code>) のバイナリログに現在記録されている GTID のセットを提供します。 最後に、<code class="literal">gtids_in_binlog_not_purged</code> が <code class="literal">gtid_executed</code> から減算されます。 結果は、サーバー上で使用されているが、現在サーバー上のバイナリログファイルに記録されていない GTID のセットであり、この結果は <code class="literal">gtid_purged</code> の初期化に使用されます。 
          </p></li></ul></div><p>
        これらの計算に MySQL 5.7.7 以前のバイナリログが含まれている場合は、<code class="literal">gtid_executed</code> および <code class="literal">gtid_purged</code> に対して不正な GTID セットを計算でき、サーバーがあとで再起動されても正しくないままになります。 詳細は、GTID セットを計算するためにバイナリログを繰り返す方法を制御する <code class="literal">binlog_gtid_simple_recovery</code> システム変数の説明を参照してください。 説明されているいずれかの状況がサーバーに当てはまる場合は、サーバー構成ファイルで <code class="literal">binlog_gtid_simple_recovery=FALSE</code> を設定してから起動します。 この設定により、サーバーは (もっとも新しいものともっとも古いものだけでなく) すべてのバイナリログファイルを反復して GTID イベントが表示される場所を見つけます。 GTID イベントのないバイナリログファイルがサーバーに多数ある場合、このプロセスには時間がかかることがあります。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-gtids-execution-history"></a>GTID 実行履歴のリセット</h5></div></div></div><p>
        サーバーで GTID 実行履歴をリセットする必要がある場合は、<code class="literal">RESET MASTER</code> ステートメントを使用します。 たとえば、テストクエリーを実行して新しい GTID 対応サーバーでレプリケーション設定を検証した後、または新しいサーバーをレプリケーショングループに結合するが、グループレプリケーションで受け入れられない不要なローカルトランザクションが含まれている場合に、これを行う必要があります。 
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          必要な GTID 実行履歴およびバイナリログファイルが失われないように、<code class="literal">RESET MASTER</code> を慎重に使用してください。
        </p></div><p>
        <code class="literal">RESET MASTER</code> を発行する前に、サーバーのバイナリログファイルとバイナリログインデックスファイル (ある場合) のバックアップがあることを確認し、<code class="literal">gtid_executed</code> システム変数のグローバル値に保持されている GTID セットを取得して保存します (たとえば、<code class="literal">SELECT @@GLOBAL.gtid_executed</code> ステートメントを発行して結果を保存します)。 その GTID セットから不要なトランザクションを削除する場合は、<span class="command"><strong>mysqlbinlog</strong></span> を使用してトランザクションの内容を調べ、値がなく、保存またはレプリケートが必要なデータがなく、サーバーでデータが変更されなかったことを確認します。 
      </p><p>
        <code class="literal">RESET MASTER</code> を発行すると、次のリセット操作が実行されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">gtid_purged</code> システム変数の値は空の文字列 (<code class="literal">''</code>) に設定されます。
          </p></li><li class="listitem"><p>
            <code class="literal">gtid_executed</code> システム変数のグローバル値 (セッション値ではない) が空の文字列に設定されています。
          </p></li><li class="listitem"><p>
            <code class="literal">mysql.gtid_executed</code> テーブルがクリアされます (<a class="xref" href="replication.html#replication-gtids-gtid-executed-table" title="mysql.gtid_executed テーブル">mysql.gtid_executed テーブル</a> を参照)。
          </p></li><li class="listitem"><p>
            サーバーでバイナリロギングが有効になっている場合、既存のバイナリログファイルは削除され、バイナリログインデックスファイルはクリアされます。
          </p></li></ul></div><p>
        サーバーがバイナリロギングが無効になっているレプリカであっても、<code class="literal">RESET MASTER</code> は GTID 実行履歴をリセットする方法であることに注意してください。 <code class="literal">RESET REPLICA | SLAVE</code> は GTID 実行履歴には影響しません。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-gtids-auto-positioning"></a>17.1.3.3 GTID 自動配置</h4></div></div></div><a class="indexterm" name="idm46723658396928"></a><p>
      GTID は、ソースとレプリカ間のデータフローを開始、停止、または再開するためのポイントを決定するために以前に必要だったファイルオフセットペアを置き換えます。 GTID が使用されている場合、レプリカがソースと同期するために必要なすべての情報は、レプリケーションデータストリームから直接取得されます。 
    </p><p>
      GTID ベースのレプリケーションを使用してレプリカを開始するには、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23 から) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 より前) で <code class="literal">SOURCE_AUTO_POSITION</code> | <code class="literal">MASTER_AUTO_POSITION</code> オプションを有効にする必要があります。 代替の <code class="literal">SOURCE_LOG_FILE</code> | <code class="literal">MASTER_LOG_FILE</code> および <code class="literal">SOURCE_LOG_POS</code> | <code class="literal">MASTER_LOG_POS</code> オプションでは、ログファイルの名前とファイル内の開始位置を指定しますが、GTID ではレプリカにこの非ローカルデータは必要ありません。 GTID ベースのレプリケーションを使用してソースおよびレプリカを構成および起動する完全な手順については、<a class="xref" href="replication.html#replication-gtids-howto" title="17.1.3.4 GTID を使用したレプリケーションのセットアップ">セクション17.1.3.4「GTID を使用したレプリケーションのセットアップ」</a> を参照してください。 
    </p><p>
      <code class="literal">SOURCE_AUTO_POSITION</code> | <code class="literal">MASTER_AUTO_POSITION</code> オプションはデフォルトで無効になっています。 レプリカでマルチソースレプリケーションが有効になっている場合は、該当するレプリケーションチャネルごとにオプションを設定する必要があります。 <code class="literal">SOURCE_AUTO_POSITION</code> | <code class="literal">MASTER_AUTO_POSITION</code> オプションを再度無効にすると、レプリカはファイルベースレプリケーションに戻ります。この場合、<code class="literal">SOURCE_LOG_FILE</code> | <code class="literal">MASTER_LOG_FILE</code> または <code class="literal">SOURCE_LOG_POS</code> | <code class="literal">MASTER_LOG_POS</code> オプションのいずれかまたは両方も指定する必要があります。 
    </p><p>
      レプリカで GTID が有効 (<code class="literal">GTID_MODE=ON</code>、<code class="literal">ON_PERMISSIVE,</code>または <code class="literal">OFF_PERMISSIVE</code>) で <code class="literal">MASTER_AUTO_POSITION</code> オプションが有効になっている場合、ソースへの接続に対して自動配置がアクティブ化されます。 接続を成功させるには、ソースに <code class="literal">GTID_MODE=ON</code> が設定されている必要があります。 初期ハンドシェークでは、レプリカは、すでに受信、コミット、またはその両方を行ったトランザクションを含む GTID セットを送信します。 この GTID セットは、<code class="literal">gtid_executed</code> システム変数 (<code class="literal">@@GLOBAL.gtid_executed</code>) 内の GTID のセットの結合、および受信したトランザクションとしてパフォーマンススキーマ <code class="literal">replication_connection_status</code> テーブルに記録された GTID のセット (<code class="literal">SELECT RECEIVED_TRANSACTION_SET FROM PERFORMANCE_SCHEMA.replication_connection_status</code> ステートメントの結果) と等しくなります。 
    </p><p>
      ソースは、GTID がレプリカによって送信される GTID セットに含まれていないバイナリログに記録されたすべてのトランザクションを送信することによって応答します。 これを行うには、ソースはまず、各バイナリログファイルのヘッダーにある <code class="literal">Previous_gtids_log_event</code> を最新のものからチェックして、作業を開始する適切なバイナリログファイルを識別します。 ソースは、レプリカが欠落しているトランザクションを含まない最初の <code class="literal">Previous_gtids_log_event</code> を検出すると、そのバイナリログファイルから始まります。 この方法は効率的で、大量のバイナリログファイルによってレプリカがソースの背後にある場合にのみかなりの時間がかかります。 次に、ソースはそのバイナリログファイル内のトランザクションとそれ以降のファイルを現在のファイルまで読み取り、レプリカが欠落している GTID を含むトランザクションを送信し、レプリカによって送信された GTID セット内のトランザクションをスキップします。 レプリカが最初に欠落しているトランザクションを受信するまでの経過時間は、バイナリログファイル内のオフセットによって異なります。 この交換により、レプリカがまだ受信またはコミットしていない GTID を持つトランザクションのみがソースから送信されるようになります。 ダイヤモンドトポロジの場合と同様に、レプリカが複数のソースからトランザクションを受信する場合、自動スキップ機能によってトランザクションが 2 回適用されないようにします。 
    </p><p>
      ソースによって送信されるべきトランザクションのいずれかがソースバイナリログからパージされているか、別の方法で <code class="literal">gtid_purged</code> システム変数の GTID セットに追加されている場合、ソースはエラー <span class="errorname">ER_MASTER_HAS_PURGED_REQUIRED_GTIDS</span> をレプリカに送信し、レプリケーションは開始しません。 欠落しているパージ済トランザクションの GTID が識別され、警告メッセージ <span class="errorname">ER_FOUND_MISSING_GTIDS</span> のソースエラーログにリストされます。 ソースのキャッチアップに必要なトランザクション履歴の一部がパージされているため、レプリカはこのエラーから自動的にリカバリできません。 <code class="literal">MASTER_AUTO_POSITION</code> オプションを有効にせずに再接続しようとすると、レプリカ上のパージされたトランザクションが失われます。 この状況からリカバリする正しいアプローチは、レプリカが <span class="errorname">ER_FOUND_MISSING_GTIDS</span> メッセージにリストされている欠落トランザクションを別のソースからレプリケートするか、レプリカをより新しいバックアップから作成された新しいレプリカに置き換えることです。 状況が再度発生しないように、ソースでバイナリログの有効期限 (<code class="literal">binlog_expire_logs_seconds</code>) を変更することを検討してください。 
    </p><p>
      トランザクションの交換中に、GTID 内のソース UUID を持つトランザクションをレプリカが受信またはコミットしたが、ソース自体にそれらのレコードがないことが判明した場合、ソースはレプリカにエラー <span class="errorname">ER_SLAVE_HAS_MORE_GTIDS_THAN_MASTER</span> を送信し、レプリケーションは開始しません。 この状況は、<code class="literal">sync_binlog=1</code> セットを持たないソースで電源障害またはオペレーティングシステムクラッシュが発生し、まだバイナリログファイルに同期されていないがレプリカによって受信されたコミット済トランザクションが失われた場合に発生する可能性があります。 再起動後にクライアントがソースでトランザクションをコミットすると、ソースとレプリカが相違する可能性があります。これは、ソースとレプリカが異なるトランザクションに同じ GTID を使用している状況につながる可能性があります。 この状況からリカバリする正しい方法は、ソースとレプリカが相違しているかどうかを手動で確認することです。 同じ GTID が異なるトランザクションに使用されている場合は、必要に応じて個々のトランザクションに対して手動による競合解決を実行するか、レプリケーショントポロジからソースまたはレプリカを削除する必要があります。 問題がソースで欠落しているトランザクションのみである場合は、かわりにソースをレプリカにし、レプリケーショントポロジ内の他のサーバーで捕捉できるようにしてから、必要に応じて再度ソースにすることができます。 
    </p><p>
      ダイヤモンドトポロジ内のマルチソースレプリカ (レプリカが複数のソースからレプリケートされ、共通ソースからレプリケートされる) の場合、GTID ベースのレプリケーションが使用されているときは、マルチソースレプリカ上のすべてのチャネルでレプリケーションフィルタまたはその他のチャネル構成が同一であることを確認してください。 GTID ベースのレプリケーションでは、フィルタはトランザクションデータにのみ適用され、GTID はフィルタで除外されません。 これは、レプリカの GTID セットがソースと一貫性が保たれるようにするためです。つまり、毎回フィルタで除外されたトランザクションを再取得せずに GTID 自動配置を使用できます。 ダウンストリームレプリカがマルチソースで、ダイアモンドトポロジの複数のソースから同じトランザクションを受信する場合、ダウンストリームレプリカには複数のバージョンのトランザクションが含まれるようになり、結果はトランザクションを最初に適用するチャネルによって異なります。 トランザクションの GTID が最初のチャネルによって <code class="literal">gtid_executed</code> セットに追加されたため、GTID 自動スキップを使用してトランザクションをスキップしようとする 2 つ目のチャネル。 チャネルのフィルタリングが同一の場合、トランザクションのすべてのバージョンに同じデータが含まれているため、結果は同じであるため、問題はありません。 ただし、チャネルのフィルタリングが異なると、データベースに一貫性がなくなる可能性があり、レプリケーションがハングする可能性があります。 
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-gtids-howto"></a>17.1.3.4 GTID を使用したレプリケーションのセットアップ</h4></div></div></div><a class="indexterm" name="idm46723658347824"></a><p>
      このセクションでは、MySQL 8.0 で GTID ベースレプリケーションを構成および起動するためのプロセスについて説明します。 これは、ソースサーバーを初めて起動するか、停止できることを前提とした<span class="quote">「<span class="quote">「コールドスタート」</span>」</span>プロシージャです。GTID を使用した実行中のソースサーバーからのレプリカのプロビジョニングの詳細は、<a class="xref" href="replication.html#replication-gtids-failover" title="17.1.3.5 フェイルオーバーおよびスケールアウトでの GTID の使用">セクション17.1.3.5「フェイルオーバーおよびスケールアウトでの GTID の使用」</a> を参照してください。 オンラインでの GTID モードの変更については、<a class="xref" href="replication.html#replication-mode-change-online" title="17.1.4 オンラインサーバーでの GTID モードの変更">セクション17.1.4「オンラインサーバーでの GTID モードの変更」</a> を参照してください。 
    </p><p>
      1 つのソースと 1 つのレプリカで構成される、最も単純な GTID レプリケーショントポロジのためのこの起動プロセスの主なステップは、次のとおりです:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          レプリケーションがすでに動作している場合、両方のサーバーを読み取り専用にすることでそれらを同期します。
        </p></li><li class="listitem"><p>
          両方のサーバーを停止します。
        </p></li><li class="listitem"><p>
          GTID を有効にして両方のサーバーを再起動し、正しいオプションを構成します。
        </p><p>
          説明したサーバーを起動するために必要な <span class="command"><strong>mysqld</strong></span> オプションについては、このセクションの後半の例で説明します。
        </p></li><li class="listitem"><p>
          ソースをレプリケーションデータソースとして使用し、自動配置を使用するようレプリカに指示します。 この手順の実施に必要な SQL ステートメントは、このセクションの後半の例で説明します。 
        </p></li><li class="listitem"><p>
          新しいバックアップを作成します。 GTID のないトランザクションを含むバイナリログは GTID が有効になっているサーバーでは使用できないため、この時点より前に作成されたバックアップは新しい構成では使用できません。 
        </p></li><li class="listitem"><p>
          レプリカを起動し、両方のサーバーで読取り専用モードを無効にして、更新を受け入れることができるようにします。
        </p></li></ol></div><p>
      次の例では、MySQL バイナリログの位置ベースのレプリケーションプロトコルを使用して、2 つのサーバーがすでにソースおよびレプリカとして実行されています。 新しいサーバーから開始する場合、レプリケーション接続用の特定のユーザーの追加の詳細は <a class="xref" href="replication.html#replication-howto-repuser" title="17.1.2.3 レプリケーション用ユーザーの作成">セクション17.1.2.3「レプリケーション用ユーザーの作成」</a> を、<code class="literal">server_id</code> 変数の設定の詳細は <a class="xref" href="replication.html#replication-howto-masterbaseconfig" title="17.1.2.1 レプリケーションソース構成の設定">セクション17.1.2.1「レプリケーションソース構成の設定」</a> を参照してください。 次の例は、<span class="command"><strong>mysqld</strong></span> 起動オプションをサーバーオプションファイルに格納する方法を示しています。詳細は、<a class="xref" href="programs.html#option-files" title="4.2.2.2 オプションファイルの使用">セクション4.2.2.2「オプションファイルの使用」</a> を参照してください。 または、<span class="command"><strong>mysqld</strong></span> の実行時に起動オプションを使用することもできます。 
    </p><p>
      後続のほとんどの手順では、<code class="literal">SUPER</code> 権限を持つ MySQL <code class="literal">root</code> アカウントまたは別の MySQL ユーザーアカウントを使用する必要があります。<span class="command"><strong>mysqladmin</strong></span> <code class="literal">shutdown</code> には、<code class="literal">SUPER</code> 権限または <code class="literal">SHUTDOWN</code> 権限が必要です。
    </p><p><b>手順 1: サーバーを同期します. </b>
        このステップは、GTID を使用せずにすでにレプリケートされているサーバーを操作する場合にのみ必要です。 新しいサーバーの場合は、ステップ 3 に進みます。 次のコマンドを発行して、各サーバーで <code class="literal">read_only</code> システム変数を <code class="literal">ON</code> に設定し、サーバーを読取り専用にします: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET @@GLOBAL.read_only = ON;</code></strong>
</pre><p>
      進行中のすべてのトランザクションがコミットまたはロールバックされるまで待機します。 その後、レプリカがソースをキャッチアップできるようにします。 <span class="emphasis"><em>続行する前にレプリカがすべての更新を処理したことを確認することが非常に重要です</em></span> .  
    </p><p>
      ポイントインタイムのバックアップおよびリストアなど、レプリケーション以外にバイナリログを使用する場合は、GTID のないトランザクションを含む古いバイナリログが不要になるまで待機します。 理想的には、サーバーがすべてのバイナリログをパージし、既存のバックアップが期限切れになるまで待機します。 
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        GTID が有効になっているサーバーでは GTID のないトランザクションを含むログを使用できないことを理解することが重要です。 続行する前に、GTID のないトランザクションがトポロジ内のどこにも存在しないことを確認する必要があります。 
      </p></div><p><b>手順 2: 両方のサーバーを停止します。. </b>
        ここで示すように、<span class="command"><strong>mysqladmin</strong></span> を使用して各サーバーを停止します。ここで、<em class="replaceable"><code>username</code></em> はサーバーをシャットダウンするのに十分な権限を持つ MySQL ユーザーのユーザー名です。
      </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqladmin -u<em class="replaceable"><code>username</code></em> -p shutdown</code></strong>
</pre><p>
      次に、プロンプトにこのユーザーのパスワードを指定します。
    </p><p><b>ステップ 3: GTID が有効な両方のサーバーを起動. </b>
        GTID ベースのレプリケーションを有効にするには、GTID ベースのレプリケーションで安全なステートメントのみがログに記録されるように、<code class="literal">gtid_mode</code> 変数を <code class="literal">ON</code> に設定し、<code class="literal">enforce_gtid_consistency</code> 変数を有効にして GTID モードで各サーバーを起動する必要があります。 例: 
      </p><pre class="programlisting">gtid_mode=ON
enforce-gtid-consistency=ON
</pre><p>
      また、レプリカ設定を構成する前に、<code class="option">--skip-slave-start</code> オプションを使用してレプリカを開始する必要があります。 GTID 関連のオプションおよび変数の詳細は、<a class="xref" href="replication.html#replication-options-gtids" title="17.1.6.5 グローバルトランザクション ID システム変数">セクション17.1.6.5「グローバルトランザクション ID システム変数」</a> を参照してください。 
    </p><p>
      <a class="xref" href="replication.html#replication-gtids-gtid-executed-table" title="mysql.gtid_executed テーブル">mysql.gtid_executed テーブル</a> の使用時に GTID を使用するためにバイナリロギングを有効にする必要はありません。 レプリケートを可能にするには、ソースサーバーで常にバイナリロギングが有効になっている必要があります。 ただし、複製サーバーは GTID を使用できますが、バイナリロギングは使用できません。 レプリカサーバーでバイナリロギングを無効にする必要がある場合は、レプリカの <code class="option">--skip-log-bin</code> および <code class="option">--log-slave-updates=OFF</code> オプションを指定して無効にできます。 
    </p><p><b>ステップ 4: GTID ベースの自動配置を使用するようにレプリカを構成. </b>
        GTID ベースのトランザクションを含むソースをレプリケーションデータソースとして使用し、ファイルベースの配置ではなく GTID ベースの自動配置を使用するようにレプリカに指示します。 レプリカに対して (MySQL 8.0.23 の) <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントまたは (MySQL 8.0.23 の前の)<code class="literal">CHANGE MASTER TO</code> ステートメントを発行し、ステートメントに <code class="literal">SOURCE_AUTO_POSITION</code> | <code class="literal">MASTER_AUTO_POSITION</code> オプションを含めて、ソーストランザクションが GTID によって識別されることをレプリカに伝えます。 
      </p><p>
      また、ソースホスト名とポート番号に適切な値を指定し、レプリカがソースに接続するために使用できるレプリケーションユーザーアカウントのユーザー名とパスワードを指定する必要がある場合もあります。これらがステップ 1 より前にすでに設定されており、それ以上変更する必要がない場合は、ここに示すステートメントから対応するオプションを安全に省略できます。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO</code></strong>
     &gt;     <strong class="userinput"><code>MASTER_HOST = <em class="replaceable"><code>host</code></em>,</code></strong>
     &gt;     <strong class="userinput"><code>MASTER_PORT = <em class="replaceable"><code>port</code></em>,</code></strong>
     &gt;     <strong class="userinput"><code>MASTER_USER = <em class="replaceable"><code>user</code></em>,</code></strong>
     &gt;     <strong class="userinput"><code>MASTER_PASSWORD = <em class="replaceable"><code>password</code></em>,</code></strong>
     &gt;     <strong class="userinput"><code>MASTER_AUTO_POSITION = 1;</code></strong>

Or from MySQL 8.0.23:

mysql&gt; <strong class="userinput"><code>CHANGE REPLICATION SOURCE TO</code></strong>
     &gt;     <strong class="userinput"><code>SOURCE_HOST = <em class="replaceable"><code>host</code></em>,</code></strong>
     &gt;     <strong class="userinput"><code>SOURCE_PORT = <em class="replaceable"><code>port</code></em>,</code></strong>
     &gt;     <strong class="userinput"><code>SOURCE_USER = <em class="replaceable"><code>user</code></em>,</code></strong>
     &gt;     <strong class="userinput"><code>SOURCE_PASSWORD = <em class="replaceable"><code>password</code></em>,</code></strong>
     &gt;     <strong class="userinput"><code>SOURCE_AUTO_POSITION = 1;</code></strong>
</pre><p><b>ステップ 5: 新しいバックアップの作成. </b>
        GTID を有効にする前に作成された既存のバックアップは、GTID を有効にしたこれらのサーバーでは使用できなくなりました。 この時点で新しいバックアップを作成して、使用可能なバックアップなしで残されないようにします。 
      </p><p>
      たとえば、バックアップを作成しているサーバーで <code class="literal">FLUSH LOGS</code> を実行できます。 次に、明示的にバックアップを取るか、設定した定期バックアップルーチンの次の反復を待機します。 
    </p><p><b>ステップ 6: レプリカを起動し、読取り専用モードを無効にします. </b>
        次のようにレプリカを起動します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>START SLAVE;</code></strong>
Or from MySQL 8.0.22:
mysql&gt; <strong class="userinput"><code>START REPLICA;</code></strong>
</pre><p>
      次のステップは、ステップ 1 でサーバーを読取り専用に構成した場合にのみ必要です。 サーバーが更新の受け入れを再度開始できるようにするには、次のステートメントを発行します: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET @@GLOBAL.read_only = OFF;</code></strong>
</pre><p>
      GTID ベースのレプリケーションが実行され、以前と同様にソースでアクティビティを開始 (または再開) できます。<a class="xref" href="replication.html#replication-gtids-failover" title="17.1.3.5 フェイルオーバーおよびスケールアウトでの GTID の使用">セクション17.1.3.5「フェイルオーバーおよびスケールアウトでの GTID の使用」</a> では、GTID 使用時の新しいレプリカの作成について説明します。
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-gtids-failover"></a>17.1.3.5 フェイルオーバーおよびスケールアウトでの GTID の使用</h4></div></div></div><a class="indexterm" name="idm46723658260880"></a><a class="indexterm" name="idm46723658258752"></a><p>
      MySQL レプリケーションをグローバルトランザクション識別子 (GTID) とともに使用して新しいレプリカをプロビジョニングする場合、スケールアウトに使用し、フェイルオーバーのために必要に応じてソースに昇格する方法が多数あります。 このセクションでは、次の手法について説明します: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="xref" href="replication.html#replication-gtids-failover-replicate" title="単純なレプリケーション">単純なレプリケーション</a>
        </p></li><li class="listitem"><p>
          <a class="xref" href="replication.html#replication-gtids-failover-copy" title="レプリカへのデータおよびトランザクションのコピー">レプリカへのデータおよびトランザクションのコピー</a>
        </p></li><li class="listitem"><p>
          <a class="xref" href="replication.html#replication-gtids-failover-empty" title="空のトランザクションの注入">空のトランザクションの注入</a>
        </p></li><li class="listitem"><p>
          <a class="xref" href="replication.html#replication-gtids-failover-gtid-purged" title="gtid_purged によるトランザクションの除外">gtid_purged によるトランザクションの除外</a>
        </p></li><li class="listitem"><p>
          <a class="xref" href="replication.html#replication-gtids-restoring-mysqlbinlog" title="GTID モードの複製の復元">GTID モードの複製の復元</a>
        </p></li></ul></div><p>
      グローバルトランザクション識別子は、特にレプリケーションデータフローおよびフェイルオーバーアクティビティーの一般管理を簡易化するために、MySQL Replication に追加されました。 各識別子は、全体でトランザクションを構成するバイナリログイベントセットを一意に識別します。 GTID はデータベースに変更を適用する際に重要な役割を果たします。サーバーは、以前に処理済みと認識している識別子のトランザクションを自動的にスキップします。 この動作は、自動レプリケーションポジショニングおよび正確なフェイルオーバーのために重要です。 
    </p><p>
      トランザクションを構成する識別子とイベントセットとの間のマッピングは、バイナリログで取得されます。 このことは、別の既存のサーバーからのデータで新しいサーバーをプロビジョニングする際に、いくつかの課題を提起します。 新しいサーバーに設定された識別子を再現するには、古いサーバーから新しいサーバーに識別子をコピーし、識別子と実際のイベントの関係を保持する必要があります。 これは、フェイルオーバーまたはスイッチオーバー時に新しいソースになる候補としてすぐに使用可能なレプリカをリストアするために必要です。 
    </p><p><a name="replication-gtids-failover-replicate"></a><b>単純なレプリケーション. </b>
        新しいサーバーですべての識別子とトランザクションを再現する最も簡単な方法は、新しいサーバーを実行履歴全体を持つソースのレプリカにし、両方のサーバーでグローバルトランザクション識別子を有効にすることです。 詳細については、<a class="xref" href="replication.html#replication-gtids-howto" title="17.1.3.4 GTID を使用したレプリケーションのセットアップ">セクション17.1.3.4「GTID を使用したレプリケーションのセットアップ」</a>を参照してください。 
      </p><p>
      レプリケーションが開始されると、新しいサーバーはバイナリログ全体をソースからコピーするため、すべての GTID に関するすべての情報を取得します。
    </p><p>
      この方法は単純で効果的ですが、レプリカがソースからバイナリログを読み取る必要があります。新しいレプリカがソースに追いつくまでに比較的長い時間がかかる場合があるため、この方法は高速フェイルオーバーやバックアップからの復元には適していません。 このセクションでは、バイナリログファイルを新しいサーバーにコピーして、ソースからすべての実行履歴をフェッチしない方法について説明します。 
    </p><p><a name="replication-gtids-failover-copy"></a><b>レプリカへのデータおよびトランザクションのコピー. </b>
        ソースサーバーが以前に多数のトランザクションを処理している場合、トランザクション履歴全体の実行に時間がかかることがあり、これは新しいレプリカの設定時の大きなボトルネックを表している可能性があります。 この要件をなくすために、データセットのスナップショット、バイナリログおよびソースサーバーに含まれるグローバルトランザクション情報を新しいレプリカにインポートできます。 スナップショットが作成されるサーバーは、ソースまたはそのレプリカのいずれかになりますが、データをコピーする前に、サーバーが必要なすべてのトランザクションを処理していることを確認する必要があります。 
      </p><p>
      この方法にはいくつかのバリアントがあります。違いは、データダンプとバイナリログからのトランザクションがレプリカに転送される方法です。次に概要を示します:
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"> データセット </span></dt><dd><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                ソースサーバーで <span class="command"><strong>mysqldump</strong></span> を使用してダンプファイルを作成します。 バイナリロギング情報を含む <code class="literal">CHANGE REPLICATION SOURCE TO</code>|<code class="literal">CHANGE MASTER TO</code> ステートメントを含めるように、<span class="command"><strong>mysqldump</strong></span> オプション <code class="option">--master-data</code> (デフォルト値は 1) を設定します。 実行されたトランザクションに関する情報をダンプに含めるには、<code class="option">--set-gtid-purged</code> オプションを <code class="literal">AUTO</code> (デフォルト) または <code class="literal">ON</code> に設定します。 次に、<span class="command"><strong>mysql</strong></span> クライアントを使用して、ダンプファイルをターゲットサーバーにインポートします。 
              </p></li><li class="listitem"><p>
                または、RAW データファイルを使用してソースサーバーのデータスナップショットを作成し、<a class="xref" href="replication.html#replication-snapshot-method" title="17.1.2.5 データスナップショットの方法の選択">セクション17.1.2.5「データスナップショットの方法の選択」</a> の手順に従ってこれらのファイルをターゲットサーバーにコピーします。 <code class="literal">InnoDB</code> テーブルを使用する場合、MySQL Enterprise Backup コンポーネントから <span class="command"><strong>mysqlbackup</strong></span> コマンドを使用して、一貫性のあるスナップショットを作成できます。 このコマンドは、レプリカで使用されるスナップショットに対応するログ名とオフセットを記録します。 MySQL Enterprise Backup は MySQL Enterprise サブスクリプションの一部として同梱される製品です。 詳細は、<a class="xref" href="mysql-enterprise.html#mysql-enterprise-backup" title="30.2 MySQL Enterprise Backup の概要">セクション30.2「MySQL Enterprise Backup の概要」</a>を参照してください。 
              </p></li><li class="listitem"><p>
                または、ソースサーバーとターゲットサーバーの両方を停止し、ソースデータディレクトリの内容を新しいレプリカデータディレクトリにコピーしてから、レプリカを再起動します。 この方法を使用する場合は、GTID ベースのレプリケーション、つまり <code class="literal">gtid_mode=ON</code> でレプリカを構成する必要があります。 この方法の手順および重要な情報については、<a class="xref" href="replication.html#replication-howto-additionalslaves" title="17.1.2.8 レプリケーション環境へのレプリカの追加">セクション17.1.2.8「レプリケーション環境へのレプリカの追加」</a> を参照してください。 
              </p></li></ol></div></dd><dt><span class="term"> トランザクション履歴 </span></dt><dd><p>
            ソースサーバーのバイナリログに完全なトランザクション履歴がある (GTID セット<code class="literal">@@GLOBAL.gtid_purged</code> が空である) 場合は、次の方法を使用できます。
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                <code class="option">--read-from-remote-server</code> および <code class="option">--read-from-remote-master</code> オプションを指定して、<span class="command"><strong>mysqlbinlog</strong></span> を使用してバイナリログをソースサーバーから新しいレプリカにインポートします。
              </p></li><li class="listitem"><p>
                または、ソースサーバーのバイナリログファイルをレプリカにコピーします。 <code class="option">--read-from-remote-server</code> および <code class="option">--raw</code> オプションを指定した <span class="command"><strong>mysqlbinlog</strong></span> を使用して、レプリカからコピーを作成できます。 これらは、<span class="command"><strong>mysqlbinlog</strong></span> <code class="literal">&gt;</code> <code class="filename"><em class="replaceable"><code>file</code></em></code> (<code class="option">--raw</code> オプションなし) を使用してバイナリログファイルを SQL ファイルにエクスポートし、これらのファイルを <span class="command"><strong>mysql</strong></span> クライアントに渡して処理することでレプリカに読み取ることができます。 すべてのバイナリログファイルが、複数の接続ではなく単一の <span class="command"><strong>mysql</strong></span> プロセスを使用して処理されていることを確認します。 例: 
              </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqlbinlog copied-binlog.000001 copied-binlog.000002 | mysql -u root -p</code></strong>
</pre><p>
                詳細は、<a class="xref" href="programs.html#mysqlbinlog-backup" title="4.6.8.3 バイナリログファイルのバックアップのための mysqlbinlog の使用">セクション4.6.8.3「バイナリログファイルのバックアップのための mysqlbinlog の使用」</a>を参照してください。
              </p></li></ol></div></dd></dl></div><p>
      この方法には、ほとんどすぐに新しいサーバーを使用できるという利点があります。スナップショットまたはダンプファイルのリプレイ中にコミットされたトランザクションのみ、既存のソースから取得する必要があります。 つまり、レプリカの可用性は瞬時ではありませんが、レプリカがこれらの少数の残りのトランザクションに追いつくには比較的短い時間しか必要ありません。 
    </p><p>
      通常、バイナリログをターゲットサーバーに事前にコピーする方が、ソースからリアルタイムでトランザクション実行履歴全体を読み取るより高速です。 ただし、サイズやその他の考慮事項により、必要なときにこれらのファイルをターゲットに移動することが常に実現できるとはかぎらない場合があります。 このセクションで説明する新しいレプリカをプロビジョニングするための残りの 2 つの方法では、他の方法を使用してトランザクションに関する情報を新しいレプリカに転送します。 
    </p><p><a name="replication-gtids-failover-empty"></a><b>空のトランザクションの注入. </b>
        ソースグローバル <code class="literal">gtid_executed</code> 変数には、ソースで実行されたすべてのトランザクションのセットが含まれます。 新しいサーバーをプロビジョニングするためにスナップショットを作成するときにバイナリログをコピーする代わりに、スナップショットが作成されたサーバーで <code class="literal">gtid_executed</code> の内容に注目できます。 新しいサーバーをレプリケーションチェーンに追加する前に、次のように、ソース <code class="literal">gtid_executed</code> に含まれるトランザクション識別子ごとに新しいサーバーで空のトランザクションをコミットします: 
      </p><pre class="programlisting">SET GTID_NEXT='aaa-bbb-ccc-ddd:N';

BEGIN;
COMMIT;

SET GTID_NEXT='AUTOMATIC';
</pre><p>
      空のトランザクションを使用してすべてのトランザクション識別子をこの方法で回復したら、次に示すようにレプリカバイナリログをフラッシュしてパージする必要があります。ここで、<em class="replaceable"><code>N</code></em> は現在のバイナリログファイル名のゼロ以外の接尾辞です:
    </p><pre class="programlisting">FLUSH LOGS;
PURGE BINARY LOGS TO 'source-bin.00000<em class="replaceable"><code>N</code></em>';
</pre><p>
      後でソースに昇格された場合に、このサーバーが false トランザクションでレプリケーションストリームをフラッディングしないようにするには、これを行うようにしてください。 (<code class="literal">FLUSH LOGS</code> ステートメントは強制的に新しいバイナリログファイルを作成します。<code class="literal">PURGE BINARY LOGS</code> は空のトランザクションをパージしますが、その識別子を保持します。) 
    </p><p>
      このメソッドは、基本的にスナップショットであるサーバーを作成しますが、バイナリログ履歴がレプリケーションストリームのバイナリログ履歴と収束する (つまり、ソースとキャッチアップする) と同時にソースになることができます。 この結果は、残りのプロビジョニング方法を使用して得られる結果に実質的に似ています (次のいくつかの段落で説明します)。 
    </p><p><a name="replication-gtids-failover-gtid-purged"></a><b>gtid_purged によるトランザクションの除外. </b>
        ソースグローバル <code class="literal">gtid_purged</code> 変数には、ソースバイナリログからパージされたすべてのトランザクションのセットが含まれます。 前に説明した方法と同様に (<a class="xref" href="replication.html#replication-gtids-failover-empty" title="空のトランザクションの注入">空のトランザクションの注入</a>を参照してください)、スナップショットが作成されたサーバーで (バイナリログを新しいサーバーにコピーする代わりに) <code class="literal">gtid_executed</code> の値を記録できます。 前述の方法とは異なり、空のトランザクションをコミットする (または <code class="literal">PURGE BINARY LOGS</code> を発行する) 必要はありません。かわりに、バックアップまたはスナップショットが作成されたサーバー上の <code class="literal">gtid_executed</code> の値に基づいて、レプリカに <code class="literal">gtid_purged</code> を直接設定できます。 
      </p><p>
      空のトランザクションを使用する方法と同様に、この方法では、機能的にスナップショットであるサーバーが作成されますが、バイナリログ履歴がソースおよびほかのレプリカのものと収束すると、時間内にソースになることができます。
    </p><p><a name="replication-gtids-restoring-mysqlbinlog"></a><b>GTID モードの複製の復元. </b>
        エラーが発生した GTID ベースのレプリケーション設定でレプリカをリストアする場合、イベントに GTID がないため、空のトランザクションをインジェクトしても問題が解決しないことがあります。
      </p><p>
      <span class="command"><strong>mysqlbinlog</strong></span> を使用して、次のトランザクション (イベント後の次のログファイルの最初のトランザクション) を検索します。 <code class="literal">SET @@SESSION.gtid_next</code> が含まれていることを確認して、そのトランザクションの <code class="literal">COMMIT</code> までのすべてをコピーします。 行ベースレプリケーションを使用していない場合でも、コマンドラインクライアントでバイナリログ行イベントを実行できます。 
    </p><p>
      レプリカを停止し、コピーしたトランザクションを実行します。 <span class="command"><strong>mysqlbinlog</strong></span> 出力ではデリミタが<code class="literal">/*!*/;</code>に設定されるため、再度設定します: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>DELIMITER ;</code></strong>
</pre><p>
      正しい位置からレプリケーションを自動的に再開します:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GTID_NEXT=automatic;</code></strong>
mysql&gt; <strong class="userinput"><code>RESET SLAVE;</code></strong>
mysql&gt; <strong class="userinput"><code>START SLAVE;</code></strong>
Or from MySQL 8.0.22:
mysql&gt; <strong class="userinput"><code>SET GTID_NEXT=automatic;</code></strong>
mysql&gt; <strong class="userinput"><code>RESET REPLICA;</code></strong>
mysql&gt; <strong class="userinput"><code>START REPLICA;</code></strong>
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-gtids-assign-anon"></a>17.1.3.6 GTID のないソースから GTID のあるレプリカへのレプリケーション</h4></div></div></div><a class="indexterm" name="idm46723658152112"></a><p>
      MySQL 8.0.23 から、GTID がまだないレプリケートされたトランザクションに GTID を割り当てるようにレプリケーションチャネルを設定できます。 この機能により、GTID が有効になっておらず GTID ベースのレプリケーションを使用しないソースサーバーから GTID が有効になっているレプリカへのレプリケーションが可能になります。 <a class="xref" href="replication.html#replication-mode-change-online" title="17.1.4 オンラインサーバーでの GTID モードの変更">セクション17.1.4「オンラインサーバーでの GTID モードの変更」</a> で説明されているように、レプリケーションソースサーバーで GTID を有効にできる場合は、代わりにそのアプローチを使用します。 この機能は、GTID を有効にできないレプリケーションソースサーバー用に設計されています。 
    </p><p>
      <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントの <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> オプションを使用して、レプリケーションチャネルで GTID 割当てを有効にできます。 <code class="literal">LOCAL</code> は、レプリカ独自の UUID (<code class="literal">server_uuid</code> 設定) を含む GTID を割り当てます。<code class="literal"><em class="replaceable"><code>uuid</code></em></code> は、レプリケーションソースサーバーの <code class="literal">server_uuid</code> 設定など、指定された UUID を含む GTID を割り当てます。 非ローカル UUID を使用すると、レプリカで発生したトランザクションと、ソースで発生したトランザクション、およびマルチソースレプリカの場合は異なるソースで発生したトランザクションを区別できます。 ソースによって送信されたトランザクションのいずれかに GTID がすでにある場合、その GTID は保持されます。 
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        フェイルオーバーが必要な場合、どのチャネルでも <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> を使用して設定されたレプリカを昇格させてレプリケーションサーバーを置き換えることはできず、レプリカから作成されたバックアップを使用してレプリケーションサーバーをリストアすることはできません。 同じ制限が、任意のチャネルで <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> を使用する他のレプリカの置換またはリストアにも適用されます。 
      </p></div><p>
      レプリカには <code class="literal">gtid_mode=ON</code> セットが必要であり、後で変更することはできません。 GTID を有効にせずにレプリカサーバーを起動し、レプリケーションチャネルに <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> を設定した場合、設定は変更されませんが、状況の変更方法を説明する警告メッセージがエラーログに書き込まれます。 
    </p><p>
      マルチソースレプリカの場合、<code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> を使用するチャネルと使用しないチャネルを混在させることができます。 Group Replication に固有のチャネルでは <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> を使用できませんが、Group Replication グループメンバーであるサーバーインスタンス上の別のソースの非同期レプリケーションチャネルでは使用できます。 Group Replication グループメンバー上のチャネルの場合、GTID を作成するための UUID として Group Replication グループ名を指定しないでください。 
    </p><p>
      レプリケーションチャネルで <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> を使用することは、チャネルに GTID ベースのレプリケーションを導入することとは異なります。 <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> で設定されたレプリカセットから GTID セット (<code class="literal">gtid_executed</code>) を別のサーバーに転送したり、別のサーバー <code class="literal">gtid_executed</code> セットと比較したりしないでください。 匿名トランザクションに割り当てられている GTID と、それらに対して選択する UUID は、そのレプリカ独自の使用にのみ意味があります。 
    </p><p>
      <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> を使用するレプリケーションチャネルには、GTID ベースのレプリケーションと次の動作の違いがあります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          GTID は、レプリケートされたトランザクションの適用時に割り当てられます (GTID がすでにある場合を除く)。 GTID は通常、トランザクションのコミット時にレプリケーションソースサーバーに割り当てられ、トランザクションとともにレプリカに送信されます。 マルチスレッドレプリカでは、これは GTID の順序が、<code class="literal">slave-preserve-commit-order=1</code> が設定されている場合でもトランザクションの順序と一致しないことを意味します。 
        </p></li><li class="listitem"><p>
          <code class="literal">MASTER_AUTO_POSITION</code> オプションではなく、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントの <code class="literal">SOURCE_LOG_FILE</code> および <code class="literal">SOURCE_LOG_POS</code> オプションを使用してレプリケーション I/O スレッドを配置します。
        </p></li><li class="listitem"><p>
          <code class="literal">SET GLOBAL sql_slave_skip_counter</code> ステートメントは、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントではなく、<code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> で設定されたレプリケーションチャネルでトランザクションをスキップするために使用されます。 その手順は、<a class="xref" href="replication.html#replication-administration-skip" title="17.1.7.3 トランザクションのスキップ">セクション17.1.7.3「トランザクションのスキップ」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">START REPLICA</code> ステートメントの <code class="literal">UNTIL SQL_BEFORE_GTIDS</code> および <code class="literal">UNTIL_SQL_AFTER_GTIDS</code> オプションは、チャネルには使用できません。
        </p></li><li class="listitem"><p>
          MySQL 8.0.18 から非推奨になった関数 <code class="literal">WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS()</code> は、チャネルでは使用できません。 サーバー全体で動作する交換用の <code class="literal">WAIT_FOR_EXECUTED_GTID_SET()</code> を使用できます。 
        </p></li></ul></div><p>
      「パフォーマンススキーマ」テーブル <code class="literal">replication_applier_configuration</code> は、GTID がレプリケーションチャネル上の匿名トランザクションに割り当てられているかどうか、UUID とは何か、およびそれがレプリカサーバー (<code class="literal">LOCAL</code>) とユーザー指定 UUID (<code class="literal">MANUAL</code>) のどちらであるかを示します。 この情報は、アプライヤメタデータリポジトリにも記録されます。 <code class="literal">RESET SLAVE ALL</code> ステートメントは <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> 設定をリセットしますが、<code class="literal">RESET SLAVE</code> ステートメントはリセットしません。 
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-gtids-restrictions"></a>17.1.3.7 GTID ベースレプリケーションの制約</h4></div></div></div><a class="indexterm" name="idm46723658100112"></a><p>
      GTID ベースレプリケーションはトランザクションに依存しているため、そうでなければ MySQL で使用できるいくつかの機能が、それを使用するときにサポートされません。 このセクションでは、GTID ベースレプリケーションの制約と制限についての情報を提供します。 
    </p><p><b>非トランザクションストレージエンジンに関係する更新. </b>
        GTID を使用する場合、<code class="literal">MyISAM</code> などの非トランザクションストレージエンジンを使用するテーブルへの更新は、<code class="literal">InnoDB</code> などのトランザクションストレージエンジンを使用するテーブルへの更新と同じステートメントまたはトランザクションで実行できません。
      </p><p>
      この制約は、非トランザクションストレージエンジンを使用するテーブルへの更新とトランザクションストレージエンジンを使用するテーブルへの更新が、同じトランザクション内に混在していると、複数の GTID が同じトランザクションに割り当てられる可能性があるためです。
    </p><p>
      このような問題は、一方のストレージエンジンがトランザクショナルで、もう一方がトランザクショナルでない場合に、ソースとレプリカがそれぞれのバージョンの同じテーブルに対して異なるストレージエンジンを使用している場合にも発生することがあります。 また、非トランザクションテーブルで動作するように定義されているトリガーが、これらの問題の原因になる可能性があることにも注意してください。 
    </p><p>
      今挙げたいずれの場合も、トランザクションと GTID との間の 1 対 1 対応が壊れていて、GTID ベースレプリケーションは正しく機能できません。
    </p><p><b>CREATE TABLE ... SELECT ステートメント. </b>
        MySQL 8.0.21 より前では、GTID ベースのレプリケーションを使用する場合、<code class="literal">CREATE TABLE ... SELECT</code> ステートメントは許可されません。 <code class="literal">binlog_format</code> が <code class="literal">STATEMENT</code> に設定されている場合、<code class="literal">CREATE TABLE ... SELECT</code> ステートメントはバイナリログに 1 つの GTID を持つ 1 つのトランザクションとして記録されますが、<code class="literal">ROW</code> 形式が使用されている場合、ステートメントは 2 つの GTID を持つ 2 つのトランザクションとして記録されます。 ソースが <code class="literal">STATEMENT</code> 形式を使用し、レプリカが <code class="literal">ROW</code> 形式を使用した場合、レプリカはトランザクションを正しく処理できないため、GTID で <code class="literal">CREATE TABLE ... SELECT</code> ステートメントを使用してこのシナリオを回避することはできません。 この制限は、アトミック DDL をサポートするストレージエンジン上の MySQL 8.0.21 で解除されています。 この場合、<code class="literal">CREATE TABLE ... SELECT</code> はバイナリログに 1 つのトランザクションとして記録されます。 詳細は、<a class="xref" href="sql-statements.html#atomic-ddl" title="13.1.1 アトミックデータ定義ステートメントのサポート">セクション13.1.1「アトミックデータ定義ステートメントのサポート」</a>を参照してください。 
      </p><p><b>一時テーブル. </b>
        <code class="literal">binlog_format</code> が <code class="literal">STATEMENT</code> に設定されている場合、GTID がサーバーで使用されているとき (<code class="literal">enforce_gtid_consistency</code> システム変数が <code class="literal">ON</code> に設定されているとき) は、トランザクション、プロシージャ、関数およびトリガー内で <code class="literal">CREATE TEMPORARY TABLE</code> および <code class="literal">DROP TEMPORARY TABLE</code> ステートメントを使用できません。 GTID が使用されている場合、<code class="literal">autocommit=1</code> が設定されていれば、これらのコンテキストの外部で使用できます。 MySQL 8.0.13 から、<code class="literal">binlog_format</code> が <code class="literal">ROW</code> または <code class="literal">MIXED</code> に設定されている場合、GTID が使用されているときに、<code class="literal">CREATE TEMPORARY TABLE</code> および <code class="literal">DROP TEMPORARY TABLE</code> ステートメントをトランザクション、プロシージャ、関数またはトリガー内で使用できます。 ステートメントはバイナリログに書き込まれないため、複製に複製されません。 行ベースのレプリケーションを使用することは、一時テーブルをレプリケートする必要なく、レプリカの同期が維持されることを意味します。 トランザクションからこれらのステートメントを削除した結果、空のトランザクションが発生した場合、そのトランザクションはバイナリログに書き込まれません。 

      </p><p><b>サポートされないステートメントの実行の回避. </b>
        GTID ベースのレプリケーションが失敗する原因となるステートメントの実行を防ぐには、GTID を有効にするときに <code class="option">--enforce-gtid-consistency</code> オプションを使用してすべてのサーバーを起動する必要があります。 これにより、このセクションですでに説明したタイプのステートメントはエラーで失敗します。 
      </p><p>
      <code class="option">--enforce-gtid-consistency</code> が有効になるのは、ステートメントに対してバイナリロギングが行われる場合だけです。 バイナリロギングがサーバーで無効になっている場合、またはステートメントがフィルタによって削除されたためにバイナリログに書き込まれない場合、GTID の整合性は、ログに記録されていないステートメントに対してチェックまたは適用されません。 
    </p><p>
      GTID を有効にするときに必要なほかの起動オプションについては、<a class="xref" href="replication.html#replication-gtids-howto" title="17.1.3.4 GTID を使用したレプリケーションのセットアップ">セクション17.1.3.4「GTID を使用したレプリケーションのセットアップ」</a>を参照してください。
    </p><p><b>トランザクションのスキップ. </b>
        GTID ベースのレプリケーションを使用している場合、<code class="literal">sql_slave_skip_counter</code> は使用できません。 トランザクションをスキップする必要がある場合は、かわりにソース <code class="literal">gtid_executed</code> 変数の値を使用します。 <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントの <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> オプションを使用してレプリケーションチャネルで GTID 割当てを有効にした場合、<code class="literal">sql_slave_skip_counter</code> を使用できます。 詳細は、<a class="xref" href="replication.html#replication-administration-skip" title="17.1.7.3 トランザクションのスキップ">セクション17.1.7.3「トランザクションのスキップ」</a>を参照してください。 
      </p><p><b>サーバーの無視. </b>
        GTID を使用している場合、<code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントの「The IGNORE_SERVER_IDS」オプションは非推奨です。すでに適用されているトランザクションは自動的に無視されるためです。 GTID ベースのレプリケーションを開始する前に、関係するサーバーで以前に設定されたすべての無視されたサーバー ID リストを確認してクリアします。 個々のチャネルに対して発行できる <code class="literal">SHOW REPLICA | SLAVE STATUS</code> ステートメントには、無視されたサーバー ID のリストが表示されます (存在する場合)。 リストがない場合、<code class="literal">Replicate_Ignore_Server_Ids</code> フィールドは空白です。 
      </p><p><a name="replication-gtids-restrictions-mysql_upgrade"></a><b>GTID モードと mysql_upgrade. </b>
        MySQL 8.0.16 より前では、グローバルトランザクション識別子 (GTID) を有効にして (<code class="literal">gtid_mode=ON</code>) サーバーを実行している場合、<span class="command"><strong>mysql_upgrade</strong></span> (<code class="option">--write-binlog</code> オプション) によるバイナリロギングを有効にしないでください。 MySQL 8.0.16 の時点では、サーバーは MySQL アップグレード手順全体を実行しますが、アップグレード中はバイナリロギングを無効にするため、問題はありません。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-gtids-functions"></a>17.1.3.8 GTID を操作するストアドファンクションの例</h4></div></div></div><p>
      MySQL には、GTID ベースのレプリケーションで使用する組込み (ネイティブ) 関数がいくつか含まれています。 これらの関数は次のとおりです: 
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"> <code class="function">GTID_SUBSET(<em class="replaceable"><code>set1</code></em>,<em class="replaceable"><code>set2</code></em>)</code> </span></dt><dd><p>
            グローバルトランザクション識別子 <em class="replaceable"><code>set1</code></em> および <em class="replaceable"><code>set2</code></em> の 2 つのセットが指定されている場合、<em class="replaceable"><code>set1</code></em> 内のすべての GTID も <em class="replaceable"><code>set2</code></em> 内にあると true を返します。 それ以外の場合は、false  を返します。 
          </p></dd><dt><span class="term"> <code class="function">GTID_SUBTRACT(<em class="replaceable"><code>set1</code></em>,<em class="replaceable"><code>set2</code></em>)</code> </span></dt><dd><p>
            グローバルトランザクション識別子 <em class="replaceable"><code>set1</code></em> および <em class="replaceable"><code>set2</code></em> の 2 つのセットがある場合、<em class="replaceable"><code>set2</code></em> にない GTID のみを <em class="replaceable"><code>set1</code></em> から返します。
          </p></dd><dt><span class="term"> <code class="function">WAIT_FOR_EXECUTED_GTID_SET(<em class="replaceable"><code>gtid_set</code></em>[, <em class="replaceable"><code>timeout</code></em>])</code> </span></dt><dd><p>
            サーバーが、グローバルトランザクション識別子が <em class="replaceable"><code>gtid_set</code></em> に含まれているすべてのトランザクションを適用するまで待機します。 オプションのタイムアウトは、指定された秒数が経過すると、関数の待機を停止します。 
          </p></dd></dl></div><p>
      これらの関数の詳細は、<a class="xref" href="functions.html#gtid-functions" title="12.19 グローバルトランザクション識別子 (GTID) で使用される機能">セクション12.19「グローバルトランザクション識別子 (GTID) で使用される機能」</a> を参照してください。
    </p><p>
      GTID を操作する独自のストアドファンクションを定義できます。 ストアドファンクションの定義の詳細は、<a class="xref" href="stored-objects.html" title="第 25 章 ストアドオブジェクト">第25章「<i>ストアドオブジェクト</i>」</a> を参照してください。 次の例は、組込みの <code class="function">GTID_SUBSET()</code> および <code class="function">GTID_SUBTRACT()</code> 関数に基づいて作成できる便利なストアドファンクションを示しています。 
    </p><p>
      これらのストアドファンクションでは、次のように delimiter コマンドを使用して MySQL ステートメントデリミタを縦棒に変更しています:

</p><pre class="programlisting">mysql&gt; delimiter |</pre><p>
    </p><p>
      これらの関数はすべて GTID セットの文字列表現を引数として取るため、GTID セットと一緒に使用する場合は常に引用符で囲む必要があります。
    </p><p>
      この関数は、2 つの GTID セットが同じセットである場合、同じ方法で書式設定されていなくても、ゼロ以外 (true) を返します。

</p><pre class="programlisting">CREATE FUNCTION GTID_IS_EQUAL(gtid_set_1 LONGTEXT, gtid_set_2 LONGTEXT)
RETURNS INT
  RETURN GTID_SUBSET(gtid_set_1, gtid_set_2) AND GTID_SUBSET(gtid_set_2, gtid_set_1)|</pre><p>
    </p><p>
      この関数は、2 つの GTID セットが非結合の場合、ゼロ以外 (true) を返します。

</p><pre class="programlisting">CREATE FUNCTION GTID_IS_DISJOINT(gtid_set_1 LONGTEXT, gtid_set_2 LONGTEXT)
RETURNS INT
  RETURN GTID_SUBSET(gtid_set_1, GTID_SUBTRACT(gtid_set_1, gtid_set_2))|</pre><p>
    </p><p>
      この関数は、2 つの GTID セットが非結合で、<code class="literal">sum</code> が 2 つのセットの和集合である場合、ゼロ以外 (true) を返します。

</p><pre class="programlisting">CREATE FUNCTION GTID_IS_DISJOINT_UNION(gtid_set_1 LONGTEXT, gtid_set_2 LONGTEXT, sum LONGTEXT)
RETURNS INT
  RETURN GTID_IS_EQUAL(GTID_SUBTRACT(sum, gtid_set_1), gtid_set_2) AND
         GTID_IS_EQUAL(GTID_SUBTRACT(sum, gtid_set_2), gtid_set_1)|</pre><p>
    </p><p>
      この関数は、GTID セットの正規化された形式をすべて大文字で返します。空白はなく、重複もありません。 UUID はアルファベット順に配置され、間隔は数値順に配置されます。 

</p><pre class="programlisting">CREATE FUNCTION GTID_NORMALIZE(g LONGTEXT)
RETURNS LONGTEXT
RETURN GTID_SUBTRACT(g, '')|</pre><p>
    </p><p>
      この関数は、2 つの GTID セットの和集合を返します。

</p><pre class="programlisting">CREATE FUNCTION GTID_UNION(gtid_set_1 LONGTEXT, gtid_set_2 LONGTEXT)
RETURNS LONGTEXT
  RETURN GTID_NORMALIZE(CONCAT(gtid_set_1, ',', gtid_set_2))|</pre><p>
    </p><p>
      この関数は、2 つの GTID セットの交差を返します。

</p><pre class="programlisting">CREATE FUNCTION GTID_INTERSECTION(gtid_set_1 LONGTEXT, gtid_set_2 LONGTEXT)
RETURNS LONGTEXT
  RETURN GTID_SUBTRACT(gtid_set_1, GTID_SUBTRACT(gtid_set_1, gtid_set_2))|</pre><p>
    </p><p>
      この関数は、2 つの GTID セット (<code class="literal">gtid_set_1</code> には存在するが <code class="literal">gtid_set_2</code> には存在しない GTID) と、<code class="literal">gtid_set_2</code> には存在するが <code class="literal">gtid_set_1</code> には存在しない GTID の対称差異を戻します。

</p><pre class="programlisting">CREATE FUNCTION GTID_SYMMETRIC_DIFFERENCE(gtid_set_1 LONGTEXT, gtid_set_2 LONGTEXT)
RETURNS LONGTEXT
  RETURN GTID_SUBTRACT(CONCAT(gtid_set_1, ',', gtid_set_2), GTID_INTERSECTION(gtid_set_1, gtid_set_2))|</pre><p>
    </p><p>
      この関数は GTID セットから、指定された起点からすべての GTID を削除し、残りの GTID があればそれを返します。 UUID は、トランザクションが発生したサーバーで使用される識別子で、通常は <code class="literal">server_uuid</code> 値です。 

</p><pre class="programlisting">CREATE FUNCTION GTID_SUBTRACT_UUID(gtid_set LONGTEXT, uuid TEXT)
RETURNS LONGTEXT
  RETURN GTID_SUBTRACT(gtid_set, CONCAT(UUID, ':1-', (1 &lt;&lt; 63) - 2))|</pre><p>
    </p><p>
      この関数は、指定された識別子 (UUID) を持つサーバーから発生した GTID セットの GTID のみを返すように、以前に一覧表示された関数を逆にします。

</p><pre class="programlisting">CREATE FUNCTION GTID_INTERSECTION_WITH_UUID(gtid_set LONGTEXT, uuid TEXT)
RETURNS LONGTEXT
  RETURN GTID_SUBTRACT(gtid_set, GTID_SUBTRACT_UUID(gtid_set, uuid))|</pre><p>
    </p><div class="example"><a name="idm46723657993312"></a><p class="title"><b>例 17.1 レプリカが最新であることの確認</b></p><div class="example-contents"><p>
        組込み関数 <code class="function">GTID_SUBSET</code> および <code class="function">GTID_SUBTRACT</code> を使用すると、ソースが適用したすべてのトランザクションにレプリカが適用されているかどうかを確認できます。
      </p><p>
        <code class="function">GTID_SUBSET</code> でこのチェックを実行するには、レプリカで次のステートメントを実行します:

</p><pre class="programlisting">SELECT GTID_SUBSET(<em class="replaceable"><code>source_gtid_executed</code></em>, <em class="replaceable"><code>replica_gtid_executed</code></em>)</pre><p>

        これが 0 (false) を返す場合、<em class="replaceable"><code>source_gtid_executed</code></em> の GTID の一部が <em class="replaceable"><code>replica_gtid_executed</code></em> に存在しないため、レプリカが適用されていないトランザクションがソースによって適用されているため、レプリカは最新ではありません。
      </p><p>
        <code class="function">GTID_SUBTRACT</code> でチェックを実行するには、レプリカで次のステートメントを実行します:

</p><pre class="programlisting">SELECT GTID_SUBTRACT(<em class="replaceable"><code>source_gtid_executed</code></em>, <em class="replaceable"><code>replica_gtid_executed</code></em>)</pre><p>

        このステートメントは、<em class="replaceable"><code>source_gtid_executed</code></em> にはあるが <em class="replaceable"><code>replica_gtid_executed</code></em> にはない GTID を返します。 GTID が返された場合、ソースはレプリカが適用していない一部のトランザクションを適用しているため、レプリカは最新ではありません。 
      </p></div></div><br class="example-break"><div class="example"><a name="idm46723657981264"></a><p class="title"><b>例 17.2 バックアップおよびリストアのシナリオ</b></p><div class="example-contents"><p>
        ストアドファンクション <code class="function">GTID_IS_EQUAL</code>、<code class="function">GTID_IS_DISJOINT</code> および <code class="function">GTID_IS_DISJOINT_UNION</code> を使用して、複数のデータベースおよびサーバーに関連するバックアップおよびリストア操作を検証できます。 この例のシナリオでは、<code class="literal">server1</code> にデータベース <code class="literal">db1</code> が含まれ、<code class="literal">server2</code> にデータベース <code class="literal">db2</code> が含まれています。 目的は、データベース <code class="literal">db2</code> を <code class="literal">server1</code> にコピーし、<code class="literal">server1</code> での結果を 2 つのデータベースの和集合にすることです。 使用する手順は、<span class="command"><strong>mysqlpump</strong></span> または <span class="command"><strong>mysqldump</strong></span> を使用して <code class="literal">server2</code> をバックアップし、<code class="literal">server1</code> でこのバックアップをリストアすることです。 
      </p><p>
        バックアッププログラムオプション <code class="option">--set-gtid-purged</code> が <code class="literal">ON</code> に設定されているか、<code class="literal">AUTO</code> のデフォルトに設定されている場合、プログラム出力には <code class="literal">SET @@GLOBAL.gtid_purged</code> ステートメントが含まれ、<code class="literal">gtid_executed</code> セットを <code class="literal">server2</code> から <code class="literal">server1</code> の <code class="literal">gtid_purged</code> に追加します。 <code class="literal">gtid_purged</code> セットには、サーバー上でコミットされたが、サーバー上のバイナリログファイルに存在しないすべてのトランザクションの GTID が含まれています。 データベース <code class="literal">db2</code> を <code class="literal">server1</code> にコピーする場合、<code class="literal">server1</code> のバイナリログファイルにない <code class="literal">server2</code> でコミットされたトランザクションの GTID を <code class="literal">server1</code> の <code class="literal">gtid_purged</code> セットに追加して、セットを完成させる必要があります。 
      </p><p>
        ストアドファンクションを使用すると、このシナリオの次のステップを実行できます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="function">GTID_IS_EQUAL</code> を使用して、バックアップ操作によって <code class="literal">SET @@GLOBAL.gtid_purged</code> ステートメントの正しい GTID セットが計算されたことを確認します。 <code class="literal">server2</code> では、<span class="command"><strong>mysqlpump</strong></span> または <span class="command"><strong>mysqldump</strong></span> の出力からそのステートメントを抽出し、GTID セットを <code class="varname">$gtid_purged_set</code> などのローカル変数に格納します。 次に、次のステートメントを実行します: 

</p><pre class="programlisting">server2&gt; SELECT GTID_IS_EQUAL($gtid_purged_set, @@GLOBAL.gtid_executed); </pre><p>

            結果が 1 の場合、2 つの GTID セットは等しく、セットは正しく計算されています。
          </p></li><li class="listitem"><p>
            <code class="function">GTID_IS_DISJOINT</code> を使用して、<span class="command"><strong>mysqlpump</strong></span> または <span class="command"><strong>mysqldump</strong></span> 出力の GTID セットが <code class="literal">server1</code> の <code class="literal">gtid_executed</code> セットと重複していないことを確認します。 両方のサーバーに同一の GTID が存在すると、データベース <code class="literal">db2</code> を <code class="literal">server1</code> にコピーするときにエラーが発生します。 確認するには、<code class="literal">server1</code> で、前述のように出力から <code class="literal">gtid_purged</code> セットを抽出してローカル変数に格納し、次のステートメントを実行します: 

</p><pre class="programlisting">server1&gt; SELECT GTID_IS_DISJOINT($gtid_purged_set, @@GLOBAL.gtid_executed); </pre><p>

            結果が 1 の場合、2 つの GTID セット間に重複がないため、重複する GTID は存在しません。
          </p></li><li class="listitem"><p>
            <code class="function">GTID_IS_DISJOINT_UNION</code> を使用して、リストア操作が <code class="literal">server1</code> で正しい GTID 状態になったことを確認します。 バックアップをリストアする前に、<code class="literal">server1</code> で次のステートメントを実行して既存の <code class="literal">gtid_executed</code> セットを取得します: 

</p><pre class="programlisting">server1&gt; SELECT @@GLOBAL.gtid_executed;</pre><p>

            結果をローカル変数 <code class="varname">$original_gtid_executed</code> に格納します。 また、前述のように、<code class="literal">gtid_purged</code> セットをローカル変数に格納します。 <code class="literal">server2</code> からのバックアップが <code class="literal">server1</code> にリストアされたら、次のステートメントを実行して GTID 状態を確認します: 

</p><pre class="programlisting">server1&gt; SELECT GTID_IS_DISJOINT_UNION($original_gtid_executed,
                                       $gtid_purged_set,
                                       @@GLOBAL.gtid_executed); </pre><p>

            結果が 1 の場合、ストアドファンクションは、<code class="literal">server1</code> (<code class="varname">$original_gtid_executed</code>) からの元の <code class="literal">gtid_executed</code> セットと <code class="literal">server2</code> (<code class="varname">$gtid_purged_set</code>) から追加された <code class="literal">gtid_purged</code> セットが重複していないことを検証し、<code class="literal">server1</code> で更新された <code class="literal">gtid_executed</code> セットが、<code class="literal">server1</code> からの以前の <code class="literal">gtid_executed</code> セットと <code class="literal">server2</code> からの <code class="literal">gtid_purged</code> セットで構成されるようになりました。これが目的の結果です。 <code class="literal">server1</code> でこれ以上のトランザクションが実行される前に、このチェックが実行されていることを確認してください。実行されていない場合、<code class="literal">gtid_executed</code> セットの新しいトランザクションが失敗します。 
          </p></li></ul></div></div></div><br class="example-break"><div class="example"><a name="idm46723657915520"></a><p class="title"><b>例 17.3 手動フェイルオーバー用の最新レプリカの選択</b></p><div class="example-contents"><p>
        ストアドファンクション <code class="function">GTID_UNION</code> を使用すると、ソースサーバーが予期せず停止した後に手動フェイルオーバー操作を実行するために、レプリカのセットから最新のレプリカを識別できます。 一部のレプリカでレプリケーションラグが発生している場合、このストアドファンクションを使用すると、すべてのレプリカが既存のリレーログを適用するのを待機せずに最新のレプリカを計算できるため、フェイルオーバー時間を最小限に抑えることができます。 この関数は、「パフォーマンススキーマ」テーブル <code class="literal">replication_connection_status</code> に記録されているレプリカが受信したトランザクションのセットを使用して、各レプリカの <code class="literal">gtid_executed</code> セットの和集合を戻すことができます。 これらの結果を比較して、すべてのトランザクションがまだコミットされていない場合でも、最新のトランザクションのレプリカレコードを検索できます。 
      </p><p>
        各レプリカで、次のステートメントを発行してトランザクションの完全なレコードを計算します:

</p><pre class="programlisting">SELECT GTID_UNION(RECEIVED_TRANSACTION_SET, @@GLOBAL.gtid_executed)
    FROM performance_schema.replication_connection_status
    WHERE channel_name = 'name';</pre><p>

        その後、各レプリカの結果を比較してトランザクションの最新レコードを確認し、このレプリカを新しいソースとして使用できます。
      </p></div></div><br class="example-break"><div class="example"><a name="idm46723657907104"></a><p class="title"><b>例 17.4 レプリカ上の無関係なトランザクションのチェック</b></p><div class="example-contents"><p>
        ストアドファンクション <code class="function">GTID_SUBTRACT_UUID</code> を使用すると、指定されたソースから発生しなかったトランザクションをレプリカが受信したかどうかを確認できます。 その場合は、レプリケーションの設定、またはプロキシ、ルーターまたはロードバランサに問題がある可能性があります。 この機能は、GTID セットから指定された発信元サーバーからすべての GTID を削除し、残りの GTID があればそれを返すことによって機能します。 
      </p><p>
        単一のソースからレプリケートするレプリカの場合、次のステートメントを発行し、元のソースの識別子 (通常は <code class="literal">server_uuid</code> 値) を指定します:

</p><pre class="programlisting">SELECT GTID_SUBTRACT_UUID(@@GLOBAL.gtid_executed, server_uuid_of_source);</pre><p>

        結果が空でない場合、返されるトランザクションは、指定されたソースから発生しなかった余分なトランザクションです。
      </p><p>
        マルチソースレプリケーショントポロジのレプリカの場合は、次の例のように機能を繰り返します:

</p><pre class="programlisting">SELECT GTID_SUBTRACT_UUID(GTID_SUBTRACT_UUID(@@GLOBAL.gtid_executed,
                                             server_uuid_of_source_1),
                                             server_uuid_of_source_2);</pre><p>

        結果が空でない場合、返されるトランザクションは、指定されたどのソースからも発生しなかった余分なトランザクションです。
      </p></div></div><br class="example-break"><div class="example"><a name="idm46723657898848"></a><p class="title"><b>例 17.5 レプリケーショントポロジ内のサーバーが読取り専用であることの確認</b></p><div class="example-contents"><p>
        ストアドファンクション <code class="function">GTID_INTERSECTION_WITH_UUID</code> を使用すると、サーバーが GTID を発生させておらず、読取り専用状態であることを検証できます。 この関数は、指定された識別子を持つサーバーから発生した GTID セットから GTID のみを返します。 サーバー <code class="literal">gtid_executed</code> セット内のいずれかのトランザクションにサーバー独自の識別子がある場合、サーバー自体がそれらのトランザクションを開始しています。 サーバーで次のステートメントを発行して確認できます: 

</p><pre class="programlisting">SELECT GTID_INTERSECTION_WITH_UUID(@@GLOBAL.gtid_executed, my_server_uuid);</pre><p>
      </p></div></div><br class="example-break"><div class="example"><a name="idm46723657893696"></a><p class="title"><b>例 17.6 マルチソースレプリケーション設定での追加レプリカの検証</b></p><div class="example-contents"><p>
        ストアドファンクション <code class="function">GTID_INTERSECTION_WITH_UUID</code> を使用すると、マルチソースレプリケーション設定にアタッチされたレプリカが、特定のソースから発生したすべてのトランザクションを適用したかどうかを確認できます。 このシナリオでは、<code class="literal">source1</code> と <code class="literal">source2</code> の両方がソースとレプリカであり、相互にレプリケートされます。<code class="literal">source2</code> には、独自のレプリカもあります。 また、<code class="literal">source2</code> が <code class="literal">log_slave_updates=ON</code> で構成されている場合、レプリカはソース <code class="literal">source1</code> からトランザクションを受信して適用しますが、<code class="literal">source2</code> が <code class="literal">log_slave_updates=OFF</code> を使用している場合は行いません。 いずれの場合も、現在、レプリカが <code class="literal">source2</code> で最新であるかどうかのみを確認します。 この状況では、ストアドファンクション <code class="function">GTID_INTERSECTION_WITH_UUID</code> を使用して、<code class="literal">source2</code> が発生させたトランザクションを識別し、<code class="literal">source2</code> が <code class="literal">source1</code> からレプリケートしたトランザクションを破棄できます。 その後、組込み関数 <code class="function">GTID_SUBSET</code> を使用して、結果をレプリカ上の <code class="literal">gtid_executed</code> セットと比較できます。 レプリカが <code class="literal">source2</code> で最新の場合、レプリカに設定されている <code class="literal">gtid_executed</code> には交差セット (<code class="literal">source2</code> から発生したトランザクション) 内のすべてのトランザクションが含まれます。 
      </p><p>
        このチェックを実行するには、次のように、<code class="literal">source2</code> の <code class="literal">gtid_executed</code> セット、<code class="literal">source2</code> のサーバー UUID およびレプリカ <code class="literal">gtid_executed</code> セットをクライアント側の変数に格納します:

</p><pre class="programlisting">    $source2_gtid_executed :=
      source2&gt; SELECT @@GLOBAL.gtid_executed;
    $source2_server_uuid :=
      source2&gt; SELECT @@GLOBAL.server_uuid;
    $replica_gtid_executed :=
      replica&gt; SELECT @@GLOBAL.gtid_executed;</pre><p>

        次に、次のように、これらの変数を入力として <code class="function">GTID_INTERSECTION_WITH_UUID</code> および <code class="function">GTID_SUBSET</code> を使用します:

</p><pre class="programlisting">SELECT GTID_SUBSET(GTID_INTERSECTION_WITH_UUID($source2_gtid_executed,
                                               $source2_server_uuid),
                                               $replica_gtid_executed);</pre><p>
      </p><p>
        <code class="literal">source2</code> (<code class="varname">$source2_server_uuid</code>) のサーバー識別子は、<code class="literal">source1</code> で発生した GTID を除外して、<code class="literal">source2</code> の <code class="literal">gtid_executed</code> セットからの GTID のみを識別して返すために <code class="literal">GTID_INTERSECTION_WITH_UUID</code> とともに使用されます。 結果の GTID セットは、<code class="function">GTID_SUBSET</code> を使用して、レプリカで実行されたすべての GTID のセットと比較されます。 このステートメントがゼロ以外 (true) を返す場合、<code class="literal">source2</code> から識別された GTID (最初のセット入力) もすべてレプリカ <code class="literal">gtid_executed</code> セット (2 番目のセット入力) に含まれます。つまり、レプリカは <code class="literal">source2</code> から発生したすべてのトランザクションをレプリケートしています。 
      </p></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-mode-change-online"></a>17.1.4 オンラインサーバーでの GTID モードの変更</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-mode-change-online-concepts">17.1.4.1 レプリケーションモードの概念</a></span></dt><dt><span class="section"><a href="replication.html#replication-mode-change-online-enable-gtids">17.1.4.2 GTID トランザクションのオンラインでの有効化</a></span></dt><dt><span class="section"><a href="replication.html#replication-mode-change-online-disable-gtids">17.1.4.3 GTID トランザクションのオンラインでの無効化</a></span></dt><dt><span class="section"><a href="replication.html#replication-mode-change-online-verify-transactions">17.1.4.4 匿名トランザクションのレプリケーションの検証</a></span></dt></dl></div><a class="indexterm" name="idm46723657856688"></a><p>
    このセクションでは、サーバーをオフラインにせずに GTID モードとの間でレプリケーションのモードを変更する方法について説明します。
  </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-mode-change-online-concepts"></a>17.1.4.1 レプリケーションモードの概念</h4></div></div></div><a class="indexterm" name="idm46723657853568"></a><p>
      オンラインサーバーのレプリケーションモードを安全に構成できるようにするには、レプリケーションのいくつかの重要な概念を理解することが重要です。 このセクションでは、オンラインサーバーのレプリケーションモードを変更する前に、これらの概念について説明し、不可欠な読み取り値を示します。 
    </p><p>
      MySQL で使用可能なレプリケーションのモードは、ログに記録されるトランザクションを識別するための様々な手法に依存します。 レプリケーションで使用されるトランザクションのタイプは次のとおりです: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          GTID トランザクションは、<code class="literal">UUID:NUMBER</code> 形式のグローバルトランザクション識別子 (GTID) によって識別されます。 ログ内の GTID トランザクションはすべて、常に <code class="literal">Gtid_log_event</code> で始まります。 GTID トランザクションは GTID を使用するか、ファイル名とポジションを使用して対処できます。 
        </p></li><li class="listitem"><p>
          匿名トランザクションに GTID が割り当てられておらず、MySQL はログ内のすべての匿名トランザクションの前に <code class="literal">Anonymous_gtid_log_event</code> があることを確認します。 以前のバージョンでは、匿名トランザクションの前に特定のイベントはありませんでした。 匿名トランザクションは、ファイル名と位置を使用してのみ処理できます。 
        </p></li></ul></div><p>
      GTID を使用する場合は、GTID 自動配置および自動フェイルオーバーを利用したり、<code class="literal">WAIT_FOR_EXECUTED_GTID_SET()</code>、<code class="literal">session_track_gtids</code> を使用したり、「パフォーマンススキーマ」テーブルを使用してレプリケートされたトランザクションをモニターしたりできます。
    </p><p>
      以前のバージョンの MySQL を実行しているソースから受信されたリレーログ内のトランザクションの前には、特定のイベントがまったく表示されない場合がありますが、リプレイされてレプリカバイナリログに記録されたあとは、それらのトランザクションの前に <code class="literal">Anonymous_gtid_log_event</code> が付きます。
    </p><p>
      レプリケーションモードをオンラインで構成する機能は、<code class="literal">gtid_mode</code> 変数と <code class="literal">enforce_gtid_consistency</code> 変数の両方が動的になり、グローバルシステム変数の設定に十分な権限を持つアカウントによって最上位レベルのステートメントから設定できることを意味します。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 MySQL 5.6 以前では、これらの変数は両方とも、サーバーの起動時に適切なオプションを使用してのみ構成できました。つまり、レプリケーションモードへの変更にはサーバーの再起動が必要でした。 すべてのバージョンで、<code class="literal">gtid_mode</code> を <code class="literal">ON</code> または <code class="literal">OFF</code> に設定でき、GTID がトランザクションの識別に使用されたかどうかに対応します。 <code class="literal">gtid_mode=ON</code> で匿名トランザクションをレプリケートできない場合、および <code class="literal">gtid_mode=OFF</code> でレプリケートできるのは匿名トランザクションのみです。 <code class="literal">gtid_mode=OFF_PERMISSIVE</code> の場合、<span class="emphasis"><em>new</em></span> トランザクションは匿名ですが、レプリケートされたトランザクションを GTID または匿名トランザクションにすることを許可します。 <code class="literal">gtid_mode=ON_PERMISSIVE</code> の場合、<span class="emphasis"><em>new</em></span> トランザクションは GTID を使用しますが、レプリケートされたトランザクションを GTID または匿名トランザクションにすることを許可します。 つまり、匿名トランザクションと GTID トランザクションの両方を使用するサーバーを持つレプリケーショントポロジを使用できます。 たとえば、<code class="literal">gtid_mode=ON</code> を含むソースは、<code class="literal">gtid_mode=ON_PERMISSIVE</code> を使用してレプリカにレプリケートできます。 <code class="literal">gtid_mode</code> の有効な値は次のとおりで、順序は次のとおりです: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">OFF</code>
        </p></li><li class="listitem"><p>
          <code class="literal">OFF_PERMISSIVE</code>
        </p></li><li class="listitem"><p>
          <code class="literal">ON_PERMISSIVE</code>
        </p></li><li class="listitem"><p>
          <code class="literal">ON</code>
        </p></li></ul></div><p>
      <code class="literal">gtid_mode</code> の状態は、前述の順序に基づいて一度に 1 つのステップでのみ変更できることに注意してください。 たとえば、<code class="literal">gtid_mode</code> が現在 <code class="literal">OFF_PERMISSIVE</code> に設定されている場合、<code class="literal">OFF</code> または <code class="literal">ON_PERMISSIVE</code> に変更できますが、<code class="literal">ON</code> には変更できません。 これは、匿名トランザクションから GTID トランザクションへの変更プロセスがサーバーによって正しく処理されるようにするためです。 <code class="literal">gtid_mode=ON</code> と <code class="literal">gtid_mode=OFF</code> を切り替えると、GTID 状態 (つまり、<code class="literal">gtid_executed</code> の値) は永続的になります。 これにより、<code class="literal">gtid_mode</code> のタイプ間の変更に関係なく、サーバーによって適用された GTID セットが常に保持されます。 
    </p><p>
      GTID に関連するフィールドには、現在選択されている <code class="literal">gtid_mode</code> に関係なく、正しい情報が表示されます。 つまり、GTID セットを表示するフィールド (<code class="literal">replication_connection_status</code>「パフォーマンススキーマ」テーブルの <code class="literal">gtid_executed</code>, <code class="literal">gtid_purged</code>, <code class="literal">RECEIVED_TRANSACTION_SET</code> など) および <code class="literal">SHOW REPLICA | SLAVE STATUS</code> の GTID 関連の結果は、GTID が存在しない場合に空の文字列を返すようになりました。 GTID トランザクションが使用されていないときに、パフォーマンススキーマ <code class="literal">replication_applier_status_by_worker</code> テーブル内の <code class="literal">CURRENT_TRANSACTION</code> などの単一 GTID を表示するフィールドに <code class="literal">ANONYMOUS</code> が表示されるようになりました。 
    </p><p>
      <code class="literal">gtid_mode=ON</code> を使用するソースからのレプリケーションでは、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23 から) の <code class="literal">SOURCE_AUTO_POSITION</code>、または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 より前) の <code class="literal">MASTER_AUTO_POSITION</code> を使用して構成された GTID 自動配置を使用できます。 使用されるレプリケーショントポロジは、自動配置を有効にできるかどうかに影響します。この機能は GTID に依存し、匿名トランザクションと互換性がないためです。 自動配置を有効にする前に、トポロジに匿名トランザクションが残っていないことを確認することを強くお薦めします。<a class="xref" href="replication.html#replication-mode-change-online-enable-gtids" title="17.1.4.2 GTID トランザクションのオンラインでの有効化">セクション17.1.4.2「GTID トランザクションのオンラインでの有効化」</a> を参照してください。 
    </p><p>
      次のテーブルに、<code class="literal">gtid_mode</code> とソースおよびレプリカでの自動配置の有効な組合せを示します。ここで、ソース <code class="literal">gtid_mode</code> は水平方向に、レプリカ <code class="literal">gtid_mode</code> は垂直方向に表示されます。 各エントリの意味は次のとおりです: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">Y</code>: ソースとレプリカの <code class="literal">gtid_mode</code> に互換性があります
        </p></li><li class="listitem"><p>
          <code class="literal">N</code>: ソースとレプリカの <code class="literal">gtid_mode</code> に互換性がありません
        </p></li><li class="listitem"><p>
          <code class="literal">*</code>: この組合せでは自動配置を使用できます
        </p></li></ul></div><div class="table"><a name="idm46723657779040"></a><p class="title"><b>表 17.1 ソースとレプリカ gtid_mode の有効な組合せ</b></p><div class="table-contents"><table summary="Explains compatible (Y) and incompatible (N) combinations of master and slave GTID mode. An asterisk (*) indicates that auto-positioning can be used with this combination of GTID modes."><col style="width=26%"><col style="width=12%"><col style="width=24%"><col style="width=24%"><col style="width=12%"><thead><tr>
          <th scope="col"><p>
              <code class="literal">gtid_mode</code>
            </p></th>
          <th scope="col"><p>
              ソース <code class="literal">OFF</code>
            </p></th>
          <th scope="col"><p>
              ソース <code class="literal">OFF_PERMISSIVE</code>
            </p></th>
          <th scope="col"><p>
              ソース <code class="literal">ON_PERMISSIVE</code>
            </p></th>
          <th scope="col"><p>
              ソース <code class="literal">ON</code>
            </p></th>
        </tr></thead><tbody><tr>
          <th scope="row"><p>
              レプリカ <code class="literal">OFF</code>
            </p></th>
          <td><p>
              Y
            </p></td>
          <td><p>
              Y
            </p></td>
          <td><p>
              N
            </p></td>
          <td><p>
              N
            </p></td>
        </tr><tr>
          <th scope="row"><p>
              レプリカ <code class="literal">OFF_PERMISSIVE</code>
            </p></th>
          <td><p>
              Y
            </p></td>
          <td><p>
              Y
            </p></td>
          <td><p>
              Y
            </p></td>
          <td><p>
              Y*
            </p></td>
        </tr><tr>
          <th scope="row"><p>
              レプリカ <code class="literal">ON_PERMISSIVE</code>
            </p></th>
          <td><p>
              Y
            </p></td>
          <td><p>
              Y
            </p></td>
          <td><p>
              Y
            </p></td>
          <td><p>
              Y*
            </p></td>
        </tr><tr>
          <th scope="row"><p>
              レプリカ <code class="literal">ON</code>
            </p></th>
          <td><p>
              N
            </p></td>
          <td><p>
              N
            </p></td>
          <td><p>
              Y
            </p></td>
          <td><p>
              Y*
            </p></td>
        </tr></tbody></table></div></div><br class="table-break"><p>
      現在選択されている <code class="literal">gtid_mode</code> は、<code class="literal">gtid_next</code> 変数にも影響します。 次のテーブルに、<code class="literal">gtid_mode</code> および <code class="literal">gtid_next</code> の様々な値に対するサーバーの動作を示します。 各エントリの意味は次のとおりです: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">ANONYMOUS</code>: 匿名トランザクションを生成します。
        </p></li><li class="listitem"><p>
          <code class="literal">Error</code>: エラーを生成し、<code class="literal">SET GTID_NEXT</code> の実行に失敗します。
        </p></li><li class="listitem"><p>
          <code class="literal">UUID:NUMBER</code> : 指定された UUID:NUMBER の GTID を生成します。
        </p></li><li class="listitem"><p>
          <code class="literal">New GTID</code>: 自動生成された番号を使用して GTID を生成します。
        </p></li></ul></div><div class="table"><a name="idm46723657724288"></a><p class="title"><b>表 17.2 gtid_mode と gtid_next の有効な組合せ</b></p><div class="table-contents"><table summary="Explains the behavior for each of the possible combinations of GTID mode and setting for the gtid_next variable. With gtid_next set to AUTOMATIC, the behavior also varies depending on whether binary logging is enabled or disabled."><col style="width=20%"><col style="width=20%"><col style="width=20%"><col style="width=20%"><col style="width=20%"><thead><tr>
          <th scope="col"></th>
          <th scope="col"><p>
              <code class="literal">gtid_next</code> AUTOMATIC
            </p><p>
              バイナリログオン
            </p></th>
          <th scope="col"><p>
              <code class="literal">gtid_next</code> AUTOMATIC
            </p><p>
              バイナリログオフ
            </p></th>
          <th scope="col"><p>
              <code class="literal">gtid_next</code> ANONYMOUS
            </p></th>
          <th scope="col"><p>
              <code class="literal">gtid_next</code> UUID:NUMBER
            </p></th>
        </tr></thead><tbody><tr>
          <th scope="row"><p>
              <code class="literal">gtid_mode</code> <code class="literal">OFF</code>
            </p></th>
          <td><p>
              ANONYMOUS
            </p></td>
          <td><p>
              ANONYMOUS
            </p></td>
          <td>ANONYMOUS</td>
          <td><p>
              エラー
            </p></td>
        </tr><tr>
          <th scope="row"><p>
              <code class="literal">gtid_mode</code> <code class="literal">OFF_PERMISSIVE</code>
            </p></th>
          <td><p>
              ANONYMOUS
            </p></td>
          <td><p>
              ANONYMOUS
            </p></td>
          <td><p>
              ANONYMOUS
            </p></td>
          <td><p>
              UUID:NUMBER
            </p></td>
        </tr><tr>
          <th scope="row"><p>
              <code class="literal">gtid_mode</code> <code class="literal">ON_PERMISSIVE</code>
            </p></th>
          <td><p>
              新規 GTID
            </p></td>
          <td><p>
              ANONYMOUS
            </p></td>
          <td><p>
              ANONYMOUS
            </p></td>
          <td><p>
              UUID:NUMBER
            </p></td>
        </tr><tr>
          <th scope="row"><p>
              <code class="literal">gtid_mode</code> <code class="literal">ON</code>
            </p></th>
          <td><p>
              新規 GTID
            </p></td>
          <td><p>
              ANONYMOUS
            </p></td>
          <td><p>
              エラー
            </p></td>
          <td><p>
              UUID:NUMBER
            </p></td>
        </tr></tbody></table></div></div><br class="table-break"><p>
      バイナリログがオフで、<code class="literal">gtid_next</code> が <code class="literal">AUTOMATIC</code> に設定されている場合、GTID は生成されません。 これは、以前のバージョンの動作と一貫性があります。 
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-mode-change-online-enable-gtids"></a>17.1.4.2 GTID トランザクションのオンラインでの有効化</h4></div></div></div><a class="indexterm" name="idm46723657673008"></a><p>
      このセクションでは、すでにオンラインで匿名トランザクションを使用しているサーバー上で GTID トランザクションを有効にし、オプションで自動配置を有効にする方法について説明します。 この手順では、サーバーをオフラインにする必要はなく、本番での使用に適しています。 ただし、GTID トランザクションを有効にするときにサーバーをオフラインにできる可能性がある場合は、プロセスが容易です。 
    </p><p>
      MySQL 8.0.23 から、GTID がまだないレプリケートされたトランザクションに GTID を割り当てるようにレプリケーションチャネルを設定できます。 この機能により、GTID ベースのレプリケーションを使用しないソースサーバーから使用するレプリカへのレプリケーションが可能になります。 この手順で説明されているように、レプリケーションソースサーバーで GTID を有効にできる場合は、代わりにこの方法を使用します。 GTID の割当ては、GTID を有効にできないレプリケーションソースサーバー用に設計されています。 このオプションの詳細は、<a class="xref" href="replication.html#replication-gtids-assign-anon" title="17.1.3.6 GTID のないソースから GTID のあるレプリカへのレプリケーション">セクション17.1.3.6「GTID のないソースから GTID のあるレプリカへのレプリケーション」</a> を参照してください。 
    </p><p>
      起動する前に、サーバーが次の事前条件を満たしていることを確認します:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          トポロジ内の <span class="emphasis"><em>All</em></span> サーバーは、MySQL 5.7.6 以上を使用する必要があります。 トポロジ内の <span class="emphasis"><em>all</em></span> サーバーがこのバージョンを使用していないかぎり、GTID トランザクションを単一のサーバーでオンラインで有効にすることはできません。 
        </p></li><li class="listitem"><p>
          すべてのサーバーで、<code class="literal">gtid_mode</code> がデフォルト値の <code class="literal">OFF</code> に設定されています。
        </p></li></ul></div><p>
      次の手順は、GTID を無効にするオンライン手順である <a class="xref" href="replication.html#replication-mode-change-online-disable-gtids" title="17.1.4.3 GTID トランザクションのオンラインでの無効化">セクション17.1.4.3「GTID トランザクションのオンラインでの無効化」</a> の対応する手順にジャンプすることで、いつでも一時停止してあとで再開できます。 これにより、プロシージャの途中で発生する関連のない問題は通常どおりに処理でき、その後、プロシージャは停止した場所で続行されるため、プロシージャはフォルトトレラントになります。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        次のステップに進む前に、すべてのステップを完了することが重要です。
      </p></div><p>
      GTID トランザクションを使用可能にする手順は、次のとおりです:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          各サーバーで、次のコマンドを実行します:
        </p><pre class="programlisting">SET @@GLOBAL.ENFORCE_GTID_CONSISTENCY = WARN;</pre><p>
          通常のワークロードでサーバーをしばらく実行し、ログを監視します。 このステップでログに警告が発生した場合は、GTID 互換機能のみを使用し、警告を生成しないようにアプリケーションを調整します。 
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
            これは最初の重要なステップです。 次のステップに進む前に、エラーログに警告が生成されていないことを確認する必要があります。 
          </p></div></li><li class="listitem"><p>
          各サーバーで、次のコマンドを実行します:
        </p><pre class="programlisting">SET @@GLOBAL.ENFORCE_GTID_CONSISTENCY = ON;</pre></li><li class="listitem"><p>
          各サーバーで、次のコマンドを実行します:
        </p><pre class="programlisting">SET @@GLOBAL.GTID_MODE = OFF_PERMISSIVE;</pre><p>
          どのサーバーがこのステートメントを最初に実行するかは関係ありませんが、すべてのサーバーが次のステップを開始する前にこのステップを完了することが重要です。
        </p></li><li class="listitem"><p>
          各サーバーで、次のコマンドを実行します:
        </p><pre class="programlisting">SET @@GLOBAL.GTID_MODE = ON_PERMISSIVE;</pre><p>
          どのサーバーがこのステートメントを最初に実行するかは関係ありません。
        </p></li><li class="listitem"><p>
          各サーバーで、ステータス変数 <code class="literal">ONGOING_ANONYMOUS_TRANSACTION_COUNT</code> がゼロになるまで待機します。 これは、次を使用してチェックできます: 
        </p><pre class="programlisting">SHOW STATUS LIKE 'ONGOING_ANONYMOUS_TRANSACTION_COUNT';</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            レプリカでは、理論的にはゼロを表示してから再度ゼロ以外を表示することが可能です。 これは問題ではなく、一度はゼロと表示されます。 
          </p></div></li><li class="listitem"><p>
          ステップ 5 までに生成されたすべてのトランザクションがすべてのサーバーにレプリケートされるまで待機します。 これは、更新を停止せずに実行できます: 唯一重要なのは、すべての匿名トランザクションがレプリケートされることです。 
        </p><p>
          すべての匿名トランザクションがすべてのサーバーにレプリケートされたことを確認する方法については、<a class="xref" href="replication.html#replication-mode-change-online-verify-transactions" title="17.1.4.4 匿名トランザクションのレプリケーションの検証">セクション17.1.4.4「匿名トランザクションのレプリケーションの検証」</a> を参照してください。
        </p></li><li class="listitem"><p>
          ポイントインタイムバックアップやリストアなど、レプリケーション以外にバイナリログを使用する場合は、GTID のないトランザクションを含む古いバイナリログが不要になるまで待機します。
        </p><p>
          たとえば、ステップ 6 の完了後、バックアップを作成しているサーバーで <code class="literal">FLUSH LOGS</code> を実行できます。 次に、明示的にバックアップを取るか、設定した定期バックアップルーチンの次の反復を待機します。 
        </p><p>
          理想的には、ステップ 6 の完了時に存在していたすべてのバイナリログがサーバーによってパージされるまで待機します。 また、ステップ 6 より前に作成したバックアップが期限切れになるまで待機します。 
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
            これは 2 番目の重要な点です。 GTID のない匿名トランザクションを含むバイナリログは、次の手順のあとに使用できないことを理解することが不可欠です。 このステップの後、GTID のないトランザクションがトポロジ内のどこにも存在しないことを確認する必要があります。 
          </p></div></li><li class="listitem"><p>
          各サーバーで、次のコマンドを実行します:
        </p><pre class="programlisting">SET @@GLOBAL.GTID_MODE = ON;</pre></li><li class="listitem"><p>
          各サーバーで、<code class="literal">gtid_mode=ON</code> および <code class="literal">enforce_gtid_consistency=ON</code> を <code class="filename">my.cnf</code> に追加します。
        </p><p>
          すべてのトランザクションに GTID があることが保証されるようになりました (ステップ 5 以前で生成され、すでに処理されたトランザクションを除く)。 GTID プロトコルの使用を開始して後で自動フェイルオーバーを実行できるようにするには、各レプリカで次を実行します。 オプションで、マルチソースレプリケーションを使用する場合は、チャネルごとにこれを行い、<code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を含めます: 
        </p><pre class="programlisting">STOP SLAVE [FOR CHANNEL 'channel'];
CHANGE MASTER TO MASTER_AUTO_POSITION = 1 [FOR CHANNEL 'channel'];
START SLAVE [FOR CHANNEL 'channel'];

Or from MySQL 8.0.22 / 8.0.23:
STOP REPLICA [FOR CHANNEL 'channel'];
CHANGE REPLICATION SOURCE TO SOURCE_AUTO_POSITION = 1 [FOR CHANNEL 'channel'];
START REPLICA [FOR CHANNEL 'channel'];
</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-mode-change-online-disable-gtids"></a>17.1.4.3 GTID トランザクションのオンラインでの無効化</h4></div></div></div><a class="indexterm" name="idm46723657622640"></a><p>
      このセクションでは、すでにオンラインになっているサーバーで GTID トランザクションを無効にする方法について説明します。 この手順では、サーバーをオフラインにする必要はなく、本番での使用に適しています。 ただし、GTID モードを無効にするときにサーバーをオフラインにする可能性がある場合は、そのプロセスが容易になります。 
    </p><p>
      このプロセスは、サーバーがオンラインのときに GTID トランザクションを有効にする場合と似ていますが、手順は逆になります。 異なるのは、ログに記録されたトランザクションがレプリケートされるまで待機するポイントのみです。 
    </p><p>
      起動する前に、サーバーが次の事前条件を満たしていることを確認します:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          トポロジ内の <span class="emphasis"><em>All</em></span> サーバーは、MySQL 5.7.6 以上を使用する必要があります。 トポロジ内の <span class="emphasis"><em>all</em></span> サーバーがこのバージョンを使用していないかぎり、GTID トランザクションを単一のサーバーでオンラインで無効にすることはできません。 
        </p></li><li class="listitem"><p>
          すべてのサーバーで、<code class="literal">gtid_mode</code> が <code class="literal">ON</code> に設定されています。
        </p></li><li class="listitem"><p>
          <code class="option">--replicate-same-server-id</code> オプションがどのサーバーにも設定されていません。 このオプションが <code class="option">--log-slave-updates</code> オプション (デフォルト) とともに設定され、バイナリロギングが有効 (デフォルト) である場合は、GTID トランザクションを無効にできません。 GTID を使用しない場合、このオプションの組み合わせによって循環レプリケーションで無限ループが発生します。 
        </p></li></ul></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          各レプリカで次を実行し、マルチソースレプリケーションを使用している場合は、チャネルごとに実行し、<code class="literal">FOR CHANNEL</code> チャネル句を含めます:
        </p><pre class="programlisting">STOP SLAVE [FOR CHANNEL 'channel'];
CHANGE MASTER TO MASTER_AUTO_POSITION = 0, MASTER_LOG_FILE = file, \
MASTER_LOG_POS = position [FOR CHANNEL 'channel'];
START SLAVE [FOR CHANNEL 'channel'];

Or from MySQL 8.0.22 / 8.0.23:
STOP REPLICA [FOR CHANNEL 'channel'];
CHANGE REPLICATION SOURCE TO SOURCE_AUTO_POSITION = 0, SOURCE_LOG_FILE = file, \
SOURCE_LOG_POS = position [FOR CHANNEL 'channel'];
START REPLICA [FOR CHANNEL 'channel'];
 </pre></li><li class="listitem"><p>
          各サーバーで、次のコマンドを実行します:
        </p><pre class="programlisting">SET @@GLOBAL.GTID_MODE = ON_PERMISSIVE;</pre></li><li class="listitem"><p>
          各サーバーで、次のコマンドを実行します:
        </p><pre class="programlisting">SET @@GLOBAL.GTID_MODE = OFF_PERMISSIVE;</pre></li><li class="listitem"><p>
          各サーバーで、変数@@GLOBAL.GTID_OWNED が空の文字列と等しくなるまで待機します。 これは、次を使用してチェックできます: 
        </p><pre class="programlisting">SELECT @@GLOBAL.GTID_OWNED;</pre><p>
          レプリカでは、理論上、これが空になってから再度空でない可能性があります。 これは問題ではありません。一度空にすれば十分です。 
        </p></li><li class="listitem"><p>
          バイナリログに現在存在するすべてのトランザクションがすべてのレプリカにレプリケートされるのを待ちます。 すべての匿名トランザクションがすべてのサーバーにレプリケートされたことを確認する方法については、<a class="xref" href="replication.html#replication-mode-change-online-verify-transactions" title="17.1.4.4 匿名トランザクションのレプリケーションの検証">セクション17.1.4.4「匿名トランザクションのレプリケーションの検証」</a> を参照してください。 
        </p></li><li class="listitem"><p>
          レプリケーション以外にバイナリログを使用する場合 (たとえば、ポイントインタイムバックアップまたはリストアを実行する場合): GTID トランザクションを含む古いバイナリログが不要になるまで待ちます。
        </p><p>
          たとえば、ステップ 5 の完了後、バックアップを作成しているサーバーで <code class="literal">FLUSH LOGS</code> を実行できます。 次に、明示的にバックアップを取るか、設定した定期バックアップルーチンの次の反復を待機します。 
        </p><p>
          理想的には、ステップ 5 の完了時に存在していたすべてのバイナリログがサーバーによってパージされるまで待機します。 また、ステップ 5 の前に作成したバックアップが期限切れになるまで待機します。 
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
            これは、この手順で重要な点です。 GTID トランザクションを含むログを次のステップの後に使用できないことを理解することが重要です。 続行する前に、GTID トランザクションがトポロジ内のどこにも存在しないことを確認する必要があります。 
          </p></div></li><li class="listitem"><p>
          各サーバーで、次のコマンドを実行します:
        </p><pre class="programlisting">SET @@GLOBAL.GTID_MODE = OFF;</pre></li><li class="listitem"><p>
          各サーバーで、<code class="filename">my.cnf</code> で <code class="literal">gtid_mode=OFF</code> を設定します。
        </p><p>
          <code class="literal">enforce_gtid_consistency=OFF</code> を設定する場合は、ここで行うことができます。 設定後、<code class="literal">enforce_gtid_consistency=OFF</code> を構成ファイルに追加する必要があります。 
        </p></li></ol></div><p>
      以前のバージョンの MySQL にダウングレードする場合は、通常のダウングレード手順を使用してここでダウングレードできます。
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-mode-change-online-verify-transactions"></a>17.1.4.4 匿名トランザクションのレプリケーションの検証</h4></div></div></div><a class="indexterm" name="idm46723657581824"></a><p>
      このセクションでは、レプリケーショントポロジを監視し、すべての匿名トランザクションがレプリケートされていることを確認する方法について説明します。 GTID トランザクションに安全に変更できることを確認できるため、これはレプリケーションモードをオンラインに変更するときに役立ちます。 
    </p><p>
      トランザクションのレプリケートを待機するには、いくつかの方法があります:
    </p><p>
      トポロジに関係なく動作しますが、タイミングに依存する最も単純な方法は次のとおりです: レプリカが N 秒を超えないことが確実な場合は、N 秒を少し待機します。 または、1 日またはデプロイメントの安全性を考慮する期間を待機します。 
    </p><p>
      タイミングに依存しないという意味で安全な方法: 1 つまたは複数のレプリカを持つソースしかない場合は、次の手順を実行します:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          ソースで、次のコマンドを実行します:
        </p><pre class="programlisting">SHOW MASTER STATUS;</pre><p>
          <code class="literal">File</code> および <code class="literal">Position</code> カラムの値をノートにとります。
        </p></li><li class="listitem"><p>
          すべてのレプリカで、ソースのファイルおよび位置情報を使用して実行します:
        </p><pre class="programlisting">SELECT MASTER_POS_WAIT(file, position);</pre></li></ol></div><p>
      ソースと複数レベルのレプリカがある場合、またはレプリカのレプリカがある場合は、ソースから開始して各レベルでステップ 2 を繰り返し、次にすべてのダイレクトレプリカ、レプリカのすべてのレプリカなどを繰り返します。
    </p><p>
      複数のサーバーに書込みクライアントが存在する循環レプリケーショントポロジを使用する場合は、円全体が完成するまで、ソースレプリケーション接続ごとにステップ 2 を実行します。 完全な円<span class="emphasis"><em>2 回</em></span>を実行するように、プロセス全体を繰り返します。 
    </p><p>
      たとえば、サーバー A、B および C が 3 つあり、A -&gt; B -&gt; C -&gt; A のように円でレプリケートしているとします。 その後、プロシージャは次のようになります: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          A でステップ 1 を実行し、B でステップ 2 を実行します。
        </p></li><li class="listitem"><p>
          B でステップ 1 を実行し、C でステップ 2 を実行します。
        </p></li><li class="listitem"><p>
          C でステップ 1 を実行し、A でステップ 2 を実行します。
        </p></li><li class="listitem"><p>
          A でステップ 1 を実行し、B でステップ 2 を実行します。
        </p></li><li class="listitem"><p>
          B でステップ 1 を実行し、C でステップ 2 を実行します。
        </p></li><li class="listitem"><p>
          C でステップ 1 を実行し、A でステップ 2 を実行します。
        </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-multi-source"></a>17.1.5 MySQL マルチソースレプリケーション</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-multi-source-configuration">17.1.5.1 マルチソースレプリケーションの構成</a></span></dt><dt><span class="section"><a href="replication.html#replication-multi-source-provision-replica">17.1.5.2 GTID ベースのレプリケーション用のマルチソースレプリカのプロビジョニング</a></span></dt><dt><span class="section"><a href="replication.html#replication-multi-source-adding-gtid-master">17.1.5.3 マルチソースレプリカへの GTID ベースのソースの追加</a></span></dt><dt><span class="section"><a href="replication.html#replication-multi-source-adding-binlog-master">17.1.5.4 マルチソースレプリカへのバイナリログベースレプリケーションソースの追加</a></span></dt><dt><span class="section"><a href="replication.html#replication-multi-source-start-replica">17.1.5.5 マルチソースレプリカの開始</a></span></dt><dt><span class="section"><a href="replication.html#replication-multi-source-stop-replica">17.1.5.6 マルチソースレプリカの停止</a></span></dt><dt><span class="section"><a href="replication.html#replication-multi-source-reset-replica">17.1.5.7 マルチソースレプリカのリセット</a></span></dt><dt><span class="section"><a href="replication.html#replication-multi-source-monitoring">17.1.5.8 マルチソースレプリケーションの監視</a></span></dt></dl></div><a class="indexterm" name="idm46723657558656"></a><a class="indexterm" name="idm46723657557136"></a><a class="indexterm" name="idm46723657555040"></a><a class="indexterm" name="idm46723657552960"></a><p>
    MySQL マルチソースレプリケーションを使用すると、レプリカは複数の即時ソースからトランザクションをパラレルに受信できます。 マルチソースレプリケーショントポロジでは、レプリカはトランザクションの受信元となるソースごとにレプリケーションチャネルを作成します。 レプリケーションチャネルの機能の詳細は、<a class="xref" href="replication.html#replication-channels" title="17.2.2 レプリケーションチャネル">セクション17.2.2「レプリケーションチャネル」</a> を参照してください。 
  </p><p>
    マルチソースレプリケーションを実装して、次のような目標を達成できます:
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        複数のサーバーの単一サーバーへのバックアップ。
      </p></li><li class="listitem"><p>
        テーブルシャードをマージしています。
      </p></li><li class="listitem"><p>
        複数のサーバーのデータを単一のサーバーに統合します。
      </p></li></ul></div><p>
    マルチソースレプリケーションでは、トランザクションの適用時に競合検出または解消は実装されず、必要に応じてこれらのタスクがアプリケーションに残されます。
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
      マルチソースレプリカ上の各チャネルは、異なるソースからレプリケートする必要があります。 単一のレプリカから単一のソースに複数のレプリケーションチャネルを設定することはできません。 これは、レプリカのサーバー ID がレプリケーショントポロジ内で一意である必要があるためです。 ソースはレプリカをサーバー ID でのみ区別し、レプリケーションチャネルの名前では区別しないため、同じレプリカとは異なるレプリケーションチャネルを認識できません。 
    </p></div><p>
    rmulti-source レプリカは、<code class="literal">slave_parallel_workers</code> システム変数を 0 より大きい値に設定することで、マルチスレッドレプリカとして設定することもできます。 マルチソースレプリカでこれを行う場合、レプリカ上の各チャネルには、指定された数のアプライヤスレッドと、それらを管理するためのコーディネータスレッドがあります。 個々のチャネルのアプライヤスレッドの数は構成できません。 
  </p><p>
    MySQL 8.0 から、特定のレプリケーションチャネルでレプリケーションフィルタを使用してマルチソースレプリカを構成できます。 チャネル固有のレプリケーションフィルタは、同じデータベースまたはテーブルが複数のソースに存在し、単一のソースからレプリケートする場合にのみ使用できます。 GTID ベースのレプリケーションでは、(ダイアモンドトポロジなどの) 複数のソースから同じトランザクションが到着する可能性がある場合、フィルタリング設定がすべてのチャネルで同じであることを確認する必要があります。 詳細は、<a class="xref" href="replication.html#replication-rules-channel-based-filters" title="17.2.5.4 レプリケーションチャネルベースのフィルタ">セクション17.2.5.4「レプリケーションチャネルベースのフィルタ」</a>を参照してください。 
  </p><p>
    このセクションでは、マルチソースレプリケーションのソースおよびレプリカの構成方法、マルチソースレプリカの起動、停止およびリセット方法、およびマルチソースレプリケーションの監視方法に関するチュートリアルを示します。
  </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-multi-source-configuration"></a>17.1.5.1 マルチソースレプリケーションの構成</h4></div></div></div><a class="indexterm" name="idm46723657535456"></a><p>
      マルチソースレプリケーショントポロジでは、少なくとも 2 つのソースと 1 つのレプリカが構成されている必要があります。 これらのチュートリアルでは、2 つのソース <code class="literal">source1</code> と <code class="literal">source2</code> およびレプリカ <code class="literal">replicahost</code> があると想定しています。 レプリカは、<code class="literal">source1</code> の <code class="literal">db1</code> および <code class="literal">source2</code> の <code class="literal">db2</code> の各ソースから 1 つのデータベースをレプリケートします。 
    </p><p>
      マルチソースレプリケーショントポロジのソースは、GTID ベースのレプリケーションまたはバイナリログ位置ベースのレプリケーションのいずれかを使用するように構成できます。 GTID ベースのレプリケーションを使用してソースを構成する方法については、<a class="xref" href="replication.html#replication-gtids-howto" title="17.1.3.4 GTID を使用したレプリケーションのセットアップ">セクション17.1.3.4「GTID を使用したレプリケーションのセットアップ」</a> を参照してください。 ファイル位置ベースのレプリケーションを使用してソースを構成する方法は、<a class="xref" href="replication.html#replication-howto-masterbaseconfig" title="17.1.2.1 レプリケーションソース構成の設定">セクション17.1.2.1「レプリケーションソース構成の設定」</a> を参照してください。 
    </p><p>
      マルチソースレプリケーショントポロジのレプリカには、MySQL 8.0 のデフォルトであるレプリカ接続メタデータリポジトリおよびアプライヤメタデータリポジトリ用の <code class="literal">TABLE</code> リポジトリが必要です。 マルチソースレプリケーションは、非推奨の代替ファイルリポジトリと互換性がありません。 
    </p><p>
      レプリカが接続に使用できるすべてのソースで適切なユーザーアカウントを作成します。 すべてのソースで同じアカウントを使用することも、それぞれで異なるアカウントを使用することもできます。 レプリケーションの目的にだけアカウントを作成する場合、そのアカウントには <code class="literal">REPLICATION SLAVE</code> 権限だけが必要です。 たとえば、レプリカ <code class="literal">replicahost</code> から接続できる新しいユーザー <code class="literal">ted</code> を設定するには、<span class="command"><strong>mysql</strong></span> クライアントを使用して各ソースで次のステートメントを発行します: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE USER 'ted'@'replicahost' IDENTIFIED BY '<em class="replaceable"><code>password</code></em>';</code></strong>
mysql&gt; <strong class="userinput"><code>GRANT REPLICATION SLAVE ON *.* TO 'ted'@'replicahost';</code></strong>
</pre><p>
      MySQL 8.0 からの新規ユーザーのデフォルト認証プラグインの詳細および重要な情報は、<a class="xref" href="replication.html#replication-howto-repuser" title="17.1.2.3 レプリケーション用ユーザーの作成">セクション17.1.2.3「レプリケーション用ユーザーの作成」</a> を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-multi-source-provision-replica"></a>17.1.5.2 GTID ベースのレプリケーション用のマルチソースレプリカのプロビジョニング</h4></div></div></div><a class="indexterm" name="idm46723657512464"></a><p>
      マルチソースレプリケーショントポロジのソースに既存のデータがある場合、レプリケーションを開始する前にレプリカに関連データをプロビジョニングする時間を節約できます。 マルチソースレプリケーショントポロジでは、データディレクトリのクローニングまたはコピーを使用して、レプリカにすべてのソースのデータをプロビジョニングすることはできません。また、各ソースから特定のデータベースのみをレプリケートすることもできます。 したがって、このようなレプリカをプロビジョニングする最善の戦略は、<span class="command"><strong>mysqldump</strong></span> を使用して各ソースに適切なダンプファイルを作成し、<span class="command"><strong>mysql</strong></span> クライアントを使用してレプリカにダンプファイルをインポートすることです。 
    </p><p>
      GTID ベースのレプリケーションを使用している場合は、<span class="command"><strong>mysqldump</strong></span> がダンプ出力に配置する <code class="literal">SET @@GLOBAL.gtid_purged</code> ステートメントに注意する必要があります。 このステートメントは、ソースで実行されたトランザクションの GTID をレプリカに転送し、レプリカはこの情報を必要とします。 ただし、あるソースから新しい空のレプリカをプロビジョニングするよりも複雑な場合は、レプリカで使用される MySQL のバージョンでステートメントの影響を確認し、それに応じてステートメントを処理する必要があります。 次のガイダンスは、適切なアクションの概要を示していますが、詳細は、<span class="command"><strong>mysqldump</strong></span> のドキュメントを参照してください。 
    </p><p>
      <span class="command"><strong>mysqldump</strong></span> によって記述された <code class="literal">SET @@GLOBAL.gtid_purged</code> ステートメントの動作は、MySQL 8.0 と MySQL 5.6 および 5.7 のリリースでは異なります。 MySQL 5.6 および 5.7 では、このステートメントによってレプリカ上の <code class="literal">gtid_purged</code> の値が置き換えられ、それらのリリースでは GTID (<code class="literal">gtid_executed</code> セット) を含むトランザクションのレプリカレコードが空の場合にのみその値を変更できます。 したがって、マルチソースレプリケーショントポロジでは、ダンプファイルをリプレイする前に、ダンプ出力から <code class="literal">SET @@GLOBAL.gtid_purged</code> ステートメントを削除する必要があります。これは、このステートメントを含む別のダンプファイルまたは後続のダンプファイルを適用できないためです。 また、MySQL 5.6 および 5.7 の場合、この制限は、ソースのすべてのダンプファイルを空の <code class="literal">gtid_executed</code> セットを持つレプリカに対する単一の操作で適用する必要があることを意味します。 レプリカ上で <code class="literal">RESET MASTER</code> を発行することでレプリカ GTID 実行履歴をクリアできますが、レプリカ上に GTID との別のトランザクションが必要な場合は、<a class="xref" href="replication.html#replication-gtids-failover" title="17.1.3.5 フェイルオーバーおよびスケールアウトでの GTID の使用">セクション17.1.3.5「フェイルオーバーおよびスケールアウトでの GTID の使用」</a> で説明されているプロビジョニング方法から別の方法を選択します。 
    </p><p>
      MySQL 8.0 から、<code class="literal">SET @@GLOBAL.gtid_purged</code> ステートメントは GTID セットをダンプファイルからレプリカ上の既存の <code class="literal">gtid_purged</code> セットに追加します。 したがって、レプリカでダンプファイルをリプレイすると、ダンプ出力にステートメントが残る可能性があり、ダンプファイルは異なるタイミングでリプレイできます。 ただし、<code class="literal">SET @@GLOBAL.gtid_purged</code> ステートメントの <span class="command"><strong>mysqldump</strong></span> に含まれる値には、ソース上の <code class="literal">gtid_executed</code> セット内のすべてのトランザクションの GTID(データベースの抑制された部分を変更したトランザクションや、部分ダンプに含まれていなかったサーバー上のその他のデータベースも含む) が含まれることに注意してください。 同じ GTID (たとえば、同じソースからの別の部分ダンプ、または重複するトランザクションを持つ別のソースからのダンプ) を含むレプリカ上の 2 番目または後続のダンプファイルをリプレイすると、2 番目のダンプファイル内の <code class="literal">SET @@GLOBAL.gtid_purged</code> ステートメントは失敗するため、ダンプ出力から削除する必要があります。 
    </p><p>
      MySQL 8.0.17 からのソースの場合、<code class="literal">SET @@GLOBAL.gtid_purged</code> ステートメントを削除するかわりに、<span class="command"><strong>mysqldump</strong></span> の <code class="literal">--set-gtid-purged</code> オプションを <code class="literal">COMMENTED</code> に設定してステートメントを含め、コメントアウトして、ダンプファイルのロード時にアクションが実行されないようにできます。 同じソースから 2 つの部分ダンプを使用してレプリカをプロビジョニングし、2 つ目のダンプで設定された GTID が最初のダンプと同じである場合 (そのため、ダンプ間でソースで新しいトランザクションが実行されていない場合)、2 つ目のダンプファイルを出力するときに <span class="command"><strong>mysqldump</strong></span> の <code class="literal">--set-gtid-purged</code> オプションを <code class="literal">OFF</code> に設定して、ステートメントを省略できます。 
    </p><p>
      次のプロビジョニング例では、<code class="literal">SET @@GLOBAL.gtid_purged</code> ステートメントをダンプ出力に残すことができず、ファイルから削除して手動で処理する必要があると想定しています。 また、プロビジョニングを開始する前に、GTID を含む必要なトランザクションがレプリカに存在しないことも前提としています。 
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          <code class="literal">db1</code> という名前のデータベース (<code class="literal">source1</code> 上) および <code class="literal">db2</code> という名前のデータベース (<code class="literal">source2</code>) のダンプファイルを作成するには、次のように <span class="command"><strong>mysqldump</strong></span> for <code class="literal">source1</code> を実行します:
        </p><pre class="programlisting"><strong class="userinput"><code>mysqldump -u&lt;<em class="replaceable"><code>user</code></em>&gt; -p&lt;<em class="replaceable"><code>password</code></em>&gt; --single-transaction --triggers --routines --set-gtid-purged=ON --databases db1 &gt; dumpM1.sql </code></strong>
</pre><p>
          次に、<span class="command"><strong>mysqldump</strong></span> for <code class="literal">source2</code> を次のように実行します:
        </p><pre class="programlisting"><strong class="userinput"><code>mysqldump -u&lt;<em class="replaceable"><code>user</code></em>&gt; -p&lt;<em class="replaceable"><code>password</code></em>&gt; --single-transaction --triggers --routines --set-gtid-purged=ON --databases db2 &gt; dumpM2.sql </code></strong>
</pre></li><li class="listitem"><p>
          <span class="command"><strong>mysqldump</strong></span> が各ダンプファイルに追加した <code class="literal">gtid_purged</code> 値を記録します。 たとえば、MySQL 5.6 または 5.7 で作成されたダンプファイルの場合、次のような値を抽出できます: 
        </p><pre class="programlisting"><strong class="userinput"><code>cat dumpM1.sql | grep GTID_PURGED | cut -f2 -d'=' | cut -f2 -d$'\''</code></strong>
<strong class="userinput"><code>cat dumpM2.sql | grep GTID_PURGED | cut -f2 -d'=' | cut -f2 -d$'\'' </code></strong>
</pre><p>
          フォーマットが変更された MySQL 8.0 から、次のような値を抽出できます:
        </p><pre class="programlisting"><strong class="userinput"><code>cat dumpM1.sql | grep GTID_PURGED | perl -p0 -e 's#/\*.*?\*/##sg' | cut -f2 -d'=' | cut -f2 -d$'\''</code></strong>
<strong class="userinput"><code>cat dumpM2.sql | grep GTID_PURGED | perl -p0 -e 's#/\*.*?\*/##sg' | cut -f2 -d'=' | cut -f2 -d$'\''</code></strong>
</pre><p>
          各ケースの結果は GTID セットである必要があります。次に例を示します:
        </p><pre class="programlisting">source1:   2174B383-5441-11E8-B90A-C80AA9429562:1-1029
source2:   224DA167-0C0C-11E8-8442-00059A3C7B00:1-2695
</pre></li><li class="listitem"><p>
          <code class="literal">SET @@GLOBAL.gtid_purged</code> ステートメントを含む各ダンプファイルから行を削除します。 例: 
        </p><pre class="programlisting"><strong class="userinput"><code>sed '/GTID_PURGED/d' dumpM1.sql &gt; dumpM1_nopurge.sql</code></strong>
<strong class="userinput"><code>sed '/GTID_PURGED/d' dumpM2.sql &gt; dumpM2_nopurge.sql </code></strong>
</pre></li><li class="listitem"><p>
          <span class="command"><strong>mysql</strong></span> クライアントを使用して、編集した各ダンプファイルをレプリカにインポートします。 例: 
        </p><pre class="programlisting"><strong class="userinput"><code>mysql -u&lt;<em class="replaceable"><code>user</code></em>&gt; -p&lt;<em class="replaceable"><code>password</code></em>&gt; &lt; dumpM1_nopurge.sql</code></strong>
<strong class="userinput"><code>mysql -u&lt;<em class="replaceable"><code>user</code></em>&gt; -p&lt;<em class="replaceable"><code>password</code></em>&gt; &lt; dumpM2_nopurge.sql </code></strong>
</pre></li><li class="listitem"><p>
          レプリカで、<code class="literal">RESET MASTER</code> を発行して GTID 実行履歴をクリアします (前述のように、すべてのダンプファイルがインポートされており、GTID を含む必要なトランザクションがレプリカにないことを前提としています)。 次に、ステップ 2 で記録したように、<code class="literal">SET @@GLOBAL.gtid_purged</code> ステートメントを発行して、<code class="literal">gtid_purged</code> 値をすべてのダンプファイルからのすべての GTID セットの和集合に設定します。 例: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>RESET MASTER;</code></strong>
mysql&gt; <strong class="userinput"><code>SET @@GLOBAL.gtid_purged = "2174B383-5441-11E8-B90A-C80AA9429562:1-1029, 224DA167-0C0C-11E8-8442-00059A3C7B00:1-2695";</code></strong>
</pre><p>
          ダンプファイル内の GTID セット間に重複するトランザクションがあるか、または重複している可能性がある場合は、<a class="xref" href="replication.html#replication-gtids-functions" title="17.1.3.8 GTID を操作するストアドファンクションの例">セクション17.1.3.8「GTID を操作するストアドファンクションの例」</a> で説明されているストアドファンクションを使用して、これを事前にチェックし、すべての GTID セットの結合を計算できます。
        </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-multi-source-adding-gtid-master"></a>17.1.5.3 マルチソースレプリカへの GTID ベースのソースの追加</h4></div></div></div><a class="indexterm" name="idm46723657434256"></a><p>
      これらのステップでは、<code class="literal">gtid_mode=ON</code> を使用してソースのトランザクションに対して GTID を有効にし、レプリケーションユーザーを作成し、レプリカが <code class="literal">TABLE</code> ベースのレプリケーションアプライヤメタデータリポジトリを使用していることを確認し、必要に応じてレプリカにソースのデータをプロビジョニングしていることを前提としています。
    </p><p>
      <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23 の場合) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 の場合) を使用して、レプリカ上の各ソースのレプリケーションチャネルを構成します (<a class="xref" href="replication.html#replication-channels" title="17.2.2 レプリケーションチャネル">セクション17.2.2「レプリケーションチャネル」</a> を参照)。 <code class="literal">FOR CHANNEL</code> 句を使用してチャネルを指定します。 GTID ベースのレプリケーションでは、GTID 自動配置を使用してソースと同期されます (<a class="xref" href="replication.html#replication-gtids-auto-positioning" title="17.1.3.3 GTID 自動配置">セクション17.1.3.3「GTID 自動配置」</a> を参照)。 <code class="literal">SOURCE_AUTO_POSITION</code> | <code class="literal">MASTER_AUTO_POSITION</code> オプションは、自動配置の使用を指定するために設定されます。 
    </p><p>
      たとえば、<code class="literal">source1</code> および <code class="literal">source2</code> をソースとしてレプリカに追加するには、<span class="command"><strong>mysql</strong></span> クライアントを使用して、次のようにレプリカでステートメントを 2 回発行します:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO MASTER_HOST="source1", MASTER_USER="ted", \
MASTER_PASSWORD="<em class="replaceable"><code>password</code></em>", MASTER_AUTO_POSITION=1 FOR CHANNEL "source_1";</code></strong>
mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO MASTER_HOST="source2", MASTER_USER="ted", \
MASTER_PASSWORD="<em class="replaceable"><code>password</code></em>", MASTER_AUTO_POSITION=1 FOR CHANNEL "source_2";</code></strong>

Or from MySQL 8.0.23:
mysql&gt; <strong class="userinput"><code>CHANGE REPLICATION SOURCE TO SOURCE_HOST="source1", SOURCE_USER="ted", \
SOURCE_PASSWORD="<em class="replaceable"><code>password</code></em>", SOURCE_AUTO_POSITION=1 FOR CHANNEL "source_1";</code></strong>
mysql&gt; <strong class="userinput"><code>CHANGE REPLICATION SOURCE TO SOURCE_HOST="source2", SOURCE_USER="ted", \
SOURCE_PASSWORD="<em class="replaceable"><code>password</code></em>", SOURCE_AUTO_POSITION=1 FOR CHANNEL "source_2";</code></strong>
</pre><p>
      レプリカが <code class="literal">source1</code> からデータベース <code class="literal">db1</code> のみをレプリケートし、<code class="literal">source2</code> からデータベース <code class="literal">db2</code> のみをレプリケートするようにするには、<span class="command"><strong>mysql</strong></span> クライアントを使用して、次のように各チャネルに対して <code class="literal">CHANGE REPLICATION FILTER</code> ステートメントを発行します:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CHANGE REPLICATION FILTER REPLICATE_WILD_DO_TABLE = ('db1.%') FOR CHANNEL "source_1";</code></strong>
mysql&gt; <strong class="userinput"><code>CHANGE REPLICATION FILTER REPLICATE_WILD_DO_TABLE = ('db2.%') FOR CHANNEL "source_2";</code></strong>
</pre><p>
      <code class="literal">CHANGE REPLICATION FILTER</code> ステートメントの完全な構文およびその他の使用可能なオプションについては、<a class="xref" href="sql-statements.html#change-replication-filter" title="13.4.2.2 CHANGE REPLICATION FILTER ステートメント">セクション13.4.2.2「CHANGE REPLICATION FILTER ステートメント」</a> を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-multi-source-adding-binlog-master"></a>17.1.5.4 マルチソースレプリカへのバイナリログベースレプリケーションソースの追加</h4></div></div></div><a class="indexterm" name="idm46723657401936"></a><p>
      これらのステップでは、バイナリロギングがソース (デフォルト) で有効になっており、レプリカが <code class="literal">TABLE</code> ベースのレプリケーションアプライアンスメタデータリポジトリ (MySQL 8.0 のデフォルト) を使用しており、レプリケーションユーザーを有効にして現在のバイナリログファイルの名前と位置をメモしていることを前提としています。
    </p><p>
      <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23 の場合) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 の場合) を使用して、レプリカ上の各ソースのレプリケーションチャネルを構成します (<a class="xref" href="replication.html#replication-channels" title="17.2.2 レプリケーションチャネル">セクション17.2.2「レプリケーションチャネル」</a> を参照)。 <code class="literal">FOR CHANNEL</code> 句を使用してチャネルを指定します。 たとえば、<code class="literal">source1</code> および <code class="literal">source2</code> をソースとしてレプリカに追加するには、<span class="command"><strong>mysql</strong></span> クライアントを使用して、次のようにレプリカでステートメントを 2 回発行します: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO MASTER_HOST="source1", MASTER_USER="ted", MASTER_PASSWORD="<em class="replaceable"><code>password</code></em>", \
MASTER_LOG_FILE='source1-bin.000006', MASTER_LOG_POS=628 FOR CHANNEL "source_1";</code></strong>
mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO MASTER_HOST="source2", MASTER_USER="ted", MASTER_PASSWORD="<em class="replaceable"><code>password</code></em>", \
MASTER_LOG_FILE='source2-bin.000018', MASTER_LOG_POS=104 FOR CHANNEL "source_2";</code></strong>

Or from MySQL 8.0.23:
mysql&gt; <strong class="userinput"><code>CHANGE REPLICATION SOURCE TO SOURCE_HOST="source1", SOURCE_USER="ted", SOURCE_PASSWORD="<em class="replaceable"><code>password</code></em>", \
SOURCE_LOG_FILE='source1-bin.000006', SOURCE_LOG_POS=628 FOR CHANNEL "source_1";</code></strong>
mysql&gt; <strong class="userinput"><code>CHANGE REPLICATION SOURCE TO SOURCE_HOST="source2", SOURCE_USER="ted", SOURCE_PASSWORD="<em class="replaceable"><code>password</code></em>", \
SOURCE_LOG_FILE='source2-bin.000018', SOURCE_LOG_POS=104 FOR CHANNEL "source_2";</code></strong></pre><p>
      レプリカが <code class="literal">source1</code> からデータベース <code class="literal">db1</code> のみをレプリケートし、<code class="literal">source2</code> からデータベース <code class="literal">db2</code> のみをレプリケートするようにするには、<span class="command"><strong>mysql</strong></span> クライアントを使用して、次のように各チャネルに対して <code class="literal">CHANGE REPLICATION FILTER</code> ステートメントを発行します:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CHANGE REPLICATION FILTER REPLICATE_WILD_DO_TABLE = ('db1.%') FOR CHANNEL "source_1";</code></strong>
mysql&gt; <strong class="userinput"><code>CHANGE REPLICATION FILTER REPLICATE_WILD_DO_TABLE = ('db2.%') FOR CHANNEL "source_2";</code></strong>
</pre><p>
      <code class="literal">CHANGE REPLICATION FILTER</code> ステートメントの完全な構文およびその他の使用可能なオプションについては、<a class="xref" href="sql-statements.html#change-replication-filter" title="13.4.2.2 CHANGE REPLICATION FILTER ステートメント">セクション13.4.2.2「CHANGE REPLICATION FILTER ステートメント」</a> を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-multi-source-start-replica"></a>17.1.5.5 マルチソースレプリカの開始</h4></div></div></div><a class="indexterm" name="idm46723657373728"></a><p>
      すべてのレプリケーションソースにチャネルを追加したら、<code class="literal">START REPLICA | SLAVE</code> ステートメントを発行してレプリケーションを開始します。 レプリカで複数のチャネルを有効にした場合は、すべてのチャネルを起動するか、開始する特定のチャネルを選択できます。 たとえば、2 つのチャネルを個別に起動するには、<span class="command"><strong>mysql</strong></span> クライアントを使用して次のステートメントを発行します: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>START SLAVE FOR CHANNEL "source_1";</code></strong>
mysql&gt; <strong class="userinput"><code>START SLAVE FOR CHANNEL "source_2";</code></strong>
Or from MySQL 8.0.22:
mysql&gt; <strong class="userinput"><code>START REPLICA FOR CHANNEL "source_1";</code></strong>
mysql&gt; <strong class="userinput"><code>START REPLICA FOR CHANNEL "source_2";</code></strong></pre><p>
      <code class="literal">START REPLICA | SLAVE</code> コマンドの完全な構文およびその他の使用可能なオプションについては、<a class="xref" href="sql-statements.html#start-replica" title="13.4.2.7 START REPLICA | SLAVE ステートメント">セクション13.4.2.7「START REPLICA | SLAVE ステートメント」</a> を参照してください。
    </p><p>
      両方のチャネルが起動し、正しく動作していることを確認するには、レプリカで次のような <code class="literal">SHOW REPLICA | SLAVE STATUS</code> ステートメントを発行します:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW SLAVE STATUS FOR CHANNEL "source_1"\G</code></strong>
mysql&gt; <strong class="userinput"><code>SHOW SLAVE STATUS FOR CHANNEL "source_2"\G</code></strong>
Or from MySQL 8.0.22:
mysql&gt; <strong class="userinput"><code>SHOW REPLICA STATUS FOR CHANNEL "source_1"\G</code></strong>
mysql&gt; <strong class="userinput"><code>SHOW REPLICA STATUS FOR CHANNEL "source_2"\G</code></strong>
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-multi-source-stop-replica"></a>17.1.5.6 マルチソースレプリカの停止</h4></div></div></div><a class="indexterm" name="idm46723657354800"></a><p>
      <code class="literal">STOP REPLICA | SLAVE</code> ステートメントを使用して、マルチソースレプリカを停止できます。 デフォルトでは、マルチソースレプリカで <code class="literal">STOP REPLICA | SLAVE</code> ステートメントを使用すると、すべてのチャネルが停止します。 オプションで、<code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を使用して、特定のチャネルのみを停止します。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          現在構成されているすべてのレプリケーションチャネルを停止するには:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>STOP SLAVE;</code></strong>
Or from MySQL 8.0.22:
mysql&gt; <strong class="userinput"><code>STOP REPLICA;</code></strong></pre></li><li class="listitem"><p>
          名前付きチャネルのみを停止するには、<code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を使用します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>STOP SLAVE FOR CHANNEL "source_1";</code></strong>
Or from MySQL 8.0.22:
mysql&gt; <strong class="userinput"><code>STOP REPLICA FOR CHANNEL "source_1";</code></strong></pre></li></ul></div><p>
      <code class="literal">STOP REPLICA | SLAVE</code> コマンドの完全な構文およびその他の使用可能なオプションについては、<a class="xref" href="sql-statements.html#stop-replica" title="13.4.2.9 STOP REPLICA | SLAVE ステートメント">セクション13.4.2.9「STOP REPLICA | SLAVE ステートメント」</a> を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-multi-source-reset-replica"></a>17.1.5.7 マルチソースレプリカのリセット</h4></div></div></div><a class="indexterm" name="idm46723657336336"></a><p>
      <code class="literal">RESET REPLICA | SLAVE</code> ステートメントを使用して、マルチソースレプリカをリセットできます。 デフォルトでは、マルチソースレプリカで <code class="literal">RESET REPLICA | SLAVE</code> ステートメントを使用すると、すべてのチャネルがリセットされます。 オプションで、<code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を使用して特定のチャネルのみをリセットします。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          現在構成されているすべてのレプリケーションチャネルをリセットするには:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>RESET SLAVE;</code></strong>
Or from MySQL 8.0.22:
mysql&gt; <strong class="userinput"><code>RESET REPLICA;</code></strong></pre></li><li class="listitem"><p>
          名前付きチャネルのみをリセットするには、<code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を使用します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>RESET SLAVE FOR CHANNEL "source_1";</code></strong>
Or from MySQL 8.0.22:
mysql&gt; <strong class="userinput"><code>RESET REPLICA FOR CHANNEL "source_1";</code></strong>
</pre></li></ul></div><p>
      GTID ベースのレプリケーションの場合、<code class="literal">RESET REPLICA | SLAVE</code> はレプリカ GTID 実行履歴に影響しないことに注意してください。 これをクリアする場合は、レプリカで <code class="literal">RESET MASTER</code> を発行します。 
    </p><p>
      <code class="literal">RESET REPLICA | SLAVE</code> はレプリカをレプリケーション位置を忘れ、リレーログをクリアしますが、レプリケーション接続パラメータ (ソースホスト名など) やレプリケーションフィルタは変更しません。 チャネルのこれらを削除する場合は、<code class="literal">RESET REPLICA | SLAVE ALL</code> を発行します。 
    </p><p>
      <code class="literal">RESET REPLICA | SLAVE</code> コマンドの完全な構文およびその他の使用可能なオプションについては、<a class="xref" href="sql-statements.html#reset-replica" title="13.4.2.5 RESET REPLICA | SLAVE ステートメント">セクション13.4.2.5「RESET REPLICA | SLAVE ステートメント」</a> を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-multi-source-monitoring"></a>17.1.5.8 マルチソースレプリケーションの監視</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-multi-source-monitoring-tutorial">17.1.5.8.1 パフォーマンススキーマテーブルを使用したチャネルの監視</a></span></dt></dl></div><a class="indexterm" name="idm46723657311648"></a><a class="indexterm" name="idm46723657309472"></a><p>
      レプリケーションチャネルのステータスを監視するには、次のオプションがあります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          レプリケーション「パフォーマンススキーマ」テーブルの使用。 これらのテーブルの最初のカラムは <code class="literal">Channel_Name</code> です。 これにより、<code class="literal">Channel_Name</code> に基づく複雑なクエリーをキーとして記述できます。 <a class="xref" href="performance-schema.html#performance-schema-replication-tables" title="27.12.11 パフォーマンススキーマレプリケーションテーブル">セクション27.12.11「パフォーマンススキーマレプリケーションテーブル」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW REPLICA | SLAVE STATUS FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> の使用。 デフォルトでは、<code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を使用しない場合、このステートメントはすべてのチャネルのレプリカステータスをチャネルごとに 1 行ずつ表示します。 識別子 <code class="literal">Channel_name</code> が結果セットのカラムとして追加されます。 <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句が指定されている場合、結果には名前付きレプリケーションチャネルのステータスのみが表示されます。 
        </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">SHOW VARIABLES</code> ステートメントは、複数のレプリケーションチャネルでは機能しません。 これらの変数を介して使用可能だった情報は、レプリケーションパフォーマンステーブルに移行されています。 複数のチャネルを含むトポロジで <code class="literal">SHOW VARIABLES</code> ステートメントを使用すると、デフォルトチャネルのステータスのみが表示されます。 
      </p></div><p>
      マルチソースレプリケーションが有効な場合に発行されるエラーコードおよびメッセージは、エラーを生成したチャネルを指定します。
    </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="replication-multi-source-monitoring-tutorial"></a>17.1.5.8.1 パフォーマンススキーマテーブルを使用したチャネルの監視</h5></div></div></div><a class="indexterm" name="idm46723657291728"></a><p>
        このセクションでは、レプリケーション「パフォーマンススキーマ」テーブルを使用してチャネルを監視する方法について説明します。 すべてのチャネルを監視するか、既存のチャネルのサブセットを監視するかを選択できます。 
      </p><p>
        すべてのチャネルの接続ステータスを監視するには:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM replication_connection_status\G;</code></strong>
*************************** 1. row ***************************
CHANNEL_NAME: source_1
GROUP_NAME:
SOURCE_UUID: 046e41f8-a223-11e4-a975-0811960cc264
THREAD_ID: 24
SERVICE_STATE: ON
COUNT_RECEIVED_HEARTBEATS: 0
LAST_HEARTBEAT_TIMESTAMP: 0000-00-00 00:00:00
RECEIVED_TRANSACTION_SET: 046e41f8-a223-11e4-a975-0811960cc264:4-37
LAST_ERROR_NUMBER: 0
LAST_ERROR_MESSAGE:
LAST_ERROR_TIMESTAMP: 0000-00-00 00:00:00
*************************** 2. row ***************************
CHANNEL_NAME: source_2
GROUP_NAME:
SOURCE_UUID: 7475e474-a223-11e4-a978-0811960cc264
THREAD_ID: 26
SERVICE_STATE: ON
COUNT_RECEIVED_HEARTBEATS: 0
LAST_HEARTBEAT_TIMESTAMP: 0000-00-00 00:00:00
RECEIVED_TRANSACTION_SET: 7475e474-a223-11e4-a978-0811960cc264:4-6
LAST_ERROR_NUMBER: 0
LAST_ERROR_MESSAGE:
LAST_ERROR_TIMESTAMP: 0000-00-00 00:00:00
2 rows in set (0.00 sec)
	    </pre><p>
        前述の出力では、2 つのチャネルが有効になっており、<code class="literal">CHANNEL_NAME</code> フィールドで示されているように、これらは <code class="literal">source_1</code> および <code class="literal">source_2</code> と呼ばれます。
      </p><p>
        <code class="literal">CHANNEL_NAME</code> フィールドを追加すると、特定のチャネルの「パフォーマンススキーマ」テーブルをクエリーすることができます。 名前付きチャネルの接続ステータスを監視するには、<code class="literal">WHERE CHANNEL_NAME=<em class="replaceable"><code>channel</code></em></code> 句を使用します: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM replication_connection_status WHERE CHANNEL_NAME='source_1'\G</code></strong>
*************************** 1. row ***************************
CHANNEL_NAME: source_1
GROUP_NAME:
SOURCE_UUID: 046e41f8-a223-11e4-a975-0811960cc264
THREAD_ID: 24
SERVICE_STATE: ON
COUNT_RECEIVED_HEARTBEATS: 0
LAST_HEARTBEAT_TIMESTAMP: 0000-00-00 00:00:00
RECEIVED_TRANSACTION_SET: 046e41f8-a223-11e4-a975-0811960cc264:4-37
LAST_ERROR_NUMBER: 0
LAST_ERROR_MESSAGE:
LAST_ERROR_TIMESTAMP: 0000-00-00 00:00:00
1 row in set (0.00 sec)
</pre><p>
        同様に、<code class="literal">WHERE CHANNEL_NAME=<em class="replaceable"><code>channel</code></em></code> 句を使用して、特定のチャネルの他のレプリケーション「パフォーマンススキーマ」テーブルを監視できます。 詳細は、<a class="xref" href="performance-schema.html#performance-schema-replication-tables" title="27.12.11 パフォーマンススキーマレプリケーションテーブル">セクション27.12.11「パフォーマンススキーマレプリケーションテーブル」</a>を参照してください。 
      </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-options"></a>17.1.6 レプリケーションおよびバイナリロギングのオプションと変数</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-options-reference">17.1.6.1 レプリケーション、バイナリロギングオプション、および変数のリファレンス</a></span></dt><dt><span class="section"><a href="replication.html#replication-options-source">17.1.6.2 レプリケーションソースのオプションと変数</a></span></dt><dt><span class="section"><a href="replication.html#replication-options-replica">17.1.6.3 Replica Server のオプションと変数</a></span></dt><dt><span class="section"><a href="replication.html#replication-options-binary-log">17.1.6.4 バイナリロギングのオプションと変数</a></span></dt><dt><span class="section"><a href="replication.html#replication-options-gtids">17.1.6.5 グローバルトランザクション ID システム変数</a></span></dt></dl></div><p>
    以降のセクションでは、<span class="command"><strong>mysqld</strong></span> オプション、およびレプリケーションで使用されてバイナリログを制御するためのサーバー変数の情報について説明します。 ソースおよびレプリカで使用するオプションおよび変数は、バイナリロギングおよびグローバルトランザクション識別子 (GTID) に関連するオプションおよび変数と同様に個別にカバーされます。 これらのオプションと変数に関する基本情報するクイックリファレンス表のセットも含まれています。 
  </p><p><a name="sysvar_server_id"></a>
    特に重要なのは、<code class="literal">server_id</code> システム変数です。
  </p><a class="indexterm" name="idm46723657269584"></a><a class="indexterm" name="idm46723657268064"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for server_id"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--server-id=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_server_id">server_id</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
    この変数は、サーバー ID を指定します。<code class="literal">server_id</code> はデフォルトで 1 に設定されています。 このデフォルト ID を使用してサーバーを起動できますが、バイナリロギングが有効になっているときに、サーバー ID を指定するように <code class="literal">server_id</code> を明示的に設定しなかった場合は、情報メッセージが発行されます。 
  </p><p>
    レプリケーショントポロジで使用されるサーバーの場合、レプリケーションサーバーごとに一意のサーバー ID を 1 から 2 の <sup>32</sup>− 1 の範囲で指定する必要があります。 <span class="quote">「<span class="quote">Unique</span>」</span> は、各 ID がレプリケーショントポロジ内の他のソースまたはレプリカで使用されている他のすべての ID と異なる必要があることを意味します。 詳細については、<a class="xref" href="replication.html#replication-options-source" title="17.1.6.2 レプリケーションソースのオプションと変数">セクション17.1.6.2「レプリケーションソースのオプションと変数」</a>,および<a class="xref" href="replication.html#replication-options-replica" title="17.1.6.3 Replica Server のオプションと変数">セクション17.1.6.3「Replica Server のオプションと変数」</a>を参照してください。 
  </p><p>
    サーバー ID が 0 に設定されている場合、バイナリロギングは行われますが、サーバー ID が 0 のソースはレプリカからの接続を拒否し、サーバー ID が 0 のレプリカはソースへの接続を拒否します。 サーバー ID は動的にゼロ以外の値に変更できますが、変更してもレプリケーションはすぐに開始されません。 レプリカを初期化するには、サーバー ID を変更してからサーバーを再起動する必要があります。 
  </p><p>
    詳細については、<a class="xref" href="replication.html#replication-howto-slavebaseconfig" title="17.1.2.2 レプリカ構成の設定">セクション17.1.2.2「レプリカ構成の設定」</a>を参照してください。
  </p><p><a name="sysvar_server_uuid"></a>
    <code class="literal">server_uuid</code>
  </p><a class="indexterm" name="idm46723657230528"></a><a class="indexterm" name="idm46723657228432"></a><p>
    MySQL サーバーは、<code class="literal">server_id</code> システム変数に設定されているデフォルトまたはユーザー指定のサーバー ID に加えて、真の UUID を生成します。 これは、グローバルな読み取り専用変数 <code class="literal">server_uuid</code> として使用できます。 
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
      このセクションで前述したように、<code class="literal">server_uuid</code> システム変数が存在しても、MySQL レプリケーションの準備および実行の一環として MySQL サーバーごとに一意の <code class="literal">server_id</code> 値を設定するための要件は変更されません。
    </p></div><div class="informaltable"><table frame="box" rules="all" summary="Properties for server_uuid"><col style="width=30%"><col style="width=70%"><tbody><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_server_uuid">server_uuid</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
    起動時、MySQL サーバーは次のように自動的に UUID を取得します。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        <a class="indexterm" name="idm46723657203488"></a> ファイル <code class="filename"><em class="replaceable"><code>data_dir</code></em>/auto.cnf</code> に書かれている UUID を読み取って使用しようとします (ここで、<em class="replaceable"><code>data_dir</code></em> はサーバーのデータディレクトリ)。
      </p></li><li class="listitem"><p>
        <code class="filename"><em class="replaceable"><code>data_dir</code></em>/auto.cnf</code> が見つからない場合、新しい UUID を生成してこのファイルに保存します (必要に応じてファイルを作成します)。
      </p></li></ol></div><p>
    <code class="filename">auto.cnf</code> ファイルの形式は、<code class="filename">my.cnf</code> または <code class="filename">my.ini</code> ファイルに使用される形式と似ています。<code class="filename">auto.cnf</code> には、単一の <code class="literal">server_uuid</code> 設定および値を含む単一の<code class="literal">[auto]</code>セクションのみがあります。ファイルの内容は次のように表示されます:
  </p><pre class="programlisting">[auto]
server_uuid=8a94f357-aab4-11df-86ab-c80aa9429562
</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
      <code class="filename">auto.cnf</code> ファイルは自動的に生成されます。このファイルを書き込んだり修正したりしようとしないでください。
    </p></div><p>
    MySQL レプリケーションを使用する場合、ソースとレプリカは相互に UUID を認識します。 レプリカ UUID の値は、<code class="literal">SHOW REPLICAS | SHOW SLAVE HOSTS</code> の出力に表示されます。 <code class="literal">START REPLICA | SLAVE</code> が実行されると、ソース UUID の値が <code class="literal">SHOW REPLICA | SLAVE STATUS</code> の出力のレプリカで使用可能になります。 
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
      <code class="literal">STOP REPLICA | SLAVE</code> または <code class="literal">RESET REPLICA | SLAVE</code> ステートメントを発行しても、レプリカで使用されているソース UUID はリセットされません。
    </p></div><p>
    サーバー <code class="literal">server_uuid</code> は GTID でも、そのサーバーで発生したトランザクションに使用されます。 詳細は、<a class="xref" href="replication.html#replication-gtids" title="17.1.3 グローバルトランザクション識別子を使用したレプリケーション">セクション17.1.3「グローバルトランザクション識別子を使用したレプリケーション」</a>を参照してください。 
  </p><p>
    起動時に、<code class="option">--replicate-same-server-id</code> オプションが設定されていないかぎり、レプリケーション I/O スレッドはエラーを生成し、そのソース UUID がそれ自体と等しい場合は中断します。 また、次のいずれかに該当する場合、レプリケーション I/O スレッドは警告を生成します: 
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        必要な <code class="literal">server_uuid</code> を持つソースが存在しません。
      </p></li><li class="listitem"><p>
        <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントは実行されていませんが、ソース <code class="literal">server_uuid</code> は変更されました。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-options-reference"></a>17.1.6.1 レプリケーション、バイナリロギングオプション、および変数のリファレンス</h4></div></div></div><p>
      次の 2 つのセクションでは、レプリケーションおよびバイナリログに適用可能な MySQL コマンド行オプションとシステム変数に関する基本情報を提供します。
    </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-optvars-list"></a>レプリケーションオプションと変数</h5></div></div></div><p>
    次のリストのコマンド行オプションとシステム変数は、レプリケーションソースサーバーと複製に関連しています。<a class="xref" href="replication.html#replication-options-source" title="17.1.6.2 レプリケーションソースのオプションと変数">セクション17.1.6.2「レプリケーションソースのオプションと変数」</a>
    では、レプリケーションソースサーバーに関連するオプションおよび変数の詳細が提供されます。
    レプリカに関連するオプションおよび変数の詳細は、<a class="xref" href="replication.html#replication-options-replica" title="17.1.6.3 Replica Server のオプションと変数">セクション17.1.6.3「Replica Server のオプションと変数」</a>
    を参照してください。
  </p><div class="itemizedlist"><a name="replication-optvar-summary-list"></a><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_abort-slave-event-count">abort-slave-event-count</a></code>:
        mysql-test
        がレプリケーションのデバッグとテストに使用するオプション.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_auto_increment_increment">auto_increment_increment</a></code>:
        AUTO_INCREMENT カラムはこの値でインクリメント.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_auto_increment_offset">auto_increment_offset</a></code>:
        AUTO_INCREMENT カラムに追加されるオフセット.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_binlog_expire_logs_seconds">binlog_expire_logs_seconds</a></code>:
        この秒数後にバイナリログをパージ.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_binlog_gtid_simple_recovery">binlog_gtid_simple_recovery</a></code>:
        GTID
        リカバリでのバイナリログの反復方法を制御.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_change_master</a></code>:
        CHANGE MASTER TO ステートメントの数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_show_master_status</a></code>:
        SHOW MASTER STATUS ステートメントの数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_show_slave_hosts</a></code>:
        SHOW REPLICAS および SHOW SLAVE HOSTS
        ステートメントの数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_show_replicas</a></code>:
        SHOW REPLICAS および SHOW SLAVE HOSTS
        ステートメントの数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_show_slave_status</a></code>:
        SHOW REPLICA STATUS および SHOW SLAVE STATUS
        ステートメントの数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_show_replica_status</a></code>:
        SHOW REPLICA STATUS および SHOW SLAVE STATUS
        ステートメントの数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_slave_start</a></code>:
        START REPLICA および START SLAVE ステートメントの数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_replica_start</a></code>:
        START REPLICA および START SLAVE ステートメントの数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_slave_stop</a></code>:
        STOP REPLICA および STOP SLAVE ステートメントの数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_replica_stop</a></code>:
        STOP REPLICA および STOP SLAVE ステートメントの数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_disconnect-slave-event-count">disconnect-slave-event-count</a></code>:
        mysql-test
        がレプリケーションのデバッグとテストに使用するオプション.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_enforce_gtid_consistency">enforce_gtid_consistency</a></code>:
        トランザクションで安全な方法でログに記録できないステートメントの実行を防止.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_expire_logs_days">expire_logs_days</a></code>:
        この日数後にバイナリログをパージ.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_gtid_executed">gtid_executed</a></code>:
        グローバル: バイナリログ (グローバル)
        または現在のトランザクション (セッション)
        内のすべての GTID。 読み取り専用.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_gtid_executed_compression_period">gtid_executed_compression_period</a></code>:
        この数のトランザクションが発生するたびに
        gtid_executed テーブルを圧縮します。0
        はこのテーブルを圧縮しないことを意味します。
        バイナリロギングが無効な場合にかぎり適用.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_gtid_mode">gtid_mode</a></code>:
        GTID
        ベースのロギングを有効にするかどうか、およびどのタイプのトランザクションログを含めることができるかを制御.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_gtid_next">gtid_next</a></code>:
        次のステートメントを実行する GTID
        を指定します。詳細は、ドキュメントを参照してください.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_gtid_owned">gtid_owned</a></code>:
        このクライアント (セッション)
        またはすべてのクライアントが所有する GTID
        のセットと、所有者 (グローバル) のスレッド
        ID。 読み取り専用.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_gtid_purged">gtid_purged</a></code>:
        バイナリログからパージされたすべての GTID
        のセット.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_init_slave">init_slave</a></code>:
        レプリカがソースに接続したときに実行されるステートメント.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_log_bin_trust_function_creators">log_bin_trust_function_creators</a></code>:
        0 (デフォルト) に設定すると、--log-bin
        を使用した場合、ストアドファンクションの作成は
        SUPER
        権限を持つユーザーに対してのみ許可され、作成された関数がバイナリロギングを中断しない場合にのみ許可されます.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_log_statements_unsafe_for_binlog">log_statements_unsafe_for_binlog</a></code>:
        エラー 1592
        警告がエラーログに書き込まれないようにします.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_master-info-file">master-info-file</a></code>:
        ソースを記憶し、I/O
        レプリケーションスレッドがソースバイナリログ内にあるファイルの場所と名前.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_master-retry-count">master-retry-count</a></code>:
        レプリカがソースへの接続を試行してから切断する回数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_master_info_repository">master_info_repository</a></code>:
        ソースバイナリログ内のソース情報およびレプリケーション
        I/O
        スレッドの場所を含む接続メタデータリポジトリをファイルまたはテーブルに書き込むかどうか.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_max_relay_log_size">max_relay_log_size</a></code>:
        ゼロでない場合、サイズがこの値を超えたときにリレーログは自動的に交替します。
        ゼロの場合、ローテーションが発生するサイズは
        max_binlog_size の値によって決まります.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_original_commit_timestamp">original_commit_timestamp</a></code>:
        トランザクションが元のソースでコミットされた時刻.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_immediate_server_version">immediate_server_version</a></code>:
        即時レプリケーションソースであるサーバーの
        MySQL Server リリース番号.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_original_server_version">original_server_version</a></code>:
        トランザクションが最初にコミットされたサーバーの
        MySQL Server リリース番号.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_relay_log">relay_log</a></code>:
        リレーログに使用する場所とベース名.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_relay_log_basename">relay_log_basename</a></code>:
        ファイル名を含むリレーログへの完全パス.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_relay_log_index">relay_log_index</a></code>:
        最後のリレーログのリストを保持するファイルに使用する場所と名前.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_relay_log_info_file">relay_log_info_file</a></code>:
        レプリカがリレーログに関する情報を記録するアプライアンスのメタデータリポジトリのファイル名.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_relay_log_info_repository">relay_log_info_repository</a></code>:
        リレーログ内のレプリケーション SQL
        スレッドの場所をファイルまたはテーブルに書き込むかどうか.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_relay_log_purge">relay_log_purge</a></code>:
        リレーログをパージするかどうかを決定.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_relay_log_recovery">relay_log_recovery</a></code>:
        起動時のソースからのリレーログファイルの自動回復を有効にするかどうか。クラッシュセーフレプリカに対して有効にする必要があります.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_relay_log_space_limit">relay_log_space_limit</a></code>:
        すべてのリレーログに使用する最大スペース.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-do-db">replicate-do-db</a></code>:
        レプリケーションを指定されたデータベースに制限するようにレプリケーション
        SQL スレッドに指示.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-do-table">replicate-do-table</a></code>:
        レプリケーションを指定されたテーブルに制限するようにレプリケーション
        SQL スレッドに指示.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-ignore-db">replicate-ignore-db</a></code>:
        指定されたデータベースにレプリケートしないようにレプリケーション
        SQL スレッドに指示.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-ignore-table">replicate-ignore-table</a></code>:
        レプリケーション SQL
        スレッドに、指定されたテーブルにレプリケートしないように指示.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-rewrite-db">replicate-rewrite-db</a></code>:
        元のデータベースとは異なる名前のデータベースへの更新.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-same-server-id">replicate-same-server-id</a></code>:
        レプリケーションでは、有効な場合、サーバー
        ID を持つイベントをスキップしないでください.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-wild-do-table">replicate-wild-do-table</a></code>:
        レプリケーション SQL
        スレッドに、指定されたワイルドカードパターンに一致するテーブルにレプリケーションを制限するように指示.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-wild-ignore-table">replicate-wild-ignore-table</a></code>:
        指定されたワイルドカードパターンに一致するテーブルにレプリケートしないようにレプリケーション
        SQL スレッドに指示.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_report_host">report_host</a></code>:
        レプリカ登録中にソースにレポートされるレプリカのホスト名または
        IP.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_report_password">report_password</a></code>:
        レプリカサーバーがソースにレポートする任意のパスワード。レプリケーションユーザーアカウントのパスワードと同じではありません.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_report_port">report_port</a></code>:
        レプリカ登録中にソースに報告されたレプリカに接続するためのポート.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_report_user">report_user</a></code>:
        レプリカサーバーがソースにレポートする任意のユーザー名。レプリケーションユーザーアカウントに使用される名前と同じではありません.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_clients">Rpl_semi_sync_master_clients</a></code>:
        準同期レプリカの数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_enabled">rpl_semi_sync_master_enabled</a></code>:
        準同期レプリケーションがソースで有効かどうか.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_net_avg_wait_time">Rpl_semi_sync_master_net_avg_wait_time</a></code>:
        ソースがレプリカからの返信を待機した平均時間.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_net_wait_time">Rpl_semi_sync_master_net_wait_time</a></code>:
        ソースがレプリカからの返信を待機した合計時間.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_net_waits">Rpl_semi_sync_master_net_waits</a></code>:
        ソースがレプリカからの返信を待機した合計回数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_no_times">Rpl_semi_sync_master_no_times</a></code>:
        ソースが準同期レプリケーションをオフにした回数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_no_tx">Rpl_semi_sync_master_no_tx</a></code>:
        肯定応答が成功しなかったコミットの数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_status">Rpl_semi_sync_master_status</a></code>:
        準同期レプリケーションがソースで動作しているかどうか.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_timefunc_failures">Rpl_semi_sync_master_timefunc_failures</a></code>:
        時間関数のコール時にソースが失敗した回数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_timeout">rpl_semi_sync_master_timeout</a></code>:
        レプリカ確認応答を待機するミリ秒数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_trace_level">rpl_semi_sync_master_trace_level</a></code>:
        ソースの準同期レプリケーションデバッグトレースレベル.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_tx_avg_wait_time">Rpl_semi_sync_master_tx_avg_wait_time</a></code>:
        ソースが各トランザクションを待機した平均時間.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_tx_wait_time">Rpl_semi_sync_master_tx_wait_time</a></code>:
        ソースがトランザクションを待機した合計時間.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_tx_waits">Rpl_semi_sync_master_tx_waits</a></code>:
        ソースがトランザクションを待機した合計回数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_for_slave_count">rpl_semi_sync_master_wait_for_slave_count</a></code>:
        続行する前に受信する必要があるレプリカ確認ソースの数
        (トランザクション当たり).
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_no_slave">rpl_semi_sync_master_wait_no_slave</a></code>:
        レプリカがなくてもソースがタイムアウトを待機するかどうか.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_point">rpl_semi_sync_master_wait_point</a></code>:
        レプリカトランザクション受信確認の待機ポイント.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_wait_pos_backtraverse">Rpl_semi_sync_master_wait_pos_backtraverse</a></code>:
        バイナリ座標が以前に待機したイベントより小さいイベントをソースが待機した合計回数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_wait_sessions">Rpl_semi_sync_master_wait_sessions</a></code>:
        レプリカ応答を現在待機しているセッションの数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_yes_tx">Rpl_semi_sync_master_yes_tx</a></code>:
        肯定応答が成功したコミットの数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_replication_sender_observe_commit_only">replication_sender_observe_commit_only</a></code>:
        準同期レプリケーションのための制限付きコールバック.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_replication_optimize_for_static_plugin_config">replication_optimize_for_static_plugin_config</a></code>:
        準同期レプリケーションの共有ロック.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_slave_enabled">rpl_semi_sync_slave_enabled</a></code>:
        準同期レプリケーションがレプリカで有効かどうか.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_slave_status">Rpl_semi_sync_slave_status</a></code>:
        準同期レプリケーションがレプリカで動作しているかどうか.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_slave_trace_level">rpl_semi_sync_slave_trace_level</a></code>:
        レプリカの準同期レプリケーションデバッグトレースレベル.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_rpl_read_size">rpl_read_size</a></code>:
        バイナリログファイルおよびリレーログファイルから読み取られるデータの最小量をバイト単位で設定.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_rpl_stop_slave_timeout">rpl_stop_slave_timeout</a></code>:
        STOP REPLICA または STOP SLAVE
        がタイムアウトするまで待機する秒数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_server_uuid">server_uuid</a></code>:
        サーバーの起動時に自動的に (再)
        生成されるサーバーグローバル一意 ID.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_show-slave-auth-info">show-slave-auth-info</a></code>:
        このソースの SHOW REPLICAS および SHOW SLAVE HOSTS
        のユーザー名とパスワードを表示.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_skip-slave-start">skip-slave-start</a></code>:
        設定されている場合、レプリケーションサーバーの起動時にレプリケーションは自動起動されません.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_slave_load_tmpdir">slave_load_tmpdir</a></code>:
        LOAD DATA
        ステートメントのレプリケート時にレプリカが一時ファイルを配置する場所.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_slave_net_timeout">slave_net_timeout</a></code>:
        読取りを中断する前にソース/レプリカ接続からの追加データを待機する秒数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-skip-errors">slave-skip-errors</a></code>:
        指定されたリストからクエリーでエラーが返された場合にレプリケーションを続行するようレプリケーションスレッドに指示.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_slave_checkpoint_group">slave_checkpoint_group</a></code>:
        進行状況ステータスを更新するためにチェックポイント操作がコールされる前にマルチスレッドレプリカによって処理されるトランザクションの最大数。
        NDB Cluster ではサポートされていません.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_slave_checkpoint_period">slave_checkpoint_period</a></code>:
        マルチスレッドレプリカの進行状況を更新し、このミリ秒後にリレーログ情報をディスクにフラッシュします。
        NDB Cluster ではサポートされていません.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_slave_compressed_protocol">slave_compressed_protocol</a></code>:
        ソース/レプリカプロトコルの圧縮の使用.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_slave_exec_mode">slave_exec_mode</a></code>:
        IDEMPOTENT モード
        (キーおよびその他のいくつかのエラーを抑制)
        と STRICT
        モードの間でレプリケーションスレッドを切り替えることができます。STRICT
        モードは NDB Cluster を除き、IDEMPOTENT
        が常に使用されます.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_slave_max_allowed_packet">slave_max_allowed_packet</a></code>:
        レプリケーションソースサーバーからレプリカに送信できるパケットの最大サイズ
        (バイト単位)。max_allowed_packet をオーバーライド.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Slave_open_temp_tables">Slave_open_temp_tables</a></code>:
        レプリケーション SQL
        スレッドが現在オープンしている一時テーブルの数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_slave_parallel_type">slave_parallel_type</a></code>:
        タイムスタンプ情報 (LOGICAL_CLOCK)
        またはデータベースパーティション化 (DATABASE)
        を使用してトランザクションをパラレル化するようレプリカに指示.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_slave_parallel_workers">slave_parallel_workers</a></code>:
        レプリケーショントランザクションをパラレルに実行するためのアプライヤスレッドの数。0
        はレプリカマルチスレッドを無効にします。
        MySQL クラスタではサポートされていません.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_slave_pending_jobs_size_max">slave_pending_jobs_size_max</a></code>:
        まだ適用されていないイベントを保持するレプリカワーカーキューの最大サイズ.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_slave_preserve_commit_order">slave_preserve_commit_order</a></code>:
        パラレルアプライヤスレッドの使用時に一貫性を維持するために、レプリカワーカーによるすべてのコミットがソースと同じ順序で発生するようにします.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_slave_rows_search_algorithms">slave_rows_search_algorithms</a></code>:
        レプリカのバッチ更新に使用される検索アルゴリズムを決定します。
        このリストの任意の 2 または 3: INDEX_SEARCH,
        TABLE_SCAN, HASH_SCAN.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Slave_rows_last_search_algorithm_used">Slave_rows_last_search_algorithm_used</a></code>:
        このレプリカが行ベースのレプリケーション
        (インデックス、テーブルまたはハッシュスキャン)
        のために最後に使用した検索アルゴリズム.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_slave_transaction_retries">slave_transaction_retries</a></code>:
        デッドロックまたは経過ロック待機タイムアウトで失敗した場合に、レプリケーション
        SQL
        スレッドがトランザクションを再試行してから停止する回数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_slave_type_conversions">slave_type_conversions</a></code>:
        レプリカの型変換モードを制御します。
        値は、このリストのゼロ個以上の要素のリストです:
        ALL_LOSSY, ALL_NON_LOSSY.
        ソースとレプリカ間の型変換を禁止するには、空の文字列に設定.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_sql_log_bin">sql_log_bin</a></code>:
        現在のセッションのバイナリロギングを制御.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_sql_slave_skip_counter">sql_slave_skip_counter</a></code>:
        レプリカがスキップするソースからのイベント数。
        GTID レプリケーションと互換性はありません.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_sync_master_info">sync_master_info</a></code>:
        # 番目のイベントごとに、master.info
        とディスクの同期を取ります.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_sync_relay_log">sync_relay_log</a></code>:
        #
        番目のイベントごとに、リレーログとディスクの同期を取ります.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_sync_relay_log_info">sync_relay_log_info</a></code>:
        # 番目のイベントごとに、relay.info
        ファイルとディスクの同期を取ります.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_transaction_write_set_extraction">transaction_write_set_extraction</a></code>:
        トランザクション中に抽出された書込みのハッシュに使用されるアルゴリズムを定義.
      </p></li></ul></div><p>
    <span class="command"><strong>mysqld</strong></span>
    で使用されるすべてのコマンドラインオプション、システム変数およびステータス変数のリストは、<a class="xref" href="server-administration.html#server-option-variable-reference" title="5.1.4 サーバーオプション、システム変数およびステータス変数リファレンス">セクション5.1.4「サーバーオプション、システム変数およびステータス変数リファレンス」</a>
    を参照してください。
  </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="binlog-optvars-list"></a>バイナリロギングのオプションと変数</h5></div></div></div><p>
    次のリストのコマンド行オプションとシステム変数は、バイナリログに関連しています。<a class="xref" href="replication.html#replication-options-binary-log" title="17.1.6.4 バイナリロギングのオプションと変数">セクション17.1.6.4「バイナリロギングのオプションと変数」</a>
    では、バイナリロギングに関連するオプションと変数について詳しく説明します。
    バイナリログに関するその他の一般情報については、<a class="xref" href="server-administration.html#binary-log" title="5.4.4 バイナリログ">セクション5.4.4「バイナリログ」</a>を参照してください。
  </p><div class="itemizedlist"><a name="binlog-optvar-summary-list"></a><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_binlog-checksum">binlog-checksum</a></code>:
        バイナリログチェックサムを有効化/無効化.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_binlog-do-db">binlog-do-db</a></code>:
        バイナリロギングを特定のデータベースに限定.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_binlog_format">binlog_format</a></code>:
        バイナリログの形式を指定.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_binlog-ignore-db">binlog-ignore-db</a></code>:
        指定されたデータベースへの更新をバイナリログに書き込まないようにソースに指示.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_binlog-row-event-max-size">binlog-row-event-max-size</a></code>:
        バイナリログの最大イベントサイズ.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_binlog_encryption">binlog_encryption</a></code>:
        このサーバー上のバイナリログファイルおよびリレーログファイルの暗号化を有効にします.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_binlog_rotate_encryption_master_key_at_startup">binlog_rotate_encryption_master_key_at_startup</a></code>:
        サーバー起動時のバイナリログマスターキーのローテーション.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Binlog_cache_disk_use">Binlog_cache_disk_use</a></code>:
        バイナリログキャッシュの代わりに一時ファイルを使用したトランザクションの数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_binlog_cache_size">binlog_cache_size</a></code>:
        トランザクション中にバイナリログの SQL
        ステートメントを保持するキャッシュのサイズ.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Binlog_cache_use">Binlog_cache_use</a></code>:
        一時バイナリログキャッシュを使用したトランザクションの数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_binlog_checksum">binlog_checksum</a></code>:
        バイナリログチェックサムを有効化/無効化.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_binlog_direct_non_transactional_updates">binlog_direct_non_transactional_updates</a></code>:
        非トランザクションエンジンへの、ステートメント形式を使用する更新が、直接バイナリログに書き込まれるようになります。
        使用する前にドキュメントを参照してください.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_binlog_error_action">binlog_error_action</a></code>:
        サーバーがバイナリログに書き込めない場合の動作を制御.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_binlog_group_commit_sync_delay">binlog_group_commit_sync_delay</a></code>:
        トランザクションをディスクに同期する前に待機するマイクロ秒数を設定.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_binlog_group_commit_sync_no_delay_count">binlog_group_commit_sync_no_delay_count</a></code>:
        binlog_group_commit_sync_delay
        で指定された現在の遅延を中断する前に待機するトランザクションの最大数を設定.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_binlog_max_flush_queue_time">binlog_max_flush_queue_time</a></code>:
        バイナリログにフラッシュするまでにどれくらいトランザクションを読み取るか.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_binlog_order_commits">binlog_order_commits</a></code>:
        バイナリログへの書き込みと同じ順序でコミットするかどうか.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_binlog_row_image">binlog_row_image</a></code>:
        行の変更のロギングの際にフルイメージまたは最少イメージを使用.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_binlog_row_metadata">binlog_row_metadata</a></code>:
        行ベースのロギングを使用している場合に、テーブル関連のすべてのメタデータをバイナリログに記録するか、最小限のメタデータのみを記録するか.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_binlog_row_value_options">binlog_row_value_options</a></code>:
        行ベースレプリケーションの部分 JSON
        更新のバイナリロギングを有効にします.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_binlog_rows_query_log_events">binlog_rows_query_log_events</a></code>:
        有効にすると、行ベースロギングの使用時に行クエリーログイベントのロギングが有効になります。
        デフォルトで無効になっています。 5.6
        より前のレプリカ/リーダーのログの生成時に有効にしないでください.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Binlog_stmt_cache_disk_use">Binlog_stmt_cache_disk_use</a></code>:
        バイナリログステートメントキャッシュの代わりに一時ファイルを使用した非トランザクションステートメントの数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_binlog_stmt_cache_size">binlog_stmt_cache_size</a></code>:
        トランザクション中にバイナリログの非トランザクションステートメントを保持するキャッシュのサイズ.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Binlog_stmt_cache_use">Binlog_stmt_cache_use</a></code>:
        一時バイナリログステートメントキャッシュを使用したステートメントの数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_binlog_transaction_compression">binlog_transaction_compression</a></code>:
        バイナリログファイル内のトランザクションペイロードの圧縮を有効にします.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_binlog_transaction_compression_level_zstd">binlog_transaction_compression_level_zstd</a></code>:
        バイナリログファイル内のトランザクションペイロードの圧縮レベル.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_binlog_transaction_dependency_tracking">binlog_transaction_dependency_tracking</a></code>:
        レプリカマルチスレッドアプリケーションでパラレルに実行できるトランザクションを評価する依存性情報
        (コミットタイムスタンプまたはトランザクション書込みセット)
        のソース.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_binlog_transaction_dependency_history_size">binlog_transaction_dependency_history_size</a></code>:
        一部の行を最後に更新したトランザクションを参照するために保持される行ハッシュの数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_show_binlog_events</a></code>:
        SHOW BINLOG EVENTS ステートメントの数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_show_binlogs</a></code>:
        SHOW BINLOGS ステートメントの数.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_log-bin">log-bin</a></code>:
        バイナリログファイルのベース名.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_log-bin-index">log-bin-index</a></code>:
        バイナリログインデックスファイル名.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_log_bin">log_bin</a></code>:
        バイナリログが有効かどうか.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_log_bin_basename">log_bin_basename</a></code>:
        バイナリログファイルのパスとベース名.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_log_bin_use_v1_row_events">log_bin_use_v1_row_events</a></code>:
        サーバーがバージョン 1
        バイナリログ行イベントを使用しているかどうか.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_log_slave_updates">log_slave_updates</a></code>:
        レプリケーション SQL
        スレッドによって実行された更新を独自のバイナリログに記録するかどうか.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_master_verify_checksum">master_verify_checksum</a></code>:
        バイナリログからの読み取り時にソースがチェックサムを検査するようにします.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_max-binlog-dump-events">max-binlog-dump-events</a></code>:
        mysql-test
        がレプリケーションのデバッグとテストに使用するオプション.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_max_binlog_cache_size">max_binlog_cache_size</a></code>:
        複数ステートメントトランザクションのキャッシュに使用する合計サイズを制限するために使用できます.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_max_binlog_size">max_binlog_size</a></code>:
        バイナリログは、サイズがこの値を超えると自動的にローテーションされます.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_max_binlog_stmt_cache_size">max_binlog_stmt_cache_size</a></code>:
        トランザクション中にすべての非トランザクションステートメントのキャッシュに使用される合計サイズを制限するために使用できます.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-sql-verify-checksum">slave-sql-verify-checksum</a></code>:
        リレーログからの読み取り時にレプリカがチェックサムを検査するようにします.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_slave_sql_verify_checksum">slave_sql_verify_checksum</a></code>:
        リレーログからの読み取り時にレプリカがチェックサムを検査するようにします.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#option_mysqld_sporadic-binlog-dump-fail">sporadic-binlog-dump-fail</a></code>:
        mysql-test
        がレプリケーションのデバッグとテストに使用するオプション.
      </p></li><li class="listitem"><p>
        <code class="literal"><a class="link" href="replication.html#sysvar_sync_binlog">sync_binlog</a></code>:
        #
        番目のイベントごとに、同期してバイナリログをディスクにフラッシュ.
      </p></li></ul></div><p>
    <span class="command"><strong>mysqld</strong></span>
    で使用されるすべてのコマンドラインオプション、システム変数およびステータス変数のリストは、<a class="xref" href="server-administration.html#server-option-variable-reference" title="5.1.4 サーバーオプション、システム変数およびステータス変数リファレンス">セクション5.1.4「サーバーオプション、システム変数およびステータス変数リファレンス」</a>
    を参照してください。
  </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-options-source"></a>17.1.6.2 レプリケーションソースのオプションと変数</h4></div></div></div><p>
      このセクションでは、レプリケーションソースサーバーで使用できるサーバーオプションおよびシステム変数について説明します。 オプションは<a class="link" href="programs.html#command-line-options" title="4.2.2.1 コマンド行でのオプションの使用">コマンド行</a>または<a class="link" href="programs.html#option-files" title="4.2.2.2 オプションファイルの使用">オプションファイル</a>で指定できます。 システム変数値は<code class="literal">SET</code> を使用して指定できます。 
    </p><p>
      ソースおよび各レプリカで、<code class="literal">server_id</code> システム変数を設定して一意のレプリケーション ID を確立する必要があります。 サーバーごとに、1 から 2 <sup>32</sup>− 1 の範囲の一意の正の整数を選択する必要があり、各 ID はレプリケーショントポロジ内の他のソースまたはレプリカで使用されている他のすべての ID と異なる必要があります。 例: <code class="literal">server-id=3</code>。 
    </p><p>
      バイナリロギングを制御するためにソースで使用されるオプションについては、<a class="xref" href="replication.html#replication-options-binary-log" title="17.1.6.4 バイナリロギングのオプションと変数">セクション17.1.6.4「バイナリロギングのオプションと変数」</a> を参照してください。
    </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-optvars-masters"></a>レプリケーションソースサーバーの起動オプション</h5></div></div></div><p>
        次のリストでは、レプリケーションソースサーバーを制御するための起動オプションについて説明します。 レプリケーションに関連するシステム変数はこのセクションの後半で説明します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_show-slave-auth-info"></a>
            <code class="option">--show-slave-auth-info</code>
          </p><a class="indexterm" name="idm46723656794592"></a><a class="indexterm" name="idm46723656792416"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for show-slave-auth-info"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--show-slave-auth-info[={OFF|ON}]</code></td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
            <code class="option">--report-user</code> および <code class="option">--report-password</code> オプションを使用して開始されたレプリカのソース上の <code class="literal">SHOW REPLICAS | SHOW SLAVE HOSTS</code> の出力に、レプリケーションユーザー名とパスワードを表示します。
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-sysvars-masters"></a>レプリケーションソースサーバーで使用されるシステム変数</h5></div></div></div><p>
        次のシステム変数は、レプリケーションソースサーバーに対して、またはレプリケーションソースサーバーによって使用されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="sysvar_auto_increment_increment"></a>
            <code class="literal">auto_increment_increment</code>
          </p><a class="indexterm" name="idm46723656772224"></a><a class="indexterm" name="idm46723656770672"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for auto_increment_increment"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--auto-increment-increment=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_auto_increment_increment">auto_increment_increment</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル、セッション</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>はい</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">65535</code></td>
</tr></tbody></table></div><p>
            <code class="literal">auto_increment_increment</code> および <code class="literal">auto_increment_offset</code> は、循環 (ソースからソース) レプリケーションでの使用を目的としており、<code class="literal">AUTO_INCREMENT</code> カラムの操作を制御するために使用できます。 両方の変数はグローバル値とセッション値を持ち、各値は 1 から 65,535 (1 と 65,535 を含みます) の間の整数値を取ることができます。 これらの 2 つの変数のいずれかの値を 0 に設定すると、代わりにその値は 1 に設定されます。 これらの 2 つの変数のいずれかの値を 65,535 より大きな整数または 0 より小さい整数に設定しようとすると、代わりにその値は 65,535 に設定されます。 <code class="literal">auto_increment_increment</code> または <code class="literal">auto_increment_offset</code> の値を整数でない値に設定しようとすると、エラーが発生し、変数の実際の値は変化しません。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">auto_increment_increment</code> は <code class="literal">NDB</code> テーブルで使用する場合にもサポートされます。
            </p></div><p>
            MySQL 8.0.18 では、このシステム変数のセッション値の設定は制限付き操作ではなくなりました。
          </p><p>
            グループレプリケーションがサーバーで開始されると、<code class="literal">auto_increment_increment</code> の値は <code class="literal">group_replication_auto_increment_increment</code> の値に変更され (デフォルトは 7 )、<code class="literal">auto_increment_offset</code> の値はサーバー ID に変更されます。 グループレプリケーションが停止すると、変更は元に戻されます。 これらの変更は、<code class="literal">auto_increment_increment</code> および <code class="literal">auto_increment_offset</code> のそれぞれのデフォルト値が 1 の場合にのみ行われ、元に戻されます。 これらの値がすでにデフォルトから変更されている場合、Group Replication はそれらを変更しません。 MySQL 8.0 からは、グループレプリケーションが単一プライマリモードで、サーバー書込みが 1 つのみの場合も、システム変数は変更されません。 
          </p><p>
            <code class="literal">auto_increment_increment</code> および <code class="literal">auto_increment_offset</code> は、<code class="literal">AUTO_INCREMENT</code> のカラムの動作に次のように影響します:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">auto_increment_increment</code> は、連続するカラム値の間隔を制御します。 例: 
              </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'auto_inc%';</code></strong>
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| auto_increment_increment | 1     |
| auto_increment_offset    | 1     |
+--------------------------+-------+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE autoinc1</code></strong>
    -&gt; <strong class="userinput"><code>(col INT NOT NULL AUTO_INCREMENT PRIMARY KEY);</code></strong>
  Query OK, 0 rows affected (0.04 sec)

mysql&gt; <strong class="userinput"><code>SET @@auto_increment_increment=10;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'auto_inc%';</code></strong>
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| auto_increment_increment | 10    |
| auto_increment_offset    | 1     |
+--------------------------+-------+
2 rows in set (0.01 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO autoinc1 VALUES (NULL), (NULL), (NULL), (NULL);</code></strong>
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT col FROM autoinc1;</code></strong>
+-----+
| col |
+-----+
|   1 |
|  11 |
|  21 |
|  31 |
+-----+
4 rows in set (0.00 sec)
</pre></li><li class="listitem"><p>
                <code class="literal">auto_increment_offset</code> は <code class="literal">AUTO_INCREMENT</code> カラム値の開始点を指定します。 次のことは、<code class="literal">auto_increment_increment</code> の記述で示した例のように、同じセッション中にこれらのステートメントが実行されるものと仮定しています。 
              </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET @@auto_increment_offset=5;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'auto_inc%';</code></strong>
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| auto_increment_increment | 10    |
| auto_increment_offset    | 5     |
+--------------------------+-------+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE autoinc2</code></strong>
    -&gt; <strong class="userinput"><code>(col INT NOT NULL AUTO_INCREMENT PRIMARY KEY);</code></strong>
Query OK, 0 rows affected (0.06 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO autoinc2 VALUES (NULL), (NULL), (NULL), (NULL);</code></strong>
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT col FROM autoinc2;</code></strong>
+-----+
| col |
+-----+
|   5 |
|  15 |
|  25 |
|  35 |
+-----+
4 rows in set (0.02 sec)
</pre><p>
                <code class="literal">auto_increment_offset</code> の値が <code class="literal">auto_increment_increment</code> の値よりも大きいと、<code class="literal">auto_increment_offset</code> の値は無視されます。
              </p></li></ul></div><p>
            これらの変数のいずれかが変更されてから、<code class="literal">AUTO_INCREMENT</code> カラムを含むテーブルに新しい行が挿入される場合、結果は反直感的に見える場合があります。<code class="literal">AUTO_INCREMENT</code> 値のシリーズがカラムにすでに存在する値に関係なく計算され、挿入される次の値が <code class="literal">AUTO_INCREMENT</code> カラムに存在する最大値よりも大きなシリーズ内最小値であるためです。 シリーズは次のように計算されます。 
          </p><p>
            <code class="literal">auto_increment_offset</code> + <em class="replaceable"><code>N</code></em> × <code class="literal">auto_increment_increment</code>
          </p><p>
            ここで、<em class="replaceable"><code>N</code></em> はシリーズ内正の整数値 [1, 2, 3, ...] です。 例: 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'auto_inc%';</code></strong>
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| auto_increment_increment | 10    |
| auto_increment_offset    | 5     |
+--------------------------+-------+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT col FROM autoinc1;</code></strong>
+-----+
| col |
+-----+
|   1 |
|  11 |
|  21 |
|  31 |
+-----+
4 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO autoinc1 VALUES (NULL), (NULL), (NULL), (NULL);</code></strong>
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT col FROM autoinc1;</code></strong>
+-----+
| col |
+-----+
|   1 |
|  11 |
|  21 |
|  31 |
|  35 |
|  45 |
|  55 |
|  65 |
+-----+
8 rows in set (0.00 sec)
</pre><p>
            <code class="literal">auto_increment_increment</code> と <code class="literal">auto_increment_offset</code> に示される値は、シリーズ 5 + <em class="replaceable"><code>N</code></em> × 10、つまり [5, 15, 25, 35, 45, ...] を生成します。 <code class="literal">INSERT</code> より前に <code class="literal">col</code> カラムに存在する最高値は 31、<code class="literal">AUTO_INCREMENT</code> シリーズ内で次に使用できる値は 35 なので、<code class="literal">col</code> に挿入される値はそのポイントで始まり、結果は <code class="literal">SELECT</code> クエリーで示されるようになります。 
          </p><p>
            これらの 2 つの変数の影響を単一テーブルに制限することはできません。これらの変数は MySQL サーバーの<span class="emphasis"><em>すべて</em></span>のテーブルのすべての <code class="literal">AUTO_INCREMENT</code> カラムの動作を制御します。 どちらかの変数のグローバル値が設定されると、グローバル値が変更されるか、セッション値の設定によってオーバーライドされるまで、または <span class="command"><strong>mysqld</strong></span> が再起動されるまでその効果は持続します。 ローカル値が設定されると、新しい値は、セッションの期間に現在のユーザーが新しい行を挿入したすべてのテーブルの <code class="literal">AUTO_INCREMENT</code> カラムに影響します (そのセッション中にそれらの値が変更される場合を除く)。 
          </p><p>
            <code class="literal">auto_increment_increment</code> のデフォルト値は 1 です。 <a class="xref" href="replication.html#replication-features-auto-increment" title="17.5.1.1 レプリケーションと AUTO_INCREMENT">セクション17.5.1.1「レプリケーションと AUTO_INCREMENT」</a>を参照してください。 
          </p></li><li class="listitem"><p><a name="sysvar_auto_increment_offset"></a>
            <code class="literal">auto_increment_offset</code>
          </p><a class="indexterm" name="idm46723656672896"></a><a class="indexterm" name="idm46723656671344"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for auto_increment_offset"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--auto-increment-offset=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_auto_increment_offset">auto_increment_offset</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル、セッション</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>はい</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">65535</code></td>
</tr></tbody></table></div><p>
            この変数のデフォルト値は 1 です。 デフォルト値のままにしておくと、グループレプリケーションがマルチプライマリモードでサーバーで起動され、サーバー ID に変更されます。 詳細については、<code class="literal">auto_increment_increment</code> の説明を参照してください。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">auto_increment_offset</code> は <code class="literal">NDB</code> テーブルで使用する場合にもサポートされます。
            </p></div><p>
            MySQL 8.0.18 では、このシステム変数のセッション値の設定は制限付き操作ではなくなりました。
          </p></li><li class="listitem"><p><a name="sysvar_immediate_server_version"></a>
            <code class="literal">immediate_server_version</code>
          </p><a class="indexterm" name="idm46723656637056"></a><a class="indexterm" name="idm46723656635504"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for immediate_server_version"><col style="width=30%"><col style="width=70%"><tbody><tr><th>導入</th>
<td>8.0.14</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_immediate_server_version">immediate_server_version</a></code></td>
</tr><tr><th>スコープ</th>
<td>セッション</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr></tbody></table></div><p>
            レプリケーションによる内部使用用。 このセッションシステム変数は、レプリケーショントポロジ内の直接のソースであるサーバーの MySQL Server リリース番号 (MySQL 8.0.14 サーバーインスタンスの <code class="literal">80014</code> など) を保持します。 この即時サーバーがセッションシステム変数をサポートしていないリリースの場合、変数の値は 0 (<code class="literal">UNKNOWN_SERVER_VERSION</code>) に設定されます。 
          </p><p>
            変数の値は、ソースからレプリカにレプリケートされます。 この情報を使用すると、関係するリリース間で構文変更またはセマンティック変更が発生した場所を認識し、それらを適切に処理することで、レプリカは古いリリースのソースから発生したデータを正しく処理できます。 この情報は、レプリケーショングループの 1 つ以上のメンバーが他のメンバーより新しいリリースであるグループレプリケーション環境でも使用できます。 変数の値は、(<code class="literal">Gtid_log_event</code> または GTID がサーバーで使用されていない場合は <code class="literal">Anonymous_gtid_log_event</code> の一部として) 各トランザクションのバイナリログに表示でき、バージョン間レプリケーションの問題のデバッグに役立つことがあります。 
          </p><p>
            このシステム変数のセッション値の設定は制限された操作です。 セッションユーザーには、<code class="literal">REPLICATION_APPLIER</code> 権限 (<a class="xref" href="replication.html#replication-privilege-checks" title="17.3.3 レプリケーション権限チェック">セクション17.3.3「レプリケーション権限チェック」</a> を参照) または制限付きセッション変数の設定に十分な権限 (<a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a> を参照) が必要です。 ただし、この変数はユーザーが設定するためのものではなく、レプリケーションインフラストラクチャによって自動的に設定されることに注意してください。 
          </p></li><li class="listitem"><p><a name="sysvar_original_server_version"></a>
            <code class="literal">original_server_version</code>
          </p><a class="indexterm" name="idm46723656604656"></a><a class="indexterm" name="idm46723656603104"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for original_server_version"><col style="width=30%"><col style="width=70%"><tbody><tr><th>導入</th>
<td>8.0.14</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_original_server_version">original_server_version</a></code></td>
</tr><tr><th>スコープ</th>
<td>セッション</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr></tbody></table></div><p>
            レプリケーションによる内部使用用。 このセッションシステム変数は、トランザクションが最初にコミットされたサーバーの MySQL Server リリース番号 (MySQL 8.0.14 サーバーインスタンスの <code class="literal">80014</code> など) を保持します。 この元のサーバーがセッションシステム変数をサポートしていないリリースの場合、変数の値は 0 (<code class="literal">UNKNOWN_SERVER_VERSION</code>) に設定されます。 リリース番号が元のサーバーによって設定されている場合、レプリケーショントポロジ内の即時サーバーまたはその他の介在するサーバーがセッションシステム変数をサポートしていないため、その値をレプリケートしないと、変数の値は 0 にリセットされます。 
          </p><p>
            変数の値は、<code class="literal">immediate_server_version</code> システム変数と同じ方法で設定および使用されます。 変数の値が <code class="literal">immediate_server_version</code> システム変数の値と同じである場合、後者のみがバイナリログに記録され、元のサーバーのバージョンが同じであることが示されます。 
          </p><p>
            グループレプリケーション環境では、変更ログイベントを表示します。変更ログイベントは、新しいメンバーがグループに参加したときに各グループメンバーによってキューに入れられる特別なトランザクションであり、トランザクションをキューに入れるグループメンバーのサーバーバージョンでタグ付けされます。 これにより、元のドナーのサーバーバージョンが参加メンバーに認識されるようになります。 特定のビュー変更に対してキューに入れられたビュー変更ログイベントは、すべてのメンバーで同じ GTID を持つため、この場合のみ、同じ GTID のインスタンスの元のサーバーバージョンが異なる可能性があります。 
          </p><p>
            このシステム変数のセッション値の設定は制限された操作です。 セッションユーザーには、<code class="literal">REPLICATION_APPLIER</code> 権限 (<a class="xref" href="replication.html#replication-privilege-checks" title="17.3.3 レプリケーション権限チェック">セクション17.3.3「レプリケーション権限チェック」</a> を参照) または制限付きセッション変数の設定に十分な権限 (<a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a> を参照) が必要です。 ただし、この変数はユーザーが設定するためのものではなく、レプリケーションインフラストラクチャによって自動的に設定されることに注意してください。 
          </p></li><li class="listitem"><p><a name="sysvar_rpl_semi_sync_master_enabled"></a>
            <code class="literal">rpl_semi_sync_master_enabled</code>
          </p><a class="indexterm" name="idm46723656569680"></a><a class="indexterm" name="idm46723656568112"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for rpl_semi_sync_master_enabled"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--rpl-semi-sync-master-enabled[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_enabled">rpl_semi_sync_master_enabled</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
            ソースサーバーで準同期レプリケーションを有効にするかどうかを制御します。 プラグインを有効または無効にするには、この変数を <code class="literal">ON</code> または <code class="literal">OFF</code> (あるいは 1 または 0) にそれぞれ設定します。 デフォルトは <code class="literal">OFF</code> です。 
          </p><p>
            この変数は、ソース側の準同期レプリケーションプラグインがインストールされている場合にのみ使用できます。
          </p></li><li class="listitem"><p><a name="sysvar_rpl_semi_sync_master_timeout"></a>
            <code class="literal">rpl_semi_sync_master_timeout</code>
          </p><a class="indexterm" name="idm46723656540128"></a><a class="indexterm" name="idm46723656538560"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for rpl_semi_sync_master_timeout"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--rpl-semi-sync-master-timeout=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_timeout">rpl_semi_sync_master_timeout</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">10000</code></td>
</tr></tbody></table></div><p>
            ソースがタイムアウトして非同期レプリケーションに戻る前にレプリカからの確認応答をコミットで待機する時間を制御するミリ秒単位の値。 デフォルト値は 10000 (10 秒) です。 
          </p><p>
            この変数は、ソース側の準同期レプリケーションプラグインがインストールされている場合にのみ使用できます。
          </p></li><li class="listitem"><p><a name="sysvar_rpl_semi_sync_master_trace_level"></a>
            <code class="literal">rpl_semi_sync_master_trace_level</code>
          </p><a class="indexterm" name="idm46723656512656"></a><a class="indexterm" name="idm46723656511072"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for rpl_semi_sync_master_trace_level"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--rpl-semi-sync-master-trace-level=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_trace_level">rpl_semi_sync_master_trace_level</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">32</code></td>
</tr></tbody></table></div><p>
            ソースサーバーの準同期レプリケーションのデバッグトレースレベル。 次の 4 つのレベルが定義されます: 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                1 = 一般レベル (時間関数の失敗など)
              </p></li><li class="listitem"><p>
                16 = 詳細レベル (詳細情報)
              </p></li><li class="listitem"><p>
                32 = ネット待機レベル (ネットワーク待機についての詳細情報)
              </p></li><li class="listitem"><p>
                64 = 関数レベル (関数の入口および出口についての情報)
              </p></li></ul></div><p>
            この変数は、ソース側の準同期レプリケーションプラグインがインストールされている場合にのみ使用できます。
          </p></li><li class="listitem"><p><a name="sysvar_rpl_semi_sync_master_wait_for_slave_count"></a>
            <code class="literal">rpl_semi_sync_master_wait_for_slave_count</code>
          </p><a class="indexterm" name="idm46723656481104"></a><a class="indexterm" name="idm46723656479488"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for rpl_semi_sync_master_wait_for_slave_count"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--rpl-semi-sync-master-wait-for-slave-count=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_for_slave_count">rpl_semi_sync_master_wait_for_slave_count</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">65535</code></td>
</tr></tbody></table></div><p>
            続行する前にソースがトランザクションごとに受信する必要があるレプリカ確認の数。 デフォルトでは、<code class="literal">rpl_semi_sync_master_wait_for_slave_count</code> は <code class="literal">1</code> です。つまり、準同期レプリケーションは、単一のレプリカ確認応答を受信した後に続行されます。 パフォーマンスは、この変数の小さい値に最適です。 
          </p><p>
            たとえば、<code class="literal">rpl_semi_sync_master_wait_for_slave_count</code> が <code class="literal">2</code> の場合、準同期レプリケーションを続行するには、<code class="literal">rpl_semi_sync_master_timeout</code> によって構成されたタイムアウト期間の前に、2 つのレプリカがトランザクションの受信を確認する必要があります。 タイムアウト期間中にトランザクションの受信を確認するレプリカの数が少ない場合、ソースは通常のレプリケーションに戻ります。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              この動作は <code class="literal">rpl_semi_sync_master_wait_no_slave</code> にも依存
            </p></div><p>
            この変数は、ソース側の準同期レプリケーションプラグインがインストールされている場合にのみ使用できます。
          </p></li><li class="listitem"><p><a name="sysvar_rpl_semi_sync_master_wait_no_slave"></a>
            <code class="literal">rpl_semi_sync_master_wait_no_slave</code>
          </p><a class="indexterm" name="idm46723656441376"></a><a class="indexterm" name="idm46723656439776"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for rpl_semi_sync_master_wait_no_slave"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--rpl-semi-sync-master-wait-no-slave[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_no_slave">rpl_semi_sync_master_wait_no_slave</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
            レプリカ数がタイムアウト期間中に <code class="literal">rpl_semi_sync_master_wait_for_slave_count</code> によって構成されたレプリカの数を下回る場合でも、<code class="literal">rpl_semi_sync_master_timeout</code> によって構成されたタイムアウト期間が経過するまでソースが待機するかどうかを制御します。
          </p><p>
            <code class="literal">rpl_semi_sync_master_wait_no_slave</code> の値が <code class="literal">ON</code> (デフォルト) の場合、レプリカ数はタイムアウト期間中に <code class="literal">rpl_semi_sync_master_wait_for_slave_count</code> 未満にドロップできます。 タイムアウト期間が経過する前に十分なレプリカがトランザクションを確認するかぎり、準同期レプリケーションは続行されます。 
          </p><p>
            <code class="literal">rpl_semi_sync_master_wait_no_slave</code> の値が <code class="literal">OFF</code> の場合、<code class="literal">rpl_semi_sync_master_timeout</code> で構成されたタイムアウト期間中に <code class="literal">rpl_semi_sync_master_wait_for_slave_count</code> で構成された数より少ない数にレプリカ数がドロップされると、ソースは通常のレプリケーションに戻ります。
          </p><p>
            この変数は、ソース側の準同期レプリケーションプラグインがインストールされている場合にのみ使用できます。
          </p></li><li class="listitem"><p><a name="sysvar_rpl_semi_sync_master_wait_point"></a>
            <code class="literal">rpl_semi_sync_master_wait_point</code>
          </p><a class="indexterm" name="idm46723656404240"></a><a class="indexterm" name="idm46723656402656"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for rpl_semi_sync_master_wait_point"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--rpl-semi-sync-master-wait-point=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_master_wait_point">rpl_semi_sync_master_wait_point</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">AFTER_SYNC</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">AFTER_SYNC</code></p><p class="valid-value"><code class="literal">AFTER_COMMIT</code></p></td>
</tr></tbody></table></div><p>
            この変数は、準同期レプリケーションソースサーバーがトランザクションをコミットしたクライアントにステータスを返す前に、トランザクション受信のレプリカ確認を待機するポイントを制御します。 次の値を使用できます: 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">AFTER_SYNC</code> (デフォルト): ソースは、各トランザクションをバイナリログとレプリカに書き込み、バイナリログをディスクに同期します。 ソースは、同期後にトランザクション受信のレプリカ確認を待機します。 確認応答を受信すると、ソースはトランザクションをストレージエンジンにコミットし、クライアントに結果を返してから続行できます。 
              </p></li><li class="listitem"><p>
                <code class="literal">AFTER_COMMIT</code>: ソースは、各トランザクションをバイナリログとレプリカに書き込み、バイナリログを同期し、トランザクションをストレージエンジンにコミットします。 ソースは、コミット後にトランザクション受信のレプリカ確認を待機します。 確認を受信すると、ソースは結果をクライアントに返し、クライアントは続行できます。 
              </p></li></ul></div><p>
            これらの設定のレプリケーション特性は、次のように異なります:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">AFTER_SYNC</code> では、すべてのクライアントに同時にコミットされたトランザクションが表示されます: レプリカによって確認され、ソース上のストレージエンジンにコミットされたあと。 したがって、すべてのクライアントにソース上の同じデータが表示されます。 
              </p><p>
                ソース障害が発生した場合、ソースでコミットされたすべてのトランザクションがレプリカにレプリケートされます (リレーログに保存されます)。 レプリカが最新であるため、ソースサーバーの予期しない終了およびレプリカへのフェイルオーバーは失われません。 ただし、バイナリログリカバリ後に外部化された場合にレプリカとの競合を引き起こすコミットされていないトランザクションがバイナリログに含まれる可能性があるため、このシナリオではソースを再起動できず、破棄する必要があることに注意してください。 
              </p></li><li class="listitem"><p>
                <code class="literal">AFTER_COMMIT</code> では、サーバーがストレージエンジンにコミットしてレプリカの確認応答を受信したあとにのみ、トランザクションを発行するクライアントは戻りステータスを取得します。 コミット後およびレプリカの確認前に、他のクライアントはコミット中のクライアントの前にコミット済トランザクションを確認できます。 
              </p><p>
                レプリカがトランザクションを処理しないなどの問題が発生した場合は、予期しないソースサーバーが終了してレプリカにフェイルオーバーしたときに、そのようなクライアントがソースで見た内容と比較してデータが失われる可能性があります。
              </p></li></ul></div><p>
            この変数は、ソース側の準同期レプリケーションプラグインがインストールされている場合にのみ使用できます。
          </p><p>
            MySQL 5.7 での <code class="literal">rpl_semi_sync_master_wait_point</code> の追加により、準同期インタフェースバージョンが増分されるため、バージョン互換性制約が作成されました: MySQL 5.7 以上のサーバーは、旧バージョンの準同期レプリケーションプラグインでは動作しません。また、旧バージョンのサーバーは、MySQL 5.7 以上の準同期レプリケーションプラグインでは動作しません。
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-options-replica"></a>17.1.6.3 Replica Server のオプションと変数</h4></div></div></div><p>
      このセクションでは、レプリカサーバーに適用されるサーバーオプションおよびシステム変数について説明します。このセクションの内容は次のとおりです:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="replication.html#replication-optvars-slaves" title="Replica Server の起動オプション">Replica Server の起動オプション</a></p></li><li class="listitem"><p><a class="xref" href="replication.html#replication-sysvars-slaves" title="レプリカサーバーで使用されるシステム変数">レプリカサーバーで使用されるシステム変数</a></p></li></ul></div><p>
      オプションは<a class="link" href="programs.html#command-line-options" title="4.2.2.1 コマンド行でのオプションの使用">コマンド行</a>または<a class="link" href="programs.html#option-files" title="4.2.2.2 オプションファイルの使用">オプションファイル</a>で指定します。 サーバーの実行中に、(MySQL 8.0.23 の) <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントまたは (MySQL 8.0.23 の前の) <code class="literal">CHANGE MASTER TO</code> ステートメントを使用して、多くのオプションを設定できます。 システム変数値は <code class="literal">SET</code> を使用して指定します。 
    </p><p><b>サーバー ID. </b>
        ソースおよび各レプリカで、<code class="literal">server_id</code> システム変数を設定して、1 から 2 <sup>32</sup>− 1 の範囲の一意のレプリケーション ID を確立する必要があります。 <span class="quote">「<span class="quote">Unique</span>」</span> は、各 ID がレプリケーショントポロジ内の他のソースまたはレプリカで使用されている他のすべての ID と異なる必要があることを意味します。 <code class="filename">my.cnf</code> ファイルの例: 
      </p><pre class="programlisting">[mysqld]
server-id=3
</pre><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-optvars-slaves"></a>Replica Server の起動オプション</h5></div></div></div><p>
        このセクションでは、レプリカサーバーを制御するための起動オプションについて説明します。 これらのオプションの多くは、(MySQL 8.0.23 の) <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントまたは (MySQL 8.0.23 の前の) <code class="literal">CHANGE MASTER TO</code> ステートメントを使用して、サーバーの実行中に設定できます。 その他のオプション (<code class="option">--replicate-*</code> オプションなど) は、レプリカサーバーの起動時にのみ設定できます。 レプリケーションに関連するシステム変数はこのセクションの後半で説明します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_master-info-file"></a>
            <code class="option">--master-info-file=<em class="replaceable"><code>file_name</code></em></code>
          </p><a class="indexterm" name="idm46723656336544"></a><a class="indexterm" name="idm46723656334384"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for master-info-file"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--master-info-file=file_name</code></td>
</tr><tr><th>非推奨</th>
<td>8.0.18</td>
</tr><tr><th>型</th>
<td>ファイル名</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">master.info</code></td>
</tr></tbody></table></div><p>
            このオプションの使用は非推奨になりました。 <code class="literal">master_info_repository=FILE</code> が設定されている場合は、レプリカ接続メタデータリポジトリのファイル名を設定するために使用されていました。接続メタデータリポジトリのファイルの使用がクラッシュセーフテーブルに置き換えられたため、<code class="option">--master-info-file</code> および <code class="literal">master_info_repository</code> システム変数の使用は非推奨になりました。 接続メタデータリポジトリの詳細は、<a class="xref" href="replication.html#replica-logs-status" title="17.2.4.2 レプリケーションメタデータリポジトリ">セクション17.2.4.2「レプリケーションメタデータリポジトリ」</a> を参照してください。 
          </p></li><li class="listitem"><p><a name="option_mysqld_master-retry-count"></a>
            <code class="option">--master-retry-count=<em class="replaceable"><code>count</code></em></code>
          </p><a class="indexterm" name="idm46723656313280"></a><a class="indexterm" name="idm46723656311120"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for master-retry-count"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--master-retry-count=#</code></td>
</tr><tr><th>非推奨</th>
<td>はい</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">86400</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値 (64 ビットプラットフォーム)</th>
<td><code class="literal">18446744073709551615</code></td>
</tr><tr><th>最大値 (32 ビットプラットフォーム)</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
            レプリカがソースへの再接続を試行してから中止する回数。 デフォルト値は 86400 回です。 値 0 は<span class="quote">「<span class="quote">「無限」</span>」</span>を意味し、レプリカは永久に接続を試みます。 再接続の試行は、レプリカが (<code class="literal">slave_net_timeout</code> システム変数で指定された) 接続タイムアウトに達したときに、ソースからデータまたはハートビートシグナルを受信せずにトリガーされます。 再接続は、<code class="literal">CHANGE REPLICATION SOURCE TO</code>|<code class="literal">CHANGE MASTER TO</code> ステートメントの <code class="literal">SOURCE_CONNECT_RETRY</code> | <code class="literal">MASTER_CONNECT_RETRY</code> オプションで設定された間隔 (デフォルトは 60 秒ごと) で試行されます。 
          </p><p>
            このオプションは非推奨です。将来の MySQL リリースで削除される予定です。 かわりに、<code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントの <code class="literal">SOURCE_RETRY_COUNT</code> | <code class="literal">MASTER_RETRY_COUNT</code> オプションを使用してください。 
          </p></li><li class="listitem"><p><a name="option_mysqld_max-relay-log-size"></a>
            <code class="option">--max-relay-log-size=<em class="replaceable"><code>size</code></em></code>
          </p><a class="indexterm" name="idm46723656277040"></a><a class="indexterm" name="idm46723656274880"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for max_relay_log_size"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--max-relay-log-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_max_relay_log_size">max_relay_log_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">1073741824</code></td>
</tr></tbody></table></div><p>
            このサイズで、サーバーはリレーログファイルを自動的にローテーションします。 この値がゼロでない場合は、サイズがこの値を超えたときにリレーログは自動的にローテーションされます。 この値がゼロ (デフォルト) の場合、リレーログローテーションが発生するサイズは <code class="literal">max_binlog_size</code> の値によって決められます。 詳細は、<a class="xref" href="replication.html#replica-logs-relaylog" title="17.2.4.1 リレーログ">セクション17.2.4.1「リレーログ」</a>を参照してください。 
          </p></li><li class="listitem"><p><a name="option_mysqld_relay-log-purge"></a>
            <code class="option">--relay-log-purge={0|1}</code>
          </p><a class="indexterm" name="idm46723656243280"></a><a class="indexterm" name="idm46723656241120"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for relay_log_purge"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--relay-log-purge[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_purge">relay_log_purge</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
            リレーログファイルが不要になるとすぐに自動的にパージすることを無効または有効にします。 デフォルト値は 1 (有効)です。 これは <code class="literal">SET GLOBAL relay_log_purge = <em class="replaceable"><code>N</code></em></code> で動的に変更できるグローバル変数です。 <code class="option">--relay-log-recovery</code> オプションを有効にするときにリレーログのパージを無効にすると、データの整合性が損なわれるため、クラッシュセーフではありません。 
          </p></li><li class="listitem"><p><a name="option_mysqld_relay-log-space-limit"></a>
            <code class="option">--relay-log-space-limit=<em class="replaceable"><code>size</code></em></code>
          </p><a class="indexterm" name="idm46723656213936"></a><a class="indexterm" name="idm46723656211712"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for relay_log_space_limit"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--relay-log-space-limit=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_space_limit">relay_log_space_limit</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値 (64 ビットプラットフォーム)</th>
<td><code class="literal">18446744073709551615</code></td>
</tr><tr><th>最大値 (32 ビットプラットフォーム)</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
            このオプションは、レプリカ上のすべてのリレーログの合計サイズの上限をバイト単位で設定します。 値 0 は <span class="quote">「<span class="quote">制限なし</span>」</span>を表します これは、ディスク容量が限られたレプリカサーバーホストに役立ちます。 制限に達すると、SQL スレッドがいくつかの未使用のリレーログをキャッチアップして削除するまで、I/O スレッドはソースサーバーからのバイナリログイベントの読み取りを停止します。 この制限は絶対ではありません。SQL スレッドがリレーログを削除する前により多くのイベントを必要とする場合があります。 その場合、SQL スレッドが一部のリレーログを削除できるようになるまで I/O スレッドは制限を超えます。そうしないとデッドロックになるためです。 <code class="option">--relay-log-space-limit</code> を <code class="option">--max-relay-log-size</code> (または <code class="option">--max-relay-log-size</code> が 0 の場合は <code class="option">--max-binlog-size</code>) の値の 2 倍未満に設定しないでください。 その場合、I/O スレッドが空き領域を待機する可能性があります。<code class="option">--relay-log-space-limit</code> を超えたけれども、SQL スレッドはパージするリレーログを持たず、I/O スレッドを満たすことができないためです。 この場合、I/O スレッドは強制的に <code class="option">--relay-log-space-limit</code> を一時的に無視します。 
          </p></li><li class="listitem"><p><a name="option_mysqld_replicate-do-db"></a>
            <code class="option">--replicate-do-db=<em class="replaceable"><code>db_name</code></em></code>
          </p><a class="indexterm" name="idm46723656172608"></a><a class="indexterm" name="idm46723656170448"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for replicate-do-db"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--replicate-do-db=name</code></td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
            データベースの名前を使用してレプリケーションフィルタを作成します。 このようなフィルタは、<code class="literal">CHANGE REPLICATION FILTER REPLICATE_DO_DB</code> を使用しても作成できます。 
          </p><p>
            このオプションでは、チャネル固有のレプリケーションフィルタがサポートされているため、マルチソースレプリカは異なるソースに対して特定のフィルタを使用できます。 <em class="replaceable"><code>channel_1</code></em> という名前のチャネルでチャネル固有のレプリケーションフィルタを構成するには、<code class="option">--replicate-do-db:<em class="replaceable"><code>channel_1</code></em> :<em class="replaceable"><code>db_name</code></em></code> を使用します。 この場合、最初のコロンはセパレータとして解釈され、後続のコロンはリテラルコロンです。 詳しくは<a class="xref" href="replication.html#replication-rules-channel-based-filters" title="17.2.5.4 レプリケーションチャネルベースのフィルタ">セクション17.2.5.4「レプリケーションチャネルベースのフィルタ」</a>をご覧ください。 
          </p><p>
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                グループレプリケーション用に構成された MySQL サーバーインスタンスでは、グローバルレプリケーションフィルタを使用できません。これは、一部のサーバーでトランザクションをフィルタすると、グループが一貫性のある状態で承諾に到達できなくなるためです。 グループメンバーがグループ外のソースへのレプリカとしても機能する場合など、グループレプリケーションに直接関与しないレプリケーションチャネルでチャネル固有のレプリケーションフィルタを使用できます。 <code class="literal">group_replication_applier</code> または <code class="literal">group_replication_recovery</code> チャネルでは使用できません。 
              </p></div><p>
          </p><p>
            このレプリケーションフィルタの正確な効果は、ステートメントベースレプリケーションと行ベースレプリケーションのどちらが使用されているかによって異なります。
          </p><p><b>ステートメントベースのレプリケーション. </b>
              レプリケーション SQL スレッドに、デフォルトデータベース (つまり、<code class="literal">USE</code> によって選択されたデータベース) が <em class="replaceable"><code>db_name</code></em> であるステートメントにレプリケーションを制限するように指示します。 複数のデータベースを指定するには、このオプションを複数回 (データベースごとに 1 回) 使用します。ただし、このようにすると別のデータベースは選択される (またはデータベースが選択されない) けれども、<code class="literal">UPDATE <em class="replaceable"><code>some_db.some_table</code></em> SET foo='bar'</code> などのクロスデータベースステートメントを複製<span class="emphasis"><em>しません</em></span>。 
            </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
              複数のデータベースを指定するには、このオプションの複数インスタンスを使用する<span class="emphasis"><em>必要があります</em></span>。 データベース名にはカンマを含めることができるため、カンマ区切りリストを指定すると、リストは単一のデータベースの名前として扱われます。 
            </p></div><p>
            ステートメントベースレプリケーションの使用時に予想どおりに機能しないことの例: レプリカが <code class="option">--replicate-do-db=sales</code> で起動され、ソースで次のステートメントを発行した場合、<code class="literal">UPDATE</code> ステートメントはレプリケートされません:
          </p><pre class="programlisting">USE prices;
UPDATE sales.january SET amount=amount+1000;
</pre><p>
            この<span class="quote">「<span class="quote">デフォルトデータベースだけをチェックする</span>」</span>動作の主な理由は、ステートメントだけから複製すべきかどうかを知るのが難しいためです (たとえば、複数のデータベースをまたがって動作する複数テーブル<code class="literal">DELETE</code> ステートメントまたは <code class="literal">UPDATE</code> ステートメントを使用する場合)。 また、必要がない場合、すべてのデータベースではなくデフォルトデータベースだけをチェックする方が早いです。 
          </p><p><b>行ベースのレプリケーション. </b>
              レプリケーションをデータベース <em class="replaceable"><code>db_name</code></em> に制限するようにレプリケーション SQL スレッドに指示します。 <em class="replaceable"><code>db_name</code></em> に属するテーブルだけが変更されます。現在のデータベースはこれに影響しません。 レプリカが <code class="option">--replicate-do-db=sales</code> で開始され、行ベースのレプリケーションが有効になっているとします。その後、次のステートメントがソースで実行されます: 
            </p><pre class="programlisting">USE prices;
UPDATE sales.february SET amount=amount+100;
</pre><p>
            レプリカ上の <code class="literal">sales</code> データベース内の <code class="literal">february</code> テーブルは、<code class="literal">UPDATE</code> ステートメントに従って変更されます。これは、<code class="literal">USE</code> ステートメントが発行されたかどうかに関係なく発生します。 ただし、行ベースのレプリケーションおよび <code class="option">--replicate-do-db=sales</code> を使用している場合、ソースで次のステートメントを発行してもレプリカには影響しません: 
          </p><pre class="programlisting">USE prices;
UPDATE prices.march SET amount=amount-25;
</pre><p>
            ステートメント <code class="literal">USE prices</code> が <code class="literal">USE sales</code> に変更された場合でも、<code class="literal">UPDATE</code> ステートメントの結果は複製されません。
          </p><p>
            <code class="option">--replicate-do-db</code> が行ベースレプリケーションとステートメントベースレプリケーションでどのように扱われるかについてもう 1 つ重要な違いは、複数のデータベースを参照するステートメントで発生します。 レプリカが <code class="option">--replicate-do-db=db1</code> で起動され、次のステートメントがソースで実行されるとします: 
          </p><pre class="programlisting">USE db1;
UPDATE db1.table1, db2.table2 SET db1.table1.col1 = 10, db2.table2.col2 = 20;
</pre><p>
            ステートメントベースレプリケーションを使用している場合は、両方のテーブルがレプリカで更新されます。 ただし、行ベースのレプリケーションを使用している場合、レプリカに対する影響を受けるのは <code class="literal">table1</code> のみです。<code class="literal">table2</code> は別のデータベースにあるため、レプリカ上の <code class="literal">table2</code> は <code class="literal">UPDATE</code> によって変更されません。 ここで、<code class="literal">USE db1</code> ステートメントの代わりに、<code class="literal">USE db4</code> ステートメントが使用されたものとします。 
          </p><pre class="programlisting">USE db4;
UPDATE db1.table1, db2.table2 SET db1.table1.col1 = 10, db2.table2.col2 = 20;
</pre><p>
            この場合、ステートメントベースのレプリケーションを使用しても、<code class="literal">UPDATE</code> ステートメントはレプリカに影響しません。 ただし、行ベースのレプリケーションを使用している場合、<code class="literal">UPDATE</code> はレプリカ上の <code class="literal">table1</code> を変更しますが、<code class="literal">table2</code> は変更しません。つまり、<code class="option">--replicate-do-db</code> によって指定されたデータベース内のテーブルのみが変更され、デフォルトデータベースの選択はこの動作に影響しません。 
          </p><p>
            クロスデータベース更新を機能させる必要がある場合は、代わりに <code class="option">--replicate-wild-do-table=<em class="replaceable"><code>db_name</code></em>.%</code> を使用してください。 <a class="xref" href="replication.html#replication-rules" title="17.2.5 サーバーがレプリケーションフィルタリングルールをどのように評価するか">セクション17.2.5「サーバーがレプリケーションフィルタリングルールをどのように評価するか」</a>を参照してください。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              このオプションは、<code class="option">--binlog-do-db</code> がバイナリロギングに影響するのと同じ方法でレプリケーションに影響し、<code class="option">--replicate-do-db</code> がレプリケーション動作にどのように影響するかに対してレプリケーション形式がどのように影響するかは、<code class="option">--binlog-do-db</code> 動作に対してロギング形式がどのように影響するかと同じです。
            </p><p>
              このオプションは、<code class="literal">BEGIN</code>、<code class="literal">COMMIT</code>、または <code class="literal">ROLLBACK</code> ステートメントに影響しません。
            </p></div></li><li class="listitem"><p><a name="option_mysqld_replicate-ignore-db"></a>
            <code class="option">--replicate-ignore-db=<em class="replaceable"><code>db_name</code></em></code>
          </p><a class="indexterm" name="idm46723656093168"></a><a class="indexterm" name="idm46723656091008"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for replicate-ignore-db"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--replicate-ignore-db=name</code></td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
            データベースの名前を使用してレプリケーションフィルタを作成します。 このようなフィルタは、<code class="literal">CHANGE REPLICATION FILTER REPLICATE_IGNORE_DB</code> を使用しても作成できます。 
          </p><p>
            このオプションでは、チャネル固有のレプリケーションフィルタがサポートされているため、マルチソースレプリカは異なるソースに対して特定のフィルタを使用できます。 <em class="replaceable"><code>channel_1</code></em> という名前のチャネルでチャネル固有のレプリケーションフィルタを構成するには、<code class="option">--replicate-ignore-db:<em class="replaceable"><code>channel_1</code></em> :<em class="replaceable"><code>db_name</code></em></code> を使用します。 この場合、最初のコロンはセパレータとして解釈され、後続のコロンはリテラルコロンです。 詳しくは<a class="xref" href="replication.html#replication-rules-channel-based-filters" title="17.2.5.4 レプリケーションチャネルベースのフィルタ">セクション17.2.5.4「レプリケーションチャネルベースのフィルタ」</a>をご覧ください。 
          </p><p>
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                グループレプリケーション用に構成された MySQL サーバーインスタンスでは、グローバルレプリケーションフィルタを使用できません。これは、一部のサーバーでトランザクションをフィルタすると、グループが一貫性のある状態で承諾に到達できなくなるためです。 グループメンバーがグループ外のソースへのレプリカとしても機能する場合など、グループレプリケーションに直接関与しないレプリケーションチャネルでチャネル固有のレプリケーションフィルタを使用できます。 <code class="literal">group_replication_applier</code> または <code class="literal">group_replication_recovery</code> チャネルでは使用できません。 
              </p></div><p>
          </p><p>
            無視するデータベースを複数指定するには、このオプションを複数回 (データベースごとに 1 回) 使用します。 データベース名にはカンマを含めることができるため、カンマ区切りリストを指定すると、単一のデータベースの名前として扱われます。 
          </p><p>
            <code class="option">--replicate-do-db</code> と同様に、このフィルタリングの正確な効果は、ステートメントベースと行ベースのどちらのレプリケーションが使用されているかによって異なり、次のいくつかの段落で説明します。
          </p><p><b>ステートメントベースのレプリケーション. </b>
              デフォルトデータベース (つまり、<code class="literal">USE</code> によって選択されたデータベース) が <em class="replaceable"><code>db_name</code></em> であるステートメントをレプリケートしないようにレプリケーション SQL スレッドに指示します。
            </p><p><b>行ベースのレプリケーション. </b>
              データベース <em class="replaceable"><code>db_name</code></em> 内のテーブルを更新しないようにレプリケーション SQL スレッドに指示します。 デフォルトデータベースは影響しません。 
            </p><p>
            ステートメントベースレプリケーションを使用する場合、次の例は予期したとおりに機能しません。 レプリカが <code class="option">--replicate-ignore-db=sales</code> で起動され、ソースで次のステートメントを発行するとします: 
          </p><pre class="programlisting">USE prices;
UPDATE sales.january SET amount=amount+1000;
</pre><p>
            このような場合 <code class="literal">UPDATE</code> ステートメントは複製され<span class="emphasis"><em>ます</em></span>。<code class="option">--replicate-ignore-db</code> が (<code class="literal">USE</code> ステートメントで指定された) デフォルトデータベースにのみ適用されるためです。 <code class="literal">sales</code> データベースがステートメントで明示的に指定されたため、ステートメントはフィルタされませんでした。 ただし、行ベースのレプリケーションを使用している場合、<code class="literal">UPDATE</code> ステートメントの効果はレプリカに伝播されず、<code class="literal">sales.january</code> テーブルのレプリカコピーは変更されません。この場合、<code class="option">--replicate-ignore-db=sales</code> によって <code class="literal">sales</code> データベースのソースコピーのテーブルに対して行われた <span class="emphasis"><em>all</em></span> の変更はレプリカによって無視されます。 
          </p><p>
            クロスデータベース更新を使用していて、これらの更新を複製したくない場合は、このオプションを使用しないでください。 <a class="xref" href="replication.html#replication-rules" title="17.2.5 サーバーがレプリケーションフィルタリングルールをどのように評価するか">セクション17.2.5「サーバーがレプリケーションフィルタリングルールをどのように評価するか」</a>を参照してください。 
          </p><p>
            クロスデータベース更新を機能させる必要がある場合、代わりに <code class="option">--replicate-wild-ignore-table=<em class="replaceable"><code>db_name</code></em>.%</code> を使用してください。 <a class="xref" href="replication.html#replication-rules" title="17.2.5 サーバーがレプリケーションフィルタリングルールをどのように評価するか">セクション17.2.5「サーバーがレプリケーションフィルタリングルールをどのように評価するか」</a>を参照してください。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              このオプションは、<code class="option">--binlog-ignore-db</code> がバイナリロギングに影響するのと同じ方法でレプリケーションに影響し、<code class="option">--replicate-ignore-db</code> がレプリケーション動作にどのように影響するかに対してレプリケーション形式がどのように影響するかは、<code class="option">--binlog-ignore-db</code> 動作に対してロギング形式がどのように影響するかと同じです。
            </p><p>
              このオプションは、<code class="literal">BEGIN</code>、<code class="literal">COMMIT</code>、または <code class="literal">ROLLBACK</code> ステートメントに影響しません。
            </p></div></li><li class="listitem"><p><a name="option_mysqld_replicate-do-table"></a>
            <code class="option">--replicate-do-table=<em class="replaceable"><code>db_name.tbl_name</code></em></code>
          </p><a class="indexterm" name="idm46723656037840"></a><a class="indexterm" name="idm46723656035680"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for replicate-do-table"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--replicate-do-table=name</code></td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
            レプリケーションを特定のテーブルに制限するようにレプリケーション SQL スレッドに指示することで、レプリケーションフィルタを作成します。 複数のテーブルを指定するには、このオプションを複数回 (テーブルごとに 1 回) 使用します。 <code class="option">--replicate-do-db</code> とは対照的に、これはクロスデータベース更新とデフォルトデータベース更新の両方に機能します。 <a class="xref" href="replication.html#replication-rules" title="17.2.5 サーバーがレプリケーションフィルタリングルールをどのように評価するか">セクション17.2.5「サーバーがレプリケーションフィルタリングルールをどのように評価するか」</a>を参照してください。 このようなフィルタは、<code class="literal">CHANGE REPLICATION FILTER REPLICATE_DO_TABLE</code> ステートメントを発行して作成することもできます。 
          </p><p>
            このオプションでは、チャネル固有のレプリケーションフィルタがサポートされているため、マルチソースレプリカは異なるソースに対して特定のフィルタを使用できます。 <em class="replaceable"><code>channel_1</code></em> という名前のチャネルでチャネル固有のレプリケーションフィルタを構成するには、<code class="option">--replicate-do-table:<em class="replaceable"><code>channel_1</code></em> :<em class="replaceable"><code>db_name.tbl_name</code></em></code> を使用します。 この場合、最初のコロンはセパレータとして解釈され、後続のコロンはリテラルコロンです。 詳しくは<a class="xref" href="replication.html#replication-rules-channel-based-filters" title="17.2.5.4 レプリケーションチャネルベースのフィルタ">セクション17.2.5.4「レプリケーションチャネルベースのフィルタ」</a>をご覧ください。 
          </p><p>
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                グループレプリケーション用に構成された MySQL サーバーインスタンスでは、グローバルレプリケーションフィルタを使用できません。これは、一部のサーバーでトランザクションをフィルタすると、グループが一貫性のある状態で承諾に到達できなくなるためです。 グループメンバーがグループ外のソースへのレプリカとしても機能する場合など、グループレプリケーションに直接関与しないレプリケーションチャネルでチャネル固有のレプリケーションフィルタを使用できます。 <code class="literal">group_replication_applier</code> または <code class="literal">group_replication_recovery</code> チャネルでは使用できません。 
              </p></div><p>
          </p><p>
            このオプションは、テーブルに適用されるステートメントにのみ影響します。 ストアドルーチンなど、ほかのデータベースオブジェクトにのみ適用されるステートメントには影響しません。 ストアドルーチンに作用するステートメントをフィルタするには、1 つまたは複数の <code class="option">--replicate-*-db</code> オプションを使用します。 
          </p></li><li class="listitem"><p><a name="option_mysqld_replicate-ignore-table"></a>
            <code class="option">--replicate-ignore-table=<em class="replaceable"><code>db_name.tbl_name</code></em></code>
          </p><a class="indexterm" name="idm46723656010304"></a><a class="indexterm" name="idm46723656008080"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for replicate-ignore-table"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--replicate-ignore-table=name</code></td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
            同じステートメントによってほかのテーブルが更新される可能性がある場合でも、指定されたテーブルを更新するステートメントをレプリケートしないようにレプリケーション SQL スレッドに指示することによって、レプリケーションフィルタを作成します。 無視するテーブルを複数指定するには、このオプションを複数回 (テーブルごとに 1 回) 使用します。 <code class="option">--replicate-ignore-db</code> とは対照的に、これはクロスデータベース更新に機能します。 <a class="xref" href="replication.html#replication-rules" title="17.2.5 サーバーがレプリケーションフィルタリングルールをどのように評価するか">セクション17.2.5「サーバーがレプリケーションフィルタリングルールをどのように評価するか」</a>を参照してください。 このようなフィルタは、<code class="literal">CHANGE REPLICATION FILTER REPLICATE_IGNORE_TABLE</code> ステートメントを発行して作成することもできます。 
          </p><p>
            このオプションでは、チャネル固有のレプリケーションフィルタがサポートされているため、マルチソースレプリカは異なるソースに対して特定のフィルタを使用できます。 <em class="replaceable"><code>channel_1</code></em> という名前のチャネルでチャネル固有のレプリケーションフィルタを構成するには、<code class="option">--replicate-ignore-table:<em class="replaceable"><code>channel_1</code></em> :<em class="replaceable"><code>db_name.tbl_name</code></em></code> を使用します。 この場合、最初のコロンはセパレータとして解釈され、後続のコロンはリテラルコロンです。 詳しくは<a class="xref" href="replication.html#replication-rules-channel-based-filters" title="17.2.5.4 レプリケーションチャネルベースのフィルタ">セクション17.2.5.4「レプリケーションチャネルベースのフィルタ」</a>をご覧ください。 
          </p><p>
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                グループレプリケーション用に構成された MySQL サーバーインスタンスでは、グローバルレプリケーションフィルタを使用できません。これは、一部のサーバーでトランザクションをフィルタすると、グループが一貫性のある状態で承諾に到達できなくなるためです。 グループメンバーがグループ外のソースへのレプリカとしても機能する場合など、グループレプリケーションに直接関与しないレプリケーションチャネルでチャネル固有のレプリケーションフィルタを使用できます。 <code class="literal">group_replication_applier</code> または <code class="literal">group_replication_recovery</code> チャネルでは使用できません。 
              </p></div><p>
          </p><p>
            このオプションは、テーブルに適用されるステートメントにのみ影響します。 ストアドルーチンなど、ほかのデータベースオブジェクトにのみ適用されるステートメントには影響しません。 ストアドルーチンに作用するステートメントをフィルタするには、1 つまたは複数の <code class="option">--replicate-*-db</code> オプションを使用します。 
          </p></li><li class="listitem"><p><a name="option_mysqld_replicate-rewrite-db"></a>
            <code class="option">--replicate-rewrite-db=<em class="replaceable"><code>from_name</code></em>-&gt;<em class="replaceable"><code>to_name</code></em></code>
          </p><a class="indexterm" name="idm46723655982288"></a><a class="indexterm" name="idm46723655980112"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for replicate-rewrite-db"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--replicate-rewrite-db=old_name-&gt;new_name</code></td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
            指定されたデータベースがソース上の <em class="replaceable"><code>from_name</code></em> である場合に、それを <em class="replaceable"><code>to_name</code></em> に変換するレプリケーションフィルタを作成するようレプリカに指示します。 影響を受けるのはテーブルを含むステートメントのみで、<code class="literal">CREATE DATABASE</code>、<code class="literal">DROP DATABASE</code>、<code class="literal">ALTER DATABASE</code> などのステートメントは影響を受けません。 
          </p><p>
            複数の書き換えを指定するには、複数回このオプションを使用します。 サーバーは、一致する <em class="replaceable"><code>from_name</code></em> 値で最初のものを使用します。 データベース名変換は、<code class="option">--replicate-*</code> ルールがテストされる<span class="emphasis"><em>前に</em></span>行われます。 このようなフィルタは、<code class="literal">CHANGE REPLICATION FILTER REPLICATE_REWRITE_DB</code> ステートメントを発行して作成することもできます。 
          </p><p>
            コマンドラインで <code class="option">--replicate-rewrite-db</code> オプションを使用し、<code class="literal">&gt;</code> 文字がコマンドインタプリタに特殊な場合は、オプション値を引用符で囲みます。 例: 
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqld --replicate-rewrite-db="<em class="replaceable"><code>olddb</code></em>-&gt;<em class="replaceable"><code>newdb</code></em>"</code></strong>
</pre><p>
            <code class="option">--replicate-rewrite-db</code> オプションの効果は、ステートメントベースと行ベースのどちらのバイナリロギング形式をクエリーに使用するかによって異なります。 ステートメントベースの形式では、DML ステートメントは、<code class="literal">USE</code> ステートメントで指定された現行のデータベースに基づいて変換されます。 行ベースの形式では、DML ステートメントは、変更されたテーブルが存在するデータベースに基づいて変換されます。 DDL ステートメントは、バイナリロギング形式に関係なく、常に <code class="literal">USE</code> ステートメントで指定された現在のデータベースに基づいてフィルタ処理されます。 
          </p><p>
            リライトによって予期した結果が得られるようにするには、特に他のレプリケーションフィルタリングオプションと組み合せて、<code class="option">--replicate-rewrite-db</code> オプションを使用する際に次の推奨事項に従います:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                ソースおよびレプリカに異なる名前で <em class="replaceable"><code>from_name</code></em> および <em class="replaceable"><code>to_name</code></em> データベースを手動で作成します。
              </p></li><li class="listitem"><p>
                ステートメントベースまたは混合バイナリロギング形式を使用する場合は、クロスデータベースクエリーを使用せず、クエリーでデータベース名を指定しないでください。 DDL ステートメントと DML ステートメントの両方で、<code class="literal">USE</code> ステートメントを使用して現在のデータベースを指定し、クエリーでテーブル名のみを使用します。 
              </p></li><li class="listitem"><p>
                DDL ステートメントで行ベースのバイナリロギング形式を排他的に使用する場合は、<code class="literal">USE</code> ステートメントを使用して現在のデータベースを指定し、クエリーでテーブル名のみを使用します。 DML ステートメントには、完全修飾テーブル名 (<em class="replaceable"><code>db</code></em>) を使用できます。<em class="replaceable"><code>table</code></em>) (必要な場合)。 
              </p></li></ul></div><p>
            これらの推奨事項に従う場合は、<code class="option">--replicate-rewrite-db</code> オプションを <code class="option">--replicate-do-table</code> などのテーブルレベルのレプリケーションフィルタリングオプションと組み合せて使用しても安全です。
          </p><p>
            このオプションでは、チャネル固有のレプリケーションフィルタがサポートされているため、マルチソースレプリカは異なるソースに対して特定のフィルタを使用できます。 チャネル名に続けてコロンを指定し、その後にフィルタ指定を指定します。 最初のコロンはセパレータとして解釈され、後続のコロンはリテラルコロンとして解釈されます。 たとえば、<em class="replaceable"><code>channel_1</code></em> という名前のチャネルでチャネル固有のレプリケーションフィルタを構成するには、次を使用します: 
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqld --replicate-rewrite-db=<em class="replaceable"><code>channel_1</code></em>:<em class="replaceable"><code>db_name1</code></em>-&gt;<em class="replaceable"><code>db_name2</code></em></code></strong>
</pre><p>
            コロンを使用してチャネル名を指定しない場合、このオプションはデフォルトのレプリケーションチャネルのレプリケーションフィルタを構成します。 詳しくは<a class="xref" href="replication.html#replication-rules-channel-based-filters" title="17.2.5.4 レプリケーションチャネルベースのフィルタ">セクション17.2.5.4「レプリケーションチャネルベースのフィルタ」</a>をご覧ください。 
          </p><p>
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                グループレプリケーション用に構成された MySQL サーバーインスタンスでは、グローバルレプリケーションフィルタを使用できません。これは、一部のサーバーでトランザクションをフィルタすると、グループが一貫性のある状態で承諾に到達できなくなるためです。 グループメンバーがグループ外のソースへのレプリカとしても機能する場合など、グループレプリケーションに直接関与しないレプリケーションチャネルでチャネル固有のレプリケーションフィルタを使用できます。 <code class="literal">group_replication_applier</code> または <code class="literal">group_replication_recovery</code> チャネルでは使用できません。 
              </p></div><p>
          </p></li><li class="listitem"><p><a name="option_mysqld_replicate-same-server-id"></a>
            <code class="option">--replicate-same-server-id</code>
          </p><a class="indexterm" name="idm46723655928288"></a><a class="indexterm" name="idm46723655926048"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for replicate-same-server-id"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--replicate-same-server-id[={OFF|ON}]</code></td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
            このオプションはレプリカで使用します。 デフォルトは 0 (<code class="literal">FALSE</code>) です。 このオプションを 1 (<code class="literal">TRUE</code>) に設定すると、レプリカは独自のサーバー ID を持つイベントをスキップしません。 通常、この設定はまれな構成でのみ役立ちます。 
          </p><p>
            レプリカでバイナリロギングが有効になっている場合、サーバーが循環レプリケーショントポロジの一部であると、レプリカ上の <code class="option">--replicate-same-server-id</code> オプションと <code class="option">--log-slave-updates</code> オプションの組み合わせによってレプリケーションで無限ループが発生する可能性があります。 (MySQL 8.0 では、バイナリロギングはデフォルトで有効になっており、バイナリロギングが有効になっている場合はレプリカ更新ロギングがデフォルトになります。) ただし、グローバルトランザクション識別子 (GTID) を使用すると、すでに適用されているトランザクションの実行がスキップされ、この状況が回避されます。 レプリカに <code class="literal">gtid_mode=ON</code> が設定されている場合、このオプションの組合せでサーバーを起動できますが、サーバーの実行中は他の GTID モードに変更できません。 ほかの GTID モードが設定されている場合、サーバーはこのオプションの組み合わせで起動しません。 
          </p><p>
            デフォルトでは、複製サーバー ID を持っている場合、レプリケーション I/O スレッドはバイナリログイベントをリレーログに書き込みません (この最適化はディスク使用量の節約に役立ちます)。 <code class="option">--replicate-same-server-id</code> を使用する場合は、レプリケーション SQL スレッドで実行する独自のイベントをレプリカで読み取る前に、必ずこのオプションを使用してレプリカを起動してください。 
          </p></li><li class="listitem"><p><a name="option_mysqld_replicate-wild-do-table"></a>
            <code class="option">--replicate-wild-do-table=<em class="replaceable"><code>db_name.tbl_name</code></em></code>
          </p><a class="indexterm" name="idm46723655902752"></a><a class="indexterm" name="idm46723655900528"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for replicate-wild-do-table"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--replicate-wild-do-table=name</code></td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
            レプリケーション SQL スレッドに、更新されたテーブルのいずれかが指定されたデータベースおよびテーブル名パターンと一致するステートメントにレプリケーションを制限するように指示することで、レプリケーションフィルタを作成します。 パターンには、<code class="literal">LIKE</code> パターン一致演算子と同じ意味を持つ <code class="literal">%</code> および<code class="literal">_</code>ワイルドカード文字を含めることができます。 複数のテーブルを指定するには、このオプションを複数回 (テーブルごとに 1 回) 使用します。 これはクロスデータベース更新に役立ちます。 <a class="xref" href="replication.html#replication-rules" title="17.2.5 サーバーがレプリケーションフィルタリングルールをどのように評価するか">セクション17.2.5「サーバーがレプリケーションフィルタリングルールをどのように評価するか」</a>を参照してください。 このようなフィルタは、<code class="literal">CHANGE REPLICATION FILTER REPLICATE_WILD_DO_TABLE</code> ステートメントを発行して作成することもできます。 
          </p><p>
            このオプションでは、チャネル固有のレプリケーションフィルタがサポートされているため、マルチソースレプリカは異なるソースに対して特定のフィルタを使用できます。 <em class="replaceable"><code>channel_1</code></em> という名前のチャネルでチャネル固有のレプリケーションフィルタを構成するには、<code class="option">--replicate-wild-do-table:<em class="replaceable"><code>channel_1</code></em> :<em class="replaceable"><code>db_name.tbl_name</code></em></code> を使用します。 この場合、最初のコロンはセパレータとして解釈され、後続のコロンはリテラルコロンです。 詳しくは<a class="xref" href="replication.html#replication-rules-channel-based-filters" title="17.2.5.4 レプリケーションチャネルベースのフィルタ">セクション17.2.5.4「レプリケーションチャネルベースのフィルタ」</a>をご覧ください。 
          </p><p>
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                グループレプリケーション用に構成された MySQL サーバーインスタンスでは、グローバルレプリケーションフィルタを使用できません。これは、一部のサーバーでトランザクションをフィルタすると、グループが一貫性のある状態で承諾に到達できなくなるためです。 グループメンバーがグループ外のソースへのレプリカとしても機能する場合など、グループレプリケーションに直接関与しないレプリケーションチャネルでチャネル固有のレプリケーションフィルタを使用できます。 <code class="literal">group_replication_applier</code> または <code class="literal">group_replication_recovery</code> チャネルでは使用できません。 
              </p></div><p>
          </p><p>
            このオプションはテーブル、ビュー、およびトリガーに適用されます。 ストアドプロシージャーと関数、またはイベントには適用されません。 後者のオブジェクトで作用するステートメントをフィルタするには、1 つまたは複数の <code class="option">--replicate-*-db</code> オプションを使用します。 
          </p><p>
            たとえば、<code class="option">--replicate-wild-do-table=foo%.bar%</code> は、データベース名が <code class="literal">foo</code> で始まり、テーブル名が <code class="literal">bar</code> で始まるテーブルを使用する更新のみをレプリケートします。
          </p><p>
            テーブル名パターンが <code class="literal">%</code> の場合、それは任意のテーブル名に一致し、このオプションはデータベースレベルステートメント (<code class="literal">CREATE DATABASE</code>、<code class="literal">DROP DATABASE</code>、および <code class="literal">ALTER DATABASE</code>) にも適用されます。 たとえば、<code class="option">--replicate-wild-do-table=foo%.%</code> を使用する場合に、データベース名がパターン <code class="literal">foo%</code> に一致する場合はデータベースレベルステートメントが複製されます。 
          </p><p>
            リテラルワイルドカード文字をデータベースまたはテーブル名パターンに含めるには、バックスラッシュでそれらをエスケープします。 たとえば、<code class="literal">my_own%db</code> という名前のデータベースのすべてのテーブルをレプリケートし、<code class="literal">my1ownAABCdb</code> データベースからはレプリケートしない場合は、次のように<code class="literal">_</code>および <code class="literal">%</code> 文字をエスケープする必要があります: <code class="option">--replicate-wild-do-table=my\_own\%db</code>。 このオプションをコマンド行で使用する場合、コマンドインタープリターによっては、バックスラッシュを二重にしたりオプション値を引用符で囲んだりする必要があります。 たとえば、<span class="command"><strong>bash</strong></span> シェルでは、<code class="option">--replicate-wild-do-table=my\\_own\\%db</code> と入力する必要があります。 
          </p></li><li class="listitem"><p><a name="option_mysqld_replicate-wild-ignore-table"></a>
            <code class="option">--replicate-wild-ignore-table=<em class="replaceable"><code>db_name.tbl_name</code></em></code>
          </p><a class="indexterm" name="idm46723655857616"></a><a class="indexterm" name="idm46723655855440"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for replicate-wild-ignore-table"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--replicate-wild-ignore-table=name</code></td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
            レプリケーション SQL スレッドが、任意のテーブルが指定されたワイルドカードパターンと一致するステートメントをレプリケートしないようにするレプリケーションフィルタを作成します。 無視するテーブルを複数指定するには、このオプションを複数回 (テーブルごとに 1 回) 使用します。 これはクロスデータベース更新に役立ちます。 <a class="xref" href="replication.html#replication-rules" title="17.2.5 サーバーがレプリケーションフィルタリングルールをどのように評価するか">セクション17.2.5「サーバーがレプリケーションフィルタリングルールをどのように評価するか」</a>を参照してください。 このようなフィルタは、<code class="literal">CHANGE REPLICATION FILTER REPLICATE_WILD_IGNORE_TABLE</code> ステートメントを発行して作成することもできます。 
          </p><p>
            このオプションでは、チャネル固有のレプリケーションフィルタがサポートされているため、マルチソースレプリカは異なるソースに対して特定のフィルタを使用できます。 <em class="replaceable"><code>channel_1</code></em> という名前のチャネルでチャネル固有のレプリケーションフィルタを構成するには、<code class="option">--replicate-wild-ignore:<em class="replaceable"><code>channel_1</code></em> :<em class="replaceable"><code>db_name.tbl_name</code></em></code> を使用します。 この場合、最初のコロンはセパレータとして解釈され、後続のコロンはリテラルコロンです。 詳しくは<a class="xref" href="replication.html#replication-rules-channel-based-filters" title="17.2.5.4 レプリケーションチャネルベースのフィルタ">セクション17.2.5.4「レプリケーションチャネルベースのフィルタ」</a>をご覧ください。 
          </p><p>
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                グループレプリケーション用に構成された MySQL サーバーインスタンスでは、グローバルレプリケーションフィルタを使用できません。これは、一部のサーバーでトランザクションをフィルタすると、グループが一貫性のある状態で承諾に到達できなくなるためです。 グループメンバーがグループ外のソースへのレプリカとしても機能する場合など、グループレプリケーションに直接関与しないレプリケーションチャネルでチャネル固有のレプリケーションフィルタを使用できます。 <code class="literal">group_replication_applier</code> または <code class="literal">group_replication_recovery</code> チャネルでは使用できません。 
              </p></div><p>
          </p><p>
            たとえば、<code class="option">--replicate-wild-ignore-table=foo%.bar%</code> では、データベース名が <code class="literal">foo</code> で始まり、テーブル名が <code class="literal">bar</code> で始まるテーブルを使用する更新はレプリケートされません。 照合の仕組みについては、<code class="option">--replicate-wild-do-table</code> オプションの説明を参照してください。 オプション値にリテラルワイルドカード文字を含めるためのルールは、<code class="option">--replicate-wild-ignore-table</code> 場合と同じです。 
          </p></li><li class="listitem"><p><a name="option_mysqld_skip-slave-start"></a>
            <code class="option">--skip-slave-start</code>
          </p><a class="indexterm" name="idm46723655828064"></a><a class="indexterm" name="idm46723655825904"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for skip-slave-start"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--skip-slave-start[={OFF|ON}]</code></td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
            サーバーの起動時にレプリケーション I/O および SQL スレッドを起動しないようにレプリカサーバーに指示します。 あとでスレッドを起動するには、<code class="literal">START REPLICA | SLAVE</code> ステートメントを使用します。 
          </p></li><li class="listitem"><p><a name="option_mysqld_slave-skip-errors"></a>
            <code class="option">--slave-skip-errors=[<em class="replaceable"><code>err_code1</code></em>,<em class="replaceable"><code>err_code2</code></em>,...|all|ddl_exist_errors]</code>
          </p><a class="indexterm" name="idm46723655808928"></a><a class="indexterm" name="idm46723655806720"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for slave-skip-errors"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--slave-skip-errors=name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_slave_skip_errors">slave_skip_errors</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">OFF</code></p><p class="valid-value"><code class="literal">[list of error codes]</code></p><p class="valid-value"><code class="literal">all</code></p><p class="valid-value"><code class="literal">ddl_exist_errors</code></p></td>
</tr></tbody></table></div><p>
            通常、レプリケーションはレプリカでエラーが発生すると停止するため、データの非一貫性を手動で解決できます。 このオプションを指定すると、ステートメントがオプション値にリストされているエラーのいずれかを返したときに、レプリケーション SQL スレッドはレプリケーションを続行します。 
          </p><p>
            このオプションは、エラーが発生している理由を完全に理解しないかぎり使用しないでください。 レプリケーションセットアップとクライアントプログラムにバグがなく、MySQL 自体にバグがない場合は、レプリケーションを停止するエラーは発生しないはずです。 このオプションを使用しないと、レプリカがソースと同期しなくなりますが、これが発生した理由はわかりません。 
          </p><p>
            エラーコードの場合は、レプリカエラーログおよび <code class="literal">SHOW REPLICA | SLAVE STATUS</code> の出力のエラーメッセージに示されている番号を使用する必要があります。<a class="xref" href="error-handling.html" title="付録 B エラーメッセージと一般的な問題">付録B「<i>エラーメッセージと一般的な問題</i>」</a> には、サーバーエラーコードがリストされます。
          </p><p>
            短縮値 <code class="literal">ddl_exist_errors</code> は、エラーコードリスト <code class="literal">1007,1008,1050,1051,1054,1060,1061,1068,1094,1146</code> と同等です。
          </p><p>
            また、<code class="literal">all</code> の推奨されない値を使用して、レプリカがすべてのエラーメッセージを無視し、何が発生したかに関係なく処理を続行するようにすることもできます (ただし、推奨されません)。 言うまでもなく、<code class="literal">all</code> を使用した場合、データの完全性に関して保証はありません。 この場合、レプリカデータがソース上のどこにも近い場所にない場合は、苦情 (またはバグレポートをファイル) しないでください。 <span class="emphasis"><em>以上のことを警告しました</em></span>。 
          </p><p>
            例:
          </p><pre class="programlisting">--slave-skip-errors=1062,1053
--slave-skip-errors=all
--slave-skip-errors=ddl_exist_errors
</pre></li><li class="listitem"><p><a name="option_mysqld_slave-sql-verify-checksum"></a>
            <code class="option">--slave-sql-verify-checksum={0|1}</code>
          </p><a class="indexterm" name="idm46723655765136"></a><a class="indexterm" name="idm46723655762896"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for slave-sql-verify-checksum"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--slave-sql-verify-checksum[={OFF|ON}]</code></td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
            このオプションを有効にすると、レプリカはリレーログから読み取られたチェックサムを調べます。 不一致が発生した場合、レプリカはエラーで停止します。 
          </p></li></ul></div><p>
        次のオプションは、レプリケーションテストおよびデバッグのために MySQL テストスイートによって内部的に使用されます。 本番設定での使用は意図していません。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_abort-slave-event-count"></a>
            <code class="option">--abort-slave-event-count</code>
          </p><a class="indexterm" name="idm46723655746784"></a><a class="indexterm" name="idm46723655744560"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for abort-slave-event-count"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--abort-slave-event-count=#</code></td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr></tbody></table></div><p>
            このオプションを 0 (デフォルト) 以外の正の整数 <em class="replaceable"><code>value</code></em> に設定すると、次のようにレプリケーションの動作に影響: レプリケーション SQL スレッドが開始されると、<em class="replaceable"><code>value</code></em> ログイベントの実行が許可されます。その後、レプリケーション SQL スレッドは、ソースからのネットワーク接続が切断された場合と同様に、これ以上イベントを受信しません。 レプリケーション SQL スレッドは引き続き実行され、<code class="literal">SHOW REPLICA | SLAVE STATUS</code> からの出力では、<code class="literal">Replica_IO_Running</code> と <code class="literal">Replica_SQL_Running</code> の両方のカラムに <code class="literal">Yes</code> が表示されますが、リレーログからそれ以上のイベントは読み取られません。 
          </p></li><li class="listitem"><p><a name="option_mysqld_disconnect-slave-event-count"></a>
            <code class="option">--disconnect-slave-event-count</code>
          </p><a class="indexterm" name="idm46723655722096"></a><a class="indexterm" name="idm46723655719904"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for disconnect-slave-event-count"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--disconnect-slave-event-count=#</code></td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr></tbody></table></div></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-sysvars-slaves"></a>レプリカサーバーで使用されるシステム変数</h5></div></div></div><p>
        次のリストでは、レプリカサーバーを制御するためのシステム変数について説明します。 これらはサーバー起動時に設定でき、それらの一部は <code class="literal">SET</code> を使用して実行時に変更できます。 レプリカで使用されるサーバーオプションは、このセクションで前述しました。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="sysvar_init_slave"></a>
            <code class="literal">init_slave</code>
          </p><a class="indexterm" name="idm46723655701600"></a><a class="indexterm" name="idm46723655700128"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for init_slave"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--init-slave=name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_init_slave">init_slave</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
            この変数は <code class="literal">init_connect</code> と似ていますが、レプリケーション SQL スレッドが開始されるたびにレプリカサーバーによって実行される文字列です。 文字列の形式は <code class="literal">init_connect</code> 変数の場合と同じです。 この変数の設定は、後続の <code class="literal">START REPLICA | SLAVE</code> ステートメントに対して有効になります。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              レプリケーション SQL スレッドは、<code class="literal">init_slave</code> を実行する前にクライアントに確認を送信します。 したがって、<code class="literal">START REPLICA | SLAVE</code> が戻ったときに <code class="literal">init_slave</code> が実行されていることは保証されていません。 詳しくは<a class="xref" href="sql-statements.html#start-replica" title="13.4.2.7 START REPLICA | SLAVE ステートメント">セクション13.4.2.7「START REPLICA | SLAVE ステートメント」</a>をご覧ください。 
            </p></div></li><li class="listitem"><p><a name="sysvar_log_slow_slave_statements"></a>
            <code class="literal">log_slow_slave_statements</code>
          </p><a class="indexterm" name="idm46723655668960"></a><a class="indexterm" name="idm46723655667392"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for log_slow_slave_statements"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--log-slow-slave-statements[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_log_slow_slave_statements">log_slow_slave_statements</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
            スロークエリーログが有効になっている場合、この変数は、レプリカでの実行に <code class="literal">long_query_time</code> 秒を超える時間がかかったクエリーのロギングを有効にします。 行ベースのレプリケーションが使用されている (<code class="literal">binlog_format=ROW</code>) 場合、<code class="literal">log_slow_slave_statements</code> は効果がないことに注意してください。 クエリーがレプリカのスロークエリーログに追加されるのは、バイナリログにステートメント形式で記録されている場合、つまり <code class="literal">binlog_format=STATEMENT</code> が設定されている場合、または <code class="literal">binlog_format=MIXED</code> が設定されていてステートメントがステートメント形式で記録されている場合だけです。 <code class="literal">binlog_format=MIXED</code> の設定時に行形式でログに記録されるスロークエリー、または <code class="literal">binlog_format=ROW</code> の設定時にログに記録されるスロークエリーは、<code class="literal">log_slow_slave_statements</code> が有効な場合でもレプリカのスロークエリーログに追加されません。 
          </p><p>
            <code class="literal">log_slow_slave_statements</code> を設定しても、すぐには影響しません。 変数の状態は、後続のすべての <code class="literal">START REPLICA | SLAVE</code> ステートメントに適用されます。 また、<code class="literal">long_query_time</code> のグローバル設定は、SQL スレッドの存続期間中に適用されることに注意してください。 この設定を変更する場合は、レプリケーション SQL スレッドを停止して再起動し、そこで変更を実装する必要があります (たとえば、<code class="literal">SQL_THREAD</code> オプションを指定して <code class="literal">STOP REPLICA | SLAVE</code> および <code class="literal">START REPLICA | SLAVE</code> ステートメントを発行します)。 
          </p></li><li class="listitem"><p><a name="sysvar_master_info_repository"></a>
            <code class="literal">master_info_repository</code>
          </p><a class="indexterm" name="idm46723655625168"></a><a class="indexterm" name="idm46723655623616"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for master_info_repository"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--master-info-repository={FILE|TABLE}</code></td>
</tr><tr><th>非推奨</th>
<td>8.0.23</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_master_info_repository">master_info_repository</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">TABLE</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">FILE</code></p><p class="valid-value"><code class="literal">TABLE</code></p></td>
</tr></tbody></table></div><p>
            このシステム変数の使用は非推奨になりました。 <code class="literal">TABLE</code> の設定がデフォルトであり、複数のレプリケーションチャネルが構成されている場合は必須です。 代替設定の <code class="literal">FILE</code> は、以前は非推奨でした。 
          </p><p>
            デフォルト設定では、レプリカは、ステータスおよび接続情報で構成されるソースに関するメタデータを、<code class="literal">mysql.slave_master_info</code> という名前の <code class="literal">mysql</code> システムデータベースの <code class="literal">InnoDB</code> テーブルに記録します。 接続メタデータリポジトリの詳細は、<a class="xref" href="replication.html#replica-logs" title="17.2.4 リレーログおよびレプリケーションメタデータリポジトリ">セクション17.2.4「リレーログおよびレプリケーションメタデータリポジトリ」</a> を参照してください。 
          </p><p>
            <code class="literal">FILE</code> 設定では、レプリカ接続メタデータリポジトリがファイルに書き込まれましたが、これはデフォルトで <code class="filename">master.info</code> という名前でした。 この名前は、<code class="option">--master-info-file</code> オプションを使用して変更できます。 
          </p></li><li class="listitem"><p><a name="sysvar_max_relay_log_size"></a>
            <code class="literal">max_relay_log_size</code>
          </p><a class="indexterm" name="idm46723655584384"></a><a class="indexterm" name="idm46723655582832"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for max_relay_log_size"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--max-relay-log-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_max_relay_log_size">max_relay_log_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">1073741824</code></td>
</tr></tbody></table></div><p>
            レプリカによるリレーログへの書込みによって、現在のログファイルサイズがこの変数の値を超える場合、レプリカはリレーログをローテーションします (現在のファイルを閉じて次のファイルを開きます)。 <code class="literal">max_relay_log_size</code> が 0 の場合、サーバーはバイナリログとリレーログの両方に <code class="literal">max_binlog_size</code> を使用します。 <code class="literal">max_relay_log_size</code> が 0 より大きい場合、リレーログのサイズを抑制し、2 つのログに異なるサイズを持たせることが可能になります。 <code class="literal">max_relay_log_size</code> を 4096 バイトと 1G バイト (両端の値を含む) の間に設定するか、0 にする必要があります。 デフォルト値は 0 です。 <a class="xref" href="replication.html#replication-implementation-details" title="17.2.3 レプリケーションスレッド">セクション17.2.3「レプリケーションスレッド」</a>を参照してください。 
          </p></li><li class="listitem"><p><a name="sysvar_relay_log"></a>
            <code class="literal">relay_log</code>
          </p><a class="indexterm" name="idm46723655547424"></a><a class="indexterm" name="idm46723655545952"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for relay_log"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--relay-log=file_name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_relay_log">relay_log</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>ファイル名</td>
</tr></tbody></table></div><p>
            リレーログファイルのベース名。 デフォルトのレプリケーションチャネルの場合、リレーログのデフォルトのベース名は <code class="filename"><em class="replaceable"><code>host_name</code></em>-relay-bin</code> です。 デフォルト以外のレプリケーションチャネルの場合、リレーログのデフォルトのベース名は <code class="filename"><em class="replaceable"><code>host_name</code></em>-relay-bin-<em class="replaceable"><code>channel</code></em></code> です。ここで、<em class="replaceable"><code>channel</code></em> は、このリレーログに記録されているレプリケーションチャネルの名前です。 
          </p><p>
            ベース名の先頭に絶対パス名を付けて別のディレクトリを指定しないかぎり、サーバーはファイルをデータディレクトリに書き込みます。 サーバーは、ベース名に数値の接尾辞を追加することによって、リレーログファイルを順番に作成します。 
          </p><p>
            レプリケーションサーバーのリレーログおよびリレーログインデックスには、バイナリログおよびバイナリログインデックスと同じ名前を付けることはできません。バイナリログおよびバイナリログインデックスの名前は、<code class="option">--log-bin</code> および <code class="option">--log-bin-index</code> オプションで指定されます。 バイナリログとリレーログファイルのベース名が同じであれば、サーバーはエラーメッセージを発行し、起動しません。 
          </p><p>
            MySQL がサーバーオプションを解析する方法のため、サーバーの起動時にこの変数を指定する場合は、<span class="emphasis"><em>デフォルトのベース名は、オプションが実際に指定されていない場合にのみ使用されます</em></span>という値を指定する必要があります。 サーバーの起動時に値を指定せずに <code class="literal">relay_log</code> システム変数を指定すると、予期しない動作が発生する可能性があります。この動作は、使用される他のオプション、それらが指定されている順序、およびそれらがコマンド行とオプションファイルのどちらで指定されているかによって異なります。 MySQL がサーバーオプションをどのように処理するかについて詳しくは、<a class="xref" href="programs.html#program-options" title="4.2.2 プログラムオプションの指定">セクション4.2.2「プログラムオプションの指定」</a>を参照してください。 
          </p><p>
            この変数を指定すると、指定した値がリレーログインデックスファイルのベース名としても使用されます。 この動作をオーバーライドするには、<code class="literal">relay_log_index</code> システム変数を使用して別のリレーログインデックスファイルのベース名を指定します。 
          </p><p>
            サーバーは、インデックスファイルからエントリを読み取るときに、エントリに相対パスが含まれているかどうかをチェックします。 その場合、パスの相対部分は、<code class="literal">relay_log</code> システム変数を使用して設定された絶対パスに置き換えられます。 絶対パスは変わりません。このような場合、使用される新しいパスを有効にするために、インデックスを手動で編集する必要があります。 
          </p><p>
            <code class="literal">relay_log</code> システム変数は、次のタスクの実行に役立つ場合があります:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                名前がホスト名に依存しないリレーログを作成する。
              </p></li><li class="listitem"><p>
                リレーログが非常に大きくなる傾向があり、<code class="literal">max_relay_log_size</code> を小さくしたくないため、リレーログをデータディレクトリ以外の領域に置く必要がある場合。
              </p></li><li class="listitem"><p>
                ディスク間のロードバランシングを使用して速度を上げるため。
              </p></li></ul></div><p>
            リレーログファイル名 (およびパス) は、<code class="literal">relay_log_basename</code> システム変数から取得できます。
          </p></li><li class="listitem"><p><a name="sysvar_relay_log_basename"></a>
            <code class="literal">relay_log_basename</code>
          </p><a class="indexterm" name="idm46723655500416"></a><a class="indexterm" name="idm46723655498864"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for relay_log_basename"><col style="width=30%"><col style="width=70%"><tbody><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_basename">relay_log_basename</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>ファイル名</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">datadir + '/' + hostname + '-relay-bin'</code></td>
</tr></tbody></table></div><p>
            リレーログファイルのベース名と完全パスを保持します。 最大可変長は 256 です。 この変数はサーバーによって設定され、読取り専用です。 
          </p></li><li class="listitem"><p><a name="sysvar_relay_log_index"></a>
            <code class="literal">relay_log_index</code>
          </p><a class="indexterm" name="idm46723655476416"></a><a class="indexterm" name="idm46723655474880"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for relay_log_index"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--relay-log-index=file_name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_index">relay_log_index</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>ファイル名</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">*host_name*-relay-bin.index</code></td>
</tr></tbody></table></div><p>
            リレーログインデックスファイルの名前。 最大可変長は 256 です。 この変数を指定しないが、<code class="literal">relay_log</code> システム変数が指定されている場合、リレーログインデックスファイルのデフォルトのベース名としてその値が使用されます。 <code class="literal">relay_log</code> も指定されていない場合、デフォルトのレプリケーションチャネルのデフォルト名は、ホストマシンの名前を使用した <code class="filename"><em class="replaceable"><code>host_name</code></em>-relay-bin.index</code> です。 デフォルト以外のレプリケーションチャネルの場合、デフォルト名は <code class="filename"><em class="replaceable"><code>host_name</code></em>-relay-bin-<em class="replaceable"><code>channel</code></em>.index</code> で、<em class="replaceable"><code>channel</code></em> はこのリレーログインデックスに記録されているレプリケーションチャネルの名前です。 
          </p><p>
            リレーログファイルのデフォルトの場所は、データディレクトリ、または <code class="literal">relay_log</code> システム変数を使用して指定されたその他の場所です。 ベース名に先頭の絶対パス名を追加して別のディレクトリを指定することで、<code class="literal">relay_log_index</code> システム変数を使用して別の場所を指定できます。 
          </p><p>
            レプリケーションサーバーのリレーログおよびリレーログインデックスには、バイナリログおよびバイナリログインデックスと同じ名前を付けることはできません。バイナリログおよびバイナリログインデックスの名前は、<code class="option">--log-bin</code> および <code class="option">--log-bin-index</code> オプションで指定されます。 バイナリログとリレーログファイルのベース名が同じであれば、サーバーはエラーメッセージを発行し、起動しません。 
          </p><p>
            MySQL がサーバーオプションを解析する方法のため、サーバーの起動時にこの変数を指定する場合は、<span class="emphasis"><em>デフォルトのベース名は、オプションが実際に指定されていない場合にのみ使用されます</em></span>という値を指定する必要があります。 サーバーの起動時に値を指定せずに <code class="literal">relay_log_index</code> システム変数を指定すると、予期しない動作が発生する可能性があります。この動作は、使用される他のオプション、それらが指定されている順序、およびそれらがコマンド行とオプションファイルのどちらで指定されているかによって異なります。 MySQL がサーバーオプションをどのように処理するかについて詳しくは、<a class="xref" href="programs.html#program-options" title="4.2.2 プログラムオプションの指定">セクション4.2.2「プログラムオプションの指定」</a>を参照してください。 
          </p></li><li class="listitem"><p><a name="sysvar_relay_log_info_file"></a>
            <code class="literal">relay_log_info_file</code>
          </p><a class="indexterm" name="idm46723655434416"></a><a class="indexterm" name="idm46723655432864"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for relay_log_info_file"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--relay-log-info-file=file_name</code></td>
</tr><tr><th>非推奨</th>
<td>8.0.18</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_info_file">relay_log_info_file</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>ファイル名</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">relay-log.info</code></td>
</tr></tbody></table></div><p>
            このシステム変数の使用は非推奨になりました。 <code class="literal">relay_log_info_repository=FILE</code> が設定されている場合、レプリカアプライアンスメタデータリポジトリのファイル名を設定するために使用されていました。<code class="literal">relay_log_info_file</code> および <code class="literal">relay_log_info_repository</code> システム変数の使用は、アプライヤメタデータリポジトリのファイルの使用がクラッシュセーフテーブルに置き換えられたため、非推奨になりました。 適用者メタデータリポジトリの詳細は、<a class="xref" href="replication.html#replica-logs-status" title="17.2.4.2 レプリケーションメタデータリポジトリ">セクション17.2.4.2「レプリケーションメタデータリポジトリ」</a> を参照してください。 
          </p></li><li class="listitem"><p><a name="sysvar_relay_log_info_repository"></a>
            <code class="literal">relay_log_info_repository</code>
          </p><a class="indexterm" name="idm46723655401568"></a><a class="indexterm" name="idm46723655400000"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for relay_log_info_repository"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--relay-log-info-repository=value</code></td>
</tr><tr><th>非推奨</th>
<td>8.0.23</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_info_repository">relay_log_info_repository</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">TABLE</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">FILE</code></p><p class="valid-value"><code class="literal">TABLE</code></p></td>
</tr></tbody></table></div><p>
            このシステム変数の使用は非推奨になりました。 <code class="literal">TABLE</code> の設定がデフォルトであり、複数のレプリケーションチャネルが構成されている場合は必須です。 レプリカアプライアンスのメタデータリポジトリの <code class="literal">TABLE</code> 設定は、予期しない停止に対するレプリケーションの回復性を確保するためにも必要です。 詳しくは<a class="xref" href="replication.html#replication-solutions-unexpected-replica-halt" title="17.4.2 レプリカの予期しない停止の処理">セクション17.4.2「レプリカの予期しない停止の処理」</a>をご覧ください。 代替設定の <code class="literal">FILE</code> は、以前は非推奨でした。 
          </p><p>
            デフォルト設定では、レプリカのアプライヤメタデータリポジトリは、<code class="literal">mysql.slave_relay_log_info</code> という名前の <code class="literal">mysql</code> システムデータベースに <code class="literal">InnoDB</code> テーブルとして格納されます。 適用者メタデータリポジトリの詳細は、<a class="xref" href="replication.html#replica-logs" title="17.2.4 リレーログおよびレプリケーションメタデータリポジトリ">セクション17.2.4「リレーログおよびレプリケーションメタデータリポジトリ」</a> を参照してください。 
          </p><p>
            <code class="literal">FILE</code> 設定では、レプリカアプライアンスメタデータリポジトリがファイルに書き込まれましたが、これはデフォルトで <code class="filename">relay-log.info</code> という名前でした。 名前は、<code class="literal">relay_log_info_file</code> システム変数を使用して変更できます。 
          </p></li><li class="listitem"><p><a name="sysvar_relay_log_purge"></a>
            <code class="literal">relay_log_purge</code>
          </p><a class="indexterm" name="idm46723655358736"></a><a class="indexterm" name="idm46723655357200"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for relay_log_purge"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--relay-log-purge[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_purge">relay_log_purge</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
            リレーログファイルが不要になったときに自動的にパージするよう無効または有効にします。 デフォルト値は 1 (<code class="literal">ON</code>) です。 
          </p></li><li class="listitem"><p><a name="sysvar_relay_log_recovery"></a>
            <code class="literal">relay_log_recovery</code>
          </p><a class="indexterm" name="idm46723655331616"></a><a class="indexterm" name="idm46723655329616"></a><a class="indexterm" name="idm46723655328064"></a><a class="indexterm" name="idm46723655326656"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for relay_log_recovery"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--relay-log-recovery[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_recovery">relay_log_recovery</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
            この変数を有効にすると、サーバーの起動直後にリレーログリカバリが自動的に有効になります。 リカバリプロセスでは、新しいリレーログファイルを作成し、SQL スレッド位置をこの新しいリレーログに初期化し、I/O スレッドを SQL スレッド位置に初期化します。 その後、ソースからのリレーログの読み取りが続行されます。 
          </p><p>
            このグローバル変数は、実行時に読取り専用です。 この値は、レプリカサーバーの起動時に <code class="option">--relay-log-recovery</code> オプションを使用して設定できます。このオプションは、破損する可能性のあるリレーログが処理されないようにするために、レプリカの予期しない停止後に使用する必要があり、クラッシュセーフなレプリカを保証するために使用する必要があります。 デフォルト値は 0 (無効)です。 予期しない停止に対して最も回復可能なレプリカの設定の組合せの詳細は、<a class="xref" href="replication.html#replication-solutions-unexpected-replica-halt" title="17.4.2 レプリカの予期しない停止の処理">セクション17.4.2「レプリカの予期しない停止の処理」</a> を参照してください。 
          </p><p>
            マルチスレッドレプリカ (<code class="literal">slave_parallel_workers</code> が 0 より大きい) の場合、起動時に <code class="option">--relay-log-recovery</code> を設定すると、リレーログから実行された一連のトランザクションの不整合およびギャップが自動的に処理されます。 これらのギャップは、ファイル位置ベースのレプリケーションが使用されている場合に発生することがあります。 (詳細は、<a class="xref" href="replication.html#replication-features-transaction-inconsistencies" title="17.5.1.34 レプリケーションとトランザクションの非一貫性">セクション17.5.1.34「レプリケーションとトランザクションの非一貫性」</a> を参照してください。) リレーログリカバリプロセスは、<code class="literal">START REPLICA | SLAVE UNTIL SQL_AFTER_MTS_GAPS</code> ステートメントと同じ方法を使用してギャップを処理します。 レプリカが一貫性のないギャップのない状態に達すると、リレーログリカバリプロセスが進行し、SQL (適用者) スレッド位置からソースからさらにトランザクションがフェッチされます。 GTID ベースのレプリケーションが使用されている場合、このプロセスは不要であり、<code class="literal">MASTER_AUTO_POSITION</code> が <code class="literal">ON</code> に設定されている場合、MySQL 8.0.18 からマルチスレッドレプリカはリレーログのリカバリを自動的にスキップするため、<code class="literal">relay_log_recovery</code> の設定に違いはありません。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              この変数は、次のグループレプリケーションチャネルには影響しません:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">group_replication_applier</code>
                </p></li><li class="listitem"><p>
                  <code class="literal">group_replication_recovery</code>
                </p></li></ul></div><p>
              外部ソースまたは別のグループからレプリケートしているチャネルなど、グループで実行されている他のチャネルは影響を受けます。
            </p></div></li><li class="listitem"><p><a name="sysvar_relay_log_space_limit"></a>
            <code class="literal">relay_log_space_limit</code>
          </p><a class="indexterm" name="idm46723655285024"></a><a class="indexterm" name="idm46723655283472"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for relay_log_space_limit"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--relay-log-space-limit=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_space_limit">relay_log_space_limit</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値 (64 ビットプラットフォーム)</th>
<td><code class="literal">18446744073709551615</code></td>
</tr><tr><th>最大値 (32 ビットプラットフォーム)</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
            すべてのリレーログに使用するスペースの最大量。
          </p></li><li class="listitem"><p><a name="sysvar_replication_optimize_for_static_plugin_config"></a>
            <code class="literal">replication_optimize_for_static_plugin_config</code>
          </p><a class="indexterm" name="idm46723655251328"></a><a class="indexterm" name="idm46723655249712"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for replication_optimize_for_static_plugin_config"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--replication-optimize-for-static-plugin-config[={OFF|ON}]</code></td>
</tr><tr><th>導入</th>
<td>8.0.23</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_replication_optimize_for_static_plugin_config">replication_optimize_for_static_plugin_config</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
            準同期レプリケーションのパフォーマンスを向上させるには、共有ロックを使用し、不要なロック取得を回避します。 このシステム変数が有効になっている間は準同期レプリケーションプラグインをアンインストールできないため、アンインストールを完了する前にシステム変数を無効にする必要があります。 
          </p><p>
            このシステム変数は、準同期レプリケーションプラグインのインストール前またはインストール後に有効にしたり、レプリケーションの実行中に有効にしたりできます。 準同期レプリケーションソースサーバーも、複製と同じロックメカニズムを使用するため、このシステム変数を有効にすることでパフォーマンス上の利点を得ることができます。 
          </p></li><li class="listitem"><p><a name="sysvar_replication_sender_observe_commit_only"></a>
            <code class="literal">replication_sender_observe_commit_only</code>
          </p><a class="indexterm" name="idm46723655221248"></a><a class="indexterm" name="idm46723655219648"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for replication_sender_observe_commit_only"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--replication-sender-observe-commit-only[={OFF|ON}]</code></td>
</tr><tr><th>導入</th>
<td>8.0.23</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_replication_sender_observe_commit_only">replication_sender_observe_commit_only</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
            準同期レプリケーションのパフォーマンスを向上させるには、コールバックを制限します。 このシステム変数は、準同期レプリケーションプラグインのインストール前またはインストール後に有効にしたり、レプリケーションの実行中に有効にしたりできます。 準同期レプリケーションソースサーバーも、複製と同じロックメカニズムを使用するため、このシステム変数を有効にすることでパフォーマンス上の利点を得ることができます。 
          </p></li><li class="listitem"><p><a name="sysvar_report_host"></a>
            <code class="literal">report_host</code>
          </p><a class="indexterm" name="idm46723655192448"></a><a class="indexterm" name="idm46723655190928"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for report_host"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--report-host=host_name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_report_host">report_host</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
            レプリカの登録時にソースにレポートされるレプリカのホスト名または IP アドレス。 この値は、ソースサーバーの <code class="literal">SHOW REPLICAS | SHOW SLAVE HOSTS</code> の出力に表示されます。 レプリカ自体をソースに登録しない場合は、値を未設定のままにします。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              レプリカの接続後、ソースが TCP/IP ソケットからレプリカサーバーの IP アドレスを読み取るだけでは不十分です。 NAT およびその他のルーティングの問題のため、その IP はソースまたは他のホストからレプリカへの接続に有効でない可能性があります。 
            </p></div></li><li class="listitem"><p><a name="sysvar_report_password"></a>
            <code class="literal">report_password</code>
          </p><a class="indexterm" name="idm46723655165616"></a><a class="indexterm" name="idm46723655164080"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for report_password"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--report-password=name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_report_password">report_password</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
            レプリカの登録時にソースにレポートされるレプリカのアカウントパスワード。 この値は、ソースが <code class="option">--show-slave-auth-info</code> で起動された場合に、ソースサーバー上の <code class="literal">SHOW REPLICAS | SHOW SLAVE HOSTS</code> の出力に表示されます。 
          </p><p>
            この変数の名前は、それ以外の意味を持つ場合もありますが、<code class="literal">report_password</code> は MySQL ユーザー権限システムに接続されていないため、MySQL レプリケーションユーザーアカウントのパスワードと同じである必要はありません (または同じである可能性もあります)。
          </p></li><li class="listitem"><p><a name="sysvar_report_port"></a>
            <code class="literal">report_port</code>
          </p><a class="indexterm" name="idm46723655137504"></a><a class="indexterm" name="idm46723655135984"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for report_port"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--report-port=port_num</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_report_port">report_port</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">[slave_port]</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">65535</code></td>
</tr></tbody></table></div><p>
            レプリカ登録時にソースにレポートされる、レプリカに接続するための TCP/IP ポート番号。 これは、レプリカがデフォルト以外のポートでリスニングしている場合、またはソースまたは他のクライアントからレプリカへの特別なトンネルがある場合にのみ設定します。 確実でない場合は、このオプションを使用しないでください。 
          </p><p>
            このオプションのデフォルト値は、レプリカによって実際に使用されるポート番号です。 これは、<code class="literal">SHOW REPLICAS | SHOW SLAVE HOSTS</code> によって表示されるデフォルト値でもあります。 
          </p></li><li class="listitem"><p><a name="sysvar_report_user"></a>
            <code class="literal">report_user</code>
          </p><a class="indexterm" name="idm46723655103920"></a><a class="indexterm" name="idm46723655102400"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for report_user"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--report-user=name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_report_user">report_user</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
            レプリカの登録時にソースにレポートされるレプリカのアカウントユーザー名。 この値は、ソースが <code class="option">--show-slave-auth-info</code> で起動された場合に、ソースサーバー上の <code class="literal">SHOW REPLICAS | SHOW SLAVE HOSTS</code> の出力に表示されます。 
          </p><p>
            この変数の名前はそれ以外を意味する場合もありますが、<code class="literal">report_user</code> は MySQL ユーザー権限システムに接続されていないため、必ずしも MySQL レプリケーションユーザーアカウントの名前と同じである必要はありません。
          </p></li><li class="listitem"><p><a name="sysvar_rpl_read_size"></a>
            <code class="literal">rpl_read_size</code>
          </p><a class="indexterm" name="idm46723655075920"></a><a class="indexterm" name="idm46723655073872"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for rpl_read_size"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--rpl-read-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_rpl_read_size">rpl_read_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">8192</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">8192</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
            <code class="literal">rpl_read_size</code> システム変数は、バイナリログファイルおよびリレーログファイルから読み取られるデータの最小量をバイト単位で制御します。 これらのファイルに対する大量のディスク I/O アクティビティがデータベースのパフォーマンスを低下させている場合、ファイルデータがオペレーティングシステムによって現在キャッシュされていないと、読取りサイズを増やすとファイル読取りが減少し、I/O が停止する可能性があります。 
          </p><p>
            <code class="literal">rpl_read_size</code> の最小値およびデフォルト値は 8192 バイトです。 値は 4KB の倍数である必要があります。 バイナリログおよびリレーログファイルから読み取るスレッドごとに、この値のバッファーが割り当てられます。これには、ソース上のダンプスレッドやレプリカ上のコーディネータスレッドも含まれます。 したがって、大きな値を設定すると、サーバーのメモリー消費に影響する可能性があります。 
          </p></li><li class="listitem"><p><a name="sysvar_rpl_semi_sync_slave_enabled"></a>
            <code class="literal">rpl_semi_sync_slave_enabled</code>
          </p><a class="indexterm" name="idm46723655041456"></a><a class="indexterm" name="idm46723655039888"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for rpl_semi_sync_slave_enabled"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--rpl-semi-sync-slave-enabled[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_slave_enabled">rpl_semi_sync_slave_enabled</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
            レプリカサーバーで準同期レプリケーションを有効にするかどうかを制御します。 プラグインを有効または無効にするには、この変数を <code class="literal">ON</code> または <code class="literal">OFF</code> (あるいは 1 または 0) にそれぞれ設定します。 デフォルトは <code class="literal">OFF</code> です。 
          </p><p>
            この変数は、レプリカ側の準同期レプリケーションプラグインがインストールされている場合にのみ使用できます。
          </p></li><li class="listitem"><p><a name="sysvar_rpl_semi_sync_slave_trace_level"></a>
            <code class="literal">rpl_semi_sync_slave_trace_level</code>
          </p><a class="indexterm" name="idm46723655011872"></a><a class="indexterm" name="idm46723655010288"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for rpl_semi_sync_slave_trace_level"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--rpl-semi-sync-slave-trace-level=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_rpl_semi_sync_slave_trace_level">rpl_semi_sync_slave_trace_level</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">32</code></td>
</tr></tbody></table></div><p>
            レプリカサーバー上の準同期レプリケーションのデバッグトレースレベル。 許可できる値については、<code class="literal">rpl_semi_sync_master_trace_level</code> を参照してください。 
          </p><p>
            この変数は、レプリカ側の準同期レプリケーションプラグインがインストールされている場合にのみ使用できます。
          </p></li><li class="listitem"><p><a name="sysvar_rpl_stop_slave_timeout"></a>
            <code class="literal">rpl_stop_slave_timeout</code>
          </p><a class="indexterm" name="idm46723654983520"></a><a class="indexterm" name="idm46723654981520"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for rpl_stop_slave_timeout"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--rpl-stop-slave-timeout=seconds</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_rpl_stop_slave_timeout">rpl_stop_slave_timeout</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">31536000</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">2</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">31536000</code></td>
</tr></tbody></table></div><p>
            この変数を設定することで、<code class="literal">STOP REPLICA | SLAVE</code> がタイムアウトするまで待機する時間 (秒) を制御できます。 これを使用すると、レプリカへの異なるクライアント接続を使用する <code class="literal">STOP REPLICA | SLAVE</code> と他の SQL ステートメントの間のデッドロックを回避できます。 
          </p><p>
            <code class="literal">rpl_stop_slave_timeout</code> の最大値およびデフォルト値は 31536000 秒 (1 年) です。 最小は 2 秒です。 この変数への変更は、後続の <code class="literal">STOP REPLICA | SLAVE</code> ステートメントに対して有効になります。 
          </p><p>
            この変数は、<code class="literal">STOP REPLICA | SLAVE</code> ステートメントを発行するクライアントにのみ影響します。 タイムアウトに達すると、発行クライアントはコマンドの実行が不完全であることを示すエラーメッセージを返します。 その後、クライアントはレプリケーション I/O および SQL スレッドの停止の待機を停止しますが、レプリケーションスレッドは引き続き停止しようとし、<code class="literal">STOP REPLICA | SLAVE</code> 命令は有効なままです。 レプリケーションスレッドがビジー状態でなくなると、<code class="literal">STOP REPLICA | SLAVE</code> ステートメントが実行され、レプリカが停止します。 
          </p></li><li class="listitem"><p><a name="sysvar_slave_checkpoint_group"></a>
            <code class="literal">slave_checkpoint_group</code>
          </p><a class="indexterm" name="idm46723654941424"></a><a class="indexterm" name="idm46723654939424"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for slave_checkpoint_group"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--slave-checkpoint-group=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_slave_checkpoint_group">slave_checkpoint_group</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">512</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">32</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">524280</code></td>
</tr><tr><th>ブロックサイズ</th>
<td><code class="literal">8</code></td>
</tr></tbody></table></div><p>
            <code class="literal">SHOW REPLICA | SLAVE STATUS</code> で示されているように、チェックポイント操作がコールされてステータスが更新されるまでにマルチスレッドレプリカで処理できるトランザクションの最大数を設定します。 この変数を設定しても、マルチスレッドが有効になっていないレプリカには影響しません。 この変数を設定しても、すぐには影響しません。 変数の状態は、後続のすべての <code class="literal">START REPLICA | SLAVE</code> コマンドに適用されます。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              マルチスレッドレプリカは現在 NDB Cluster でサポートされていないため、この変数の設定は暗黙的に無視されます。 詳しくは<a class="xref" href="mysql-cluster.html#mysql-cluster-replication-issues" title="23.6.3 NDB Cluster レプリケーションの既知の問題">セクション23.6.3「NDB Cluster レプリケーションの既知の問題」</a>,をご覧ください。 
            </p></div><p>
            この変数は、<code class="literal">slave_checkpoint_period</code> システム変数との組み合わせで、どちらかの制限を超えたときに、チェックポイントが実行され、トランザクションの数と最後のチェックポイントから経過した時間の両方を追跡するカウンタがリセットされる、という方法で機能します。
          </p><p>
            この変数の最小許容値は 32 です (サーバーが <code class="option">-DWITH_DEBUG</code> を使用して構築された場合を除く、この場合の最小値は 1)。 効果的な値は常に 8 の倍数です。そのような倍数でない値に設定することもできますが、サーバーは値を格納する前に次に小さい 8 の倍数に丸めます。 (<span class="emphasis"><em>例外</em></span>: このような丸めはデバッグサーバーでは実行されません。) サーバーの構築方法にかかわらず、デフォルト値は 512 であり、最大許容値は 524280 です。 
          </p></li><li class="listitem"><p><a name="sysvar_slave_checkpoint_period"></a>
            <code class="literal">slave_checkpoint_period</code>
          </p><a class="indexterm" name="idm46723654898048"></a><a class="indexterm" name="idm46723654896048"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for slave_checkpoint_period"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--slave-checkpoint-period=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_slave_checkpoint_period">slave_checkpoint_period</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">300</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値 (64 ビットプラットフォーム)</th>
<td><code class="literal">18446744073709551615</code></td>
</tr><tr><th>最大値 (32 ビットプラットフォーム)</th>
<td><code class="literal">4294967295</code></td>
</tr><tr><th>単位</th>
<td><code class="literal">milliseconds</code></td>
</tr></tbody></table></div><p>
            <code class="literal">SHOW REPLICA | SLAVE STATUS</code> で示されるように、マルチスレッドレプリカのステータスを更新するためにチェックポイント操作がコールされるまでに許容される最大時間 (ミリ秒) を設定します。 この変数を設定しても、マルチスレッドが有効になっていないレプリカには影響しません。 この変数の設定は、実行中のチャネルを含め、すべてのレプリケーションチャネルに対してただちに有効になります。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              マルチスレッドレプリカは現在 NDB Cluster でサポートされていないため、この変数の設定は暗黙的に無視されます。 詳しくは<a class="xref" href="mysql-cluster.html#mysql-cluster-replication-issues" title="23.6.3 NDB Cluster レプリケーションの既知の問題">セクション23.6.3「NDB Cluster レプリケーションの既知の問題」</a>,をご覧ください。 
            </p></div><p>
            この変数は、<code class="literal">slave_checkpoint_group</code> システム変数との組み合わせで、どちらかの制限を超えたときに、チェックポイントが実行され、トランザクションの数と最後のチェックポイントから経過した時間の両方を追跡するカウンタがリセットされる、という方法で機能します。
          </p><p>
            この変数の最小許容値は 1 です (サーバーが <code class="option">-DWITH_DEBUG</code> を使用して構築された場合を除く、この場合の最小値は 0)。 サーバーの構築方法にかかわらず、デフォルト値は 300 であり、最大可能値は 4294967296 (4G バイト) です。 
          </p></li><li class="listitem"><p><a name="sysvar_slave_compressed_protocol"></a>
            <code class="literal">slave_compressed_protocol</code>
          </p><a class="indexterm" name="idm46723654854656"></a><a class="indexterm" name="idm46723654853088"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for slave_compressed_protocol"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--slave-compressed-protocol[={OFF|ON}]</code></td>
</tr><tr><th>非推奨</th>
<td>8.0.18</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_slave_compressed_protocol">slave_compressed_protocol</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
            ソースとレプリカの両方でサポートされている場合に、ソース/レプリカ接続プロトコルの圧縮を使用するかどうか。 この変数が無効 (デフォルト) の場合、接続は圧縮解除されます。 この変数への変更は、後続の接続試行時に有効になります。これには、<code class="literal">START REPLICA | SLAVE</code> ステートメントの発行後、および実行中のレプリケーション I/O スレッドによって行われた再接続が含まれます。 
          </p><p>
            <code class="literal">binlog_transaction_compression</code> システム変数によってアクティブ化されるバイナリログトランザクション圧縮 (MySQL 8.0.20 で使用可能) を使用して帯域幅を節約することもできます。 バイナリログトランザクション圧縮をプロトコル圧縮と組み合せて使用する場合、プロトコル圧縮ではデータを処理する機会は少なくなりますが、ヘッダーと、圧縮されていないイベントおよびトランザクションペイロードは圧縮できます。 バイナリログのトランザクション圧縮の詳細は、<a class="xref" href="server-administration.html#binary-log-transaction-compression" title="5.4.4.5 バイナリログトランザクション圧縮">セクション5.4.4.5「バイナリログトランザクション圧縮」</a> を参照してください。 
          </p><p>
            MySQL 8.0.18 の時点では、<code class="literal">slave_compressed_protocol</code> が有効な場合、<code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントに指定された <code class="literal">SOURCE_COMPRESSION_ALGORITHMS</code> | <code class="literal">MASTER_COMPRESSION_ALGORITHMS</code> オプションより優先されます。 この場合、ソースとレプリカの両方がそのアルゴリズムをサポートしていれば、ソースへの接続で <code class="literal">zlib</code> 圧縮が使用されます。 <code class="literal">slave_compressed_protocol</code> が無効な場合、<code class="literal">SOURCE_COMPRESSION_ALGORITHMS</code> | <code class="literal">MASTER_COMPRESSION_ALGORITHMS</code> の値が適用されます。 詳細は、<a class="xref" href="programs.html#connection-compression-control" title="4.2.8 接続圧縮制御">セクション4.2.8「接続圧縮制御」</a>を参照してください。 
          </p><p>
            MySQL 8.0.18 では、このシステム変数は非推奨です。 MySQL の将来のバージョンで削除される予定です。 <a class="xref" href="programs.html#connection-compression-legacy-configuration" title="レガシー接続圧縮の構成">レガシー接続圧縮の構成</a>を参照してください。 
          </p></li><li class="listitem"><p><a name="sysvar_slave_exec_mode"></a>
            <code class="literal">slave_exec_mode</code>
          </p><a class="indexterm" name="idm46723654810656"></a><a class="indexterm" name="idm46723654809120"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for slave_exec_mode"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--slave-exec-mode=mode</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_slave_exec_mode">slave_exec_mode</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><p class="valid-value"><code class="literal">IDEMPOTENT</code> (NDB)</p><p class="valid-value"><code class="literal">STRICT</code> (その他)</p></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">IDEMPOTENT</code></p><p class="valid-value"><code class="literal">STRICT</code></p></td>
</tr></tbody></table></div><p>
            レプリケーション中にレプリケーションスレッドが競合およびエラーを解決する方法を制御します。 <code class="literal">IDEMPOTENT</code> モードでは、重複キーおよびキーが見つからないエラーが抑止されます。<code class="literal">STRICT</code> では、このような抑止は行われません。 
          </p><p>
            <code class="literal">IDEMPOTENT</code> モードは、マルチソースレプリケーション、循環レプリケーション、および NDB Cluster レプリケーションのその他の特殊なレプリケーションシナリオで使用することを目的としています。 (詳しくは、<a class="xref" href="mysql-cluster.html#mysql-cluster-replication-multi-source" title="23.6.10 NDB Cluster レプリケーション: 双方向および循環レプリケーション">セクション23.6.10「NDB Cluster レプリケーション: 双方向および循環レプリケーション」</a>および<a class="xref" href="mysql-cluster.html#mysql-cluster-replication-conflict-resolution" title="23.6.11 NDB Cluster レプリケーションの競合解決">セクション23.6.11「NDB Cluster レプリケーションの競合解決」</a>を参照してください。) NDB Cluster は、<code class="literal">slave_exec_mode</code> に明示的に設定された値を無視し、常に <code class="literal">IDEMPOTENT</code> として扱います。 
          </p><p>
            MySQL Server 8.0 では、<code class="literal">STRICT</code> モードがデフォルト値です。
          </p><p>
            この変数を設定すると、実行中のチャネルを含むすべてのレプリケーションチャネルに対して即時に有効になります。
          </p><p>
            <code class="literal">NDB</code>、<span class="emphasis"><em>「<code class="literal">IDEMPOTENT</code> モードは、重複キーエラーおよびキーが見つからないエラーが無視される可能性があることを絶対に確認している場合にのみ使用してください」</em></span>以外のストレージエンジンの場合。 マルチソースレプリケーションまたは循環レプリケーションが採用されている NDB Cluster のフェイルオーバーシナリオで使用されることを意図しており、ほかの場合には使用しないことをお勧めします。 
          </p></li><li class="listitem"><p><a name="sysvar_slave_load_tmpdir"></a>
            <code class="literal">slave_load_tmpdir</code>
          </p><a class="indexterm" name="idm46723654766176"></a><a class="indexterm" name="idm46723654764624"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for slave_load_tmpdir"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--slave-load-tmpdir=dir_name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_slave_load_tmpdir">slave_load_tmpdir</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>ディレクトリ名</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">Value of --tmpdir</code></td>
</tr></tbody></table></div><p>
            レプリカが一時ファイルを作成するディレクトリの名前。 この変数の設定は、実行中のチャネルを含め、すべてのレプリケーションチャネルに対してただちに有効になります。 変数値は、デフォルトでは <code class="literal">tmpdir</code> システム変数の値、またはそのシステム変数が指定されていない場合に適用されるデフォルトと等しくなります。 
          </p><p>
            レプリケーション SQL スレッドは、<code class="literal">LOAD DATA</code> ステートメントをレプリケートするときに、リレーログから一時ファイルにロードされるファイルを抽出し、それらをテーブルにロードします。 ソースにロードされたファイルが膨大な場合、レプリカ上の一時ファイルも膨大になります。 したがって、このオプションを使用して、使用可能な領域が大量にある一部のファイルシステムにあるディレクトリに一時ファイルを配置するようレプリカに指示することをお薦めします。 その場合、リレーログも非常に大きいため、リレーログをそのファイルシステムに配置するように <code class="literal">relay_log</code> システム変数を設定することもできます。 
          </p><p>
            このオプションで指定するディレクトリは、<code class="literal">LOAD DATA</code> ステートメントのレプリケートに使用される一時ファイルがマシンの再起動後も存続できるように、メモリーベースのファイルシステムではなくディスクベースのファイルシステムに配置する必要があります。 このディレクトリは、システム起動プロセス中にオペレーティングシステムによってクリアされるものではいけません。 ただし、一時ファイルが削除されている場合は、再起動後にレプリケーションを続行できるようになりました。 
          </p></li><li class="listitem"><p><a name="sysvar_slave_max_allowed_packet"></a>
            <code class="literal">slave_max_allowed_packet</code>
          </p><a class="indexterm" name="idm46723654731424"></a><a class="indexterm" name="idm46723654729872"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for slave_max_allowed_packet"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--slave-max-allowed-packet=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_slave_max_allowed_packet">slave_max_allowed_packet</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">1073741824</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1024</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">1073741824</code></td>
</tr></tbody></table></div><p>
            このオプションは、レプリケーション SQL および I/O スレッドが処理できる最大パケットサイズをバイト単位で設定します。 この変数の設定は、実行中のチャネルを含め、すべてのレプリケーションチャネルに対してただちに有効になります。 イベントヘッダーが追加されると、ソースは <code class="literal">max_allowed_packet</code> 設定より長いバイナリログイベントを書き込むことができます。 <code class="literal">slave_max_allowed_packet</code> の設定は、行ベースのレプリケーションを使用した大規模な更新によってレプリケーションが失敗しないように、ソースの <code class="literal">max_allowed_packet</code> 設定より大きくする必要があります。 
          </p><p>
            このグローバル変数は常に、1024 の正の整数の倍数である値を持ちます。そうでない何らかの値に設定しても、値は次に大きい 1024 の倍数に自動的に丸められて、格納または使用されます。<code class="literal">slave_max_allowed_packet</code> を 0 に設定すると、1024 が使用されます。 (このような場合、切り捨ての警告が発行されます。) デフォルトおよび最大値は 1073741824 (1G バイト) で、最小は 1024 です。 
          </p></li><li class="listitem"><p><a name="sysvar_slave_net_timeout"></a>
            <code class="literal">slave_net_timeout</code>
          </p><a class="indexterm" name="idm46723654694016"></a><a class="indexterm" name="idm46723654692464"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for slave_net_timeout"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--slave-net-timeout=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_slave_net_timeout">slave_net_timeout</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">60</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
            レプリカが接続の切断を考慮し、読取りを中断して再接続を試行するまでに、ソースからさらにデータまたはハートビートシグナルを待機する秒数。 この変数を設定しても、すぐには影響しません。 変数の状態は、後続のすべての <code class="literal">START REPLICA | SLAVE</code> コマンドに適用されます。 
          </p><p>
            デフォルト値は 60 秒 (1 分) です。 最初の再試行はタイムアウトの直後に発生します。 再試行の間隔は、<code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントの <code class="literal">SOURCE_CONNECT_RETRY</code> | <code class="literal">MASTER_CONNECT_RETRY</code> オプションによって制御され、再接続の試行回数は <code class="literal">SOURCE_RETRY_COUNT</code> | <code class="literal">MASTER_RETRY_COUNT</code> オプションによって制限されます。 
          </p><p>
            ハートビート間隔は、データが存在しない場合に接続タイムアウトが発生するのを停止します (接続が正常な場合)。ハートビート間隔は、<code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントの <code class="literal">SOURCE_HEARTBEAT_PERIOD</code> | <code class="literal">MASTER_HEARTBEAT_PERIOD</code> オプションによって制御されます。 ハートビート間隔はデフォルトで <code class="literal">slave_net_timeout</code> の半分の値に設定され、レプリカ接続メタデータリポジトリに記録されて <code class="literal">replication_connection_configuration</code>「パフォーマンススキーマ」テーブルに表示されます。 <code class="literal">slave_net_timeout</code> の値またはデフォルト設定を変更しても、明示的に設定されているか、以前に計算されたデフォルトを使用しているかにかかわらず、ハートビート間隔は自動的には変更されないことに注意してください。 接続タイムアウトが変更された場合は、<code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> も発行して、接続タイムアウトの前に発生するようにハートビート間隔を適切な値に調整する必要があります。 
          </p></li><li class="listitem"><p><a name="sysvar_slave_parallel_type"></a>
            <code class="literal">slave_parallel_type</code>
          </p><a class="indexterm" name="idm46723654644912"></a><a class="indexterm" name="idm46723654643360"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for slave_parallel_type"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--slave-parallel-type=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_slave_parallel_type">slave_parallel_type</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">DATABASE</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">DATABASE</code></p><p class="valid-value"><code class="literal">LOGICAL_CLOCK</code></p></td>
</tr></tbody></table></div><p>
            マルチスレッドのレプリカ (<code class="literal">slave_parallel_workers</code> が 0 より大きい値に設定されているレプリカ) の場合、<code class="literal">slave_parallel_type</code> はレプリカでパラレルに実行できるトランザクションを決定するために使用されるポリシーを指定します。 この変数は、マルチスレッドが有効になっていないレプリカには影響しません。 指定可能な値は次のとおりです。 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">LOGICAL_CLOCK</code>: ソース上の同じバイナリロググループのコミットの一部であるトランザクションは、レプリカ上で並列に適用されます。 可能な場合は、トランザクション間の依存性がタイムスタンプに基づいて追跡され、追加のパラレル化が提供されます。 この値を設定すると、<code class="literal">binlog_transaction_dependency_tracking</code> システム変数をソースで使用して、書込みセットがトランザクションで使用可能で、タイムスタンプと比較して改善された結果が得られる場合に、タイムスタンプのかわりに書込みセットがパラレル化に使用されるように指定できます。 
              </p></li><li class="listitem"><p>
                <code class="literal">DATABASE</code>: 異なるデータベースを更新するトランザクションはパラレルに適用されます。 この値は、データがソースで独立して同時に更新される複数のデータベースにパーティション化されている場合にのみ適しています。 このような制約はレプリカで違反する可能性があるため、クロスデータベース制約は存在できません。 
              </p></li></ul></div><p>
            <code class="literal">slave_preserve_commit_order=1</code> が設定されている場合、使用できるのは <code class="literal">LOGICAL_CLOCK</code> のみです。
          </p><p>
            レプリケーショントポロジで複数レベルのレプリカが使用されている場合、<code class="literal">LOGICAL_CLOCK</code> ではレプリカがソースから離れている各レベルのパラレル化が実現されないことがあります。 可能な場合は、ソースで <code class="literal">binlog_transaction_dependency_tracking</code> を使用してパラレル化にタイムスタンプのかわりに書込みセットを使用するように指定することで、この影響を軽減できます。 
          </p><p>
            <code class="literal">binlog_transaction_compression</code> システム変数を使用してバイナリログトランザクション圧縮が有効になっている場合、<code class="literal">slave_parallel_type</code> が <code class="literal">DATABASE</code> に設定されていると、トランザクションがスケジュールされる前に、トランザクションの影響を受けるすべてのデータベースがマップされます。 バイナリログトランザクション圧縮を <code class="literal">DATABASE</code> ポリシーとともに使用すると、イベントごとにマップおよびスケジュールされる圧縮されていないトランザクションと比較して並列度を減らすことができます。 
          </p></li><li class="listitem"><p><a name="sysvar_slave_parallel_workers"></a>
            <code class="literal">slave_parallel_workers</code>
          </p><a class="indexterm" name="idm46723654595840"></a><a class="indexterm" name="idm46723654594288"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for slave_parallel_workers"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--slave-parallel-workers=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_slave_parallel_workers">slave_parallel_workers</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">1024</code></td>
</tr></tbody></table></div><p>
            レプリカでマルチスレッドを有効にし、レプリケーショントランザクションをパラレルに実行するためのアプライヤスレッドの数を設定します。 値が 0 より大きい場合、レプリカは、指定された数のアプライヤスレッドと、それらを管理するためのコーディネータスレッドを持つマルチスレッドのレプリカです。 複数のレプリケーションチャネルを使用している場合、各チャネルにはこの数のスレッドがあります。 


          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              マルチスレッドレプリカは現在 NDB Cluster でサポートされていないため、この変数の設定は暗黙的に無視されます。 詳しくは<a class="xref" href="mysql-cluster.html#mysql-cluster-replication-issues" title="23.6.3 NDB Cluster レプリケーションの既知の問題">セクション23.6.3「NDB Cluster レプリケーションの既知の問題」</a>,をご覧ください。 
            </p></div><p>
            レプリカでマルチスレッドが有効になっている場合、トランザクションの再試行がサポートされます。 <code class="literal">slave_preserve_commit_order=1</code> の場合 



            レプリカ上のトランザクションは、レプリカリレーログに表示される順序と同じ順序でレプリカ上で外部化されます。 トランザクションがアプライヤスレッド間で分散される方法は、<code class="literal">slave_parallel_type</code> によって構成されます。 
          </p><p>
            パラレル実行を無効にするには、このオプションを 0 に設定します。これにより、レプリカに単一のアプライヤスレッドが提供され、コーディネータスレッドは提供されません。 この設定では、<code class="literal">slave_parallel_type</code> および <code class="literal">slave_preserve_commit_order</code> システム変数は効果がなく、無視されます。 
          </p><p>
            <code class="literal">slave_parallel_workers</code> を設定しても、すぐには影響しません。 変数の状態は、後続のすべての <code class="literal">START REPLICA | SLAVE</code> ステートメントに適用されます。 
          </p></li><li class="listitem"><p><a name="sysvar_slave_pending_jobs_size_max"></a>
            <code class="literal">slave_pending_jobs_size_max</code>
          </p><a class="indexterm" name="idm46723654553104"></a><a class="indexterm" name="idm46723654551024"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for slave_pending_jobs_size_max"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--slave-pending-jobs-size-max=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_slave_pending_jobs_size_max">slave_pending_jobs_size_max</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値 (≥ 8.0.12)</th>
<td><code class="literal">128M</code></td>
</tr><tr><th>デフォルト値 (8.0.11)</th>
<td><code class="literal">16M</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1024</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">16EiB</code></td>
</tr><tr><th>単位</th>
<td><code class="literal">bytes</code></td>
</tr><tr><th>ブロックサイズ</th>
<td><code class="literal">1024</code></td>
</tr></tbody></table></div><p>
            マルチスレッドレプリカの場合、この変数は、まだ適用されていないイベントを保持するアプライヤキューで使用可能なメモリーの最大量 (バイト単位) を設定します。 この変数を設定しても、マルチスレッドが有効になっていないレプリカには影響しません。 この変数を設定しても、すぐには影響しません。 変数の状態は、後続のすべての <code class="literal">START REPLICA | SLAVE</code> コマンドに適用されます。 
          </p><p>
            この変数に指定できる最小値は 1024 バイトです。デフォルトは 128MB です。 可能な最大値は 18446744073709551615 (16 exbibytes) です。 1024 バイトの正確な倍数でない値は、格納される前に 1024 バイトの次の小さい倍数に切り捨てられます。 
          </p><p>
            この変数の値は弱い制限であり、通常のワークロードと一致するように設定できます。 異常に大きいイベントがこのサイズを超えると、すべてのワーカースレッドに空のキューが設定されてから処理されるまで、トランザクションは保持されます。 後続のすべてのトランザクションは、大規模なトランザクションが完了するまで保持されます。 
          </p></li><li class="listitem"><p><a name="sysvar_slave_preserve_commit_order"></a>
            <code class="literal">slave_preserve_commit_order</code>
          </p><a class="indexterm" name="idm46723654510656"></a><a class="indexterm" name="idm46723654508576"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for slave_preserve_commit_order"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--slave-preserve-commit-order[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_slave_preserve_commit_order">slave_preserve_commit_order</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
            マルチスレッドのレプリカ (<code class="literal">slave_parallel_workers</code> が 0 より大きい値に設定されているレプリカ) の場合、<code class="literal">slave_preserve_commit_order=1</code> を設定すると、トランザクションはレプリカリレーログと同じ順序でレプリカで実行およびコミットされます。 これにより、レプリカリレーログから実行された一連のトランザクションのギャップが回避され、レプリカとソースで同じトランザクション履歴が保持されます (ただし、次の制限があります)。 この変数は、マルチスレッドが有効になっていないレプリカには影響しません。 
          </p><p>
            MySQL 8.0.18 まで、<code class="literal">slave_preserve_commit_order=1</code> を設定するには、バイナリロギング (<code class="literal">log_bin</code>) およびレプリカ更新ロギング (<code class="literal">log_slave_updates</code>) がレプリカで有効になっている必要があります。これは、MySQL 8.0 のデフォルト設定です。 MySQL 8.0.19 からは、バイナリロギングおよびレプリカ更新ロギングは、<code class="literal">slave_preserve_commit_order=1</code> を設定するためにレプリカでは必要なく、必要に応じて無効にできます。 すべてのリリースで、<code class="literal">slave_preserve_commit_order=1</code> を設定するには、<code class="literal">slave_parallel_type</code> がデフォルト設定ではない <code class="literal">LOGICAL_CLOCK</code> に設定されている必要があります。 <code class="literal">slave_preserve_commit_order</code> および <code class="literal">slave_parallel_type</code> の値を変更する前に、レプリケーション SQL スレッド (複数のレプリケーションチャネルを使用している場合はすべてのレプリケーションチャネル用) を停止する必要があります。 
          </p><p>
            <code class="literal">slave_preserve_commit_order=0</code> が設定されている場合 (デフォルト)、マルチスレッドレプリカがパラレルで適用するトランザクションは、順序が正しくない場合があります。 したがって、最後に実行されたトランザクションのチェックでは、ソースの以前のすべてのトランザクションがレプリカで実行されていることは保証されません。 レプリカリレーログから実行された一連のトランザクションにギャップが生じる可能性があります。 これは、マルチスレッドレプリカを使用する場合のロギングおよびリカバリに影響します。 詳しくは<a class="xref" href="replication.html#replication-features-transaction-inconsistencies" title="17.5.1.34 レプリケーションとトランザクションの非一貫性">セクション17.5.1.34「レプリケーションとトランザクションの非一貫性」</a>をご覧ください。 
          </p><p>
            <code class="literal">slave_preserve_commit_order=1</code> が設定されている場合、実行中のワーカースレッドは、前のすべてのトランザクションがコミットされるまで待機してからコミットします。 特定のスレッドが他のワーカースレッドによるトランザクションのコミットを待機している間、そのステータスは <code class="literal">Waiting for preceding transaction to commit</code> としてレポートされます。 このモードでは、マルチスレッドレプリカはソースが存在しなかった状態になることはありません。 これにより、読取りスケールアウトでのレプリケーションの使用がサポートされます。 <a class="xref" href="replication.html#replication-solutions-scaleout" title="17.4.5 スケールアウトのためにレプリケーションを使用する">セクション17.4.5「スケールアウトのためにレプリケーションを使用する」</a>を参照してください。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">slave_preserve_commit_order=1</code> では、<code class="literal">Exec_master_log_pos</code> がトランザクションが実行された位置より遅れているソースバイナリログの位置ラグは防止されません。 <a class="xref" href="replication.html#replication-features-transaction-inconsistencies" title="17.5.1.34 レプリケーションとトランザクションの非一貫性">セクション17.5.1.34「レプリケーションとトランザクションの非一貫性」</a>を参照してください。 
                </p></li><li class="listitem"><p>
                  レプリカが <code class="option">--binlog-do-db</code> などのバイナリログでフィルタを使用する場合、<code class="literal">slave_preserve_commit_order=1</code> はコミット順序およびトランザクション履歴を保持しません。
                </p></li><li class="listitem"><p>
                  <code class="literal">slave_preserve_commit_order=1</code> では、非トランザクション DML 更新の順序は保持されません。 これらはリレーログ内で、それらより前のトランザクションの前にコミットされる可能性があるため、レプリカリレーログから実行された一連のトランザクションにギャップが生じる可能性があります。 
                </p></li><li class="listitem"><p>
                  MySQL 8.0.19 より前のリリースでは、関連するオブジェクトが存在しない場合、<code class="literal">slave_preserve_commit_order=1</code> は <code class="literal">IF EXISTS</code> 句を含むステートメントの順序を保持しません。 これらはリレーログ内で、それらより前のトランザクションの前にコミットされる可能性があるため、レプリカリレーログから実行された一連のトランザクションにギャップが生じる可能性があります。 
                </p></li><li class="listitem"><p>
                  ステートメントベースのレプリケーションが使用中で、トランザクションおよび非トランザクションの両方のストレージエンジンがソースでロールバックされる非 XA トランザクションに参加している場合、レプリカ上のコミット順序を保持する制限が発生することがあります。 通常、ソースでロールバックされる非 XA トランザクションはレプリカにレプリケートされませんが、この特定の状況ではトランザクションがレプリカにレプリケートされる可能性があります。 これが発生した場合、バイナリロギングのないマルチスレッドレプリカはトランザクションのロールバックを処理しないため、レプリカ上のコミット順序は、その場合のトランザクションのリレーログ順序とは異なります。 
                </p></li></ul></div></div></li><li class="listitem"><p><a name="sysvar_slave_rows_search_algorithms"></a>
            <code class="literal">slave_rows_search_algorithms</code>
          </p><a class="indexterm" name="idm46723654448048"></a><a class="indexterm" name="idm46723654446480"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for slave_rows_search_algorithms"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--slave-rows-search-algorithms=value</code></td>
</tr><tr><th>非推奨</th>
<td>8.0.18</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_slave_rows_search_algorithms">slave_rows_search_algorithms</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Set</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">INDEX_SCAN,HASH_SCAN</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">TABLE_SCAN,INDEX_SCAN</code></p><p class="valid-value"><code class="literal">INDEX_SCAN,HASH_SCAN</code></p><p class="valid-value"><code class="literal">TABLE_SCAN,HASH_SCAN</code></p><p class="valid-value"><code class="literal">TABLE_SCAN,INDEX_SCAN,HASH_SCAN</code> (INDEX_SCAN,HASH_SCAN と同等)</p></td>
</tr></tbody></table></div><p>
            行ベースのロギングおよびレプリケーションのために行のバッチを準備する場合、このシステム変数は、行で一致を検索する方法、特にハッシュスキャンを使用するかどうかを制御します。 このシステム変数の使用は非推奨になりました。 デフォルト設定の <code class="literal">INDEX_SCAN,HASH_SCAN</code> はパフォーマンスに最適で、すべてのシナリオで正しく機能します。 <a class="xref" href="replication.html#replication-features-row-searches" title="17.5.1.27 レプリケーションおよび行検索">セクション17.5.1.27「レプリケーションおよび行検索」</a>を参照してください。 
          </p></li><li class="listitem"><p><a name="sysvar_slave_skip_errors"></a>
            <code class="literal">slave_skip_errors</code>
          </p><a class="indexterm" name="idm46723654411424"></a><a class="indexterm" name="idm46723654409872"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for slave-skip-errors"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--slave-skip-errors=name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_slave_skip_errors">slave_skip_errors</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">OFF</code></p><p class="valid-value"><code class="literal">[list of error codes]</code></p><p class="valid-value"><code class="literal">all</code></p><p class="valid-value"><code class="literal">ddl_exist_errors</code></p></td>
</tr></tbody></table></div><p>
            通常、レプリケーションはレプリカでエラーが発生すると停止するため、データの非一貫性を手動で解決できます。 この変数を指定すると、ステートメントが変数値にリストされているエラーのいずれかを返したときに、レプリケーション SQL スレッドはレプリケーションを続行します。 
          </p></li><li class="listitem"><p><a name="sysvar_slave_sql_verify_checksum"></a>
            <code class="literal">slave_sql_verify_checksum</code>
          </p><a class="indexterm" name="idm46723654379104"></a><a class="indexterm" name="idm46723654377536"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for slave_sql_verify_checksum"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--slave-sql-verify-checksum[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_slave_sql_verify_checksum">slave_sql_verify_checksum</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
            レプリケーション SQL スレッドがリレーログから読み取られたチェックサムを使用してデータを検証するようにします。 不一致が発生した場合、レプリカはエラーで停止します。 この変数の設定は、実行中のチャネルを含め、すべてのレプリケーションチャネルに対してただちに有効になります。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              レプリケーション I/O スレッドは、ネットワーク経由でイベントを受け入れるときに、可能であれば常にチェックサムを読み取ります。
            </p></div></li><li class="listitem"><p><a name="sysvar_slave_transaction_retries"></a>
            <code class="literal">slave_transaction_retries</code>
          </p><a class="indexterm" name="idm46723654351120"></a><a class="indexterm" name="idm46723654349552"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for slave_transaction_retries"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--slave-transaction-retries=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_slave_transaction_retries">slave_transaction_retries</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">10</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値 (64 ビットプラットフォーム)</th>
<td><code class="literal">18446744073709551615</code></td>
</tr><tr><th>最大値 (32 ビットプラットフォーム)</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
            シングルスレッドまたはマルチスレッドレプリカ上のレプリケーション SQL スレッドが、停止前に失敗したトランザクションを自動的に再試行する最大回数を設定します。 この変数の設定は、実行中のチャネルを含め、すべてのレプリケーションチャネルに対してただちに有効になります。 デフォルト値は 10 です。 変数を 0 に設定すると、トランザクションの自動再試行が無効になります。 
          </p><p>
            <code class="literal">InnoDB</code> デッドロックのため、またはトランザクション実行時間が <code class="literal">InnoDB</code> の <code class="literal">innodb_lock_wait_timeout</code>、<code class="literal">NDB</code> の <code class="literal">TransactionDeadlockDetectionTimeout</code> または <code class="literal">TransactionInactiveTimeout</code> を超えたためにレプリケーション SQL スレッドがトランザクションの実行に失敗した場合、エラーで停止する前に <code class="literal">slave_transaction_retries</code> 回自動的に再試行されます。 一時的でないエラーのあるトランザクションは再試行されません。 
          </p><p>
            「パフォーマンススキーマ」テーブル <code class="literal">replication_applier_status</code> の <code class="literal">COUNT_TRANSACTIONS_RETRIES</code> カラムには、各レプリケーションチャネルで行われた再試行回数が表示されます。 「パフォーマンススキーマ」テーブル <code class="literal">replication_applier_status_by_worker</code> には、シングルスレッドまたはマルチスレッドレプリカ上の個々のアプライヤスレッドによるトランザクションの再試行に関する詳細情報が表示され、最後のトランザクションの原因となったエラーおよび現在進行中のトランザクションの再試行が識別されます。 
          </p></li><li class="listitem"><p><a name="sysvar_slave_type_conversions"></a>
            <code class="literal">slave_type_conversions</code>
          </p><a class="indexterm" name="idm46723654304832"></a><a class="indexterm" name="idm46723654303280"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for slave_type_conversions"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--slave-type-conversions=set</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_slave_type_conversions">slave_type_conversions</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Set</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal"></code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">ALL_LOSSY</code></p><p class="valid-value"><code class="literal">ALL_NON_LOSSY</code></p><p class="valid-value"><code class="literal">ALL_SIGNED</code></p><p class="valid-value"><code class="literal">ALL_UNSIGNED</code></p></td>
</tr></tbody></table></div><p>
            行ベースレプリケーションの使用時にレプリカで有効な型変換モードを制御します。 その値は、リスト内のゼロ個以上の要素のカンマ区切りセットです: <code class="literal">ALL_LOSSY</code>, <code class="literal">ALL_NON_LOSSY</code>, <code class="literal">ALL_SIGNED</code>, <code class="literal">ALL_UNSIGNED</code>。 ソースとレプリカ間の型変換を禁止するには、この変数を空の文字列に設定します。 この変数の設定は、実行中のチャネルを含め、すべてのレプリケーションチャネルに対してただちに有効になります。 
          </p><p>
            行ベースレプリケーションで属性の昇格と降格に適用できるタイプ変換モードの詳細については、<a class="xref" href="replication.html#replication-features-attribute-promotion" title="行ベースレプリケーション: 属性の昇格と降格">行ベースレプリケーション: 属性の昇格と降格</a>を参照してください。
          </p></li><li class="listitem"><p><a name="sysvar_sql_slave_skip_counter"></a>
            <code class="literal">sql_slave_skip_counter</code>
          </p><a class="indexterm" name="idm46723654268064"></a><a class="indexterm" name="idm46723654266512"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for sql_slave_skip_counter"><col style="width=30%"><col style="width=70%"><tbody><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_sql_slave_skip_counter">sql_slave_skip_counter</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値 (64 ビットプラットフォーム)</th>
<td><code class="literal">18446744073709551615</code></td>
</tr><tr><th>最大値 (32 ビットプラットフォーム)</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
            レプリカがスキップするソースからのイベントの数。 このオプションを設定しても、すぐには影響しません。 変数は次の <code class="literal">START REPLICA | SLAVE</code> ステートメントに適用され、次の <code class="literal">START REPLICA | SLAVE</code> ステートメントでも値が 0 に戻ります。 この変数がゼロ以外の値に設定され、複数のレプリケーションチャネルが構成されている場合、<code class="literal">START REPLICA | SLAVE</code> ステートメントは <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句でのみ使用できます。 
          </p><p>
            このオプションは GTID ベースのレプリケーションと互換性がなく、<code class="literal">gtid_mode=ON</code> が設定されている場合はゼロ以外の値に設定しないでください。 GTID の採用時にトランザクションをスキップする必要がある場合は、かわりにソースから <code class="literal">gtid_executed</code> を使用します。 <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントの <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> オプションを使用してレプリケーションチャネルで GTID 割当てを有効にした場合、<code class="literal">sql_slave_skip_counter</code> を使用できます。 <a class="xref" href="replication.html#replication-administration-skip" title="17.1.7.3 トランザクションのスキップ">セクション17.1.7.3「トランザクションのスキップ」</a>を参照してください。 
          </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
              この変数を設定して指定されたイベント数をスキップすると、レプリカがイベントグループの途中で開始される場合、レプリカは次のイベントグループの開始を検出し、その時点から開始するまでスキップし続けます。 詳細は、<a class="xref" href="replication.html#replication-administration-skip" title="17.1.7.3 トランザクションのスキップ">セクション17.1.7.3「トランザクションのスキップ」</a>を参照してください。 
            </p></div></li><li class="listitem"><p><a name="sysvar_sync_master_info"></a>
            <code class="literal">sync_master_info</code>
          </p><a class="indexterm" name="idm46723654222496"></a><a class="indexterm" name="idm46723654220960"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for sync_master_info"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--sync-master-info=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_sync_master_info">sync_master_info</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">10000</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値 (64 ビットプラットフォーム)</th>
<td><code class="literal">18446744073709551615</code></td>
</tr><tr><th>最大値 (32 ビットプラットフォーム)</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
            レプリカが接続メタデータリポジトリを更新するまでのイベント数。 接続メタデータリポジトリが MySQL 8.0 のデフォルトである <code class="literal">InnoDB</code> テーブルとして格納されている場合、この数のイベントの後に更新されます。 接続メタデータリポジトリが、MySQL 8.0 から非推奨になったファイルとして格納されている場合、レプリカは、この数のイベントの後に、(<code class="literal">fdatasync()</code> を使用して) <code class="literal">master.info</code> ファイルをディスクに同期します。 デフォルト値は 10000 で、ゼロ値はリポジトリが更新されないことを意味します。 この変数の設定は、実行中のチャネルを含め、すべてのレプリケーションチャネルに対してただちに有効になります。 
          </p></li><li class="listitem"><p><a name="sysvar_sync_relay_log"></a>
            <code class="literal">sync_relay_log</code>
          </p><a class="indexterm" name="idm46723654185216"></a><a class="indexterm" name="idm46723654183696"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for sync_relay_log"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--sync-relay-log=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_sync_relay_log">sync_relay_log</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">10000</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値 (64 ビットプラットフォーム)</th>
<td><code class="literal">18446744073709551615</code></td>
</tr><tr><th>最大値 (32 ビットプラットフォーム)</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
            この変数の値が 0 より大きい場合は、すべての <code class="literal">sync_relay_log</code> イベントがリレーログに書き込まれたあとに、MySQL サーバーはそのリレーログをディスクに同期します (<code class="literal">fdatasync()</code> を使用)。 この変数の設定は、実行中のチャネルを含め、すべてのレプリケーションチャネルに対してただちに有効になります。 
          </p><p>
            <code class="literal">sync_relay_log</code> を 0 に設定すると、ディスクへの同期は実行されません。この場合、サーバーはオペレーティングシステムに依存してほかのファイルに関してリレーログの内容をときどきフラッシュします。
          </p><p>
            値 1 は、予期しない停止が発生した場合にリレーログから最大 1 つのイベントが失われるため、もっとも安全な選択です。 しかし、一番遅い選択でもあります (ディスクにバッテリ付きキャッシュがある場合を除きます。その場合は同期が非常に速くなります)。 予期しない停止に対して最も回復可能なレプリカの設定の組合せの詳細は、<a class="xref" href="replication.html#replication-solutions-unexpected-replica-halt" title="17.4.2 レプリカの予期しない停止の処理">セクション17.4.2「レプリカの予期しない停止の処理」</a> を参照してください。 
          </p></li><li class="listitem"><p><a name="sysvar_sync_relay_log_info"></a>
            <code class="literal">sync_relay_log_info</code>
          </p><a class="indexterm" name="idm46723654146096"></a><a class="indexterm" name="idm46723654144544"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for sync_relay_log_info"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--sync-relay-log-info=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_sync_relay_log_info">sync_relay_log_info</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">10000</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値 (64 ビットプラットフォーム)</th>
<td><code class="literal">18446744073709551615</code></td>
</tr><tr><th>最大値 (32 ビットプラットフォーム)</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
            レプリカが適用者メタデータリポジトリを更新するまでのトランザクションの数。 アプライヤメタデータリポジトリが MySQL 8.0 のデフォルトである <code class="literal">InnoDB</code> テーブルとして格納されている場合、トランザクションのたびに更新され、このシステム変数は無視されます。 アプライヤメタデータリポジトリが、MySQL 8.0 で非推奨になったファイルとして格納されている場合、レプリカは、この数のトランザクションの後に、(<code class="literal">fdatasync()</code> を使用して) <code class="literal">relay-log.info</code> ファイルをディスクに同期します。 <code class="literal">sync_relay_log_info</code> のデフォルト値は 10000 で、ゼロ値はファイルの内容がオペレーティングシステムによってのみフラッシュされることを意味します。 この変数の設定は、実行中のチャネルを含め、すべてのレプリケーションチャネルに対してただちに有効になります。 
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-options-binary-log"></a>17.1.6.4 バイナリロギングのオプションと変数</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="replication.html#replication-optvars-binlog" title="バイナリロギングで使用する起動オプション">バイナリロギングで使用する起動オプション</a></p></li><li class="listitem"><p><a class="xref" href="replication.html#replication-sysvars-binlog" title="バイナリロギングで使用されるシステム変数">バイナリロギングで使用されるシステム変数</a></p></li></ul></div><p>
      このセクションで説明する <span class="command"><strong>mysqld</strong></span> オプションおよびシステム変数を使用して、バイナリログの操作に影響を与えたり、バイナリログにどのステートメントが書き込まれたかを制御したりできます。 バイナリログの追加情報については、<a class="xref" href="server-administration.html#binary-log" title="5.4.4 バイナリログ">セクション5.4.4「バイナリログ」</a>を参照してください。 MySQL サーバーのオプションとシステム変数の使用に関する追加情報については、<a class="xref" href="server-administration.html#server-options" title="5.1.7 サーバーコマンドオプション">セクション5.1.7「サーバーコマンドオプション」</a>および<a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>を参照してください。 
    </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-optvars-binlog"></a>バイナリロギングで使用する起動オプション</h5></div></div></div><p>
        次のリストでは、バイナリログを有効化したり構成したりするための起動オプションについて説明します。 バイナリロギングで使用するシステム変数については、このセクションの後半で説明します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_binlog-row-event-max-size"></a>
            <code class="option">--binlog-row-event-max-size=<em class="replaceable"><code>N</code></em></code>
          </p><a class="indexterm" name="idm46723654097520"></a><a class="indexterm" name="idm46723654095280"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog-row-event-max-size"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-row-event-max-size=#</code></td>
</tr><tr><th>システム変数 (≥ 8.0.14)</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_row_event_max_size">binlog_row_event_max_size</a></code></td>
</tr><tr><th>スコープ (≥ 8.0.14)</th>
<td>グローバル</td>
</tr><tr><th>動的 (≥ 8.0.14)</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用 (≥ 8.0.14)</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">8192</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">256</code></td>
</tr><tr><th>最大値 (64 ビットプラットフォーム)</th>
<td><code class="literal">18446744073709551615</code></td>
</tr><tr><th>最大値 (32 ビットプラットフォーム)</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
            行ベースのバイナリロギングを使用する場合、この設定は、行ベースのバイナリログイベントの最大サイズに対する弱い制限 (バイト単位) です。 可能であれば、バイナリログに格納されている行は、この設定の値を超えないサイズのイベントにグループ化されます。 イベントを分割できない場合は、最大サイズを超えることができます。 値は 256 の倍数である必要があります (そうでない場合は切り捨てられます)。 デフォルトは 8192 バイトです。 
          </p></li><li class="listitem"><p><a name="option_mysqld_log-bin"></a>
            <code class="option">--log-bin[=<em class="replaceable"><code>base_name</code></em>]</code>
          </p><a class="indexterm" name="idm46723654062272"></a><a class="indexterm" name="idm46723654060096"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for log-bin"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--log-bin=file_name</code></td>
</tr><tr><th>型</th>
<td>ファイル名</td>
</tr></tbody></table></div><p>
            バイナリログファイルに使用するベース名を指定します。 バイナリロギングが有効になっている場合、サーバーは、データを変更するすべてのステートメントをバイナリログに記録します。バイナリログは、バックアップとレプリケーションに使用されます。 バイナリログは、ベース名と数値拡張子を持つ一連のファイルです。 <code class="option">--log-bin</code> オプションの値は、ログ順序のベース名です。 サーバーは、ベース名に数値の接尾辞を追加して、バイナリログファイルを順番に作成します。 
          </p><p>
            <code class="option">--log-bin</code> オプションを指定しない場合、MySQL はバイナリログファイルのデフォルトのベース名として <code class="filename">binlog</code> を使用します。 以前のリリースとの互換性のために、文字列なしまたは空の文字列を指定して <code class="option">--log-bin</code> オプションを指定した場合、ベース名はホストマシンの名前を使用して <code class="filename"><em class="replaceable"><code>host_name</code></em>-bin</code> にデフォルト設定されます。 
          </p><p>
            バイナリログファイルのデフォルトの場所はデータディレクトリです。 ベース名に先頭の絶対パス名を追加して別のディレクトリを指定することで、<code class="option">--log-bin</code> オプションを使用して別の場所を指定できます。 サーバーは、使用されたバイナリログファイルを追跡するバイナリログインデックスファイルからエントリを読み取るときに、エントリに相対パスが含まれているかどうかを確認します。 その場合、パスの相対部分は、<code class="option">--log-bin</code> オプションを使用して設定された絶対パスに置き換えられます。 バイナリログインデックスファイルに記録された絶対パスは変更されません。このような場合は、新しいパスを使用できるようにインデックスファイルを手動で編集する必要があります。 バイナリログファイルのベース名と指定されたパスは、<code class="literal">log_bin_basename</code> システム変数として使用できます。 
          </p><p>
            以前の MySQL バージョンでは、バイナリロギングはデフォルトで無効になっており、<code class="option">--log-bin</code> オプションを指定した場合は有効になっていました。 MySQL 8.0 からは、<code class="option">--log-bin</code> オプションを指定するかどうかにかかわらず、バイナリロギングはデフォルトで有効になっています。 例外は、バイナリロギングがデフォルトで無効になっている場合に、<span class="command"><strong>mysqld</strong></span> を使用して <code class="option">--initialize</code> または <code class="option">--initialize-insecure</code> オプションを指定してデータディレクトリを手動で呼び出すことによって、データディレクトリを初期化する場合です。 この場合、<code class="option">--log-bin</code> オプションを指定することでバイナリロギングを有効にできます。 バイナリロギングが有効になっている場合、サーバー上のバイナリロギングのステータスを示す <code class="literal">log_bin</code> システム変数は ON に設定されます。 


          </p><p>
            バイナリロギングを無効にするには、起動時に <code class="option">--skip-log-bin</code> または <code class="option">--disable-log-bin</code> オプションを指定できます。 これらのオプションのいずれかが指定され、<code class="option">--log-bin</code> も指定されている場合は、後で指定するオプションが優先されます。 バイナリロギングが無効になっている場合、<code class="literal">log_bin</code> システム変数は OFF に設定されます。 
          </p><p>
            GTID がサーバーで使用されているときに、異常シャットダウン後にサーバーを再起動するときにバイナリロギングを無効にすると、GTID の一部が失われ、レプリケーションが失敗する可能性があります。 通常のシャットダウンでは、現在のバイナリログファイルから GTID のセットが <code class="literal">mysql.gtid_executed</code> テーブルに保存されます。 これが発生しなかった異常なシャットダウンのあと、バイナリロギングがまだ有効になっている場合は、回復中に GTID がバイナリログファイルからテーブルに追加されます。 サーバーの再起動に対してバイナリロギングが無効になっている場合、サーバーはバイナリログファイルにアクセスして GTID を回復できないため、レプリケーションを開始できません。 バイナリロギングは、通常のシャットダウン後に安全に無効にできます。 
          </p><p>
            <code class="option">--log-slave-updates</code> および <code class="option">--slave-preserve-commit-order</code> オプションにはバイナリロギングが必要です。 バイナリロギングを無効にする場合は、これらのオプションを省略するか、<code class="option">--log-slave-updates=OFF</code> および <code class="option">--skip-slave-preserve-commit-order</code> を指定します。 <code class="option">--skip-log-bin</code> または <code class="option">--disable-log-bin</code> が指定されている場合、MySQL はこれらのオプションをデフォルトで無効にします。 <code class="option">--log-slave-updates</code> または <code class="option">--slave-preserve-commit-order</code> を <code class="option">--skip-log-bin</code> または <code class="option">--disable-log-bin</code> とともに指定すると、警告またはエラーメッセージが発行されます。 
          </p><p>
            MySQL 5.7 では、バイナリロギングが有効になっているときにサーバー ID を指定する必要がありました。そうしないと、サーバーが起動しません。 MySQL 8.0 では、<code class="literal">server_id</code> システム変数はデフォルトで 1 に設定されています。 バイナリロギングが有効になっている場合、このデフォルトのサーバー ID を使用してサーバーを起動できるようになりましたが、<code class="literal">server_id</code> システム変数を設定してサーバー ID を明示的に指定しないと、情報メッセージが発行されます。 レプリケーショントポロジで使用されるサーバーの場合、サーバーごとにゼロ以外の一意のサーバー ID を指定する必要があります。 
          </p><p>
            バイナリログの形式と管理については、<a class="xref" href="server-administration.html#binary-log" title="5.4.4 バイナリログ">セクション5.4.4「バイナリログ」</a> を参照してください。
          </p></li><li class="listitem"><p><a name="option_mysqld_log-bin-index"></a>
            <code class="option">--log-bin-index[=<em class="replaceable"><code>file_name</code></em>]</code>
          </p><a class="indexterm" name="idm46723654009904"></a><a class="indexterm" name="idm46723654007744"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for log-bin-index"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--log-bin-index=file_name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_log_bin_index">log_bin_index</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>ファイル名</td>
</tr></tbody></table></div><p>
            バイナリログインデックスファイルの名前。バイナリログファイルの名前が含まれます。 デフォルトでは、<code class="option">--log-bin</code> オプションと拡張子 <code class="filename">.index</code> を使用してバイナリログファイルに指定された値と同じ場所とベース名を持ちます。 <code class="option">--log-bin</code> を指定しない場合、デフォルトのバイナリログインデックスファイル名は <code class="filename">binlog.index</code> です。 文字列または空の文字列を指定せずに <code class="option">--log-bin</code> オプションを指定した場合、デフォルトのバイナリログインデックスファイル名は、ホストマシンの名前を使用して <code class="filename"><em class="replaceable"><code>host_name</code></em>-bin.index</code> になります。 
          </p><p>
            バイナリログの形式と管理については、<a class="xref" href="server-administration.html#binary-log" title="5.4.4 バイナリログ">セクション5.4.4「バイナリログ」</a> を参照してください。
          </p></li></ul></div><p><b>ステートメント選択オプション. </b>
          次のリストのオプションは、バイナリログに書き込まれ、レプリケーションソースサーバーによってその複製に送信されるステートメントに影響します。 レプリカには、ソースから受信したどのステートメントを実行または無視するかを制御するオプションもあります。 詳細は、<a class="xref" href="replication.html#replication-options-replica" title="17.1.6.3 Replica Server のオプションと変数">セクション17.1.6.3「Replica Server のオプションと変数」</a>を参照してください。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_binlog-do-db"></a>
            <code class="option">--binlog-do-db=<em class="replaceable"><code>db_name</code></em></code>
          </p><a class="indexterm" name="idm46723653975296"></a><a class="indexterm" name="idm46723653973136"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog-do-db"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-do-db=name</code></td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
            このオプションは、<code class="option">--replicate-do-db</code> がレプリケーションに影響するのと同様にバイナリロギングに影響します。
          </p><p>
            このオプションの影響は、ステートメントベースまたは行ベースロギング形式のどちらが使用されるかに依存します (<code class="option">--replicate-do-db</code> の影響がステートメントベースまたは行ベースレプリケーションのどちらが使用されたかに依存すると同じ)。 指定されたステートメントのログを記録するために使用される形式が、<code class="literal">binlog_format</code> の値で示される形式と必ずしも同じではないことに留意してください。 たとえば、<code class="literal">CREATE TABLE</code> や <code class="literal">ALTER TABLE</code> などの DDL ステートメントは、有効になっているロギング形式にかかわらず、常にステートメントとしてログが記録されるため、<code class="option">--binlog-do-db</code> の次のステートメントベースルールはステートメントのログが記録されるかどうかの判断に常に適用されます。 
          </p><p><b>ステートメントベースのロギング. </b>
              デフォルトデータベース (つまり、<code class="literal">USE</code> で選択されたもの) が <em class="replaceable"><code>db_name</code></em> であるステートメントだけが、バイナリログに書き込まれます。 複数のデータベースを指定するには、このオプションを複数回 （データベースごとに 1 回） 使用します。ただし、このようにしても、別のデータベースが選択されているとき （またはデータベースが選択されていないとき） に、<code class="literal">UPDATE <em class="replaceable"><code>some_db.some_table</code></em> SET foo='bar'</code> などのクロスデータベースステートメントのログは記録<span class="emphasis"><em>されません</em></span>。 
            </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
              複数のデータベースを指定するには、このオプションの複数インスタンスを使用する<span class="emphasis"><em>必要があります</em></span>。 データベース名にはカンマを含めることができるため、カンマ区切りリストを指定すると、リストは単一のデータベースの名前として扱われます。 
            </p></div><p>
            ステートメントベースロギングを使用するときに想定される、機能しない例: サーバーが <code class="option">--binlog-do-db=sales</code> で起動され、次のステートメントを発行する場合、<code class="literal">UPDATE</code> ステートメントのログは記録<span class="emphasis"><em>されません</em></span>。
          </p><pre class="programlisting">USE prices;
UPDATE sales.january SET amount=amount+1000;
</pre><p>
            この<span class="quote">「<span class="quote">デフォルトデータベースをチェックするだけ</span>」</span>動作の主な理由は、ステートメントだけから複製すべきかどうかを知ることが難しいことです (たとえば、複数のデータベースをまたがって動作する複数テーブル <code class="literal">DELETE</code> ステートメントまたは複数テーブル <code class="literal">UPDATE</code> ステートメントを使用する場合)。 また、必要がない場合、すべてのデータベースではなくデフォルトデータベースだけをチェックする方が早いです。 
          </p><p>
            もう 1 つのケースは自明ではないかもしれませんが、オプションを設定するときに指定されなかったけれども所定のデータベースが複製されます。 サーバーが <code class="option">--binlog-do-db=sales</code> で起動される場合、<code class="option">--binlog-do-db</code> の設定時に <code class="literal">prices</code> が含まれなかったけれども、次の <code class="literal">UPDATE</code> ステートメントのログが記録されます。 
          </p><pre class="programlisting">USE sales;
UPDATE prices.discounts SET percentage = percentage + 10;
</pre><p>
            <code class="literal">UPDATE</code> ステートメントが発行されたときに <code class="literal">sales</code> がデフォルトデータベースであるため、<code class="literal">UPDATE</code> のログが記録されます。
          </p><p><b>行ベースのロギング. </b>
              ロギングはデータベース <em class="replaceable"><code>db_name</code></em> に制限されます。 <em class="replaceable"><code>db_name</code></em> に属するテーブルへの変更だけがログに記録されます。デフォルトデータベースはこれに影響しません。 サーバーが <code class="option">--binlog-do-db=sales</code> で起動され、行ベースロギングが有効であると想定すると、次のステートメントが実行されます。 
            </p><pre class="programlisting">USE prices;
UPDATE sales.february SET amount=amount+100;
</pre><p>
            <code class="literal">sales</code> データベース内の <code class="literal">february</code> テーブルへの変更が、<code class="literal">UPDATE</code> ステートメントに従ってログに記録されます。これは <code class="literal">USE</code> ステートメントが発行されたかどうかにかかわらず発生します。 ただし、行ベースロギング形式および <code class="option">--binlog-do-db=sales</code> を使用するときは、次の <code class="literal">UPDATE</code> によって行われた変更のログは記録されません。 
          </p><pre class="programlisting">USE prices;
UPDATE prices.march SET amount=amount-25;
</pre><p>
            <code class="literal">USE prices</code> ステートメントが <code class="literal">USE sales</code> に変更された場合でも、<code class="literal">UPDATE</code> ステートメントの結果は依然としてバイナリログに書き込まれません。
          </p><p>
            <code class="option">--binlog-do-db</code> 処理でステートメントベースロギングと行ベースロギング間のもう 1 つの重要な違いは、複数のデータベースを参照するステートメントに関して発生します。 サーバーが <code class="option">--binlog-do-db=db1</code> で起動され、次のステートメントが実行されると想定します。 
          </p><pre class="programlisting">USE db1;
UPDATE db1.table1, db2.table2 SET db1.table1.col1 = 10, db2.table2.col2 = 20;
</pre><p>
            ステートメントベースロギングを使用している場合、両方のテーブルへの更新がバイナリログに書き込まれます。 一方、行ベース形式を使用するときは、<code class="literal">table1</code> への変更だけがログに記録されます。<code class="literal">table2</code> は別のデータベース内にあり、<code class="literal">UPDATE</code> によって変更されません。 ここで、<code class="literal">USE db1</code> ステートメントの代わりに、<code class="literal">USE db4</code> ステートメントが使用されたものとします。 
          </p><pre class="programlisting">USE db4;
UPDATE db1.table1, db2.table2 SET db1.table1.col1 = 10, db2.table2.col2 = 20;
</pre><p>
            この場合、ステートメントベースロギングを使用するときに <code class="literal">UPDATE</code> ステートメントはバイナリログに書き込まれません。 一方、行ベースロギングを使用するときは、<code class="literal">table1</code> への変更のログは記録されますが、<code class="literal">table2</code> へはそうなりません。つまり、<code class="option">--binlog-do-db</code> によって指定されたデータベース内のテーブルへの変更のみがログに記録され、デフォルトデータベースの選択はこの動作に影響しません。 
          </p></li><li class="listitem"><p><a name="option_mysqld_binlog-ignore-db"></a>
            <code class="option">--binlog-ignore-db=<em class="replaceable"><code>db_name</code></em></code>
          </p><a class="indexterm" name="idm46723653902400"></a><a class="indexterm" name="idm46723653900240"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog-ignore-db"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-ignore-db=name</code></td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
            このオプションは、<code class="option">--replicate-ignore-db</code> がレプリケーションに影響するように、バイナリロギングに影響します。
          </p><p>
            このオプションの影響は、ステートメントベースまたは行ベースロギング形式のどちらが使用されるかに依存します (<code class="option">--replicate-ignore-db</code> の影響がステートメントベースまたは行ベースレプリケーションのどちらが使用されたかに依存すると同じ)。 指定されたステートメントのログを記録するために使用される形式が、<code class="literal">binlog_format</code> の値で示される形式と必ずしも同じではないことに留意してください。 たとえば、<code class="literal">CREATE TABLE</code> や <code class="literal">ALTER TABLE</code> などの DDL ステートメントは、有効になっているロギング形式にかかわらず、常にステートメントとしてログが記録されるため、<code class="option">--binlog-ignore-db</code> の次のステートメントベースルールはステートメントのログが記録されるかどうかの判断に常に適用されます。 
          </p><p><b>ステートメントベースのロギング. </b>
              デフォルトデータベース (つまり、<code class="literal">USE</code> で選択されたもの) が <em class="replaceable"><code>db_name</code></em> であるステートメントのログを記録しないようにサーバーに指示します。
            </p><p>
            デフォルトのデータベースがない場合、<code class="option">--binlog-ignore-db</code> オプションは適用されず、このようなステートメントは常にログに記録されます。 (Bug #11829838、Bug #60188) 
          </p><p><b>行ベース形式. </b>
              データベース <em class="replaceable"><code>db_name</code></em> 内のテーブルへの更新のログを記録しないようにサーバーに指示します。 現在のデータベースは影響しません。 
            </p><p>
            ステートメントベースロギングを使用するとき、次の例は予期するとおりに機能しません。 サーバーが <code class="option">--binlog-ignore-db=sales</code> で起動され、次のステートメントを発行すると想定します。 
          </p><pre class="programlisting">USE prices;
UPDATE sales.january SET amount=amount+1000;
</pre><p>
            <code class="option">--binlog-ignore-db</code> がデフォルトデータベース (<code class="literal">USE</code> ステートメントで決定) にのみ適用されるため、このような場合は <code class="literal">UPDATE</code> ステートメントのログが記録され<span class="emphasis"><em>ます</em></span>。 <code class="literal">sales</code> データベースがステートメントで明示的に指定されたため、ステートメントはフィルタされませんでした。 ただし、行ベースのロギングを使用している場合、<code class="literal">UPDATE</code> ステートメントの効果はバイナリログに書き込まれません。つまり、<code class="literal">sales.january</code> テーブルへの変更は記録されません。この場合、<code class="option">--binlog-ignore-db=sales</code> は <code class="literal">sales</code> データベースのソースコピー内のテーブルに対して行われた <span class="emphasis"><em>all</em></span> の変更をバイナリロギングのために無視します。 
          </p><p>
            無視するデータベースを複数指定するには、このオプションを複数回 (データベースごとに 1 回) 使用します。 データベース名にはカンマを含めることができるため、カンマ区切りリストを指定すると、リストは単一のデータベースの名前として扱われます。 
          </p><p>
            クロスデータベース更新を使用していて、それらの更新ログを記録したくない場合は、このオプションを使用しないでください。
          </p></li></ul></div><p><a name="replication-optvars-binlog-checksums"></a><b>チェックサムオプション. </b>
          MySQL では、バイナリログチェックサムの読み取りと書き込みがサポートされています。 これらは、ここで示す 2 つのオプションを使用して有効化されます。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_binlog-checksum"></a>
            <code class="option">--binlog-checksum={NONE|CRC32}</code>
          </p><a class="indexterm" name="idm46723653858720"></a><a class="indexterm" name="idm46723653856512"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog-checksum"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-checksum=type</code></td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">CRC32</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">NONE</code></p><p class="valid-value"><code class="literal">CRC32</code></p></td>
</tr></tbody></table></div><p>
            このオプションを有効にすると、ソースはバイナリログに書き込まれたイベントのチェックサムを書き込みます。 <code class="literal">NONE</code> に設定して無効にするか、チェックサムの生成に使用するアルゴリズムの名前を指定します。現在、CRC32 チェックサムのみがサポートされており、CRC32 がデフォルトです。 トランザクション内のこのオプションの設定は変更できません。 
          </p></li></ul></div><p>
        レプリカによる (リレーログからの) チェックサムの読み取りを制御するには、<code class="option">--slave-sql-verify-checksum</code> オプションを使用します。
      </p><p><b>テストおよびデバッグのオプション. </b>
          次のバイナリログオプションは、レプリケーションテストおよびデバッグで使用されます。 これらは通常操作での使用を意図していません。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_max-binlog-dump-events"></a>
            <code class="option">--max-binlog-dump-events=<em class="replaceable"><code>N</code></em></code>
          </p><a class="indexterm" name="idm46723653832256"></a><a class="indexterm" name="idm46723653830032"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for max-binlog-dump-events"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--max-binlog-dump-events=#</code></td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr></tbody></table></div><p>
            このオプションは、レプリケーションのテストとデバッグのために、MySQL テストスイートで内部的に使用されます。
          </p></li><li class="listitem"><p><a name="option_mysqld_sporadic-binlog-dump-fail"></a>
            <code class="option">--sporadic-binlog-dump-fail</code>
          </p><a class="indexterm" name="idm46723653815328"></a><a class="indexterm" name="idm46723653813088"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for sporadic-binlog-dump-fail"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--sporadic-binlog-dump-fail[={OFF|ON}]</code></td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
            このオプションは、レプリケーションのテストとデバッグのために、MySQL テストスイートで内部的に使用されます。
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-sysvars-binlog"></a>バイナリロギングで使用されるシステム変数</h5></div></div></div><p>
        次の一覧で、バイナリロギングを制御するためのシステム変数について説明します。 これらはサーバー起動時に設定でき、それらの一部は <code class="literal">SET</code> を使用して実行時に変更できます。 バイナリロギングを制御するために使用されるサーバーオプションは、このセクションですでにリストされています。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="sysvar_binlog_cache_size"></a>
            <code class="literal">binlog_cache_size</code>
          </p><a class="indexterm" name="idm46723653793904"></a><a class="indexterm" name="idm46723653792352"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog_cache_size"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-cache-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_cache_size">binlog_cache_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">32768</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">4096</code></td>
</tr><tr><th>最大値 (64 ビットプラットフォーム)</th>
<td><code class="literal">18446744073709551615</code></td>
</tr><tr><th>最大値 (32 ビットプラットフォーム)</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
            トランザクション中にバイナリログに対する変更を保持するメモリーバッファーのサイズ。 (<code class="literal">log_bin</code> システム変数を ON に設定して) サーバーでバイナリロギングが有効になっている場合、サーバーがトランザクションストレージエンジンをサポートしていれば、クライアントごとにバイナリログキャッシュが割り当てられます。 トランザクションのデータがメモリーバッファ内の領域を超えた場合、余分なデータは一時ファイルに格納されます。 バイナリログの暗号化がサーバーでアクティブな場合、メモリーバッファは暗号化されませんが、バイナリログキャッシュの保持に使用される一時ファイルは (MySQL 8.0.17 から) 暗号化されます。 各トランザクションがコミットされると、メモリーバッファをクリアし、一時ファイル (使用されている場合) を切り捨てることで、バイナリログキャッシュがリセットされます。 
          </p><p>
            大規模なトランザクションを頻繁に使用する場合は、一時ファイルへの書込みを削減または排除することで、このキャッシュサイズを増やしてパフォーマンスを向上させることができます。 <code class="literal">Binlog_cache_use</code> および <code class="literal">Binlog_cache_disk_use</code> ステータス変数は、この変数のサイズを調整するために役立つことがあります。 <a class="xref" href="server-administration.html#binary-log" title="5.4.4 バイナリログ">セクション5.4.4「バイナリログ」</a>を参照してください。 
          </p><p>
            <code class="literal">binlog_cache_size</code> はトランザクションキャッシュのみのサイズを設定します。ステートメントキャッシュのサイズは <code class="literal">binlog_stmt_cache_size</code> システム変数によって管理されます。
          </p></li><li class="listitem"><p><a name="sysvar_binlog_checksum"></a>
            <code class="literal">binlog_checksum</code>
          </p><a class="indexterm" name="idm46723653751136"></a><a class="indexterm" name="idm46723653749600"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog_checksum"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-checksum=name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_checksum">binlog_checksum</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">CRC32</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">NONE</code></p><p class="valid-value"><code class="literal">CRC32</code></p></td>
</tr></tbody></table></div><p>
            この変数を有効にすると、ソースは各イベントのチェックサムをバイナリログに書き込みます。<code class="literal">binlog_checksum</code> は、<code class="literal">NONE</code> (チェックサムを無効にする) および <code class="literal">CRC32</code> の値をサポートしています。 デフォルトは <code class="literal">CRC32</code> です。 <code class="literal">binlog_checksum</code> が無効 (値 <code class="literal">NONE</code>) のときは、サーバーは各イベントのイベント長 （チェックサムではなく） を書き込んでチェックすることで、すべてそろったイベントのみをバイナリログに書き込んでいることを検証します。 
          </p><p>
            ソースでこの変数をレプリカで認識されない値に設定すると、レプリカは独自の <code class="literal">binlog_checksum</code> 値を <code class="literal">NONE</code> に設定し、エラーでレプリケーションを停止します。 古いレプリカとの下位互換性に問題がある場合は、値を明示的に <code class="literal">NONE</code> に設定できます。 
          </p><p>
            MySQL 8.0.20 まで、グループレプリケーションはチェックサムを使用できず、バイナリログでのチェックサムの存在をサポートしないため、サーバーインスタンスがグループメンバーになるように構成するときに <code class="literal">binlog_checksum=NONE</code> を設定する必要があります。 MySQL 8.0.21 からは、グループレプリケーションでチェックサムがサポートされるため、グループメンバーはデフォルト設定を使用できます。 
          </p><p>
            チェックサムはバイナリログファイル全体に対して書き込まれる必要があり、バイナリログの一部に対してのみ書き込まれないため、<code class="literal">binlog_checksum</code> の値を変更するとバイナリログがローテーションされます。 トランザクション内の <code class="literal">binlog_checksum</code> の値は変更できません。 
          </p><p>
            <code class="literal">binlog_transaction_compression</code> システム変数を使用してバイナリログのトランザクション圧縮が有効になっている場合、圧縮されたトランザクションペイロード内の個々のイベントのチェックサムは書き込まれません。 代わりに、GTID イベントに対してチェックサムが書き込まれ、圧縮された <code class="literal">Transaction_payload_event</code> に対してチェックサムが書き込まれます。 
          </p></li><li class="listitem"><p><a name="sysvar_binlog_direct_non_transactional_updates"></a>
            <code class="literal">binlog_direct_non_transactional_updates</code>
          </p><a class="indexterm" name="idm46723653704864"></a><a class="indexterm" name="idm46723653703264"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog_direct_non_transactional_updates"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-direct-non-transactional-updates[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_direct_non_transactional_updates">binlog_direct_non_transactional_updates</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル、セッション</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
            同時実行性の問題のため、トランザクションにトランザクションテーブルと非トランザクションテーブルの両方に対する更新が含まれる場合、レプリカに一貫性がなくなる可能性があります。 MySQL は、非トランザクションステートメントをトランザクションキャッシュに書き込むことで （コミット時にフラッシュされる）、これらのステートメント間の因果関係を維持しようとします。 ただし、トランザクションに代わって非トランザクションテーブルに行われた変更がほかの接続にただちに可視になるときに、問題が起こります (これらの変更がただちにバイナリログに書き込まれない場合があるため)。 
          </p><p>
            <code class="literal">binlog_direct_non_transactional_updates</code> 変数は、この問題に対する 1 つの可能な回避策を提供します。 デフォルトでは、この変数は無効です。 <code class="literal">binlog_direct_non_transactional_updates</code> を有効にすることで、非トランザクションテーブルへの更新が、トランザクションキャッシュではなく直接バイナリログに書き込まれます。 
          </p><p>
            MySQL 8.0.14 では、このシステム変数のセッション値の設定は制限された操作です。 セッションユーザーには、制限付きセッション変数を設定するのに十分な権限が必要です。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 
          </p><p>
            <span class="emphasis"><em><code class="literal">binlog_direct_non_transactional_updates</code> は、ステートメントベースバイナリロギング形式を使用して複製されるステートメントにのみ機能します。</em></span>つまり、<code class="literal">binlog_format</code> の値が <code class="literal">STATEMENT</code> のとき、または <code class="literal">binlog_format</code> が <code class="literal">MIXED</code> で、与えられたステートメントがステートメントベース形式を使用して複製されているときにのみ機能します。 バイナリログ形式が <code class="literal">ROW</code> のとき、または <code class="literal">binlog_format</code> が <code class="literal">MIXED</code> に設定され、与えられたステートメントが行ベース形式で複製されるときは、この変数は効果がありません。 
          </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
              この変数を有効にする前に、トランザクションおよび非トランザクションテーブルの間に依存関係がないことを確認する必要があります。このような依存関係の例は、ステートメント <code class="literal">INSERT INTO myisam_table SELECT * FROM innodb_table</code> です。 そうしないと、このようなステートメントによってレプリカがソースと相違する可能性があります。 
            </p></div><p>
            バイナリログ形式が <code class="literal">ROW</code> または <code class="literal">MIXED</code> の場合、この変数は無効です。
          </p></li><li class="listitem"><p><a name="sysvar_binlog_encryption"></a>
            <code class="literal">binlog_encryption</code>
          </p><a class="indexterm" name="idm46723653659392"></a><a class="indexterm" name="idm46723653657840"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog_encryption"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-encryption[={OFF|ON}]</code></td>
</tr><tr><th>導入</th>
<td>8.0.14</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_encryption">binlog_encryption</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
            このサーバー上のバイナリログファイルおよびリレーログファイルの暗号化を有効にします。 <code class="literal">OFF</code> がデフォルトです。 <code class="literal">ON</code> は、バイナリログファイルおよびリレーログファイルの暗号化をオンに設定します。 暗号化を有効にするためにバイナリロギングをサーバー上で有効にする必要はないため、バイナリログのないレプリカ上のリレーログファイルを暗号化できます。 暗号化を使用するには、MySQL Server 鍵リングサービスを提供するように鍵リングプラグインをインストールして構成する必要があります。 これを行う手順は、<a class="xref" href="security.html#keyring" title="6.4.4 MySQL キーリング">セクション6.4.4「MySQL キーリング」</a> を参照してください。 サポートされている任意のキーリングプラグインを使用して、バイナリログ暗号化鍵を格納できます。 
          </p><p>
            バイナリログ暗号化を有効にしてサーバーをはじめて起動すると、バイナリログとリレーログが初期化される前に新しいバイナリログ暗号化鍵が生成されます。 このキーは、各バイナリログファイル (サーバーでバイナリロギングが有効になっている場合) およびリレーログファイル (サーバーにレプリケーションチャネルがある場合) のファイルパスワードを暗号化するために使用され、ファイルパスワードから生成された以降の鍵を使用してファイル内のデータが暗号化されます。 リレーログファイルは、グループレプリケーションアプライヤチャネルや暗号化のアクティブ化後に作成される新しいチャネルなど、すべてのチャネルに対して暗号化されます。 バイナリログインデックスファイルとリレーログインデックスファイルは暗号化されません。 
          </p><p>
            サーバーの実行中に暗号化をアクティブ化すると、その時点で新しいバイナリログ暗号化鍵が生成されます。 例外は、以前にサーバー上で暗号化がアクティブであり、その後無効になっていた場合です。その場合、以前に使用されていたバイナリログ暗号化鍵が再度使用されます。 バイナリログファイルとリレーログファイルはただちにローテーションされ、新しいファイルとそれ以降のすべてのバイナリログファイルおよびリレーログファイルのファイルパスワードは、このバイナリログ暗号化鍵を使用して暗号化されます。 既存のバイナリログファイルとリレーログファイルがサーバー上にまだ存在する場合、それらは自動的に暗号化されませんが、不要になった場合はパージできます。 
          </p><p>
            <code class="literal">binlog_encryption</code> システム変数を <code class="literal">OFF</code> に変更して暗号化を非アクティブにすると、バイナリログファイルとリレーログファイルはただちにローテーションされ、それ以降のすべてのロギングは暗号化されません。 以前に暗号化されたファイルは自動的に復号化されませんが、サーバーはそれらを読み取ることができます。 サーバーの実行中に暗号化をアクティブ化または非アクティブ化するには、<code class="literal">BINLOG_ENCRYPTION_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。 グループレプリケーションアプライヤチャネルはリレーログローテーションリクエストに含まれないため、これらのチャネルの暗号化されていないロギングは、ログが通常の使用でローテーションされるまで開始されません。 
          </p><p>
            バイナリログファイルとリレーログファイルの暗号化の詳細は、<a class="xref" href="replication.html#replication-binlog-encryption" title="17.3.2 バイナリログファイルとリレーログファイルの暗号化">セクション17.3.2「バイナリログファイルとリレーログファイルの暗号化」</a> を参照してください。
          </p></li><li class="listitem"><p><a name="sysvar_binlog_error_action"></a>
            <code class="literal">binlog_error_action</code>
          </p><a class="indexterm" name="idm46723653617024"></a><a class="indexterm" name="idm46723653615472"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog_error_action"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-error-action[=value]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_error_action">binlog_error_action</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ABORT_SERVER</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">IGNORE_ERROR</code></p><p class="valid-value"><code class="literal">ABORT_SERVER</code></p></td>
</tr></tbody></table></div><p>
            バイナリログへの書き込み、フラッシュ、同期ができないなどのエラーがサーバーで発生した場合に何が起こるかを制御します。これにより、ソースバイナリログが矛盾し、レプリカが同期を失う可能性があります。
          </p><p>
            この変数のデフォルトは <code class="literal">ABORT_SERVER</code> で、バイナリログでこのようなエラーが発生するたびに、サーバーはロギングを停止してシャットダウンします。 再起動時に、予期しないサーバーが停止した場合と同様にリカバリが続行されます (<a class="xref" href="replication.html#replication-solutions-unexpected-replica-halt" title="17.4.2 レプリカの予期しない停止の処理">セクション17.4.2「レプリカの予期しない停止の処理」</a> を参照)。 
          </p><p>
            <code class="literal">binlog_error_action</code> が <code class="literal">IGNORE_ERROR</code> に設定されている場合、サーバーでこのようなエラーが発生すると、進行中のトランザクションが続行され、エラーがログに記録されてからロギングが停止され、更新の実行が続行されます。 バイナリロギングを再開するには、<code class="literal">log_bin</code> を再度有効にする必要があります。これにはサーバーの再起動が必要です。 この設定により、古いバージョンの MySQL との下位互換性が提供されます。 
          </p></li><li class="listitem"><p><a name="sysvar_binlog_expire_logs_seconds"></a>
            <code class="literal">binlog_expire_logs_seconds</code>
          </p><a class="indexterm" name="idm46723653580192"></a><a class="indexterm" name="idm46723653579072"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog_expire_logs_seconds"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-expire-logs-seconds=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_expire_logs_seconds">binlog_expire_logs_seconds</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">2592000</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
            バイナリログの有効期限を秒単位で設定します。 有効期限の終了後、バイナリログファイルを自動的に削除できます。 削除は起動時およびバイナリログがフラッシュされるときに発生する可能性があります。 ログのフラッシュは、<a class="xref" href="server-administration.html#server-logs" title="5.4 MySQL Server ログ">セクション5.4「MySQL Server ログ」</a>に記載されているように発生します。 
          </p><p>
            デフォルトのバイナリログ有効期限は 2592000 秒で、30 日 (30*24*60*60 秒) です。 デフォルトは、<code class="literal">binlog_expire_logs_seconds</code> と非推奨のシステム変数 <code class="literal">expire_logs_days</code> のどちらにも起動時に設定された値がない場合に適用されます。 <code class="literal">binlog_expire_logs_seconds</code> または <code class="literal">expire_logs_days</code> のいずれかの変数にゼロ以外の値が起動時に設定されている場合、この値はバイナリログの有効期限として使用されます。 これらの両方の変数にゼロ以外の値が起動時に設定されている場合、<code class="literal">binlog_expire_logs_seconds</code> の値がバイナリログの有効期限として使用され、<code class="literal">expire_logs_days</code> の値は警告メッセージとともに無視されます。 
          </p><p>
            バイナリログの自動パージを無効にするには、<code class="literal">binlog_expire_logs_seconds</code> に値 0 を明示的に指定し、<code class="literal">expire_logs_days</code> に値を指定しないでください。 以前のリリースとの互換性のために、<code class="literal">expire_logs_days</code> に値 0 を明示的に指定し、<code class="literal">binlog_expire_logs_seconds</code> に値を指定しないと、自動パージも無効になります。 その場合、<code class="literal">binlog_expire_logs_seconds</code> のデフォルトは適用されません。 
          </p><p>
            バイナリログファイルを手動で削除するには、<code class="literal">PURGE BINARY LOGS</code> ステートメントを使用します。 <a class="xref" href="sql-statements.html#purge-binary-logs" title="13.4.1.1 PURGE BINARY LOGS ステートメント">セクション13.4.1.1「PURGE BINARY LOGS ステートメント」</a>を参照してください。 
          </p></li><li class="listitem"><p><a name="sysvar_binlog_format"></a>
            <code class="literal">binlog_format</code>
          </p><a class="indexterm" name="idm46723653532064"></a><a class="indexterm" name="idm46723653530544"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog_format"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-format=format</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_format">binlog_format</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル、セッション</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ROW</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">ROW</code></p><p class="valid-value"><code class="literal">STATEMENT</code></p><p class="valid-value"><code class="literal">MIXED</code></p></td>
</tr></tbody></table></div><p>
            この変数はバイナリロギング形式を設定し、<code class="literal">STATEMENT</code>、<code class="literal">ROW</code>、<code class="literal">MIXED</code> のいずれかが可能です。 <a class="xref" href="replication.html#replication-formats" title="17.2.1 レプリケーション形式">セクション17.2.1「レプリケーション形式」</a>を参照してください。 
          </p><p>
            <code class="literal">binlog_format</code> は起動時または実行時に設定できますが、後で説明するように、一部の条件下ではこの変数を実行時に変更できないか、レプリケーションが失敗することを除きます。
          </p><p>
            デフォルトは <code class="literal">ROW</code> です。 <span class="emphasis"><em>例外</em></span>: NDB Cluster では、デフォルトは <code class="literal">MIXED</code> です。ステートメントベースのレプリケーションは NDB Cluster ではサポートされません。 
          </p><p>
            このシステム変数のセッション値の設定は制限された操作です。 セッションユーザーには、制限付きセッション変数を設定するのに十分な権限が必要です。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 
          </p><p>
            この変数への変更がいつ有効になり、影響はどのくらい長く続くかを管理するルールは、ほかの MySQL サーバーシステム変数の場合と同じです。 詳細は、<a class="xref" href="sql-statements.html#set-variable" title="13.7.6.1 変数代入の SET 構文">セクション13.7.6.1「変数代入の SET 構文」</a>を参照してください。 
          </p><p>
            <code class="literal">MIXED</code> が指定されている場合、行ベースレプリケーションだけが適切な結果になることが保証されている場合を除き、ステートメントベースレプリケーションが使用されます。 たとえば、これはユーザー定義関数 (UDF) または <code class="literal">UUID()</code> 関数がステートメントに含まれているときに発生します。 
          </p><p>
            各バイナリロギング形式が設定されている場合のストアドプログラム (ストアドプロシージャーとストアドファンクション、トリガー、およびイベント) の処理方法の詳細は、<a class="xref" href="stored-objects.html#stored-programs-logging" title="25.7 ストアドプログラムバイナリロギング">セクション25.7「ストアドプログラムバイナリロギング」</a> を参照してください。
          </p><p>
            レプリケーション形式を実行時に切り替えることができない例外もあります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                レプリケーション形式は、ストアドファンクションまたはトリガー内から変更できません。
              </p></li><li class="listitem"><p>
                セッションにオープン一時テーブルがある場合、セッション (<code class="literal">SET @@SESSION.binlog_format</code>) のレプリケーション形式は変更できません。
              </p></li><li class="listitem"><p>
                いずれかのレプリケーションチャネルにオープン一時テーブルがある場合、レプリケーション形式はグローバルに変更できません (<code class="literal">SET @@GLOBAL.binlog_format</code> または <code class="literal">SET @@PERSIST.binlog_format</code>)。
              </p></li><li class="listitem"><p>
                レプリケーションチャネルアプライヤスレッドが現在実行されている場合、レプリケーション形式はグローバルに変更できません (<code class="literal">SET @@GLOBAL.binlog_format</code> または <code class="literal">SET @@PERSIST.binlog_format</code>)。
              </p></li></ul></div><p>
            これらのいずれかの場合 (または現在のレプリケーション形式を設定しようとする場合) にレプリケーション形式を切り替えようとすると、エラーになります。 ただし、<code class="literal">PERSIST_ONLY</code> (<code class="literal">SET @@PERSIST_ONLY.binlog_format</code>) を使用してレプリケーション形式をいつでも変更できます。これは、このアクションによってランタイムグローバルシステム変数の値が変更されず、サーバーの再起動後にのみ有効になるためです。 
          </p><p>
            一時テーブルが存在する場合、実行時にレプリケーション形式を切り替えることはお勧めしません。一時テーブルはステートメントベースレプリケーションの使用時にのみログに記録されますが、行ベースレプリケーションと混在レプリケーションではログに記録されないためです。
          </p><p>
            レプリケーションソースサーバーでロギング形式を変更しても、レプリカのロギング形式は一致するように変更されません。 レプリケーションの進行中にレプリケーション形式を切り替えると、レプリカでバイナリロギングが有効になっている場合に問題が発生し、ソースが <code class="literal">ROW</code> または <code class="literal">MIXED</code> 形式のロギングを使用している間に、変更によってレプリカで <code class="literal">STATEMENT</code> 形式のロギングが使用されることがあります。 レプリカは、<code class="literal">ROW</code> ロギング形式で受信したバイナリログエントリを独自のバイナリログで使用するために <code class="literal">STATEMENT</code> 形式に変換できないため、レプリケーションが失敗する可能性があります。 詳細は、<a class="xref" href="server-administration.html#binary-log-setting" title="5.4.4.2 バイナリログ形式の設定">セクション5.4.4.2「バイナリログ形式の設定」</a>を参照してください。 
          </p><p>
            バイナリログ形式は次のサーバーオプションの動作に影響を与えます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="option">--replicate-do-db</code>
              </p></li><li class="listitem"><p>
                <code class="option">--replicate-ignore-db</code>
              </p></li><li class="listitem"><p>
                <code class="option">--binlog-do-db</code>
              </p></li><li class="listitem"><p>
                <code class="option">--binlog-ignore-db</code>
              </p></li></ul></div><p>
            これらの影響の詳細は、個々のオプションの説明に記載されています。
          </p></li><li class="listitem"><p><a name="sysvar_binlog_group_commit_sync_delay"></a>
            <code class="literal">binlog_group_commit_sync_delay</code>
          </p><a class="indexterm" name="idm46723653459424"></a><a class="indexterm" name="idm46723653458304"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog_group_commit_sync_delay"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-group-commit-sync-delay=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_group_commit_sync_delay">binlog_group_commit_sync_delay</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">1000000</code></td>
</tr></tbody></table></div><p>
            バイナリログファイルをディスクに同期する前にバイナリログのコミットが待機するマイクロ秒数を制御します。 デフォルトでは、<code class="literal">binlog_group_commit_sync_delay</code> は 0 に設定されており、これは遅延がないことを意味します。 <code class="literal">binlog_group_commit_sync_delay</code> をマイクロ秒遅延に設定すると、必要なグループがグループごとの時間単位が少なくなるため、一度により多くのトランザクションをディスクに同期でき、トランザクションのグループをコミットするための全体的な時間が短縮されます。 
          </p><p>
            <code class="literal">sync_binlog=0</code> または <code class="literal">sync_binlog=1</code> が設定されている場合、<code class="literal">binlog_group_commit_sync_delay</code> によって指定された遅延は、同期の前 (または <code class="literal">sync_binlog=0</code> の場合は先に進む前) にすべてのバイナリログコミットグループに適用されます。 <code class="literal">sync_binlog</code> が 1 より大きい値 <span class="emphasis"><em>n</em></span> に設定されている場合、遅延はすべての <span class="emphasis"><em>n</em></span> バイナリログコミットグループのあとに適用されます。 
          </p><p>
            <code class="literal">binlog_group_commit_sync_delay</code> を設定すると、レプリカを持つ (またはフェイルオーバー後に存在する可能性のある) サーバー上のパラレルコミットトランザクションの数を増やすことができるため、レプリカに対するパラレル実行を増やすことができます。 この効果を活用するには、レプリカサーバーに <code class="literal">slave_parallel_type=LOGICAL_CLOCK</code> が設定されている必要があります。また、<code class="literal">binlog_transaction_dependency_tracking=COMMIT_ORDER</code> も設定されている場合は、この効果が重要になります。 <code class="literal">binlog_group_commit_sync_delay</code> の設定をチューニングする場合は、ソースのスループットとレプリカのスループットの両方を考慮することが重要です。 
          </p><p>
            <code class="literal">binlog_group_commit_sync_delay</code> を設定すると、バイナリログを持つサーバー (ソースまたはレプリカ) 上のバイナリログへの <code class="literal">fsync()</code> 呼び出しの数を減らすこともできます。
          </p><p>
            <code class="literal">binlog_group_commit_sync_delay</code> を設定すると、サーバー上のトランザクションの待機時間が長くなり、クライアントアプリケーションに影響する可能性があることに注意してください。 また、同時実行性の高いワークロードでは、遅延によって競合が増加し、スループットが低下する可能性があります。 通常、遅延を設定する利点は欠点を上回っていますが、最適な設定を決定するには、チューニングを常に実行する必要があります。 
          </p></li><li class="listitem"><p><a name="sysvar_binlog_group_commit_sync_no_delay_count"></a>
            <code class="literal">binlog_group_commit_sync_no_delay_count</code>
          </p><a class="indexterm" name="idm46723653408592"></a><a class="indexterm" name="idm46723653407472"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog_group_commit_sync_no_delay_count"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-group-commit-sync-no-delay-count=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_group_commit_sync_no_delay_count">binlog_group_commit_sync_no_delay_count</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">1000000</code></td>
</tr></tbody></table></div><p>
            <code class="literal">binlog_group_commit_sync_delay</code> で指定された現在の遅延を中断する前に待機するトランザクションの最大数。 <code class="literal">binlog_group_commit_sync_delay</code> が 0 に設定されている場合、このオプションは無効です。 
          </p></li><li class="listitem"><p><a name="sysvar_binlog_max_flush_queue_time"></a>
            <code class="literal">binlog_max_flush_queue_time</code>
          </p><a class="indexterm" name="idm46723653375568"></a><a class="indexterm" name="idm46723653374000"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog_max_flush_queue_time"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-max-flush-queue-time=#</code></td>
</tr><tr><th>非推奨</th>
<td>はい</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_max_flush_queue_time">binlog_max_flush_queue_time</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">100000</code></td>
</tr></tbody></table></div><p>
            <code class="literal">binlog_max_flush_queue_time</code> は非推奨であり、将来の MySQL リリースでは最終的に削除対象としてマークされます。 以前は、このシステム変数は、グループコミットを続行する前にフラッシュキューからトランザクションの読取りを続行する時間をマイクロ秒単位で制御していました。 効果はなくなりました。 
          </p></li><li class="listitem"><p><a name="sysvar_binlog_order_commits"></a>
            <code class="literal">binlog_order_commits</code>
          </p><a class="indexterm" name="idm46723653341152"></a><a class="indexterm" name="idm46723653339600"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog_order_commits"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-order-commits[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_order_commits">binlog_order_commits</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
            この変数がレプリケーションソースサーバー (デフォルト) で有効になっている場合、ストレージエンジンに発行されるトランザクションコミット命令はシングルスレッド上で直列化されるため、トランザクションは常にバイナリログに書き込まれるのと同じ順序でコミットされます。 この変数を無効にすると、複数のスレッドを使用してトランザクションコミット命令を発行できます。 バイナリロググループのコミットと組み合わせて使用すると、単一のトランザクションのコミット率がスループットのボトルネックになるのを防ぐため、パフォーマンスが向上する可能性があります。 
          </p><p>
            トランザクションは、関連するすべてのストレージエンジンがトランザクションのコミット準備を完了したことを確認した時点で、バイナリログに書き込まれます。 その後、バイナリロググループのコミットロジックは、バイナリログの書き込みが行われたあとにトランザクションのグループをコミットします。 <code class="literal">binlog_order_commits</code> が無効になっている場合、このプロセスに複数のスレッドが使用されているため、コミットグループ内のトランザクションはバイナリログ内の順序とは異なる順序でコミットされる可能性があります。 (単一のクライアントからのトランザクションは常に時系列順にコミットされます。) 多くの場合、これは問題ではありません。個別のトランザクションで実行される操作は一貫した結果を生成する必要があり、そうでない場合は、かわりに単一のトランザクションを使用する必要があります。 
          </p><p>
            ソースとマルチスレッドのレプリカのトランザクション履歴が同一であることを確認する場合は、レプリカに <code class="literal">slave_preserve_commit_order=1</code> を設定します。
          </p></li><li class="listitem"><p><a name="sysvar_binlog_rotate_encryption_master_key_at_startup"></a>
            <code class="literal">binlog_rotate_encryption_master_key_at_startup</code>
          </p><a class="indexterm" name="idm46723653308272"></a><a class="indexterm" name="idm46723653306656"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog_rotate_encryption_master_key_at_startup"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-rotate-encryption-master-key-at-startup[={OFF|ON}]</code></td>
</tr><tr><th>導入</th>
<td>8.0.14</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_rotate_encryption_master_key_at_startup">binlog_rotate_encryption_master_key_at_startup</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
            サーバーの起動時にバイナリログマスターキーをローテーションするかどうかを指定します。 バイナリログマスターキーは、バイナリログファイルおよびサーバー上のリレーログファイルのファイルパスワードを暗号化するために使用されるバイナリログ暗号化鍵です。 バイナリログ暗号化 (<code class="literal">binlog_encryption=ON</code>) を有効にしてサーバーをはじめて起動すると、新しいバイナリログ暗号化鍵が生成され、バイナリログマスターキーとして使用されます。 <code class="literal">binlog_rotate_encryption_master_key_at_startup</code> システム変数も <code class="literal">ON</code> に設定されている場合、サーバーが再起動されるたびにバイナリログ暗号化鍵が生成され、後続のすべてのバイナリログファイルおよびリレーログファイルのバイナリログマスターキーとして使用されます。 <code class="literal">binlog_rotate_encryption_master_key_at_startup</code> システム変数が <code class="literal">OFF</code>(デフォルト) に設定されている場合、サーバーの再起動後に既存のバイナリログマスターキーが再度使用されます。 バイナリログ暗号化鍵とバイナリログマスターキーの詳細は、<a class="xref" href="replication.html#replication-binlog-encryption" title="17.3.2 バイナリログファイルとリレーログファイルの暗号化">セクション17.3.2「バイナリログファイルとリレーログファイルの暗号化」</a> を参照してください。 
          </p></li><li class="listitem"><p><a name="sysvar_binlog_row_event_max_size"></a>
            <code class="literal">binlog_row_event_max_size</code>
          </p><a class="indexterm" name="idm46723653272640"></a><a class="indexterm" name="idm46723653271072"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog-row-event-max-size"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-row-event-max-size=#</code></td>
</tr><tr><th>システム変数 (≥ 8.0.14)</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_row_event_max_size">binlog_row_event_max_size</a></code></td>
</tr><tr><th>スコープ (≥ 8.0.14)</th>
<td>グローバル</td>
</tr><tr><th>動的 (≥ 8.0.14)</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用 (≥ 8.0.14)</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">8192</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">256</code></td>
</tr><tr><th>最大値 (64 ビットプラットフォーム)</th>
<td><code class="literal">18446744073709551615</code></td>
</tr><tr><th>最大値 (32 ビットプラットフォーム)</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
            行ベースのバイナリロギングを使用する場合、この設定は、行ベースのバイナリログイベントの最大サイズに対する弱い制限 (バイト単位) です。 可能であれば、バイナリログに格納されている行は、この設定の値を超えないサイズのイベントにグループ化されます。 イベントを分割できない場合は、最大サイズを超えることができます。 値は 256 の倍数である必要があります (そうでない場合は切り捨てられます)。 デフォルトは 8192 バイトです。 
          </p><p>
            このグローバルシステム変数は読取り専用で、サーバーの起動時にのみ設定できます。 したがって、その値を変更するには、<code class="literal">SET</code> ステートメントで <code class="literal">PERSIST_ONLY</code> キーワードまたは<code class="literal">@@persist_only</code> 修飾子を使用する必要があります。 
          </p></li><li class="listitem"><p><a name="sysvar_binlog_row_image"></a>
            <code class="literal">binlog_row_image</code>
          </p><a class="indexterm" name="idm46723653235088"></a><a class="indexterm" name="idm46723653233552"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog_row_image"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-row-image=image_type</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_row_image">binlog_row_image</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル、セッション</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">full</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">full</code> (すべてのカラムをログに記録)</p><p class="valid-value"><code class="literal">minimal</code> (変更されたカラムおよび、行を特定するために必要とされたカラムのみをログに記録)</p><p class="valid-value"><code class="literal">noblob</code> (不要な BLOB カラムおよび TEXT カラム以外のすべてのカラムをログに記録)</p></td>
</tr></tbody></table></div><p>
            MySQL 行ベースレプリケーションの場合、この変数は行イメージをバイナリログに書き込む方法を決定します。
          </p><p>
            このシステム変数のセッション値の設定は制限された操作です。 セッションユーザーには、制限付きセッション変数を設定するのに十分な権限が必要です。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 
          </p><p>
            MySQL 行ベースレプリケーションでは、各行変更イベントに 2 つのイメージ、つまり<span class="quote">「<span class="quote">前</span>」</span>イメージ (更新される行を検索するときにこれらのカラムが照合される) と<span class="quote">「<span class="quote">後</span>」</span>イメージ (変更を含む) が含まれます。 通常、MySQL は前イメージと後イメージの両方のためにすべての行 （つまり、すべてのカラム） のログを記録します。 ただし、両方のイメージにすべてのカラムが厳密に含まれている必要はなく、多くの場合、実際に必要なカラムのログのみを記録することでディスク、メモリー、およびネットワーク使用量を節約できます。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              行を削除するときは、削除後に伝達する変更後の値がないため、前イメージのみのログが記録されます。 行を挿入するときは、照合される既存の行がないため、後イメージのみのログが記録されます。 行を更新するときのみ、前イメージと後イメージの両方が必要で、両方がバイナリログに書き込まれます。 
            </p></div><p>
            前イメージについては、行を一意に識別するために必要な最小カラムセットのログが記録されることのみが必要です。 行を含むテーブルに主キーがある場合、主キーカラムだけがバイナリログに書き込まれます。 そうではなく、テーブルに一意キーがあり、そのカラムのすべてが <code class="literal">NOT NULL</code> の場合は、一意キー内のカラムのログのみを記録する必要があります。 (テーブルに <code class="literal">NULL</code> カラムなしの主キーまたは一意キーがない場合、すべてのカラムが前イメージで使用され、それらのログが記録される必要があります。) 後イメージでは、実際に変更されたカラムのログのみを記録する必要があります。 
          </p><p>
            <code class="literal">binlog_row_image</code> システム変数を使用して、サーバーに完全な行または最小限の行を記録させることができます。 この変数は実際には、次のリストで示す 3 つの可能な値の 1 つを取ることができます。 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">full</code>: 前イメージと後イメージの両方にすべてのカラムのログを記録します。
              </p></li><li class="listitem"><p>
                <code class="literal">minimal</code>: 変更する行を識別するために必要なビフォアイメージのカラムのみをログに記録します。SQL ステートメントで値が指定されたか、自動増分によって生成されたアフターイメージのカラムのみをログに記録します。
              </p></li><li class="listitem"><p>
                <code class="literal">noblob</code>: すべてのカラム (<code class="literal">full</code> と同じ) のログを記録しますが、行の識別に必要がない、または変更されなかった <code class="literal">BLOB</code> および <code class="literal">TEXT</code> カラムは除きます。
              </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              この変数は NDB Cluster ではサポートされていません。設定しても <code class="literal">NDB</code> テーブルのロギングには影響しません。
            </p></div><p>
            デフォルト値は <code class="literal">full</code> です。
          </p><p>
            <code class="literal">minimal</code> または <code class="literal">noblob</code> を使用するときは、ソーステーブルと宛先テーブルの両方について次の条件が true の場合にのみ、所定のテーブルに対して削除と更新が正しく機能することが保証されます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                すべてのカラムが同じ順番で存在する必要があります。それぞれのカラムがもう一方のテーブル内の対応するものと同じデータ型を使用する必要があります。
              </p></li><li class="listitem"><p>
                これらのテーブルの主キー定義が同じである必要があります。
              </p></li></ul></div><p>
            (つまり、これらのテーブルは同じである必要がありますが、テーブルの主キーの一部でないインデックスがある場合にはそれらは除きます。)
          </p><p>
            これらの条件が満たされない場合は、宛先テーブル内の主キーカラム値が、削除または更新のための一意一致を提供するために不十分であることが判明する場合があります。 この場合、警告やエラーは発行されず、ソースとレプリカは暗黙的に相違するため、一貫性が損なわれます。 
          </p><p>
            バイナリロギング形式が <code class="literal">STATEMENT</code> のときは、この変数を設定しても効果はありません。 <code class="literal">binlog_format</code> が <code class="literal">MIXED</code> の場合、<code class="literal">binlog_row_image</code> の設定は行ベースの形式を使用して記録された変更に適用されますが、この設定はステートメントとして記録された変更には影響しません。 
          </p><p>
            グローバルまたはセッションレベルのいずれかで <code class="literal">binlog_row_image</code> を設定しても、暗黙的にコミットされません。これは、トランザクションの進行中にトランザクションに影響を与えずにこの変数を変更できることを意味します。
          </p></li><li class="listitem"><p><a name="sysvar_binlog_row_metadata"></a>
            <code class="literal">binlog_row_metadata</code>
          </p><a class="indexterm" name="idm46723653167744"></a><a class="indexterm" name="idm46723653166192"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog_row_metadata"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-row-metadata=metadata_type</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_row_metadata">binlog_row_metadata</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">MINIMAL</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">FULL</code> (すべてのメタデータが含まれます)</p><p class="valid-value"><code class="literal">MINIMAL</code> (含まれるメタデータの制限)</p></td>
</tr></tbody></table></div><p>
            行ベースロギングの使用時にバイナリログに追加されるテーブルメタデータの量を構成します。 <code class="literal">MINIMAL</code>(デフォルト) に設定すると、<code class="literal">SIGNED</code> フラグ、カラム文字セットおよびジオメトリタイプに関連するメタデータのみがログに記録されます。 <code class="literal">FULL</code> に設定すると、カラム名、<code class="literal">ENUM</code> または <code class="literal">SET</code> 文字列値、<code class="literal">PRIMARY KEY</code> 情報など、テーブルの完全なメタデータがログに記録されます。 
          </p><p>
            拡張メタデータは、次の目的で使用されます:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                レプリカは、テーブル構造がソースと異なる場合、メタデータを使用してデータを転送します。
              </p></li><li class="listitem"><p>
                外部ソフトウェアでは、メタデータを使用して行イベントをデコードし、データウェアハウスなどの外部データベースにデータを格納できます。
              </p></li></ul></div></li><li class="listitem"><p><a name="sysvar_binlog_row_value_options"></a>
            <code class="literal">binlog_row_value_options</code>
          </p><a class="indexterm" name="idm46723653128656"></a><a class="indexterm" name="idm46723653127104"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog_row_value_options"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-row-value-options=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_row_value_options">binlog_row_value_options</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル、セッション</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Set</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">''</code></td>
</tr><tr><th>有効な値</th>
<td><code class="literal">PARTIAL_JSON</code></td>
</tr></tbody></table></div><p>
            <code class="literal">PARTIAL_JSON</code> に設定すると、JSON ドキュメントの小さい部分のみを変更する更新に領域効率のよいバイナリログ形式を使用できるようになります。これにより、行ベースのレプリケーションでは、JSON ドキュメントの変更された部分のみがバイナリログ内の更新のアフターイメージに書き込まれます (完全なドキュメントは書き込まれません)。 これは、<code class="literal">JSON_SET()</code>、<code class="literal">JSON_REPLACE()</code> および <code class="literal">JSON_REMOVE()</code> の任意の順序を使用して JSON カラムを変更する <code class="literal">UPDATE</code> ステートメントに対して機能します。 変更にドキュメント全体よりも多くの領域が必要な場合、またはサーバーが部分更新を生成できない場合は、かわりにドキュメント全体が使用されます。 
          </p><p>
            このシステム変数のセッション値の設定は制限された操作です。 セッションユーザーには、制限付きセッション変数を設定するのに十分な権限が必要です。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 
          </p><p>
            サポートされている値は <code class="literal">PARTIAL_JSON</code> のみです。<code class="literal">binlog_row_value_options</code> の設定を解除するには、その値を空の文字列に設定します。
          </p><p>
            <code class="literal">binlog_row_value_options=PARTIAL_JSON</code> は、バイナリロギングが有効で、<code class="literal">binlog_format</code> が <code class="literal">ROW</code> または <code class="literal">MIXED</code> に設定されている場合にのみ有効になります。 ステートメントベースレプリケーション <span class="emphasis"><em>always</em></span> は、<code class="literal">binlog_row_value_options</code> に設定された値に関係なく、JSON ドキュメントの変更された部分のみを記録します。 節約される領域の量を最大化するには、このオプションとともに <code class="literal">binlog_row_image=NOBLOB</code> または <code class="literal">binlog_row_image=MINIMAL</code> を使用します。完全な JSON ドキュメントはビフォアイメージに格納され、部分更新はアフターイメージにのみ格納されるため、<code class="literal">binlog_row_image=FULL</code> はこれらのいずれかよりも少ない領域を節約します。 
          </p><p>
            <span class="command"><strong>mysqlbinlog</strong></span> 出力には、<code class="literal">BINLOG</code> ステートメントを使用して base-64 文字列としてエンコードされたイベントの形式で部分的な JSON 更新が含まれます。 <code class="option">--verbose</code> オプションが指定されている場合、<span class="command"><strong>mysqlbinlog</strong></span> は擬似 SQL ステートメントを使用して部分的な JSON 更新を読取り可能な JSON として表示します。 
          </p><p>
            レプリカ上の JSON ドキュメントに変更を適用できない場合、MySQL レプリケーションはエラーを生成します。 これには、パスの検索の失敗も含まれます。 この安全性チェックおよびその他の安全性チェックでも、レプリカ上の JSON ドキュメントがソース上の JSON ドキュメントと相違しており、部分更新が適用されても、理論的にはレプリカ上に有効だが予期しない JSON ドキュメントを生成できることに注意してください。 
          </p></li><li class="listitem"><p><a name="sysvar_binlog_rows_query_log_events"></a>
            <code class="literal">binlog_rows_query_log_events</code>
          </p><a class="indexterm" name="idm46723653076432"></a><a class="indexterm" name="idm46723653074864"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog_rows_query_log_events"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-rows-query-log-events[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_rows_query_log_events">binlog_rows_query_log_events</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル、セッション</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
            このシステム変数は、行ベースのロギングにのみ影響します。 有効にすると、サーバーは行クエリーログイベントなどの情報ログイベントをバイナリログに書き込みます。 この情報は、行の更新から再構築できない場合にソースに対して発行された元のクエリーを取得するなど、デバッグおよび関連する目的で使用できます。 
          </p><p>
            このシステム変数のセッション値の設定は制限された操作です。 セッションユーザーには、制限付きセッション変数を設定するのに十分な権限が必要です。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 
          </p><p>
            これらの情報イベントは通常、バイナリログを読み取る MySQL プログラムによって無視されるため、バックアップからレプリケートまたは復元するときに問題は発生しません。 これらを表示するには、mysqlbinlog <code class="option">--verbose</code> オプションを <code class="option">-vv</code> または <code class="option">--verbose --verbose</code> として 2 回使用して、冗長性レベルを上げます。 
          </p></li><li class="listitem"><p><a name="sysvar_binlog_stmt_cache_size"></a>
            <code class="literal">binlog_stmt_cache_size</code>
          </p><a class="indexterm" name="idm46723653045248"></a><a class="indexterm" name="idm46723653043696"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog_stmt_cache_size"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-stmt-cache-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_stmt_cache_size">binlog_stmt_cache_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">32768</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">4096</code></td>
</tr><tr><th>最大値 (64 ビットプラットフォーム)</th>
<td><code class="literal">18446744073709551615</code></td>
</tr><tr><th>最大値 (32 ビットプラットフォーム)</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
            トランザクション中に発行された非トランザクションステートメントを保持するバイナリログのメモリーバッファーのサイズ。 (<code class="literal">log_bin</code> システム変数を ON に設定して) サーバーでバイナリロギングが有効になっている場合、サーバーがトランザクションストレージエンジンをサポートしていれば、クライアントごとに個別のバイナリログトランザクションとステートメントキャッシュが割り当てられます。 トランザクションで使用される非トランザクションステートメントのデータがメモリーバッファ内の領域を超えると、余分なデータが一時ファイルに格納されます。 バイナリログの暗号化がサーバーでアクティブな場合、メモリーバッファは暗号化されませんが、バイナリログキャッシュの保持に使用される一時ファイルは (MySQL 8.0.17 から) 暗号化されます。 各トランザクションがコミットされたあと、バイナリログステートメントキャッシュはメモリーバッファーをクリアし、一時ファイルが使用されている場合は切り捨ててリセットされます。 
          </p><p>
            トランザクション中に大規模な非トランザクションステートメントを頻繁に使用する場合は、一時ファイルへの書込みを削減または排除することで、このキャッシュサイズを増やしてパフォーマンスを向上させることができます。 <code class="literal">Binlog_stmt_cache_use</code> および <code class="literal">Binlog_stmt_cache_disk_use</code> ステータス変数は、この変数のサイズを調整する場合に役立つ場合があります。 <a class="xref" href="server-administration.html#binary-log" title="5.4.4 バイナリログ">セクション5.4.4「バイナリログ」</a>を参照してください。 
          </p><p>
            <code class="literal">binlog_cache_size</code> システム変数はトランザクションキャッシュのサイズを設定します。
          </p></li><li class="listitem"><p><a name="sysvar_binlog_transaction_compression"></a>
            <code class="literal">binlog_transaction_compression</code>
          </p><a class="indexterm" name="idm46723653003120"></a><a class="indexterm" name="idm46723653001552"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog_transaction_compression"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-transaction-compression[={OFF|ON}]</code></td>
</tr><tr><th>導入</th>
<td>8.0.20</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_transaction_compression">binlog_transaction_compression</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
            このサーバー上のバイナリログファイルに書き込まれるトランザクションの圧縮を有効にします。 <code class="literal">OFF</code> がデフォルトです。 <code class="literal">binlog_transaction_compression_level_zstd</code> システム変数を使用して、圧縮に使用される zstd アルゴリズムのレベルを設定します。 
          </p><p>
            バイナリログのトランザクション圧縮が有効になっている場合、トランザクションペイロードは圧縮され、単一のイベント (<code class="literal">Transaction_payload_event</code>) としてバイナリログファイルに書き込まれます。 圧縮されたトランザクションペイロードは、レプリケーションストリームでレプリカ、他のグループレプリケーショングループメンバー、または <span class="command"><strong>mysqlbinlog</strong></span> などのクライアントに送信されている間、圧縮状態のままであり、圧縮状態のままリレーログに書き込まれます。 したがって、バイナリログトランザクション圧縮では、トランザクションの作成者と受信者 (およびそのバックアップ) の両方に記憶領域が節約され、トランザクションがサーバーインスタンス間で送信されるときにネットワーク帯域幅が節約されます。 
          </p><p>
            <code class="literal">binlog_transaction_compression=ON</code> を直接有効にするには、サーバーでバイナリロギングを有効にする必要があります。 MySQL サーバーインスタンスにバイナリログがない場合、MySQL 8.0.20 からのリリースであれば、<code class="literal">binlog_transaction_compression</code> の値に関係なく、圧縮されたトランザクションペイロードを受信、処理および表示できます。 このようなサーバーインスタンスによって受信された圧縮トランザクションペイロードは、圧縮された状態でリレーログに書き込まれるため、レプリケーショントポロジ内の他のサーバーによって実行される圧縮から間接的にメリットが得られます。 
          </p><p>
            このシステム変数は、トランザクションのコンテキスト内では変更できません。 このシステム変数のセッション値の設定は制限された操作です。 セッションユーザーには、制限付きセッション変数を設定するのに十分な権限が必要です。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 
          </p><p>
            バイナリログのトランザクション圧縮の詳細 (圧縮されているイベントと圧縮されていないイベントの詳細、トランザクション圧縮が使用されている場合の動作の変更など) は、<a class="xref" href="server-administration.html#binary-log-transaction-compression" title="5.4.4.5 バイナリログトランザクション圧縮">セクション5.4.4.5「バイナリログトランザクション圧縮」</a> を参照してください。
          </p></li><li class="listitem"><p><a name="sysvar_binlog_transaction_compression_level_zstd"></a>
            <code class="literal">binlog_transaction_compression_level_zstd</code>
          </p><a class="indexterm" name="idm46723652962576"></a><a class="indexterm" name="idm46723652960960"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog_transaction_compression_level_zstd"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-transaction-compression-level-zstd=#</code></td>
</tr><tr><th>導入</th>
<td>8.0.20</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_transaction_compression_level_zstd">binlog_transaction_compression_level_zstd</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">3</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">22</code></td>
</tr></tbody></table></div><p>
            <code class="literal">binlog_transaction_compression</code> システム変数によって有効になる、このサーバー上のバイナリログトランザクション圧縮の圧縮レベルを設定します。 この値は、圧縮作業を決定する整数で、1 (最小作業量) から 22 (最大作業量) までです。 このシステム変数を指定しない場合、圧縮レベルは 3 に設定されます。 
          </p><p>
            圧縮レベルが高くなると、データ圧縮率が高くなり、トランザクションペイロードに必要なストレージ領域およびネットワーク帯域幅が削減されます。 ただし、データ圧縮に必要な労力も増加し、元のサーバーでは時間と CPU およびメモリーリソースがかかります。 圧縮作業の増加には、データ圧縮率の増加と線形関係はありません。 
          </p><p>
            このシステム変数は、トランザクションのコンテキスト内では変更できません。 このシステム変数のセッション値の設定は制限された操作です。 セッションユーザーには、制限付きセッション変数を設定するのに十分な権限が必要です。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 
          </p></li><li class="listitem"><p><a name="sysvar_binlog_transaction_dependency_tracking"></a>
            <code class="literal">binlog_transaction_dependency_tracking</code>
          </p><a class="indexterm" name="idm46723652924960"></a><a class="indexterm" name="idm46723652923360"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog_transaction_dependency_tracking"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-transaction-dependency-tracking=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_transaction_dependency_tracking">binlog_transaction_dependency_tracking</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">COMMIT_ORDER</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">COMMIT_ORDER</code></p><p class="valid-value"><code class="literal">WRITESET</code></p><p class="valid-value"><code class="literal">WRITESET_SESSION</code></p></td>
</tr></tbody></table></div><p>
            マルチスレッドレプリカ (<code class="literal">slave_parallel_workers</code> が 0 より大きい値に設定されているレプリカ) を持つレプリケーションソースサーバーの場合、<code class="literal">binlog_transaction_dependency_tracking</code> は、レプリカが並列で実行できるトランザクションを判断するのに役立つように、バイナリログにソースが記録する依存性情報のソースを指定します。 指定可能な値は次のとおりです。 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">COMMIT_ORDER</code> : 依存性情報は、ソースコミットタイムスタンプから生成されます。 これはデフォルトです。 
              </p></li><li class="listitem"><p>
                <code class="literal">WRITESET</code> : 依存性情報はソース書込みセットから生成され、異なるタプルを書き込むトランザクションはパラレル化できます。
              </p></li><li class="listitem"><p>
                <code class="literal">WRITESET_SESSION</code> : 依存性情報はソース書込みセットから生成され、異なるタプルを書き込むトランザクションはパラレル化できますが、同じセッションからの 2 つの更新を並べ替えることはできません。
              </p></li></ul></div><p>
            <code class="literal">WRITESET</code> および <code class="literal">WRITESET_SESSION</code> モードでは、<code class="literal">COMMIT_ORDER</code> モードで返されるものよりも最適化されていないトランザクション依存性は提供されません。 <code class="literal">WRITESET</code> または <code class="literal">WRITESET_SESSION</code> を値として設定すると、ソースは、空または部分書込みセットを持つトランザクション、主キーまたは一意キーのないテーブルを更新するトランザクション、および外部キー関係の親テーブルを更新するトランザクションに対して <code class="literal">COMMIT_ORDER</code> モードを使用します。 
          </p><p>
            <code class="literal">WRITESET</code> または <code class="literal">WRITESET_SESSION</code> を <code class="literal">binlog_transaction_dependency_tracking</code> の値として設定するには、(<code class="literal">OFF</code> に設定されていない) アルゴリズムを指定するように <code class="literal">transaction_write_set_extraction</code> を設定する必要があります。 MySQL 8.0 のデフォルトでは、<code class="literal">transaction_write_set_extraction</code> は <code class="literal">XXHASH64</code> に設定されています。 <code class="literal">transaction_write_set_extraction</code> に選択した値は、<code class="literal">binlog_transaction_dependency_tracking</code> の値が <code class="literal">WRITESET</code> または <code class="literal">WRITESET_SESSION</code> のままである間は再度変更できません。 
          </p><p>
            特定の行を変更した最新のトランザクションについて保持およびチェックされる行ハッシュの数は、<code class="literal">binlog_transaction_dependency_history_size</code> の値によって決まります。
          </p><p>
            グループレプリケーションの場合、<code class="literal">binlog_transaction_dependency_tracking=WRITESET_SESSION</code> を設定すると、グループワークロードに応じてグループメンバーのパフォーマンスを向上させることができます。 Group Replication は、<code class="literal">binlog_transaction_dependency_tracking</code> に設定された値とは関係なく、リレーログからトランザクションを適用するときに、証明後に独自のパラレル化を実行します。 ただし、<code class="literal">binlog_transaction_dependency_tracking</code> の値は、グループレプリケーションメンバーのバイナリログへのトランザクションの書込み方法に影響します。 これらのログ内の依存関係情報は、メンバーがグループに参加または再参加するたびに発生する分散リカバリのドナーバイナリログからの状態転送プロセスを支援するために使用されます。 
          </p></li><li class="listitem"><p><a name="sysvar_binlog_transaction_dependency_history_size"></a>
            <code class="literal">binlog_transaction_dependency_history_size</code>
          </p><a class="indexterm" name="idm46723652862608"></a><a class="indexterm" name="idm46723652860992"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog_transaction_dependency_history_size"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-transaction-dependency-history-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_transaction_dependency_history_size">binlog_transaction_dependency_history_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">25000</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">1000000</code></td>
</tr></tbody></table></div><p>
            メモリーに保持され、特定の行を最後に変更したトランザクションの検索に使用される行ハッシュの数の上限を設定します。 このハッシュ数に達すると、履歴がパージされます。 
          </p></li><li class="listitem"><p><a name="sysvar_expire_logs_days"></a>
            <code class="literal">expire_logs_days</code>
          </p><a class="indexterm" name="idm46723652830912"></a><a class="indexterm" name="idm46723652829376"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for expire_logs_days"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--expire-logs-days=#</code></td>
</tr><tr><th>非推奨</th>
<td>はい</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_expire_logs_days">expire_logs_days</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">99</code></td>
</tr></tbody></table></div><p>
            バイナリログファイルを自動的に削除するまでの日数を指定します。<code class="literal">expire_logs_days</code> は非推奨であり、将来のリリースで削除される予定です。 代わりに、バイナリログの有効期限を秒単位で設定する <code class="literal">binlog_expire_logs_seconds</code> を使用してください。 どちらのシステム変数にも値を設定しない場合、デフォルトの有効期限は 30 日です。 削除は起動時およびバイナリログがフラッシュされるときに発生する可能性があります。 ログのフラッシュは、<a class="xref" href="server-administration.html#server-logs" title="5.4 MySQL Server ログ">セクション5.4「MySQL Server ログ」</a>に記載されているように発生します。 
          </p><p>
            <code class="literal">binlog_expire_logs_seconds</code> も指定した場合、<code class="literal">expire_logs_days</code> にゼロ以外の値を指定すると無視され、かわりにバイナリログの有効期限として <code class="literal">binlog_expire_logs_seconds</code> の値が使用されます。 この状況では、警告メッセージが発行されます。 <code class="literal">expire_logs_days</code> のゼロ以外の値は、<code class="literal">binlog_expire_logs_seconds</code> が指定されていないか、0 として指定されている場合にのみバイナリログの有効期限として適用されます。 
          </p><p>
            バイナリログの自動パージを無効にするには、<code class="literal">binlog_expire_logs_seconds</code> に値 0 を明示的に指定し、<code class="literal">expire_logs_days</code> に値を指定しないでください。 以前のリリースとの互換性のために、<code class="literal">expire_logs_days</code> に値 0 を明示的に指定し、<code class="literal">binlog_expire_logs_seconds</code> に値を指定しないと、自動パージも無効になります。 その場合、<code class="literal">binlog_expire_logs_seconds</code> のデフォルトは適用されません。 
          </p><p>
            バイナリログファイルを手動で削除するには、<code class="literal">PURGE BINARY LOGS</code> ステートメントを使用します。 <a class="xref" href="sql-statements.html#purge-binary-logs" title="13.4.1.1 PURGE BINARY LOGS ステートメント">セクション13.4.1.1「PURGE BINARY LOGS ステートメント」</a>を参照してください。 
          </p></li><li class="listitem"><p><a name="sysvar_log_bin"></a>
            <code class="literal">log_bin</code>
          </p><a class="indexterm" name="idm46723652779696"></a><a class="indexterm" name="idm46723652778192"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for log_bin"><col style="width=30%"><col style="width=70%"><tbody><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_log_bin">log_bin</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr></tbody></table></div><p>
            サーバー上のバイナリロギングのステータスを表示します。有効 (<code class="literal">ON</code>) または無効 (<code class="literal">OFF</code>) のいずれかです。 バイナリロギングが有効になっている場合、サーバーは、データを変更するすべてのステートメントをバイナリログに記録します。バイナリログは、バックアップとレプリケーションに使用されます。 <code class="literal">ON</code> はバイナリログが使用可能であることを意味し、<code class="literal">OFF</code> はバイナリログが使用されていないことを意味します。 <code class="option">--log-bin</code> オプションを使用すると、バイナリログのベース名と場所を指定できます。 
          </p><p>
            以前の MySQL バージョンでは、バイナリロギングはデフォルトで無効になっており、<code class="option">--log-bin</code> オプションを指定した場合は有効になっていました。 MySQL 8.0 からは、<code class="option">--log-bin</code> オプションを指定するかどうかに関係なく、<code class="literal">log_bin</code> システム変数が <code class="literal">ON</code> に設定されたバイナリロギングがデフォルトで有効になります。 例外は、バイナリロギングがデフォルトで無効になっている場合に、<span class="command"><strong>mysqld</strong></span> を使用して <code class="option">--initialize</code> または <code class="option">--initialize-insecure</code> オプションを指定してデータディレクトリを手動で呼び出すことによって、データディレクトリを初期化する場合です。 この場合、<code class="option">--log-bin</code> オプションを指定することでバイナリロギングを有効にできます。 


          </p><p>
            <code class="option">--skip-log-bin</code> または <code class="option">--disable-log-bin</code> オプションが起動時に指定された場合、バイナリロギングは無効になり、<code class="literal">log_bin</code> システム変数は <code class="literal">OFF</code> に設定されます。 これらのオプションのいずれかが指定され、<code class="option">--log-bin</code> も指定されている場合は、後で指定するオプションが優先されます。 
          </p><p>
            バイナリログの形式と管理については、<a class="xref" href="server-administration.html#binary-log" title="5.4.4 バイナリログ">セクション5.4.4「バイナリログ」</a> を参照してください。
          </p></li><li class="listitem"><p><a name="sysvar_log_bin_basename"></a>
            <code class="literal">log_bin_basename</code>
          </p><a class="indexterm" name="idm46723652741600"></a><a class="indexterm" name="idm46723652740064"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for log_bin_basename"><col style="width=30%"><col style="width=70%"><tbody><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_log_bin_basename">log_bin_basename</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>ファイル名</td>
</tr></tbody></table></div><p>
            バイナリログファイルのベース名とパスを保持します。これらは <code class="option">--log-bin</code> サーバーオプションで設定できます。 最大可変長は 256 です。 MySQL 8.0 では、<code class="option">--log-bin</code> オプションが指定されていない場合、デフォルトのベース名は <code class="filename">binlog</code> です。 MySQL 5.7 との互換性のために、<code class="option">--log-bin</code> オプションが文字列なしまたは空の文字列とともに指定されている場合、デフォルトのベース名は <code class="filename"><em class="replaceable"><code>host_name</code></em>-bin</code> で、ホストマシンの名前が使用されます。 デフォルトの場所はデータディレクトリです。 
          </p></li><li class="listitem"><p><a name="sysvar_log_bin_index"></a>
            <code class="literal">log_bin_index</code>
          </p><a class="indexterm" name="idm46723652715536"></a><a class="indexterm" name="idm46723652714016"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for log-bin-index"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--log-bin-index=file_name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_log_bin_index">log_bin_index</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>ファイル名</td>
</tr></tbody></table></div><p>
            バイナリログインデックスファイルのベース名とパスを保持します。これは、<code class="option">--log-bin-index</code> サーバーオプションで設定できます。 最大可変長は 256 です。 
          </p></li><li class="listitem"><p><a name="sysvar_log_bin_trust_function_creators"></a>
            <code class="literal">log_bin_trust_function_creators</code>
          </p><a class="indexterm" name="idm46723652690800"></a><a class="indexterm" name="idm46723652689216"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for log_bin_trust_function_creators"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--log-bin-trust-function-creators[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_log_bin_trust_function_creators">log_bin_trust_function_creators</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
            この変数は、バイナリロギングが有効な場合に適用されます。 ストアドファンクションの作成者が、安全でないイベントがバイナリログに書き込まれる原因となるストアドファンクションを作成しないことを信頼できるかどうかを制御します。 0 (デフォルト) に設定した場合、ユーザーは <code class="literal">CREATE ROUTINE</code> または <code class="literal">ALTER ROUTINE</code> 権限に加えて <code class="literal">SUPER</code> 権限を持たないかぎり、ストアドファンクションを作成または変更することが許可されません。 0 に設定することで、関数を <code class="literal">DETERMINISTIC</code> 特性で、あるいは <code class="literal">READS SQL DATA</code> または <code class="literal">NO SQL</code> 特性で宣言する必要があるという制約も強制されます。 変数が 1 に設定された場合、MySQL はストアドファンクション作成にこれらの制約を強制しません。 この変数はトリガー作成にも適用されます。 <a class="xref" href="stored-objects.html#stored-programs-logging" title="25.7 ストアドプログラムバイナリロギング">セクション25.7「ストアドプログラムバイナリロギング」</a>を参照してください。 
          </p></li><li class="listitem"><p><a name="sysvar_log_bin_use_v1_row_events"></a>
            <code class="literal">log_bin_use_v1_row_events</code>
          </p><a class="indexterm" name="idm46723652657296"></a><a class="indexterm" name="idm46723652655728"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for log_bin_use_v1_row_events"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--log-bin-use-v1-row-events[={OFF|ON}]</code></td>
</tr><tr><th>非推奨</th>
<td>8.0.18</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_log_bin_use_v1_row_events">log_bin_use_v1_row_events</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
            この読取り専用システム変数は非推奨です。 サーバーの起動時にシステム変数を <code class="literal">ON</code> に設定すると、MySQL 5.6 の時点でデフォルトであるバージョン 2 バイナリログ行イベントではなく、バージョン 1 バイナリログ行イベントを使用してバイナリログを書き込むことによって、MySQL Server 5.5 以前を実行しているレプリカで行ベースレプリケーションが有効になります。 
          </p></li><li class="listitem"><p><a name="sysvar_log_slave_updates"></a>
            <code class="literal">log_slave_updates</code>
          </p><a class="indexterm" name="idm46723652627536"></a><a class="indexterm" name="idm46723652625984"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for log_slave_updates"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--log-slave-updates[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_log_slave_updates">log_slave_updates</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
            レプリケーションソースサーバーから受信した更新を、レプリカ独自のバイナリログに記録するかどうか。
          </p><p>
            この変数を有効にすると、レプリカはソースから受信し、レプリケーション SQL スレッドによって実行された更新をレプリカ独自のバイナリログに書き込みます。 バイナリロギングは <code class="option">--log-bin</code> オプションによって制御され、デフォルトで有効になっていますが、更新をログに記録するにはレプリカでも有効にする必要があります。 <a class="xref" href="replication.html#replication-options" title="17.1.6 レプリケーションおよびバイナリロギングのオプションと変数">セクション17.1.6「レプリケーションおよびバイナリロギングのオプションと変数」</a> を参照してください。<code class="option">--skip-log-bin</code> を指定してバイナリロギングを無効にしないかぎり、<code class="literal">log_slave_updates</code> はデフォルトで有効になっています。この場合、MySQL はレプリカ更新ロギングもデフォルトで無効にします。 バイナリロギングが有効になっているときにレプリカ更新ロギングを無効にする必要がある場合は、レプリカサーバーの起動時に <code class="option">--log-slave-updates=OFF</code> を指定します。 
          </p><p>
            <code class="literal">log_slave_updates</code> を有効にすると、レプリケーションサーバーをチェーンできます。 たとえば、このようにレプリケーションサーバーをセットアップするとします。 
          </p><pre class="programlisting">A -&gt; B -&gt; C
</pre><p>
            ここで、<code class="literal">A</code> はレプリカ <code class="literal">B</code> のソースとして機能し、<code class="literal">B</code> はレプリカ <code class="literal">C</code> のソースとして機能します。 これが機能するには、<code class="literal">B</code> がソースとレプリカの両方である必要があります。 バイナリロギングが有効で、<code class="literal">log_slave_updates</code> が有効になっている場合 (デフォルト設定)、<code class="literal">A</code> から受信した更新は <code class="literal">B</code> によってバイナリログに記録されるため、<code class="literal">C</code> に渡すことができます。 
          </p></li><li class="listitem"><p><a name="sysvar_log_statements_unsafe_for_binlog"></a>
            <code class="literal">log_statements_unsafe_for_binlog</code>
          </p><a class="indexterm" name="idm46723652584496"></a><a class="indexterm" name="idm46723652582912"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for log_statements_unsafe_for_binlog"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--log-statements-unsafe-for-binlog[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_log_statements_unsafe_for_binlog">log_statements_unsafe_for_binlog</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
            エラー 1592 が発生した場合、生成された警告をエラーログに追加するかどうかを制御します。
          </p></li><li class="listitem"><p><a name="sysvar_master_verify_checksum"></a>
            <code class="literal">master_verify_checksum</code>
          </p><a class="indexterm" name="idm46723652557968"></a><a class="indexterm" name="idm46723652556416"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for master_verify_checksum"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--master-verify-checksum[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_master_verify_checksum">master_verify_checksum</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
            この変数を有効にすると、ソースはチェックサムを検査してバイナリログから読み取られたイベントを検証し、不一致が発生した場合はエラーで停止します。<code class="literal">master_verify_checksum</code> はデフォルトで無効になっています。この場合、ソースはバイナリログのイベント長を使用してイベントを検証し、バイナリログから完全なイベントのみが読み取られるようにします。
          </p></li><li class="listitem"><p><a name="sysvar_max_binlog_cache_size"></a>
            <code class="literal">max_binlog_cache_size</code>
          </p><a class="indexterm" name="idm46723652529952"></a><a class="indexterm" name="idm46723652528400"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for max_binlog_cache_size"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--max-binlog-cache-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_max_binlog_cache_size">max_binlog_cache_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">18446744073709551615</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">4096</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">18446744073709551615</code></td>
</tr></tbody></table></div><p>
            トランザクション内の非トランザクションステートメントがこのバイト数より多くのメモリーを必要とする場合、サーバーは<span class="errortext">Multi-statement transaction required more than 'max_binlog_cache_size' bytes of storage</span>エラーを生成します。 最小値は 4096 です。 可能な最大値は 16EiB (exbibytes) です。 推奨される最大値は 4G バイトです。これは、MySQL が現在 4G バイトより大きなバイナリログ位置で作業できないという事実によります。 
          </p><p>
            <code class="literal">max_binlog_cache_size</code> はトランザクションキャッシュのみのサイズを設定します。ステートメントキャッシュの上限値は <code class="literal">max_binlog_stmt_cache_size</code> システム変数によって管理されます。
          </p><p>
            <code class="literal">max_binlog_cache_size</code> のセッションの可視性は、<code class="literal">binlog_cache_size</code> システム変数の可視性と一致します。つまり、その値を変更すると、値が変更された後に開始される新しいセッションにのみ影響します。
          </p></li><li class="listitem"><p><a name="sysvar_max_binlog_size"></a>
            <code class="literal">max_binlog_size</code>
          </p><a class="indexterm" name="idm46723652492544"></a><a class="indexterm" name="idm46723652491008"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for max_binlog_size"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--max-binlog-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_max_binlog_size">max_binlog_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">1073741824</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">4096</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">1073741824</code></td>
</tr></tbody></table></div><p>
            バイナリログへの書き込みによって、現在のログファイルサイズがこの変数の値を超えた場合、サーバーはバイナリログをローテーションします (現在のファイルを閉じて、新しいものを開きます)。 最小値は 4096 バイトです。 最大値およびデフォルト値は 1G バイトです。 暗号化バイナリログファイルには、<code class="literal">max_binlog_size</code> に含まれる追加の 512 バイトヘッダーがあります。 
          </p><p>
            トランザクションはバイナリログにひとまとまりで書き込まれ、複数のバイナリログ間に分割されることはありません。 このため、大きなトランザクションの場合、<code class="literal">max_binlog_size</code> より大きいバイナリログファイルが見られることがあります。 
          </p><p>
            <code class="literal">max_relay_log_size</code> が 0 の場合、<code class="literal">max_binlog_size</code> の値がリレーログにも適用されます。
          </p><p>
            GTID がサーバーで使用されている場合、<code class="literal">max_binlog_size</code> に到達したときに、システムテーブル <code class="literal">mysql.gtid_executed</code> にアクセスして GTID を現在のバイナリログファイルから書き込めないと、バイナリログをローテーションできません。 この状況では、サーバーはその <code class="literal">binlog_error_action</code> 設定に従って応答します。 <code class="literal">IGNORE_ERROR</code> が設定されている場合、サーバーにエラーが記録され、バイナリロギングが停止されます。または、<code class="literal">ABORT_SERVER</code> が設定されている場合、サーバーはシャットダウンします。 


          </p></li><li class="listitem"><p><a name="sysvar_max_binlog_stmt_cache_size"></a>
            <code class="literal">max_binlog_stmt_cache_size</code>
          </p><a class="indexterm" name="idm46723652449632"></a><a class="indexterm" name="idm46723652448064"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for max_binlog_stmt_cache_size"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--max-binlog-stmt-cache-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_max_binlog_stmt_cache_size">max_binlog_stmt_cache_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">18446744073709547520</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">4096</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">18446744073709547520</code></td>
</tr></tbody></table></div><p>
            トランザクション内の非トランザクションステートメントがこのバイト数より多くのメモリーを必要とする場合、サーバーはエラーを生成します。 最小値は 4096 です。 最大値およびデフォルト値は、32 ビットプラットフォームでは 4G バイト、64 ビットプラットフォームでは 16E バイト (エクサバイト) です。 
          </p><p>
            <code class="literal">max_binlog_stmt_cache_size</code> はステートメントキャッシュのみのサイズを設定します。トランザクションキャッシュの上限値は <code class="literal">max_binlog_cache_size</code> システム変数によって排他的に管理されます。
          </p></li><li class="listitem"><p><a name="sysvar_original_commit_timestamp"></a>
            <code class="literal">original_commit_timestamp</code>
          </p><a class="indexterm" name="idm46723652415424"></a><a class="indexterm" name="idm46723652413856"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for original_commit_timestamp"><col style="width=30%"><col style="width=70%"><tbody><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_original_commit_timestamp">original_commit_timestamp</a></code></td>
</tr><tr><th>スコープ</th>
<td>セッション</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>数値</td>
</tr></tbody></table></div><p>
            レプリケーションによる内部使用用。 レプリカでトランザクションを再実行する場合、これは元のソースでトランザクションがコミットされた時間に設定され、エポック以降マイクロ秒単位で測定されます。 これにより、元のコミットタイムスタンプをレプリケーショントポロジ全体に伝播できます。 
          </p><p>
            このシステム変数のセッション値の設定は制限された操作です。 セッションユーザーには、<code class="literal">REPLICATION_APPLIER</code> 権限 (<a class="xref" href="replication.html#replication-privilege-checks" title="17.3.3 レプリケーション権限チェック">セクション17.3.3「レプリケーション権限チェック」</a> を参照) または制限付きセッション変数の設定に十分な権限 (<a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a> を参照) が必要です。 ただし、この変数はユーザーが設定するためのものではなく、レプリケーションインフラストラクチャによって自動的に設定されることに注意してください。 
          </p></li><li class="listitem"><p><a name="sysvar_sql_log_bin"></a>
            <code class="literal">sql_log_bin</code>
          </p><a class="indexterm" name="idm46723652389808"></a><a class="indexterm" name="idm46723652388336"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for sql_log_bin"><col style="width=30%"><col style="width=70%"><tbody><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_sql_log_bin">sql_log_bin</a></code></td>
</tr><tr><th>スコープ</th>
<td>セッション</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
            この変数は、現在のセッションでバイナリログへのロギングを有効にするかどうかを制御します (バイナリログ自体が有効になっていると仮定します)。 デフォルト値は <code class="literal">ON</code> です。 現在のセッションのバイナリロギングを無効または有効にするには、セッション <code class="literal">sql_log_bin</code> 変数を <code class="literal">OFF</code> または <code class="literal">ON</code> に設定します。 
          </p><p>
            レプリカにレプリケートしないソースに変更を加えている間にバイナリロギングを一時的に無効にするには、セッションに対してこの変数を <code class="literal">OFF</code> に設定します。
          </p><p>
            このシステム変数のセッション値の設定は制限された操作です。 セッションユーザーには、制限付きセッション変数を設定するのに十分な権限が必要です。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 
          </p><p>
            トランザクションまたはサブクエリー内で <code class="literal">sql_log_bin</code> のセッション値を設定することはできません。
          </p><p>
            <span class="emphasis"><em>「この変数を <code class="literal">OFF</code> に設定すると、GTID がバイナリログ内のトランザクションに割り当てられなくなります」</em></span>。 これは、GTID をレプリケーションに使用している場合、バイナリロギングがあとで再度有効になった場合でも、この時点からログに書き込まれる GTID はその意味で発生したトランザクションを考慮しないため、それらのトランザクションは失われることを意味します。 
          </p></li><li class="listitem"><p><a name="sysvar_sync_binlog"></a>
            <code class="literal">sync_binlog</code>
          </p><a class="indexterm" name="idm46723652355232"></a><a class="indexterm" name="idm46723652353760"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for sync_binlog"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--sync-binlog=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_sync_binlog">sync_binlog</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
            MySQL サーバーがバイナリログをディスクに同期する頻度を制御します。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">sync_binlog=0</code>: MySQL サーバーによるバイナリログのディスクへの同期を無効にします。 代わりに、MySQL サーバーは、ほかのファイルの場合と同様に、バイナリログをディスクにフラッシュするためにオペレーティングシステムに依存します。 この設定は最高のパフォーマンスを提供しますが、電源障害またはオペレーティングシステムがクラッシュした場合は、バイナリログに同期されていないトランザクションがサーバーによってコミットされている可能性があります。 
              </p></li><li class="listitem"><p>
                <code class="literal">sync_binlog=1</code>: トランザクションがコミットされる前にバイナリログをディスクに同期できるようにします。 これは最も安全な設定ですが、ディスク書込み数が増加したためにパフォーマンスに悪影響を与える可能性があります。 電源障害またはオペレーティングシステムがクラッシュした場合、バイナリログから欠落しているトランザクションは準備完了状態にすぎません。 これにより、自動回復ルーチンはトランザクションをロールバックでき、バイナリログからトランザクションが失われないことが保証されます。 
              </p></li><li class="listitem"><p>
                <code class="literal">sync_binlog=<em class="replaceable"><code>N</code></em></code> (<em class="replaceable"><code>N</code></em> は 0 または 1 以外の値): バイナリログは、<code class="literal">N</code> バイナリログコミットグループが収集されたあとにディスクに同期されます。 電源障害またはオペレーティングシステムがクラッシュした場合は、バイナリログにフラッシュされていないトランザクションがサーバーによってコミットされている可能性があります。 この設定は、ディスク書込み数が増加したため、パフォーマンスに悪影響を与える可能性があります。 値を大きくするとパフォーマンスは向上しますが、データ損失のリスクは高くなります。 
              </p></li></ul></div><p>
            トランザクションで <code class="literal">InnoDB</code> を使用するレプリケーション設定で永続性と一貫性を最大限に高めるには、次の設定を使用します:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">sync_binlog=1</code>。
              </p></li><li class="listitem"><p>
                <code class="literal">innodb_flush_log_at_trx_commit=1</code>。
              </p></li></ul></div><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注意</div><p>
              多くのオペレーティングシステムや一部のディスクハードウェアは、ディスクへのフラッシュ操作を行なったと欺きます。 フラッシュが行われていなくても、行われたと <span class="command"><strong>mysqld</strong></span> に通知される可能性があります。 この場合、推奨設定であってもトランザクションの永続性は保証されず、最悪の場合は停電によって <code class="literal">InnoDB</code> データが破損する可能性があります。 バッテリーバックアップのディスクキャッシュを SCSI ディスクコントローラ内やディスク自体で使用すると、ファイルフラッシュの速度が上がり、操作が安全になります。 ハードウェアキャッシュ内のディスク書き込みのキャッシュを無効にすることもできます。 
            </p></div></li><li class="listitem"><p><a name="sysvar_transaction_write_set_extraction"></a>
            <code class="literal">transaction_write_set_extraction</code>
          </p><a class="indexterm" name="idm46723652304096"></a><a class="indexterm" name="idm46723652302976"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for transaction_write_set_extraction"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--transaction-write-set-extraction[=value]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_transaction_write_set_extraction">transaction_write_set_extraction</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル、セッション</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">XXHASH64</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">OFF</code></p><p class="valid-value"><code class="literal">MURMUR32</code></p><p class="valid-value"><code class="literal">XXHASH64</code></p></td>
</tr></tbody></table></div><p>
            マルチスレッドレプリカ (<code class="literal">slave_parallel_workers</code> が 0 より大きい値に設定されているレプリカ) を持つレプリケーションソースサーバーの場合、<code class="literal">binlog_transaction_dependency_tracking</code> は <code class="literal">WRITESET</code> または <code class="literal">WRITESET_SESSION</code> に設定され、ソース書込みセットから依存性情報を生成します。<code class="literal">transaction_write_set_extraction</code> は、トランザクション中に抽出された書込みのハッシュに使用されるアルゴリズムを指定します。このシステム変数の値を変更するには、<code class="literal">binlog_format</code> を <code class="literal">ROW</code> に設定する必要があります。
          </p><p>
            <code class="literal">WRITESET</code> または <code class="literal">WRITESET_SESSION</code> が <code class="literal">binlog_transaction_dependency_tracking</code> の値として設定されている場合、<code class="literal">transaction_write_set_extraction</code> を設定してアルゴリズムを指定する必要があります (<code class="literal">OFF</code> に設定されていません)。 MySQL 8.0 のデフォルトでは、<code class="literal">transaction_write_set_extraction</code> は <code class="literal">XXHASH64</code> に設定されています。 <code class="literal">binlog_transaction_dependency_tracking</code> の現在の値は <code class="literal">WRITESET</code> または <code class="literal">WRITESET_SESSION</code> ですが、<code class="literal">transaction_write_set_extraction</code> の値は変更できません。 
          </p><p>
            グループレプリケーションの場合、<code class="literal">transaction_write_set_extraction</code> を <code class="literal">XXHASH64</code> に設定する必要があります。 トランザクションから書込みを抽出するプロセスは、すべてのグループメンバーの競合検出および証明のためにグループレプリケーションで使用されます。 <a class="xref" href="group-replication.html#group-replication-requirements" title="18.9.1 グループレプリケーションの要件">セクション18.9.1「グループレプリケーションの要件」</a>を参照してください。 
          </p><p>
            MySQL 8.0.14 では、このシステム変数のセッション値の設定は制限された操作です。 セッションユーザーには、制限付きセッション変数を設定するのに十分な権限が必要です。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-options-gtids"></a>17.1.6.5 グローバルトランザクション ID システム変数</h4></div></div></div><p>
      このセクションで説明する MySQL Server システム変数は、グローバルトランザクション識別子 (GTID) をモニターおよび制御するために使用されます。 追加情報については <a class="xref" href="replication.html#replication-gtids" title="17.1.3 グローバルトランザクション識別子を使用したレプリケーション">セクション17.1.3「グローバルトランザクション識別子を使用したレプリケーション」</a>を参照してください。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="sysvar_binlog_gtid_simple_recovery"></a>
          <code class="literal">binlog_gtid_simple_recovery</code>
        </p><a class="indexterm" name="idm46723652247520"></a><a class="indexterm" name="idm46723652246400"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for binlog_gtid_simple_recovery"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--binlog-gtid-simple-recovery[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_binlog_gtid_simple_recovery">binlog_gtid_simple_recovery</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
          この変数は、MySQL の起動または再起動時に GTID の検索中にバイナリログファイルがどのように繰り返されるかを制御します。
        </p><p>
          MySQL 8.0 のデフォルトである <code class="literal">binlog_gtid_simple_recovery=TRUE</code> の場合、<code class="literal">gtid_executed</code> および <code class="literal">gtid_purged</code> の値は、最新のバイナリログファイルともっとも古いバイナリログファイルの <code class="literal">Previous_gtids_log_event</code> の値に基づいて起動時に計算されます。 計算の詳細は、<a class="xref" href="replication.html#replication-gtids-gtid-purged" title="gtid_purged システム変数"><code class="literal">gtid_purged</code> システム変数</a> を参照してください。 この設定は、サーバーの再起動時に 2 つのバイナリログファイルにのみアクセスします。 サーバー上のすべてのバイナリログが MySQL 5.7.8 以降を使用して生成された場合、<code class="literal">binlog_gtid_simple_recovery=TRUE</code> は常に安全に使用できます。 


        </p><p>
          MySQL 5.7.7 以前のバイナリログがサーバーに存在する場合 (たとえば、古いサーバーから MySQL 8.0 へのアップグレード後)、<code class="literal">binlog_gtid_simple_recovery=TRUE</code> を使用すると、次の 2 つの状況で <code class="literal">gtid_executed</code> および <code class="literal">gtid_purged</code> が正しく初期化されないことがあります:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              最新のバイナリログは MySQL 5.7.5 以前によって生成され、<code class="literal">gtid_mode</code> は一部のバイナリログでは <code class="literal">ON</code> でしたが、最新のバイナリログでは <code class="literal">OFF</code> でした。
            </p></li><li class="listitem"><p>
              MySQL 5.7.7 以前で <code class="literal">SET @@GLOBAL.gtid_purged</code> ステートメントが発行され、<code class="literal">SET @@GLOBAL.gtid_purged</code> ステートメントの時点でアクティブだったバイナリログはまだパージされていません。


            </p></li></ul></div><p>
          いずれかの状況で不正な GTID セットが計算された場合、あとで <code class="literal">binlog_gtid_simple_recovery=FALSE</code> を使用してサーバーを再起動しても、正しくありません。 これらの状況のいずれかが適用されるか、サーバーに適用される可能性がある場合は、サーバーを起動または再起動する前に <code class="literal">binlog_gtid_simple_recovery=FALSE</code> を設定します。 
        </p><p>
          <code class="literal">binlog_gtid_simple_recovery=FALSE</code> が設定されている場合、<a class="xref" href="replication.html#replication-gtids-gtid-purged" title="gtid_purged システム変数"><code class="literal">gtid_purged</code> システム変数</a> で説明されている <code class="literal">gtid_executed</code> および <code class="literal">gtid_purged</code> の計算方法は、次のようにバイナリログファイルを繰り返すように変更されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              最新のバイナリログファイルからの <code class="literal">Previous_gtids_log_event</code> および GTID ログイベントの値を使用する代わりに、<code class="literal">gtid_executed</code> の計算は最新のバイナリログファイルから繰り返され、<code class="literal">Previous_gtids_log_event</code> の値と、<code class="literal">Previous_gtids_log_event</code> 値が見つかった最初のバイナリログファイルからの GTID ログイベントを使用します。 サーバーの最新のバイナリログファイルに GTID ログイベントがない場合 (たとえば、<code class="literal">gtid_mode=ON</code> が使用されたが、あとでサーバーが <code class="literal">gtid_mode=OFF</code> に変更された場合)、このプロセスには時間がかかることがあります。 
            </p></li><li class="listitem"><p>
              もっとも古いバイナリログファイルからの <code class="literal">Previous_gtids_log_event</code> の値を使用する代わりに、<code class="literal">gtid_purged</code> の計算はもっとも古いバイナリログファイルから繰り返され、空でない <code class="literal">Previous_gtids_log_event</code> 値または GTID ログイベント (GTID の使用がその時点から開始されることを示す) が見つかった最初のバイナリログファイルからの <code class="literal">Previous_gtids_log_event</code> の値を使用します。 サーバーの古いバイナリログファイルに GTID ログイベントがない場合 (たとえば、<code class="literal">gtid_mode=ON</code> がサーバー上で最近のみ設定された場合)、このプロセスには時間がかかることがあります。 
            </p></li></ul></div></li><li class="listitem"><p><a name="sysvar_enforce_gtid_consistency"></a>
          <code class="literal">enforce_gtid_consistency</code>
        </p><a class="indexterm" name="idm46723652182560"></a><a class="indexterm" name="idm46723652181008"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for enforce_gtid_consistency"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--enforce-gtid-consistency[=value]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_enforce_gtid_consistency">enforce_gtid_consistency</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">OFF</code></p><p class="valid-value"><code class="literal">ON</code></p><p class="valid-value"><code class="literal">WARN</code></p></td>
</tr></tbody></table></div><p>
          この変数の値に応じて、GTID を使用して安全にログに記録できるステートメントのみを実行できるようにすることで、サーバーは GTID 整合性を強制します。 GTID ベースのレプリケーションを有効にする前に、この変数を <code class="literal">ON</code> に設定する必要があります。 
        </p><p>
          <code class="literal">enforce_gtid_consistency</code> で構成できる値は次のとおりです:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">OFF</code>: すべてのトランザクションが GTID 整合性に違反することを許可されます。
            </p></li><li class="listitem"><p>
              <code class="literal">ON</code>: GTID 整合性に違反するトランザクションは許可されていません。
            </p></li><li class="listitem"><p>
              <code class="literal">WARN</code>: すべてのトランザクションは GTID 整合性に違反できますが、この場合は警告が生成されます。
            </p></li></ul></div><p>
          <code class="option">--enforce-gtid-consistency</code> は、ステートメントに対してバイナリロギングが行われた場合にのみ有効になります。 バイナリロギングがサーバーで無効になっている場合、またはステートメントがフィルタによって削除されたためにバイナリログに書き込まれない場合、GTID の整合性は、ログに記録されていないステートメントに対してチェックまたは適用されません。 
        </p><p>
          <code class="literal">enforce_gtid_consistency</code> が <code class="literal">ON</code> に設定されている場合、GTID セーフステートメントを使用してログに記録できるステートメントのみが記録されるため、ここにリストされている操作はこのオプションとともに使用できません:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              トランザクション内の <code class="literal">CREATE TEMPORARY TABLE</code> または <code class="literal">DROP TEMPORARY TABLE</code> ステートメント。
            </p></li><li class="listitem"><p>
              トランザクションおよび非トランザクションテーブルの両方を更新するトランザクションまたはステートメント。 すべての<span class="emphasis"><em>非トランザクション</em></span>テーブルが一時テーブルの場合、非トランザクション DML は同じトランザクションまたはトランザクション DML と同じステートメントで許可されるという例外があります。 
            </p></li><li class="listitem"><p>
              MySQL 8.0.21 より前の <code class="literal">CREATE TABLE ... SELECT</code> ステートメント。 MySQL 8.0.21 からは、アトミック DDL をサポートするストレージエンジンに対して <code class="literal">CREATE TABLE ... SELECT</code> ステートメントが許可されます。 
            </p></li></ul></div><p>
          詳細は、<a class="xref" href="replication.html#replication-gtids-restrictions" title="17.1.3.7 GTID ベースレプリケーションの制約">セクション17.1.3.7「GTID ベースレプリケーションの制約」</a>を参照してください。
        </p><p>
          MySQL 5.7 より前およびそのリリースシリーズの初期リリースでは、ブール <code class="literal">enforce_gtid_consistency</code> は <code class="literal">OFF</code> にデフォルト設定されていました。 これらの以前のリリースとの互換性を維持するために、列挙はデフォルトで <code class="literal">OFF</code> に設定され、値を指定せずに <code class="option">--enforce-gtid-consistency</code> を設定すると、値が <code class="literal">ON</code> に設定されたと解釈されます。 変数には、値に対する複数のテキストエイリアスもあります: <code class="literal">0=OFF=FALSE</code>、<code class="literal">1=ON=TRUE</code>、<code class="literal">2=WARN</code>。 これは他の列挙型とは異なりますが、以前のリリースで使用されていたブール型との互換性は維持されます。 これらの変更は、変数によって返される内容に影響します。 <code class="literal">SELECT @@ENFORCE_GTID_CONSISTENCY</code>、<code class="literal">SHOW VARIABLES LIKE 'ENFORCE_GTID_CONSISTENCY'</code>および <code class="literal">SELECT * FROM INFORMATION_SCHEMA.VARIABLES WHERE 'VARIABLE_NAME' = 'ENFORCE_GTID_CONSISTENCY'</code>を使用すると、すべて数値フォームではなくテキストフォームが返されます。 <code class="literal">@@ENFORCE_GTID_CONSISTENCY</code> はブールの数値フォームを返しますが、<code class="literal">SHOW</code> および情報スキーマのテキストフォームを返すため、これは互換性のない変更です。 
        </p></li><li class="listitem"><p><a name="sysvar_gtid_executed"></a>
          <code class="literal">gtid_executed</code>
        </p><a class="indexterm" name="idm46723652116880"></a><a class="indexterm" name="idm46723652115360"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for gtid_executed"><col style="width=30%"><col style="width=70%"><tbody><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_gtid_executed">gtid_executed</a></code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_gtid_executed">gtid_executed</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>スコープ</th>
<td>グローバル、セッション</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr><tr><th>単位</th>
<td><code class="literal">set of GTIDs</code></td>
</tr></tbody></table></div><p>
          グローバルスコープで使用する場合、この変数には、<code class="literal">SET</code> <code class="literal">gtid_purged</code> ステートメントによって設定されたサーバーおよび GTID で実行されたすべてのトランザクションのセットの表現が含まれます。 これは、<code class="literal">SHOW MASTER STATUS</code> および <code class="literal">SHOW REPLICA | SLAVE STATUS</code> の出力の <code class="literal">Executed_Gtid_Set</code> カラムの値と同じです。 この変数の値は GTID セットです。詳細は、<a class="xref" href="replication.html#replication-gtids-concepts-gtid-sets" title="GTID セット">GTID セット</a> を参照してください。 
        </p><p>
          サーバーが起動すると、<code class="literal">@@GLOBAL.gtid_executed</code> が初期化されます。 バイナリログを反復して <code class="literal">gtid_executed</code> に移入する方法の詳細は、<code class="literal">binlog_gtid_simple_recovery</code> を参照してください。 GTID は、トランザクションの実行時、または <code class="literal">SET</code> <code class="literal">gtid_purged</code> ステートメントの実行時にセットに追加されます。 
        </p><p>
          任意の時点でバイナリログに存在できるトランザクションのセットは、<code class="literal">GTID_SUBTRACT(@@GLOBAL.gtid_executed, @@GLOBAL.gtid_purged)</code> と同等です。つまり、まだパージされていないバイナリログ内のすべてのトランザクションに相当します。
        </p><p>
          <code class="literal">RESET MASTER</code> を発行することで、この変数のグローバル値 (ただし、セッション値ではない) は空の文字列にリセットされます。 GTID は、セットが <code class="literal">RESET MASTER</code> によってクリアされるときを除いてセットから削除されません。 
        </p><p>
          一部の旧リリースでは、この変数はセッションスコープとともに使用することもできます。セッションスコープには、現在のセッションでキャッシュに書き込まれる一連のトランザクションの表現が含まれていました。 セッションスコープは非推奨になりました。 
        </p></li><li class="listitem"><p><a name="sysvar_gtid_executed_compression_period"></a>
          <code class="literal">gtid_executed_compression_period</code>
        </p><a class="indexterm" name="idm46723652064528"></a><a class="indexterm" name="idm46723652063408"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for gtid_executed_compression_period"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--gtid-executed-compression-period=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_gtid_executed_compression_period">gtid_executed_compression_period</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値 (≥ 8.0.23)</th>
<td><code class="literal">0</code></td>
</tr><tr><th>デフォルト値 (≤ 8.0.22)</th>
<td><code class="literal">1000</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
          この数のトランザクションが処理されるたびに、<code class="literal">mysql.gtid_executed</code> テーブルを圧縮します。 サーバーでバイナリロギングが有効になっている場合、この圧縮方法は使用されず、代わりに <code class="literal">mysql.gtid_executed</code> テーブルはバイナリログのローテーションごとに圧縮されます。 バイナリロギングがサーバーで無効になっている場合、圧縮スレッドは、指定された数のトランザクションが実行されるまでスリープしてから、ウェイクアップして <code class="literal">mysql.gtid_executed</code> テーブルの圧縮を実行します。 このシステム変数の値を 0 に設定すると、スレッドはウェイクアップしないため、この明示的な圧縮方法は使用されません。 かわりに、圧縮は必要に応じて暗黙的に行われます。 
        </p><p>
          MySQL 8.0.17 から、<code class="literal">InnoDB</code> トランザクションは、<code class="literal">InnoDB</code> 以外のトランザクションに対する個別のプロセスによって <code class="literal">mysql.gtid_executed</code> テーブルに書き込まれます。 サーバーに <code class="literal">InnoDB</code> トランザクションと <code class="literal">InnoDB</code> 以外のトランザクションが混在している場合、このシステム変数によって制御される圧縮はこのプロセスの作業を妨げ、処理速度が大幅に低下する可能性があります。 このため、そのリリースから、<code class="literal">gtid_executed_compression_period</code> を 0 に設定することをお薦めします。 
        </p><p>
          MySQL 8.0.23 から、<code class="literal">InnoDB</code> および <code class="literal">InnoDB</code> 以外のトランザクションが同じプロセスで <code class="literal">mysql.gtid_executed</code> テーブルに書き込まれ、<code class="literal">gtid_executed_compression_period</code> のデフォルト値は 0 です。
        </p><p>
          詳しくは<a class="xref" href="replication.html#replication-gtids-gtid-executed-table-compression" title="mysql.gtid_executed テーブル圧縮">mysql.gtid_executed テーブル圧縮</a>をご覧ください。
        </p></li><li class="listitem"><p><a name="sysvar_gtid_mode"></a>
          <code class="literal">gtid_mode</code>
        </p><a class="indexterm" name="idm46723652016512"></a><a class="indexterm" name="idm46723652014992"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for gtid_mode"><col style="width=30%"><col style="width=70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--gtid-mode=MODE</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_gtid_mode">gtid_mode</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">OFF</code></p><p class="valid-value"><code class="literal">OFF_PERMISSIVE</code></p><p class="valid-value"><code class="literal">ON_PERMISSIVE</code></p><p class="valid-value"><code class="literal">ON</code></p></td>
</tr></tbody></table></div><p>
          GTID ベースのロギングを有効にするかどうか、およびログに含めることができるトランザクションのタイプを制御します。 グローバルシステム変数を設定するには、十分な権限が必要です。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a> を参照してください。<code class="literal">gtid_mode=ON</code> を設定するには、<code class="literal">enforce_gtid_consistency</code> が true である必要があります。 この変数を変更する前に、<a class="xref" href="replication.html#replication-mode-change-online" title="17.1.4 オンラインサーバーでの GTID モードの変更">セクション17.1.4「オンラインサーバーでの GTID モードの変更」</a> を参照してください。 
        </p><p>
          ログに記録されるトランザクションは、匿名にすることも GTID を使用することもできます。 匿名トランザクションは、特定のトランザクションを識別するためにバイナリログファイルと位置に依存します。 GTID トランザクションには、トランザクションの参照に使用される一意の識別子があります。 様々なモードは次のとおりです: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">OFF</code>: 新規トランザクションとレプリケートされたトランザクションの両方が匿名である必要があります。
            </p></li><li class="listitem"><p>
              <code class="literal">OFF_PERMISSIVE</code>: 新しいトランザクションは匿名です。 レプリケートされたトランザクションは、匿名トランザクションまたは GTID トランザクションのいずれかです。 
            </p></li><li class="listitem"><p>
              <code class="literal">ON_PERMISSIVE</code>: 新規トランザクションは GTID トランザクションです。 レプリケートされたトランザクションは、匿名トランザクションまたは GTID トランザクションのいずれかです。 
            </p></li><li class="listitem"><p>
              <code class="literal">ON</code>: 新規トランザクションとレプリケートされたトランザクションの両方が GTID トランザクションである必要があります。
            </p></li></ul></div><p>
          ある値から別の値への変更は、一度に 1 つのステップにしかできません。 たとえば、<code class="literal">gtid_mode</code> が現在 <code class="literal">OFF_PERMISSIVE</code> に設定されている場合、<code class="literal">OFF</code> または <code class="literal">ON_PERMISSIVE</code> に変更できますが、<code class="literal">ON</code> には変更できません。 
        </p><p>
          <code class="literal">gtid_purged</code> および <code class="literal">gtid_executed</code> の値は、<code class="literal">gtid_mode</code> の値に関係なく永続的です。 したがって、<code class="literal">gtid_mode</code> の値を変更した後でも、これらの変数には正しい値が含まれます。 
        </p></li><li class="listitem"><p><a name="sysvar_gtid_next"></a>
          <code class="literal">gtid_next</code>
        </p><a class="indexterm" name="idm46723651962544"></a><a class="indexterm" name="idm46723651961072"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for gtid_next"><col style="width=30%"><col style="width=70%"><tbody><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_gtid_next">gtid_next</a></code></td>
</tr><tr><th>スコープ</th>
<td>セッション</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">AUTOMATIC</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">AUTOMATIC</code></p><p class="valid-value"><code class="literal">ANONYMOUS</code></p><p class="valid-value"><code class="literal">UUID:NUMBER</code></p></td>
</tr></tbody></table></div><p>
          この変数は、次の GTID を取得するかどうかとその取得方法を指定するために使用されます。
        </p><p>
          このシステム変数のセッション値の設定は制限された操作です。 セッションユーザーには、<code class="literal">REPLICATION_APPLIER</code> 権限 (<a class="xref" href="replication.html#replication-privilege-checks" title="17.3.3 レプリケーション権限チェック">セクション17.3.3「レプリケーション権限チェック」</a> を参照) または制限付きセッション変数の設定に十分な権限 (<a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a> を参照) が必要です。 
        </p><p>
          <code class="literal">gtid_next</code> では、次のいずれかの値を使用できます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">AUTOMATIC</code>: 自動的に生成される次のグローバルトランザクション ID を使用します。
            </p></li><li class="listitem"><p>
              <code class="literal">ANONYMOUS</code>: トランザクションはグローバル識別子を持たず、ファイルと位置のみで識別されます。
            </p></li><li class="listitem"><p>
              <em class="replaceable"><code>UUID</code></em>:<em class="replaceable"><code>NUMBER</code></em> 形式のグローバルトランザクション ID。
            </p></li></ul></div><p>
          前述のどのオプションが有効かは、<code class="literal">gtid_mode</code> の設定によって異なります。詳細は、<a class="xref" href="replication.html#replication-mode-change-online-concepts" title="17.1.4.1 レプリケーションモードの概念">セクション17.1.4.1「レプリケーションモードの概念」</a> を参照してください。 <code class="literal">gtid_mode</code> が <code class="literal">OFF</code> の場合、この変数を設定しても効果はありません。 
        </p><p>
          この変数が <em class="replaceable"><code>UUID</code></em> に設定された後:<em class="replaceable"><code>NUMBER</code></em> では、トランザクションがコミットまたはロールバックされている場合、他のステートメントの前に明示的な <code class="literal">SET GTID_NEXT</code> ステートメントを再発行する必要があります。
        </p><p>
          <code class="literal">DROP TABLE</code> または <code class="literal">DROP TEMPORARY TABLE</code> は、非一時テーブルと一時テーブルの組み合わせ、または非トランザクションストレージエンジンを使用する一時テーブルとトランザクションストレージエンジンを使用する一時テーブルの組み合わせで使用すると、明示的なエラーで失敗します。
        </p></li><li class="listitem"><p><a name="sysvar_gtid_owned"></a>
          <code class="literal">gtid_owned</code>
        </p><a class="indexterm" name="idm46723651913824"></a><a class="indexterm" name="idm46723651912352"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for gtid_owned"><col style="width=30%"><col style="width=70%"><tbody><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_gtid_owned">gtid_owned</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル、セッション</td>
</tr><tr><th>動的</th>
<td>いいえ</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr><tr><th>単位</th>
<td><code class="literal">set of GTIDs</code></td>
</tr></tbody></table></div><p>
          この読取り専用変数は、主に内部で使用されます。 その内容はスコープによって異なります。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              グローバルスコープで使用される場合、<code class="literal">gtid_owned</code> は、サーバーで現在使用されているすべての GTID のリストを、それらを所有するスレッドの ID とともに保持します。 この変数は主に、マルチスレッドレプリカがトランザクションがすでに別のスレッドに適用されているかどうかをチェックする場合に役立ちます。 アプライヤスレッドは、トランザクションを処理している間は常にトランザクション GTID の所有権を取得するため、<code class="literal">@@global.gtid_owned</code> には処理中の GTID と所有者が表示されます。 トランザクションがコミット (またはロールバック) されると、適用者スレッドは GTID の所有権を解放します。 
            </p></li><li class="listitem"><p>
              セッションスコープとともに使用された場合、<code class="literal">gtid_owned</code> は、このセッションによって現在使用されており、所有されている単一の GTID を保持します。 この変数は主に、クライアントが <code class="literal">gtid_next</code> を設定してトランザクションに GTID を明示的に割り当てたときに GTID の使用をテストおよびデバッグする場合に役立ちます。 この場合、<code class="literal">@@session.gtid_owned</code> は、トランザクションがコミット (またはロールバック) されるまで、クライアントがトランザクションを処理している間は常に GTID を表示します。 クライアントがトランザクションの処理を終了すると、変数はクリアされます。 セッションに <code class="literal">gtid_next=AUTOMATIC</code> が使用されている場合、<code class="literal">gtid_owned</code> はトランザクションのコミットステートメントの実行中に短時間のみ移入されるため、適切な時点で<code class="literal">@@global.gtid_owned</code> が読み取られるかどうかはリストされますが、対象のセッションからは監視できません。 セッションでクライアントによって処理される GTID を追跡する必要がある場合は、<code class="literal">session_track_gtids</code> システム変数によって制御されるセッション状態トラッカを有効にできます。 
            </p></li></ul></div></li><li class="listitem"><p><a name="sysvar_gtid_purged"></a>
          <code class="literal">gtid_purged</code>
        </p><a class="indexterm" name="idm46723651876368"></a><a class="indexterm" name="idm46723651874848"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for gtid_purged"><col style="width=30%"><col style="width=70%"><tbody><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="replication.html#sysvar_gtid_purged">gtid_purged</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr><tr><th>単位</th>
<td><code class="literal">set of GTIDs</code></td>
</tr></tbody></table></div><p>
          <code class="literal">gtid_purged</code> システム変数 (<code class="literal">@@GLOBAL.gtid_purged</code>) のグローバル値は GTID セットで、サーバー上でコミットされたが、サーバー上のバイナリログファイルには存在しないすべてのトランザクションの GTID で構成されます。<code class="literal">gtid_purged</code> は、<code class="literal">gtid_executed</code> のサブセットです。 GTID の次のカテゴリが <code class="literal">gtid_purged</code> にあります: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              レプリカでバイナリロギングを無効にしてコミットされたレプリケートされたトランザクションの GTID。
            </p></li><li class="listitem"><p>
              現在パージされているバイナリログファイルに書き込まれたトランザクションの GTID。
            </p></li><li class="listitem"><p>
              ステートメント <code class="literal">SET @@GLOBAL.gtid_purged</code> によってセットに明示的に追加された GTID。
            </p></li></ul></div><p>
          サーバーが起動すると、<code class="literal">gtid_purged</code> のグローバル値は GTID のセットに初期化されます。 この GTID セットの計算方法については、<a class="xref" href="replication.html#replication-gtids-gtid-purged" title="gtid_purged システム変数"><code class="literal">gtid_purged</code> システム変数</a> を参照してください。 MySQL 5.7.7 以前のバイナリログがサーバーに存在する場合は、サーバー構成ファイルで <code class="literal">binlog_gtid_simple_recovery=FALSE</code> を設定して、正しい計算を生成する必要がある場合があります。 この設定が必要な状況の詳細は、<code class="literal">binlog_gtid_simple_recovery</code> の説明を参照してください。 
        </p><p>
          <code class="literal">RESET MASTER</code> を発行すると、<code class="literal">gtid_purged</code> の値が空の文字列にリセットされます。
        </p><p>
          特定の GTID セット内のトランザクションが適用されたことをサーバーに記録するために、<code class="literal">gtid_purged</code> の値を設定できますが、それらはサーバー上のバイナリログには存在しません。 このアクションのユースケースの例は、サーバー上の 1 つ以上のデータベースのバックアップをリストアするが、サーバー上のトランザクションを含む関連するバイナリログがない場合です。 
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
            GTID は、符号付き 64 ビット整数 (2 から 63 の累乗から 1 を引いた数) の負でない値までのサーバーインスタンスでのみ使用できます。 <code class="literal">gtid_purged</code> の値をこの制限に近づく数に設定すると、後続のコミットによってサーバーで GTID が不足し、<code class="literal">binlog_error_action</code> で指定されたアクションが実行される可能性があります。 MySQL 8.0.23 からは、サーバーインスタンスが制限に近づいたときに警告メッセージが発行されます。 
          </p></div><p>
          MySQL 8.0 からは、<code class="literal">gtid_purged</code> の値を設定する方法が 2 つあります。 <code class="literal">gtid_purged</code> の値を指定した GTID セットに置き換えるか、<code class="literal">gtid_purged</code> によってすでに保持されている GTID セットに指定した GTID セットを追加できます。 サーバーに既存の GTID がない場合 (たとえば、既存のデータベースのバックアップをプロビジョニングする空のサーバーがある場合)、両方の方法で同じ結果が得られます。 サーバー上にすでに存在するトランザクションと重複するバックアップを復元する場合、たとえば、破損したテーブルを <span class="command"><strong>mysqldump</strong></span> を使用して作成されたソースからの部分的なダンプで置き換える場合 (ダンプが部分的であっても、サーバー上のすべてのトランザクションの GTID を含む)、<code class="literal">gtid_purged</code> の値を置き換える最初の方法を使用します。 サーバー上にすでに存在するトランザクションとは無関係なバックアップをリストアする場合 (たとえば、2 つの異なるサーバーからのダンプを使用してマルチソースレプリカをプロビジョニングする場合)、<code class="literal">gtid_purged</code> の値に追加する別の方法を使用します。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">gtid_purged</code> の値を指定した GTID セットに置き換えるには、次のステートメントを使用します:
            </p><pre class="programlisting">SET @@GLOBAL.gtid_purged = 'gtid_set'</pre><p>
              <code class="literal">gtid_set</code> は、<code class="literal">gtid_purged</code> の現在の値のスーパーセットである必要があり、<code class="literal">gtid_subtract(gtid_executed,gtid_purged)</code> と交差していてはなりません。 つまり、新しい GTID セットには、<code class="literal">gtid_purged</code> にすでに存在する GTID が含まれている必要があり、まだパージされていない GTID を <code class="literal">gtid_executed</code> に含めることはできません。<code class="literal">gtid_set</code> には、<code class="literal">@@global.gtid_owned</code> にある GTID、つまりサーバーで現在処理されているトランザクションの GTID も含めることができません。 
            </p><p>
              その結果、<code class="literal">gtid_purged</code> のグローバル値は <code class="literal">gtid_set</code> に設定され、<code class="literal">gtid_executed</code> の値は <code class="literal">gtid_set</code> と <code class="literal">gtid_executed</code> の以前の値の和集合になります。
            </p></li><li class="listitem"><p>
              指定した GTID セットを <code class="literal">gtid_purged</code> に追加するには、GTID セットの前にプラス記号 (+) を付けて次のステートメントを使用します:
            </p><pre class="programlisting">SET @@GLOBAL.gtid_purged = '+gtid_set'</pre><p>
              <code class="literal">gtid_set</code> は、<code class="literal">gtid_executed</code> の現在の値と交差できません。 つまり、新しい GTID セットには、<code class="literal">gtid_purged</code> にもすでに存在するトランザクションを含め、<code class="literal">gtid_executed</code> の GTID を含めないでください。<code class="literal">gtid_set</code> には、<code class="literal">@@global.gtid_owned</code> にある GTID、つまりサーバーで現在処理されているトランザクションの GTID も含めることができません。 
            </p><p>
              その結果、<code class="literal">gtid_set</code> が <code class="literal">gtid_executed</code> と <code class="literal">gtid_purged</code> の両方に追加されます。
            </p></li></ul></div></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        MySQL 5.7.7 以前のバイナリログがサーバーに存在する場合 (たとえば、古いサーバーから MySQL 8.0 へのアップグレード後)、<code class="literal">SET @@GLOBAL.gtid_purged</code> ステートメントの発行後、サーバーを再起動する前にサーバー構成ファイルで <code class="literal">binlog_gtid_simple_recovery=FALSE</code> を設定する必要がある場合があります。そうしないと、<code class="literal">gtid_purged</code> が正しく計算されない可能性があります。 この設定が必要な状況の詳細は、<code class="literal">binlog_gtid_simple_recovery</code> の説明を参照してください。 
      </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-administration"></a>17.1.7 一般的なレプリケーション管理タスク</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-administration-status">17.1.7.1 レプリケーションステータスの確認</a></span></dt><dt><span class="section"><a href="replication.html#replication-administration-pausing">17.1.7.2 レプリカでのレプリケーションの一時停止</a></span></dt><dt><span class="section"><a href="replication.html#replication-administration-skip">17.1.7.3 トランザクションのスキップ</a></span></dt></dl></div><p>
      レプリケーションが開始されると、定期的に管理しなくても実行されます。 このセクションでは、レプリケーションのステータスを確認する方法、レプリカを一時停止する方法、およびレプリカで失敗したトランザクションをスキップする方法について説明します。 
    </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">ヒント</div><p>
        MySQL の複数のインスタンスをデプロイするには、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/" target="_top">MySQL Shell</a> で MySQL サーバーインスタンスのグループを簡単に管理できるようにする <a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-innodb-cluster.html" target="_top">InnoDB クラスタ</a> を使用できます。InnoDB クラスタ は MySQL Group Replication をプログラム環境でラップするため、MySQL インスタンスのクラスタを簡単にデプロイして高可用性を実現できます。 また、InnoDB クラスタ は <a class="ulink" href="https://dev.mysql.com/doc/mysql-router/8.0/en/" target="_top">MySQL Router</a> とシームレスにインタフェースするため、アプリケーションは独自のフェイルオーバープロセスを記述せずにクラスタに接続できます。 ただし、高可用性を必要としない同様のユースケースでは、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-innodb-replicaset.html" target="_top">InnoDB ReplicaSet</a> を使用できます。 MySQL Shell のインストール手順は、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-shell-install.html" target="_top">here</a> にあります。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-administration-status"></a>17.1.7.1 レプリケーションステータスの確認</h4></div></div></div><p>
        レプリケーションプロセスを管理する場合の最も一般的なタスクは、レプリケーションが実行され、レプリカとソースの間にエラーがないことを確認することです。
      </p><p>
        各レプリカで実行する必要がある <code class="literal">SHOW REPLICA | SLAVE STATUS</code> ステートメントは、レプリカサーバーとソースサーバー間の接続の構成およびステータスに関する情報を提供します。 MySQL 8.0.22 から、<code class="literal">SHOW SLAVE STATUS</code> は非推奨になり、かわりに <code class="literal">SHOW REPLICA STATUS</code> を使用できます。 パフォーマンススキーマには、この情報をよりアクセスしやすい形式で提供するレプリケーションテーブルがあります。 <a class="xref" href="performance-schema.html#performance-schema-replication-tables" title="27.12.11 パフォーマンススキーマレプリケーションテーブル">セクション27.12.11「パフォーマンススキーマレプリケーションテーブル」</a>を参照してください。 
      </p><p>
        パフォーマンススキーマレプリケーションテーブルに表示されるレプリケーションハートビート情報を使用すると、ソースが最近レプリカにイベントを送信していない場合でも、レプリケーション接続がアクティブであることを確認できます。 ソースは、ハートビート間隔より長い期間バイナリログに更新がなく、未送信のイベントがない場合に、ハートビートシグナルをレプリカに送信します。 (<code class="literal">CHANGE MASTER TO</code> ステートメントで設定された) ソースの <code class="literal">MASTER_HEARTBEAT_PERIOD</code> 設定では、ハートビートの頻度を指定します。これは、レプリカ (<code class="literal">slave_net_timeout</code>) の接続タイムアウト間隔の半分にデフォルト設定されます。 <code class="literal">replication_connection_status</code>「パフォーマンススキーマ」テーブルには、レプリカが最新のハートビートシグナルをいつ受信したか、および受信したハートビートシグナルの数が表示されます。 
      </p><p>
        <code class="literal">SHOW REPLICA | SLAVE STATUS</code> ステートメントを使用して個々のレプリカのステータスを確認している場合、ステートメントは次の情報を提供します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW REPLICA STATUS\G</code></strong>
*************************** 1. row ***************************
             Replica_IO_State: Waiting for master to send event
                  Source_Host: source1
                  Source_User: root
                  Source_Port: 3306
                Connect_Retry: 60
              Source_Log_File: mysql-bin.000004
          Read_Source_Log_Pos: 931
               Relay_Log_File: replica1-relay-bin.000056
                Relay_Log_Pos: 950
        Relay_Source_Log_File: mysql-bin.000004
           Replica_IO_Running: Yes
          Replica_SQL_Running: Yes
              Replicate_Do_DB:
          Replicate_Ignore_DB:
           Replicate_Do_Table:
       Replicate_Ignore_Table:
      Replicate_Wild_Do_Table:
  Replicate_Wild_Ignore_Table:
                   Last_Errno: 0
                   Last_Error:
                 Skip_Counter: 0
          Exec_Source_Log_Pos: 931
              Relay_Log_Space: 1365
              Until_Condition: None
               Until_Log_File:
                Until_Log_Pos: 0
           Source_SSL_Allowed: No
           Source_SSL_CA_File:
           Source_SSL_CA_Path:
              Source_SSL_Cert:
            Source_SSL_Cipher:
               Source_SSL_Key:
        Seconds_Behind_Source: 0
Source_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error:
               Last_SQL_Errno: 0
               Last_SQL_Error:
  Replicate_Ignore_Server_Ids: 0
</pre><p>
        ステータスレポートの中で調査すべき主要フィールドは、次のとおりです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Replica_IO_State</code>: レプリカの現在のステータス。 詳細は、<a class="xref" href="optimization.html#replica-io-thread-states" title="8.14.5 レプリケーション I/O スレッドの状態">セクション8.14.5「レプリケーション I/O スレッドの状態」</a>および<a class="xref" href="optimization.html#replica-sql-thread-states" title="8.14.6 レプリケーション SQL スレッドの状態">セクション8.14.6「レプリケーション SQL スレッドの状態」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">Replica_IO_Running</code>: ソースバイナリログを読み取るための I/O スレッドが実行されているかどうか。 通常、レプリケーションをまだ開始していないか、<code class="literal">STOP REPLICA | SLAVE</code> で明示的に停止していないかぎり、これを <code class="literal">Yes</code> にします。 
          </p></li><li class="listitem"><p>
            <code class="literal">Replica_SQL_Running</code>: リレーログ内のイベントを実行するための SQL スレッドが実行中かどうか。 I/O スレッドと同様、これは通常は <code class="literal">Yes</code> にすることをお勧めします。 
          </p></li><li class="listitem"><p>
            <code class="literal">Last_IO_Error</code>、<code class="literal">Last_SQL_Error</code>: リレーログを処理するときに I/O および SQL スレッドによって登録された最後のエラー。 理想的には、これらはエラーがないことを示すブランクであるべきです。 
          </p></li><li class="listitem"><p>
            <code class="literal">Seconds_Behind_Source</code>: レプリケーション SQL スレッドがソースバイナリログの処理を遅れている秒数。 高い数値 (または増加する数値) は、レプリカがソースからのイベントを適時に処理できないことを示します。 
          </p><p>
            <code class="literal">Seconds_Behind_Source</code> の値 0 は通常、レプリカがソースに追いついたことを意味するものとして解釈できますが、厳密には true でない場合もあります。 たとえば、これは、ソースとレプリカの間のネットワーク接続が切断されたが、レプリケーション I/O スレッドがまだこれに気付いていない (<code class="literal">slave_net_timeout</code> がまだ経過していない) 場合に発生することがあります。 
          </p><p>
            <code class="literal">Seconds_Behind_Source</code> の一時的な値が状況を正確に反映しない場合もあります。 レプリケーション SQL スレッドが I/O, <code class="literal">Seconds_Behind_Source</code> でキャッチアップされると 0 が表示されますが、レプリケーション I/O スレッドがまだ新しいイベントをキューに入れている場合、レプリケーション SQL スレッドが新しいイベントの実行を終了するまで、<code class="literal">Seconds_Behind_Source</code> に大きな値が表示されることがあります。 これは、イベントに古いタイムスタンプがある場合に特に発生する可能性があります。このような場合、比較的短い期間に <code class="literal">SHOW REPLICA | SLAVE STATUS</code> を複数回実行すると、この値が 0 から比較的大きい値まで繰り返し変更されることがあります。 
          </p></li></ul></div><p>
        フィールドのいくつかのペアは、ソースバイナリログからイベントを読み取り、リレーログでそれらを処理する際のレプリカの進行状況に関する情報を提供します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            (<code class="literal">Master_Log_file</code>, <code class="literal">Read_Master_Log_Pos</code>): レプリケーション I/O スレッドがそのログからイベントを読み取る距離を示す、ソースバイナリログ内の座標。
          </p></li><li class="listitem"><p>
            (<code class="literal">Relay_Master_Log_File</code>, <code class="literal">Exec_Master_Log_Pos</code>): レプリケーション SQL スレッドがそのログから受信したイベントを実行した距離を示すソースバイナリログ内の座標。
          </p></li><li class="listitem"><p>
            (<code class="literal">Relay_Log_File</code>, <code class="literal">Relay_Log_Pos</code>): レプリケーション SQL スレッドがリレーログを実行した距離を示すレプリカリレーログ内の座標。 これらは前述の座標に対応していますが、ソースバイナリログ座標ではなくレプリカリレーログ座標で表されます。 
          </p></li></ul></div><p>
        ソースでは、<code class="literal">SHOW PROCESSLIST</code> を使用して接続レプリカのステータスを確認し、実行中のプロセスのリストを調べることができます。 レプリカ接続では、<code class="literal">Command</code> フィールドに <code class="literal">Binlog Dump</code> があります: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW PROCESSLIST \G;</code></strong>
*************************** 4. row ***************************
     Id: 10
   User: root
   Host: replica1:58371
     db: NULL
Command: Binlog Dump
   Time: 777
  State: Has sent all binlog to slave; waiting for binlog to be updated
   Info: NULL
</pre><p>
        これはレプリケーションプロセスを駆動するレプリカであるため、このレポートで使用できる情報はほとんどありません。
      </p><p>
        <code class="option">--report-host</code> オプションで開始され、ソースに接続されているレプリカの場合、ソースの <code class="literal">SHOW REPLICAS | SHOW SLAVE HOSTS</code> ステートメントにレプリカに関する基本情報が表示されます。 出力には、レプリカサーバーの ID、<code class="option">--report-host</code> オプションの値、接続ポートおよびソース ID が含まれます: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW REPLICAS;</code></strong>
+-----------+----------+------+-------------------+-----------+
| Server_id | Host     | Port | Rpl_recovery_rank | Source_id |
+-----------+----------+------+-------------------+-----------+
|        10 | replica1 | 3306 |                 0 |         1 |
+-----------+----------+------+-------------------+-----------+
1 row in set (0.00 sec)
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-administration-pausing"></a>17.1.7.2 レプリカでのレプリケーションの一時停止</h4></div></div></div><p>
        <code class="literal">STOP REPLICA | SLAVE</code> および <code class="literal">START REPLICA | SLAVE</code> ステートメントを使用して、レプリカのレプリケーションを停止および開始できます。 MySQL 8.0.22 から、<code class="literal">STOP SLAVE</code> および <code class="literal">START SLAVE</code> は非推奨になり、<code class="literal">STOP REPLICA</code> および <code class="literal">START REPLICA</code> をかわりに使用できます。 
      </p><p>
        ソースからのバイナリログの処理を停止するには、<code class="literal">STOP REPLICA | SLAVE</code> を使用します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>STOP SLAVE;</code></strong>
Or from MySQL 8.0.22:
mysql&gt; <strong class="userinput"><code>STOP REPLICA;</code></strong>
</pre><p>
        レプリケーションが停止すると、レプリケーション I/O スレッドはソースバイナリログからのイベントの読み取りとリレーログへの書き込みを停止し、SQL スレッドはリレーログからのイベントの読み取りと実行を停止します。 スレッドタイプを指定することで、I/O または SQL スレッドを個別に一時停止できます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>STOP SLAVE IO_THREAD;</code></strong>
mysql&gt; <strong class="userinput"><code>STOP SLAVE SQL_THREAD;</code></strong>
Or from MySQL 8.0.22:
mysql&gt; <strong class="userinput"><code>STOP REPLICA IO_THREAD;</code></strong>
mysql&gt; <strong class="userinput"><code>STOP REPLICA SQL_THREAD;</code></strong>
</pre><p>
        実行を再開するには、<code class="literal">START REPLICA | SLAVE</code> ステートメントを使用します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>START SLAVE;</code></strong>
Or from MySQL 8.0.22:
mysql&gt; <strong class="userinput"><code>START REPLICA;</code></strong>
</pre><p>
        特定のスレッドを開始するには、スレッドタイプを指定します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>START SLAVE IO_THREAD;</code></strong>
mysql&gt; <strong class="userinput"><code>START SLAVE SQL_THREAD;</code></strong>
Or from MySQL 8.0.22:
mysql&gt; <strong class="userinput"><code>START REPLICA IO_THREAD;</code></strong>
mysql&gt; <strong class="userinput"><code>START REPLICA SQL_THREAD;</code></strong>
</pre><p>
        ソースからのイベントを処理することによってのみ更新を実行するレプリカの場合、SQL スレッドのみを停止すると、バックアップまたはその他のタスクを実行する場合に役立ちます。 I/O スレッドはソースからのイベントの読取りを続行しますが、実行されません。 これにより、SQL スレッドの再起動時にレプリカが捕捉されやすくなります。 
      </p><p>
        I/O スレッドだけを停止することで、SQL スレッドはリレーログが終了したポイントまでリレーログ内のイベントを実行できます。 これは、ソースからすでに受信したイベントを捕捉するために実行を一時停止する場合、レプリカで管理を実行するが、特定のポイントへのすべての更新が処理されていることを確認する場合に役立ちます。 この方法を使用して、ソースでの管理を実行しながら、レプリカでのイベント受信を一時停止することもできます。 I/O スレッドは停止するけれども SQL スレッドの実行を許可することで、レプリケーションが再開したときに実行される大量のイベントバックログを確実になくすのに役立ちます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-administration-skip"></a>17.1.7.3 トランザクションのスキップ</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-administration-skip-gtid">17.1.7.3.1 GTID のあるトランザクションのスキップ</a></span></dt><dt><span class="section"><a href="replication.html#replication-administration-skip-nogtid">17.1.7.3.2 GTID のないトランザクションのスキップ</a></span></dt></dl></div><p>
        レプリケートされたトランザクションのイベントの問題が原因でレプリケーションが停止した場合は、レプリカで失敗したトランザクションをスキップしてレプリケーションを再開できます。 トランザクションをスキップする前に、レプリケーション I/O スレッドと SQL スレッドが停止していることを確認します。 
      </p><p>
        まず、エラーの原因となったレプリケートイベントを特定する必要があります。 エラーの詳細および最後に正常に適用されたトランザクションは、「パフォーマンススキーマ」テーブル <code class="literal">replication_applier_status_by_worker</code> に記録されます。 <span class="command"><strong>mysqlbinlog</strong></span> を使用して、エラー発生時にログに記録されたイベントを取得して表示できます。 これを行う手順は、<a class="xref" href="backup-and-recovery.html#point-in-time-recovery" title="7.5 Point-in-Time (増分) リカバリ">セクション7.5「Point-in-Time (増分) リカバリ」</a> を参照してください。 または、レプリカまたはソース上の <code class="literal">SHOW BINLOG EVENTS</code> で <code class="literal">SHOW RELAYLOG EVENTS</code> を発行できます。 
      </p><p>
        トランザクションをスキップしてレプリカを再起動する前に、次の点を確認します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            不明または信頼できないソースからのレプリケーションを停止したトランザクションですか。 その場合は、レプリカを再起動しないことを示すセキュリティ上の考慮事項がある場合に、原因を調査します。 
          </p></li><li class="listitem"><p>
            レプリケーションを停止したトランザクションをレプリカに適用する必要がありますか。 その場合は、適切な修正を行ってトランザクションを再適用するか、レプリカ上のデータを手動で調整します。 
          </p></li><li class="listitem"><p>
            レプリケーションを停止したトランザクションをソースに適用する必要がありましたか。 そうでない場合は、最初に実行されたサーバーでトランザクションを手動で元に戻します。 
          </p></li></ul></div><p>
        トランザクションをスキップするには、必要に応じて次のいずれかの方法を選択します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            GTID が使用中 (<code class="literal">gtid_mode</code> が <code class="literal">ON</code>) の場合は、<a class="xref" href="replication.html#replication-administration-skip-gtid" title="17.1.7.3.1 GTID のあるトランザクションのスキップ">セクション17.1.7.3.1「GTID のあるトランザクションのスキップ」</a> を参照してください。
          </p></li><li class="listitem"><p>
            GTID が使用されていないか、段階的に導入されている (<code class="literal">gtid_mode</code> が <code class="literal">OFF</code>、<code class="literal">OFF_PERMISSIVE</code> または <code class="literal">ON_PERMISSIVE</code>) 場合は、<a class="xref" href="replication.html#replication-administration-skip-nogtid" title="17.1.7.3.2 GTID のないトランザクションのスキップ">セクション17.1.7.3.2「GTID のないトランザクションのスキップ」</a> を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントの <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> オプションを使用してレプリケーションチャネルで GTID 割り当てを有効にした場合は、<a class="xref" href="replication.html#replication-administration-skip-nogtid" title="17.1.7.3.2 GTID のないトランザクションのスキップ">セクション17.1.7.3.2「GTID のないトランザクションのスキップ」</a> を参照してください。 レプリケーションチャネルで <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> を使用することは、チャネルに GTID ベースのレプリケーションを導入することとは異なり、GTID ベースのレプリケーションではそれらのチャネルでトランザクションスキップ方法を使用できません。 
          </p></li></ul></div><p>
        トランザクションのスキップ後にレプリケーションを再開するには、レプリカがマルチソースレプリカの場合は、<code class="literal">FOR CHANNEL</code> 句を指定して <code class="literal">START REPLICA | SLAVE</code> を発行します。
      </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="replication-administration-skip-gtid"></a>17.1.7.3.1 GTID のあるトランザクションのスキップ</h5></div></div></div><p>
          GTID が使用されている場合 (<code class="literal">gtid_mode</code> が <code class="literal">ON</code>)、コミットされたトランザクションの GTID は、トランザクションの内容がフィルタで除外されてもレプリカに保持されます。 この機能により、GTID 自動配置を使用してソースに再接続したときに、レプリカが以前にフィルタ処理されたトランザクションを取得できなくなります。 また、障害が発生したトランザクションのかわりに空のトランザクションをコミットすることで、レプリカ上のトランザクションをスキップするためにも使用できます。 
        </p><p>
          このトランザクションのスキップ方法は、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントの <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> オプションを使用してレプリケーションチャネルで GTID 割当てを有効にした場合には適していません。
        </p><p>
          失敗したトランザクションによってワーカースレッドでエラーが生成された場合は、「パフォーマンススキーマ」テーブル <code class="literal">replication_applier_status_by_worker</code> の <code class="literal">LAST_SEEN_TRANSACTION</code> フィールドから GTID を直接取得できます。 トランザクションの内容を確認するには、レプリカまたはソース上の <code class="literal">SHOW BINLOG EVENTS</code> で <code class="literal">SHOW RELAYLOG EVENTS</code> を発行し、その GTID で始まるトランザクションの出力を検索します。 
        </p><p>
          前述の他の適切なアクション (セキュリティ上の考慮事項など) の失敗したトランザクションを評価した場合、スキップするには、失敗したトランザクションと同じ GTID を持つレプリカで空のトランザクションをコミットします。 例: 
        </p><pre class="programlisting">SET GTID_NEXT='aaa-bbb-ccc-ddd:N';
BEGIN;
COMMIT;
SET GTID_NEXT='AUTOMATIC';
</pre><p>
          レプリカ上にこの空のトランザクションが存在するということは、レプリケーションを再開するために <code class="literal">START REPLICA | SLAVE</code> ステートメントを発行すると、その GTID を持つトランザクションがすでに適用されていることがわかっているため、レプリカは自動スキップ機能を使用して失敗したトランザクションを無視することを意味します。 レプリカがマルチソースレプリカの場合、空のトランザクションのコミット時にチャネル名を指定する必要はありませんが、<code class="literal">START REPLICA | SLAVE</code> の発行時にチャネル名を指定する必要があります。 
        </p><p>
          バイナリロギングがこのレプリカで使用されている場合、レプリカが将来ソースまたはプライマリになると、空のトランザクションがレプリケーションストリームに入ります。 この可能性を回避する必要がある場合は、次の例のようにレプリカバイナリログをフラッシュおよびパージすることを検討してください: 
        </p><pre class="programlisting">FLUSH LOGS;
PURGE BINARY LOGS TO 'binlog.000146';
</pre><p>
          空のトランザクションの GTID は永続化されますが、トランザクション自体はバイナリログファイルをパージすることによって削除されます。
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="replication-administration-skip-nogtid"></a>17.1.7.3.2 GTID のないトランザクションのスキップ</h5></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#set-global-replica-sql-skip-counter">17.1.7.3.2.1 <code class="literal">SET GLOBAL sql_slave_skip_counter</code> でのトランザクションのスキップ</a></span></dt><dt><span class="section"><a href="replication.html#replication-administration-skip-change-master-to">17.1.7.3.2.2 <code class="literal">CHANGE MASTER TO</code> でのトランザクションのスキップ</a></span></dt></dl></div><p>
          GTID が使用されていないか、段階的に導入されている (<code class="literal">gtid_mode</code> が <code class="literal">OFF</code>、<code class="literal">OFF_PERMISSIVE</code> または <code class="literal">ON_PERMISSIVE</code>) 場合に失敗したトランザクションをスキップするには、<code class="literal">SET GLOBAL sql_slave_skip_counter</code> ステートメントを発行して、指定した数のイベントをスキップできます。 または、<code class="literal">CHANGE MASTER TO</code> ステートメントを発行してソースバイナリログの位置を前方に移動することによって、イベントを過ぎてスキップすることもできます。 
        </p><p>
          これらの方法は、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントの <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> オプションを使用してレプリケーションチャネルで GTID 割当てを有効にした場合にも適しています。
        </p><p>
          これらの方法を使用する場合は、前述の GTID ベースの方法の場合と同様に、完全なトランザクションをスキップする必要はないことを理解することが重要です。 GTID ベース以外のこれらの方法では、そのようなトランザクションは認識されませんが、かわりにイベントを操作します。 バイナリログはイベントグループと呼ばれる一連のグループとして編成され、各イベントグループは一連のイベントで構成されます。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              トランザクションテーブルの場合、イベントグループはトランザクションに対応しています。
            </p></li><li class="listitem"><p>
              非トランザクションテーブルの場合、イベントグループは 1 つの SQL ステートメントに対応しています。
            </p></li></ul></div><p>
          1 つのトランザクションに、トランザクションテーブルと非トランザクションテーブルの両方の変更を含めることができます。
        </p><p>
          <code class="literal">SET GLOBAL sql_slave_skip_counter</code> ステートメントを使用してイベントをスキップし、結果の位置がイベントグループの途中にある場合、レプリカはグループの最後に達するまでイベントをスキップし続けます。 そのあと、次のイベントグループから実行が開始されます。 <code class="literal">CHANGE MASTER TO</code> ステートメントにはこの機能がないため、イベントグループの開始時にレプリケーションを再開する正しい場所を特定するように注意する必要があります。 ただし、<code class="literal">CHANGE MASTER TO</code> を使用すると、<code class="literal">SET GLOBAL sql_slave_skip_counter</code> と同様にスキップする必要があるイベントをカウントする必要がなく、かわりに再起動する場所を指定できます。 
        </p><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="set-global-replica-sql-skip-counter"></a>17.1.7.3.2.1 <code class="literal">SET GLOBAL sql_slave_skip_counter</code> でのトランザクションのスキップ</h6></div></div></div><a class="indexterm" name="idm46723651617344"></a><a class="indexterm" name="idm46723651615968"></a><a class="indexterm" name="idm46723651614624"></a><a class="indexterm" name="idm46723651613136"></a><p>
            前述の他の適切なアクション (セキュリティ上の考慮事項など) の失敗したトランザクションを評価したら、スキップする必要があるイベントの数をカウントします。 あるイベントは通常、バイナリログ内の 1 つの SQL ステートメントに対応しますが、<code class="literal">AUTO_INCREMENT</code> または <code class="literal">LAST_INSERT_ID()</code> を使用するステートメントはバイナリログ内の 2 つのイベントとしてカウントされることに注意してください。 バイナリログのトランザクション圧縮が使用されている場合、圧縮されたトランザクションペイロード (<code class="literal">Transaction_payload_event</code>) は単一のカウンタ値としてカウントされるため、その内部のすべてのイベントは単位としてスキップされます。 
          </p><p>
            完了したトランザクションをスキップする場合は、イベントをトランザクションの最後までカウントすることも、関連するイベントグループをスキップすることもできます。 <code class="literal">SET GLOBAL sql_slave_skip_counter</code> では、レプリカはイベントグループの最後までスキップし続けることに注意してください。 スキップがスキップされないように、スキップして次のイベントグループまたはトランザクションに移動しないでください。 
          </p><p>
            次のように <code class="literal">SET</code> ステートメントを発行します。ここで、<em class="replaceable"><code>N</code></em> はスキップするソースからのイベント数です:
          </p><pre class="programlisting">SET GLOBAL sql_slave_skip_counter = <em class="replaceable"><code>N</code></em>
</pre><p>
            このステートメントは、<code class="literal">gtid_mode=ON</code> が設定されている場合、またはレプリケーション I/O および SQL スレッドが実行されている場合は発行できません。
          </p><p>
            <code class="literal">SET GLOBAL sql_slave_skip_counter</code> ステートメントはすぐには影響しません。 次の <code class="literal">SET</code> ステートメントの後に <code class="literal">START REPLICA | SLAVE</code> ステートメントを発行すると、システム変数 <code class="literal">sql_slave_skip_counter</code> の新しい値が適用され、イベントはスキップされます。 その <code class="literal">START REPLICA | SLAVE</code> ステートメントでは、システム変数の値も自動的に 0 に戻されます。 レプリカがマルチソースレプリカの場合は、その <code class="literal">START REPLICA | SLAVE</code> ステートメントを発行するときに <code class="literal">FOR CHANNEL</code> 句が必要です。 正しいチャネルを指定していることを確認してください。そうしないと、間違ったチャネルでイベントがスキップされます。 
          </p></div><div class="section"><div class="titlepage"><div><div><h6 class="title"><a name="replication-administration-skip-change-master-to"></a>17.1.7.3.2.2 <code class="literal">CHANGE MASTER TO</code> でのトランザクションのスキップ</h6></div></div></div><p>
            前述の他の適切なアクション (セキュリティ上の考慮事項など) の失敗したトランザクションを評価したら、レプリケーションを再開するための適切な位置を表すソースバイナリログ内の座標 (ファイルと位置) を特定します。 これは、問題の原因となったイベントの後のイベントグループの開始、または次のトランザクションの開始です。 レプリケーション I/O スレッドは、次にスレッドが起動したときに、これらの座標でソースからの読取りを開始し、失敗したイベントをスキップします。 このステートメントではイベントグループが考慮されないため、ポジションが正確に識別されていることを確認してください。 
          </p><p>
            次のように <code class="literal">CHANGE MASTER TO</code> ステートメントを発行します。ここで、<em class="replaceable"><code>source_log_name</code></em> は再起動位置を含むバイナリログファイル、<em class="replaceable"><code>source_log_pos</code></em> はバイナリログファイルに記述されている再起動位置を表す番号です:
          </p><pre class="programlisting">CHANGE MASTER TO MASTER_LOG_FILE='<em class="replaceable"><code>source_log_name</code></em>', MASTER_LOG_POS=<em class="replaceable"><code>source_log_pos</code></em>;
</pre><p>
            レプリカがマルチソースレプリカの場合は、<code class="literal">FOR CHANNEL</code> 句を使用して <code class="literal">CHANGE MASTER TO</code> ステートメントの適切なチャネルに名前を付ける必要があります。
          </p><p>
            このステートメントは、<code class="literal">MASTER_AUTO_POSITION=1</code> が設定されている場合、またはレプリケーション I/O および SQL スレッドが実行されている場合は発行できません。 <code class="literal">MASTER_AUTO_POSITION=1</code> が通常設定されているときにトランザクションをスキップするこの方法を使用する必要がある場合は、ステートメントの発行中に設定を <code class="literal">MASTER_AUTO_POSITION=1</code> に変更してから、変更しなおすことができます。 例: 
          </p><pre class="programlisting">CHANGE MASTER TO MASTER_AUTO_POSITION=0, MASTER_LOG_FILE='binlog.000145', MASTER_LOG_POS=235;
CHANGE MASTER TO MASTER_AUTO_POSITION=1;
</pre></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="replication-implementation"></a>17.2 レプリケーションの実装</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-formats">17.2.1 レプリケーション形式</a></span></dt><dt><span class="section"><a href="replication.html#replication-channels">17.2.2 レプリケーションチャネル</a></span></dt><dt><span class="section"><a href="replication.html#replication-implementation-details">17.2.3 レプリケーションスレッド</a></span></dt><dt><span class="section"><a href="replication.html#replica-logs">17.2.4 リレーログおよびレプリケーションメタデータリポジトリ</a></span></dt><dt><span class="section"><a href="replication.html#replication-rules">17.2.5 サーバーがレプリケーションフィルタリングルールをどのように評価するか</a></span></dt></dl></div><a class="indexterm" name="idm46723651573952"></a><p>
    レプリケーションは、バイナリログ内のデータベースに対するすべての変更 (更新、削除など) を追跡するソースサーバーに基づいています。 バイナリログは、サーバーが起動した瞬間からデータベースの構造または内容 （データ） を変更するあらゆるイベントが書き込まれた記録として機能します。 <code class="literal">SELECT</code> ステートメントは通常、データベースの構造および内容を変更しないため記録されません。 
  </p><p>
    ソースに接続する各レプリカは、バイナリログのコピーを要求します。 つまり、ソースがレプリカにデータをプッシュするのではなく、ソースからデータをプルします。 レプリカは、受信したバイナリログからもイベントを実行します。 これは、元の変更をソースで行ったときと同じように繰り返す効果があります。 テーブルが作成されるか、その構造が変更され、元のソースで行われた変更に従ってデータが挿入、削除および更新されます。 
  </p><p>
    各レプリカは独立しているため、ソースバイナリログからの変更のリプレイは、ソースに接続されている各レプリカで独立して行われます。 また、各レプリカはソースからのリクエストによってのみバイナリログのコピーを受信するため、レプリカは独自のペースでデータベースのコピーを読み取って更新でき、ソース側またはレプリカ側の最新のデータベースステータスに更新する機能に影響を与えることなく、レプリケーションプロセスを任意に開始および停止できます。 
  </p><p>
    レプリケーション実装の仕様に関する詳細は、<a class="xref" href="replication.html#replication-implementation-details" title="17.2.3 レプリケーションスレッド">セクション17.2.3「レプリケーションスレッド」</a>を参照してください。
  </p><p>
    ソースサーバーおよびレプリカは、レプリケーションプロセスに関するステータスを定期的にレポートして、それらを監視できるようにします。 すべてのレプリケーション関連ステータスの説明については、<a class="xref" href="optimization.html#thread-information" title="8.14 サーバースレッド (プロセス) 情報の確認">セクション8.14「サーバースレッド (プロセス) 情報の確認」</a>を参照してください。 
  </p><p>
    ソースバイナリログは、レプリカが処理される前に、レプリカ上のローカルリレーログに書き込まれます。 また、レプリカは、現在の位置に関する情報をソースバイナリログおよびローカルリレーログとともに記録します。 <a class="xref" href="replication.html#replica-logs" title="17.2.4 リレーログおよびレプリケーションメタデータリポジトリ">セクション17.2.4「リレーログおよびレプリケーションメタデータリポジトリ」</a>を参照してください。 
  </p><p>
    データベースの変更は、イベント評価を制御する様々な構成オプションおよび変数に従って適用される一連のルールに従ってレプリカでフィルタ処理されます。 これらのルールがどのように適用されるかについての詳細は、<a class="xref" href="replication.html#replication-rules" title="17.2.5 サーバーがレプリケーションフィルタリングルールをどのように評価するか">セクション17.2.5「サーバーがレプリケーションフィルタリングルールをどのように評価するか」</a>を参照してください。 
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-formats"></a>17.2.1 レプリケーション形式</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-sbr-rbr">17.2.1.1 ステートメントベースおよび行ベースレプリケーションのメリットとデメリット</a></span></dt><dt><span class="section"><a href="replication.html#replication-rbr-usage">17.2.1.2 行ベースロギングおよびレプリケーションの使用</a></span></dt><dt><span class="section"><a href="replication.html#replication-rbr-safe-unsafe">17.2.1.3 バイナリロギングでの安全および安全でないステートメントの判断</a></span></dt></dl></div><p>
      レプリケーションは、バイナリログに書き込まれたイベントがソースから読み取られてからレプリカで処理されるため機能します。 イベントは、イベントタイプに従ってさまざまな形式でバイナリログに記録されます。 使用されるさまざまなレプリケーション形式は、イベントがソースバイナリログに記録されたときに使用されたバイナリロギング形式に対応します。 バイナリロギング形式とレプリケーションで使用される用語との関係は次のとおりです。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ステートメントベースのバイナリロギングを使用する場合、ソースは SQL ステートメントをバイナリログに書き込みます。 レプリカへのソースのレプリケーションは、レプリカで SQL ステートメントを実行することで機能します。 これは、MySQL ステートメントベースのバイナリロギング形式に対応する<span class="firstterm">ステートメントベースレプリケーション</span> (<span class="firstterm">SBR</span> と省略できます) と呼ばれます。 
        </p></li><li class="listitem"><p>
          行ベースのロギングを使用する場合、ソースは個々のテーブル行の変更方法を示す <span class="firstterm">events</span> をバイナリログに書き込みます。 レプリカへのソースのレプリケーションは、テーブルの行に対する変更を表すイベントをレプリカにコピーすることで機能します。 これは<span class="firstterm">行ベースのレプリケーション</span>と呼ばれます (<span class="firstterm">RBR</span> と省略できます)。 
        </p><p>
          デフォルトの方法は行ベースのロギングです。
        </p></li><li class="listitem"><p>
          変更ログが記録されるときにステートメントベースと行ベースのどちらが適しているかによって、これらのロギングの組み合わせを使用するように MySQL を構成することもできます。 これは<span class="firstterm">混合形式のロギング</span>と呼ばれます。 混合形式のロギングを使用する場合、デフォルトでステートメントベースのログが使用されます。 ステートメントに応じて、また使用されるストレージエンジンに応じて、ログは特定のケースで行ベースに自動的に切りかえられます。 混合形式を使用したレプリケーションは、<span class="firstterm">混合ベースのレプリケーション</span>または<span class="firstterm">混合形式のレプリケーション</span>と呼ばれます。 詳細については、<a class="xref" href="server-administration.html#binary-log-mixed" title="5.4.4.3 混合形式のバイナリロギング形式">セクション5.4.4.3「混合形式のバイナリロギング形式」</a>を参照してください。 
        </p></li></ul></div><p><b>NDB Cluster. </b>
        MySQL NDB Cluster 8.0 のデフォルトのバイナリロギング形式は <code class="literal">MIXED</code> です。 NDB Cluster レプリケーションは常に行ベースレプリケーションを使用し、<code class="literal">NDB</code> ストレージエンジンはステートメントベースレプリケーションと互換性がないことに注意してください。 詳細については、<a class="xref" href="mysql-cluster.html#mysql-cluster-replication-general" title="23.6.2 NDB Cluster レプリケーションの一般的な要件">セクション23.6.2「NDB Cluster レプリケーションの一般的な要件」</a>を参照してください。 
      </p><p>
      <code class="literal">混合</code>形式を使用する場合、バイナリロギング形式は、使用されているストレージエンジンと実行されているステートメントによってある程度決定されます。 混合形式のロギング、および異なるロギング形式のサポートを管理するルールの詳細は、<a class="xref" href="server-administration.html#binary-log-mixed" title="5.4.4.3 混合形式のバイナリロギング形式">セクション5.4.4.3「混合形式のバイナリロギング形式」</a>を参照してください。 
    </p><p>
      実行中 MySQL サーバーのロギング形式は、<code class="literal">binlog_format</code> サーバーシステム変数を設定することで制御されます。 この変数はセッションまたはグローバルスコープで設定できます。 新しい設定が有効になるタイミングと方法を制御するルールは、他の MySQL サーバーシステム変数の場合と同じです。 現在のセッションの変数の設定は、そのセッションが終了するまでのみ継続され、変更は他のセッションには表示されません。 変数をグローバルに設定すると、変更後に接続するクライアントに対して有効になりますが、変数設定が変更されたセッションを含む現在のクライアントセッションに対しては有効になりません。 グローバルシステム変数設定を永続的にしてサーバーの再起動後も適用されるようにするには、オプションファイルで設定する必要があります。 詳細は、<a class="xref" href="sql-statements.html#set-variable" title="13.7.6.1 変数代入の SET 構文">セクション13.7.6.1「変数代入の SET 構文」</a>を参照してください。 
    </p><p>
      実行時にバイナリロギング形式を変更できない、つまりそのようにするとレプリケーションが失敗する状況があります。 <a class="xref" href="server-administration.html#binary-log-setting" title="5.4.4.2 バイナリログ形式の設定">セクション5.4.4.2「バイナリログ形式の設定」</a>を参照してください。 
    </p><p>
      グローバル <code class="literal">binlog_format</code> 値を変更するには、グローバルシステム変数を設定するのに十分な権限が必要です。 セッションの <code class="literal">binlog_format</code> 値を変更するには、制限付きセッションシステム変数を設定するのに十分な権限が必要です。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 
    </p><p>
      ステートメントベースと行ベースのレプリケーション形式には、異なる問題と制限があります。 関連するメリットとデメリットの比較は、<a class="xref" href="replication.html#replication-sbr-rbr" title="17.2.1.1 ステートメントベースおよび行ベースレプリケーションのメリットとデメリット">セクション17.2.1.1「ステートメントベースおよび行ベースレプリケーションのメリットとデメリット」</a>を参照してください。 
    </p><p>
      ステートメントベースのレプリケーションでは、ストアドルーチンまたはトリガーの複製で問題が発生する場合があります。 代わりに行ベースのレプリケーションを使用することで、これらの問題を回避できます。 詳細については、<a class="xref" href="stored-objects.html#stored-programs-logging" title="25.7 ストアドプログラムバイナリロギング">セクション25.7「ストアドプログラムバイナリロギング」</a>を参照してください。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-sbr-rbr"></a>17.2.1.1 ステートメントベースおよび行ベースレプリケーションのメリットとデメリット</h4></div></div></div><a class="indexterm" name="idm46723651525328"></a><a class="indexterm" name="idm46723651523184"></a><p>
        それぞれのバイナリロギングの形式にメリットとデメリットがあります。 ほとんどのユーザーにとって、データの完全性とパフォーマンスの最善の組み合わせが得られるのは、混合レプリケーション形式であるはずです。 ただし、特定のタスクを実行するときにステートメントベースまたは行ベースレプリケーション形式固有の機能を利用する場合、関連するメリットとデメリットのサマリーを記述したこのセクションの情報を使用して、どちらがニーズに最適であるかを決めることができます。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="link" href="replication.html#replication-sbr-rbr-sbr-advantages" title="ステートメントベースレプリケーションのメリット">ステートメントベースレプリケーションのメリット</a>
          </p></li><li class="listitem"><p>
            <a class="link" href="replication.html#replication-sbr-rbr-sbr-disadvantages" title="ステートメントベースレプリケーションのデメリット">ステートメントベースレプリケーションのデメリット</a>
          </p></li><li class="listitem"><p>
            <a class="link" href="replication.html#replication-sbr-rbr-rbr-advantages" title="行ベースレプリケーションのメリット">行ベースレプリケーションのメリット</a>
          </p></li><li class="listitem"><p>
            <a class="link" href="replication.html#replication-sbr-rbr-rbr-disadvantages" title="行ベースレプリケーションのデメリット">行ベースレプリケーションのデメリット</a>
          </p></li></ul></div><h5><a name="replication-sbr-rbr-sbr-advantages"></a>ステートメントベースレプリケーションのメリット</h5><a class="indexterm" name="idm46723651510288"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            実績のあるテクノロジー。
          </p></li><li class="listitem"><p>
            ログファイルに書き込まれるデータが少ないです。 更新または削除が多くの行に影響を与える場合、これによってログファイルに必要なストレージ容量が<span class="emphasis"><em>かなり</em></span>少なくなります。 つまり、バックアップの取得とリストアをより短時間で達成できます。 
          </p></li><li class="listitem"><p>
            ログファイルには変更があったすべてのステートメントが含まれるため、データベースの監査に使用できます。
          </p></li></ul></div><h5><a name="replication-sbr-rbr-sbr-disadvantages"></a>ステートメントベースレプリケーションのデメリット</h5><a class="indexterm" name="idm46723651502688"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>SBR にとって安全でないステートメント. </b><a class="indexterm" name="idm46723651499312"></a><a class="indexterm" name="idm46723651497152"></a>
              データを変更するすべてのステートメント (<code class="literal">INSERT</code> <code class="literal">DELETE</code>、<code class="literal">UPDATE</code>、<code class="literal">REPLACE</code> ステートメントなど) を、ステートメントベースレプリケーションを使用して複製できるわけではありません。 ステートメントベースレプリケーションを使用する場合、非決定的動作は複製が困難です。 このようなデータ変更言語 (DML) ステートメントの例を次に示します: 
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                非決定的な UDF またはストアドプログラムに依存するステートメント。そのような UDF またはストアドプログラムによって返される値は、それに提供されるパラメータ以外の要因に依存するため。 (ただし、行ベースのレプリケーションでは、UDF またはストアドプログラムによって返される値が単にレプリケートされるため、テーブルの行およびデータに対する影響はソースとレプリカの両方で同じです。) 詳細は、<a class="xref" href="replication.html#replication-features-invoked" title="17.5.1.16 呼び出される機能のレプリケーション">セクション17.5.1.16「呼び出される機能のレプリケーション」</a>を参照してください。 
              </p></li><li class="listitem"><p>
                <code class="literal">ORDER BY</code> なしで <code class="literal">LIMIT</code> 句を使用する <code class="literal">DELETE</code> および <code class="literal">UPDATE</code> ステートメントは非決定的です。 <a class="xref" href="replication.html#replication-features-limit" title="17.5.1.18 レプリケーションと LIMIT">セクション17.5.1.18「レプリケーションと LIMIT」</a>を参照してください。 
              </p></li><li class="listitem"><p>
                <code class="literal">NOWAIT</code> または <code class="literal">SKIP LOCKED</code> オプションを使用する読取りステートメント (<code class="literal">SELECT ... FOR UPDATE</code> および <code class="literal">SELECT ... FOR SHARE</code>) のロック。 <a class="xref" href="innodb-storage-engine.html#innodb-locking-reads-nowait-skip-locked" title="NOWAIT および SKIP LOCKED による読取り同時実行性のロック">NOWAIT および SKIP LOCKED による読取り同時実行性のロック</a>を参照してください。 
              </p></li><li class="listitem"><p>
                決定論的 UDF をレプリカに適用する必要があります。
              </p></li><li class="listitem"><p>
                次のいずれかの関数を使用するステートメントは、ステートメントベースレプリケーションでは適切に複製できません。
              </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                    <code class="literal">LOAD_FILE()</code>
                  </p></li><li class="listitem"><p>
                    <code class="literal">UUID()</code>、<code class="literal">UUID_SHORT()</code>
                  </p></li><li class="listitem"><p>
                    <code class="literal">USER()</code>
                  </p></li><li class="listitem"><p>
                    <code class="literal">FOUND_ROWS()</code>
                  </p></li><li class="listitem"><p>
                    <code class="literal">SYSDATE()</code> (ソースとレプリカの両方が <code class="option">--sysdate-is-now</code> オプションで起動されていない場合)
                  </p></li><li class="listitem"><p>
                    <code class="literal">GET_LOCK()</code>
                  </p></li><li class="listitem"><p>
                    <code class="literal">IS_FREE_LOCK()</code>
                  </p></li><li class="listitem"><p>
                    <code class="literal">IS_USED_LOCK()</code>
                  </p></li><li class="listitem"><p>
                    <code class="literal">MASTER_POS_WAIT()</code>
                  </p></li><li class="listitem"><p>
                    <code class="literal">RAND()</code>
                  </p></li><li class="listitem"><p>
                    <code class="literal">RELEASE_LOCK()</code>
                  </p></li><li class="listitem"><p>
                    <code class="literal">SLEEP()</code>
                  </p></li><li class="listitem"><p>
                    <code class="literal">VERSION()</code>
                  </p></li></ul></div><p>
                ただし、<code class="literal">NOW()</code> などを含めてほかのすべての関数はステートメントベースレプリケーションで正しく複製されます。
              </p><p>
                詳細については、<a class="xref" href="replication.html#replication-features-functions" title="17.5.1.14 レプリケーションとシステム関数">セクション17.5.1.14「レプリケーションとシステム関数」</a>を参照してください。
              </p></li></ul></div><p>
            ステートメントベースレプリケーションで正しく複製できないステートメントは、ここに示すもののような警告でログが記録されます。
          </p><pre class="programlisting">[Warning] Statement is not safe to log in statement format.
</pre><p>
            このような場合、類似の警告がクライアントにも発行されます。 クライアントは <code class="literal">SHOW WARNINGS</code> を使用してそれを表示できます。 
          </p></li><li class="listitem"><p>
            <code class="literal">INSERT ... SELECT</code> は、行ベースレプリケーションよりも多くの行レベルロックが必要です。
          </p></li><li class="listitem"><p>
            <code class="literal">WHERE</code> 句でインデックスが使用されていないためにテーブルスキャンを必要とする <code class="literal">UPDATE</code> ステートメントは、行ベースレプリケーションの場合より多くの行をロックする必要があります。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> の場合: <code class="literal">AUTO_INCREMENT</code> を使用する <code class="literal">INSERT</code> ステートメントは、競合しないほかの <code class="literal">INSERT</code> ステートメントをブロックします。
          </p></li><li class="listitem"><p>
            複雑なステートメントの場合、行が更新または挿入される前に、ステートメントを評価してレプリカで実行する必要があります。 行ベースのレプリケーションでは、レプリカは影響を受ける行のみを変更する必要があり、完全なステートメントは実行しません。 
          </p></li><li class="listitem"><p>
            特に複雑なステートメントの実行時にレプリカの評価でエラーが発生した場合、ステートメントベースのレプリケーションによって、影響を受ける行のエラーのマージンが徐々に増加する可能性があります。 <a class="xref" href="replication.html#replication-features-slaveerrors" title="17.5.1.29 レプリケーション中のレプリカエラー">セクション17.5.1.29「レプリケーション中のレプリカエラー」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            ストアドファンクションは、呼び出し元のステートメントと同じ <code class="literal">NOW()</code> 値で実行します。 ただし、これはストアドプロシージャーには当てはまりません。 
          </p></li><li class="listitem"><p>
            決定論的 UDF をレプリカに適用する必要があります。
          </p></li><li class="listitem"><p>
            テーブル定義は、ソースとレプリカで (ほぼ) 同一である必要があります。 詳細については、<a class="xref" href="replication.html#replication-features-differing-tables" title="17.5.1.9 ソースとレプリカで異なるテーブル定義を使用したレプリケーション">セクション17.5.1.9「ソースとレプリカで異なるテーブル定義を使用したレプリケーション」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            MySQL 8.0.22 の時点では、(結合リストまたはサブクエリーを介して) MySQL 付与テーブルからデータを読み取るが、変更しない DML 操作は、MySQL 付与テーブルに対する非ロック読取りとして実行されるため、ステートメントベースのレプリケーションでは安全ではありません。 詳細は、<a class="xref" href="security.html#grant-tables-concurrency" title="テーブル同時実行性の付与">テーブル同時実行性の付与</a>を参照してください。 
          </p></li></ul></div><h5><a name="replication-sbr-rbr-rbr-advantages"></a>行ベースレプリケーションのメリット</h5><a class="indexterm" name="idm46723651419552"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            すべての変更を複製できます。 これはもっとも安全な形式のレプリケーションです。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">GRANT</code>、<code class="literal">REVOKE</code> およびトリガー、ストアドルーチン (ストアドプロシージャーを含む) およびビューの操作など、<code class="literal">mysql</code> システムスキーマ内の情報を更新するステートメントはすべて、ステートメントベースレプリケーションを使用してレプリカにレプリケートされます。
            </p><p>
              <code class="literal">CREATE TABLE ... SELECT</code> などのステートメントの場合、<code class="literal">CREATE</code> ステートメントはテーブル定義から生成されてステートメントベース形式を使用して複製される一方、行挿入は行ベース形式を使用して複製されます。
            </p></div></li><li class="listitem"><p>
            次のタイプのステートメントでは、ソースで必要な行ロックが少なくなるため、同時実行性が高くなります:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">INSERT ... SELECT</code>
              </p></li><li class="listitem"><p>
                <code class="literal">AUTO_INCREMENT</code> 付きの <code class="literal">INSERT</code> ステートメント
              </p></li><li class="listitem"><p>
                キーを使用しないまたは検査された行のほとんどを変更しない <code class="literal">WHERE</code> 句付きの <code class="literal">UPDATE</code> または <code class="literal">DELETE</code> ステートメント。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">INSERT</code>、<code class="literal">UPDATE</code> または <code class="literal">DELETE</code> ステートメントのレプリカで必要な行ロックが少なくなります。
          </p></li></ul></div><h5><a name="replication-sbr-rbr-rbr-disadvantages"></a>行ベースレプリケーションのデメリット</h5><a class="indexterm" name="idm46723651394080"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            RBR では、ログに書き込む必要があるデータが増える可能性があります。 ステートメントベースレプリケーションでは、DML ステートメント (<code class="literal">UPDATE</code>、<code class="literal">DELETE</code> ステートメントなど) を複製するためにステートメントだけをバイナリログに書き込みます。 一方、行ベースレプリケーションでは変更されたすべての行をバイナリログに書き込みます。 ステートメントが多くの行を変更する場合、行ベースレプリケーションは非常に多くのデータをバイナリログに書き込む可能性があります。このことはロールバックされるステートメントにも当てはまります。 これは、バックアップの作成およびリストアにさらに時間がかかる可能性があることも意味します。 また、データを書き込むためにバイナリログがロックされる時間が長くなるため、並列性の問題が発生する場合があります。 <code class="literal">binlog_row_image=minimal</code> を使用すると、デメリットを大幅に削減できます。 
          </p></li><li class="listitem"><p>
            大きな <code class="literal">BLOB</code> 値を生成する決定的 UDF の場合は、ステートメントベースレプリケーションより行ベースレプリケーションの方が複製に時間がかかります。 これは、データを生成するステートメントではなく、<code class="literal">BLOB</code> カラム値がログに書き込まれるためです。 
          </p></li><li class="listitem"><p>
            レプリカでは、ソースから受信して実行されたステートメントは表示されません。 ただし、オプション <code class="option">--base64-output=DECODE-ROWS</code> および <code class="option">--verbose</code> を付けて <span class="command"><strong>mysqlbinlog</strong></span> を使用すると、何のデータが変更されたかがわかります。 
          </p><p>
            または、<code class="literal">binlog_rows_query_log_events</code> 変数を使用します。これを有効にすると、<code class="literal">-vv</code> オプションが使用されたときに、<code class="literal">Rows_query</code> イベントとそのステートメントが <span class="command"><strong>mysqlbinlog</strong></span> 出力に追加されます。
          </p></li><li class="listitem"><p>
            <code class="literal">MyISAM</code> ストレージエンジンを使用するテーブルの場合、<code class="literal">INSERT</code> ステートメントをバイナリログに行ベースのイベントとして適用するときは、ステートメントとして適用するときよりも強力なロックが <code class="literal">INSERT</code> ステートメントのレプリカに必要です。 これは、<code class="literal">MyISAM</code> テーブルでの同時挿入が、行ベースレプリケーションを使用するときにサポートされないことを意味します。 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-rbr-usage"></a>17.2.1.2 行ベースロギングおよびレプリケーションの使用</h4></div></div></div><p>
        MySQL はステートメントベースロギング (SBL)、行ベースロギング (RBL)、または混合形式ロギングを使用します。 使用されるバイナリログのタイプは、ロギングのサイズと効率に影響します。 したがって、行ベースレプリケーション (RBR) とステートメントベースレプリケーション (SBR) のどちらを選択するかは、アプリケーションと環境によって異なります。 このセクションでは、行ベースのフォーマットログを使用する際の既知の問題と、それをレプリケーションで使用するためのいくつかのベストプラクティスについて説明します。 
      </p><p>
        詳細については、<a class="xref" href="replication.html#replication-formats" title="17.2.1 レプリケーション形式">セクション17.2.1「レプリケーション形式」</a>および<a class="xref" href="replication.html#replication-sbr-rbr" title="17.2.1.1 ステートメントベースおよび行ベースレプリケーションのメリットとデメリット">セクション17.2.1.1「ステートメントベースおよび行ベースレプリケーションのメリットとデメリット」</a>を参照してください。
      </p><p>
        NDB Cluster レプリケーションに固有の問題 (行ベースレプリケーションに依存) については、<a class="xref" href="mysql-cluster.html#mysql-cluster-replication-issues" title="23.6.3 NDB Cluster レプリケーションの既知の問題">セクション23.6.3「NDB Cluster レプリケーションの既知の問題」</a> を参照してください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="replication-rbr-usage-temptables"></a><b>一時テーブルの行ベースロギング. </b>
              <a class="xref" href="replication.html#replication-features-temptables" title="17.5.1.31 レプリケーションと一時テーブル">セクション17.5.1.31「レプリケーションと一時テーブル」</a> で説明されているように、行ベース形式または (MySQL 8.0.4) 混合形式を使用する場合、一時テーブルはレプリケートされません。 詳細については、<a class="xref" href="replication.html#replication-sbr-rbr" title="17.2.1.1 ステートメントベースおよび行ベースレプリケーションのメリットとデメリット">セクション17.2.1.1「ステートメントベースおよび行ベースレプリケーションのメリットとデメリット」</a>を参照してください。 
            </p><p>
            行ベースまたは混合形式を使用する場合、一時テーブルはレプリケートされません。これは、必要がないためです。 また、一時テーブルはそれらを作成したスレッドからのみ読み取れるため、ステートメントベース形式を使用する場合でも、それらを複製することから得られるメリットはまずありません。 
          </p><p>
            一時テーブルが作成されている場合でも、実行時にステートメントベースから行ベースのバイナリロギング形式に切り替えることができます。 ただし、MySQL 8.0 では、前のモードでバイナリログから <code class="literal">CREATE TEMPORARY TABLE</code> ステートメントが省略されているため、バイナリロギングの行ベースまたは混合形式からステートメントベース形式に切り替えることはできません。 
          </p><p>
            MySQL サーバーは、各一時テーブルが作成されたときに有効だったロギングモードを追跡します。 特定のクライアントセッションが終了すると、サーバーは、まだ存在し、ステートメントベースのバイナリロギングが使用されていたときに作成された一時テーブルごとに <code class="literal">DROP TEMPORARY TABLE IF EXISTS</code> ステートメントをログに記録します。 テーブルの作成時に行ベースまたは混合形式のバイナリロギングが使用されていた場合、<code class="literal">DROP TEMPORARY TABLE IF EXISTS</code> ステートメントはログに記録されません。 MySQL 8.0.4 および 5.7.25 より前のリリースでは、<code class="literal">DROP TEMPORARY TABLE IF EXISTS</code> ステートメントは有効なロギングモードに関係なくログに記録されていました。 
          </p><p>
            一時テーブルに関連する非トランザクション DML ステートメントは、ステートメントの影響を受ける非トランザクションテーブルが一時テーブルであるかぎり、<code class="literal">binlog_format=ROW</code> の使用時に許可されます (Bug #14272672)。
          </p></li><li class="listitem"><p><b>非トランザクションテーブルの RBL と同期. </b>
              多くの行が影響を受ける場合、変更のセットは複数のイベントに分割されます。ステートメントがコミットすると、これらのイベントのすべてがバイナリログに書き込まれます。 レプリカで実行すると、関連するすべてのテーブルでテーブルロックが取得され、行がバッチモードで適用されます。 テーブルのレプリカコピーに使用されるエンジンによっては、これが有効な場合と無効な場合があります。 
            </p></li><li class="listitem"><p><b>待機時間およびバイナリログサイズ. </b>
              RBL は各行の変更をバイナリログに書き込むため、そのサイズは急激に増える場合があります。 これにより、ソースと一致するレプリカの変更に必要な時間が大幅に長くなる可能性があります。 アプリケーションでこのような遅延が発生する可能性を意識してください。 
            </p></li><li class="listitem"><p><b>バイナリログの読み取り. </b>
              <span class="command"><strong>mysqlbinlog</strong></span> は、<code class="literal">BINLOG</code> ステートメントを使用してバイナリログ内の行ベースイベントを表示します(<a class="xref" href="sql-statements.html#binlog" title="13.7.8.1 BINLOG ステートメント">セクション13.7.8.1「BINLOG ステートメント」</a>を参照してください)。 このステートメントは base 64 でエンコードされた文字列 (その意味は明白ではありません) としてイベントを表示します。 <code class="option">--base64-output=DECODE-ROWS</code> および <code class="option">--verbose</code> オプションを付けて呼び出されたときは、<span class="command"><strong>mysqlbinlog</strong></span> はバイナリログの内容を人間が読める形式にします。 バイナリログイベントが行ベース形式で書き込まれ、それらを読み取ったりレプリケーションまたはデータベース障害からリカバリしたりしたい場合は、このコマンドでバイナリログの内容を読み取ることができます。 詳細については、<a class="xref" href="programs.html#mysqlbinlog-row-events" title="4.6.8.2 mysqlbinlog 行イベントの表示">セクション4.6.8.2「mysqlbinlog 行イベントの表示」</a>を参照してください。 
            </p></li><li class="listitem"><p><b>バイナリログ実行エラーおよびレプリカ実行モード. </b>
              <code class="literal">slave_exec_mode=IDEMPOTENT</code> の使用は一般に、<code class="literal">IDEMPOTENT</code> がデフォルト値である MySQL NDB Cluster レプリケーションでのみ役立ちます。 (<a class="xref" href="mysql-cluster.html#mysql-cluster-replication-multi-source" title="23.6.10 NDB Cluster レプリケーション: 双方向および循環レプリケーション">セクション23.6.10「NDB Cluster レプリケーション: 双方向および循環レプリケーション」</a> を参照してください)。 <code class="literal">slave_exec_mode</code> が <code class="literal">IDEMPOTENT</code> の場合、元の行が見つからないため RBL からの変更の適用に失敗しても、エラーはトリガーされず、レプリケーションが失敗します。 つまり、ソースとレプリカが同期されなくなるように、更新がレプリカに適用されない可能性があります。 <code class="literal">slave_exec_mode</code> が <code class="literal">IDEMPOTENT</code> の場合、RBR での待機時間の問題および非トランザクションテーブルの使用によって、ソースとレプリカがさらに相違する可能性があります。 <code class="literal">slave_exec_mode</code> の詳細については、<a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>を参照してください。 
            </p><p>
            その他のシナリオでは、通常、<code class="literal">slave_exec_mode</code> を <code class="literal">STRICT</code> に設定するだけで十分です。これは、<code class="literal">NDB</code> 以外のストレージエンジンのデフォルト値です。
          </p></li><li class="listitem"><p><b>サーバー ID に基づくフィルタリングはサポートされない. </b>
              サーバー ID に基づいてフィルタ処理するには、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23 の場合) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 の場合) の <code class="literal">IGNORE_SERVER_IDS</code> オプションを使用します。 このオプションは、ステートメントベースおよび行ベースのロギング形式で機能しますが、<code class="literal">GTID_MODE=ON</code> が設定されている場合に使用することは非推奨です。 一部のレプリカに対する変更を除外する別の方法は、<code class="literal">UPDATE</code> および <code class="literal">DELETE</code> ステートメントでリレーション<code class="literal">@@server_id &lt;&gt; <em class="replaceable"><code>id_value</code></em></code> 句を含む <code class="literal">WHERE</code> 句を使用することです。 たとえば、<code class="literal">WHERE @@server_id &lt;&gt; 1</code>。 ただし、これは行ベースロギングでは正しく動作しません。 ステートメントフィルタリングに <code class="literal">server_id</code> システム変数を使用するには、ステートメントベースロギングを使用します。 
            </p></li><li class="listitem"><p><b>RBL、非トランザクションテーブルおよび停止したレプリカ. </b>
              行ベースのロギングを使用している場合、レプリカスレッドが非トランザクションテーブルを更新している間にレプリカサーバーが停止すると、レプリカデータベースが一貫性のない状態になる可能性があります。 このため、行ベース形式を使用して複製されたすべてのテーブルに、<code class="literal">InnoDB</code> などのトランザクションストレージエンジンを使用することをお勧めします。 レプリカ MySQL サーバーを停止する前に <code class="literal">STOP REPLICA | SLAVE</code> または <code class="literal">STOP REPLICA | SLAVE SQL_THREAD</code> を使用すると、問題の発生を防ぐことができ、使用するロギング形式やストレージエンジンに関係なく常に推奨されます。 
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-rbr-safe-unsafe"></a>17.2.1.3 バイナリロギングでの安全および安全でないステートメントの判断</h4></div></div></div><a class="indexterm" name="idm46723651302384"></a><a class="indexterm" name="idm46723651300176"></a><a class="indexterm" name="idm46723651298160"></a><p>
        MySQL レプリケーションでのステートメントの<span class="quote">「<span class="quote">「安全性」</span>」</span>とは、ステートメントベースの形式を使用してステートメントとその効果を正しくレプリケートできるかどうかを指します。 これがステートメントに当てはまる場合、ステートメントは<span class="firstterm">安全</span>と言い、そうでない場合は<span class="firstterm">安全でない</span>と言います。 
      </p><p>
        一般的に、ステートメントが決定的である場合は安全であり、そうでない場合は安全ではありません。 ただし、特定の非決定的関数は「安全でない」と見なされ<span class="emphasis"><em>ません</em></span> (このセクションの後半の<a class="xref" href="replication.html#replication-rbr-safe-unsafe-not" title="安全でないと見なされない非決定的関数。">安全でないと見なされない非決定的関数。</a>を参照してください)。 また、浮動小数点数学関数 (ハードウェア依存) からの結果を使用するステートメントは、常に安全でないと見なされます (<a class="xref" href="replication.html#replication-features-floatvalues" title="17.5.1.12 レプリケーションと浮動小数点値">セクション17.5.1.12「レプリケーションと浮動小数点値」</a>を参照してください)。 
      </p><p><b>安全および安全でないステートメントの処理. </b>
          ステートメントは、ステートメントが安全と見なされるかどうかに応じて、およびバイナリロギング形式 (すなわち、<code class="literal">binlog_format</code> の現在の値) に基づいて異なる方法で処理されます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            行ベースロギングを使用する場合、安全および安全でないステートメントの扱いに違いはありません。
          </p></li><li class="listitem"><p>
            混合形式ロギングを使用する場合、安全でないとフラグされたステートメントは行ベース形式を使用してログが記録され、安全と見なされたステートメントはステートメントベース形式を使用してログが記録されます。
          </p></li><li class="listitem"><p>
            ステートメントベースロギングを使用する場合、安全でないとフラグされたステートメントはこの結果に警告を生成します。 安全なステートメントは通常どおりにログが記録されます。 
          </p></li></ul></div><p>
        安全でないとフラグされた各ステートメントは警告を生成します。 このようなステートメントがソースで多数実行された場合、エラーログファイルが過剰に大きくなる可能性があります。 これを防ぐために、MySQL には警告抑制メカニズムがあります。 50 秒間に 50 回を超える最新の <code class="literal">ER_BINLOG_UNSAFE_STATEMENT</code> 警告が 50 回生成されると、警告抑制が有効になります。 有効になっているときは、これによってこのような警告がエラーログに書き込まれることはありません。代わりに、このタイプの警告が 50 個生成されるたびに、<code class="literal">「最後の警告が <em class="replaceable"><code>N</code></em> 回、最近の <em class="replaceable"><code>S</code></em> 秒間に繰り返されました」</code>との注記がエラーログに書き込まれます。 50 個の最近のこのような警告が 50 秒以内に発行されるかぎり、これが継続します。頻度がこのしきい値を下回ると、再度通常どおりに警告ログが記録されます。 警告抑止は、ステートメントベースロギングでステートメントの安全がどのように判断されるか、および警告がクライアントにどのように送信されるかに影響しません。 MySQL クライアントは引き続きこのようなステートメントごとに 1 つの警告を受け取ります。 
      </p><p>
        詳細については、<a class="xref" href="replication.html#replication-formats" title="17.2.1 レプリケーション形式">セクション17.2.1「レプリケーション形式」</a>を参照してください。
      </p><p><b>安全でないと見なされるステートメント. </b><a class="indexterm" name="idm46723651275776"></a>
          次の特徴を持つステートメントは安全でないと見なされます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>レプリカで異なる値を返す可能性のあるシステム関数を含むステートメント. </b>
              これらの関数には、<code class="literal">FOUND_ROWS()</code>, <code class="literal">GET_LOCK()</code>, <code class="literal">IS_FREE_LOCK()</code>, <code class="literal">IS_USED_LOCK()</code>, <code class="literal">LOAD_FILE()</code>, <code class="literal">MASTER_POS_WAIT()</code>, <code class="literal">RAND()</code>, <code class="literal">RELEASE_LOCK()</code>, <code class="literal">ROW_COUNT()</code>, <code class="literal">SESSION_USER()</code>, <code class="literal">SLEEP()</code>, <code class="literal">SYSDATE()</code>, <code class="literal">SYSTEM_USER()</code>, <code class="literal">USER()</code>, <code class="literal">UUID()</code> および <code class="literal">UUID_SHORT()</code> が含まれます。
            </p><p><a name="replication-rbr-safe-unsafe-not"></a><b>安全でないと見なされない非決定的関数。. </b>
              これらの関数は決定的ではありませんが、ロギングおよびレプリケーション目的の場合は安全として処理されます: <code class="literal">CONNECTION_ID()</code>、<code class="literal">CURDATE()</code>、<code class="literal">CURRENT_DATE()</code>、<code class="literal">CURRENT_TIME()</code>、<code class="literal">CURRENT_TIMESTAMP()</code>、<code class="literal">CURTIME()</code>、<code class="literal">LAST_INSERT_ID()</code>、<code class="literal">LOCALTIME()</code>、<code class="literal">LOCALTIMESTAMP()</code>、<code class="literal">NOW()</code>、<code class="literal">UNIX_TIMESTAMP()</code>、<code class="literal">UTC_DATE()</code>、<code class="literal">UTC_TIME()</code>、および <code class="literal">UTC_TIMESTAMP()</code>。
            </p><p>
            詳細については、<a class="xref" href="replication.html#replication-features-functions" title="17.5.1.14 レプリケーションとシステム関数">セクション17.5.1.14「レプリケーションとシステム関数」</a>を参照してください。
          </p></li><li class="listitem"><p><b>システム変数への参照. </b>
              ほとんどのシステム変数は、ステートメントベース形式で正しく複製されません。 <a class="xref" href="replication.html#replication-features-variables" title="17.5.1.39 レプリケーションと変数">セクション17.5.1.39「レプリケーションと変数」</a>を参照してください。 例外については、<a class="xref" href="server-administration.html#binary-log-mixed" title="5.4.4.3 混合形式のバイナリロギング形式">セクション5.4.4.3「混合形式のバイナリロギング形式」</a>を参照してください。 
            </p></li><li class="listitem"><p><b>UDF. </b>
              UDF が何をするかは制御できないため、それが安全でないステートメントを実行していると推定する必要があります。
            </p></li><li class="listitem"><p><b>全文プラグイン. </b>
              このプラグインの動作は MySQL サーバーによって異なる場合があるため、それに基づくステートメントは結果が異なる場合があります。 このため、フルテキストプラグインに依存するすべてのステートメントは、MySQL で安全でないものとして扱われます。 
            </p></li><li class="listitem"><p><b>トリガーまたはストアドプログラムは AUTO_INCREMENT カラムを持つテーブルを更新する。. </b>
              行の更新順序がソースとレプリカで異なる可能性があるため、これは安全ではありません。
            </p><p>
            また、複合主キーを持つテーブルに、この複合キーの先頭カラムでない <code class="literal">AUTO_INCREMENT</code> カラムが含まれるテーブルに <code class="literal">INSERT</code> することは、安全ではありません。
          </p><p>
            詳細については、<a class="xref" href="replication.html#replication-features-auto-increment" title="17.5.1.1 レプリケーションと AUTO_INCREMENT">セクション17.5.1.1「レプリケーションと AUTO_INCREMENT」</a>を参照してください。
          </p></li><li class="listitem"><p><b>複数の主キーまたは一意キーを持つテーブルでの INSERT ... ON DUPLICATE KEY UPDATE ステートメント. </b>
              複数の主キーまたは一意キーを持つテーブルに対して実行されるときのこのステートメントは、安全でないと見なされます (ストレージエンジンがキーをチェックする順番に影響されやすいですが、これは決定的でなく、さらに MySQL Server が更新する行の選択がこれに依存するためです)。
            </p><p>
            複数の一意キーまたは主キーを持つテーブルに対する <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> ステートメントは、ステートメントベースのレプリケーションに対して安全でないとマークされます。 (Bug #11765650、Bug #58637) 
          </p></li><li class="listitem"><p><b>LIMIT を使用する更新. </b>
              行の取得順序が指定されていないため、安全でないと見なされます。 <a class="xref" href="replication.html#replication-features-limit" title="17.5.1.18 レプリケーションと LIMIT">セクション17.5.1.18「レプリケーションと LIMIT」</a>を参照してください。 
            </p></li><li class="listitem"><p><b>ログテーブルへのアクセスまたは参照. </b>
              システムログテーブルの内容は、ソースとレプリカで異なる場合があります。
            </p></li><li class="listitem"><p><b>トランザクション操作後の非トランザクション操作. </b>
              トランザクション内で、トランザクション読み取りまたは書き込み後に非トランザクション読み取りまたは書き込みを実行することを許可することは、安全でないと見なされます。
            </p><p>
            詳細については、<a class="xref" href="replication.html#replication-features-transactions" title="17.5.1.35 レプリケーションとトランザクション">セクション17.5.1.35「レプリケーションとトランザクション」</a>を参照してください。
          </p></li><li class="listitem"><p><b>セルフロギングテーブルへのアクセスまたは参照. </b>
              セルフロギングテーブルへのすべての読み取りと書き込みは、安全でないと見なされます。 トランザクション内で、セルフロギングテーブルへの読み取りまたは書き込みに続くステートメントも、安全でないと見なされます。 
            </p></li><li class="listitem"><p><b>LOAD DATA ステートメント. </b>
              <code class="literal">LOAD DATA</code> は安全でないとみなされ、<code class="literal">binlog_format=MIXED</code> の場合、ステートメントは行ベースの形式で記録されます。 他の安全でないステートメントとは異なり、<code class="literal">binlog_format=STATEMENT</code> <code class="literal">LOAD DATA</code> で警告が生成されない場合。 
            </p></li><li class="listitem"><p><b>XA トランザクション. </b>
              ソースでパラレルにコミットされた 2 つの XA トランザクションがレプリカで逆の順序で準備されている場合、安全に解決できないステートメントベースのレプリケーションでロック依存関係が発生する可能性があり、レプリケーションがレプリカのデッドロックで失敗する可能性があります。 <code class="literal">binlog_format=STATEMENT</code> が設定されている場合、XA トランザクション内の DML ステートメントに安全でないというフラグが付けられ、警告が生成されます。 <code class="literal">binlog_format=MIXED</code> または <code class="literal">binlog_format=ROW</code> が設定されている場合、XA トランザクション内の DML ステートメントは行ベースのレプリケーションを使用して記録され、潜在的な問題は存在しません。 
            </p></li><li class="listitem"><p><b>非決定的関数を参照する <code class="literal">DEFAULT</code> 句. </b>
              式のデフォルト値が非決定的関数を参照している場合、式を評価するステートメントはステートメントベースレプリケーションでは安全ではありません。 これには、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、<code class="literal">ALTER TABLE</code> などのステートメントが含まれます。 他のほとんどの安全でないステートメントとは異なり、このカテゴリのステートメントは行ベースの形式で安全にレプリケートできません。 <code class="literal">binlog_format</code> が <code class="literal">STATEMENT</code> に設定されている場合、ステートメントはログに記録されて実行されますが、エラーログに警告メッセージが書き込まれます。 <code class="literal">binlog_format</code> が <code class="literal">MIXED</code> または <code class="literal">ROW</code> に設定されている場合、ステートメントは実行されず、エラーログにエラーメッセージが書き込まれます。 明示的なデフォルトの処理の詳細は、<a class="xref" href="data-types.html#data-type-defaults-explicit" title="MySQL 8.0.13 での明示的なデフォルト処理">MySQL 8.0.13 での明示的なデフォルト処理</a> を参照してください。 
            </p></li></ul></div><p>
        追加情報については <a class="xref" href="replication.html#replication-features" title="17.5.1 レプリケーションの機能と問題">セクション17.5.1「レプリケーションの機能と問題」</a>を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-channels"></a>17.2.2 レプリケーションチャネル</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#channels-commands-single-channel">17.2.2.1 単一チャネルで操作するためのコマンド</a></span></dt><dt><span class="section"><a href="replication.html#channels-with-prev-replication">17.2.2.2 以前のレプリケーションステートメントとの互換性</a></span></dt><dt><span class="section"><a href="replication.html#channels-startup-options">17.2.2.3 起動オプションとレプリケーションチャネル</a></span></dt><dt><span class="section"><a href="replication.html#channels-naming-conventions">17.2.2.4 レプリケーションチャネルのネーミング規則</a></span></dt></dl></div><a class="indexterm" name="idm46723651183776"></a><a class="indexterm" name="idm46723651182320"></a><p>
    MySQL マルチソースレプリケーションでは、レプリカはソースサーバーごとに複数のレプリケーションチャネルを開きます。 レプリケーションチャネルは、ソースからレプリカに流れるトランザクションのパスを表します。 各レプリケーションチャネルには、独自の受信者 (I/O) スレッド、1 つ以上の適用者 (SQL) スレッドおよびリレーログがあります。 ソースからのトランザクションがチャネルレシーバスレッドによって受信されると、トランザクションはチャネルリレーログファイルに追加され、チャネルアプライヤスレッドに渡されます。 これにより、各チャネルは個別に機能できます。 
  </p><p>
    このセクションでは、レプリケーショントポロジでチャネルを使用する方法と、チャネルが単一ソースレプリケーションに与える影響について説明します。 マルチソースレプリケーションのソースおよびレプリカの構成、マルチソースレプリカの起動、停止およびリセット、およびマルチソースレプリケーションの監視の手順は、<a class="xref" href="replication.html#replication-multi-source" title="17.1.5 MySQL マルチソースレプリケーション">セクション17.1.5「MySQL マルチソースレプリケーション」</a> を参照してください。 
  </p><p>
    マルチソースレプリケーショントポロジの 1 つのレプリカサーバーに作成できるチャネルの最大数は 256 です。 各レプリケーションチャネルには、<a class="xref" href="replication.html#channels-naming-conventions" title="17.2.2.4 レプリケーションチャネルのネーミング規則">セクション17.2.2.4「レプリケーションチャネルのネーミング規則」</a> で説明されている一意の (空でない) 名前が必要です。 マルチソースレプリケーションが有効な場合に発行されるエラーコードおよびメッセージは、エラーを生成したチャネルを指定します。 
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
      マルチソースレプリカ上の各チャネルは、異なるソースからレプリケートする必要があります。 単一のレプリカから単一のソースに複数のレプリケーションチャネルを設定することはできません。 これは、レプリカのサーバー ID がレプリケーショントポロジ内で一意である必要があるためです。 ソースはレプリカをサーバー ID でのみ区別し、レプリケーションチャネルの名前では区別しないため、同じレプリカとは異なるレプリケーションチャネルを認識できません。 
    </p></div><p>
    マルチソースレプリカは、<code class="literal">slave_parallel_workers</code> システム変数を 0 より大きい値に設定することで、マルチスレッドレプリカとして設定することもできます。 マルチソースレプリカでこれを行う場合、レプリカ上の各チャネルには、指定された数のアプライヤスレッドと、それらを管理するためのコーディネータスレッドがあります。 個々のチャネルのアプライヤスレッドの数は構成できません。 
  </p><p>
    MySQL 8.0 から、特定のレプリケーションチャネルでレプリケーションフィルタを使用してマルチソースレプリカを構成できます。 チャネル固有のレプリケーションフィルタは、同じデータベースまたはテーブルが複数のソースに存在し、単一のソースからレプリケートする場合にのみ使用できます。 GTID ベースのレプリケーションでは、(ダイアモンドトポロジなどの) 複数のソースから同じトランザクションが到着する可能性がある場合、フィルタリング設定がすべてのチャネルで同じであることを確認する必要があります。 詳細は、<a class="xref" href="replication.html#replication-rules-channel-based-filters" title="17.2.5.4 レプリケーションチャネルベースのフィルタ">セクション17.2.5.4「レプリケーションチャネルベースのフィルタ」</a>を参照してください。 
  </p><p>
    以前のバージョンとの互換性を提供するために、MySQL サーバーは起動時に、名前が空の文字列 (<code class="literal">""</code>) であるデフォルトチャネルを自動的に作成します。 このチャネルは常に存在します。ユーザーが作成または破棄することはできません。 他のチャネル (空でない名前を持つ) が作成されていない場合、レプリケーションステートメントはデフォルトチャネルでのみ機能するため、古いレプリカからのすべてのレプリケーションステートメントは予想どおりに機能します (<a class="xref" href="replication.html#channels-with-prev-replication" title="17.2.2.2 以前のレプリケーションステートメントとの互換性">セクション17.2.2.2「以前のレプリケーションステートメントとの互換性」</a> を参照)。 このセクションで説明するように、レプリケーションチャネルに適用するステートメントは、少なくとも 1 つの名前付きチャネルがある場合にのみ使用できます。 
  </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="channels-commands-single-channel"></a>17.2.2.1 単一チャネルで操作するためのコマンド</h4></div></div></div><a class="indexterm" name="idm46723651163904"></a><a class="indexterm" name="idm46723651161760"></a><p>
      MySQL レプリケーション操作で個々のレプリケーションチャネルを操作できるようにするには、次のレプリケーションステートメントで <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を使用します:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">CHANGE REPLICATION SOURCE TO</code>
        </p></li><li class="listitem"><p>
          <code class="literal">CHANGE MASTER TO</code>
        </p></li><li class="listitem"><p>
          <code class="literal">START REPLICA | SLAVE</code>
        </p></li><li class="listitem"><p>
          <code class="literal">STOP REPLICA | SLAVE</code>
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW RELAYLOG EVENTS</code>
        </p></li><li class="listitem"><p>
          <code class="literal">FLUSH RELAY LOGS</code>
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW REPLICA | SLAVE STATUS</code>
        </p></li><li class="listitem"><p>
          <code class="literal">RESET REPLICA | SLAVE</code>
        </p></li></ul></div><p>
      次の関数に追加の <code class="literal">channel</code> パラメータが導入されました:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">MASTER_POS_WAIT()</code>
        </p></li></ul></div><p>
      <code class="literal">group_replication_recovery</code> チャネルでは、次のステートメントは許可されません:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">START REPLICA | SLAVE</code>
        </p></li><li class="listitem"><p>
          <code class="literal">STOP REPLICA | SLAVE</code>
        </p></li></ul></div><p>
      <code class="literal">group_replication_applier</code> チャネルでは、次のステートメントは許可されません:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">START REPLICA | SLAVE</code>
        </p></li><li class="listitem"><p>
          <code class="literal">STOP REPLICA | SLAVE</code>
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW REPLICA | SLAVE STATUS</code>
        </p></li></ul></div><p>
      <code class="literal">FLUSH RELAY LOGS</code> は <code class="literal">group_replication_applier</code> チャネルに対して許可されるようになりましたが、トランザクションの適用中にリクエストを受信した場合、リクエストはトランザクションの終了後に実行されます。 リクエスタは、トランザクションが完了してローテーションが実行されるまで待機する必要があります。 この動作により、グループレプリケーションで許可されていないトランザクションを分割できなくなります。 
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="channels-with-prev-replication"></a>17.2.2.2 以前のレプリケーションステートメントとの互換性</h4></div></div></div><a class="indexterm" name="idm46723651121392"></a><p>
      レプリカに複数のチャネルがあり、<code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> オプションが指定されていない場合、通常、有効なステートメントは使用可能なすべてのチャネルに対して動作しますが、特定の例外があります。
    </p><p>
      たとえば、次のステートメントは、特定のグループレプリケーションチャネルを除くすべてのステートメントで予想どおりに動作します:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">START REPLICA | SLAVE</code> は、<code class="literal">group_replication_recovery</code> および <code class="literal">group_replication_applier</code> チャネルを除くすべてのチャネルのレプリケーションスレッドを開始します。
        </p></li><li class="listitem"><p>
          <code class="literal">STOP REPLICA | SLAVE</code> は、<code class="literal">group_replication_recovery</code> および <code class="literal">group_replication_applier</code> チャネルを除くすべてのチャネルのレプリケーションスレッドを停止します。
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW REPLICA | SLAVE STATUS</code> では、<code class="literal">group_replication_applier</code> チャネルを除くすべてのチャネルのステータスがレポートされます。
        </p></li><li class="listitem"><p>
          <code class="literal">RESET REPLICA | SLAVE</code> はすべてのチャネルをリセットします。
        </p></li></ul></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
        このステートメントは既存のすべてのチャネルを削除し、リレーログファイルをパージし、デフォルトチャネルのみを再作成するため、<code class="literal">RESET REPLICA | SLAVE</code> を慎重に使用してください。
      </p></div><p>
      一部のレプリケーションステートメントは、すべてのチャネルで動作するわけではありません。 この場合、エラー 1964 <span class="errortext">Multiple チャネルがレプリカに存在します。 argument.</span> が生成されるため、チャネル名を指定してください。 次のステートメントおよび関数は、マルチソースレプリケーショントポロジで使用され、<code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> オプションを使用して動作するチャネルを指定しない場合に、このエラーを生成します: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SHOW RELAYLOG EVENTS</code>
        </p></li><li class="listitem"><p>
          <code class="literal">CHANGE REPLICATION SOURCE TO</code>
        </p></li><li class="listitem"><p>
          <code class="literal">CHANGE MASTER TO</code>
        </p></li><li class="listitem"><p>
          <code class="literal">MASTER_POS_WAIT()</code>
        </p></li></ul></div><p>
      デフォルトチャネルは常に単一ソースレプリケーショントポロジに存在することに注意してください。このトポロジでは、ステートメントおよび関数は以前のバージョンの MySQL と同様に動作します。
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="channels-startup-options"></a>17.2.2.3 起動オプションとレプリケーションチャネル</h4></div></div></div><a class="indexterm" name="idm46723651088880"></a><a class="indexterm" name="idm46723651086736"></a><p>
      このセクションでは、レプリケーションチャネルの追加によって影響を受ける起動オプションについて説明します。
    </p><p>
      レプリケーションチャネルを使用する場合は、<code class="literal">master_info_repository</code> および <code class="literal">relay_log_info_repository</code> システム変数を <code class="literal">FILE</code> に設定しないでください。 MySQL 8.0 では、<code class="literal">FILE</code> 設定は非推奨であり、<code class="literal">TABLE</code> がデフォルトであるため、システム変数を省略できます。 MySQL 8.0.23 では、使用は非推奨であるため、省略する必要があります。 これらのシステム変数が <code class="literal">FILE</code> に設定されている場合、レプリカにソースを追加しようとすると、<code class="literal">ER_SLAVE_NEW_CHANNEL_WRONG_REPOSITORY</code> で失敗します。 
    </p><p>
      次の起動オプションがレプリケーショントポロジの <span class="emphasis"><em>all</em></span> チャネルに影響するようになりました。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">--log-slave-updates</code>
        </p><p>
          レプリカによって受信されたすべてのトランザクション (複数のソースからのトランザクションも含む) は、バイナリログに書き込まれます。
        </p></li><li class="listitem"><p>
          <code class="literal">--relay-log-purge</code>
        </p><p>
          設定すると、各チャネルは独自のリレーログを自動的にパージします。
        </p></li><li class="listitem"><p>
          <code class="literal">--slave_transaction_retries</code>
        </p><p>
          指定された数のトランザクション再試行は、すべてのチャネルのすべてのアプライヤスレッドで実行できます。
        </p></li><li class="listitem"><p>
          <code class="option">--skip-slave-start</code>
        </p><p>
          どのチャネルでもレプリケーションスレッドは開始しません。
        </p></li><li class="listitem"><p>
          <code class="literal">--slave-skip-errors</code>
        </p><p>
          すべてのチャネルで実行が続行され、エラーはスキップされます。
        </p></li></ul></div><p>
      次の起動オプションに設定された値は各チャネルに適用されます。これらは <span class="command"><strong>mysqld</strong></span> の起動オプションであるため、すべてのチャネルに適用されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="option">--max-relay-log-size=<em class="replaceable"><code>size</code></em></code>
        </p><p>
          各チャネルの個々のリレーログファイルの最大サイズ。この制限に達すると、ファイルはローテーションされます。
        </p></li><li class="listitem"><p>
          <code class="option">--relay-log-space-limit=<em class="replaceable"><code>size</code></em></code>
        </p><p>
          個々のチャネルについて、結合されたすべてのリレーログの合計サイズの上限。 <em class="replaceable"><code>N</code></em> チャネルの場合、これらのログの合計サイズは <code class="literal">relay_log_space_limit * <em class="replaceable"><code>N</code></em> </code>に制限されます。 
        </p></li><li class="listitem"><p>
          <code class="option">--slave-parallel-workers=<em class="replaceable"><code>value</code></em></code>
        </p><p>
          チャネル当たりのレプリケーションアプライヤスレッド数。
        </p></li><li class="listitem"><p>
          <code class="literal">slave_checkpoint_group</code>
        </p><p>
          各ソースの I/O スレッドによる待機時間。
        </p></li><li class="listitem"><p>
          <code class="option">--relay-log-index=filename</code>
        </p><p>
          各チャネルリレーログインデックスファイルのベース名。 <a class="xref" href="replication.html#channels-naming-conventions" title="17.2.2.4 レプリケーションチャネルのネーミング規則">セクション17.2.2.4「レプリケーションチャネルのネーミング規則」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="option">--relay-log=filename</code>
        </p><p>
          各チャネルリレーログファイルのベース名を示します。 <a class="xref" href="replication.html#channels-naming-conventions" title="17.2.2.4 レプリケーションチャネルのネーミング規則">セクション17.2.2.4「レプリケーションチャネルのネーミング規則」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="option">--slave_net-timeout=N</code>
        </p><p>
          この値はチャネルごとに設定されるため、各チャネルは <em class="replaceable"><code>N</code></em> 秒間待機して切断された接続をチェックします。
        </p></li><li class="listitem"><p>
          <code class="option">--slave-skip-counter=N</code>
        </p><p>
          この値はチャネルごとに設定されるため、各チャネルはソースからの <em class="replaceable"><code>N</code></em> イベントをスキップします。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="channels-naming-conventions"></a>17.2.2.4 レプリケーションチャネルのネーミング規則</h4></div></div></div><a class="indexterm" name="idm46723651039984"></a><p>
      このセクションでは、レプリケーションチャネルによるネーミング規則への影響について説明します。
    </p><p>
      各レプリケーションチャネルの一意の名前は、最大 64 文字の文字列で、大/小文字は区別されません。 チャネル名はレプリカアプライアンスのメタデータリポジトリテーブルで使用されるため、これらに使用される文字セットは常に UTF-8 です。 通常、チャネルには任意の名前を自由に使用できますが、次の名前は予約されています: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">group_replication_applier</code>
        </p></li><li class="listitem"><p>
          <code class="literal">group_replication_recovery</code>
        </p></li></ul></div><p>
      レプリケーションチャネルに選択した名前は、マルチソースレプリカで使用されるファイル名にも影響します。 各チャネルのリレーログファイルとインデックスファイルには <code class="filename"><em class="replaceable"><code>relay_log_basename</code></em>-<em class="replaceable"><code>channel</code></em>.xxxxxx</code> という名前が付けられます。ここで、<em class="replaceable"><code>relay_log_basename</code></em> は <code class="literal">relay_log</code> システム変数を使用して指定されたベース名、<em class="replaceable"><code>channel</code></em> はこのファイルに記録されたチャネルの名前です。 <code class="literal">relay_log</code> システム変数を指定しない場合は、チャネルの名前も含むデフォルトのファイル名が使用されます。 
    </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-implementation-details"></a>17.2.3 レプリケーションスレッド</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-threads-monitor-main">17.2.3.1 レプリケーションメインスレッドの監視</a></span></dt><dt><span class="section"><a href="replication.html#replication-threads-monitor-worker">17.2.3.2 レプリケーションアプライアンスワーカースレッドの監視</a></span></dt></dl></div><p>
      MySQL レプリケーション機能は、3 つのメインスレッド (ソースサーバー上のスレッドとレプリカ上のスレッド) を使用して実装されます:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>バイナリログダンプスレッド. </b>
            ソースは、レプリカの接続時にバイナリログの内容をレプリカに送信するスレッドを作成します。 このスレッドは、ソース上の <code class="literal">SHOW PROCESSLIST</code> の出力で <code class="literal">Binlog Dump</code> スレッドとして識別できます。 
          </p><p>
          バイナリログダンプスレッドは、レプリカに送信される各イベントを読み取るために、ソースバイナリログのロックを取得します。 イベントが読み取られるとすぐに、イベントがレプリカに送信される前でもロックが解除されます。 
        </p></li><li class="listitem"><p><b>レプリケーション I/O スレッド. </b>
            レプリカサーバーで <code class="literal">START REPLICA | SLAVE</code> ステートメントが発行されると、レプリカは I/O スレッドを作成します。このスレッドはソースに接続し、バイナリログに記録された更新を送信するように要求します。
          </p><p>
          レプリケーション I/O スレッドは、ソース <code class="literal">Binlog Dump</code> スレッドが送信した更新を読み取り (前の項目を参照)、レプリカリレーログを構成するローカルファイルにコピーします。
        </p><p>
          このスレッドの状態は、<code class="literal">SHOW SLAVE STATUS</code> の出力に <code class="literal">Slave_IO_running</code> として表示されます。
        </p></li><li class="listitem"><p><b>レプリケーション SQL スレッド. </b>
            レプリカは、レプリケーション I/O スレッドによって書き込まれるリレーログを読み取り、そこに含まれるトランザクションを実行する SQL スレッドを作成します。
          </p></li></ul></div><p>
      ソース/レプリカ接続ごとに 3 つのメインスレッドがあります。 複数のレプリカを持つソースは、現在接続されているレプリカごとに 1 つのバイナリログダンプスレッドを作成し、各レプリカには独自のレプリケーション I/O および SQL スレッドがあります。 
    </p><p>
      レプリカは 2 つのスレッドを使用して、読取り更新をソースから分離し、独立したタスクに実行します。 したがって、トランザクションの適用プロセスが遅い場合、トランザクションの読取りタスクは遅くなりません。 たとえば、レプリカサーバーがしばらく実行されていない場合、その I/O スレッドは、SQL スレッドが遠く遅れていても、レプリカの起動時にソースからすべてのバイナリログコンテンツをすばやくフェッチできます。 SQL スレッドがフェッチされたすべてのステートメントを実行する前にレプリカが停止した場合、I/O スレッドは少なくともすべてをフェッチして、トランザクションの安全なコピーがレプリカリレーログにローカルに格納され、レプリカの次回の起動時に実行できるようにします。 
    </p><p>
      <code class="literal">slave_parallel_workers</code> システム変数を 0 (デフォルト) より大きい値に設定することで、レプリカのタスクに対してさらにパラレル化を有効にできます。 このシステム変数を設定すると、レプリカは、トランザクションを適用するために指定された数のワーカースレッドと、それらを管理するためのコーディネータスレッドを作成します。 複数のレプリケーションチャネルを使用している場合、各チャネルにはこの数のスレッドがあります。 <code class="literal">slave_parallel_workers</code> が 0 より大きい値に設定されたレプリカは、マルチスレッドレプリカと呼ばれます。 この設定では、失敗したトランザクションを再試行できます。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        マルチスレッドレプリカは現在 NDB Cluster でサポートされていないため、この変数の設定は暗黙的に無視されます。 詳しくは<a class="xref" href="mysql-cluster.html#mysql-cluster-replication-issues" title="23.6.3 NDB Cluster レプリケーションの既知の問題">セクション23.6.3「NDB Cluster レプリケーションの既知の問題」</a>をご覧ください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-threads-monitor-main"></a>17.2.3.1 レプリケーションメインスレッドの監視</h4></div></div></div><p>
        <code class="literal">SHOW PROCESSLIST</code> ステートメントは、レプリケーションに関してソースおよびレプリカで何が起こっているかを示す情報を提供します。 ソースの状態の詳細は、<a class="xref" href="optimization.html#source-thread-states" title="8.14.4 レプリケーションソーススレッドの状態">セクション8.14.4「レプリケーションソーススレッドの状態」</a> を参照してください。 レプリカの状態については、<a class="xref" href="optimization.html#replica-io-thread-states" title="8.14.5 レプリケーション I/O スレッドの状態">セクション8.14.5「レプリケーション I/O スレッドの状態」</a> および <a class="xref" href="optimization.html#replica-sql-thread-states" title="8.14.6 レプリケーション SQL スレッドの状態">セクション8.14.6「レプリケーション SQL スレッドの状態」</a> を参照してください。 
      </p><p>
        次の例は、バイナリログダンプスレッド、Replicatin I/O スレッド、およびレプリケーション SQL スレッドの 3 つのメインレプリケーションスレッドが <code class="literal">SHOW PROCESSLIST</code> からの出力にどのように表示されるかを示しています。
      </p><p>
        ソースサーバーでは、<code class="literal">SHOW PROCESSLIST</code> からの出力は次のようになります:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW PROCESSLIST\G</code></strong>
*************************** 1. row ***************************
     Id: 2
   User: root
   Host: localhost:32931
     db: NULL
Command: Binlog Dump
   Time: 94
  State: Has sent all binlog to slave; waiting for binlog to
         be updated
   Info: NULL
</pre><p>
        ここで、スレッド 2 は接続レプリカにサービスを提供する <code class="literal">Binlog Dump</code> スレッドです。 <code class="literal">State</code> 情報は、すべての未処理の更新がレプリカに送信され、ソースがさらに更新が発生するのを待機していることを示します。 ソースサーバーに <code class="literal">Binlog Dump</code> スレッドが表示されない場合は、レプリケーションが実行されていないことを意味します。つまり、レプリカは現在接続されていません。 
      </p><p>
        レプリカサーバーでは、<code class="literal">SHOW PROCESSLIST</code> からの出力は次のようになります:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW PROCESSLIST\G</code></strong>
*************************** 1. row ***************************
     Id: 10
   User: system user
   Host:
     db: NULL
Command: Connect
   Time: 11
  State: Waiting for master to send event
   Info: NULL
*************************** 2. row ***************************
     Id: 11
   User: system user
   Host:
     db: NULL
Command: Connect
   Time: 11
  State: Has read all relay log; waiting for the slave I/O
         thread to update it
   Info: NULL
</pre><p>
        <code class="literal">State</code> 情報は、スレッド 10 がソースサーバーと通信しているレプリケーション I/O スレッドであり、スレッド 11 がリレーログに格納されている更新を処理しているレプリケーション SQL スレッドであることを示しています。 <code class="literal">SHOW PROCESSLIST</code> が実行された時点で、両方のスレッドはアイドルで、後続の更新を待機中でした。 
      </p><p>
        <code class="literal">Time</code> カラムの値は、レプリカがソースと比較される遅延を示すことができます。 <a class="xref" href="faqs.html#faqs-replication" title="A.14 MySQL 8.0 FAQ: レプリケーション">セクションA.14「MySQL 8.0 FAQ: レプリケーション」</a>を参照してください。 <code class="literal">Binlog Dump</code> スレッドのアクティビティなしでソース側で十分な時間が経過すると、ソースはレプリカが接続されなくなったと判断します。 ほかのクライアント接続に関して、これのタイムアウトは <code class="option">net_write_timeout</code> および <code class="option">net_retry_count</code> の値によって異なります。これらの詳細については、<a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>を参照してください。 
      </p><p>
        <code class="literal">SHOW REPLICA | SLAVE STATUS</code> ステートメントは、レプリカサーバーでのレプリケーション処理に関する追加情報を提供します。 <a class="xref" href="replication.html#replication-administration-status" title="17.1.7.1 レプリケーションステータスの確認">セクション17.1.7.1「レプリケーションステータスの確認」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-threads-monitor-worker"></a>17.2.3.2 レプリケーションアプライアンスワーカースレッドの監視</h4></div></div></div><p>
        マルチスレッドレプリカでは、「パフォーマンススキーマ」テーブル <code class="literal">replication_applier_status_by_coordinator</code> および <code class="literal">replication_applier_status_by_worker</code> に、レプリカコーディネータスレッドおよびアプライヤワーカースレッドのステータス情報がそれぞれ表示されます。 複数のチャネルを持つレプリカの場合、各チャネルのスレッドが識別されます。 
      </p><p>
        マルチスレッドレプリカコーディネータスレッドは、詳細設定が情報メッセージを表示するように設定されている場合、定期的にレプリカエラーログに統計も出力します。 統計は、コーディネータスレッドがアプライヤワーカースレッドに割り当てたイベントの量に応じて出力されます。最大頻度は 120 秒ごとに 1 回です。 このメッセージには、関連するレプリケーションチャネルまたはデフォルトのレプリケーションチャネル (名前のない) に関する次の統計がリストされます: 
      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">経過秒数</span></dt><dd><p>
              この情報がエラーログに最後に出力された時間と現在の時間の差 (秒)。
            </p></dd><dt><span class="term">イベント割当済</span></dt><dd><p>
              コーディネータスレッドが起動されてから、すべてのアプライヤワーカースレッドに対してコーディネータスレッドがキューに入れたイベントの合計数。
            </p></dd><dt><span class="term">オーバーランレベルを超えて入力されたワーカーキュー</span></dt><dd><p>
              オーバーランレベルを超えて、任意のアプライヤワーカースレッドにキューに入れられているイベントの現在の数。これは、16384 イベントの最大キュー長の 90% に設定されます。 この値がゼロの場合、アプライヤワーカースレッドは容量の上限で動作していません。 
            </p></dd><dt><span class="term">ワーカーキューがいっぱいであるため待機中</span></dt><dd><p>
              アプライヤワーカースレッドキューがいっぱいであったために、コーディネータスレッドがイベントのスケジュールを待機する必要があった回数。 この値がゼロの場合、アプライヤワーカースレッドは容量を使い果たしませんでした。 
            </p></dd><dt><span class="term">合計サイズのため待機中</span></dt><dd><p>
              <code class="literal">slave_pending_jobs_size_max</code> 制限に達したために、コーディネータスレッドがイベントのスケジュールを待機する必要があった回数。 このシステム変数は、まだ適用されていないイベントを保持するアプライヤワーカースレッドキューで使用可能なメモリーの最大量 (バイト) を設定します。 異常に大きいイベントがこのサイズを超えると、すべてのアプライヤワーカースレッドに空のキューが設定されてから処理されるまで、トランザクションは保持されます。 後続のすべてのトランザクションは、大規模なトランザクションが完了するまで保持されます。 
            </p></dd><dt><span class="term">クロック競合で待機中</span></dt><dd><p>
              イベントが依存していたトランザクションがまだコミットされていないために、コーディネータスレッドがイベントのスケジュールを待機する必要があったナノ秒数。 <code class="literal">slave_parallel_type</code> が (<code class="literal">LOGICAL_CLOCK</code> ではなく) <code class="literal">DATABASE</code> に設定されている場合、この値は常にゼロです。 
            </p></dd><dt><span class="term">ワーカーが占有している場合の待機 (件数)</span></dt><dd><p>
              コーディネータスレッドが短期間スリープした回数。これは 2 つの状況で実行される可能性があります。 最初の状況では、コーディネータスレッドがイベントを割り当て、最大キュー長の 10% のアンダーランレベルを超えて適用者ワーカースレッドキューが一杯であることが判明します。この場合、最大 1 ミリ秒スリープします。 2 つ目の状況では、<code class="literal">slave_parallel_type</code> が <code class="literal">LOGICAL_CLOCK</code> に設定され、コーディネータのスレッドがトランザクションの最初のイベントをアプライアンスのワーカースレッドキューに割り当てる必要があり、これは空のキューを持つワーカーに対してのみ実行されるため、キューが空でない場合、コーディネータスレッドは空になるまでスリープします。 
            </p></dd><dt><span class="term">ワーカーが占有している場合に待機</span></dt><dd><p>
              空のアプライヤワーカースレッドキューを待機している間にコーディネータスレッドがスリープしたナノ秒数 (つまり、前述の 2 つ目の状況では、<code class="literal">slave_parallel_type</code> が <code class="literal">LOGICAL_CLOCK</code> に設定され、トランザクションの最初のイベントを割り当てる必要があります)。
            </p></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replica-logs"></a>17.2.4 リレーログおよびレプリケーションメタデータリポジトリ</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replica-logs-relaylog">17.2.4.1 リレーログ</a></span></dt><dt><span class="section"><a href="replication.html#replica-logs-status">17.2.4.2 レプリケーションメタデータリポジトリ</a></span></dt></dl></div><a class="indexterm" name="idm46723650939504"></a><a class="indexterm" name="idm46723650937360"></a><a class="indexterm" name="idm46723650935232"></a><a class="indexterm" name="idm46723650933824"></a><a class="indexterm" name="idm46723650932416"></a><a class="indexterm" name="idm46723650930992"></a><a class="indexterm" name="idm46723650929568"></a><a class="indexterm" name="idm46723650928128"></a><a class="indexterm" name="idm46723650926672"></a><p>
      レプリカサーバーは、レプリケーションプロセスに使用する情報のリポジトリをいくつか作成します:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          レプリケーション I/O スレッドによって書き込まれるレプリカ<span class="emphasis"><em>リレーログ</em></span>には、レプリケーションソースサーバーのバイナリログから読み取られたトランザクションが含まれます。 リレーログ内のトランザクションは、レプリケーション SQL スレッドによってレプリカに適用されます。 リレーログについては、<a class="xref" href="replication.html#replica-logs-relaylog" title="17.2.4.1 リレーログ">セクション17.2.4.1「リレーログ」</a> を参照してください。 
        </p></li><li class="listitem"><p>
          レプリカ<span class="emphasis"><em>接続メタデータリポジトリ</em></span>には、レプリケーション I/O スレッドがレプリケーションソースサーバーに接続し、ソースバイナリログからトランザクションを取得するために必要な情報が含まれています。 接続メタデータリポジトリが <code class="literal">mysql.slave_master_info</code> テーブルに書き込まれます。 
        </p></li><li class="listitem"><p>
          レプリカ<span class="emphasis"><em>適用者メタデータリポジトリ</em></span>には、レプリケーション SQL スレッドがレプリカリレーログからトランザクションを読み取り、適用するために必要な情報が含まれています。 アプライヤメタデータリポジトリが <code class="literal">mysql.slave_relay_log_info</code> テーブルに書き込まれます。 
        </p></li></ul></div><p>
      レプリカ接続メタデータリポジトリと適用者メタデータリポジトリは、まとめてレプリケーションメタデータリポジトリと呼ばれます。 詳細は、<a class="xref" href="replication.html#replica-logs-status" title="17.2.4.2 レプリケーションメタデータリポジトリ">セクション17.2.4.2「レプリケーションメタデータリポジトリ」</a> を参照してください。 
    </p><p><a name="replication-implementation-crash-safe"></a><b>予期しない停止に対するレプリケーションの回復性の実現. </b>
        <code class="literal">mysql.slave_master_info</code> および <code class="literal">mysql.slave_relay_log_info</code> テーブルは、トランザクションストレージエンジン <code class="literal">InnoDB</code> を使用して作成されます。 レプリカアプライアンスのメタデータリポジトリテーブルへの更新は、トランザクションとともにコミットされます。つまり、予期しないサーバーが停止した場合でも、そのリポジトリに記録されるレプリカ進捗情報は、常にデータベースに適用されているものと一貫性があります。 予期しない停止に対して最も回復可能なレプリカの設定の組合せの詳細は、<a class="xref" href="replication.html#replication-solutions-unexpected-replica-halt" title="17.4.2 レプリカの予期しない停止の処理">セクション17.4.2「レプリカの予期しない停止の処理」</a> を参照してください。 
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replica-logs-relaylog"></a>17.2.4.1 リレーログ</h4></div></div></div><p>
        リレーログは、バイナリログと同様に、データベース変更を記述するイベントを含む番号付きファイルのセットと、使用されたすべてのリレーログファイルの名前を含むインデックスファイルとで構成されます。 リレーログファイルのデフォルトの場所はデータディレクトリです。 
      </p><p>
        用語<span class="quote">「<span class="quote">リレーログファイル</span>」</span>は一般的に、データベースイベントを含む個々の番号付きファイルを示します。 用語<span class="quote">「<span class="quote">リレーログ</span>」</span>は、番号付きリレーログファイルとインデックスファイルのセットの総称です。 
      </p><p>
        リレーログファイルはバイナリログファイルと同じ形式で、<span class="command"><strong>mysqlbinlog</strong></span> を使用して読み取ることができます (<a class="xref" href="programs.html#mysqlbinlog" title="4.6.8 mysqlbinlog — バイナリログファイルを処理するためのユーティリティー">セクション4.6.8「mysqlbinlog — バイナリログファイルを処理するためのユーティリティー」</a>を参照)。 バイナリログのトランザクション圧縮 (MySQL 8.0.20 の時点で使用可能) が使用されている場合、リレーログに書き込まれるトランザクションペイロードはバイナリログと同じ方法で圧縮されます。 バイナリログのトランザクション圧縮の詳細は、<a class="xref" href="server-administration.html#binary-log-transaction-compression" title="5.4.4.5 バイナリログトランザクション圧縮">セクション5.4.4.5「バイナリログトランザクション圧縮」</a> を参照してください。 
      </p><p>
        デフォルトのレプリケーションチャネルの場合、リレーログファイル名のデフォルト形式は <code class="filename"><em class="replaceable"><code>host_name</code></em>-relay-bin.<em class="replaceable"><code>nnnnnn</code></em></code> です。ここで、<em class="replaceable"><code>host_name</code></em> はレプリカサーバーホストの名前、<em class="replaceable"><code>nnnnnn</code></em> はシーケンス番号です。 連続するリレーログファイルは、<code class="literal">000001</code> で始まる連続シーケンス番号を使用して作成されます。 デフォルト以外のレプリケーションチャネルの場合、デフォルトのベース名は <code class="filename"><em class="replaceable"><code>host_name</code></em>-relay-bin-<em class="replaceable"><code>channel</code></em></code> です。ここで、<em class="replaceable"><code>channel</code></em> はリレーログに記録されたレプリケーションチャネルの名前です。 
      </p><p>
        レプリカはインデックスファイルを使用して、現在使用されているリレーログファイルを追跡します。 デフォルトのリレーログインデックスファイル名は、デフォルトチャネルの場合は <code class="filename"><em class="replaceable"><code>host_name</code></em>-relay-bin.index</code>、デフォルト以外のレプリケーションチャネルの場合は <code class="filename"><em class="replaceable"><code>host_name</code></em>-relay-bin-<em class="replaceable"><code>channel</code></em>.index</code> です。 
      </p><p>
        デフォルトのリレーログファイルとリレーログインデックスファイルの名前と場所は、それぞれ <code class="literal">relay_log</code> および <code class="literal">relay_log_index</code> システム変数でオーバーライドできます (<a class="xref" href="replication.html#replication-options" title="17.1.6 レプリケーションおよびバイナリロギングのオプションと変数">セクション17.1.6「レプリケーションおよびバイナリロギングのオプションと変数」</a> を参照)。
      </p><p>
        レプリカがデフォルトのホストベースのリレーログファイル名を使用する場合、レプリケーションの設定後にレプリカホスト名を変更すると、<span class="errortext">「リレーログのオープンに失敗しました」</span>および<span class="errortext">「リレーログの初期化中にターゲットログが見つかりませんでした」</span>のエラーでレプリケーションが失敗する可能性があります。 これは既知の問題です (Bug #2122 を参照してください)。 将来レプリカホスト名が変更される可能性があると予想される場合 (たとえば、DHCP を使用してホスト名を変更できるようにレプリカにネットワーキングが設定されている場合)、レプリカの初期設定時に <code class="literal">relay_log</code> および <code class="literal">relay_log_index</code> システム変数を使用してリレーログファイル名を明示的に指定することで、この問題を完全に回避できます。 これにより、名前はサーバーのホスト名の変更とは無関係になります。 
      </p><p>
        レプリケーションの開始後に問題が発生した場合に対処するには、レプリカサーバーを停止し、古いリレーログインデックスファイルの内容を新しいファイルの先頭に追加してからレプリカを再起動します。 Unix システムでは、ここで示すようにこれを実行できます。 
      </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>cat <em class="replaceable"><code>new_relay_log_name</code></em>.index &gt;&gt; <em class="replaceable"><code>old_relay_log_name</code></em>.index</code></strong>
shell&gt; <strong class="userinput"><code>mv <em class="replaceable"><code>old_relay_log_name</code></em>.index <em class="replaceable"><code>new_relay_log_name</code></em>.index</code></strong>
</pre><p>
        複製サーバーは、次の条件下で新しいリレーログファイルを作成します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            レプリケーション I/O スレッドが開始されるたび。
          </p></li><li class="listitem"><p>
            ログがフラッシュされるタイミング (<code class="literal">FLUSH LOGS</code> や <span class="command"><strong>mysqladmin flush-logs</strong></span> などを使用)。
          </p></li><li class="listitem"><p>
            現在のリレーログファイルのサイズが大きすぎる場合は、次のように決定されます:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">max_relay_log_size</code> (最大リレーログファイルサイズ) の値が 0 より大きい場合。
              </p></li><li class="listitem"><p>
                <code class="literal">max_relay_log_size</code> の値が 0 の場合、<code class="literal">max_binlog_size</code> が最大リレーログファイルサイズを判断します。
              </p></li></ul></div></li></ul></div><p>
        レプリケーション SQL スレッドは、ファイル内のすべてのイベントを実行し、不要になったあと、各リレーログファイルを自動的に削除します。 レプリケーション SQL スレッドがリレーログを削除するための明示的なメカニズムはありません。 ただし、<code class="literal">FLUSH LOGS</code> はリレーログをローテーションするため、レプリケーション SQL スレッドがリレーログを削除するタイミングに影響します。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replica-logs-status"></a>17.2.4.2 レプリケーションメタデータリポジトリ</h4></div></div></div><p>
        レプリカサーバーは、接続メタデータリポジトリと適用者メタデータリポジトリの 2 つのレプリケーションメタデータリポジトリを作成します。 レプリケーションメタデータリポジトリは、レプリカサーバーの停止後も存続します。 バイナリログファイルの位置ベースのレプリケーションを使用している場合、レプリカは再起動時に 2 つのリポジトリを読み取り、以前にソースからバイナリログを読み取り、独自のリレーログを処理していた距離を判断します。 GTID ベースのレプリケーションが使用されている場合、レプリカはその目的のためにレプリケーションメタデータリポジトリを使用しませんが、含まれている他のメタデータのために必要です。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            レプリカ<span class="emphasis"><em>接続メタデータリポジトリ</em></span>には、レプリケーション I/O スレッドがレプリケーションソースサーバーに接続し、ソースバイナリログからトランザクションを取得するために必要な情報が含まれています。 このリポジトリのメタデータには、接続構成、レプリケーションユーザーアカウントの詳細、接続の SSL 設定、レプリケーション I/O スレッドがソースバイナリログから現在読み取っているファイル名と位置が含まれます。 
          </p></li><li class="listitem"><p>
            レプリカ<span class="emphasis"><em>適用者メタデータリポジトリ</em></span>には、レプリケーション SQL スレッドがレプリカリレーログからトランザクションを読み取り、適用するために必要な情報が含まれています。 このリポジトリのメタデータには、レプリケーション SQL スレッドがリレーログ内のトランザクションを実行したファイル名と位置、およびソースバイナリログ内の同等の位置が含まれます。 また、ワーカースレッドの数やチャネルの <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントなど、トランザクションを適用するプロセスのメタデータも含まれます。 
          </p></li></ul></div><p>
        接続メタデータリポジトリは <code class="literal">mysql</code> システムスキーマの <code class="literal">slave_master_info</code> テーブルに書き込まれ、適用者メタデータリポジトリは <code class="literal">mysql</code> システムスキーマの <code class="literal">slave_relay_log_info</code> テーブルに書き込まれます。 <span class="command"><strong>mysqld</strong></span> がレプリケーションメタデータリポジトリのテーブルを初期化できないが、レプリカの起動を続行できる場合は、警告メッセージが発行されます。 この状況は、リポジトリのテーブルの使用をサポートしていない MySQL のバージョンから、サポートされているバージョンにアップグレードする場合に最も発生する可能性があります。 
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              <code class="literal">mysql.slave_master_info</code> または <code class="literal">mysql.slave_relay_log_info</code> テーブルの行を手動で更新または挿入しないでください。 そのようにすることは、未定義の動作になる可能性があり、サポートされていません。 レプリケーションの進行中は、<code class="literal">slave_master_info</code> テーブルと <code class="literal">slave_relay_log_info</code> テーブルのいずれかまたは両方で書込みロックを必要とするステートメントの実行は許可されません (ただし、読取りのみを実行するステートメントはいつでも許可されます)。 
            </p></li><li class="listitem"><p>
              接続メタデータリポジトリテーブル <code class="literal">mysql.slave_master_info</code> のアクセス権限は、ソースに接続するためのレプリケーションユーザーアカウント名とパスワードが含まれているため、データベース管理者に制限する必要があります。 このテーブルを含むデータベースバックアップを保護するには、制限付きアクセスモードを使用します。 MySQL 8.0.21 から、レプリケーションユーザーアカウントの資格証明を接続メタデータリポジトリからクリアし、かわりにレプリケーションチャネルを起動する <code class="literal">START REPLICA | SLAVE</code> ステートメントまたは <code class="literal">START GROUP_REPLICATION</code> ステートメントを使用してそれらを常に指定できます。 このアプローチでは、レプリケーションチャネルを再起動するためにオペレータの介入が常に必要ですが、アカウント名とパスワードはレプリケーションメタデータリポジトリに記録されません。 
            </p></li></ol></div></div><p>
        <code class="literal">RESET REPLICA | SLAVE</code> は、レプリケーション接続パラメータ (MySQL Server リリースによって異なります) を除いて、レプリケーションメタデータリポジトリ内のデータをクリアします。 詳細は、<code class="literal">RESET REPLICA | SLAVE</code> の説明を参照してください。 
      </p><p>
        MySQL 8.0 より前は、レプリケーションメタデータリポジトリをテーブルとして作成するには、サーバーの起動時に <code class="literal">master_info_repository=TABLE</code> および <code class="literal">relay_log_info_repository=TABLE</code> を指定する必要がありました。 それ以外の場合、リポジトリは、<code class="filename">master.info</code> および <code class="filename">relay-log.info</code> という名前のデータディレクトリにファイルとして作成されたか、<code class="option">--master-info-file</code> オプションおよび <code class="literal">relay_log_info_file</code> システム変数で指定された代替の名前と場所を使用して作成されました。 MySQL 8.0 からは、レプリケーションメタデータリポジトリをテーブルとして作成することがデフォルトであり、これらすべてのシステム変数の使用は非推奨になりました。 
      </p><p>
        <code class="literal">mysql.slave_master_info</code> および <code class="literal">mysql.slave_relay_log_info</code> テーブルは、<code class="literal">InnoDB</code> トランザクションストレージエンジンを使用して作成されます。 アプライヤメタデータリポジトリテーブルへの更新は、トランザクションとともにコミットされます。つまり、予期しないサーバーが停止した場合でも、そのリポジトリに記録されるレプリカ進捗情報は、常にデータベースに適用されているものと一貫性があります。 予期しない停止に対して最も回復可能なレプリカの設定の組合せの詳細は、<a class="xref" href="replication.html#replication-solutions-unexpected-replica-halt" title="17.4.2 レプリカの予期しない停止の処理">セクション17.4.2「レプリカの予期しない停止の処理」</a> を参照してください。 
      </p><p>
        レプリカデータをバックアップするか、そのデータのスナップショットを転送して新しいレプリカを作成する場合は、レプリケーションメタデータリポジトリを含む <code class="literal">mysql.slave_master_info</code> および <code class="literal">mysql.slave_relay_log_info</code> テーブルを必ず含めてください。 クローニング操作の場合、レプリケーションメタデータリポジトリがテーブルとして作成されると、クローニング操作中に受信者にコピーされますが、ファイルとして作成されるとコピーされないことに注意してください。 バイナリログファイルの位置ベースのレプリケーションが使用されている場合、レプリケーションメタデータリポジトリは、復元、コピー、またはクローニングされたレプリカの再起動後にレプリケーションを再開するために必要です。 リレーログファイルはないが、まだアプライヤメタデータリポジトリがある場合は、それをチェックして、レプリケーション SQL スレッドがソースバイナリログで実行された距離を判断できます。 その後、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23 から) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 より前) を <code class="literal">SOURCE_LOG_FILE</code> | <code class="literal">MASTER_LOG_FILE</code> および <code class="literal">SOURCE_LOG_POS</code> | <code class="literal">MASTER_LOG_POS</code> オプションとともに使用して、必要なバイナリログをソースログに再度読み取り、バイナリログからレプリカを読み取ることができます。 
      </p><p>
        追加のリポジトリであるアプライヤワーカーメタデータリポジトリは、主に内部使用のために作成され、マルチスレッドレプリカ上のワーカースレッドに関するステータス情報を保持します。 アプライヤワーカーメタデータリポジトリには、リレーログファイルの名前と位置、および各ワーカースレッドのソースバイナリログファイルが含まれます。 アプライヤメタデータリポジトリがテーブルとして作成されている場合 (デフォルト)、アプライヤワーカーメタデータリポジトリは <code class="literal">mysql.slave_worker_info</code> テーブルに書き込まれます。 適用者メタデータリポジトリがファイルに書き込まれると、適用者ワーカーメタデータリポジトリが <code class="filename">worker-relay-log.info</code> ファイルに書き込まれます。 外部で使用するために、ワーカースレッドのステータス情報がパフォーマンススキーマ <code class="literal">replication_applier_status_by_worker</code> テーブルに表示されます。 
      </p><p>
        レプリケーションメタデータリポジトリには、<a class="xref" href="sql-statements.html#replication-statements-replica" title="13.4.2 レプリケーションサーバーを制御するための SQL ステートメント">セクション13.4.2「レプリケーションサーバーを制御するための SQL ステートメント」</a> で説明されている <code class="literal">SHOW REPLICA | SLAVE STATUS</code> ステートメントの出力に示されているような情報が最初に含まれていました。 <code class="literal">SHOW REPLICA | SLAVE STATUS</code> ステートメントで表示されないレプリケーションメタデータリポジトリに追加された情報。 
      </p><p>
        接続メタデータリポジトリの場合、次のテーブルに、<code class="literal">mysql.slave_master_info</code> テーブルのカラム、<code class="literal">SHOW REPLICA | SLAVE STATUS</code> によって表示されるカラムおよび非推奨の <code class="filename">master.info</code> ファイルの行の対応関係を示します。
      </p><div class="informaltable"><table summary="The correspondence between the columns in the mysql.slave_master_info table, the columns displayed by SHOW REPLICA STATUS or SHOW SLAVE STATUS, and the lines in the deprecated master.info file."><col style="width=31%"><col style="width=40%"><col style="width=16%"><col style="width=18%"><thead><tr>
            <th scope="col"><code class="literal">slave_master_info</code> テーブルのカラム</th>
            <th scope="col"><code class="literal">SHOW REPLICA | SLAVE STATUS</code> カラム</th>
            <th scope="col"><code class="filename">master.info</code> ファイル行</th>
            <th scope="col">説明</th>
          </tr></thead><tbody><tr>
            <th scope="row"><code class="literal">Number_of_lines</code></th>
            <td>[None]</td>
            <td>1</td>
            <td>テーブル (またはファイル内の行) のカラム数</td>
          </tr><tr>
            <th scope="row"><code class="literal">Master_log_name</code></th>
            <td><code class="literal">Source_Log_File</code></td>
            <td>2</td>
            <td>ソースから現在読み取られているバイナリログの名前</td>
          </tr><tr>
            <th scope="row"><code class="literal">Master_log_pos</code></th>
            <td><code class="literal">Read_Source_Log_Pos</code></td>
            <td>3</td>
            <td>ソースから読み取られたバイナリログ内の現在の位置</td>
          </tr><tr>
            <th scope="row"><code class="literal">Host</code></th>
            <td><code class="literal">Source_Host</code></td>
            <td>4</td>
            <td>レプリケーションソースサーバーのホスト名</td>
          </tr><tr>
            <th scope="row"><code class="literal">User_name</code></th>
            <td><code class="literal">Source_User</code></td>
            <td>5</td>
            <td>ソースへの接続に使用されるレプリケーションユーザーアカウント名</td>
          </tr><tr>
            <th scope="row"><code class="literal">User_password</code></th>
            <td>パスワード (<code class="literal">SHOW REPLICA | SLAVE STATUS</code> では表示されません)</td>
            <td>6</td>
            <td>ソースへの接続に使用されるレプリケーションユーザーアカウントのパスワード</td>
          </tr><tr>
            <th scope="row"><code class="literal">Port</code></th>
            <td><code class="literal">Source_Port</code></td>
            <td>7</td>
            <td>レプリケーションソースサーバーへの接続に使用されるネットワークポート</td>
          </tr><tr>
            <th scope="row"><code class="literal">Connect_retry</code></th>
            <td><code class="literal">Connect_Retry</code></td>
            <td>8</td>
            <td>レプリカがソースへの再接続を試行するまで待機する期間 (秒)</td>
          </tr><tr>
            <th scope="row"><code class="literal">Enabled_ssl</code></th>
            <td><code class="literal">Source_SSL_Allowed</code></td>
            <td>9</td>
            <td>レプリカが SSL 接続をサポートするかどうか</td>
          </tr><tr>
            <th scope="row"><code class="literal">Ssl_ca</code></th>
            <td><code class="literal">Source_SSL_CA_File</code></td>
            <td>10</td>
            <td>認証局 (CA) 証明書に使用されるファイル</td>
          </tr><tr>
            <th scope="row"><code class="literal">Ssl_capath</code></th>
            <td><code class="literal">Source_SSL_CA_Path</code></td>
            <td>11</td>
            <td>認証局 (CA) 証明書へのパス</td>
          </tr><tr>
            <th scope="row"><code class="literal">Ssl_cert</code></th>
            <td><code class="literal">Source_SSL_Cert</code></td>
            <td>12</td>
            <td>SSL 証明書ファイルの名前</td>
          </tr><tr>
            <th scope="row"><code class="literal">Ssl_cipher</code></th>
            <td><code class="literal">Source_SSL_Cipher</code></td>
            <td>13</td>
            <td>SSL 接続のハンドシェイクで使用される可能な暗号のリスト</td>
          </tr><tr>
            <th scope="row"><code class="literal">Ssl_key</code></th>
            <td><code class="literal">Source_SSL_Key</code></td>
            <td>14</td>
            <td>SSL キーファイルの名前</td>
          </tr><tr>
            <th scope="row"><code class="literal">Ssl_verify_server_cert</code></th>
            <td><code class="literal">Source_SSL_Verify_Server_Cert</code></td>
            <td>15</td>
            <td>サーバー証明書を検証するかどうか</td>
          </tr><tr>
            <th scope="row"><code class="literal">Heartbeat</code></th>
            <td>[None]</td>
            <td>16</td>
            <td>レプリケーションハートビートの間隔 （秒単位）</td>
          </tr><tr>
            <th scope="row"><code class="literal">Bind</code></th>
            <td><code class="literal">Source_Bind</code></td>
            <td>17</td>
            <td>ソースへの接続に使用するレプリカネットワークインタフェース</td>
          </tr><tr>
            <th scope="row"><code class="literal">Ignored_server_ids</code></th>
            <td><code class="literal">Replicate_Ignore_Server_Ids</code></td>
            <td>18</td>
            <td>無視するサーバー ID のリスト。 <code class="literal">Ignored_server_ids</code> の場合、サーバー ID のリストの前に、無視するサーバー ID の合計数が付きます。 </td>
          </tr><tr>
            <th scope="row"><code class="literal">Uuid</code></th>
            <td><code class="literal">Source_UUID</code></td>
            <td>19</td>
            <td>ソースの一意の ID</td>
          </tr><tr>
            <th scope="row"><code class="literal">Retry_count</code></th>
            <td><code class="literal">Source_Retry_Count</code></td>
            <td>20</td>
            <td>許容される再接続試行の最大数</td>
          </tr><tr>
            <th scope="row"><code class="literal">Ssl_crl</code></th>
            <td>[None]</td>
            <td>21</td>
            <td>SSL 証明書失効リストファイルへのパス</td>
          </tr><tr>
            <th scope="row"><code class="literal">Ssl_crlpath</code></th>
            <td>[None]</td>
            <td>22</td>
            <td>SSL 証明書失効リストファイルを含むディレクトリへのパス</td>
          </tr><tr>
            <th scope="row"><code class="literal">Enabled_auto_position</code></th>
            <td><code class="literal">Auto_position</code></td>
            <td>23</td>
            <td>GTID 自動配置が使用中かどうか</td>
          </tr><tr>
            <th scope="row"><code class="literal">Channel_name</code></th>
            <td><code class="literal">Channel_name</code></td>
            <td>24</td>
            <td>レプリケーションチャネルの名前</td>
          </tr><tr>
            <th scope="row"><code class="literal">Tls_version</code></th>
            <td><code class="literal">Source_TLS_Version</code></td>
            <td>25</td>
            <td>ソースの TLS バージョン</td>
          </tr><tr>
            <th scope="row"><code class="literal">Public_key_path</code></th>
            <td><code class="literal">Source_public_key_path</code></td>
            <td>26</td>
            <td>RSA 公開キーファイルの名前</td>
          </tr><tr>
            <th scope="row"><code class="literal">Get_public_key</code></th>
            <td><code class="literal">Get_source_public_key</code></td>
            <td>27</td>
            <td>ソースから RSA 公開キーをリクエストするかどうか</td>
          </tr><tr>
            <th scope="row"><code class="literal">Network_namespace</code></th>
            <td><code class="literal">Network_namespace</code></td>
            <td>28</td>
            <td>ネットワークネームスペース</td>
          </tr><tr>
            <th scope="row"><code class="literal">Master_compression_algorithm</code></th>
            <td>[None]</td>
            <td>29</td>
            <td>ソースへの接続に許可される圧縮アルゴリズム</td>
          </tr><tr>
            <th scope="row"><code class="literal">Master_zstd_compression_level</code></th>
            <td>[None]</td>
            <td>30</td>
            <td><code class="literal">zstd</code> 圧縮レベル</td>
          </tr><tr>
            <th scope="row"><code class="literal">Tls_ciphersuites</code></th>
            <td>[None]</td>
            <td>31</td>
            <td>TLSv1.3 で許可される暗号スイート</td>
          </tr><tr>
            <th scope="row"><code class="literal">Source_connection_auto_failover</code></th>
            <td>[None]</td>
            <td>32</td>
            <td>非同期接続フェイルオーバーメカニズムをアクティブ化するかどうか</td>
          </tr></tbody></table></div><p>
        アプライヤメタデータリポジトリの場合、次のテーブルに、<code class="literal">mysql.slave_relay_log_info</code> テーブルのカラム、<code class="literal">SHOW REPLICA | SLAVE STATUS</code> によって表示されるカラムおよび非推奨の <code class="filename">relay-log.info</code> ファイルの行の対応関係を示します。
      </p><div class="informaltable"><table summary="The correspondence between the columns in the mysql.slave_relay_log_info table, the columns displayed by SHOW REPLICA STATUS or SHOW SLAVE STATUS, and the lines in the deprecated relay-log.info file."><col style="width=30%"><col style="width=40%"><col style="width=15%"><col style="width=20%"><thead><tr>
            <th scope="col"><code class="literal">slave_relay_log_info</code> テーブルのカラム</th>
            <th scope="col"><code class="literal">SHOW REPLICA | SLAVE STATUS</code> カラム</th>
            <th scope="col"><code class="filename">relay-log.info</code> ファイルの行</th>
            <th scope="col">説明</th>
          </tr></thead><tbody><tr>
            <th scope="row"><code class="literal">Number_of_lines</code></th>
            <td>[None]</td>
            <td>1</td>
            <td>ファイル内のテーブルまたは行のカラム数</td>
          </tr><tr>
            <th scope="row"><code class="literal">Relay_log_name</code></th>
            <td><code class="literal">Relay_Log_File</code></td>
            <td>2</td>
            <td>現在のリレーログファイルの名前</td>
          </tr><tr>
            <th scope="row"><code class="literal">Relay_log_pos</code></th>
            <td><code class="literal">Relay_Log_Pos</code></td>
            <td>3</td>
            <td>リレーログファイル内の現在の位置。この位置までのイベントがレプリカデータベース上で実行されています</td>
          </tr><tr>
            <th scope="row"><code class="literal">Master_log_name</code></th>
            <td><code class="literal">Relay_Source_Log_File</code></td>
            <td>4</td>
            <td>リレーログファイル内のイベントが読み取られたソースバイナリログファイルの名前</td>
          </tr><tr>
            <th scope="row"><code class="literal">Master_log_pos</code></th>
            <td><code class="literal">Exec_Source_Log_Pos</code></td>
            <td>5</td>
            <td>レプリカで実行されたイベントのソースバイナリログファイル内の同等の位置</td>
          </tr><tr>
            <th scope="row"><code class="literal">Sql_delay</code></th>
            <td><code class="literal">SQL_Delay</code></td>
            <td>6</td>
            <td>レプリカがソースを遅らせる必要がある秒数</td>
          </tr><tr>
            <th scope="row"><code class="literal">Number_of_workers</code></th>
            <td>[None]</td>
            <td>7</td>
            <td>レプリケーショントランザクションをパラレルに適用するワーカースレッドの数</td>
          </tr><tr>
            <th scope="row"><code class="literal">Id</code></th>
            <td>[None]</td>
            <td>8</td>
            <td>内部目的に使用される ID。現在は常に 1 です</td>
          </tr><tr>
            <th scope="row"><code class="literal">Channel_name</code></th>
            <td><code class="literal">Channel_name</code></td>
            <td>9</td>
            <td>レプリケーションチャネルの名前</td>
          </tr><tr>
            <th scope="row"><code class="literal">Privilege_checks_username</code></th>
            <td>[None]</td>
            <td>10</td>
            <td>チャネルの <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントのユーザー名</td>
          </tr><tr>
            <th scope="row"><code class="literal">Privilege_checks_hostname</code></th>
            <td>[None]</td>
            <td>11</td>
            <td>チャネルの <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントのホスト名</td>
          </tr><tr>
            <th scope="row"><code class="literal">Require_row_format</code></th>
            <td>[None]</td>
            <td>12</td>
            <td>チャネルが行ベースのイベントのみを受け入れるかどうか</td>
          </tr><tr>
            <th scope="row"><code class="literal">Require_table_primary_key_check</code></th>
            <td>[None]</td>
            <td>13</td>
            <td><code class="literal">CREATE TABLE</code> および <code class="literal">ALTER TABLE</code> 操作のためにテーブルに主キーが必要かどうかに関するチャネルポリシー</td>
          </tr><tr>
            <th scope="row"><code class="literal">Assign_gtids_to_anonymous_transactions_type </code></th>
            <td>[None]</td>
            <td>14</td>
            <td>チャネルが GTID をまだ持っていないレプリケートトランザクションに割り当てるかどうか、および割り当てられている場合はレプリカローカル UUID を使用するか手動で設定した UUID を使用するかどうか</td>
          </tr><tr>
            <th scope="row"><code class="literal">Assign_gtids_to_anonymous_transactions_value </code></th>
            <td>[None]</td>
            <td>15</td>
            <td>匿名トランザクションに割り当てられた GTID で使用される UUID</td>
          </tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-rules"></a>17.2.5 サーバーがレプリケーションフィルタリングルールをどのように評価するか</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-rules-db-options">17.2.5.1 データベースレベルレプリケーションオプションおよびバイナリロギングオプションの評価</a></span></dt><dt><span class="section"><a href="replication.html#replication-rules-table-options">17.2.5.2 テーブルレベルレプリケーションオプションの評価</a></span></dt><dt><span class="section"><a href="replication.html#replication-rules-examples">17.2.5.3 レプリケーションフィルタリングオプション間の相互作用</a></span></dt><dt><span class="section"><a href="replication.html#replication-rules-channel-based-filters">17.2.5.4 レプリケーションチャネルベースのフィルタ</a></span></dt></dl></div><p>
      レプリケーションソースサーバーがステートメントをバイナリログに書き込まない場合、ステートメントはレプリケートされません。 サーバーがステートメントをログに記録する場合、ステートメントはすべてのレプリカに送信され、各レプリカはステートメントを実行するか無視するかを決定します。 
    </p><p>
      ソースでは、<code class="option">--binlog-do-db</code> および <code class="option">--binlog-ignore-db</code> オプションを使用してバイナリロギングを制御することによって、変更を記録するデータベースを制御できます。 これらのオプションを評価するときにサーバーが使用するルールの詳細は、<a class="xref" href="replication.html#replication-rules-db-options" title="17.2.5.1 データベースレベルレプリケーションオプションおよびバイナリロギングオプションの評価">セクション17.2.5.1「データベースレベルレプリケーションオプションおよびバイナリロギングオプションの評価」</a>を参照してください。 複製するデータベースとテーブルを制御するためにこれらのオプションを使用しないでください。 代わりに、レプリカでフィルタリングを使用して、レプリカで実行されるイベントを制御します。 
    </p><p>
      レプリカ側では、ソースから受け取ったステートメントを実行するか無視するかに関する決定は、レプリカが起動された <code class="option">--replicate-*</code> オプションに従って行われます。 <a class="xref" href="replication.html#replication-options" title="17.1.6 レプリケーションおよびバイナリロギングのオプションと変数">セクション17.1.6「レプリケーションおよびバイナリロギングのオプションと変数」</a>を参照してください。 これらのオプションによって制御されるフィルタは、<code class="literal">CHANGE REPLICATION FILTER</code> ステートメントを使用して動的に設定することもできます。 このようなフィルタを制御するルールは、<code class="option">--replicate-*</code> オプションを使用して起動時に作成されるか、<code class="literal">CHANGE REPLICATION FILTER</code> によってレプリカサーバーが実行されている間に作成されるかに関係なく同じです。 レプリケーションフィルタは、グループレプリケーション用に構成された MySQL サーバーインスタンス上のグループレプリケーション固有のチャネルでは使用できません。これは、一部のサーバーでトランザクションをフィルタすると、グループが一貫性のある状態で承諾に到達できなくなるためです。 
    </p><p>
      最も単純なケースでは、<code class="option">--replicate-*</code> オプションがない場合、レプリカはソースから受信したすべてのステートメントを実行します。 そうでない場合は、結果は指定された特定のオプションに依存します。 
    </p><p>
      データベースレベルオプション (<code class="option">--replicate-do-db</code>、<code class="option">--replicate-ignore-db</code>) が最初にチェックされます。このプロセスの説明については、<a class="xref" href="replication.html#replication-rules-db-options" title="17.2.5.1 データベースレベルレプリケーションオプションおよびバイナリロギングオプションの評価">セクション17.2.5.1「データベースレベルレプリケーションオプションおよびバイナリロギングオプションの評価」</a>を参照してください。 データベースレベルオプションが使用されない場合は、オプションチェックはテーブルレベルオプション (使用されている場合がある) のチェックに進みます (これらの説明については、<a class="xref" href="replication.html#replication-rules-table-options" title="17.2.5.2 テーブルレベルレプリケーションオプションの評価">セクション17.2.5.2「テーブルレベルレプリケーションオプションの評価」</a>を参照してください)。 1 つ以上のデータベースレベルオプションが使用されているけれども、一致するものがない場合は、ステートメントは複製されません。 
    </p><p>
      データベースにのみ影響するステートメントの場合 (つまり、<code class="literal">CREATE DATABASE</code>、<code class="literal">DROP DATABASE</code>、および <code class="literal">ALTER DATABASE</code>)、データベースレベルオプションは <code class="option">--replicate-wild-do-table</code> オプションより常に優先されます。 つまり、このようなステートメントの場合、適用するデータベースレベルオプションがない場合にかぎり、<code class="option">--replicate-wild-do-table</code> オプションがチェックされます。 
    </p><p>
      特定のオプションセットにどのような影響があるかを簡単に判断できるように、<code class="option">do-*</code> オプションと <code class="option">ignore-*</code> オプション、またはワイルドカードを含むオプションとそれ以外のオプションを混在させないことをお薦めします。
    </p><p>
      <code class="option">--replicate-rewrite-db</code> オプションが指定された場合、それらは <code class="option">--replicate-*</code> フィルタリングルールがテストされる前に適用されます。
    </p><a class="indexterm" name="idm46723650514384"></a><a class="indexterm" name="idm46723650512096"></a><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        すべてのレプリケーションフィルタリングオプションは、<code class="literal">lower_case_table_names</code> システム変数の影響を含め、MySQL サーバーの他の場所にあるデータベースおよびテーブルの名前に適用される大/小文字の区別について同じルールに従います。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-rules-db-options"></a>17.2.5.1 データベースレベルレプリケーションオプションおよびバイナリロギングオプションの評価</h4></div></div></div><p>
        レプリケーションオプションを評価する場合、レプリカはまず、適用される <code class="option">--replicate-do-db</code> または <code class="option">--replicate-ignore-db</code> オプションがあるかどうかを確認します。 <code class="option">--binlog-do-db</code> または <code class="option">--binlog-ignore-db</code> を使用する場合、プロセスは似ていますが、オプションはソースでチェックされます。 
      </p><p>
        一致がチェックされるデータベースは、処理されるステートメントのバイナリログ形式によって異なります。 ステートメントが行形式を使用してログに記録されている場合、データが変更されるデータベースはチェックされるデータベースです。 ステートメントがステートメントの形式を使用してログに記録されている場合、デフォルトのデータベース (<code class="literal">USE</code> ステートメントで指定) がチェックされるデータベースになります。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          行形式を使用してログに記録できるのは DML ステートメントのみです。 DDL ステートメントは、<code class="literal">binlog_format=ROW</code> の場合でも、常にステートメントとして記録されます。 したがって、すべての DDL ステートメントは、ステートメントベースのレプリケーションのルールに従って常にフィルタ処理されます。 つまり、DDL ステートメントを適用するには、<code class="literal">USE</code> ステートメントを使用してデフォルトのデータベースを明示的に選択する必要があります。 
        </p></div><p>
        レプリケーションの場合、関連するステップは次のとおりです:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            どのロギング形式が使用されますか。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>STATEMENT. </b>
                  デフォルトのデータベースをテストします。
                </p></li><li class="listitem"><p><b>ROW. </b>
                  変更の影響を受けるデータベースをテストします。
                </p></li></ul></div></li><li class="listitem"><p>
            <code class="option">--replicate-do-db</code> オプションはありますか ?
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい. </b>
                  データベースはこれらのいずれかと一致しますか。

                  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>はい. </b>
                          ステップ 4 に進みます。
                        </p></li><li class="listitem"><p><b>いいえ. </b>
                          更新を無視して終了します。
                        </p></li></ul></div><p>
                </p></li><li class="listitem"><p><b>いいえ. </b>
                  手順 3 に進みます。
                </p></li></ul></div></li><li class="listitem"><p>
            <code class="option">--replicate-ignore-db</code> オプションはありますか ?
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい. </b>
                  データベースはこれらのいずれかと一致しますか。

                  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>はい. </b>
                          更新を無視して終了します。
                        </p></li><li class="listitem"><p><b>いいえ. </b>
                          手順 4 に進みます。
                        </p></li></ul></div><p>
                </p></li><li class="listitem"><p><b>いいえ. </b>
                  手順 4 に進みます。
                </p></li></ul></div></li><li class="listitem"><p>
            テーブルレベルレプリケーションオプションがある場合、それらの検査に進みます。 これらのオプションの検査方法の説明については、<a class="xref" href="replication.html#replication-rules-table-options" title="17.2.5.2 テーブルレベルレプリケーションオプションの評価">セクション17.2.5.2「テーブルレベルレプリケーションオプションの評価」</a>を参照してください。 
          </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
              この段階でまだ許可されているステートメントは、実際にはまだ実行されていません。 ステートメントはすべてのテーブルレベルオプション （ある場合） が検査されるまで実行されず、そのプロセスの結果がステートメントの実行を許可します。 
            </p></div></li></ol></div><p>
        バイナリロギングの場合、関連する手順の一覧は次のとおりです。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <code class="option">--binlog-do-db</code> または <code class="option">--binlog-ignore-db</code> オプションはありますか ?
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい. </b>
                  手順 2 に進みます。
                </p></li><li class="listitem"><p><b>いいえ. </b>
                  ステートメントのログを記録して終了します。
                </p></li></ul></div></li><li class="listitem"><p>
            デフォルトデータベースはありますか (データベースが <code class="literal">USE</code> で選択されていますか) ?
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい. </b>
                  手順 3 に進みます。
                </p></li><li class="listitem"><p><b>いいえ. </b>
                  ステートメントを無視して終了します。
                </p></li></ul></div></li><li class="listitem"><p>
            デフォルトデータベースがあります。 <code class="option">--binlog-do-db</code> オプションはありますか ? 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい. </b>
                  それらのいずれかがデータベースに一致しますか ?

                  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>はい. </b>
                          ステートメントのログを記録して終了します。
                        </p></li><li class="listitem"><p><b>いいえ. </b>
                          ステートメントを無視して終了します。
                        </p></li></ul></div><p>
                </p></li><li class="listitem"><p><b>いいえ. </b>
                  手順 4 に進みます。
                </p></li></ul></div></li><li class="listitem"><p>
            <code class="option">--binlog-ignore-db</code> オプションのいずれかがデータベースに一致しますか ?
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい. </b>
                  ステートメントを無視して終了します。
                </p></li><li class="listitem"><p><b>いいえ. </b>
                  ステートメントのログを記録して終了します。
                </p></li></ul></div></li></ol></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          ステートメントベースロギングの場合、<code class="literal">CREATE DATABASE</code>、<code class="literal">ALTER DATABASE</code>、および <code class="literal">DROP DATABASE</code> ステートメントに適用されるルールにだけ例外が作成されています。 これらの場合には、更新のログを記録または無視するかを判断するときに、<span class="emphasis"><em>作成、変更、またはドロップされる</em></span>データベースがデフォルトデータベースを置き換えます。 
        </p></div><p>
        <code class="option">--binlog-do-db</code> は<span class="quote">「<span class="quote">ほかのデータベースを無視する</span>」</span>ことを意味する場合があります。 たとえば、ステートメントベースロギングを使用するときに、<code class="option">--binlog-do-db=sales</code> だけで動作するサーバーは、デフォルトデータベースが <code class="literal">sales</code> ではないバイナリログステートメントに書き込みません。 同じオプションで行ベースロギングを使用するときは、サーバーは <code class="literal">sales</code> 内のデータを変更する更新のみのログを記録します。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-rules-table-options"></a>17.2.5.2 テーブルレベルレプリケーションオプションの評価</h4></div></div></div><p>
        レプリカは、次の 2 つの条件のいずれかに該当する場合にのみ、テーブルオプションをチェックして評価します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            一致するデータベースオプションが見つからなかった。
          </p></li><li class="listitem"><p>
            1 つ以上のデータベースオプションが見つかり、前のセクションで説明したルール (<a class="xref" href="replication.html#replication-rules-db-options" title="17.2.5.1 データベースレベルレプリケーションオプションおよびバイナリロギングオプションの評価">セクション17.2.5.1「データベースレベルレプリケーションオプションおよびバイナリロギングオプションの評価」</a>を参照) に従って、<span class="quote">「<span class="quote">実行</span>」</span>条件に達していると評価された。
          </p></li></ul></div><p>
        まず、予備的な状態として、レプリカはステートメントベースのレプリケーションが有効かどうかをチェックします。 その場合、ステートメントがストアドファンクション内で発生すると、レプリカはステートメントを実行して終了します。 行ベースレプリケーションが有効になっている場合、レプリカはソースのストアドファンクション内でステートメントが発生したかどうかを認識しないため、この条件は適用されません。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          ステートメントベースレプリケーションの場合、レプリケーションイベントがステートメントを表現します (あるイベントを構成するすべての変更が単一 SQL ステートメントに関連付けられています)。行ベースレプリケーションの場合、各イベントが単一テーブル行内の変更を表現します (このため、<code class="literal">UPDATE mytable SET mycol = 1</code> などの単一ステートメントが多くの行ベースイベントを生成する場合があります)。 イベントの観点から見ると、テーブルオプションを検査するプロセスは行ベースおよびステートメントベースレプリケーションの両方について同じです。 
        </p></div><p>
        この時点に到達すると、テーブルオプションがない場合、レプリカは単にすべてのイベントを実行します。 <code class="option">--replicate-do-table</code> または <code class="option">--replicate-wild-do-table</code> オプションがある場合は、それが実行すべきイベントの場合、イベントはこれらのいずれかに一致する必要があります。そうでない場合、無視されます。 <code class="option">--replicate-ignore-table</code> または <code class="option">--replicate-wild-ignore-table</code> オプションがある場合、これらのオプションのいずれかに一致するものを除いてすべてのイベントが実行されます。 
      </p><p>
        次のステップでは、この評価について詳しく説明します。 開始ポイントは、<a class="xref" href="replication.html#replication-rules-db-options" title="17.2.5.1 データベースレベルレプリケーションオプションおよびバイナリロギングオプションの評価">セクション17.2.5.1「データベースレベルレプリケーションオプションおよびバイナリロギングオプションの評価」</a> で説明されているように、データベースレベルのオプションの評価の最後です。 
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            テーブルレプリケーションオプションはありますか。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい. </b>
                  手順 2 に進みます。
                </p></li><li class="listitem"><p><b>いいえ. </b>
                  更新を実行して終了します。
                </p></li></ul></div></li><li class="listitem"><p>
            どのロギング形式が使用されますか。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>STATEMENT. </b>
                  更新を実行するステートメントごとに残りのステップを実行します。
                </p></li><li class="listitem"><p><b>ROW. </b>
                  テーブルの行を更新するたびに残りのステップを実行します。
                </p></li></ul></div></li><li class="listitem"><p>
            <code class="option">--replicate-do-table</code> オプションはありますか ?
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい. </b>
                  テーブルはそれらのいずれかに一致しますか ?
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>はい. </b>
                      更新を実行して終了します。
                    </p></li><li class="listitem"><p><b>いいえ. </b>
                      手順 4 に進みます。
                    </p></li></ul></div></li><li class="listitem"><p><b>いいえ. </b>
                  手順 4 に進みます。
                </p></li></ul></div></li><li class="listitem"><p>
            <code class="option">--replicate-ignore-table</code> オプションはありますか ?
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい. </b>
                  テーブルはそれらのいずれかに一致しますか ?
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>はい. </b>
                      更新を無視して終了します。
                    </p></li><li class="listitem"><p><b>いいえ. </b>
                      手順 5 に進みます。
                    </p></li></ul></div></li><li class="listitem"><p><b>いいえ. </b>
                  手順 5 に進みます。
                </p></li></ul></div></li><li class="listitem"><p>
            <code class="option">--replicate-wild-do-table</code> オプションはありますか ?
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい. </b>
                  テーブルはそれらのいずれかに一致しますか ?
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>はい. </b>
                      更新を実行して終了します。
                    </p></li><li class="listitem"><p><b>いいえ. </b>
                      手順 6 に進みます。
                    </p></li></ul></div></li><li class="listitem"><p><b>いいえ. </b>
                  手順 6 に進みます。
                </p></li></ul></div></li><li class="listitem"><p>
            <code class="option">--replicate-wild-ignore-table</code> オプションはありますか ?
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい. </b>
                  テーブルはそれらのいずれかに一致しますか ?
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>はい. </b>
                      更新を無視して終了します。
                    </p></li><li class="listitem"><p><b>いいえ. </b>
                      手順 7 に進みます。
                    </p></li></ul></div></li><li class="listitem"><p><b>いいえ. </b>
                  手順 7 に進みます。
                </p></li></ul></div></li><li class="listitem"><p>
            テストする別のテーブルがありますか。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい. </b>
                  ステップ 3 に戻ります。
                </p></li><li class="listitem"><p><b>いいえ. </b>
                  手順 8 に進みます。
                </p></li></ul></div></li><li class="listitem"><p>
            <code class="option">--replicate-do-table</code> または <code class="option">--replicate-wild-do-table</code> オプションはありますか ?
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい. </b>
                  更新を無視して終了します。
                </p></li><li class="listitem"><p><b>いいえ. </b>
                  更新を実行して終了します。
                </p></li></ul></div></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          単一の SQL ステートメントが <code class="option">--replicate-do-table</code> または <code class="option">--replicate-wild-do-table</code> オプションに含まれるテーブルと、<code class="option">--replicate-ignore-table</code> または <code class="option">--replicate-wild-ignore-table</code> オプションで無視される別のテーブルの両方で動作する場合、ステートメントベースのレプリケーションは停止します。 レプリカは、(レプリケーションイベントを形成する) 完全なステートメントを実行または無視する必要があり、論理的にはこれを実行できません。 DDL ステートメントは常に有効なロギング形式に関係なくステートメントとして記録されるため、これは DDL ステートメントの行ベースのレプリケーションにも適用されます。 インクルードされたテーブルと無視されたテーブルの両方を更新でき、正常にレプリケートされる唯一のタイプのステートメントは、<code class="literal">binlog_format=ROW</code> でログに記録された DML ステートメントです。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-rules-examples"></a>17.2.5.3 レプリケーションフィルタリングオプション間の相互作用</h4></div></div></div><p>
        データベースレベルとテーブルレベルのレプリケーションフィルタリングオプションの組合せを使用する場合、レプリカは最初にデータベースオプションを使用してイベントを受け入れるか無視し、次にテーブルオプションに従ってそれらのオプションで許可されるすべてのイベントを評価します。 これにより、結果が直感的に印刷される場合があります。 また、ステートメントベースと行ベースのどちらのバイナリロギング形式を使用して操作をログに記録するかによって結果が異なることにも注意してください。 レプリケーションフィルタがバイナリロギング形式とは独立して常に同じ方法で動作するようにする場合は、特に混合バイナリロギング形式を使用する場合に重要です。このトピックのガイダンスに従ってください。 
      </p><p>
        レプリケーションフィルタリングオプションの効果は、データベース名が識別される方法のため、バイナリロギング形式によって異なります。 ステートメントベースの形式では、DML ステートメントは、<code class="literal">USE</code> ステートメントステートメントで指定された現行のデータベースに基づいて処理されます。 行ベースの形式では、DML ステートメントは、変更されたテーブルが存在するデータベースに基づいて処理されます。 DDL ステートメントは、バイナリロギング形式に関係なく、常に <code class="literal">USE</code> ステートメントで指定された現在のデータベースに基づいてフィルタ処理されます。 
      </p><p>
        複数のテーブルを含む操作は、バイナリロギング形式に応じて、レプリケーションフィルタリングオプションの影響を受けることもあります。 監視する操作には、複数テーブルの <code class="literal">UPDATE</code> ステートメント、トリガー、外部キーのカスケード、複数のテーブルを更新するストアドファンクション、および 1 つ以上のテーブルを更新するストアドファンクションを起動する DML ステートメントが含まれます。 これらの操作によってフィルタ処理されたテーブルとフィルタ処理されたテーブルの両方が更新される場合、結果はバイナリロギング形式によって異なる可能性があります。 
      </p><p>
        特に混合バイナリロギング形式 (<code class="literal">binlog_format=MIXED</code>) を使用している場合、レプリケーションフィルタがバイナリロギング形式に関係なく一貫して動作することを保証する必要がある場合は、テーブルレベルのレプリケーションフィルタリングオプションのみを使用し、データベースレベルのレプリケーションフィルタリングオプションは使用しないでください。 また、フィルタ処理されたテーブルとフィルタ処理されたテーブルの両方を更新する複数テーブル DML ステートメントは使用しないでください。 
      </p><p>
        データベースレベルとテーブルレベルのレプリケーションフィルタの組合せを使用する必要があり、これらを可能なかぎり一貫して動作させる場合は、次のいずれかの方法を選択します:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            DDL ステートメントに行ベースのバイナリロギング形式 (<code class="literal">binlog_format=ROW</code>) を使用する場合は、<code class="literal">USE</code> ステートメントを使用してデータベースを設定し、データベース名を指定しないでください。 レプリケーションフィルタリングとの一貫性を向上させるために、行ベースのバイナリロギング形式に変更することを検討できます。 バイナリロギング形式の変更に適用される条件については、<a class="xref" href="server-administration.html#binary-log-setting" title="5.4.4.2 バイナリログ形式の設定">セクション5.4.4.2「バイナリログ形式の設定」</a> を参照してください。 
          </p></li><li class="listitem"><p>
            ステートメントベースまたは混合バイナリロギング形式 (<code class="literal">binlog_format=STATEMENT</code> または <code class="literal">MIXED</code>) を DML ステートメントと DDL ステートメントの両方に使用する場合は、<code class="literal">USE</code> ステートメントに依存し、データベース名は使用しません。 また、フィルタ処理されたテーブルとフィルタ処理されたテーブルの両方を更新する複数テーブル DML ステートメントは使用しないでください。 
          </p></li></ol></div><div class="example"><a name="idm46723650326320"></a><p class="title"><b>例 17.7 <code class="option">--replicate-ignore-db</code> オプションおよび <code class="option">--replicate-do-table</code> オプション</b></p><div class="example-contents"><p>
          レプリケーションソースサーバーでは、次のステートメントが発行されます:
        </p><pre class="programlisting">USE db1;
CREATE TABLE t2 LIKE t1;
INSERT INTO db2.t3 VALUES (1);
</pre><p>
          レプリカには、次のレプリケーションフィルタリングオプションが設定されています:
        </p><pre class="programlisting">replicate-ignore-db = db1
replicate-do-table = db2.t3
</pre><p>
          DDL ステートメント <code class="literal">CREATE TABLE</code> は、前述の <code class="literal">USE</code> ステートメントで指定されているように、<code class="literal">db1</code> にテーブルを作成します。 <code class="literal">db1</code> が現在のデータベースであるため、レプリカは <code class="option">--replicate-ignore-db = db1</code> オプションに従ってこのステートメントを除外します。 この結果は、レプリケーションソースサーバー上のバイナリロギング形式と同じです。 ただし、DML <code class="literal">INSERT</code> ステートメントの結果は、バイナリロギング形式によって異なります: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              行ベースのバイナリロギング形式がソース (<code class="literal">binlog_format=ROW</code>) で使用されている場合、レプリカは、<code class="literal">db2</code> という名前のテーブルが存在するデータベースを使用して <code class="literal">INSERT</code> 操作を評価します。 最初に評価されるデータベースレベルのオプション <code class="option">--replicate-ignore-db = db1</code> は適用されません。 テーブルレベルのオプション <code class="option">--replicate-do-table = db2.t3</code> は適用されるため、レプリカはテーブル <code class="literal">t3</code> に変更を適用します。 
            </p></li><li class="listitem"><p>
              ステートメントベースのバイナリロギング形式がソース (<code class="literal">binlog_format=STATEMENT</code>) で使用されている場合、レプリカは、<code class="literal">USE</code> ステートメントによって <code class="literal">db1</code> に設定され、変更されていないデフォルトのデータベースを使用して <code class="literal">INSERT</code> 操作を評価します。 したがって、データベースレベルの <code class="option">--replicate-ignore-db = db1</code> オプションによると、操作は無視され、変更はテーブル <code class="literal">t3</code> に適用されません。 ステートメントがすでにデータベースレベルのオプションと一致し、無視されたため、テーブルレベルのオプション <code class="option">--replicate-do-table = db2.t3</code> はチェックされません。 
            </p></li></ul></div><p>
          レプリカで <code class="option">--replicate-ignore-db = db1</code> オプションが必要であり、ソースでステートメントベース (または混在) のバイナリロギング形式を使用する必要もある場合は、次のように <code class="literal">INSERT</code> ステートメントからデータベース名を省略し、代わりに <code class="literal">USE</code> ステートメントに依存することで、結果を整合させることができます:
        </p><pre class="programlisting">USE db1;
CREATE TABLE t2 LIKE t1;
USE db2;
INSERT INTO t3 VALUES (1);
</pre><p>
          この場合、レプリカは常にデータベース <code class="literal">db2</code> に基づいて <code class="literal">INSERT</code> ステートメントを評価します。 操作がステートメントベースまたは行ベースのバイナリ形式のどちらで記録されているかにかかわらず、結果は同じままです。 
        </p></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-rules-channel-based-filters"></a>17.2.5.4 レプリケーションチャネルベースのフィルタ</h4></div></div></div><a class="indexterm" name="idm46723650291264"></a><p>
        このセクションでは、マルチソースレプリケーショントポロジなどに複数のレプリケーションチャネルが存在する場合にレプリケーションフィルタを使用する方法について説明します。 MySQL 8.0 より前は、レプリケーションフィルタはグローバルであったため、すべてのレプリケーションチャネルにフィルタが適用されていました。 MySQL 8.0 からは、レプリケーションフィルタをグローバルまたはチャネル固有にでき、特定のレプリケーションチャネルでレプリケーションフィルタを使用してマルチソースレプリカを構成できます。 チャネル固有のレプリケーションフィルタは、同じデータベースまたはテーブルが複数のソースに存在し、レプリカが単一のソースからレプリケートする必要がある場合に、マルチソースレプリケーショントポロジで特に役立ちます。 
      </p><p>
        レプリケーションチャネルの設定手順は、<a class="xref" href="replication.html#replication-multi-source" title="17.1.5 MySQL マルチソースレプリケーション">セクション17.1.5「MySQL マルチソースレプリケーション」</a> を参照してください。レプリケーションチャネルの動作の詳細は、<a class="xref" href="replication.html#replication-channels" title="17.2.2 レプリケーションチャネル">セクション17.2.2「レプリケーションチャネル」</a> を参照してください。
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          マルチソースレプリカ上の各チャネルは、異なるソースからレプリケートする必要があります。 レプリケーションフィルタを使用してチャネルごとにレプリケートする異なるデータを選択した場合でも、単一のレプリカから単一のソースに複数のレプリケーションチャネルを設定することはできません。 これは、レプリカのサーバー ID がレプリケーショントポロジ内で一意である必要があるためです。 ソースはレプリカをサーバー ID でのみ区別し、レプリケーションチャネルの名前では区別しないため、同じレプリカとは異なるレプリケーションチャネルを認識できません。 
        </p></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          グループレプリケーション用に構成された MySQL サーバーインスタンスでは、グループレプリケーションに直接関係しないレプリケーションチャネル (グループメンバーがグループ外のソースへのレプリカとしても機能する場合など) でチャネル固有のレプリケーションフィルタを使用できます。 <code class="literal">group_replication_applier</code> または <code class="literal">group_replication_recovery</code> チャネルでは使用できません。 これらのチャネルをフィルタすると、グループは一貫性のある状態でアグリーメントに到達できなくなります。 
        </p></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          ダイヤモンドトポロジ内のマルチソースレプリカ (レプリカが複数のソースからレプリケートされ、共通ソースからレプリケートされる) の場合、GTID ベースのレプリケーションが使用されているときは、マルチソースレプリカ上のすべてのチャネルでレプリケーションフィルタまたはその他のチャネル構成が同一であることを確認してください。 GTID ベースのレプリケーションでは、フィルタはトランザクションデータにのみ適用され、GTID はフィルタで除外されません。 これは、レプリカの GTID セットがソースと一貫性が保たれるようにするためです。つまり、毎回フィルタで除外されたトランザクションを再取得せずに GTID 自動配置を使用できます。 ダウンストリームレプリカがマルチソースで、ダイアモンドトポロジの複数のソースから同じトランザクションを受信する場合、ダウンストリームレプリカには複数のバージョンのトランザクションが含まれるようになり、結果はトランザクションを最初に適用するチャネルによって異なります。 トランザクションの GTID が最初のチャネルによって <code class="literal">gtid_executed</code> セットに追加されたため、GTID 自動スキップを使用してトランザクションをスキップしようとする 2 つ目のチャネル。 チャネルのフィルタリングが同一の場合、トランザクションのすべてのバージョンに同じデータが含まれているため、結果は同じであるため、問題はありません。 ただし、チャネルのフィルタリングが異なると、データベースに一貫性がなくなる可能性があり、レプリケーションがハングする可能性があります。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-rules-channel-overview"></a>レプリケーションフィルタおよびチャネルの概要</h5></div></div></div><p>
          マルチソースレプリケーショントポロジなどに複数のレプリケーションチャネルが存在する場合、レプリケーションフィルタは次のように適用されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              指定したグローバルレプリケーションフィルタは、フィルタタイプ (<code class="literal">do_db</code>、<code class="literal">do_ignore_table</code> など) のグローバルレプリケーションフィルタに追加されます。
            </p></li><li class="listitem"><p>
              チャネル固有のレプリケーションフィルタは、指定されたフィルタタイプの指定されたチャネルのレプリケーションフィルタにフィルタを追加します。
            </p></li><li class="listitem"><p>
              このタイプのチャネル固有のレプリケーションフィルタが構成されていない場合、各レプリケーションチャネルはグローバルレプリケーションフィルタをチャネル固有のレプリケーションフィルタにコピーします。
            </p></li><li class="listitem"><p>
              各チャネルは、チャネル固有のレプリケーションフィルタを使用してレプリケーションストリームをフィルタリングします。
            </p></li></ul></div><p>
          チャネル固有のレプリケーションフィルタを作成する構文は、既存の SQL ステートメントおよびコマンドオプションを拡張します。 レプリケーションチャネルが指定されていない場合、グローバルレプリケーションフィルタは下位互換性を保証するように構成されます。 <code class="literal">CHANGE REPLICATION FILTER</code> ステートメントでは、チャネル固有のフィルタをオンラインで構成する <code class="literal">FOR CHANNEL</code> 句がサポートされています。 フィルタを構成するための <code class="literal">--replicate-*</code> コマンドオプションでは、<code class="literal">--replicate-<em class="replaceable"><code>filter_type</code></em>=<em class="replaceable"><code>channel_name</code></em>:<em class="replaceable"><code>filter_details</code></em></code> の形式を使用してレプリケーションチャネルを指定できます。 たとえば、サーバーの起動前にチャネル <code class="literal">channel_1</code> および <code class="literal">channel_2</code> が存在し、コマンドラインオプション <code class="option">--replicate-do-db=db1</code> <code class="option">--replicate-do-db=channel_1:db2</code> <code class="option">--replicate-do-db=db3</code> <code class="option">--replicate-ignore-db=db4</code> <code class="option">--replicate-ignore-db=channel_2:db5</code> を使用してレプリカを起動すると、次のようになります: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <span class="emphasis"><em>グローバルレプリケーションフィルタ</em></span>: do_db=db1,db3, ignore_db=db4
            </p></li><li class="listitem"><p>
              <span class="emphasis"><em>channel_1 でのチャネル固有のフィルタ</em></span>: do_db=db2 ignore_db=db4
            </p></li><li class="listitem"><p>
              <span class="emphasis"><em>channel_2 でのチャネル固有のフィルタ</em></span>: do_db=db1,db3 ignore_db=db5
            </p></li></ul></div><p>
          このような設定でレプリケーションフィルタを監視するには、<code class="literal">replication_applier_global_filters</code> テーブルと <code class="literal">replication_applier_filters</code> テーブルを使用します。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-rules-channel-replication-filter-options"></a>起動時のチャネル固有のレプリケーションフィルタの構成</h5></div></div></div><p>
          レプリケーションフィルタ関連のコマンドオプションには、オプションの <em class="replaceable"><code>channel</code></em> に続けてコロンを指定し、その後にフィルタ指定を指定できます。 最初のコロンはセパレータとして解釈され、後続のコロンはリテラルコロンとして解釈されます。 次のコマンドオプションは、この形式を使用したチャネル固有のレプリケーションフィルタをサポートしています: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">--replicate-do-db=<em class="replaceable"><code>channel</code></em>:<em class="replaceable"><code>database_id</code></em></code>
            </p></li><li class="listitem"><p>
              <code class="literal">--replicate-ignore-db=<em class="replaceable"><code>channel</code></em>:<em class="replaceable"><code>database_id</code></em></code>
            </p></li><li class="listitem"><p>
              <code class="literal">--replicate-do-table=<em class="replaceable"><code>channel</code></em>:<em class="replaceable"><code>table_id</code></em></code>
            </p></li><li class="listitem"><p>
              <code class="literal">--replicate-ignore-table=<em class="replaceable"><code>channel</code></em>:<em class="replaceable"><code>table_id</code></em></code>
            </p></li><li class="listitem"><p>
              <code class="literal">--replicate-rewrite-db=<em class="replaceable"><code>channel</code></em>:<em class="replaceable"><code>db1-db2</code></em></code>
            </p></li><li class="listitem"><p>
              <code class="literal">--replicate-wild-do-table=<em class="replaceable"><code>channel</code></em>:<em class="replaceable"><code>table regexid</code></em></code>
            </p></li><li class="listitem"><p>
              <code class="literal">--replicate-wild-ignore-table=<em class="replaceable"><code>channel</code></em>:<em class="replaceable"><code>table regexid</code></em></code>
            </p></li></ul></div><p>
          コロンを使用するが、<code class="option">--replicate-do-db=:<em class="replaceable"><code>database_id</code></em></code> などのフィルタオプションに <em class="replaceable"><code>channel</code></em> を指定しない場合、このオプションはデフォルトのレプリケーションチャネルのレプリケーションフィルタを構成します。 デフォルトのレプリケーションチャネルは、レプリケーションが開始されると常に存在するレプリケーションチャネルで、手動で作成するマルチソースレプリケーションチャネルとは異なります。 コロンも <em class="replaceable"><code>channel</code></em> も指定されていない場合は、グローバルレプリケーションフィルタが構成されます。たとえば、<code class="option">--replicate-do-db=<em class="replaceable"><code>database_id</code></em></code> はグローバル <code class="option">--replicate-do-db</code> フィルタを構成します。 
        </p><p>
          同じ <em class="replaceable"><code>from_name</code></em> データベースで複数の <code class="literal">rewrite-db=<em class="replaceable"><code>from_name</code></em>-&gt;<em class="replaceable"><code>to_name</code></em></code> オプションを構成すると、すべてのフィルタがまとめて追加され (<code class="literal">rewrite_do</code> リストに入れられます)、最初のフィルタが有効になります。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-rules-channel-change-replication-filter"></a>チャネル固有のレプリケーションフィルタのオンラインでの変更</h5></div></div></div><p>
          <code class="option">--replicate-*</code> オプションに加えて、<code class="literal">CHANGE REPLICATION FILTER</code> ステートメントを使用してレプリケーションフィルタを構成できます。 これにより、サーバーを再起動する必要がなくなりますが、変更中はレプリケーション SQL スレッドを停止する必要があります。 このステートメントで特定のチャネルにフィルタを適用するには、<code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を使用します。 例: 
        </p><pre class="programlisting">CHANGE REPLICATION FILTER REPLICATE_DO_DB=(db1) FOR CHANNEL channel_1;</pre><p>
          <code class="literal">FOR CHANNEL</code> 句が指定されている場合、ステートメントは指定されたチャネルレプリケーションフィルタに対して動作します。 複数のタイプのフィルタ (<code class="literal">do_db</code>, <code class="literal">do_ignore_table</code>, <code class="literal">wild_do_table</code> など) が指定されている場合、指定されたフィルタタイプのみがステートメントで置換されます。 マルチソースレプリカなどの複数のチャネルがあるレプリケーショントポロジでは、<code class="literal">FOR CHANNEL</code> 句が指定されていない場合、<code class="literal">FOR CHANNEL</code> の場合と同様のロジックを使用して、グローバルレプリケーションフィルタおよびすべてのチャネルのレプリケーションフィルタに対してステートメントが機能します。 詳細は、<a class="xref" href="sql-statements.html#change-replication-filter" title="13.4.2.2 CHANGE REPLICATION FILTER ステートメント">セクション13.4.2.2「CHANGE REPLICATION FILTER ステートメント」</a> を参照してください。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-rules-channel-removing"></a>チャネル固有のレプリケーションフィルタの削除</h5></div></div></div><p>
          チャネル固有のレプリケーションフィルタが構成されている場合は、空の filter type ステートメントを発行してフィルタを削除できます。 たとえば、<code class="literal">channel_1</code> issue という名前のレプリケーションチャネルからすべての <code class="literal">REPLICATE_REWRITE_DB</code> フィルタを削除するには、次のコマンドを発行します: 
        </p><pre class="programlisting">CHANGE REPLICATION FILTER REPLICATE_REWRITE_DB=() FOR CHANNEL channel_1;</pre><p>
          コマンドオプションまたは <code class="literal">CHANGE REPLICATION FILTER</code> を使用して以前に構成された <code class="literal">REPLICATE_REWRITE_DB</code> フィルタは削除されます。
        </p><p>
          <code class="literal">RESET REPLICA | SLAVE ALL</code> ステートメントは、ステートメントによって削除されたチャネルに設定されたチャネル固有のレプリケーションフィルタを削除します。 削除されたチャネルが再作成されると、レプリカに指定されたグローバルレプリケーションフィルタがそれらにコピーされ、チャネル固有のレプリケーションフィルタは適用されません。 
        </p></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="replication-security"></a>17.3 レプリケーションのセキュリティ</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-solutions-encrypted-connections">17.3.1 暗号化接続を使用するためのレプリケーションの設定</a></span></dt><dt><span class="section"><a href="replication.html#replication-binlog-encryption">17.3.2 バイナリログファイルとリレーログファイルの暗号化</a></span></dt><dt><span class="section"><a href="replication.html#replication-privilege-checks">17.3.3 レプリケーション権限チェック</a></span></dt></dl></div><p>
    レプリケーションソースサーバーとレプリカ間で格納および転送されるデータへの不正なアクセスから保護するには、<a class="xref" href="security.html" title="第 6 章 セキュリティー">第6章「<i>セキュリティー</i>」</a> で説明されているように、インストール内の任意の MySQL インスタンスに対して選択するセキュリティ対策を使用して、関係するすべてのサーバーを設定します。 また、レプリケーショントポロジ内のサーバーの場合は、次のセキュリティ対策を実装することを検討してください: 
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        暗号化された接続を使用してバイナリログを転送するようにソースとレプリカを設定します。これにより、このデータは移動中に保護されます。 これらの接続の暗号化は、暗号化されたネットワーク接続をサポートするようにサーバーを設定するだけでなく、<code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントを使用してアクティブ化する必要があります。 <a class="xref" href="replication.html#replication-solutions-encrypted-connections" title="17.3.1 暗号化接続を使用するためのレプリケーションの設定">セクション17.3.1「暗号化接続を使用するためのレプリケーションの設定」</a>を参照してください。 
      </p></li><li class="listitem"><p>
        バイナリログファイルを暗号化し、ソースおよびレプリカ上のリレーログファイルを暗号化します。これにより、このデータが保存され、バイナリログキャッシュで使用されているデータも保護されます。 バイナリログの暗号化は、<code class="literal">binlog_encryption</code> システム変数を使用してアクティブ化されます。 <a class="xref" href="replication.html#replication-binlog-encryption" title="17.3.2 バイナリログファイルとリレーログファイルの暗号化">セクション17.3.2「バイナリログファイルとリレーログファイルの暗号化」</a>を参照してください。 
      </p></li><li class="listitem"><p>
        権限チェックをレプリケーションアプライアンスに適用します。これは、権限のある操作または不要な操作の不正または偶然の使用からレプリケーションチャネルを保護するのに役立ちます。 権限チェックは、<code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントを設定することで実装されます。このアカウントは、そのチャネルの特定の各トランザクションが認可されていることを確認するために MySQL で使用されます。 <a class="xref" href="replication.html#replication-privilege-checks" title="17.3.3 レプリケーション権限チェック">セクション17.3.3「レプリケーション権限チェック」</a>を参照してください。 
      </p></li></ul></div><p>
    グループレプリケーションでは、バイナリログの暗号化および権限チェックをレプリケーショングループメンバーのセキュリティ対策として使用できます。 また、グループメンバー間の接続の暗号化、グループ通信接続と分散リカバリ接続の構成、および信頼できないホストを除外するための IP アドレスの割当ての適用も検討する必要があります。 Group Replication に固有のこれらのセキュリティー対策については、<a class="xref" href="group-replication.html#group-replication-security" title="18.5 グループレプリケーションセキュリティ">セクション18.5「グループレプリケーションセキュリティ」</a> を参照してください。 
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-solutions-encrypted-connections"></a>17.3.1 暗号化接続を使用するためのレプリケーションの設定</h3></div></div></div><p>
      レプリケーション中に必要なバイナリログの転送に暗号化された接続を使用するには、ソースサーバーと複製サーバーの両方が暗号化されたネットワーク接続をサポートしている必要があります。 いずれかのサーバーが暗号化された接続をサポートしていない場合 (それらに対してコンパイルまたは構成されていないため)、暗号化された接続を介したレプリケーションはできません。 
    </p><p>
      レプリケーション用の暗号化された接続の設定は、クライアント/サーバー接続の場合と同様です。 ソースで使用できる適切なセキュリティ証明書と、各レプリカで (同じ認証局から) 同様の証明書を取得 (または作成) する必要があります。 適切なキーファイルも取得する必要があります。 
    </p><p>
      暗号化された接続のためのサーバーおよびクライアントの設定の詳細は、<a class="xref" href="security.html#using-encrypted-connections" title="6.3.1 暗号化接続を使用するための MySQL の構成">セクション6.3.1「暗号化接続を使用するための MySQL の構成」</a> を参照してください。
    </p><p>
      ソースで暗号化された接続を有効にするには、適切な証明書およびキーファイルを作成または取得し、必要に応じてファイル名を変更して、ソース <code class="filename">my.cnf</code> ファイルの<code class="literal">[mysqld]</code>セクション内のソース構成に次の構成パラメータを追加する必要があります:
    </p><pre class="programlisting">[mysqld]
ssl_ca=cacert.pem
ssl_cert=server-cert.pem
ssl_key=server-key.pem
</pre><p>
      ファイルへのパスは相対パスまたは絶対パスである可能性があります。この目的には、常に完全なパスを使用することをお薦めします。
    </p><p>
      構成パラメータは次のとおりです:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">ssl_ca</code>: 認証局 (CA) 証明書ファイルのパス名。(<code class="literal">ssl_capath</code> は類似していますが、CA 証明書ファイルのディレクトリのパス名を指定します。)
        </p></li><li class="listitem"><p>
          <code class="literal">ssl_cert</code>: サーバー公開キー証明書ファイルのパス名。 この証明書はクライアントに送信し、クライアントが持っている CA 証明書に対して認証できます。 
        </p></li><li class="listitem"><p>
          <code class="literal">ssl_key</code>: サーバー秘密キーファイルのパス名。
        </p></li></ul></div><p>
      レプリカで暗号化された接続を有効にするには、(MySQL 8.0.23 の) <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントまたは (MySQL 8.0.23 の前の) <code class="literal">CHANGE MASTER TO</code> ステートメントを使用します。 レプリカ <code class="filename">my.cnf</code> ファイルの<code class="literal">[client]</code>セクションで、暗号化された接続に必要なレプリカ証明書および SSL 秘密キーファイルに名前を付けることも、<code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントを使用してその情報を明示的に指定することもできます。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          オプションファイルを使用してレプリカ証明書およびキーファイルに名前を付けるには、レプリカ <code class="filename">my.cnf</code> ファイルの<code class="literal">[client]</code>セクションに次の行を追加し、必要に応じてファイル名を変更します:
        </p><pre class="programlisting">[client]
ssl-ca=cacert.pem
ssl-cert=client-cert.pem
ssl-key=client-key.pem
</pre></li><li class="listitem"><p>
          レプリカがソースに接続しないようにするには、<code class="option">--skip-slave-start</code> オプションを使用してレプリカサーバーを再起動します。 <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> を使用してソース構成を指定し、暗号化を使用して接続するための <code class="literal">MASTER_SSL</code> オプションを追加します: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_HOST='source_hostname',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_USER='repl',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_PASSWORD='<em class="replaceable"><code>password</code></em>',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_SSL=1;</code></strong>

Or from MySQL 8.0.23:
mysql&gt; <strong class="userinput"><code>CHANGE REPLICATION SOURCE TO</code></strong>
    -&gt; <strong class="userinput"><code>SOURCE_HOST='source_hostname',</code></strong>
    -&gt; <strong class="userinput"><code>SOURCE_USER='repl',</code></strong>
    -&gt; <strong class="userinput"><code>SOURCE_PASSWORD='<em class="replaceable"><code>password</code></em>',</code></strong>
    -&gt; <strong class="userinput"><code>SOURCE_SSL=1;</code></strong>

</pre><p>
          レプリケーション接続用の <code class="literal">SOURCE_SSL=1</code> | <code class="literal">MASTER_SSL=1</code> を設定し、それ以上の <code class="literal">SOURCE_SSL_<em class="replaceable"><code>xxx</code></em></code> | <code class="literal">MASTER_SSL_<em class="replaceable"><code>xxx</code></em></code> オプションを設定しないことは、<a class="xref" href="programs.html#encrypted-connection-options" title="暗号化接続のコマンドオプション">暗号化接続のコマンドオプション</a> で説明されているように、クライアント用の <code class="literal">--ssl-mode=REQUIRED</code> の設定に対応します。 <code class="literal">SOURCE_SSL=1</code> | <code class="literal">MASTER_SSL=1</code> では、暗号化された接続を確立できる場合にのみ接続が成功します。 レプリケーション接続は暗号化されていない接続にフォールバックしないため、レプリケーションの <code class="literal">--ssl-mode=PREFERRED</code> 設定に対応する設定はありません。 <code class="literal">SOURCE_SSL=0</code> | <code class="literal">MASTER_SSL=0</code> が設定されている場合、これは <code class="literal">--ssl-mode=DISABLED</code> に対応します。 
        </p></li><li class="listitem"><p>
          <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントを使用してレプリカ証明書および SSL 秘密キーファイルに名前を付けるには、レプリカ <code class="filename">my.cnf</code> ファイルで指定していない場合は、適切な <code class="literal">SOURCE_SSL_<em class="replaceable"><code>xxx</code></em></code> | <code class="literal">MASTER_SSL_<em class="replaceable"><code>xxx</code></em></code> オプションを追加します:
        </p><pre class="programlisting">    -&gt; <strong class="userinput"><code>MASTER_SSL_CA = 'ca_file_name',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_SSL_CAPATH = 'ca_directory_name',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_SSL_CERT = 'cert_file_name',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_SSL_KEY = 'key_file_name',</code></strong>
</pre><p>
          これらのオプションは、<a class="xref" href="programs.html#encrypted-connection-options" title="暗号化接続のコマンドオプション">暗号化接続のコマンドオプション</a> で説明されている同じ名前の <code class="literal">--ssl-<em class="replaceable"><code>xxx</code></em></code> オプションに対応しています。 これらのオプションを有効にするには、<code class="literal">MASTER_SSL=1</code> も設定する必要があります。 レプリケーション接続の場合、<code class="literal"> MASTER_SSL_CA</code> または <code class="literal">MASTER_SSL_CAPATH</code> のいずれかの値を指定するか、レプリカ <code class="filename">my.cnf</code> ファイルでこれらのオプションを指定すると、<code class="literal">--ssl-mode=VERIFY_CA</code> の設定に対応します。 接続試行は、指定された情報を使用して有効な一致する認証局 (CA) 証明書が見つかった場合にのみ成功します。 
        </p></li><li class="listitem"><p>
          ホスト名アイデンティティ検証をアクティブ化するには、<code class="literal">MASTER_SSL_VERIFY_SERVER_CERT</code> オプションを追加します:
        </p><pre class="programlisting">    -&gt; <strong class="userinput"><code>MASTER_SSL_VERIFY_SERVER_CERT=1,</code></strong>
</pre><p>
          このオプションは、MySQL 5.7 から非推奨になり、MySQL 8.0 で削除された <code class="literal">--ssl-verify-server-cert</code> オプションに対応します。 レプリケーション接続の場合、<a class="xref" href="programs.html#encrypted-connection-options" title="暗号化接続のコマンドオプション">暗号化接続のコマンドオプション</a> で説明されているように、<code class="literal">MASTER_SSL_VERIFY_SERVER_CERT=1</code> の指定は <code class="literal">--ssl-mode=VERIFY_IDENTITY</code> の設定に対応します。 このオプションを有効にするには、<code class="literal">MASTER_SSL=1</code> も設定する必要があります。 ホスト名アイデンティティ検証は、自己署名証明書では機能しません。 
        </p></li><li class="listitem"><p>
          証明書失効リスト (CRL) チェックをアクティブ化するには、<code class="literal">MASTER_SSL_CRL</code> または <code class="literal">MASTER_SSL_CRLPATH</code> オプションを追加します:
        </p><pre class="programlisting">    -&gt; <strong class="userinput"><code>MASTER_SSL_CRL = 'crl_file_name',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_SSL_CRLPATH = 'crl_directory_name',</code></strong></pre><p>
          これらのオプションは、<a class="xref" href="programs.html#encrypted-connection-options" title="暗号化接続のコマンドオプション">暗号化接続のコマンドオプション</a> で説明されている同じ名前の <code class="literal">--ssl-<em class="replaceable"><code>xxx</code></em></code> オプションに対応しています。 指定しない場合、CRL チェックは行われません。 
        </p></li><li class="listitem"><p>
          レプリケーション接続のレプリカで許可される暗号、暗号スイートおよび暗号化プロトコルのリストを指定するには、<code class="literal">MASTER_SSL_CIPHER</code>、<code class="literal">MASTER_TLS_VERSION</code> および <code class="literal">MASTER_TLS_CIPHERSUITES</code> オプションを使用します:
        </p><pre class="programlisting">    -&gt; <strong class="userinput"><code>MASTER_SSL_CIPHER = 'cipher_list',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_TLS_VERSION = 'protocol_list',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_TLS_CIPHERSUITES = 'ciphersuite_list',</code></strong>
</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">MASTER_SSL_CIPHER</code> オプションは、レプリケーション接続のレプリカで許可される暗号のコロン区切りリストを指定します。
            </p></li><li class="listitem"><p>
              <code class="literal">MASTER_TLS_VERSION</code> オプションは、レプリケーション接続のレプリカで許可される TLS 暗号化プロトコルのコンマ区切りリストを、<code class="literal">tls_version</code> サーバーシステム変数と同様の形式で指定します。 接続手順では、ソースとレプリカの両方で許可されている最上位 TLS バージョンの使用をネゴシエーションします。 接続できるようにするには、レプリカにソースと共通の TLS バージョンが少なくとも 1 つ必要です。 
            </p></li><li class="listitem"><p>
              <code class="literal">MASTER_TLS_CIPHERSUITES</code> オプション (MySQL 8.0.19 から使用可能) は、TLSv1.3 が接続に使用されている場合にレプリケーション接続のレプリカで許可される暗号スイートのコロン区切りリストを指定します。 TLSv1.3 の使用時にこのオプションが <code class="literal">NULL</code> に設定されている場合 (オプションを設定しない場合のデフォルト)、デフォルトで有効になっている暗号スイートが許可されます。 オプションを空の文字列に設定した場合、暗号スイートは許可されないため、TLSv1.3 は使用されません。 
            </p></li></ul></div><p>
          これらのリストで指定できるプロトコル、暗号および暗号スイートは、MySQL のコンパイルに使用される SSL ライブラリによって異なります。 フォーマット、許可される値、およびオプションを指定しない場合のデフォルトの詳細は、<a class="xref" href="security.html#encrypted-connection-protocols-ciphers" title="6.3.2 暗号化された接続 TLS プロトコルおよび暗号">セクション6.3.2「暗号化された接続 TLS プロトコルおよび暗号」</a> を参照してください。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            8.0.18 を介した MySQL 8.0.16 では、MySQL は TLSv1.3 をサポートしていますが、<code class="literal">MASTER_TLS_CIPHERSUITES</code> オプションは使用できません。 これらのリリースでは、ソースとレプリカ間の接続に TLSv1.3 を使用する場合、デフォルトで有効になっている少なくとも 1 つの TLSv1.3 暗号スイートの使用をソースで許可する必要があります。 MySQL 8.0.19 から、オプションを使用して、デフォルト以外の暗号スイートのみを含め、任意の暗号スイートの選択を指定できます。 
          </p></div></li><li class="listitem"><p>
          ソース情報が更新されたら、レプリカでレプリケーションプロセスを開始します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>START SLAVE;</code></strong>
Or from MySQL 8.0.22:
mysql&gt; <strong class="userinput"><code>START REPLICA;</code></strong>
</pre><p>
          <code class="literal">SHOW REPLICA | SLAVE STATUS</code> ステートメントを使用して、暗号化された接続が正常に確立されたことを確認できます。
        </p></li><li class="listitem"><p>
          レプリカで暗号化された接続を要求しても、ソースがレプリカからの暗号化された接続を必要とすることは保証されません。 ソースが暗号化された接続を使用して接続するレプリカのみを受け入れるようにするには、<code class="literal">REQUIRE SSL</code> オプションを使用してソースにレプリケーションユーザーアカウントを作成し、そのユーザーに <code class="literal">REPLICATION SLAVE</code> 権限を付与します。 例: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE USER 'repl'@'%.example.com' IDENTIFIED BY '<em class="replaceable"><code>password</code></em>'</code></strong>
    -&gt; <strong class="userinput"><code>REQUIRE SSL;</code></strong>
mysql&gt; <strong class="userinput"><code>GRANT REPLICATION SLAVE ON *.*</code></strong>
    -&gt; <strong class="userinput"><code>TO 'repl'@'%.example.com';</code></strong>
</pre><p>
          ソースに既存のレプリケーションユーザーアカウントがある場合は、次のステートメントを使用して <code class="literal">REQUIRE SSL</code> を追加できます:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER USER 'repl'@'%.example.com' REQUIRE SSL;</code></strong>
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-binlog-encryption"></a>17.3.2 バイナリログファイルとリレーログファイルの暗号化</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-binlog-encryption-scope">17.3.2.1 バイナリログの暗号化の範囲</a></span></dt><dt><span class="section"><a href="replication.html#replication-binlog-encryption-encryption-keys">17.3.2.2 バイナリログ暗号化キー</a></span></dt><dt><span class="section"><a href="replication.html#replication-binlog-encryption-key-rotation">17.3.2.3 バイナリログマスターキーのローテーション</a></span></dt></dl></div><a class="indexterm" name="idm46723650061328"></a><a class="indexterm" name="idm46723650059888"></a><p>
      MySQL 8.0.14 からは、バイナリログファイルとリレーログファイルを暗号化できるため、これらのファイルとそれらに含まれる潜在的機密データを、外部の攻撃者による誤用から保護したり、格納されているオペレーティングシステムのユーザーによる不正な表示から保護したりできます。 ファイルに使用される暗号化アルゴリズム AES (Advanced Encryption Standard) 暗号アルゴリズムは、MySQL Server に組み込まれており、構成できません。 
    </p><p>
      MySQL サーバーでこの暗号化を有効にするには、<code class="literal">binlog_encryption</code> システム変数を <code class="literal">ON</code> に設定します。 <code class="literal">OFF</code> がデフォルトです。 システム変数は、バイナリログファイルおよびリレーログファイルの暗号化をオンに設定します。 暗号化を有効にするためにバイナリロギングをサーバー上で有効にする必要はないため、バイナリログのないレプリカ上のリレーログファイルを暗号化できます。 暗号化を使用するには、MySQL Server 鍵リングサービスを提供するように鍵リングプラグインをインストールして構成する必要があります。 これを行う手順は、<a class="xref" href="security.html#keyring" title="6.4.4 MySQL キーリング">セクション6.4.4「MySQL キーリング」</a> を参照してください。 サポートされている任意のキーリングプラグインを使用して、バイナリログ暗号化鍵を格納できます。 
    </p><p>
      暗号化を有効にしてサーバーを初めて起動すると、バイナリログとリレーログが初期化される前に新しいバイナリログ暗号化鍵が生成されます。 このキーは、各バイナリログファイル (サーバーでバイナリロギングが有効になっている場合) およびリレーログファイル (サーバーにレプリケーションチャネルがある場合) のファイルパスワードを暗号化するために使用され、ファイルパスワードから生成された以降の鍵を使用してファイル内のデータが暗号化されます。 サーバーで現在使用されているバイナリログ暗号化鍵は、バイナリログマスターキーと呼ばれます。 2 層暗号化キーアーキテクチャでは、必要に応じてバイナリログマスターキーをローテーション (新しいマスターキーに置換) でき、各ファイルのファイルパスワードのみを新しいマスターキーで再暗号化する必要があり、ファイル全体ではありません。 リレーログファイルは、暗号化がアクティブ化された後に作成される新しいチャネルを含め、すべてのチャネルに対して暗号化されます。 バイナリログインデックスファイルとリレーログインデックスファイルは暗号化されません。 
    </p><p>
      サーバーの実行中に暗号化をアクティブ化すると、その時点で新しいバイナリログ暗号化鍵が生成されます。 例外は、以前にサーバー上で暗号化がアクティブであり、その後無効になっていた場合です。その場合、以前に使用されていたバイナリログ暗号化鍵が再度使用されます。 バイナリログファイルとリレーログファイルはただちにローテーションされ、新しいファイルとそれ以降のすべてのバイナリログファイルおよびリレーログファイルのファイルパスワードは、このバイナリログ暗号化鍵を使用して暗号化されます。 既存のバイナリログファイルとリレーログファイルはまだサーバー上に存在していても暗号化されませんが、不要になった場合はパージできます。 
    </p><p>
      <code class="literal">binlog_encryption</code> システム変数を <code class="literal">OFF</code> に変更して暗号化を非アクティブにすると、バイナリログファイルとリレーログファイルはただちにローテーションされ、それ以降のすべてのロギングは暗号化されません。 以前に暗号化されたファイルは自動的に復号化されませんが、サーバーはそれらを読み取ることができます。 サーバーの実行中に暗号化をアクティブ化または非アクティブ化するには、<code class="literal">BINLOG_ENCRYPTION_ADMIN</code> 権限が必要です。 
    </p><p>
      暗号化されたバイナリログファイルと暗号化されていないバイナリログファイルは、暗号化されたログファイル (<code class="literal">0xFD62696E</code>) のファイルヘッダーの先頭にあるマジック番号を使用して区別できます。これは、暗号化されていないログファイル (<code class="literal">0xFE62696E</code>) に使用されるものとは異なります。 <code class="literal">SHOW BINARY LOGS</code> ステートメントは、各バイナリログファイルが暗号化されているか暗号化されていないかを示します。 
    </p><p>
      バイナリログファイルが暗号化されている場合、<span class="command"><strong>mysqlbinlog</strong></span> はそれらを直接読み取ることはできませんが、<code class="option">--read-from-remote-server</code> オプションを使用してサーバーから読み取ることができます。 MySQL 8.0.14 から、暗号化されたバイナリログファイルを直接読み取ろうとしたが、古いバージョンの <span class="command"><strong>mysqlbinlog</strong></span> がそのファイルをバイナリログファイルとして認識しない場合、<span class="command"><strong>mysqlbinlog</strong></span> は適切なエラーを返します。 <span class="command"><strong>mysqlbinlog</strong></span> を使用して暗号化バイナリログファイルをバックアップする場合、<span class="command"><strong>mysqlbinlog</strong></span> を使用して生成されるファイルのコピーは暗号化されていない形式で格納されることに注意してください。 
    </p><p>
      バイナリログ暗号化は、バイナリログトランザクション圧縮 (MySQL 8.0.20 の時点で使用可能) と組み合わせることができます。 バイナリログのトランザクション圧縮の詳細は、<a class="xref" href="server-administration.html#binary-log-transaction-compression" title="5.4.4.5 バイナリログトランザクション圧縮">セクション5.4.4.5「バイナリログトランザクション圧縮」</a> を参照してください。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-binlog-encryption-scope"></a>17.3.2.1 バイナリログの暗号化の範囲</h4></div></div></div><p>
        MySQL サーバーインスタンスのバイナリログ暗号化がアクティブな場合、暗号化の範囲は次のとおりです:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            バイナリログファイルおよびリレーログファイルに書き込まれる保存データは、前述の 2 層暗号化アーキテクチャーを使用して、暗号化が開始された時点から暗号化されます。 暗号化を開始したときにサーバーに存在していた既存のバイナリログファイルおよびリレーログファイルは暗号化されません。 これらのファイルは、不要になったときにパージできます。 
          </p></li><li class="listitem"><p>
            <span class="command"><strong>mysqlbinlog</strong></span> を含む MySQL クライアントに送信されるレプリケーションイベントストリーム内の移動中のデータは、転送用に復号化されるため、接続暗号化を使用して転送中に保護する必要があります (<a class="xref" href="security.html#encrypted-connections" title="6.3 暗号化された接続の使用">セクション6.3「暗号化された接続の使用」</a> および <a class="xref" href="replication.html#replication-solutions-encrypted-connections" title="17.3.1 暗号化接続を使用するためのレプリケーションの設定">セクション17.3.1「暗号化接続を使用するためのレプリケーションの設定」</a> を参照)。
          </p></li><li class="listitem"><p>
            トランザクション中にバイナリログトランザクションおよびステートメントキャッシュに保持される使用中のデータは、キャッシュを格納するメモリーバッファー内で暗号化されていない形式です。 データは、メモリーバッファで使用可能な領域を超えると、ディスク上の一時ファイルに書き込まれます。 MySQL 8.0.17 から、バイナリログ暗号化がサーバー上でアクティブな場合、バイナリログキャッシュを保持するために使用される一時ファイルは、ストリーム暗号化に AES-CTR (AES カウンタモード) を使用して暗号化されます。 一時ファイルは揮発性であり、単一のプロセスに関連付けられているため、ランダムに生成されたファイルパスワードと初期化ベクトルを使用して単一層暗号化を使用して暗号化され、メモリー内にのみ存在し、ディスクまたはキーリングに格納されることはありません。 各トランザクションがコミットされると、バイナリログキャッシュがリセットされます: メモリーバッファがクリアされ、バイナリログキャッシュの保持に使用される一時ファイルが切り捨てられ、次のトランザクションで使用するために新しいファイルパスワードおよび初期化ベクトルがランダムに生成されます。 このリセットは、通常の停止または予期しない停止の後にサーバーが再起動された場合にも行われます。 
          </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">binlog_format=STATEMENT</code> が設定されているときに <code class="literal">LOAD DATA</code> を使用する場合 (ステートメントがステートメントベースのレプリケーションで安全でないとみなされるため、お薦めしません)、変更が適用されるレプリカにデータを含む一時ファイルが作成されます。 これらの一時ファイルは、バイナリログの暗号化がサーバー上でアクティブな場合は暗号化されません。 代わりに、一時ファイルを作成しない行ベースまたは混合バイナリロギング形式を使用してください。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-binlog-encryption-encryption-keys"></a>17.3.2.2 バイナリログ暗号化キー</h4></div></div></div><p>
        ログファイルのファイルパスワードの暗号化に使用されるバイナリログ暗号化キーは 256 ビットキーで、MySQL Server キーリングサービスを使用して各 MySQL サーバーインスタンス専用に生成されます (<a class="xref" href="security.html#keyring" title="6.4.4 MySQL キーリング">セクション6.4.4「MySQL キーリング」</a> を参照)。 鍵リングサービスは、バイナリログ暗号化鍵の作成、取得、および削除を処理します。 サーバーインスタンスは、自身に対して生成されたキーの作成と削除のみを行いますが、ファイルコピーによってクローニングされたサーバーインスタンスの場合と同様に、キーリングに格納されている他のインスタンスに対して生成されたキーを読み取ることができます。 
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          MySQL サーバーインスタンスのバイナリログ暗号化キーは、バックアップおよびリカバリ手順に含める必要があります。これは、現在および保持されているバイナリログファイルまたはリレーログファイルのファイルパスワードの復号化に必要なキーが失われた場合、サーバーを起動できない可能性があるためです。
        </p></div><p>
        鍵リング内のバイナリログ暗号化鍵の形式は次のとおりです:
      </p><pre class="programlisting">MySQLReplicationKey_{UUID}_{SEQ_NO}</pre><p>
        例:
      </p><pre class="programlisting">MySQLReplicationKey_00508583-b5ce-11e8-a6a5-0010e0734796_1 </pre><p>
        <code class="literal">{UUID}</code> は、MySQL サーバーによって生成される真の UUID (<code class="literal">server_uuid</code> システム変数の値) です。<code class="literal">{SEQ_NO}</code> はバイナリログ暗号化キーの順序番号で、サーバーで生成される新しいキーごとに 1 ずつ増分されます。
      </p><p>
        サーバーで現在使用されているバイナリログ暗号化鍵は、バイナリログマスターキーと呼ばれます。 現在のバイナリログマスターキーのシーケンス番号は、鍵リングに格納されます。 バイナリログマスターキーは、新しい各ログファイルパスワードを暗号化するために使用されます。これは、ファイルデータの暗号化に使用されるログファイルに固有のランダムに生成された 32 バイトのファイルパスワードです。 ファイルパスワードは AES-CBC (AES 暗号ブロックチェーンモード) を使用して 256 ビットバイナリログ暗号化キーおよびランダム初期化ベクトル (IV) とともに暗号化され、ログファイルヘッダーに格納されます。 ファイルデータは AES-CTR (AES カウンタモード) を使用して暗号化され、ファイルパスワードから 256 ビット鍵が生成され、nonce もファイルパスワードから生成されます。 ファイルパスワードの暗号化に使用されるバイナリログ暗号化キーがわかっている場合は、OpenSSL 暗号化ツールキットで使用可能なツールを使用して、暗号化ファイルを技術的にオフラインで復号化できます。 
      </p><p>
        バイナリログファイルおよびリレーログファイルが暗号化されるように、ファイルコピーを使用して暗号化がアクティブな MySQL サーバーインスタンスをクローニングする場合は、クローンサーバーがソースサーバーからバイナリログ暗号化キーを読み取ることができるように、キーリングもコピーされていることを確認します。 クローンサーバーで暗号化がアクティブ化されると (起動時またはその後)、クローンサーバーは、コピーされたファイルで使用されるバイナリログ暗号化キーにソースサーバーの生成済 UUID が含まれていることを認識します。 独自に生成された UUID を使用して新しいバイナリログ暗号化鍵を自動的に生成し、これを使用して後続のバイナリログファイルおよびリレーログファイルのファイルパスワードを暗号化します。 コピーされたファイルは、ソースサーバーキーを使用して引き続き読み取られます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-binlog-encryption-key-rotation"></a>17.3.2.3 バイナリログマスターキーのローテーション</h4></div></div></div><p>
        バイナリログの暗号化が有効になっている場合は、<code class="literal">ALTER INSTANCE ROTATE BINLOG MASTER KEY</code> を発行することで、サーバーの実行中いつでもバイナリログマスターキーをローテーションできます。 このステートメントを使用してバイナリログマスターキーを手動でローテーションすると、新規および後続のファイルのパスワードは新しいバイナリログマスターキーを使用して暗号化され、既存の暗号化バイナリログファイルおよびリレーログファイルのファイルパスワードも新しいバイナリログマスターキーを使用して再暗号化されるため、暗号化は完全に更新されます。 バイナリログマスターキーを定期的にローテーションして、組織のセキュリティーポリシーに準拠できます。また、現在のバイナリログマスターキーまたは以前のバイナリログマスターキーのいずれかが危険にさらされている疑いがある場合も同様です。 
      </p><p>
        バイナリログマスターキーを手動でローテーションすると、MySQL Server は次のアクションを順番に実行します:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            新しいバイナリログ暗号化鍵は、次に使用可能なシーケンス番号で生成され、鍵リングに格納され、新しいバイナリログマスターキーとして使用されます。
          </p></li><li class="listitem"><p>
            バイナリログおよびリレーログファイルは、すべてのチャネルでローテーションされます。
          </p></li><li class="listitem"><p>
            新しいバイナリログマスターキーは、新しいバイナリログファイル、リレーログファイル、および鍵が再度変更されるまで後続のファイルのファイルパスワードを暗号化するために使用されます。
          </p></li><li class="listitem"><p>
            サーバー上の既存の暗号化バイナリログファイルおよびリレーログファイルのファイルパスワードは、新しいバイナリログマスターキーを使用して、最新のファイルから順に再暗号化されます。 暗号化されていないファイルはスキップされます。 
          </p></li><li class="listitem"><p>
            再暗号化プロセス後にファイルに使用されなくなったバイナリログ暗号化キーは、キーリングから削除されます。
          </p></li></ol></div><p>
        <code class="literal">ALTER INSTANCE ROTATE BINLOG MASTER KEY</code> を発行するには <code class="literal">BINLOG_ENCRYPTION_ADMIN</code> 権限が必要であり、<code class="literal">binlog_encryption</code> システム変数が <code class="literal">OFF</code> に設定されている場合、このステートメントは使用できません。
      </p><p>
        バイナリログマスターキーローテーション処理の最終ステップとして、保持されているバイナリログファイルまたはリレーログファイルに適用されなくなったすべてのバイナリログ暗号化鍵が鍵リングからクリーンアップされます。 保持されているバイナリログファイルまたはリレーログファイルを再暗号化のために初期化できない場合、将来ファイルを回復できるように、関連するバイナリログ暗号化鍵は削除されません。 たとえば、バイナリログインデックスファイルにリストされているファイルが現在読み取れない場合や、チャネルの初期化に失敗した場合などです。 たとえば、MySQL Enterprise Backup を使用して作成されたバックアップを使用して新しいレプリカを設定するためにサーバー UUID が変更された場合、新しいサーバーで <code class="literal">ALTER INSTANCE ROTATE BINLOG MASTER KEY</code> を発行しても、元のサーバー UUID を含む以前のバイナリログ暗号化キーは削除されません。 
      </p><p>
        バイナリログマスターキーローテーション処理の最初の 4 つの手順のいずれかを正しく完了できない場合は、状況とバイナリログファイルおよびリレーログファイルの暗号化ステータスの結果を説明するエラーメッセージが発行されます。 以前に暗号化されたファイルは常に暗号化された状態のままですが、そのファイルのパスワードは古いバイナリログマスターキーを使用して暗号化される場合があります。 これらのエラーが表示された場合は、まず <code class="literal">ALTER INSTANCE ROTATE BINLOG MASTER KEY</code> を再発行してプロセスを再試行してください。 次に、個々のファイルのステータスを調べて、特に現在または以前のバイナリログマスターキーのいずれかが危険にさらされている可能性があると疑われる場合に、プロセスをブロックしている内容を確認します。 
      </p><p>
        バイナリログマスターキーローテーション処理の最終ステップを正しく完了できない場合は、状況を説明する警告メッセージが発行されます。 警告メッセージは、バイナリログマスターキーをローテーションするための鍵リング内の補助鍵をプロセスがクリーンアップできなかったか、または未使用のバイナリログ暗号化鍵をクリーンアップできなかったかを示します。 キーが補助キーであるか使用されなくなったため、メッセージを無視するか、<code class="literal">ALTER INSTANCE ROTATE BINLOG MASTER KEY</code> を再発行してプロセスを再試行できます。 
      </p><p>
        サーバーが停止し、バイナリログマスターキーローテーション処理中にバイナリログ暗号化が <code class="literal">ON</code> に設定されたままで再起動された場合、再起動後の新しいバイナリログファイルとリレーログファイルは新しいバイナリログマスターキーを使用して暗号化されます。 ただし、既存のファイルの再暗号化は続行されないため、サーバーが停止する前に再暗号化されなかったファイルは、以前のバイナリログマスターキーを使用して暗号化されたままになります。 再暗号化を完了し、未使用のバイナリログ暗号化キーをクリーンアップするには、再起動後に <code class="literal">ALTER INSTANCE ROTATE BINLOG MASTER KEY</code> を再発行します。 
      </p><p>
        <code class="literal">ALTER INSTANCE ROTATE BINLOG MASTER KEY</code> アクションはバイナリログに書き込まれず、レプリカでは実行されません。 したがって、バイナリログマスターキーローテーションは、MySQL バージョンの混在を含むレプリケーション環境で実行できます。 適用可能なすべてのソースサーバーおよびレプリカサーバーでバイナリログマスターキーの定期ローテーションをスケジュールするには、各サーバーで MySQL イベントスケジューラを有効にし、<code class="literal">CREATE EVENT</code> ステートメントを使用して <code class="literal">ALTER INSTANCE ROTATE BINLOG MASTER KEY</code> ステートメントを発行します。 現在または以前のバイナリログマスターキーのいずれかが危険にさらされている可能性があるためにバイナリログマスターキーをローテーションした場合は、該当するすべてのソースおよびレプリカサーバーでステートメントを発行します。 個々のサーバーでステートメントを発行すると、遅延しているレプリカ、複数のレプリケーショントポロジに属しているレプリカ、またはレプリケーショントポロジで現在アクティブではないがバイナリログファイルとリレーログファイルがあるレプリカの場合でも、即座にコンプライアンスを検証できます。 
      </p><p>
        <code class="literal">binlog_rotate_encryption_master_key_at_startup</code> システム変数は、サーバーの再起動時にバイナリログマスターキーを自動的にローテーションするかどうかを制御します。 このシステム変数が <code class="literal">ON</code> に設定されている場合、新しいバイナリログ暗号化鍵が生成され、サーバーが再起動されるたびに新しいバイナリログマスターキーとして使用されます。 <code class="literal">OFF</code>(デフォルト) に設定されている場合は、再起動後に既存のバイナリログマスターキーが再度使用されます。 バイナリログマスターキーが起動時にローテーションされると、新しいバイナリログおよびリレーログファイルのファイルパスワードは新しいキーを使用して暗号化されます。 既存の暗号化バイナリログファイルおよびリレーログファイルのファイルパスワードは再暗号化されないため、鍵リングで引き続き使用できる古い鍵を使用して暗号化されたままになります。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-privilege-checks"></a>17.3.3 レプリケーション権限チェック</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-privilege-checks-account">17.3.3.1 レプリケーション PRIVILEGE_CHECKS_USER アカウントの権限</a></span></dt><dt><span class="section"><a href="replication.html#replication-privilege-checks-gr">17.3.3.2 グループレプリケーションチャネルの権限チェック</a></span></dt><dt><span class="section"><a href="replication.html#replication-privilege-checks-recover">17.3.3.3 失敗したレプリケーション権限チェックからのリカバリ</a></span></dt></dl></div><p>
      デフォルトでは、別のサーバーによってすでに受け入れられたトランザクションがレプリカまたはグループメンバーに適用されている場合、MySQL レプリケーション (グループレプリケーションを含む) は権限チェックを実行しません。 MySQL 8.0.18 から、通常はチャネルでレプリケートされるトランザクションを適用する適切な権限を持つユーザーアカウントを作成し、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23 の場合) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 の場合) を使用して、これをレプリケーションアプライアンスの <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントとして指定できます。 次に、MySQL は各トランザクションをユーザーアカウント権限と照合してチェックし、そのチャネルに対する操作が認可されていることを確認します。 管理者は、このアカウントを安全に使用して、チャネルのレプリケーションエラーからのリカバリなど、<span class="command"><strong>mysqlbinlog</strong></span> 出力からトランザクションを適用または再適用することもできます。 
    </p><p>
      <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントを使用すると、権限のある操作または不要な操作の不正または誤った使用からレプリケーションチャネルを保護できます。 <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントは、次のような状況で追加のセキュリティレイヤーを提供します: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          あなたは、組織のネットワーク上のサーバーインスタンスと、クラウドサービスプロバイダによって提供されるインスタンスなど、別のネットワーク上のサーバーインスタンスの間でレプリケートしています。
        </p></li><li class="listitem"><p>
          すべてのデプロイメントに対して 1 つの管理者アカウント権限を付与せずに、複数のオンプレミスデプロイメントまたはオフサイトデプロイメントを別々のユニットとして管理する場合。
        </p></li><li class="listitem"><p>
          管理者がサーバーインスタンスに対する広範囲の権限を持つのではなく、レプリケーションチャネルおよびレプリケーションチャネルがレプリケートするデータベースに直接関連する操作のみを実行できるようにする管理者アカウントが必要です。
        </p></li></ul></div><p>
      チャネルの <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントを指定するときに、次のいずれかまたは両方のオプションを <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントに追加することで、権限チェックが適用されるレプリケーションチャネルのセキュリティを強化できます:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">REQUIRE_ROW_FORMAT</code> オプション (MySQL 8.0.19 から使用可能) は、レプリケーションチャネルが行ベースのレプリケーションイベントのみを受け入れるようにします。 <code class="literal">REQUIRE_ROW_FORMAT</code> が設定されている場合、ソースサーバーで行ベースのバイナリロギング (<code class="literal">binlog_format=ROW</code>) を使用する必要があります。 MySQL 8.0.18 では、<code class="literal">REQUIRE_ROW_FORMAT</code> は使用できませんが、セキュアなレプリケーションチャネルに行ベースのバイナリロギングを使用することを強くお薦めします。 ステートメントベースのバイナリロギングでは、<code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントがトランザクションを正常に実行するために、一部の管理者レベルの権限が必要になる場合があります。 
        </p></li><li class="listitem"><p>
          <code class="literal">REQUIRE_TABLE_PRIMARY_KEY_CHECK</code> オプション (MySQL 8.0.20 から使用可能) は、レプリケーションチャネルが主キーチェックに独自のポリシーを使用するようにします。 <code class="literal">ON</code> を設定することは、主キーが常に必要であり、<code class="literal">OFF</code> を設定することは、主キーが不要であることを意味します。 デフォルト設定の <code class="literal">STREAM</code> では、各トランザクションのソースからレプリケートされた値を使用して、<code class="literal">sql_require_primary_key</code> システム変数のセッション値が設定されます。 <code class="literal">PRIVILEGE_CHECKS_USER</code> が設定されている場合、<code class="literal">REQUIRE_TABLE_PRIMARY_KEY_CHECK</code> を <code class="literal">ON</code> または <code class="literal">OFF</code> に設定することは、<code class="literal">sql_require_primary_key</code> の値を変更するために必要な、制限されたセッション変数を設定するためのセッション管理レベルの権限をユーザーアカウントが必要としないことを意味します。 また、様々なソースのレプリケーションチャネル間の動作を正規化します。 
        </p></li></ul></div><p>
      レプリケーションアプライヤスレッドの <code class="literal">PRIVILEGE_CHECKS_USER</code> としてユーザーアカウントを表示できるようにし、mysqlbinlog で使用される内部使用 <code class="literal">BINLOG</code> ステートメントを実行するには、<code class="literal">REPLICATION_APPLIER</code> 権限を付与します。 <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントのユーザー名とホスト名は、<a class="xref" href="security.html#account-names" title="6.2.4 アカウント名の指定">セクション6.2.4「アカウント名の指定」</a> で説明されている構文に従う必要があり、ユーザーは匿名ユーザー (ユーザー名が空白) または <code class="literal">CURRENT_USER</code> であってはなりません。 新しいアカウントを作成するには、<code class="literal">CREATE USER</code> を使用します。 このアカウントに <code class="literal">REPLICATION_APPLIER</code> 権限を付与するには、<code class="literal">GRANT</code> ステートメントを使用します。 たとえば、<code class="literal">example.com</code> ドメイン内の任意のホストから管理者が手動で使用でき、暗号化された接続が必要なユーザーアカウント <code class="literal">priv_repl</code> を作成するには、次のステートメントを発行します: 
    </p><pre class="programlisting">mysql&gt; SET sql_log_bin = 0;
mysql&gt; CREATE USER 'priv_repl'@'%.example.com' IDENTIFIED BY '<em class="replaceable"><code>password</code></em>' REQUIRE SSL;
mysql&gt; GRANT REPLICATION_APPLIER ON *.* TO 'priv_repl'@'%.example.com';
mysql&gt; SET sql_log_bin = 1;
</pre><p>
      <code class="literal">SET sql_log_bin</code> ステートメントは、アカウント管理ステートメントがバイナリログに追加されず、レプリケーションチャネルに送信されないように使用されます (<a class="xref" href="sql-statements.html#set-sql-log-bin" title="13.4.1.3 SET sql_log_bin ステートメント">セクション13.4.1.3「SET sql_log_bin ステートメント」</a> を参照)。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        <code class="literal">caching_sha2_password</code> 認証プラグインは、MySQL 8.0 から作成された新規ユーザーのデフォルトです (詳細は、<a class="xref" href="security.html#caching-sha2-pluggable-authentication" title="6.4.1.2 SHA-2 プラガブル認証のキャッシュ">セクション6.4.1.2「SHA-2 プラガブル認証のキャッシュ」</a> を参照)。 このプラグインで認証するユーザーアカウントを使用してサーバーに接続するには、<a class="xref" href="replication.html#replication-solutions-encrypted-connections" title="17.3.1 暗号化接続を使用するためのレプリケーションの設定">セクション17.3.1「暗号化接続を使用するためのレプリケーションの設定」</a> の説明に従って暗号化された接続を設定するか、RSA キーペアを使用したパスワード交換をサポートするように暗号化されていない接続を有効にする必要があります。 
      </p></div><p>
      ユーザーアカウントを設定した後、<code class="literal">GRANT</code> ステートメントを使用して追加の権限を付与し、サーバーに保持されている特定のテーブルの更新など、アプライヤスレッドが実行する予定のデータベース変更をユーザーアカウントが実行できるようにします。 レプリケーションチャネルでこれらのトランザクションのいずれかを手動で実行する必要がある場合、管理者はこれらの同じ権限を使用できます。 適切な権限を付与しなかった予期しない操作が試行された場合、操作は許可されず、レプリケーションアプライヤスレッドはエラーで停止します。<a class="xref" href="replication.html#replication-privilege-checks-account" title="17.3.3.1 レプリケーション PRIVILEGE_CHECKS_USER アカウントの権限">セクション17.3.3.1「レプリケーション PRIVILEGE_CHECKS_USER アカウントの権限」</a> では、アカウントに必要な追加の権限について説明します。 たとえば、<code class="literal">priv_repl</code> ユーザーアカウントに <code class="literal">db1</code> の <code class="literal">cust</code> テーブルに行を追加する <code class="literal">INSERT</code> 権限を付与するには、次のステートメントを発行します: 
    </p><pre class="programlisting">mysql&gt; GRANT INSERT ON db1.cust TO 'priv_repl'@'%.example.com';
</pre><p>
      レプリケーションチャネルの <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントは、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23 の場合) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 の場合) を使用して割り当てます。 <code class="literal">PRIVILEGE_CHECKS_USER</code> が設定されている場合は、行ベースのバイナリロギングを使用することを強くお勧めします。また、MySQL 8.0.19 から、このステートメントを使用して <code class="literal">REQUIRE_ROW_FORMAT</code> を設定してこれを強制できます。 レプリケーションが実行中の場合は、<code class="literal">CHANGE MASTER TO</code> ステートメントの前に <code class="literal">STOP REPLICA | SLAVE</code> を発行し、その後に <code class="literal">START REPLICA | SLAVE</code> を発行します。 たとえば、実行中のレプリカでチャネル <code class="literal">channel_1</code> に対する権限チェックを開始するには、次のステートメントを発行します: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>STOP SLAVE FOR CHANNEL 'channel_1';</code></strong>
mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO</code></strong>
         <strong class="userinput"><code>PRIVILEGE_CHECKS_USER = 'priv_repl'@'%.example.com',</code></strong>
         <strong class="userinput"><code>REQUIRE_ROW_FORMAT = 1 FOR CHANNEL 'channel_1';</code></strong>
mysql&gt; <strong class="userinput"><code>START SLAVE FOR CHANNEL 'channel_1';</code></strong>

Or from MySQL 8.0.22 / 8.0.23:
mysql&gt; <strong class="userinput"><code>STOP REPLICA FOR CHANNEL 'channel_1';</code></strong>
mysql&gt; <strong class="userinput"><code>CHANGE REPLICATION SOURCE TO</code></strong>
         <strong class="userinput"><code>PRIVILEGE_CHECKS_USER = 'priv_repl'@'%.example.com',</code></strong>
         <strong class="userinput"><code>REQUIRE_ROW_FORMAT = 1 FOR CHANNEL 'channel_1';</code></strong>
mysql&gt; <strong class="userinput"><code>START REPLICA FOR CHANNEL 'channel_1';</code></strong>
</pre><p>
      レプリケーションチャネルを再起動すると、その時点から権限チェックが適用されます。 チャネルを指定せず、他のチャネルが存在しない場合は、ステートメントがデフォルトチャネルに適用されます。 チャネルの <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントのユーザー名とホスト名は、パフォーマンススキーマの <code class="literal">replication_applier_configuration</code> テーブルに表示されます。ここでは、パフォーマンススキーマが適切にエスケープされているため、個々のトランザクションを実行するために SQL ステートメントに直接コピーできます。 
    </p><p>
      レプリケーションチャネルに <code class="literal">REQUIRE_ROW_FORMAT</code> が設定されている場合、レプリケーションアプライアンスは一時テーブルを作成または削除しないため、<code class="literal">pseudo_thread_id</code> セッションシステム変数は設定されません。 <code class="literal">LOAD DATA INFILE</code> 命令は実行されないため、(<code class="literal">Format_description_log_event</code> としてログに記録された) データロードに関連付けられた一時ファイルへのファイル操作のアクセスまたは削除は試行されません。 <code class="literal">INTVAR</code>、<code class="literal">RAND</code> および <code class="literal">USER_VAR</code> イベントは実行されません。これらは、ステートメントベースレプリケーションのクライアント接続状態を再現するために使用されます。 (例外は、実行される DDL クエリーに関連付けられた <code class="literal">USER_VAR</code> イベントです。) DML トランザクション内に記録されるステートメントは実行されません。 トランザクションのキューイングまたは適用の試行中にレプリケーションアプライアンスがこれらのタイプのイベントのいずれかを検出した場合、イベントは適用されず、レプリケーションはエラーで停止します。 
    </p><p>
      <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントを設定するかどうかに関係なく、レプリケーションチャネルに <code class="literal">REQUIRE_ROW_FORMAT</code> を設定できます。 このオプションを設定すると、権限チェックなしでもレプリケーションチャネルのセキュリティが向上します。 <span class="command"><strong>mysqlbinlog</strong></span> の使用時に <code class="option">--require-row-format</code> オプションを指定して、<span class="command"><strong>mysqlbinlog</strong></span> 出力で行ベースのレプリケーションイベントを強制することもできます。 
    </p><p><b>セキュリティコンテキスト. </b>
        デフォルトでは、レプリケーションアプライヤスレッドが <code class="literal">PRIVILEGE_CHECKS_USER</code> として指定されたユーザーアカウントで起動されると、セキュリティコンテキストはデフォルトロールを使用して作成されるか、<code class="literal">activate_all_roles_on_login</code> が <code class="literal">ON</code> に設定されている場合はすべてのロールを使用して作成されます。
      </p><p>
      次の例に示すように、ロールを使用して、<code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントとして使用されるアカウントに一般権限セットを提供できます。 ここでは、前述の例のように、<code class="literal">db1.cust</code> テーブルに対する <code class="literal">INSERT</code> 権限をユーザーアカウントに直接付与するかわりに、この権限が <code class="literal">REPLICATION_APPLIER</code> 権限とともに <code class="literal">priv_repl_role</code> ロールに付与されます。 このロールは、権限セットを 2 つのユーザーアカウントに付与するために使用され、その両方を <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントとして使用できるようになります: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET sql_log_bin = 0;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE USER 'priv_repa'@'%.example.com'</code></strong>
                  <strong class="userinput"><code>IDENTIFIED BY '<em class="replaceable"><code>password</code></em>'</code></strong>
                  <strong class="userinput"><code>REQUIRE SSL;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE USER 'priv_repb'@'%.example.com'</code></strong>
                  <strong class="userinput"><code>IDENTIFIED BY '<em class="replaceable"><code>password</code></em>'</code></strong>
                  <strong class="userinput"><code>REQUIRE SSL;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE ROLE 'priv_repl_role';</code></strong>
mysql&gt; <strong class="userinput"><code>GRANT REPLICATION_APPLIER TO 'priv_repl_role';</code></strong>
mysql&gt; <strong class="userinput"><code>GRANT INSERT ON db1.cust TO 'priv_repl_role';</code></strong>
mysql&gt; <strong class="userinput"><code>GRANT 'priv_repl_role' TO</code></strong>
                  <strong class="userinput"><code>'priv_repa'@'%.example.com',</code></strong>
                  <strong class="userinput"><code>'priv_repb'@'%.example.com';</code></strong>
mysql&gt; <strong class="userinput"><code>SET DEFAULT ROLE 'priv_repl_role' TO</code></strong>
                  <strong class="userinput"><code>'priv_repa'@'%.example.com',</code></strong>
                  <strong class="userinput"><code>'priv_repb'@'%.example.com';</code></strong>
mysql&gt; <strong class="userinput"><code>SET sql_log_bin = 1;</code></strong>
</pre><p>
      レプリケーションアプライヤスレッドがセキュリティコンテキストを作成する場合、<code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントの権限はチェックされますが、パスワード検証は実行されず、アカウントがロックされているかどうかのチェックなど、アカウント管理に関連するチェックは実行されません。 作成されたセキュリティコンテキストは、レプリケーションアプライヤスレッドの存続期間中は変更されません。 
    </p><p><b>制限. </b>
        MySQL 8.0.18 でのみ、<code class="literal">RESET REPLICA | SLAVE</code> ステートメントを発行した直後にレプリカ <span class="command"><strong>mysqld</strong></span> が再起動された場合 (予期しないサーバー終了または意図的な再起動のため)、<code class="literal">mysql.slave_relay_log_info</code> テーブルに保持されている <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウント設定は失われ、再指定する必要があります。 そのリリースで権限チェックを使用する場合は、必ず再起動後に権限チェックが設定されていることを確認し、必要に応じて再指定します。 この状況では、MySQL 8.0.19 から <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウント設定が保持されるため、テーブルから取得され、チャネルに再適用されます。 

      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-privilege-checks-account"></a>17.3.3.1 レプリケーション PRIVILEGE_CHECKS_USER アカウントの権限</h4></div></div></div><p>
        レプリケーションチャネルの <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントとして <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントを使用して指定されたユーザーアカウントには、<code class="literal">REPLICATION_APPLIER</code> 権限が必要です。権限がない場合、レプリケーションアプライアンススレッドは起動しません。 <a class="xref" href="replication.html#replication-privilege-checks" title="17.3.3 レプリケーション権限チェック">セクション17.3.3「レプリケーション権限チェック」</a> で説明されているように、アカウントには、レプリケーションチャネルで予想されるすべてのトランザクションを適用するのに十分な追加の権限が必要です。 これらの権限は、関連するトランザクションが実行された場合にのみチェックされます。 
      </p><p>
        <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントを使用して保護されているレプリケーションチャネルには、行ベースのバイナリロギング (<code class="literal">binlog_format=ROW</code>) を使用することを強くお薦めします。 ステートメントベースのバイナリロギングでは、<code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントがトランザクションを正常に実行するために、一部の管理者レベルの権限が必要になる場合があります。 MySQL 8.0.19 から、<code class="literal">REQUIRE_ROW_FORMAT</code> 設定を保護されたチャネルに適用できます。これにより、チャネルはこれらの権限を必要とするイベントを実行できなくなります。 
      </p><p>
        <code class="literal">REPLICATION_APPLIER</code> 権限によって、<code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントはレプリケーションスレッドが実行する必要がある次の操作を明示的または暗黙的に実行できます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            システム変数 <code class="literal">gtid_next</code>, <code class="literal">original_commit_timestamp</code>, <code class="literal">original_server_version</code>, <code class="literal">immediate_server_version</code> および <code class="literal">pseudo_slave_mode</code> の値を設定して、トランザクションの実行時に適切なメタデータおよび動作を適用します。
          </p></li><li class="listitem"><p>
            内部使用の <code class="literal">BINLOG</code> ステートメントを実行して <span class="command"><strong>mysqlbinlog</strong></span> 出力を適用します (アカウントにそれらのステートメントのテーブルおよび操作に対する権限もある場合)。
          </p></li><li class="listitem"><p>
            レプリケーションメタデータを更新するためのシステムテーブル <code class="literal">mysql.gtid_executed</code>, <code class="literal">mysql.slave_relay_log_info</code>, <code class="literal">mysql.slave_worker_info</code> および <code class="literal">mysql.slave_master_info</code> の更新。 (イベントが他の目的でこれらのテーブルに明示的にアクセスする場合は、テーブルに対する適切な権限を付与する必要があります。) 
          </p></li><li class="listitem"><p>
            バイナリログ <code class="literal">Table_map_log_event</code> を適用します。これは、テーブルメタデータを提供しますが、データベースの変更は行いません。
          </p></li></ul></div><p>
        <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントの <code class="literal">REQUIRE_TABLE_PRIMARY_KEY_CHECK</code> オプションがデフォルトの <code class="literal">STREAM</code> に設定されている場合、<code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントには、ソースからレプリケートされた設定と一致するようにセッション期間中に <code class="literal">sql_require_primary_key</code> システム変数の値を変更できるように、制限付きセッション変数を設定するのに十分な権限が必要です。 <code class="literal">SESSION_VARIABLES_ADMIN</code> 権限により、アカウントにこの機能が付与されます。 この権限により、アカウントは <code class="option">--disable-log-bin</code> オプションを使用して作成された <span class="command"><strong>mysqlbinlog</strong></span> 出力を適用することもできます。 <code class="literal">REQUIRE_TABLE_PRIMARY_KEY_CHECK</code> を <code class="literal">ON</code> または <code class="literal">OFF</code> のいずれかに設定した場合、レプリカはレプリケーション操作で <code class="literal">sql_require_primary_key</code> システム変数にその値を常に使用するため、これらのセッション管理レベルの権限は必要ありません。 
      </p><p>
        テーブルの暗号化が使用されており、<code class="literal">table_encryption_privilege_check</code> システム変数が <code class="literal">ON</code> に設定されており、イベントに関係するテーブルスペースの暗号化設定が (<code class="literal">default_table_encryption</code> システム変数で指定された) サーバーのデフォルトの暗号化設定の適用と異なる場合、<code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントでは、デフォルトの暗号化設定をオーバーライドするために <code class="literal">TABLE_ENCRYPTION_ADMIN</code> 権限が必要です。 この権限を付与しないことを強くお薦めします。 かわりに、レプリカのデフォルトの暗号化設定がレプリケートするテーブルスペースの暗号化ステータスと一致し、レプリケーショングループメンバーのデフォルトの暗号化設定が同じであることを確認して、権限が不要になるようにします。 
      </p><p>
        特定のレプリケートされたトランザクションをリレーログから実行するか、必要に応じて <span class="command"><strong>mysqlbinlog</strong></span> 出力から実行するには、<code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントに次の権限が必要です:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            (<code class="literal">Write_rows_log_event</code> として記録される) 行形式で記録される行挿入の場合、関連するテーブルに対する <code class="literal">INSERT</code> 権限。
          </p></li><li class="listitem"><p>
            (<code class="literal">Update_rows_log_event</code> として記録される) 行形式で記録された行更新の場合、関連するテーブルに対する <code class="literal">UPDATE</code> 権限。
          </p></li><li class="listitem"><p>
            (<code class="literal">Delete_rows_log_event</code> として記録される) 行形式で記録された行の削除の場合、関連するテーブルに対する <code class="literal">DELETE</code> 権限。
          </p></li></ul></div><p>
        ステートメントベースのバイナリロギングが使用されている (<code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントでは推奨されません) 場合、<code class="literal">BEGIN</code>、<code class="literal">COMMIT</code>、DML logged in statement format (<code class="literal">Query_log_event</code> として記録されます) などのトランザクション制御ステートメントでは、<code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントにはイベントに含まれるステートメントを実行する権限が必要です。
      </p><p>
        レプリケーションチャネルで <code class="literal">LOAD DATA</code> 操作を実行する必要がある場合は、行ベースのバイナリロギング (<code class="literal">binlog_format=ROW</code>) を使用します。 このロギング形式では、イベントの実行に <code class="literal">FILE</code> 権限は必要ないため、<code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントにこの権限を付与しないでください。 <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントを使用して保護されているレプリケーションチャネルでは、行ベースのバイナリロギングを使用することを強くお勧めします。 チャネルに <code class="literal">REQUIRE_ROW_FORMAT</code> が設定されている場合は、行ベースのバイナリロギングが必要です。 <code class="literal">LOAD DATA</code> イベントによって作成された一時ファイルを削除する <code class="literal">Format_description_log_event</code> は、権限チェックなしで処理されます。 詳細は、<a class="xref" href="replication.html#replication-features-load-data" title="17.5.1.19 レプリケーションと LOAD DATA">セクション17.5.1.19「レプリケーションと LOAD DATA」</a>を参照してください。 
      </p><p>
        レプリケーション SQL スレッドの起動時に実行される 1 つ以上の SQL ステートメントを指定するように <code class="literal">init_slave</code> システム変数が設定されている場合、<code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントにはこれらのステートメントの実行に必要な権限が必要です。
      </p><p>
        <code class="literal">CREATE USER</code>, <code class="literal">CREATE ROLE</code>, <code class="literal">DROP ROLE</code> や <code class="literal">GRANT OPTION</code> などの ACL 権限を <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントに付与しないこと、およびアカウントによる <code class="literal">mysql.user</code> テーブルの更新を許可しないことをお薦めします。 これらの権限では、アカウントを使用してサーバー上のユーザーアカウントを作成または変更できます。 ソースサーバーで発行された ACL ステートメントが実行のために保護されたチャネルにレプリケートされないようにするには (これらの権限がない場合は失敗します)、すべての ACL ステートメントの前に <code class="literal">SET sql_log_bin = 0</code> を発行し、その後に <code class="literal">SET sql_log_bin = 1</code> を発行して、ソースバイナリログからステートメントを除外します。 または、すべての ACL ステートメントを実行する前に専用の現行データベースを設定し、レプリケーションフィルタ (<code class="option">--binlog-ignore-db</code>) を使用してレプリカでこのデータベースを除外することもできます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-privilege-checks-gr"></a>17.3.3.2 グループレプリケーションチャネルの権限チェック</h4></div></div></div><p>
        MySQL 8.0.19 から、非同期レプリケーションおよび準同期レプリケーションを保護するだけでなく、<code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントを使用して、Group Replication で使用される 2 つのレプリケーションアプライヤスレッドを保護することもできます。 各グループメンバーの <code class="literal">group_replication_applier</code> スレッドはグループトランザクションの適用に使用され、各グループメンバーの <code class="literal">group_replication_recovery</code> スレッドは、メンバーがグループに参加または再参加したときの分散リカバリの一環として、バイナリログからの状態転送に使用されます。 
      </p><p>
        これらのスレッドのいずれかを保護するには、Group Replication を停止し、<code class="literal">PRIVILEGE_CHECKS_USER</code> オプションとともに <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 より前) を発行し、チャネル名として <code class="literal">group_replication_applier</code> または <code class="literal">group_replication_recovery</code> を指定します。。 例: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>STOP GROUP_REPLICATION;</code></strong>
mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO PRIVILEGE_CHECKS_USER = 'gr_repl'@'%.example.com' 
          FOR CHANNEL 'group_replication_recovery';</code></strong>
mysql&gt; <strong class="userinput"><code>START GROUP_REPLICATION;</code></strong>

Or from MySQL 8.0.23:
mysql&gt; <strong class="userinput"><code>STOP GROUP_REPLICATION;</code></strong>
mysql&gt; <strong class="userinput"><code>CHANGE REPLICATION SOURCE TO PRIVILEGE_CHECKS_USER = 'gr_repl'@'%.example.com' 
          FOR CHANNEL 'group_replication_recovery';</code></strong>
mysql&gt; <strong class="userinput"><code>START GROUP_REPLICATION;</code></strong>
</pre><p>
        グループレプリケーションチャネルの場合、<code class="literal">REQUIRE_ROW_FORMAT</code> 設定はチャネルの作成時に自動的に有効化され、無効化できないため、指定する必要はありません。
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          MySQL 8.0.19 では、Group Replication の実行中に <code class="literal">PRIVILEGE_CHECKS_USER</code> オプションを指定して <code class="literal">CHANGE REPLICATION SOURCE TO</code>|<code class="literal">CHANGE MASTER TO</code> ステートメントを発行しないでください。 このアクションにより、チャネルのリレーログファイルがパージされ、受信してリレーログにキューに入れられたがまだ適用されていないトランザクションが失われる可能性があります。 
        </p></div><p>
        グループレプリケーションでは、グループによってレプリケートされるすべてのテーブルに、定義済の主キーまたは同等の主キー (同等のものが NULL 以外の一意キー) がある必要があります。 グループレプリケーションには、<code class="literal">sql_require_primary_key</code> システム変数によって実行されるチェックを使用するかわりに、主キーまたは主キーに相当する独自の組込みチェックセットがあります。 グループレプリケーションチャネルの場合、<code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントの <code class="literal">REQUIRE_TABLE_PRIMARY_KEY_CHECK</code> オプションを <code class="literal">ON</code> に設定できます。 ただし、グループレプリケーションの組込みチェックで許可されている一部のトランザクションは、<code class="literal">sql_require_primary_key = ON</code> または <code class="literal">REQUIRE_TABLE_PRIMARY_KEY_CHECK = ON</code> の設定時に実行されるチェックでは許可されない場合があることに注意してください。 このため、MySQL 8.0.20 の新規およびアップグレードされたグループレプリケーションチャネル (オプションが導入された場合) では、<code class="literal">REQUIRE_TABLE_PRIMARY_KEY_CHECK</code> が <code class="literal">ON</code> ではなく <code class="literal">STREAM</code> のデフォルトに設定されています。 
      </p><p>
        Group Replication (<a class="xref" href="group-replication.html#group-replication-cloning" title="18.4.3.2 分散リカバリのためのクローニング">セクション18.4.3.2「分散リカバリのためのクローニング」</a> を参照) の分散リカバリにリモートクローニング操作が使用されている場合、MySQL 8.0.19 から、ドナーの <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントおよび関連設定が結合メンバーにクローニングされます。 参加メンバーがブート時にグループレプリケーションを開始するように設定されている場合、適切なレプリケーションチャネルの権限チェックにアカウントが自動的に使用されます。 
      </p><p>
        MySQL 8.0.18 では、多くの制限により、グループレプリケーションチャネルで <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントを使用しないことをお薦めします。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-privilege-checks-recover"></a>17.3.3.3 失敗したレプリケーション権限チェックからのリカバリ</h4></div></div></div><p>
        <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントに対する権限チェックが失敗した場合、トランザクションは実行されず、チャネルのレプリケーションは停止します。 エラーの詳細と最後に適用されたトランザクションは、パフォーマンススキーマ <code class="literal">replication_applier_status_by_worker</code> テーブルに記録されます。 エラーから回復するには、次の手順に従います: 
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            エラーの原因となったレプリケートイベントを特定し、イベントが予想されるかどうか、および信頼できるソースからのものかどうかを確認します。 <span class="command"><strong>mysqlbinlog</strong></span> を使用して、エラー発生時にログに記録されたイベントを取得して表示できます。 これを行う手順は、<a class="xref" href="backup-and-recovery.html#point-in-time-recovery" title="7.5 Point-in-Time (増分) リカバリ">セクション7.5「Point-in-Time (増分) リカバリ」</a> を参照してください。 
          </p></li><li class="listitem"><p>
            レプリケートされたイベントが予期されていないか、既知の信頼できるソースからのものでない場合は、原因を調査します。 イベントが発生した理由がわかり、セキュリティ上の考慮事項がない場合は、次の説明に従ってエラーの修正に進みます。 
          </p></li><li class="listitem"><p>
            <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントがトランザクションの実行を許可されている必要があるが、正しく構成されていない場合は、アカウントに不足している権限を付与し、チャネルのレプリケーションを再開します。
          </p></li><li class="listitem"><p>
            トランザクションを実行する必要があり、信頼できることを確認したが、<code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントにこの権限を通常どおりに付与しない場合は、<code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントに必要な権限を一時的に付与できます。 レプリケートされたイベントが適用されたら、アカウントから権限を削除し、必要なステップを実行して、回避できる場合にイベントが繰り返されないようにします。 
          </p></li><li class="listitem"><p>
            トランザクションがソースでのみ実行され、レプリカでは実行されない管理アクションである場合、または単一のレプリケーショングループメンバーでのみ実行される必要がある場合は、レプリケーションを停止したサーバーでトランザクションをスキップし、<code class="literal">START REPLICA | SLAVE</code> を発行してチャネルでレプリケーションを再起動します。 今後の状況を回避するために、その前に <code class="literal">SET sql_log_bin = 0</code> を使用し、その後に <code class="literal">SET sql_log_bin = 1</code> を使用してこのような管理ステートメントを発行して、ソースに記録されないようにすることができます。 
          </p></li><li class="listitem"><p>
            トランザクションがソースまたはレプリカで行われてはならない DDL ステートメントまたは DML ステートメントである場合は、レプリケーションを停止したサーバー上のトランザクションをスキップし、トランザクションを元のサーバー上で手動で取り消してから、<code class="literal">START REPLICA | SLAVE</code> を発行してレプリケーションを再起動します。
          </p></li></ol></div><p>
        GTID が使用中の場合にトランザクションをスキップするには、失敗したトランザクションの GTID を持つ空のトランザクションをコミットします。次に例を示します:
      </p><pre class="programlisting">SET GTID_NEXT='aaa-bbb-ccc-ddd:N';
BEGIN;
COMMIT;
SET GTID_NEXT='AUTOMATIC';
</pre><p>
        GTID が使用されていない場合は、<code class="literal">SET GLOBAL sql_slave_skip_counter</code> ステートメントを発行してイベントをスキップします。 この代替方法を使用する手順およびトランザクションのスキップの詳細は、<a class="xref" href="replication.html#replication-administration-skip" title="17.1.7.3 トランザクションのスキップ">セクション17.1.7.3「トランザクションのスキップ」</a> を参照してください。 
      </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="replication-solutions"></a>17.4 レプリケーションソリューション</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-solutions-backups">17.4.1 バックアップ用にレプリケーションを使用する</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-unexpected-replica-halt">17.4.2 レプリカの予期しない停止の処理</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-rbr-monitoring">17.4.3 行ベースのレプリケーションの監視</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-diffengines">17.4.4 異なるソースおよびレプリカのストレージエンジンでのレプリケーションの使用</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-scaleout">17.4.5 スケールアウトのためにレプリケーションを使用する</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-partitioning">17.4.6 異なるレプリカへの異なるデータベースのレプリケート</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-performance">17.4.7 レプリケーションパフォーマンスを改善する</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-switch">17.4.8 フェイルオーバー中のソースの切替え</a></span></dt><dt><span class="section"><a href="replication.html#replication-asynchronous-connection-failover">17.4.9 非同期接続フェイルオーバーによるソースの切替え</a></span></dt><dt><span class="section"><a href="replication.html#replication-semisync">17.4.10 準同期レプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-delayed">17.4.11 遅延レプリケーション</a></span></dt></dl></div><p>
    レプリケーションは、多くの異なる環境でさまざまな目的に使用できます。 このセクションでは、特定のソリューションタイプにレプリケーションを使用する場合の一般的な注意点とアドバイスを提供します。 
  </p><p>
    セットアップに関する注意点、バックアップ手順、バックアップするファイルなど、バックアップ環境でレプリケーションを使用する場合の情報については、<a class="xref" href="replication.html#replication-solutions-backups" title="17.4.1 バックアップ用にレプリケーションを使用する">セクション17.4.1「バックアップ用にレプリケーションを使用する」</a>を参照してください。
  </p><p>
    ソースとレプリカで異なるストレージエンジンを使用する際のアドバイスとヒントについては、<a class="xref" href="replication.html#replication-solutions-diffengines" title="17.4.4 異なるソースおよびレプリカのストレージエンジンでのレプリケーションの使用">セクション17.4.4「異なるソースおよびレプリカのストレージエンジンでのレプリケーションの使用」</a> を参照してください。
  </p><p>
    スケールアウトソリューションとしてレプリケーションを使用するには、ソリューションを使用するアプリケーションのロジックとオペレーションで若干の変更が必要になります。 <a class="xref" href="replication.html#replication-solutions-scaleout" title="17.4.5 スケールアウトのためにレプリケーションを使用する">セクション17.4.5「スケールアウトのためにレプリケーションを使用する」</a>を参照してください。 
  </p><p>
    パフォーマンスまたはデータ分散の理由から、異なるデータベースを異なるレプリカにレプリケートできます。 <a class="xref" href="replication.html#replication-solutions-partitioning" title="17.4.6 異なるレプリカへの異なるデータベースのレプリケート">セクション17.4.6「異なるレプリカへの異なるデータベースのレプリケート」</a>を参照してください 
  </p><p>
    レプリカの数が増えると、ソースの負荷が増加し、パフォーマンスが低下する可能性があります (各レプリカにバイナリログをレプリケートする必要があるため)。 単一のセカンダリサーバーをソースとして使用するなど、レプリケーションパフォーマンスの向上に関するヒントは、<a class="xref" href="replication.html#replication-solutions-performance" title="17.4.7 レプリケーションパフォーマンスを改善する">セクション17.4.7「レプリケーションパフォーマンスを改善する」</a> を参照してください。 
  </p><p>
    緊急フェイルオーバーソリューションの一部としてのソースの切替えまたはレプリカのソースへの変換に関するガイダンスは、<a class="xref" href="replication.html#replication-solutions-switch" title="17.4.8 フェイルオーバー中のソースの切替え">セクション17.4.8「フェイルオーバー中のソースの切替え」</a> を参照してください。
  </p><p>
    レプリケーショントポロジ内のサーバーに固有のセキュリティ対策の詳細は、<a class="xref" href="replication.html#replication-security" title="17.3 レプリケーションのセキュリティ">セクション17.3「レプリケーションのセキュリティ」</a> を参照してください。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-solutions-backups"></a>17.4.1 バックアップ用にレプリケーションを使用する</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-solutions-backups-mysqldump">17.4.1.1 mysqldump を使用したレプリカのバックアップ</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-backups-rawdata">17.4.1.2 レプリカからの RAW データのバックアップ</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-backups-read-only">17.4.1.3 ソースまたはレプリカを読取り専用にすることによるバックアップ</a></span></dt></dl></div><p>
      レプリケーションをバックアップソリューションとして使用するには、ソースからレプリカにデータをレプリケートしてから、レプリカをバックアップします。 レプリカは、ソースの実行操作に影響を与えずに一時停止および停止できるため、ソースの停止を必要とする<span class="quote">「<span class="quote">「ライブ」</span>」</span>データの有効なスナップショットを生成できます。 
    </p><p>
      データベースのバックアップ方法は、データベースのサイズと、障害発生時にレプリカを再構築できるようにデータのみをバックアップするか、データとレプリカの状態をバックアップするかによって異なります。 つまり、2 つの選択肢があります。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ソース上のデータのバックアップを可能にするソリューションとしてレプリケーションを使用しており、データベースのサイズが大きすぎない場合は、<span class="command"><strong>mysqldump</strong></span> ツールが適している可能性があります。 <a class="xref" href="replication.html#replication-solutions-backups-mysqldump" title="17.4.1.1 mysqldump を使用したレプリカのバックアップ">セクション17.4.1.1「mysqldump を使用したレプリカのバックアップ」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          より大きなデータベースの場合は、<span class="command"><strong>mysqldump</strong></span> は実用的または効率的でなく、代わりにローデータファイルをバックアップできます。 RAW データファイルオプションを使用すると、レプリカに障害が発生した場合にレプリカを再作成できるバイナリログおよびリレーログをバックアップすることもできます。 詳細については、<a class="xref" href="replication.html#replication-solutions-backups-rawdata" title="17.4.1.2 レプリカからの RAW データのバックアップ">セクション17.4.1.2「レプリカからの RAW データのバックアップ」</a>を参照してください。 
        </p></li></ul></div><p>
      ソースサーバーまたはレプリカサーバーに使用できる別のバックアップ計画は、サーバーを読取り専用状態にすることです。 バックアップは読み取り専用サーバーに対して実行され、これが通常の読み取り/書き込み操作ステータスに戻されます。 <a class="xref" href="replication.html#replication-solutions-backups-read-only" title="17.4.1.3 ソースまたはレプリカを読取り専用にすることによるバックアップ">セクション17.4.1.3「ソースまたはレプリカを読取り専用にすることによるバックアップ」</a>を参照してください。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-solutions-backups-mysqldump"></a>17.4.1.1 mysqldump を使用したレプリカのバックアップ</h4></div></div></div><p>
        <span class="command"><strong>mysqldump</strong></span> を使用してデータベースのコピーを作成することで、MySQL Server の別のインスタンスに情報をインポートできる形式でデータベース内のすべてのデータを取得できます (<a class="xref" href="programs.html#mysqldump" title="4.5.4 mysqldump — データベースバックアッププログラム">セクション4.5.4「mysqldump — データベースバックアッププログラム」</a>を参照してください)。 情報の形式が SQL ステートメントであるため、緊急時にデータにアクセスする必要がある場合にファイルを実行中サーバーに配布して適用することも簡単にできます。 ただし、データセットのサイズが非常に大きい場合は、<span class="command"><strong>mysqldump</strong></span> が実用的でない場合があります。 
      </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">ヒント</div><p>
          複数のスレッド、ファイル圧縮、進捗情報の表示、および Oracle Cloud Infrastructure Object Storage ストリーミングや MySQL データベースサービス 互換性チェックおよび変更などのクラウド機能で並列ダンプを提供する <a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-shell-utilities-dump-instance-schema.html" target="_top">MySQL Shell dump utilities</a> の使用を検討してください。 ダンプは、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-shell-utilities-load-dump.html" target="_top">MySQL Shell load dump utilities</a> を使用して MySQL Server インスタンスまたは MySQL データベースサービス DB システムに簡単にインポートできます。 MySQL Shell のインストール手順は、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-shell-install.html" target="_top">here</a> にあります。 
        </p></div><p>
        <span class="command"><strong>mysqldump</strong></span> を使用する場合は、ダンププロセスを開始する前にレプリカのレプリケーションを停止して、ダンプに一貫性のあるデータセットが含まれていることを確認する必要があります:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            レプリカによるリクエストの処理を停止します。 <span class="command"><strong>mysqladmin</strong></span> を使用して、レプリカ上のレプリケーションを完全に停止できます: 
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqladmin stop-slave</code></strong></pre><p>
            または、レプリケーション SQL スレッドのみを停止してイベントの実行を一時停止することもできます:
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysql -e 'STOP SLAVE SQL_THREAD;'</code></strong>
Or from MySQL 8.0.22:
shell&gt; <strong class="userinput"><code>mysql -e 'STOP REPLICA SQL_THREAD;'</code></strong>
</pre><p>
            これにより、レプリカは引き続きソースバイナリログからデータ変更イベントを受信し、レプリケーション I/O スレッドを使用してリレーログに格納できますが、レプリカはこれらのイベントを実行してデータを変更できなくなります。 ビジーなレプリケーション環境では、レプリケーション SQL スレッドを再起動するときに、バックアップ中にレプリケーション I/O スレッドの実行を許可するとキャッチアッププロセスが高速化される場合があります。 
          </p></li><li class="listitem"><p>
            <span class="command"><strong>mysqldump</strong></span> を実行してデータベースをダンプします。 すべてのデータベースをダンプしたり、ダンプするデータベースを選択したりできます。 たとえば、すべてのデータベースをダンプするには:  
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqldump --all-databases &gt; fulldb.dump</code></strong></pre></li><li class="listitem"><p>
            ダンプが完了したら、レプリケーションを再度開始します:
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqladmin start-slave</code></strong></pre></li></ol></div><p>
        前の例では、ログイン資格証明 (ユーザー名、パスワード) をコマンドに追加したり、毎日自動的に実行できるプロセスをスクリプトにバンドルしたりすることをお勧めします。
      </p><p>
        このアプローチを使用する場合は、必ずレプリケーションプロセスを監視して、バックアップの実行に要した時間が、ソースからのイベントを継続するレプリカ機能に影響しないようにしてください。 <a class="xref" href="replication.html#replication-administration-status" title="17.1.7.1 レプリケーションステータスの確認">セクション17.1.7.1「レプリケーションステータスの確認」</a>を参照してください。 レプリカを維持できない場合は、別のレプリカを追加してバックアッププロセスを分散できます。 このシナリオの構成方法の例は、<a class="xref" href="replication.html#replication-solutions-partitioning" title="17.4.6 異なるレプリカへの異なるデータベースのレプリケート">セクション17.4.6「異なるレプリカへの異なるデータベースのレプリケート」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-solutions-backups-rawdata"></a>17.4.1.2 レプリカからの RAW データのバックアップ</h4></div></div></div><p>
        コピーされるファイルの整合性を保証するには、レプリカサーバーの停止中に MySQL レプリカ上の RAW データファイルのバックアップを実行する必要があります。 MySQL サーバーがまだ実行中の場合は、バックグラウンドタスクがデータベースファイルをまだ更新中の可能性があります (特に、<code class="literal">InnoDB</code> などのストレージエンジンをバックグラウンドプロセスで使用するもの)。 <code class="literal">InnoDB</code> では、クラッシュリカバリ中にこれらの問題を解決する必要がありますが、この機能を利用すると、ソースの実行に影響を与えることなく、バックアッププロセス中にレプリカサーバーを停止できるためです。 
      </p><p>
        サーバーをシャットダウンしてファイルをバックアップするには：
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            レプリカ MySQL サーバーを停止します:
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqladmin shutdown</code></strong></pre></li><li class="listitem"><p>
            データファイルをコピーします。 <span class="command"><strong>cp</strong></span>、<span class="command"><strong>tar</strong></span>、<span class="command"><strong>WinZip</strong></span> など、コピーまたはアーカイブに適したユーティリティーを使用できます。 たとえば、データディレクトリが現在のディレクトリの下にある場合、ディレクトリ全体を次のようにアーカイブできます。 
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>tar cf /tmp/dbbackup.tar ./data</code></strong></pre></li><li class="listitem"><p>
            MySQL サーバーを再起動します。 Unix の場合: 
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqld_safe &amp;</code></strong></pre><p>
            Windows の場合:
          </p><pre class="programlisting">C:\&gt; <strong class="userinput"><code>"C:\Program Files\MySQL\MySQL Server 8.0\bin\mysqld"</code></strong></pre></li></ol></div><p>
        通常、レプリカ MySQL サーバーのデータディレクトリ全体をバックアップする必要があります。 データをリストアしてレプリカとして操作できるようにするには (レプリカに障害が発生した場合など)、データに加えて、レプリカ接続メタデータリポジトリと適用者メタデータリポジトリ、およびリレーログファイルが必要です。 これらのアイテムは、レプリカデータのリストア後にレプリケーションを再開するために必要です。 MySQL 8.0 のデフォルトであるレプリカ接続メタデータリポジトリおよび適用機能メタデータリポジトリ (<a class="xref" href="replication.html#replica-logs" title="17.2.4 リレーログおよびレプリケーションメタデータリポジトリ">セクション17.2.4「リレーログおよびレプリケーションメタデータリポジトリ」</a> を参照) にテーブルが使用されている場合、これらのテーブルはデータディレクトリとともにバックアップされます。 非推奨のリポジトリにファイルが使用されている場合は、それらを個別にバックアップする必要があります。 リレーログファイルがデータディレクトリとは異なる場所に配置されている場合は、個別にバックアップする必要があります。 
      </p><p>
        リレーログを失っても <code class="filename">relay-log.info</code> ファイルが残っている場合は、それをチェックして、レプリケーション SQL スレッドがソースバイナリログで実行された距離を判断できます。 その後、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23 から) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 より前) を <code class="literal">SOURCE_LOG_FILE</code> | <code class="literal">MASTER_LOG_FILE</code> および <code class="literal">SOURCE_LOG_POS</code> | <code class="literal">MASTER_LOG_POS</code> オプションとともに使用して、バイナリログを再度読み取り、そのレプリカに記録することができます。 これには、バイナリログがソースサーバーにまだ存在している必要があります。 
      </p><p>
        レプリカが <code class="literal">LOAD DATA</code> ステートメントをレプリケートしている場合は、レプリカがこの目的で使用するディレクトリに存在する <code class="filename">SQL_LOAD-*</code> ファイルもバックアップする必要があります。 レプリカでは、中断された <code class="literal">LOAD DATA</code> 操作のレプリケーションを再開するために、これらのファイルが必要です。 このディレクトリの場所は、<code class="literal">slave_load_tmpdir</code> システム変数の値です。 その変数を設定してサーバーを起動しなかった場合、ディレクトリの場所は <code class="literal">tmpdir</code> システム変数の値になります。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-solutions-backups-read-only"></a>17.4.1.3 ソースまたはレプリカを読取り専用にすることによるバックアップ</h4></div></div></div><p>
        グローバル読取りロックを取得し、<code class="literal">read_only</code> システム変数を操作して、バックアップするサーバーの読取り専用状態を変更することで、レプリケーション設定のソースサーバーまたはレプリカサーバーをバックアップできます:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            サーバーを読み取り専用にします (検索のみが処理され、更新はブロックされます)。
          </p></li><li class="listitem"><p>
            バックアップを実行します。
          </p></li><li class="listitem"><p>
            サーバーを通常の読み取り/書き込み状態に戻します。
          </p></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          このセクションの手順では、バックアップするサーバーを、サーバーからデータを取得するバックアップ方式 (<span class="command"><strong>mysqldump</strong></span> など) に安全な状態に変換しています (<a class="xref" href="programs.html#mysqldump" title="4.5.4 mysqldump — データベースバックアッププログラム">セクション4.5.4「mysqldump — データベースバックアッププログラム」</a>を参照してください)。 バイナリバックアップを作成するために、ファイルを直接コピーする方法でこれらの手順の使用を試みてはいけません (サーバーが変更後データをまだメモリー内にキャッシュしていてディスクにフラッシュしていない可能性があるため)。 
        </p></div><p>
        次の手順では、ソースおよびレプリカに対してこれを実行する方法について説明します。 ここで説明する両方のシナリオでは、次のレプリケーションセットアップを想定します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ソースサーバー S1
          </p></li><li class="listitem"><p>
            ソースとして S1 を持つレプリカサーバー R1
          </p></li><li class="listitem"><p>
            S1 に接続されたクライアント C1
          </p></li><li class="listitem"><p>
            R1 に接続されたクライアント C2
          </p></li></ul></div><p>
        いずれのシナリオでも、グローバル読取りロックを取得して <code class="literal">read_only</code> 変数を操作するステートメントは、バックアップ対象のサーバーで実行され、そのサーバーのレプリカには伝播されません。
      </p><p>
        <span class="bold"><strong>シナリオ 1: 読取り専用ソースを使用したバックアップ</strong></span>
      </p><p>
        次のステートメントを実行して、ソース S1 を読取り専用状態にします:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>FLUSH TABLES WITH READ LOCK;</code></strong>
mysql&gt; <strong class="userinput"><code>SET GLOBAL read_only = ON;</code></strong>
</pre><p>
        S1 が読み取り専用状態のときは、次の属性が true になります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            サーバーが読取り専用モードであるため、C1 によって S1 ブロックに送信される更新のリクエスト。
          </p></li><li class="listitem"><p>
            C1 から S1 に送信されたクエリー結果のリクエストは成功しました。
          </p></li><li class="listitem"><p>
            S1 でのバックアップの作成は安全です。
          </p></li><li class="listitem"><p>
            R1 でバックアップを作成することは安全ではありません。 このサーバーはまだ実行中で、バイナリログを処理中であったり、クライアント C2 から着信する要求を更新したりする可能性があります。 
          </p></li></ul></div><p>
        S1 が読み取り専用のときに、バックアップを実行してください。 たとえば、<span class="command"><strong>mysqldump</strong></span> を使用できます。 
      </p><p>
        S1 でのバックアップ操作が完了したあとに、これらのステートメントを実行することで S1 を通常の動作状態に戻します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL read_only = OFF;</code></strong>
mysql&gt; <strong class="userinput"><code>UNLOCK TABLES;</code></strong>
</pre><p>
        S1 でのバックアップの実行は安全ですが (バックアップに関するかぎり)、S1 のクライアントは更新の実行をブロックされるため、パフォーマンスに最適ではありません。
      </p><p>
        この戦略は、レプリケーション設定でのソースのバックアップに適用されますが、非レプリケーション設定で単一のサーバーに使用することもできます。
      </p><p>
        <span class="bold"><strong>シナリオ 2: 読取り専用レプリカによるバックアップ</strong></span>
      </p><p>
        次のステートメントを実行して、レプリカ R1 を読取り専用状態にします:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>FLUSH TABLES WITH READ LOCK;</code></strong>
mysql&gt; <strong class="userinput"><code>SET GLOBAL read_only = ON;</code></strong>
</pre><p>
        R1 が読取り専用状態の間は、次のプロパティが適用されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ソース S1 は引き続き動作するため、ソースでのバックアップは安全ではありません。
          </p></li><li class="listitem"><p>
            レプリカ R1 は停止しているため、レプリカ R1 上のバックアップは安全です。
          </p></li></ul></div><p>
        これらのプロパティは、一般的なバックアップシナリオの基礎を提供: バックアップの実行中に 1 つのレプリカがビジー状態になっていても、ネットワーク全体には影響せず、バックアップ中もシステムが実行中であるため、問題は発生しません。 特に、クライアントはソースサーバーで更新を実行できますが、レプリカのバックアップアクティビティによる影響は受けません。 
      </p><p>
        R1 は読取り専用ですが、バックアップを実行します。 たとえば、<span class="command"><strong>mysqldump</strong></span> を使用できます。 
      </p><p>
        R1 でのバックアップ操作が完了したら、次のステートメントを実行して、R1 を通常の操作状態にリストアします:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL read_only = OFF;</code></strong>
mysql&gt; <strong class="userinput"><code>UNLOCK TABLES;</code></strong>
</pre><p>
        replca は、通常の操作に復元されたあと、ソースバイナリログからの未処理の更新をキャッチアップすることによって、ソースと再度同期します。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-solutions-unexpected-replica-halt"></a>17.4.2 レプリカの予期しない停止の処理</h3></div></div></div><a class="indexterm" name="idm46723649548464"></a><a class="indexterm" name="idm46723649546944"></a><a class="indexterm" name="idm46723649544864"></a><p>
      サーバーの予期しない停止 (クラッシュセーフとも呼ばれる) に対するレプリケーションを回復できるようにするには、レプリカが停止する前にその状態を回復できる必要があります。 このセクションでは、レプリケーション中のレプリカの予期しない停止の影響、およびレプリケーションを続行するためのリカバリの最善の機会を得るためのレプリカの構成方法について説明します。 
    </p><p>
      レプリカの予期しない停止後、再起動時に、レプリケーション SQL スレッドは、すでに実行されているトランザクションに関する情報をリカバリする必要があります。 リカバリに必要な情報は、レプリカアプライアンスのメタデータリポジトリに格納されます。 MySQL 8.0 から、このリポジトリは <code class="literal">mysql.slave_relay_log_info</code> という名前の <code class="literal">InnoDB</code> テーブルとしてデフォルトで作成されます。 このトランザクションストレージエンジンを使用すると、再起動時に情報が常に回復可能になります。 アプライヤメタデータリポジトリへの更新は、トランザクションとともにコミットされます。つまり、予期しないサーバーが停止した場合でも、そのリポジトリに記録されるレプリカ進捗情報は、常にデータベースに適用されているものと一貫性があります。 適用者メタデータリポジトリの詳細は、<a class="xref" href="replication.html#replica-logs" title="17.2.4 リレーログおよびレプリケーションメタデータリポジトリ">セクション17.2.4「リレーログおよびレプリケーションメタデータリポジトリ」</a> を参照してください。 
    </p><p>
      DML トランザクションおよびアトミック DDL は、アトミック操作としてのデータベースへの変更の適用とともに、<code class="literal">mysql.slave_relay_log_info</code> テーブルのレプリカアプリケーションメタデータリポジトリ内のレプリケーション位置を更新します。 完全にアトミックではない DDL ステートメントや、アトミック DDL をサポートしない除外されたストレージエンジンなど、ほかのすべての場合、サーバーが予期せず停止した場合、レプリケートされたデータに関連付けられた更新が <code class="literal">mysql.slave_relay_log_info</code> テーブルに失われる可能性があります。 この場合、更新のリストアは手動プロセスです。 MySQL 8.0 でのアトミック DDL のサポートおよび特定のステートメントのレプリケーションの結果の動作の詳細は、<a class="xref" href="sql-statements.html#atomic-ddl" title="13.1.1 アトミックデータ定義ステートメントのサポート">セクション13.1.1「アトミックデータ定義ステートメントのサポート」</a> を参照してください。 
    </p><p>
      予期しない停止からレプリカをリカバリするリカバリプロセスは、レプリカの構成によって異なります。 リカバリプロセスの詳細は、レプリケーションの選択した方法、レプリカがシングルスレッドかマルチスレッドか、および関連するシステム変数の設定の影響を受けます。 リカバリプロセスの全体的な目的は、予期しない停止が発生する前にレプリカデータベースにすでに適用されているトランザクションを識別し、予期しない停止の後にレプリカが見逃したトランザクションを取得して適用することです。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          GTID ベースのレプリケーションの場合、回復プロセスには、レプリカによってすでに受信またはコミットされたトランザクションの GTID が必要です。 GTID 自動配置を使用すると、欠落しているトランザクションをソースから取得できます。GTID 自動配置では、ソーストランザクションがレプリカトランザクションと自動的に比較され、欠落しているトランザクションが識別されます。 
        </p></li><li class="listitem"><p>
          ファイル位置ベースのレプリケーションの場合、リカバリプロセスには、レプリカに適用された最後のトランザクションを示す正確なレプリケーション SQL スレッド (適用者) 位置が必要です。 その位置に基づいて、レプリケーション I/O スレッド (レシーバ) は、その時点からレプリカに適用する必要があるすべてのトランザクションをソースバイナリログから取得します。 
        </p></li></ul></div><p>
      GTID ベースのレプリケーションを使用すると、予期しない停止に対して回復可能になるようにレプリケーションを構成することがもっとも簡単になります。 GTID 自動配置とは、適用されたトランザクションのシーケンスにギャップがある場合でも、レプリカが欠落しているトランザクションを確実に識別して取得できることを意味します。 
    </p><p>
      次の情報は、レプリケーションの制御下にあるかぎりリカバリを保証するために、様々なタイプのレプリカに適した設定の組合せを提供します。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        レプリケーションの制御外の一部の要因は、レプリケーションリカバリプロセスおよびリカバリプロセス後のレプリケーションの全体的な状態に影響を与える可能性があります。 特に、個々のストレージエンジンの回復プロセスに影響する設定では、レプリカが予期せず停止したためにトランザクションが失われ、レプリケーションリカバリプロセスで使用できなくなる可能性があります。 次のリストに示す <code class="literal">innodb_flush_log_at_trx_commit=1</code> 設定は、トランザクションで <code class="literal">InnoDB</code> を使用するレプリケーション設定の主要な設定です。 ただし、<code class="literal">InnoDB</code> またはほかのストレージエンジン (特にフラッシュまたは同期に関連するもの) に固有のほかの設定も影響を与える可能性があります。 選択したストレージエンジンによって作成されたクラッシュセーフ設定に関する推奨事項を常にチェックして適用します。 
      </p></div><p>
      レプリカの次の設定の組合せは、予期しない停止に対する最も回復力があります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          GTID ベースのレプリケーションが使用されている場合 (<code class="literal">gtid_mode=ON</code>)、<code class="literal">SOURCE_AUTO_POSITION=1</code> | <code class="literal">MASTER_AUTO_POSITION=1</code> を設定します。これにより、ソースへの接続の GTID 自動配置がアクティブ化され、欠落しているトランザクションが自動的に識別および取得されます。 このオプションは、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23 の場合) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 の場合) を使用して設定します。 レプリカに複数のレプリケーションチャネルがある場合は、チャネルごとにこのオプションを個別に設定する必要があります。 GTID 自動配置の動作の詳細は、<a class="xref" href="replication.html#replication-gtids-auto-positioning" title="17.1.3.3 GTID 自動配置">セクション17.1.3.3「GTID 自動配置」</a> を参照してください。 ファイル位置ベースのレプリケーションが使用されている場合、<code class="literal">SOURCE_AUTO_POSITION=1</code> | <code class="literal">MASTER_AUTO_POSITION=1</code> は使用されず、代わりにバイナリログ位置またはリレーログポジションを使用してレプリケーションの開始位置が制御されます。 
        </p></li><li class="listitem"><p>
          受信した各トランザクションがディスクに書き込まれた後、リレーログをディスクに同期するようにレプリケーション I/O スレッドに指示する <code class="literal">sync_relay_log=1</code> を設定します。 つまり、ソースバイナリログ (アプライヤメタデータリポジトリ内) から読み取られた現在の位置のレプリカレコードが、リレーログに保存されたトランザクションのレコードより前になることはありません。 この設定は最も安全ですが、関連するディスク書込みの数が原因で最も遅くなることにも注意してください。 <code class="literal">sync_relay_log &gt; 1</code> または <code class="literal">sync_relay_log=0</code> (同期がオペレーティングシステムによって処理される) では、レプリカが予期せず停止した場合、コミットされたトランザクションがディスクに同期されていない可能性があります。 このようなトランザクションでは、リカバリしているレプリカがディスクに最後に同期されたときのリレーログ内の情報に基づいて、トランザクションをスキップするのではなく、トランザクションの取得および適用を再試行する場合に、リカバリプロセスが失敗する可能性があります。 <code class="literal">sync_relay_log=1</code> の設定は、マルチスレッドレプリカで特に重要です。マルチスレッドレプリカでは、リレーログの情報を使用して一連のトランザクションのギャップを埋めることができない場合、リカバリプロセスは失敗します。 シングルスレッドレプリカの場合、リカバリプロセスでリレーログを使用する必要があるのは、関連情報がアプライヤメタデータリポジトリで使用できない場合のみです。 
        </p></li><li class="listitem"><p>
          各トランザクションがコミットされる前に <code class="literal">InnoDB</code> ログをディスクに同期する <code class="literal">innodb_flush_log_at_trx_commit=1</code> を設定します。 この設定 (デフォルト) により、<code class="literal">InnoDB</code> テーブルおよび <code class="literal">InnoDB</code> ログがディスクに保存されるため、トランザクションに関する情報がリレーログに不要になります。 この設定を <code class="literal">sync_relay_log=1</code> の設定と組み合わせると、<code class="literal">InnoDB</code> テーブルと <code class="literal">InnoDB</code> ログの内容が常にリレーログの内容と一致するようになるため、予期しない停止が発生した場合にリレーログファイルをパージしてもトランザクションのレプリカ履歴に問題のないギャップが生じることはありません。 
        </p></li><li class="listitem"><p>
          レプリケーション SQL スレッドの位置を <code class="literal">InnoDB</code> テーブル <code class="literal">mysql.slave_relay_log_info</code> に格納する <code class="literal">relay_log_info_repository = TABLE</code> を設定し、トランザクションコミットとともに更新して、常に正確なレコードを確保します。 この設定は MySQL 8.0 のデフォルトであり、<code class="literal">FILE</code> 設定は非推奨です。 MySQL 8.0.23 では、システム変数自体の使用は非推奨であるため、省略してデフォルトにできます。 <code class="literal">FILE</code> 設定 (以前のリリースのデフォルト) を使用した場合、情報は、トランザクションの適用後に更新されるデータディレクトリ内のファイルに格納されます。 これにより、レプリカが停止するトランザクションの処理ステージや、ファイル自体の破損に応じて、ソースとの同期が失われるリスクが発生します。 <code class="literal">relay_log_info_repository = FILE</code> の設定では、リカバリは保証されません。 
        </p></li><li class="listitem"><p>
          サーバーの起動直後に自動リレーログリカバリを有効にする <code class="literal">relay_log_recovery = ON</code> を設定します。 このグローバル変数はデフォルトで <code class="literal">OFF</code> に設定され、実行時には読取り専用ですが、レプリカの予期しない停止後、レプリカの起動時に <code class="option">--relay-log-recovery</code> オプションを使用して <code class="literal">ON</code> に設定できます。 この設定では、既存のリレーログファイルが破損または矛盾している場合に無視されることに注意してください。 リレーログリカバリプロセスでは、新しいリレーログファイルが開始され、アプライヤメタデータリポジトリに記録されているレプリケーション SQL スレッド位置からソースからトランザクションがフェッチされます。 以前のリレーログファイルは、レプリカの通常のパージメカニズムによって時間の経過とともに削除されます。 
        </p></li></ul></div><p>
      マルチスレッドレプリカの場合、<code class="literal">relay_log_recovery = ON</code> を設定すると、リレーログから実行された一連のトランザクションの不整合およびギャップが自動的に処理されます。 これらのギャップは、ファイル位置ベースのレプリケーションが使用されている場合に発生することがあります。 (詳細は、<a class="xref" href="replication.html#replication-features-transaction-inconsistencies" title="17.5.1.34 レプリケーションとトランザクションの非一貫性">セクション17.5.1.34「レプリケーションとトランザクションの非一貫性」</a> を参照してください。) リレーログリカバリプロセスは、<code class="literal">START REPLICA | SLAVE UNTIL SQL_AFTER_MTS_GAPS</code> ステートメントと同じ方法を使用してギャップを処理します。 レプリカが一貫性のないギャップのない状態に達すると、リレーログリカバリプロセスが進行し、レプリケーション SQL スレッド位置からソースからさらにトランザクションがフェッチされます。 GTID ベースのレプリケーションが使用されている場合、このプロセスは不要であり、<code class="literal">MASTER_AUTO_POSITION</code> が <code class="literal">ON</code> に設定されている場合、MySQL 8.0.18 からマルチスレッドレプリカはリレーログのリカバリを自動的にスキップするため、<code class="literal">relay_log_recovery</code> の設定に違いはありません。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-solutions-rbr-monitoring"></a>17.4.3 行ベースのレプリケーションの監視</h3></div></div></div><p>
      行ベースレプリケーション使用時のレプリケーションアプライアンス (SQL) スレッドの現在の進行状況は、パフォーマンススキーマインストゥルメントステージを介してモニターされるため、操作の処理を追跡したり、完了した作業量や推定作業量を確認したりできます。 これらのパフォーマンススキーマインストゥルメントステージが有効になっている場合、<code class="literal">events_stages_current</code> テーブルにはアプライヤスレッドのステージとその進行状況が表示されます。 背景情報については、<a class="xref" href="performance-schema.html#performance-schema-stage-tables" title="27.12.5 パフォーマンススキーマステージイベントテーブル">セクション27.12.5「パフォーマンススキーマステージイベントテーブル」</a> を参照してください。 
    </p><p>
      3 つのすべての行ベースのレプリケーションイベントタイプ (書込み、更新、削除) の進行状況を追跡するには:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          次を発行して、3 つのパフォーマンススキーマステージを有効にします:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE performance_schema.setup_instruments SET ENABLED = 'YES'</code></strong>
    -&gt; <strong class="userinput"><code>WHERE NAME LIKE 'stage/sql/Applying batch of row changes%';</code></strong>
</pre></li><li class="listitem"><p>
          一部のイベントがレプリケーションアプライヤスレッドによって処理されるまで待機し、<code class="literal">events_stages_current</code> テーブルを参照して進行状況を確認します。 たとえば、<code class="literal">update</code> イベントの進捗を取得するには、次のようにします: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT WORK_COMPLETED, WORK_ESTIMATED FROM performance_schema.events_stages_current</code></strong>
    -&gt; <strong class="userinput"><code>WHERE EVENT_NAME LIKE 'stage/sql/Applying batch of row changes (update)'</code></strong>
</pre></li><li class="listitem"><p>
          <code class="literal">binlog_rows_query_log_events</code> が有効な場合、クエリーに関する情報はバイナリログに格納され、<code class="literal">processlist_info</code> フィールドに表示されます。 このイベントをトリガーした元のクエリーを表示するには: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT db, processlist_state, processlist_info FROM performance_schema.threads</code></strong>
    -&gt; <strong class="userinput"><code>WHERE processlist_state LIKE 'stage/sql/Applying batch of row changes%' AND thread_id = N;</code></strong>
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-solutions-diffengines"></a>17.4.4 異なるソースおよびレプリカのストレージエンジンでのレプリケーションの使用</h3></div></div></div><p>
      レプリケーションプロセスでは、ソース上の元のテーブルとレプリカ上のレプリケートされたテーブルが異なるストレージエンジンタイプを使用するかどうかは関係ありません。 実際、<code class="literal">default_storage_engine</code> システム変数はレプリケートされません。 
    </p><p>
      これは、異なるレプリケーションシナリオに異なるエンジンタイプを利用できるという点で、レプリケーションプロセスにいくつかの利点を提供します。 たとえば、典型的なスケールアウトシナリオ (<a class="xref" href="replication.html#replication-solutions-scaleout" title="17.4.5 スケールアウトのためにレプリケーションを使用する">セクション17.4.5「スケールアウトのためにレプリケーションを使用する」</a> を参照) では、トランザクション機能を利用するためにソースで <code class="literal">InnoDB</code> テーブルを使用しますが、データの読取りのみであるためトランザクションサポートが不要なレプリカでは <code class="literal">MyISAM</code> を使用します。 データロギング環境でレプリケーションを使用する場合は、レプリカで <code class="literal">Archive</code> ストレージエンジンを使用できます。 
    </p><p>
      ソースとレプリカで異なるエンジンを構成するかどうかは、初期レプリケーションプロセスの設定方法によって異なります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <span class="command"><strong>mysqldump</strong></span> を使用してソースにデータベーススナップショットを作成した場合は、ダンプファイルのテキストを編集して、各テーブルで使用されるエンジンタイプを変更できます。
        </p><p>
          <span class="command"><strong>mysqldump</strong></span> の別の方法は、ダンプを使用してレプリカにデータを構築する前に、レプリカで使用しないエンジンタイプを無効にすることです。 たとえば、レプリカに <code class="option">--skip-federated</code> オプションを追加して、<code class="literal">FEDERATED</code> エンジンを無効にできます。 作成するテーブルに特定のエンジンが存在しない場合、MySQL はデフォルトのエンジンタイプ (通常は <code class="literal">InnoDB</code>) を使用します。 (これには、<code class="literal">NO_ENGINE_SUBSTITUTION</code> SQL モードが有効でないことが必要です。) この方法で追加のエンジンを無効にする場合は、必要なエンジンのみをサポートするレプリカで使用する特別なバイナリを構築することを検討してください。 
        </p></li><li class="listitem"><p>
          RAW データファイル (バイナリバックアップ) を使用してレプリカを設定する場合、初期テーブル形式を変更することはできません。 かわりに、レプリカの起動後に <code class="literal">ALTER TABLE</code> を使用してテーブルタイプを変更します。 
        </p></li><li class="listitem"><p>
          現在ソースにテーブルがない新しいソース/レプリカレプリケーション設定の場合は、新しいテーブルの作成時にエンジンタイプを指定しないでください。
        </p></li></ul></div><p>
      レプリケーションソリューションをすでに実行していて、既存のテーブルを別のエンジンタイプに変更する場合は、これらの手順に従ってください。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          レプリカによるレプリケーション更新の実行を停止します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>STOP SLAVE;</code></strong>
Or from MySQL 8.0.22:
mysql&gt; <strong class="userinput"><code>STOP REPLICA;</code></strong>
</pre><p>
          これにより、中断せずにエンジンタイプを変更できます。
        </p></li><li class="listitem"><p>
          変更するテーブルごとに <code class="literal">ALTER TABLE ... ENGINE='<em class="replaceable"><code>engine_type</code></em>'</code> を実行します。
        </p></li><li class="listitem"><p>
          レプリケーションプロセスを再度開始します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>START SLAVE;</code></strong>
</pre><p>
          または、MySQL 8.0.22 以降では次のようになります:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>START REPLICA;</code></strong>
</pre></li></ol></div><p>
      <code class="literal">default_storage_engine</code> 変数はレプリケートされませんが、エンジン仕様を含む <code class="literal">CREATE TABLE</code> および <code class="literal">ALTER TABLE</code> ステートメントはレプリカに正しくレプリケートされることに注意してください。 <code class="literal">CSV</code> テーブルの場合は、次のステートメントを実行します: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE csvtable ENGINE='MyISAM';</code></strong>
</pre><p>
      このステートメントはレプリケートされます。レプリカのテーブルエンジンタイプを以前に <code class="literal">CSV</code> 以外のエンジンに変更した場合でも、レプリカのテーブルエンジンタイプは <code class="literal">InnoDB</code> に変換されます。 ソースとレプリカでエンジンの差異を保持する場合は、新しいテーブルの作成時にソースで <code class="literal">default_storage_engine</code> 変数を使用するように注意する必要があります。 たとえば、次の代わりに:  
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE tablea (columna int) Engine=MyISAM;</code></strong>
</pre><p>
      この形式を使用してください。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET default_storage_engine=MyISAM;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE tablea (columna int);</code></strong>
</pre><p>
      レプリケートされると、<code class="literal">default_storage_engine</code> 変数は無視され、レプリカのデフォルトエンジンを使用してレプリカで <code class="literal">CREATE TABLE</code> ステートメントが実行されます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-solutions-scaleout"></a>17.4.5 スケールアウトのためにレプリケーションを使用する</h3></div></div></div><p>
      レプリケーションをスケールアウトソリューションとして、つまり、いくつかの合理的な制限内でデータベースクエリーの負荷を複数のデータベースサーバーに分割するために使用できます
    </p><p>
      レプリケーションは 1 つのソースから 1 つ以上のレプリカに分散するため、スケールアウトにレプリケーションを使用するのは、読取り数が多く、書込み/更新数が少ない環境で最適です。 ほとんどの web サイトは、ユーザーが Web サイトを参照したり、記事を読んだり、投稿したり、製品を表示したりするこのカテゴリに該当します。 更新は、セッション管理中、購入するとき、またはフォーラムにコメント/メッセージを追加するときにのみ発生します。 
    </p><p>
      この状況でのレプリケーションでは、書込みが必要なときに web サーバーがソースと通信できるようにしながら、レプリカに読取りを分散できます。 このシナリオのためのサンプルレプリケーションレイアウトは、<a class="xref" href="replication.html#figure_replication-scaleout" title="図 17.1 スケールアウト中のパフォーマンスを向上するためにレプリケーションを使用する">図17.1「スケールアウト中のパフォーマンスを向上するためにレプリケーションを使用する」</a>で見ることができます。 
    </p><div class="figure"><a name="figure_replication-scaleout"></a><p class="title"><b>図 17.1 スケールアウト中のパフォーマンスを向上するためにレプリケーションを使用する</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/scaleout.png" width="725" height="900" alt="クライアントからの受信リクエストは、多数の web クライアント間でクライアントデータを分散するロードバランサに送られます。 web クライアントによる書込みは単一の MySQL ソースサーバーに送信され、Web クライアントによる読取りは 3 つの MySQL レプリカサーバーのいずれかに送信されます。 レプリケーションは、MySQL ソースサーバーから 3 つの MySQL レプリカサーバーに実行されます。"></div></div></div><br class="figure-break"><p>
      データベースにアクセスするコードの一部が適切に抽象化/モジュール化されている場合は、それを複製されたセットアップで動作するように変換することはとても効率的かつ簡単であるはずです。 すべての書込みをソースに送信し、読取りをソースまたはレプリカに送信するように、データベースアクセスの実装を変更します。 コードがこのレベルの抽象を備えていない場合、複製されたシステムのセットアップは整理するための機会および動機となります。 まずは、次の関数を実装するラッパーライブラリまたはモジュールを作成してください。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">safe_writer_connect()</code>
        </p></li><li class="listitem"><p>
          <code class="literal">safe_reader_connect()</code>
        </p></li><li class="listitem"><p>
          <code class="literal">safe_reader_statement()</code>
        </p></li><li class="listitem"><p>
          <code class="literal">safe_writer_statement()</code>
        </p></li></ul></div><p>
      各関数名の <code class="literal">safe_</code> は、その関数がすべてのエラー条件の処理を引き受けることを意味します。 関数に別の名前を使用できます。 重要なことは、読み取りのための接続、書き込みのための接続、読み取りの実行、および書き込みの実行に対して、統一されたインタフェースを持つことです。 
    </p><p>
      次に、ラッパーライブラリを使用するようにクライアントコードを変換してください。 これは、最初は苦しくて怖い工程かもしれませんが、長い目でみるとやるだけの価値があります。 ここで説明したアプローチを使用するすべてのアプリケーションは、複数のレプリカを含むアプリケーションであっても、ソース/レプリカ構成を利用できます。 こうしたコードは非常に保守しやすく、トラブルシューティングオプションを追加するのも手間がかかりません。 変更する必要があるのは、1 つまたは 2 つの関数のみです (たとえば、各ステートメントの所要時間、または発行されたステートメントのうちエラーが発生したステートメントをログに記録する場合)。 
    </p><p>
      多数のコードを記述した場合は、変換スクリプトを記述して変換タスクを自動化できます。 理想的には、コードが一貫性のあるプログラミングスタイル規則を使用するべきです。 そうでない場合は、一貫性のあるスタイルを使用するために、とにかく書き換えたり、少なくとも詳しく調べて手動で整理したりすることをお勧めします。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-solutions-partitioning"></a>17.4.6 異なるレプリカへの異なるデータベースのレプリケート</h3></div></div></div><p>
      単一のソースサーバーがあり、異なるデータベースを異なるレプリカにレプリケートする必要がある場合があります。 たとえば、データ分析時の負荷を分散するために、異なる売上データを異なる部門に分散したい場合です。 このレイアウトの例を<a class="xref" href="replication.html#figure_replication-multi-db" title="図 17.2 個別のレプリカへのデータベースのレプリケート">図17.2「個別のレプリカへのデータベースのレプリケート」</a>に示します。 
    </p><div class="figure"><a name="figure_replication-multi-db"></a><p class="title"><b>図 17.2 個別のレプリカへのデータベースのレプリケート</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/multi-db.png" width="725" height="375" alt="MySQL ソースには、databaseA、databaseB および databaseC の 3 つのデータベースがあります。databaseA は MySQL レプリカ 1 にのみレプリケートされ、databaseB は MySQL レプリカ 2 にのみレプリケートされ、databaseC は MySQL レプリカ 3 にのみレプリケートされます。"></div></div></div><br class="figure-break"><p>
      この分離を実現するには、ソースとレプリカを通常どおりに構成し、各レプリカで <code class="option">--replicate-wild-do-table</code> 構成オプションを使用して、各レプリカが処理するバイナリログステートメントを制限します。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        ステートメントベースレプリケーションを使用する場合は、<code class="option">--replicate-do-db</code> をこの目的に使用しないでください。ステートメントベースレプリケーションを使用すると、このオプションの影響は現在選択されているデータベースによって異なります。 このことは、混合形式のレプリケーションにも当てはまります。一部の更新をステートメントベース形式を使用して複製できるためです。 
      </p><p>
        しかし、行ベースレプリケーションだけを使用している場合には、この目的のために <code class="option">--replicate-do-db</code> を使用しても安全なはずです。この場合には、現在選択されているデータベースがオプションの動作に影響しないためです。
      </p></div><p>
      たとえば、<a class="xref" href="replication.html#figure_replication-multi-db" title="図 17.2 個別のレプリカへのデータベースのレプリケート">図17.2「個別のレプリカへのデータベースのレプリケート」</a> に示されている分離をサポートするには、<code class="literal">START REPLICA | SLAVE</code> を実行する前に、各レプリカを次のように構成する必要があります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          レプリカ 1 では <code class="option">--replicate-wild-do-table=databaseA.%</code> を使用する必要があります。
        </p></li><li class="listitem"><p>
          レプリカ 2 では <code class="option">--replicate-wild-do-table=databaseB.%</code> を使用する必要があります。
        </p></li><li class="listitem"><p>
          レプリカ 3 では <code class="option">--replicate-wild-do-table=databaseC.%</code> を使用する必要があります。
        </p></li></ul></div><p>
      この構成内の各レプリカは、ソースからバイナリログ全体を受け取りますが、そのレプリカで有効な <code class="option">--replicate-wild-do-table</code> オプションに含まれるデータベースとテーブルに適用されるバイナリログからのイベントのみを実行します。
    </p><p>
      レプリケーションを開始する前にレプリカに同期する必要があるデータがある場合は、次のようないくつかの選択肢があります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          すべてのデータを各レプリカに同期し、保持しないデータベースまたはテーブル、あるいはその両方を削除します。
        </p></li><li class="listitem"><p>
          <span class="command"><strong>mysqldump</strong></span> を使用して、データベースごとに個別のダンプファイルを作成し、各レプリカに適切なダンプファイルをロードします。
        </p></li><li class="listitem"><p>
          RAW データファイルダンプを使用し、各レプリカに必要な特定のファイルおよびデータベースのみを含めます。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            これは、<code class="literal">innodb_file_per_table</code> を使用しないかぎり、<code class="literal">InnoDB</code> データベースでは機能しません。
          </p></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-solutions-performance"></a>17.4.7 レプリケーションパフォーマンスを改善する</h3></div></div></div><p>
      ソースに接続するレプリカの数が増えるにつれて、各レプリカがソースへのクライアント接続を使用するため、負荷も最小限に抑えられます。 また、各レプリカはソースバイナリログの完全なコピーを受信する必要があるため、ソースのネットワーク負荷も増加し、ボトルネックが発生する可能性があります。 
    </p><p>
      あるソースに接続されている多数のレプリカを使用しており、そのソースがリクエストの処理にもビジー状態である場合 (たとえば、スケールアウトソリューションの一部として)、レプリケーションプロセスのパフォーマンスを向上させることが必要な場合があります。
    </p><p>
      レプリケーションプロセスのパフォーマンスを向上させる方法の 1 つは、ソースを 1 つのレプリカにのみレプリケートし、残りのレプリカが個々のレプリケーション要件のためにこのプライマリレプリカに接続できるようにする、より深いレプリケーション構造を作成することです。 この構造のサンプルを<a class="xref" href="replication.html#figure_replication-performance" title="図 17.3 追加のレプリケーションソースを使用したパフォーマンスの向上">図17.3「追加のレプリケーションソースを使用したパフォーマンスの向上」</a>に示します。 
    </p><div class="figure"><a name="figure_replication-performance"></a><p class="title"><b>図 17.3 追加のレプリケーションソースを使用したパフォーマンスの向上</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/subsource-performance.png" width="725" height="425" alt="サーバー MySQL ソース 1 はサーバー MySQL ソース 2 にレプリケートされ、サーバー MySQL レプリカ 1、MySQL レプリカ 2 および MySQL レプリカ 3 にレプリケートされます。"></div></div></div><br class="figure-break"><p>
      これが機能するには、MySQL インスタンスを次のように構成する必要があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ソース 1 は、すべての変更および更新がデータベースに書き込まれるプライマリソースです。 バイナリロギングは、両方のソースサーバー (デフォルト) で有効になっています。 
        </p></li><li class="listitem"><p>
          ソース 2 はサーバー Source 1 へのレプリカで、レプリケーション構造内の残りのレプリカにレプリケーション機能を提供します。 ソース 2 は、ソース 1 への接続が許可されている唯一のマシンです。 ソース 2 では、<code class="option">--log-slave-updates</code> オプションが有効 (デフォルト) になっています。 このオプションを使用すると、ソース 1 からのレプリケーション命令もソース 2 のバイナリログに書き込まれるため、それらを実際のレプリカにレプリケートできます。 
        </p></li><li class="listitem"><p>
          レプリカ 1、レプリカ 2 およびレプリカ 3 はレプリカとしてソース 2 に機能し、ソース 2 からの情報をレプリケートします。この情報は、実際にはソース 1 に記録されたアップグレードで構成されます。
        </p></li></ul></div><p>
      前述のソリューションを直接データベースソリューションとして使用すると、プライマリソースでのクライアントの負荷とネットワークインタフェースの負荷が軽減されるため、プライマリソースの全体的なパフォーマンスが向上します。
    </p><p>
      レプリカがソースでのレプリケーションプロセスの維持に問題がある場合は、いくつかのオプションを使用できます:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          可能であれば、リレーログとデータファイルを異なる物理ドライブに置きます。 これを行うには、<code class="literal">relay_log</code> システム変数を設定してリレーログの場所を指定します。 
        </p></li><li class="listitem"><p>
          バイナリログファイルおよびリレーログファイルの読み取りに対するディスク I/O アクティビティーが大きい場合は、<code class="literal">rpl_read_size</code> システム変数の値を増やすことを検討してください。 このシステム変数は、ログファイルから読み取られるデータの最小量を制御し、それを増やすと、ファイルデータがオペレーティングシステムによって現在キャッシュされていない場合にファイルの読取りおよび I/O の停止が減少する可能性があります。 バイナリログおよびリレーログファイルから読み取るスレッドごとに、この値のバッファーが割り当てられます。これには、ソース上のダンプスレッドやレプリカ上のコーディネータスレッドも含まれます。 したがって、大きな値を設定すると、サーバーのメモリー消費に影響する可能性があります。 
        </p></li><li class="listitem"><p>
          レプリカがソースより大幅に低速な場合は、異なるデータベースを異なるレプリカにレプリケートする責任を分けることが必要になる場合があります。 <a class="xref" href="replication.html#replication-solutions-partitioning" title="17.4.6 異なるレプリカへの異なるデータベースのレプリケート">セクション17.4.6「異なるレプリカへの異なるデータベースのレプリケート」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          ソースでトランザクションを使用していて、レプリカでのトランザクションサポートに関心がない場合は、レプリカで <code class="literal">MyISAM</code> または別の非トランザクションエンジンを使用します。 <a class="xref" href="replication.html#replication-solutions-diffengines" title="17.4.4 異なるソースおよびレプリカのストレージエンジンでのレプリケーションの使用">セクション17.4.4「異なるソースおよびレプリカのストレージエンジンでのレプリケーションの使用」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          レプリカがソースとして機能せず、障害発生時にソースを起動できるようにするための潜在的なソリューションがある場合は、レプリカの <code class="literal">log_slave_updates</code> システム変数を無効にできます。 これにより、<span class="quote">「<span class="quote">dumb</span>」</span> レプリカは、実行したイベントを独自のバイナリログに記録することもできなくなります。 
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-solutions-switch"></a>17.4.8 フェイルオーバー中のソースの切替え</h3></div></div></div><p>
      (MySQL 8.0.23 の)<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントまたは <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 の前) を使用して、新しいソースに変更するようレプリカに指示できます。 レプリカは、ソース上のデータベースがレプリカ上のデータベースと互換性があるかどうかをチェックしません。単に、新しいソースバイナリログ内の指定された座標からイベントの読取りおよび実行を開始します。 フェイルオーバーの状況では、グループ内のすべてのサーバーが同じバイナリログファイルから同じイベントを実行するのが一般的であるため、イベントのソースを変更しても、変更を加えるときに注意することで、データベースの構造または完全性に影響を与えないはずです。 
    </p><p>
      レプリカは、バイナリロギングを有効にして実行するようにしてください (<code class="option">--log-bin</code> オプション)。これはデフォルトです。 GTID をレプリケーションに使用しない場合は、レプリカも <code class="option">--log-slave-updates=OFF</code> で実行する必要があります (レプリカ更新のロギングがデフォルトです)。 このように、レプリカはレプリカ <span class="command"><strong>mysqld</strong></span> を再起動せずにソースになる準備ができています。 <a class="xref" href="replication.html#figure_replication-redundancy-before" title="図 17.4 レプリケーションを使用する冗長性、初期構造">図17.4「レプリケーションを使用する冗長性、初期構造」</a>で示す構造を想定してください。 
    </p><div class="figure"><a name="figure_replication-redundancy-before"></a><p class="title"><b>図 17.4 レプリケーションを使用する冗長性、初期構造</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/redundancy-before.png" width="425" height="425" alt="2 つの web クライアントは、データベース読取りとデータベース書込みの両方を単一の MySQL ソースサーバーに送ります。 MySQL ソースサーバーは、MySQL レプリカ 1、MySQL レプリカ 2 および MySQL レプリカ 3 にレプリケートします。"></div></div></div><br class="figure-break"><p>
      この図では、<code class="literal">MySQL Source</code> はソースデータベースを保持し、<code class="literal">MySQL Replica</code> ホストはレプリカであり、<code class="literal">Web Client</code> マシンはデータベースの読取りおよび書込みを発行しています。 読取りのみを発行する (通常はレプリカに接続される) Web クライアントは、障害発生時に新しいサーバーに切り替える必要がないため、表示されません。 読み取り/書き込みスケールアウトレプリケーション構造の詳細例については、<a class="xref" href="replication.html#replication-solutions-scaleout" title="17.4.5 スケールアウトのためにレプリケーションを使用する">セクション17.4.5「スケールアウトのためにレプリケーションを使用する」</a>を参照してください。 
    </p><p>
      各 MySQL レプリカ (<code class="literal">Replica 1</code>、<code class="literal">Replica 2</code> および <code class="literal">Replica 3</code>) は、バイナリロギングを有効にして <code class="option">--log-slave-updates=OFF</code> で実行されるレプリカです。 <code class="option">--log-slave-updates=OFF</code> が指定されている場合、ソースからレプリカによって受信された更新はバイナリログに記録されないため、各レプリカのバイナリログは最初は空になります。 なんらかの理由で <code class="literal">MySQL Source</code> が使用できなくなった場合は、いずれかのレプリカを選択して新しいソースにすることができます。 たとえば、<code class="literal">Replica 1</code> を選択した場合、すべての <code class="literal">Web Clients</code> は <code class="literal">Replica 1</code> にリダイレクトされ、バイナリログに更新が書き込まれます。 その後、<code class="literal">Replica 2</code> および <code class="literal">Replica 3</code> は <code class="literal">Replica 1</code> からレプリケートする必要があります。 
    </p><p>
      <code class="option">--log-slave-updates=OFF</code> でレプリカを実行する理由は、いずれかのレプリカが新しいソースになった場合に、レプリカが更新を 2 回受信しないようにするためです。 <code class="literal">Replica 1</code> で <code class="option">--log-slave-updates</code> が有効になっている場合 (デフォルト)、<code class="literal">Source</code> から受信した更新が独自のバイナリログに書き込まれます。 つまり、<code class="literal">Replica 2</code> が <code class="literal">Source</code> から <code class="literal">Replica 1</code> にソースとして変更されると、<code class="literal">Source</code> からすでに受信した <code class="literal">Replica 1</code> から更新を受信する可能性があります。 
    </p><p>
      すべてのレプリカがリレーログ内のすべてのステートメントを処理したことを確認します。 各レプリカで <code class="literal">STOP REPLICA | SLAVE IO_THREAD</code> を発行し、<code class="literal">Has read all relay log</code> が表示されるまで <code class="literal">SHOW PROCESSLIST</code> の出力を確認します。 これがすべてのレプリカに当てはまる場合は、新しい設定に再構成できます。 ソースになるように昇格されるレプリカ <code class="literal">Replica 1</code> で、<code class="literal">STOP REPLICA | SLAVE</code> および <code class="literal">RESET MASTER</code> を発行します。 
    </p><p>
      他のレプリカ <code class="literal">Replica 2</code> および <code class="literal">Replica 3</code> では、<code class="literal">STOP REPLICA | SLAVE</code> および <code class="literal">CHANGE REPLICATION SOURCE TO SOURCE_HOST='Replica1'</code>または <code class="literal">CHANGE MASTER TO MASTER_HOST='Replica1'</code>を使用します (<code class="literal">'Replica1'</code>は <code class="literal">Replica 1</code> の実際のホスト名を表します)。 <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> を使用するには、<code class="literal">Replica 2</code> または <code class="literal">Replica 3</code> (<em class="replaceable"><code>user</code></em>, <em class="replaceable"><code>password</code></em>, <em class="replaceable"><code>port</code></em>) から <code class="literal">Replica 1</code> に接続する方法に関するすべての情報を追加します。 このシナリオでは、最初のバイナリログファイルと位置 4 がデフォルトであるため、ステートメントを発行するときに、読み取る <code class="literal">Replica 1</code> バイナリログファイルまたはログ位置の名前を指定する必要はありません。 最後に、<code class="literal">Replica 2</code> および <code class="literal">Replica 3</code> で <code class="literal">START REPLICA | SLAVE</code> を実行します。 
    </p><p>
      新しいレプリケーションの設定が完了したら、そのステートメントを <code class="literal">Replica 1</code> に送るように各 <code class="literal">Web Client</code> に指示する必要があります。 この時点から、<code class="literal">Web Client</code> から <code class="literal">Replica 1</code> に送信されたすべての update ステートメントが <code class="literal">Replica 1</code> のバイナリログに書き込まれ、<code class="literal">Source</code> の停止後に <code class="literal">Replica 1</code> に送信されたすべての update ステートメントが含まれます。 
    </p><p>
      結果のサーバー構造を<a class="xref" href="replication.html#figure_replication-redundancy-after" title="図 17.5 ソース障害後のレプリケーションを使用した冗長性">図17.5「ソース障害後のレプリケーションを使用した冗長性」</a>に示します。
    </p><div class="figure"><a name="figure_replication-redundancy-after"></a><p class="title"><b>図 17.5 ソース障害後のレプリケーションを使用した冗長性</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/redundancy-after.png" width="425" height="425" alt="MySQL ソースサーバーに障害が発生し、レプリケーショントポロジに接続されていません。 これで、2 つの web クライアントは、データベース読取りとデータベース書込みの両方を、新しいソースである MySQL レプリカ 1 に送ります。 MySQL レプリカ 1 は、MySQL レプリカ 2 および MySQL レプリカ 3 にレプリケートされます。"></div></div></div><br class="figure-break"><p>
      <code class="literal">Source</code> が再び使用可能になったら、<code class="literal">Replica 1</code> のレプリカにする必要があります。 これを行うには、<code class="literal">Replica 2</code> および <code class="literal">Replica 3</code> で発行されたのと同じ <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントを <code class="literal">Source</code> で発行します。 その後、<code class="literal">Source</code> は <code class="literal">Replica 1</code> のレプリカになり、オフライン中に失われた <code class="literal">Web Client</code> 書込みを取得します。 
    </p><p>
      <code class="literal">Source</code> を再度ソースにするには、<code class="literal">Replica 1</code> を使用できず、<code class="literal">Source</code> を新しいソースにする場合と同様に、前述の手順を使用します。 この手順では、<code class="literal">Source</code> の <code class="literal">Replica 1</code>、<code class="literal">Replica 2</code> および <code class="literal">Replica 3</code> レプリカを作成する前に、必ず <code class="literal">Replica 1</code> で <code class="literal">RESET MASTER</code> を実行してください。 これを実行できない場合、レプリカは、<code class="literal">Source</code> が使用できなくなった時点より前の <code class="literal">Web Client</code> アプリケーションから失効した書込みを取得する可能性があります。 
    </p><p>
      レプリカが同じソースを共有している場合でも、レプリカ間で同期が行われないため、一部のレプリカが他のレプリカよりかなり進んでいる可能性があることに注意してください。 これは場合によっては、前の例で説明した手順が期待どおりに機能しない可能性があることを意味します。 ただし、実際には、すべてのレプリカのリレーログを比較的近いものにする必要があります。 
    </p><p>
      ソースの場所についてアプリケーションに通知する方法の 1 つは、ソースサーバーの動的 DNS エントリを保持することです。 <code class="literal">bind</code> で <code class="filename">nsupdate</code> を使用することで DNS を動的に更新できます。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-asynchronous-connection-failover"></a>17.4.9 非同期接続フェイルオーバーによるソースの切替え</h3></div></div></div><p>
      MySQL 8.0.22 以降では、レプリカからソースへの既存の接続が失敗した後、非同期接続フェイルオーバーメカニズムを使用して、新しいソースへの非同期 (ソースからレプリカ) レプリケーション接続を自動的に確立できます。 非同期接続フェイルオーバーメカニズムを使用すると、データを共有する複数の MySQL サーバーまたはサーバーグループとのレプリカの同期を維持できます。 潜在的なソースサーバーのリストはレプリカに格納され、接続障害が発生すると、設定した重み付け優先度に基づいて新しいソースがリストから選択されます。 
    </p><p>
      MySQL 8.0.23 から、非同期接続フェイルオーバーメカニズムでは、グループメンバーシップに対する変更を自動的に監視し、プライマリサーバーとセカンダリサーバーを区別することで、グループレプリケーショントポロジもサポートされます。 グループメンバーをソースリストに追加し、それを管理対象グループの一部として定義すると、非同期接続フェイルオーバーメカニズムによってソースリストが更新され、メンバーシップの変更にあわせて保持され、グループメンバーの追加または削除が自動的に行われます。 接続およびステータスの取得に使用されるのは、大多数のオンライングループメンバーのみです。 管理対象グループの最後に残っているメンバーは、グループから移動しても自動的に削除されないため、管理対象グループの構成は保持されますが、管理対象グループが不要になった場合は手動で削除できます。 
    </p><p>
      レプリケーションチャネルの非同期接続フェイルオーバーをアクティブ化するには、チャネルの <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 より前) で <code class="literal">SOURCE_CONNECTION_AUTO_FAILOVER=1</code> を設定します。 GTID 自動配置は、チャネルで使用されている必要があります (<code class="literal">SOURCE_AUTO_POSITION = 1</code> | <code class="literal">MASTER_AUTO_POSITION = 1</code>)。 このオプションは、レプリカの実行中に設定できます。 
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        ソースへの既存の接続に失敗した場合、レプリカはまず、<code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントの <code class="literal">SOURCE_RETRY_COUNT</code> | <code class="literal">MASTER_RETRY_COUNT</code> オプションで指定された回数だけ同じ接続を再試行します。 試行間隔は、<code class="literal">SOURCE_CONNECT_RETRY</code> | <code class="literal">MASTER_CONNECT_RETRY</code> オプションによって設定されます。 これらの試行を使い果たすと、非同期接続フェイルオーバーメカニズムが引き継ぎます。 単一ソースへの接続用に設計されたこれらのオプションのデフォルトでは、レプリカは 60 日間同じ接続を再試行します。 非同期接続フェイルオーバーメカニズムをすぐにアクティブ化できるようにするには、接続障害の原因が一時的なネットワーク停止である場合に備えて、<code class="literal">SOURCE_RETRY_COUNT</code> | <code class="literal">MASTER_RETRY_COUNT</code> および <code class="literal">SOURCE_CONNECT_RETRY</code> | <code class="literal">MASTER_CONNECT_RETRY</code> を、同じソースでの再試行を数回のみ許可する最小数に設定します。 適切な値は、<code class="literal">SOURCE_RETRY_COUNT=3</code> | <code class="literal">MASTER_RETRY_COUNT=3</code> と <code class="literal">SOURCE_CONNECT_RETRY=10</code> | <code class="literal">MASTER_CONNECT_RETRY=10</code> です。これにより、レプリカは 10 秒間隔で接続を 3 回再試行します。 
      </p></div><p>
      また、レプリケーションチャネルのレプリカにソースリストを設定します。 <code class="literal">asynchronous_connection_failover_add_source</code> および <code class="literal">asynchronous_connection_failover_delete_source</code> UDF を使用してソースリストを設定および管理し、単一のレプリケーションサーバーを追加および削除します。 サーバーの管理対象グループを追加および削除するには、かわりに <code class="literal">asynchronous_connection_failover_add_managed</code> および <code class="literal">asynchronous_connection_failover_delete_managed</code> UDF を使用します。 
    </p><p>
      UDF は、関連するレプリケーションチャネルに名前を付け、チャネルソースリストに対して追加または削除する MySQL インスタンスのホスト名、ポート番号、ネットワークネームスペースおよび重み付け優先度 (1-100、100 が最高の優先度) を指定します。 管理対象グループの場合は、管理対象サービスのタイプ (現在使用可能なのは Group Replication のみ) および管理対象グループの識別子 (Group Replication の場合は <code class="literal">group_replication_group_name</code> システム変数の値) も指定します。 管理対象グループを追加する場合、追加する必要があるのは 1 つのグループメンバーのみで、レプリカは現在のグループメンバーシップから残りを自動的に追加します。 管理対象グループを削除すると、グループ全体がまとめて削除されます。 
    </p><p>
      MySQL 8.0.22 では、ソースへのレプリカ接続の失敗後に非同期接続フェイルオーバーメカニズムがアクティブ化され、<code class="literal">START REPLICA | SLAVE</code> ステートメントが発行されて新しいソースへの接続が試行されます。 このリリースでは、ソースの停止またはネットワーク障害が原因でレプリケーション I/O スレッドが停止した場合、接続はフェイルオーバーします。 レプリケーションスレッドが <code class="literal">STOP REPLICA | SLAVE</code> ステートメントによって停止された場合など、他の状況では接続はフェイルオーバーされません。 
    </p><p>
      MySQL 8.0.23 では、ソースリストで使用可能な別のサーバーの優先度 (重み) 設定が高い場合、非同期接続フェイルオーバーメカニズムによって接続もフェイルオーバーされます。 この機能により、レプリカは常に最適なソースサーバーに接続されたままになり、管理対象グループと単一 (非管理対象) サーバーの両方に適用されます。 管理対象グループの場合、ソースの重みは、プライマリサーバーとセカンダリサーバーのどちらであるかによって割り当てられます。 したがって、プライマリに高い重みを与え、セカンダリに低い重みを与えるように管理対象グループを設定した場合、プライマリが変更されると、新しいプライマリに高い重みが割り当てられるため、レプリカは接続を介して変更されます。 非同期接続フェイルオーバーメカニズムでは、現在接続している管理対象ソースサーバーが管理対象グループから離れるか、管理対象グループの大部分に存在しなくなった場合にも、接続が変更されます。 
    </p><p>
      接続をフェイルオーバーする場合、チャネルのソースリストにリストされている代替ソースの中で、優先度 (重み) が最も高いソースが最初の接続試行に対して選択されます。


      レプリカは、まずソースサーバーに接続できることを確認します。管理対象グループの場合は、ソースサーバーがグループ内で <code class="literal">ONLINE</code> ステータスになっていることを確認します。 最も重み付けされたソースが使用できない場合、レプリカは、リストされたすべてのソースを重みの降順で試行し、最も重み付けされたソースから再開します。 複数のソースの重みが同じ場合、レプリカはそれらをランダムに順序付けします。 レプリカは、リストの操作を再度開始する必要がある場合、元の接続障害が発生したソースを含めて再試行します。 
    </p><p>
      ソースリストは <code class="literal">mysql.replication_asynchronous_connection_failover</code> および <code class="literal">mysql.replication_asynchronous_connection_failover_managed</code> テーブルに格納され、「パフォーマンススキーマ」テーブル <code class="literal">replication_asynchronous_connection_failover</code> で表示できます。 レプリカは、モニタースレッドを使用して管理対象グループのメンバーシップを追跡し、ソースリスト (<code class="literal">thread/sql/replica_monitor</code>) を更新します。 <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントの <code class="literal">SOURCE_CONNECTION_AUTO_FAILOVER</code> オプションの設定およびソースリストは、リモートクローニング操作中にレプリカのクローンに転送されます。 
    </p><p>
      非同期接続フェイルオーバーメカニズムを使用するための要件は次のとおりです:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          GTID がソースおよびレプリカ (<code class="literal">gtid_mode=ON</code>) で使用されている必要があり、GTID 自動配置がソースへの接続に使用されるように、<code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントの <code class="literal">SOURCE_AUTO_POSITION</code> | <code class="literal">MASTER_AUTO_POSITION</code> オプションがレプリカで有効になっている必要があります。
        </p></li><li class="listitem"><p>
          チャネルのソースリスト内のすべてのソースサーバーに、同じレプリケーションユーザーアカウントおよびパスワードが存在する必要があります。 このアカウントは、各ソースへの接続に使用されます。 チャネルごとに異なるアカウントを設定できます。 
        </p></li><li class="listitem"><p>
          レプリケーションユーザーアカウントには、たとえば <code class="literal">GRANT SELECT ON performance_schema.* TO '<em class="replaceable"><code>repl_user</code></em>';</code>を発行して、「パフォーマンススキーマ」テーブルに対する <code class="literal">SELECT</code> 権限が付与されている必要があります
        </p></li><li class="listitem"><p>
          レプリケーションユーザーアカウントおよびパスワードは、代替ソースへの接続のために自動再起動時に使用可能である必要があるため、レプリケーションの開始に使用するステートメントには指定できません。 これらは、レプリカで <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントを使用してチャネルに設定し、レプリケーションメタデータリポジトリに記録する必要があります。 
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-semisync"></a>17.4.10 準同期レプリケーション</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-semisync-interface">17.4.10.1 準同期レプリケーション管理インタフェース</a></span></dt><dt><span class="section"><a href="replication.html#replication-semisync-installation">17.4.10.2 準同期レプリケーションのインストールと構成</a></span></dt><dt><span class="section"><a href="replication.html#replication-semisync-monitoring">17.4.10.3 準同期レプリケーションモニタリング</a></span></dt></dl></div><a class="indexterm" name="idm46723649146128"></a><a class="indexterm" name="idm46723649144656"></a><p>
      MySQL 8.0 は、非同期レプリケーションを内蔵していますが、さらにプラグインによって実装される準同期レプリケーションへのインタフェースをサポートします。 このセクションでは、準同期レプリケーションの概要とその動作について説明します。 後続のセクションでは、準同期レプリケーションへの管理インタフェース、およびこれをインストール、構成、およびモニターする方法について説明します。 
    </p><p>
      MySQL レプリケーションはデフォルトで非同期です。 ソースはイベントをバイナリログに書き込み、レプリカは準備ができたらそれらを要求します。 ソースでは、レプリカがトランザクションを取得して処理したかどうか、またはいつ処理したかは認識されず、イベントがレプリカに到達したことは保証されません。 非同期レプリケーションでは、ソースがクラッシュした場合、コミットされたトランザクションがレプリカに送信されていない可能性があります。 この場合、ソースからレプリカにフェイルオーバーすると、ソースに対して相対的なトランザクションが欠落しているサーバーにフェイルオーバーする可能性があります。 
    </p><p>
      完全同期レプリケーションでは、ソースがトランザクションをコミットすると、ソースがトランザクションを実行したセッションに戻る前に、すべてのレプリカもトランザクションをコミットしています。 完全同期レプリケーションは、ソースから任意のレプリカへのフェイルオーバーがいつでも可能であることを意味します。 完全同期レプリケーションの欠点は、トランザクションの完了に多くの遅延が発生する可能性があることです。 
    </p><p>
      準同期レプリケーションは、非同期および完全同期レプリケーションの中間です。 ソースは、少なくとも 1 つのレプリカがイベントを受信してログに記録する (必要な数のレプリカが構成可能) まで待機してから、トランザクションをコミットします。 ソースは、すべてのレプリカが受信を確認するのを待機するわけではなく、レプリカからの確認のみを必要とし、レプリカ側でイベントが完全に実行およびコミットされたことを必要としません。 したがって、準同期レプリケーションでは、ソースがクラッシュした場合、コミットされたすべてのトランザクションが少なくとも 1 つのレプリカに送信されていることが保証されます。 
    </p><p>
      非同期レプリケーションと比較して、準同期レプリケーションではデータ整合性が向上します。コミットが正常に終了すると、データが 2 つ以上の場所に存在することがわかっているためです。 準同期ソースが必要な数のレプリカから確認を受信するまで、トランザクションは保留中でコミットされません。 
    </p><p>
      完全同期レプリケーションと比較すると、準同期レプリケーションは、データ整合性の要件 (トランザクションの受信を確認するレプリカの数) とコミットの速度のバランスをとるように構成できるため、高速です。これは、レプリカを待機する必要があるため、速度が遅くなります。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        準同期レプリケーションでは、ソースがクラッシュし、レプリカへのフェイルオーバーが実行された場合、障害が発生したソースはレプリケーションソースとして再利用されないため、破棄するようにしてください。 どのレプリカによっても確認されなかったため、フェイルオーバーの前にコミットされなかったトランザクションがある可能性があります。 
      </p><p>
        すべてのサーバーが同じトランザクションを同じ順序で受信し、クラッシュしたサーバーがグループに再度参加して自動的に最新になるフォルトトレラントレプリケーショントポロジを実装することを目的としている場合は、グループレプリケーションを使用してこれを実現できます。 詳細は、<a class="xref" href="group-replication.html" title="第 18 章 グループレプリケーション">第18章「<i>グループレプリケーション</i>」</a> を参照してください。 
      </p></div><p>
      非同期レプリケーションと比較した準同期レプリケーションのパフォーマンスへの影響は、データ整合性を向上させるためのトレードオフです。 速度低下の量は、少なくともレプリカにコミットを送信し、レプリカによる受信確認を待機する TCP/IP ラウンドトリップ時間です。 これは、準同期レプリケーションは高速ネットワーク上で通信する近いサーバーに最適で、低速ネットワークで通信する遠いサーバーに最悪であることを意味します。 準同期レプリケーションでは、バイナリログイベントをソースからレプリカに送信できる速度を制限することによって、ビジーセッションの速度制限も設定されます。 あるユーザーがビジー状態の場合、これにより処理速度が低下するため、一部のデプロイメント状況で役立ちます。 
    </p><p>
      ソースとそのレプリカ間の準同期レプリケーションは、次のように動作します:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          レプリカは、ソースへの接続時に準同期対応であるかどうかを示します。
        </p></li><li class="listitem"><p>
          ソース側で準同期レプリケーションが有効になっていて、少なくとも 1 つの準同期レプリカが存在する場合、ソースブロックでトランザクションコミットを実行し、少なくとも 1 つの準同期レプリカがトランザクションのすべてのイベントを受信したことを確認するか、タイムアウトが発生するまで待機するスレッド。
        </p></li><li class="listitem"><p>
          レプリカは、イベントがリレーログに書き込まれてディスクにフラッシュされた後にのみ、トランザクションイベントの受信を確認します。
        </p></li><li class="listitem"><p>
          レプリカがトランザクションを確認せずにタイムアウトが発生した場合、ソースは非同期レプリケーションに戻ります。 少なくとも 1 つの準同期レプリカがキャッチアップすると、ソースは準同期レプリケーションに戻ります。 
        </p></li><li class="listitem"><p>
          ソース側とレプリカ側の両方で、準同期レプリケーションを有効にする必要があります。 準同期レプリケーションがソースで無効になっているか、ソースで有効になっているがレプリカで有効になっていない場合、ソースは非同期レプリケーションを使用します。 
        </p></li></ul></div><p>
      ソースがブロックしている間 (レプリカからの確認を待機している間)、トランザクションを実行したセッションには戻りません。 ブロックが終了すると、ソースはセッションに戻り、他のステートメントの実行に進むことができます。 この時点で、トランザクションはソース側でコミットされ、そのイベントの受信は少なくとも 1 つのレプリカによって確認されています。 セッションに戻る前にソースがトランザクションごとに受信する必要があるレプリカ確認の数は、<code class="literal">rpl_semi_sync_master_wait_for_slave_count</code> システム変数 (デフォルト値は 1) を使用して構成できます。 
    </p><p>
      ブロックはバイナリログに書き込まれるロールバック後にも発生し、これは非トランザクションテーブルを変更するトランザクションがロールバックされるときに発生します。 非トランザクションテーブルへの変更はロールバックできず、レプリカに送信する必要があるため、トランザクションテーブルには影響しませんが、ロールバックされたトランザクションはログに記録されます。 
    </p><p>
      トランザクションコンテキストで発生しないステートメントの場合 (つまり、トランザクションが <code class="literal">START TRANSACTION</code> または <code class="literal">SET autocommit = 0</code> で起動されなかったとき)、自動コミットが有効になっていて、各ステートメントは暗黙的にコミットされます。 準同期レプリケーションでは、明示的なトランザクションコミットの場合と同様に、このような各ステートメントのソースブロックが行われます。 
    </p><p>
      <code class="literal">rpl_semi_sync_master_wait_point</code> システム変数は、準同期ソースサーバーがトランザクションをコミットしたクライアントにステータスを返す前に、トランザクション受信のレプリカ確認を待機するポイントを制御します。 次の値を使用できます: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">AFTER_SYNC</code> (デフォルト): ソースは、各トランザクションをバイナリログとレプリカに書き込み、バイナリログをディスクに同期します。 ソースは、同期後にトランザクション受信のレプリカ確認を待機します。 確認応答を受信すると、ソースはトランザクションをストレージエンジンにコミットし、クライアントに結果を返してから続行できます。 
        </p></li><li class="listitem"><p>
          <code class="literal">AFTER_COMMIT</code>: ソースは、各トランザクションをバイナリログとレプリカに書き込み、バイナリログを同期し、トランザクションをストレージエンジンにコミットします。 ソースは、コミット後にトランザクション受信のレプリカ確認を待機します。 確認を受信すると、ソースは結果をクライアントに返し、クライアントは続行できます。 
        </p></li></ul></div><p>
      これらの設定のレプリケーション特性は、次のように異なります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">AFTER_SYNC</code> では、すべてのクライアントが同時にコミットされたトランザクションを確認できます。これは、レプリカによって確認され、ソース上のストレージエンジンにコミットされたあとです。 したがって、すべてのクライアントにソース上の同じデータが表示されます。 
        </p><p>
          ソース障害が発生した場合、ソースでコミットされたすべてのトランザクションがレプリカにレプリケートされます (リレーログに保存されます)。 レプリカが最新であるため、ソースの予期しない終了およびレプリカへのフェイルオーバーは失われません。 前述のように、フェイルオーバー後にソースを再利用しないでください。 
        </p></li><li class="listitem"><p>
          <code class="literal">AFTER_COMMIT</code> では、サーバーがストレージエンジンにコミットしてレプリカの確認応答を受信したあとにのみ、トランザクションを発行するクライアントは戻りステータスを取得します。 コミット後およびレプリカの確認前に、他のクライアントはコミット中のクライアントの前にコミット済トランザクションを確認できます。 
        </p><p>
          レプリカがトランザクションを処理しないなどの問題が発生した場合は、予期しないソースの終了およびレプリカへのフェイルオーバーが発生したときに、そのようなクライアントがソースで見た内容と比較してデータの損失を確認できる可能性があります。
        </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-semisync-interface"></a>17.4.10.1 準同期レプリケーション管理インタフェース</h4></div></div></div><a class="indexterm" name="idm46723649098688"></a><p>
        準同期レプリケーションへの管理インタフェースにはいくつかのコンポーネントがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            準同期機能を実装する 2 つのプラグイン。 ソース側には 1 つのプラグイン、レプリカ側には 1 つのプラグインがあります。 
          </p></li><li class="listitem"><p>
            プラグインの動作を制御するシステム変数。 例:  
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">rpl_semi_sync_master_enabled</code>
              </p><p>
                ソースサーバーで準同期レプリケーションを有効にするかどうかを制御します。 プラグインを有効または無効にするには、この変数をそれぞれ 1 または 0 に設定します。 デフォルトは 0 （オフ） です。 
              </p></li><li class="listitem"><p>
                <code class="literal">rpl_semi_sync_master_timeout</code>
              </p><p>
                ソースがタイムアウトして非同期レプリケーションに戻る前にレプリカからの確認応答をコミットで待機する時間を制御するミリ秒単位の値。 デフォルト値は 10000 (10 秒) です。 
              </p></li><li class="listitem"><p>
                <code class="literal">rpl_semi_sync_slave_enabled</code>
              </p><p>
                <code class="literal">rpl_semi_sync_master_enabled</code> と似ていますが、レプリカプラグインを制御します。
              </p></li></ul></div><p>
            すべての <code class="literal">rpl_semi_sync_<em class="replaceable"><code>xxx</code></em></code> システム変数は、<a class="xref" href="replication.html#replication-options-source" title="17.1.6.2 レプリケーションソースのオプションと変数">セクション17.1.6.2「レプリケーションソースのオプションと変数」</a> および <a class="xref" href="replication.html#replication-options-replica" title="17.1.6.3 Replica Server のオプションと変数">セクション17.1.6.3「Replica Server のオプションと変数」</a> で説明されています。
          </p></li><li class="listitem"><p>
            MySQL 8.0.23 から、コールバックを制限するシステム変数 <code class="literal">replication_sender_observe_commit_only</code> と、共有ロックを追加して不要なロック取得を回避する <code class="literal">replication_optimize_for_static_plugin_config</code> を有効にすることで、準同期レプリケーションのパフォーマンスを向上させることができます。 これらの設定は、ロックの競合によってパフォーマンスが低下する可能性があるため、レプリカの数が増えるにつれて役立ちます。 準同期レプリケーションソースサーバーは、複製と同じロックメカニズムを使用するため、これらのシステム変数を有効にすることによってパフォーマンス上の利点を得ることもできます。 
          </p></li><li class="listitem"><p>
            準同期レプリケーションモニタリングを有効にするステータス変数。 例:  
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">Rpl_semi_sync_master_clients</code>
              </p><p>
                準同期レプリカの数。
              </p></li><li class="listitem"><p>
                <code class="literal">Rpl_semi_sync_master_status</code>
              </p><p>
                準同期レプリケーションが現在ソースサーバーで動作しているかどうか。 プラグインが有効になっていてコミット通知が発生していない場合、値は 1 です。 プラグインが有効になっていない場合、またはコミット確認タイムアウトのためにソースが非同期レプリケーションにフォールバックした場合は 0 です。 
              </p></li><li class="listitem"><p>
                <code class="literal">Rpl_semi_sync_master_no_tx</code>
              </p><p>
                レプリカによって正常に確認されなかったコミットの数。
              </p></li><li class="listitem"><p>
                <code class="literal">Rpl_semi_sync_master_yes_tx</code>
              </p><p>
                レプリカによって正常に確認されたコミットの数。
              </p></li><li class="listitem"><p>
                <code class="literal">Rpl_semi_sync_slave_status</code>
              </p><p>
                準同期レプリケーションが現在レプリカで動作しているかどうか。 プラグインが有効になっていてレプリケーション I/O スレッドが実行中の場合は 1、それ以外の場合は 0 です。 
              </p></li></ul></div><p>
            すべての <code class="literal">Rpl_semi_sync_<em class="replaceable"><code>xxx</code></em></code> ステータス変数は<a class="xref" href="server-administration.html#server-status-variables" title="5.1.10 サーバーステータス変数">セクション5.1.10「サーバーステータス変数」</a>で説明されています。
          </p></li></ul></div><p>
        システム変数およびステータス変数は、適切なソースまたはレプリカプラグインが <code class="literal">INSTALL PLUGIN</code> とともにインストールされている場合にのみ使用できます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-semisync-installation"></a>17.4.10.2 準同期レプリケーションのインストールと構成</h4></div></div></div><a class="indexterm" name="idm46723649058400"></a><a class="indexterm" name="idm46723649056256"></a><p>
        準同期レプリケーションはプラグインを使用して実装されるため、プラグインがサーバーにインストールされて利用できる状態である必要があります。 プラグインがインストールされたあと、それに関連付けられたシステム変数によって制御します。 これらのシステム変数は、関連付けられたプラグインがインストールされるまで利用できません。 
      </p><p>
        このセクションでは、準同期レプリケーションプラグインをインストールする方法について説明します。 プラグインのインストールについての一般的な情報は、<a class="xref" href="server-administration.html#plugin-loading" title="5.6.1 プラグインのインストールおよびアンインストール">セクション5.6.1「プラグインのインストールおよびアンインストール」</a>を参照してください。 
      </p><p>
        準同期レプリケーションを使用するには、次の要件を満たす必要があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            プラグインをインストールする機能には、動的ローディングをサポートする MySQL サーバーが必要です。 これを検証するために、<code class="literal">have_dynamic_loading</code> システム変数の値が <code class="literal">YES</code> であることを確認してください。 バイナリ配布は動的ローディングをサポートしているはずです。 
          </p></li><li class="listitem"><p>
            レプリケーションがすでに機能している必要があります。<a class="xref" href="replication.html#replication-configuration" title="17.1 レプリケーションの構成">セクション17.1「レプリケーションの構成」</a> を参照してください。
          </p></li><li class="listitem"><p>
            複数のレプリケーションチャネルを構成しないでください。 準同期レプリケーションは、デフォルトのレプリケーションチャネルとのみ互換性があります。 <a class="xref" href="replication.html#replication-channels" title="17.2.2 レプリケーションチャネル">セクション17.2.2「レプリケーションチャネル」</a>を参照してください。 
          </p></li></ul></div><p>
        準同期レプリケーションをセットアップするには、次の指示を使用してください。 ここで説明する <code class="literal">INSTALL PLUGIN</code>, <code class="literal">SET GLOBAL</code>, <code class="literal">STOP REPLICA | SLAVE</code> および <code class="literal">START REPLICA | SLAVE</code> ステートメントには、<code class="literal">REPLICATION_SLAVE_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。 
      </p><p>
        MySQL ディストリビューションには、ソース側とレプリカ側の準同期レプリケーションプラグインファイルが含まれます。
      </p><p>
        ソースサーバーまたはレプリカサーバーで使用できるようにするには、適切なプラグインライブラリファイルを MySQL プラグインディレクトリ (<code class="literal">plugin_dir</code> システム変数で指定されたディレクトリ) に配置する必要があります。 必要に応じて、サーバーの起動時に <code class="literal">plugin_dir</code> の値を設定してプラグインディレクトリの場所を構成します。 
      </p><p>
        プラグインライブラリファイルのベース名は、ソース用の <code class="literal">semisync_master</code>、およびレプリカ用の <code class="literal">semisync_slave</code> です。 ファイル名の接尾辞は、プラットフォームごとに異なります (たとえば、<code class="filename">.so</code> for Unix and Unix-like systems, <code class="filename">.dll</code> for Windows)。 
      </p><p>
        ソースプラグインライブラリファイルは、ソースサーバーのプラグインディレクトリに存在する必要があります。 レプリカプラグインライブラリファイルは、各レプリカサーバーのプラグインディレクトリに存在する必要があります。 
      </p><p>
        プラグインをロードするには、ソースおよび準同期化する各レプリカで <code class="literal">INSTALL PLUGIN</code> ステートメントを使用し、必要に応じてプラットフォームの <code class="filename">.so</code> 接尾辞を調整します。
      </p><p>
        ソースで、次のようにします:
      </p><pre class="programlisting">INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';
</pre><p>
        各レプリカで、次のようにします:
      </p><pre class="programlisting">INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so';
</pre><p>
        プラグインをインストールしようとすると、次に示すようなエラーが Linux で発生する場合は、<code class="literal">libimf</code> をインストールする必要があります:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';</code></strong>
ERROR 1126 (HY000): Can't open shared library
'/usr/local/mysql/lib/plugin/semisync_master.so'
(errno: 22 libimf.so: cannot open shared object file:
No such file or directory)
</pre><p>
        <code class="literal">libimf</code> は <a class="ulink" href="https://dev.mysql.com/downloads/os-linux.html" target="_top">https://dev.mysql.com/downloads/os-linux.html</a>から取得できます。
      </p><p>
        どのプラグインがインストールされているかを確認するには、<code class="literal">SHOW PLUGINS</code> ステートメントを使用するか、<code class="literal">INFORMATION_SCHEMA.PLUGINS</code> テーブルを照会してください。
      </p><p>
        プラグインのインストールを確認するには、<code class="literal">INFORMATION_SCHEMA.PLUGINS</code> テーブルを調べるか、<code class="literal">SHOW PLUGINS</code> ステートメントを使用します (<a class="xref" href="server-administration.html#obtaining-plugin-information" title="5.6.2 サーバープラグイン情報の取得">セクション5.6.2「サーバープラグイン情報の取得」</a> を参照)。 例: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT PLUGIN_NAME, PLUGIN_STATUS</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PLUGINS</code></strong>
       <strong class="userinput"><code>WHERE PLUGIN_NAME LIKE '%semi%';</code></strong>
+----------------------+---------------+
| PLUGIN_NAME          | PLUGIN_STATUS |
+----------------------+---------------+
| rpl_semi_sync_master | ACTIVE        |
+----------------------+---------------+
</pre><p>
        プラグインの初期化に失敗した場合は、サーバーエラーログで診断メッセージを確認してください。
      </p><p>
        準同期レプリケーションプラグインがインストールされたあとは、デフォルトで無効になっています。 準同期レプリケーションを有効にするには、ソース側とレプリカ側の両方でプラグインを有効にする必要があります。 一方の側のみが有効な場合、レプリケーションは非同期です。 
      </p><p>
        インストールされたプラグインが有効かどうかを制御するには、該当するシステム変数を設定します。 これらの変数は実行時に <code class="literal">SET GLOBAL</code> を使用して、またはコマンド行またはオプションファイルでサーバー起動時に設定できます。 
      </p><p>
        実行時には、次のソース側システム変数を使用できます:
      </p><pre class="programlisting">SET GLOBAL rpl_semi_sync_master_enabled = {0|1};
SET GLOBAL rpl_semi_sync_master_timeout = <em class="replaceable"><code>N</code></em>;
</pre><p>
        レプリカ側では、次のシステム変数を使用できます:
      </p><pre class="programlisting">SET GLOBAL rpl_semi_sync_slave_enabled = {0|1};
</pre><p>
        <code class="literal">rpl_semi_sync_master_enabled</code> または <code class="literal">rpl_semi_sync_slave_enabled</code> の場合、準同期レプリケーションを有効にするには値を 1、無効にするには 0 にすべきです。 デフォルトでは、これらの変数は 0 に設定されています。 
      </p><p>
        <code class="literal">rpl_semi_sync_master_timeout</code> の場合、値 <em class="replaceable"><code>N</code></em> はミリ秒で指定されます。 デフォルト値は 10000 (10 秒) です。 
      </p><p>
        実行時にレプリカで準同期レプリケーションを有効にする場合は、レプリケーション I/O スレッドも起動 (すでに実行されている場合は最初に停止) して、レプリカをソースに接続し、準同期レプリカとして登録する必要があります:
      </p><pre class="programlisting">STOP SLAVE IO_THREAD;
START SLAVE IO_THREAD;
Or from MySQL 8.0.22:
STOP REPLICA IO_THREAD;
START REPLICA IO_THREAD;
</pre><p>
        レプリケーション I/O スレッドがすでに実行されていて、再起動しない場合、レプリカは非同期レプリケーションを引き続き使用します。
      </p><p>
        サーバー起動時に、準同期レプリケーションを制御する変数をコマンド行オプションとしてまたはオプションファイルに設定できます。 オプションファイルにリストされる設定は、サーバーが起動するたびに有効になります。 たとえば、次のようにして、ソースサーバーおよびレプリカサーバー上の <code class="filename">my.cnf</code> ファイルに変数を設定できます。 
      </p><p>
        ソースで、次のようにします:
      </p><pre class="programlisting">[mysqld]
rpl_semi_sync_master_enabled=1
rpl_semi_sync_master_timeout=1000 # 1 second
</pre><p>
        各レプリカで、次のようにします:
      </p><pre class="programlisting">[mysqld]
rpl_semi_sync_slave_enabled=1
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-semisync-monitoring"></a>17.4.10.3 準同期レプリケーションモニタリング</h4></div></div></div><a class="indexterm" name="idm46723648986432"></a><p>
        準同期レプリケーション機能用のプラグインはいくつのシステム変数とステータス変数を公開しており、その構成および運用状態を判断するためにそれらを調べることができます。
      </p><p>
        システム変数は準同期レプリケーションがどのように構成されているかを反映します。 これらの値を確認するには、<code class="literal">SHOW VARIABLES</code> を使用します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'rpl_semi_sync%';</code></strong>
</pre><p>
        ステータス変数によって、準同期レプリケーションの動作をモニターできます。 これらの値を確認するには、<code class="literal">SHOW STATUS</code> を使用します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'Rpl_semi_sync%';</code></strong>
</pre><p>
        コミットブロックのタイムアウトまたはレプリカのキャッチアップのためにソースが非同期レプリケーションまたは準同期レプリケーションを切り替えると、<code class="literal">Rpl_semi_sync_master_status</code> ステータス変数の値が適切に設定されます。 ソースでの準同期レプリケーションから非同期レプリケーションへの自動フォールバックは、準同期レプリケーションが実際には動作していない場合でも、<code class="literal">rpl_semi_sync_master_enabled</code> システム変数の値がソース側で 1 になる可能性があることを意味します。 <code class="literal">Rpl_semi_sync_master_status</code> ステータス変数をモニターして、ソースが現在非同期レプリケーションと準同期レプリケーションのどちらを使用しているかを判断できます。 
      </p><p>
        接続されている準同期レプリカの数を確認するには、<code class="literal">Rpl_semi_sync_master_clients</code> をチェックします。
      </p><p>
        レプリカによって正常に確認されたコミットまたは正常に確認されなかったコミットの数は、<code class="literal">Rpl_semi_sync_master_yes_tx</code> および <code class="literal">Rpl_semi_sync_master_no_tx</code> 変数によって示されます。
      </p><p>
        レプリカ側では、<code class="literal">Rpl_semi_sync_slave_status</code> は準同期レプリケーションが現在動作しているかどうかを示します。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-delayed"></a>17.4.11 遅延レプリケーション</h3></div></div></div><a class="indexterm" name="idm46723648964256"></a><a class="indexterm" name="idm46723648962800"></a><a class="indexterm" name="idm46723648960736"></a><a class="indexterm" name="idm46723648959728"></a><p>
      MySQL では、レプリカサーバーが、少なくとも指定した時間だけソースより後のトランザクションを意図的に実行するように遅延レプリケーションをサポートしています。 このセクションでは、レプリカのレプリケーション遅延を構成する方法と、レプリケーション遅延を監視する方法について説明します。 
    </p><p>
      MySQL 8.0 では、レプリケーションを遅延させる方法は、<code class="literal">immediate_commit_timestamp</code> および <code class="literal">original_commit_timestamp</code> (<a class="xref" href="replication.html#replication-delayed-timestamps" title="レプリケーション遅延タイムスタンプ">レプリケーション遅延タイムスタンプ</a> を参照) の 2 つのタイムスタンプによって異なります。 レプリケーショントポロジ内のすべてのサーバーで MySQL 8.0 以上が実行されている場合、遅延レプリケーションはこれらのタイムスタンプを使用して測定されます。 即時ソースまたはレプリカがこれらのタイムスタンプを使用していない場合は、MySQL 5.7 からの遅延レプリケーションの実装が使用されます (<a class="ulink" href="https://dev.mysql.com/doc/refman/5.7/en/replication-delayed.html" target="_top">Delayed Replication</a> を参照)。 このセクションでは、これらのタイムスタンプをすべて使用しているサーバー間の遅延レプリケーションについて説明します。 
    </p><p>
      デフォルトのレプリケーション遅延は 0 秒です。 <code class="literal">CHANGE REPLICATION SOURCE TO SOURCE_DELAY=<em class="replaceable"><code>N</code></em></code> ステートメント (MySQL 8.0.23 の場合) または <code class="literal">CHANGE MASTER TO MASTER_DELAY=<em class="replaceable"><code>N</code></em></code> ステートメント (MySQL 8.0.23 の場合) を使用して、遅延を <em class="replaceable"><code>N</code></em> 秒に設定します。 ソースから受信したトランザクションは、<em class="replaceable"><code>N</code></em> 秒以上が即時ソースでのコミットより後になるまで実行されません。 遅延はトランザクションごとに発生し (以前の MySQL バージョンとは異なり)、実際の遅延は <code class="literal">gtid_log_event</code> または <code class="literal">anonymous_gtid_log_event</code> にのみ適用されます。 トランザクション内の他のイベントは、常に待機時間なしでこれらのイベントに従います。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">START REPLICA | SLAVE</code> および <code class="literal">STOP REPLICA | SLAVE</code> はただちに有効になり、遅延は無視されます。 <code class="literal">RESET REPLICA | SLAVE</code> は遅延を 0 にリセットします。 
      </p></div><p>
      <code class="literal">replication_applier_configuration</code>「パフォーマンススキーマ」テーブルには、<code class="literal">SOURCE_DELAY</code> | <code class="literal">MASTER_DELAY</code> オプションを使用して構成された遅延を示す <code class="literal">DESIRED_DELAY</code> カラムが含まれます。 <code class="literal">replication_applier_status</code>「パフォーマンススキーマ」テーブルには、残りの遅延秒数を示す <code class="literal">REMAINING_DELAY</code> カラムが含まれています。 
    </p><p>
      遅延レプリケーションはいくつかの目的に使用できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ソースでのユーザーミスから保護します。 遅延により、遅延レプリカを誤った直前の時点にロールバックできます。 
        </p></li><li class="listitem"><p>
          遅延があるときにシステムがどのように動作するかをテストするため。 たとえば、アプリケーションでは、レプリカの負荷が高いためにラグが発生する場合があります。 しかし、この負荷レベルを生成するのが難しい場合があります。 遅延レプリケーションは、負荷をシミュレートしなくても遅延をシミュレートできます。 また、遅延レプリカに関連する状態のデバッグにも使用できます。 
        </p></li><li class="listitem"><p>
          バックアップを再ロードせずに、データベースが過去にどのように表示されていたかを検査します。 たとえば、1 週間の遅延でレプリカを構成することで、過去数日前にデータベースがどのように表示されたかを確認する必要がある場合は、遅延レプリカを検査できます。 
        </p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="replication-delayed-timestamps"></a>レプリケーション遅延タイムスタンプ</h4></div></div></div><p>
        MySQL 8.0 には、バイナリログに書き込まれる (各イベントではなく) 各トランザクションの GTID に関連付けられた次のタイムスタンプに依存するレプリケーショントポロジで遅延 (レプリケーションラグとも呼ばれる) を測定するための新しい方法が用意されています。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">original_commit_timestamp</code>: トランザクションが元のソースのバイナリログに書き込まれた (コミットされた) ときのエポック以降のマイクロ秒数。
          </p></li><li class="listitem"><p>
            <code class="literal">immediate_commit_timestamp</code>: トランザクションが即時ソースのバイナリログに書き込まれた (コミットされた) ときのエポック以降のマイクロ秒数。
          </p></li></ul></div><p>
        <span class="command"><strong>mysqlbinlog</strong></span> の出力には、これらのタイムスタンプがエポックからのマイクロ秒の形式で表示され、読みやすくするためにユーザー定義のタイムゾーンに基づく <code class="literal">TIMESTAMP</code> 形式でも表示されます。 例: 
      </p><pre class="programlisting">#170404 10:48:05 server id 1  end_log_pos 233 CRC32 0x016ce647     GTID    last_committed=0
\ sequence_number=1    original_committed_timestamp=1491299285661130    immediate_commit_timestamp=1491299285843771
# original_commit_timestamp=1491299285661130 (2017-04-04 10:48:05.661130 WEST)
# immediate_commit_timestamp=1491299285843771 (2017-04-04 10:48:05.843771 WEST)
 /*!80001 SET @@SESSION.original_commit_timestamp=1491299285661130*//*!*/;
   SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1'/*!*/;
# at 233
</pre><p>
        原則として、<code class="literal">original_commit_timestamp</code> は、トランザクションが適用されるすべてのレプリカで常に同じです。 ソースレプリケーションレプリケーションでは、(元の) ソースのバイナリログ内のトランザクションの <code class="literal">original_commit_timestamp</code> は、常にその <code class="literal">immediate_commit_timestamp</code> と同じです。 レプリカのリレーログでは、トランザクションの <code class="literal">original_commit_timestamp</code> と <code class="literal">immediate_commit_timestamp</code> はソースのバイナリログと同じですが、独自のバイナリログでは、レプリカがトランザクションをコミットした時点にトランザクションの <code class="literal">immediate_commit_timestamp</code> が対応します。 
      </p><p>
        グループレプリケーション設定では、元のソースがグループのメンバーである場合、トランザクションをコミットする準備が整うと <code class="literal">original_commit_timestamp</code> が生成されます。 つまり、元のソースでの実行が終了し、その書込みセットを証明のためにグループのすべてのメンバーに送信する準備が整ったときです。 したがって、(グループメンバーであるか、メンバーからレプリケートされるグループ外のレプリカであるかに関係なく) すべてのサーバーに同じ <code class="literal">original_commit_timestamp</code> がレプリケートされ、トランザクションとそのバイナリログ内の各ストアに、<code class="literal">immediate_commit_timestamp</code> を使用したローカルコミット時間が記録されます。 
      </p><p>
        グループレプリケーション専用の変更イベントの表示は特殊なケースです。 これらのイベントを含むトランザクションは各サーバーによって生成されますが、同じ GTID を共有します (そのため、最初にソースで実行されてからグループにレプリケートされるのではなく、グループのすべてのメンバーが同じトランザクションを実行して適用します)。 元のソースがないため、これらのトランザクションの <code class="literal">original_commit_timestamp</code> はゼロに設定されます。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="replication-delayed-monitoring"></a>レプリケーション遅延の監視</h4></div></div></div><p>
        以前の MySQL バージョンでレプリケーション遅延 (ラグ) を監視する最も一般的な方法の 1 つは、<code class="literal">SHOW REPLICA | SLAVE STATUS</code> の出力の <code class="literal">Seconds_Behind_Master</code> フィールドに依存することでした。 ただし、このメトリックは、グループレプリケーションなどの従来のソースレプリケーション設定より複雑なレプリケーショントポロジを使用する場合には適していません。 MySQL 8 に <code class="literal">immediate_commit_timestamp</code> および <code class="literal">original_commit_timestamp</code> を追加すると、レプリケーション遅延に関するより詳細な情報が提供されます。 これらのタイムスタンプをサポートするトポロジでレプリケーション遅延を監視するには、次の「パフォーマンススキーマ」テーブルを使用することをお薦めします。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">replication_connection_status</code>: ソースへの接続の現在のステータス。接続スレッドがリレーログにキューに入れた最後のトランザクションと現在のトランザクションに関する情報を提供します。
          </p></li><li class="listitem"><p>
            <code class="literal">replication_applier_status_by_coordinator</code>: マルチスレッドレプリカの使用時にのみ情報を表示するコーディネータスレッドの現在のステータスは、コーディネータスレッドによってワーカーキューにバッファリングされた最後のトランザクションに関する情報と、現在バッファリングしているトランザクションに関する情報を提供します。
          </p></li><li class="listitem"><p>
            <code class="literal">replication_applier_status_by_worker</code>: ソースから受信したトランザクションを適用しているスレッドの現在のステータス。レプリケーション SQL スレッド、またはマルチスレッドのレプリカを使用している場合は各ワーカースレッドによって適用されたトランザクションに関する情報を提供します。
          </p></li></ul></div><p>
        これらのテーブルを使用して、対応するスレッドが処理した最後のトランザクションおよびスレッドが現在処理しているトランザクションに関する情報を監視できます。 この情報は次のもので構成されます: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            トランザクションの GTID
          </p></li><li class="listitem"><p>
            レプリカのリレーログから取得されたトランザクション <code class="literal">original_commit_timestamp</code> および <code class="literal">immediate_commit_timestamp</code>
          </p></li><li class="listitem"><p>
            スレッドがトランザクションの処理を開始した時刻
          </p></li><li class="listitem"><p>
            スレッドが最後に処理したトランザクションの処理を終了した時間
          </p></li></ul></div><p>
        「パフォーマンススキーマ」テーブルに加えて、<code class="literal">SHOW REPLICA | SLAVE STATUS</code> の出力には次の 3 つのフィールドがあります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">SQL_Delay</code>: <code class="literal">CHANGE REPLICATION SOURCE TO SOURCE_DELAY=<em class="replaceable"><code>N</code></em></code> (MySQL 8.0.23 から) または <code class="literal">CHANGE MASTER TO MASTER_DELAY=N</code> (MySQL 8.0.23 より前) を使用して構成されたレプリケーション遅延を示す負でない整数 (単位は秒)。
          </p></li><li class="listitem"><p>
            <code class="literal">SQL_Remaining_Delay</code>: <code class="literal">Replica_SQL_Running_State</code> が <code class="literal">Waiting until MASTER_DELAY seconds after master executed event</code> の場合、このフィールドには遅延の残り秒数を示す整数が含まれます。 ほかのときは、このフィールドは <code class="literal">NULL</code> です。 
          </p></li><li class="listitem"><p>
            <code class="literal">Replica_SQL_Running_State</code>: SQL スレッドの状態を示す文字列 (<code class="literal">Replica_IO_State</code> に類似)。 値は、<code class="literal">SHOW PROCESSLIST</code> で表示される、SQL スレッドの <code class="literal">State</code> 値と同じです。 
          </p></li></ul></div><p>
        レプリケーション SQL スレッドがイベントの実行前に遅延が経過するのを待機している場合、<code class="literal">SHOW PROCESSLIST</code> はその <code class="literal">State</code> 値を <code class="literal">Waiting until MASTER_DELAY seconds after master executed event</code> として表示します。
      </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="replication-notes"></a>17.5 レプリケーションの注釈とヒント</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-features">17.5.1 レプリケーションの機能と問題</a></span></dt><dt><span class="section"><a href="replication.html#replication-compatibility">17.5.2 MySQL バージョン間のレプリケーション互換性</a></span></dt><dt><span class="section"><a href="replication.html#replication-upgrade">17.5.3 レプリケーションセットアップをアップグレードする</a></span></dt><dt><span class="section"><a href="replication.html#replication-problems">17.5.4 レプリケーションのトラブルシューティング</a></span></dt><dt><span class="section"><a href="replication.html#replication-bugs">17.5.5 レプリケーションバグまたは問題を報告する方法</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-features"></a>17.5.1 レプリケーションの機能と問題</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-features-auto-increment">17.5.1.1 レプリケーションと AUTO_INCREMENT</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-blackhole">17.5.1.2 レプリケーションと BLACKHOLE テーブル</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-charset">17.5.1.3 レプリケーションと文字セット</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-checksum-table">17.5.1.4 レプリケーションと CHECKSUM TABLE</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-create-alter-drop-server">17.5.1.5 CREATE SERVER、ALTER SERVER、および DROP SERVER のレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-create-if-not-exists">17.5.1.6 CREATE ... IF NOT EXISTS ステートメントのレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-create-select">17.5.1.7 CREATE TABLE ... SELECT ステートメントのレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-current-user">17.5.1.8 CURRENT_USER() のレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-differing-tables">17.5.1.9 ソースとレプリカで異なるテーブル定義を使用したレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-directory">17.5.1.10 レプリケーションと DIRECTORY テーブルオプション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-drop-if-exists">17.5.1.11 DROP ... IF EXISTS ステートメントのレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-floatvalues">17.5.1.12 レプリケーションと浮動小数点値</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-flush">17.5.1.13 レプリケーションと FLUSH</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-functions">17.5.1.14 レプリケーションとシステム関数</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-fractional-seconds">17.5.1.15 レプリケーションと小数秒サポート</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-invoked">17.5.1.16 呼び出される機能のレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-json">17.5.1.17 JSON ドキュメントのレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-limit">17.5.1.18 レプリケーションと LIMIT</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-load-data">17.5.1.19 レプリケーションと LOAD DATA</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-max-allowed-packet">17.5.1.20 レプリケーションと max_allowed_packet</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-memory">17.5.1.21 レプリケーションと MEMORY テーブル</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-mysqldb">17.5.1.22 mysql システムスキーマのレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-optimizer">17.5.1.23 レプリケーションとクエリーオプティマイザ</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-partitioning">17.5.1.24 レプリケーションおよびパーティション化</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-repair-table">17.5.1.25 レプリケーションと REPAIR TABLE</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-reserved-words">17.5.1.26 レプリケーションと予約語</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-row-searches">17.5.1.27 レプリケーションおよび行検索</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-shutdowns">17.5.1.28 レプリケーションとソースまたはレプリカの停止</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-slaveerrors">17.5.1.29 レプリケーション中のレプリカエラー</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-sql-mode">17.5.1.30 レプリケーションとサーバー SQL モード</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-temptables">17.5.1.31 レプリケーションと一時テーブル</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-timeout">17.5.1.32 レプリケーション再試行とタイムアウト</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-timezone">17.5.1.33 レプリケーションとタイムゾーン</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-transaction-inconsistencies">17.5.1.34 レプリケーションとトランザクションの非一貫性</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-transactions">17.5.1.35 レプリケーションとトランザクション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-triggers">17.5.1.36 レプリケーションとトリガー</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-truncate">17.5.1.37 レプリケーションと TRUNCATE TABLE</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-user-names">17.5.1.38 レプリケーションおよびユーザー名の長さ</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-variables">17.5.1.39 レプリケーションと変数</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-views">17.5.1.40 レプリケーションとビュー</a></span></dt></dl></div><a class="indexterm" name="idm46723648868832"></a><a class="indexterm" name="idm46723648866688"></a><a class="indexterm" name="idm46723648865312"></a><a class="indexterm" name="idm46723648863248"></a><a class="indexterm" name="idm46723648861856"></a><a class="indexterm" name="idm46723648860448"></a><p>
      以降のセクションでは、MySQL レプリケーションでサポートされていることとされていないことに関する情報、および特定のステートメントの複製時に発生する可能性がある固有の問題と状況に関する情報を提供します。
    </p><p>
      ステートメントベースレプリケーションは、ソースとレプリカの間の SQL レベルでの互換性に依存します。 つまり、ステートメントベースのレプリケーションが成功するには、使用される SQL 機能がソースサーバーとレプリカサーバーの両方でサポートされている必要があります。 現在のバージョンの MySQL でのみ使用可能なソースサーバーで機能を使用する場合、以前のバージョンの MySQL を使用するレプリカにレプリケートすることはできません。 このような非互換性は、リリースシリーズ内およびバージョン間でも発生する可能性があります。 
    </p><p>
      MySQL 8.0 と以前の MySQL リリースシリーズの間でステートメントベースレプリケーションを使用する場合は、そのシリーズのレプリケーション特性に関する情報について、以前のリリースシリーズに対応する<em class="citetitle">「MySQL リファレンスマニュアル」</em>のエディションを参照することをお勧めします。
    </p><p>
      MySQL のステートメントベースレプリケーションでは、ストアドルーチンまたはトリガーの複製で問題が発生する場合があります。 これらの問題は、代わりに MySQL の行ベースのレプリケーションを使用することで回避できます。 問題の詳細な一覧は、<a class="xref" href="stored-objects.html#stored-programs-logging" title="25.7 ストアドプログラムバイナリロギング">セクション25.7「ストアドプログラムバイナリロギング」</a>を参照してください。 行ベースロギングおよび行ベースレプリケーションに関する詳細は、<a class="xref" href="server-administration.html#binary-log-formats" title="5.4.4.1 バイナリロギング形式">セクション5.4.4.1「バイナリロギング形式」</a>および<a class="xref" href="replication.html#replication-formats" title="17.2.1 レプリケーション形式">セクション17.2.1「レプリケーション形式」</a>を参照してください。 
    </p><p>
      レプリケーションおよび <code class="literal">InnoDB</code> に固有の追加情報については、<a class="xref" href="innodb-storage-engine.html#innodb-and-mysql-replication" title="15.19 InnoDB と MySQL レプリケーション">セクション15.19「InnoDB と MySQL レプリケーション」</a>を参照してください。 NDB Cluster でのレプリケーションに関する情報については、<a class="xref" href="mysql-cluster.html#mysql-cluster-replication" title="23.6 NDB Cluster レプリケーション">セクション23.6「NDB Cluster レプリケーション」</a> を参照してください。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-auto-increment"></a>17.5.1.1 レプリケーションと AUTO_INCREMENT</h4></div></div></div><a class="indexterm" name="idm46723648846864"></a><a class="indexterm" name="idm46723648844704"></a><a class="indexterm" name="idm46723648842640"></a><a class="indexterm" name="idm46723648840544"></a><a class="indexterm" name="idm46723648838480"></a><a class="indexterm" name="idm46723648836416"></a><p>
        <code class="literal">AUTO_INCREMENT</code>、<code class="literal">LAST_INSERT_ID()</code> および <code class="literal">TIMESTAMP</code> の値のステートメントベースのレプリケーションは、次の例外の対象となります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">AUTO_INCREMENT</code> カラムを更新するトリガーまたは関数を呼び出すステートメントは、ステートメントベースレプリケーションでは正しく複製されません。 これらのステートメントは安全でないとマークされます。 (Bug #45677) 
          </p></li><li class="listitem"><p>
            複合主キーを持ち、この複合キーの先頭カラムでない <code class="literal">AUTO_INCREMENT</code> カラムを含むテーブルに <code class="literal">INSERT</code> を実行することは、ステートメントベースロギングまたはレプリケーションにとって安全ではありません。 これらのステートメントは安全でないとマークされます。 (Bug #11754117、Bug #45670) 
          </p><p>
            この問題は <code class="literal">InnoDB</code> ストレージエンジンを使用するテーブルに影響しません。<a class="link" href="glossary.html#glos_auto_increment" title="自動インクリメント">AUTO_INCREMENT</a> カラムを持つ <code class="literal">InnoDB</code> テーブルには、自動インクリメントカラムが唯一または左端のカラムであるキーが少なくとも 1 つ必要であるためです。
          </p></li><li class="listitem"><p>
            <code class="literal">ALTER TABLE</code> を使用してテーブルに <code class="literal">AUTO_INCREMENT</code> カラムを追加すると、レプリカとソースで同じ順序で行が生成されない場合があります。 これが発生するのは、行が番号付けされる順序が、テーブルに使用される固有のストレージエンジンおよび行が挿入された順序に依存するためです。 ソースとレプリカで順序が同じであることが重要な場合は、<code class="literal">AUTO_INCREMENT</code> 番号を割り当てる前に行を順序付けする必要があります。 カラム <code class="literal">col1</code> と <code class="literal">col2</code> を持つテーブル <code class="literal">t1</code> に <code class="literal">AUTO_INCREMENT</code> カラムを追加するものと仮定すると、次のステートメントは <code class="literal">t1</code> と同じであるけれども <code class="literal">AUTO_INCREMENT</code> カラムを持つ新しいテーブル <code class="literal">t2</code> を生成します。 
          </p><pre class="programlisting">CREATE TABLE t2 LIKE t1;
ALTER TABLE t2 ADD id INT AUTO_INCREMENT PRIMARY KEY;
INSERT INTO t2 SELECT * FROM t1 ORDER BY col1, col2;
</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
              ソースとレプリカの両方で同じ順序を保証するには、<code class="literal">ORDER BY</code> 句で <code class="literal">t1</code> の <span class="emphasis"><em>all</em></span> カラムを指定する必要があります。
            </p></div><p>
            上記の指示には <code class="literal">CREATE TABLE ... LIKE</code> の制限が適用されます。外部キー定義は <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> テーブルオプションと同様に無視されます。 テーブル定義がこれらの特性を含む場合、<code class="literal">t1</code> の作成に使用したものと同じであるけれども <code class="literal">AUTO_INCREMENT</code> カラムを追加した <code class="literal">CREATE TABLE</code> ステートメントを使用して、<code class="literal">t2</code> を作成してください。 
          </p><p>
            <code class="literal">AUTO_INCREMENT</code> カラムを持つコピーを作成および移入するために使用する方法にかかわらず、最終手順は元のテーブルを削除してコピーの名前を変更することです。
          </p><pre class="programlisting">DROP t1;
ALTER TABLE t2 RENAME t1;
</pre><p>
            <a class="xref" href="error-handling.html#alter-table-problems" title="B.3.6.1 ALTER TABLE での問題">セクションB.3.6.1「ALTER TABLE での問題」</a>も参照してください。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-blackhole"></a>17.5.1.2 レプリケーションと BLACKHOLE テーブル</h4></div></div></div><a class="indexterm" name="idm46723648797024"></a><a class="indexterm" name="idm46723648795040"></a><a class="indexterm" name="idm46723648792864"></a><a class="indexterm" name="idm46723648790944"></a><p>
        <code class="literal">BLACKHOLE</code> ストレージエンジンはデータを受け入れますが、それを破棄し、格納しません。 バイナリロギングを実行するときは、使用しているロギング形式にかかわらず、このようなテーブルへのすべての挿入は常にログが記録されます。 更新と削除は、ステートメントベースまたは行ベースのどちらのロギングが使用されているかによって扱いが異なります。 ステートメントベースロギング形式では、<code class="literal">BLACKHOLE</code> テーブルに影響するすべてのステートメントのログが記録されますが、それらの影響は無視されます。 行ベースロギングを使用するときは、このようなテーブルへの更新と削除は単にスキップされ、バイナリログに書き込まれません。 これが発生するたびに警告がログに記録されます。 
      </p><p>
        このため、<code class="literal">BLACKHOLE</code> ストレージエンジンを使用してテーブルに複製するときは、<code class="literal">binlog_format</code> サーバー変数を <code class="literal">ROW</code> または <code class="literal">MIXED</code> ではなく <code class="literal">STATEMENT</code> に設定することをお勧めします。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-charset"></a>17.5.1.3 レプリケーションと文字セット</h4></div></div></div><a class="indexterm" name="idm46723648779456"></a><a class="indexterm" name="idm46723648777296"></a><p>
        次のことは、異なる文字セットを使用する MySQL サーバー間でのレプリケーションに適用されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ソースにグローバル <code class="literal">character_set_server</code> 値とは異なる文字セットのデータベースがある場合は、データベースのデフォルト文字セットに暗黙的に依存しないように <code class="literal">CREATE TABLE</code> ステートメントを設計する必要があります。 推奨される回避策は、<code class="literal">CREATE TABLE</code> ステートメントに明示的に文字セットと照合順序を指定することです。 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-checksum-table"></a>17.5.1.4 レプリケーションと CHECKSUM TABLE</h4></div></div></div><a class="indexterm" name="idm46723648768320"></a><a class="indexterm" name="idm46723648766112"></a><p>
        <code class="literal">CHECKSUM TABLE</code> は、テーブルの行の格納形式に依存する方法を使用して、行ごとに計算されるチェックサムを返します。 MySQL バージョン間で記憶域形式が同じであることは保証されないため、アップグレード後にチェックサム値が変更される可能性があります。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-create-alter-drop-server"></a>17.5.1.5 CREATE SERVER、ALTER SERVER、および DROP SERVER のレプリケーション</h4></div></div></div><p>
        使用されているバイナリロギング形式に関係なく、ステートメント <code class="literal">CREATE SERVER</code>、<code class="literal">ALTER SERVER</code>、および <code class="literal">DROP SERVER</code> はバイナリログに書き込まれません。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-create-if-not-exists"></a>17.5.1.6 CREATE ... IF NOT EXISTS ステートメントのレプリケーション</h4></div></div></div><a class="indexterm" name="idm46723648755488"></a><a class="indexterm" name="idm46723648753280"></a><p>
        MySQL は、さまざまな <code class="literal">CREATE ... IF NOT EXISTS</code> ステートメントが複製されるときにこれらの値を適用します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            データベースがソースにすでに存在するかどうかにかかわらず、すべての <code class="literal">CREATE DATABASE IF NOT EXISTS</code> ステートメントがレプリケートされます。
          </p></li><li class="listitem"><p>
            同様に、テーブルがソースにすでに存在するかどうかに関係なく、<code class="literal">SELECT</code> のないすべての <code class="literal">CREATE TABLE IF NOT EXISTS</code> ステートメントがレプリケートされます。 これは <code class="literal">CREATE TABLE IF NOT EXISTS ... LIKE</code> を含みます。 <code class="literal">CREATE TABLE IF NOT EXISTS ... SELECT</code> のレプリケーションは、多少異なるルールに従います。詳細については、<a class="xref" href="replication.html#replication-features-create-select" title="17.5.1.7 CREATE TABLE ... SELECT ステートメントのレプリケーション">セクション17.5.1.7「CREATE TABLE ... SELECT ステートメントのレプリケーション」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            ステートメントで指定されたイベントがソースにすでに存在するかどうかにかかわらず、<code class="literal">CREATE EVENT IF NOT EXISTS</code> は常にレプリケートされます。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-create-select"></a>17.5.1.7 CREATE TABLE ... SELECT ステートメントのレプリケーション</h4></div></div></div><a class="indexterm" name="idm46723648736176"></a><a class="indexterm" name="idm46723648734016"></a><p>
        MySQL では、<code class="literal">CREATE TABLE ... SELECT</code> ステートメントのレプリケート時に次のルールが適用されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CREATE TABLE ... SELECT</code> は常に暗黙的コミットを実行します (<a class="xref" href="sql-statements.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>)。
          </p></li><li class="listitem"><p>
            宛先テーブルが存在しない場合、ロギングは次のように行われます。 <code class="literal">IF NOT EXISTS</code> が存在するかどうかは重要ではありません。 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">STATEMENT</code> または <code class="literal">MIXED</code> 形式: ステートメントは、書き込まれたものとしてログに記録されます。
              </p></li><li class="listitem"><p>
                <code class="literal">ROW</code> 形式: ステートメントは、<code class="literal">CREATE TABLE</code> ステートメントおよび一連の行挿入イベントとしてログに記録されます。
              </p><p>
                MySQL 8.0.21 より前は、ステートメントは 2 つのトランザクションとしてログに記録されます。 MySQL 8.0.21 の時点では、アトミック DDL をサポートするストレージエンジンでは、1 つのトランザクションとしてログに記録されます。 詳細は、<a class="xref" href="sql-statements.html#atomic-ddl" title="13.1.1 アトミックデータ定義ステートメントのサポート">セクション13.1.1「アトミックデータ定義ステートメントのサポート」</a>を参照してください。 
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">CREATE TABLE ... SELECT</code> ステートメントが失敗した場合、何も記録されません。 これには、宛先テーブルが存在し、<code class="literal">IF NOT EXISTS</code> が指定されていないケースが含まれます。 
          </p></li><li class="listitem"><p>
            宛先テーブルが存在し、<code class="literal">IF NOT EXISTS</code> が指定されている場合、MySQL 8.0 はステートメントを完全に無視します。何も挿入または記録されません。
          </p></li></ul></div><p>
        MySQL 8.0 では、<code class="literal">CREATE TABLE ... SELECT</code> ステートメントで、ステートメントによって作成されたテーブル以外のテーブルを変更することはできません。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-current-user"></a>17.5.1.8 CURRENT_USER() のレプリケーション</h4></div></div></div><p>
        次のステートメントは、影響を受けるユーザーまたは定義者の名前 (場合によってはホスト) のかわりに <code class="literal">CURRENT_USER()</code> 関数の使用をサポートしています:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">DROP USER</code>
          </p></li><li class="listitem"><p>
            <code class="literal">RENAME USER</code>
          </p></li><li class="listitem"><p>
            <code class="literal">GRANT</code>
          </p></li><li class="listitem"><p>
            <code class="literal">REVOKE</code>
          </p></li><li class="listitem"><p>
            <code class="literal">CREATE FUNCTION</code>
          </p></li><li class="listitem"><p>
            <code class="literal">CREATE PROCEDURE</code>
          </p></li><li class="listitem"><p>
            <code class="literal">CREATE TRIGGER</code>
          </p></li><li class="listitem"><p>
            <code class="literal">CREATE EVENT</code>
          </p></li><li class="listitem"><p>
            <code class="literal">CREATE VIEW</code>
          </p></li><li class="listitem"><p>
            <code class="literal">ALTER EVENT</code>
          </p></li><li class="listitem"><p>
            <code class="literal">ALTER VIEW</code>
          </p></li><li class="listitem"><p>
            <code class="literal">SET PASSWORD</code>
          </p></li></ul></div><p>
        バイナリロギングが有効で、これらのステートメントのいずれかで <code class="literal">CURRENT_USER()</code> または <code class="literal">CURRENT_USER</code> が定義者として使用されている場合、MySQL Server はステートメントがレプリケートされるときに、ソースとレプリカの両方の同じユーザーにステートメントが適用されることを確認します。 場合によっては、パスワードを変更するステートメントなど、ステートメントにユーザー名が含まれるように、関数参照がバイナリログに書き込まれる前に展開されます。 他のすべての場合、ソースの現在のユーザーの名前はメタデータとしてレプリカにレプリケートされ、レプリカはレプリカの現在のユーザーではなく、メタデータで指定された現在のユーザーにステートメントを適用します。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-differing-tables"></a>17.5.1.9 ソースとレプリカで異なるテーブル定義を使用したレプリケーション</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-features-more-columns">17.5.1.9.1 ソースまたはレプリカにカラムが多いレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-different-data-types">17.5.1.9.2 データ型が異なるカラムのレプリケーション</a></span></dt></dl></div><a class="indexterm" name="idm46723648681088"></a><p>
        レプリケーションのソースおよびターゲットテーブルは同じである必要はありません。 ソース上のテーブルには、テーブルのレプリカコピーより多いカラムまたは少ないカラムを含めることができます。 また、ソースおよびレプリカ上の対応するテーブルのカラムでは、特定の条件に応じて異なるデータ型を使用できます。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          パーティション化が異なるテーブル間のレプリケーションはサポートされていません。 <a class="xref" href="replication.html#replication-features-partitioning" title="17.5.1.24 レプリケーションおよびパーティション化">セクション17.5.1.24「レプリケーションおよびパーティション化」</a>を参照してください。 
        </p></div><p>
        ソーステーブルとターゲットテーブルの定義が同じではない場合、データベースとテーブルの名前はソースとレプリカの両方で同じである必要があります。 次の 2 つのセクションで、追加条件について例を示して説明します。 
      </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="replication-features-more-columns"></a>17.5.1.9.1 ソースまたはレプリカにカラムが多いレプリケーション</h5></div></div></div><p>
          テーブルのソースコピーとレプリカコピーのカラム数が異なるように、次の条件に従ってソースからレプリカにテーブルをレプリケートできます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              両方のバージョンのテーブルに共通するカラムは、ソースとレプリカで同じ順序で定義する必要があります。 (これは、両方のテーブルのカラム数が同じ場合でも当てはまります。) 
            </p></li><li class="listitem"><p>
              両方のバージョンのテーブルに共通するカラムは、追加カラムの前に定義する必要があります。
            </p><p>
              これは、次の例に示すように、両方のテーブルに共通するカラムの範囲内のテーブルに新しいカラムが挿入されるレプリカで <code class="literal">ALTER TABLE</code> ステートメントを実行すると、レプリケーションが失敗することを意味します:
            </p><p>
              ソースおよびレプリカに存在するテーブル <code class="literal">t</code> が、次の <code class="literal">CREATE TABLE</code> ステートメントによって定義されているとします:
            </p><pre class="programlisting">CREATE TABLE t (
    c1 INT,
    c2 INT,
    c3 INT
);
</pre><p>
              ここに示す <code class="literal">ALTER TABLE</code> ステートメントがレプリカで実行されるとします:
            </p><pre class="programlisting">ALTER TABLE t ADD COLUMN cnew1 INT AFTER c3;
</pre><p>
              以前の <code class="literal">ALTER TABLE</code> はレプリカで許可されています。これは、両方のバージョンのテーブル <code class="literal">t</code> に共通のカラム <code class="literal">c1</code>、<code class="literal">c2</code> および <code class="literal">c3</code> が、異なるカラムの前に両方のバージョンのテーブルでグループ化されたままであるためです。
            </p><p>
              ただし、レプリケーションを中断させないかぎり、次の <code class="literal">ALTER TABLE</code> ステートメントはレプリカで実行できません:
            </p><pre class="programlisting">ALTER TABLE t ADD COLUMN cnew2 INT AFTER c2;
</pre><p>
              新しいカラム <code class="literal">cnew2</code> は両方のバージョンの <code class="literal">t</code> に共通のカラムの間にあるため、示されている <code class="literal">ALTER TABLE</code> ステートメントのレプリカでの実行後にレプリケーションが失敗します。
            </p></li><li class="listitem"><p>
              カラム数の多いバージョンのテーブルの<span class="quote">「<span class="quote">追加</span>」</span>カラムごとに、デフォルト値が必要です。
            </p><p>
              カラムのデフォルト値は、その型、<code class="literal">DEFAULT</code> オプションで定義されているかどうか、<code class="literal">NULL</code> として宣言されているかどうか、作成時に有効であったサーバー SQL モードなど、いくつかの要因で決まります。詳細については、<a class="xref" href="data-types.html#data-type-defaults" title="11.6 データ型デフォルト値">セクション11.6「データ型デフォルト値」</a>を参照してください)。
            </p></li></ul></div><p>
          また、テーブルのレプリカコピーにソースコピーよりも多くのカラムがある場合、テーブルに共通する各カラムは両方のテーブルで同じデータ型を使用する必要があります。
        </p><p><b>例. </b>
            次の例は、有効および無効なテーブル定義をいくつか示します。
          </p><p><b>ソースのその他のカラム. </b>
            次のテーブル定義は有効で、正しく複製されます。
          </p><pre class="programlisting">source&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);</code></strong>
replica&gt;  <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT);</code></strong>
</pre><p>
          次のテーブル定義では、両方のバージョンのテーブルに共通するカラムの定義がソースとは異なる順序でレプリカ上にあるため、エラーが発生します:
        </p><pre class="programlisting">source&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);</code></strong>
replica&gt;  <strong class="userinput"><code>CREATE TABLE t1 (c2 INT, c1 INT);</code></strong>
</pre><p>
          次のテーブル定義では、両方のバージョンのテーブルに共通するカラムの定義の前にソースの追加カラムの定義が表示されるため、エラーが発生します:
        </p><pre class="programlisting">source&gt; <strong class="userinput"><code>CREATE TABLE t1 (c3 INT, c1 INT, c2 INT);</code></strong>
replica&gt;  <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT);</code></strong>
</pre><p><b>レプリカのカラムが増えます. </b>
            次のテーブル定義は有効で、正しく複製されます。
          </p><pre class="programlisting">source&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT);</code></strong>
replica&gt;  <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);</code></strong>
                  </pre><p>
          次の定義では、両方のバージョンのテーブルに共通するカラムがソースとレプリカの両方で同じ順序で定義されていないため、エラーが発生します:
        </p><pre class="programlisting">source&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT);</code></strong>
replica&gt;  <strong class="userinput"><code>CREATE TABLE t1 (c2 INT, c1 INT, c3 INT);</code></strong>
</pre><p>
          レプリカバージョンのテーブルの追加カラムの定義は、両方のバージョンのテーブルに共通するカラムの定義の前に表示されるため、次のテーブル定義でもエラーが発生します:
        </p><pre class="programlisting">source&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT);</code></strong>
replica&gt;  <strong class="userinput"><code>CREATE TABLE t1 (c3 INT, c1 INT, c2 INT);</code></strong>
</pre><p>
          次のテーブル定義は、レプリカバージョンのテーブルにソースバージョンと比較して追加のカラムがあり、2 つのバージョンのテーブルで共通カラム <code class="literal">c2</code> に異なるデータ型が使用されているため、失敗します:
        </p><pre class="programlisting">source&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 BIGINT);</code></strong>
replica&gt;  <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);</code></strong>
</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="replication-features-different-data-types"></a>17.5.1.9.2 データ型が異なるカラムのレプリケーション</h5></div></div></div><a class="indexterm" name="idm46723648618960"></a><a class="indexterm" name="idm46723648616768"></a><a class="indexterm" name="idm46723648614688"></a><a class="indexterm" name="idm46723648612608"></a><p>
          ソース上の対応するカラムと同じテーブルのレプリカコピーは、同じデータ型であることが理想的です。 ただし、特定の条件が満たされているかぎり、これは必ずしも厳密には強制されません。 
        </p><p>
          通常、特定のデータ型のカラムから、同じサイズまたは幅 (該当する場合) またはそれ以上の同じ型の別のカラムにレプリケートできます。 たとえば、<code class="literal">CHAR(10)</code> カラムから別の <code class="literal">CHAR(10)</code> に、または <code class="literal">CHAR(10)</code> カラムから <code class="literal">CHAR(25)</code> カラムに、問題なく複製できます。 場合によっては、あるデータ型 (ソース上) を持つカラムから (レプリカ上の) 異なるデータ型を持つカラムにレプリケートすることもできます。ソースバージョンのカラムのデータ型がレプリカ上で同じサイズ以上の型に昇格される場合、これは<span class="firstterm">属性プロモーション</span>と呼ばれます。 
        </p><p>
          属性昇格は、ステートメントベースと行ベースの両方のレプリケーションで使用でき、ソースまたはレプリカで使用されるストレージエンジンには依存しません。 ただし、ロギング形式の選択は許可される型変換に影響します。詳細は、このセクションで後述します。 
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
            ステートメントベースまたは行ベースのレプリケーションのどちらを使用する場合でも、属性昇格を採用する場合は、テーブルのレプリカコピーにソースコピーより多くのカラムを含めることはできません。
          </p></div><p><b>ステートメントベースのレプリケーション. </b>
            ステートメントベースレプリケーションを使用する場合、従うべき簡単な経験則は<span class="quote">「<span class="quote">「ソースで実行されたステートメントもレプリカで正常に実行される場合は、正常にレプリケートする必要もあります」</span>」</span>です。 つまり、レプリカ上の特定のカラムの型と互換性のある値がステートメントで使用されている場合は、そのステートメントをレプリケートできます。 たとえば、<code class="literal">TINYINT</code> カラムに収まる任意の値を <code class="literal">BIGINT</code> カラムに挿入することもできます。テーブルのレプリカコピーの <code class="literal">TINYINT</code> カラムのタイプを <code class="literal">BIGINT</code> に変更した場合でも、成功したソースのそのカラムへの挿入もレプリカで成功する必要があります。これは、<code class="literal">BIGINT</code> カラムを超える有効な <code class="literal">TINYINT</code> 値を持つことができないためです。 
          </p><p><a name="replication-features-attribute-promotion"></a><b>行ベースレプリケーション: 属性の昇格と降格. </b>
            行ベースのレプリケーションでは、小さいデータ型と大きいデータ型の間の属性昇格および降格がサポートされています。 このセクションで後述するように、降格されるカラム値の不可逆 (切り捨て) または非不可逆変換を許可するかどうかを指定することもできます。 
          </p><p><b>不可逆および非不可逆変換. </b>
            ターゲット型が挿入される値を表現できない場合、変換をどのように扱うかについての決定が必要になります。 変換を許可するけれども、ターゲットカラムで<span class="quote">「<span class="quote">適合</span>」</span>を実現するためにソース値を切り捨てる (または変更する) 場合、<span class="firstterm">不可逆変換</span>と呼ばれることを行います。 ソースカラム値をターゲットカラムに適合させるために切り捨てまたは同様の変更を必要としない変換は、<span class="firstterm">非不可逆</span>変換です。 
          </p><p><b>型変換モード. </b>
            <code class="literal">slave_type_conversions</code> グローバルサーバー変数の設定によって、レプリカで使用される型変換モードが制御されます。 この変数は、レプリカタイプ変換動作に対する各モードの影響を説明する次のリストから一連の値を取得します: 
          </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"> ALL_LOSSY </span></dt><dd><p>
                このモードでは、情報の損失を意味する型変換が許可されます。
              </p><p>
                これは非不可逆変換が許可されることを暗示せず、不可逆変換を必要とするまたは変換をまったく必要としないケースのみが許可されることだけを暗示します。たとえば、このモード<span class="emphasis"><em>のみ</em></span>を有効にした場合、<code class="literal">INT</code> カラムが <code class="literal">TINYINT</code> に変換されること (不可逆変換) は許可されますが、<code class="literal">TINYINT</code> カラムが <code class="literal">INT</code> カラムに変換されること (非不可逆) は許可されません。 この場合、後者の変換を試みると、レプリカでエラーが発生してレプリケーションが停止します。 
              </p></dd><dt><span class="term"> ALL_NON_LOSSY </span></dt><dd><p>
                このモードは、ソース値の切り捨てまたは特別処理を必要とない変換を許可します。すなわち、ターゲット型の範囲がソース型より広い変換を許可します。
              </p><p>
                このモードを設定することは、不可逆変換が許可されるかどうかに関係ありません。これは <code class="literal">ALL_LOSSY</code> モードで制御されます。 <code class="literal">ALL_NON_LOSSY</code> のみが設定され、<code class="literal">ALL_LOSSY</code> は設定されていない場合、データ (<code class="literal">INT</code> から <code class="literal">TINYINT</code>、<code class="literal">CHAR(25)</code> から <code class="literal">VARCHAR(20)</code> など) が失われる原因となる変換を試みると、レプリカはエラーで停止します。 
              </p></dd><dt><span class="term"> ALL_LOSSY,ALL_NON_LOSSY </span></dt><dd><p>
                このモードが設定されると、サポートされるすべての型変換が、不可逆変換かどうかにかかわらず、許可されます。
              </p></dd><dt><span class="term"> ALL_SIGNED </span></dt><dd><p>
                昇格される整数型を符号付き値として扱います (デフォルト動作)。
              </p></dd><dt><span class="term"> ALL_UNSIGNED </span></dt><dd><p>
                昇格される整数型を符号なし値として扱います。
              </p></dd><dt><span class="term"> ALL_SIGNED,ALL_UNSIGNED </span></dt><dd><p>
                昇格される整数型を、可能な場合符号付きとして、そうでない場合は符号なしとして扱います。
              </p></dd><dt><span class="term"> [<span class="emphasis"><em>empty</em></span>] </span></dt><dd><p>
                <code class="literal">slave_type_conversions</code> が設定されていなときは、属性の昇格または降格は許可されません。これは、ソースおよびターゲットテーブル内のすべてのカラムが同じ型である必要があることを意味します。
              </p><p>
                このモードがデフォルトです。
              </p></dd></dl></div><p>
          整数型が昇格されるときに、符号ありか符号なしかは保持されません。 デフォルトでは、レプリカはこのような値をすべて符号付きとして扱います。 この動作は、<code class="literal">ALL_SIGNED</code>、<code class="literal">ALL_UNSIGNED</code>、またはその両方を使用して制御できます。 <code class="literal">ALL_SIGNED</code> は、昇格されたすべての整数型を符号付きとして処理するようレプリカに指示します。<code class="literal">ALL_UNSIGNED</code> は、これらを符号なしとして処理するように指示します。 両方を指定すると、レプリカは可能であれば値を符号付きとして処理し、それ以外の場合は符号なしとして処理します。リストされる順序は重要ではありません。 少なくとも <code class="literal">ALL_LOSSY</code> または <code class="literal">ALL_NONLOSSY</code> のいずれかが使用されていない場合は、<code class="literal">ALL_SIGNED</code> も <code class="literal">ALL_UNSIGNED</code> も効果を持ちません。 
        </p><p>
          タイプ変換モードを変更するには、新しい <code class="literal">slave_type_conversions</code> 設定でレプリカを再起動する必要があります。
        </p><p><b>サポートされる変換. </b>
            違うけれども似ているデータ型の間でサポートされる変換を次のリストに示します。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              整数型 <code class="literal">TINYINT</code>、<code class="literal">SMALLINT</code>、<code class="literal">MEDIUMINT</code>、<code class="literal">INT</code>、および <code class="literal">BIGINT</code> のいずれかの間。
            </p><p>
              これには、これらの型の符号付きおよび符号なしバージョンの間の変換が含まれます。
            </p><p>
              不可逆変換は、ソース値をターゲットカラムで許可される最大値 (または最小値) に切り捨てることで行われます。 符号なし型から符号付き型への変換時に非可逆変換を保証するには、ターゲットカラムがソースカラムの値の範囲を収容できる十分な大きさである必要があります。 たとえば、<code class="literal">TINYINT UNSIGNED</code> は、非不可逆に <code class="literal">SMALLINT</code> に降格できますが、<code class="literal">TINYINT</code> にはできません。 
            </p></li><li class="listitem"><p>
              小数点型 <code class="literal">DECIMAL</code>、<code class="literal">FLOAT</code>、<code class="literal">DOUBLE</code>、および <code class="literal">NUMERIC</code> のいずれかの間。
            </p><p>
              <code class="literal">FLOAT</code> から <code class="literal">DOUBLE</code> へは非不可逆変換です。<code class="literal">DOUBLE</code> から <code class="literal">FLOAT</code> へは不可逆にしか扱えません。 <code class="literal"><em class="replaceable"><code>D'</code></em> &gt;= <em class="replaceable"><code>D</code></em></code> および <code class="literal">(<em class="replaceable"><code>M'</code></em>-<em class="replaceable"><code>D'</code></em>) &gt;= (<em class="replaceable"><code>M</code></em>-<em class="replaceable"><code>D</code></em></code>) が非可逆的である <code class="literal">DECIMAL(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code> から <code class="literal">DECIMAL(<em class="replaceable"><code>M'</code></em>,<em class="replaceable"><code>D'</code></em>)</code> への変換。<code class="literal"><em class="replaceable"><code>M'</code></em> &lt; <em class="replaceable"><code>M</code></em></code>、<code class="literal"><em class="replaceable"><code>D'</code></em> &lt; <em class="replaceable"><code>D</code></em></code>、またはその両方の場合、不可逆変換のみ実行できます。 
            </p><p>
              いずれかの小数点型の場合、格納される値をターゲット型に適合させることができない場合は、このマニュアルのほかの場所でサーバーに定義される丸めルールに従って値が切り捨てられます。 小数点型でこれがどのように実行されるかについては、<a class="xref" href="functions.html#precision-math-rounding" title="12.25.4 丸め動作">セクション12.25.4「丸め動作」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              文字列型 <code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、および <code class="literal">TEXT</code> のいずれかの間 (異なる幅の間での変換を含む)。
            </p><p>
              <code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、または <code class="literal">TEXT</code> から、同じまたはそれより大きいサイズの <code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、または <code class="literal">TEXT</code> カラムへの変換は、決して不可逆ではありません。 不可逆変換は、レプリカに文字列の最初の <em class="replaceable"><code>N</code></em> 文字のみを挿入することで処理されます。ここで、<em class="replaceable"><code>N</code></em> はターゲットカラムの幅です。 
            </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
                異なる文字セットを使用するカラム間のレプリケーションはサポートされません。
              </p></div></li><li class="listitem"><p>
              バイナリデータ型 <code class="literal">BINARY</code>、<code class="literal">VARBINARY</code>、および <code class="literal">BLOB</code> のいずれかの間 (異なる幅の間での変換を含む)。
            </p><p>
              <code class="literal">BINARY</code>、<code class="literal">VARBINARY</code>、または <code class="literal">BLOB</code> から、同じまたはそれより大きいサイズの <code class="literal">BINARY</code>、<code class="literal">VARBINARY</code>、または <code class="literal">BLOB</code> カラムへの変換は、決して不可逆ではありません。 不可逆変換は、レプリカに文字列の最初の <em class="replaceable"><code>N</code></em> バイトのみを挿入することで処理されます。ここで、<em class="replaceable"><code>N</code></em> はターゲットカラムの幅です。 
            </p></li><li class="listitem"><p>
              任意の 2 つのサイズの任意の 2 つの <code class="literal">BIT</code> カラムの間。
            </p><p>
              <code class="literal">BIT(<em class="replaceable"><code>M</code></em>)</code> カラムからの値を <code class="literal">BIT(<em class="replaceable"><code>M'</code></em>)</code> カラムに挿入するときは (<code class="literal"><em class="replaceable"><code>M'</code></em> &gt; <em class="replaceable"><code>M</code></em></code>)、<code class="literal">BIT(<em class="replaceable"><code>M'</code></em>)</code> カラムの最上位ビットがクリアされ (ゼロに設定され)、<code class="literal">BIT(<em class="replaceable"><code>M</code></em>)</code> 値の <em class="replaceable"><code>M</code></em> ビットが <code class="literal">BIT(<em class="replaceable"><code>M'</code></em>)</code> カラムの最下位ビットとして設定されます。
            </p><p>
              ソース <code class="literal">BIT(<em class="replaceable"><code>M</code></em>)</code> カラムからの値をターゲット <code class="literal">BIT(<em class="replaceable"><code>M'</code></em>)</code> カラムに挿入するときは (<code class="literal"><em class="replaceable"><code>M'</code></em> &lt; <em class="replaceable"><code>M</code></em></code>)、<code class="literal">BIT(<em class="replaceable"><code>M'</code></em>)</code> カラムの可能な最大値が割り当てられます。つまり、<span class="quote">「<span class="quote">すべてが設定された</span>」</span>値がターゲットカラムに割り当てられます。
            </p></li></ul></div><p>
          前のリストにない型の間の変換は許可されません。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-directory"></a>17.5.1.10 レプリケーションと DIRECTORY テーブルオプション</h4></div></div></div><a class="indexterm" name="idm46723648481056"></a><a class="indexterm" name="idm46723648478896"></a><a class="indexterm" name="idm46723648476832"></a><a class="indexterm" name="idm46723648474736"></a><a class="indexterm" name="idm46723648472672"></a><p>
        ソースサーバーの <code class="literal">CREATE TABLE</code> ステートメントで <code class="literal">DATA DIRECTORY</code> または <code class="literal">INDEX DIRECTORY</code> テーブルオプションが使用されている場合は、レプリカでもテーブルオプションが使用されます。 これにより、対応するディレクトリがレプリカホストファイルシステムに存在しない場合、または存在するがレプリカ MySQL サーバーにアクセスできない場合に問題が発生する可能性があります。 これをオーバーライドするには、レプリカで <code class="literal">NO_DIR_IN_CREATE</code> サーバーの SQL モードを使用します。これにより、<code class="literal">CREATE TABLE</code> ステートメントのレプリケート時にレプリカで <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> テーブルオプションが無視されます。 その結果、テーブルのデータベースディレクトリ内に <code class="literal">MyISAM</code> データおよびインデックスファイルが作成されます。 
      </p><p>
        詳細は、<a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-drop-if-exists"></a>17.5.1.11 DROP ... IF EXISTS ステートメントのレプリケーション</h4></div></div></div><a class="indexterm" name="idm46723648459056"></a><a class="indexterm" name="idm46723648456928"></a><p>
        削除するデータベース、テーブルまたはビューがソースに存在しない場合でも、<code class="literal">DROP DATABASE IF EXISTS</code>、<code class="literal">DROP TABLE IF EXISTS</code> および <code class="literal">DROP VIEW IF EXISTS</code> ステートメントは常にレプリケートされます。 これは、レプリカがソースでキャッチアップされた後、削除するオブジェクトがソースまたはレプリカに存在しなくなるようにするためです。 
      </p><p>
        ストアドプログラム (ストアドプロシージャとストアドファンクション、トリガーおよびイベント) の <code class="literal">DROP ... IF EXISTS</code> ステートメントも、削除するストアドプログラムがソースに存在しない場合でもレプリケートされます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-floatvalues"></a>17.5.1.12 レプリケーションと浮動小数点値</h4></div></div></div><a class="indexterm" name="idm46723648446992"></a><a class="indexterm" name="idm46723648444816"></a><p>
        ステートメントベースレプリケーションでは、値は 10 進からバイナリに変換されます。 それらの表現を 10 進とバイナリの間で変換すると近似値になる場合があるため、浮動小数点値を含む比較が不正確になります。 これは、浮動小数点値を明示的に使用したり、浮動小数点に暗黙的に変換された値を使用したりする演算に当てはまります。 浮動小数点値を比較すると、コンピュータアーキテクチャ、MySQL の構築に使用されるコンパイラなどが異なるため、ソースサーバーとレプリカサーバーで異なる結果が生じる可能性があります。 <a class="xref" href="functions.html#type-conversion" title="12.3 式評価での型変換">セクション12.3「式評価での型変換」</a>および<a class="xref" href="error-handling.html#problems-with-float" title="B.3.4.8 浮動小数点値に関する問題">セクションB.3.4.8「浮動小数点値に関する問題」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-flush"></a>17.5.1.13 レプリケーションと FLUSH</h4></div></div></div><a class="indexterm" name="idm46723648438240"></a><a class="indexterm" name="idm46723648436096"></a><p>
        レプリカにレプリケートすると問題が発生する可能性があるため、一部の形式の <code class="literal">FLUSH</code> ステートメントはログに記録されません: <code class="literal">FLUSH LOGS</code> および <code class="literal">FLUSH TABLES WITH READ LOCK</code>。 構文例は、<a class="xref" href="sql-statements.html#flush" title="13.7.8.3 FLUSH ステートメント">セクション13.7.8.3「FLUSH ステートメント」</a>を参照してください。 <code class="literal">FLUSH TABLES</code>, <code class="literal">ANALYZE TABLE</code>, <code class="literal">OPTIMIZE TABLE</code> および <code class="literal">REPAIR TABLE</code> ステートメントはバイナリログに書き込まれるため、複製に複製されます。 これらのステートメントはテーブルデータを変更しないため、通常は問題ではありません。 
      </p><p>
        ただし、ある状況では、この動作が問題になる場合があります。 <code class="literal">mysql</code> データベースで権限テーブルをレプリケートし、<code class="literal">GRANT</code> を使用せずにそれらのテーブルを直接更新する場合は、レプリカで <code class="literal">FLUSH PRIVILEGES</code> を発行して新しい権限を有効にする必要があります。 また、<code class="literal">MERGE</code> テーブルの一部である <code class="literal">MyISAM</code> テーブルの名前を変更するときに <code class="literal">FLUSH TABLES</code> を使用する場合は、レプリカに対して <code class="literal">FLUSH TABLES</code> を手動で発行する必要があります。 <code class="literal">NO_WRITE_TO_BINLOG</code> またはそのエイリアスの <code class="literal">LOCAL</code> を指定しない場合、これらのステートメントはバイナリログに書き込まれます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-functions"></a>17.5.1.14 レプリケーションとシステム関数</h4></div></div></div><a class="indexterm" name="idm46723648414864"></a><a class="indexterm" name="idm46723648412736"></a><p>
        一部の関数は条件によっては適切に複製されません。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">USER()</code>、<code class="literal">CURRENT_USER()</code> (または <code class="literal">CURRENT_USER</code>)、<code class="literal">UUID()</code>、<code class="literal">VERSION()</code> および <code class="literal">LOAD_FILE()</code> 関数は変更なしでレプリケートされるため、行ベースのレプリケーションが有効になっていないかぎり、レプリカで確実に動作しません。 (<a class="xref" href="replication.html#replication-formats" title="17.2.1 レプリケーション形式">セクション17.2.1「レプリケーション形式」</a>を参照してください。) 
          </p><p>
            <code class="literal">USER()</code> および <code class="literal">CURRENT_USER()</code> は、<code class="literal">MIXED</code> モード使用時に行ベースレプリケーションを使用して自動的に複製され、<code class="literal">STATEMENT</code> モードでは警告を生成します。 (<a class="xref" href="replication.html#replication-features-current-user" title="17.5.1.8 CURRENT_USER() のレプリケーション">セクション17.5.1.8「CURRENT_USER() のレプリケーション」</a>も参照してください。) これは、<code class="literal">VERSION()</code> および <code class="literal">RAND()</code> にも当てはまります。 
          </p></li><li class="listitem"><p>
            <code class="literal">NOW()</code> の場合、バイナリログはタイムスタンプを含みます。 これは、値<span class="emphasis"><em>ソースでこの関数を呼び出したときに返されます</em></span>がレプリカにレプリケートされることを意味します。 異なるタイムゾーンの MySQL サーバー間でレプリケートするときに予期しない結果が発生しないようにするには、ソースとレプリカの両方でタイムゾーンを設定します。 詳細は、<a class="xref" href="replication.html#replication-features-timezone" title="17.5.1.33 レプリケーションとタイムゾーン">セクション17.5.1.33「レプリケーションとタイムゾーン」</a>を参照してください。 
          </p><p>
            異なるタイムゾーンのサーバー間でレプリケートする際の潜在的な問題を説明するために、ソースがニューヨークにあり、レプリカがストックホルムにあり、両方のサーバーがローカル時間を使用しているとします。 さらに、次に示すように、ソースでテーブル <code class="literal">mytable</code> を作成し、このテーブルに対して <code class="literal">INSERT</code> ステートメントを実行し、テーブルから選択するとします: 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE mytable (mycol TEXT);</code></strong>
Query OK, 0 rows affected (0.06 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO mytable VALUES ( NOW() );</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM mytable;</code></strong>
+---------------------+
| mycol               |
+---------------------+
| 2009-09-01 12:00:00 |
+---------------------+
1 row in set (0.00 sec)
</pre><p>
            ストックホルムの現地時間はニューヨークより 6 時間遅れているため、その瞬間にレプリカで <code class="literal">SELECT NOW()</code> を発行すると、値 <code class="literal">2009-09-01 18:00:00</code> が返されます。 このため、表示された <code class="literal">CREATE TABLE</code> および <code class="literal">INSERT</code> ステートメントがレプリケートされた後に、<code class="literal">mytable</code> のレプリカコピーから選択した場合、<code class="literal">mycol</code> に <code class="literal">2009-09-01 18:00:00</code> という値が含まれている可能性があります。 ただし、これは当てはまりません。<code class="literal">mytable</code> のレプリカコピーから選択すると、ソースとまったく同じ結果が得られます: 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM mytable;</code></strong>
+---------------------+
| mycol               |
+---------------------+
| 2009-09-01 12:00:00 |
+---------------------+
1 row in set (0.00 sec)
</pre><p>
            <code class="literal">SYSDATE()</code> 関数は、<code class="literal">NOW()</code> とは異なり、レプリケーションに安全ではありません。バイナリログ内で <code class="literal">SET TIMESTAMP</code> ステートメントに影響されず、ステートメントベースロギングが使用される場合は非決定的であるためです。 行ベースロギングを使用する場合は、これは問題ではありません。 
          </p><p>
            ほかの方法は <code class="option">--sysdate-is-now</code> オプションを使用することで、<code class="literal">SYSDATE()</code> が <code class="literal">NOW()</code> のエイリアスになります。 これは、ソースおよびレプリカで正しく機能するために必要です。 このような場合でも、この関数によって警告が発行されますが、<code class="option">--sysdate-is-now</code> がソースとレプリカの両方で使用されているかぎり、無視しても問題ありません。 
          </p><p>
            <code class="literal">SYSDATE()</code> は、<code class="literal">MIXED</code> モードの使用時に行ベースのレプリケーションを使用して自動的にレプリケートされ、<code class="literal">STATEMENT</code> モードで警告を生成します。
          </p><p>
            <a class="xref" href="replication.html#replication-features-timezone" title="17.5.1.33 レプリケーションとタイムゾーン">セクション17.5.1.33「レプリケーションとタイムゾーン」</a>も参照してください。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>次の制限は、ステートメントベースレプリケーションにのみ適用され、行ベースレプリケーションには適用されません。</em></span> ユーザーレベルのロックを処理する <code class="literal">GET_LOCK()</code>, <code class="literal">RELEASE_LOCK()</code>, <code class="literal">IS_FREE_LOCK()</code> および <code class="literal">IS_USED_LOCK()</code> 関数は、ソース上の同時実行性コンテキストを認識していないレプリカでレプリケートされます。 したがって、レプリカ上のコンテンツが異なるため、これらの関数を使用してソーステーブルに挿入しないでください。 たとえば、<code class="literal">INSERT INTO mytable VALUES(GET_LOCK(...))</code> などのステートメントを発行しないでください。 
          </p><p>
            これらの関数は、<code class="literal">MIXED</code> モード使用時に行ベースレプリケーションを使用して自動的に複製され、<code class="literal">STATEMENT</code> モードで警告を生成します。
          </p></li></ul></div><p>
        ステートメントベースレプリケーションが有効のときに前述の制限に対する回避策として、問題のある関数結果をユーザー変数に保存して、後続のステートメントでその変数を参照する方法を使用できます。 たとえば、次の単一行 <code class="literal">INSERT</code> は、<code class="literal">UUID()</code> 関数を参照するため問題があります。 
      </p><pre class="programlisting">INSERT INTO t VALUES(UUID());
</pre><p>
        この問題を回避するには、代わりにこれを実行してください。
      </p><pre class="programlisting">SET @my_uuid = UUID();
INSERT INTO t VALUES(@my_uuid);
</pre><p>
        このステートメントの連続は複製されます。<code class="literal">@my_uuid</code> の値が <code class="literal">INSERT</code> ステートメントの前にユーザー変数イベントとしてバイナリログに格納されて <code class="literal">INSERT</code> で使用できるためです。
      </p><p>
        同じ概念が複数行挿入に適用されますが、使用するのが面倒です。 2 行挿入の場合、このようにできます。 
      </p><pre class="programlisting">SET @my_uuid1 = UUID(); @my_uuid2 = UUID();
INSERT INTO t VALUES(@my_uuid1),(@my_uuid2);
</pre><p>
        ただし、行数が多いか不明の場合、この回避策は困難であるか実用的でありません。 たとえば、次のステートメントを個々のユーザー変数が各行に関連付けられているものに変換することはできません。 
      </p><pre class="programlisting">INSERT INTO t2 SELECT UUID(), * FROM t1;
</pre><p>
        ストアドファンクション内で、<code class="literal">RAND()</code> は、関数の実行中に 1 回だけ呼び出されるかぎり、正しく複製されます。 (関数実行タイムスタンプおよび乱数シードは、ソースとレプリカで同一の暗黙的な入力とみなすことができます。) 
      </p><p>
        <code class="literal">FOUND_ROWS()</code> と <code class="literal">ROW_COUNT()</code> 関数がステートメントベースレプリケーションを使用して複製されるときは、信頼性がありません。 回避策は、関数呼び出しの結果をユーザー変数に格納してから、<code class="literal">INSERT</code> ステートメントでこれを使用することです。 たとえば、<code class="literal">mytable</code> という名前のテーブルに結果を格納する場合は、普通は次のように実行するかもしれません。 
      </p><pre class="programlisting">SELECT SQL_CALC_FOUND_ROWS FROM mytable LIMIT 1;
INSERT INTO mytable VALUES( FOUND_ROWS() );
</pre><p>
        しかし、<code class="literal">mytable</code> を複製する場合は、次のように <code class="literal">SELECT ... INTO</code> を使用してから変数をテーブルに格納することをお勧めします。
      </p><pre class="programlisting">SELECT SQL_CALC_FOUND_ROWS INTO @found_rows FROM mytable LIMIT 1;
INSERT INTO mytable VALUES(@found_rows);
</pre><p>
        このように、ユーザー変数はコンテキストの一部としてレプリケートされ、レプリカに正しく適用されます。
      </p><p>
        これらの関数は、<code class="literal">MIXED</code> モード使用時に行ベースレプリケーションを使用して自動的に複製され、<code class="literal">STATEMENT</code> モードで警告を生成します。 (Bug #12092、Bug #30244) 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-fractional-seconds"></a>17.5.1.15 レプリケーションと小数秒サポート</h4></div></div></div><a class="indexterm" name="idm46723648325040"></a><a class="indexterm" name="idm46723648322896"></a><p>
        MySQL 8.0 では、最大マイクロ秒 (6 桁) の精度で <code class="literal">TIME</code>、<code class="literal">DATETIME</code> および <code class="literal">TIMESTAMP</code> 値の小数秒が許可されます。 <a class="xref" href="data-types.html#fractional-seconds" title="11.2.6 時間値での小数秒">セクション11.2.6「時間値での小数秒」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-invoked"></a>17.5.1.16 呼び出される機能のレプリケーション</h4></div></div></div><a class="indexterm" name="idm46723648315280"></a><a class="indexterm" name="idm46723648313152"></a><a class="indexterm" name="idm46723648311024"></a><a class="indexterm" name="idm46723648308928"></a><a class="indexterm" name="idm46723648306864"></a><a class="indexterm" name="idm46723648304768"></a><a class="indexterm" name="idm46723648302672"></a><p>
        ユーザー定義関数 (UDF) やストアドプログラム (ストアドプロシージャーと関数、トリガー、およびイベント) などの呼び出される機能のレプリケーションには、次の特徴があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            機能の影響は常に複製されます。
          </p></li><li class="listitem"><p>
            次のステートメントはステートメントベースレプリケーションを使用して複製されます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">CREATE EVENT</code>
              </p></li><li class="listitem"><p>
                <code class="literal">ALTER EVENT</code>
              </p></li><li class="listitem"><p>
                <code class="literal">DROP EVENT</code>
              </p></li><li class="listitem"><p>
                <code class="literal">CREATE PROCEDURE</code>
              </p></li><li class="listitem"><p>
                <code class="literal">DROP PROCEDURE</code>
              </p></li><li class="listitem"><p>
                <code class="literal">CREATE FUNCTION</code>
              </p></li><li class="listitem"><p>
                <code class="literal">DROP FUNCTION</code>
              </p></li><li class="listitem"><p>
                <code class="literal">CREATE TRIGGER</code>
              </p></li><li class="listitem"><p>
                <code class="literal">DROP TRIGGER</code>
              </p></li></ul></div><p>
            ただし、これらのステートメントを使用して作成、変更、または削除される機能の<span class="emphasis"><em>影響</em></span>は、行ベースレプリケーションを使用して複製されます。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              呼び出される機能をステートメントベースレプリケーションを使用して複製しようとすると、警告が生成されます: <span class="errortext">Statement is not safe to log in statement format</span>。 たとえば、ステートメントベースプリケーションで UDF を複製しようとすると、MySQL サーバーは現在 UDF が決定的かどうかを判断できないため、この警告が生成されます。 呼び出される機能の影響が決定的であることを確実にわかっている場合は、このような警告を安全に無視できます。 
            </p></div></li><li class="listitem"><p>
            <a class="indexterm" name="idm46723648277504"></a> <a class="indexterm" name="idm46723648275328"></a> <a class="indexterm" name="idm46723648273264"></a> <a class="indexterm" name="idm46723648271168"></a><code class="literal">CREATE EVENT</code> および <code class="literal">ALTER EVENT</code> の場合:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                イベントのステータスは、指定された状態に関係なくレプリカ上で <code class="literal">SLAVESIDE_DISABLED</code> に設定されます (これは <code class="literal">DROP EVENT</code> には適用されません)。
              </p></li><li class="listitem"><p>
                イベントが作成されたソースは、レプリカ上でそのサーバー ID によって識別されます。 <code class="literal">INFORMATION_SCHEMA.EVENTS</code> の <code class="literal">ORIGINATOR</code> カラムには、この情報が格納されます。 詳細は、<a class="xref" href="information-schema.html#information-schema-events-table" title="26.14 INFORMATION_SCHEMA EVENTS テーブル">セクション26.14「INFORMATION_SCHEMA EVENTS テーブル」</a>および<a class="xref" href="sql-statements.html#show-events" title="13.7.7.18 SHOW EVENTS ステートメント">セクション13.7.7.18「SHOW EVENTS ステートメント」</a>を参照してください。 
              </p></li></ul></div></li><li class="listitem"><p>
            機能実装は、ソースに障害が発生した場合にイベント処理を失うことなくレプリカをソースとして使用できるように、更新可能な状態のレプリカに存在します。
          </p></li></ul></div><p>
        (ソースとして機能していた) 別のサーバーで作成されたスケジュール済イベントが MySQL サーバーにあるかどうかを確認するには、次に示すような方法で <code class="literal">INFORMATION_SCHEMA.EVENTS</code> テーブルをクエリーします:
      </p><pre class="programlisting">SELECT EVENT_SCHEMA, EVENT_NAME
    FROM INFORMATION_SCHEMA.EVENTS
    WHERE STATUS = 'SLAVESIDE_DISABLED';
</pre><p>
        また、<code class="literal">SHOW EVENTS</code> ステートメントを次のように使用できます。
      </p><pre class="programlisting">SHOW EVENTS
    WHERE STATUS = 'SLAVESIDE_DISABLED';
</pre><p>
        このようなイベントを持つレプリカをソースに昇格する場合は、<code class="literal">ALTER EVENT <em class="replaceable"><code>event_name</code></em> ENABLE</code> を使用して各イベントを有効にする必要があります。ここで、<em class="replaceable"><code>event_name</code></em> はイベントの名前です。
      </p><p>
        このレプリカでのイベントの作成に複数のソースが関与しており、サーバー ID <em class="replaceable"><code>source_id</code></em> を持つ特定のソースでのみ作成されたイベントを識別する場合は、次に示すように、<code class="literal">EVENTS</code> テーブルで前のクエリーを変更して <code class="literal">ORIGINATOR</code> カラムを含めます:
      </p><pre class="programlisting">SELECT EVENT_SCHEMA, EVENT_NAME, ORIGINATOR
    FROM INFORMATION_SCHEMA.EVENTS
    WHERE STATUS = 'SLAVESIDE_DISABLED'
    AND   ORIGINATOR = '<em class="replaceable"><code>source_id</code></em>'
</pre><p>
        同じような方法で <code class="literal">SHOW EVENTS</code> ステートメントで <code class="literal">ORIGINATOR</code> を使用できます。
      </p><pre class="programlisting">SHOW EVENTS
    WHERE STATUS = 'SLAVESIDE_DISABLED'
    AND   ORIGINATOR = '<em class="replaceable"><code>source_id</code></em>'
</pre><p>
        ソースからレプリケートされたイベントを有効にする前に、(<code class="literal">SET GLOBAL event_scheduler = OFF;</code>などのステートメントを使用して) レプリカで MySQL イベントスケジューラを無効にし、必要な <code class="literal">ALTER EVENT</code> ステートメントを実行してサーバーを再起動してから、(<code class="literal">SET GLOBAL event_scheduler = ON;</code>などのステートメントを使用して) レプリカでイベントスケジューラを再度有効にする必要があります
      </p><p>
        後で新しいソースをレプリカに後退させる場合は、<code class="literal">ALTER EVENT</code> ステートメントで有効になっているすべてのイベントを手動で無効にする必要があります。 これは、前に示した <code class="literal">SELECT</code> ステートメントからのイベントの名前を別個のテーブルに格納するか、<code class="literal">ALTER EVENT</code> ステートメントを使用してイベントを識別する共通プリフィクス ( <code class="literal">replicated_</code> など) でそれらの名前を変更することで、行うことができます。 
      </p><p>
        イベントの名前を変更した場合、このサーバーをレプリカに後退させるときに、次に示すように <code class="literal">EVENTS</code> テーブルをクエリーしてイベントを識別できます:
      </p><pre class="programlisting">SELECT CONCAT(EVENT_SCHEMA, '.', EVENT_NAME) AS 'Db.Event'
      FROM INFORMATION_SCHEMA.EVENTS
      WHERE INSTR(EVENT_NAME, 'replicated_') = 1;
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-json"></a>17.5.1.17 JSON ドキュメントのレプリケーション</h4></div></div></div><p>
        MySQL 8.0 より前は、JSON カラムへの更新は常に完全なドキュメントとしてバイナリログに書き込まれていました。 MySQL 8.0 では、JSON ドキュメントへの部分的な更新をログに記録できます (<a class="xref" href="data-types.html#json-partial-updates" title="JSON 値の部分更新">JSON 値の部分更新</a> を参照)。これはより効率的です。 ロギングの動作は、次に説明するように、使用する形式によって異なります: 
      </p><p><b>ステートメントベースのレプリケーション. </b>
          JSON 部分更新は、常に部分更新として記録されます。 ステートメントベースのロギングを使用している場合は、これを無効にできません。 
        </p><p><b>行ベースのレプリケーション. </b>
          JSON 部分更新は、デフォルトではログに記録されませんが、完全なドキュメントとして記録されます。 部分更新のロギングを有効にするには、<code class="literal">binlog_row_value_options=PARTIAL_JSON</code> を設定します。 レプリケーションソースにこの変数が設定されている場合、そのソースから受信された部分更新は、その変数のレプリカ自体の設定に関係なく、レプリカによって処理および適用されます。 
        </p><p>
        MySQL 8.0.2 以前を実行しているサーバーは、JSON 部分更新に使用されるログイベントを認識しません。 このため、MySQL 8.0.3 以降を実行しているサーバーからこのようなサーバーにレプリケートする場合は、この変数を<code class="literal">''</code> (空の文字列) に設定して、ソースで <code class="literal">binlog_row_value_options</code> を無効にする必要があります。 詳細は、この変数の説明を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-limit"></a>17.5.1.18 レプリケーションと LIMIT</h4></div></div></div><a class="indexterm" name="idm46723648218064"></a><a class="indexterm" name="idm46723648215888"></a><p>
        <code class="literal">DELETE</code>、<code class="literal">UPDATE</code>、および <code class="literal">INSERT ... SELECT</code> ステートメント内の <code class="literal">LIMIT</code> 句のステートメントベースレプリケーションは、影響を受ける行の順序が未定義のため、安全ではありません。 (このようなステートメントは、<code class="literal">ORDER BY</code> 句も含んでいる場合にのみ、ステートメントベースレプリケーションで正しく複製できます。) このようなステートメントに遭遇したときは: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">STATEMENT</code> モード使用時は、このステートメントがステートメントベースレプリケーションで安全でないという警告が発行されるようになりました。
          </p><p>
            <code class="literal">STATEMENT</code> モードを使用している場合、<code class="literal">LIMIT</code> を含む DML ステートメントには、<code class="literal">ORDER BY</code> 句も含まれていても警告が発行されます (決定論的に行われます)。 これは既知の問題です。 (Bug #42851) 
          </p></li><li class="listitem"><p>
            <code class="literal">MIXED</code> モード使用時は、このステートメントは行ベースモードを使用して自動的に複製されるようになりました。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-load-data"></a>17.5.1.19 レプリケーションと LOAD DATA</h4></div></div></div><a class="indexterm" name="idm46723648199760"></a><a class="indexterm" name="idm46723648197584"></a><p>
        <code class="literal">LOAD DATA</code> はステートメントベースのロギングで安全でないとみなされます (を参照してください <a class="xref" href="replication.html#replication-rbr-safe-unsafe" title="17.2.1.3 バイナリロギングでの安全および安全でないステートメントの判断">セクション17.2.1.3「バイナリロギングでの安全および安全でないステートメントの判断」</a>). <code class="literal">binlog_format=MIXED</code> が設定されている場合、ステートメントは行ベースの形式で記録されます。 <code class="literal">binlog_format=STATEMENT</code> が設定されている場合、他の安全でないステートメントとは異なり、<code class="literal">LOAD DATA</code> では警告が生成されないことに注意してください。 
      </p><p>
        <code class="literal">binlog_format=STATEMENT</code> が設定されているときに <code class="literal">LOAD DATA</code> を使用すると、変更が適用されるレプリカにデータを含む一時ファイルが作成されます。 次に、レプリカは <code class="literal">LOAD DATA INFILE</code> ステートメントを使用して変更を適用します。 バイナリログの暗号化がサーバー上でアクティブな場合、この一時ファイルは暗号化されないことに注意してください。 暗号化が必要な場合は、一時ファイルを作成しない行ベースまたは混合バイナリロギング形式を使用してください。 
      </p><p>
        レプリケーションチャネルの保護に <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントが使用されている場合 (<a class="xref" href="replication.html#replication-privilege-checks" title="17.3.3 レプリケーション権限チェック">セクション17.3.3「レプリケーション権限チェック」</a> を参照)、行ベースのバイナリロギング (<code class="literal">binlog_format=ROW</code>) を使用して <code class="literal">LOAD DATA</code> 操作をログに記録することを強くお薦めします。 チャネルに <code class="literal">REQUIRE_ROW_FORMAT</code> が設定されている場合は、行ベースのバイナリロギングが必要です。 このロギング形式では、イベントの実行に <code class="literal">FILE</code> 権限は必要ないため、<code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントにこの権限を付与しないでください。 ステートメント形式で記録された <code class="literal">LOAD DATA INFILE</code> 操作に関連するレプリケーションエラーからリカバリする必要があり、レプリケートされたイベントが信頼できる場合は、<code class="literal">FILE</code> 権限を <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントに一時的に付与し、レプリケートされたイベントの適用後に削除できます。 
      </p><p>
        <span class="command"><strong>mysqlbinlog</strong></span> がステートメントベースの形式で記録された <code class="literal">LOAD DATA</code> ステートメントのログイベントを読み取ると、生成されたローカルファイルが一時ディレクトリに作成されます。 これらの一時ファイルは、<span class="command"><strong>mysqlbinlog</strong></span> およびその他のどの MySQL プログラムによっても自動的に削除されません。 ステートメントベースのバイナリロギングで <code class="literal">LOAD DATA</code> ステートメントを使用する場合は、ステートメントログが不要になったあとに一時ファイルを自分で削除するようにしてください。 詳細は、<a class="xref" href="programs.html#mysqlbinlog" title="4.6.8 mysqlbinlog — バイナリログファイルを処理するためのユーティリティー">セクション4.6.8「mysqlbinlog — バイナリログファイルを処理するためのユーティリティー」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-max-allowed-packet"></a>17.5.1.20 レプリケーションと max_allowed_packet</h4></div></div></div><a class="indexterm" name="idm46723648168576"></a><a class="indexterm" name="idm46723648166448"></a><p>
        <code class="literal">max_allowed_packet</code> は、MySQL サーバーとクライアント間の単一のメッセージ (レプリカを含む) のサイズに上限を設定します。 大規模なカラム値 (<code class="literal">TEXT</code> または <code class="literal">BLOB</code> カラムにある可能性がある) をレプリケートしていて、<code class="literal">max_allowed_packet</code> がソース上で小さすぎる場合、ソースはエラーで失敗し、レプリカはレプリケーション I/O スレッドを停止します。 レプリカ上の <code class="literal">max_allowed_packet</code> が小さすぎると、レプリカは I/O スレッドを停止します。 
      </p><p>
        現在、行ベースのレプリケーションでは、更新によって実際に変更されなかったカラムの値を含め、更新された行のすべてのカラムおよびカラムの値がソースからレプリカに送信されます。 これは、行ベースレプリケーションを使用して大きなカラム値を複製するときに、複製されるテーブル内でもっとも大きい行を格納できるだけの大きさに <code class="literal">max_allowed_packet</code> を設定するように気をつける必要があります (更新だけを複製したり、比較的小さい値だけを挿入したりする場合でも)。 
      </p><p>
        マルチスレッドレプリカ (<code class="literal">slave_parallel_workers &gt; 0</code> を使用) では、<code class="literal">slave_pending_jobs_size_max</code> システム変数がソースの <code class="literal">max_allowed_packet</code> システム変数の設定以上の値に設定されていることを確認します。 <code class="literal">slave_pending_jobs_size_max</code> のデフォルト設定 128M は、<code class="literal">max_allowed_packet</code> のデフォルト設定の 64M の 2 倍です。<code class="literal">max_allowed_packet</code> は、ソースが送信できるパケットサイズを制限しますが、イベントヘッダーを追加すると、このサイズを超えるバイナリログイベントを生成できます。 また、行ベースのレプリケーションでは、<code class="literal">max_allowed_packet</code> の値によってテーブルの各カラムのみが制限されるため、単一のイベントが <code class="literal">max_allowed_packet</code> サイズより大幅に大きくなる可能性があります。 
      </p><p>
        レプリカは、<code class="literal">slave_max_allowed_packet</code> 設定で設定された制限までパケットを実際に受け入れます。これは、大きなパケットによるレプリケーションの失敗を防ぐために、デフォルトで最大設定の 1GB に設定されています。 ただし、<code class="literal">slave_pending_jobs_size_max</code> の値によって、受信パケットを保持するためにレプリカで使用可能になるメモリーが制御されます。 指定されたメモリーは、すべてのレプリカワーカーキュー間で共有されます。 
      </p><p>
        <code class="literal">slave_pending_jobs_size_max</code> の値は弱い制限であり、非常に大きなイベント (1 つまたは複数のパケットで構成される) がこのサイズを超えると、トランザクションはすべてのレプリカワーカーが空のキューを持つまで保持されてから処理されます。 後続のすべてのトランザクションは、大規模なトランザクションが完了するまで保持されます。 そのため、<code class="literal">slave_pending_jobs_size_max</code> より大きい異常なイベントを処理できますが、すべてのレプリカワーカーのキューをクリアする遅延および後続のトランザクションをキューに入れる待機によってレプリカが遅れ、レプリカワーカーの同時実行性が低下する可能性があります。そのため、<code class="literal">slave_pending_jobs_size_max</code> は、予想されるほとんどのイベントサイズに対応できる高さに設定する必要があります。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-memory"></a>17.5.1.21 レプリケーションと MEMORY テーブル</h4></div></div></div><a class="indexterm" name="idm46723648136528"></a><a class="indexterm" name="idm46723648134368"></a><p>
        レプリケーションソースサーバーが停止して再起動すると、その <code class="literal">MEMORY</code> テーブルは空になります。 この効果をレプリカにレプリケートするには、ソースが起動後に最初に特定の <code class="literal">MEMORY</code> テーブルを使用するときに、そのテーブルの <code class="literal">DELETE</code> ステートメントまたは (MySQL 8.0.22 から) <code class="literal">TRUNCATE TABLE</code> ステートメントをバイナリログに書き込むことによってテーブルを空にする必要があることをレプリカに通知するイベントをログに記録します。 この生成されたイベントはバイナリログ内のコメントによって識別でき、GTID がサーバー上で使用されている場合は GTID が割り当てられます。 バイナリロギング形式が <code class="literal">ROW</code> に設定されている場合でも、ステートメントは常にステートメント形式で記録され、<code class="literal">read_only</code> または <code class="literal">super_read_only</code> モードがサーバーで設定されていても書き込まれます。 ソースの再起動からテーブルの最初の使用までの間、レプリカの <code class="literal">MEMORY</code> テーブルに古いデータが残っていることに注意してください。 レプリカへの直接クエリーで失効したデータが返される可能性がある場合にこの間隔を回避するには、<code class="literal">init_file</code> システム変数を設定して、起動時にソースの <code class="literal">MEMORY</code> テーブルに移入するステートメントを含むファイルに名前を付けることができます。 
      </p><p>
        レプリカサーバーを停止して再起動すると、その <code class="literal">MEMORY</code> テーブルは空になります。 これにより、レプリカがソースと同期しなくなり、他の障害が発生したり、レプリカが停止する可能性があります: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ソースから受信した行形式の更新および削除は、<code class="literal">Can't find record in '<em class="replaceable"><code>memory_table</code></em>'</code>で失敗する場合があります。
          </p></li><li class="listitem"><p>
            <code class="literal">INSERT INTO ... SELECT FROM <em class="replaceable"><code>memory_table</code></em></code> などのステートメントによって、ソースおよびレプリカに異なる行セットが挿入される場合があります。
          </p></li></ul></div><p>
        レプリカはまた、<code class="literal">DELETE</code> または (MySQL 8.0.22) <code class="literal">TRUNCATE TABLE</code> ステートメントを独自のバイナリログに書き込み、それがダウンストリームレプリカに渡されて、独自の <code class="literal">MEMORY</code> テーブルが空になります。
      </p><p>
        <code class="literal">MEMORY</code> テーブルをレプリケートしているレプリカを再起動する安全な方法は、まずソース上の <code class="literal">MEMORY</code> テーブルからすべての行を削除し、それらの変更がレプリカにレプリケートされるまで待機することです。 その後、レプリカを安全に再起動できます。 
      </p><p>
        場合によっては、別の再起動方法を適用できることがあります。 <code class="literal">binlog_format=ROW</code> の場合、レプリカを再起動する前に <code class="literal">slave_exec_mode=IDEMPOTENT</code> を設定すると、レプリカが停止しないようにできます。 これにより、レプリカはレプリケートを続行できますが、その <code class="literal">MEMORY</code> テーブルはソースのテーブルとは異なります。 これは、<code class="literal">MEMORY</code> テーブルの内容が安全に失われるようにアプリケーションロジックが設定されている場合 (<code class="literal">MEMORY</code> テーブルがキャッシュに使用されている場合など) に許容されます。<code class="literal">slave_exec_mode=IDEMPOTENT</code> はすべてのテーブルにグローバルに適用されるため、<code class="literal">MEMORY</code> 以外のテーブルの他のレプリケーションエラーが非表示になる可能性があります。 
      </p><p>
        (ここで説明した方法は NDB Cluster では適用できません。ここでは、<code class="literal">slave_exec_mode</code> は常に <code class="literal">IDEMPOTENT</code> であり、変更できません。)
      </p><p>
        <code class="literal">MEMORY</code> テーブルのサイズは、<code class="literal">max_heap_table_size</code> システム変数の値によって制限され、これは複製されません (<a class="xref" href="replication.html#replication-features-variables" title="17.5.1.39 レプリケーションと変数">セクション17.5.1.39「レプリケーションと変数」</a>を参照してください)。 <code class="literal">max_heap_table_size</code> での変更は、変更後に <code class="literal">ALTER TABLE ... ENGINE = MEMORY</code> または <code class="literal">TRUNCATE TABLE</code> を使用して作成または更新された <code class="literal">MEMORY</code> テーブルに、またはサーバー再起動後にすべての <code class="literal">MEMORY</code> テーブルに反映されます。 レプリカで実行せずにソースでこの変数の値を増やすと、ソース上のテーブルがレプリカ上の対応するテーブルより大きくなり、ソースでは正常に挿入されますが、<span class="errortext">「テーブルがいっぱいです」</span>エラーでレプリカでは失敗します。 これは既知の問題です (Bug #48666)。 このような場合は、レプリカおよびソースで <code class="literal">max_heap_table_size</code> のグローバル値を設定してから、レプリケーションを再起動する必要があります。 また、ソースとレプリカの両方の MySQL サーバーを再起動して、それぞれに新しい値が完全 (グローバル) に有効になるようにすることをお薦めします。 
      </p><p>
        <code class="literal">MEMORY</code> テーブルに関する詳細は、<a class="xref" href="storage-engines.html#memory-storage-engine" title="16.3 MEMORY ストレージエンジン">セクション16.3「MEMORY ストレージエンジン」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-mysqldb"></a>17.5.1.22 mysql システムスキーマのレプリケーション</h4></div></div></div><a class="indexterm" name="idm46723648081344"></a><a class="indexterm" name="idm46723648079184"></a><a class="indexterm" name="idm46723648077056"></a><a class="indexterm" name="idm46723648074992"></a><p>
        <code class="literal">mysql</code> スキーマのテーブルに対して行われたデータ変更ステートメントは、<code class="literal">binlog_format</code> の値に従ってレプリケートされます。この値が <code class="literal">MIXED</code> の場合、これらのステートメントは行ベースの形式を使用してレプリケートされます。 ただし、通常はこの情報を間接的に更新するステートメント (<code class="literal">GRANT</code>、<code class="literal">REVOKE</code>、およびトリガー、ストアドルーチン、およびビューを操作するステートメント) は、ステートメントベースレプリケーションを使用してレプリカにレプリケートされます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-optimizer"></a>17.5.1.23 レプリケーションとクエリーオプティマイザ</h4></div></div></div><a class="indexterm" name="idm46723648065936"></a><a class="indexterm" name="idm46723648063744"></a><p>
        データ変更が非決定的に行われるようにステートメントが書き込まれた場合、つまりクエリーオプティマイザを残した場合は、ソースとレプリカのデータが異なる可能性があります。 (一般的に、これはレプリケーション以外であっても良い行動ではありません。) 非決定的なステートメントの例には、<code class="literal">ORDER BY</code> 句なしの <code class="literal">LIMIT</code> を使用する <code class="literal">DELETE</code> または <code class="literal">UPDATE</code> ステートメントが含まれます。これらの説明の詳細は、<a class="xref" href="replication.html#replication-features-limit" title="17.5.1.18 レプリケーションと LIMIT">セクション17.5.1.18「レプリケーションと LIMIT」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-partitioning"></a>17.5.1.24 レプリケーションおよびパーティション化</h4></div></div></div><a class="indexterm" name="idm46723648055152"></a><a class="indexterm" name="idm46723648052992"></a><p>
        パーティションテーブル間のレプリケーションは、例外が特に許可されている場合を除き、同じパーティション化スキームを使用し、それ以外の場合は同じ構造を持つかぎりサポートされます (<a class="xref" href="replication.html#replication-features-differing-tables" title="17.5.1.9 ソースとレプリカで異なるテーブル定義を使用したレプリケーション">セクション17.5.1.9「ソースとレプリカで異なるテーブル定義を使用したレプリケーション」</a> を参照)。
      </p><p>
        通常、パーティション化が異なるテーブル間のレプリケーションはサポートされません。 これは、このような場合にパーティションに直接作用するステートメント (<code class="literal">ALTER TABLE ... DROP PARTITION</code> など) がソースとレプリカで異なる結果を生成する可能性があるためです。 テーブルがソースでパーティション化されているがレプリカではパーティション化されていない場合、レプリカのソースコピーでパーティションを操作するステートメントはレプリカで失敗します。 テーブルのレプリカコピーがパーティション化されているが、ソースコピーがパーティション化されていない場合、パーティションに直接作用するステートメントは、そこでエラーが発生することなくソースで実行できません。 レプリケーションを停止したり、ソースとレプリカ間の不整合を作成したりしないようにするには、必ずソースのテーブルとレプリカの対応するレプリケートテーブルが同じ方法でパーティション化されていることを確認します。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-repair-table"></a>17.5.1.25 レプリケーションと REPAIR TABLE</h4></div></div></div><a class="indexterm" name="idm46723648044016"></a><a class="indexterm" name="idm46723648041824"></a><p>
        破損または損傷したテーブルで使用されるとき、<code class="literal">REPAIR TABLE</code> ステートメントはリカバリできない行を削除できます。 ただし、このステートメントによって実行されるテーブルデータのこのような変更はレプリケートされないため、ソースとレプリカの同期が失われる可能性があります。 このため、ソース上のテーブルが破損し、<code class="literal">REPAIR TABLE</code> を使用して修復する場合は、レプリケーションを停止してから (まだ実行中の場合)、<code class="literal">REPAIR TABLE</code> を使用する必要があります。その後、テーブルのソースコピーとレプリカコピーを比較し、矛盾を手動で修正する準備をしてから、レプリケーションを再起動してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-reserved-words"></a>17.5.1.26 レプリケーションと予約語</h4></div></div></div><a class="indexterm" name="idm46723648033760"></a><a class="indexterm" name="idm46723648031584"></a><p>
        古いソースから新しいレプリカにレプリケートしようとしたときに、レプリカで実行されている新しい MySQL バージョンの予約語であるソースで識別子を使用すると、問題が発生する可能性があります。 たとえば、MySQL 8.0 レプリカにレプリケートしている MySQL 5.7 ソース上の <code class="literal">rank</code> という名前のテーブルのカラムは、<code class="literal">RANK</code> が MySQL 8.0 で始まる予約語であるため、問題が発生する可能性があります。 
      </p><p>
        このような場合、レプリケーションはエラー 1064 で失敗する可能性があります: <span class="errortext">You have an error in your SQL syntax...</span>。<span class="emphasis"><em>(予約語を使用して名前が付けられたデータベースまたはテーブル、または予約語を使用して名前が付けられたカラムを持つテーブルが、レプリケーションから除外されていても)</em></span>。 これは、レプリカが影響を受けるデータベースオブジェクトを認識できるように、実行前に各 SQL イベントをレプリカで解析する必要があるためです。 イベントが解析された後にのみ、レプリカは <code class="option">--replicate-do-db</code>, <code class="option">--replicate-do-table</code>, <code class="option">--replicate-ignore-db</code> および <code class="option">--replicate-ignore-table</code> で定義されたフィルタリングルールを適用できます。 
      </p><p>
        レプリカによって予約語とみなされるソース上のデータベース、テーブルまたはカラムの名前の問題を回避するには、次のいずれかを実行します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ソースで 1 つ以上の <code class="literal">ALTER TABLE</code> ステートメントを使用して、レプリカでこれらの名前が予約語とみなされるデータベースオブジェクトの名前を変更し、かわりに古い名前を使用する SQL ステートメントを変更して新しい名前を使用します。
          </p></li><li class="listitem"><p>
            これらのデータベースオブジェクト名を使用する SQL ステートメントで、それらの名前をバッククォート文字 (<code class="literal">`</code>) で囲まれた識別子として書いてください。
          </p></li></ul></div><p>
        MySQL バージョン別の予約語の一覧については、「<em class="citetitle">MySQL Server Version Reference</em>」の「<a class="ulink" href="http://dev.mysql.com/doc/mysqld-version-reference/en/mysqld-version-reference-optvar.html" target="_top">Reserved Words</a>」を参照してください。 識別子を囲むルールについては、<a class="xref" href="language-structure.html#identifiers" title="9.2 スキーマオブジェクト名">セクション9.2「スキーマオブジェクト名」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-row-searches"></a>17.5.1.27 レプリケーションおよび行検索</h4></div></div></div><p>
        行ベースのレプリケーション形式を使用するレプリカが <code class="literal">UPDATE</code> または <code class="literal">DELETE</code> 操作を適用する場合、関連するテーブルで一致する行を検索する必要があります。 このプロセスの実行に使用されるアルゴリズムでは、いずれかのテーブルインデックスを使用して最初の選択として検索を実行し、適切なインデックスがない場合はハッシュテーブルを使用します。 
      </p><p>
        アルゴリズムは、まずテーブル定義で使用可能なインデックスを評価して、使用する適切なインデックスがあるかどうか、および複数の可能性があるかどうかを確認します。どのインデックスが操作に最適ですか。 このアルゴリズムは、次のタイプのインデックスを無視します: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            全文インデックス。
          </p></li><li class="listitem"><p>
            非表示インデックス。
          </p></li><li class="listitem"><p>
            生成されたインデックス。
          </p></li><li class="listitem"><p>
            Multi-valued indexes.
          </p></li><li class="listitem"><p>
            行イベントのビフォアイメージにインデックスのすべてのカラムが含まれていないインデックス。
          </p></li></ul></div><p>
        これらのインデックスタイプを除外した後に適切なインデックスがない場合、アルゴリズムは検索にインデックスを使用しません。 適切なインデックスがある場合は、次の優先順位で候補から 1 つのインデックスが選択されます: 
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            主キー。
          </p></li><li class="listitem"><p>
            インデックス内のすべてのカラムに NOT NULL 属性がある一意のインデックス。 このようなインデックスが複数使用可能な場合、アルゴリズムはこれらのインデックスの左端を選択します。 
          </p></li><li class="listitem"><p>
            その他のインデックス。 このようなインデックスが複数使用可能な場合、アルゴリズムはこれらのインデックスの左端を選択します。 
          </p></li></ol></div><p>
        インデックス内のすべてのカラムに <code class="literal">NOT NULL</code> 属性がある主キーまたは一意インデックスをアルゴリズムで選択できる場合、このインデックスを使用して <code class="literal">UPDATE</code> または <code class="literal">DELETE</code> 操作の行を反復処理します。 行イベントの各行について、アルゴリズムはインデックス内の行を検索して、更新するテーブルレコードを検索します。 一致するレコードが見つからない場合は、エラー <span class="errortext">ER_KEY_NOT_FOUND</span> が返され、レプリケーションアプライヤスレッドが停止します。 
      </p><p>
        アルゴリズムが適切なインデックスを見つけられなかった場合、または一意でないか NULL を含んでいたインデックスのみを見つけることができた場合は、ハッシュテーブルを使用してテーブルレコードを識別します。 このアルゴリズムは、<code class="literal">UPDATE</code> または <code class="literal">DELETE</code> 操作の行を含むハッシュテーブルを作成し、そのキーを行の完全なビフォアイメージとして使用します。 アルゴリズムは、検出された場合は選択されたインデックスを使用してターゲットテーブルのすべてのレコードを反復処理し、それ以外の場合は全テーブルスキャンを実行します。 ターゲットテーブルのレコードごとに、その行がハッシュテーブルに存在するかどうかが判別されます。 ハッシュテーブルで行が見つかった場合、ターゲットテーブルのレコードが更新され、ハッシュテーブルから行が削除されます。 ターゲットテーブルのすべてのレコードがチェックされると、このアルゴリズムはハッシュテーブルが空であるかどうかを検証します。 ハッシュテーブルに一致しない行が残っている場合、アルゴリズムはエラー <span class="errortext">ER_KEY_NOT_FOUND</span> を返し、レプリケーションアプライヤスレッドを停止します。 
      </p><p>
        <code class="literal">slave_rows_search_algorithms</code> システム変数は、以前は一致する行の検索方法を制御するために使用されていました。 前述のように、インデックススキャンの後にハッシュスキャンを使用するデフォルト設定はパフォーマンスに最適であり、すべてのシナリオで正しく機能するため、このシステム変数の使用は非推奨になりました。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-shutdowns"></a>17.5.1.28 レプリケーションとソースまたはレプリカの停止</h4></div></div></div><a class="indexterm" name="idm46723647984224"></a><a class="indexterm" name="idm46723647982064"></a><a class="indexterm" name="idm46723647980000"></a><a class="indexterm" name="idm46723647977936"></a><p>
        レプリケーションソースサーバーをシャットダウンして、あとで再起動しても安全です。 レプリカがソースへの接続を失うと、レプリカはただちに再接続を試み、失敗した場合は定期的に再試行します。 デフォルトでは 60 秒ごとに再試行します。 これは、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23 の場合) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 の場合) を使用して変更できます。 レプリカは、ネットワーク接続の停止にも対処できます。 ただし、レプリカは、ソースから <code class="literal">slave_net_timeout</code> 秒間データを受信しなかった後にのみネットワークの停止に気付きます。 停止時間が短い場合は、<code class="literal">slave_net_timeout</code> を減らすことをお勧めします。 <a class="xref" href="replication.html#replication-solutions-unexpected-replica-halt" title="17.4.2 レプリカの予期しない停止の処理">セクション17.4.2「レプリカの予期しない停止の処理」</a>を参照してください。 
      </p><p>
        ソースバイナリログファイルがフラッシュされていないため、ソース側でクリーンでないシャットダウン (クラッシュなど) を実行すると、ソースバイナリログの最終的な位置がレプリカによって読み取られた最新の位置より小さくなる可能性があります。 これにより、ソースの起動時にレプリカをレプリケートできなくなる可能性があります。 ソースサーバーの <code class="filename">my.cnf</code> ファイルで <code class="literal">sync_binlog=1</code> を設定すると、ソースがより頻繁にバイナリログをフラッシュするため、この問題を最小限に抑えることができます。 <code class="literal">InnoDB</code> とトランザクションを使用したレプリケーション設定で永続性と一貫性を最大限に高めるには、<code class="literal">innodb_flush_log_at_trx_commit=1</code> も設定する必要があります。 この設定では、各トランザクションのコミット時に <code class="literal">InnoDB</code> redo ログバッファの内容がログファイルに書き込まれ、ログファイルがディスクにフラッシュされます。 オペレーティングシステムまたはディスクハードウェアは、ディスクへのフラッシュ操作が行われたことを <span class="command"><strong>mysqld</strong></span> に通知する場合があるため、トランザクションの永続性はまだこの設定で保証されていないことに注意してください。 
      </p><p>
        レプリカの完全なシャットダウンは、レプリカが停止した場所を追跡するため安全です。 ただし、レプリカに一時テーブルが開かれていないことに注意してください。<a class="xref" href="replication.html#replication-features-temptables" title="17.5.1.31 レプリケーションと一時テーブル">セクション17.5.1.31「レプリケーションと一時テーブル」</a> を参照してください。 予期しないシャットダウンにより問題が発生する場合があります (特に、ディスクキャッシュがディスクにフラッシュされない状態で問題が発生した場合)。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            トランザクションの場合、レプリカは <code class="filename">relay-log.info</code> をコミットしてから更新します。 これらの 2 つの操作の間に予期しない終了が発生した場合、リレーログの処理は情報ファイルに示されているよりも先に進み、レプリカは再起動後にリレーログ内の最後のトランザクションからイベントを再実行します。 
          </p></li><li class="listitem"><p>
            同様の問題は、レプリカが <code class="filename">relay-log.info</code> を更新しても、書込みがディスクにフラッシュされる前にサーバーホストがクラッシュした場合に発生することがあります。 これが発生する可能性を最小限に抑えるには、レプリカ <code class="filename">my.cnf</code> ファイルに <code class="literal">sync_relay_log_info=1</code> を設定します。 <code class="literal">sync_relay_log_info</code> を 0 に設定すると、ディスクへの書込みは強制されず、サーバーはオペレーティングシステムに依存してファイルを随時フラッシュします。 
          </p></li></ul></div><p>
        システムのこのような問題に対する耐障害性は、優れた無停電電源があると大幅に向上します。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-slaveerrors"></a>17.5.1.29 レプリケーション中のレプリカエラー</h4></div></div></div><a class="indexterm" name="idm46723647950688"></a><a class="indexterm" name="idm46723647948528"></a><a class="indexterm" name="idm46723647946464"></a><a class="indexterm" name="idm46723647944400"></a><p>
        ステートメントがソースとレプリカの両方で同じエラー (同一のエラーコード) を生成した場合、エラーはログに記録されますが、レプリケーションは続行されます。
      </p><p>
        ステートメントがソースとレプリカで異なるエラーを生成すると、レプリケーション SQL スレッドは終了し、レプリカはエラーログにメッセージを書き込み、データベース管理者がエラーに関する処理を決定するのを待機します。 これには、ステートメントがソースまたはレプリカでエラーを生成する場合が含まれますが、両方ではありません。 この問題に対処するには、レプリカに手動で接続し、問題の原因を特定します。 これには、<code class="literal">SHOW REPLICA | SLAVE STATUS</code> が役立ちます。 次に、問題を修正し、<code class="literal">START REPLICA | SLAVE</code> を実行します。 たとえば、レプリカを再起動する前に、存在しないテーブルを作成する必要がある場合があります。 

        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            レプリカエラーログに一時エラーが記録されている場合は、引用符で囲まれたエラーメッセージに示されているアクションを実行する必要はありません。 一時エラーは、トランザクションを再試行するクライアントによって処理される必要があります。 たとえば、レプリケーション SQL スレッドがデッドロックに関連する一時エラーを記録している場合、レプリケーション SQL スレッドがその後非一時エラーメッセージで終了しないかぎり、レプリカでトランザクションを手動で再起動する必要はありません。 
          </p></div><p>
      </p><p>
        このエラーコード検証動作が望ましくない場合は、<code class="option">--slave-skip-errors</code> オプションでエラーの一部またはすべてを隠す (無視する) ことができます。
      </p><p>
        <code class="literal">MyISAM</code> などの非トランザクションストレージエンジンの場合、テーブルを不完全に更新してエラーコードを返すだけのステートメントが存在する場合があります。 これはたとえば、1 つの行がキー制約に違反する複数行挿入で、または長い更新ステートメントが一部の行を更新したあとに強制終了された場合に発生する可能性があります。 これがソースで発生した場合、レプリカはステートメントの実行結果が同じエラーコードになることを想定しています。 そうでない場合、レプリケーション SQL スレッドは前述のように停止します。 
      </p><p>
        ソースとレプリカで異なるストレージエンジンを使用するテーブル間でレプリケートする場合は、同じステートメントをテーブルの一方のバージョンに対して実行すると異なるエラーが生成される可能性がありますが、他方に対しては生成されないか、一方のバージョンのテーブルでエラーが発生する可能性がありますが、他方のバージョンでは発生しないことに注意してください。 たとえば、<code class="literal">MyISAM</code> は外部キー制約を無視するため、ソース上の <code class="literal">InnoDB</code> テーブルにアクセスする <code class="literal">INSERT</code> または <code class="literal">UPDATE</code> ステートメントは外部キー違反を引き起こす可能性がありますが、レプリカ上の同じテーブルの <code class="literal">MyISAM</code> バージョンで同じステートメントを実行してもそのようなエラーは発生せず、レプリケーションは停止します。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-sql-mode"></a>17.5.1.30 レプリケーションとサーバー SQL モード</h4></div></div></div><a class="indexterm" name="idm46723647924048"></a><a class="indexterm" name="idm46723647921920"></a><a class="indexterm" name="idm46723647919840"></a><a class="indexterm" name="idm46723647917744"></a><a class="indexterm" name="idm46723647915648"></a><a class="indexterm" name="idm46723647913568"></a><p>
        ソースとレプリカで異なるサーバー SQL モード設定を使用すると、ソースとレプリカで同じ <code class="literal">INSERT</code> ステートメントが異なる方法で処理され、ソースとレプリカが相違する可能性があります。 最良の結果を得るには、ソースとレプリカで常に同じサーバー SQL モードを使用する必要があります。 このアドバイスは、ステートメントベースまたは行ベースのどちらのレプリケーションを使用しているかにかかわらず、適用されます。 
      </p><p>
        パーティションテーブルをレプリケートする場合、ソースとレプリカで異なる SQL モードを使用すると、問題が発生する可能性があります。 少なくとも、特定のテーブルのソースコピーとレプリカコピーでパーティション間のデータ分散が異なる可能性があります。 また、ソースで成功したパーティションテーブルへの挿入がレプリカで失敗する可能性もあります。 
      </p><p>
        詳細は、<a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-temptables"></a>17.5.1.31 レプリケーションと一時テーブル</h4></div></div></div><a class="indexterm" name="idm46723647905824"></a><a class="indexterm" name="idm46723647903696"></a><a class="indexterm" name="idm46723647901584"></a><p>
        MySQL 8.0 では、<code class="literal">binlog_format</code> が <code class="literal">ROW</code> または <code class="literal">MIXED</code> に設定されている場合、一時テーブルのみを使用するステートメントはソースに記録されないため、一時テーブルはレプリケートされません。 一時テーブルと非一時テーブルが混在するステートメントは、非一時テーブルに対する操作に対してのみソースに記録され、一時テーブルに対する操作は記録されません。 これは、レプリカによって計画外停止が行われた場合に失われるレプリカ上の一時テーブルがないことを意味します。 行ベースレプリケーションと一時テーブルの詳細は、<a class="xref" href="replication.html#replication-rbr-usage-temptables" title="一時テーブルの行ベースロギング">一時テーブルの行ベースロギング</a>を参照してください。 


      </p><p>
        <code class="literal">binlog_format</code> が <code class="literal">STATEMENT</code> に設定されている場合、一時テーブルに関連するステートメントをステートメントベースの形式を使用して安全にログに記録できるかぎり、一時テーブルに対する操作はソースに記録され、レプリカにレプリケートされます。 この状況では、レプリカ上のレプリケートされた一時テーブルの損失が問題になる可能性があります。 ステートメントベースレプリケーションモードでは、GTID がサーバー上で使用されている場合 (つまり、<code class="literal">enforce_gtid_consistency</code> システム変数が <code class="literal">ON</code> に設定されている場合)、<code class="literal">CREATE TEMPORARY TABLE</code> および <code class="literal">DROP TEMPORARY TABLE</code> ステートメントをトランザクション、手順、関数、またはトリガー内で使用することはできません。 GTID が使用されている場合、<code class="literal">autocommit=1</code> が設定されていれば、これらのコンテキストの外部で使用できます。 
      </p><p>
        一時テーブルに関して行ベースまたは混合レプリケーションモードとステートメントベースのレプリケーションモードの動作が異なるため、変更がオープン一時テーブルを含むコンテキスト (グローバルまたはセッション) に適用される場合、実行時にレプリケーション形式を切り替えることはできません。 詳細は、<code class="literal">binlog_format</code> オプションの説明を参照してください。 
      </p><p><b>一時テーブル使用時の安全なレプリカの停止. </b>
          ステートメントベースレプリケーションモードでは、(レプリケーションスレッドだけでなく) 複製サーバーを停止し、まだ複製で実行されていない更新で使用するために開かれている複製一時テーブルがある場合を除き、一時テーブルは複製されます。 レプリカサーバーを停止すると、レプリカの再起動時に、これらの更新に必要な一時テーブルを使用できなくなります。 この問題を回避するには、一時テーブルが開いている間はレプリカを停止しないでください。 代わりに、次の手順を使用してください。 
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <code class="literal">STOP REPLICA | SLAVE SQL_THREAD</code> ステートメントを発行します。
          </p></li><li class="listitem"><p>
            <code class="literal">SHOW STATUS</code> を使用して <code class="literal">Slave_open_temp_tables</code> 変数の値を確認します。
          </p></li><li class="listitem"><p>
            値が 0 でない場合は、<code class="literal">START REPLICA | SLAVE SQL_THREAD</code> を使用してレプリケーション SQL スレッドを再起動し、後で手順を繰り返します。
          </p></li><li class="listitem"><p>
            値が 0 の場合は、<span class="command"><strong>mysqladmin shutdown</strong></span> コマンドを発行してレプリカを停止します。
          </p></li></ol></div><p><b>一時テーブルとレプリケーションオプション. </b>
          デフォルトでは、ステートメントベースレプリケーションでは、すべての一時テーブルがレプリケートされます。これは、一致する <code class="option">--replicate-do-db</code>、<code class="option">--replicate-do-table</code>、または <code class="option">--replicate-wild-do-table</code> オプションが有効になっているかどうかにかかわらず発生します。 ただし、<code class="option">--replicate-ignore-table</code> および <code class="option">--replicate-wild-ignore-table</code> オプションは一時テーブルで受け付けられます。 ただし、セッションの終了時に一時テーブルを正しく削除できるようにするために、レプリカは、通常は指定されたテーブルに適用される除外ルールに関係なく、常に <code class="literal">DROP TEMPORARY TABLE IF EXISTS</code> ステートメントをレプリケートします。 
        </p><p>
        ステートメントベースレプリケーションを使用するときに推奨される方法は、レプリケートしない一時テーブルの名前付けに排他的に使用する接頭辞を指定し、その接頭辞と一致するように <code class="option">--replicate-wild-ignore-table</code> オプションを使用することです。 たとえば、このようなすべてのテーブルに <code class="literal">norep</code> で始まる名前を付けてから (たとえば、<code class="literal">norepmytable</code>、<code class="literal">norepyourtable</code> など)、テーブルが複製されることを回避するために <code class="option">--replicate-wild-ignore-table=norep%</code> を使用します。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-timeout"></a>17.5.1.32 レプリケーション再試行とタイムアウト</h4></div></div></div><a class="indexterm" name="idm46723647858512"></a><a class="indexterm" name="idm46723647856352"></a><a class="indexterm" name="idm46723647854288"></a><a class="indexterm" name="idm46723647852880"></a><p>
        グローバルシステム変数 <code class="literal">slave_transaction_retries</code> は、シングルスレッドまたはマルチスレッドレプリカ上の適用者スレッドが、停止前に失敗したトランザクションを自動的に再試行する最大回数を設定します。 <code class="literal">InnoDB</code> デッドロックのために SQL スレッドがトランザクションの実行に失敗した場合、またはトランザクション実行時間が <code class="literal">InnoDB</code> <code class="literal">innodb_lock_wait_timeout</code> 値を超えた場合、トランザクションは自動的に再試行されます。 トランザクションに、成功を妨げる一時的でないエラーがある場合、再試行されません。 
      </p><p>
        <code class="literal">slave_transaction_retries</code> のデフォルト設定は 10 です。これは、通常一時エラーで失敗したトランザクションが、アプライヤスレッドが停止する前に 10 回再試行されることを意味します。 変数を 0 に設定すると、トランザクションの自動再試行が無効になります。 マルチスレッドのレプリカでは、すべてのチャネルのすべてのアプライヤスレッドで、指定された数のトランザクション再試行を実行できます。 「パフォーマンススキーマ」テーブル <code class="literal">replication_applier_status</code> の <code class="literal">COUNT_TRANSACTIONS_RETRIES</code> カラムには、各レプリケーションチャネルで行われたトランザクション再試行の合計数が表示されます。 
      </p><p>
        トランザクションを再試行するプロセスによって、レプリカまたはグループレプリケーショングループメンバーでラグが発生する可能性があります。これは、シングルスレッドまたはマルチスレッドのレプリカとして構成できます。 「パフォーマンススキーマ」テーブル <code class="literal">replication_applier_status_by_worker</code> には、シングルスレッドまたはマルチスレッドレプリカでの適用者スレッドによるトランザクションの再試行に関する詳細情報が表示されます。 このデータには、アプライヤスレッドが最後のトランザクションの適用にかかった時間 (および現在進行中のトランザクションが開始された時間) と、元のソースおよび即時ソースでのコミット後の時間を示すタイムスタンプが含まれます。 データには、最後のトランザクションおよび現在進行中のトランザクションの再試行回数も表示され、トランザクションの再試行の原因となった一時エラーを識別できます。 この情報を使用して、トランザクションの再試行がレプリケーションラグの原因であるかどうかを確認し、再試行の原因となった失敗の根本原因を調査できます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-timezone"></a>17.5.1.33 レプリケーションとタイムゾーン</h4></div></div></div><a class="indexterm" name="idm46723647836768"></a><a class="indexterm" name="idm46723647834608"></a><p>
        デフォルトでは、ソースサーバーとレプリカサーバーは同じタイムゾーンであると想定します。 異なるタイムゾーンのサーバー間でレプリケートする場合は、ソースとレプリカの両方でタイムゾーンを設定する必要があります。 それ以外の場合、ソースのローカル時間に依存するステートメント (<code class="literal">NOW()</code> または <code class="literal">FROM_UNIXTIME()</code> 関数を使用するステートメントなど) は正しくレプリケートされません。 
      </p><p>
        ソースおよびレプリカのシステムタイムゾーン (<code class="literal">system_time_zone</code>)、サーバーの現在のタイムゾーン (<code class="literal">time_zone</code> のグローバル値) およびセッションごとのタイムゾーン (<code class="literal">time_zone</code> のセッション値) の設定の組合せが正しい結果を生成していることを確認します。 特に、<code class="literal">time_zone</code> システム変数が <code class="literal">SYSTEM</code> の値に設定されていて、サーバーのタイムゾーンがシステムのタイムゾーンと同じであることを示している場合は、ソースとレプリカが異なるタイムゾーンを適用する可能性があります。 たとえば、ソースはバイナリログに次のステートメントを書き込むことができます: 
      </p><pre class="programlisting">SET @@session.time_zone='SYSTEM';
</pre><p>
        このソースとそのレプリカのシステムタイムゾーンの設定が異なる場合、レプリカグローバル <code class="literal">time_zone</code> 値がソースと一致するように設定されていても、このステートメントによってレプリカで予期しない結果が生成される可能性があります。 MySQL Server のタイムゾーン設定およびその変更方法の詳細は、<a class="xref" href="server-administration.html#time-zone-support" title="5.1.15 MySQL Server でのタイムゾーンのサポート">セクション5.1.15「MySQL Server でのタイムゾーンのサポート」</a> を参照してください。 
      </p><p>
        <a class="xref" href="replication.html#replication-features-functions" title="17.5.1.14 レプリケーションとシステム関数">セクション17.5.1.14「レプリケーションとシステム関数」</a>も参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-transaction-inconsistencies"></a>17.5.1.34 レプリケーションとトランザクションの非一貫性</h4></div></div></div><p>
        リレーログから実行された一連のトランザクションの不整合は、レプリケーション構成によって発生する可能性があります。 このセクションでは、不整合を回避し、問題の原因を解決する方法について説明します。 
      </p><p>
        次のタイプの不整合が存在する可能性があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="emphasis"><em>半消込済トランザクション</em></span>。 非トランザクションテーブルを更新するトランザクションが、そのすべてではなく一部の変更を適用しました。 
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>ギャップ</em></span>。 外部化されたトランザクションセット内のギャップは、順序付けられたトランザクションのシーケンスが指定された場合に、シーケンス内の後のトランザクションがシーケンス内の他のトランザクションより前に適用されるときに表示されます。 ギャップは、マルチスレッドのレプリカを使用している場合にのみ表示されます。 ギャップが発生しないようにするには、<code class="literal">slave_preserve_commit_order=1</code> を設定します。 この設定では、MySQL 8.0.18 まで、バイナリロギング (<code class="literal">log_bin</code>) およびレプリカ更新ロギング (<code class="literal">log_slave_updates</code>) も有効にする必要があります。これは、MySQL 8.0 のデフォルト設定です。 MySQL 8.0.19 からは、バイナリロギングおよびレプリカ更新ロギングは、<code class="literal">slave_preserve_commit_order=1</code> を設定するためにレプリカでは必要なく、必要に応じて無効にできます。 すべてのリリースで、<code class="literal">slave_preserve_commit_order=1</code> を設定するには、<code class="literal">slave_parallel_type</code> がデフォルト設定ではない <code class="literal">LOGICAL_CLOCK</code> に設定されている必要があります。 一部の特定の状況では、<code class="literal">slave_preserve_commit_order</code> の説明に示されているように、<code class="literal">slave_preserve_commit_order=1</code> を設定してもレプリカのコミット順序を保持できないため、レプリカリレーログから実行された一連のトランザクションにギャップが表示される場合があります。 
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>ソースバイナリログの位置ラグ</em></span>。 ギャップがなくても、<code class="literal">Exec_master_log_pos</code> が適用された後のトランザクションが発生する可能性があります。 つまり、<code class="literal">N</code> までのすべてのトランザクションが適用され、<code class="literal">N</code> が適用された後のトランザクションは適用されませんが、<code class="literal">Exec_master_log_pos</code> の値は <code class="literal">N</code> より小さくなります。 この場合、<code class="literal">Exec_master_log_pos</code> は適用されたトランザクションの<span class="quote">「<span class="quote">「最低水位標」</span>」</span>であり、最後に適用されたトランザクションの位置より遅れています。 これはマルチスレッドのレプリカでのみ発生します。 <code class="literal">slave_preserve_commit_order</code> を有効にしても、ソースバイナリログの位置ラグは妨げられません。 
          </p></li></ul></div><p>
        次のシナリオは、半導体で適用されるトランザクション、ギャップ、およびソースバイナリログの位置ラグの存在に関連します:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            レプリケーションスレッドの実行中に、ギャップと半数適用のトランザクションが発生する場合があります。
          </p></li><li class="listitem"><p>
            <span class="command"><strong>mysqld</strong></span> が停止します。 クリーンな停止とクリーンでない停止の両方により、進行中のトランザクションが中断され、ギャップと半数適用のトランザクションが残る可能性があります。 
          </p></li><li class="listitem"><p>
            レプリケーションスレッドの <code class="literal">KILL</code> (シングルスレッドレプリカを使用する場合は SQL スレッド、マルチスレッドレプリカを使用する場合はコーディネータスレッド)。 これにより、進行中のトランザクションが中断され、ギャップや半数適用のトランザクションが残る可能性があります。 
          </p></li><li class="listitem"><p>
            適用者スレッドでエラーが発生しました。 これによりギャップが生じる可能性があります。 エラーが混合トランザクション内にある場合、そのトランザクションは半適用されます。 マルチスレッドのレプリカを使用する場合、エラーを受信していないワーカーはキューを完了するため、すべてのスレッドの停止に時間がかかることがあります。 
          </p></li><li class="listitem"><p>
            マルチスレッドのレプリカを使用している場合は <code class="literal">STOP REPLICA | SLAVE</code>。 <code class="literal">STOP REPLICA | SLAVE</code> の発行後、レプリカはギャップが一杯になるまで待機し、<code class="literal">Exec_master_log_pos</code> を更新します。 これにより、前述のいずれかのケース (つまり、<code class="literal">STOP REPLICA | SLAVE</code> が完了する前、エラーが発生する前、別のスレッドが <code class="literal">KILL</code> を発行する前、またはサーバーが再起動する前) を除き、ギャップまたはソースバイナリログの位置ラグが保持されることはありません。 このような場合、<code class="literal">STOP REPLICA | SLAVE</code> は正常に戻ります。 
          </p></li><li class="listitem"><p>
            リレーログ内の最後のトランザクションが半数受信のみで、マルチスレッドレプリカコーディネータスレッドがワーカーへのトランザクションのスケジュールを開始した場合、<code class="literal">STOP REPLICA | SLAVE</code> はトランザクションが受信されるまで最大 60 秒待機します。 このタイムアウト後、コーディネータはトランザクションを中止します。 トランザクションが混在している場合は、半完了のままにすることができます。 
          </p></li><li class="listitem"><p>
            シングルスレッドレプリカを使用する場合の <code class="literal">STOP REPLICA | SLAVE</code>。 進行中のトランザクションがトランザクションテーブルのみを更新する場合、トランザクションテーブルはロールバックされ、<code class="literal">STOP REPLICA | SLAVE</code> はただちに停止します。 進行中のトランザクションが混在している場合、<code class="literal">STOP REPLICA | SLAVE</code> はトランザクションが完了するまで最大 60 秒待機します。 このタイムアウト後、トランザクションは中断されるため、半分完了のままになります。 
          </p></li></ol></div><p>
        グローバル変数 <code class="literal">rpl_stop_slave_timeout</code> は、レプリケーションスレッドを停止するプロセスとは無関係です。 <code class="literal">STOP REPLICA | SLAVE</code> を発行するクライアントがクライアントに戻るだけですが、レプリケーションスレッドは引き続き停止しようとします。 
      </p><p>
        レプリケーションチャネルにギャップがある場合は、次の結果になります:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            レプリカデータベースは、ソースに存在していない可能性がある状態です。
          </p></li><li class="listitem"><p>
            <code class="literal">SHOW REPLICA | SLAVE STATUS</code> のフィールド <code class="literal">Exec_master_log_pos</code> は、<span class="quote">「<span class="quote">「最低水位標」</span>」</span>のみです。 つまり、位置の前に表示されるトランザクションはコミットされていることが保証されますが、位置の後のトランザクションはコミットされているかどうかは保証されません。 
          </p></li><li class="listitem"><p>
            そのチャネルの <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントおよび <code class="literal">CHANGE MASTER TO</code> ステートメントは、適用者スレッドが実行中であり、ステートメントで受信者オプションのみが設定されている場合を除き、エラーで失敗します。
          </p></li><li class="listitem"><p>
            <code class="option">--relay-log-recovery</code> を使用して <span class="command"><strong>mysqld</strong></span> を起動した場合、そのチャネルのリカバリは行われず、警告が出力されます。
          </p></li><li class="listitem"><p>
            If <span class="command"><strong>mysqldump</strong></span> is used with <code class="option">--dump-slave</code>, it does not record the existence of gaps; thus it prints <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> with <code class="literal">RELAY_LOG_POS</code> set to the <span class="quote">「<span class="quote">「最低水位標」</span>」</span> position in <code class="literal">Exec_master_log_pos</code>.
          </p><p>
            ダンプを別のサーバーに適用し、レプリケーションスレッドを開始すると、位置の後に表示されるトランザクションが再度レプリケートされます。 GTID が有効になっている場合、これは無害であることに注意してください (ただし、その場合、<code class="option">--dump-slave</code> を使用することはお薦めしません)。 
          </p></li></ol></div><p>
        レプリケーションチャネルにソースバイナリログの位置ラグがあり、ギャップがない場合は、前述のケース 2 から 5 が適用されますが、ケース 1 は適用されません。
      </p><p>
        ソースバイナリログの位置情報は、内部テーブル <code class="literal">mysql.slave_worker_info</code> にバイナリ形式で保持されます。 <code class="literal">START REPLICA | SLAVE [SQL_THREAD]</code>は常にこの情報を参照して、正しいトランザクションのみを適用します。 これは、<code class="literal">slave_parallel_workers</code> が <code class="literal">START REPLICA | SLAVE</code> の前に 0 に変更された場合、および <code class="literal">START REPLICA | SLAVE</code> が <code class="literal">UNTIL</code> 句とともに使用された場合でも当てはまります。 <code class="literal">START REPLICA | SLAVE UNTIL SQL_AFTER_MTS_GAPS</code> では、ギャップを埋めるために必要な数のトランザクションのみが適用されます。 <code class="literal">START REPLICA | SLAVE</code> が、すべてのギャップを消費する前に停止するように指示する <code class="literal">UNTIL</code> 句とともに使用されている場合、残りのギャップは残ります。 
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          <code class="literal">RESET REPLICA | SLAVE</code> によってリレーログが削除され、レプリケーション位置がリセットされます。 したがって、ギャップのあるレプリカで <code class="literal">RESET REPLICA | SLAVE</code> を発行すると、レプリカはギャップを修正せずにギャップに関する情報を失います。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-transactions"></a>17.5.1.35 レプリケーションとトランザクション</h4></div></div></div><a class="indexterm" name="idm46723647726992"></a><a class="indexterm" name="idm46723647724832"></a><p><b>同じトランザクション内にトランザクションおよび非トランザクションステートメントを混在させる. </b>
          一般的に、レプリケーション環境でトランザクションおよび非トランザクションテーブルの両方を更新するトランザクションは避けるべきです。 トランザクション (または一時) および非トランザクションテーブルの両方にアクセスしてそれらに書き込むステートメントを使用することも避けるべきです。 
        </p><p>
        サーバーは、バイナリロギングに次の規則を使用します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            トランザクション内の最初のステートメントが非トランザクションである場合、それらはすぐにバイナリログに書き込まれます。 トランザクション内の残りのステートメントはキャッシュされ、トランザクションがコミットされるまでバイナリログに書き込まれません。 (トランザクションがロールバックされた場合、キャッシュされたステートメントは、ロールバックできない非トランザクション変更を行う場合にのみバイナリログに書き込まれます。 それ以外の場合は、それらは破棄されます。) 
          </p></li><li class="listitem"><p>
            ステートメントベースロギングの場合、非トランザクションステートメントのロギングは <code class="literal">binlog_direct_non_transactional_updates</code> システム変数によって影響されます。 この変数が <code class="literal">OFF</code>の場合 (デフォルト)、ロギングは上記のとおりになります。 この変数が <code class="literal">ON</code> の場合、非トランザクションステートメントがトランザクション内のどこで発生しても (最初の非トランザクションステートメントだけではありません)、ただちにロギングが発生します。 ほかのステートメントはトランザクションキャッシュに保持され、トランザクションがコミットしたときにログが記録されます。<code class="literal">binlog_direct_non_transactional_updates</code> は行形式または混合形式バイナリロギングに影響しません。 
          </p></li></ul></div><p><a name="replication-features-transactions-trx-nontrx-mixed"></a><b>トランザクション、非トランザクション、および混合ステートメント. </b><a class="indexterm" name="idm46723647710944"></a>
          これらのルールを適用する場合、サーバーは、非トランザクションテーブルだけを変更する場合にはステートメントを非トランザクションと見なし、トランザクションテーブルだけを変更する場合にはトランザクションと見なします。 非トランザクションテーブルとトランザクションテーブルの両方を参照し、関係するテーブルを更新するステートメントは、<span class="quote">「<span class="quote">mixed</span>」</span> ステートメントとみなされます。 混合ステートメントは、トランザクションステートメントと同様に、キャッシュされ、トランザクションがコミットするときにログが記録されます。 
        </p><p>
        トランザクションテーブルを更新する混合ステートメントは、次のアクションのいずれかを実行する場合も、安全ではないと見なされます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            一時テーブルの更新または読取り
          </p></li><li class="listitem"><p>
            非トランザクションテーブルを読み取り、トランザクション分離レベルが REPEATABLE_READ 未満
          </p></li></ul></div><p>
        トランザクション内でトランザクションテーブル更新に続く混合ステートメントは、次のアクションのいずれかを実行する場合、安全ではないと見なされます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブルを更新し、一時テーブルから読み取る
          </p></li><li class="listitem"><p>
            非トランザクションテーブルを更新し、<code class="literal">binlog_direct_non_transactional_updates</code> が OFF の場合
          </p></li></ul></div><p>
        詳細については、<a class="xref" href="replication.html#replication-rbr-safe-unsafe" title="17.2.1.3 バイナリロギングでの安全および安全でないステートメントの判断">セクション17.2.1.3「バイナリロギングでの安全および安全でないステートメントの判断」</a>を参照してください。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          混合ステートメントは混合バイナリロギング形式とは関係ありません。
        </p></div><p>
        トランザクション内でトランザクションおよび非トランザクションテーブルへの更新が混在している状況で、バイナリログ内のステートメントの順序は正しく、必要なすべてのステートメントがバイナリログに書き込まれます (<code class="literal">ROLLBACK</code> の場合でも)。 ただし、最初の接続トランザクションが完了する前に 2 番目の接続が非トランザクションテーブルを更新するときは、ステートメントログが記録される順序が乱れる場合があります。最初の接続によって実行されているトランザクションの状態にかかわらず、2 番目の接続更新が実行された直後に書き込まれるためです。 
      </p><p><b>ソースとレプリカで異なるストレージエンジンを使用. </b>
          レプリカの非トランザクションテーブルを使用して、ソースでトランザクションテーブルをレプリケートできます。 たとえば、<code class="literal">InnoDB</code> ソーステーブルを <code class="literal">MyISAM</code> レプリカテーブルとしてレプリケートできます。 ただし、これを行うと、レプリカが <code class="literal">BEGIN</code> ... <code class="literal">COMMIT</code> ブロックの先頭から再開されるため、レプリカが <code class="literal">BEGIN</code> ... <code class="literal">COMMIT</code> ブロックの途中で停止した場合に問題が発生します。 
        </p><p>
        また、ソース上の <code class="literal">MyISAM</code> テーブルからレプリカ上のトランザクションテーブル (<code class="literal">InnoDB</code> ストレージエンジンを使用するテーブルなど) にトランザクションをレプリケートすることも安全です。 このような場合、ソースで発行された <code class="literal">AUTOCOMMIT=1</code> ステートメントがレプリケートされるため、レプリカで <code class="literal">AUTOCOMMIT</code> モードが強制されます。 
      </p><p>
        レプリカのストレージエンジンタイプが非トランザクションの場合、トランザクションテーブルと非トランザクションテーブルの更新が混在するソース上のトランザクションは、ソーストランザクションテーブルとレプリカ非トランザクションテーブルの間でデータの不整合を引き起こす可能性があるため、回避するようにしてください。 つまり、このようなトランザクションは、ソースストレージエンジン固有の動作につながり、レプリケーションが同期しなくなる可能性があります。 MySQL では、これに関する警告は発行されないため、レプリカ上でソーステーブルから非トランザクションテーブルにトランザクションテーブルをレプリケートする場合は、特に注意する必要があります。 
      </p><p><b>トランザクション内でバイナリロギング形式を変更する. </b>
          <code class="literal">binlog_format</code> および <code class="literal">binlog_checksum</code> システム変数は、トランザクションが進行中であれば読取り専用です。
        </p><p>
        各トランザクション (<code class="literal">autocommit</code> トランザクションを含む) は、<code class="literal">BEGIN</code> ステートメントで始まり、<code class="literal">COMMIT</code> または <code class="literal">ROLLBACK</code> ステートメントで終わるかのように、バイナリログに記録されます。 これは、非トランザクションストレージエンジン (<code class="literal">MyISAM</code> など) を使用するテーブルに影響を与えるステートメントにも当てはまります。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          XA トランザクションに特に適用される制限については、<a class="xref" href="sql-statements.html#xa-restrictions" title="13.3.8.3 XA トランザクションの制約">セクション13.3.8.3「XA トランザクションの制約」</a> を参照してください。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-triggers"></a>17.5.1.36 レプリケーションとトリガー</h4></div></div></div><a class="indexterm" name="idm46723647666512"></a><a class="indexterm" name="idm46723647664368"></a><p>
        ステートメントベースレプリケーションでは、ソースで実行されたトリガーもレプリカで実行されます。 行ベースのレプリケーションでは、ソースで実行されたトリガーはレプリカで実行されません。 かわりに、トリガーの実行によって生成されたソースの行変更がレプリケートされ、レプリカに適用されます。 
      </p><p>
        この動作は設計によります。 行ベースのレプリケーションでは、レプリカがトリガーおよびトリガーによって発生した行の変更を適用した場合、変更はレプリカに 2 回適用され、ソースとレプリカのデータが異なります。 
      </p><p>
        ソースとレプリカの両方でトリガーを実行する場合は、おそらくソースとレプリカで異なるトリガーがあるため、ステートメントベースのレプリケーションを使用する必要があります。 ただし、レプリカ側トリガーを有効にするには、ステートメントベースのレプリケーションを排他的に使用する必要はありません。 この効果が必要なステートメントでのみステートメントベースレプリケーションに切り替え、残りの時間は行ベースレプリケーションを使用することで十分です。 
      </p><p>
        <code class="literal">AUTO_INCREMENT</code> カラムを更新するトリガー (または関数) を呼び出すステートメントは、ステートメントベースレプリケーションを使用して正しく複製されません。 MySQL 8.0 はこのようなステートメントを安全でないとマークします。 (Bug #45677) 
      </p><p>
        トリガーは、トリガーイベント (<code class="literal">INSERT</code>, <code class="literal">UPDATE</code>, <code class="literal">DELETE</code>) とアクション時間 (<code class="literal">BEFORE</code>、<code class="literal">AFTER</code>) の様々な組合せに対してトリガーを持つことができ、複数のトリガーが許可されます。
      </p><p>
        簡潔にするために、ここでの<span class="quote">「<span class="quote">「複数のトリガー」</span>」</span>は<span class="quote">「<span class="quote">「同じトリガーイベントおよびアクション時間を持つ複数のトリガー」</span>」</span>の短縮形です。
      </p><p>
        <span class="bold"><strong>Upgrades.</strong></span> MySQL 5.7 より前のバージョンでは、複数のトリガーはサポートされていません。 MySQL 5.7 より前のバージョンを使用するレプリケーショントポロジのサーバーをアップグレードする場合は、まずレプリカをアップグレードしてから、ソースをアップグレードします。 アップグレードされたレプリケーションソースサーバーに、複数のトリガーをサポートしていない MySQL バージョンを使用する古いレプリカがまだ存在する場合、トリガーイベントとアクション時間がすでに同じトリガーを持つテーブルのソースでトリガーが作成されると、それらのレプリカでエラーが発生します。 
      </p><p>
        <span class="bold"><strong>Downgrades.</strong></span> 複数のトリガーをサポートするサーバーをサポートしていない古いバージョンにダウングレードすると、ダウングレードは次の影響を受けます: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            トリガーを持つテーブルごとに、すべてのトリガー定義はテーブルの <code class="filename">.TRG</code> ファイルにあります。 ただし、トリガーイベントとアクション時間が同じトリガーが複数ある場合、サーバーはトリガーイベントが発生したときにいずれか一方のみを実行します。 <code class="literal">.TRG</code> ファイルの詳細は、<a class="ulink" href="https://dev.mysql.com/doc/index-other.html" target="_top">https://dev.mysql.com/doc/index-other.html</a> で入手可能な MySQL Server Doxygen ドキュメントの「テーブルトリガー記憶域」に関するセクションを参照してください。 
          </p></li><li class="listitem"><p>
            ダウングレード後にテーブルのトリガーが追加または削除されると、サーバーはテーブルの <code class="filename">.TRG</code> ファイルを書き換えます。 リライトされたファイルには、トリガーイベントとアクション時間の組合せごとに 1 つのトリガーのみが保持され、他のトリガーは失われます。 
          </p></li></ul></div><p>
        これらの問題を回避するには、ダウングレードする前にトリガーを変更します。 トリガーイベントとアクション時間の組合せごとに複数のトリガーを持つテーブルごとに、次のようにトリガーの各セットを単一のトリガーに変換します: 
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            トリガーごとに、トリガー内のすべてのコードを含むストアドルーチンを作成します。 <code class="literal">NEW</code> および <code class="literal">OLD</code> を使用してアクセスされる値は、パラメータを使用してルーチンに渡すことができます。 トリガーにコードからの単一の結果値が必要な場合は、ストアドファンクションにコードを配置し、その関数で値を戻すことができます。 トリガーにコードからの複数の結果値が必要な場合は、ストアドプロシージャにコードを配置し、<code class="literal">OUT</code> パラメータを使用して値を返すことができます。 
          </p></li><li class="listitem"><p>
            テーブルのすべてのトリガーを削除します。
          </p></li><li class="listitem"><p>
            作成したストアドルーチンを呼び出すテーブルに対して、新しいトリガーを作成します。 したがって、このトリガーの効果は、トリガーが置換する複数のトリガーと同じです。 
          </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-truncate"></a>17.5.1.37 レプリケーションと TRUNCATE TABLE</h4></div></div></div><a class="indexterm" name="idm46723647630128"></a><a class="indexterm" name="idm46723647627984"></a><p>
        <code class="literal">TRUNCATE TABLE</code> は通常は DML ステートメントと見なされるため、バイナリロギングモードが <code class="literal">ROW</code> または <code class="literal">MIXED</code> のときは行ベース形式を使用してログが記録されて複製されることが予想されます。 しかしこのことが、<code class="literal">InnoDB</code> などのトランザクションストレージエンジン (トランザクション分離レベルが <code class="literal">READ COMMITTED</code> または <code class="literal">READ UNCOMMITTED</code> (ステートメントベースロギングを排除)) を使用するテーブルを <code class="literal">STATEMENT</code> または <code class="literal">MIXED</code> モードでログを記録または複製するときに、問題を発生させました。 
      </p><p>
        <code class="literal">TRUNCATE TABLE</code> は、ロギングおよびレプリケーション目的のときはステートメントとしてログを記録し複製できるように、DML ではなく DDL として扱われます。 ただし、レプリカに対する <code class="literal">InnoDB</code> および他のトランザクションテーブルに適用可能なステートメントの影響は、そのようなテーブルを制御する <a class="xref" href="sql-statements.html#truncate-table" title="13.1.37 TRUNCATE TABLE ステートメント">セクション13.1.37「TRUNCATE TABLE ステートメント」</a> で説明されているルールに従います。 (Bug #36763) 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-user-names"></a>17.5.1.38 レプリケーションおよびユーザー名の長さ</h4></div></div></div><a class="indexterm" name="idm46723647613088"></a><a class="indexterm" name="idm46723647610960"></a><p>
        MySQL 8.0 でのユーザー名の最大長は 32 文字です。 16 文字を超えるユーザー名のレプリケーションは、5.7 より前のバージョンの MySQL をレプリカが実行している場合に失敗します。これらのバージョンでは短いユーザー名のみがサポートされるためです。 これは、新しいソースから古いレプリカにレプリケートする場合にのみ発生します。これは推奨される構成ではありません。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-variables"></a>17.5.1.39 レプリケーションと変数</h4></div></div></div><a class="indexterm" name="idm46723647606656"></a><a class="indexterm" name="idm46723647604480"></a><a class="indexterm" name="idm46723647602416"></a><a class="indexterm" name="idm46723647600336"></a><a class="indexterm" name="idm46723647598256"></a><p>
        システム変数は、次の変数を除き (セッションスコープで使用されるとき)、<code class="literal">STATEMENT</code> モード使用時は正しく複製されません。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">auto_increment_increment</code>
          </p></li><li class="listitem"><p>
            <code class="literal">auto_increment_offset</code>
          </p></li><li class="listitem"><p>
            <code class="literal">character_set_client</code>
          </p></li><li class="listitem"><p>
            <code class="literal">character_set_connection</code>
          </p></li><li class="listitem"><p>
            <code class="literal">character_set_database</code>
          </p></li><li class="listitem"><p>
            <code class="literal">character_set_server</code>
          </p></li><li class="listitem"><p>
            <code class="literal">collation_connection</code>
          </p></li><li class="listitem"><p>
            <code class="literal">collation_database</code>
          </p></li><li class="listitem"><p>
            <code class="literal">collation_server</code>
          </p></li><li class="listitem"><p>
            <code class="literal">foreign_key_checks</code>
          </p></li><li class="listitem"><p>
            <code class="literal">identity</code>
          </p></li><li class="listitem"><p>
            <code class="literal">last_insert_id</code>
          </p></li><li class="listitem"><p>
            <code class="literal">lc_time_names</code>
          </p></li><li class="listitem"><p>
            <code class="literal">pseudo_thread_id</code>
          </p></li><li class="listitem"><p>
            <code class="literal">sql_auto_is_null</code>
          </p></li><li class="listitem"><p>
            <code class="literal">time_zone</code>
          </p></li><li class="listitem"><p>
            <code class="literal">timestamp</code>
          </p></li><li class="listitem"><p>
            <code class="literal">unique_checks</code>
          </p></li></ul></div><p>
        <code class="literal">MIXED</code> モード使用時に、前述のリスト内の変数がセッションスコープで使用されるときはステートメントベースから行ベースロギングに切り替わります。 <a class="xref" href="server-administration.html#binary-log-mixed" title="5.4.4.3 混合形式のバイナリロギング形式">セクション5.4.4.3「混合形式のバイナリロギング形式」</a>を参照してください。 
      </p><p>
        <code class="literal">sql_mode</code> も <code class="literal">NO_DIR_IN_CREATE</code> モードを除いてレプリケートされます。レプリカは、ソースでの変更に関係なく、常に <code class="literal">NO_DIR_IN_CREATE</code> の独自の値を保持します。 これは、すべてのレプリケーション形式に当てはまります。 
      </p><p>
        ただし、<span class="command"><strong>mysqlbinlog</strong></span> が <code class="literal">SET @@sql_mode = <em class="replaceable"><code>mode</code></em></code> ステートメントを解析したときに、<code class="literal">NO_DIR_IN_CREATE</code>を含む完全な <em class="replaceable"><code>mode</code></em> 値が受信サーバーに渡されます。 このため、このようなステートメントのレプリケーションは、<code class="literal">STATEMENT</code> モード使用時は安全でない場合があります。 
      </p><p>
        ロギングモードに関係なく、<code class="literal">default_storage_engine</code> システム変数はレプリケートされません。これは、異なるストレージエンジン間のレプリケーションを容易にすることを目的としています。
      </p><p>
        <code class="literal">read_only</code> システム変数は複製されません。 さらに、この変数を有効にした場合の一時テーブル、テーブルロック、および <code class="literal">SET PASSWORD</code> ステートメントに関する効果は、MySQL バージョンごとに異なります。 
      </p><p>
        <code class="literal">max_heap_table_size</code> システム変数は複製されません。 レプリカでこれを行わずにソースでこの変数の値を増やすと、ソース上の <code class="literal">MEMORY</code> テーブルで <code class="literal">INSERT</code> ステートメントを実行しようとしたときに、最終的にレプリカで<span class="errortext">「テーブルがいっぱいです」</span>エラーが発生する可能性があるため、レプリカ上の対応する値より大きくなることが許可されます。 詳細については、<a class="xref" href="replication.html#replication-features-memory" title="17.5.1.21 レプリケーションと MEMORY テーブル">セクション17.5.1.21「レプリケーションと MEMORY テーブル」</a>を参照してください。 
      </p><p>
        ステートメントベースレプリケーションで、セッション変数は、テーブルを更新するステートメントで使用されるときに正しく複製されません。 たとえば、次の一連のステートメントでは、ソースとレプリカに同じデータは挿入されません: 
      </p><pre class="programlisting">SET max_join_size=1000;
INSERT INTO mytable VALUES(@@max_join_size);
</pre><p>
        これは、一般的なシーケンスには適用されません。
      </p><pre class="programlisting">SET time_zone=...;
INSERT INTO mytable VALUES(CONVERT_TZ(..., ..., @@time_zone));
</pre><p>
        セッション変数のレプリケーションは、行ベースレプリケーションが使用されているときは問題ではありません。このケースでは、セッション変数は常に安全に複製されます。 <a class="xref" href="replication.html#replication-formats" title="17.2.1 レプリケーション形式">セクション17.2.1「レプリケーション形式」</a>を参照してください。 
      </p><p>
        次のセッション変数はバイナリログに書き込まれ、ロギング形式に関係なく、バイナリログの解析時にレプリカによって適用されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">sql_mode</code>
          </p></li><li class="listitem"><p>
            <code class="literal">foreign_key_checks</code>
          </p></li><li class="listitem"><p>
            <code class="literal">unique_checks</code>
          </p></li><li class="listitem"><p>
            <code class="literal">character_set_client</code>
          </p></li><li class="listitem"><p>
            <code class="literal">collation_connection</code>
          </p></li><li class="listitem"><p>
            <code class="literal">collation_database</code>
          </p></li><li class="listitem"><p>
            <code class="literal">collation_server</code>
          </p></li><li class="listitem"><p>
            <code class="literal">sql_auto_is_null</code>
          </p></li></ul></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          文字セットと照合順序に関係するセッション変数はバイナリログに書き込まれるけれども、異なる文字セット間のレプリケーションはサポートされません。
        </p></div><p>
        混乱の可能性を低減するために、特にファイルシステムが大/小文字を区別するプラットフォームで MySQL を実行している場合は、ソースとレプリカの両方で <code class="literal">lower_case_table_names</code> システム変数に常に同じ設定を使用することをお薦めします。 <code class="literal">lower_case_table_names</code> 設定は、サーバーの初期化時にのみ構成できます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-views"></a>17.5.1.40 レプリケーションとビュー</h4></div></div></div><a class="indexterm" name="idm46723647516848"></a><a class="indexterm" name="idm46723647514672"></a><p>
        ビューは常にレプリカにレプリケートされます。 ビューは、それらが参照するテーブルではなく、それら独自の名前でフィルタリングされます。 つまり、通常は <code class="option">replication-ignore-table</code> ルールによってフィルタで除外されるテーブルがビューに含まれている場合でも、ビューをレプリカにレプリケートできます。 このため、通常はセキュリティー上の理由でフィルタリングされるテーブルデータをビューが複製しないように、気を付けるようにしてください。 
      </p><p>
        テーブルから同じ名前のビューへのレプリケーションは、ステートメントベースのロギングを使用してサポートされますが、行ベースのロギングを使用している場合はサポートされません。 行ベースのロギングが有効なときに試行すると、エラーが発生します。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-compatibility"></a>17.5.2 MySQL バージョン間のレプリケーション互換性</h3></div></div></div><p>
      MySQL は、あるリリースシリーズから次の上位リリースシリーズへのレプリケーションをサポートしています。 たとえば、MySQL 5.6 を実行しているソースから MySQL 5.7 を実行しているレプリカ、MySQL 5.7 を実行しているソースから MySQL 8.0 を実行しているレプリカなどにレプリケートできます。 ただし、ソースがステートメントを使用しているか、レプリカで使用されている MySQL のバージョンでサポートされなくなった動作に依存している場合、古いソースから新しいレプリカにレプリケートするときに問題が発生することがあります。 たとえば、64 文字を超える外部キー名は、MySQL 8.0 からサポートされなくなりました。 
    </p><p>
      複数のソースを含むレプリケーション設定では、ソースまたはレプリカ MySQL サーバーの数に関係なく、複数の MySQL Server バージョンの使用はサポートされていません。 この制限は、リリースシリーズだけでなく、同じリリースシリーズ内のバージョン番号にも適用されます。 たとえば、連鎖レプリケーション設定または循環レプリケーション設定を使用している場合、MySQL 8.0.1、MySQL 8.0.2 および MySQL 8.0.4 を同時に使用することはできませんが、これらのリリースのいずれかを同時に使用できます。 
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        レプリケーション (およびその他の) 機能は継続的に改善されるため、特定の MySQL リリースシリーズ内で使用可能な最新リリースを使用することを強くお薦めします。 また、MySQL のリリースシリーズの初期リリースを使用するソースおよびレプリカを GA (本番) リリースにアップグレードすることもお薦めします (後者がそのリリースシリーズで使用可能になった場合)。 
      </p></div><p>
      MySQL 8.0.14 から、サーバーのバージョンは、トランザクションを最初にコミットしたサーバー (<code class="literal">original_server_version</code>) の各トランザクション、およびレプリケーショントポロジ (<code class="literal">immediate_server_version</code>) の現在のサーバーの即時ソースであるサーバーのバイナリログに記録されます。
    </p><p>
      新しいソースから古いレプリカへのレプリケーションは可能ですが、通常はサポートされていません。 これはいくつかの要因によります。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>バイナリログ形式の変更. </b>
            バイナリログ形式はメジャーリリース間で変わることがあります。 下位互換性を維持しようと試みてはいますが、これがいつか可能なわけではありません。 ソースでは、バイナリログトランザクション圧縮など、古いレプリカで認識されないオプションの機能が有効になっている場合もあります。バイナリログトランザクション圧縮では、MySQL 8.0.20 より前のリリースでは結果の圧縮トランザクションペイロードをレプリカで読み取ることができません。 
          </p><p>
          これは、レプリケーションサーバーのアップグレードにも密接な関係があります。詳細は、<a class="xref" href="replication.html#replication-upgrade" title="17.5.3 レプリケーションセットアップをアップグレードする">セクション17.5.3「レプリケーションセットアップをアップグレードする」</a>を参照してください。
        </p></li><li class="listitem"><p>
          行ベースレプリケーションの詳細は、<a class="xref" href="replication.html#replication-formats" title="17.2.1 レプリケーション形式">セクション17.2.1「レプリケーション形式」</a>を参照してください。
        </p></li><li class="listitem"><p><b>SQL 非互換. </b>
            レプリケート対象のステートメントがソースで使用可能でレプリカではなく SQL 機能を使用している場合、ステートメントベースのレプリケーションを使用して新しいソースから古いレプリカにレプリケートすることはできません。
          </p><p>
          ただし、ソースとレプリカの両方が行ベースのレプリケーションをサポートし、ソースで検出されたがレプリカでは検出されなかった SQL 機能に依存するレプリケート対象のデータ定義ステートメントがない場合は、ソースで実行された DDL がレプリカでサポートされていなくても、行ベースのレプリケーションを使用してデータ変更ステートメントの影響をレプリケートできます。
        </p></li></ul></div><p>
      潜在的なレプリケーション問題の詳細は、<a class="xref" href="replication.html#replication-features" title="17.5.1 レプリケーションの機能と問題">セクション17.5.1「レプリケーションの機能と問題」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-upgrade"></a>17.5.3 レプリケーションセットアップをアップグレードする</h3></div></div></div><p>
      レプリケーションセットアップに関与するサーバーをアップグレードするときに、アップグレードの手順は現在のサーバーバージョンとアップグレード後のバージョンによって異なります。 このセクションでは、アップグレードがレプリケーションに与える影響について説明します。 MySQL のアップグレードの一般情報は、<a class="xref" href="installing.html#upgrading" title="2.11 MySQL のアップグレード">セクション2.11「MySQL のアップグレード」</a> を参照してください 
    </p><p>
      以前の MySQL リリースシリーズから 8.0 にソースをアップグレードする場合は、まず、このソースのすべてのレプリカが同じ 8.0.x リリースを使用していることを確認する必要があります。 そうでない場合は、まずレプリカをアップグレードする必要があります。 各レプリカをアップグレードするには、レプリカを停止し、適切な 8.0.x バージョンにアップグレードして再起動し、レプリケーションを再開します。 アップグレード後にレプリカによって作成されるリレーログは、8.0 形式です。 
    </p><p>
      厳密な SQL モード (<code class="literal">STRICT_TRANS_TABLES</code> または <code class="literal">STRICT_ALL_TABLES</code>) で操作に影響を与える変更により、アップグレードされたレプリカでレプリケーションが失敗する可能性があります。 ステートメントベースのロギング (<code class="literal">binlog_format=STATEMENT</code>) を使用する場合、ソースの前にレプリカがアップグレードされると、ソースはソースで成功したがレプリカで失敗する可能性があるステートメントを実行するため、レプリケーションが停止します。 これに対処するには、ソース上のすべての新しいステートメントを停止し、レプリカがキャッチアップされるまで待機してから、レプリカをアップグレードします。 または、新しいステートメントを停止できない場合は、ソース (<code class="literal">binlog_format=ROW</code>) で一時的に行ベースのロギングに変更し、この変更時点までに生成されたすべてのバイナリログがすべてのレプリカによって処理されるまで待機してから、レプリカをアップグレードします。 
    </p><p>
      MySQL 8.0 で、デフォルトの文字セットが <code class="literal">latin1</code> から <code class="literal">utf8mb4</code> に変更されました。 レプリケートされた設定では、MySQL 5.7 から 8.0 にアップグレードする場合、アップグレードする前にデフォルトの文字セットを MySQL 5.7 で使用されている文字セットに戻すことをお薦めします。 アップグレードの完了後、デフォルトの文字セットを <code class="literal">utf8mb4</code> に変更できます。 以前のデフォルトが使用されていたと仮定すると、これらを保持する方法の 1 つは、<code class="filename">my.cnf</code> ファイル内の次の行を使用してサーバーを起動することです: 
    </p><pre class="programlisting">[mysqld]
character_set_server=latin1
collation_server=latin1_swedish_ci
</pre><p>
      レプリカがアップグレードされたら、ソースを停止し、レプリカと同じ 8.0.x リリースにアップグレードして再起動します。 ソースを一時的に行ベースのロギングに変更した場合は、ステートメントベースのロギングに戻します。 8.0 ソースは、アップグレード前に書き込まれた古いバイナリログを読み取り、それらを 8.0 レプリカに送信できます。 レプリカは古い形式を認識し、適切に処理します。 アップグレード後にソースによって作成されるバイナリログは、8.0 形式です。 これらも 8.0 レプリカによって認識されます。 
    </p><p>
      つまり、MySQL 8.0 にアップグレードする場合、ソースを 8.0 にアップグレードする前にレプリカが MySQL 8.0 である必要があります。 8.0 から古いバージョンへのダウングレードは、それほど簡単には機能しません。ダウングレードに進む前に 8.0 バイナリログまたはリレーログを削除できるように、それらが完全に処理されたことを確認する必要があります。 
    </p><p>
      アップグレードによっては、ある MySQL シリーズから次のものに移行するときに、データベースオブジェクトの削除と再作成が必要になる場合があります。 たとえば、照合順序の変更には、テーブルインデックスの再構築が必要な場合があります。 このような操作の詳細は、必要に応じて <a class="xref" href="installing.html#upgrading-from-previous-series" title="2.11.4 MySQL 8.0 での変更">セクション2.11.4「MySQL 8.0 での変更」</a> を参照してください。 レプリカとソースでこれらの操作を個別に実行し、ソースからレプリカへのこれらの操作のレプリケーションを無効にすることが最も安全です。 これを実現するには、次の手順を使用してください。 
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          すべてのレプリカを停止し、アップグレードします。 ソースに接続しないように、<code class="option">--skip-slave-start</code> オプションを使用して再起動します。 データベースオブジェクトの再作成に必要なテーブル修復または再構築操作 (<code class="literal">REPAIR TABLE</code>、<code class="literal">ALTER TABLE</code> の使用など)、またはテーブルまたはトリガーのダンプおよびリロードを実行します。 
        </p></li><li class="listitem"><p>
          ソースのバイナリログを無効にします。 ソースを再起動せずにこれを行うには、<code class="literal">SET sql_log_bin = OFF</code> ステートメントを実行します。 または、ソースを停止し、<code class="option">--skip-log-bin</code> オプションを使用して再起動します。 ソースを再起動する場合は、クライアント接続を禁止することもできます。 たとえば、すべてのクライアントが TCP/IP を使用して接続する場合は、ソースの再起動時に <code class="literal">skip_networking</code> システム変数を有効にします。 
        </p></li><li class="listitem"><p>
          バイナリログが無効の状態で、データベースオブジェクトの再作成に必要なテーブル修復または再構築操作を実行します。 これらの操作がログに記録され、あとでレプリカに送信されないようにするには、この手順でバイナリログを無効にする必要があります。 
        </p></li><li class="listitem"><p>
          ソースでバイナリログを再度有効にします。 以前に <code class="literal">sql_log_bin</code> を <code class="literal">OFF</code> に設定した場合は、<code class="literal">SET sql_log_bin = ON</code> ステートメントを実行します。 バイナリログを無効にするためにソースを再起動した場合は、クライアントとレプリカが接続できるように、<code class="option">--skip-log-bin</code> なしで <code class="literal">skip_networking</code> システム変数を有効にせずに再起動します。 
        </p></li><li class="listitem"><p>
          今回は、<code class="option">--skip-slave-start</code> オプションを指定せずにレプリカを再起動します。
        </p></li></ol></div><p>
      グローバルトランザクション識別子をサポートしていない MySQL のバージョンからアップグレードする場合は、GTID ベースのレプリケーションのすべての要件を設定が満たしていることを確認する前に、ソースまたはレプリカで GTID を有効にしないでください。 <a class="xref" href="replication.html#replication-gtids-howto" title="17.1.3.4 GTID を使用したレプリケーションのセットアップ">セクション17.1.3.4「GTID を使用したレプリケーションのセットアップ」</a>を参照してください。GTID ベースレプリケーションを使用するために既存のレプリケーションセットアップを変換することに関する情報が含まれています。 
    </p><p>
      MySQL 8.0.16 より前では、グローバルトランザクション識別子 (GTID) を有効にして (<code class="literal">gtid_mode=ON</code>) サーバーを実行している場合、<span class="command"><strong>mysql_upgrade</strong></span> (<code class="option">--write-binlog</code> オプション) によるバイナリロギングを有効にしないでください。 MySQL 8.0.16 の時点では、サーバーは MySQL アップグレード手順全体を実行しますが、アップグレード中はバイナリロギングを無効にするため、問題はありません。 
    </p><p>
      ダンプファイルにシステムテーブルが含まれている場合、GTID がサーバー (<code class="literal">gtid_mode=ON</code>) で有効になっているときにダンプファイルをロードすることはお薦めしません。<span class="command"><strong>mysqldump</strong></span> は、非トランザクション MyISAM ストレージエンジンを使用するシステムテーブルに対して DML 命令を発行します。GTID が有効になっている場合、この組み合わせは許可されません。 GTID が有効になっているサーバーから GTID が有効になっている別のサーバーにダンプファイルをロードすると、異なるトランザクション識別子が生成されることにも注意してください。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-problems"></a>17.5.4 レプリケーションのトラブルシューティング</h3></div></div></div><a class="indexterm" name="idm46723647438848"></a><p>
      指示に従ってもレプリケーションセットアップが機能しない場合、最初に行うことは<span class="emphasis"><em>エラーログでメッセージを確認する</em></span>ことです。 多くのユーザーは、問題が発生したあとにこれを十分に実行せずに、時間を失います。 
    </p><p>
      エラーログから何が問題だったのかがわからない場合は、次の手法を試してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SHOW MASTER STATUS</code> ステートメントを発行して、ソースのバイナリロギングが有効になっていることを確認します。 バイナリロギングはデフォルトで有効になっています。 バイナリロギングが有効になっている場合、<code class="literal">Position</code> はゼロ以外です。 バイナリロギングが有効になっていない場合は、バイナリロギングを無効にする設定 (<code class="option">--skip-log-bin</code> オプションなど) でソースを実行していないことを確認します。 
        </p></li><li class="listitem"><p>
          ソースとレプリカの両方で起動時に <code class="literal">server_id</code> システム変数が設定され、ID 値が各サーバーで一意であることを確認します。
        </p></li><li class="listitem"><p>
          レプリカが実行されていることを確認します。 <code class="literal">SHOW REPLICA | SLAVE STATUS</code> を使用して、<code class="literal">Replica_IO_Running</code> と <code class="literal">Replica_SQL_Running</code> の両方の値が <code class="literal">Yes</code> であるかどうかを確認します。 そうでない場合は、レプリカサーバーの起動時に使用されたオプションを確認します。 たとえば、<code class="option">--skip-slave-start</code> では、<code class="literal">START REPLICA | SLAVE</code> ステートメントを発行するまでレプリケーションスレッドが起動しません。 
        </p></li><li class="listitem"><p>
          レプリカが実行中の場合は、ソースへの接続が確立されているかどうかを確認します。 <code class="literal">SHOW PROCESSLIST</code> を使用して I/O スレッドと SQL スレッドを見つけ、それらの <code class="literal">State</code> カラムをチェックしてそれらに何が表示されているかを確認してください。 <a class="xref" href="replication.html#replication-implementation-details" title="17.2.3 レプリケーションスレッド">セクション17.2.3「レプリケーションスレッド」</a>を参照してください。 I/O スレッド状態が <code class="literal">Connecting to master</code> である場合、次のことを確認してください。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              ソースのレプリケーションユーザーの権限を確認します。
            </p></li><li class="listitem"><p>
              ソースのホスト名が正しいこと、およびソースへの接続に正しいポートを使用していることを確認してください。 レプリケーションに使用されるポートは、クライアントネットワーク通信に使用されるポートと同じです (デフォルトは <code class="literal">3306</code> です)。 ホスト名の場合、その名前が正しい IP アドレスに解決されることを確認してください。 
            </p></li><li class="listitem"><p>
              構成ファイルをチェックして、ネットワークを無効にするためにソースまたはレプリカで <code class="literal">skip_networking</code> システム変数が有効になっているかどうかを確認します。 その場合は、設定をコメント化するか、削除します。 
            </p></li><li class="listitem"><p>
              ソースにファイアウォールまたは IP フィルタリング構成がある場合は、MySQL に使用されているネットワークポートがフィルタ処理されていないことを確認します。
            </p></li><li class="listitem"><p>
              <code class="literal">ping</code> または <code class="literal">traceroute</code>/<code class="literal">tracert</code> を使用してホストにアクセスし、ソースに到達できることを確認します。
            </p></li></ul></div></li><li class="listitem"><p>
          レプリカが以前に実行されていたが停止している場合は、通常、ソースで成功した一部のステートメントがレプリカで失敗したためです。 これは、ソースの適切なスナップショットを取得し、レプリケーションスレッド外のレプリカのデータを変更していない場合には発生しません。 レプリカが予期せず停止した場合は、バグであるか、<a class="xref" href="replication.html#replication-features" title="17.5.1 レプリケーションの機能と問題">セクション17.5.1「レプリケーションの機能と問題」</a> で説明されている既知のレプリケーション制限のいずれかが発生しています。 バグの場合は、報告方法の説明を<a class="xref" href="replication.html#replication-bugs" title="17.5.5 レプリケーションバグまたは問題を報告する方法">セクション17.5.5「レプリケーションバグまたは問題を報告する方法」</a>で参照してください。 
        </p></li><li class="listitem"><p>
          ソースで成功したステートメントがレプリカでの実行を拒否した場合、レプリカデータベースを削除してソースから新しいスナップショットをコピーすることで、完全なデータベース再同期を実行できない場合は、次の手順を実行します:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              レプリカ上の影響を受けるテーブルがソーステーブルと異なるかどうかを確認します。 これがどのように発生したかを理解しようとしてください。 次に、レプリカテーブルをソースと同一にして、<code class="literal">START REPLICA | SLAVE</code> を実行します。 
            </p></li><li class="listitem"><p>
              前述のステップが機能しないか適用されない場合は、手動で更新を安全に行うかどうか (必要な場合) を理解してから、ソースの次のステートメントを無視してください。
            </p></li><li class="listitem"><p>
              レプリカがソースから次のステートメントをスキップできると判断した場合は、次のステートメントを発行します:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL sql_slave_skip_counter = <em class="replaceable"><code>N</code></em>;</code></strong>
mysql&gt; <strong class="userinput"><code>START SLAVE;</code></strong>
Or from MySQL 8.0.22:
mysql&gt; <strong class="userinput"><code>START REPLICA;</code></strong>
</pre><p>
              ソースの次のステートメントで <code class="literal">AUTO_INCREMENT</code> または <code class="literal">LAST_INSERT_ID()</code> を使用しない場合、<em class="replaceable"><code>N</code></em> の値は 1 にする必要があります。 そうでない場合は、値は 2 であるべきです。 <code class="literal">AUTO_INCREMENT</code> または <code class="literal">LAST_INSERT_ID()</code> を使用するステートメントに値 2 を使用する理由は、ソースのバイナリログで 2 つのイベントを取得するためです。 
            </p><p>
              <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/set-global-sql-slave-skip-counter.html" target="_top">SET GLOBAL sql_slave_skip_counter Statement</a>も参照してください。
            </p></li><li class="listitem"><p>
              レプリカがソースと完全に同期化を開始し、レプリケーションスレッドの外部に関係するテーブルを誰も更新していないことが確実な場合は、バグの結果として相違が発生している可能性があります。 最新バージョンの MySQL を実行している場合は、この問題を報告してください。 古いバージョンを実行している場合は、最新の本番環境リリースにアップグレードして問題が持続するかどうかを判断してみてください。 
            </p></li></ol></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-bugs"></a>17.5.5 レプリケーションバグまたは問題を報告する方法</h3></div></div></div><p>
      関係するユーザーエラーはないと判断したけれども、依然としてレプリケーションがまったく機能しないか安定しない場合は、バグレポートを送る時期です。 バグを突き止めるため、できるだけ多くの情報をユーザーから入手する必要があります。 優れたバグレポートを準備するために、ある程度の時間と労力を費やしてくださるようにお願いします。 
    </p><p>
      そのバグをはっきりと示す再現可能なテストケースがある場合は、<a class="xref" href="introduction.html#bug-reports" title="1.6 質問またはバグをレポートする方法">セクション1.6「質問またはバグをレポートする方法」</a>で示す手順を使用してオラクルのバグデータベースに入力してくださるようにお願いします。 <span class="quote">「<span class="quote">幽霊のような</span>」</span>問題 (意のままに再現できないもの) の場合は、次の手順を使用してください。 
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          ユーザーエラーが関係していないことを確認します。 たとえば、レプリケーションスレッド外でレプリカを更新すると、データが同期しなくなり、更新時に一意キー違反が発生する可能性があります。 この場合、レプリケーションスレッドは停止し、テーブルを手動でクリーンアップして同期化するまで待機します。  <span class="emphasis"><em>これは、レプリケーションの問題ではありません。 外部干渉の問題でレプリケーションが失敗しています。</em></span> 
        </p></li><li class="listitem"><p>
          バイナリロギングを有効にして (<code class="literal">log_bin</code> システム変数)、<code class="option">--log-slave-updates</code> オプションを有効にしてレプリカが実行されていることを確認します。これにより、ソースから受信した更新がレプリカによって独自のバイナリログに記録されます。 これらの設定はデフォルトです。 
        </p></li><li class="listitem"><p>
          レプリケーション状態をリセットする前のすべての証拠を保存します。 情報がなかったり、不完全な情報しかなかったりすると、オラクルでは問題を突き止めることが困難または不可能になります。 収集すべき証拠: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              ソースのすべてのバイナリログファイル
            </p></li><li class="listitem"><p>
              レプリカからのすべてのバイナリログファイル
            </p></li><li class="listitem"><p>
              問題を検出した時点でのソースからの <code class="literal">SHOW MASTER STATUS</code> の出力
            </p></li><li class="listitem"><p>
              問題を検出した時点でのレプリカからの <code class="literal">SHOW REPLICA | SLAVE STATUS</code> の出力
            </p></li><li class="listitem"><p>
              ソースおよびレプリカからのエラーログ
            </p></li></ul></div></li><li class="listitem"><p>
          <span class="command"><strong>mysqlbinlog</strong></span> を使用してバイナリログを調べます。 問題の説明ステートメントを見つけるには、次のことが役立ちます。<em class="replaceable"><code>log_file</code></em> および <em class="replaceable"><code>log_pos</code></em> は、<code class="literal">SHOW REPLICA | SLAVE STATUS</code> の <code class="literal">Master_Log_File</code> および <code class="literal">Read_Master_Log_Pos</code> の値です。 
        </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqlbinlog --start-position=<em class="replaceable"><code>log_pos</code></em> <em class="replaceable"><code>log_file</code></em> | head</code></strong>
</pre></li></ol></div><p>
      問題の証拠を収集したあとは、まずそれらを個別のテストケースとして切り分けてみてください。 そのうえで、<a class="xref" href="introduction.html#bug-reports" title="1.6 質問またはバグをレポートする方法">セクション1.6「質問またはバグをレポートする方法」</a>での指示を使用して問題およびできるだけ多くの情報をオラクルのバグデータベースに入力してください。 
    </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="storage-engines.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="group-replication.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第 16 章 代替ストレージエンジン </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第 18 章 グループレプリケーション</td></tr></table></div><div class="copyright-footer"></div></body></html>
