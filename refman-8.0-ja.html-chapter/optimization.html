<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第 8 章 最適化</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="MySQL 8.0 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 8.0 リファレンスマニュアル"><link rel="prev" href="backup-and-recovery.html" title="第 7 章 バックアップとリカバリ"><link rel="next" href="language-structure.html" title="第 9 章 言語構造"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 8 章 最適化</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="backup-and-recovery.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="language-structure.html">次へ</a></td></tr></table><hr></div><div class="status-header"><p class="alert">このページは機械翻訳したものです。</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="optimization"></a>第 8 章 最適化</h1></div></div></div><div class="toc"><p><b>目次</b></p><dl class="toc"><dt><span class="section"><a href="optimization.html#optimize-overview">8.1 最適化の概要</a></span></dt><dt><span class="section"><a href="optimization.html#statement-optimization">8.2 SQL ステートメントの最適化</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#select-optimization">8.2.1 SELECT ステートメントの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#subquery-optimization">8.2.2 サブクエリー、導出テーブル、ビュー参照および共通テーブル式の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#information-schema-optimization">8.2.3 INFORMATION_SCHEMA クエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#performance-schema-optimization">8.2.4 パフォーマンススキーマクエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#data-change-optimization">8.2.5 データ変更ステートメントの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#permission-optimization">8.2.6 データベース権限の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#miscellaneous-optimization-tips">8.2.7 その他の最適化のヒント</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimization-indexes">8.3 最適化とインデックス</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#mysql-indexes">8.3.1 MySQL のインデックスの使用の仕組み</a></span></dt><dt><span class="section"><a href="optimization.html#primary-key-optimization">8.3.2 主キーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#spatial-index-optimization">8.3.3 SPATIAL インデックス最適化</a></span></dt><dt><span class="section"><a href="optimization.html#foreign-key-optimization">8.3.4 外部キーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#column-indexes">8.3.5 カラムインデックス</a></span></dt><dt><span class="section"><a href="optimization.html#multiple-column-indexes">8.3.6 マルチカラムインデックス</a></span></dt><dt><span class="section"><a href="optimization.html#verifying-index-usage">8.3.7 インデックスの使用の確認</a></span></dt><dt><span class="section"><a href="optimization.html#index-statistics">8.3.8 InnoDB および MyISAM インデックス統計コレクション</a></span></dt><dt><span class="section"><a href="optimization.html#index-btree-hash">8.3.9 B ツリーインデックスとハッシュインデックスの比較</a></span></dt><dt><span class="section"><a href="optimization.html#index-extensions">8.3.10 インデックス拡張の使用</a></span></dt><dt><span class="section"><a href="optimization.html#generated-column-index-optimizations">8.3.11 生成されたカラムインデックスのオプティマイザによる使用</a></span></dt><dt><span class="section"><a href="optimization.html#invisible-indexes">8.3.12 不可視のインデックス</a></span></dt><dt><span class="section"><a href="optimization.html#descending-indexes">8.3.13 降順インデックス</a></span></dt><dt><span class="section"><a href="optimization.html#timestamp-lookups">8.3.14 TIMESTAMP カラムからのインデックス付きルックアップ</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimizing-database-structure">8.4 データベース構造の最適化</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#data-size">8.4.1 データサイズの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimize-data-types">8.4.2 MySQL データ型の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimize-multi-tables">8.4.3 多数のテーブルの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#internal-temporary-tables">8.4.4 MySQL での内部一時テーブルの使用</a></span></dt><dt><span class="section"><a href="optimization.html#database-count-limit">8.4.5 データベースおよびテーブルの数に対する制限</a></span></dt><dt><span class="section"><a href="optimization.html#table-size-limit">8.4.6 テーブルサイズの制限</a></span></dt><dt><span class="section"><a href="optimization.html#column-count-limit">8.4.7 テーブルカラム数と行サイズの制限</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimizing-innodb">8.5 InnoDB テーブルの最適化</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#optimizing-innodb-storage-layout">8.5.1 InnoDB テーブルのストレージレイアウトの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-transaction-management">8.5.2 InnoDB トランザクション管理の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#innodb-performance-ro-txn">8.5.3 InnoDB の読み取り専用トランザクションの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-logging">8.5.4 InnoDB redo ロギングの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-bulk-data-loading">8.5.5 InnoDB テーブルの一括データロード</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-queries">8.5.6 InnoDB クエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-ddl-operations">8.5.7 InnoDB DDL 操作の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-diskio">8.5.8 InnoDB ディスク I/O の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-configuration-variables">8.5.9 InnoDB 構成変数の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-many-tables">8.5.10 多くのテーブルのあるシステムに対する InnoDB の最適化</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimizing-myisam">8.6 MyISAM テーブルの最適化</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#optimizing-queries-myisam">8.6.1 MyISAM クエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-myisam-bulk-data-loading">8.6.2 MyISAM テーブルの一括データロード</a></span></dt><dt><span class="section"><a href="optimization.html#repair-table-optimization">8.6.3 REPAIR TABLE ステートメントの最適化</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimizing-memory-tables">8.7 MEMORY テーブルの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#execution-plan-information">8.8 クエリー実行プランの理解</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#using-explain">8.8.1 EXPLAIN によるクエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#explain-output">8.8.2 EXPLAIN 出力フォーマット</a></span></dt><dt><span class="section"><a href="optimization.html#explain-extended">8.8.3 拡張 EXPLAIN 出力形式</a></span></dt><dt><span class="section"><a href="optimization.html#explain-for-connection">8.8.4 名前付き接続の実行計画情報の取得</a></span></dt><dt><span class="section"><a href="optimization.html#estimating-performance">8.8.5 クエリーパフォーマンスの推定</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#controlling-optimizer">8.9 クエリーオプティマイザの制御</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#controlling-query-plan-evaluation">8.9.1 クエリー計画評価の制御</a></span></dt><dt><span class="section"><a href="optimization.html#switchable-optimizations">8.9.2 切り替え可能な最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizer-hints">8.9.3 オプティマイザヒント</a></span></dt><dt><span class="section"><a href="optimization.html#index-hints">8.9.4 インデックスヒント</a></span></dt><dt><span class="section"><a href="optimization.html#cost-model">8.9.5 オプティマイザコストモデル</a></span></dt><dt><span class="section"><a href="optimization.html#optimizer-statistics">8.9.6 オプティマイザ統計</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#buffering-caching">8.10 バッファリングとキャッシュ</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#innodb-buffer-pool-optimization">8.10.1 InnoDB バッファプールの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#myisam-key-cache">8.10.2 MyISAM キーキャッシュ</a></span></dt><dt><span class="section"><a href="optimization.html#statement-caching">8.10.3 プリペアドステートメントおよびストアドプログラムのキャッシュ</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#locking-issues">8.11 ロック操作の最適化</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#internal-locking">8.11.1 内部ロック方法</a></span></dt><dt><span class="section"><a href="optimization.html#table-locking">8.11.2 テーブルロックの問題</a></span></dt><dt><span class="section"><a href="optimization.html#concurrent-inserts">8.11.3 同時挿入</a></span></dt><dt><span class="section"><a href="optimization.html#metadata-locking">8.11.4 メタデータのロック</a></span></dt><dt><span class="section"><a href="optimization.html#external-locking">8.11.5 外部ロック</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimizing-server">8.12 MySQL サーバーの最適化</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#disk-issues">8.12.1 ディスク I/O の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#symbolic-links">8.12.2 シンボリックリンクの使用</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-memory">8.12.3 メモリーの使用の最適化</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimize-benchmarking">8.13 パフォーマンスの測定 (ベンチマーク)</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#select-benchmarking">8.13.1 式と関数の速度の測定</a></span></dt><dt><span class="section"><a href="optimization.html#custom-benchmarks">8.13.2 独自のベンチマークの使用</a></span></dt><dt><span class="section"><a href="optimization.html#monitoring-performance-schema">8.13.3 performance_schema によるパフォーマンスの測定</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#thread-information">8.14 サーバースレッド (プロセス) 情報の確認</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#processlist-access">8.14.1 プロセスリストへのアクセス</a></span></dt><dt><span class="section"><a href="optimization.html#thread-commands">8.14.2 スレッドのコマンド値</a></span></dt><dt><span class="section"><a href="optimization.html#general-thread-states">8.14.3 一般的なスレッドの状態</a></span></dt><dt><span class="section"><a href="optimization.html#source-thread-states">8.14.4 レプリケーションソーススレッドの状態</a></span></dt><dt><span class="section"><a href="optimization.html#replica-io-thread-states">8.14.5 レプリケーション I/O スレッドの状態</a></span></dt><dt><span class="section"><a href="optimization.html#replica-sql-thread-states">8.14.6 レプリケーション SQL スレッドの状態</a></span></dt><dt><span class="section"><a href="optimization.html#replica-connection-thread-states">8.14.7 レプリケーション接続スレッドの状態</a></span></dt><dt><span class="section"><a href="optimization.html#mysql-cluster-thread-states">8.14.8 NDB Cluster スレッドの状態</a></span></dt><dt><span class="section"><a href="optimization.html#event-scheduler-thread-states">8.14.9 イベントスケジューラスレッドの状態</a></span></dt></dl></dd></dl></div><a class="indexterm" name="idm45661481817920"></a><a class="indexterm" name="idm45661481816464"></a><a class="indexterm" name="idm45661481815120"></a><p>
    この章では、MySQL のパフォーマンスを最適化する方法について説明し、例を示します。 最適化には、いくつかのレベルでの構成、チューニング、およびパフォーマンスの測定が含まれます。 業務の役割 (開発者、データベース管理者、または両方の組み合わせ) に応じて、個々の SQL ステートメント、アプリケーション全体、単一のデータベースサーバー、または複数のネットワーク接続されたデータベースサーバーのレベルで最適化できます。 プロアクティブにパフォーマンスを事前に計画する場合や、または問題の発生後に、構成やコードの問題のトラブルシューティングを行う場合があります。 CPU やメモリーの使用を最適化することで、スケーラビリティーを向上し、データベースを低下させず、より多くの負荷を処理させることもできます。 
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="optimize-overview"></a>8.1 最適化の概要</h2></div></div></div><p>
      データベースのパフォーマンスは、テーブル、クエリー、構成設定など、データベースレベルの複数の要因に依存します。 これらのソフトウェア構造は、ハードウェアレベルでの CPU および I/O 操作につながり、それらを最小限にし、可能なかぎり効率的にする必要があります。 データベースのパフォーマンスを行う際は、ソフトウェア側の高レベルのルールとガイドラインについて学び、時計を使ってパフォーマンスを測定することから始めます。 熟練するにつれ、内部で起こっていることについて詳しく学習し、CPU サイクルや I/O 操作などの測定を開始します。 
    </p><p>
      一般的なユーザーの目標は、既存のソフトウェアやハードウェア構成から、最高のデータベースパフォーマンスを得ることです。 上級ユーザーは、MySQL ソフトウェア自体を改善する機会を見つけたり、独自のストレージエンジンやハードウェアアプライアンスを開発して、MySQL エコシステムを拡張したりします。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#optimize-database-level" title="データベースレベルでの最適化">データベースレベルでの最適化</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#optimize-hardware-level" title="ハードウェアレベルでの最適化">ハードウェアレベルでの最適化</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#optimize-portability-performance" title="移植性とパフォーマンスのバランス">移植性とパフォーマンスのバランス</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="optimize-database-level"></a>データベースレベルでの最適化</h3></div></div></div><p>
        データベースアプリケーションを高速にすることにおいてもっとも重要な要素は、その基本設計です。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブルは適切に構築されていますか。 特に、カラムに適切なデータ型があり、各テーブルに、作業の種類に適切なカラムがありますか。 たとえば、頻繁な更新を実行するアプリケーションでは、多くの場合に少数のカラムのある多数のテーブルを使用し、大量のデータを解析するアプリケーションでは、多くの場合に多数のカラムのある少数のテーブルを使用します。 
          </p></li><li class="listitem"><p>
            クエリーを効率的にするため、適切な<a class="link" href="optimization.html#optimization-indexes" title="8.3 最適化とインデックス">インデックス</a>が設定されていますか。
          </p></li><li class="listitem"><p>
            テーブルごとに適切なストレージエンジンを使用しており、使用している各ストレージエンジンの長所と機能を生かしていますか。 特に、<code class="literal"><a class="link" href="optimization.html#optimizing-innodb" title="8.5 InnoDB テーブルの最適化">InnoDB</a></code> などのトランザクションストレージエンジンまたは <code class="literal"><a class="link" href="optimization.html#optimizing-myisam" title="8.6 MyISAM テーブルの最適化">MyISAM</a></code> などの非トランザクションストレージエンジンの選択は、パフォーマンスとスケーラビリティーにきわめて重要な場合があります。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">InnoDB</code> は、新しいテーブルのデフォルトのストレージエンジンです。 実際に、高度な <code class="literal">InnoDB</code> パフォーマンス機能は、<code class="literal">InnoDB</code> テーブルが、特にビジーなデータベースに対して、多くの場合に単純な <code class="literal">MyISAM</code> テーブルよりパフォーマンスが優れていることを意味します。 
            </p></div></li><li class="listitem"><p>
            各テーブルは適切な行フォーマットを使用していますか。 この選択は、テーブルに使用されるストレージエンジンによっても異なります。 特に、圧縮テーブルは使用するディスク領域が減るため、データの読み取りと書き込みに必要なディスク I/O も少なくなります。 圧縮は、<code class="literal">InnoDB</code> テーブルでのあらゆる種類のワークロードと、読み取り専用 <code class="literal">MyISAM</code> テーブルに使用できます。 
          </p></li><li class="listitem"><p>
            アプリケーションでは、適切な<a class="link" href="optimization.html#locking-issues" title="8.11 ロック操作の最適化">ロック戦略</a>を使用していますか。 たとえば、データベース操作を同時に実行できるように、可能なかぎり共有アクセスを許可したり、重要な操作が最優先されるように、適切な場合に排他的アクセスを要求したりするなどです。 ここでも、ストレージエンジンの選択が重要です。 <code class="literal">InnoDB</code> ストレージエンジンは、ユーザーが関与せずに、ほとんどのロックの問題を処理するため、データベースの同時実行性を向上し、コードの実験やチューニングの量を削減できます。 
          </p></li><li class="listitem"><p>
            <a class="link" href="optimization.html#buffering-caching" title="8.10 バッファリングとキャッシュ">キャッシュに使用されるメモリー領域</a>がすべて正しくサイズ設定されていますか。 つまり、頻繁にアクセスされるデータを保持するために十分な大きさがありながらも、物理メモリーをオーバーロードし、ページングを発生させるほど大きくしません。 構成するメインメモリー領域は、<code class="literal">InnoDB</code> バッファプールおよび <code class="literal">MyISAM</code> キーキャッシュです。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="optimize-hardware-level"></a>ハードウェアレベルでの最適化</h3></div></div></div><p>
        データベースがビジーになるほど、どんなデータベースアプリケーションも最終的にハードウェアの制限に達します。 データベース管理者は、アプリケーションをチューニングするか、サーバーを再構成してこれらの<a class="link" href="glossary.html#glos_bottleneck" title="ボトルネック">ボトルネック</a>を回避できるかどうか、または追加のハードウェアリソースが必要かどうかを評価する必要があります。 システムボトルネックは一般に次の原因から発生します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ディスクシーク。 ディスクがデータを検索するには時間がかかります。 最新のディスクでは、通常この平均時間が 10 ms 未満であるため、理論的には 1 秒間に約 100 シーク実行できることになります。 この時間は、新しいディスクでは徐々に改善されますが、1 つのテーブルに対して最適化することはきわめて困難です。 シーク時間を最適化する方法は、複数のディスクにデータを分散することです。 
          </p></li><li class="listitem"><p>
            ディスクの読み取りと書き込み。 ディスクが正しい位置にある場合に、データを読み取りまたは書き込みする必要があります。 最新のディスクでは、1 つのディスクで少なくとも 10 - 20M バイト/秒のスループットを実現します。 これは、複数のディスクから並列で読み取ることができるため、シークより最適化が簡単です。 
          </p></li><li class="listitem"><p>
            CPU サイクル。 データがメインメモリー内にある場合、結果を得るために、それを処理する必要があります。 メモリーの量と比較して大きなテーブルを使用することは、もっとも一般的な制限要因になります。 しかし、小さいテーブルでは、通常速度は問題になりません。 
          </p></li><li class="listitem"><p>
            メモリー帯域幅。 CPU で、CPU キャッシュに収められるより多くのデータを必要とする場合、メインメモリーの帯域幅がボトルネックになります。 これは、ほとんどのシステムでまれなボトルネックですが、認識しておくべきです。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="optimize-portability-performance"></a>移植性とパフォーマンスのバランス</h3></div></div></div><a class="indexterm" name="idm45661481768240"></a><p>
        ポータブル MySQL プログラムで、パフォーマンス指向の SQL 拡張を使用するには、ステートメント内の MySQL 固有のキーワードを <code class="literal">/*! */</code> コメント区切り文字で囲むことができます。 ほかの SQL サーバーはコメントにされたキーワードを無視します。 コメントの作成については、<a class="xref" href="language-structure.html#comments" title="9.7 コメント">セクション9.7「コメント」</a>を参照してください。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="statement-optimization"></a>8.2 SQL ステートメントの最適化</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#select-optimization">8.2.1 SELECT ステートメントの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#subquery-optimization">8.2.2 サブクエリー、導出テーブル、ビュー参照および共通テーブル式の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#information-schema-optimization">8.2.3 INFORMATION_SCHEMA クエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#performance-schema-optimization">8.2.4 パフォーマンススキーマクエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#data-change-optimization">8.2.5 データ変更ステートメントの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#permission-optimization">8.2.6 データベース権限の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#miscellaneous-optimization-tips">8.2.7 その他の最適化のヒント</a></span></dt></dl></div><a class="indexterm" name="idm45661481762912"></a><p>
      インタプリタから直接発行されるか、API によって内部で送信されるかに関係なく、データベースアプリケーションのコアロジックは SQL ステートメントによって実行されます。 このセクションのチューニングのガイドラインは、あらゆる種類の MySQL アプリケーションの高速化に役立ちます。 このガイドラインでは、データを読み取りおよび書き込みする SQL 操作、一般的な SQL 操作の内部オーバーヘッド、およびデータベースモニタリングなどの特定のシナリオで使われる操作について説明します。 
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="select-optimization"></a>8.2.1 SELECT ステートメントの最適化</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#where-optimization">8.2.1.1 WHERE 句の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#range-optimization">8.2.1.2 range の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#index-merge-optimization">8.2.1.3 インデックスマージの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#hash-joins">8.2.1.4 ハッシュ結合の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#engine-condition-pushdown-optimization">8.2.1.5 エンジンコンディションプッシュダウンの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#index-condition-pushdown-optimization">8.2.1.6 インデックスコンディションプッシュダウンの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#nested-loop-joins">8.2.1.7 Nested Loop 結合アルゴリズム</a></span></dt><dt><span class="section"><a href="optimization.html#nested-join-optimization">8.2.1.8 ネストした結合の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#outer-join-optimization">8.2.1.9 外部結合の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#outer-join-simplification">8.2.1.10 外部結合の単純化</a></span></dt><dt><span class="section"><a href="optimization.html#mrr-optimization">8.2.1.11 Multi-Range Read の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#bnl-bka-optimization">8.2.1.12 Block Nested Loop 結合と Batched Key Access 結合</a></span></dt><dt><span class="section"><a href="optimization.html#condition-filtering">8.2.1.13 条件フィルタ</a></span></dt><dt><span class="section"><a href="optimization.html#constant-folding-optimization">8.2.1.14 定数 - フォールディングの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#is-null-optimization">8.2.1.15 IS NULL の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#order-by-optimization">8.2.1.16 ORDER BY の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#group-by-optimization">8.2.1.17 GROUP BY の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#distinct-optimization">8.2.1.18 DISTINCT の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#limit-optimization">8.2.1.19 LIMIT クエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#function-optimization">8.2.1.20 関数コールの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#window-function-optimization">8.2.1.21 ウィンドウ機能最適化</a></span></dt><dt><span class="section"><a href="optimization.html#row-constructor-optimization">8.2.1.22 行コンストラクタ式の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#table-scan-avoidance">8.2.1.23 全テーブルスキャンの回避</a></span></dt></dl></div><a class="indexterm" name="idm45661481757824"></a><a class="indexterm" name="idm45661481755712"></a><a class="indexterm" name="idm45661481753680"></a><p>
        <code class="literal">SELECT</code> ステートメントの形式のクエリーは、データベースのすべてのルックアップ操作を実行します。 動的 Web ページの 1 秒未満の応答時間を達成するためでも、または巨大な夜間のレポートを生成するための時間から数時間を取り除くためでも、これらのステートメントのチューニングは最優先です。 
      </p><p>
        <code class="literal">SELECT</code> ステートメントに加えて、クエリーのチューニング手法は <code class="literal">DELETE</code> ステートメントの <code class="literal">CREATE TABLE...AS SELECT</code>、<code class="literal">INSERT INTO...SELECT</code>、<code class="literal">WHERE</code> 句などの構成要素にも適用されます。 これらのステートメントは、書込み操作と読取り指向クエリー操作を組み合せるため、パフォーマンスに関する追加の考慮事項があります。 
      </p><p>
        NDB Cluster は結合プッシュダウン最適化をサポートしており、そこで適格な結合が NDB Cluster データノードに完全に送信され、そこでそれらのノード間で分散して並列で実行できます。 この最適化の詳細は、<a class="xref" href="mysql-cluster.html#ndb_join_pushdown-conditions" title="NDB プッシュダウン結合の条件">NDB プッシュダウン結合の条件</a> を参照してください。 
      </p><p>
        クエリーの最適化の主な考慮事項は次のとおりです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            遅い <code class="literal">SELECT ... WHERE</code> クエリーを高速化するため、最初に確認することは、<a class="link" href="glossary.html#glos_index" title="インデックス">インデックス</a>を追加できるかどうかです。 <code class="literal">WHERE</code> 句で使用するカラムにインデックスをセットアップし、評価、フィルタリング、および最終的な結果の取得を高速化します。 無駄なディスク領域を避けるため、アプリケーションで使用される多くの関連クエリーを高速化する少数のインデックスのセットを構築します。 
          </p><p>
            インデックスは、<a class="link" href="glossary.html#glos_join" title="結合">結合</a>や<a class="link" href="glossary.html#glos_foreign_key" title="外部キー">外部キー</a>などの機能を使用して、さまざまなテーブルを参照するクエリーに特に重要です。 <code class="literal">EXPLAIN</code> ステートメントを使用して、<code class="literal">SELECT</code> に使用するインデックスを判断できます。 <a class="xref" href="optimization.html#mysql-indexes" title="8.3.1 MySQL のインデックスの使用の仕組み">セクション8.3.1「MySQL のインデックスの使用の仕組み」</a>および<a class="xref" href="optimization.html#using-explain" title="8.8.1 EXPLAIN によるクエリーの最適化">セクション8.8.1「EXPLAIN によるクエリーの最適化」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            過度な時間がかかる関数呼び出しなどのクエリーの部分を特定し、チューニングします。 クエリーの構築の仕方によっては、関数が結果セットのすべての行に対して 1 回ずつ、さらにはテーブル内のすべての行に対して 1 回ずつ呼び出されるなど、大幅に非効率性を拡大させていることがあります。 
          </p></li><li class="listitem"><p>
            特に大きなテーブルの場合に、クエリーでの<a class="link" href="glossary.html#glos_full_table_scan" title="テーブルの完全スキャン">完全テーブルスキャン</a>の回数を最小にします。
          </p></li><li class="listitem"><p>
            <code class="literal">ANALYZE TABLE</code> ステートメントを定期的に使用して、テーブル統計を最新に維持し、オプティマイザが、効率的な実行プランを立てるために必要な情報が得られるようにします。
          </p></li><li class="listitem"><p>
            チューニング技法、インデックス作成技法、および各テーブルのストレージエンジンに固有の構成パラメータについて学習します。 <code class="literal">InnoDB</code> と <code class="literal">MyISAM</code> のどちらでも、クエリーの高いパフォーマンスを可能にし、維持するための一連のガイドラインがあります。 詳細については、<a class="xref" href="optimization.html#optimizing-innodb-queries" title="8.5.6 InnoDB クエリーの最適化">セクション8.5.6「InnoDB クエリーの最適化」</a>および<a class="xref" href="optimization.html#optimizing-queries-myisam" title="8.6.1 MyISAM クエリーの最適化">セクション8.6.1「MyISAM クエリーの最適化」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <a class="xref" href="optimization.html#innodb-performance-ro-txn" title="8.5.3 InnoDB の読み取り専用トランザクションの最適化">セクション8.5.3「InnoDB の読み取り専用トランザクションの最適化」</a> の手法を使用して、<code class="literal">InnoDB</code> テーブルの単一クエリートランザクションを最適化できます。
          </p></li><li class="listitem"><p>
            特にオプティマイザで同じ変換の一部を自動的に実行する場合、理解が困難になるようなクエリーの変換を避けます。
          </p></li><li class="listitem"><p>
            いずれかの基本ガイドラインによって、パフォーマンスの問題が簡単に解決されない場合、<code class="literal">EXPLAIN</code> プランを読み、インデックス、<code class="literal">WHERE</code> 句、結合句などを調整して、特定のクエリーの内部の詳細を調査します。 (ある程度の専門技術に達している場合は、<code class="literal">EXPLAIN</code> プランを読むことがすべてのクエリーの最初の手順になると考えられます。) 
          </p></li><li class="listitem"><p>
            MySQL がキャッシュに使用するメモリー領域のサイズとプロパティーを調整します。 <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>、<code class="literal">MyISAM</code> キーキャッシュ、および MySQL クエリーキャッシュの効率的な使用によって、2 回目以降、メモリーから結果が取得されるため、繰り返しのクエリーの実行が高速化します。 
          </p></li><li class="listitem"><p>
            キャッシュメモリー領域を使用して高速に実行するクエリーでも、必要なキャッシュメモリーを減らして、アプリケーションがよりスケーラブルになるように、さらに最適化できます。 スケーラビリティーは、パフォーマンスを大幅に低下させずに、アプリケーションでより多くの同時ユーザー、大きなリクエストなどを処理できることを意味します。 
          </p></li><li class="listitem"><p>
            クエリーの速度が、テーブルに同時にアクセスしているほかのセッションによって影響を受ける可能性があるロックの問題を処理します。
          </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="where-optimization"></a>8.2.1.1 WHERE 句の最適化</h4></div></div></div><a class="indexterm" name="idm45661481704384"></a><a class="indexterm" name="idm45661481703328"></a><p>
          このセクションでは、<code class="literal">WHERE</code> 句の処理で実行可能な最適化について説明します。 例では <code class="literal">SELECT</code> ステートメントを使用していますが、<code class="literal">DELETE</code> および <code class="literal">UPDATE</code> ステートメント内の <code class="literal">WHERE</code> 句にも同じ最適化を適用します。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            MySQL オプティマイザへの取り組みは継続中であるため、MySQL が実行する最適化のすべてをここで説明しているわけではありません。
          </p></div><p>
          読みやすさを犠牲にしても、算術演算を高速化するように、クエリーを書き換えたいと考えがちです。 MySQL では同様の最適化を自動的に実行するため、多くの場合にこの作業を回避でき、クエリーを理解しやすく、保守しやすい形式のままにしておくことができます。 MySQL によって実行される最適化の一部を次に示します。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              不要なかっこの削除:
            </p><pre class="programlisting">   ((a AND b) AND c OR (((a AND b) AND (c AND d))))
-&gt; (a AND b AND c) OR (a AND b AND c AND d)
</pre></li><li class="listitem"><p>
              定数畳み込み:
            </p><pre class="programlisting">   (a&lt;b AND b=c) AND a=5
-&gt; b&gt;5 AND b=c AND a=5
</pre></li><li class="listitem"><p>
              一定条件の削除:
            </p><pre class="programlisting">   (b&gt;=5 AND b=5) OR (b=6 AND 5=5) OR (b=7 AND 5=6)
-&gt; b=5 OR b=6
</pre><p>
              MySQL 8.0.14 以降では、これは最適化フェーズではなく準備中に行われるため、結合の簡略化に役立ちます。 詳細および例は、<a class="xref" href="optimization.html#outer-join-optimization" title="8.2.1.9 外部結合の最適化">セクション8.2.1.9「外部結合の最適化」</a> を参照してください。 
            </p></li><li class="listitem"><p>
              インデックスによって使用される定数式は 1 回だけ評価されます。
            </p></li><li class="listitem"><p>
              MySQL 8.0.16 以降では、定数値を持つ数値型のカラムの比較がチェックされて折りたたまれるか、無効な値または範囲外の値がないかどうかが削除されます:
            </p><pre class="programlisting"># CREATE TABLE t (c TINYINT UNSIGNED NOT NULL);
  SELECT * FROM t WHERE c ≪ 256;
-≫ SELECT * FROM t WHERE 1;
</pre><p>
              詳しくは<a class="xref" href="optimization.html#constant-folding-optimization" title="8.2.1.14 定数 - フォールディングの最適化">セクション8.2.1.14「定数 - フォールディングの最適化」</a>,をご覧ください。
            </p></li><li class="listitem"><p>
              <code class="literal">WHERE</code> を使用しない単一テーブルの <code class="literal">COUNT(*)</code> は、<code class="literal">MyISAM</code> テーブルと <code class="literal">MEMORY</code> テーブルのテーブル情報から直接取得されます。 これは、1 つだけのテーブルで使用された場合に、<code class="literal">NOT NULL</code> 式にも実行されます。 
            </p></li><li class="listitem"><p>
              無効な定数式の早期の検出。 MySQL は一部の <code class="literal">SELECT</code> ステートメントが実行不可能であることをすみやかに検出し、行を返しません。 
            </p></li><li class="listitem"><p>
              <code class="literal">GROUP BY</code> または集約関数 (<code class="literal">COUNT()</code>、<code class="literal">MIN()</code> など) を使用しない場合、<code class="literal">HAVING</code> は <code class="literal">WHERE</code> とマージされます。
            </p></li><li class="listitem"><p>
              結合内の各テーブルについて、テーブルの高速の <code class="literal">WHERE</code> 評価を取得し、可能なかぎり早く行をスキップするために、より単純な <code class="literal">WHERE</code> が構築されます。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm45661481666256"></a> <a class="indexterm" name="idm45661481664832"></a> クエリー内のほかのすべてのテーブルの前に、まず、すべての定数テーブルが読み取られます。 定数テーブルは次のいずれかです。 
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  空白のテーブルまたは 1 行のテーブル。
                </p></li><li class="listitem"><p>
                  <code class="literal">PRIMARY KEY</code> または <code class="literal">UNIQUE</code> インデックスでの <code class="literal">WHERE</code> 句で使用されるテーブル。ここではすべてのインデックス部分が定数式と比較され、<code class="literal">NOT NULL</code> として定義されます。
                </p></li></ul></div><p>
              次のテーブルはすべて定数テーブルとして使用されます。
            </p><pre class="programlisting">SELECT * FROM t WHERE <em class="replaceable"><code>primary_key</code></em>=1;
SELECT * FROM t1,t2
  WHERE t1.<em class="replaceable"><code>primary_key</code></em>=1 AND t2.<em class="replaceable"><code>primary_key</code></em>=t1.id;
</pre></li><li class="listitem"><p>
              テーブルを結合するための最適な結合の組み合わせは、すべての可能性を試してみることで見つかります。 <code class="literal">ORDER BY</code> および <code class="literal">GROUP BY</code> 句内のすべてのカラムが同じテーブルにある場合、結合する際に最初にそのテーブルが選ばれます。 
            </p></li><li class="listitem"><p>
              <code class="literal">ORDER BY</code> 句と別の <code class="literal">GROUP BY</code> 句がある場合、または、<code class="literal">ORDER BY</code> または <code class="literal">GROUP BY</code> に結合キュー内の最初のテーブルと異なるテーブルのカラムが含まれている場合は、一時テーブルが作成されます。
            </p></li><li class="listitem"><p>
              <code class="literal">SQL_SMALL_RESULT</code> 修飾子を使用する場合、MySQL はインメモリー一時テーブルを使用します。
            </p></li><li class="listitem"><p>
              オプティマイザがテーブルスキャンを使用する方が効率的であると判断しないかぎり、各テーブルインデックスがクエリーされ、最適なインデックスが使用されます。 かつて、スキャンは、最適なインデックスがテーブルの 30% 超にまたがっているかどうかに基づいて使用されていましたが、固定のパーセンテージによって、インデックスを使用するか、スキャンを使用するかの選択が決定されなくなりました。 現在のオプティマイザは複雑になり、テーブルサイズ、行数、I/O ブロックサイズなどの追加の要因に基づいて推定します。 
            </p></li><li class="listitem"><p>
              場合によって、MySQL はデータファイルを参照しなくてもインデックスから行を読み取ることができます。 インデックスから使用されるすべてのカラムが数値の場合、クエリーの解決にインデックスツリーのみが使用されます。 
            </p></li><li class="listitem"><p>
              各行が出力される前に、<code class="literal">HAVING</code> 句に一致しないものはスキップされます。
            </p></li></ul></div><p>
          きわめて高速なクエリーのいくつかの例:
        </p><pre class="programlisting">SELECT COUNT(*) FROM <em class="replaceable"><code>tbl_name</code></em>;

SELECT MIN(<em class="replaceable"><code>key_part1</code></em>),MAX(<em class="replaceable"><code>key_part1</code></em>) FROM <em class="replaceable"><code>tbl_name</code></em>;

SELECT MAX(<em class="replaceable"><code>key_part2</code></em>) FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_part1</code></em>=<em class="replaceable"><code>constant</code></em>;

SELECT ... FROM <em class="replaceable"><code>tbl_name</code></em>
  ORDER BY <em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>,... LIMIT 10;

SELECT ... FROM <em class="replaceable"><code>tbl_name</code></em>
  ORDER BY <em class="replaceable"><code>key_part1</code></em> DESC, <em class="replaceable"><code>key_part2</code></em> DESC, ... LIMIT 10;
</pre><p>
          MySQL は、インデックス設定されたカラムが数値であるとして、インデックスツリーのみを使用して、次のクエリーを解決します。
        </p><pre class="programlisting">SELECT <em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em> FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_part1</code></em>=<em class="replaceable"><code>val</code></em>;

SELECT COUNT(*) FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_part1</code></em>=<em class="replaceable"><code>val1</code></em> AND <em class="replaceable"><code>key_part2</code></em>=<em class="replaceable"><code>val2</code></em>;

SELECT <em class="replaceable"><code>key_part2</code></em> FROM <em class="replaceable"><code>tbl_name</code></em> GROUP BY <em class="replaceable"><code>key_part1</code></em>;
</pre><p>
          次のクエリーは、個別のソーティングパスを使用せずに、インデックスを使用して、ソート順で行を取得します。
        </p><pre class="programlisting">SELECT ... FROM <em class="replaceable"><code>tbl_name</code></em>
  ORDER BY <em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>,... ;

SELECT ... FROM <em class="replaceable"><code>tbl_name</code></em>
  ORDER BY <em class="replaceable"><code>key_part1</code></em> DESC, <em class="replaceable"><code>key_part2</code></em> DESC, ... ;
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="range-optimization"></a>8.2.1.2 range の最適化</h4></div></div></div><p>
          <code class="literal">range</code> アクセスメソッドは単一のインデックスを使用して、1 つまたは複数のインデックス値間隔の中に含まれるテーブル行のサブセットを取得します。 これは、シングルパートまたはマルチパートインデックスに使用できます。 次の各セクションでは、オプティマイザが範囲アクセスを使用する条件について説明します。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#range-access-single-part" title="単一部品インデックスの範囲アクセス方法">単一部品インデックスの範囲アクセス方法</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#range-access-multi-part" title="マルチパートインデックスの範囲アクセス方法">マルチパートインデックスの範囲アクセス方法</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#equality-range-optimization" title="複数値比較の等価範囲の最適化">複数値比較の等価範囲の最適化</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#range-access-skip-scan" title="スキャン範囲アクセス方法のスキップ">スキャン範囲アクセス方法のスキップ</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#row-constructor-range-optimization" title="行コンストラクタ式の範囲最適化">行コンストラクタ式の範囲最適化</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#range-optimization-memory-use" title="範囲最適化のためのメモリー使用の制限">範囲最適化のためのメモリー使用の制限</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="range-access-single-part"></a>単一部品インデックスの範囲アクセス方法</h5></div></div></div><p>
            単一パートインデックスの場合、インデックス値の間隔は、<span class="quote">「<span class="quote">intervals</span>」</span> ではなく<span class="firstterm">範囲条件</span>として示される <code class="literal">WHERE</code> 句内の対応する条件によって便利に表現できます。
          </p><p>
            シングルパートインデックスの範囲条件の定義は次のとおりです。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">BTREE</code> インデックスと <code class="literal">HASH</code> インデックスの両方で、キー部分と定数値の比較は、<code class="literal">=</code>, <code class="literal">&lt;=&gt;</code>, <code class="literal">IN()</code>, <code class="literal">IS NULL</code> または <code class="literal">IS NOT NULL</code> 演算子を使用する場合の範囲条件です。
              </p></li><li class="listitem"><p>
                さらに、<code class="literal">BTREE</code> インデックスでは、<code class="literal">&gt;</code>、<code class="literal">&lt;</code>、<code class="literal">&gt;=</code>、<code class="literal">&lt;=</code>、<code class="literal">BETWEEN</code>、<code class="literal">!=</code>、または <code class="literal">&lt;&gt;</code> 演算子、または <code class="literal">LIKE</code> への引数が、ワイルドカード文字で始まっていない定数文字列である場合の <code class="literal">LIKE</code> 比較を使用した場合に、キーパートと定数値の比較は範囲条件です。
              </p></li><li class="listitem"><p>
                すべてのインデックスタイプで、<code class="literal">OR</code> または <code class="literal">AND</code> と組み合せた複数の範囲条件によって範囲条件が形成されます。
              </p></li></ul></div><p>
            先述の<span class="quote">「<span class="quote">定数値</span>」</span>とは次のいずれかを意味します。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                クエリー文字列からの定数
              </p></li><li class="listitem"><p>
                同じ結合からの <code class="literal">const</code> または <code class="literal">system</code> テーブルのカラム
              </p></li><li class="listitem"><p>
                非相関サブクエリーの結果
              </p></li><li class="listitem"><p>
                以前の型の部分式からのみ構成された式
              </p></li></ul></div><p>
            以下に <code class="literal">WHERE</code> 句内で範囲条件を使用したクエリーのいくつかの例を示します。
          </p><pre class="programlisting">SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_col</code></em> &gt; 1
  AND <em class="replaceable"><code>key_col</code></em> &lt; 10;

SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_col</code></em> = 1
  OR <em class="replaceable"><code>key_col</code></em> IN (15,18,20);

SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_col</code></em> LIKE 'ab%'
  OR <em class="replaceable"><code>key_col</code></em> BETWEEN 'bar' AND 'foo';
</pre><p>
            一部の非定数値は、オプティマイザ定数伝播フェーズで定数に変換できます。
          </p><p>
            MySQL は可能なインデックスごとに、<code class="literal">WHERE</code> 句から範囲条件を抽出しようとします。 抽出プロセス時に、範囲条件の構築に使用できない条件はドロップされ、重複する範囲を生成する条件は組み合わされて、空の範囲を生成する条件は削除されます。 
          </p><p>
            <code class="literal">key1</code> がインデックス設定されたカラムで <code class="literal">nonkey</code> がインデックス設定されていない、次のステートメントを考慮します。
          </p><pre class="programlisting">SELECT * FROM t1 WHERE
  (key1 &lt; 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
  (key1 &lt; 'bar' AND nonkey = 4) OR
  (key1 &lt; 'uux' AND key1 &gt; 'z');
</pre><p>
            キー <code class="literal">key1</code> の抽出プロセスは次のとおりです。
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                元の <code class="literal">WHERE</code> 句から始めます。
              </p><pre class="programlisting">(key1 &lt; 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
(key1 &lt; 'bar' AND nonkey = 4) OR
(key1 &lt; 'uux' AND key1 &gt; 'z')
</pre></li><li class="listitem"><p>
                <code class="literal">nonkey = 4</code> と <code class="literal">key1 LIKE '%b'</code> は、範囲スキャンに使用できないため、削除します。 それらを削除する正しい方法は、範囲スキャンの実行時に一致する行を見落とさないように、それらを <code class="literal">TRUE</code> で置き換えることです。 これらを <code class="literal">TRUE</code> の歩留まりに置き換えます: 
              </p><pre class="programlisting">(key1 &lt; 'abc' AND (key1 LIKE 'abcde%' OR TRUE)) OR
(key1 &lt; 'bar' AND TRUE) OR
(key1 &lt; 'uux' AND key1 &gt; 'z')
</pre></li><li class="listitem"><p>
                常に true または false である条件を縮小します。
              </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">(key1 LIKE 'abcde%' OR TRUE)</code> は常に true です
                  </p></li><li class="listitem"><p>
                    <code class="literal">(key1 &lt; 'uux' AND key1 &gt; 'z')</code> は常に false です
                  </p></li></ul></div><p>
                これらの条件を定数に置き換えると、次のようになります:
              </p><pre class="programlisting">(key1 &lt; 'abc' AND TRUE) OR (key1 &lt; 'bar' AND TRUE) OR (FALSE)
</pre><p>
                不要な <code class="literal">TRUE</code> 定数および <code class="literal">FALSE</code> 定数を削除すると、次のようになります:
              </p><pre class="programlisting">(key1 &lt; 'abc') OR (key1 &lt; 'bar')
</pre></li><li class="listitem"><p>
                重複する間隔を 1 つに組み合わせて、範囲スキャンに使用される最終的な条件が生成されます。
              </p><pre class="programlisting">(key1 &lt; 'bar')
</pre></li></ol></div><p>
            一般に (前の例で示したように)、範囲スキャンに使用される条件は、<code class="literal">WHERE</code> 句より制限がゆるくなります。 MySQL は、範囲条件を満たすが、完全な <code class="literal">WHERE</code> 句でない行をフィルタ処理する追加のチェックを実行します。 
          </p><p>
            範囲条件抽出アルゴリズムは、任意の深さのネストの <code class="literal">AND</code>/<code class="literal">OR</code> 構造を処理でき、その出力は <code class="literal">WHERE</code> 句内の条件が存在する順番に依存しません。
          </p><p>
            MySQL では、空間インデックスの <code class="literal">range</code> アクセス方法に対する複数の範囲のマージはサポートされていません。 この制限を回避するには、同じ <code class="literal">SELECT</code> ステートメントで <code class="literal">UNION</code> を使用できますが、ただし、各空間述語は、別の <code class="literal">SELECT</code> に入れます。 
          </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="range-access-multi-part"></a>マルチパートインデックスの範囲アクセス方法</h5></div></div></div><p>
            マルチパートインデックスの範囲条件は、シングルパートインデックスの範囲条件の拡張です。 マルチパートインデックスの範囲条件は、インデックス行を 1 つまたは複数のキータプル間隔内に入るように制限します。 キータプル間隔は、インデックスからの順序付けを使用して、キータプルのセットに定義されます。 
          </p><p>
            たとえば、<code class="literal">key1(<em class="replaceable"><code>key_part1</code></em>、<em class="replaceable"><code>key_part2</code></em>、<em class="replaceable"><code>key_part3</code></em>)</code> として定義されたマルチパートインデックスと、キー順で示された次のキータプルのセットを考慮します。
          </p><pre class="programlisting"><em class="replaceable"><code>key_part1</code></em>  <em class="replaceable"><code>key_part2</code></em>  <em class="replaceable"><code>key_part3</code></em>
  NULL       1          'abc'
  NULL       1          'xyz'
  NULL       2          'foo'
   1         1          'abc'
   1         1          'xyz'
   1         2          'abc'
   2         1          'aaa'
</pre><p>
            条件 <code class="literal"><em class="replaceable"><code>key_part1</code></em> = 1</code> は次の間隔を定義します。
          </p><pre class="programlisting">(1,-inf,-inf) &lt;= (<em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>,<em class="replaceable"><code>key_part3</code></em>) &lt; (1,+inf,+inf)
</pre><p>
            間隔は前のデータセットの 4、5、6 番目のタプルをカバーし、range アクセスメソッドで使用できます。
          </p><p>
            対照的に、条件 <code class="literal"><em class="replaceable"><code>key_part3</code></em> = 'abc'</code> は単一の間隔を定義せず、range アクセスメソッドで使用できません。
          </p><p>
            次の説明では、マルチパートインデックスに対して、範囲条件がどのように作用するかを詳しく示します。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">HASH</code> インデックスでは、同一の値を含む各間隔を使用できます。 これは次の形式の条件に対してのみ、間隔を生成できることを意味します。 
              </p><pre class="programlisting">    <em class="replaceable"><code>key_part1</code></em> <em class="replaceable"><code>cmp</code></em> <em class="replaceable"><code>const1</code></em>
AND <em class="replaceable"><code>key_part2</code></em> <em class="replaceable"><code>cmp</code></em> <em class="replaceable"><code>const2</code></em>
AND ...
AND <em class="replaceable"><code>key_partN</code></em> <em class="replaceable"><code>cmp</code></em> <em class="replaceable"><code>constN</code></em>;
</pre><p>
                ここで、<em class="replaceable"><code>const1</code></em>、<em class="replaceable"><code>const2</code></em>、… は定数で、<em class="replaceable"><code>cmp</code></em> は、<code class="literal">=</code>、<code class="literal">&lt;=&gt;</code>、または <code class="literal">IS NULL</code> 比較演算子のいずれかで、条件はすべてのインデックスパートをカバーします。 (つまり、<em class="replaceable"><code>N</code></em> パートインデックスの各パートに 1 つずつ <em class="replaceable"><code>N</code></em> 条件があります。) たとえば、次は 3 パート <code class="literal">HASH</code> インデックスの範囲条件です。 
              </p><pre class="programlisting"><em class="replaceable"><code>key_part1</code></em> = 1 AND <em class="replaceable"><code>key_part2</code></em> IS NULL AND <em class="replaceable"><code>key_part3</code></em> = 'foo'
</pre><p>
                何を定数とみなすかの定義については、「<a class="xref" href="optimization.html#range-access-single-part" title="単一部品インデックスの範囲アクセス方法">単一部品インデックスの範囲アクセス方法</a>」を参照してください。
              </p></li><li class="listitem"><p>
                <code class="literal">BTREE</code> インデックスでは、各条件で <code class="literal">=</code>、<code class="literal">&lt;=&gt;</code>、<code class="literal">IS NULL</code>、<code class="literal">&gt;</code>、<code class="literal">&lt;</code>、<code class="literal">&gt;=</code>、<code class="literal">&lt;=</code>、<code class="literal">!=</code>、<code class="literal">&lt;&gt;</code>、<code class="literal">BETWEEN</code>、または <code class="literal">LIKE '<em class="replaceable"><code>pattern</code></em>'</code> (ここで <code class="literal">'<em class="replaceable"><code>pattern</code></em>'</code> はワイルドカードで始まらない) を使用して、キーパートと定数値を比較する、<code class="literal">AND</code> で組み合わされた条件に、間隔を使用できます。 条件に一致するすべての行を含む単一のキータプルを判断できる場合にかぎり、1 つの間隔を使用できます (または <code class="literal">&lt;&gt;</code> または <code class="literal">!=</code> を使用する場合は 2 つの間隔)。 
              </p><p>
                オプティマイザは、比較演算子が <code class="literal">=</code>、<code class="literal">&lt;=&gt;</code>、または <code class="literal">IS NULL</code> である場合にかぎり、追加のキーパートを使用して、間隔を判断しようとします。 演算子が <code class="literal">&gt;</code>、<code class="literal">&lt;</code>、<code class="literal">&gt;=</code>、<code class="literal">&lt;=</code>、<code class="literal">!=</code>、<code class="literal">&lt;&gt;</code>、<code class="literal">BETWEEN</code>、または <code class="literal">LIKE</code> の場合、オプティマイザはそれを使用しますが、追加のキーパートは考慮しません。 次の式では、オプティマイザは最初の比較からの <code class="literal">=</code> を使用します。 さらに 2 番目の比較からの <code class="literal">&gt;=</code> も使用しますが、それ以上のキーパートを考慮せず、間隔の構築に 3 番目の比較を使用しません。 
              </p><pre class="programlisting"><em class="replaceable"><code>key_part1</code></em> = 'foo' AND <em class="replaceable"><code>key_part2</code></em> &gt;= 10 AND <em class="replaceable"><code>key_part3</code></em> &gt; 10
</pre><p>
                単一の間隔は次のとおりです。
              </p><pre class="programlisting">('foo',10,-inf) &lt; (<em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>,<em class="replaceable"><code>key_part3</code></em>) &lt; ('foo',+inf,+inf)
</pre><p>
                作成された間隔に初期条件よりも多い行が含まれる可能性があります。 たとえば、前の間隔は値 <code class="literal">('foo', 11, 0)</code> を含みますが、これは元の条件を満たしません。 
              </p></li><li class="listitem"><p>
                間隔内に含まれる行セットをカバーする条件が <code class="literal">OR</code> で組み合わされている場合、それらは、それらの間隔の和集合内に含まれる行セットをカバーする条件を形成します。 条件が <code class="literal">AND</code> で組み合わされている場合、それらは間隔の共通集合内に含まれる行セットを対象とする条件を形成します。 たとえば、2 パートインデックスでのこの条件の場合:  
              </p><pre class="programlisting">(<em class="replaceable"><code>key_part1</code></em> = 1 AND <em class="replaceable"><code>key_part2</code></em> &lt; 2) OR (<em class="replaceable"><code>key_part1</code></em> &gt; 5)
</pre><p>
                間隔は次のとおりです。
              </p><pre class="programlisting">(1,-inf) &lt; (<em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>) &lt; (1,2)
(5,-inf) &lt; (<em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>)
</pre><p>
                この例で、1 行目の間隔は、左境界に 1 つのキーパートを使用し、右境界に 2 つのキーパートを使用しています。 2 行目の間隔は 1 つのキーパートのみを使用しています。 <code class="literal">EXPLAIN</code> 出力の <code class="literal">key_len</code> カラムは、使用されたキープリフィクスの最大長を示しています。 
              </p><p>
                場合によって、<code class="literal">key_len</code> はキーパートが使用されたことを示しますが、それが予期したものではないことがあります。 <em class="replaceable"><code>key_part1</code></em> と <em class="replaceable"><code>key_part2</code></em> が <code class="literal">NULL</code> になることがあるとします。 次に、<code class="literal">key_len</code> カラムに、次の条件の 2 つのキーパート長が表示されます。 
              </p><pre class="programlisting"><em class="replaceable"><code>key_part1</code></em> &gt;= 1 AND <em class="replaceable"><code>key_part2</code></em> &lt; 2
</pre><p>
                しかし、実際は条件が次に変換されます。
              </p><pre class="programlisting"><em class="replaceable"><code>key_part1</code></em> &gt;= 1 AND <em class="replaceable"><code>key_part2</code></em> IS NOT NULL
</pre></li></ul></div><p>
            単一パートインデックスの範囲条件の間隔を結合または排除するために最適化を実行する方法の詳細は、<a class="xref" href="optimization.html#range-access-single-part" title="単一部品インデックスの範囲アクセス方法">単一部品インデックスの範囲アクセス方法</a> を参照してください。 マルチパートインデックスでの範囲条件にも類似の手順が実行されます。 
          </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="equality-range-optimization"></a>複数値比較の等価範囲の最適化</h5></div></div></div><p>
            <em class="replaceable"><code>col_name</code></em> がインデックス設定されたカラムである次の式を考慮します。
          </p><pre class="programlisting"><em class="replaceable"><code>col_name</code></em> IN(<em class="replaceable"><code>val1</code></em>, ..., <em class="replaceable"><code>valN</code></em>)
<em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>val1</code></em> OR ... OR <em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>valN</code></em>
</pre><p>
            <em class="replaceable"><code>col_name</code></em> が複数の値のいずれかと等しい場合に、各式は true になります。 これらの比較は等価範囲比較です (ここで<span class="quote">「<span class="quote">範囲</span>」</span>は単一の値です)。 オプティマイザは、次のように等価範囲比較の対象とする行の読み取りのコストを推定します。 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <em class="replaceable"><code>col_name</code></em> に一意のインデックスがある場合、指定した値を持つことができる行は多くても 1 つであるため、各範囲の行の見積もりは 1 です。
              </p></li><li class="listitem"><p>
                それ以外の場合、<em class="replaceable"><code>col_name</code></em> のインデックスは一意ではなく、オプティマイザはインデックスまたはインデックス統計に分割して、各範囲の行数を見積もることができます。
              </p></li></ul></div><a class="indexterm" name="idm45661481424000"></a><p>
            インデックスダイブでは、オプティマイザは範囲の両端でダイブを作成し、範囲内の行数を見積もりとして使用します。 たとえば、式 <code class="literal"><em class="replaceable"><code>col_name</code></em> IN (10, 20, 30)</code> には 3 つの等価範囲があり、オプティマイザは範囲あたり 2 つのダイブを作成して、行の見積もりを生成します。 ダイブのペアごとに、指定した値を持つ行数の見積もりを生成します。 
          </p><p>
            インデックスダイブは、正確な行見積もりを提供しますが、式内の比較値の数が増えるほど、オプティマイザの行見積もりの生成に時間がかかるようになります。 インデックス統計の使用は、インデックスダイブより正確ではありませんが、大きな値リストの場合に、行見積もりが高速になります。 
          </p><p>
            <code class="literal">eq_range_index_dive_limit</code> システム変数を使用して、オプティマイザが行の見積もり戦略を別の戦略に切り替える値の数を構成できます。 最大 <em class="replaceable"><code>N</code></em> 個の等価範囲の比較にインデックスダイブの使用を許可するには、<code class="literal">eq_range_index_dive_limit</code> を <em class="replaceable"><code>N</code></em> + 1 に設定します。 統計の使用を無効にし、<em class="replaceable"><code>N</code></em> に関係なく常にインデックスダイブを使用するには、<code class="literal">eq_range_index_dive_limit</code> を 0 に設定します。 
          </p><p>
            最適な推定を行うためにテーブルインデックス統計を更新するには、<code class="literal">ANALYZE TABLE</code> を使用します。
          </p><p>
            MySQL 8.0 より前では、<code class="literal">eq_range_index_dive_limit</code> システム変数を使用する場合を除き、インデックス dives の使用をスキップしてインデックスの有用性を見積もる方法はありません。 MySQL 8.0 では、次のすべての条件を満たすクエリーでインデックス分割スキップが可能です: 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                クエリーは、複数のテーブルに対する結合ではなく、単一のテーブルに対するものです。
              </p></li><li class="listitem"><p>
                単一インデックスの <code class="literal">FORCE INDEX</code> インデックスヒントが存在します。 インデックスの使用が強制される場合、インデックスへの分割を実行する追加のオーバーヘッドからは何も取得されません。 
              </p></li><li class="listitem"><p>
                インデックスは一意ではなく、<code class="literal">FULLTEXT</code> インデックスではありません。
              </p></li><li class="listitem"><p>
                サブクエリーが存在しません。
              </p></li><li class="listitem"><p>
                <code class="literal">DISTINCT</code>、<code class="literal">GROUP BY</code> または <code class="literal">ORDER BY</code> 句が存在しません。
              </p></li></ul></div><p>
            <code class="literal">EXPLAIN FOR CONNECTION</code> の場合、index dives がスキップされると、出力は次のように変更されます:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                従来の出力では、<code class="literal">rows</code> および <code class="literal">filtered</code> の値は <code class="literal">NULL</code> です。
              </p></li><li class="listitem"><p>
                JSON 出力の場合、<code class="literal">rows_examined_per_scan</code> および <code class="literal">rows_produced_per_join</code> は表示されず、<code class="literal">skip_index_dive_due_to_force</code> は <code class="literal">true</code> で、コスト計算は正確ではありません。
              </p></li></ul></div><p>
            <code class="literal">FOR CONNECTION</code> を使用しない場合、インデックス dives がスキップされても、<code class="literal">EXPLAIN</code> 出力は変更されません。
          </p><p>
            インデックス分割がスキップされるクエリーの実行後、<code class="literal">INFORMATION_SCHEMA.OPTIMIZER_TRACE</code> テーブルの対応する行に <code class="literal">skipped_due_to_force_index</code> の <code class="literal">index_dives_for_range_access</code> 値が含まれます。
          </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="range-access-skip-scan"></a>スキャン範囲アクセス方法のスキップ</h5></div></div></div><p>
            次のシナリオを考えてみます:
          </p><pre class="programlisting">CREATE TABLE t1 (f1 INT NOT NULL, f2 INT NOT NULL, PRIMARY KEY(f1, f2));
INSERT INTO t1 VALUES
  (1,1), (1,2), (1,3), (1,4), (1,5),
  (2,1), (2,2), (2,3), (2,4), (2,5);
INSERT INTO t1 SELECT f1, f2 + 5 FROM t1;
INSERT INTO t1 SELECT f1, f2 + 10 FROM t1;
INSERT INTO t1 SELECT f1, f2 + 20 FROM t1;
INSERT INTO t1 SELECT f1, f2 + 40 FROM t1;
ANALYZE TABLE t1;

EXPLAIN SELECT f1, f2 FROM t1 WHERE f2 &gt; 40;
</pre><p>
            このクエリーを実行するために、MySQL では、インデックススキャンを選択してすべての行をフェッチし (インデックスには選択するすべてのカラムが含まれます)、<code class="literal">WHERE</code> 句から <code class="literal">f2 &gt; 40</code> 条件を適用して最終結果セットを生成できます。
          </p><p>
            レンジスキャンは全インデックススキャンよりも効率的ですが、最初のインデックスカラムである <code class="literal">f1</code> に条件がないため、この場合は使用できません。 ただし、MySQL 8.0.13 の時点では、オプティマイザは、ループインデックススキャンと同様のスキップスキャンという方法を使用して、<code class="literal">f1</code> の値ごとに複数のレンジスキャンを実行できます (<a class="xref" href="optimization.html#group-by-optimization" title="8.2.1.17 GROUP BY の最適化">セクション8.2.1.17「GROUP BY の最適化」</a> を参照): 
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                最初のインデックス部分、<code class="literal">f1</code> (インデックス接頭辞) の個別値間でスキップします。
              </p></li><li class="listitem"><p>
                残りのインデックス部分で、<code class="literal">f2 &gt; 40</code> 条件の個別の接頭辞値ごとにサブレンジスキャンを実行します。
              </p></li></ol></div><p>
            前述のデータセットの場合、アルゴリズムは次のように動作します:
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                最初のキー部分 (<code class="literal">f1 = 1</code>) の最初の個別値を取得します。
              </p></li><li class="listitem"><p>
                最初と 2 番目のキー部分 (<code class="literal">f1 = 1 AND f2 &gt; 40</code>) に基づいて範囲を構築します。
              </p></li><li class="listitem"><p>
                範囲スキャンを実行します。
              </p></li><li class="listitem"><p>
                最初のキー部分の次の個別値を取得します (<code class="literal">f1 = 2</code>)。
              </p></li><li class="listitem"><p>
                最初と 2 番目のキー部分 (<code class="literal">f1 = 2 AND f2 &gt; 40</code>) に基づいて範囲を構築します。
              </p></li><li class="listitem"><p>
                範囲スキャンを実行します。
              </p></li></ol></div><p>
            この方法を使用すると、構成された範囲ごとに適格でない行が MySQL によってスキップされるため、アクセスされる行の数が減ります。 このスキップスキャンアクセス方法は、次の条件下で適用できます: 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                表 T には、フォーム ([A_1, ..., A_<em class="replaceable"><code>k</code></em>,] B_1, ..., B_<em class="replaceable"><code>m</code></em>, C [, D_1, ..., D_<em class="replaceable"><code>n</code></em>]) のキー部分を持つ複合インデックスが少なくとも 1 つあります。 キー部分 A および D は空でもかまいませんが、B および C は空でない必要があります。 
              </p></li><li class="listitem"><p>
                クエリーは 1 つのテーブルだけを参照します。
              </p></li><li class="listitem"><p>
                クエリーでは、<code class="literal">GROUP BY</code> または <code class="literal">DISTINCT</code> は使用されません。
              </p></li><li class="listitem"><p>
                クエリーは、インデックス内のカラムのみを参照します。
              </p></li><li class="listitem"><p>
                A_1、...、A_ <em class="replaceable"><code>k</code></em> の述語は等価述語であり、定数である必要があります。 これには、<code class="literal">IN()</code> 演算子が含まれます。 
              </p></li><li class="listitem"><p>
                クエリーは結合クエリー (<code class="literal">OR</code> 条件の <code class="literal">AND</code>) である必要があります: <code class="literal">(<em class="replaceable"><code>cond1</code></em>(<em class="replaceable"><code>key_part1</code></em>) OR <em class="replaceable"><code>cond2</code></em>(<em class="replaceable"><code>key_part1</code></em>)) AND (<em class="replaceable"><code>cond1</code></em>(<em class="replaceable"><code>key_part2</code></em>) OR ...) AND ...</code>
              </p></li><li class="listitem"><p>
                C には範囲条件が必要です。
              </p></li><li class="listitem"><p>
                D カラムに対する条件は許可されています。 D の条件は、C の範囲条件と組み合せる必要があります。 
              </p></li></ul></div><p>
            スキップスキャンの使用は、<code class="literal">EXPLAIN</code> 出力で次のように示されます:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">Extra</code> カラムの <code class="literal">Using index for skip scan</code> は、ルーズインデックススキップスキャンアクセス方法が使用されていることを示します。
              </p></li><li class="listitem"><p>
                インデックスをスキップスキャンに使用できる場合は、インデックスが <code class="literal">possible_keys</code> カラムに表示されます。
              </p></li></ul></div><p>
            スキップスキャンの使用は、オプティマイザトレース出力で次の形式の<code class="literal">"skip scan"</code>要素によって示されます:
          </p><pre class="programlisting">"skip_scan_range": {
  "type": "skip_scan",
  "index": <em class="replaceable"><code>index_used_for_skip_scan</code></em>,
  "key_parts_used_for_access": [<em class="replaceable"><code>key_parts_used_for_access</code></em>],
  "range": [<em class="replaceable"><code>range</code></em>]
}
</pre><p>
            <code class="literal">"best_skip_scan_summary"</code>要素も表示される場合があります。 最適なレンジアクセスバリアントとしてスキャンのスキップを選択すると、<code class="literal">"chosen_range_access_summary"</code>が書き込まれます。 全体的な最適なアクセス方法としてスキャンのスキップが選択されている場合は、<code class="literal">"best_access_path"</code>要素が存在します。 
          </p><p>
            スキップスキャンの使用は、<code class="literal">optimizer_switch</code> システム変数の <code class="literal">skip_scan</code> フラグの値の影響を受けます。 <a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2 切り替え可能な最適化">セクション8.9.2「切り替え可能な最適化」</a>を参照してください。 デフォルトでは、このフラグは <code class="literal">on</code> です。 無効にするには、<code class="literal">skip_scan</code> を <code class="literal">off</code> に設定します。 
          </p><p>
            <code class="literal">optimizer_switch</code> システム変数を使用してスキップスキャンセッション全体のオプティマイザの使用を制御することに加えて、MySQL ではオプティマイザヒントをサポートしてステートメントごとにオプティマイザに影響を与えます。 <a class="xref" href="optimization.html#optimizer-hints" title="8.9.3 オプティマイザヒント">セクション8.9.3「オプティマイザヒント」</a>を参照してください。 
          </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="row-constructor-range-optimization"></a>行コンストラクタ式の範囲最適化</h5></div></div></div><p>
            オプティマイザは、レンジスキャンアクセス方法を次の形式のクエリーに適用できます:
          </p><pre class="programlisting">SELECT ... FROM t1 WHERE ( col_1, col_2 ) IN (( 'a', 'b' ), ( 'c', 'd' ));
</pre><p>
            以前は、レンジスキャンを使用するには、次のようにクエリーを記述する必要がありました:
          </p><pre class="programlisting">SELECT ... FROM t1 WHERE ( col_1 = 'a' AND col_2 = 'b' )
OR ( col_1 = 'c' AND col_2 = 'd' );
</pre><p>
            オプティマイザでレンジスキャンを使用するには、クエリーが次の条件を満たす必要があります:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">IN()</code> 述語のみが使用され、<code class="literal">NOT IN()</code> は使用されません。
              </p></li><li class="listitem"><p>
                <code class="literal">IN()</code> 述語の左側では、行コンストラクタにはカラム参照のみが含まれます。
              </p></li><li class="listitem"><p>
                <code class="literal">IN()</code> 述語の右側にある行コンストラクタには、実行中に定数にバインドされるリテラルまたはローカルカラム参照であるランタイム定数のみが含まれます。
              </p></li><li class="listitem"><p>
                <code class="literal">IN()</code> 述語の右側には、複数の行コンストラクタがあります。
              </p></li></ul></div><p>
            オプティマイザおよび行コンストラクタの詳細は、<a class="xref" href="optimization.html#row-constructor-optimization" title="8.2.1.22 行コンストラクタ式の最適化">セクション8.2.1.22「行コンストラクタ式の最適化」</a> を参照してください
          </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="range-optimization-memory-use"></a>範囲最適化のためのメモリー使用の制限</h5></div></div></div><p>
            範囲オプティマイザで使用可能なメモリーを制御するには、<code class="literal">range_optimizer_max_mem_size</code> システム変数を使用します:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                値 0 は <span class="quote">「<span class="quote">制限なし</span>」</span>を表します。
              </p></li><li class="listitem"><p>
                0 より大きい値を指定すると、オプティマイザは範囲アクセス方法を考慮する際に消費されるメモリーを追跡します。 指定した制限を超えると、レンジアクセス方法が破棄され、全テーブルスキャンなどの他の方法がかわりに考慮されます。 これは最適ではない可能性があります。 これが発生すると、次の警告が発生します (<em class="replaceable"><code>N</code></em> は現在の <code class="literal">range_optimizer_max_mem_size</code> 値です): 
              </p><pre class="programlisting">Warning    3170    Memory capacity of <em class="replaceable"><code>N</code></em> bytes for
                   'range_optimizer_max_mem_size' exceeded. Range
                   optimization was not done for this query.
</pre></li><li class="listitem"><p>
                <code class="literal">UPDATE</code> および <code class="literal">DELETE</code> ステートメントでは、オプティマイザが全テーブルスキャンにフォールバックし、<code class="literal">sql_safe_updates</code> システム変数が有効になっている場合、変更する行の決定にキーが使用されないため、警告ではなくエラーが発生します。 詳細は、<a class="xref" href="programs.html#safe-updates" title="セーフ更新モードの使用 (--safe-updates)">セーフ更新モードの使用 (--safe-updates)</a>を参照してください。 
              </p></li></ul></div><p>
            使用可能な範囲最適化メモリーを超え、オプティマイザがより最適でない計画にフォールバックする個々のクエリーの場合、<code class="literal">range_optimizer_max_mem_size</code> 値を増やすとパフォーマンスが向上する可能性があります。
          </p><p>
            範囲式の処理に必要なメモリー量を見積もるには、次のガイドラインを使用します:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                範囲アクセス方法の候補キーが 1 つある次のような単純なクエリーの場合、<code class="literal">OR</code> と組み合された各述語では約 230 バイトが使用されます:
              </p><pre class="programlisting">SELECT COUNT(*) FROM t
WHERE a=1 OR a=2 OR a=3 OR .. . a=<em class="replaceable"><code>N</code></em>;
</pre></li><li class="listitem"><p>
                同様に、次のようなクエリーでは、<code class="literal">AND</code> と組み合された各述語で約 125 バイトが使用されます:
              </p><pre class="programlisting">SELECT COUNT(*) FROM t
WHERE a=1 AND b=1 AND c=1 ... <em class="replaceable"><code>N</code></em>;
</pre></li><li class="listitem"><p>
                <code class="literal">IN()</code> 述語を含むクエリーの場合:
              </p><pre class="programlisting">SELECT COUNT(*) FROM t
WHERE a IN (1,2, ..., <em class="replaceable"><code>M</code></em>) AND b IN (1,2, ..., <em class="replaceable"><code>N</code></em>);
</pre><p>
                <code class="literal">IN()</code> リストの各リテラル値は、<code class="literal">OR</code> と組み合された述語としてカウントされます。 2 つの <code class="literal">IN()</code> リストがある場合、<code class="literal">OR</code> と組み合せた述語の数は、各リストのリテラル値の数になります。 したがって、前述の例で <code class="literal">OR</code> と組み合されている述語の数は、<em class="replaceable"><code>M</code></em>× <em class="replaceable"><code>N</code></em> です。 
              </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="index-merge-optimization"></a>8.2.1.3 インデックスマージの最適化</h4></div></div></div><a class="indexterm" name="idm45661481270864"></a><a class="indexterm" name="idm45661481269584"></a><a class="indexterm" name="idm45661481268032"></a><p>
          <span class="firstterm">インデックスマージ</span>アクセス方法では、複数の <code class="literal">range</code> スキャンを含む行が取得され、その結果が 1 つにマージされます。 このアクセス方法では、単一のテーブルからのみインデックススキャンがマージされ、複数のテーブルにわたるスキャンはマージされません。 このマージによって、その基盤となるスキャンの和集合、共通集合、または共通集合の和集合を生成できます。 
        </p><p>
          インデックスマージを使用できるクエリーの例:
        </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key1</code></em> = 10 OR <em class="replaceable"><code>key2</code></em> = 20;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE (<em class="replaceable"><code>key1</code></em> = 10 OR <em class="replaceable"><code>key2</code></em> = 20) AND <em class="replaceable"><code>non_key</code></em> = 30;

SELECT * FROM t1, t2
  WHERE (t1.<em class="replaceable"><code>key1</code></em> IN (1,2) OR t1.<em class="replaceable"><code>key2</code></em> LIKE '<em class="replaceable"><code>value</code></em>%')
  AND t2.<em class="replaceable"><code>key1</code></em> = t1.<em class="replaceable"><code>some_col</code></em>;

SELECT * FROM t1, t2
  WHERE t1.<em class="replaceable"><code>key1</code></em> = 1
  AND (t2.<em class="replaceable"><code>key1</code></em> = t1.<em class="replaceable"><code>some_col</code></em> OR t2.<em class="replaceable"><code>key2</code></em> = t1.<em class="replaceable"><code>some_col2</code></em>);
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            インデックスマージ最適化アルゴリズムには、次の既知の制限事項があります:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                クエリーに深い <code class="literal">AND</code>/<code class="literal">OR</code> ネストを含む複雑な <code class="literal">WHERE</code> 句があり、MySQL が最適な計画を選択しない場合は、次のアイデンティティ変換を使用して用語を配布してみてください:
              </p><pre class="programlisting">(<em class="replaceable"><code>x</code></em> AND <em class="replaceable"><code>y</code></em>) OR <em class="replaceable"><code>z</code></em> =&gt; (<em class="replaceable"><code>x</code></em> OR <em class="replaceable"><code>z</code></em>) AND (<em class="replaceable"><code>y</code></em> OR <em class="replaceable"><code>z</code></em>)
(<em class="replaceable"><code>x</code></em> OR <em class="replaceable"><code>y</code></em>) AND <em class="replaceable"><code>z</code></em> =&gt; (<em class="replaceable"><code>x</code></em> AND <em class="replaceable"><code>z</code></em>) OR (<em class="replaceable"><code>y</code></em> AND <em class="replaceable"><code>z</code></em>)
</pre></li><li class="listitem"><p>
                インデックスマージは全文インデックスには適用できません。
              </p></li></ul></div></div><p>
          <code class="literal">EXPLAIN</code> 出力では、インデックスマージメソッドは <code class="literal">type</code> カラムに <code class="literal">index_merge</code> と表示されます。 この場合、<code class="literal">key</code> カラムには使用されたインデックスのリストが含まれ、<code class="literal">key_len</code> にはそれらのインデックスの最長のキーパートのリストが含まれます。 
        </p><p>
          インデックスマージアクセス方法には、<code class="literal">EXPLAIN</code> 出力の <code class="literal">Extra</code> フィールドに表示されるいくつかのアルゴリズムがあります:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">Using intersect(...)</code>
            </p></li><li class="listitem"><p>
              <code class="literal">Using union(...)</code>
            </p></li><li class="listitem"><p>
              <code class="literal">Using sort_union(...)</code>
            </p></li></ul></div><p>
          次の各セクションでは、これらのアルゴリズムについて詳しく説明します。 オプティマイザは、使用可能な様々なオプションのコスト見積りに基づいて、様々なインデックスマージアルゴリズムとその他のアクセス方法のいずれかを選択します。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#index-merge-intersection" title="インデックスマージ交差アクセスアルゴリズム">インデックスマージ交差アクセスアルゴリズム</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#index-merge-union" title="インデックスマージ結合アクセスアルゴリズム">インデックスマージ結合アクセスアルゴリズム</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#index-merge-sort-union" title="インデックスマージソート - ユニオンアクセスアルゴリズム">インデックスマージソート - ユニオンアクセスアルゴリズム</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#index-merge-influencing" title="インデックスマージ最適化への影響">インデックスマージ最適化への影響</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="index-merge-intersection"></a>インデックスマージ交差アクセスアルゴリズム</h5></div></div></div><p>
            このアクセスアルゴリズムは、<code class="literal">WHERE</code> 句が <code class="literal">AND</code> と組み合された異なるキーの複数の範囲条件に変換され、各条件が次のいずれかである場合に適用されます:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                この形式の <em class="replaceable"><code>N</code></em> 部分式。インデックスには正確に <em class="replaceable"><code>N</code></em> 部分が含まれます (つまり、すべてのインデックス部分が対象となります):
              </p><pre class="programlisting"><em class="replaceable"><code>key_part1</code></em> = <em class="replaceable"><code>const1</code></em> AND <em class="replaceable"><code>key_part2</code></em> = <em class="replaceable"><code>const2</code></em> ... AND <em class="replaceable"><code>key_partN</code></em> = <em class="replaceable"><code>constN</code></em>
</pre></li><li class="listitem"><p>
                <code class="literal">InnoDB</code> テーブルの主キーに対する範囲条件。
              </p></li></ul></div><p>
            例:
          </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>innodb_table</code></em>
  WHERE <em class="replaceable"><code>primary_key</code></em> &lt; 10 AND <em class="replaceable"><code>key_col1</code></em> = 20;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key1_part1</code></em> = 1 AND <em class="replaceable"><code>key1_part2</code></em> = 2 AND <em class="replaceable"><code>key2</code></em> = 2;
</pre><p>
            インデックスマージ共通集合アルゴリズムは、使用されたすべてのインデックスの同時スキャンを実行し、マージされたインデックススキャンから受け取る行シーケンスの共通集合を生成します。
          </p><p>
            クエリーに使用されているすべてのカラムが、使用されるインデックスによってカバーされている場合、完全なテーブル行は取得されません (この場合、<code class="literal">EXPLAIN</code> 出力の <code class="literal">Extra</code> フィールドに <code class="literal">Using index</code> が含まれます)。 次はそのようなクエリーの例です。 
          </p><pre class="programlisting">SELECT COUNT(*) FROM t1 WHERE key1 = 1 AND key2 = 1;
</pre><p>
            使用されているインデックスがクエリーで使用されているすべてのカラムをカバーしているわけではない場合、使用されているすべてのキーの範囲条件が満たされている場合にのみ、行全体が取得されます。
          </p><p>
            マージされた条件のいずれかが <code class="literal">InnoDB</code> テーブルの主キーに対する条件である場合、行の取得には使用されませんが、他の条件を使用して取得された行を除外するために使用されます。
          </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="index-merge-union"></a>インデックスマージ結合アクセスアルゴリズム</h5></div></div></div><p>
            このアルゴリズムの基準は、インデックスマージ交差アルゴリズムの基準と似ています。 このアルゴリズムは、テーブルの <code class="literal">WHERE</code> 句が <code class="literal">OR</code> と組み合された異なるキーの複数の範囲条件に変換され、各条件が次のいずれかである場合に適用されます: 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                この形式の <em class="replaceable"><code>N</code></em> 部分式。インデックスには正確に <em class="replaceable"><code>N</code></em> 部分が含まれます (つまり、すべてのインデックス部分が対象となります):
              </p><pre class="programlisting"><em class="replaceable"><code>key_part1</code></em> = <em class="replaceable"><code>const1</code></em> AND <em class="replaceable"><code>key_part2</code></em> = <em class="replaceable"><code>const2</code></em> ... AND <em class="replaceable"><code>key_partN</code></em> = <em class="replaceable"><code>constN</code></em>
</pre></li><li class="listitem"><p>
                <code class="literal">InnoDB</code> テーブルの主キーに対する範囲条件。
              </p></li><li class="listitem"><p>
                インデックスマージ交差アルゴリズムが適用可能な条件。
              </p></li></ul></div><p>
            例:
          </p><pre class="programlisting">SELECT * FROM t1
  WHERE <em class="replaceable"><code>key1</code></em> = 1 OR <em class="replaceable"><code>key2</code></em> = 2 OR <em class="replaceable"><code>key3</code></em> = 3;

SELECT * FROM <em class="replaceable"><code>innodb_table</code></em>
  WHERE (<em class="replaceable"><code>key1</code></em> = 1 AND <em class="replaceable"><code>key2</code></em> = 2)
     OR (<em class="replaceable"><code>key3</code></em> = 'foo' AND <em class="replaceable"><code>key4</code></em> = 'bar') AND <em class="replaceable"><code>key5</code></em> = 5;
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="index-merge-sort-union"></a>インデックスマージソート - ユニオンアクセスアルゴリズム</h5></div></div></div><p>
            このアクセスアルゴリズムは、<code class="literal">WHERE</code> 句が <code class="literal">OR</code> で結合された複数の範囲条件に変換されるが、インデックスマージ結合アルゴリズムが適用できない場合に適用できます。
          </p><p>
            例:
          </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_col1</code></em> &lt; 10 OR <em class="replaceable"><code>key_col2</code></em> &lt; 20;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE (<em class="replaceable"><code>key_col1</code></em> &gt; 10 OR <em class="replaceable"><code>key_col2</code></em> = 20) AND <em class="replaceable"><code>nonkey_col</code></em> = 30;
</pre><p>
            ソート和集合アルゴリズムと和集合アルゴリズムの違いは、ソート和集合アルゴリズムでは、行を返す前にまずすべての行の行 ID をフェッチし、それらをソートする必要があることです。
          </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="index-merge-influencing"></a>インデックスマージ最適化への影響</h5></div></div></div><p>
            インデックスマージの使用は、<code class="literal">optimizer_switch</code> システム変数の <code class="literal">index_merge</code>, <code class="literal">index_merge_intersection</code>, <code class="literal">index_merge_union</code> および <code class="literal">index_merge_sort_union</code> フラグの値の影響を受けます。 <a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2 切り替え可能な最適化">セクション8.9.2「切り替え可能な最適化」</a>を参照してください。 デフォルトでは、これらのフラグはすべて <code class="literal">on</code> です。 特定のアルゴリズムのみを有効にするには、<code class="literal">index_merge</code> を <code class="literal">off</code> に設定し、許可される他のアルゴリズムのみを有効にします。 
          </p><p>
            MySQL では、<code class="literal">optimizer_switch</code> システム変数を使用してインデックスマージアルゴリズムのセッション全体のオプティマイザ使用を制御することに加えて、オプティマイザヒントをサポートしてステートメントごとにオプティマイザに影響を与えます。 <a class="xref" href="optimization.html#optimizer-hints" title="8.9.3 オプティマイザヒント">セクション8.9.3「オプティマイザヒント」</a>を参照してください。 
          </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="hash-joins"></a>8.2.1.4 ハッシュ結合の最適化</h4></div></div></div><p>
          MySQL 8.0.18 以降、MySQL では、各結合に等価結合条件があり、次のような結合条件に適用できるインデックスがないクエリーに対してハッシュ結合が使用されます:
        </p><pre class="programlisting">SELECT *
    FROM t1
    JOIN t2
        ON t1.c1=t2.c1;
</pre><p>
          ハッシュ結合は、単一テーブルの述語に使用できるインデックスが 1 つ以上ある場合にも使用できます。
        </p><p>
          ハッシュ結合は通常、以前のバージョンの MySQL で採用されていたブロックネストループアルゴリズム (<a class="xref" href="optimization.html#block-nested-loop-join-algorithm" title="Block Nested Loop 結合アルゴリズム">Block Nested Loop 結合アルゴリズム</a> を参照) のかわりに、このような場合に使用することを目的としています。 MySQL 8.0.20 以降では、ブロックネストループのサポートが削除され、以前にブロックネステッドループが使用されていた場所では、サーバーはハッシュ結合を採用します。 
        </p><p>
          前述の例およびこのセクションの残りの例では、次のステートメントを使用して <code class="literal">t1</code>、<code class="literal">t2</code> および <code class="literal">t3</code> の 3 つのテーブルが作成されていることを前提としています:
        </p><pre class="programlisting">CREATE TABLE t1 (c1 INT, c2 INT);
CREATE TABLE t2 (c1 INT, c2 INT);
CREATE TABLE t3 (c1 INT, c2 INT);
</pre><p>
          ハッシュ結合が採用されていることは、次のように <code class="literal">EXPLAIN</code> を使用して確認できます:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN</code></strong>
    -&gt; <strong class="userinput"><code>SELECT * FROM t1</code></strong>
    -&gt;     <strong class="userinput"><code>JOIN t2 ON t1.c1=t2.c1\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: t2
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: Using where; Using join buffer (hash join)
</pre><p>
          (MySQL 8.0.20 より前では、ハッシュ結合が特定の結合に使用されていたかどうかを確認するには、<code class="literal">FORMAT=TREE</code> オプションを含める必要がありました。)
        </p><p>
          <code class="literal">EXPLAIN ANALYZE</code> には、使用されているハッシュ結合に関する情報も表示されます。
        </p><p>
          ハッシュ結合は、次に示すように、テーブルのペアごとに少なくとも 1 つの結合条件が等価結合であるかぎり、複数の結合を含むクエリーにも使用されます:
        </p><pre class="programlisting">SELECT * FROM t1
    JOIN t2 ON (t1.c1 = t2.c1 AND t1.c2 &lt; t2.c2)
    JOIN t3 ON (t2.c1 = t3.c1);
</pre><p>
          内部結合を使用する前述のような場合、等価結合ではない追加の条件は、結合の実行後にフィルタとして適用されます。 (左結合、準結合、アンチ結合などの外部結合の場合は、結合の一部として出力されます。) これは、<code class="literal">EXPLAIN</code> の出力に表示されます: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN FORMAT=TREE</code></strong>
    -&gt; <strong class="userinput"><code>SELECT *</code></strong>
    -&gt;     <strong class="userinput"><code>FROM t1</code></strong>
    -&gt;     <strong class="userinput"><code>JOIN t2</code></strong>
    -&gt;         <strong class="userinput"><code>ON (t1.c1 = t2.c1 AND t1.c2 &lt; t2.c2)</code></strong>
    -&gt;     <strong class="userinput"><code>JOIN t3</code></strong>
    -&gt;         <strong class="userinput"><code>ON (t2.c1 = t3.c1)\G</code></strong>
*************************** 1. row ***************************
EXPLAIN: -&gt; Inner hash join (t3.c1 = t1.c1)  (cost=1.05 rows=1)
    -&gt; Table scan on t3  (cost=0.35 rows=1)
    -&gt; Hash
        -&gt; Filter: (t1.c2 &lt; t2.c2)  (cost=0.70 rows=1)
            -&gt; Inner hash join (t2.c1 = t1.c1)  (cost=0.70 rows=1)
                -&gt; Table scan on t2  (cost=0.35 rows=1)
                -&gt; Hash
                    -&gt; Table scan on t1  (cost=0.35 rows=1)
</pre><p>
          前述の出力からもわかるように、複数の等価結合条件を持つ結合には複数のハッシュ結合を使用できます。
        </p><p>
          MySQL 8.0.20 より前は、結合テーブルのいずれかのペアに等価結合条件がなく、より遅いブロックのネステッドループアルゴリズムが使用されていた場合、ハッシュ結合は使用できませんでした。 MySQL 8.0.20 以降では、次に示すように、ハッシュ結合が使用されます: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN FORMAT=TREE</code></strong>
    -&gt; <strong class="userinput"><code>SELECT * FROM t1</code></strong>
    -&gt;     <strong class="userinput"><code>JOIN t2 ON (t1.c1 = t2.c1)</code></strong>
    -&gt;     <strong class="userinput"><code>JOIN t3 ON (t2.c1 &lt; t3.c1)\G</code></strong>
*************************** 1. row ***************************
EXPLAIN: -&gt; Filter: (t1.c1 &lt; t3.c1)  (cost=1.05 rows=1)
    -&gt; Inner hash join (no condition)  (cost=1.05 rows=1)
        -&gt; Table scan on t3  (cost=0.35 rows=1)
        -&gt; Hash
            -&gt; Inner hash join (t2.c1 = t1.c1)  (cost=0.70 rows=1)
                -&gt; Table scan on t2  (cost=0.35 rows=1)
                -&gt; Hash
                    -&gt; Table scan on t1  (cost=0.35 rows=1)
</pre><p>
          (追加の例は、このセクションの後半で説明します。)
        </p><p>
          ハッシュ結合はデカルト積にも適用されます。つまり、結合条件が指定されていない場合は、次のようになります:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN FORMAT=TREE</code></strong>
    -&gt; <strong class="userinput"><code>SELECT *</code></strong>
    -&gt;     <strong class="userinput"><code>FROM t1</code></strong>
    -&gt;     <strong class="userinput"><code>JOIN t2</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE t1.c2 &gt; 50\G</code></strong>
*************************** 1. row ***************************
EXPLAIN: -&gt; Inner hash join  (cost=0.70 rows=1)
    -&gt; Table scan on t2  (cost=0.35 rows=1)
    -&gt; Hash
        -&gt; Filter: (t1.c2 &gt; 50)  (cost=0.35 rows=1)
            -&gt; Table scan on t1  (cost=0.35 rows=1)
</pre><p>
          MySQL 8.0.20 以降では、ハッシュ結合を使用するために、結合に少なくとも 1 つの等価結合条件を含める必要がなくなりました。 つまり、ハッシュ結合を使用して最適化できるクエリーのタイプには、次のリスト (および例) のクエリーが含まれます: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <span class="emphasis"><em>内部非等価結合</em></span>:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN FORMAT=TREE SELECT * FROM t1 JOIN t2 ON t1.c1 &lt; t2.c1\G</code></strong>
*************************** 1. row ***************************
EXPLAIN: -&gt; Filter: (t1.c1 &lt; t2.c1)  (cost=4.70 rows=12)
    -&gt; Inner hash join (no condition)  (cost=4.70 rows=12)
        -&gt; Table scan on t2  (cost=0.08 rows=6)
        -&gt; Hash
            -&gt; Table scan on t1  (cost=0.85 rows=6)
</pre></li><li class="listitem"><p>
              <span class="emphasis"><em>準結合</em></span>:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN FORMAT=TREE SELECT * FROM t1 </code></strong>
    -&gt;     <strong class="userinput"><code>WHERE t1.c1 IN (SELECT t2.c2 FROM t2)\G</code></strong>
*************************** 1. row ***************************
EXPLAIN: -&gt; Nested loop inner join
    -&gt; Filter: (t1.c1 is not null)  (cost=0.85 rows=6)
        -&gt; Table scan on t1  (cost=0.85 rows=6)
    -&gt; Single-row index lookup on &lt;subquery2&gt; using &lt;auto_distinct_key&gt; (c2=t1.c1)
        -&gt; Materialize with deduplication
            -&gt; Filter: (t2.c2 is not null)  (cost=0.85 rows=6)
                -&gt; Table scan on t2  (cost=0.85 rows=6)
</pre></li><li class="listitem"><p>
              <span class="emphasis"><em>アンチ結合</em></span>:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN FORMAT=TREE SELECT * FROM t2 </code></strong>
    -&gt;     <strong class="userinput"><code>WHERE NOT EXISTS (SELECT * FROM t1 WHERE t1.col1 = t2.col1)\G</code></strong>
*************************** 1. row ***************************
EXPLAIN: -&gt; Nested loop antijoin
    -&gt; Table scan on t2  (cost=0.85 rows=6)
    -&gt; Single-row index lookup on &lt;subquery2&gt; using &lt;auto_distinct_key&gt; (c1=t2.c1)
        -&gt; Materialize with deduplication
            -&gt; Filter: (t1.c1 is not null)  (cost=0.85 rows=6)
                -&gt; Table scan on t1  (cost=0.85 rows=6)
</pre></li><li class="listitem"><p>
              <span class="emphasis"><em>左外部結合</em></span>:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN FORMAT=TREE SELECT * FROM t1 LEFT JOIN t2 ON t1.c1 = t2.c1\G</code></strong>
*************************** 1. row ***************************
EXPLAIN: -&gt; Left hash join (t2.c1 = t1.c1)  (cost=3.99 rows=36)
    -&gt; Table scan on t1  (cost=0.85 rows=6)
    -&gt; Hash
        -&gt; Table scan on t2  (cost=0.14 rows=6)
</pre></li><li class="listitem"><p>
              <span class="emphasis"><em>右外部結合</em></span> (MySQL では、すべての右外部結合が左外部結合としてリライトされることを確認します):
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN FORMAT=TREE SELECT * FROM t1 RIGHT JOIN t2 ON t1.c1 = t2.c1\G</code></strong>
*************************** 1. row ***************************
EXPLAIN: -&gt; Left hash join (t1.c1 = t2.c1)  (cost=3.99 rows=36)
    -&gt; Table scan on t2  (cost=0.85 rows=6)
    -&gt; Hash
        -&gt; Table scan on t1  (cost=0.14 rows=6)
</pre></li></ul></div><p>
          デフォルトでは、MySQL 8.0.18 以降では可能なかぎりハッシュ結合が使用されます。 ハッシュ結合を使用するかどうかは、<code class="literal">BNL</code> オプティマイザヒントと <code class="literal">NO_BNL</code> オプティマイザヒントのいずれかを使用して制御できます。 
        </p><p>
          (MySQL 8.0.18 は、<code class="literal">optimizer_switch</code> サーバーシステム変数の設定の一部として <code class="literal">hash_join=on</code> または <code class="literal">hash_join=off</code> をサポートし、オプティマイザヒント <code class="literal">HASH_JOIN</code> または <code class="literal">NO_HASH_JOIN</code> もサポートしていました。 MySQL 8.0.19 以降では、これらは効果がなくなりました。) 
        </p><p>
          ハッシュ結合によるメモリー使用量は、<code class="literal">join_buffer_size</code> システム変数を使用して制御できます。ハッシュ結合では、この量を超えるメモリーを使用できません。 ハッシュ結合に必要なメモリーが使用可能な量を超えると、MySQL はディスク上のファイルを使用してこれを処理します。 これが発生した場合、ハッシュ結合がメモリーに収まらず、<code class="literal">open_files_limit</code> に設定されているよりも多くのファイルが作成されると、結合が成功しない可能性があることに注意してください。 このような問題を回避するには、次のいずれかの変更を行います: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              ハッシュ結合がディスクにオーバーフローしないように、<code class="literal">join_buffer_size</code> を増やします。
            </p></li><li class="listitem"><p>
              <code class="literal">open_files_limit</code> を増やします。
            </p></li></ul></div><p>
          MySQL 8.0.18 以降、ハッシュ結合の結合バッファは増分的に割り当てられるため、非常に大量の RAM を割り当てる小さいクエリーなしに <code class="literal">join_buffer_size</code> をより高く設定できますが、外部結合ではバッファ全体が割り当てられます。 MySQL 8.0.20 以降では、外部結合 (アンチ結合および準結合を含む) にもハッシュ結合が使用されるため、これは問題ではなくなりました。 
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="engine-condition-pushdown-optimization"></a>8.2.1.5 エンジンコンディションプッシュダウンの最適化</h4></div></div></div><a class="indexterm" name="idm45661481077920"></a><a class="indexterm" name="idm45661481076464"></a><p>
          この最適化は、インデックスが設定されていないカラムと定数との直接比較の効率性を向上します。 このような場合、条件が評価のためにストレージエンジンに<span class="quote">「<span class="quote">プッシュダウン</span>」</span>されます。 この最適化は、<code class="literal">NDB</code> ストレージエンジンでのみ使用できます。 
        </p><p>
          NDB Cluster の場合、この最適化により、クラスタデータノードとクエリーを発行した MySQL サーバーの間で一致しない行をネットワーク経由で送信する必要がなくなり、条件プッシュダウンが可能だが使用されない場合に 5 から 10 倍の係数で使用されるクエリーを高速化できます。
        </p><p>
          「NDB Cluster」テーブルが次のように定義されているとします:
        </p><pre class="programlisting">CREATE TABLE t1 (
    a INT,
    b INT,
    KEY(a)
) ENGINE=NDB;
</pre><p>
          エンジン条件プッシュダウンは、インデックス付けされていないカラムと定数の比較を含む、次に示すようなクエリーで使用できます:
        </p><pre class="programlisting">SELECT a, b FROM t1 WHERE b = 10;
</pre><p>
          エンジン条件プッシュダウンの使用は、<code class="literal">EXPLAIN</code> の出力で確認できます:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT a,b FROM t1 WHERE b = 10\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 10
        Extra: Using where with pushed condition
</pre><p>
          ただし、エンジン条件プッシュダウンは、次のクエリーでは使用できません:
        </p><pre class="programlisting">SELECT a,b FROM t1 WHERE a = 10;
</pre><p>
          カラム <code class="literal">a</code> にインデックスが存在するため、エンジン条件プッシュダウンはここでは適用できません。 (インデックスアクセスメソッドの方が効率的であるため、コンディションプッシュダウンよりも優先して選択されます。)  
        </p><p>
          エンジン条件プッシュダウンは、インデックス付けされたカラムが <code class="literal">&gt;</code> または <code class="literal">&lt;</code> 演算子を使用して定数と比較される場合にも使用できます:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT a, b FROM t1 WHERE a &lt; 2\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
         type: range
possible_keys: a
          key: a
      key_len: 5
          ref: NULL
         rows: 2
        Extra: Using where with pushed condition
</pre><p>
          エンジン条件プッシュダウンでサポートされているその他の比較には、次のものがあります:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal"><em class="replaceable"><code>column</code></em> [NOT] LIKE <em class="replaceable"><code>pattern</code></em></code>
            </p><p>
              <em class="replaceable"><code>pattern</code></em> は、照合するパターンを含む文字列リテラルである必要があります。構文については、<a class="xref" href="functions.html#string-comparison-functions" title="12.8.1 文字列比較関数および演算子">セクション12.8.1「文字列比較関数および演算子」</a>を参照してください。
            </p></li><li class="listitem"><p>
              <code class="literal"><em class="replaceable"><code>column</code></em> IS [NOT] NULL</code>
            </p></li><li class="listitem"><p>
              <code class="literal"><em class="replaceable"><code>column</code></em> IN (<em class="replaceable"><code>value_list</code></em>)</code>
            </p><p>
              <em class="replaceable"><code>value_list</code></em> の各項目は定数のリテラル値である必要があります。
            </p></li><li class="listitem"><p>
              <code class="literal"><em class="replaceable"><code>column</code></em> BETWEEN <em class="replaceable"><code>constant1</code></em> AND <em class="replaceable"><code>constant2</code></em></code>
            </p><p>
              <em class="replaceable"><code>constant1</code></em> と <em class="replaceable"><code>constant2</code></em> はそれぞれ、定数のリテラル値である必要があります。
            </p></li></ul></div><p>
          前のリストのすべての場合で、条件をカラムと定数との 1 つ以上の直接比較の形式に変換できます。
        </p><p>
          エンジンコンディションプッシュダウンはデフォルトで有効です。 サーバーの起動時に無効にするには、<code class="literal">optimizer_switch</code> システム変数の <code class="literal">engine_condition_pushdown</code> フラグを <code class="literal">off</code> に設定します。 たとえば、<code class="filename">my.cnf</code> ファイルで、次の行を使用します。 
        </p><pre class="programlisting">[mysqld]
optimizer_switch=engine_condition_pushdown=off
</pre><p>
          実行時に、次のように条件プッシュダウンを無効にします:
        </p><pre class="programlisting">SET optimizer_switch='engine_condition_pushdown=off';
</pre><p><b>制限. </b>
            エンジンコンディションプッシュダウンには次の制限があります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              エンジン条件プッシュダウンは、<code class="literal">NDB</code> ストレージエンジンでのみサポートされます。
            </p></li><li class="listitem"><p>
              NDB 8.0.18 より前では、カラムは定数または定数値にのみ評価される式と比較できました。 NDB 8.0.18 以降では、カラムがまったく同じタイプであるかぎり、カラムを相互に比較できます (それらが該当する場合は、同じ符号性、長さ、文字セット、精度、およびスケールを含む)。 
            </p></li><li class="listitem"><p>
              比較に使用されるカラムは、<code class="literal">BLOB</code> 型または <code class="literal">TEXT</code> 型のいずれかであってはいけません。 この除外は、<code class="literal">JSON</code>、<code class="literal">BIT</code> および <code class="literal">ENUM</code> カラムにも拡張されます。 
            </p></li><li class="listitem"><p>
              カラムと比較される文字列値は、カラムと同じ照合順序を使用する必要があります。
            </p></li><li class="listitem"><p>
              結合は直接サポートされていません。複数のテーブルを含む条件は、可能な場合に個別にプッシュされます。 拡張 <code class="literal">EXPLAIN</code> 出力を使用して、実際にプッシュダウンされる条件を決定します。 <a class="xref" href="optimization.html#explain-extended" title="8.8.3 拡張 EXPLAIN 出力形式">セクション8.8.3「拡張 EXPLAIN 出力形式」</a>を参照してください。 
            </p></li></ul></div><p>
          以前は、エンジン条件プッシュダウンは、条件のプッシュ先と同じテーブルのカラム値を参照する用語に制限されていました。 NDB 8.0.16 以降では、クエリープラン内の以前のテーブルのカラム値をプッシュされた条件から参照することもできます。 これにより、結合処理中に SQL ノードで処理する必要がある行数が削減されます。 フィルタリングは、単一の <span class="command"><strong>mysqld</strong></span> プロセスではなく LDM スレッドで並列に実行することもできます。 これにより、クエリーのパフォーマンスが大幅に向上する可能性があります。 
        </p><p>
          NDB 8.0.20 以降では、スキャンを使用する外部結合は、同じ結合入れ子で使用されるテーブル、またはそれが依存する結合 nmests 内のテーブルにプッシュ不可能な条件がない場合にプッシュできます。 これは、使用される最適化戦略が <code class="literal">firstMatch</code> である場合にには、準結合でも当てはまります (<a class="xref" href="optimization.html#semijoins" title="8.2.2.1 準結合変換による IN および EXISTS サブクエリー述語の最適化">セクション8.2.2.1「準結合変換による IN および EXISTS サブクエリー述語の最適化」</a> を参照)。 
        </p><p>
          次の 2 つの状況では、結合アルゴリズムを前のテーブルの参照カラムと組み合せることはできません:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              参照された以前のテーブルのいずれかが結合バッファ内にある場合。 この場合、スキャンフィルタ処理されたテーブルから取得された各行は、バッファ内のすべての行と照合されます。 つまり、スキャンフィルタの生成時にカラム値をフェッチできる単一の特定の行はありません。 
            </p></li><li class="listitem"><p>
              プッシュされた結合の子操作からカラムが作成された場合。 これは、スキャンフィルタの生成時に、結合の祖先操作から参照される行がまだ取得されていないためです。 
            </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="index-condition-pushdown-optimization"></a>8.2.1.6 インデックスコンディションプッシュダウンの最適化</h4></div></div></div><p>
          インデックスコンディションプッシュダウン (ICP) は、MySQL がインデックスを使用してテーブルから行を取得する場合の最適化です。 ICP を使用しない場合、ストレージエンジンはインデックスをトラバースして、ベーステーブル内で行を検索し、MySQL Server に返し、MySQL Server が行に対して <code class="literal">WHERE</code> 条件を評価します。 ICP が有効で、インデックスのカラムのみを使用して <code class="literal">WHERE</code> 条件の一部を評価できる場合、MySQL サーバーは <code class="literal">WHERE</code> 条件のこの部分をストレージエンジンにプッシュダウンします。 ストレージエンジンは、インデックスエントリを使用して、プッシュされたインデックス条件を評価し、これが満たされている場合にのみ、テーブルから行を読み取ります。 ICP は、ストレージエンジンがベーステーブルにアクセスする必要がある回数と、MySQL サーバーがストレージエンジンにアクセスする必要がある回数を削減できます。 
        </p><p>
          インデックス条件プッシュダウン最適化の適用には、次の条件があります:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              ICP は、完全なテーブルの行にアクセスする必要がある場合に、<code class="literal">range</code>, <code class="literal">ref</code>, <code class="literal">eq_ref</code> および <code class="literal">ref_or_null</code> のアクセス方法に使用されます。
            </p></li><li class="listitem"><p>
              ICP は、パーティション化された <code class="literal">InnoDB</code> テーブルおよび <code class="literal">MyISAM</code> テーブルを含む <code class="literal">InnoDB</code> テーブルおよび <code class="literal">MyISAM</code> テーブルに使用できます。
            </p></li><li class="listitem"><p>
              <code class="literal">InnoDB</code> テーブルの場合、ICP はセカンダリインデックスにのみ使用されます。 ICP の目的は、全行読取りの数を減らして I/O 操作を減らすことです。 <code class="literal">InnoDB</code> のクラスタ化されたインデックスの場合、完全なレコードはすでに <code class="literal">InnoDB</code> バッファーに読み込まれています。 この場合、ICP を使用しても I/O は削減されません。 
            </p></li><li class="listitem"><p>
              ICP は、仮想生成カラムに作成されたセカンダリインデックスではサポートされていません。 <code class="literal">InnoDB</code> では、仮想生成カラムのセカンダリインデックスがサポートされます。 
            </p></li><li class="listitem"><p>
              サブクエリーを参照する条件はプッシュダウンできません。
            </p></li><li class="listitem"><p>
              ストアドファンクションを参照する条件はプッシュダウンできません。 ストレージエンジンはストアドファンクションを呼び出せません。 
            </p></li><li class="listitem"><p>
              トリガー条件はプッシュダウンできません。 (トリガーされる条件の詳細は、<a class="xref" href="optimization.html#subquery-optimization-with-exists" title="8.2.2.3 EXISTS 戦略を使用したサブクエリーの最適化">セクション8.2.2.3「EXISTS 戦略を使用したサブクエリーの最適化」</a> を参照してください。) 
            </p></li></ul></div><p>
          この最適化の仕組みを理解するには、最初に、インデックス条件プッシュダウンが使用されない場合のインデックススキャンの進行方法を検討します:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              まず、インデックスタプルを読み取り、次にそのインデックスタプルを使用して、完全なテーブル行を見つけて読み取ることで、次の行を取得します。
            </p></li><li class="listitem"><p>
              このテーブルに適用される <code class="literal">WHERE</code> 条件の部分をテストします。 テスト結果に基づいて行を受け入れるか、拒否します。 
            </p></li></ol></div><p>
          インデックス条件プッシュダウンを使用すると、かわりに次のようにスキャンが続行されます:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              次の行のインデックスタプルを取得します (ただし完全なテーブル行ではありません)。
            </p></li><li class="listitem"><p>
              このテーブルに適用され、インデックスカラムのみを使用してチェックできる <code class="literal">WHERE</code> 条件の部分をテストします。 条件が満たされている場合、次の行のインデックスタプルに進みます。 
            </p></li><li class="listitem"><p>
              条件が満たされている場合、インデックスタプルを使用して、完全なテーブル行を見つけて読み取ります。
            </p></li><li class="listitem"><p>
              このテーブルに適用される <code class="literal">WHERE</code> 条件の残りの部分をテストします。 テスト結果に基づいて行を受け入れるか、拒否します。 
            </p></li></ol></div><p>
          インデックス条件プッシュダウンが使用されている場合、<code class="literal">EXPLAIN</code> 出力の <code class="literal">Extra</code> カラムに <code class="literal">Using index condition</code> が表示されます。 完全なテーブルの行を読み取る必要がある場合は適用されないため、<code class="literal">Using index</code> は表示されません。 
        </p><p>
          テーブルに人とそのアドレスに関する情報が含まれており、テーブルに <code class="literal">INDEX (zipcode, lastname, firstname)</code> として定義されたインデックスがあるとします。 個人の <code class="literal">zipcode</code> 値がわかっているが、姓がわからない場合は、次のように検索できます: 
        </p><pre class="programlisting">SELECT * FROM people
  WHERE zipcode='95054'
  AND lastname LIKE '%etrunia%'
  AND address LIKE '%Main Street%';
</pre><p>
          MySQL はインデックスを使用して、<code class="literal">zipcode='95054'</code> を持つ人をスキャンします。 2 番目の部分 (<code class="literal">lastname LIKE '%etrunia%'</code>) を使用してスキャンする必要がある行数を制限することはできないため、インデックス条件プッシュダウンを使用しない場合、このクエリーでは、<code class="literal">zipcode='95054'</code>を持つすべてのユーザーの完全なテーブルの行を取得する必要があります。 
        </p><p>
          インデックス条件プッシュダウンでは、MySQL はテーブルの行全体を読み取る前に <code class="literal">lastname LIKE '%etrunia%'</code>部分をチェックします。 これにより、<code class="literal">zipcode</code> 条件に一致するが <code class="literal">lastname</code> 条件に一致しないインデックスタプルに対応する完全な行の読取りが回避されます。 
        </p><p>
          インデックス条件のプッシュダウンはデフォルトで有効になっています。 <code class="literal">index_condition_pushdown</code> フラグを設定することで、<code class="literal">optimizer_switch</code> システム変数で制御できます: 
        </p><pre class="programlisting">SET optimizer_switch = 'index_condition_pushdown=off';
SET optimizer_switch = 'index_condition_pushdown=on';
</pre><p>
          <a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2 切り替え可能な最適化">セクション8.9.2「切り替え可能な最適化」</a>を参照してください。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="nested-loop-joins"></a>8.2.1.7 Nested Loop 結合アルゴリズム</h4></div></div></div><a class="indexterm" name="idm45661480952928"></a><a class="indexterm" name="idm45661480951408"></a><a class="indexterm" name="idm45661480949456"></a><a class="indexterm" name="idm45661480947904"></a><p>
          MySQL は、Nested Loop アルゴリズムまたはそのバリエーションを使用してテーブル間の結合を実行します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#nested-loop-join-algorithm" title="Nested Loop 結合アルゴリズム">Nested Loop 結合アルゴリズム</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#block-nested-loop-join-algorithm" title="Block Nested Loop 結合アルゴリズム">Block Nested Loop 結合アルゴリズム</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="nested-loop-join-algorithm"></a>Nested Loop 結合アルゴリズム</h5></div></div></div><p>
            単純な Nested Loop Join (NLJ) アルゴリズムは、ループ内の最初のテーブルから行を一度に 1 つずつ読み取り、各行を、結合の次のテーブルを処理するネストしたループに渡します。 このプロセスは、結合するテーブルが残っている回数だけ繰り返されます。 
          </p><p>
            3 つのテーブル <code class="literal">t1</code>、<code class="literal">t2</code>、および <code class="literal">t3</code> 間の結合が、次の結合型を使用して実行されるとします。
          </p><pre class="programlisting">Table   Join Type
t1      range
t2      ref
t3      ALL
</pre><p>
            単純な NLJ アルゴリズムを使用した場合、結合は次のように処理されます。
          </p><pre class="programlisting">for each row in t1 matching range {
  for each row in t2 matching reference key {
    for each row in t3 {
      if row satisfies join conditions, send to client
    }
  }
}
</pre><p>
            NLJ アルゴリズムでは、外側のループから内側のループに、一度に 1 つずつ行を渡すため、一般に内側のループで処理されるテーブルを何回も読み取ります。
          </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="block-nested-loop-join-algorithm"></a>Block Nested Loop 結合アルゴリズム</h5></div></div></div><p>
            Block Nested-Loop (BNL) 結合アルゴリズムは、外側のループで読み取られた行のバッファリングを使用して、内側のループでテーブルを読み取る必要がある回数が削減されます。 たとえば、バッファーに 10 行が読み込まれ、このバッファーが次の内側のループに渡される場合、内側のループで読み取られる各行をバッファー内のすべての 10 行と比較できます。 これにより、内部テーブルを読み取る必要がある回数が大幅に減少します。 
          </p><p>
            MySQL 8.0.18 より前は、このアルゴリズムはインデックスを使用できなかった場合に等価結合に適用されていました。MySQL 8.0.18 以降では、このような場合にハッシュ結合の最適化が採用されます。 MySQL 8.0.20 以降では、ブロックのネステッドループは MySQL で使用されなくなり、ブロックのネステッドループが以前に使用されていたすべての場合にハッシュ結合が使用されます。 <a class="xref" href="optimization.html#hash-joins" title="8.2.1.4 ハッシュ結合の最適化">セクション8.2.1.4「ハッシュ結合の最適化」</a>を参照してください。 
          </p><p>
            MySQL 結合バッファリングには、次の特性があります:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                結合バッファリングは、結合の型が <code class="literal">ALL</code> または <code class="literal">index</code> である (つまり、使用できるキーがなく、データ行またはインデックス行の完全スキャンがそれぞれ実行される場合) か、または <code class="literal">range</code> である場合に使用できます。 <a class="xref" href="optimization.html#bnl-bka-optimization" title="8.2.1.12 Block Nested Loop 結合と Batched Key Access 結合">セクション8.2.1.12「Block Nested Loop 結合と Batched Key Access 結合」</a> で説明されているように、バッファリングの使用は外部結合にも適用できます。 
              </p></li><li class="listitem"><p>
                結合バッファは、<code class="literal">ALL</code> または <code class="literal">index</code> タイプであっても、最初の非定数テーブルには割り当てられません。
              </p></li><li class="listitem"><p>
                結合に関連するカラムのみが、行全体ではなく結合バッファに格納されます。
              </p></li><li class="listitem"><p>
                <code class="literal">join_buffer_size</code> システム変数は、クエリーの処理に使用される各結合バッファのサイズを決定します。
              </p></li><li class="listitem"><p>
                バッファリング可能な結合ごとに 1 つのバッファーが割り当てられるため、特定のクエリーが、複数の結合バッファーを使用して処理されることがあります。
              </p></li><li class="listitem"><p>
                結合バッファーは、結合の実行前に割り当てられ、クエリーの完了後に解放されます。
              </p></li></ul></div><p>
            NLJ アルゴリズム (バッファリングなし) で前述した結合の例では、結合は結合バッファリングを使用して次のように実行されます:
          </p><pre class="programlisting">for each row in t1 matching range {
  for each row in t2 matching reference key {
    store used columns from t1, t2 in join buffer
    if buffer is full {
      for each row in t3 {
        for each t1, t2 combination in join buffer {
          if row satisfies join conditions, send to client
        }
      }
      empty join buffer
    }
  }
}

if buffer is not empty {
  for each row in t3 {
    for each t1, t2 combination in join buffer {
      if row satisfies join conditions, send to client
    }
  }
}
</pre><p>
            <em class="replaceable"><code>S</code></em> が格納されている各 <code class="literal">t1</code>、結合バッファ内の <code class="literal">t2</code> の組合せのサイズであり、<em class="replaceable"><code>C</code></em> がバッファ内の組合せの数である場合、<code class="literal">t3</code> テーブルがスキャンされる回数は次のとおりです:
          </p><pre class="programlisting">(<em class="replaceable"><code>S</code></em> * <em class="replaceable"><code>C</code></em>)/join_buffer_size + 1
</pre><p>
            <code class="literal">join_buffer_size</code> が前のすべての行の組み合わせを保持できるだけの大きさになる時点まで、<code class="literal">join_buffer_size</code> の値が大きくなるほど、<code class="literal">t3</code> スキャンの回数は減少します。 その時点では、それを大きくしても速度は向上しません。 
          </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="nested-join-optimization"></a>8.2.1.8 ネストした結合の最適化</h4></div></div></div><p>
          結合を表す構文では、ネストした結合を使用できます。 次の説明は、<a class="xref" href="sql-statements.html#join" title="13.2.10.2 JOIN 句">セクション13.2.10.2「JOIN 句」</a>に説明する結合構文について言及しています。 
        </p><p>
          <em class="replaceable"><code>table_factor</code></em> の構文は SQL 標準と比較して拡張されています。 後者は <em class="replaceable"><code>table_reference</code></em> のみを受け付け、かっこ内のそれらのリストは受け付けません。 これは、<em class="replaceable"><code>table_reference</code></em> 項目のリストの各カンマを内部結合と同等とみなす場合、保守的な拡張です。 例: 
        </p><pre class="programlisting">SELECT * FROM t1 LEFT JOIN (t2, t3, t4)
                 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)
</pre><p>
          次と同等です:
        </p><pre class="programlisting">SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4)
                 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)
</pre><p>
          MySQL では、<code class="literal">CROSS JOIN</code> は <code class="literal">INNER JOIN</code> と構文的に同等であり、相互に置換できます。 標準 SQL では、それらは同等ではありません。 <code class="literal">INNER JOIN</code> は <code class="literal">ON</code> 句と一緒に使用します。<code class="literal">CROSS JOIN</code> はそうでない場合でも使用できます。 
        </p><p>
          一般に、内部結合操作のみを含む結合式内のかっこは無視できます。 次の結合式について考えてみます: 
        </p><pre class="programlisting">t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)
   ON t1.a=t2.a
</pre><p>
          左のカッコおよびグループ化操作を削除すると、その結合式は次の式に変換されます:
        </p><pre class="programlisting">(t1 LEFT JOIN t2 ON t1.a=t2.a) LEFT JOIN t3
    ON t2.b=t3.b OR t2.b IS NULL
</pre><p>
          まだ、2 つの式は同等ではありません。 これを確認するには、テーブル <code class="literal">t1</code>、<code class="literal">t2</code>、<code class="literal">t3</code> が次の状態であるとします。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              テーブル <code class="literal">t1</code> には行 <code class="literal">(1)</code>、<code class="literal">(2)</code> が含まれます
            </p></li><li class="listitem"><p>
              テーブル <code class="literal">t2</code> には行 <code class="literal">(1,101)</code> が含まれます
            </p></li><li class="listitem"><p>
              テーブル <code class="literal">t3</code> には行 <code class="literal">(101)</code> が含まれます
            </p></li></ul></div><p>
          この場合、最初の式は行 <code class="literal">(1,1,101,101)</code>、<code class="literal">(2,NULL,NULL,NULL)</code> を含む結果セットを返し、2 番目の式は行 <code class="literal">(1,1,101,101)</code>、<code class="literal">(2,NULL,NULL,101)</code> を返します。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
       <strong class="userinput"><code>FROM t1</code></strong>
            <strong class="userinput"><code>LEFT JOIN</code></strong>
            <strong class="userinput"><code>(t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)</code></strong>
            <strong class="userinput"><code>ON t1.a=t2.a;</code></strong>
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL | NULL |
+------+------+------+------+

mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
       <strong class="userinput"><code>FROM (t1 LEFT JOIN t2 ON t1.a=t2.a)</code></strong>
            <strong class="userinput"><code>LEFT JOIN t3</code></strong>
            <strong class="userinput"><code>ON t2.b=t3.b OR t2.b IS NULL;</code></strong>
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL |  101 |
+------+------+------+------+
</pre><p>
          次の例では、外部結合操作が内部結合操作と一緒に使用されています。
        </p><pre class="programlisting">t1 LEFT JOIN (t2, t3) ON t1.a=t2.a
</pre><p>
          その式は次の式に変換できません。
        </p><pre class="programlisting">t1 LEFT JOIN t2 ON t1.a=t2.a, t3
</pre><p>
          指定されたテーブル状態では、次の 2 つの式は異なる行セットを返します。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
       <strong class="userinput"><code>FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a;</code></strong>
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL | NULL |
+------+------+------+------+

mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
       <strong class="userinput"><code>FROM t1 LEFT JOIN t2 ON t1.a=t2.a, t3;</code></strong>
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL |  101 |
+------+------+------+------+
</pre><p>
          したがって、外部結合演算子を含む結合式のかっこを省略すると、元の式の結果セットが変わることがあります。
        </p><p>
          正確に言えば、左外部結合操作の右オペランドと右結合操作の左オペランドのかっこを無視することはできません。 言い換えれば、外部結合操作の内部テーブル式のかっこを無視することはできません。 ほかのオペランド (外部テーブルのオペランド) のかっこは無視できます。 
        </p><p>
          次の式: 
        </p><pre class="programlisting">(t1,t2) LEFT JOIN t3 ON P(t2.b,t3.b)
</pre><p>
          属性 <code class="literal">t2.b</code> および <code class="literal">t3.b</code> に対する任意のテーブル <code class="literal">t1,t2,t3</code> および任意の条件 <code class="literal">P</code> のこの式と同等です:
        </p><pre class="programlisting">t1, t2 LEFT JOIN t3 ON P(t2.b,t3.b)
</pre><p>
          結合式 (<em class="replaceable"><code>joined_table</code></em>) での結合操作の実行順序が左から右にならない場合は、ネストされた結合について説明します。 次のクエリーを考慮します。 
        </p><pre class="programlisting">SELECT * FROM t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b) ON t1.a=t2.a
  WHERE t1.a &gt; 1

SELECT * FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a
  WHERE (t2.b=t3.b OR t2.b IS NULL) AND t1.a &gt; 1
</pre><p>
          それらのクエリーは次のネストした結合が含まれるとみなされます。
        </p><pre class="programlisting">t2 LEFT JOIN t3 ON t2.b=t3.b
t2, t3
</pre><p>
          最初のクエリーでは、ネストされた結合は左結合操作で形成されます。 2 番目のクエリーでは、内部結合操作を使用して形成されます。 
        </p><p>
          最初のクエリーでは、カッコを省略できます: 結合式の文法構造によって、結合操作の実行順序が同じになります。 2 番目のクエリーでは、かっこを省略できますが、それらがなくてもここの結合式は一義的に解釈できます。 拡張構文では、理論的にはクエリーは解析されますが、2 番目のクエリーの <code class="literal">(t2, t3)</code> にカッコが必要です: <code class="literal">LEFT JOIN</code> および <code class="literal">ON</code> は式 <code class="literal">(t2,t3)</code> の左右のデリミタの役割を果たすため、クエリーの構文構造は明確なままです。 
        </p><p>
          前の例でこれらの点を説明します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              内部結合のみを含む (外部結合を含まない) 結合式の場合は、カッコを削除して、左から右に結合を評価できます。 実際には、テーブルは任意の順序で評価できます。 
            </p></li><li class="listitem"><p>
              一般に、外部結合、または内部結合と混在した外部結合の場合には、同じことが当てはまりません。 かっこの削除によって、結果が変わることがあります。 
            </p></li></ul></div><a class="indexterm" name="idm45661480838112"></a><a class="indexterm" name="idm45661480835904"></a><p>
          ネストした外部結合を含むクエリーは内部結合を含むクエリーと同じパイプライン方式で実行されます。 正確には、Nested Loop 結合アルゴリズムのバリエーションが利用されます。 ネステッドループ結合でクエリーを実行するアルゴリズムを思い出します (<a class="xref" href="optimization.html#nested-loop-joins" title="8.2.1.7 Nested Loop 結合アルゴリズム">セクション8.2.1.7「Nested Loop 結合アルゴリズム」</a> を参照)。 3 つのテーブルに対する結合クエリー <code class="literal">T1,T2,T3</code> が次の形式であるとします: 
        </p><pre class="programlisting">SELECT * FROM T1 INNER JOIN T2 ON P1(T1,T2)
                 INNER JOIN T3 ON P2(T2,T3)
  WHERE P(T1,T2,T3)
</pre><p>
          ここでは、<code class="literal">P1(T1,T2)</code> と <code class="literal">P2(T3,T3)</code> が何らかの結合条件 (式での) で、<code class="literal">P(T1,T2,T3)</code> はテーブル <code class="literal">T1,T2,T3</code> のカラムに対する条件です。
        </p><p>
          Nested Loop 結合アルゴリズムでは、このクエリーを次のように実行します。
        </p><pre class="programlisting">FOR each row t1 in T1 {
  FOR each row t2 in T2 such that P1(t1,t2) {
    FOR each row t3 in T3 such that P2(t2,t3) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3; OUTPUT t;
      }
    }
  }
}
</pre><p>
          <code class="literal">t1||t2||t3</code> という表記法は、<code class="literal">t1</code>、<code class="literal">t2</code> および <code class="literal">t3</code> の行のカラムを連結して構築された行を示します。 次の例の一部では、テーブル名が表示される <code class="literal">NULL</code> は、そのテーブルの各カラムに <code class="literal">NULL</code> が使用される行を意味します。 たとえば、<code class="literal">t1||t2||NULL</code> は、<code class="literal">t3</code> のカラムごとに行 <code class="literal">t1</code> および <code class="literal">t2</code> のカラムと <code class="literal">NULL</code> を連結して構築された行を示します。 このような行は、<code class="literal">NULL</code> で補完されていると言われます。 
        </p><a class="indexterm" name="idm45661480816080"></a><p>
          ここで、ネストされた外部結合を含むクエリーについて考えてみます:
        </p><pre class="programlisting">SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON P2(T2,T3))
              ON P1(T1,T2)
  WHERE P(T1,T2,T3)
</pre><p>
          このクエリーでは、ネステッドループパターンを変更して次のものを取得します:
        </p><pre class="programlisting">FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t2 in T2 such that P1(t1,t2) {
    BOOL f2:=FALSE;
    FOR each row t3 in T3 such that P2(t2,t3) {
      IF P(t1,t2,t3) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f2=TRUE;
      f1=TRUE;
    }
    IF (!f2) {
      IF P(t1,t2,NULL) {
        t:=t1||t2||NULL; OUTPUT t;
      }
      f1=TRUE;
    }
  }
  IF (!f1) {
    IF P(t1,NULL,NULL) {
      t:=t1||NULL||NULL; OUTPUT t;
    }
  }
}
</pre><p>
          一般に、外部結合操作の最初の内部テーブルのネストしたループでは、ループの前にオフにされ、ループのあとにチェックされるフラグが導入されます。 フラグは、外部テーブルの現在行で、内側オペランドを表すテーブルからの一致が見つかったときにオンにされます。 ループサイクルの最後でフラグがまだオフの場合は、外部テーブルの現在行で一致が見つかりませんでした。 この例では、行が内部テーブルのカラムの <code class="literal">NULL</code> 値で補完されます。 結果の行は、出力の最終チェックまたは次のネストしたループに渡されますが、行が、埋め込まれたすべての外部結合の結合条件を満たしている場合に限られます。 
        </p><p>
          この例では、次の式でテーブルされる外部結合テーブルが埋め込まれています:
        </p><pre class="programlisting">(T2 LEFT JOIN T3 ON P2(T2,T3))
</pre><p>
          内部結合を含むクエリーの場合、オプティマイザは次のように、ネステッドループの異なる順序を選択できます:
        </p><pre class="programlisting">FOR each row t3 in T3 {
  FOR each row t2 in T2 such that P2(t2,t3) {
    FOR each row t1 in T1 such that P1(t1,t2) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3; OUTPUT t;
      }
    }
  }
}
</pre><p>
          外部結合を使用するクエリーの場合、オプティマイザは、外部テーブルのループが内部テーブルのループより前にある順序のみを選択できます。 つまり、外部結合を含むクエリーでは、1 つだけのネスト順序しか使用できません。 次のクエリーでは、オプティマイザは 2 つの異なるネストを評価します。 両方のネストで、<code class="literal">T1</code> は外部結合で使用されているため、外側のループで処理される必要があります。 <code class="literal">T2</code> と <code class="literal">T3</code> は内部結合で使用されているため、その結合は内側のループで処理される必要があります。 ただし、結合は内部結合であるため、<code class="literal">T2</code> と <code class="literal">T3</code> はどちらの順序でも処理できます。 
        </p><pre class="programlisting">SELECT * T1 LEFT JOIN (T2,T3) ON P1(T1,T2) AND P2(T1,T3)
  WHERE P(T1,T2,T3)
</pre><p>
          あるネストによって <code class="literal">T2</code> が評価され、次に <code class="literal">T3</code> が評価されます:
        </p><pre class="programlisting">FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t2 in T2 such that P1(t1,t2) {
    FOR each row t3 in T3 such that P2(t1,t3) {
      IF P(t1,t2,t3) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f1:=TRUE
    }
  }
  IF (!f1) {
    IF P(t1,NULL,NULL) {
      t:=t1||NULL||NULL; OUTPUT t;
    }
  }
}
</pre><p>
          もう一方のネストでは、<code class="literal">T3</code> を評価してから、<code class="literal">T2</code> を評価します:
        </p><pre class="programlisting">FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t3 in T3 such that P2(t1,t3) {
    FOR each row t2 in T2 such that P1(t1,t2) {
      IF P(t1,t2,t3) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f1:=TRUE
    }
  }
  IF (!f1) {
    IF P(t1,NULL,NULL) {
      t:=t1||NULL||NULL; OUTPUT t;
    }
  }
}
</pre><p>
          内部結合の Nested Loop アルゴリズムについて説明した際に、クエリー実行のパフォーマンスに与える影響が大きい場合があるという詳細については省きました。 いわゆる<span class="quote">「<span class="quote">プッシュダウン</span>」</span> 条件については説明しませんでした。 たとえば、<code class="literal">WHERE</code> 条件 <code class="literal">P(T1,T2,T3)</code> を論理積標準形によって表現できるとします。 
        </p><pre class="programlisting">P(T1,T2,T2) = C1(T1) AND C2(T2) AND C3(T3).
</pre><p>
          この場合、MySQL では、内部結合を使用したクエリーの実行に次のネステッドループアルゴリズムが実際に使用されます:
        </p><pre class="programlisting">FOR each row t1 in T1 such that C1(t1) {
  FOR each row t2 in T2 such that P1(t1,t2) AND C2(t2)  {
    FOR each row t3 in T3 such that P2(t2,t3) AND C3(t3) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3; OUTPUT t;
      }
    }
  }
}
</pre><p>
          等位項 <code class="literal">C1(T1)</code>、<code class="literal">C2(T2)</code>、<code class="literal">C3(T3)</code> がそれぞれ、もっとも内側のループから、評価可能なもっとも外側のループまで押し出されることがわかります。 <code class="literal">C1(T1)</code> がきわめて制限の強い条件である場合、このコンディションプッシュダウンによって、テーブル <code class="literal">T1</code> から内側ループに渡される行数が大幅に少なくなることがあります。 結果として、クエリーの実行時間が大幅に短縮される可能性があります。 
        </p><p>
          外部結合を含むクエリーでは、外部テーブルの現在行で内部テーブルに一致があることが見つかったあとにのみ、<code class="literal">WHERE</code> 条件がチェックされます。 そのため、内側のネストしたループからのプッシュ条件の最適化は、外部結合を含むクエリーには直接適用できません。 ここでは、一致が発生したときにオンになるフラグで保護される条件付きプッシュダウン述語を導入する必要があります。 
        </p><p>
          外部結合を使用した次の例を思い出してください:
        </p><pre class="programlisting">P(T1,T2,T3)=C1(T1) AND C(T2) AND C3(T3)
</pre><p>
          この例では、保護されたプッシュダウン条件を使用するネステッドループアルゴリズムは次のようになります:
        </p><pre class="programlisting">FOR each row t1 in T1 such that C1(t1) {
  BOOL f1:=FALSE;
  FOR each row t2 in T2
      such that P1(t1,t2) AND (f1?C2(t2):TRUE) {
    BOOL f2:=FALSE;
    FOR each row t3 in T3
        such that P2(t2,t3) AND (f1&amp;&amp;f2?C3(t3):TRUE) {
      IF (f1&amp;&amp;f2?TRUE:(C2(t2) AND C3(t3))) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f2=TRUE;
      f1=TRUE;
    }
    IF (!f2) {
      IF (f1?TRUE:C2(t2) &amp;&amp; P(t1,t2,NULL)) {
        t:=t1||t2||NULL; OUTPUT t;
      }
      f1=TRUE;
    }
  }
  IF (!f1 &amp;&amp; P(t1,NULL,NULL)) {
      t:=t1||NULL||NULL; OUTPUT t;
  }
}
</pre><p>
          一般に、プッシュダウン述語は <code class="literal">P1(T1,T2)</code> や <code class="literal">P(T2,T3)</code> などの結合条件から抽出できます。 この場合、プッシュダウン述語は、対応する外部結合操作によって生成される <code class="literal">NULL</code> が補完された行の述語のチェックを妨げるフラグによっても保護されます。 
        </p><p>
          同じネストされた結合内のある内部テーブルから別のテーブルへのキーによるアクセスは、<code class="literal">WHERE</code> 条件から述語によって誘導された場合は禁止されます。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="outer-join-optimization"></a>8.2.1.9 外部結合の最適化</h4></div></div></div><a class="indexterm" name="idm45661480769616"></a><a class="indexterm" name="idm45661480767504"></a><a class="indexterm" name="idm45661480765472"></a><a class="indexterm" name="idm45661480764496"></a><a class="indexterm" name="idm45661480762464"></a><a class="indexterm" name="idm45661480761376"></a><p>
          外部結合には、<code class="literal">LEFT JOIN</code> および <code class="literal">RIGHT JOIN</code> が含まれます。
        </p><p>
          MySQL は、次のように <code class="literal"><em class="replaceable"><code>A</code></em> LEFT JOIN <em class="replaceable"><code>B</code></em> <em class="replaceable"><code>join_specification</code></em></code> を実装します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              テーブル <em class="replaceable"><code>B</code></em> は、テーブル <em class="replaceable"><code>A</code></em> と <em class="replaceable"><code>A</code></em> が依存するすべてのテーブルに依存して設定されます。
            </p></li><li class="listitem"><p>
              テーブル <em class="replaceable"><code>A</code></em> は、<code class="literal">LEFT JOIN</code> 条件で使用されるすべてのテーブル (<em class="replaceable"><code>B</code></em> を除く) に依存して設定されます。
            </p></li><li class="listitem"><p>
              <code class="literal">LEFT JOIN</code> 条件は、テーブル <em class="replaceable"><code>B</code></em> からの行の取得方法を決定するために使用されます。 (言い換えると、<code class="literal">WHERE</code> 句内のすべての条件が使用されません)。 
            </p></li><li class="listitem"><p>
              テーブルは常にそれが依存するすべてのテーブルのあとに読み取られることを除き、すべての標準の結合最適化が実行されます。 循環依存関係がある場合は、エラーが発生します。 
            </p></li><li class="listitem"><p>
              すべての標準 <code class="literal">WHERE</code> 最適化が実行されます。
            </p></li><li class="listitem"><p>
              <em class="replaceable"><code>A</code></em> に <code class="literal">WHERE</code> 句に一致する行があるが、<em class="replaceable"><code>B</code></em> に <code class="literal">ON</code> 条件に一致する行がない場合、すべてのカラムが <code class="literal">NULL</code> に設定された追加の <em class="replaceable"><code>B</code></em> 行が生成されます。
            </p></li><li class="listitem"><p>
              <code class="literal">LEFT JOIN</code> を使用して、一部のテーブルに存在しない行を検索し、<code class="literal">WHERE</code> 部分の <code class="literal"><em class="replaceable"><code>col_name</code></em> IS NULL</code> のテストを実行した場合 (ここで <em class="replaceable"><code>col_name</code></em> は <code class="literal">NOT NULL</code> と宣言されているカラム)、MySQL は <code class="literal">LEFT JOIN</code> 条件に一致する 1 つの行が見つかったあとに、それ以上の行 (の特定のキーの組み合わせ) の検索を停止します。
            </p></li></ul></div><p>
          <code class="literal">RIGHT JOIN</code> の実装は、テーブルロールを逆にした <code class="literal">LEFT JOIN</code> の実装に似ています。 <a class="xref" href="optimization.html#outer-join-simplification" title="8.2.1.10 外部結合の単純化">セクション8.2.1.10「外部結合の単純化」</a> で説明されているように、右結合は同等の左結合に変換されます。 
        </p><p>
          <code class="literal">LEFT JOIN</code> では、生成された <code class="literal">NULL</code> 行の <code class="literal">WHERE</code> 条件が常に false の場合、<code class="literal">LEFT JOIN</code> は内部結合に変更されます。 たとえば、<code class="literal">t2.column1</code> が <code class="literal">NULL</code> であった場合、次のクエリーの <code class="literal">WHERE</code> 句は false になります。 
        </p><pre class="programlisting">SELECT * FROM t1 LEFT JOIN t2 ON (column1) WHERE t2.column2=5;
</pre><p>
          したがって、クエリーを内部結合に変換しても安全です:
        </p><pre class="programlisting">SELECT * FROM t1, t2 WHERE t2.column2=5 AND t1.column1=t2.column1;
</pre><p>
          MySQL 8.0.14 以降では、定数リテラル式から発生する簡単な <code class="literal">WHERE</code> 条件は、最適化の後の段階ではなく、準備中に削除され、結合がすでに簡略化されています。 以前に簡易条件を削除すると、オプティマイザは外部結合を内部結合に変換できます。これにより、次のような <code class="literal">WHERE</code> 句に簡易条件を含む外部結合を含むクエリーの計画が改善される可能性があります: 
        </p><pre class="programlisting">SELECT * FROM t1 LEFT JOIN t2 ON <em class="replaceable"><code>condition_1</code></em> WHERE <em class="replaceable"><code>condition_2</code></em> OR 0 = 1
</pre><p>
          オプティマイザは、準備中に 0 = 1 が常に false であることを確認し、<code class="literal">OR 0 = 1</code> を冗長にして削除し、次の状態のままにします:
        </p><pre class="programlisting">SELECT * FROM t1 LEFT JOIN t2 ON <em class="replaceable"><code>condition_1</code></em> where <em class="replaceable"><code>condition_2</code></em>
</pre><p>
          これで、オプティマイザは、次のようにクエリーを内部結合としてリライトできます:
        </p><pre class="programlisting">SELECT * FROM t1 JOIN t2 WHERE <em class="replaceable"><code>condition_1</code></em> AND <em class="replaceable"><code>condition_2</code></em>
</pre><a class="indexterm" name="idm45661480712864"></a><p>
          これによりクエリー計画が改善される場合、オプティマイザはテーブル <code class="literal">t1</code> の前にテーブル <code class="literal">t2</code> を使用できるようになりました。 テーブルの結合順序に関するヒントを提供するには、オプティマイザヒントを使用します。<a class="xref" href="optimization.html#optimizer-hints" title="8.9.3 オプティマイザヒント">セクション8.9.3「オプティマイザヒント」</a> を参照してください。 または、<code class="literal">STRAIGHT_JOIN</code> を使用します。<a class="xref" href="sql-statements.html#select" title="13.2.10 SELECT ステートメント">セクション13.2.10「SELECT ステートメント」</a> を参照してください。 ただし、<code class="literal">STRAIGHT_JOIN</code> では準結合変換が無効になるため、インデックスの使用が妨げられる場合があります。<a class="xref" href="optimization.html#semijoins" title="8.2.2.1 準結合変換による IN および EXISTS サブクエリー述語の最適化">セクション8.2.2.1「準結合変換による IN および EXISTS サブクエリー述語の最適化」</a> を参照してください。 
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="outer-join-simplification"></a>8.2.1.10 外部結合の単純化</h4></div></div></div><p>
          クエリーの <code class="literal">FROM</code> 句内のテーブル式は、多くの場合単純化されます。
        </p><p>
          パーサーステージでは、右外部結合操作を含むクエリーは、左結合操作のみを含む同等のクエリーに変換されます。 一般的に、変換は次の右結合になるように実行されます: 
        </p><pre class="programlisting">(T1, ...) RIGHT JOIN (T2, ...) ON P(T1, ..., T2, ...)
</pre><p>
          次の同等の左結合になります:
        </p><pre class="programlisting">(T2, ...) LEFT JOIN (T1, ...) ON P(T1, ..., T2, ...)
</pre><p>
          形式 <code class="literal">T1 INNER JOIN T2 ON P(T1,T2)</code> のすべての内部結合式は、<code class="literal">WHERE</code> 条件に (または埋め込まれる結合の結合条件が存在する場合は、それに) 等位項として結合されるリスト <code class="literal">T1,T2</code>、<code class="literal">P(T1,T2)</code> によって、置き換えられます。
        </p><p>
          オプティマイザが外部結合操作の計画を評価するときは、そのような操作ごとに外部テーブルが内部テーブルの前にアクセスされる計画のみが考慮されます。 このような計画でのみネステッドループアルゴリズムを使用して外部結合を実行できるため、オプティマイザの選択は制限されます。 
        </p><p>
          次の形式のクエリーについて考えてみます。<code class="literal">R(T2)</code> では、テーブル <code class="literal">T2</code> の一致する行数が大幅に絞り込まれます:
        </p><pre class="programlisting">SELECT * T1 LEFT JOIN T2 ON P1(T1,T2)
  WHERE P(T1,T2) AND R(T2)
</pre><p>
          クエリーが書込み済として実行される場合、オプティマイザでは選択できませんが、より制限の少ないテーブル <code class="literal">T1</code> にアクセスしてから、より限定されたテーブル <code class="literal">T2</code> にアクセスすると、非常に非効率的な実行計画が生成される可能性があります。
        </p><p>
          かわりに、<code class="literal">WHERE</code> 条件が NULL 拒否の場合、MySQL はクエリーを外部結合操作なしのクエリーに変換します。 (つまり、外部結合を内部結合に変換します。) 条件は、その操作に対して生成された <code class="literal">NULL</code> で補完された行に対して <code class="literal">FALSE</code> または <code class="literal">UNKNOWN</code> と評価された場合、外部結合操作に対して NULL 拒否と呼ばれます。 
        </p><a class="indexterm" name="idm45661480684976"></a><a class="indexterm" name="idm45661480683488"></a><p>
          したがって、この外部結合の場合: 
        </p><pre class="programlisting">T1 LEFT JOIN T2 ON T1.A=T2.A
</pre><p>
          これらのような条件は、<code class="literal">NULL</code> で補完された行 (<code class="literal">T2</code> カラムが <code class="literal">NULL</code> に設定されている場合) では true にできないため、NULL 拒否されます:
        </p><pre class="programlisting">T2.B IS NOT NULL
T2.B &gt; 3
T2.C &lt;= T1.C
T2.B &lt; 2 OR T2.C &gt; 1
</pre><p>
          次のような条件は、<code class="literal">NULL</code> で補完された行に対して true になる可能性があるため、NULL 拒否されません:
        </p><pre class="programlisting">T2.B IS NULL
T1.B &lt; 3 OR T2.B IS NOT NULL
T1.B &lt; 3 OR T2.B &gt; 3
</pre><p>
          外部結合操作で条件が NULL 拒否かどうかをチェックする一般的なルールは、次のとおりです:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">A IS NOT NULL</code> の形式で、<code class="literal">A</code> は内部テーブルのいずれかの属性です
            </p></li><li class="listitem"><p>
              いずれかの引数が <code class="literal">NULL</code> の場合に <code class="literal">UNKNOWN</code> に評価される内部テーブルへの参照を含む述語です
            </p></li><li class="listitem"><p>
              結合として NULL 拒否条件を含む結合です
            </p></li><li class="listitem"><p>
              NULL 拒否条件の論理積です
            </p></li></ul></div><p>
          条件は、クエリー内で、ある外部結合操作に対しては NULL を受け付けないが、ほかの外部結合操作に対しては NULL を受け付ける場合があります。 このクエリーでは、<code class="literal">WHERE</code> 条件は 2 番目の外部結合操作では NULL 拒否されますが、最初の外部結合操作では NULL 拒否されません: 
        </p><pre class="programlisting">SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 LEFT JOIN T3 ON T3.B=T1.B
  WHERE T3.C &gt; 0
</pre><p>
          <code class="literal">WHERE</code> 条件がクエリーの外部結合操作に対して NULL を受け付けない場合、外部結合操作は内部結合操作に置き換えられます。
        </p><p>
          たとえば、前述のクエリーでは、2 番目の外部結合は NULL 拒否され、内部結合で置換できます:
        </p><pre class="programlisting">SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 INNER JOIN T3 ON T3.B=T1.B
  WHERE T3.C &gt; 0
</pre><p>
          元のクエリーの場合、オプティマイザは単一のテーブルアクセス順序 <code class="literal">T1,T2,T3</code> と互換性のある計画のみを評価します。 リライトされたクエリーでは、アクセス順序 <code class="literal">T3,T1,T2</code> も考慮されます。 
        </p><p>
          ある外部結合操作の変換によって、別の操作の変換がトリガーされることがあります。 そのため、次のクエリー:  
        </p><pre class="programlisting">SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 LEFT JOIN T3 ON T3.B=T2.B
  WHERE T3.C &gt; 0
</pre><p>
          最初にクエリーに変換されます:
        </p><pre class="programlisting">SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 INNER JOIN T3 ON T3.B=T2.B
  WHERE T3.C &gt; 0
</pre><p>
          これはクエリーと同等です:
        </p><pre class="programlisting">SELECT * FROM (T1 LEFT JOIN T2 ON T2.A=T1.A), T3
  WHERE T3.C &gt; 0 AND T3.B=T2.B
</pre><p>
          条件 <code class="literal">T3.B=T2.B</code> が NULL 拒否であるため、残りの外部結合操作を内部結合に置き換えることもできます。 これにより、外部結合のないクエリーが発生します: 
        </p><pre class="programlisting">SELECT * FROM (T1 INNER JOIN T2 ON T2.A=T1.A), T3
  WHERE T3.C &gt; 0 AND T3.B=T2.B
</pre><p>
          オプティマイザが埋込み外部結合操作の置換に成功しても、埋込み外部結合を変換できない場合があります。 次のクエリー:  
        </p><pre class="programlisting">SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A
  WHERE T3.C &gt; 0
</pre><p>
          次に変換されます:
        </p><pre class="programlisting">SELECT * FROM T1 LEFT JOIN
              (T2 INNER JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A
  WHERE T3.C &gt; 0
</pre><p>
          それは埋め込む外部結合操作を含む形式にのみ書き換えることができます。
        </p><pre class="programlisting">SELECT * FROM T1 LEFT JOIN
              (T2,T3)
              ON (T2.A=T1.A AND T3.B=T2.B)
  WHERE T3.C &gt; 0
</pre><p>
          クエリーで埋込み外部結合操作を変換しようとする場合は、埋込み外部結合の結合条件を <code class="literal">WHERE</code> 条件とともに考慮する必要があります。 このクエリーでは、埋込み外部結合の <code class="literal">WHERE</code> 条件は NULL 拒否されませんが、埋込み外部結合 <code class="literal">T2.A=T1.A AND T3.C=T1.C</code> の結合条件は NULL 拒否されます: 
        </p><pre class="programlisting">SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A AND T3.C=T1.C
  WHERE T3.D &gt; 0 OR T1.D &gt; 0
</pre><p>
          したがって、クエリーは次のように変換できます:
        </p><pre class="programlisting">SELECT * FROM T1 LEFT JOIN
              (T2, T3)
              ON T2.A=T1.A AND T3.C=T1.C AND T3.B=T2.B
  WHERE T3.D &gt; 0 OR T1.D &gt; 0
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mrr-optimization"></a>8.2.1.11 Multi-Range Read の最適化</h4></div></div></div><a class="indexterm" name="idm45661480637824"></a><a class="indexterm" name="idm45661480635712"></a><p>
          セカンダリインデックスでの範囲スキャンを使用して行を読み取ると、テーブルが大きく、ストレージエンジンのキャッシュに格納されていない場合、ベーステーブルへのランダムディスクアクセスが多発する結果になることがあります。 Disk-Sweep Multi-Range Read (MRR) 最適化を使用すると、MySQL は、最初にインデックスだけをスキャンし、該当する行のキーを収集することによって、範囲スキャンのランダムディスクアクセスの回数を軽減しようとします。 続いてキーがソートされ、最後に主キーの順序を使用してベーステーブルから行が取得されます。 Disk-Sweep MRR の目的は、ランダムディスクアクセスの回数を減らし、その代わりに、ベーステーブルデータの順次スキャンを増やすことです。 
        </p><p>
          Multi-Range Read の最適化には、次のメリットがあります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              MRR により、データ行はインデックスタプルに基づいて、ランダムな順序ではなく、順次アクセスできます。 サーバーはクエリー条件を満たすインデックスタプルセットを取得し、それらをデータ行 ID 順に従ってソートし、ソートされたタプルを使用して、データ行を順番に取得します。 これにより、データアクセスの効率が向上し、負荷が軽減されます。 
            </p></li><li class="listitem"><p>
              MRR により、範囲インデックススキャンや結合属性にインデックスを使用する等価結合などの、インデックスタプル経由でのデータ行へのアクセスを必要とする操作のキーアクセスのリクエストのバッチ処理が可能になります。 MRR はインデックス範囲のシーケンスを反復処理して、対象のインデックスタプルを取得します。 これらの結果が累積されると、それらは対応するデータ行にアクセスするために使用されます。 データ行の読み取りを開始する前に、すべてのインデックスタプルを取得する必要はありません。 
            </p></li></ul></div><p>
          MRR 最適化は、仮想生成カラムに作成されたセカンダリインデックスではサポートされていません。 <code class="literal">InnoDB</code> では、仮想生成カラムのセカンダリインデックスがサポートされます。 
        </p><p>
          次のシナリオでは、MRR の最適化に利益がある場合について説明しています。
        </p><p>
          シナリオ A: インデックス範囲スキャンと等価結合操作で、<code class="literal">InnoDB</code> テーブルと <code class="literal">MyISAM</code> テーブルに対して MRR を使用できます。
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              インデックスタプルの一部はバッファーに累積されます。
            </p></li><li class="listitem"><p>
              バッファー内のタプルはそれらのデータ行 ID によってソートされます。
            </p></li><li class="listitem"><p>
              データ行には、ソートされたインデックスタプルシーケンスに従ってアクセスされます。
            </p></li></ol></div><p>
          シナリオ B: 複数範囲インデックススキャンで、または属性によって等価結合を実行する際に、<code class="literal">NDB</code> テーブルに対して、MRR を使用できます。
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              単一キー範囲の可能性のある範囲の一部は、クエリーが送信される中央ノード上のバッファーに累積されます。
            </p></li><li class="listitem"><p>
              範囲はデータ行にアクセスする実行ノードに送信されます。
            </p></li><li class="listitem"><p>
              アクセスされた行はパッケージに格納され、中央ノードに返送されます。
            </p></li><li class="listitem"><p>
              受け取ったデータ行を含むパッケージはバッファーに入れられます。
            </p></li><li class="listitem"><p>
              データ行がバッファーから読み取られます。
            </p></li></ol></div><p>
          MRR が使用された場合は、<code class="literal">EXPLAIN</code> 出力の <code class="literal">Extra</code> カラムに <code class="literal">Using MRR</code> と示されます。
        </p><p>
          <code class="literal">InnoDB</code> と <code class="literal">MyISAM</code> は、クエリー結果を生成するために完全なテーブル行にアクセスする必要がない場合、MRR を使用しません。 これは、(<a class="link" href="glossary.html#glos_covering_index" title="カバリングインデックス">カバーするインデックス</a>経由で) インデックスタプル内の情報に完全に基づいて結果を生成できる場合であり、MRR にメリットはありません。 
        </p><p>
          2 つの <code class="literal">optimizer_switch</code> システム変数フラグは、MRR 最適化の使用へのインタフェースを提供します。 <code class="literal">mrr</code> フラグは MRR を有効にするかどうかを制御します。 <code class="literal">mrr</code> が有効 (<code class="literal">on</code>) の場合、<code class="literal">mrr_cost_based</code> フラグは、オプティマイザが MRR (<code class="literal">on</code>) を使用するかどうか、または可能な場合は MRR (<code class="literal">off</code>) を使用するかどうかを制御します。 デフォルトでは、<code class="literal">mrr</code> は <code class="literal">on</code> で、<code class="literal">mrr_cost_based</code> は <code class="literal">on</code> です。 <a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2 切り替え可能な最適化">セクション8.9.2「切り替え可能な最適化」</a>を参照してください。 
        </p><p>
          MRR では、ストレージエンジンが、そのバッファーに割り当てることができるメモリーの量のガイドラインとして、<code class="literal">read_rnd_buffer_size</code> システム変数の値を使用します。 エンジンは最大 <code class="literal">read_rnd_buffer_size</code> バイトを使用して、単一のパスで処理する範囲の数を判断します。 
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="bnl-bka-optimization"></a>8.2.1.12 Block Nested Loop 結合と Batched Key Access 結合</h4></div></div></div><a class="indexterm" name="idm45661480588752"></a><a class="indexterm" name="idm45661480586640"></a><a class="indexterm" name="idm45661480584720"></a><a class="indexterm" name="idm45661480582576"></a><p>
          MySQL では、結合テーブルと結合バッファの両方へのインデックスアクセスを使用するバッチキーアクセス (BKA) 結合アルゴリズムを使用できます。 BKA アルゴリズムでは、内部結合、外部結合、およびネストされた外部結合を含む準結合操作がサポートされています。 BKA には、テーブルスキャンの効率性の向上による結合パフォーマンスの改善というメリットもあります。 また、以前は内部結合にのみ使用されていた Block Nested-Loop (BNL) 結合アルゴリズムが拡張され、ネストされた外部結合を含む外部結合および準結合操作に使用できます。 
        </p><p>
          次のセクションでは、元の BNL アルゴリズムの拡張の基礎にある結合バッファー管理、拡張 BNL アルゴリズム、および BKA アルゴリズムについて説明します。 準結合戦略の詳細は、<a class="xref" href="optimization.html#semijoins" title="8.2.2.1 準結合変換による IN および EXISTS サブクエリー述語の最適化">セクション8.2.2.1「準結合変換による IN および EXISTS サブクエリー述語の最適化」</a> を参照してください 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#join-buffer-management" title="Block Nested Loop および Batched Key Access アルゴリズムの結合バッファー管理">Block Nested Loop および Batched Key Access アルゴリズムの結合バッファー管理</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#bnl-optimization" title="外部結合および準結合のブロックネストループアルゴリズム">外部結合および準結合のブロックネストループアルゴリズム</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#bka-optimization" title="Batched Key Access 結合">Batched Key Access 結合</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#bnl-bka-optimizer-hints" title="ブロックネストループおよびバッチキーアクセスアルゴリズムのオプティマイザヒント">ブロックネストループおよびバッチキーアクセスアルゴリズムのオプティマイザヒント</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="join-buffer-management"></a>Block Nested Loop および Batched Key Access アルゴリズムの結合バッファー管理</h5></div></div></div><p>
            MySQL では、結合バッファを使用して、内部テーブルへのインデックスアクセスなしで内部結合のみでなく、サブクエリーのフラット化後に表示される外部結合および準結合も実行できます。 さらに、内部テーブルへのインデックスアクセスがある場合、結合バッファーを効率的に使用できます。 
          </p><p>
            結合バッファー管理コードは、目的の行カラムの値を格納する際に、結合バッファー領域を少し効率的に利用します。行カラムの値が <code class="literal">NULL</code> の場合に行カラムにバッファー内の追加バイトを割り当てず、<code class="literal">VARCHAR</code> 型の値には最小数のバイトが割り当てられます。
          </p><p>
            コードでは、標準と増分の 2 つの種類のバッファーをサポートします。 結合テーブル <code class="literal">t1</code> と <code class="literal">t2</code> に結合バッファー <code class="literal">B1</code> が使用されており、この操作の結果が結合バッファー <code class="literal">B2</code> を使用して、テーブル <code class="literal">t3</code> と結合されるとします。 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                標準結合バッファーには、各結合オペランドからのカラムが格納されます。 <code class="literal">B2</code> が通常の結合バッファの場合、<code class="literal">B2</code> に配置される各行 <em class="replaceable"><code>r</code></em> は、<code class="literal">B1</code> の行 <em class="replaceable"><code>r1</code></em> のカラムと、テーブル <code class="literal">t3</code> の一致する行 <em class="replaceable"><code>r2</code></em> の興味深いカラムで構成されます。 
              </p></li><li class="listitem"><p>
                増分結合バッファーには、2 つめの結合オペランドによって生成されるテーブルの行からのカラムのみが格納されます。 つまり、それは 1 つめのオペランドバッファーからの行の増分になります。 <code class="literal">B2</code> が増分結合バッファーである場合、それには、<code class="literal">B1</code> からの行 <em class="replaceable"><code>r1</code></em> へのリンクとともに、行 <em class="replaceable"><code>r2</code></em> の対象のカラムが格納されます。 
              </p></li></ul></div><p>
            増分結合バッファーは常に、前の結合操作からの結合バッファーに相対的な増分になるため、最初の結合操作からのバッファーは常に標準バッファーになります。 直前の例では、テーブル <code class="literal">t1</code> および <code class="literal">t2</code> を結合するために使用されるバッファー <code class="literal">B1</code> は標準バッファーである必要があります。 
          </p><p>
            結合操作に使用される増分バッファーの各行には、結合されるテーブルからの行の対象カラムのみが格納されます。 これらのカラムには、最初の結合オペランドによって生成されたテーブルからの一致する行の対象カラムへの参照が追加されます。 増分バッファー内の複数の行から、カラムが前の結合バッファーに格納されている同じ行 <em class="replaceable"><code>r</code></em> を参照できます。ただし、これらのすべての行が行 <em class="replaceable"><code>r</code></em> に一致する場合にかぎります。 
          </p><p>
            増分バッファーにより、前の結合操作で使用されたバッファーからのカラムのコピーの頻度を少なくできます。 これにより、一般に、最初の結合オペランドによって生成された行が 2 つめの結合オペランドによって生成される複数の行に一致する可能性があるため、バッファー領域が節約されます。 最初のオペランドからの行のコピーを何回も行う必要がありません。 さらに、増分バッファーにより、コピー時間の短縮のため、処理時間も節約されます。 
          </p><p>
            MySQL 8.0 では、<code class="literal">optimizer_switch</code> システム変数の <code class="literal">block_nested_loop</code> フラグは次のように機能します:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                MySQL 8.0.20 より前は、オプティマイザが Block Nested Loop 結合アルゴリズムを使用する方法を制御していました。
              </p></li><li class="listitem"><p>
                MySQL 8.0.18 以降では、ハッシュ結合の使用も制御します (<a class="xref" href="optimization.html#hash-joins" title="8.2.1.4 ハッシュ結合の最適化">セクション8.2.1.4「ハッシュ結合の最適化」</a> を参照)。
              </p></li><li class="listitem"><p>
                MySQL 8.0.20 以降、このフラグはハッシュ結合のみを制御し、ブロックネストループアルゴリズムはサポートされなくなりました。
              </p></li></ul></div><p>
            <code class="literal">batched_key_access</code> フラグは、オプティマイザがバッチキーアクセス結合アルゴリズムを使用する方法を制御します。
          </p><p>
            デフォルトで、<code class="literal">block_nested_loop</code> は <code class="literal">on</code> で <code class="literal">batched_key_access</code> は <code class="literal">off</code> です。 <a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2 切り替え可能な最適化">セクション8.9.2「切り替え可能な最適化」</a>を参照してください。 オプティマイザヒントも適用できます。<a class="xref" href="optimization.html#bnl-bka-optimizer-hints" title="ブロックネストループおよびバッチキーアクセスアルゴリズムのオプティマイザヒント">ブロックネストループおよびバッチキーアクセスアルゴリズムのオプティマイザヒント</a> を参照してください。 
          </p><p>
            準結合戦略の詳細は、<a class="xref" href="optimization.html#semijoins" title="8.2.2.1 準結合変換による IN および EXISTS サブクエリー述語の最適化">セクション8.2.2.1「準結合変換による IN および EXISTS サブクエリー述語の最適化」</a> を参照してください
          </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="bnl-optimization"></a>外部結合および準結合のブロックネストループアルゴリズム</h5></div></div></div><a class="indexterm" name="idm45661480530144"></a><a class="indexterm" name="idm45661480528032"></a><p>
            MySQL BNL アルゴリズムの元の実装は、外部結合および準結合操作をサポートするように拡張されました (後でハッシュ結合アルゴリズムに置き換えられました。<a class="xref" href="optimization.html#hash-joins" title="8.2.1.4 ハッシュ結合の最適化">セクション8.2.1.4「ハッシュ結合の最適化」</a> を参照)。
          </p><p>
            結合バッファーを使用して、これらの操作が実行されると、バッファーに入れられた各行に一致フラグが付加されます。
          </p><p>
            結合バッファーを使用して、外部結合操作が実行された場合、2 つめのオペランドによって生成されたテーブルの各行で、結合バッファー内の各行に対する一致がチェックされます。 一致が見つかると、新しく拡張された行が形成され (元の行に 2 つめのオペランドからのカラムを追加)、残りの結合操作によるさらなる拡張のために送られます。 さらに、バッファー内の一致した行の一致フラグが有効にされます。 結合されるテーブル内のすべての行が調査されたあとに、結合バッファーがスキャンされます。 有効にされた一致フラグがないバッファーからの各行は、<code class="literal">NULL</code> の補完 (2 つめのオペランドの各カラムの <code class="literal">NULL</code> 値) によって拡張され、残りの結合操作によるさらなる拡張のために送られます。 
          </p><p>
            MySQL 8.0 では、<code class="literal">optimizer_switch</code> システム変数の <code class="literal">block_nested_loop</code> フラグは次のように機能します:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                MySQL 8.0.20 より前は、オプティマイザが Block Nested Loop 結合アルゴリズムを使用する方法を制御していました。
              </p></li><li class="listitem"><p>
                MySQL 8.0.18 以降では、ハッシュ結合の使用も制御します (<a class="xref" href="optimization.html#hash-joins" title="8.2.1.4 ハッシュ結合の最適化">セクション8.2.1.4「ハッシュ結合の最適化」</a> を参照)。
              </p></li><li class="listitem"><p>
                MySQL 8.0.20 以降、このフラグはハッシュ結合のみを制御し、ブロックネストループアルゴリズムはサポートされなくなりました。
              </p></li></ul></div><p>
            詳しくは<a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2 切り替え可能な最適化">セクション8.9.2「切り替え可能な最適化」</a>,をご覧ください。 オプティマイザヒントも適用できます。<a class="xref" href="optimization.html#bnl-bka-optimizer-hints" title="ブロックネストループおよびバッチキーアクセスアルゴリズムのオプティマイザヒント">ブロックネストループおよびバッチキーアクセスアルゴリズムのオプティマイザヒント</a> を参照してください。 
          </p><p>
            <code class="literal">EXPLAIN</code> 出力で、<code class="literal">Extra</code> 値に <code class="literal">Using join buffer (Block Nested Loop)</code> が含まれ、<code class="literal">type</code> 値が <code class="literal">ALL</code>、<code class="literal">index</code>、または <code class="literal">range</code> の場合に、テーブルへの BNL の使用が示されます。
          </p><p>
            準結合戦略の詳細は、<a class="xref" href="optimization.html#semijoins" title="8.2.2.1 準結合変換による IN および EXISTS サブクエリー述語の最適化">セクション8.2.2.1「準結合変換による IN および EXISTS サブクエリー述語の最適化」</a> を参照してください
          </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="bka-optimization"></a>Batched Key Access 結合</h5></div></div></div><a class="indexterm" name="idm45661480501840"></a><a class="indexterm" name="idm45661480499728"></a><p>
            MySQL  では Batched Key Access (BKA) 結合アルゴリズムと呼ばれるテーブルの結合の方法を実装しています。 BKA は、2 つめの結合オペランドによって生成されるテーブルへのインデックスアクセスがある場合に適用できます。 BNL 結合アルゴリズムと同様、BKA 結合アルゴリズムでは、結合バッファーを使用して、結合操作の最初のオペランドによって生成された行の対象カラムを累積します。 次に、BKA アルゴリズムは、バッファー内のすべての行に対し、結合されるテーブルにアクセスするためのキーを構築し、これらのキーをインデックスルックアップのために、データベースエンジンに一括で送信します。 キーは、Multi-Range Read (MRR) インタフェース経由で、エンジンに送信されます (<a class="xref" href="optimization.html#mrr-optimization" title="8.2.1.11 Multi-Range Read の最適化">セクション8.2.1.11「Multi-Range Read の最適化」</a>を参照してください)。 キーの送信後、MRR エンジン関数は最適な方法で、インデックス内のルックアップを実行し、これらのキーによって見つかった結合されたテーブルの行をフェッチし、BKA 結合アルゴリズムに一致する行の提供を開始します。 一致する各行は結合バッファー内の行への参照が組み合わされます。 
          </p><p>
            BKA が使用される場合、<code class="literal">join_buffer_size</code> の値によって、ストレージエンジンへの個々のリクエストでのキーのバッチの大きさが定義されます。 バッファが大きいほど、結合操作の右側のテーブルへの順次アクセスが多くなり、パフォーマンスが大幅に向上する可能性があります。 
          </p><p>
            BKA を使用するには、<code class="literal">optimizer_switch</code> システム変数の <code class="literal">batched_key_access</code> フラグが <code class="literal">on</code> に設定されている必要があります。 BKA では MRR を使用するため、<code class="literal">mrr</code> フラグも <code class="literal">on</code> に設定されている必要があります。 現在、MRR のコスト見積もりはきわめて悲観的です。 したがって、BKA を使用するには、<code class="literal">mrr_cost_based</code> を <code class="literal">off</code> にする必要もあります。 次の設定によって、BKA が有効になります。 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';</code></strong>
</pre><p>
            MRR 関数が実行される 2 つのシナリオがあります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                最初のシナリオは、<code class="literal">InnoDB</code> や <code class="literal">MyISAM</code> などの従来のディスクベースのストレージエンジンで使用されます。 これらのエンジンでは通常、結合バッファーからのすべての行のキーが一度に MRR インタフェースに送信されます。 エンジン固有の MRR 関数は、送信されたキーのインデックスルックアップを実行し、それらから行 ID (または主キー) を取得して、BKA アルゴリズムからのリクエストによって、これらの選択されたすべての行 ID の行を 1 つずつフェッチします。 各行は、結合バッファー内の一致した行へのアクセスを可能にするアソシエーション参照とともに返されます。 行は MRR 関数によって最適な方法でフェッチされます。それらは、行 ID (主キー) 順でフェッチされます。 これにより、読み取りがランダムな順序ではなく、ディスク順になるため、パフォーマンスが向上します。 
              </p></li><li class="listitem"><p>
                2 つめのシナリオは、<code class="literal">NDB</code> などのリモートストレージエンジンで使用されます。 結合バッファーからの行の一部のキーのパッケージが、それらのアソシエーションとともに、MySQL Server (SQL ノード) によって、MySQL Cluster データノードに送信されます。 返信で、SQL ノードは、対応するアソシエーションが組み合わされた一致する行のパッケージ (または複数のパッケージ) を受け取ります。 BKA 結合アルゴリズムでは、これらの行を取得し、新しく結合された行を構築します。 次に、新しいキーセットがデータノードに送信され、返されたパッケージからの行が新しい結合された行の構築に使用されます。 このプロセスは、結合バッファーからの最後のキーがデータノードに送信され、SQL ノードがこれらのキーに一致するすべての行を受け取り、結合するまで、続行されます。 これにより、SQL ノードによってデータノードに送信されるキーを含むパッケージが少なくなることは、結合操作を実行するために、それとデータノード間のラウンドトリップが少なくなることを意味するため、パフォーマンスが向上します。 
              </p></li></ul></div><p>
            最初のシナリオでは、結合バッファーの一部がインデックスルックアップによって選択され、MRR 関数へのパラメータとして渡される行 ID (主キー) を格納するために予約されます。
          </p><p>
            結合バッファーからの行に対して構築されるキーを格納するための特別なバッファーはありません。 代わりに、バッファー内の次の行のキーを構築する関数が、MRR 関数へのパラメータとして渡されます。 
          </p><p>
            <code class="literal">EXPLAIN</code> 出力で、<code class="literal">Extra</code> 値に <code class="literal">Using join buffer (Batched Key Access)</code> が含まれ、<code class="literal">type</code> 値が <code class="literal">ref</code> または <code class="literal">eq_ref</code> の場合に、テーブルへの BKA の使用が示されます。
          </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="bnl-bka-optimizer-hints"></a>ブロックネストループおよびバッチキーアクセスアルゴリズムのオプティマイザヒント</h5></div></div></div><p>
            BNL および BKA アルゴリズムのセッション全体でのオプティマイザの使用を制御するために <code class="literal">optimizer_switch</code> システム変数を使用することに加えて、MySQL はオプティマイザヒントをサポートして、ステートメントごとにオプティマイザに影響を与えます。 <a class="xref" href="optimization.html#optimizer-hints" title="8.9.3 オプティマイザヒント">セクション8.9.3「オプティマイザヒント」</a>を参照してください。 
          </p><p>
            BNL または BKA ヒントを使用して外部結合の内部テーブルの結合バッファリングを有効にするには、外部結合のすべての内部テーブルに対して結合バッファリングを有効にする必要があります。
          </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="condition-filtering"></a>8.2.1.13 条件フィルタ</h4></div></div></div><p>
          結合処理では、接頭辞行は、結合のあるテーブルから次のテーブルに渡される行です。 通常、オプティマイザは、行の組合せの数が急速に増加しないように、接頭辞数が少ないテーブルを結合順序の早い段階に配置しようとします。 オプティマイザがあるテーブルから選択されて次のテーブルに渡される行の条件に関する情報を使用できる範囲では、行の見積りをより正確に計算し、最適な実行計画を選択できます。 
        </p><p>
          条件フィルタリングを使用しない場合、テーブルの接頭辞行数は、オプティマイザが選択したアクセス方法に応じて、<code class="literal">WHERE</code> 句によって選択された推定行数に基づきます。 条件フィルタリングを使用すると、オプティマイザは、アクセス方法で考慮されない他の関連条件を <code class="literal">WHERE</code> 句で使用できるため、接頭辞の行数の見積りが改善されます。 たとえば、結合で現在のテーブルから行を選択するために使用できるインデックスベースのアクセス方法がある場合でも、次のテーブルに渡される行を修飾するための見積りをフィルタ (さらに制限) できる、<code class="literal">WHERE</code> 句内のテーブルに対する追加の条件が存在する可能性があります。 
        </p><p>
          条件は、次の場合にのみフィルタリング推定に寄与します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              現在のテーブルを参照します。
            </p></li><li class="listitem"><p>
              これは、定数値または結合順序内の以前のテーブルの値に依存します。
            </p></li><li class="listitem"><p>
              アクセス方法ではまだ考慮されていません。
            </p></li></ul></div><p>
          <code class="literal">EXPLAIN</code> 出力では、<code class="literal">rows</code> カラムに選択したアクセス方法の行の見積りが示され、<code class="literal">filtered</code> カラムに条件フィルタの効果が反映されます。<code class="literal">filtered</code> 値はパーセンテージで表されます。 最大値は 100 で、これは行のフィルタリングが行われなかったことを意味します。 100 から減少する値は、フィルタリングの量が増加していることを示します。 
        </p><p>
          接頭辞の行数 (結合で現在のテーブルから次のテーブルに渡されると推定される行数) は、<code class="literal">rows</code> 値と <code class="literal">filtered</code> 値の積です。 つまり、接頭辞の行数は推定された行数で、推定されたフィルタリング効果によって削減されます。 たとえば、<code class="literal">rows</code> が 1000 で、<code class="literal">filtered</code> が 20% の場合、条件フィルタリングによって 1000 の推定行数が接頭辞の行数 1000× 20% = 1000× .2 = 200 に削減されます。 
        </p><p>
          次のクエリーを考慮してください。
        </p><pre class="programlisting">SELECT *
  FROM employee JOIN department ON employee.dept_no = department.dept_no
  WHERE employee.first_name = 'John'
  AND employee.hire_date BETWEEN '2018-01-01' AND '2018-06-01';
</pre><p>
          データセットに次の特性があるとします:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">employee</code> テーブルには 1024 行あります。
            </p></li><li class="listitem"><p>
              <code class="literal">department</code> テーブルには 12 行あります。
            </p></li><li class="listitem"><p>
              どちらのテーブルにも、<code class="literal">dept_no</code> のインデックスがあります。
            </p></li><li class="listitem"><p>
              <code class="literal">employee</code> テーブルには、<code class="literal">first_name</code> のインデックスがあります。
            </p></li><li class="listitem"><p>
              <code class="literal">employee.first_name</code> では、8 行が次の条件を満たします:
            </p><pre class="programlisting">employee.first_name = 'John'
</pre></li><li class="listitem"><p>
              150 行が <code class="literal">employee.hire_date</code> で次の条件を満たしています:
            </p><pre class="programlisting">employee.hire_date BETWEEN '2018-01-01' AND '2018-06-01'
</pre></li><li class="listitem"><p>
              1 行が両方の条件を満たしています:
            </p><pre class="programlisting">employee.first_name = 'John'
AND employee.hire_date BETWEEN '2018-01-01' AND '2018-06-01'
</pre></li></ul></div><p>
          条件フィルタリングを使用しない場合、<code class="literal">EXPLAIN</code> は次のような出力を生成します:
        </p><pre class="programlisting">+----+------------+--------+------------------+---------+---------+------+----------+
| id | table      | type   | possible_keys    | key     | ref     | rows | filtered |
+----+------------+--------+------------------+---------+---------+------+----------+
| 1  | employee   | ref    | name,h_date,dept | name    | const   | 8    | 100.00   |
| 1  | department | eq_ref | PRIMARY          | PRIMARY | dept_no | 1    | 100.00   |
+----+------------+--------+------------------+---------+---------+------+----------+
</pre><p>
          <code class="literal">employee</code> の場合、<code class="literal">name</code> インデックスのアクセス方法では、<code class="literal">'John'</code>の名前と一致する 8 行が取得されます。 フィルタリングは行われない (<code class="literal">filtered</code> は 100%) ため、すべての行が次のテーブルの接頭辞行になります: 接頭辞の行数は、<code class="literal">rows</code>× <code class="literal">filtered</code> = 8× 100% = 8 です。 
        </p><p>
          条件フィルタリングを使用すると、オプティマイザでは、アクセス方法で考慮されない <code class="literal">WHERE</code> 句の条件も考慮されます。 この場合、オプティマイザはヒューリスティックを使用して、<code class="literal">employee.hire_date</code> での <code class="literal">BETWEEN</code> 条件に対する 16.31 % のフィルタリング効果を見積もります。 その結果、<code class="literal">EXPLAIN</code> では次のような出力が生成されます: 
        </p><pre class="programlisting">+----+------------+--------+------------------+---------+---------+------+----------+
| id | table      | type   | possible_keys    | key     | ref     | rows | filtered |
+----+------------+--------+------------------+---------+---------+------+----------+
| 1  | employee   | ref    | name,h_date,dept | name    | const   | 8    | 16.31    |
| 1  | department | eq_ref | PRIMARY          | PRIMARY | dept_no | 1    | 100.00   |
+----+------------+--------+------------------+---------+---------+------+----------+
</pre><p>
          接頭辞の行数は、実際のデータセットをより厳密に反映した <code class="literal">rows</code>× <code class="literal">filtered</code> = 8× 16.31 % = 1.3,になりました。
        </p><p>
          通常、オプティマイザでは、行を渡す次のテーブルがないため、最後に結合されたテーブルの条件フィルタリング効果 (接頭辞行数の削減) は計算されません。 <code class="literal">EXPLAIN</code> で例外が発生しました: 詳細情報を提供するために、最後の結合テーブルを含むすべての結合テーブルのフィルタリング効果が計算されます。 
        </p><p>
          オプティマイザが追加のフィルタリング条件を考慮するかどうかを制御するには、<code class="literal">optimizer_switch</code> システム変数の <code class="literal">condition_fanout_filter</code> フラグを使用します (<a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2 切り替え可能な最適化">セクション8.9.2「切り替え可能な最適化」</a> を参照)。 このフラグはデフォルトで有効になっていますが、条件フィルタリングを抑制するために無効にできます (たとえば、特定のクエリーでパフォーマンスが向上することが判明した場合)。 
        </p><p>
          オプティマイザが条件フィルタリングの影響を過度に見積もる場合、条件フィルタリングが使用されていない場合よりもパフォーマンスが低下する可能性があります。 このような場合は、次の方法が役立ちます: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              カラムがインデックス付けされていない場合は、オプティマイザがカラム値の分散に関する情報を取得し、その行の見積りを改善できるようにインデックス付けします。
            </p></li><li class="listitem"><p>
              同様に、使用可能なカラムヒストグラム情報がない場合は、ヒストグラムを生成します (<a class="xref" href="optimization.html#optimizer-statistics" title="8.9.6 オプティマイザ統計">セクション8.9.6「オプティマイザ統計」</a> を参照)。
            </p></li><li class="listitem"><p>
              結合順序を変更します。 これを実現する方法には、結合順序オプティマイザヒント (<a class="xref" href="optimization.html#optimizer-hints" title="8.9.3 オプティマイザヒント">セクション8.9.3「オプティマイザヒント」</a> を参照)、<code class="literal">SELECT</code> 直後の <code class="literal">STRAIGHT_JOIN</code> および <code class="literal">STRAIGHT_JOIN</code> 結合演算子が含まれます。 
            </p></li><li class="listitem"><p>
              セッションの条件フィルタリングを無効にします:
            </p><pre class="programlisting">SET optimizer_switch = 'condition_fanout_filter=off';
</pre><p>
              または、特定のクエリーに対して、オプティマイザヒントを使用します:
            </p><pre class="programlisting">SELECT /*+ SET_VAR(optimizer_switch = 'condition_fanout_filter=off') */ ...
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="constant-folding-optimization"></a>8.2.1.14 定数 - フォールディングの最適化</h4></div></div></div><p>
          定数値が範囲外であるか、カラムタイプに関して間違ったタイプである定数とカラム値の比較は、クエリーの最適化中に、実行中ではなく行単位で処理されるようになりました。 この方法で処理できる比較は、<code class="literal">&gt;</code>, <code class="literal">&gt;=</code>, <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>, <code class="literal">&lt;&gt;</code>/<code class="literal">!=</code>、<code class="literal">=</code> および <code class="literal">&lt;=&gt;</code> です。 
        </p><p>
          次のステートメントで作成されたテーブルについて考えてみます:
        </p><pre class="programlisting">CREATE TABLE t (c TINYINT UNSIGNED NOT NULL);
</pre><p>
          クエリー <code class="literal">SELECT * FROM t WHERE c &lt; 256</code> の <code class="literal">WHERE</code> 条件に、<code class="literal">TINYINT UNSIGNED</code> カラムの範囲外の整数定数 256 が含まれています。 これまでは、両方のオペランドを大きい型として扱うことで処理されていましたが、<code class="literal">c</code> に許可されている値が定数より小さいため、かわりに <code class="literal">WHERE</code> 式を <code class="literal">WHERE 1</code> として折りたたんで、クエリーを <code class="literal">SELECT * FROM t WHERE 1</code> としてリライトできます。 
        </p><p>
          これにより、オプティマイザは <code class="literal">WHERE</code> 式を完全に削除できます。 カラム <code class="literal">c</code> が NULL 値可能だった (つまり、<code class="literal">TINYINT UNSIGNED</code> としてのみ定義されていた) 場合、クエリーは次のようにリライトされます: 
        </p><pre class="programlisting">SELECT * FROM t WHERE ti IS NOT NULL
</pre><p>
          折りたたみは、サポートされている MySQL カラムタイプと比較して、次のように定数に対して実行されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>整数カラムタイプ. </b>
                整数型は、次に説明するように、次の型の定数と比較されます:
              </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>整数値. </b>
                    定数がカラムタイプの範囲外の場合、すでに示すように、比較は <code class="literal">1</code> または <code class="literal">IS NOT NULL</code> に折りたたまれます。
                  </p><p>
                  定数が範囲境界の場合、比較は <code class="literal">=</code> に折りたたまれます。 次に例を示します (すでに定義されているのと同じテーブルを使用): 
                </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM t WHERE c &gt;= 255;</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 5
     filtered: 20.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select `test`.`t`.`ti` AS `ti` from `test`.`t` where (`test`.`t`.`ti` = 255)
1 row in set (0.00 sec)
</pre></li><li class="listitem"><p><b>浮動小数点値または固定小数点値. </b>
                    定数が小数型 (<code class="literal">DECIMAL</code>, <code class="literal">REAL</code>, <code class="literal">DOUBLE</code>、<code class="literal">FLOAT</code> など) のいずれかで、小数部がゼロ以外の場合は等しくできません。それに応じて折りたたみます。 その他の比較の場合は、符号に従って整数値に切り上げまたは切り下げてから、整数比較ですでに説明されている範囲チェックおよびハンドルを実行します。 
                  </p><p>
                  小さすぎて <code class="literal">DECIMAL</code> として表現できない <code class="literal">REAL</code> 値は、記号に応じて .01 または -.01 に丸められ、<code class="literal">DECIMAL</code> として処理されます。
                </p></li><li class="listitem"><p><b>文字列型. </b>
                    文字列値を整数型として解釈し、整数値間の比較を処理します。 これが失敗した場合は、値を <code class="literal">REAL</code> として処理してみてください。 
                  </p></li></ul></div></li><li class="listitem"><p><b>DECIMAL または REAL カラム. </b>
                ここで説明するように、小数型は次の型の定数と比較されます:
              </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>整数値. </b>
                    カラム値の整数部分に対して範囲チェックを実行します。 折りたたみ結果がない場合は、定数をカラム値と同じ小数点以下の桁数で <code class="literal">DECIMAL</code> に変換し、<code class="literal">DECIMAL</code> として確認します (次を参照)。 
                  </p></li><li class="listitem"><p><b>DECIMAL または REAL 値. </b>
                    オーバーフローをチェックします (つまり、定数の整数部分に、カラムの小数型に許可されている桁数より多い数値があるかどうか)。 その場合は折りたたみます。 
                  </p><p>
                  定数の小数点以下の桁数がカラムの型より多い場合は、定数を切り捨てます。 比較演算子が <code class="literal">=</code> または <code class="literal">&lt;&gt;</code> の場合は、折りたたみます。 演算子が <code class="literal">&gt;=</code> または <code class="literal">&lt;=</code> の場合は、切捨てのために演算子を調整します。 たとえば、カラムタイプが <code class="literal">DECIMAL(3,1)</code> の場合、<code class="literal">SELECT * FROM t WHERE f &gt;= 10.13</code> は <code class="literal">SELECT * FROM t WHERE f &gt; 10.1</code> になります。 
                </p><p>
                  定数の小数点以下の桁数がカラムの型より少ない場合は、同じ桁数の定数に変換します。 <code class="literal">REAL</code> 値のアンダーフロー (小数が少なすぎて表すことができない) の場合は、定数を小数 0 に変換します。 
                </p></li><li class="listitem"><p><b>文字列値. </b>
                    値を整数型として解釈できる場合は、そのように処理します。 それ以外の場合は、<code class="literal">REAL</code> として処理してください。 
                  </p></li></ul></div></li><li class="listitem"><p><b>FLOAT または DOUBLE カラム. </b>
                定数と比較した <code class="literal">FLOAT(<em class="replaceable"><code>m</code></em>,<em class="replaceable"><code>n</code></em>)</code> または <code class="literal">DOUBLE(<em class="replaceable"><code>m</code></em>,<em class="replaceable"><code>n</code></em>)</code> の値は、次のように処理されます:
              </p><p>
              値がカラムの範囲をオーバーフローする場合は、折りたたみます。
            </p><p>
              値の小数点以下が <em class="replaceable"><code>n</code></em> を超える場合は、折りたたみ時に切り捨てて補正します。 <code class="literal">=</code> と <code class="literal">&lt;&gt;</code> の比較の場合は、前述のように <code class="literal">TRUE</code>、<code class="literal">FALSE</code> または <code class="literal">IS [NOT] NULL</code> に折りたたみます。他の演算子の場合は、演算子を調整します。 
            </p><p>
              値が <code class="literal">m</code> 整数より大きい場合は折りたたみます。
            </p></li></ul></div><p><b>制限. </b>
            この最適化は、次の場合には使用できません:
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              <code class="literal">BETWEEN</code> または <code class="literal">IN</code> を使用した比較。
            </p></li><li class="listitem"><p>
              日付型または時間型を使用する <code class="literal">BIT</code> のカラムまたはカラム。
            </p></li><li class="listitem"><p>
              プリペアドステートメントの準備フェーズ中。ただし、プリペアドステートメントが実際に実行されるときに最適化フェーズ中に適用できます。 これは、ステートメントの準備中に定数の値が不明であるためです。 
            </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="is-null-optimization"></a>8.2.1.15 IS NULL の最適化</h4></div></div></div><a class="indexterm" name="idm45661480311344"></a><a class="indexterm" name="idm45661480310032"></a><p>
          MySQL は、<em class="replaceable"><code>col_name</code></em> <code class="literal">=</code> <em class="replaceable"><code>constant_value</code></em> に対して使用できる同じ最適化を <em class="replaceable"><code>col_name</code></em> <code class="literal">IS NULL</code> に対しても実行できます。 たとえば、MySQL は、インデックスと範囲を使用して、<code class="literal">IS NULL</code> を含む <code class="literal">NULL</code> を検索できます。 
        </p><p>
          例:
        </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> IS NULL;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> &lt;=&gt; NULL;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_col</code></em>=<em class="replaceable"><code>const1</code></em> OR <em class="replaceable"><code>key_col</code></em>=<em class="replaceable"><code>const2</code></em> OR <em class="replaceable"><code>key_col</code></em> IS NULL;
</pre><p>
          <code class="literal">WHERE</code> 句に、<code class="literal">NOT NULL</code> として宣言されているカラムの <em class="replaceable"><code>col_name</code></em> <code class="literal">IS NULL</code> 条件が含まれている場合、その式は最適化により除去されます。 この最適化は、カラムが <code class="literal">NULL</code> を生成する可能性がある場合 (たとえば、<code class="literal">LEFT JOIN</code> の右側のテーブルから生成される場合) には発生しません。 
        </p><p>
          MySQL は、解決済みのサブクエリーで一般的な形式である <code class="literal"><em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>expr</code></em> OR <em class="replaceable"><code>col_name</code></em> IS NULL</code> の組み合わせを最適化することもできます。 この最適化が使用された場合、<code class="literal">EXPLAIN</code> で <code class="literal">ref_or_null</code> と示されます。 
        </p><p>
          この最適化は、任意のキーパートに対して 1 つの <code class="literal">IS NULL</code> を処理できます。
        </p><p>
          テーブル <code class="literal">t2</code> のカラム <code class="literal">a</code> および <code class="literal">b</code> にインデックスがあるとして、最適化されるクエリーのいくつかの例:
        </p><pre class="programlisting">SELECT * FROM t1 WHERE t1.a=<em class="replaceable"><code>expr</code></em> OR t1.a IS NULL;

SELECT * FROM t1, t2 WHERE t1.a=t2.a OR t2.a IS NULL;

SELECT * FROM t1, t2
  WHERE (t1.a=t2.a OR t2.a IS NULL) AND t2.b=t1.b;

SELECT * FROM t1, t2
  WHERE t1.a=t2.a AND (t2.b=t1.b OR t2.b IS NULL);

SELECT * FROM t1, t2
  WHERE (t1.a=t2.a AND t2.a IS NULL AND ...)
  OR (t1.a=t2.a AND t2.a IS NULL AND ...);
</pre><p>
          <code class="literal">ref_or_null</code> はまずリファレンスキーの読み取りを行い、次に <code class="literal">NULL</code> キー値のある行の個別の検索を実行します。
        </p><p>
          最適化では、単一の <code class="literal">IS NULL</code> レベルのみを処理できます。 次のクエリーでは、MySQL は式 <code class="literal">(t1.a=t2.a AND t2.a IS NULL)</code> に対してのみキールックアップを使用し、<code class="literal">b</code> に対してはキーパートを使用できません。 
        </p><pre class="programlisting">SELECT * FROM t1, t2
  WHERE (t1.a=t2.a AND t2.a IS NULL)
  OR (t1.b=t2.b AND t2.b IS NULL);
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="order-by-optimization"></a>8.2.1.16 ORDER BY の最適化</h4></div></div></div><a class="indexterm" name="idm45661480273728"></a><a class="indexterm" name="idm45661480272272"></a><p>
          このセクションでは、MySQL が <code class="literal">ORDER BY</code> 句を満たすためにインデックスを使用できるタイミング、インデックスを使用できない場合に使用される <code class="literal">filesort</code> 操作、および <code class="literal">ORDER BY</code> に関するオプティマイザから使用可能な実行計画情報について説明します。
        </p><p>
          <a class="xref" href="optimization.html#limit-optimization" title="8.2.1.19 LIMIT クエリーの最適化">セクション8.2.1.19「LIMIT クエリーの最適化」</a> で説明されているように、<code class="literal">LIMIT</code> を使用する場合と使用しない場合で <code class="literal">ORDER BY</code> が異なる順序で行を返すことがあります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#order-by-index-use" title="ORDER BY を満たすためのインデックスの使用">ORDER BY を満たすためのインデックスの使用</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#order-by-filesort" title="filesort を使用して ORDER BY を満たす">filesort を使用して ORDER BY を満たす</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#order-by-optimizer-control" title="ORDER BY 最適化への影響">ORDER BY 最適化への影響</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#order-by-diagnostic-information" title="ORDER BY 実行計画情報使用可能">ORDER BY 実行計画情報使用可能</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="order-by-index-use"></a>ORDER BY を満たすためのインデックスの使用</h5></div></div></div><p>
            場合によっては、MySQL でインデックスを使用して <code class="literal">ORDER BY</code> 句を満たし、<code class="literal">filesort</code> 操作の実行に伴う余分なソートを回避できます。
          </p><p>
            インデックスのすべての未使用部分と追加の <code class="literal">ORDER BY</code> カラムが <code class="literal">WHERE</code> 句の定数であるかぎり、<code class="literal">ORDER BY</code> がインデックスと完全に一致しない場合でもインデックスを使用できます。 クエリーによってアクセスされるすべてのカラムがインデックスに含まれていない場合、インデックスアクセスが他のアクセス方法よりも安い場合にのみインデックスが使用されます。 
          </p><p>
            <code class="literal">(<em class="replaceable"><code>key_part1</code></em>, <em class="replaceable"><code>key_part2</code></em>)</code> にインデックスがあると仮定すると、次のクエリーではインデックスを使用して <code class="literal">ORDER BY</code> 部分を解決できます。 オプティマイザが実際にこれを行うかどうかは、インデックスに含まれていないカラムも読み取る必要がある場合に、インデックスの読取りがテーブルスキャンよりも効率的かどうかによって異なります。 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                このクエリーでは、<code class="literal">(<em class="replaceable"><code>key_part1</code></em>, <em class="replaceable"><code>key_part2</code></em>)</code> のインデックスにより、オプティマイザはソートを回避できます:
              </p><pre class="programlisting">SELECT * FROM t1
  ORDER BY <em class="replaceable"><code>key_part1</code></em>, <em class="replaceable"><code>key_part2</code></em>;
</pre><p>
                ただし、クエリーでは、<em class="replaceable"><code>key_part1</code></em> および <em class="replaceable"><code>key_part2</code></em> よりも多くのカラムを選択できる <code class="literal">SELECT *</code> が使用されます。 その場合、インデックス全体をスキャンしてテーブルの行を検索し、インデックスにないカラムを検索すると、テーブルをスキャンして結果をソートするよりコストがかかる可能性があります。 その場合、オプティマイザはおそらくインデックスを使用しません。 <code class="literal">SELECT *</code> がインデックスカラムのみを選択した場合、インデックスが使用され、ソートは回避されます。 
              </p><p>
                <code class="literal">t1</code> が <code class="literal">InnoDB</code> テーブルの場合、テーブルの主キーは暗黙的にインデックスの一部であり、インデックスを使用してこのクエリーの <code class="literal">ORDER BY</code> を解決できます:
              </p><pre class="programlisting">SELECT <em class="replaceable"><code>pk</code></em>, <em class="replaceable"><code>key_part1</code></em>, <em class="replaceable"><code>key_part2</code></em> FROM t1
  ORDER BY <em class="replaceable"><code>key_part1</code></em>, <em class="replaceable"><code>key_part2</code></em>;
</pre></li><li class="listitem"><p>
                このクエリーでは、<em class="replaceable"><code>key_part1</code></em> は定数であるため、インデックスを介してアクセスされるすべての行は <em class="replaceable"><code>key_part2</code></em> の順序であり、<code class="literal">WHERE</code> 句が選択的でテーブルスキャンよりも安価なインデックスレンジスキャンを行うことができる場合、<code class="literal">(<em class="replaceable"><code>key_part1</code></em>, <em class="replaceable"><code>key_part2</code></em>)</code> のインデックスはソートを回避します:
              </p><pre class="programlisting">SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_part1</code></em> = <em class="replaceable"><code>constant</code></em>
  ORDER BY <em class="replaceable"><code>key_part2</code></em>;
</pre></li><li class="listitem"><p>
                次の 2 つのクエリーでは、インデックスを使用するかどうかが、前述の <code class="literal">DESC</code> を使用しない同じクエリーと類似しています:
              </p><pre class="programlisting">SELECT * FROM t1
  ORDER BY <em class="replaceable"><code>key_part1</code></em> DESC, <em class="replaceable"><code>key_part2</code></em> DESC;

SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_part1</code></em> = <em class="replaceable"><code>constant</code></em>
  ORDER BY <em class="replaceable"><code>key_part2</code></em> DESC;
</pre></li><li class="listitem"><p>
                <code class="literal">ORDER BY</code> の 2 つのカラムは、同じ方向 (<code class="literal">ASC</code> または両方の <code class="literal">DESC</code>) または反対方向 (<code class="literal">ASC</code>、一方の <code class="literal">DESC</code>) でソートできます。 インデックスの使用条件は、インデックスの均一性は同じである必要があるが、実際の方向は同じである必要がないことです。 
              </p><p>
                クエリーで <code class="literal">ASC</code> と <code class="literal">DESC</code> が混在している場合、インデックスで対応する昇順と降順の混合カラムも使用されていれば、オプティマイザはカラムにインデックスを使用できます:
              </p><pre class="programlisting">SELECT * FROM t1
  ORDER BY <em class="replaceable"><code>key_part1</code></em> DESC, <em class="replaceable"><code>key_part2</code></em> ASC;
</pre><p>
                <em class="replaceable"><code>key_part1</code></em> が降順で <em class="replaceable"><code>key_part2</code></em> が昇順の場合、オプティマイザは (<em class="replaceable"><code>key_part1</code></em>、<em class="replaceable"><code>key_part2</code></em>) のインデックスを使用できます。 <em class="replaceable"><code>key_part1</code></em> が昇順で <em class="replaceable"><code>key_part2</code></em> が降順の場合は、これらのカラムにインデックスを使用することもできます (バックワードスキャンを使用)。 <a class="xref" href="optimization.html#descending-indexes" title="8.3.13 降順インデックス">セクション8.3.13「降順インデックス」</a>を参照してください。 
              </p></li><li class="listitem"><p>
                次の 2 つのクエリーでは、<em class="replaceable"><code>key_part1</code></em> が定数と比較されます。 インデックスは、テーブルスキャンよりもインデックスレンジスキャンの方が安くなるように、<code class="literal">WHERE</code> 句が選択的である場合に使用されます: 
              </p><pre class="programlisting">SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_part1</code></em> &gt; <em class="replaceable"><code>constant</code></em>
  ORDER BY <em class="replaceable"><code>key_part1</code></em> ASC;

SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_part1</code></em> &lt; <em class="replaceable"><code>constant</code></em>
  ORDER BY <em class="replaceable"><code>key_part1</code></em> DESC;
</pre></li><li class="listitem"><p>
                次のクエリーでは、<code class="literal">ORDER BY</code> は <em class="replaceable"><code>key_part1</code></em> を指定しませんが、選択されたすべての行には定数の <em class="replaceable"><code>key_part1</code></em> 値があるため、インデックスは引き続き使用できます:
              </p><pre class="programlisting">SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_part1</code></em> = <em class="replaceable"><code>constant1</code></em> AND <em class="replaceable"><code>key_part2</code></em> &gt; <em class="replaceable"><code>constant2</code></em>
  ORDER BY <em class="replaceable"><code>key_part2</code></em>;
</pre></li></ul></div><p>
            場合によっては、MySQL はインデックスを使用して <code class="literal">ORDER BY</code> を解決できませんが、インデックスを使用して <code class="literal">WHERE</code> 句に一致する行を見つけることができます。 例: 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                このクエリーでは、異なるインデックスで <code class="literal">ORDER BY</code> を使用します:
              </p><pre class="programlisting">SELECT * FROM t1 ORDER BY <em class="replaceable"><code>key1</code></em>, <em class="replaceable"><code>key2</code></em>;
</pre></li><li class="listitem"><p>
                クエリーでは、インデックスの連続していない部分で <code class="literal">ORDER BY</code> を使用します:
              </p><pre class="programlisting">SELECT * FROM t1 WHERE <em class="replaceable"><code>key2</code></em>=<em class="replaceable"><code>constant</code></em> ORDER BY <em class="replaceable"><code>key1_part1</code></em>, <em class="replaceable"><code>key1_part3</code></em>;
</pre></li><li class="listitem"><p>
                行のフェッチに使用されるインデックスは、<code class="literal">ORDER BY</code> で使用されるインデックスとは異なります:
              </p><pre class="programlisting">SELECT * FROM t1 WHERE <em class="replaceable"><code>key2</code></em>=<em class="replaceable"><code>constant</code></em> ORDER BY <em class="replaceable"><code>key1</code></em>;
</pre></li><li class="listitem"><p>
                クエリーでは、インデックスカラム名以外の用語を含む式を使用して <code class="literal">ORDER BY</code> を使用します:
              </p><pre class="programlisting">SELECT * FROM t1 ORDER BY ABS(<em class="replaceable"><code>key</code></em>);
SELECT * FROM t1 ORDER BY -<em class="replaceable"><code>key</code></em>;
</pre></li><li class="listitem"><p>
                クエリーによって多数のテーブルが結合され、<code class="literal">ORDER BY</code> のカラムは、行の取得に使用される最初の非定数テーブルのすべてではありません。 (これは <code class="literal">EXPLAIN</code> 出力で、<code class="literal">const</code> 結合型を持たない最初のテーブルです。)  
              </p></li><li class="listitem"><p>
                クエリーの <code class="literal">ORDER BY</code> 式と <code class="literal">GROUP BY</code> 式が異なります。
              </p></li><li class="listitem"><p>
                <code class="literal">ORDER BY</code> 句で指定されたカラムの接頭辞にのみインデックスがあります。 この場合、インデックスを使用してソート順序を完全には解決できません。 たとえば、<code class="literal">CHAR(20)</code> カラムの最初の 10 バイトのみがインデックス付けされている場合、インデックスでは 10 バイトを超える値を区別できず、<code class="literal">filesort</code> が必要です。 
              </p></li><li class="listitem"><p>
                インデックスには、行は順番に格納されません。 たとえば、これは、<code class="literal">MEMORY</code> テーブルの <code class="literal">HASH</code> インデックスに当てはまります。 
              </p></li></ul></div><p>
            インデックスをソートに使用できるかどうかは、カラムエイリアスの使用によって影響を受けることがあります。 カラム <code class="literal">t1.a</code> にインデックスが設定されているとします。 次のステートメントでは、選択リスト内のカラム名は <code class="literal">a</code> です。 <code class="literal">ORDER BY</code> 内の <code class="literal">a</code> への参照と同様に、<code class="literal">t1.a</code> を参照するため、<code class="literal">t1.a</code> 上のインデックスを使用できます: 
          </p><pre class="programlisting">SELECT a FROM t1 ORDER BY a;
</pre><p>
            次のステートメントでも、選択リスト内のカラム名は <code class="literal">a</code> ですが、これはエイリアス名です。 <code class="literal">ORDER BY</code> 内の <code class="literal">a</code> への参照と同様に、<code class="literal">ABS(a)</code> を参照するため、<code class="literal">t1.a</code> 上のインデックスは使用できません: 
          </p><pre class="programlisting">SELECT ABS(a) AS a FROM t1 ORDER BY a;
</pre><p>
            次のステートメントでは、<code class="literal">ORDER BY</code> は、選択リスト内のカラムの名前でない名前を参照しています。 ただし、<code class="literal">t1</code> には <code class="literal">a</code> という名前のカラムがあるため、<code class="literal">ORDER BY</code> は <code class="literal">t1.a</code> を参照し、<code class="literal">t1.a</code> のインデックスを使用できます。 (当然ながら、結果のソート順序は、<code class="literal">ABS(a)</code> の順序とはまったく異なる可能性があります。)  
          </p><pre class="programlisting">SELECT ABS(a) AS b FROM t1 ORDER BY a;
</pre><a class="indexterm" name="idm45661480148384"></a><a class="indexterm" name="idm45661480146608"></a><a class="indexterm" name="idm45661480144832"></a><a class="indexterm" name="idm45661480142672"></a><p>
            以前は (MySQL 5.7 以下)、<code class="literal">GROUP BY</code> は特定の条件下で暗黙的にソートされていました。 MySQL 8.0 では発生しなくなったため、暗黙的ソートを抑制するために最後に <code class="literal">ORDER BY NULL</code> を指定する必要はなくなりました (前述のとおり)。 ただし、クエリー結果は以前の MySQL バージョンとは異なる場合があります。 特定のソート順序を生成するには、<code class="literal">ORDER BY</code> 句を指定します。 
          </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="order-by-filesort"></a>filesort を使用して ORDER BY を満たす</h5></div></div></div><a class="indexterm" name="idm45661480136576"></a><a class="indexterm" name="idm45661480135104"></a><p>
            インデックスを使用して <code class="literal">ORDER BY</code> 句を満たすことができない場合、MySQL はテーブルの行を読み取ってソートする <code class="literal">filesort</code> 操作を実行します。 <code class="literal">filesort</code> は、クエリーの実行時に追加のソートフェーズを構成します。 
          </p><p>
            MySQL 8.0.12 の時点で、<code class="literal">filesort</code> 操作用のメモリーを取得するために、オプティマイザは、MySQL 8.0.12 より前に行われた一定量の <code class="literal">sort_buffer_size</code> バイトを割り当てるのではなく、<code class="literal">sort_buffer_size</code> システム変数で指定されたサイズまで必要に応じて増分的にメモリーバッファを割り当てます。 これにより、ユーザーは小さいソートに過剰なメモリー使用を考慮せずに、大きいソートを高速化するために <code class="literal">sort_buffer_size</code> を大きい値に設定できます。 (この利点は、マルチスレッド <code class="literal">malloc</code> が弱い Windows での複数の同時ソートでは発生しない場合があります。) 
          </p><p>
            結果セットが大きすぎてメモリーに収まらない場合、<code class="literal">filesort</code> 操作は必要に応じて一時ディスクファイルを使用します。 一部のタイプのクエリーは、完全にインメモリー <code class="literal">filesort</code> 操作に特に適しています。 たとえば、オプティマイザは <code class="literal">filesort</code> を使用して、一時ファイルを使用せずに、次の形式のクエリー (およびサブクエリー) に対する <code class="literal">ORDER BY</code> 操作をメモリー内で効率的に処理できます: 
          </p><pre class="programlisting">SELECT ... FROM <em class="replaceable"><code>single_table</code></em> ... ORDER BY <em class="replaceable"><code>non_index_column</code></em> [DESC] LIMIT [<em class="replaceable"><code>M</code></em>,]<em class="replaceable"><code>N</code></em>;
</pre><p>
            このようなクエリーは、より大きな結果セットの少数の行のみを表示する web アプリケーションで一般的です。 例: 
          </p><pre class="programlisting">SELECT col1, ... FROM t1 ... ORDER BY name LIMIT 10;
SELECT col1, ... FROM t1 ... ORDER BY RAND() LIMIT 15;
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="order-by-optimizer-control"></a>ORDER BY 最適化への影響</h5></div></div></div><p>
            <code class="literal">filesort</code> が使用されていない低速な <code class="literal">ORDER BY</code> クエリーの場合は、<code class="literal">max_length_for_sort_data</code> システム変数を <code class="literal">filesort</code> のトリガーに適した値に下げてみてください。 (この変数の値を著しく高く設定すると、高いディスクアクティビティーと低い CPU アクティビティーの組み合わせが見られます。) この方法は、MySQL 8.0.20 の前にのみ適用されます。 8.0.20 では、<code class="literal">max_length_for_sort_data</code> は非推奨になりました。これは、オプティマイザの変更によって廃止され、効果がないためです。 
          </p><p>
            <code class="literal">ORDER BY</code> 速度を向上するには、MySQL で、追加のソートフェーズではなく、インデックスを使用させることができるかどうかをチェックします。 これが不可能な場合は、次の方法を試してください: 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">sort_buffer_size</code> 変数値を増やします。 理想的には、(ディスクへの書込みおよびマージパスを回避するために) 結果セット全体がソートバッファに収まるように値を十分に大きくする必要があります。 
              </p><p>
                ソートバッファーに格納されているカラム値のサイズは、<code class="literal">max_sort_length</code> システム変数値の影響を受けることを考慮してください。 たとえば、タプルに長い文字列カラムの値が格納されていて、<code class="literal">max_sort_length</code> の値を増やすと、ソートバッファータプルのサイズも増加し、<code class="literal">sort_buffer_size</code> を増やす必要がある場合があります。 
              </p><p>
                (一時ファイルをマージするための) マージパスの数を監視するには、<code class="literal">Sort_merge_passes</code> ステータス変数を確認します。
              </p></li><li class="listitem"><p>
                一度に読み取られる行が増えるように、<code class="literal">read_rnd_buffer_size</code> 変数の値を増やします。
              </p></li><li class="listitem"><p>
                <code class="literal">tmpdir</code> システム変数を変更して、大量の空き領域のある専用ファイルシステムを指すようにします。 変数値には、ラウンドロビン方式で使用される複数のパスをリストできます。この機能を使用して、複数のディレクトリに負荷を分散できます。 パスは、Unix ではコロン文字 (<code class="literal">:</code>) で区切り、Windows ではセミコロン文字 (<code class="literal">;</code>) で区切ります。 パスには、同じディスク上の異なるパーティションではなく、異なる<span class="emphasis"><em>物理</em></span>ディスクにあるファイルシステム内のディレクトリを指定してください。 
              </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="order-by-diagnostic-information"></a>ORDER BY 実行計画情報使用可能</h5></div></div></div><p>
            <code class="literal">EXPLAIN</code> (<a class="xref" href="optimization.html#using-explain" title="8.8.1 EXPLAIN によるクエリーの最適化">セクション8.8.1「EXPLAIN によるクエリーの最適化」</a> を参照) では、MySQL がインデックスを使用して <code class="literal">ORDER BY</code> 句を解決できるかどうかを確認できます:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">EXPLAIN</code> 出力の <code class="literal">Extra</code> カラムに <code class="literal">Using filesort</code> が含まれていない場合、インデックスが使用され、<code class="literal">filesort</code> は実行されません。
              </p></li><li class="listitem"><p>
                <code class="literal">EXPLAIN</code> 出力の <code class="literal">Extra</code> カラムに <code class="literal">Using filesort</code> が含まれている場合、インデックスは使用されず、<code class="literal">filesort</code> が実行されます。
              </p></li></ul></div><p>
            また、<code class="literal">filesort</code> が実行されると、オプティマイザのトレース出力に <code class="literal">filesort_summary</code> ブロックが含まれます。 例: 
          </p><pre class="programlisting">"filesort_summary": {
  "rows": 100,
  "examined_rows": 100,
  "number_of_tmp_files": 0,
  "peak_memory_used": 25192,
  "sort_mode": "&lt;sort_key, packed_additional_fields&gt;"
}
</pre><p>
            <code class="literal">peak_memory_used</code> は、ソート中に一度に使用される最大メモリーを示します。 これは、<code class="literal">sort_buffer_size</code> システム変数の値までの値ですが、必ずしも大きくなるとはかぎりません。 MySQL 8.0.12 より前の出力では、かわりに <code class="literal">sort_buffer_size</code> の値を示す <code class="literal">sort_buffer_size</code> が表示されます。 (MySQL 8.0.12 より前では、オプティマイザは常に <code class="literal">sort_buffer_size</code> バイトをソートバッファーに割り当てます。 8.0.12 の時点では、オプティマイザは、少量から始まり、必要に応じて <code class="literal">sort_buffer_size</code> バイトまで、ソートバッファメモリーを増分的に割り当てます。) 
          </p><p>
            <code class="literal">sort_mode</code> 値は、ソートバッファー内のタプルの内容に関する情報を提供します:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">&lt;sort_key, rowid&gt;</code> : これは、ソートバッファータプルが、元のテーブル行のソートキー値と行 ID を含むペアであることを示します。 タプルはソートキー値でソートされ、行 ID は、テーブルからの行の読み取りに使用されます。 
              </p></li><li class="listitem"><p>
                <code class="literal">&lt;sort_key, additional_fields&gt;</code> : これは、ソートバッファータプルにソートキー値とクエリーによって参照されるカラムが含まれていることを示します。 タプルはソートキー値でソートされ、カラム値は、タプルから直接読み取られます。 
              </p></li><li class="listitem"><p>
                <code class="literal">&lt;sort_key, packed_additional_fields&gt;</code> : 前のバリアントと同様ですが、追加のカラムは固定長エンコーディングを使用するかわりに密接にパックされます。
              </p></li></ul></div><p>
            <code class="literal">EXPLAIN</code> は、オプティマイザがメモリー内で <code class="literal">filesort</code> を実行するかどうかを区別しません。 インメモリー <code class="literal">filesort</code> の使用は、オプティマイザのトレース出力で確認できます。 <code class="literal">filesort_priority_queue_optimization</code> を探します。 オプティマイザのトレースについては、「<a class="ulink" href="https://dev.mysql.com/doc/internals/en/optimizer-tracing.html" target="_top">MySQL Internals: Tracing the Optimizer</a>」を参照してください。 
          </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-by-optimization"></a>8.2.1.17 GROUP BY の最適化</h4></div></div></div><a class="indexterm" name="idm45661480054304"></a><a class="indexterm" name="idm45661480052848"></a><p>
          <code class="literal">GROUP BY</code> 句を満たすもっとも一般的な方法は、テーブル全体をスキャンし、各グループのすべての行が連続する新しい一時テーブルを作成することであり、それにより、この一時テーブルを使用してグループを見つけて、集約関数 (ある場合) を適用できます。 場合によっては、MySQL はそれよりはるかに優れた処理を実行でき、インデックスアクセスを使用した一時テーブルの作成を回避できます。 
        </p><p>
          <code class="literal">GROUP BY</code> のインデックスを使用するための最も重要な前提条件は、すべての <code class="literal">GROUP BY</code> カラムが同じインデックスの属性を参照し、インデックスにそのキーが順番に格納されることです (たとえば、<code class="literal">BTREE</code> インデックスの場合は該当しますが、<code class="literal">HASH</code> インデックスの場合は該当しません)。 一時テーブルの使用をインデックスアクセスに置き換えられるかどうかは、クエリー内でインデックスのどの部分が使用されているか、その部分に指定された条件、および選択された集約関数にもよります。 
        </p><p>
          次のセクションで詳しく説明するように、インデックスアクセスによって <code class="literal">GROUP BY</code> クエリーを実行する方法は 2 つあります。 最初の方法では、すべての範囲述語 (ある場合) とともにグループ化操作が適用されます。 2 つめの方法では、まず範囲スキャンを実行し、次に結果タプルをグループ化します。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#loose-index-scan" title="ルースインデックススキャン">ルースインデックススキャン</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#tight-index-scan" title="タイトインデックススキャン">タイトインデックススキャン</a></p></li></ul></div><p>
          一部の条件下では、<code class="literal">GROUP BY</code> が存在しない場合にも、緩やかなインデックススキャンを使用できます。 <a class="xref" href="optimization.html#range-access-skip-scan" title="スキャン範囲アクセス方法のスキップ">スキャン範囲アクセス方法のスキップ</a>を参照してください。 
        </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="loose-index-scan"></a>ルースインデックススキャン</h5></div></div></div><a class="indexterm" name="idm45661480037296"></a><p>
            <code class="literal">GROUP BY</code> を処理するもっとも効率的な方法は、インデックスを使用してグループ化するカラムを直接取得することです。 このアクセスメソッドでは、MySQL はキーが順序付けられている、インデックス型のプロパティーを使用します。(たとえば、<code class="literal">BTREE</code>)。 このプロパティーにより、インデックス内のすべての <code class="literal">WHERE</code> 条件を満たすキーを考慮する必要なく、インデックス内のルックアップグループを使用できます。 このアクセス方法では、インデックス内のキーの一部のみが考慮されるため、<span class="firstterm">ルーズインデックススキャン</span>と呼ばれます。 <code class="literal">WHERE</code> 句がない場合、ループインデックススキャンはグループ数と同じ数のキーを読み取ります。これは、すべてのキーの数よりはるかに小さい場合があります。 <code class="literal">WHERE</code> 句に範囲述語が含まれている場合 (<a class="xref" href="optimization.html#using-explain" title="8.8.1 EXPLAIN によるクエリーの最適化">セクション8.8.1「EXPLAIN によるクエリーの最適化」</a> の <code class="literal">range</code> 結合タイプの説明を参照)、ルーズインデックススキャンは範囲条件を満たす各グループの最初のキーを検索し、可能なかぎり少ない数のキーを再度読み取ります。 これは次の条件の下で可能です。 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                クエリーが単一テーブルに対するものです。
              </p></li><li class="listitem"><p>
                <code class="literal">GROUP BY</code> はインデックスの左端のプリフィクスを形成するカラムのみを指定し、ほかのカラムは指定しません。 (<code class="literal">GROUP BY</code> の代わりに、クエリーに <code class="literal">DISTINCT</code> 句がある場合、個々のすべての属性がインデックスの左端のプリフィクスを形成するカラムを参照します。) たとえば、テーブル <code class="literal">t1</code> の <code class="literal">(c1,c2,c3)</code> にインデックスがある場合、クエリーに <code class="literal">GROUP BY c1, c2</code> が含まれていれば、Loose Index Scan が適用されます。 クエリーに <code class="literal">GROUP BY c2, c3</code> (カラムは左端のプリフィクスでない) または <code class="literal">GROUP BY c1, c2, c4</code> (<code class="literal">c4</code> はインデックス内にない) がある場合は適用できません。 
              </p></li><li class="listitem"><p>
                選択リスト (ある場合) で使用されている集約関数が、<code class="literal">MIN()</code> と <code class="literal">MAX()</code> だけであり、それらはすべて同じカラムを参照します。 カラムはインデックス内にあり、<code class="literal">GROUP BY</code> のカラムの直後にある必要があります。 
              </p></li><li class="listitem"><p>
                クエリーで参照された <code class="literal">GROUP BY</code> からの部分以外のインデックスの部分は、定数である必要があります (つまり、定数と同等のもので参照されている必要があります) が、<code class="literal">MIN()</code> または <code class="literal">MAX()</code> 関数の引数を除きます。
              </p></li><li class="listitem"><p>
                インデックス内のカラムの場合、プリフィクスだけでなく、完全なカラム値にインデックスが設定されている必要があります。 たとえば、<code class="literal">c1 VARCHAR(20), INDEX (c1(10))</code> では、インデックスは <code class="literal">c1</code> 値の接頭辞のみを使用し、ループインデックススキャンには使用できません。 
              </p></li></ul></div><p>
            ループインデックススキャンがクエリーに適用可能な場合、<code class="literal">EXPLAIN</code> 出力の <code class="literal">Extra</code> カラムに <code class="literal">Using index for group-by</code> が表示されます。
          </p><p>
            テーブル <code class="literal">t1(c1,c2,c3,c4)</code> にインデックス <code class="literal">idx(c1,c2,c3)</code> があると仮定します。 Loose Index Scan アクセス方法は、次のクエリーに使用できます: 
          </p><pre class="programlisting">SELECT c1, c2 FROM t1 GROUP BY c1, c2;
SELECT DISTINCT c1, c2 FROM t1;
SELECT c1, MIN(c2) FROM t1 GROUP BY c1;
SELECT c1, c2 FROM t1 WHERE c1 &lt; <em class="replaceable"><code>const</code></em> GROUP BY c1, c2;
SELECT MAX(c3), MIN(c3), c1, c2 FROM t1 WHERE c2 &gt; <em class="replaceable"><code>const</code></em> GROUP BY c1, c2;
SELECT c2 FROM t1 WHERE c1 &lt; <em class="replaceable"><code>const</code></em> GROUP BY c1, c2;
SELECT c1, c2 FROM t1 WHERE c3 = <em class="replaceable"><code>const</code></em> GROUP BY c1, c2;
</pre><p>
            次に示す理由により、以下のクエリーはこのクイック選択メソッドで実行できません。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">MIN()</code> または <code class="literal">MAX()</code> 以外の集約関数があります。
              </p><pre class="programlisting">SELECT c1, SUM(c2) FROM t1 GROUP BY c1;
</pre></li><li class="listitem"><p>
                <code class="literal">GROUP BY</code> 句内のカラムがインデックスの左端のプリフィクスを形成していません。
              </p><pre class="programlisting">SELECT c1, c2 FROM t1 GROUP BY c2, c3;
</pre></li><li class="listitem"><p>
                クエリーは <code class="literal">GROUP BY</code> 部分のあとに続くキーの部分を参照し、そこに定数と同等のものがありません。
              </p><pre class="programlisting">SELECT c1, c3 FROM t1 GROUP BY c1, c2;
</pre><p>
                クエリーに <code class="literal">WHERE c3 = <em class="replaceable"><code>const</code></em></code> が含まれていたため、ループインデックススキャンを使用できました。
              </p></li></ul></div><p>
            Loose Index Scan アクセス方法は、すでにサポートされている <code class="literal">MIN()</code> および <code class="literal">MAX()</code> 参照に加えて、選択リストの他の形式の集計関数参照にも適用できます:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">AVG(DISTINCT)</code>、<code class="literal">SUM(DISTINCT)</code>、および <code class="literal">COUNT(DISTINCT)</code> がサポートされています。 <code class="literal">AVG(DISTINCT)</code> と <code class="literal">SUM(DISTINCT)</code> は 1 つの引数をとります。 <code class="literal">COUNT(DISTINCT)</code> には複数のカラム引数を指定できます。 
              </p></li><li class="listitem"><p>
                クエリーに <code class="literal">GROUP BY</code> または <code class="literal">DISTINCT</code> 句があってはいけません。
              </p></li><li class="listitem"><p>
                前に説明した Loose Index Scan の制限が引き続き適用されます。
              </p></li></ul></div><p>
            テーブル <code class="literal">t1(c1,c2,c3,c4)</code> にインデックス <code class="literal">idx(c1,c2,c3)</code> があると仮定します。 Loose Index Scan アクセス方法は、次のクエリーに使用できます: 
          </p><pre class="programlisting">SELECT COUNT(DISTINCT c1), SUM(DISTINCT c1) FROM t1;

SELECT COUNT(DISTINCT c1, c2), COUNT(DISTINCT c2, c1) FROM t1;
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="tight-index-scan"></a>タイトインデックススキャン</h5></div></div></div><p>
            密インデックススキャンは、クエリー条件に応じて、全インデックススキャンまたはレンジインデックススキャンのいずれかになります。
          </p><p>
            ループインデックススキャンの条件が満たされていない場合でも、<code class="literal">GROUP BY</code> クエリーの一時テーブルの作成を回避できます。 <code class="literal">WHERE</code> 句に範囲条件がある場合、このメソッドはこれらの条件を満たすキーだけを読み取ります。 そうでない場合は、インデックススキャンを実行します。 このメソッドは、<code class="literal">WHERE</code> 句で定義された各範囲内のすべてのキーを読み取るか、範囲条件がない場合はインデックス全体をスキャンするため、<span class="firstterm">タイトインデックススキャン</span>と呼ばれます。 厳密なインデックススキャンでは、範囲条件を満たすすべてのキーが検出された後にのみグループ化操作が実行されます。 
          </p><p>
            この方法が機能するには、<code class="literal">GROUP BY</code> キーの一部の前後に来るキーの一部を参照するクエリーのすべてのカラムに一定の等価条件がある必要があります。 同等条件からの定数は、インデックスの完全なプリフィクスを形成できるように、検索キーの<span class="quote">「<span class="quote">ギャップ</span>」</span>を埋めます。 これらのインデックスのプリフィクスは、インデックスルックアップに使用できます。 <code class="literal">GROUP BY</code> の結果にソートが必要で、インデックスの接頭辞である検索キーを形成できる場合、順序付きインデックスの接頭辞で検索するとすべてのキーがすでに順番に取得されるため、MySQL では余分なソート操作も回避されます。 
          </p><p>
            テーブル <code class="literal">t1(c1,c2,c3,c4)</code> にインデックス <code class="literal">idx(c1,c2,c3)</code> があると仮定します。 次のクエリーは、前述の Loose Index Scan アクセス方法では機能しませんが、Tight Index Scan アクセス方法では機能します。 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">GROUP BY</code> にはギャップがありますが、条件 <code class="literal">c2 = 'a'</code> によってカバーされます。
              </p><pre class="programlisting">SELECT c1, c2, c3 FROM t1 WHERE c2 = 'a' GROUP BY c1, c3;
</pre></li><li class="listitem"><p>
                <code class="literal">GROUP BY</code> は、キーの最初の部分から開始されませんが、その部分に対して定数を与える条件があります。
              </p><pre class="programlisting">SELECT c1, c2, c3 FROM t1 WHERE c1 = 'a' GROUP BY c2, c3;
</pre></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="distinct-optimization"></a>8.2.1.18 DISTINCT の最適化</h4></div></div></div><a class="indexterm" name="idm45661479948464"></a><a class="indexterm" name="idm45661479947152"></a><p>
          <code class="literal">ORDER BY</code> と組み合わされた <code class="literal">DISTINCT</code> では多くの場合に一時テーブルが必要です。
        </p><p>
          <code class="literal">DISTINCT</code> では <code class="literal">GROUP BY</code> を使用できるため、MySQL が <code class="literal">ORDER BY</code> または <code class="literal">HAVING</code> 句内の選択したカラムの部分でないカラムをどのように処理するかを学んでください。 <a class="xref" href="functions.html#group-by-handling" title="12.20.3 MySQL での GROUP BY の処理">セクション12.20.3「MySQL での GROUP BY の処理」</a>を参照してください。 
        </p><p>
          ほとんどの場合、<code class="literal">DISTINCT</code> 句は <code class="literal">GROUP BY</code> の特殊な例と考えることができます。 たとえば、次の 2 つのクエリーは同等です。 
        </p><pre class="programlisting">SELECT DISTINCT c1, c2, c3 FROM t1
WHERE c1 &gt; <em class="replaceable"><code>const</code></em>;

SELECT c1, c2, c3 FROM t1
WHERE c1 &gt; <em class="replaceable"><code>const</code></em> GROUP BY c1, c2, c3;
</pre><p>
          この同等性のため、<code class="literal">GROUP BY</code> クエリーに適用できる最適化は <code class="literal">DISTINCT</code> 句のあるクエリーにも適用できます。 そのため、<code class="literal">DISTINCT</code> クエリー最適化の可能性の詳細については、<a class="xref" href="optimization.html#group-by-optimization" title="8.2.1.17 GROUP BY の最適化">セクション8.2.1.17「GROUP BY の最適化」</a>を参照してください。 
        </p><p>
          <code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em></code> を <code class="literal">DISTINCT</code> と組み合わせた場合、MySQL は <em class="replaceable"><code>row_count</code></em> 固有の行が見つかるとただちに停止します。
        </p><p>
          クエリーに指定されたすべてのテーブルのカラムを使用しない場合、MySQL は最初の一致が見つかるとただちに未使用テーブルのスキャンを停止します。 次の例では、<code class="literal">t1</code> が <code class="literal">t2</code> の前に使用され (これは、<code class="literal">EXPLAIN</code> で確認できます)、MySQL は <code class="literal">t2</code> (<code class="literal">t1</code> 内の特定の行の) で、最初の行を見つけると、<code class="literal">t2</code> からの読み取りを停止します。 
        </p><pre class="programlisting">SELECT DISTINCT t1.a FROM t1, t2 where t1.a=t2.a;
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="limit-optimization"></a>8.2.1.19 LIMIT クエリーの最適化</h4></div></div></div><a class="indexterm" name="idm45661479920496"></a><a class="indexterm" name="idm45661479918384"></a><p>
          結果セットから指定した数の行のみが必要な場合、結果セット全体をフェッチして、余分なデータを破棄するのではなく、クエリーで <code class="literal">LIMIT</code> 句を使用します。
        </p><p>
          MySQL は <code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em></code> 句があり <code class="literal">HAVING</code> 句のないクエリーを最適化することがあります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">LIMIT</code> で少数の行のみを選択すると、MySQL では、通常フルテーブルスキャンを実行するより望ましい特定の場合に、インデックスが使用されます。
            </p></li><li class="listitem"><p>
              <code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em></code> を <code class="literal">ORDER BY</code> と組み合せると、MySQL はソート結果の最初の <em class="replaceable"><code>row_count</code></em> 行を見つけた直後に、結果全体をソートするのではなくソートを停止します。 インデックスを使用して順序付けが行われている場合、これはきわめて高速になります。 filesort を実行する必要がある場合、最初の <em class="replaceable"><code>row_count</code></em> を見つける前に、<code class="literal">LIMIT</code> 句を使用しないクエリーに一致するすべての行が選択され、それらのほとんどまたはすべてがソートされます。 初期の行が見つかったら、MySQL は結果セットの残りをすべてソートしません。 
            </p><p>
              この動作をはっきり示している現象の 1 つは、このセクションで後述するように、<code class="literal">LIMIT</code> を付けるか付けないかで <code class="literal">ORDER BY</code> クエリーは異なる順序で行を返す場合があることです。
            </p></li><li class="listitem"><p>
              <code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em></code> を <code class="literal">DISTINCT</code> と組み合せると、MySQL は <em class="replaceable"><code>row_count</code></em> の一意の行を検出するとすぐに停止します。
            </p></li><li class="listitem"><p>
              場合によっては、インデックスを順番に読み取る (またはインデックスでソートする) ことで <code class="literal">GROUP BY</code> を解決し、インデックス値が変更されるまでサマリーを計算できます。 この場合、<code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em></code> は不要な <code class="literal">GROUP BY</code> 値を計算しません。 
            </p></li><li class="listitem"><p>
              MySQL は必要な数の行をクライアントに送信するとただちに、<code class="literal">SQL_CALC_FOUND_ROWS</code> が使用されていないかぎり、クエリーを中止します。 その場合、<code class="literal">SELECT FOUND_ROWS()</code> を使用して行数を取得できます。 <a class="xref" href="functions.html#information-functions" title="12.16 情報関数">セクション12.16「情報関数」</a>を参照してください。 
            </p><a class="indexterm" name="idm45661479892608"></a></li><li class="listitem"><p>
              <code class="literal">LIMIT 0</code> は迅速に空のセットを返します。 これは、クエリーの妥当性のチェックに役立つことがあります。 また、結果セットメタデータを使用可能にする MySQL API を使用するアプリケーション内の結果カラムのタイプを取得するためにも使用できます。 <span class="command"><strong>mysql</strong></span> クライアントプログラムでは、<code class="option">--column-type-info</code> オプションを使用して結果カラムタイプを表示できます。 
            </p></li><li class="listitem"><p>
              サーバーは、一時テーブルを使用してクエリーを解決する場合、<code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em></code> 句を使用して必要な容量を計算します。
            </p></li><li class="listitem"><p>
              <code class="literal">ORDER BY</code> にインデックスが使用されていないが、<code class="literal">LIMIT</code> 句も存在する場合、オプティマイザはインメモリー <code class="literal">filesort</code> 操作を使用して、マージファイルの使用を回避し、メモリー内の行をソートできます。
            </p></li></ul></div><p>
          複数の行の <code class="literal">ORDER BY</code> カラムに同一の値がある場合、サーバーは自由にそれらの行を任意の順序で返しますが、その実行は実行プラン全体によって異なることがあります。 言い換えると、それらの行のソート順序は、順序付けされていないカラムに関して決定的ではありません。 
        </p><p>
          実行プランに影響する 1 つの要素は <code class="literal">LIMIT</code> であるため、<code class="literal">LIMIT</code> を付けるか付けないかで <code class="literal">ORDER BY</code> クエリーは異なる順序で行を返すことがあります。 <code class="literal">category</code> カラムによってソートされるが、<code class="literal">id</code> および <code class="literal">rating</code> カラムに関して非決定的である次のクエリーを考慮します。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM ratings ORDER BY category;</code></strong>
+----+----------+--------+
| id | category | rating |
+----+----------+--------+
|  1 |        1 |    4.5 |
|  5 |        1 |    3.2 |
|  3 |        2 |    3.7 |
|  4 |        2 |    3.5 |
|  6 |        2 |    3.5 |
|  2 |        3 |    5.0 |
|  7 |        3 |    2.7 |
+----+----------+--------+
</pre><p>
          <code class="literal">LIMIT</code> を含めると、各 <code class="literal">category</code> 値内の行の順序に影響することがあります。 たとえば、これは有効なクエリー結果です。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM ratings ORDER BY category LIMIT 5;</code></strong>
+----+----------+--------+
| id | category | rating |
+----+----------+--------+
|  1 |        1 |    4.5 |
|  5 |        1 |    3.2 |
|  4 |        2 |    3.5 |
|  3 |        2 |    3.7 |
|  6 |        2 |    3.5 |
+----+----------+--------+
</pre><p>
          各ケースで、行は <code class="literal">ORDER BY</code> カラムによってソートされますが、SQL 標準で必要とされるのはこれだけです。
        </p><p>
          <code class="literal">LIMIT</code> を使用してもしなくても同じ行順序を確保することが重要な場合は、<code class="literal">ORDER BY</code> 句に順序を決定的にする追加カラムを含めます。 たとえば、<code class="literal">id</code> 値が一意の場合、次のようにソートすることで、特定の <code class="literal">category</code> 値の行を <code class="literal">id</code> の順序で表示できます: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM ratings ORDER BY category, id;</code></strong>
+----+----------+--------+
| id | category | rating |
+----+----------+--------+
|  1 |        1 |    4.5 |
|  5 |        1 |    3.2 |
|  3 |        2 |    3.7 |
|  4 |        2 |    3.5 |
|  6 |        2 |    3.5 |
|  2 |        3 |    5.0 |
|  7 |        3 |    2.7 |
+----+----------+--------+

mysql&gt; <strong class="userinput"><code>SELECT * FROM ratings ORDER BY category, id LIMIT 5;</code></strong>
+----+----------+--------+
| id | category | rating |
+----+----------+--------+
|  1 |        1 |    4.5 |
|  5 |        1 |    3.2 |
|  3 |        2 |    3.7 |
|  4 |        2 |    3.5 |
|  6 |        2 |    3.5 |
+----+----------+--------+
</pre><p>
          <code class="literal">ORDER BY</code> または <code class="literal">GROUP BY</code> と <code class="literal">LIMIT</code> 句を含むクエリーの場合、オプティマイザは、クエリーの実行速度を上げるために、順序付けられたインデックスをデフォルトで選択しようとします。 MySQL 8.0.21 より前は、他の最適化を使用する方が高速であっても、この動作をオーバーライドする方法はありませんでした。 MySQL 8.0.21 以降では、<code class="literal">optimizer_switch</code> システム変数 <code class="literal">prefer_ordering_index</code> フラグを <code class="literal">off</code> に設定することで、この最適化をオフにできます。 
        </p><p>
          <span class="emphasis"><em>例</em></span>: まず、次に示すように、テーブル <code class="literal">t</code> を作成して移入します:
        </p><pre class="programlisting"># Create and populate a table t:

mysql&gt; <strong class="userinput"><code>CREATE TABLE t (</code></strong>
    -&gt;     <strong class="userinput"><code>id1 BIGINT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>id2 BIGINT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>c1 VARCHAR(50) NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>c2 VARCHAR(50) NOT NULL,</code></strong>
    -&gt;  <strong class="userinput"><code>PRIMARY KEY (id1),</code></strong>
    -&gt;  <strong class="userinput"><code>INDEX i (id2, c1)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>

# [Insert some rows into table t - not shown]
</pre><p>
          <code class="literal">prefer_ordering_index</code> フラグが有効になっていることを確認します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@optimizer_switch LIKE '%prefer_ordering_index=on%';</code></strong>
+------------------------------------------------------+
| @@optimizer_switch LIKE '%prefer_ordering_index=on%' |
+------------------------------------------------------+
|                                                    1 |
+------------------------------------------------------+
</pre><p>
          次のクエリーには <code class="literal">LIMIT</code> 句があるため、可能な場合は順序付けされたインデックスを使用する必要があります。 この場合、<code class="literal">EXPLAIN</code> 出力からわかるように、テーブルの主キーが使用されます。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT c2 FROM t</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE id2 &gt; 3</code></strong>
    -&gt;     <strong class="userinput"><code>ORDER BY id1 ASC LIMIT 2\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t
   partitions: NULL
         type: index
possible_keys: i
          key: PRIMARY
      key_len: 8
          ref: NULL
         rows: 2
     filtered: 70.00
        Extra: Using where
</pre><p>
          次に、<code class="literal">prefer_ordering_index</code> フラグを無効にし、同じクエリーを再実行します。今回は、インデックス <code class="literal">i</code> (<code class="literal">WHERE</code> 句で使用される <code class="literal">id2</code> カラムを含む) と filesort を使用します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET optimizer_switch = "prefer_ordering_index=off";</code></strong>

mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT c2 FROM t</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE id2 &gt; 3</code></strong>
    -&gt;     <strong class="userinput"><code>ORDER BY id1 ASC LIMIT 2\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t
   partitions: NULL
         type: range
possible_keys: i
          key: i
      key_len: 8
          ref: NULL
         rows: 14
     filtered: 100.00
        Extra: Using index condition; Using filesort
</pre><p>
          <a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2 切り替え可能な最適化">セクション8.9.2「切り替え可能な最適化」</a>も参照してください。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="function-optimization"></a>8.2.1.20 関数コールの最適化</h4></div></div></div><a class="indexterm" name="idm45661479825168"></a><a class="indexterm" name="idm45661479823040"></a><a class="indexterm" name="idm45661479820992"></a><a class="indexterm" name="idm45661479818912"></a><p>
          MySQL 関数は、内部的に決定論的または非決定的としてタグ付けされます。 関数に決定性がない状態とは、引数の値が固定されていても、呼び出しごとに異なる結果が返されることがある場合です。 非決定的関数の例: <code class="literal">RAND()</code>、<code class="literal">UUID()</code>。 
        </p><p>
          関数が非決定的にタグ付けされている場合、<code class="literal">WHERE</code> 句でのその関数への参照は、行ごと (あるテーブルから選択する場合) または行の組合せごと (複数テーブル結合から選択する場合) に評価されます。
        </p><p>
          MySQL では、引数がテーブルのカラムであるか定数値であるかにかかわらず、引数のタイプに基づいて関数を評価するタイミングも決定されます。 テーブルのカラムを引数として取る決定的関数は、そのカラムの値が変更されるたびに評価される必要があります。 
        </p><p>
          非決定的関数は、クエリーのパフォーマンスに影響を与える可能性があります。 たとえば、一部の最適化を使用できない場合や、より多くのロックが必要になる場合があります。 次の説明では、<code class="literal">RAND()</code> を使用しますが、他の非決定的関数にも適用されます。 
        </p><p>
          テーブル <code class="literal">t</code> に次の定義があるとします:
        </p><pre class="programlisting">CREATE TABLE t (id INT NOT NULL PRIMARY KEY, col_a VARCHAR(100));
</pre><p>
          次の 2 つのクエリーについて考えてみます:
        </p><pre class="programlisting">SELECT * FROM t WHERE id = POW(1,2);
SELECT * FROM t WHERE id = FLOOR(1 + RAND() * 49);
</pre><p>
          主キーに対する等価比較のため、両方のクエリーで主キー参照が使用されているように見えますが、これは最初のクエリーにのみ当てはまります:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              定数引数を持つ <code class="literal">POW()</code> は定数値であり、インデックスルックアップに使用されるため、最初のクエリーでは常に最大 1 行が生成されます。
            </p></li><li class="listitem"><p>
              2 番目のクエリーには、非決定的関数 <code class="literal">RAND()</code> を使用する式が含まれています。これはクエリーでは定数ではありませんが、実際にはテーブル <code class="literal">t</code> の各行に新しい値があります。 したがって、クエリーはテーブルのすべての行を読み取り、各行の述語を評価して、主キーがランダム値と一致するすべての行を出力します。 これは、<code class="literal">id</code> のカラム値および <code class="literal">RAND()</code> 順序内の値に応じて、ゼロ、1 または複数の行になります。 
            </p></li></ul></div><p>
          非決定の影響は、<code class="literal">SELECT</code> ステートメントに限定されません。 次の <code class="literal">UPDATE</code> ステートメントでは、非決定的関数を使用して、変更する行を選択します: 
        </p><pre class="programlisting">UPDATE t SET col_a = <em class="replaceable"><code>some_expr</code></em> WHERE id = FLOOR(1 + RAND() * 49);
</pre><p>
          主キーが式と一致する単一の行のみを更新することを意図しています。 ただし、<code class="literal">id</code> カラムの値および <code class="literal">RAND()</code> 順序の値によっては、ゼロ、1 または複数の行が更新される場合があります。 
        </p><p>
          ここで説明した動作は、パフォーマンスとレプリケーションに影響します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              非決定的関数では定数値が生成されないため、オプティマイザは、それ以外の場合には適用可能な戦略 (インデックス参照など) を使用できません。 結果はテーブルスキャンである可能性があります。 
            </p></li><li class="listitem"><p>
              <code class="literal">InnoDB</code> は、一致する行に対して単一行ロックを取得するのではなく、範囲キーロックにエスカレートする場合があります。
            </p></li><li class="listitem"><p>
              決定的に実行されない更新は、レプリケーションに対して安全ではありません。
            </p></li></ul></div><p>
          問題は、<code class="literal">RAND()</code> 関数がテーブルのすべての行に対して 1 回評価されるという事実から発生します。 複数の関数の評価を回避するには、次のいずれかの方法を使用します: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              非決定的関数を含む式を別のステートメントに移動し、値を変数に保存します。 元のステートメントで、式を変数への参照に置き換えます。この変数は、オプティマイザで定数値として処理できます: 
            </p><pre class="programlisting">SET @keyval = FLOOR(1 + RAND() * 49);
UPDATE t SET col_a = <em class="replaceable"><code>some_expr</code></em> WHERE id = @keyval;
</pre></li><li class="listitem"><p>
              導出テーブルの変数にランダム値を割り当てます。 この方法では、<code class="literal">WHERE</code> 句での比較で変数を使用する前に、変数に値が一度割り当てられます: 
            </p><pre class="programlisting">UPDATE /*+ NO_MERGE(dt) */ t, (SELECT FLOOR(1 + RAND() * 49) AS r) AS dt
SET col_a = <em class="replaceable"><code>some_expr</code></em> WHERE id = dt.r;
</pre></li></ul></div><p>
          前述のように、<code class="literal">WHERE</code> 句の非決定的な式によって最適化が妨げられ、テーブルスキャンが発生する可能性があります。 ただし、他の式が決定的である場合は、<code class="literal">WHERE</code> 句を部分的に最適化できます。 例: 
        </p><pre class="programlisting">SELECT * FROM t WHERE partial_key=5 AND some_column=RAND();
</pre><p>
          オプティマイザが <code class="literal">partial_key</code> を使用して選択された行セットを減らすことができる場合、<code class="literal">RAND()</code> の実行回数が少なくなり、最適化に対する非決定の影響が低下します。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="window-function-optimization"></a>8.2.1.21 ウィンドウ機能最適化</h4></div></div></div><a class="indexterm" name="idm45661479769360"></a><a class="indexterm" name="idm45661479767200"></a><p>
          ウィンドウ関数は、オプティマイザが考慮する戦略に影響します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              サブクエリーにウィンドウ関数がある場合、サブクエリーの導出テーブルマージは無効になります。 サブクエリーは常に実体化されます。 
            </p></li><li class="listitem"><p>
              準結合は、ウィンドウ関数の最適化には適用できません。これは、ウィンドウ関数を含むことができない <code class="literal">WHERE</code> および <code class="literal">JOIN ... ON</code> のサブクエリーに準結合が適用されるためです。
            </p></li><li class="listitem"><p>
              オプティマイザは同じ順序付け要件を持つ複数のウィンドウを順番に処理するため、最初のウィンドウに続くウィンドウではソートをスキップできます。
            </p></li><li class="listitem"><p>
              オプティマイザは、単一のステップで評価できるウィンドウをマージしようとしません (たとえば、複数の <code class="literal">OVER</code> 句に同一のウィンドウ定義が含まれている場合)。 回避策は、<code class="literal">WINDOW</code> 句でウィンドウを定義し、<code class="literal">OVER</code> 句でウィンドウ名を参照することです。 
            </p></li></ul></div><p>
          ウィンドウ関数として使用されない集計関数は、可能なかぎり外側のクエリーで集計されます。 たとえば、次のクエリーでは、MySQL は、<code class="literal">COUNT(t1.b)</code> が <code class="literal">WHERE</code> 句に配置されているために外部クエリーに存在できないものであることを確認します: 
        </p><pre class="programlisting">SELECT * FROM t1 WHERE t1.a = (SELECT COUNT(t1.b) FROM t2);
</pre><p>
          したがって、MySQL はサブクエリー内で集計し、<code class="literal">t1.b</code> を定数として扱い、<code class="literal">t2</code> の行数を返します。
        </p><p>
          <code class="literal">WHERE</code> を <code class="literal">HAVING</code> に置き換えると、エラーが発生します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM t1 HAVING t1.a = (SELECT COUNT(t1.b) FROM t2);</code></strong>
ERROR 1140 (42000): In aggregated query without GROUP BY, expression #1
of SELECT list contains nonaggregated column 'test.t1.a'; this is
incompatible with sql_mode=only_full_group_by
</pre><p>
          このエラーは、<code class="literal">COUNT(t1.b)</code> が <code class="literal">HAVING</code> に存在し、外部クエリーが集計されるために発生します。
        </p><p>
          ウィンドウ関数 (ウィンドウ関数として使用される集計関数を含む) には、前述の複雑さはありません。 これらは常に、外部クエリーではなく、書き込まれるサブクエリーで集計されます。 
        </p><p>
          ウィンドウ関数の評価は、精度を失わずにウィンドウ操作を計算するかどうかを決定する <code class="literal">windowing_use_high_precision</code> システム変数の値の影響を受ける可能性があります。 デフォルトでは、<code class="literal">windowing_use_high_precision</code> は有効です。 
        </p><p>
          一部の移動フレーム集計では、逆集計関数を適用して集計から値を削除できます。 これにより、パフォーマンスは向上しますが、精度が失われる可能性があります。 たとえば、非常に小さい浮動小数点値を非常に大きな値に追加すると、非常に小さい値が大きい値の<span class="quote">「<span class="quote">「非表示」</span>」</span>になります。 大きい値を後で反転すると、小さい値の効果は失われます。 
        </p><p>
          逆集約による精度の損失は、浮動小数点 (近似値) データ型に対する演算の場合にのみ係数となります。 他のタイプの場合、逆集約は安全です。これには、小数部を許可するが正確な値タイプである <code class="literal">DECIMAL</code> が含まれます。 
        </p><p>
          高速実行のために、安全な場合、MySQL は常に逆集約を使用します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              浮動小数点値の場合、逆集約は必ずしも安全ではなく、精度が失われる可能性があります。 デフォルトでは、逆集約は回避されます。逆集約は低速ですが、精度は維持されます。 速度の安全性を犠牲にすることが許可されている場合は、<code class="literal">windowing_use_high_precision</code> を無効にして逆集約を許可できます。 
            </p></li><li class="listitem"><p>
              非浮動小数点データ型の場合、逆集約は常に安全であり、<code class="literal">windowing_use_high_precision</code> 値に関係なく使用されます。
            </p></li><li class="listitem"><p>
              <code class="literal">windowing_use_high_precision</code> は、<code class="literal">MIN()</code> および <code class="literal">MAX()</code> には影響せず、いずれの場合も逆集約を使用しません。
            </p></li></ul></div><p>
          <code class="literal">STDDEV_POP()</code>, <code class="literal">STDDEV_SAMP()</code>, <code class="literal">VAR_POP()</code>, <code class="literal">VAR_SAMP()</code> の分散関数およびそのシノニムの評価では、最適化モードまたはデフォルトモードで評価を行うことができます。 最適化モードでは、最後の有効桁の結果が若干異なる場合があります。 このような違いが許容される場合は、<code class="literal">windowing_use_high_precision</code> を無効にして最適化モードを許可できます。 
        </p><a class="indexterm" name="idm45661479721152"></a><a class="indexterm" name="idm45661479719104"></a><p>
          <code class="literal">EXPLAIN</code> の場合、ウィンドウ実行計画情報は大きすぎるため、従来の出力形式で表示できません。 ウィンドウ情報を表示するには、<code class="literal">EXPLAIN FORMAT=JSON</code> を使用して <code class="literal">windowing</code> 要素を探します。 
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="row-constructor-optimization"></a>8.2.1.22 行コンストラクタ式の最適化</h4></div></div></div><a class="indexterm" name="idm45661479712032"></a><a class="indexterm" name="idm45661479709856"></a><p>
          行コンストラクタを使用すると、複数の値を同時に比較できます。 たとえば、次の 2 つのステートメントは意味的に同等です: 
        </p><pre class="programlisting">SELECT * FROM t1 WHERE (column1,column2) = (1,1);
SELECT * FROM t1 WHERE column1 = 1 AND column2 = 1;
</pre><p>
          また、オプティマイザは両方の式を同じ方法で処理します。
        </p><p>
          行コンストラクタカラムがインデックスの接頭辞をカバーしていない場合、オプティマイザは使用可能なインデックスを使用する可能性が低くなります。 <code class="literal">(c1, c2, c3)</code> で主キーを持つ次のテーブルについて考えてみます: 
        </p><pre class="programlisting">CREATE TABLE t1 (
  c1 INT, c2 INT, c3 INT, c4 CHAR(100),
  PRIMARY KEY(c1,c2,c3)
);
</pre><p>
          このクエリーでは、<code class="literal">WHERE</code> 句はインデックス内のすべてのカラムを使用します。 ただし、行コンストラクタ自体はインデックス接頭辞をカバーしません。その結果、オプティマイザは <code class="literal">c1</code> (<code class="literal">key_len=4</code>、つまり <code class="literal">c1</code> のサイズ) のみを使用します: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM t1</code></strong>
       <strong class="userinput"><code>WHERE c1=1 AND (c2,c3) &gt; (1,1)\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
   partitions: NULL
         type: ref
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 4
          ref: const
         rows: 3
     filtered: 100.00
        Extra: Using where
</pre><p>
          このような場合、等価の非コンストラクタ式を使用して行コンストラクタ式をリライトすると、より完全なインデックスが使用される可能性があります。 指定されたクエリーについて、行コンストラクタおよび同等の非コンストラクタ式は次のとおりです: 
        </p><pre class="programlisting">(c2,c3) &gt; (1,1)
c2 &gt; 1 OR ((c2 = 1) AND (c3 &gt; 1))
</pre><p>
          非コンストラクタ式を使用するようにクエリーをリライトすると、オプティマイザはインデックス内の 3 つのカラムすべて (<code class="literal">key_len=12</code>) を使用します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM t1</code></strong>
       <strong class="userinput"><code>WHERE c1 = 1 AND (c2 &gt; 1 OR ((c2 = 1) AND (c3 &gt; 1)))\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
   partitions: NULL
         type: range
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 12
          ref: NULL
         rows: 3
     filtered: 100.00
        Extra: Using where
</pre><p>
          したがって、より適切な結果を得るには、行コンストラクタと <code class="literal">AND</code>/<code class="literal">OR</code> 式を混在させないでください。 一方を使用してください。 
        </p><p>
          特定の条件下では、オプティマイザは行コンストラクタ引数を持つ <code class="literal">IN()</code> 式に範囲アクセス方法を適用できます。 <a class="xref" href="optimization.html#row-constructor-range-optimization" title="行コンストラクタ式の範囲最適化">行コンストラクタ式の範囲最適化</a>を参照してください。 
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="table-scan-avoidance"></a>8.2.1.23 全テーブルスキャンの回避</h4></div></div></div><a class="indexterm" name="idm45661479683776"></a><a class="indexterm" name="idm45661479681632"></a><a class="indexterm" name="idm45661479679568"></a><p>
          MySQL が<a class="link" href="glossary.html#glos_full_table_scan" title="テーブルの完全スキャン">フルテーブルスキャン</a>を使用してクエリーを解決する場合、<code class="literal">EXPLAIN</code> からの出力には <code class="literal">type</code> カラムに <code class="literal">ALL</code> と示されます。 これは通常は次の条件で発生します。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              テーブルがきわめて小さいため、キールックアップで煩わされるよりもテーブルスキャンを実行する方が速くなります。 これは、10 行未満の行や短い行長のテーブルによくあります。 
            </p></li><li class="listitem"><p>
              インデックスが設定されたカラムに対して、<code class="literal">ON</code> または <code class="literal">WHERE</code> 句に使用可能な制限がありません。
            </p></li><li class="listitem"><p>
              インデックスが設定されたカラムと定数値を比較していて、MySQL が (インデックスツリーに基づいて) その定数がテーブルのきわめて大きい部分をカバーしており、テーブルスキャンが高速に行われると計算しました。 <a class="xref" href="optimization.html#where-optimization" title="8.2.1.1 WHERE 句の最適化">セクション8.2.1.1「WHERE 句の最適化」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              別のカラム経由で、カーディナリティーが低い (多数の行がキー値に一致する) キーを使用しています。 この場合、MySQL では、キーを使用することで多くのキー検索が必要になり、テーブルスキャンが高速になると想定しています。 
            </p></li></ul></div><p>
          小さいテーブルでは、テーブルスキャンは多くの場合に適切であり、実行の影響は無視できます。 大きいテーブルでは、オプティマイザがテーブルスキャンを誤って選択しないように、次の技法を試してください。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">ANALYZE TABLE <em class="replaceable"><code>tbl_name</code></em></code> を使用して、スキャンされるテーブルのキー分布を更新します。 <a class="xref" href="sql-statements.html#analyze-table" title="13.7.3.1 ANALYZE TABLE ステートメント">セクション13.7.3.1「ANALYZE TABLE ステートメント」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              スキャンされるテーブルに <code class="literal">FORCE INDEX</code> を使用して、MySQL に、テーブルスキャンは指定したインデックスを使用するのと比較して著しく負荷が大きいことを伝えます。
            </p><pre class="programlisting">SELECT * FROM t1, t2 FORCE INDEX (<em class="replaceable"><code>index_for_column</code></em>)
  WHERE t1.<em class="replaceable"><code>col_name</code></em>=t2.<em class="replaceable"><code>col_name</code></em>;
</pre><p>
              <a class="xref" href="optimization.html#index-hints" title="8.9.4 インデックスヒント">セクション8.9.4「インデックスヒント」</a>を参照してください。
            </p></li><li class="listitem"><p>
              <code class="option">--max-seeks-for-key=1000</code> オプションを使用して <span class="command"><strong>mysqld</strong></span> を開始するか、または <code class="literal">SET max_seeks_for_key=1000</code> を使用して、オプティマイザに、キースキャンでは 1,000 より多くのキーシークは発生しないと想定するように伝えます。 <a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>を参照してください。 
            </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="subquery-optimization"></a>8.2.2 サブクエリー、導出テーブル、ビュー参照および共通テーブル式の最適化</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#semijoins">8.2.2.1 準結合変換による IN および EXISTS サブクエリー述語の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#subquery-materialization">8.2.2.2 実体化を使用したサブクエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#subquery-optimization-with-exists">8.2.2.3 EXISTS 戦略を使用したサブクエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#derived-table-optimization">8.2.2.4 マージまたは実体化を使用した導出テーブル、ビュー参照および共通テーブル式の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#derived-condition-pushdown-optimization">8.2.2.5 導出条件プッシュダウン最適化</a></span></dt></dl></div><a class="indexterm" name="idm45661479651360"></a><a class="indexterm" name="idm45661479649248"></a><a class="indexterm" name="idm45661479647216"></a><a class="indexterm" name="idm45661479645168"></a><a class="indexterm" name="idm45661479643120"></a><a class="indexterm" name="idm45661479641088"></a><a class="indexterm" name="idm45661479639056"></a><a class="indexterm" name="idm45661479637008"></a><p>
        MySQL クエリーオプティマイザには、サブクエリーの評価に使用できる様々な戦略があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">IN</code>、<code class="literal">= ANY</code> または <code class="literal">EXISTS</code> 述語で使用されるサブクエリーの場合、オプティマイザには次の選択肢があります:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                準結合
              </p></li><li class="listitem"><p>
                実体化
              </p></li><li class="listitem"><p>
                <code class="literal">EXISTS</code> 戦略
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">NOT IN</code>、<code class="literal">&lt;&gt; ALL</code> または <code class="literal">NOT EXISTS</code> 述語で使用されるサブクエリーの場合、オプティマイザには次の選択肢があります:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                実体化
              </p></li><li class="listitem"><p>
                <code class="literal">EXISTS</code> 戦略
              </p></li></ul></div></li></ul></div><p>
        導出テーブルの場合、オプティマイザには次の選択肢があります (ビュー参照および共通テーブル式にも適用されます):
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            導出テーブルの外部クエリーブロックへのマージ
          </p></li><li class="listitem"><p>
            導出テーブルを内部一時テーブルに実体化
          </p></li></ul></div><p>
        次の説明では、前述の最適化戦略について詳しく説明します。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          サブクエリーを使用して単一のテーブルを変更する <code class="literal">UPDATE</code> ステートメントおよび <code class="literal">DELETE</code> ステートメントの制限は、オプティマイザが準結合サブクエリーまたは実体化サブクエリーの最適化を使用しないことです。 回避策として、サブクエリーではなく結合を使用する複数テーブルの <code class="literal">UPDATE</code> ステートメントおよび <code class="literal">DELETE</code> ステートメントとしてリライトしてみてください。 
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="semijoins"></a>8.2.2.1 準結合変換による IN および EXISTS サブクエリー述語の最適化</h4></div></div></div><a class="indexterm" name="idm45661479610240"></a><p>
          準結合は、テーブルのプルアウト、重複の除去、最初の一致、緩やかなスキャン、実体化などの複数の実行戦略を可能にする準備時変換です。 オプティマイザは、このセクションで説明するように、準結合戦略を使用してサブクエリーの実行を改善します。 
        </p><p>
          2 つのテーブル間の内部結合の場合、結合は、他方のテーブルに一致がある回数だけ、一方のテーブルから 1 行を返します。 ただし、問題によっては、重要な情報は一致の数ではなく、一致があるかどうかだけの場合があります。 コースカリキュラムのクラスとクラス名簿 (各クラスに登録されている生徒) をそれぞれ一覧表示する <code class="literal">class</code> と <code class="literal">roster</code> というテーブルがあるとします。 実際に生徒が登録されているクラスを一覧表示するには、次の結合を使用できます。 
        </p><pre class="programlisting">SELECT class.class_num, class.class_name
    FROM class
    INNER JOIN roster
    WHERE class.class_num = roster.class_num;
</pre><p>
          ただし、結果には、登録された生徒ごとに、各クラスが 1 回ずつ一覧表示されます。 ここでの問題では、これは不要な情報の重複です。 
        </p><p>
          <code class="literal">class_num</code> が <code class="literal">class</code> テーブルの主キーであると仮定すると、<code class="literal">SELECT DISTINCT</code> を使用して重複抑制が可能ですが、後で重複を排除するためにのみ、最初に一致するすべての行を生成することは非効率的です。
        </p><p>
          同じ重複のない結果は、次のサブクエリーを使用して取得できます。
        </p><pre class="programlisting">SELECT class_num, class_name
    FROM class
    WHERE class_num IN
        (SELECT class_num FROM roster);
</pre><p>
          ここで、オプティマイザは <code class="literal">IN</code> 句に <code class="literal">roster</code> テーブルから各クラス番号のインスタンスを 1 つだけ返すサブクエリーが必要であることを認識できます。 この場合、クエリーでは<span class="firstterm">準結合</span>を使用できます。つまり、<code class="literal">roster</code> の行と一致する <code class="literal">class</code> の各行のインスタンスを 1 つのみ返す操作です。 
        </p><p>
          <code class="literal">EXISTS</code> サブクエリー述語を含む次のステートメントは、<code class="literal">IN</code> サブクエリー述語を含む前述のステートメントと同等です:
        </p><pre class="programlisting">SELECT class_num, class_name
    FROM class
    WHERE EXISTS
        (SELECT * FROM roster WHERE class.class_num = roster.class_num);
</pre><p>
          MySQL 8.0.16 以降では、<code class="literal">EXISTS</code> サブクエリー述語を含むステートメントは、同等の <code class="literal">IN</code> サブクエリー述語を含むステートメントと同じ準結合変換の対象となります。
        </p><p>
          MySQL 8.0.17 以降、次のサブクエリーはアンチ結合に変換されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">NOT IN (SELECT ... FROM ...)</code>
            </p></li><li class="listitem"><p>
              <code class="literal">NOT EXISTS (SELECT ... FROM ...)</code>。
            </p></li><li class="listitem"><p>
              <code class="literal">IN (SELECT ... FROM ...) IS NOT TRUE</code>
            </p></li><li class="listitem"><p>
              <code class="literal">EXISTS (SELECT ... FROM ...) IS NOT TRUE</code>。
            </p></li><li class="listitem"><p>
              <code class="literal">IN (SELECT ... FROM ...) IS FALSE</code>
            </p></li><li class="listitem"><p>
              <code class="literal">EXISTS (SELECT ... FROM ...) IS FALSE</code>。
            </p></li></ul></div><p>
          つまり、<code class="literal">IN (SELECT ... FROM ...)</code> または <code class="literal">EXISTS (SELECT ... FROM ...)</code> 形式のサブクエリーの否定は、アンチ結合に変換されます。
        </p><p>
          アンチ結合は、一致がない行のみを返す操作です。 次に示すクエリーについて考えてみます: 
        </p><pre class="programlisting">SELECT class_num, class_name
    FROM class
    WHERE class_num NOT IN
        (SELECT class_num FROM roster);
</pre><p>
          このクエリーは内部的にアンチ結合 <code class="literal">SELECT class_num, class_name FROM class ANTIJOIN roster ON class_num</code> としてリライトされ、<code class="literal">roster</code> のどの行とも一致しない <code class="literal">class</code> の各行のインスタンスが返されます。 つまり、<code class="literal">class</code> の各行については、<code class="literal">roster</code> で一致が見つかるとすぐに <code class="literal">class</code> の行を破棄できます。 
        </p><p>
          比較対象の式が NULL 値可能な場合、ほとんどの場合、アンチ結合変換は適用できません。 このルールの例外は、<code class="literal">(... NOT IN (SELECT ...)) IS NOT FALSE</code> とそれに相当する <code class="literal">(... IN (SELECT ...)) IS NOT TRUE</code> をアンチ結合に変換できることです。 
        </p><p>
          外部結合および内部結合の構文は外部クエリー仕様で許可され、テーブル参照は実テーブル、導出テーブル、ビュー参照または共通テーブル式です。
        </p><p>
          MySQL では、サブクエリーを準結合として処理するには、次の基準を満たす必要があります (MySQL 8.0.17 以降では、<code class="literal">NOT</code> がサブクエリーを変更する場合はアンチ結合):
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">WHERE</code> 句または <code class="literal">ON</code> 句の最上位レベルに表示される <code class="literal">IN</code>、<code class="literal">= ANY</code> または <code class="literal">EXISTS</code> 述語の一部である必要があります。<code class="literal">AND</code> 式の用語として使用することもできます。 例: 
            </p><pre class="programlisting">SELECT ...
    FROM ot1, ...
    WHERE (oe1, ...) IN
        (SELECT ie1, ... FROM it1, ... WHERE ...);
</pre><p>
              ここで、<code class="literal">ot_<em class="replaceable"><code>i</code></em></code> と <code class="literal">it_<em class="replaceable"><code>i</code></em></code> は、クエリーの外側部分と内側部分のテーブルを表し、<code class="literal">oe_<em class="replaceable"><code>i</code></em></code> と <code class="literal">ie_<em class="replaceable"><code>i</code></em></code> は、外部テーブルと内部テーブル内のカラムを参照する式を表します。
            </p><p>
              MySQL 8.0.17 以降では、サブクエリーは <code class="literal">NOT</code>、<code class="literal">IS [NOT] TRUE</code> または <code class="literal">IS [NOT] FALSE</code> によって変更された式の引数にすることもできます。
            </p></li><li class="listitem"><p>
              それは <code class="literal">UNION</code> コンストラクトのない単一の <code class="literal">SELECT</code> である必要があります。
            </p></li><li class="listitem"><p>
              <code class="literal">HAVING</code> 句を含めることはできません。
            </p></li><li class="listitem"><p>
              (明示的または暗黙的にグループ化されているかどうかにかかわらず) 集計関数を含めることはできません。
            </p></li><li class="listitem"><p>
              <code class="literal">LIMIT</code> 句を指定しないでください。
            </p></li><li class="listitem"><p>
              ステートメントでは、外部クエリーで <code class="literal">STRAIGHT_JOIN</code> 結合タイプを使用しないでください。
            </p><a class="indexterm" name="idm45661479541344"></a></li><li class="listitem"><p>
              <code class="literal">STRAIGHT_JOIN</code> 修飾子は指定できません。
            </p><a class="indexterm" name="idm45661479538000"></a></li><li class="listitem"><p>
              外部テーブルとおよび内部テーブルの合計数が結合で許可されている最大テーブル数より少なくなければなりません。
            </p></li><li class="listitem"><p>
              サブクエリーは相関する場合と相関しない場合があります。 MySQL 8.0.16 以降では、デコレーションは <code class="literal">EXISTS</code> への引数として使用されるサブクエリーの <code class="literal">WHERE</code> 句内の簡易相関述語を調べ、<code class="literal">IN (SELECT b FROM ...)</code> 内で使用されたかのように最適化できます。 <span class="emphasis"><em>簡易相関</em></span>という用語は、述語が等価述語であり、<code class="literal">WHERE</code> 句の唯一の述語である (または <code class="literal">AND</code> と組み合されている) こと、および一方のオペランドがサブクエリーで参照されるテーブルのもので、もう一方のオペランドが外部クエリーブロックのものであることを意味します。 
            </p></li><li class="listitem"><p>
              <code class="literal">DISTINCT</code> キーワードは使用できますが、無視されます。 準結合戦略では、重複削除が自動的に処理されます。 
            </p></li><li class="listitem"><p>
              サブクエリーに集計関数も含まれていないかぎり、<code class="literal">GROUP BY</code> 句は許可されますが無視されます。
            </p></li><li class="listitem"><p>
              順序付けは準結合戦略の評価には関係ないため、<code class="literal">ORDER BY</code> 句は許可されますが無視されます。
            </p></li></ul></div><p>
          サブクエリーが前述の基準を満たす場合、MySQL は準結合 (MySQL 8.0.17 以降ではアンチ結合) に変換し、次の方法からコストベースの選択を行います:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              サブクエリーを結合に変換するか、テーブルプルアウトを使用して、クエリーをサブクエリーテーブルと外部テーブル間の内部結合として実行します。 テーブルプルアウトは、テーブルをサブクエリーから外部クエリーに引き出します。 
            </p><a class="indexterm" name="idm45661479521072"></a></li><li class="listitem"><p>
              <span class="emphasis"><em>重複の除去</em></span>: 準結合を結合として実行し、一時テーブルを使用して重複レコードを削除します。
            </p><a class="indexterm" name="idm45661479517680"></a></li><li class="listitem"><p>
              <span class="emphasis"><em>FirstMatch</em></span>: 内部テーブルで行の組合せをスキャンし、特定の値グループに複数のインスタンスがある場合は、すべてを戻すのではなく、いずれかを選択します。 これはスキャンを「ショートカット」し、不要な行の生成をなくします。 
            </p><a class="indexterm" name="idm45661479514064"></a></li><li class="listitem"><p>
              <span class="emphasis"><em>LooseScan</em></span> : 各サブクエリー値グループから単一の値を選択できるインデックスを使用して、サブクエリーテーブルをスキャンします。
            </p><a class="indexterm" name="idm45661479510704"></a></li><li class="listitem"><p>
              結合の実行に使用されるインデックス付き一時テーブルにサブクエリーを実体化します。インデックスは重複を削除するために使用されます。 さらに、インデックスはあとで一時テーブルと外部テーブルを結合する際のルックアップにも使用されることがあります。そうでない場合はテーブルがスキャンされます。 実体化の詳細は、<a class="xref" href="optimization.html#subquery-materialization" title="8.2.2.2 実体化を使用したサブクエリーの最適化">セクション8.2.2.2「実体化を使用したサブクエリーの最適化」</a> を参照してください。 
            </p><a class="indexterm" name="idm45661479506592"></a></li></ul></div><p>
          これらの各戦略は、次の <code class="literal">optimizer_switch</code> システム変数フラグを使用して有効または無効にできます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">semijoin</code> フラグは、準結合を使用するかどうかを制御します。 MySQL 8.0.17 以降、これはアンチ結合にも適用されます。 
            </p></li><li class="listitem"><p>
              <code class="literal">semijoin</code> が有効になっている場合、<code class="literal">firstmatch</code>, <code class="literal">loosescan</code>, <code class="literal">duplicateweedout</code> および <code class="literal">materialization</code> フラグを使用すると、許可される準結合戦略をより詳細に制御できます。
            </p></li><li class="listitem"><p>
              <code class="literal">duplicateweedout</code> 準結合戦略が無効になっている場合は、他のすべての適用可能な戦略も無効にしないかぎり、使用されません。
            </p></li><li class="listitem"><p>
              <code class="literal">duplicateweedout</code> が無効になっている場合、オプティマイザによって最適ではないクエリー計画が生成されることがあります。 これは、最長一致検索中のヒューリスティックプルーニングが原因で発生します。これは、<code class="literal">optimizer_prune_level=0</code> を設定することで回避できます。 
            </p></li></ul></div><p>
          これらのフラグはデフォルトで有効になっています。 <a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2 切り替え可能な最適化">セクション8.9.2「切り替え可能な最適化」</a>を参照してください。 
        </p><p>
          オプティマイザは、ビューおよび導出テーブルの処理の違いを最小限に抑えます。 これは、<code class="literal">STRAIGHT_JOIN</code> 修飾子を使用するクエリーおよび準結合に変換可能な <code class="literal">IN</code> サブクエリーを含むビューに影響します。 次のクエリーは、処理の変更によって変換が変更されるため、実行計画が異なるため、これを示しています: 
        </p><pre class="programlisting">CREATE VIEW v AS
SELECT *
FROM t1
WHERE a IN (SELECT b
           FROM t2);

SELECT STRAIGHT_JOIN *
FROM t3 JOIN v ON t3.x = v.a;
</pre><p>
          オプティマイザはまずビューを参照し、<code class="literal">IN</code> サブクエリーを準結合に変換してから、ビューを外部クエリーにマージできるかどうかをチェックします。 外部クエリーの <code class="literal">STRAIGHT_JOIN</code> 修飾子によって準結合が妨げられるため、オプティマイザはマージを拒否し、実体化テーブルを使用して導出テーブルを評価します。 
        </p><p>
          <code class="literal">EXPLAIN</code> 出力には、次のような準結合戦略の使用が示されています:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              拡張 <code class="literal">EXPLAIN</code> 出力の場合、次の <code class="literal">SHOW WARNINGS</code> によって表示されるテキストは、準結合構造を表示するリライトされたクエリーを示しています。 (<a class="xref" href="optimization.html#explain-extended" title="8.8.3 拡張 EXPLAIN 出力形式">セクション8.8.3「拡張 EXPLAIN 出力形式」</a>を参照してください。) このページから、準結合から取得されたテーブルについて理解できます。 サブクエリーが準結合に変換された場合は、サブクエリー述語がなくなり、そのテーブルおよび <code class="literal">WHERE</code> 句が外部クエリー結合リストおよび <code class="literal">WHERE</code> 句にマージされたことがわかります。 
            </p></li><li class="listitem"><p>
              重複の除去のための一時テーブルの使用は、<code class="literal">Extra</code> カラムの <code class="literal">Start temporary</code> と <code class="literal">End temporary</code> によって示されます。 プルされず、<code class="literal">Start temporary</code> および <code class="literal">End temporary</code> でカバーされる <code class="literal">EXPLAIN</code> 出力行の範囲内にあるテーブルの一時テーブルには、<code class="literal">rowid</code> があります。 
            </p></li><li class="listitem"><p>
              <code class="literal">Extra</code> カラムの <code class="literal">FirstMatch(<em class="replaceable"><code>tbl_name</code></em>)</code> は結合のショートカットを示します。
            </p></li><li class="listitem"><p>
              <code class="literal">Extra</code> カラムの <code class="literal">LooseScan(<em class="replaceable"><code>m</code></em>..<em class="replaceable"><code>n</code></em>)</code> は LooseScan 戦略の使用を示します。<em class="replaceable"><code>m</code></em> と <em class="replaceable"><code>n</code></em> はキーパート番号です。
            </p></li><li class="listitem"><p>
              実体化での一時テーブルの使用は、<code class="literal">select_type</code> 値が <code class="literal">MATERIALIZED</code> の行と、<code class="literal">table</code> 値が <code class="literal">&lt;subquery<em class="replaceable"><code>N</code></em>&gt;</code> の行によって示されます。
            </p></li></ul></div><p>
          MySQL 8.0.21 以降では、準結合変換は、単一テーブル <code class="literal">UPDATE</code>、または<code class="literal">[NOT] IN</code> または<code class="literal">[NOT] EXISTS</code> サブクエリー述語を使用する <code class="literal">DELETE</code> ステートメントへ適用もできます。ただし、ステートメントが <code class="literal">ORDER BY</code> または <code class="literal">LIMIT</code> を使用せず、準結合変換がオプティマイザヒントにより、または <code class="literal">optimizer_switch</code> 設定により許可されている場合です。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="subquery-materialization"></a>8.2.2.2 実体化を使用したサブクエリーの最適化</h4></div></div></div><a class="indexterm" name="idm45661479448016"></a><a class="indexterm" name="idm45661479446576"></a><a class="indexterm" name="idm45661479444544"></a><p>
          オプティマイザは実体化を使用して、より効率的なサブクエリー処理を可能にします。 実体化は、通常メモリー内に一時テーブルとしてサブクエリー結果を生成することによって、クエリー実行を高速化します。 MySQL ははじめてサブクエリー結果を必要としたときに、その結果を一時テーブルに実体化します。 あとで結果が必要になったときに、MySQL は再度一時テーブルを参照します。 オプティマイザはハッシュインデックスを使用してテーブルをインデックス付けし、高速かつ低コストにルックアップできる場合があります。 インデックスには、重複を排除してテーブルを小さくするための一意の値が含まれています。 
        </p><p>
          サブクエリーの実体化では、可能な場合はインメモリー一時テーブルが使用され、テーブルが大きすぎるとディスク上の記憶域にフォールバックします。 <a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4 MySQL での内部一時テーブルの使用">セクション8.4.4「MySQL での内部一時テーブルの使用」</a>を参照してください。 
        </p><p>
          実体化を使用しない場合、オプティマイザは、非相関サブクエリーを相関サブクエリーとして書き換えることがあります。 たとえば、次の <code class="literal">IN</code> サブクエリーは非相関です (<em class="replaceable"><code>where_condition</code></em> には <code class="literal">t2</code> からのカラムのみが含まれ、<code class="literal">t1</code> からは含まれません)。 
        </p><pre class="programlisting">SELECT * FROM t1
WHERE t1.a IN (SELECT t2.b FROM t2 WHERE <em class="replaceable"><code>where_condition</code></em>);
</pre><p>
          オプティマイザはこれを <code class="literal">EXISTS</code> 相関サブクエリーとして書き換えることがあります。
        </p><pre class="programlisting">SELECT * FROM t1
WHERE EXISTS (SELECT t2.b FROM t2 WHERE <em class="replaceable"><code>where_condition</code></em> AND t1.a=t2.b);
</pre><p>
          一時テーブルを使用したサブクエリー実体化により、そのような書き換えを回避し、外部クエリーの行ごとに 1 回ではなく、1 回だけサブクエリーを実行させることができます。
        </p><p>
          MySQL でサブクエリー実体化を使用するには、<code class="literal">optimizer_switch</code> システム変数 <code class="literal">materialization</code> フラグを有効にする必要があります。 (<a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2 切り替え可能な最適化">セクション8.9.2「切り替え可能な最適化」</a>を参照してください。) <code class="literal">materialization</code> フラグを有効にすると、実体化は、次のユースケースのいずれかに該当する述語に対して、(選択リスト、<code class="literal">WHERE</code>, <code class="literal">ON</code>, <code class="literal">GROUP BY</code>, <code class="literal">HAVING</code> または <code class="literal">ORDER BY</code>) 任意の場所に出現するサブクエリー述語に適用されます: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              外側の式 <em class="replaceable"><code>oe_i</code></em> または内側の式 <em class="replaceable"><code>ie_i</code></em> が NULL 可能でない場合に、述語はこの形式になります。 <em class="replaceable"><code>N</code></em> は 1 以上です。 
            </p><pre class="programlisting">(<em class="replaceable"><code>oe_1</code></em>, <em class="replaceable"><code>oe_2</code></em>, ..., <em class="replaceable"><code>oe_N</code></em>) [NOT] IN (SELECT <em class="replaceable"><code>ie_1</code></em>, <em class="replaceable"><code>i_2</code></em>, ..., <em class="replaceable"><code>ie_N</code></em> ...)
</pre></li><li class="listitem"><p>
              単一の外側の式 <em class="replaceable"><code>oe</code></em> と内側の式 <em class="replaceable"><code>ie</code></em> がある場合に、述語はこの形式になります。 式は NULL 可能にできます。 
            </p><pre class="programlisting"><em class="replaceable"><code>oe</code></em> [NOT] IN (SELECT <em class="replaceable"><code>ie</code></em> ...)
</pre></li><li class="listitem"><p>
              述語は <code class="literal">IN</code> または <code class="literal">NOT IN</code> で <code class="literal">UNKNOWN</code> (<code class="literal">NULL</code>) の結果は <code class="literal">FALSE</code> の結果と同じ意味になります。
            </p></li></ul></div><p>
          次の例に、<code class="literal">UNKNOWN</code> および <code class="literal">FALSE</code> 述語評価の同等性の要件が、サブクエリー実体化を使用できるかどうかにどのように影響するかを示します。 サブクエリーが非相関になるように、<em class="replaceable"><code>where_condition</code></em> に <code class="literal">t2</code> からのカラムのみが含まれ、<code class="literal">t1</code> からは含まれないとします。 
        </p><p>
          このクエリーは実体化の対象になります。
        </p><pre class="programlisting">SELECT * FROM t1
WHERE t1.a IN (SELECT t2.b FROM t2 WHERE <em class="replaceable"><code>where_condition</code></em>);
</pre><p>
          ここでは、<code class="literal">IN</code> 述語が <code class="literal">UNKNOWN</code> を返すか、<code class="literal">FALSE</code> を返すかは問題ではありません。 どちらも <code class="literal">t1</code> からの行はクエリー結果に含まれません。 
        </p><p>
          サブクエリーの実体化が使用されていない例は、次のクエリーで、<code class="literal">t2.b</code> は NULL 値可能なカラムです:
        </p><pre class="programlisting">SELECT * FROM t1
WHERE (t1.a,t1.b) NOT IN (SELECT t2.a,t2.b FROM t2
                          WHERE <em class="replaceable"><code>where_condition</code></em>);
</pre><p>
          サブクエリー実体化の使用には、次の制限が適用されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              内部式と外部式の型は一致する必要があります。 たとえば、両方の式が整数であるか、両方が小数の場合、オプティマイザは実体化を使用できますが、一方の式が整数でもう一方が小数の場合は使用できません。 
            </p></li><li class="listitem"><p>
              内部式は <code class="literal">BLOB</code> にできません。
            </p></li></ul></div><p>
          クエリーで <code class="literal">EXPLAIN</code> を使用すると、オプティマイザがサブクエリーの実体化を使用するかどうかがわかります:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              実体化を使用しないクエリー実行と比較して、<code class="literal">select_type</code> が <code class="literal">DEPENDENT SUBQUERY</code> から <code class="literal">SUBQUERY</code> に変更されることがあります。 これは、外部行ごとに 1 回実行されるサブクエリーの場合、実体化によってサブクエリーが 1 回だけ実行されるようにできることを示します。 
            </p></li><li class="listitem"><p>
              拡張 <code class="literal">EXPLAIN</code> 出力の場合、次の <code class="literal">SHOW WARNINGS</code> によって表示されるテキストには、<code class="literal">materialize</code> および <code class="literal">materialized-subquery</code> が含まれます。
            </p></li></ul></div><p>
          MySQL 8.0.21 以降では、MySQL は、単一テーブル <code class="literal">UPDATE</code> へ、または<code class="literal">[NOT] IN</code> または<code class="literal">[NOT] EXISTS</code> サブクエリー述語を使用する <code class="literal">DELETE</code> ステートメントへサブクエリー実体化が、ステートメントが <code class="literal">ORDER BY</code> または <code class="literal">LIMIT</code> を使用せず、およびサブクエリーの実体化がオプティマイザヒントにより、または <code class="literal">optimizer_switch</code> 設定により許可されていれば、提供できます。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="subquery-optimization-with-exists"></a>8.2.2.3 EXISTS 戦略を使用したサブクエリーの最適化</h4></div></div></div><a class="indexterm" name="idm45661479372352"></a><a class="indexterm" name="idm45661479370208"></a><p>
          特定の最適化は、<code class="literal">IN</code> (または <code class="literal">=ANY</code>) 演算子を使用してサブクエリーの結果をテストする比較に適用できます。 このセクションでは、これらの最適化について、特に <code class="literal">NULL</code> 値が存在する課題に関して説明します。 この説明の最後の部分では、オプティマイザの支援方法を示します。 
        </p><p>
          次のようなサブクエリーの比較を考慮します。
        </p><pre class="programlisting"><em class="replaceable"><code>outer_expr</code></em> IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
          MySQL は<span class="quote">「<span class="quote">外側から内側に</span>」</span>クエリーを評価します。 つまり、まず外側の式 <em class="replaceable"><code>outer_expr</code></em> の値を取得してから、サブクエリーを実行し、それによって生成される行を取得します。 
        </p><p>
          内側の式 <em class="replaceable"><code>inner_expr</code></em> が <em class="replaceable"><code>outer_expr</code></em> と等しい行だけが目的の行であることをサブクエリーに<span class="quote">「<span class="quote">通知する</span>」</span>ことは、かなり役に立つ最適化です。 これを行うには、サブクエリーの <code class="literal">WHERE</code> 句に適切な等価をプッシュダウンして、より限定的にします。 変換された比較は次のようになります: 
        </p><pre class="programlisting">EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em> AND <em class="replaceable"><code>outer_expr</code></em>=<em class="replaceable"><code>inner_expr</code></em>)
</pre><p>
          変換後、MySQL はプッシュダウンされた等価を使用して、サブクエリーを評価するために調査する必要がある行数を制限できます。
        </p><p>
          より一般的には、<em class="replaceable"><code>N</code></em> 個の値と <em class="replaceable"><code>N</code></em> 値の行を返すサブクエリーとの比較は、同じ変換の対象になります。 <em class="replaceable"><code>oe_i</code></em> と <em class="replaceable"><code>ie_i</code></em> が対応する外側と内側の式の値を表す場合、次のサブクエリー比較は: 
        </p><pre class="programlisting">(<em class="replaceable"><code>oe_1</code></em>, ..., <em class="replaceable"><code>oe_N</code></em>) IN
  (SELECT <em class="replaceable"><code>ie_1</code></em>, ..., <em class="replaceable"><code>ie_N</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
          次のようになります。
        </p><pre class="programlisting">EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>
                          AND <em class="replaceable"><code>oe_1</code></em> = <em class="replaceable"><code>ie_1</code></em>
                          AND ...
                          AND <em class="replaceable"><code>oe_N</code></em> = <em class="replaceable"><code>ie_N</code></em>)
</pre><p>
          簡単にするために、次の説明では、外部式と内部式の値の単一のペアを想定しています。
        </p><p>
          前述の<span class="quote">「<span class="quote">「プッシュダウン」</span>」</span>戦略は、次のいずれかの条件に該当する場合に機能します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <em class="replaceable"><code>outer_expr</code></em> と <em class="replaceable"><code>inner_expr</code></em> は <code class="literal">NULL</code> にできません。
            </p></li><li class="listitem"><p>
              <code class="literal">NULL</code> と <code class="literal">FALSE</code> サブクエリーの結果を区別する必要はありません。 サブクエリーが <code class="literal">WHERE</code> 句の <code class="literal">OR</code> 式または <code class="literal">AND</code> 式の一部である場合、MySQL では考慮されないものとみなされます。 オプティマイザが <code class="literal">NULL</code> と <code class="literal">FALSE</code> サブクエリーの結果を区別する必要がないことに気付いた別のインスタンスは、次の構成です: 
            </p><pre class="programlisting">... WHERE <em class="replaceable"><code>outer_expr</code></em> IN (<em class="replaceable"><code>subquery</code></em>)
</pre><p>
              この場合、<code class="literal">IN (<em class="replaceable"><code>subquery</code></em>)</code> が <code class="literal">NULL</code> または <code class="literal">FALSE</code> を返すかどうかにかかわらず、<code class="literal">WHERE</code> 句は行を拒否します。
            </p></li></ul></div><p>
          <em class="replaceable"><code>outer_expr</code></em> は <code class="literal">NULL</code> 以外の値であることがわかっているが、サブクエリーは <em class="replaceable"><code>outer_expr</code></em> = <em class="replaceable"><code>inner_expr</code></em> となるような行を生成しないものとします。 その場合、<code class="literal"><em class="replaceable"><code>outer_expr</code></em> IN (SELECT ...)</code> は次のように評価されます。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <em class="replaceable"><code>inner_expr</code></em> が <code class="literal">NULL</code> である行を <code class="literal">SELECT</code> が生成する場合は <code class="literal">NULL</code>
            </p></li><li class="listitem"><p>
              <code class="literal">SELECT</code> が <code class="literal">NULL</code> 以外の値のみを生成するかまたは何も生成しない場合は <code class="literal">FALSE</code>
            </p></li></ul></div><p>
          この状況では、<code class="literal"><em class="replaceable"><code>outer_expr</code></em> = <em class="replaceable"><code>inner_expr</code></em></code> である行を探すアプローチは有効でなくなります。 そのような行を探すことは必要ですが、何も見つからない場合には、<em class="replaceable"><code>inner_expr</code></em> が <code class="literal">NULL</code> となる行も探します。 概して言えば、サブクエリーは次のように変換できます: 
        </p><pre class="programlisting">EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em> AND
        (<em class="replaceable"><code>outer_expr</code></em>=<em class="replaceable"><code>inner_expr</code></em> OR <em class="replaceable"><code>inner_expr</code></em> IS NULL))
</pre><p>
          追加の <code class="literal">IS NULL</code> 条件を評価する必要性は、MySQL に <code class="literal">ref_or_null</code> アクセスメソッドがある理由です。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN</code></strong>
       <strong class="userinput"><code>SELECT <em class="replaceable"><code>outer_expr</code></em> IN (SELECT t2.maybe_null_key</code></strong>
                             <strong class="userinput"><code>FROM t2, t3 WHERE ...)</code></strong>
       <strong class="userinput"><code>FROM t1;</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: t1
...
*************************** 2. row ***************************
           id: 2
  select_type: DEPENDENT SUBQUERY
        table: t2
         type: ref_or_null
possible_keys: maybe_null_key
          key: maybe_null_key
      key_len: 5
          ref: func
         rows: 2
        Extra: Using where; Using index
...
</pre><p>
          <code class="literal">unique_subquery</code> および <code class="literal">index_subquery</code> サブクエリー固有のアクセスメソッドには <span class="quote">「<span class="quote">or <code class="literal">NULL</code></span>」</span> バリアントもあります。
        </p><p>
          追加の <code class="literal">OR ... IS NULL</code> 条件によってクエリーの実行は多少複雑になり、サブクエリー内の最適化の一部も適用できなくなりますが、通常これは許容できます。
        </p><p>
          <em class="replaceable"><code>outer_expr</code></em> が <code class="literal">NULL</code> になる可能性がある場合、状況ははるかに悪くなります。 <span class="quote">「<span class="quote">不明な値</span>」</span>としての <code class="literal">NULL</code> の SQL の解釈によると、<code class="literal">NULL IN (SELECT <em class="replaceable"><code>inner_expr</code></em> ...)</code> は次のように評価されるはずです。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">SELECT</code> が何らかの行を生成する場合は <code class="literal">NULL</code>
            </p></li><li class="listitem"><p>
              <code class="literal">SELECT</code> が行を生成しない場合は <code class="literal">FALSE</code>
            </p></li></ul></div><p>
          正しい評価には、<code class="literal">SELECT</code> がとにかく何らかの行を生成したかどうかを確認できるようにする必要があるため、<code class="literal"><em class="replaceable"><code>outer_expr</code></em> = <em class="replaceable"><code>inner_expr</code></em></code> をサブクエリーにプッシュダウンすることはできません。 等価をプッシュダウンできないかぎり、多くの実世界のサブクエリーが非常に遅くなるため、これは問題です。 
        </p><p>
          基本的に、<em class="replaceable"><code>outer_expr</code></em> の値に応じて、サブクエリーを実行するさまざまな方法が存在する必要があります。
        </p><p>
          オプティマイザは速度よりも SQL 準拠を選択するため、<em class="replaceable"><code>outer_expr</code></em> が <code class="literal">NULL</code> である可能性があります:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <em class="replaceable"><code>outer_expr</code></em> が <code class="literal">NULL</code> の場合、次の式を評価するには、<code class="literal">SELECT</code> を実行して行を生成するかどうかを判断する必要があります:
            </p><pre class="programlisting">NULL IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
              前述の種類と同等にプッシュダウンせずに、ここで元の <code class="literal">SELECT</code> を実行する必要があります。
            </p></li><li class="listitem"><p>
              一方、<em class="replaceable"><code>outer_expr</code></em> が <code class="literal">NULL</code> でない場合、次の比較が絶対に必要です:
            </p><pre class="programlisting"><em class="replaceable"><code>outer_expr</code></em> IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
              プッシュダウン条件を使用する次の式に変換する必要があります:
            </p><pre class="programlisting">EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em> AND <em class="replaceable"><code>outer_expr</code></em>=<em class="replaceable"><code>inner_expr</code></em>)
</pre><p>
              この変換を行わないと、サブクエリーは遅くなります。
            </p></li></ul></div><p>
          条件をサブクエリーにプッシュダウンするかどうかの問題を解決するために、条件は <span class="quote">「<span class="quote">trigger</span>」</span> 関数内にラップされます。 したがって、次の形式の式は: 
        </p><pre class="programlisting"><em class="replaceable"><code>outer_expr</code></em> IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
          次に変換されます:
        </p><pre class="programlisting">EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>
                          AND trigcond(<em class="replaceable"><code>outer_expr</code></em>=<em class="replaceable"><code>inner_expr</code></em>))
</pre><p>
          より一般的には、サブクエリーの比較が外側の式と内側の式の複数のペアに基づく場合、変換は次の比較をします。
        </p><pre class="programlisting">(<em class="replaceable"><code>oe_1</code></em>, ..., <em class="replaceable"><code>oe_N</code></em>) IN (SELECT <em class="replaceable"><code>ie_1</code></em>, ..., <em class="replaceable"><code>ie_N</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
          これを次の式に変換します:
        </p><pre class="programlisting">EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>
                          AND trigcond(<em class="replaceable"><code>oe_1</code></em>=<em class="replaceable"><code>ie_1</code></em>)
                          AND ...
                          AND trigcond(<em class="replaceable"><code>oe_N</code></em>=<em class="replaceable"><code>ie_N</code></em>)
       )
</pre><p>
          各 <code class="literal">trigcond(<em class="replaceable"><code>X</code></em>)</code> は、次の値に評価される特殊な関数です。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <span class="quote">「<span class="quote">リンクされた</span>」</span>外側の式 <em class="replaceable"><code>oe_i</code></em> が <code class="literal">NULL</code> でない場合は <em class="replaceable"><code>X</code></em>
            </p></li><li class="listitem"><p>
              <span class="quote">「<span class="quote">リンクされた</span>」</span>外側の式 <em class="replaceable"><code>oe_i</code></em> が <code class="literal">NULL</code> の場合は <code class="literal">TRUE</code>
            </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            トリガー関数は、<code class="literal">CREATE TRIGGER</code> で作成する種類のトリガーではありません。
          </p></div><p>
          <code class="literal">trigcond()</code> 関数内でラップされる等価は、クエリーオプティマイザのファーストクラス述語ではありません。 ほとんどの最適化では、クエリーの実行時にオンまたはオフになる可能性のある述語を処理できないため、<code class="literal">trigcond(<em class="replaceable"><code>X</code></em>)</code> をすべて不明な関数であるとみなし、無視します。 トリガーされた等価は、次の最適化で使用できます: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              参照の最適化: <code class="literal">trigcond(<em class="replaceable"><code>X</code></em>=<em class="replaceable"><code>Y</code></em> [OR <em class="replaceable"><code>Y</code></em> IS NULL])</code> を使用して、<code class="literal">ref</code>、<code class="literal">eq_ref</code>、または <code class="literal">ref_or_null</code> テーブルアクセスを構築できます。
            </p></li><li class="listitem"><p>
              インデックスルックアップベースのサブクエリー実行エンジン: <code class="literal">trigcond(<em class="replaceable"><code>X</code></em>=<em class="replaceable"><code>Y</code></em>)</code> を使用して、<code class="literal">unique_subquery</code> または <code class="literal">index_subquery</code> アクセスを構築できます。
            </p></li><li class="listitem"><p>
              テーブル条件ジェネレータ: サブクエリーが複数のテーブルの結合である場合、トリガーされた条件はできるだけ早くチェックされます。
            </p></li></ul></div><p>
          オプティマイザがトリガー条件を使用して、何らかの種類のインデックスルックアップベースのアクセスを作成する場合 (上記リストの最初の 2 項目に関して)、条件がオフである場合のフォールバック戦略が必要です。 このフォールバック戦略は常に同じで、フルテーブルスキャンを実行します。 <code class="literal">EXPLAIN</code> の出力で、フォールバックは <code class="literal">Extra</code> カラムに <code class="literal">Full scan on NULL key</code> と表示されます。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT t1.col1,</code></strong>
       <strong class="userinput"><code>t1.col1 IN (SELECT t2.key1 FROM t2 WHERE t2.col2=t1.col2) FROM t1\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: t1
        ...
*************************** 2. row ***************************
           id: 2
  select_type: DEPENDENT SUBQUERY
        table: t2
         type: index_subquery
possible_keys: key1
          key: key1
      key_len: 5
          ref: func
         rows: 2
        Extra: Using where; Full scan on NULL key
</pre><p>
          <code class="literal">EXPLAIN</code> の後に <code class="literal">SHOW WARNINGS</code> を実行すると、トリガーされた条件が表示されます:
        </p><pre class="programlisting">*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: select `test`.`t1`.`col1` AS `col1`,
         &lt;in_optimizer&gt;(`test`.`t1`.`col1`,
         &lt;exists&gt;(&lt;index_lookup&gt;(&lt;cache&gt;(`test`.`t1`.`col1`) in t2
         on key1 checking NULL
         where (`test`.`t2`.`col2` = `test`.`t1`.`col2`) having
         trigcond(&lt;is_not_null_test&gt;(`test`.`t2`.`key1`))))) AS
         `t1.col1 IN (select t2.key1 from t2 where t2.col2=t1.col2)`
         from `test`.`t1`
</pre><p>
          トリガー条件を使用すると、パフォーマンスに多少の影響があります。 現在 <code class="literal">NULL IN (SELECT ...)</code> 式では、以前に実行されなかった (遅い) フルテーブルスキャンが行われる可能性があります。 これは、正しい結果を得るために支払われる価格です (トリガー条件戦略の目的は、速度ではなくコンプライアンスを向上させることです)。 
        </p><p>
          複数テーブルサブクエリーの場合、結合オプティマイザは外部式が <code class="literal">NULL</code> の場合に最適化しないため、<code class="literal">NULL IN (SELECT ...)</code> の実行は特に遅くなります。 それは、左辺が <code class="literal">NULL</code> の場合のサブクエリーの評価はめったにないものと想定しています (そうでないことを示す統計があっても)。 一方、外側の式が <code class="literal">NULL</code> になる可能性があっても実際にそうなることがない場合、パフォーマンスの低下はありません。 
        </p><p>
          クエリーオプティマイザがクエリーをより効率的に実行できるようにするには、次の提案を使用します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              カラムが実際に <code class="literal">NOT NULL</code> である場合は、そのように宣言します。 これは、カラムの条件テストを簡略化することでオプティマイザの他の側面にも役立ちます。 
            </p></li><li class="listitem"><p>
              <code class="literal">NULL</code> と <code class="literal">FALSE</code> サブクエリーの結果を区別する必要がない場合は、実行速度の低下を簡単に回避できます。 次のような比較を置き換えます。 
            </p><pre class="programlisting"><em class="replaceable"><code>outer_expr</code></em> [NOT] IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ...)
</pre><p>
              次の式で:
            </p><pre class="programlisting">(<em class="replaceable"><code>outer_expr</code></em> IS NOT NULL) AND (<em class="replaceable"><code>outer_expr</code></em> [NOT] IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ...))
</pre><p>
              式の結果が明らかになるとすぐに MySQL が <code class="literal">AND</code> 部分の評価を停止するため、<code class="literal">NULL IN (SELECT ...)</code> は評価されません。
            </p><p>
              別のリライトも可能です:
            </p><pre class="programlisting">[NOT] EXISTS (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ...
        WHERE <em class="replaceable"><code>inner_expr</code></em>=<em class="replaceable"><code>outer_expr</code></em>)
</pre></li></ul></div><p>
          <code class="literal">optimizer_switch</code> システム変数の <code class="literal">subquery_materialization_cost_based</code> フラグを使用すると、サブクエリー実体化と <code class="literal">IN</code> から <code class="literal">EXISTS</code> へのサブクエリー変換の選択を制御できます。 <a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2 切り替え可能な最適化">セクション8.9.2「切り替え可能な最適化」</a>を参照してください。 
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="derived-table-optimization"></a>8.2.2.4 マージまたは実体化を使用した導出テーブル、ビュー参照および共通テーブル式の最適化</h4></div></div></div><a class="indexterm" name="idm45661479191184"></a><a class="indexterm" name="idm45661479189072"></a><a class="indexterm" name="idm45661479187040"></a><a class="indexterm" name="idm45661479184992"></a><a class="indexterm" name="idm45661479182944"></a><a class="indexterm" name="idm45661479180896"></a><a class="indexterm" name="idm45661479178848"></a><a class="indexterm" name="idm45661479176800"></a><a class="indexterm" name="idm45661479174752"></a><p>
          オプティマイザは、次の 2 つの戦略を使用して導出テーブル参照を処理できます (ビュー参照および共通テーブル式にも適用されます):
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              導出テーブルの外部クエリーブロックへのマージ
            </p></li><li class="listitem"><p>
              導出テーブルを内部一時テーブルに実体化
            </p></li></ul></div><p>
          例 1:
        </p><pre class="programlisting">SELECT * FROM (SELECT * FROM t1) AS derived_t1;
</pre><p>
          導出テーブル <code class="literal">derived_t1</code> のマージでは、そのクエリーは次のように実行されます:
        </p><pre class="programlisting">SELECT * FROM t1;
</pre><p>
          例 2:
        </p><pre class="programlisting">SELECT *
  FROM t1 JOIN (SELECT t2.f1 FROM t2) AS derived_t2 ON t1.f2=derived_t2.f1
  WHERE t1.f1 &gt; 0;
</pre><p>
          導出テーブル <code class="literal">derived_t2</code> のマージでは、そのクエリーは次のように実行されます:
        </p><pre class="programlisting">SELECT t1.*, t2.f1
  FROM t1 JOIN t2 ON t1.f2=t2.f1
  WHERE t1.f1 &gt; 0;
</pre><p>
          実体化では、<code class="literal">derived_t1</code> と <code class="literal">derived_t2</code> はそれぞれ、それぞれのクエリー内で個別のテーブルとして扱われます。
        </p><p>
          オプティマイザは、導出テーブル、ビュー参照および共通テーブル式を同様に処理: これにより、可能なかぎり不要な実体化が回避され、外部クエリーから導出テーブルへの条件のプッシュダウンが可能になり、より効率的な実行計画が生成されます。 (例については、<a class="xref" href="optimization.html#subquery-materialization" title="8.2.2.2 実体化を使用したサブクエリーの最適化">セクション8.2.2.2「実体化を使用したサブクエリーの最適化」</a>を参照してください。) 
        </p><p>
          マージによって 61 を超える実テーブルを参照する外部クエリーブロックが生成される場合、オプティマイザはかわりに実体化を選択します。
        </p><p>
          次の条件がすべて満たされている場合、オプティマイザは導出テーブルまたはビュー参照の <code class="literal">ORDER BY</code> 句を外部クエリーブロックに伝播します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              外部クエリーはグループ化または集計されません。
            </p></li><li class="listitem"><p>
              外部クエリーでは、<code class="literal">DISTINCT</code>、<code class="literal">HAVING</code> または <code class="literal">ORDER BY</code> は指定されません。
            </p></li><li class="listitem"><p>
              外部クエリーでは、この導出テーブルまたはビュー参照が <code class="literal">FROM</code> 句の唯一のソースとして使用されます。
            </p></li></ul></div><p>
          それ以外の場合、オプティマイザは <code class="literal">ORDER BY</code> 句を無視します。
        </p><p>
          オプティマイザが導出テーブル、ビュー参照および共通テーブル式を外部クエリーブロックにマージしようとするかどうかに影響を与えるために、次の方法を使用できます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">MERGE</code> および <code class="literal">NO_MERGE</code> オプティマイザヒントを使用できます。 マージを妨げる他のルールがないことを前提としています。 <a class="xref" href="optimization.html#optimizer-hints" title="8.9.3 オプティマイザヒント">セクション8.9.3「オプティマイザヒント」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              同様に、<code class="literal">optimizer_switch</code> システム変数の <code class="literal">derived_merge</code> フラグを使用できます。 <a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2 切り替え可能な最適化">セクション8.9.2「切り替え可能な最適化」</a>を参照してください。 デフォルトでは、このフラグはマージを許可するように有効になっています。 フラグを無効にすると、マージが回避され、<code class="literal">ER_UPDATE_TABLE_USED</code> エラーが回避されます。 
            </p><p>
              <code class="literal">derived_merge</code> フラグは、<code class="literal">ALGORITHM</code> 句を含まないビューにも適用されます。 したがって、サブクエリーと同等の式を使用するビュー参照に対して <code class="literal">ER_UPDATE_TABLE_USED</code> エラーが発生した場合、ビュー定義に <code class="literal">ALGORITHM=TEMPTABLE</code> を追加するとマージが回避され、<code class="literal">derived_merge</code> 値よりも優先されます。 
            </p></li><li class="listitem"><p>
              マージを妨げる構造体はサブクエリーで使用することでマージを無効にできますが、実体化への影響では明示的ではありません。 マージが行われないようにする構成は、導出テーブル、共通テーブル式およびビュー参照で同じです: 
            </p><div class="itemizedlist"><a class="indexterm" name="idm45661479131632"></a><a class="indexterm" name="idm45661479129504"></a><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  集計関数またはウィンドウ関数 (<code class="literal">SUM()</code>, <code class="literal">MIN()</code>, <code class="literal">MAX()</code>, <code class="literal">COUNT()</code> など)
                </p></li><li class="listitem"><p>
                  <code class="literal">DISTINCT</code>
                </p></li><li class="listitem"><p>
                  <code class="literal">GROUP BY</code>
                </p></li><li class="listitem"><p>
                  <code class="literal">HAVING</code>
                </p></li><li class="listitem"><p>
                  <code class="literal">LIMIT</code>
                </p></li><li class="listitem"><p>
                  <code class="literal">UNION</code> または <code class="literal">UNION ALL</code>
                </p></li><li class="listitem"><p>
                  選択リストのサブクエリー
                </p></li><li class="listitem"><p>
                  ユーザー変数への割当て
                </p></li><li class="listitem"><p>
                  リテラル値のみを参照します (この場合、基礎となるテーブルはありません)
                </p></li></ul></div></li></ul></div><p>
          オプティマイザが導出テーブルのマージではなく実体化戦略を選択した場合、クエリーは次のように処理されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              オプティマイザは、クエリーの実行中にその内容が必要になるまで、導出テーブルの実体化を延期します。 これにより、実体化の遅延によってパフォーマンスが向上する可能性があるため、パフォーマンスが向上します。 導出テーブルの結果を別のテーブルに結合するクエリーについて考えます: オプティマイザが最初に他のテーブルを処理し、行を戻さないことが判明した場合、結合をさらに実行する必要はなく、オプティマイザは導出テーブルの実体化を完全にスキップできます。 
            </p></li><li class="listitem"><p>
              クエリー実行中に、オプティマイザは派生テーブルにインデックスを追加して、そこからの行の取得を高速化できます。
            </p></li></ul></div><p>
          導出テーブルを含む <code class="literal">SELECT</code> クエリーについて、次の <code class="literal">EXPLAIN</code> ステートメントを考えてみます:
        </p><pre class="programlisting">EXPLAIN SELECT * FROM (SELECT * FROM t1) AS derived_t1;
</pre><p>
          オプティマイザは、<code class="literal">SELECT</code> の実行中に結果が必要になるまで導出テーブルを遅延させることで、導出テーブルの実体化を回避します。 この場合、(<code class="literal">EXPLAIN</code> ステートメントで発生するため) クエリーは実行されないため、結果は必要ありません。 
        </p><p>
          実行されるクエリーの場合でも、導出テーブルの実体化の遅延により、オプティマイザは実体化を完全に回避できます。 これが発生すると、クエリー実行は実体化の実行に必要な時間が短縮されます。 導出テーブルの結果を別のテーブルに結合する次のクエリーについて考えてみます: 
        </p><pre class="programlisting">SELECT *
  FROM t1 JOIN (SELECT t2.f1 FROM t2) AS derived_t2
          ON t1.f2=derived_t2.f1
  WHERE t1.f1 &gt; 0;
</pre><p>
          最適化が最初に <code class="literal">t1</code> を処理し、<code class="literal">WHERE</code> 句で空の結果が生成される場合、結合は空である必要があり、導出テーブルを実体化する必要はありません。
        </p><p>
          導出テーブルに実体化が必要な場合は、オプティマイザによって実体化ビューにインデックスが追加され、アクセスが高速化される可能性があります。 このようなインデックスによってテーブルへの <code class="literal">ref</code> アクセスが可能になると、クエリーの実行中に読み取られるデータ量を大幅に削減できます。 次のクエリーを考慮してください。 
        </p><pre class="programlisting">SELECT *
 FROM t1 JOIN (SELECT DISTINCT f1 FROM t2) AS derived_t2
         ON t1.f1=derived_t2.f1;
</pre><p>
          オプティマイザは、コストが最も低い実行計画に対して <code class="literal">ref</code> アクセスを使用できるようにする場合、<code class="literal">derived_t2</code> からカラム <code class="literal">f1</code> に対するインデックスを構成します。 インデックスを追加した後、オプティマイザは実体化導出テーブルをインデックス付きの通常のテーブルと同様に処理でき、生成されたインデックスと同様の利点があります。 インデックス作成のオーバーヘッドは、インデックスを使用しないクエリー実行のコストと比較して無視できます。 <code class="literal">ref</code> アクセスによって他のアクセス方法よりコストが高くなる場合、オプティマイザはインデックスを作成せず、何も失われません。 
        </p><p>
          オプティマイザトレース出力の場合、マージされた導出テーブルまたはビュー参照はノードとして表示されません。 最上位のクエリー計画には、基礎となるテーブルのみが表示されます。 
        </p><p>
          導出テーブルの実体化に関して正しい記述は、共通テーブル式 (CTE) についても当てはまります。 さらに、CTE には特に次の考慮事項があります。 
        </p><p>
          CTE がクエリーによって実体化されている場合、クエリーが複数回参照していても、その CTE はクエリーに対して 1 回実体化されます。
        </p><p>
          再帰 CTE は常に実体化されます。
        </p><p>
          CTE が実体化されている場合、オプティマイザは、トップレベルのステートメントによる CTE へのアクセスを高速化できると予想すると、関連するインデックスを自動的に追加します。 これは導出テーブルの自動インデックス付けと似ていますが、CTE が複数回参照される場合、オプティマイザは複数のインデックスを作成して、各参照によるアクセスを最適な方法で高速化できます。 
        </p><p>
          CTE には、<code class="literal">MERGE</code> および <code class="literal">NO_MERGE</code> オプティマイザヒントを適用できます。 トップレベルのステートメントの各 CTE 参照には独自のヒントを指定でき、CTE 参照を選択的にマージまたは実体化できます。 次のステートメントは、ヒントを使用して、<code class="literal">cte1</code> をマージし、<code class="literal">cte2</code> を実体化する必要があることを示します: 
        </p><pre class="programlisting">WITH
  cte1 AS (SELECT a, b FROM table1),
  cte2 AS (SELECT c, d FROM table2)
SELECT /*+ MERGE(cte1) NO_MERGE(cte2) */ cte1.b, cte2.d
FROM cte1 JOIN cte2
WHERE cte1.a = cte2.c;
</pre><p>
          <code class="literal">CREATE VIEW</code> の <code class="literal">ALGORITHM</code> 句は、ビュー定義の <code class="literal">SELECT</code> ステートメントの前にある <code class="literal">WITH</code> 句の実体化には影響しません。 次のステートメントがあるとします。 
        </p><pre class="programlisting">CREATE ALGORITHM={TEMPTABLE|MERGE} VIEW v1 AS WITH ... SELECT ...
</pre><p>
          <code class="literal">ALGORITHM</code> 値は、<code class="literal">WITH</code> 句ではなく、<code class="literal">SELECT</code> の実体化にのみ影響します。
        </p><p>
          MySQL 8.0.16 より前では、<code class="literal">internal_tmp_disk_storage_engine=MYISAM</code> でディスク上の一時テーブルを使用して CTE を実体化しようとすると、CTE の場合、ディスク上の内部一時テーブルに使用されるストレージエンジンを <code class="literal">MyISAM</code> にできなかったため、エラーが発生しました。 MySQL 8.0.16 以降、<code class="literal">TempTable</code> ではディスク上の内部一時テーブルに <code class="literal">InnoDB</code> が常に使用されるようになったため、これは問題ではなくなりました。 
        </p><p>
          前述のように、CTE(実体化されている場合) は、複数回参照されていても実体化されます。 一時的な実体化を示すために、オプティマイザトレース出力には、<code class="literal">creating_tmp_table</code> のオカレンスと <code class="literal">reusing_tmp_table</code> のオカレンスが含まれます。 
        </p><p>
          CTE は、<code class="literal">materialized_from_subquery</code> ノードが参照に従う導出テーブルに似ています。 これは、複数回参照される CTE に当てはまるため、<code class="literal">materialized_from_subquery</code> ノードの複製はありません (これにより、サブクエリーが複数回実行され、不必要に冗長な出力が生成されるインプレッションが提供されます)。 CTE への参照には、サブクエリー計画の説明を含む完全な <code class="literal">materialized_from_subquery</code> ノードのみが含まれます。 その他の参照では、<code class="literal">materialized_from_subquery</code> ノードが削減されます。 <code class="literal">TRADITIONAL</code> 形式の <code class="literal">EXPLAIN</code> 出力にも同じ考えが適用されます: 他の参照のサブクエリーは表示されません。 
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="derived-condition-pushdown-optimization"></a>8.2.2.5 導出条件プッシュダウン最適化</h4></div></div></div><a class="indexterm" name="idm45661479054144"></a><a class="indexterm" name="idm45661479052688"></a><p>
          MySQL 8.0.22 以降では、適格なサブクエリーの導出条件プッシュダウンがサポートされています。 <code class="literal">SELECT * FROM (SELECT i, j FROM t1) AS dt WHERE i &gt; <em class="replaceable"><code>constant</code></em></code> などのクエリーでは、多くの場合、外部 <code class="literal">WHERE</code> 条件を導出テーブルにプッシュダウンできます (この場合、<code class="literal">SELECT * FROM (SELECT i, j FROM t1 WHERE i &gt; <em class="replaceable"><code>constant</code></em>) AS dt</code> になります)。 導出テーブルを外部クエリーにマージできない場合 (導出テーブルで集計が使用されている場合など)、外部 <code class="literal">WHERE</code> 条件を導出テーブルにプッシュダウンすると、処理する必要がある行数が減り、クエリーの実行が高速化されます。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            MySQL 8.0.22 より前では、導出テーブルが実体化されているがマージされていない場合、MySQL はテーブル全体を実体化し、結果のすべての行を <code class="literal">WHERE</code> 条件で修飾していました。 これは、導出条件プッシュダウンが有効になっていない場合や、なんらかの理由で採用できない場合にも当てはまります。 
          </p></div><p>
          次の状況では、外部 <code class="literal">WHERE</code> 条件を導出実体化テーブルにプッシュダウンできます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              導出テーブルで集計関数またはウィンドウ関数が使用されていない場合は、外部 <code class="literal">WHERE</code> 条件を直接プッシュダウンできます。 これには、<code class="literal">AND</code>、<code class="literal">OR</code> またはその両方と結合された複数の述語を持つ <code class="literal">WHERE</code> 条件が含まれます。 
            </p><p>
              たとえば、クエリー <code class="literal">SELECT * FROM (SELECT f1, f2 FROM t1) AS dt WHERE f1 &lt; 3 AND f2 &gt; 11</code> は <code class="literal">SELECT f1, f2 FROM (SELECT f1, f2 FROM t1 WHERE f1 &lt; 3 AND f2 &gt; 11) AS dt</code> としてリライトされます。
            </p></li><li class="listitem"><p>
              導出テーブルに <code class="literal">GROUP BY</code> があり、ウィンドウ関数を使用しない場合、<code class="literal">GROUP BY</code> の一部ではない 1 つ以上のカラムを参照する外部 <code class="literal">WHERE</code> 条件を <code class="literal">HAVING</code> 条件として導出テーブルにプッシュダウンできます。
            </p><p>
              たとえば、<code class="literal">SELECT * FROM (SELECT i, j, SUM(k) AS sum FROM t1 GROUP BY i, j) AS dt WHERE sum &gt; 100</code> は、導出条件プッシュダウンに従って <code class="literal">SELECT * FROM (SELECT i, j, SUM(k) AS sum FROM t1 GROUP BY i, j HAVING sum &gt; 100) AS dt</code> としてリライトされます。
            </p></li><li class="listitem"><p>
              導出テーブルで <code class="literal">GROUP BY</code> が使用され、外部 <code class="literal">WHERE</code> 条件のカラムが <code class="literal">GROUP BY</code> カラムの場合、これらのカラムを参照する <code class="literal">WHERE</code> 条件を導出テーブルに直接プッシュダウンできます。
            </p><p>
              たとえば、クエリー <code class="literal">SELECT * FROM (SELECT i,j, SUM(k) AS sum FROM t1 GROUP BY i,j) AS dt WHERE i &gt; 10</code> は <code class="literal">SELECT * FROM (SELECT i,j, SUM(k) AS sum FROM t1 WHERE i &gt; 10 GROUP BY i,j) AS dt</code> としてリライトされます。
            </p><p>
              外部 <code class="literal">WHERE</code> 条件に、<code class="literal">GROUP BY</code> の一部であるカラムを参照する述語とそうでないカラムを参照する述語がある場合、前のソートの述語は <code class="literal">WHERE</code> 条件としてプッシュダウンされ、後者のタイプの述語は <code class="literal">HAVING</code> 条件としてプッシュダウンされます。 たとえば、クエリー <code class="literal">SELECT * FROM (SELECT i, j, SUM(k) AS sum FROM t1 GROUP BY i,j) AS dt WHERE i &gt; 10 AND sum &gt; 100</code> では、外部 <code class="literal">WHERE</code> 句の述語 <code class="literal">i &gt; 10</code> は <code class="literal">GROUP BY</code> カラムを参照しますが、述語 <code class="literal">sum &gt; 100</code> は <code class="literal">GROUP BY</code> カラムを参照しません。 このため、導出テーブルプッシュダウン最適化によって、クエリーは次に示すような方法でリライトされます: 
            </p><pre class="programlisting">SELECT * FROM (
    SELECT i, j, SUM(k) AS sum FROM t1
        WHERE i &gt; 10
        GROUP BY i, j
        HAVING sum &gt; 100
    ) AS dt;
</pre></li></ul></div><p>
          導出条件プッシュダウンを有効にするには、<code class="literal">optimizer_switch</code> システム変数の <code class="literal">derived_condition_pushdown</code> フラグ (このリリースで追加) を <code class="literal">on</code> (デフォルト設定) に設定する必要があります。 この最適化が <code class="literal">optimizer_switch</code> によって無効化されている場合は、<code class="literal">DERIVED_CONDITION_PUSHDOWN</code> オプティマイザヒントを使用して特定のクエリーに対して有効化できます。 特定のクエリーの最適化を無効にするには、<code class="literal">NO_DERIVED_CONDITION_PUSHDOWN</code> オプティマイザヒントを使用します。 
        </p><p>
          導出テーブル条件プッシュダウン最適化には、次の制限事項および制限事項が適用されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              導出テーブルに <code class="literal">UNION</code> が含まれている場合、最適化は使用できません。
            </p></li><li class="listitem"><p>
              導出テーブルでは <code class="literal">LIMIT</code> 句を使用できません。
            </p></li><li class="listitem"><p>
              サブクエリーを含む条件はプッシュダウンできません。
            </p></li><li class="listitem"><p>
              導出テーブルが外部結合の内部テーブルである場合、最適化は使用できません。
            </p></li><li class="listitem"><p>
              実体化導出テーブルが共通テーブル式である場合、条件が複数回参照されても条件はプッシュされません。
            </p></li><li class="listitem"><p>
              条件が <code class="literal"><em class="replaceable"><code>derived_column</code></em> &gt; ?</code> 形式の場合は、パラメータを使用して条件をプッシュダウンできます。 外部 <code class="literal">WHERE</code> 条件の導出カラムが、基礎となる導出テーブルに <code class="literal">?</code> を持つ式である場合、この条件はプッシュダウンできません。 
            </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="information-schema-optimization"></a>8.2.3 INFORMATION_SCHEMA クエリーの最適化</h3></div></div></div><a class="indexterm" name="idm45661478993088"></a><a class="indexterm" name="idm45661478990928"></a><p>
        データベースを監視するアプリケーションでは、<code class="literal">INFORMATION_SCHEMA</code> テーブルを頻繁に使用できます。 これらのテーブルに対するクエリーを最も効率的に記述するには、次の一般的なガイドラインを使用します: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            データディクショナリテーブルのビューである <code class="literal">INFORMATION_SCHEMA</code> テーブルのみのクエリーを試行します。
          </p></li><li class="listitem"><p>
            静的メタデータのみのクエリーを試行してください。 動的メタデータのカラムを選択するか、取得条件を静的メタデータとともに使用すると、動的メタデータを処理するためのオーバーヘッドが増加します。 
          </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">INFORMATION_SCHEMA</code> クエリーでのデータベース名とテーブル名の比較動作は、予想とは異なる場合があります。 詳細は、<a class="xref" href="charset.html#charset-collation-information-schema" title="10.8.7 INFORMATION_SCHEMA 検索での照合の使用">セクション10.8.7「INFORMATION_SCHEMA 検索での照合の使用」</a>を参照してください。 
        </p></div><p>
        これらの <code class="literal">INFORMATION_SCHEMA</code> テーブルはデータディクショナリテーブルのビューとして実装されるため、これらのテーブルに対するクエリーではデータディクショナリから情報が取得されます:
      </p><pre class="programlisting">CHARACTER_SETS
CHECK_CONSTRAINTS
COLLATIONS
COLLATION_CHARACTER_SET_APPLICABILITY
COLUMNS
EVENTS
FILES
INNODB_COLUMNS
INNODB_DATAFILES
INNODB_FIELDS
INNODB_FOREIGN
INNODB_FOREIGN_COLS
INNODB_INDEXES
INNODB_TABLES
INNODB_TABLESPACES
INNODB_TABLESPACES_BRIEF
INNODB_TABLESTATS
KEY_COLUMN_USAGE
PARAMETERS
PARTITIONS
REFERENTIAL_CONSTRAINTS
RESOURCE_GROUPS
ROUTINES
SCHEMATA
STATISTICS
TABLES
TABLE_CONSTRAINTS
TRIGGERS
VIEWS
VIEW_ROUTINE_USAGE
VIEW_TABLE_USAGE
</pre><p>
        一部のタイプの値は、非ビューの <code class="literal">INFORMATION_SCHEMA</code> テーブルの場合でも、データディクショナリからの参照によって取得されます。 これには、データベース名、テーブル名、テーブルタイプ、ストレージエンジンなどの値が含まれます。 
      </p><p>
        一部の <code class="literal">INFORMATION_SCHEMA</code> テーブルには、テーブル統計を提供するカラムが含まれています:
      </p><pre class="programlisting">STATISTICS.CARDINALITY
TABLES.AUTO_INCREMENT
TABLES.AVG_ROW_LENGTH
TABLES.CHECKSUM
TABLES.CHECK_TIME
TABLES.CREATE_TIME
TABLES.DATA_FREE
TABLES.DATA_LENGTH
TABLES.INDEX_LENGTH
TABLES.MAX_DATA_LENGTH
TABLES.TABLE_ROWS
TABLES.UPDATE_TIME
</pre><p>
        これらのカラムは、動的テーブルメタデータ、つまりテーブルの内容の変更に応じて変更される情報を表します。
      </p><p>
        デフォルトでは、MySQL は、カラムのクエリー時に <code class="literal">mysql.index_stats</code> および <code class="literal">mysql.table_stats</code> ディクショナリテーブルからこれらのカラムのキャッシュされた値を取得します。これは、ストレージエンジンから統計を直接取得するよりも効率的です。 キャッシュされた統計が使用できないか、期限切れになっている場合、MySQL はストレージエンジンから最新の統計を取得し、<code class="literal">mysql.index_stats</code> および <code class="literal">mysql.table_stats</code> ディクショナリテーブルにキャッシュします。 後続のクエリーでは、キャッシュされた統計が期限切れになるまで、キャッシュされた統計が取得されます。 
      </p><p>
        <code class="literal">information_schema_stats_expiry</code> セッション変数は、キャッシュされた統計が期限切れになるまでの期間を定義します。 デフォルトは 86400 秒 (24 時間) ですが、期間は 1 年まで延長できます。 
      </p><p>
        特定のテーブルのキャッシュされた値をいつでも更新するには、<code class="literal">ANALYZE TABLE</code> を使用します。
      </p><p>
        次の場合、統計カラムのクエリーでは、<code class="literal">mysql.index_stats</code> および <code class="literal">mysql.table_stats</code> ディクショナリテーブルの統計は格納または更新されません:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            キャッシュされた統計が失効していない場合。
          </p></li><li class="listitem"><p>
            <code class="literal">information_schema_stats_expiry</code> が 0 に設定されている場合。
          </p></li><li class="listitem"><p>
            サーバーが <code class="literal">read_only</code>, <code class="literal">super_read_only</code>, <code class="literal">transaction_read_only</code> または <code class="literal">innodb_read_only</code> モードで起動されたとき。
          </p></li><li class="listitem"><p>
            クエリーでパフォーマンススキーマデータもフェッチされる場合。
          </p></li></ul></div><p>
        <code class="literal">information_schema_stats_expiry</code> はセッション変数であり、各クライアントセッションで独自の有効期限値を定義できます。 ストレージエンジンから取得され、あるセッションによってキャッシュされた統計は、ほかのセッションで使用できます。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">innodb_read_only</code> システム変数が有効になっている場合、<code class="literal">InnoDB</code> を使用するデータディクショナリの統計テーブルを更新できないため、<code class="literal">ANALYZE TABLE</code> が失敗することがあります。 キー分散を更新する <code class="literal">ANALYZE TABLE</code> 操作では、操作によってテーブル自体が更新された場合でも (<code class="literal">MyISAM</code> テーブルの場合など)、障害が発生する可能性があります。 更新された分散統計を取得するには、<code class="literal">information_schema_stats_expiry=0</code> を設定します。 
        </p></div><p>
        データディクショナリテーブルのビューとして実装された <code class="literal">INFORMATION_SCHEMA</code> テーブルの場合、基礎となるデータディクショナリテーブルのインデックスを使用すると、オプティマイザで効率的なクエリー実行計画を作成できます。 オプティマイザによる選択を確認するには、<code class="literal">EXPLAIN</code> を使用します。 サーバーが <code class="literal">INFORMATION_SCHEMA</code> クエリーを実行するために使用するクエリーも表示するには、<code class="literal">EXPLAIN</code> の直後に <code class="literal">SHOW WARNINGS</code> を使用します。 
      </p><p>
        <code class="literal">utf8mb4</code> 文字セットの照合順序を識別する次のステートメントについて考えてみます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT COLLATION_NAME</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.COLLATION_CHARACTER_SET_APPLICABILITY</code></strong>
       <strong class="userinput"><code>WHERE CHARACTER_SET_NAME = 'utf8mb4';</code></strong>
+----------------------------+
| COLLATION_NAME             |
+----------------------------+
| utf8mb4_general_ci         |
| utf8mb4_bin                |
| utf8mb4_unicode_ci         |
| utf8mb4_icelandic_ci       |
| utf8mb4_latvian_ci         |
| utf8mb4_romanian_ci        |
| utf8mb4_slovenian_ci       |
...
</pre><p>
        サーバーはこのステートメントをどのように処理しますか。 確認するには、<code class="literal">EXPLAIN</code> を使用します: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT COLLATION_NAME</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.COLLATION_CHARACTER_SET_APPLICABILITY</code></strong>
       <strong class="userinput"><code>WHERE CHARACTER_SET_NAME = 'utf8mb4'\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: cs
   partitions: NULL
         type: const
possible_keys: PRIMARY,name
          key: name
      key_len: 194
          ref: const
         rows: 1
     filtered: 100.00
        Extra: Using index
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: col
   partitions: NULL
         type: ref
possible_keys: character_set_id
          key: character_set_id
      key_len: 8
          ref: const
         rows: 68
     filtered: 100.00
        Extra: NULL
2 rows in set, 1 warning (0.01 sec)
</pre><p>
        そのステートメントの静的化に使用されたクエリーを表示するには、<code class="literal">SHOW WARNINGS</code> を使用します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select `mysql`.`col`.`name` AS `COLLATION_NAME`
         from `mysql`.`character_sets` `cs`
         join `mysql`.`collations` `col`
         where ((`mysql`.`col`.`character_set_id` = '45')
         and ('utf8mb4' = 'utf8mb4'))
</pre><p>
        <code class="literal">SHOW WARNINGS</code> で示されているように、サーバーは、<code class="literal">mysql</code> システムデータベースの <code class="literal">character_sets</code> および <code class="literal">collations</code> データディクショナリテーブルに対するクエリーとして <code class="literal">COLLATION_CHARACTER_SET_APPLICABILITY</code> に対するクエリーを処理します。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="performance-schema-optimization"></a>8.2.4 パフォーマンススキーマクエリーの最適化</h3></div></div></div><a class="indexterm" name="idm45661478919120"></a><a class="indexterm" name="idm45661478916912"></a><p>
        データベースを監視するアプリケーションでは、「パフォーマンススキーマ」テーブルを頻繁に使用できます。 これらのテーブルに対するクエリーを最も効率的に記述するには、インデックスを利用します。 たとえば、インデックス付けされたカラムの特定の値との比較に基づいて、取得される行を制限する <code class="literal">WHERE</code> 句を含めます。 
      </p><p>
        「最もパフォーマンスの高いスキーマ」テーブルにはインデックスがあります。 通常は少数の行を含むテーブルではないか、頻繁にクエリーが行われる可能性が低いテーブル。 パフォーマンススキーマインデックスを使用すると、オプティマイザは全テーブルスキャン以外の実行計画にアクセスできます。 これらのインデックスは、それらのテーブルを使用する <code class="literal">sys</code> スキーマビューなど、関連するオブジェクトのパフォーマンスも向上します。 
      </p><p>
        特定の「パフォーマンススキーマ」テーブルにインデックスがあるかどうかとその内容を確認するには、<code class="literal">SHOW INDEX</code> または <code class="literal">SHOW CREATE TABLE</code> を使用します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW INDEX FROM performance_schema.accounts\G</code></strong>
*************************** 1. row ***************************
        Table: accounts
   Non_unique: 0
     Key_name: ACCOUNT
 Seq_in_index: 1
  Column_name: USER
    Collation: NULL
  Cardinality: NULL
     Sub_part: NULL
       Packed: NULL
         Null: YES
   Index_type: HASH
      Comment:
Index_comment:
      Visible: YES
*************************** 2. row ***************************
        Table: accounts
   Non_unique: 0
     Key_name: ACCOUNT
 Seq_in_index: 2
  Column_name: HOST
    Collation: NULL
  Cardinality: NULL
     Sub_part: NULL
       Packed: NULL
         Null: YES
   Index_type: HASH
      Comment:
Index_comment:
      Visible: YES

mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE performance_schema.rwlock_instances\G</code></strong>
*************************** 1. row ***************************
       Table: rwlock_instances
Create Table: CREATE TABLE `rwlock_instances` (
  `NAME` varchar(128) NOT NULL,
  `OBJECT_INSTANCE_BEGIN` bigint(20) unsigned NOT NULL,
  `WRITE_LOCKED_BY_THREAD_ID` bigint(20) unsigned DEFAULT NULL,
  `READ_LOCKED_BY_COUNT` int(10) unsigned NOT NULL,
  PRIMARY KEY (`OBJECT_INSTANCE_BEGIN`),
  KEY `NAME` (`NAME`),
  KEY `WRITE_LOCKED_BY_THREAD_ID` (`WRITE_LOCKED_BY_THREAD_ID`)
) ENGINE=PERFORMANCE_SCHEMA DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
</pre><p>
        パフォーマンススキーマクエリーの実行計画およびインデックスを使用するかどうかを確認するには、<code class="literal">EXPLAIN</code> を使用します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM performance_schema.accounts</code></strong>
       <strong class="userinput"><code>WHERE (USER,HOST) = ('root','localhost')\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: accounts
   partitions: NULL
         type: const
possible_keys: ACCOUNT
          key: ACCOUNT
      key_len: 278
          ref: const,const
         rows: 1
     filtered: 100.00
        Extra: NULL
</pre><p>
        <code class="literal">EXPLAIN</code> 出力は、<code class="literal">USER</code> カラムと <code class="literal">HOST</code> カラムで構成される <code class="literal">accounts</code> テーブルの <code class="literal">ACCOUNT</code> インデックスをオプティマイザが使用することを示しています。
      </p><p>
        パフォーマンススキーマのインデックスは仮想です: これらはパフォーマンススキーマストレージエンジンの構成であり、メモリーやディスクストレージを使用しません。 パフォーマンススキーマは、効率的な実行計画を構築できるように、オプティマイザにインデックス情報を報告します。 パフォーマンススキーマは、実際のインデックス構造を構築せずに効率的な検索を実行できるように、検索対象に関するオプティマイザ情報 (特定のキー値など) を使用します。 この実装には、次の 2 つの重要な利点があります: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            頻繁に更新されるテーブルで通常発生するメンテナンスコストを完全に回避します。
          </p></li><li class="listitem"><p>
            これにより、クエリー実行の初期段階で取得されるデータ量が削減されます。 インデックス付きカラムの条件の場合、パフォーマンススキーマはクエリー条件を満たすテーブル行のみを効率的に返します。 インデックスがない場合、パフォーマンススキーマはテーブル内のすべての行を返すため、オプティマイザはあとで各行に対して条件を評価して最終結果を生成する必要があります。 
          </p></li></ul></div><p>
        パフォーマンススキーマのインデックスは事前定義されており、削除、追加、または変更できません。
      </p><p>
        パフォーマンススキーマのインデックスはハッシュインデックスに似ています。 例: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            これらは、<code class="literal">=</code> または <code class="literal">&lt;=&gt;</code> 演算子を使用する等価比較にのみ使用されます。
          </p></li><li class="listitem"><p>
            これらは順序付けられていません。 クエリー結果に特定の行順序付け特性が必要な場合は、<code class="literal">ORDER BY</code> 句を含めます。 
          </p></li></ul></div><p>
        ハッシュインデックスの詳細は、<a class="xref" href="optimization.html#index-btree-hash" title="8.3.9 B ツリーインデックスとハッシュインデックスの比較">セクション8.3.9「B ツリーインデックスとハッシュインデックスの比較」</a> を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="data-change-optimization"></a>8.2.5 データ変更ステートメントの最適化</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#insert-optimization">8.2.5.1 INSERT ステートメントの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#update-optimization">8.2.5.2 UPDATE ステートメントの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#delete-optimization">8.2.5.3 DELETE ステートメントの最適化</a></span></dt></dl></div><a class="indexterm" name="idm45661478881296"></a><p>
        このセクションでは、データ変更ステートメントを高速化する方法について説明: <code class="literal">INSERT</code>、<code class="literal">UPDATE</code> および <code class="literal">DELETE</code>。 従来の OLTP アプリケーションおよび最新の web アプリケーションでは、通常、同時実行性が重要な多数の小さなデータ変更操作が実行されます。 データ分析およびレポートアプリケーションでは、通常、一度に多数の行に影響するデータ変更操作が実行されます。主な考慮事項は、大量のデータを書き込み、インデックスを最新の状態に保つための I/O です。 大量のデータの挿入と更新 (業界では ETL (<span class="quote">「<span class="quote">extract-transform-load</span>」</span>) と呼ばれる) では、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> ステートメントの効果を模倣する、その他の SQL ステートメントや外部コマンドを使用することがあります。 
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="insert-optimization"></a>8.2.5.1 INSERT ステートメントの最適化</h4></div></div></div><a class="indexterm" name="idm45661478869904"></a><a class="indexterm" name="idm45661478868592"></a><a class="indexterm" name="idm45661478866448"></a><a class="indexterm" name="idm45661478864416"></a><p>
          挿入の速度を最適化するには、多くの小さな操作を 1 つの大きな操作に組み合わせます。 理想的には、単一の接続を作成し、多くの新しい行のデータを一度に送信し、すべてのインデックスの更新と一貫性チェックを最後まで延期します。 
        </p><p>
          行の挿入に必要な時間は、次の要因によって決まります。ここでの数はおよその割合を示しています。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              接続: (3)
            </p></li><li class="listitem"><p>
              サーバーへのクエリーの送信: (2)
            </p></li><li class="listitem"><p>
              クエリーの解析: (2)
            </p></li><li class="listitem"><p>
              行の挿入: (1 ×行サイズ)
            </p></li><li class="listitem"><p>
              インデックスの挿入: (1 ×インデックス数)
            </p></li><li class="listitem"><p>
              クローズ: (1)
            </p></li></ul></div><p>
          これには、テーブルを開く初期オーバーヘッドを考慮に入れていません。これは同時実行クエリーごとに 1 回実行されます。
        </p><p>
          テーブルのサイズによって、log <em class="replaceable"><code>N</code></em> だけインデックスの挿入が遅くなります (B ツリーインデックスであるとして)。
        </p><p>
          次の方法を使用して、挿入を高速化できます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              同じクライアントから同時に多数の行を挿入する場合は、複数の <code class="literal">VALUES</code> リストで <code class="literal">INSERT</code> ステートメントを使用して、同時に複数の行を挿入します。 これは、個別の単一行の <code class="literal">INSERT</code> ステートメントを使用するより、大幅に (場合によっては数倍) 速くなります。 空ではないテーブルにデータを追加する場合は、データの挿入をさらに速くするために、<code class="literal">bulk_insert_buffer_size</code> 変数を調整できます。 <a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              テキストファイルからテーブルをロードする場合は、<code class="literal">LOAD DATA</code> を使用します。 通常、これは <code class="literal">INSERT</code> ステートメントを使用する場合より、20 倍速くなります。 <a class="xref" href="sql-statements.html#load-data" title="13.2.7 LOAD DATA ステートメント">セクション13.2.7「LOAD DATA ステートメント」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              カラムにデフォルト値があることを利用します。 挿入する値がデフォルト値と異なる場合にのみ、明示的に値を挿入します。 これにより、MySQL が実行する必要がある解析が減り、挿入速度が向上します。 
            </p></li><li class="listitem"><p>
              <code class="literal">InnoDB</code> テーブルに固有のヒントについては、<a class="xref" href="optimization.html#optimizing-innodb-bulk-data-loading" title="8.5.5 InnoDB テーブルの一括データロード">セクション8.5.5「InnoDB テーブルの一括データロード」</a>を参照してください。
            </p></li><li class="listitem"><p>
              <code class="literal">MyISAM</code> テーブルに固有のヒントについては、<a class="xref" href="optimization.html#optimizing-myisam-bulk-data-loading" title="8.6.2 MyISAM テーブルの一括データロード">セクション8.6.2「MyISAM テーブルの一括データロード」</a>を参照してください。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="update-optimization"></a>8.2.5.2 UPDATE ステートメントの最適化</h4></div></div></div><a class="indexterm" name="idm45661478834288"></a><p>
          更新ステートメントは、<code class="literal">SELECT</code> クエリーと同様に最適化されますが、書き込みの追加のオーバーヘッドがあります。 書き込みの速度は更新されるデータの量と更新されるインデックス数によって異なります。 変更がないインデックスは更新されません。 
        </p><p>
          更新を速くするもう 1 つの方法は、更新を遅延して、あとで 1 行で多くの更新を実行することです。 複数の更新をまとめて実行することで、テーブルをロックした場合に、一度に 1 つずつ実行するよりはるかに高速になります。 
        </p><p>
          動的な行フォーマットを使用する <code class="literal">MyISAM</code> テーブルの場合、行を長い合計長に更新すると、行が分割されることがあります。 頻繁にこれを実行する場合は、ときどき <code class="literal">OPTIMIZE TABLE</code> を使用することがきわめて重要になります。 <a class="xref" href="sql-statements.html#optimize-table" title="13.7.3.4 OPTIMIZE TABLE ステートメント">セクション13.7.3.4「OPTIMIZE TABLE ステートメント」</a>を参照してください。 
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="delete-optimization"></a>8.2.5.3 DELETE ステートメントの最適化</h4></div></div></div><a class="indexterm" name="idm45661478824432"></a><p>
          <code class="literal">MyISAM</code> テーブル内の個々の行を削除するために必要な時間は、インデックスの数に正確に比例します。 行をもっと速く削除するには、<code class="literal">key_buffer_size</code> システム変数を増やして、キーキャッシュのサイズを大きくできます。 <a class="xref" href="server-administration.html#server-configuration" title="5.1.1 サーバーの構成">セクション5.1.1「サーバーの構成」</a>を参照してください。 
        </p><p>
          <code class="literal">MyISAM</code> テーブルからすべての行を削除するには、<code class="literal">TRUNCATE TABLE <em class="replaceable"><code>tbl_name</code></em></code> の方が <code class="literal">DELETE FROM <em class="replaceable"><code>tbl_name</code></em></code> より速くなります。 切り捨て操作はトランザクションセーフではありません。アクティブなトランザクションやアクティブなテーブルロックの途中で試みるとエラーが発生します。 <a class="xref" href="sql-statements.html#truncate-table" title="13.1.37 TRUNCATE TABLE ステートメント">セクション13.1.37「TRUNCATE TABLE ステートメント」</a>を参照してください。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="permission-optimization"></a>8.2.6 データベース権限の最適化</h3></div></div></div><a class="indexterm" name="idm45661478813088"></a><a class="indexterm" name="idm45661478810944"></a><p>
        権限のセットアップが複雑であるほど、すべての SQL ステートメントに適用されるオーバーヘッドが大きくなります。 <code class="literal">GRANT</code> ステートメントによって確立された権限を簡単にすることで、クライアントがステートメントを実行するときの MySQL の権限チェックのオーバーヘッドを軽減できます。 たとえば、テーブルレベルやカラムレベルの権限を付与しない場合、サーバーは <code class="literal">tables_priv</code> と <code class="literal">columns_priv</code> テーブルの内容をチェックする必要はなくなります。 同じように、どのアカウントにもリソース制限を設けない場合、サーバーはリソースのカウントを実行する必要がありません。 ステートメント処理の負荷が著しく高い場合は、簡略化した付与構造を使用して、権限チェックのオーバーヘッドを軽減することを考慮してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="miscellaneous-optimization-tips"></a>8.2.7 その他の最適化のヒント</h3></div></div></div><a class="indexterm" name="idm45661478803312"></a><a class="indexterm" name="idm45661478801168"></a><p>
        このセクションでは、クエリー処理速度を向上するためのさまざまな多くのヒントを示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            アプリケーションが関連する更新を実行するために複数のデータベースリクエストを作成する場合、ステートメントをストアドルーチンに結合するとパフォーマンスが向上します。 同様に、アプリケーションで複数のカラム値または大量のデータに基づいて単一の結果を計算する場合、計算を UDF (ユーザー定義関数) に結合するとパフォーマンスが向上します。 結果の高速データベース操作は、他のクエリー、アプリケーションおよび異なるプログラミング言語で記述されたコードで再利用できます。 詳細は、<a class="xref" href="stored-objects.html#stored-routines" title="25.2 ストアドルーチンの使用">セクション25.2「ストアドルーチンの使用」</a> および <a class="ulink" href="https://dev.mysql.com/doc/extending-mysql/8.0/en/adding-functions.html" target="_top">Adding Functions to MySQL</a> を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">ARCHIVE</code> テーブルで発生する圧縮の問題を修正するには、<code class="literal">OPTIMIZE TABLE</code> を使用します。 <a class="xref" href="storage-engines.html#archive-storage-engine" title="16.5 ARCHIVE ストレージエンジン">セクション16.5「ARCHIVE ストレージエンジン」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            可能な場合は、レポートを<span class="quote">「<span class="quote">「ライブ」</span>」</span>または<span class="quote">「<span class="quote">「統計」</span>」</span>として分類します。統計レポートに必要なデータは、ライブデータから定期的に生成されるサマリーテーブルからのみ作成されます。
          </p></li><li class="listitem"><p>
            行とカラムのテーブル構造に適合しないデータがある場合は、データを圧縮して <code class="literal">BLOB</code> カラムに格納できます。 この場合、情報を圧縮および解凍するためのコードをアプリケーションに指定する必要がありますが、これにより、関連する値のセットの読取りおよび書込みのための I/O 操作が保存される可能性があります。 
          </p></li><li class="listitem"><p>
            Web サーバーでは、イメージおよびその他のバイナリアセットをファイルとして格納し、パス名をファイル自体ではなくデータベースに格納します。 ほとんどの Web サーバーは、データベースコンテンツよりファイルのキャッシュに優れているため、ファイルの使用は一般に高速です。 (ただし、この場合はバックアップとストレージの問題を自分で処理する必要があります。) 
          </p></li><li class="listitem"><p>
            実際に高速化が必要な場合は、低レベルの MySQL インタフェースを参照してください。 たとえば、MySQL <code class="literal">InnoDB</code> または <code class="literal">MyISAM</code> ストレージエンジンに直接アクセスすると、SQL インタフェースを使用する場合と比べて大幅に高速化できます。 
          </p><p>
            同様に、<code class="literal">NDBCLUSTER</code> ストレージエンジンを使用するデータベースの場合は、NDB API の使用可能な使用状況を調査することをお勧めします (<a class="ulink" href="https://dev.mysql.com/doc/ndbapi/en/" target="_top">MySQL NDB Cluster API Developer Guide</a> を参照)。
          </p></li><li class="listitem"><p>
            レプリケーションは、特定の操作でパフォーマンスの向上を実現できます。 クライアントの取得をレプリカ間で分散して、負荷を分割できます。 バックアップの作成中にソースの速度が低下しないように、レプリカを使用してバックアップを作成できます。 <a class="xref" href="replication.html" title="第 17 章 レプリケーション">第17章「<i>レプリケーション</i>」</a>を参照してください。 
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="optimization-indexes"></a>8.3 最適化とインデックス</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#mysql-indexes">8.3.1 MySQL のインデックスの使用の仕組み</a></span></dt><dt><span class="section"><a href="optimization.html#primary-key-optimization">8.3.2 主キーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#spatial-index-optimization">8.3.3 SPATIAL インデックス最適化</a></span></dt><dt><span class="section"><a href="optimization.html#foreign-key-optimization">8.3.4 外部キーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#column-indexes">8.3.5 カラムインデックス</a></span></dt><dt><span class="section"><a href="optimization.html#multiple-column-indexes">8.3.6 マルチカラムインデックス</a></span></dt><dt><span class="section"><a href="optimization.html#verifying-index-usage">8.3.7 インデックスの使用の確認</a></span></dt><dt><span class="section"><a href="optimization.html#index-statistics">8.3.8 InnoDB および MyISAM インデックス統計コレクション</a></span></dt><dt><span class="section"><a href="optimization.html#index-btree-hash">8.3.9 B ツリーインデックスとハッシュインデックスの比較</a></span></dt><dt><span class="section"><a href="optimization.html#index-extensions">8.3.10 インデックス拡張の使用</a></span></dt><dt><span class="section"><a href="optimization.html#generated-column-index-optimizations">8.3.11 生成されたカラムインデックスのオプティマイザによる使用</a></span></dt><dt><span class="section"><a href="optimization.html#invisible-indexes">8.3.12 不可視のインデックス</a></span></dt><dt><span class="section"><a href="optimization.html#descending-indexes">8.3.13 降順インデックス</a></span></dt><dt><span class="section"><a href="optimization.html#timestamp-lookups">8.3.14 TIMESTAMP カラムからのインデックス付きルックアップ</a></span></dt></dl></div><a class="indexterm" name="idm45661478775600"></a><p>
      <code class="literal">SELECT</code> 操作のパフォーマンスを向上する最善の方法は、クエリーでテストされる 1 つ以上のカラムにインデックスを作成することです。 インデックスエントリは、テーブル行へのポインタのように動作し、クエリーが <code class="literal">WHERE</code> 句の条件に一致する行を迅速に特定し、それらの行のほかのカラム値を取得できます。 すべての MySQL データ型にインデックスを設定できます。 
    </p><p>
      クエリーで使用されている可能なすべてのカラムにインデックスを作成しようとしがちですが、不要なインデックスは領域を無駄にし、MySQL が使用するインデックスを判断するための時間を無駄にします。 各インデックスを更新する必要があるため、インデックスは挿入、更新、削除のコストも追加します。 最適なインデックスのセットを使用して、高速のクエリーを実現するために、適切なバランスを見つける必要があります。 
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="mysql-indexes"></a>8.3.1 MySQL のインデックスの使用の仕組み</h3></div></div></div><a class="indexterm" name="idm45661478768320"></a><p>
        インデックスは特定のカラム値のある行をすばやく見つけるために使用されます。 インデックスがないと、MySQL は関連する行を見つけるために、先頭行から始めてテーブル全体を読み取る必要があります。 テーブルが大きいほど、このコストが大きくなります。 テーブルに問題のカラムのインデックスが含まれている場合、MySQL はすべてのデータを調べる必要なく、データファイルの途中のシークする位置をすばやく特定できます。 これはすべての行を順次読み取るよりはるかに高速です。 
      </p><p>
        ほとんどの MySQL インデックス (<code class="literal">PRIMARY KEY</code>、<code class="literal">UNIQUE</code>、<code class="literal">INDEX</code>、および <code class="literal">FULLTEXT</code>) は <a class="link" href="glossary.html#glos_b_tree" title="B ツリー">B ツリー</a>に格納されます。 例外: 空間データ型のインデックスは R ツリーを使用します。<code class="literal">MEMORY</code> テーブルは<a class="link" href="glossary.html#glos_hash_index" title="ハッシュインデックス">ハッシュインデックス</a>もサポートします。<code class="literal">InnoDB</code> は <code class="literal">FULLTEXT</code> インデックスの逆のリストを使用します。 
      </p><p>
        一般に、インデックスは次の説明に示すように使われます。 ハッシュインデックス (<code class="literal">MEMORY</code> テーブルで使用されているような) に固有の特性については、<a class="xref" href="optimization.html#index-btree-hash" title="8.3.9 B ツリーインデックスとハッシュインデックスの比較">セクション8.3.9「B ツリーインデックスとハッシュインデックスの比較」</a>で説明しています。 
      </p><p>
        MySQL はこれらの操作にインデックスを使用します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">WHERE</code> 句に一致する行をすばやく見つけるため。
          </p></li><li class="listitem"><p>
            行を考慮に入れないようにするため。 複数のインデックスから選択する場合、MySQL は通常最小数の行を見つけるインデックス (もっとも<a class="link" href="glossary.html#glos_selectivity" title="選択性">選択的な</a>インデックス) を使用します。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661478749456"></a> <a class="indexterm" name="idm45661478747280"></a>テーブルにマルチカラムインデックスがある場合、オプティマイザは、インデックスの左端のプリフィクスを使用して行をルックアップできます。 たとえば、<code class="literal">(col1, col2, col3)</code> に 3 カラムのインデックスがある場合、<code class="literal">(col1)</code>、<code class="literal">(col1, col2)</code>、および <code class="literal">(col1, col2, col3)</code> に対して、インデックス検索機能を使用できます。 詳細については、<a class="xref" href="optimization.html#multiple-column-indexes" title="8.3.6 マルチカラムインデックス">セクション8.3.6「マルチカラムインデックス」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            結合の実行時に、ほかのテーブルから行を取得するため。 カラムが同じ型とサイズで宣言されていると、MySQL はカラムのインデックスをより効率的に使用できます。 このコンテキストでは、<code class="literal">VARCHAR</code> と <code class="literal">CHAR</code> は同じサイズで宣言されていれば同じとみなされます。 たとえば、<code class="literal">VARCHAR(10)</code> と <code class="literal">CHAR(10)</code> は同じサイズですが、<code class="literal">VARCHAR(10)</code> と <code class="literal">CHAR(15)</code> は異なります。 
          </p><p>
            非バイナリ文字列カラム間での比較の場合、両方のカラムで同じ文字セットを使用しているべきです。 たとえば、<code class="literal">utf8</code> カラムと <code class="literal">latin1</code> カラムの比較はインデックスの使用の可能性を否定します。 
          </p><p>
            異種のカラムの比較 (文字列カラムを時間または数値カラムと比較するなど) では、値を変換せずに直接比較できない場合、インデックスの使用が妨げられることがあります。 数値カラム内の <code class="literal">1</code> などの特定の値の場合、<code class="literal">'1'</code>、<code class="literal">' 1'</code>、<code class="literal">'00001'</code>、または <code class="literal">'01.e1'</code> などの文字列カラム内の任意の数の値と等しくなる可能性があります。 これは、文字列カラムのインデックスの使用を除外します。 
          </p></li><li class="listitem"><p>
            特定のインデックス設定されたカラム <em class="replaceable"><code>key_col</code></em> に対して、<code class="literal">MIN()</code> あるいは <code class="literal">MAX()</code> 値を見つけるため。 これはインデックス内の <em class="replaceable"><code>key_col</code></em> より前に発生するすべてのキーパートで、<code class="literal">WHERE <em class="replaceable"><code>key_part_N</code></em> = <em class="replaceable"><code>constant</code></em></code> が使用されているかどうかをチェックするプリプロセッサによって最適化されます。 この場合、MySQL は各 <code class="literal">MIN()</code> または <code class="literal">MAX()</code> 式に対して単一キールックアップを行い、それを定数で置き換えます。 すべての式が定数で置き換えられた場合、クエリーは同時に返されます。 例: 
          </p><pre class="programlisting">SELECT MIN(<em class="replaceable"><code>key_part2</code></em>),MAX(<em class="replaceable"><code>key_part2</code></em>)
  FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_part1</code></em>=10;
</pre></li><li class="listitem"><p>
            使用可能なインデックスの左端のプリフィクスに対してソートまたはグループ化が行われている場合 (たとえば、<code class="literal">ORDER BY <em class="replaceable"><code>key_part1</code></em>, <em class="replaceable"><code>key_part2</code></em></code>) に、テーブルをソートまたはグループ化するため。 すべてのキーパートのあとに <code class="literal">DESC</code> が付けられている場合、キーは逆の順序で読み取られます。 (または、インデックスが降順の場合、キーは順方向に読み取られます。) <a class="xref" href="optimization.html#order-by-optimization" title="8.2.1.16 ORDER BY の最適化">セクション8.2.1.16「ORDER BY の最適化」</a>、<a class="xref" href="optimization.html#group-by-optimization" title="8.2.1.17 GROUP BY の最適化">セクション8.2.1.17「GROUP BY の最適化」</a>、および<a class="xref" href="optimization.html#descending-indexes" title="8.3.13 降順インデックス">セクション8.3.13「降順インデックス」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            場合によって、データ行を参照しないで値を取得するように、クエリーを最適化できます。 (クエリーの必要なすべての結果を提供するインデックスは、<a class="link" href="glossary.html#glos_covering_index" title="カバリングインデックス">カバーするインデックス</a>と呼ばれます。) クエリーがテーブルから特定のインデックスに含まれるカラムのみを使用している場合、きわめて高速に、選択した値をインデックスツリーから取得できます。 
          </p><pre class="programlisting">SELECT <em class="replaceable"><code>key_part3</code></em> FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_part1</code></em>=1
</pre></li></ul></div><p>
        小さなテーブルまたは、レポートクエリーが行の大半またはすべてを処理する大きなテーブルに対するクエリーでは、インデックスはあまり重要ではありません。 クエリーで行の大半にアクセスする必要がある場合は、順次読み取る方が、インデックスを処理するより高速です。 クエリーですべての行が必要でない場合でも、順次読み取りは、ディスクシークを最小にします。 詳細は、<a class="xref" href="optimization.html#table-scan-avoidance" title="8.2.1.23 全テーブルスキャンの回避">セクション8.2.1.23「全テーブルスキャンの回避」</a> を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="primary-key-optimization"></a>8.3.2 主キーの最適化</h3></div></div></div><a class="indexterm" name="idm45661478703120"></a><p>
        テーブルの主キーは、もっとも重要なクエリーで使用するカラムやカラムのセットを表します。 それには、高速のクエリーパフォーマンスのため、インデックスが関連付けられます。 それには <code class="literal">NULL</code> 値を含めることができないため、クエリーパフォーマンスは <code class="literal">NOT NULL</code> 最適化からメリットが得られます。 <code class="literal">InnoDB</code> ストレージエンジンによって、テーブルデータが、主キーカラムに基づいて、超高速ルックアップおよびソートを実行するように物理的に編成されます。 
      </p><p>
        テーブルが大きく、重要でも、主キーとして使用する明確なカラムやカラムのセットがない場合は、自動インクリメント値で個別のカラムを作成して、主キーとして使用できます。 これらの一意の ID は、外部キーを使用してテーブルを結合する場合に、ほかのテーブル内の対応する行へのポインタとして使用できます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="spatial-index-optimization"></a>8.3.3 SPATIAL インデックス最適化</h3></div></div></div><a class="indexterm" name="idm45661478695072"></a><a class="indexterm" name="idm45661478692928"></a><p>
        MySQL では、<code class="literal">NOT NULL</code> ジオメトリ値カラムに <code class="literal">SPATIAL</code> インデックスを作成できます (<a class="xref" href="data-types.html#creating-spatial-indexes" title="11.4.10 空間インデックスの作成">セクション11.4.10「空間インデックスの作成」</a> を参照)。 オプティマイザは、インデックス付けされたカラムの <code class="literal">SRID</code> 属性をチェックして、比較に使用する空間参照システム (SRS) を決定し、SRS に適した計算を使用します。 (MySQL 8.0 より前では、オプティマイザはデカルト計算を使用して <code class="literal">SPATIAL</code> インデックス値の比較を実行します。このような操作の結果は、非デカルト SRID を持つ値がカラムに含まれている場合は未定義です。) 
      </p><p>
        比較が適切に機能するには、<code class="literal">SPATIAL</code> インデックスの各カラムが SRID 制限付きである必要があります。 つまり、カラム定義には明示的な <code class="literal">SRID</code> 属性が含まれている必要があり、すべてのカラム値は同じ SRID を持つ必要があります。 
      </p><p>
        オプティマイザは、SRID で制限されたカラムに対してのみ <code class="literal">SPATIAL</code> インデックスを考慮します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            デカルト SRID に制限されたカラムのインデックスを使用すると、デカルト境界ボックスの計算が可能になります。
          </p></li><li class="listitem"><p>
            地理 SRID に制限されたカラムのインデックスを使用すると、地理的境界ボックスの計算が可能になります。
          </p></li></ul></div><p>
        オプティマイザは、<code class="literal">SRID</code> 属性を持たない (したがって SRID 制限のない) カラムの <code class="literal">SPATIAL</code> インデックスを無視します。 MySQL では、このようなインデックスは次のように維持されます: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブルの変更 (<code class="literal">INSERT</code>, <code class="literal">UPDATE</code>, <code class="literal">DELETE</code> など) のために更新されます。 カラムにデカルト値と地理的値が混在している場合でも、インデックスがデカルトであるかのように更新が行われます。 
          </p></li><li class="listitem"><p>
            これらは下位互換性のためにのみ存在します (たとえば、MySQL 5.7 でダンプを実行し、MySQL 8.0 でリストアする機能)。 SRID 制限のないカラムの <code class="literal">SPATIAL</code> インデックスはオプティマイザで使用されないため、このような各カラムを変更する必要があります: 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                カラム内のすべての値が同じ SRID を持つことを確認します。 ジオメトリカラム <em class="replaceable"><code>col_name</code></em> に含まれる SRID を確認するには、次のクエリーを使用します: 
              </p><pre class="programlisting">SELECT DISTINCT ST_SRID(<em class="replaceable"><code>col_name</code></em>) FROM <em class="replaceable"><code>tbl_name</code></em>;
</pre><p>
                クエリーで複数の行が返された場合、カラムには SRID の混在が含まれます。 その場合は、その内容を変更して、すべての値が同じ SRID を持つようにします。 
              </p></li><li class="listitem"><p>
                明示的な <code class="literal">SRID</code> 属性を持つようにカラムを再定義します。
              </p></li><li class="listitem"><p>
                <code class="literal">SPATIAL</code> インデックスを再作成します。
              </p></li></ul></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="foreign-key-optimization"></a>8.3.4 外部キーの最適化</h3></div></div></div><a class="indexterm" name="idm45661478660784"></a><p>
        テーブルに多くのカラムがあり、多くのさまざまなカラムの組み合わせをクエリーする場合、あまり頻繁に使用されないデータをそれぞれ少数のカラムを持つ個別のテーブルに分割し、それらを、メインテーブルの数値 ID カラムを複製してメインテーブルに関連付けると、効率的なことがあります。 そのようにして、小さな各テーブルに、そのデータの高速ルックアップのための主キーを設定でき、結合操作を使用して必要とするカラムのセットだけをクエリーできます。 データの分散状況に応じて、関連カラムがディスク上にまとめてパックされるため、クエリーで実行する I/O が少なくなり、使用するキャッシュメモリーが減る可能性があります。 (パフォーマンスを最大にするため、クエリーはディスクから可能なかぎり少ないデータブロックを読み取ろうとします。数個のカラムしかないテーブルでは各データブロックにより多くのデータを収めることができます。) 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="column-indexes"></a>8.3.5 カラムインデックス</h3></div></div></div><a class="indexterm" name="idm45661478655184"></a><a class="indexterm" name="idm45661478653072"></a><a class="indexterm" name="idm45661478651040"></a><p>
        もっとも一般的なインデックスの種類には、単一カラムがあり、データ構造にそのカラムの値のコピーを格納し、対応するカラム値のある行を高速にルックアップできます。 B ツリーデータ構造により、インデックスは、<code class="literal">WHERE</code> 句内の <code class="literal">=</code>、<code class="literal">&gt;</code>、<code class="literal">≤</code>、<code class="literal">BETWEEN</code>、<code class="literal">IN</code> などの演算子に対応する特定の値、値のセット、または値の範囲をすばやく見つけることができます。 
      </p><p>
        テーブルあたりの最大インデックス数とインデックスの最大長は、ストレージエンジンごとに定義されます。 <a class="xref" href="innodb-storage-engine.html" title="第 15 章 InnoDB ストレージエンジン">第15章「<i>InnoDB ストレージエンジン</i>」</a>および<a class="xref" href="storage-engines.html" title="第 16 章 代替ストレージエンジン">第16章「<i>代替ストレージエンジン</i>」</a>を参照してください。 すべてのストレージエンジンは、1 テーブルあたり 16 個以上のインデックスと 256 バイト以上の合計インデックス長をサポートします。 ほとんどのストレージエンジンでは、制限が高く設定されています。 
      </p><p>
        カラムインデックスの詳細は、<a class="xref" href="sql-statements.html#create-index" title="13.1.15 CREATE INDEX ステートメント">セクション13.1.15「CREATE INDEX ステートメント」</a> を参照してください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#column-indexes-prefix" title="インデックス接頭辞">インデックス接頭辞</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#column-indexes-fulltext" title="FULLTEXT インデックス">FULLTEXT インデックス</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#column-indexes-spatial" title="空間インデックス">空間インデックス</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#column-indexes-memory-storage-engine" title="MEMORY ストレージエンジンでのインデックス">MEMORY ストレージエンジンでのインデックス</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="column-indexes-prefix"></a>インデックス接頭辞</h4></div></div></div><a class="indexterm" name="idm45661478634704"></a><a class="indexterm" name="idm45661478632576"></a><a class="indexterm" name="idm45661478630496"></a><a class="indexterm" name="idm45661478628448"></a><a class="indexterm" name="idm45661478626368"></a><p>
          文字列カラムのインデックス指定に <code class="literal"><em class="replaceable"><code>col_name</code></em>(<em class="replaceable"><code>N</code></em>)</code> 構文を使用すると、カラムの最初の <em class="replaceable"><code>N</code></em> 文字のみを使用するインデックスを作成できます。 このようにカラム値のプリフィクスのみのインデックスを作成すると、インデックスファイルをかなり小さくできます。 <code class="literal">BLOB</code> または <code class="literal">TEXT</code> カラムにインデックス設定する場合、インデックスのプリフィクス長を指定する<span class="emphasis"><em>必要があります</em></span>。 例: 
        </p><pre class="programlisting">CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));
</pre><p>
          <code class="literal"><a class="link" href="glossary.html#glos_redundant_row_format" title="冗長行フォーマット">REDUNDANT</a></code> または <code class="literal"><a class="link" href="glossary.html#glos_compact_row_format" title="コンパクト行フォーマット">COMPACT</a></code> の行形式を使用する <code class="literal">InnoDB</code> テーブルでは、接頭辞の長さは最大 767 バイトです。 <code class="literal"><a class="link" href="glossary.html#glos_dynamic_row_format" title="動的行フォーマット">DYNAMIC</a></code> または <code class="literal"><a class="link" href="glossary.html#glos_compressed_row_format" title="圧縮行フォーマット">COMPRESSED</a></code> の行形式を使用する <code class="literal">InnoDB</code> テーブルでは、接頭辞の長さの制限は 3072 バイトです。 「MyISAM の場合」テーブルでは、接頭辞の長さの制限は 1000 バイトです。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            接頭辞の制限はバイト単位で測定されますが、<code class="literal">CREATE TABLE</code>、<code class="literal">ALTER TABLE</code> および <code class="literal">CREATE INDEX</code> ステートメントの接頭辞の長さは、非バイナリ文字列型 (<code class="literal">CHAR</code>, <code class="literal">VARCHAR</code>, <code class="literal">TEXT</code>) の場合は文字数、バイナリ文字列型 (<code class="literal">BINARY</code>, <code class="literal">VARBINARY</code>, <code class="literal">BLOB</code>) の場合はバイト数として解釈されます。 マルチバイト文字セットを使用する非バイナリ文字列カラムに接頭辞の長さを指定する場合は、これを考慮してください。 
          </p></div><p>
          検索語がインデックス接頭辞の長さを超える場合、インデックスを使用して一致しない行が除外され、残りの行で一致の可能性が調査されます。
        </p><p>
          インデックス接頭辞の詳細は、<a class="xref" href="sql-statements.html#create-index" title="13.1.15 CREATE INDEX ステートメント">セクション13.1.15「CREATE INDEX ステートメント」</a> を参照してください。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="column-indexes-fulltext"></a>FULLTEXT インデックス</h4></div></div></div><a class="indexterm" name="idm45661478596128"></a><a class="indexterm" name="idm45661478594000"></a><p>
          <code class="literal">FULLTEXT</code> インデックスは、全文検索に使用されます。 <code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> ストレージエンジンのみが、<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、および <code class="literal">TEXT</code> カラムに対してのみ、<code class="literal">FULLTEXT</code> インデックスをサポートしています。 インデックス設定は常にカラム全体に対して行われ、カラムプリフィクスインデックス設定はサポートされていません。 詳細は、<a class="xref" href="functions.html#fulltext-search" title="12.10 全文検索関数">セクション12.10「全文検索関数」</a>を参照してください。 
        </p><p>
          最適化は、単一の <code class="literal">InnoDB</code> テーブルに対する特定の種類の <code class="literal">FULLTEXT</code> クエリーに適用されます。 これらの特性を持つクエリーは特に効率的です。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              ドキュメント ID またはドキュメント ID と検索ランクのみを返す <code class="literal">FULLTEXT</code> クエリー。
            </p></li><li class="listitem"><p>
              一致する行をスコアの降順でソートし、<code class="literal">LIMIT</code> 句を適用して、上位 N 個の一致する行を取得する <code class="literal">FULLTEXT</code> クエリー。 この最適化を適用するには、<code class="literal">WHERE</code> 句がなく、降順の単一の <code class="literal">ORDER BY</code> 句のみがある必要があります。 
            </p></li><li class="listitem"><p>
              検索語に一致する行の <code class="literal">COUNT(*)</code> 値のみを取得し、追加の <code class="literal">WHERE</code> 句がない <code class="literal">FULLTEXT</code> クエリー。 <code class="literal">WHERE</code> 句を <code class="literal">&gt; 0</code> 比較演算子を使用せずに、<code class="literal">WHERE MATCH(<em class="replaceable"><code>text</code></em>) AGAINST ('<em class="replaceable"><code>other_text</code></em>')</code> とコーディングします。 
            </p></li></ul></div><p>
          全文式を含むクエリーの場合、MySQL では、クエリー実行の最適化フェーズ中にこれらの式が評価されます。 オプティマイザは、全文式を参照して見積りを行うだけでなく、実行計画の開発プロセスでそれらを実際に評価します。 
        </p><p>
          この動作の影響は、全文クエリーの <code class="literal">EXPLAIN</code> は通常、最適化フェーズ中に式の評価が行われない非全文クエリーより遅くなることです。
        </p><p>
          全文クエリーの <code class="literal">EXPLAIN</code> では、最適化中に一致が発生するため、<code class="literal">Extra</code> カラムに <code class="literal">Select tables optimized away</code> が表示される場合があります。この場合、後で実行する際にテーブルへのアクセスは必要ありません。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="column-indexes-spatial"></a>空間インデックス</h4></div></div></div><a class="indexterm" name="idm45661478561648"></a><a class="indexterm" name="idm45661478559520"></a><p>
          空間データ型にインデックスを作成できます。 <code class="literal">MyISAM</code> および <code class="literal">InnoDB</code> は、空間型の R ツリーインデックスをサポートしています。 ほかのストレージエンジンは、空間型のインデックス設定に B ツリーを使用します (<code class="literal">ARCHIVE</code> を除きます。これは空間型のインデックス設定をサポートしていません)。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="column-indexes-memory-storage-engine"></a>MEMORY ストレージエンジンでのインデックス</h4></div></div></div><a class="indexterm" name="idm45661478552880"></a><a class="indexterm" name="idm45661478550720"></a><p>
          <code class="literal">MEMORY</code> ストレージエンジンはデフォルトで <code class="literal">HASH</code> インデックスを使用しますが、<code class="literal">BTREE</code> インデックスもサポートしています。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="multiple-column-indexes"></a>8.3.6 マルチカラムインデックス</h3></div></div></div><a class="indexterm" name="idm45661478544528"></a><a class="indexterm" name="idm45661478543072"></a><a class="indexterm" name="idm45661478541040"></a><p>
        MySQL は複合インデックス (つまり、複数のカラムに対するインデックス) を作成できます。 インデックスは最大 16 カラムで構成できます。 特定のデータ型では、カラムのプリフィクスにインデックスを設定できます (<a class="xref" href="optimization.html#column-indexes" title="8.3.5 カラムインデックス">セクション8.3.5「カラムインデックス」</a>を参照してください)。 
      </p><p>
        MySQL では、インデックスで、すべてのカラムをテストするクエリーまたは最初のカラム、最初の 2 つのカラム、最初の 3 つのカラムというようにテストするクエリーにマルチカラムインデックスを使用できます。 インデックス定義の正しい順序でカラムを指定する場合、単一の複合インデックスにより、同じテーブルへの複数の種類のクエリーを高速化できます。 
      </p><p>
        マルチカラムインデックスは、インデックス設定されたカラムの値を連結して作成された値を格納する行である、ソート済みの配列とみなすことができます。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          複合インデックスの代わりに、ほかのカラムの情報に基づいて<span class="quote">「<span class="quote">ハッシュされた</span>」</span>カラムを導入できます。 このカラムが短く、十分に一意で、インデックスが設定されている場合は、多数のカラムへの<span class="quote">「<span class="quote">広範な</span>」</span>インデックスより速くなる可能性があります。 MySQL では、この追加カラムをきわめて簡単に使用できます。 
        </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>hash_col</code></em>=MD5(CONCAT(<em class="replaceable"><code>val1</code></em>,<em class="replaceable"><code>val2</code></em>))
  AND <em class="replaceable"><code>col1</code></em>=<em class="replaceable"><code>val1</code></em> AND <em class="replaceable"><code>col2</code></em>=<em class="replaceable"><code>val2</code></em>;
</pre></div><p>
        テーブルが次のような仕様であるとします。
      </p><pre class="programlisting">CREATE TABLE test (
    id         INT NOT NULL,
    last_name  CHAR(30) NOT NULL,
    first_name CHAR(30) NOT NULL,
    PRIMARY KEY (id),
    INDEX name (last_name,first_name)
);
</pre><p>
        <code class="literal">name</code> インデックスは、<code class="literal">last_name</code> カラムと <code class="literal">first_name</code> カラムに対するインデックスです。 このインデックスは、<code class="literal">last_name</code> 値と <code class="literal">first_name</code> 値の組み合わせに既知の範囲の値を指定するクエリーで、ルックアップに使用できます。 そのカラムはインデックスの左端のプリフィクスであるため、<code class="literal">last_name</code> 値だけを指定するクエリーにも使用できます (このセクションで後述するように)。 そのため、<code class="literal">name</code> インデックスは、次のクエリーでのルックアップに使用されます。 
      </p><pre class="programlisting">SELECT * FROM test WHERE last_name='Jones';

SELECT * FROM test
  WHERE last_name='Jones' AND first_name='John';

SELECT * FROM test
  WHERE last_name='Jones'
  AND (first_name='John' OR first_name='Jon');

SELECT * FROM test
  WHERE last_name='Jones'
  AND first_name &gt;='M' AND first_name &lt; 'N';
</pre><p>
        ただし、<code class="literal">name</code> インデックスは次のクエリーでのルックアップには使用<span class="emphasis"><em>されません</em></span>。
      </p><pre class="programlisting">SELECT * FROM test WHERE first_name='John';

SELECT * FROM test
  WHERE last_name='Jones' OR first_name='John';
</pre><p>
        次の <code class="literal">SELECT</code> ステートメントを発行するとします。
      </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE col1=<em class="replaceable"><code>val1</code></em> AND col2=<em class="replaceable"><code>val2</code></em>;
</pre><p>
        <code class="literal">col1</code> と <code class="literal">col2</code> に対するマルチカラムインデックスが存在する場合、該当する行を直接フェッチできます。 <code class="literal">col1</code> および <code class="literal">col2</code> に対して個別の単一カラムのインデックスが存在する場合、オプティマイザは、インデックスマージ最適化 (<a class="xref" href="optimization.html#index-merge-optimization" title="8.2.1.3 インデックスマージの最適化">セクション8.2.1.3「インデックスマージの最適化」</a>を参照してください) の使用を試みるか、またはより多くの行を除外するインデックスを判断して、そのインデックスを使用して行をフェッチすることで、もっとも制限の厳しいインデックスを見つけようとします。 
      </p><a class="indexterm" name="idm45661478507952"></a><a class="indexterm" name="idm45661478505824"></a><p>
        テーブルにマルチカラムインデックスがある場合、オプティマイザは、インデックスの左端のプリフィクスを使用して行をルックアップできます。 たとえば、<code class="literal">(col1, col2, col3)</code> に 3 カラムのインデックスがある場合、<code class="literal">(col1)</code>、<code class="literal">(col1, col2)</code>、および <code class="literal">(col1, col2, col3)</code> に対して、インデックス検索機能を使用できます。 
      </p><p>
        カラムがインデックスの左端のプリフィクスを形成していない場合、MySQL はこのインデックスを使用してルックアップを実行できません。 ここに示す <code class="literal">SELECT</code> ステートメントがあるとします。 
      </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE col1=<em class="replaceable"><code>val1</code></em>;
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE col1=<em class="replaceable"><code>val1</code></em> AND col2=<em class="replaceable"><code>val2</code></em>;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE col2=<em class="replaceable"><code>val2</code></em>;
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE col2=<em class="replaceable"><code>val2</code></em> AND col3=<em class="replaceable"><code>val3</code></em>;
</pre><p>
        <code class="literal">(col1, col2, col3)</code> にインデックスが存在する場合、最初の 2 つのクエリーだけがインデックスを使用します。 3 番目と 4 番目のクエリーにはインデックス付けされたカラムが含まれますが、<code class="literal">(col2)</code> および <code class="literal">(col2, col3)</code> は <code class="literal">(col1, col2, col3)</code> の左端の接頭辞ではないため、インデックスを使用してルックアップを実行しません。 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="verifying-index-usage"></a>8.3.7 インデックスの使用の確認</h3></div></div></div><p>
        すべてのクエリーがテーブル内に作成したインデックスを実際に使用していることを常に確認します。 <a class="xref" href="optimization.html#using-explain" title="8.8.1 EXPLAIN によるクエリーの最適化">セクション8.8.1「EXPLAIN によるクエリーの最適化」</a>に説明するように、<code class="literal">EXPLAIN</code> ステートメントを使用します。 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="index-statistics"></a>8.3.8 InnoDB および MyISAM インデックス統計コレクション</h3></div></div></div><p>
        ストレージエンジンはオプティマイザによって使用されるテーブルに関する統計を収集します。 テーブル統計は値グループに基づきますが、ここで値グループは同じキープリフィクス値を持つ行のセットです。 オプティマイザの目的で、重要な統計は平均値グループサイズです。 
      </p><p>
        MySQL は平均値グループサイズを次のように使用します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">ref</code> アクセスごとに読み取る必要がある行数を見積もるには
          </p></li><li class="listitem"><p>
            部分結合によって生成される行数、つまりフォームの操作によって生成される行数を見積もるため
          </p><pre class="programlisting">(...) JOIN <em class="replaceable"><code>tbl_name</code></em> ON <em class="replaceable"><code>tbl_name</code></em>.<em class="replaceable"><code>key</code></em> = <em class="replaceable"><code>expr</code></em>
</pre></li></ul></div><p>
        インデックスの平均値グループサイズが増えるほど、ルックアップあたりの平均行数が増えるため、それらの 2 つの目的でインデックスが役立たなくなります。インデックスが最適化の目的に役立つようにするには、各インデックス値でターゲットとするテーブル内の行を少なくすることがもっとも適切です。 指定したインデックス値が多数の行を生成する場合、そのインデックスはあまり役に立たず、MySQL がそれを使用する可能性は少なくなります。 
      </p><p>
        平均値グループサイズは、値グループの数であるテーブルカーディナリティーと関連しています。 <code class="literal">SHOW INDEX</code> ステートメントは、<em class="replaceable"><code>N/S</code></em> に基づいて、カーディナリティー値を表示します。ここで <em class="replaceable"><code>N</code></em> はテーブル内の行数で、<em class="replaceable"><code>S</code></em> は平均値グループサイズです。 その比率から、テーブル内の値グループの概数がわかります。 
      </p><p>
        <code class="literal">&lt;=&gt;</code> 比較演算子に基づいた結合では、<code class="literal">NULL</code> の扱いはほかの値と異なりません。ほかのどの <em class="replaceable"><code>N</code></em> に対しても <code class="literal"><em class="replaceable"><code>N</code></em> &lt;=&gt; <em class="replaceable"><code>N</code></em></code> とまったく同じように、<code class="literal">NULL &lt;=&gt; NULL</code> です。
      </p><p>
        ただし、<code class="literal">=</code> 演算子に基づく結合では、<code class="literal">NULL</code> は <code class="literal">NULL</code> 以外の値と異なります。<em class="replaceable"><code>expr1</code></em> または <em class="replaceable"><code>expr2</code></em> (または両方) が <code class="literal">NULL</code> である場合、<code class="literal"><em class="replaceable"><code>expr1</code></em> = <em class="replaceable"><code>expr2</code></em></code> は true になりません。 これは、<code class="literal"><em class="replaceable"><code>tbl_name.key</code></em> = <em class="replaceable"><code>expr</code></em></code> 形式の比較のための <code class="literal">ref</code> アクセスに影響: 比較は true にできないため、<em class="replaceable"><code>expr</code></em> の現在の値が <code class="literal">NULL</code> の場合、MySQL はテーブルにアクセスしません。 
      </p><p>
        <code class="literal">=</code> 比較では、テーブルにある <code class="literal">NULL</code> 値の数は問題になりません。 最適化の目的で、関連のある値は <code class="literal">NULL</code> 以外の値グループの平均サイズです。 ただし、MySQL では現在その平均サイズを収集したり、使用したりできません。 
      </p><p>
        <code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> テーブルでは、<code class="literal">innodb_stats_method</code> および <code class="literal">myisam_stats_method</code> システム変数をそれぞれ使用して、テーブル統計のコレクションに対していくらかの制御ができます。 これらの変数には、3 つの可能性のある値を使用でき、次のように異なります。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            変数が <code class="literal">nulls_equal</code> に設定されている場合、すべての <code class="literal">NULL</code> 値が同一として扱われます (つまり、それらすべてが単一の値グループを形成します)。
          </p><p>
            <code class="literal">NULL</code> 値グループサイズが、<code class="literal">NULL</code> 以外の値グループサイズよりはるかに大きい場合、このメソッドは平均値グループサイズを上方に歪めます。 これにより、オプティマイザには、<code class="literal">NULL</code> 以外の値を検索する結合に対して、インデックスが実際以上に役に立たないかのように見えます。 結果として、<code class="literal">nulls_equal</code> メソッドにより、オプティマイザに <code class="literal">ref</code> アクセスに対してインデックスを使用すべきときでも使用させないようにすることがあります。 
          </p></li><li class="listitem"><p>
            変数が <code class="literal">nulls_unequal</code> に設定されている場合、<code class="literal">NULL</code> 値は同じとみなされません。 代わりに、各 <code class="literal">NULL</code> 値はサイズ 1 の個別の値グループを形成します。 
          </p><p>
            多くの <code class="literal">NULL</code> 値がある場合、このメソッドは平均値グループサイズを下方に歪めます。 <code class="literal">NULL</code> 以外の平均値グループサイズが大きい場合、<code class="literal">NULL</code> 値をサイズ 1 のグループとしてカウントすると、オプティマイザは <code class="literal">NULL</code> 以外の値を検索する結合に対して、インデックスの値を多く見積もりすぎます。 結果として、<code class="literal">nulls_unequal</code> メソッドによって、ほかのメソッドの方が適している可能性がある場合に、オプティマイザに <code class="literal">ref</code> ルックアップに対してこのインデックスを使用させることがあります。 
          </p></li><li class="listitem"><p>
            変数が <code class="literal">nulls_ignored</code> に設定されている場合、<code class="literal">NULL</code> 値は無視されます。
          </p></li></ul></div><p>
        <code class="literal">=</code> より <code class="literal">&lt;=&gt;</code> を使用する多くの結合を使用する傾向がある場合、比較で <code class="literal">NULL</code> 値は特別ではなく、<code class="literal">NULL</code> は互いに等しくなります。 この場合、<code class="literal">nulls_equal</code> は適切な統計メソッドです。 
      </p><p>
        <code class="literal">innodb_stats_method</code> システム変数にはグローバル値があります。<code class="literal">myisam_stats_method</code> システム変数にはグローバル値とセッション値の両方があります。 グローバル値を設定すると、対応するストレージエンジンからのテーブルの統計収集に影響します。 セッション値を設定すると、現在のクライアント接続のみに対する統計収集に影響します。 つまり、<code class="literal">myisam_stats_method</code> のセッション値を設定することで、他のクライアントに影響を与えることなく、特定の方法でテーブル統計を強制的に再生成できます。 
      </p><p>
        <code class="literal">MyISAM</code> テーブルの統計を再生成するには、次のいずれかの方法を使用できます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="command"><strong>myisamchk --stats_method=<em class="replaceable"><code>method_name</code></em> --analyze</strong></span> を実行します
          </p></li><li class="listitem"><p>
            テーブルを変更して、統計を古くさせ (たとえば、行を挿入してから削除します)、次に <code class="literal">myisam_stats_method</code> を設定して、<code class="literal">ANALYZE TABLE</code> ステートメントを発行します。
          </p></li></ul></div><p>
        <code class="literal">innodb_stats_method</code> と <code class="literal">myisam_stats_method</code> の使用に関するいくつかの警告は次のとおりです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            先述したように、テーブル統計を明示的に収集させることができます。 ただし、MySQL は統計を自動的に収集することもあります。 たとえば、テーブルへのステートメントの実行の途中で、そうしたステートメントの中にはテーブルを変更するものもあり、MySQL は統計を収集する場合があります。 (たとえば、これは一括挿入や削除、または一部の <code class="literal">ALTER TABLE</code> ステートメントで行われることがあります。) これが行われた場合、その時点での <code class="literal">innodb_stats_method</code> または <code class="literal">myisam_stats_method</code> の値を使用して、統計が収集されます。 したがって、一方の方法を使用して統計を収集し、後でテーブル統計が自動的に収集されるときにシステム変数がもう一方の方法に設定されている場合は、もう一方の方法が使用されます。 
          </p></li><li class="listitem"><p>
            特定のテーブルの統計の生成に使用されたメソッドを伝える方法はありません。
          </p></li><li class="listitem"><p>
            これらの変数は <code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> テーブルにのみ適用されます。 ほかのストレージエンジンはテーブル統計を収集するメソッドが 1 つしかありません。 通常、それは <code class="literal">nulls_equal</code> メソッドに近いものになります。 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="index-btree-hash"></a>8.3.9 B ツリーインデックスとハッシュインデックスの比較</h3></div></div></div><a class="indexterm" name="idm45661478400592"></a><a class="indexterm" name="idm45661478399104"></a><p>
        B ツリーおよびハッシュデータ構造を理解することは、インデックスにこれらのデータ構造を使用するさまざまなストレージエンジンで (特に B ツリーインデックスを使用するか、ハッシュインデックスを使用するかを選択できる <code class="literal">MEMORY</code> ストレージエンジンの場合に)、さまざまなクエリーがどのように実行されるかを予測するのに役立つ可能性があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#btree-index-characteristics" title="B ツリーインデックスの特性">B ツリーインデックスの特性</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#hash-index-characteristics" title="ハッシュインデックスの特性">ハッシュインデックスの特性</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="btree-index-characteristics"></a>B ツリーインデックスの特性</h4></div></div></div><a class="indexterm" name="idm45661478392112"></a><a class="indexterm" name="idm45661478389984"></a><a class="indexterm" name="idm45661478387920"></a><a class="indexterm" name="idm45661478385888"></a><p>
          B ツリーインデックスは <code class="literal">=</code>、<code class="literal">&gt;</code>、<code class="literal">&gt;=</code>、<code class="literal">&lt;</code>、<code class="literal">&lt;=</code>、または <code class="literal">BETWEEN</code> 演算子を使用する式で、カラム比較に使用できます。 このインデックスは、<code class="literal">LIKE</code> への引数がワイルドカード文字で始まらない定数文字列の場合の <code class="literal">LIKE</code> 比較にも使用できます。 たとえば、次の <code class="literal">SELECT</code> ステートメントはインデックスを使用します。 
        </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> LIKE 'Patrick%';
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> LIKE 'Pat%_ck%';
</pre><p>
          最初のステートメントでは、<code class="literal">'Patrick' &lt;= <em class="replaceable"><code>key_col</code></em> &lt; 'Patricl'</code> の行のみが考慮されます。 2 つめのステートメントでは、<code class="literal">'Pat' &lt;= <em class="replaceable"><code>key_col</code></em> &lt; 'Pau'</code> の行のみが考慮されます。 
        </p><p>
          次の <code class="literal">SELECT</code> ステートメントはインデックスを使用しません。
        </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> LIKE '%Patrick%';
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> LIKE <em class="replaceable"><code>other_col</code></em>;
</pre><p>
          最初のステートメントでは、<code class="literal">LIKE</code> 値はワイルドカード文字で始まります。 2 つめのステートメントでは、<code class="literal">LIKE</code> 値は定数ではありません。 
        </p><p>
          <code class="literal">... LIKE '%<em class="replaceable"><code>string</code></em>%'</code> を使用し、<em class="replaceable"><code>string</code></em> が 3 文字より長い場合、MySQL は <span class="firstterm">Turbo Boyer-Moore アルゴリズム</span>を使用して、文字列のパターンを初期化してから、このパターンを使用して検索をより迅速に実行します。
        </p><a class="indexterm" name="idm45661478356656"></a><a class="indexterm" name="idm45661478354480"></a><p>
          <code class="literal"><em class="replaceable"><code>col_name</code></em> IS NULL</code> を使用した検索では、<em class="replaceable"><code>col_name</code></em> にインデックスが設定されている場合にインデックスが使用されます。
        </p><p>
          <code class="literal">WHERE</code> 句内のすべての <code class="literal">AND</code> レベルにまたがっていないインデックスは、クエリーの最適化に使用されません。 言い換えると、インデックスの使用を可能にするには、インデックスのプリフィクスがすべての <code class="literal">AND</code> グループで使用されている必要があります。 
        </p><p>
          次の <code class="literal">WHERE</code> 句ではインデックスが使用されます。
        </p><pre class="programlisting">... WHERE <em class="replaceable"><code>index_part1</code></em>=1 AND <em class="replaceable"><code>index_part2</code></em>=2 AND <em class="replaceable"><code>other_column</code></em>=3

    /* <em class="replaceable"><code>index</code></em> = 1 OR <em class="replaceable"><code>index</code></em> = 2 */
... WHERE <em class="replaceable"><code>index</code></em>=1 OR A=10 AND <em class="replaceable"><code>index</code></em>=2

    /* optimized like "<em class="replaceable"><code>index_part1</code></em>='hello'" */
... WHERE <em class="replaceable"><code>index_part1</code></em>='hello' AND <em class="replaceable"><code>index_part3</code></em>=5

    /* Can use index on <em class="replaceable"><code>index1</code></em> but not on <em class="replaceable"><code>index2</code></em> or <em class="replaceable"><code>index3</code></em> */
... WHERE <em class="replaceable"><code>index1</code></em>=1 AND <em class="replaceable"><code>index2</code></em>=2 OR <em class="replaceable"><code>index1</code></em>=3 AND <em class="replaceable"><code>index3</code></em>=3;
</pre><p>
          これらの <code class="literal">WHERE</code> 句ではインデックスが使用<span class="emphasis"><em>されません</em></span>。
        </p><pre class="programlisting">    /* <em class="replaceable"><code>index_part1</code></em> is not used */
... WHERE <em class="replaceable"><code>index_part2</code></em>=1 AND <em class="replaceable"><code>index_part3</code></em>=2

    /*  Index is not used in both parts of the WHERE clause  */
... WHERE <em class="replaceable"><code>index</code></em>=1 OR A=10

    /* No index spans all rows  */
... WHERE <em class="replaceable"><code>index_part1</code></em>=1 OR <em class="replaceable"><code>index_part2</code></em>=10
</pre><p>
          MySQL ではインデックスが使用できる場合でも使用しないことがあります。 これが発生する 1 つの状況は、オプティマイザが、インデックスを使用することによって MySQL がテーブルの大部分の行にアクセスする必要があると推定した場合です。 (この場合、必要なシークが少ないため、テーブルスキャンの方がはるかに高速になる可能性があります。)  ただし、そのようなクエリーで、行の一部のみを取得する <code class="literal">LIMIT</code> を使用している場合、結果で返す少数の行をはるかにすばやく見つけることができるため、MySQL はとにかくインデックスを使用します。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="hash-index-characteristics"></a>ハッシュインデックスの特性</h4></div></div></div><a class="indexterm" name="idm45661478328224"></a><p>
          ハッシュインデックスは先述したものといくらか異なる特性を持ちます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              それらは、<code class="literal">=</code> または <code class="literal">&lt;=&gt;</code> 演算子を使用する等価比較にのみ使用されます (ただし<span class="emphasis"><em>きわめて</em></span>高速です)。 それらは、値の範囲を見つける <code class="literal">&lt;</code> などの比較演算子には使用されません。 この種類の単一値ルックアップに依存するシステムは、<span class="quote">「<span class="quote">キー値ストア</span>」</span>として知られています。そのようなアプリケーションで MySQL を使用するには、可能なかぎりハッシュインデックスを使用します。 
            </p></li><li class="listitem"><p>
              オプティマイザはハッシュインデックスを使用して、<code class="literal">ORDER BY</code> 操作を高速化することはできません。 (この種類のインデックスは順番に次のエントリを検索するために使用できません。) 
            </p></li><li class="listitem"><p>
              MySQL は 2 つの値の間におよそどのくらいの行数があるかを判断できません (これは範囲オプティマイザによって使用するインデックスを特定するために使用されます)。 これは、<code class="literal">MyISAM</code> または <code class="literal">InnoDB</code> テーブルをハッシュインデックス設定された <code class="literal">MEMORY</code> テーブルに変更した場合に、一部のクエリーに影響することがあります。 
            </p></li><li class="listitem"><p>
              行の検索にはキー全体のみを使用できます。 (B ツリーインデックスでは、キーの任意の左端のプリフィクスを使用して行を検索できます。) 
            </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="index-extensions"></a>8.3.10 インデックス拡張の使用</h3></div></div></div><a class="indexterm" name="idm45661478312976"></a><p>
        <code class="literal">InnoDB</code> は、自動的に各セカンダリインデックスに主キーカラムを追加して、それを拡張します。 このテーブル定義について考えます。 
      </p><pre class="programlisting">CREATE TABLE t1 (
  i1 INT NOT NULL DEFAULT 0,
  i2 INT NOT NULL DEFAULT 0,
  d DATE DEFAULT NULL,
  PRIMARY KEY (i1, i2),
  INDEX k_d (d)
) ENGINE = InnoDB;
</pre><p>
        このテーブルでは、カラム <code class="literal">(i1, i2)</code> に主キーを定義しています。 さらに、カラム <code class="literal">(d)</code> にセカンダリインデックス <code class="literal">k_d</code> を定義していますが、内部で <code class="literal">InnoDB</code> はこのインデックスを拡張し、それをカラム <code class="literal">(d, i1, i2)</code> として処理します。 
      </p><p>
        オプティマイザは、拡張セカンダリインデックスの主キーカラムを考慮して、そのインデックスを使用する方法と使用するかどうかを決定します。 これにより、クエリー実行計画の効率が向上し、パフォーマンスが向上する可能性があります。 
      </p><p>
        オプティマイザは、<code class="literal">ref</code>、<code class="literal">range</code> および <code class="literal">index_merge</code> のインデックスアクセス、ルーズインデックススキャンアクセス、結合およびソートの最適化、<code class="literal">MIN()</code>/<code class="literal">MAX()</code> の最適化に拡張セカンダリインデックスを使用できます。
      </p><p>
        次の例に、オプティマイザが拡張セカンダリインデックスを使用するかどうかによって、実行プランにどのような影響を与えるか示します。 これらの行に <code class="literal">t1</code> が移入されているとします。 
      </p><pre class="programlisting">INSERT INTO t1 VALUES
(1, 1, '1998-01-01'), (1, 2, '1999-01-01'),
(1, 3, '2000-01-01'), (1, 4, '2001-01-01'),
(1, 5, '2002-01-01'), (2, 1, '1998-01-01'),
(2, 2, '1999-01-01'), (2, 3, '2000-01-01'),
(2, 4, '2001-01-01'), (2, 5, '2002-01-01'),
(3, 1, '1998-01-01'), (3, 2, '1999-01-01'),
(3, 3, '2000-01-01'), (3, 4, '2001-01-01'),
(3, 5, '2002-01-01'), (4, 1, '1998-01-01'),
(4, 2, '1999-01-01'), (4, 3, '2000-01-01'),
(4, 4, '2001-01-01'), (4, 5, '2002-01-01'),
(5, 1, '1998-01-01'), (5, 2, '1999-01-01'),
(5, 3, '2000-01-01'), (5, 4, '2001-01-01'),
(5, 5, '2002-01-01');
</pre><p>
        ここで次のクエリーを考慮します。
      </p><pre class="programlisting">EXPLAIN SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01'
</pre><p>
        実行計画は、拡張インデックスが使用されているかどうかによって異なります。
      </p><p>
        オプティマイザがインデックス拡張を考慮しない場合、それはインデックス <code class="literal">k_d</code> を <code class="literal">(d)</code> のみとして扱います。 クエリーの <code class="literal">EXPLAIN</code> では次の結果が生成されます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01'\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
         type: ref
possible_keys: PRIMARY,k_d
          key: k_d
      key_len: 4
          ref: const
         rows: 5
        Extra: Using where; Using index
</pre><p>
        オプティマイザがインデックス拡張を考慮する場合、それはインデックス <code class="literal">k_d</code> を <code class="literal">(d, i1, i2)</code> として扱います。 この場合、それは左端のインデックスプリフィクス <code class="literal">(d, i1)</code> を使用して、より適切な実行プランを生成できます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01'\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
         type: ref
possible_keys: PRIMARY,k_d
          key: k_d
      key_len: 8
          ref: const,const
         rows: 1
        Extra: Using index
</pre><p>
        どちらの場合も、<code class="literal">key</code> はオプティマイザがセカンダリインデックス <code class="literal">k_d</code> を使用することを示しますが、<code class="literal">EXPLAIN</code> 出力には拡張インデックスの使用による次の改善点が示されています:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">key_len</code> は 4 バイトから 8 バイトになり、キールックアップでカラム <code class="literal">d</code> だけでなく、<code class="literal">d</code> と <code class="literal">i1</code> も使用されていることを示しています。
          </p></li><li class="listitem"><p>
            キールックアップで 1 つではなく 2 つのキーパートが使用されるため、<code class="literal">ref</code> 値が <code class="literal">const</code> から <code class="literal">const,const</code> に変更されています。
          </p></li><li class="listitem"><p>
            <code class="literal">rows</code> 数は 5 から 1 に減少し、<code class="literal">InnoDB</code> が結果を生成するために調査する必要がある行数が少なくなることを示しています。
          </p></li><li class="listitem"><p>
            <code class="literal">Extra</code> 値が <code class="literal">Using where; Using index</code> から <code class="literal">Using index</code> に変更されています。 このことは、データ行のカラムを参照せずに、インデックスのみを使用して、行を読み取れることを意味します。 
          </p></li></ul></div><p>
        拡張インデックスの使用のオプティマイザの動作の違いは、<code class="literal">SHOW STATUS</code> でも確認できます。
      </p><pre class="programlisting">FLUSH TABLE t1;
FLUSH STATUS;
SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01';
SHOW STATUS LIKE 'handler_read%'
</pre><p>
        前述のステートメントには、テーブルキャッシュをフラッシュしてステータスカウンタをクリアする <code class="literal">FLUSH TABLES</code> および <code class="literal">FLUSH STATUS</code> が含まれています。
      </p><p>
        インデックス拡張を使用しないと、<code class="literal">SHOW STATUS</code> は次の結果を生成します。
      </p><pre class="programlisting">+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| Handler_read_first    | 0     |
| Handler_read_key      | 1     |
| Handler_read_last     | 0     |
| Handler_read_next     | 5     |
| Handler_read_prev     | 0     |
| Handler_read_rnd      | 0     |
| Handler_read_rnd_next | 0     |
+-----------------------+-------+
</pre><p>
        インデックス拡張を使用すると、<code class="literal">SHOW STATUS</code> は次の結果を生成します。 <code class="literal">Handler_read_next</code> 値が 5 から 1 に減少し、インデックスをより効率的に使用していることを示しています。 
      </p><pre class="programlisting">+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| Handler_read_first    | 0     |
| Handler_read_key      | 1     |
| Handler_read_last     | 0     |
| Handler_read_next     | 1     |
| Handler_read_prev     | 0     |
| Handler_read_rnd      | 0     |
| Handler_read_rnd_next | 0     |
+-----------------------+-------+
</pre><p>
        <code class="literal">optimizer_switch</code> システム変数の <code class="literal">use_index_extensions</code> フラグを使用すると、<code class="literal">InnoDB</code> テーブルのセカンダリ索引の使用方法を決定するときにオプティマイザが主キーカラムを考慮するかどうかを制御できます。 デフォルトで、<code class="literal">use_index_extensions</code> は有効です。 インデックス拡張機能の使用を無効にするとパフォーマンスが向上するかどうかを確認するには、次のステートメントを使用します: 
      </p><pre class="programlisting">SET optimizer_switch = 'use_index_extensions=off';
</pre><p>
        オプティマイザによるインデックス拡張の使用は、インデックス (16) のキーパートの数と最大キー長 (3072 バイト) への通常の制限によります。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="generated-column-index-optimizations"></a>8.3.11 生成されたカラムインデックスのオプティマイザによる使用</h3></div></div></div><p>
        MySQL では、生成されたカラムのインデックスがサポートされます。 例: 
      </p><pre class="programlisting">CREATE TABLE t1 (f1 INT, gc INT AS (f1 + 1) STORED, INDEX (gc));
</pre><p>
        生成されたカラム <code class="literal">gc</code> は、式 <code class="literal">f1 + 1</code> として定義されます。 カラムもインデックス付けされ、オプティマイザは実行計画の構成時にそのインデックスを考慮できます。 次のクエリーでは、<code class="literal">WHERE</code> 句が <code class="literal">gc</code> を参照し、オプティマイザはそのカラムのインデックスがより効率的な計画をもたらすかどうかを考慮します: 
      </p><pre class="programlisting">SELECT * FROM t1 WHERE gc &gt; 9;
</pre><p>
        オプティマイザは、生成されたカラムのインデックスを使用して実行計画を生成できます。これらのカラムへの名前によるクエリーに直接参照がない場合でも同様です。 これは、<code class="literal">WHERE</code>、<code class="literal">ORDER BY</code> または <code class="literal">GROUP BY</code> 句が、インデックス付けされた生成カラムの定義と一致する式を参照している場合に発生します。 次のクエリーは、<code class="literal">gc</code> を直接参照しませんが、<code class="literal">gc</code> の定義と一致する式を使用します: 
      </p><pre class="programlisting">SELECT * FROM t1 WHERE f1 + 1 &gt; 9;
</pre><p>
        オプティマイザは、式 <code class="literal">f1 + 1</code> が <code class="literal">gc</code> の定義と一致し、<code class="literal">gc</code> がインデックス付けされていることを認識するため、実行計画の構成時にそのインデックスが考慮されます。 これは、<code class="literal">EXPLAIN</code> を使用して表示できます: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM t1 WHERE f1 + 1 &gt; 9\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
   partitions: NULL
         type: range
possible_keys: gc
          key: gc
      key_len: 5
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: Using index condition
</pre><p>
        実際には、オプティマイザは式 <code class="literal">f1 + 1</code> を、式に一致する生成されたカラムの名前に置き換えています。 これは、<code class="literal">SHOW WARNINGS</code> によって表示される拡張 <code class="literal">EXPLAIN</code> 情報で使用可能なリライトされたクエリーでもわかります: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`gc`
         AS `gc` from `test`.`t1` where (`test`.`t1`.`gc` &gt; 9)
</pre><p>
        生成されたカラムインデックスのオプティマイザでの使用には、次の制限および条件が適用されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            クエリー式が生成されたカラム定義と一致するには、式が同一であり、同じ結果タイプである必要があります。 たとえば、生成されたカラム式が <code class="literal">f1 + 1</code> の場合、クエリーで <code class="literal">1 + f1</code> が使用されているか、<code class="literal">f1 + 1</code> (整数式) が文字列と比較されても、オプティマイザは一致を認識しません。 
          </p></li><li class="listitem"><p>
            最適化はこれらの演算子に適用されます: <code class="literal">=</code>, <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>, <code class="literal">&gt;</code>, <code class="literal">&gt;=</code>, <code class="literal">BETWEEN</code> および <code class="literal">IN()</code>。
          </p><p>
            <code class="literal">BETWEEN</code> および <code class="literal">IN()</code> 以外の演算子の場合、どちらのオペランドも一致する生成されたカラムで置換できます。 <code class="literal">BETWEEN</code> および <code class="literal">IN()</code> の場合、最初の引数のみが一致する生成されたカラムで置換でき、他の引数の結果タイプは同じである必要があります。 <code class="literal">BETWEEN</code> および <code class="literal">IN()</code> は、JSON 値を含む比較ではまだサポートされていません。 
          </p></li><li class="listitem"><p>
            生成されたカラムは、少なくとも関数コールまたは前述のいずれかの演算子を含む式として定義する必要があります。 式は、別のカラムへの単純な参照で構成できません。 たとえば、<code class="literal">gc INT AS (f1) STORED</code> はカラム参照のみで構成されるため、<code class="literal">gc</code> のインデックスは考慮されません。 
          </p></li><li class="listitem"><p>
            引用符で囲まれた文字列を返す JSON 関数の値を計算するインデックス付き生成カラムと文字列を比較するには、関数値から余分な引用符を削除するために、カラム定義に <code class="literal">JSON_UNQUOTE()</code> が必要です。 (文字列と関数の結果を直接比較する場合、JSON コンパレータは引用符の削除を処理しますが、これはインデックスルックアップでは発生しません。) たとえば、次のようなカラム定義を記述するかわりに: 
          </p><pre class="programlisting">doc_name TEXT AS (JSON_EXTRACT(jdoc, '$.name')) STORED
</pre><p>
            次のように記述します:
          </p><pre class="programlisting">doc_name TEXT AS (JSON_UNQUOTE(JSON_EXTRACT(jdoc, '$.name'))) STORED
</pre><p>
            後者の定義では、オプティマイザは次の両方の比較で一致を検出できます:
          </p><pre class="programlisting">... WHERE JSON_EXTRACT(jdoc, '$.name') = '<em class="replaceable"><code>some_string</code></em>' ...
... WHERE JSON_UNQUOTE(JSON_EXTRACT(jdoc, '$.name')) = '<em class="replaceable"><code>some_string</code></em>' ...
</pre><p>
            カラム定義に <code class="literal">JSON_UNQUOTE()</code> が指定されていない場合、オプティマイザはこれらの最初の比較に対してのみ一致を検出します。
          </p></li><li class="listitem"><p>
            オプティマイザが間違ったインデックスを選択した場合は、インデックスヒントを使用して無効にし、オプティマイザに別の選択を強制できます。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="invisible-indexes"></a>8.3.12 不可視のインデックス</h3></div></div></div><a class="indexterm" name="idm45661478186528"></a><p>
        MySQL では、不可視のインデックス (オプティマイザで使用されないインデックス) がサポートされています。 この機能は、主キー以外のインデックス (明示的または暗黙的) に適用されます。 
      </p><p>
        インデックスはデフォルトで可視化されます。 新しいインデックスの可視性を明示的に制御するには、<code class="literal">CREATE TABLE</code>、<code class="literal">CREATE INDEX</code> または <code class="literal">ALTER TABLE</code> のインデックス定義の一部として <code class="literal">VISIBLE</code> または <code class="literal">INVISIBLE</code> キーワードを使用します: 
      </p><pre class="programlisting">CREATE TABLE t1 (
  i INT,
  j INT,
  k INT,
  INDEX i_idx (i) INVISIBLE
) ENGINE = InnoDB;
CREATE INDEX j_idx ON t1 (j) INVISIBLE;
ALTER TABLE t1 ADD INDEX k_idx (k) INVISIBLE;
</pre><p>
        既存のインデックスの可視性を変更するには、<code class="literal">ALTER TABLE ... ALTER INDEX</code> 操作で <code class="literal">VISIBLE</code> または <code class="literal">INVISIBLE</code> キーワードを使用します:
      </p><pre class="programlisting">ALTER TABLE t1 ALTER INDEX i_idx INVISIBLE;
ALTER TABLE t1 ALTER INDEX i_idx VISIBLE;
</pre><p>
        インデックスが可視か不可視かに関する情報は、<code class="literal">INFORMATION_SCHEMA.STATISTICS</code> テーブルまたは <code class="literal">SHOW INDEX</code> 出力から入手できます。 例: 
      </p><a class="indexterm" name="idm45661478171744"></a><a class="indexterm" name="idm45661478169568"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT INDEX_NAME, IS_VISIBLE</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.STATISTICS</code></strong>
       <strong class="userinput"><code>WHERE TABLE_SCHEMA = 'db1' AND TABLE_NAME = 't1';</code></strong>
+------------+------------+
| INDEX_NAME | IS_VISIBLE |
+------------+------------+
| i_idx      | YES        |
| j_idx      | NO         |
| k_idx      | NO         |
+------------+------------+
</pre><p>
        不可視のインデックスを使用すると、インデックスが必要になった場合に元に戻す必要がある破壊的な変更を行わずに、クエリーのパフォーマンスに対するインデックスの削除の影響をテストできます。 大規模なテーブルの場合、インデックスを削除して再追加するとコストがかかる可能性がありますが、インデックスを非表示にして可視にすると、高速なインプレース操作になります。 
      </p><p>
        インデックスが実際に不可視になった場合、またはオプティマイザによって使用された場合は、そのインデックスが存在しないことがテーブルのクエリーに与える影響に注意する方法がいくつかあります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            不可視インデックスを参照するインデックスヒントを含むクエリーでは、エラーが発生します。
          </p></li><li class="listitem"><p>
            パフォーマンススキーマデータは、影響を受けるクエリーのワークロードの増加を示します。
          </p></li><li class="listitem"><p>
            クエリーには、異なる <code class="literal">EXPLAIN</code> 実行計画があります。
          </p></li><li class="listitem"><p>
            クエリーは、以前に表示されていなかったスロークエリーログに表示されます。
          </p></li></ul></div><a class="indexterm" name="idm45661478156800"></a><a class="indexterm" name="idm45661478154512"></a><p>
        <code class="literal">optimizer_switch</code> システム変数の <code class="literal">use_invisible_indexes</code> フラグは、オプティマイザがクエリー実行計画の構成に不可視のインデックスを使用するかどうかを制御します。 フラグが <code class="literal">off</code> (デフォルト) の場合、オプティマイザは不可視のインデックス (このフラグの導入前と同じ動作) を無視します。 フラグが <code class="literal">on</code> の場合、不可視のインデックスは不可視のままですが、オプティマイザは実行計画の構成を考慮に入れます。 
      </p><p>
        <code class="literal">SET_VAR</code> オプティマイザヒントを使用して一時的に <code class="literal">optimizer_switch</code> の値を更新すると、次のように、単一のクエリーの間のみ不可視インデックスを有効にできます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT /*+ SET_VAR(optimizer_switch = 'use_invisible_indexes=on') */</code></strong>
     &gt; <strong class="userinput"><code>    i, j FROM t1 WHERE j &gt;= 50\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
   partitions: NULL
         type: range
possible_keys: j_idx
          key: j_idx
      key_len: 5
          ref: NULL
         rows: 2
     filtered: 100.00
        Extra: Using index condition

mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT i, j FROM t1 WHERE j &gt;= 50\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 5
     filtered: 33.33
        Extra: Using where
</pre><p>
        インデックスの可視性は、インデックスメンテナンスには影響しません。 たとえば、インデックスはテーブルの行に対する変更ごとに引き続き更新され、一意のインデックスによって、インデックスが可視か不可視かに関係なく、カラムへの重複の挿入が防止されます。 
      </p><p>
        明示的な主キーを持たないテーブルは、<code class="literal">NOT NULL</code> カラムに <code class="literal">UNIQUE</code> インデックスがある場合でも、有効な暗黙的主キーを持つことができます。 この場合、最初のこのようなインデックスは明示的な主キーと同じ制約をテーブルの行に配置し、そのインデックスを不可視にすることはできません。 次のテーブル定義について考えてみます: 
      </p><pre class="programlisting">CREATE TABLE t2 (
  i INT NOT NULL,
  j INT NOT NULL,
  UNIQUE j_idx (j)
) ENGINE = InnoDB;
</pre><p>
        この定義には明示的な主キーは含まれていませんが、<code class="literal">NOT NULL</code> カラム <code class="literal">j</code> のインデックスは主キーと同じ制約を行に設定し、非表示にすることはできません:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE t2 ALTER INDEX j_idx INVISIBLE;</code></strong>
ERROR 3522 (HY000): A primary key index cannot be invisible.
</pre><p>
        ここで、明示的な主キーがテーブルに追加されるとします:
      </p><pre class="programlisting">ALTER TABLE t2 ADD PRIMARY KEY (i);
</pre><p>
        明示的な主キーは非表示にできません。 また、<code class="literal">j</code> の一意インデックスは暗黙的主キーとして機能しなくなり、その結果非表示になる可能性があります: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE t2 ALTER INDEX j_idx INVISIBLE;</code></strong>
Query OK, 0 rows affected (0.03 sec)
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="descending-indexes"></a>8.3.13 降順インデックス</h3></div></div></div><a class="indexterm" name="idm45661478126352"></a><a class="indexterm" name="idm45661478124896"></a><p>
        MySQL は降順インデックスをサポートしています: インデックス定義内の <code class="literal">DESC</code> は無視されなくなりましたが、キー値が降順で格納されます。 以前は、インデックスを逆の順序でスキャンできましたが、パフォーマンスが低下していました。 降順インデックスは順にスキャンできるため、より効率的です。 降順インデックスを使用すると、オプティマイザが複数カラムインデックスを使用できるようになります (最も効率的なスキャン順序で一部のカラムに昇順が混在し、他のカラムに降順が混在している場合)。 
      </p><p>
        カラムの昇順インデックスと降順インデックスの様々な組合せに対する 2 つのカラムと 4 つの 2 カラムインデックス定義を含む、次のテーブル定義について考えてみます:
      </p><pre class="programlisting">CREATE TABLE t (
  c1 INT, c2 INT,
  INDEX idx1 (c1 ASC, c2 ASC),
  INDEX idx2 (c1 ASC, c2 DESC),
  INDEX idx3 (c1 DESC, c2 ASC),
  INDEX idx4 (c1 DESC, c2 DESC)
);
</pre><p>
        テーブル定義の結果、4 つの個別インデックスが作成されます。 オプティマイザは、各 <code class="literal">ORDER BY</code> 句に対して正引きインデックススキャンを実行できるため、<code class="literal">filesort</code> 操作を使用する必要はありません: 
      </p><pre class="programlisting">ORDER BY c1 ASC, c2 ASC    -- optimizer can use idx1
ORDER BY c1 DESC, c2 DESC  -- optimizer can use idx4
ORDER BY c1 ASC, c2 DESC   -- optimizer can use idx2
ORDER BY c1 DESC, c2 ASC   -- optimizer can use idx3
</pre><p>
        降順インデックスの使用には、次の条件があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            降順インデックスは <code class="literal">InnoDB</code> ストレージエンジンでのみサポートされますが、次の制限があります:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                インデックスに降順のインデックスキーカラムが含まれている場合、または主キーに降順のインデックスカラムが含まれている場合、変更バッファリングはセカンダリインデックスではサポートされません。
              </p></li><li class="listitem"><p>
                <code class="literal">InnoDB</code> SQL パーサーは降順インデックスを使用しません。 <code class="literal">InnoDB</code> 全文検索の場合、これは、インデックス付きテーブルの <code class="literal">FTS_DOC_ID</code> カラムに必要なインデックスを降順インデックスとして定義できないことを意味します。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index" title="15.6.2.4 InnoDB FULLTEXT インデックス">セクション15.6.2.4「InnoDB FULLTEXT インデックス」</a>を参照してください。 
              </p></li></ul></div></li><li class="listitem"><p>
            降順インデックスは、昇順インデックスが使用可能なすべてのデータ型でサポートされています。
          </p></li><li class="listitem"><p>
            降順インデックスは、通常の (生成されない) カラムおよび生成されるカラム (<code class="literal">VIRTUAL</code> と <code class="literal">STORED</code> の両方) でサポートされます。
          </p></li><li class="listitem"><p>
            <code class="literal">DISTINCT</code> では、降順のキー部分など、一致するカラムを含む任意のインデックスを使用できます。
          </p></li><li class="listitem"><p>
            降順のキー部分を持つインデックスは、集計関数を呼び出すが <code class="literal">GROUP BY</code> 句を持たないクエリーの <code class="literal">MIN()</code>/<code class="literal">MAX()</code> 最適化には使用されません。
          </p></li><li class="listitem"><p>
            降順インデックスは <code class="literal">BTREE</code> ではサポートされていますが、<code class="literal">HASH</code> インデックスではサポートされていません。 降順インデックスは、<code class="literal">FULLTEXT</code> または <code class="literal">SPATIAL</code> インデックスではサポートされていません。 
          </p><p>
            <code class="literal">HASH</code>、<code class="literal">FULLTEXT</code> および <code class="literal">SPATIAL</code> インデックスに対して明示的に指定された <code class="literal">ASC</code> および <code class="literal">DESC</code> の指定では、エラーが発生します。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="timestamp-lookups"></a>8.3.14 TIMESTAMP カラムからのインデックス付きルックアップ</h3></div></div></div><a class="indexterm" name="idm45661478087936"></a><a class="indexterm" name="idm45661478085760"></a><p>
        一時値は UTC 値として <code class="literal">TIMESTAMP</code> カラムに格納され、<code class="literal">TIMESTAMP</code> カラムに対して挿入および取得された値はセッションタイムゾーンと UTC の間で変換されます。 (これは、<code class="literal">CONVERT_TZ()</code> 関数によって実行される変換と同じタイプです。 セッションのタイムゾーンが UTC の場合、事実上タイムゾーンの変換は行われません。) 
      </p><a class="indexterm" name="idm45661478079696"></a><p>
        夏時間 (DST) などのローカルタイムゾーンの変更の規則により、UTC タイムゾーンと UTC 以外のタイムゾーン間の変換は両方向で 1 対 1 ではありません。 個別の UTC 値は、別のタイムゾーンでは区別できません。 次の例は、UTC 以外のタイムゾーンで同一になる個別の UTC 値を示しています: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE tstable (ts TIMESTAMP);</code></strong>
mysql&gt; <strong class="userinput"><code>SET time_zone = 'UTC'; -- insert UTC values</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO tstable VALUES</code></strong>
       <strong class="userinput"><code>('2018-10-28 00:30:00'),</code></strong>
       <strong class="userinput"><code>('2018-10-28 01:30:00');</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT ts FROM tstable;</code></strong>
+---------------------+
| ts                  |
+---------------------+
| 2018-10-28 00:30:00 |
| 2018-10-28 01:30:00 |
+---------------------+
mysql&gt; <strong class="userinput"><code>SET time_zone = 'MET'; -- retrieve non-UTC values</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT ts FROM tstable;</code></strong>
+---------------------+
| ts                  |
+---------------------+
| 2018-10-28 02:30:00 |
| 2018-10-28 02:30:00 |
+---------------------+
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">'MET'</code>や<code class="literal">'Europe/Amsterdam'</code>などの名前付きタイムゾーンを使用するには、タイムゾーンテーブルが適切に設定されている必要があります。 その手順は、<a class="xref" href="server-administration.html#time-zone-support" title="5.1.15 MySQL Server でのタイムゾーンのサポート">セクション5.1.15「MySQL Server でのタイムゾーンのサポート」</a>を参照してください。 
        </p></div><p>
        <code class="literal">'MET'</code>タイムゾーンに変換すると、2 つの異なる UTC 値が同じであることがわかります。 この現象は、オプティマイザがインデックスを使用してクエリーを実行するかどうかに応じて、特定の <code class="literal">TIMESTAMP</code> カラムクエリーの結果が異なる可能性があります。 
      </p><p>
        クエリーで、<code class="literal">WHERE</code> 句を使用して <code class="literal">ts</code> カラムでユーザー指定のタイムスタンプリテラルなどの単一の特定の値を検索するために、前述のテーブルから値を選択するとします:
      </p><pre class="programlisting">SELECT ts FROM tstable
WHERE ts = '<em class="replaceable"><code>literal</code></em>';
</pre><p>
        さらに、クエリーが次の条件下で実行されるとします:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            セッションのタイムゾーンは UTC ではなく、DST シフトがあります。 例: 
          </p><pre class="programlisting">SET time_zone = 'MET';
</pre></li><li class="listitem"><p>
            DST シフトのため、<code class="literal">TIMESTAMP</code> カラムに格納されている一意の UTC 値がセッションタイムゾーンで一意ではありません。 (前述の例は、これがどのように発生するかを示しています。) 
          </p></li><li class="listitem"><p>
            クエリーでは、セッションタイムゾーンの DST への入力時間内の検索値を指定します。
          </p></li></ul></div><p>
        これらの条件では、インデックス付けされていない参照とインデックス付けされた参照で <code class="literal">WHERE</code> 句の比較が様々な方法で行われ、結果が異なります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            インデックスがない場合、またはオプティマイザがインデックスを使用できない場合は、セッションのタイムゾーンで比較が行われます。 オプティマイザは、各 <code class="literal">ts</code> カラム値を取得し、UTC からセッションタイムゾーンに変換して、検索値と比較するテーブルスキャンを実行します (セッションタイムゾーンでも解釈されます): 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT ts FROM tstable</code></strong>
       <strong class="userinput"><code>WHERE ts = '2018-10-28 02:30:00';</code></strong>
+---------------------+
| ts                  |
+---------------------+
| 2018-10-28 02:30:00 |
| 2018-10-28 02:30:00 |
+---------------------+
</pre><p>
            格納された <code class="literal">ts</code> 値はセッションタイムゾーンに変換されるため、UTC 値とは異なるが、セッションタイムゾーンでは等しい 2 つのタイムスタンプ値をクエリーで返すことができます: クロックが変更されたときに DST シフトの前に発生する値と、DST シフトの後に発生した値。
          </p></li><li class="listitem"><p>
            使用可能なインデックスがある場合、UTC で比較が行われます。 オプティマイザはインデックススキャンを実行し、最初に検索値をセッションタイムゾーンから UTC に変換してから、結果を UTC インデックスエントリと比較します: 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE tstable ADD INDEX (ts);</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT ts FROM tstable</code></strong>
       <strong class="userinput"><code>WHERE ts = '2018-10-28 02:30:00';</code></strong>
+---------------------+
| ts                  |
+---------------------+
| 2018-10-28 02:30:00 |
+---------------------+
</pre><p>
            この場合、(変換された) 検索値はインデックスエントリにのみ一致し、格納されている個別の UTC 値のインデックスエントリも個別であるため、検索値はそれらのいずれかにのみ一致できます。
          </p></li></ul></div><p>
        インデックス付けされていないルックアップとインデックス付けされたルックアップのオプティマイザ操作が異なるため、クエリーではそれぞれ異なる結果が生成されます。 インデックス付けされていない参照の結果は、セッションタイムゾーンで一致するすべての値を返します。 インデックス付きルックアップではこれを実行できません: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            UTC 値についてのみ認識されるストレージエンジン内で実行されます。
          </p></li><li class="listitem"><p>
            同じ UTC 値にマップされる 2 つの異なるセッションタイムゾーン値の場合、インデックス付き参照は対応する UTC インデックスエントリのみに一致し、単一行のみを返します。
          </p></li></ul></div><p>
        前述の説明では、<code class="literal">tstable</code> に格納されているデータセットは個別の UTC 値で構成されています。 このような場合、表示された形式のすべてのインデックス使用クエリーは、最大 1 つのインデックスエントリに一致します。 
      </p><p>
        インデックスが <code class="literal">UNIQUE</code> でない場合は、テーブル (およびインデックス) に特定の UTC 値の複数のインスタンスを格納できます。 たとえば、<code class="literal">ts</code> カラムに UTC 値<code class="literal">'2018-10-28 00:30:00'</code>の複数のインスタンスが含まれる場合があります。 この場合、インデックス使用クエリーはそれぞれを戻します (結果セットで MET 値<code class="literal">'2018-10-28 02:30:00'</code>に変換されます)。 インデックス使用クエリーは、セッションタイムゾーンの検索値に変換される複数の UTC 値を照合するのではなく、変換された検索値を UTC インデックスエントリの単一の値に一致させることができます。 
      </p><p>
        セッションタイムゾーンに一致するすべての <code class="literal">ts</code> 値を返すことが重要な場合、回避策は <code class="literal">IGNORE INDEX</code> ヒントでインデックスを使用しないようにすることです:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT ts FROM tstable</code></strong>
       <strong class="userinput"><code>IGNORE INDEX (ts)</code></strong>
       <strong class="userinput"><code>WHERE ts = '2018-10-28 02:30:00';</code></strong>
+---------------------+
| ts                  |
+---------------------+
| 2018-10-28 02:30:00 |
| 2018-10-28 02:30:00 |
+---------------------+
</pre><p>
        <code class="literal">FROM_UNIXTIME()</code> 関数や <code class="literal">UNIX_TIMESTAMP()</code> 関数で実行される変換など、両方の方向でのタイムゾーン変換に同じ一対一マッピングがないことが他のコンテキストでも発生します。 <a class="xref" href="functions.html#date-and-time-functions" title="12.7 日付および時間関数">セクション12.7「日付および時間関数」</a>を参照してください。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="optimizing-database-structure"></a>8.4 データベース構造の最適化</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#data-size">8.4.1 データサイズの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimize-data-types">8.4.2 MySQL データ型の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimize-multi-tables">8.4.3 多数のテーブルの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#internal-temporary-tables">8.4.4 MySQL での内部一時テーブルの使用</a></span></dt><dt><span class="section"><a href="optimization.html#database-count-limit">8.4.5 データベースおよびテーブルの数に対する制限</a></span></dt><dt><span class="section"><a href="optimization.html#table-size-limit">8.4.6 テーブルサイズの制限</a></span></dt><dt><span class="section"><a href="optimization.html#column-count-limit">8.4.7 テーブルカラム数と行サイズの制限</a></span></dt></dl></div><p>
      データベース設計者としての役割では、スキーマ、テーブル、およびカラムを編成するもっとも効率的な方法を探します。 アプリケーションコードをチューニングする場合、I/O を最小にし、関連項目をまとめて、データボリュームが増加してもパフォーマンスを高く維持するように、事前に計画します。 効率的なデータベース設計から始めることで、チームメンバーは高性能のアプリケーションコードを簡単に書けるようになり、アプリケーションが発展して、書き換えられても、データベースを持ちこたえさせる可能性が高くなります。 
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="data-size"></a>8.4.1 データサイズの最適化</h3></div></div></div><a class="indexterm" name="idm45661478017712"></a><a class="indexterm" name="idm45661478015600"></a><a class="indexterm" name="idm45661478013568"></a><a class="indexterm" name="idm45661478011520"></a><a class="indexterm" name="idm45661478009456"></a><p>
        ディスク上の領域を最小にするようにテーブルを設計します。 これにより、ディスクに対して読み取りおよび書き込みされるデータの量が減ることで、大幅な改善が見られます。 内容がクエリー実行中にアクティブに処理される間、テーブルが小さいほど、通常必要なメインメモリーの量は少なくなります。 テーブルデータの領域の削減により、インデックスも小さくなり、高速に処理できます。 
      </p><p>
        MySQL は多数のさまざまなストレージエンジン (テーブル型) と行フォーマットをサポートしています。 テーブルごとに、使用するストレージとインデックス設定方法を決定できます。 アプリケーションに適切なテーブル形式を選択することで、大幅なパフォーマンスの向上が得られることがあります。 <a class="xref" href="innodb-storage-engine.html" title="第 15 章 InnoDB ストレージエンジン">第15章「<i>InnoDB ストレージエンジン</i>」</a>および<a class="xref" href="storage-engines.html" title="第 16 章 代替ストレージエンジン">第16章「<i>代替ストレージエンジン</i>」</a>を参照してください。 
      </p><p>
        ここで挙げられた技法を使用して、テーブルのパフォーマンス改善とストレージ領域の最小化を図ることができます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#data-size-table-columns" title="テーブルカラム">テーブルカラム</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#data-size-row-format" title="行フォーマット">行フォーマット</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#data-size-indexes" title="インデックス">インデックス</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#data-size-joins" title="結合">結合</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#data-size-normalization" title="正規化">正規化</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="data-size-table-columns"></a>テーブルカラム</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              可能なかぎりもっとも効率的 (最小) のデータ型を使用します。 MySQL にはディスク領域とメモリーを節約する多くの専用の型があります。 たとえば、可能な場合は、小さなテーブルを取得するために、小さな整数型を使用します。 <code class="literal">MEDIUMINT</code> カラムが使用する領域は 25% 少ないため、<code class="literal">MEDIUMINT</code> は多くの場合に <code class="literal">INT</code> より適切な選択肢です。 
            </p></li><li class="listitem"><p>
              可能な場合は、カラムを <code class="literal">NOT NULL</code> として宣言します。 それにより、インデックスを適切に使用し、各値が <code class="literal">NULL</code> であるかどうかをテストするためのオーバーヘッドがなくなることで、SQL の操作が速くなります。 カラムあたり 1 ビットでいくらかのストレージ領域も節約します。 テーブルで実際に <code class="literal">NULL</code> 値が必要な場合、それらを使用します。 単にすべてのカラムで <code class="literal">NULL</code> 値を許可するデフォルトの設定を避けます。 
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="data-size-row-format"></a>行フォーマット</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">InnoDB</code> テーブルは、デフォルトでは <code class="literal">DYNAMIC</code> 行形式を使用して作成されます。 <code class="literal">DYNAMIC</code> 以外の行フォーマットを使用するには、<code class="literal">innodb_default_row_format</code> を構成するか、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントで <code class="literal">ROW_FORMAT</code> オプションを明示的に指定します。 
            </p><p>
              <code class="literal">COMPACT</code>、<code class="literal">DYNAMIC</code> および <code class="literal">COMPRESSED</code> を含む行形式のコンパクトファミリでは、一部の操作で CPU 使用率を増やすコストで行の記憶領域が削減されます。 ワークロードが、キャッシュヒット率とディスク速度によって制限される通常のワークロードであれば、速くなる可能性があります。 CPU 速度によって制限されるまれな例では、遅くなることがあります。 
            </p><p>
              行形式のコンパクトファミリでは、<code class="literal">utf8mb3</code> や <code class="literal">utf8mb4</code> などの可変長文字セットを使用する場合にも、<code class="literal">CHAR</code> カラムの格納が最適化されます。 <code class="literal">ROW_FORMAT=REDUNDANT</code> では、<code class="literal">CHAR(<em class="replaceable"><code>N</code></em>)</code> は <em class="replaceable"><code>N</code></em>×文字セットの最大バイト長を占有します。 多くの言語は主にシングルバイトの <code class="literal">utf8</code> 文字を使用して記述できるため、固定記憶域の長さによって領域が無駄になることがよくあります。 行フォーマットのコンパクトファミリでは、<code class="literal">InnoDB</code> は、末尾の空白を削除することで、<em class="replaceable"><code>N</code></em> の範囲内の可変量の記憶域を <em class="replaceable"><code>N</code></em>×これらのカラムの文字セットの最大バイト長に割り当てます。 一般的な場合にインプレース更新を容易にするために、記憶域の最小長は <em class="replaceable"><code>N</code></em> バイトです。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="15.10 InnoDB の行フォーマット">セクション15.10「InnoDB の行フォーマット」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              テーブルデータを圧縮形式で保存することで、さらに領域を最小にするには、<code class="literal">InnoDB</code> テーブルを作成する際に <code class="literal">ROW_FORMAT=COMPRESSED</code> を指定するか、既存の <code class="literal">MyISAM</code> テーブルに対して、<span class="command"><strong>myisampack</strong></span> コマンドを実行します。 (<code class="literal">InnoDB</code> 圧縮テーブルは読取りおよび書込み可能ですが、<code class="literal">MyISAM</code> 圧縮テーブルは読取り専用です。) 
            </p></li><li class="listitem"><p>
              <code class="literal">MyISAM</code> テーブルで、可変長カラム (<code class="literal">VARCHAR</code>、<code class="literal">TEXT</code>、あるいは <code class="literal">BLOB</code> など) がない場合は、固定サイズ行フォーマットが使用されます。 これは高速ですが、いくらか領域を無駄にすることがあります。 <a class="xref" href="storage-engines.html#myisam-table-formats" title="16.2.3 MyISAM テーブルのストレージフォーマット">セクション16.2.3「MyISAM テーブルのストレージフォーマット」</a>を参照してください。 <code class="literal">CREATE TABLE</code> オプション <code class="literal">ROW_FORMAT=FIXED</code> によって、<code class="literal">VARCHAR</code> カラムがある場合でも、固定長の行を必要としていることを伝えることができます。 
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="data-size-indexes"></a>インデックス</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              テーブルのプライマリインデックスは可能なかぎり短くしてください。 これにより、各行の識別が容易になり効率的になります。 <code class="literal">InnoDB</code> テーブルの場合、主キーカラムは、各セカンダリインデックスエントリに複製されるため、多数のセカンダリインデックスがある場合に、短い主キーによって、かなりの領域が節約されます。 
            </p></li><li class="listitem"><p>
              クエリーパフォーマンスを向上するために必要なインデックスのみを作成します。 インデックスは取得には有効ですが、挿入および更新操作を遅くします。 ほとんどカラムの組み合わせに対して検索することによって、テーブルにアクセスする場合、カラムごとに個別のインデックスを作成するのではなく、それらに対して単一の複合インデックスを作成します。 インデックスの最初の部分は、もっとも使用されるカラムにするべきです。 テーブルから選択する場合に、<span class="emphasis"><em>常に</em></span>多くのカラムを使用する場合、適切なインデックスの圧縮を取得するため、インデックスの最初のカラムは、もっとも重複の多いカラムにするべきです。 
            </p></li><li class="listitem"><p>
              長い文字列のカラムの最初の文字数に一意の接頭辞がある可能性が高い場合は、カラムの左端に索引を作成するための MySQL サポートを使用して、この接頭辞のみを索引付けすることをお薦めします (<a class="xref" href="sql-statements.html#create-index" title="13.1.15 CREATE INDEX ステートメント">セクション13.1.15「CREATE INDEX ステートメント」</a> を参照)。 短いインデックスほど速くなるのは、必要なディスク領域が少ないだけでなく、インデックスキャッシュでのヒットが多くなり、そのためにディスクシークが少なくなるためでもあります。 <a class="xref" href="server-administration.html#server-configuration" title="5.1.1 サーバーの構成">セクション5.1.1「サーバーの構成」</a>を参照してください。 
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="data-size-joins"></a>結合</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              状況によって、頻繁にスキャンされるテーブルを 2 つに分割することで、メリットがある場合があります。 これは特に、それが動的形式テーブルで、テーブルのスキャン時に、関連行を見つけるために使用できる小さな静的形式テーブルを使用できる場合に当てはまります。 
            </p></li><li class="listitem"><p>
              対応するカラムに基づいた結合を高速化するには、異なるテーブル内の同一の情報を持つカラムを同一のデータ型で宣言します。
            </p></li><li class="listitem"><p>
              異なるテーブルで同じ名前を使用し、結合クエリーを簡略化できるように、カラム名を簡単にします。 たとえば、<code class="literal">customer</code> というテーブルでは <code class="literal">customer_name</code> ではなく <code class="literal">name</code> のカラム名を使用します。 名前をほかの SQL サーバーに移植できるようにするため、18 文字より短くすることを考慮します。 
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="data-size-normalization"></a>正規化</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              通常、すべてのデータを非冗長に維持しようとしてください (データベース理論で<span class="firstterm">第 3 正規形</span>と呼ばれるものを順守します)。 名前や住所などの長い値を繰り返す代わりに、それらに一意の ID を割り当て、複数の小さなテーブルで必要なだけこれらの ID を繰り返し、結合句で ID を参照して、クエリーでテーブルを結合します。 
            </p></li><li class="listitem"><p>
              たとえば、大きなテーブルからすべてのデータを解析するビジネスインテリジェンスシナリオなどで、ディスク領域やデータの複数のコピーを維持する保守コストより、速度の方が重要である場合、正規化ルールを緩和して、情報を複製したり、サマリーテーブルを作成したりして、速度を向上させることができます。
            </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimize-data-types"></a>8.4.2 MySQL データ型の最適化</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#optimize-numeric">8.4.2.1 数値データの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimize-character">8.4.2.2 文字および文字列型の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimize-blob">8.4.2.3 BLOB 型の最適化</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="optimize-numeric"></a>8.4.2.1 数値データの最適化</h4></div></div></div><a class="indexterm" name="idm45661477924976"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              文字列または数値として表すことができる一意の ID やその他の値の場合、文字列カラムより数値カラムをお勧めします。 大きな数値は、対応する文字列より少ないバイト数で格納できるため、それらの転送と比較が高速になり、使用するメモリーが少なくなります。 
            </p></li><li class="listitem"><p>
              数値データを使用している場合、多くの場合にテキストファイルにアクセスするより、ライブ接続を使用して、データベースから情報にアクセスする方が高速です。 データベース内の情報はテキストファイルよりコンパクトなフォーマットで格納される可能性が高いため、それへのアクセスにかかわるディスクアクセスが少なくなります。 また、テキストファイルを解析して、行とカラムの境界を見つけることを回避できるため、アプリケーションのコードも節約できます。 
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="optimize-character"></a>8.4.2.2 文字および文字列型の最適化</h4></div></div></div><a class="indexterm" name="idm45661477917728"></a><p>
          文字および文字列カラムの場合、次のガイドラインに従います。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              言語固有の照合機能が必要でない場合は、比較およびソート操作を速くするため、バイナリ照合順序を使用します。 特定のクエリー内でバイナリ照合順序を使用するには、<code class="literal">BINARY</code> 演算子を使用できます。 
            </p></li><li class="listitem"><p>
              さまざまなカラムの値を比較する場合、可能なかぎり、それらのカラムを同じ文字セットと照合順序で宣言し、クエリー実行中の文字列変換を避けます。
            </p></li><li class="listitem"><p>
              サイズが 8K バイト未満のカラム値では、<code class="literal">BLOB</code> の代わりにバイナリ <code class="literal">VARCHAR</code> を使用します。 <code class="literal">GROUP BY</code> および <code class="literal">ORDER BY</code> 句は一時テーブルを生成する可能性があり、これらの一時テーブルでは、元のテーブルに <code class="literal">BLOB</code> カラムが含まれない場合に、<code class="literal">MEMORY</code> ストレージエンジンを使用することがあります。 
            </p></li><li class="listitem"><p>
              テーブルに名前や住所などの文字列カラムが含まれるが、多くのクエリーでそれらのカラムを取得しない場合、文字列カラムを個別のテーブルに分割し、必要に応じて、外部キーで結合クエリーを使用することを考慮します。 MySQL で行から何らかの値を取得する場合、その行 (およびおそらくその他の隣接する行) のすべてのカラムを含むデータブロックを読み取ります。 もっとも頻繁に使用するカラムのみで、各行を小さくすることで、より多くの行を各データブロックに収めることができます。 そのようなコンパクトなテーブルは、一般的なクエリーのディスク I/O やメモリーの使用量を削減します。 
            </p></li><li class="listitem"><p>
              <code class="literal">InnoDB</code> テーブルで主キーとして、ランダムに生成された値を使用する場合、可能であれば、現在の日時などの降順の値でプリフィクスを付けます。 連続したプライマリ値が、相互に物理的に近くに保存されていれば、<code class="literal">InnoDB</code> はそれらを高速に挿入し、取得できます。 
            </p></li><li class="listitem"><p>
              数値カラムの方が通常同等の文字列カラムより推奨される理由については、<a class="xref" href="optimization.html#optimize-numeric" title="8.4.2.1 数値データの最適化">セクション8.4.2.1「数値データの最適化」</a>を参照してください。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="optimize-blob"></a>8.4.2.3 BLOB 型の最適化</h4></div></div></div><a class="indexterm" name="idm45661477896768"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              テキストデータを格納する大きな BLOB を保存する場合、まずそれを圧縮することを考慮します。 テーブル全体が <code class="literal">InnoDB</code> または <code class="literal">MyISAM</code> によって圧縮されている場合は、この技法を使用しないでください。 
            </p></li><li class="listitem"><p>
              複数のカラムのあるテーブルで、BLOB カラムを使用しないクエリーのメモリー要件を削減するには、BLOB カラムを個別のテーブルに分割し、必要に応じて、結合クエリーでそれを参照することを考慮します。
            </p></li><li class="listitem"><p>
              BLOB 値を取得し、表示するためのパフォーマンス要件は、ほかのデータ型と大きく異なることがあるため、BLOB 固有テーブルを別のストレージデバイスまたは個別のデータベースインスタンスに置くことができます。 たとえば、BLOB を取得するには、大量の順次ディスク読み取りが必要で、<a class="link" href="glossary.html#glos_ssd" title="SSD">SSD デバイス</a>より、従来のハードドライブの方が適しています。 
            </p></li><li class="listitem"><p>
              バイナリ <code class="literal">VARCHAR</code> カラムの方が同等の BLOB カラムより推奨されることがある理由については、<a class="xref" href="optimization.html#optimize-character" title="8.4.2.2 文字および文字列型の最適化">セクション8.4.2.2「文字および文字列型の最適化」</a>を参照してください。
            </p></li><li class="listitem"><p>
              きわめて長いテキスト文字列に対して、同等性をテストする代わりに、個別のカラムにカラムのハッシュを格納し、そのカラムにインデックスを設定して、クエリー内のハッシュ値をテストします。 (<code class="literal">MD5()</code> または <code class="literal">CRC32()</code> 関数を使用して、ハッシュ値を生成します。) ハッシュ関数は、異なる入力で重複した結果を生成することがあるため、引き続きクエリーに句 <code class="literal">AND <em class="replaceable"><code>blob_column</code></em> = <em class="replaceable"><code>long_string_value</code></em></code> を含めて、誤った一致に対して保護します。パフォーマンスは、ハッシュ値の小さく、簡単にスキャンされるインデックスからメリットが得られます。 
            </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimize-multi-tables"></a>8.4.3 多数のテーブルの最適化</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#table-cache">8.4.3.1 MySQL でのテーブルのオープンとクローズの方法</a></span></dt><dt><span class="section"><a href="optimization.html#creating-many-tables">8.4.3.2 同じデータベースに大量のテーブルを作成することの短所</a></span></dt></dl></div><a class="indexterm" name="idm45661477878720"></a><p>
        各クエリーを高速にするいくつかの技法には、多数のテーブルへのデータの分割が含まれます。 テーブルの数が数千または数百万にもなる場合、これらすべてのテーブルの処理のオーバーヘッドは新たなパフォーマンスの考慮事項になります。 
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="table-cache"></a>8.4.3.1 MySQL でのテーブルのオープンとクローズの方法</h4></div></div></div><a class="indexterm" name="idm45661477874432"></a><a class="indexterm" name="idm45661477873120"></a><a class="indexterm" name="idm45661477870976"></a><a class="indexterm" name="idm45661477868944"></a><a class="indexterm" name="idm45661477866912"></a><a class="indexterm" name="idm45661477864880"></a><a class="indexterm" name="idm45661477863504"></a><a class="indexterm" name="idm45661477861472"></a><p>
          <span class="command"><strong>mysqladmin status</strong></span> コマンドを実行すると、次のように表示されるはずです。
        </p><pre class="programlisting">Uptime: 426 Running threads: 1 Questions: 11082
Reloads: 1 Open tables: 12
</pre><p>
          12 未満のテーブルがある場合、<code class="literal">Open tables</code> 値の 12 はある程度パズルになる可能性があります。
        </p><p>
          MySQL はマルチスレッド化されているため、特定のテーブルに対するクエリーを同時に発行するクライアントが多数存在する場合があります。 同じテーブルに対して、複数のクライアントセッションが異なる状態を持つ問題を最小にするため、テーブルは各同時セッションに独立して開かれます。 これは追加メモリーを使用しますが、一般にパフォーマンスは向上します。 <code class="literal">MyISAM</code> テーブルでは、テーブルを開いているクライアントごとに、データファイルに 1 つの追加のファイルディスクリプタが必要になります。 (対照的に、インデックスファイルディスクリプタはすべてのセッションで共有されます。) 
        </p><p>
          <code class="literal">table_open_cache</code> および <code class="literal">max_connections</code> システム変数は、サーバーが開いたままにするファイルの最大数に影響します。 これらの値のいずれかまたは両方を増やすと、オープンファイルディスクリプタのプロセスあたりの数に関して、オペレーティングシステムによって適用されている制限に達する可能性があります。 多くのオペレーティングシステムでは、オープンファイル制限を増やすことができますが、方法はシステムによって大きく異なります。 制限値を増やすことができるかどうか、およびその実行方法については、使用するオペレーティングシステムのドキュメントを参照してください。 
        </p><p>
          <code class="literal">table_open_cache</code> は <code class="literal">max_connections</code> に関連します。 たとえば、200 の同時実行接続の場合、少なくとも <code class="literal">200 * <em class="replaceable"><code>N</code></em></code> のテーブルキャッシュサイズを指定します。ここで <em class="replaceable"><code>N</code></em> は実行するクエリーの結合あたりのテーブルの最大数です。 また、一時テーブルとファイル用のいくつかの追加のファイルディスクリプタを予約する必要もあります。 
        </p><p>
          オペレーティングシステムで、<code class="literal">table_open_cache</code> の設定に示されたオープンファイルディスクリプタの数を処理できることを確認してください。 <code class="literal">table_open_cache</code> の設定が高すぎると、MySQL でファイル記述子が不足し、接続の拒否やクエリーの実行の失敗などの症状が発生する可能性があります。 
        </p><p>
          また、<code class="literal">MyISAM</code> ストレージエンジンでは、一意のオープンテーブルごとに 2 つのファイル記述子が必要であることも考慮してください。 MySQL で使用可能なファイル記述子の数を増やすには、<code class="literal">open_files_limit</code> システム変数を設定します。 <a class="xref" href="error-handling.html#not-enough-file-handles" title="B.3.2.16 ファイルが見つからず同様のエラーが発生しました">セクションB.3.2.16「ファイルが見つからず同様のエラーが発生しました」</a>を参照してください。 
        </p><p>
          オープンテーブルのキャッシュは、<code class="literal">table_open_cache</code> エントリのレベルで保持されます。 サーバーはスタートアップ時にキャッシュサイズを自動サイズ設定します。 サイズを明示的に設定するには、スタートアップ時に <code class="literal">table_open_cache</code> システム変数を設定します。 MySQL では、このセクションの後半で説明するように、クエリーを実行するために一時的にこれよりも多くのテーブルを開く場合があります。 
        </p><p>
          次の状況では、MySQL は未使用のテーブルを閉じ、それをテーブルキャッシュから削除します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              キャッシュがいっぱいで、スレッドがキャッシュにないテーブルを開こうとした場合。
            </p></li><li class="listitem"><p>
              キャッシュに <code class="literal">table_open_cache</code> を超えるエントリがあり、キャッシュ内のテーブルがどのスレッドによっても使用されなくなった場合。
            </p></li><li class="listitem"><p>
              テーブルフラッシュ操作が発生した場合。 これは、だれかが <code class="literal">FLUSH TABLES</code> ステートメントを発行するか、または <span class="command"><strong>mysqladmin flush-tables</strong></span> または <span class="command"><strong>mysqladmin refresh</strong></span> コマンドを実行した場合に行われます。 
            </p></li></ul></div><p>
          テーブルキャッシュがいっぱいになると、サーバーは次の手順に従って使用するキャッシュエントリを見つけます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              現在使用されていないテーブルは、最も最近使用されていないテーブルからリリースされます。
            </p></li><li class="listitem"><p>
              新しいテーブルを開く必要があるが、キャッシュがいっぱいでテーブルを解放できない場合、キャッシュは必要に応じて一時的に拡張されます。 キャッシュが一時的に拡張された状況で、テーブルが使用中から未使用状態になったときは、そのテーブルが閉じられ、キャッシュから解放されます。 
            </p></li></ul></div><p>
          <code class="literal">MyISAM</code> テーブルは同時アクセスごとに開かれます。 つまり、2 つのスレッドで同じテーブルにアクセスする場合、または 1 つのスレッドが同一クエリーでテーブルに 2 回アクセスする場合 (テーブルをそれ自体に結合することによってなど) は、テーブルを 2 回開く必要があることを意味します。 同時オープンは、それぞれテーブルキャッシュにエントリが必要になります。 いずれかの <code class="literal">MyISAM</code> テーブルを最初に開くと、データファイルに 1 つとインデックスファイルに 1 つの 2 つのファイルディスクリプタが必要になります。 テーブルの追加の使用では、それぞれデータファイルに 1 つだけのファイルディスクリプタが必要です。 インデックスファイルディスクリプタはすべてのスレッドで共有されます。 
        </p><p>
          <code class="literal">HANDLER <em class="replaceable"><code>tbl_name</code></em> OPEN</code> ステートメントを使用してテーブルを開く場合、専用のテーブルオブジェクトがスレッドに割り当てられます。 このテーブルオブジェクトはほかのスレッドと共有されず、スレッドが <code class="literal">HANDLER <em class="replaceable"><code>tbl_name</code></em> CLOSE</code> を呼び出すか、スレッドが終了するまでクローズされません。 これが発生すると、テーブルがテーブルキャッシュに戻されます (キャッシュがいっぱいでない場合)。 <a class="xref" href="sql-statements.html#handler" title="13.2.4 HANDLER ステートメント">セクション13.2.4「HANDLER ステートメント」</a>を参照してください。 
        </p><p>
          テーブルキャッシュが小さすぎるかどうかを判断するには、サーバーの起動後のテーブルオープン操作の数を示す <code class="literal">Opened_tables</code> ステータス変数を確認します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW GLOBAL STATUS LIKE 'Opened_tables';</code></strong>
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| Opened_tables | 2741  |
+---------------+-------+
</pre><p>
          多数の <code class="literal">FLUSH TABLES</code> ステートメントを発行していない場合でも、値が非常に大きいか急速に増加する場合は、サーバーの起動時に <code class="literal">table_open_cache</code> 値を増やします。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="creating-many-tables"></a>8.4.3.2 同じデータベースに大量のテーブルを作成することの短所</h4></div></div></div><a class="indexterm" name="idm45661477809248"></a><p>
          同じデータベースディレクトリに多数の <code class="literal">MyISAM</code> テーブルがある場合、オープン、クローズ、および作成操作が遅くなります。 多数のテーブルに対して <code class="literal">SELECT</code> ステートメントを実行した場合、開く必要があるテーブルごとに、別のテーブルを閉じる必要があるため、テーブルキャッシュがいっぱいの場合にオーバーヘッドが少し発生します。 テーブルキャッシュで許可されるエントリ数を増やすことによって、このオーバーヘッドを減らすことができます。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="internal-temporary-tables"></a>8.4.4 MySQL での内部一時テーブルの使用</h3></div></div></div><a class="indexterm" name="idm45661477802688"></a><p>
        場合によっては、サーバーはステートメントの処理中に内部一時テーブルを作成します。 これが発生した場合、ユーザーは直接的に制御できません。 
      </p><p>
        サーバーは、次のような条件下で一時テーブルを作成します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">UNION</code> ステートメントの評価 (ただし、後で説明するいくつかの例外があります)。
          </p></li><li class="listitem"><p>
            <code class="literal">TEMPTABLE</code> アルゴリズム、<code class="literal">UNION</code> または集計を使用するビューなど、一部のビューの評価。
          </p></li><li class="listitem"><p>
            導出テーブルの評価 (<a class="xref" href="sql-statements.html#derived-tables" title="13.2.11.8 導出テーブル">セクション13.2.11.8「導出テーブル」</a> を参照)。
          </p></li><li class="listitem"><p>
            共通テーブル式の評価 (<a class="xref" href="sql-statements.html#with" title="13.2.15 WITH (共通テーブル式)">セクション13.2.15「WITH (共通テーブル式)」</a> を参照)。
          </p></li><li class="listitem"><p>
            サブクエリーまたは準結合の実体化用に作成されたテーブル (<a class="xref" href="optimization.html#subquery-optimization" title="8.2.2 サブクエリー、導出テーブル、ビュー参照および共通テーブル式の最適化">セクション8.2.2「サブクエリー、導出テーブル、ビュー参照および共通テーブル式の最適化」</a> を参照)。
          </p></li><li class="listitem"><p>
            <code class="literal">ORDER BY</code> 句と異なる <code class="literal">GROUP BY</code> 句を含むステートメント、または結合キューの最初のテーブル以外のテーブルのカラムが <code class="literal">ORDER BY</code> または <code class="literal">GROUP BY</code> に含まれるステートメントの評価。
          </p></li><li class="listitem"><p>
            <code class="literal">ORDER BY</code> と組み合せた <code class="literal">DISTINCT</code> の評価には、一時テーブルが必要になる場合があります。
          </p></li><li class="listitem"><p>
            <code class="literal">SQL_SMALL_RESULT</code> 修飾子を使用するクエリーの場合、ディスク上の記憶域を必要とする要素 (後述) もクエリーに含まれていないかぎり、MySQL はインメモリー一時テーブルを使用します。
          </p></li><li class="listitem"><p>
            同じテーブルから選択して同じテーブルに挿入する <code class="literal">INSERT ... SELECT</code> ステートメントを評価するために、MySQL は <code class="literal">SELECT</code> の行を保持する内部一時テーブルを作成し、それらの行をターゲットテーブルに挿入します。 <a class="xref" href="sql-statements.html#insert-select" title="13.2.6.1 INSERT ... SELECT ステートメント">セクション13.2.6.1「INSERT ... SELECT ステートメント」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            複数テーブルの <code class="literal">UPDATE</code> ステートメントの評価。
          </p></li><li class="listitem"><p>
            <code class="literal">GROUP_CONCAT()</code> または <code class="literal">COUNT(DISTINCT)</code> 式の評価。
          </p></li><li class="listitem"><p>
            ウィンドウ関数の評価 (<a class="xref" href="functions.html#window-functions" title="12.21 ウィンドウ関数">セクション12.21「ウィンドウ関数」</a> を参照) では、必要に応じて一時テーブルが使用されます。
          </p></li></ul></div><p>
        ステートメントに一時テーブルが必要かどうかを判断するには、<code class="literal">EXPLAIN</code> を使用し、<code class="literal">Extra</code> カラムをチェックして、<code class="literal">Using temporary</code> と表示されているかどうかを確認します (<a class="xref" href="optimization.html#using-explain" title="8.8.1 EXPLAIN によるクエリーの最適化">セクション8.8.1「EXPLAIN によるクエリーの最適化」</a> を参照)。 <code class="literal">EXPLAIN</code> では、導出一時テーブルまたは実体化一時テーブルの場合、必ずしも <code class="literal">Using temporary</code> とは言えません。 ウィンドウ関数を使用するステートメントの場合、<code class="literal">EXPLAIN</code> と <code class="literal">FORMAT=JSON</code> では常にウィンドウステップに関する情報が提供されます。 ウィンドウ関数で一時テーブルが使用されている場合は、ステップごとに示されます。 
      </p><p>
        一部のクエリー条件では、インメモリー一時テーブルを使用できません。この場合、サーバーは代わりにディスク上のテーブルを使用します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブル内の <code class="literal">BLOB</code> または <code class="literal">TEXT</code> カラムの存在 ただし、MySQL 8.0 のインメモリー内部一時テーブルのデフォルトのストレージエンジンである <code class="literal">TempTable</code> ストレージエンジンは、MySQL 8.0.13 の時点でバイナリラージオブジェクト型をサポートしています。 <a class="xref" href="optimization.html#internal-temporary-tables-engines" title="内部一時テーブルストレージエンジン">内部一時テーブルストレージエンジン</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">UNION</code> または <code class="literal">UNION ALL</code> が使用された場合に、<code class="literal">SELECT</code> リスト内の 512 (バイナリ文字列の場合はバイト数、非バイナリ文字列の場合は文字数) より大きい最大長を持つ文字列カラムの存在。
          </p></li><li class="listitem"><p>
            <code class="literal">SHOW COLUMNS</code> および <code class="literal">DESCRIBE</code> ステートメントでは、一部のカラムのタイプとして <code class="literal">BLOB</code> が使用されるため、結果に使用される一時テーブルはディスク上のテーブルです。
          </p></li></ul></div><p>
        サーバーは、特定の条件を満たす <code class="literal">UNION</code> ステートメントに一時テーブルを使用しません。 かわりに、結果カラムの型キャストの実行に必要なデータ構造のみが一時テーブルの作成から保持されます。 テーブルは完全にはインスタンス化されず、テーブルに対する書込みまたは読取りは行われません。行はクライアントに直接送信されます。 最後のクエリーブロックが実行されるまでサーバーが待機する必要がないため、結果としてメモリーおよびディスクの要件が削減され、最初の行がクライアントに送信されるまでの遅延が短くなります。 <code class="literal">EXPLAIN</code> およびオプティマイザのトレース出力には、この実行計画が反映されます: <code class="literal">UNION RESULT</code> クエリーブロックは、一時テーブルから読み取る部分に対応しているため、存在しません。 
      </p><p>
        次の条件は、一時テーブルを使用しない <code class="literal">UNION</code> の評価に適しています:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            共用体は、<code class="literal">UNION</code> や <code class="literal">UNION DISTINCT</code> ではなく、<code class="literal">UNION ALL</code> です。
          </p></li><li class="listitem"><p>
            グローバル <code class="literal">ORDER BY</code> 句がありません。
          </p></li><li class="listitem"><p>
            共用体は、<code class="literal">{INSERT | REPLACE} ... SELECT ...</code> ステートメントのトップレベルのクエリーブロックではありません。
          </p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="internal-temporary-tables-engines"></a>内部一時テーブルストレージエンジン</h4></div></div></div><p>
          内部一時テーブルはメモリー内に保持され、<code class="literal">TempTable</code> または <code class="literal">MEMORY</code> ストレージエンジンによって処理されるか、<code class="literal">InnoDB</code> ストレージエンジンによってディスクに格納されます。
        </p><h5><a name="idm45661477730640"></a>インメモリー内部一時テーブルのストレージエンジン</h5><p>
          <code class="literal">internal_tmp_mem_storage_engine</code> セッション変数は、インメモリー内部一時テーブルのストレージエンジンを定義します。 許可される値は、<code class="literal">TempTable</code> (デフォルト) および <code class="literal">MEMORY</code> です。 
        </p><p>
          <code class="literal">TempTable</code> ストレージエンジンは、<code class="literal">VARCHAR</code> および <code class="literal">VARBINARY</code> カラム、および MySQL 8.0.13 の時点でのその他のバイナリラージオブジェクト型の効率的なストレージを提供します。
        </p><p>
          <code class="literal">temptable_max_ram</code> 変数は、<code class="literal">TempTable</code> ストレージエンジンがメモリーマップ一時ファイルまたは <code class="literal">InnoDB</code> ディスク上の内部一時テーブルの形式でディスクから領域の割り当てを開始する前に占有できる RAM の最大量を定義します。 デフォルトの <code class="literal">temptable_max_ram</code> 設定は 1GiB です。 <code class="literal">temptable_use_mmap</code> 変数 (MySQL 8.0.16 で導入) は、<code class="literal">temptable_max_ram</code> の制限を超えた場合に、<code class="literal">TempTable</code> ストレージエンジンがメモリーマップされたファイルまたは <code class="literal">InnoDB</code> ディスク上の内部一時テーブルを使用するかどうかを制御します。 デフォルト設定は <code class="literal">temptable_use_mmap=ON</code> です。 MySQL 8.0.23 で導入された <code class="literal">temptable_max_mmap</code> 変数は、TempTable ストレージエンジンが内部一時テーブルデータの <code class="literal">InnoDB</code> ディスク上の内部一時テーブルへの格納を開始する前に、メモリーマップされたファイルから割り当てることができるメモリーの最大量を定義します。 <code class="literal">temptable_max_mmap=0</code> 設定では、メモリーマップファイルからの割当てが無効化され、<code class="literal">temptable_use_mmap</code> 設定に関係なく、使用が効率的に無効化されます。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">temptable_max_ram</code> 設定では、<code class="literal">TempTable</code> ストレージエンジンを使用する各スレッドに割り当てられたスレッドローカルメモリーブロックは考慮されません。 スレッドローカルメモリーブロックのサイズは、スレッドの最初のメモリー割当てリクエストのサイズによって異なります。 リクエストが 1MB 未満の場合 (ほとんどの場合)、スレッドローカルメモリーブロックサイズは 1MB です。 リクエストが 1MB を超える場合、スレッドローカルメモリーブロックは初期メモリーリクエストとほぼ同じサイズになります。 スレッドローカルメモリーブロックは、スレッドが終了するまでスレッドローカル記憶域に保持されます。 
          </p></div><p>
          <code class="literal">TempTable</code> ストレージエンジンによる内部一時テーブルのオーバーフローメカニズムとしてのメモリーマップ一時ファイルの使用は、次の規則によって制御されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              一時ファイルは、<code class="literal">tmpdir</code> 変数で定義されたディレクトリに作成されます。
            </p></li><li class="listitem"><p>
              一時ファイルは、作成して開いた直後に削除されるため、<code class="literal">tmpdir</code> ディレクトリには表示されません。 一時ファイルが占有する領域は、一時ファイルが開いている間はオペレーティングシステムによって保持されます。 領域は、一時ファイルが <code class="literal">TempTable</code> ストレージエンジンによって閉じられたとき、または <code class="literal">mysqld</code> プロセスがシャットダウンされたときに再利用されます。 
            </p></li><li class="listitem"><p>
              RAM と一時ファイル間、RAM 内、または一時ファイル間でデータが移動されることはありません。
            </p></li><li class="listitem"><p>
              <code class="literal">temptable_max_ram</code> で定義された制限内に領域が使用可能になると、新しいデータが RAM に格納されます。 それ以外の場合、新しいデータは一時ファイルに格納されます。 
            </p></li><li class="listitem"><p>
              テーブルの一部のデータが一時ファイルに書き込まれた後に RAM で領域が使用可能になった場合、残りのテーブルデータを RAM に格納できます。
            </p></li></ul></div><p>
          <code class="literal">TempTable</code> ストレージエンジンが <code class="literal">InnoDB</code> ディスク上の内部一時テーブルをオーバーフローメカニズムとして使用するように構成されている場合 (<code class="literal">temptable_use_mmap=OFF</code> または <code class="literal">temptable_max_mmap</code>=0)、<code class="literal">temptable_max_ram</code> 制限を超えるインメモリーテーブルは <code class="literal">InnoDB</code> ディスク上の内部一時テーブルに変換され、そのテーブルに属する行はメモリーから <code class="literal">InnoDB</code> ディスク上の内部一時テーブルに移動されます。 MySQL 8.0.16 で削除された <code class="literal">internal_tmp_disk_storage_engine</code> 設定は、<code class="literal">TempTable</code> ストレージエンジンオーバーフローメカニズムには影響しません。 
        </p><p>
          MySQL 8.0.23 より前は、TempTable ストレージエンジンが <code class="literal">temptable_max_ram</code> の制限を超え、メモリーマップされたファイル用に一時ディレクトリ内の過剰な領域を使用することが多い場合、<code class="literal">TempTable</code> オーバーフローメカニズムとして <code class="literal">InnoDB</code> のディスク上の内部一時テーブルが推奨されていました。 MySQL 8.0.23 の時点で、<code class="literal">temptable_max_mmap</code> 変数は TempTable ストレージエンジンがメモリーマップされたファイルから割り当てるメモリー量の制限を定義するため、これらのファイルが使用する領域が多すぎるリスクに対処します。 通常、<code class="literal">temptable_max_ram</code> の制限を超えるのは、大規模な内部一時テーブルの使用または内部一時テーブルの広範囲な使用が原因です。 <code class="literal">InnoDB</code> のディスク上の内部一時テーブルは、デフォルトでデータディレクトリに存在するセッション一時テーブルスペースに作成されます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-temporary-tablespace" title="15.6.3.5 一時テーブルスペース">セクション15.6.3.5「一時テーブルスペース」</a>を参照してください。 
        </p><p>
          インメモリー一時テーブルに <code class="literal">MEMORY</code> ストレージエンジンを使用する場合、MySQL はインメモリー一時テーブルが大きすぎると、インメモリー一時テーブルをディスク上のテーブルに自動的に変換します。 インメモリー一時テーブルの最大サイズは、<code class="literal">tmp_table_size</code> または <code class="literal">max_heap_table_size</code> のいずれか小さい方の値によって定義されます。 これは、<code class="literal">CREATE TABLE</code> で明示的に作成される <code class="literal">MEMORY</code> テーブルとは異なります。 このようなテーブルの場合、<code class="literal">max_heap_table_size</code> 変数のみがテーブルの大きさを決定し、ディスク上の形式への変換はありません。 
        </p><h5><a name="internal-temporary-tables-engines-disk"></a>オンディスク内部一時テーブルのストレージエンジン</h5><p>
          MySQL 8.0.16 以降、サーバーは常に <code class="literal">InnoDB</code> ストレージエンジンを使用してディスク上の内部一時テーブルを管理します。
        </p><p>
          MySQL 8.0.15 以前では、<code class="literal">internal_tmp_disk_storage_engine</code> 変数を使用して、ディスク上の内部一時テーブルに使用されるストレージエンジンを定義していました。 この変数は MySQL 8.0.16 で削除され、この目的に使用されるストレージエンジンはユーザーが構成できなくなりました。 
        </p><p>
          MySQL 8.0.15 以前: 共通テーブル式 (CTE) の場合、ディスク上の内部一時テーブルに使用されるストレージエンジンを <code class="literal">MyISAM</code> にすることはできません。 <code class="literal">internal_tmp_disk_storage_engine=MYISAM</code> の場合、ディスク上の一時テーブルを使用して CTE を実体化しようとすると、エラーが発生します。 
        </p><p>
          MySQL 8.0.15 以前: <code class="literal">internal_tmp_disk_storage_engine=INNODB</code> を使用している場合、<a class="link" href="innodb-storage-engine.html#innodb-limits" title="15.22 InnoDB の制限"><code class="literal">InnoDB</code> row or column limits</a> を超えるディスク上の内部一時テーブルを生成するクエリーは、<span class="errortext">「行サイズが大きすぎます」</span>または<span class="errortext">「カラムが多すぎます」</span>エラーを返します。 回避策は、<code class="literal">internal_tmp_disk_storage_engine</code> を <code class="literal">MYISAM</code> に設定することです。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="internal-temporary-tables-storage"></a>内部一時テーブル記憶域形式</h4></div></div></div><p>
          インメモリー内部一時テーブルが <code class="literal">TempTable</code> ストレージエンジンによって管理される場合、<code class="literal">VARCHAR</code> カラム、<code class="literal">VARBINARY</code> カラムおよびその他のバイナリラージオブジェクト型のカラム (MySQL 8.0.13 時点でサポートされています) を含む行は、セルの配列によってメモリー内にテーブルされ、各セルには NULL フラグ、データ長およびデータポインタが含まれます。 カラム値は、配カラムの後の単一のメモリー領域に、パディングなしで連続した順序で配置されます。 配列内の各セルは 16 バイトの記憶域を使用します。 <code class="literal">TempTable</code> ストレージエンジンが <code class="literal">temptable_max_ram</code> 制限を超え、メモリーマップされたファイルまたは <code class="literal">InnoDB</code> ディスク上の内部一時テーブルとしてディスクから領域の割り当てを開始した場合も、同じストレージ形式が適用されます。 
        </p><p>
          インメモリー内部一時テーブルが <code class="literal">MEMORY</code> ストレージエンジンによって管理される場合、固定長の行形式が使用されます。 <code class="literal">VARCHAR</code> および <code class="literal">VARBINARY</code> のカラム値は最大カラム長に埋め込まれ、実質的には <code class="literal">CHAR</code> および <code class="literal">BINARY</code> のカラムとして格納されます。 
        </p><p>
          MySQL 8.0.16 より前は、ディスク上の内部一時テーブルは <code class="literal">InnoDB</code> または <code class="literal">MyISAM</code> ストレージエンジンによって管理されていました (<code class="literal">internal_tmp_disk_storage_engine</code> の設定によって異なります)。 どちらのエンジンも、動的幅の行形式を使用して内部一時テーブルを格納します。 カラムには必要な記憶域のみが必要です。これにより、固定長の行を使用するディスク上のテーブルと比較して、ディスク I/O,領域要件および処理時間が短縮されます。 MySQL 8.0.16 以降、<code class="literal">internal_tmp_disk_storage_engine</code> はサポートされず、ディスク上の内部一時テーブルは常に <code class="literal">InnoDB</code> によって処理されます。 
        </p><p>
          <code class="literal">MEMORY</code> ストレージエンジンを使用する場合、ステートメントは最初にインメモリー内部一時テーブルを作成し、テーブルが大きすぎる場合はそれをディスク上のテーブルに変換できます。 このような場合は、変換をスキップし、ディスク上に内部一時テーブルを作成して開始することで、パフォーマンスが向上する可能性があります。 <code class="literal">big_tables</code> 変数を使用して、内部一時テーブルのディスク記憶域を強制できます。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="internal-temporary-tables-monitoring"></a>内部一時テーブルの作成の監視</h4></div></div></div><p>
          内部一時テーブルがメモリーまたはディスクに作成されると、サーバーは <code class="literal">Created_tmp_tables</code> 値を増分します。 内部一時テーブルがディスク上に作成されると、サーバーは <code class="literal">Created_tmp_disk_tables</code> 値を増分します。 ディスク上に作成される内部一時テーブルが多すぎる場合は、<code class="literal">tmp_table_size</code> および <code class="literal">max_heap_table_size</code> の設定を増やすことを検討してください。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            既知の制限のため、<code class="literal">Created_tmp_disk_tables</code> ではメモリーマップファイルに作成されたディスク上の一時テーブルはカウントされません。 デフォルトでは、TempTable ストレージエンジンオーバーフローメカニズムは、メモリーマップされたファイルに内部一時テーブルを作成します。 この動作は、<code class="literal">temptable_use_mmap</code> および <code class="literal">temptable_max_mmap</code> 変数によって制御されます。 
          </p></div><p>
          <code class="literal">memory/temptable/physical_ram</code> および <code class="literal">memory/temptable/physical_disk</code> パフォーマンススキーマインストゥルメントを使用すると、メモリーおよびディスクからの <code class="literal">TempTable</code> 領域割り当てをモニターできます。<code class="literal">memory/temptable/physical_ram</code> では、割り当てられた RAM の量がレポートされます。メモリーマップされたファイルが TempTable オーバーフローメカニズムとして使用されている場合、<code class="literal">memory/temptable/physical_disk</code> はディスクから割り当てられた領域の量を報告します。 <code class="literal">physical_disk</code> インストゥルメントが 0 以外の値を報告し、メモリーマップされたファイルが TempTable オーバーフローメカニズムとして使用される場合、<code class="literal">temptable_max_ram</code> しきい値にはある時点で到達しました。 データは、<code class="literal">memory_summary_global_by_event_name</code> などのパフォーマンススキーマメモリーサマリーテーブルでクエリーできます。 <a class="xref" href="performance-schema.html#performance-schema-memory-summary-tables" title="27.12.18.10 メモリーサマリーテーブル">セクション27.12.18.10「メモリーサマリーテーブル」</a>を参照してください。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="database-count-limit"></a>8.4.5 データベースおよびテーブルの数に対する制限</h3></div></div></div><a class="indexterm" name="idm45661477612752"></a><a class="indexterm" name="idm45661477610608"></a><a class="indexterm" name="idm45661477608544"></a><a class="indexterm" name="idm45661477606480"></a><p>
        MySQL にはデータベース数の制限はありません。 ベースとなるファイルシステムによっては、ディレクトリ数に制限がある場合があります。 
      </p><p>
        MySQL にはテーブル数の制限はありません。 ベースとなるファイルシステムによっては、テーブルを表すファイル数に制限がある場合があります。 個々のストレージエンジンには、エンジン固有の制約が課される場合があります。 <code class="literal">InnoDB</code> では、最大 40 億個のテーブルを使用できます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="table-size-limit"></a>8.4.6 テーブルサイズの制限</h3></div></div></div><a class="indexterm" name="idm45661477600496"></a><a class="indexterm" name="idm45661477598384"></a><a class="indexterm" name="idm45661477596352"></a><a class="indexterm" name="idm45661477594320"></a><a class="indexterm" name="idm45661477592944"></a><a class="indexterm" name="idm45661477590848"></a><a class="indexterm" name="idm45661477589184"></a><p>
        MySQL データベースの事実上の最大テーブルサイズは、通常、MySQL の内部制限ではなくオペレーティングシステムのファイルサイズに関する制約によって判断します。 オペレーティングシステムのファイルサイズに関する最新情報は、オペレーティングシステム固有のドキュメントを参照してください。 
      </p><p>
        Windows ユーザーの場合、FAT および VFAT (FAT32) は、MySQL で本番使用に適しているとは見なされ<span class="emphasis"><em>ません</em></span>。 代わりに NTFS を使用してください。 
      </p><p>
        全テーブルエラーが発生した場合は、いくつかの理由が考えられます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ディスクがいっぱいになっている可能性がある。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> テーブルを使用しており、<code class="literal">InnoDB</code> テーブルスペースファイルの領域が不足しています。 最大テーブルスペースサイズは、テーブルの最大サイズでもあります。 テーブルスペースのサイズ制限については、<a class="xref" href="innodb-storage-engine.html#innodb-limits" title="15.22 InnoDB の制限">セクション15.22「InnoDB の制限」</a> を参照してください。 
          </p><p>
            一般に、サイズが 1TB を超えるテーブルでは、テーブルを複数のテーブルスペースファイルにパーティション化することをお薦めします。
          </p></li><li class="listitem"><p>
            オペレーティングシステムのファイルサイズ制限に達しました。 たとえば、最大 2GB のサイズのファイルのみをサポートするオペレーティングシステムで <code class="literal">MyISAM</code> テーブルを使用しており、データファイルまたはインデックスファイルに対してこの制限に達しているとします。 
          </p></li><li class="listitem"><p>
            <code class="literal">MyISAM</code> テーブルを使用していて、テーブルに必要な領域が内部ポインタサイズによって許可されているサイズを超えている。 <code class="literal">MyISAM</code> では、データファイルとインデックスファイルのサイズはデフォルトで最大 256T バイトですが、この制限は、65,536T バイト (256<sup>7</sup> − 1 バイト) の最大許容サイズまで変更できます。 
          </p><p>
            デフォルトの制限より大きな <code class="literal">MyISAM</code> テーブルが必要であり、オペレーティングシステムが大きなファイルをサポートしている場合は、<code class="literal">CREATE TABLE</code> ステートメントは <code class="literal">AVG_ROW_LENGTH</code> オプションと <code class="literal">MAX_ROWS</code> オプションをサポートします。 <a class="xref" href="sql-statements.html#create-table" title="13.1.20 CREATE TABLE ステートメント">セクション13.1.20「CREATE TABLE ステートメント」</a>を参照してください。 サーバーはこれらのオプションを使用して、許可するテーブルのサイズを決定します。 
          </p><p>
            ポインタサイズが既存のテーブルに対して小さすぎる場合は、<code class="literal">ALTER TABLE</code> でオプションを変更して、テーブルの最大許容サイズを増やすことができます。 <a class="xref" href="sql-statements.html#alter-table" title="13.1.9 ALTER TABLE ステートメント">セクション13.1.9「ALTER TABLE ステートメント」</a>を参照してください。 
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> MAX_ROWS=1000000000 AVG_ROW_LENGTH=<em class="replaceable"><code>nnn</code></em>;
</pre><p>
            <code class="literal">AVG_ROW_LENGTH</code> は、<code class="literal">BLOB</code> カラムまたは <code class="literal">TEXT</code> カラムを含むテーブルに対してのみ指定する必要があります。この場合、MySQL では、行数にのみ基づいて必要な領域を最適化することはできません。
          </p><p>
            <code class="literal">MyISAM</code> テーブルのデフォルトのサイズ制限を変更するには、内部行ポインタに使用されるバイト数を設定する <code class="literal">myisam_data_pointer_size</code> を設定します。 <code class="literal">MAX_ROWS</code> オプションを指定しない場合、新しいテーブルのポインタサイズを設定するためにこの値が使用されます。 <code class="literal">myisam_data_pointer_size</code> の値は 2 から 7 で指定できます。 4 の値は 4G バイトまでのテーブルを許可し、6 の値は 256T バイトまでのテーブルを許可します。 
          </p><p>
            次のステートメントを使用すると、データファイルおよびインデックスファイルの最大サイズを確認できます。
          </p><pre class="programlisting">SHOW TABLE STATUS FROM <em class="replaceable"><code>db_name</code></em> LIKE '<em class="replaceable"><code>tbl_name</code></em>';
</pre><p>
            <span class="command"><strong>myisamchk -dv /path/to/table-index-file</strong></span> も使用できます。 <a class="xref" href="sql-statements.html#show" title="13.7.7 SHOW ステートメント">セクション13.7.7「SHOW ステートメント」</a>または<a class="xref" href="programs.html#myisamchk" title="4.6.4 myisamchk — MyISAM テーブルメンテナンスユーティリティー">セクション4.6.4「myisamchk — MyISAM テーブルメンテナンスユーティリティー」</a>を参照してください。 
          </p><p>
            <code class="literal">MyISAM</code> テーブルのファイルサイズ制限に対処するその他の方法は次のとおりです。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                大きなテーブルが読み取り専用である場合、<span class="command"><strong>myisampack</strong></span> を使用してこのテーブルを圧縮できます。<span class="command"><strong>myisampack</strong></span> は通常、少なくとも 50% 圧縮するので、実質上、さらに大きなテーブルを保有できます。<span class="command"><strong>myisampack</strong></span> で複数のテーブルを単一のテーブルにマージすることもできます。 <a class="xref" href="programs.html#myisampack" title="4.6.6 myisampack — 圧縮された読み取り専用の MyISAM テーブルの生成">セクション4.6.6「myisampack — 圧縮された読み取り専用の MyISAM テーブルの生成」</a>を参照してください。 
              </p></li><li class="listitem"><p>
                MySQL には、単一の <code class="literal">MERGE</code> テーブルと同一の構造を持つ <code class="literal">MyISAM</code> テーブルの集まりを処理できるようにする <code class="literal">MERGE</code> ライブラリが含まれます。 <a class="xref" href="storage-engines.html#merge-storage-engine" title="16.7 MERGE ストレージエンジン">セクション16.7「MERGE ストレージエンジン」</a>を参照してください。 
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">MEMORY</code> (<code class="literal">HEAP</code>) ストレージエンジンを使用している場合は、<code class="literal">max_heap_table_size</code> システム変数の値を増やす必要があります。 <a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>を参照してください。 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="column-count-limit"></a>8.4.7 テーブルカラム数と行サイズの制限</h3></div></div></div><p>
        このセクションでは、テーブルのカラム数および個々の行のサイズの制限について説明します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#column-count-limits" title="カラム数制限">カラム数制限</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#row-size-limits" title="行サイズ制限">行サイズ制限</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="column-count-limits"></a>カラム数制限</h4></div></div></div><a class="indexterm" name="idm45661477530864"></a><a class="indexterm" name="idm45661477528656"></a><a class="indexterm" name="idm45661477526560"></a><p>
          MySQL にはテーブル当たり 4096 カラムの強い制限がありますが、特定のテーブルの有効な最大値が少なくなる可能性があります。 カラムの正確な制限は、いくつかの要因によって異なります: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              すべてのカラムの合計長がこのサイズを超えることはできないため、テーブルの最大行サイズによってカラムの数 (および場合によってはサイズ) が制限されます。 <a class="xref" href="optimization.html#row-size-limits" title="行サイズ制限">行サイズ制限</a>を参照してください。 
            </p></li><li class="listitem"><p>
              個々のカラムの記憶域要件によって、指定された最大行サイズ内に収まるカラム数が制限されます。 一部のデータ型の記憶域要件は、記憶域エンジン、記憶域形式、文字セットなどの要因によって異なります。 <a class="xref" href="data-types.html#storage-requirements" title="11.7 データ型のストレージ要件">セクション11.7「データ型のストレージ要件」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              ストレージエンジンは、テーブルカラム数を制限する追加の制限を課す場合があります。 たとえば、<code class="literal">InnoDB</code> には、テーブル当たり 1017 カラムの制限があります。 <a class="xref" href="innodb-storage-engine.html#innodb-limits" title="15.22 InnoDB の制限">セクション15.22「InnoDB の制限」</a>を参照してください。 その他のストレージエンジンについては、<a class="xref" href="storage-engines.html" title="第 16 章 代替ストレージエンジン">第16章「<i>代替ストレージエンジン</i>」</a> を参照してください。 
            </p></li><li class="listitem"><p>
              関数キー部分 (<a class="xref" href="sql-statements.html#create-index" title="13.1.15 CREATE INDEX ステートメント">セクション13.1.15「CREATE INDEX ステートメント」</a> を参照) は、非表示の仮想生成ストアドカラムとして実装されるため、テーブルインデックス内の各関数キー部分は、テーブルの合計カラム制限に対してカウントされます。
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="row-size-limits"></a>行サイズ制限</h4></div></div></div><a class="indexterm" name="idm45661477512144"></a><a class="indexterm" name="idm45661477509984"></a><a class="indexterm" name="idm45661477507936"></a><p>
          特定のテーブルの最大行サイズは、いくつかの要因によって決定されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              ストレージエンジンがより大きな行をサポートできる場合でも、MySQL テーブルの内部表現の最大行サイズは 65,535 バイトです。 <code class="literal">BLOB</code> および <code class="literal">TEXT</code> のカラムは、行サイズ制限に 9 から 12 バイトのみ寄与します。これは、その内容が行の他の部分とは別に格納されるためです。 
            </p></li><li class="listitem"><p>
              データベースページ内にローカルに格納されたデータに適用される <code class="literal">InnoDB</code> テーブルの最大行サイズは、4KB、8KB、16KB および 32KB の <code class="literal">innodb_page_size</code> 設定のページの半分未満です。 たとえば、デフォルトの 16KB の <code class="literal">InnoDB</code> ページサイズでは、最大行サイズは 8KB 未満です。 64KB ページの場合、最大行サイズは 16KB 未満です。 <a class="xref" href="innodb-storage-engine.html#innodb-limits" title="15.22 InnoDB の制限">セクション15.22「InnoDB の制限」</a>を参照してください。 
            </p><p>
              <a class="link" href="glossary.html#glos_variable_length_type" title="可変長型">variable-length columns</a> を含む行が <code class="literal">InnoDB</code> の最大行サイズを超える場合、<code class="literal">InnoDB</code> は、行が <code class="literal">InnoDB</code> の行サイズ制限内に収まるまで、外部オフページストレージの可変長カラムを選択します。 ページ外に格納される可変長カラムに対してローカルに格納されるデータ量は、行形式によって異なります。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="15.10 InnoDB の行フォーマット">セクション15.10「InnoDB の行フォーマット」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              記憶域形式が異なると、ページヘッダーおよびトレーラデータが異なるため、行に使用可能な記憶域の量に影響します。
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">InnoDB</code> の行フォーマットの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="15.10 InnoDB の行フォーマット">セクション15.10「InnoDB の行フォーマット」</a> を参照してください。
                </p></li><li class="listitem"><p>
                  <code class="literal">MyISAM</code> 記憶域形式の詳細は、<a class="xref" href="storage-engines.html#myisam-table-formats" title="16.2.3 MyISAM テーブルのストレージフォーマット">セクション16.2.3「MyISAM テーブルのストレージフォーマット」</a> を参照してください。
                </p></li></ul></div></li></ul></div><h5><a name="idm45661477485584"></a>行サイズ制限の例</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              次の <code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> の例では、65,535 バイトの MySQL 最大行サイズ制限を示します。 この制限は、ストレージエンジンがより大きな行をサポートできる場合でも、ストレージエンジンに関係なく適用されます。 
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t (a VARCHAR(10000), b VARCHAR(10000),</code></strong>
       <strong class="userinput"><code>c VARCHAR(10000), d VARCHAR(10000), e VARCHAR(10000),</code></strong>
       <strong class="userinput"><code>f VARCHAR(10000), g VARCHAR(6000)) ENGINE=InnoDB CHARACTER SET latin1;</code></strong>
ERROR 1118 (42000): Row size too large. The maximum row size for the used
table type, not counting BLOBs, is 65535. This includes storage overhead,
check the manual. You have to change some columns to TEXT or BLOBs
</pre><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t (a VARCHAR(10000), b VARCHAR(10000),</code></strong>
       <strong class="userinput"><code>c VARCHAR(10000), d VARCHAR(10000), e VARCHAR(10000),</code></strong>
       <strong class="userinput"><code>f VARCHAR(10000), g VARCHAR(6000)) ENGINE=MyISAM CHARACTER SET latin1;</code></strong>
ERROR 1118 (42000): Row size too large. The maximum row size for the used
table type, not counting BLOBs, is 65535. This includes storage overhead,
check the manual. You have to change some columns to TEXT or BLOBs
</pre><p>
              次の <code class="literal">MyISAM</code> の例では、カラムを <code class="literal">TEXT</code> に変更すると、65,535-byte の行サイズ制限が回避され、<code class="literal">BLOB</code> および <code class="literal">TEXT</code> のカラムは行サイズに 9 から 12 バイトしか寄与しないため、操作を成功させることができます。
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t (a VARCHAR(10000), b VARCHAR(10000),</code></strong>
       <strong class="userinput"><code>c VARCHAR(10000), d VARCHAR(10000), e VARCHAR(10000),</code></strong>
       <strong class="userinput"><code>f VARCHAR(10000), g TEXT(6000)) ENGINE=MyISAM CHARACTER SET latin1;</code></strong>
Query OK, 0 rows affected (0.02 sec)
</pre><p>
              カラムを <code class="literal">TEXT</code> に変更すると MySQL 65,535-byte の行サイズ制限が回避され、可変長カラムの <code class="literal">InnoDB</code> オフページストレージによって <code class="literal">InnoDB</code> の行サイズ制限が回避されるため、<code class="literal">InnoDB</code> テーブルに対する操作は成功します。
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t (a VARCHAR(10000), b VARCHAR(10000),</code></strong>
       <strong class="userinput"><code>c VARCHAR(10000), d VARCHAR(10000), e VARCHAR(10000),</code></strong>
       <strong class="userinput"><code>f VARCHAR(10000), g TEXT(6000)) ENGINE=InnoDB CHARACTER SET latin1;</code></strong>
Query OK, 0 rows affected (0.02 sec)
</pre></li><li class="listitem"><p>
              可変長カラムの記憶域には、行サイズにカウントされる長さバイトが含まれます。 たとえば、<code class="literal">VARCHAR(255) CHARACTER SET utf8mb3</code> カラムには値の長さを格納するために 2 バイトかかるため、各値には最大 767 バイトを使用できます。 
            </p><p>
              カラムに 32,765 + 2 バイトおよび 32,766 + 2 バイトが必要で、これは最大行サイズ 65,535 バイト内にあるため、テーブル <code class="literal">t1</code> を作成するステートメントは成功します:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1</code></strong>
       <strong class="userinput"><code>(c1 VARCHAR(32765) NOT NULL, c2 VARCHAR(32766) NOT NULL)</code></strong>
       <strong class="userinput"><code>ENGINE = InnoDB CHARACTER SET latin1;</code></strong>
Query OK, 0 rows affected (0.02 sec)
</pre><p>
              カラムの長さが 65,535 バイトの最大長内にあるにもかかわらず、行サイズが 65,535 バイトを超えるため、テーブル <code class="literal">t2</code> を作成するステートメントは失敗します:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t2</code></strong>
       <strong class="userinput"><code>(c1 VARCHAR(65535) NOT NULL)</code></strong>
       <strong class="userinput"><code>ENGINE = InnoDB CHARACTER SET latin1;</code></strong>
ERROR 1118 (42000): Row size too large. The maximum row size for the used
table type, not counting BLOBs, is 65535. This includes storage overhead,
check the manual. You have to change some columns to TEXT or BLOBs
</pre><p>
              カラム長を 65,533 以下に減らすと、ステートメントは成功します。
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t2</code></strong>
       <strong class="userinput"><code>(c1 VARCHAR(65533) NOT NULL)</code></strong>
       <strong class="userinput"><code>ENGINE = InnoDB CHARACTER SET latin1;</code></strong>
Query OK, 0 rows affected (0.01 sec)
</pre></li><li class="listitem"><p>
              <code class="literal">MyISAM</code> テーブルの場合、<code class="literal">NULL</code> カラムは、値が <code class="literal">NULL</code> であるかどうかを記録するための追加領域を行内に必要とします。 各 <code class="literal">NULL</code> カラムは 1 ビット余分に占め、もっとも近いバイトまで丸められます。 
            </p><p>
              <code class="literal">MyISAM</code> には可変長のカラム長バイトに必要な領域に加えて <code class="literal">NULL</code> カラムの領域が必要であり、行サイズが 65,535 バイトを超えるため、テーブル <code class="literal">t3</code> を作成するステートメントは失敗します:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t3</code></strong>
       <strong class="userinput"><code>(c1 VARCHAR(32765) NULL, c2 VARCHAR(32766) NULL)</code></strong>
       <strong class="userinput"><code>ENGINE = MyISAM CHARACTER SET latin1;</code></strong>
ERROR 1118 (42000): Row size too large. The maximum row size for the used
table type, not counting BLOBs, is 65535. This includes storage overhead,
check the manual. You have to change some columns to TEXT or BLOBs
</pre><p>
              <code class="literal">InnoDB</code> <code class="literal">NULL</code> カラムの記憶域の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="15.10 InnoDB の行フォーマット">セクション15.10「InnoDB の行フォーマット」</a> を参照してください。
            </p></li><li class="listitem"><p>
              <code class="literal">InnoDB</code> では、行サイズ (データベースページ内にローカルに格納されるデータの場合) は、4KB、8KB、16KB および 32KB の <code class="literal">innodb_page_size</code> 設定ではデータベースページの半分未満に制限され、64KB ページでは 16KB 未満に制限されます。
            </p><p>
              定義されたカラムが 16KB の <code class="literal">InnoDB</code> ページの行サイズ制限を超えているため、テーブル <code class="literal">t4</code> を作成するステートメントは失敗します。
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t4 (</code></strong>
       <strong class="userinput"><code>c1 CHAR(255),c2 CHAR(255),c3 CHAR(255),</code></strong>
       <strong class="userinput"><code>c4 CHAR(255),c5 CHAR(255),c6 CHAR(255),</code></strong>
       <strong class="userinput"><code>c7 CHAR(255),c8 CHAR(255),c9 CHAR(255),</code></strong>
       <strong class="userinput"><code>c10 CHAR(255),c11 CHAR(255),c12 CHAR(255),</code></strong>
       <strong class="userinput"><code>c13 CHAR(255),c14 CHAR(255),c15 CHAR(255),</code></strong>
       <strong class="userinput"><code>c16 CHAR(255),c17 CHAR(255),c18 CHAR(255),</code></strong>
       <strong class="userinput"><code>c19 CHAR(255),c20 CHAR(255),c21 CHAR(255),</code></strong>
       <strong class="userinput"><code>c22 CHAR(255),c23 CHAR(255),c24 CHAR(255),</code></strong>
       <strong class="userinput"><code>c25 CHAR(255),c26 CHAR(255),c27 CHAR(255),</code></strong>
       <strong class="userinput"><code>c28 CHAR(255),c29 CHAR(255),c30 CHAR(255),</code></strong>
       <strong class="userinput"><code>c31 CHAR(255),c32 CHAR(255),c33 CHAR(255)</code></strong>
       <strong class="userinput"><code>) ENGINE=InnoDB ROW_FORMAT=DYNAMIC DEFAULT CHARSET latin1;</code></strong>
ERROR 1118 (42000): Row size too large (&gt; 8126). Changing some columns to TEXT or BLOB may help.
In current row format, BLOB prefix of 0 bytes is stored inline.
</pre></li></ul></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="optimizing-innodb"></a>8.5 InnoDB テーブルの最適化</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#optimizing-innodb-storage-layout">8.5.1 InnoDB テーブルのストレージレイアウトの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-transaction-management">8.5.2 InnoDB トランザクション管理の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#innodb-performance-ro-txn">8.5.3 InnoDB の読み取り専用トランザクションの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-logging">8.5.4 InnoDB redo ロギングの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-bulk-data-loading">8.5.5 InnoDB テーブルの一括データロード</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-queries">8.5.6 InnoDB クエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-ddl-operations">8.5.7 InnoDB DDL 操作の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-diskio">8.5.8 InnoDB ディスク I/O の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-configuration-variables">8.5.9 InnoDB 構成変数の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-many-tables">8.5.10 多くのテーブルのあるシステムに対する InnoDB の最適化</a></span></dt></dl></div><a class="indexterm" name="idm45661477413216"></a><a class="indexterm" name="idm45661477410352"></a><p>
      <code class="literal">InnoDB</code> は、MySQL のお客様が一般に、信頼性と並列性が重要である本番環境のデータベースで使用するストレージエンジンです。 <code class="literal">InnoDB</code> は、MySQL のデフォルトのストレージエンジンです。 このセクションでは、<code class="literal">InnoDB</code> テーブルに対するデータベース操作を最適化する方法について説明します。 
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-innodb-storage-layout"></a>8.5.1 InnoDB テーブルのストレージレイアウトの最適化</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            データが安定したサイズに達するか、拡大しているテーブルが数十または数百メガバイト単位で増大した場合、<code class="literal">OPTIMIZE TABLE</code> ステートメントを使用して、テーブルを再編成し、無駄なスペースを圧縮することを考慮します。 再編成されたテーブルでは、フルテーブルスキャンを実行するために必要なディスク I/O が減ります。 これは、インデックスの使用の改善やアプリケーションコードのチューニングなどのほかの技法が現実的でない場合に、パフォーマンスを向上できる直接的な技法です。 
          </p><p>
            <code class="literal">OPTIMIZE TABLE</code> はテーブルのデータ部分をコピーし、インデックスを再構築します。 インデックス内へのデータのパックの改善とテーブルスペース内およびディスク上の断片化の削減からメリットが得られます。 このメリットは各テーブル内のデータによって異なります。 利点が大きいものとそうでないものがあること、またはテーブルの次回の最適化まで、時間の経過とともに利点が減っていくことに気付く場合があります。 テーブルが大きい場合、または再構築されるインデックスがバッファプールに収まらない場合、この操作は遅くなる可能性があります。 大量のデータをテーブルに追加したあとの最初の実行では、多くの場合にその後の実行よりかなり遅くなります。 
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> では、長い <code class="literal">PRIMARY KEY</code> (長い値を持つ単一カラムまたは長い複合値を形成する複数のカラムのいずれか) があると、大量のディスク領域を無駄にします。 行の主キー値は、同じ行を指すすべてのセカンダリインデックスレコードに複製されます。 (<a class="xref" href="innodb-storage-engine.html#innodb-index-types" title="15.6.2.1 クラスタインデックスとセカンダリインデックス">セクション15.6.2.1「クラスタインデックスとセカンダリインデックス」</a>を参照してください。) 主キーが長い場合、<code class="literal">AUTO_INCREMENT</code> カラムを主キーとして作成するか、カラム全体ではなく、長い <code class="literal">VARCHAR</code> カラムのプリフィクスをインデックス設定します。 
          </p></li><li class="listitem"><p>
            可変長の文字列を格納するために、または多くの <code class="literal">NULL</code> 値を持つカラムに対して、<code class="literal">CHAR</code> の代わりに <code class="literal">VARCHAR</code> データ型を使用します。 <code class="literal">CHAR(<em class="replaceable"><code>N</code></em>)</code> カラムは、文字列が短いか、その値が <code class="literal">NULL</code> だとしても、データを格納するために常に <em class="replaceable"><code>N</code></em> 文字を必要とします。 テーブルが小さいほどバッファープールに収まりやすく、ディスク I/O が減ります。 
          </p><p>
            <code class="literal">COMPACT</code> 行フォーマット (デフォルトの <code class="literal">InnoDB</code> フォーマット) および可変長文字セット (<code class="literal">utf8</code> や <code class="literal">sjis</code> など) を使用する場合、<code class="literal">CHAR(<em class="replaceable"><code>N</code></em>)</code> カラムは可変容量の領域を占有しますが、<em class="replaceable"><code>N</code></em> バイト以上のままです。
          </p></li><li class="listitem"><p>
            大きいか、繰り返しの多い大量のテキストや数値データを格納するテーブルでは、<code class="literal">COMPRESSED</code> 行フォーマットを使用することを考慮します。 データをバッファープールに入れたり、フルテーブルスキャンを実行したりするために必要なディスク I/O が減ります。 永続的な決断を下す前に、<code class="literal">COMPRESSED</code> と <code class="literal">COMPACT</code> の行フォーマットを使用して達成できる圧縮の量を測定してください。 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-innodb-transaction-management"></a>8.5.2 InnoDB トランザクション管理の最適化</h3></div></div></div><p>
        <code class="literal">InnoDB</code> トランザクション処理を最適化するには、トランザクション機能のパフォーマンスオーバーヘッドとサーバーのワークロードの理想的なバランスを見つけます。 たとえば、アプリケーションで、秒あたり数千回コミットする場合にパフォーマンスの問題が発生し、2、3 時間に 1 回だけコミットする場合に別のパフォーマンスの問題が発生することがあります。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            デフォルトの MySQL 設定 <code class="literal">AUTOCOMMIT=1</code> は、ビジーなデータベースサーバーにパフォーマンスの制限を課すことがあります。 実用的な場合は、<code class="literal">SET AUTOCOMMIT=0</code> または <code class="literal">START TRANSACTION</code> ステートメントを発行し、すべての変更を行った後に <code class="literal">COMMIT</code> ステートメントを発行して、関連する複数のデータ変更操作を単一のトランザクションにラップします。 
          </p><p>
            <code class="literal">InnoDB</code> は、トランザクションによってデータベースが変更された場合、そのトランザクションのコミットのたびにディスクにログをフラッシュする必要があります。 変更のたびにあとでコミットされる場合 (デフォルトの自動コミット設定のように)、ストレージデバイスの I/O スループットによって、秒あたりに可能な操作数が制限されます。 
          </p></li><li class="listitem"><p>
            または、単一の <code class="literal">SELECT</code> ステートメントのみから構成されるトランザクションの場合、<code class="literal">AUTOCOMMIT</code> をオンにすると、<code class="literal">InnoDB</code> が読み取り専用トランザクションを認識し、それらを最適化するのに役立ちます。 要件については、<a class="xref" href="optimization.html#innodb-performance-ro-txn" title="8.5.3 InnoDB の読み取り専用トランザクションの最適化">セクション8.5.3「InnoDB の読み取り専用トランザクションの最適化」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            大量の行の挿入、更新、または削除後のロールバックの実行は避けます。 大きなトランザクションがサーバーのパフォーマンスを低下させている場合、ロールバックすると問題が悪化し、元のデータ変更操作の実行に数回かかる可能性があります。 ロールバックはサーバーの起動時に再度開始されるため、データベースプロセスを強制終了しても役立ちません。 
          </p><p>
            この問題が発生する可能性を最小限に抑えるには:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                すべてのデータ変更がディスクに即座に書き込まれるのではなくキャッシュされるように、<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> のサイズを増やします。
              </p></li><li class="listitem"><p>
                挿入に加えて更新および削除操作がバッファされるように <code class="literal">innodb_change_buffering=all</code> を設定します。
              </p></li><li class="listitem"><p>
                ビッグデータ変更操作中に <code class="literal">COMMIT</code> ステートメントを定期的に発行することを検討してください。これにより、単一の削除または更新が少数の行で動作する複数のステートメントに分割される可能性があります。
              </p></li></ul></div><p>
            ロールバックの暴走が発生した場合にそれを解消するには、ロールバックが CPU に依存して高速に実行するように、バッファープールを増加するか、<a class="xref" href="innodb-storage-engine.html#innodb-recovery" title="15.18.2 InnoDB のリカバリ">セクション15.18.2「InnoDB のリカバリ」</a>に説明するように、サーバーを強制終了し、<code class="literal">innodb_force_recovery=3</code> で再起動します。
          </p><p>
            この問題は、デフォルト設定の <code class="literal">innodb_change_buffering=all</code> ではあまり発生しないことが予想されます。これにより、更新および削除操作をメモリーにキャッシュできるため、最初の場所での実行が高速になり、必要に応じてロールバックも高速になります。 多くの挿入、更新、または削除を伴う長時間実行トランザクションを処理するサーバーでこのパラメータ設定を使うようにしてください。 
          </p></li><li class="listitem"><p>
            予期しない終了が発生した場合に最新のコミット済トランザクションの一部が失われる可能性がある場合は、<code class="literal">innodb_flush_log_at_trx_commit</code> パラメータを 0 に設定できます。 フラッシュが保証されていなくても、<code class="literal">InnoDB</code> はとにかく 1 秒に 1 回ログをフラッシュしようとします。 
          </p></li><li class="listitem"><p>
            行が変更されるか削除される場合、行と関連付けられた<a class="link" href="glossary.html#glos_undo_log" title="Undo ログ">Undo ログ</a>はただちに、またはトランザクションのコミットの直後でも、物理的に削除されません。 以前または同時に開始したトランザクションが終了するまで古いデータは保持されるため、それらのトランザクションは変更または削除された行の以前の状態にアクセスできます。 そのため、長時間実行トランザクションは、<code class="literal">InnoDB</code> が別のトランザクションによって変更されたデータをパージすることを妨げることがあります。 
          </p></li><li class="listitem"><p>
            長時間実行トランザクション内で行が変更されるか、削除された場合、<code class="literal">READ COMMITTED</code> および <code class="literal">REPEATABLE READ</code> 分離レベルを使用するほかのトランザクションは、古いデータを再構築するために、それらの同じ行を読み取る場合、多くの作業を実行する必要があります。
          </p></li><li class="listitem"><p>
            長時間実行トランザクションでテーブルが変更された場合、ほかのトランザクションからのそのテーブルに対するクエリーは、<a class="link" href="glossary.html#glos_covering_index" title="カバリングインデックス">カバリングインデックス</a>技法を利用しません。 通常、セカンダリインデックスからすべての結果カラムを取得できるクエリーは、代わりにテーブルデータから該当する値をルックアップします。 
          </p><p>
            セカンダリインデックスページに、新しすぎる <code class="literal">PAGE_MAX_TRX_ID</code> があることが検出された場合、またはセカンダリインデックス内のレコードに削除がマークされている場合、<code class="literal">InnoDB</code> はクラスタ化されたインデックスを使用してレコードをルックアップする必要がある可能性があります。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-performance-ro-txn"></a>8.5.3 InnoDB の読み取り専用トランザクションの最適化</h3></div></div></div><p>
        <code class="literal">InnoDB</code> では、読取り専用として認識されているトランザクションの <a class="link" href="glossary.html#glos_transaction_id" title="トランザクション ID">transaction ID</a> (<code class="literal">TRX_ID</code> フィールド) の設定に関連するオーバーヘッドを回避できます。 トランザクション ID は、書き込み操作または<a class="link" href="glossary.html#glos_locking_read" title="ロック読み取り">ロック読み取り</a> (<code class="literal">SELECT ... FOR UPDATE</code> など) を実行する可能性のある<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>にのみ必要です。 不要なトランザクション ID を排除すると、クエリーまたはデータ変更ステートメントが <a class="link" href="glossary.html#glos_read_view" title="読み取りビュー">read view</a> を構成するたびに参照される内部データ構造のサイズが削減されます。 
      </p><p>
        <code class="literal">InnoDB</code> は、次の場合に読取り専用トランザクションを検出します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            トランザクションが <code class="literal">START TRANSACTION READ ONLY</code> ステートメントで開始された場合。 この場合は、データベース (<code class="literal">InnoDB</code>、<code class="literal">MyISAM</code>、またはその他のタイプのテーブル) に対して変更を行おうとするとエラーが発生し、そのトランザクションは読み取り専用状態のままになります。 
          </p><pre class="programlisting">ERROR 1792 (25006): Cannot execute statement in a READ ONLY transaction.
</pre><p>
            ただし、読み取り専用トランザクションでのセッション固有の一時テーブルの変更や、それらのテーブルに対するロッククエリーの発行は、その変更やロックがほかのどのトランザクションにも表示されないため引き続き可能です。
          </p></li><li class="listitem"><p>
            <code class="literal">autocommit</code> 設定がオンになっているため、トランザクションが 1 つのステートメントであることが保証され、そのトランザクションを構成している 1 つのステートメントが<span class="quote">「<span class="quote">非ロック</span>」</span>の <code class="literal">SELECT</code> ステートメントである場合。 つまり、<code class="literal">FOR UPDATE</code> または <code class="literal">LOCK IN SHARED MODE</code> 句を使用しない <code class="literal">SELECT</code> です。 
          </p></li><li class="listitem"><p>
            トランザクションは <code class="literal">READ ONLY</code> オプションなしで開始されますが、行を明示的にロックする更新またはステートメントはまだ実行されていません。 更新または明示的ロックが必要になるまで、トランザクションは読取り専用モードのままです。 
          </p></li></ul></div><p>
        したがって、レポートジェネレータなどの読取り集中型アプリケーションの場合は、<code class="literal">START TRANSACTION READ ONLY</code> および <code class="literal">COMMIT</code> 内でグループ化するか、<code class="literal">SELECT</code> ステートメントを実行する前に <code class="literal">autocommit</code> 設定をオンにするか、単にクエリーと混在するデータ変更ステートメントを回避することで、一連の <code class="literal">InnoDB</code> クエリーをチューニングできます。
      </p><p>
        <code class="literal">START TRANSACTION</code> および <code class="literal">autocommit</code> については、<a class="xref" href="sql-statements.html#commit" title="13.3.1 START TRANSACTION、COMMIT および ROLLBACK ステートメント">セクション13.3.1「START TRANSACTION、COMMIT および ROLLBACK ステートメント」</a>を参照してください。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          自動コミット、非ロック、および読み取り専用 (AC-NL-RO) として承認されたトランザクションは、<code class="literal">InnoDB</code> の特定の内部データ構造から除外されるため、<code class="literal">SHOW ENGINE INNODB STATUS</code> の出力には表示されません。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-innodb-logging"></a>8.5.4 InnoDB redo ロギングの最適化</h3></div></div></div><p>
        redo ロギングを最適化するために、次のガイドラインを考慮してください:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            redo ログファイルを <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">buffer pool</a> と同じ大きさにします。 <code class="literal">InnoDB</code> が redo ログファイルをいっぱいにした場合、バッファプールの変更された内容を <a class="link" href="glossary.html#glos_checkpoint" title="チェックポイント">checkpoint</a> のディスクに書き込む必要があります。 redo ログファイルが小さいと、不要なディスク書込みが多数発生します。 以前は大きな redo ログファイルが原因で長いリカバリ時間が発生していましたが、リカバリが大幅に高速になり、大きな redo ログファイルを確実に使用できるようになりました。 
          </p><p>
            redo ログファイルのサイズと数は、<code class="literal">innodb_log_file_size</code> および <code class="literal">innodb_log_files_in_group</code> の構成オプションを使用して構成します。 既存の redo ログファイル構成の変更の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-redo-log-file-reconfigure" title="redo ログファイルの数またはサイズの変更">redo ログファイルの数またはサイズの変更</a> を参照してください。 
          </p></li><li class="listitem"><p>
            <a class="link" href="glossary.html#glos_log_buffer" title="ログバッファー">log buffer</a> のサイズを増やすことを検討してください。 ログバッファーを大きくすると、トランザクションが<a class="link" href="glossary.html#glos_commit" title="コミット">コミット</a>する前にディスクにログを書き込まなくても、大規模な<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>を実行できます。 したがって、多数の行を更新、挿入、または削除するトランザクションの場合、ログバッファーを大きくすると、ディスク I/O を節約できます。 ログバッファサイズは、MySQL 8.0 で動的に構成できる <code class="literal">innodb_log_buffer_size</code> 構成オプションを使用して構成します。 
          </p></li><li class="listitem"><p>
            <span class="quote">「<span class="quote">read-on-write</span>」</span> を回避するには、<code class="literal">innodb_log_write_ahead_size</code> 構成オプションを構成します。 このオプションは、redo ログの先行書込みブロックサイズを定義します。 オペレーティングシステムまたはファイルシステムのキャッシュブロックサイズと一致するように <code class="literal">innodb_log_write_ahead_size</code> を設定します。 読取り/書込みは、redo ログの先行書込みブロックサイズとオペレーティングシステムまたはファイルシステムのキャッシュブロックサイズが一致しないために、redo ログブロックがオペレーティングシステムまたはファイルシステムに完全にキャッシュされない場合に発生します。 
          </p><p>
            <code class="literal">innodb_log_write_ahead_size</code> の有効な値は、<code class="literal">InnoDB</code> ログファイルのブロックサイズ (2 <sup>n</sup>) の倍数です。 最小値は、<code class="literal">InnoDB</code> ログファイルのブロックサイズ (512) です。 最小値が指定されている場合、ライトアヘッドは発生しません。 最大値は <code class="literal">innodb_page_size</code> 値と同じです。 <code class="literal">innodb_log_write_ahead_size</code> に <code class="literal">innodb_page_size</code> 値より大きい値を指定すると、<code class="literal">innodb_log_write_ahead_size</code> 設定は <code class="literal">innodb_page_size</code> 値に切り捨てられます。 
          </p><p>
            オペレーティングシステムまたはファイルシステムのキャッシュブロックサイズに関連して <code class="literal">innodb_log_write_ahead_size</code> 値の設定が小さすぎると、読取り/書込みになります。 値を高く設定しすぎると、一度に複数のブロックが書き込まれるため、ログファイル書込みの <code class="literal">fsync</code> パフォーマンスにわずかな影響を与える可能性があります。 
          </p></li><li class="listitem"><p>
            MySQL 8.0.11 では、ログバッファからシステムバッファに redo ログレコードを書き込み、システムバッファを redo ログファイルにフラッシュするための専用のログライタースレッドが導入されました。 以前は、個々のユーザースレッドがこれらのタスクを担当していました。 MySQL 8.0.22 では、<code class="literal">innodb_log_writer_threads</code> 変数を使用してログライタースレッドを有効または無効にできます。 専用ログライタースレッドを使用すると、同時実行性の高いシステムのパフォーマンスを向上させることができますが、同時実行性の低いシステムでは、専用ログライタースレッドを無効にすると、パフォーマンスが向上します。 
          </p></li><li class="listitem"><p>
            フラッシュされた redo を待機するユーザースレッドによるスピン遅延の使用を最適化します。 スピン遅延は、待機時間の短縮に役立ちます。 同時実行性の低い期間では、待機時間を短縮すると優先度が低くなり、これらの期間中のスピン遅延の使用を回避するとエネルギー消費が削減される可能性があります。 同時実行性が高い期間は、スピン遅延時の処理能力の消費を回避して、他の作業に使用できるようにすることが必要な場合があります。 次のシステム変数では、スピン遅延を使用するための境界を定義する最高水位標値と最低水位標値を設定できます。 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">innodb_log_wait_for_flush_spin_hwm</code>: フラッシュされた redo の待機中にユーザースレッドがスピンしなくなる最大平均ログフラッシュ時間を定義します。 デフォルト値は 400 マイクロ秒です。 
              </p></li><li class="listitem"><p>
                <code class="literal">innodb_log_spin_cpu_abs_lwm</code>: フラッシュされた redo の待機中にユーザースレッドがスピンしなくなる CPU 使用率の最小量を定義します。 この値は、CPU コア使用率の合計として表されます。 たとえば、80 のデフォルト値は、単一の CPU コアの 80% です。 マルチコアプロセッサを搭載したシステムでは、150 の値は、1 つの CPU コアの 100% 使用率と 2 つ目の CPU コアの 50% 使用率を表します。 
              </p></li><li class="listitem"><p>
                <code class="literal">innodb_log_spin_cpu_pct_hwm</code>: フラッシュされた redo の待機中にユーザースレッドがスピンしなくなる CPU 使用率の最大量を定義します。 この値は、すべての CPU コアの合計処理能力の割合として表されます。 デフォルト値は 50% です。 たとえば、2 つの CPU コアの 100% 使用率は、4 つの CPU コアを持つサーバーでの CPU 処理能力の合計の 50% です。 
              </p><p>
                <code class="literal">innodb_log_spin_cpu_pct_hwm</code> 構成オプションは、プロセッサアフィニティを考慮します。 たとえば、サーバーに 48 個のコアがあり、<span class="command"><strong>mysqld</strong></span> プロセスが 4 個の CPU コアにのみ固定されている場合、他の 44 個の CPU コアは無視されます。 
              </p></li></ul></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-innodb-bulk-data-loading"></a>8.5.5 InnoDB テーブルの一括データロード</h3></div></div></div><a class="indexterm" name="idm45661477248288"></a><p>
        これらのパフォーマンスのヒントは、<a class="xref" href="optimization.html#insert-optimization" title="8.2.5.1 INSERT ステートメントの最適化">セクション8.2.5.1「INSERT ステートメントの最適化」</a>の高速挿入の一般的なガイドラインを補足するものです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">InnoDB</code> にデータをインポートする場合、自動コミットモードでは挿入のたびに、ディスクへのログのフラッシュを実行するため、それをオフにします。 インポート操作時に自動コミットを無効にするには、それを、<code class="literal">SET autocommit</code> ステートメントと <code class="literal">COMMIT</code> ステートメントで囲みます。 
          </p><pre class="programlisting">SET autocommit=0;
<em class="replaceable"><code>... SQL import statements ...</code></em>
COMMIT;
</pre><p>
            <span class="command"><strong>mysqldump</strong></span> オプション <code class="option">--opt</code> は、それらを <code class="literal">SET autocommit</code> ステートメントと <code class="literal">COMMIT</code> ステートメントで囲まなくても、<code class="literal">InnoDB</code> テーブルに高速にインポートするダンプファイルを作成します。
          </p></li><li class="listitem"><p>
            副キーに <code class="literal">UNIQUE</code> 制約がある場合、インポートセッション中に一意性チェックを一時的にオフにすることで、テーブルインポートを高速化できます。
          </p><pre class="programlisting">SET unique_checks=0;
<em class="replaceable"><code>... SQL import statements ...</code></em>
SET unique_checks=1;
</pre><p>
            大きなテーブルの場合、<code class="literal">InnoDB</code> はその変更バッファを使用してセカンダリインデックスレコードをバッチで書き込むことができるため、これによりディスク I/O が大量に節約されます。 データに重複キーが含まれていないことを確認してください。 
          </p></li><li class="listitem"><p>
            テーブルに <code class="literal">FOREIGN KEY</code> 制約がある場合、インポートセッションの間の外部キーチェックをオフにすることで、テーブルインポートを高速化できます。
          </p><pre class="programlisting">SET foreign_key_checks=0;
<em class="replaceable"><code>... SQL import statements ...</code></em>
SET foreign_key_checks=1;
</pre><p>
            大きいテーブルの場合、これにより、大量のディスク I/O を節約できます。
          </p></li><li class="listitem"><p>
            多くの行を挿入する必要がある場合、複数行 <code class="literal">INSERT</code> 構文を使用して、クライアントとサーバー間の通信オーバーヘッドを軽減します。
          </p><pre class="programlisting">INSERT INTO yourtable VALUES (1,2), (5,5), ...;
</pre><p>
            このヒントは、<code class="literal">InnoDB</code> テーブルだけではなく、任意のテーブルへの挿入に有効です。
          </p></li><li class="listitem"><p>
            自動増分カラムを含むテーブルに一括挿入を実行する場合は、<code class="literal">innodb_autoinc_lock_mode</code> を 1 (連続) ではなく 2 (インターリーブ) に設定します。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-handling" title="15.6.1.6 InnoDB での AUTO_INCREMENT 処理">セクション15.6.1.6「InnoDB での AUTO_INCREMENT 処理」</a> を参照してください。 
          </p></li><li class="listitem"><p>
            一括挿入を実行する場合は、<code class="literal">PRIMARY KEY</code> の順序で行を挿入する方が高速です。 <code class="literal">InnoDB</code> テーブルでは <a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">clustered index</a> が使用されるため、<code class="literal">PRIMARY KEY</code> の順序で比較的高速にデータを使用できます。 <code class="literal">PRIMARY KEY</code> 順序での一括挿入の実行は、バッファプール内に完全に収まらないテーブルで特に重要です。 
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> インデックスにデータをロードする場合の最高のパフォーマンスのため、次の一連のステップに従います。
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                テーブル作成時に、<code class="literal">FTS_DOC_ID_INDEX</code> という一意のインデックスで、型 <code class="literal">BIGINT UNSIGNED NOT NULL</code> のカラム <code class="literal">FTS_DOC_ID</code> を定義します。 例: 
              </p><pre class="programlisting">CREATE TABLE t1 (
FTS_DOC_ID BIGINT unsigned NOT NULL AUTO_INCREMENT,
title varchar(255) NOT NULL DEFAULT '',
text mediumtext NOT NULL,
PRIMARY KEY (`FTS_DOC_ID`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE UNIQUE INDEX FTS_DOC_ID_INDEX on t1(FTS_DOC_ID);
</pre></li><li class="listitem"><p>
                テーブルにデータをロードします。
              </p></li><li class="listitem"><p>
                データがロードされたら、<code class="literal">FULLTEXT</code> インデックスを作成します。
              </p></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              テーブル作成時に <code class="literal">FTS_DOC_ID</code> カラムを追加する場合、<code class="literal">FTS_DOC_ID</code> は各 <code class="literal">INSERT</code> または <code class="literal">UPDATE</code> によって単調に増分される必要があるため、<code class="literal">FULLTEXT</code> インデックス設定されたカラムが更新されたときに、<code class="literal">FTS_DOC_ID</code> カラムが更新されることを確認します。 テーブルの作成時に <code class="literal">FTS_DOC_ID</code> を追加せずに、<code class="literal">InnoDB</code> で DOC ID を管理する場合、<code class="literal">InnoDB</code> は、次の <code class="literal">CREATE FULLTEXT INDEX</code> コールで <code class="literal">FTS_DOC_ID</code> を非表示カラムとして追加します。 ただし、このアプローチでは、パフォーマンスに影響を与える可能性のあるテーブルの再構築が必要です。 
            </p></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-innodb-queries"></a>8.5.6 InnoDB クエリーの最適化</h3></div></div></div><p>
        <code class="literal">InnoDB</code> テーブルのクエリーをチューニングするには、各テーブルに適切なインデックスのセットを作成します。 詳細は、<a class="xref" href="optimization.html#mysql-indexes" title="8.3.1 MySQL のインデックスの使用の仕組み">セクション8.3.1「MySQL のインデックスの使用の仕組み」</a>を参照してください。 <code class="literal">InnoDB</code> インデックスに関する次のガイドラインに従います。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            各 <code class="literal">InnoDB</code> テーブルには<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a> がある (それをリクエストするかしないかに関係なく) ため、もっとも重要で緊急を要するクエリーで使用されるカラムとして、テーブルごとに主キーカラムのセットを指定します。
          </p></li><li class="listitem"><p>
            主キーのカラム値は各セカンダリインデックスに複製されるため、あまり多く、長すぎるカラムを指定しないでください。 インデックスに不要なデータが含まれていると、このデータを読み取る I/O とそれをキャッシュするメモリーによって、サーバーのパフォーマンスとスケーラビリティーが低下します。 
          </p></li><li class="listitem"><p>
            各クエリーで使用できるインデックスは 1 つだけであるため、カラムごとに個別の<a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">セカンダリインデックス</a>を作成しないでください。 ほんの少数の異なる値を持ち、めったにテストされないカラムへのインデックスは、どのクエリーにも役立たない可能性があります。 同じテーブルに対して多くのクエリーがあり、カラムのさまざまな組み合わせをテストする場合、多数の単一カラムインデックスよりも、少数の<a class="link" href="glossary.html#glos_concatenated_index" title="連結されたインデックス">連結されたインデックス</a>を作成してみてください。 インデックスに結果セットに必要なすべてのカラムが含まれている (<a class="link" href="glossary.html#glos_covering_index" title="カバリングインデックス">カバリングインデックス</a>と呼ばれます) 場合、クエリーはテーブルデータをまったく読み取らなくても済む可能性があります。 
          </p></li><li class="listitem"><p>
            インデックス設定されたカラムに <code class="literal">NULL</code> 値が含まれることがない場合は、テーブルの作成時に、それを <code class="literal">NOT NULL</code> として宣言します。 オプティマイザは、各カラムに <code class="literal">NULL</code> 値が含まれているかどうかがわかっている場合、クエリーに最も効果的なインデックスを判断できます。 
          </p></li><li class="listitem"><p>
            <a class="xref" href="optimization.html#innodb-performance-ro-txn" title="8.5.3 InnoDB の読み取り専用トランザクションの最適化">セクション8.5.3「InnoDB の読み取り専用トランザクションの最適化」</a> の手法を使用して、<code class="literal">InnoDB</code> テーブルの単一クエリートランザクションを最適化できます。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-innodb-ddl-operations"></a>8.5.7 InnoDB DDL 操作の最適化</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブルおよびインデックス (<code class="literal">CREATE</code>、<code class="literal">ALTER</code> および <code class="literal">DROP</code> ステートメント) に対する多くの DDL 操作は、オンラインで実行できます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl" title="15.12 InnoDB とオンライン DDL">セクション15.12「InnoDB とオンライン DDL」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            セカンダリインデックスを追加するためのオンライン DDL サポートとは、通常、セカンダリインデックスのないテーブルを作成してからデータのロード後にセカンダリインデックスを追加することで、テーブルおよび関連するインデックスの作成およびロードのプロセスを高速化できることを意味します。
          </p></li><li class="listitem"><p>
            テーブルを空にするには <code class="literal">DELETE FROM <em class="replaceable"><code>tbl_name</code></em></code> ではなく、<code class="literal">TRUNCATE TABLE</code> を使用します。 外部キー制約により、<code class="literal">TRUNCATE</code> ステートメントを通常の <code class="literal">DELETE</code> ステートメントのように動作させることができます。その場合、<code class="literal">DROP TABLE</code> や <code class="literal">CREATE TABLE</code> のようなコマンドのシーケンスがもっとも速くなる可能性があります。 
          </p></li><li class="listitem"><p>
            主キーは、各 <code class="literal">InnoDB</code> テーブルのストレージレイアウトに不可欠であり、主キーの定義の変更には、テーブル全体の再編成が必要であるため、常に主キーを <code class="literal">CREATE TABLE</code> ステートメントの一部としてセットアップし、あとで主キーを <code class="literal">ALTER</code> または <code class="literal">DROP</code> する必要がないように、事前に計画してください。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-innodb-diskio"></a>8.5.8 InnoDB ディスク I/O の最適化</h3></div></div></div><a class="indexterm" name="idm45661477150256"></a><a class="indexterm" name="idm45661477148128"></a><a class="indexterm" name="idm45661477146784"></a><a class="indexterm" name="idm45661477145440"></a><p>
        SQL 操作のためのデータベース設計およびチューニング方法のベストプラクティスに従っているが、ディスク I/O アクティビティが多いためにデータベースの速度がまだ遅い場合は、これらのディスク I/O 最適化を検討してください。 Unix <code class="filename">top</code> ツールまたは Windows タスクマネージャーに、ワークロードの CPU 使用率が 70% 未満であることが示されている場合、ワークロードはディスクに依存している可能性があります。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            バッファプールサイズの増加
          </p><p>
            テーブルデータが <code class="literal">InnoDB</code> バッファプールにキャッシュされると、ディスク I/O を必要とせずにクエリーによって繰り返しアクセスできます。 バッファープールサイズは、<code class="literal">innodb_buffer_pool_size</code> オプションで指定します。 このメモリー領域は、通常、<code class="literal">innodb_buffer_pool_size</code> を 50 から 75% のシステムメモリーに構成することをお薦めします。 詳細は、<a class="xref" href="optimization.html#memory-use" title="8.12.3.1 MySQL のメモリーの使用方法">セクション8.12.3.1「MySQL のメモリーの使用方法」</a> を参照してください。 
          </p></li><li class="listitem"><p>
            フラッシュ方法の調整
          </p><p>
            GNU/Linux および Unix の一部のバージョンでは、Unix <code class="literal">fsync()</code> 呼び出し (これは <code class="literal">InnoDB</code> がデフォルトで使用します) および類似のメソッドによるファイルのディスクへのフラッシュが驚くほど低速です。 データベースの書き込みパフォーマンスが問題である場合、<code class="literal">innodb_flush_method</code> パラメータを <code class="literal">O_DSYNC</code> に設定してベンチマークを実行します。 
          </p></li><li class="listitem"><p>
            fsync しきい値の構成
          </p><p>
            デフォルトでは、<code class="literal">InnoDB</code> が新しいログファイルやテーブルスペースファイルなどの新しいデータファイルを作成すると、ファイルはディスクにフラッシュされる前にオペレーティングシステムキャッシュに完全に書き込まれるため、大量のディスク書込みアクティビティが一度に発生する可能性があります。 オペレーティングシステムキャッシュから定期的にデータを強制的に小さいフラッシュするには、<code class="literal">innodb_fsync_threshold</code> 変数を使用してしきい値をバイト単位で定義します。 バイトしきい値に達すると、オペレーティングシステムキャッシュの内容がディスクにフラッシュされます。 デフォルト値の 0 では、デフォルトの動作が強制されます。つまり、ファイルがキャッシュに完全に書き込まれた後にのみ、データがディスクにフラッシュされます。 
          </p><p>
            複数の MySQL インスタンスが同じストレージデバイスを使用している場合は、より小さい定期的なフラッシュを強制的に実行するためのしきい値を指定すると有益です。 たとえば、新しい MySQL インスタンスとそれに関連付けられたデータファイルを作成すると、ディスク書込みアクティビティが大きくなり、同じストレージデバイスを使用する他の MySQL インスタンスのパフォーマンスが低下する可能性があります。 しきい値を構成すると、書込みアクティビティでのこのようなサージの回避に役立ちます。 
          </p></li><li class="listitem"><p>
            Linux でネイティブ AIO を使用した noop または deadline I/O スケジューラの使用
          </p><p>
            <code class="literal">InnoDB</code> は、Linux で非同期 I/O サブシステム (ネイティブ AIO) を使用して、データファイルページの先読みおよび書込みリクエストを実行します。 この動作は、デフォルトで有効になっている <code class="literal">innodb_use_native_aio</code> 構成オプションによって制御されます。 ネイティブ AIO では、I/O スケジューラのタイプが I/O のパフォーマンスに大きく影響します。 通常、noop および deadline I/O スケジューラをお薦めします。 ベンチマークを実行して、ワークロードおよび環境に最適な結果を提供する I/O スケジューラを決定します。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-linux-native-aio" title="15.8.6 Linux での非同期 I/O の使用">セクション15.8.6「Linux での非同期 I/O の使用」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            x86_64 アーキテクチャーに Solaris 10 上の直接 I/O を使用
          </p><p>
            Solaris 10 for x86_64 Architecture (AMD Opteron) で <code class="literal">InnoDB</code> ストレージエンジンを使用する場合は、<code class="literal">InnoDB</code> 関連ファイルに直接 I/O を使用して、<code class="literal">InnoDB</code> パフォーマンスの低下を回避します。 <code class="literal">InnoDB</code> 関連ファイルを格納するために使用される UFS ファイルシステム全体にダイレクト I/O を使用するには、それを <code class="literal">forcedirectio</code> オプションでマウントします。<code class="literal">mount_ufs(1M)</code> を参照してください。 (Solaris 10/x86_64 のデフォルトではこのオプションを使用<span class="emphasis"><em>しません</em></span>)。 ダイレクト I/O をファイルシステム全体ではなく、<code class="literal">InnoDB</code> ファイル操作にのみ適用するには、<code class="literal">innodb_flush_method = O_DIRECT</code> を設定します。 この設定では、<code class="literal">InnoDB</code> はデータファイルへの I/O (ログファイルへの I/O ではなく) に <code class="literal">fcntl()</code> ではなく、<code class="literal">directio()</code> を呼び出します。 
          </p></li><li class="listitem"><p>
            Solaris 2.6 以上でのデータおよびログファイルの RAW 記憶域の使用
          </p><p>
            任意のリリースの Solaris 2.6 および任意のプラットフォーム (sparc/x86/x64/amd64) で、<code class="literal">innodb_buffer_pool_size</code> 値が大きい <code class="literal">InnoDB</code> ストレージエンジンを使用する場合は、前に説明した <code class="literal">forcedirectio</code> マウントオプションを使用して、raw デバイスまたは別の直接 I/O UFS ファイルシステム上の <code class="literal">InnoDB</code> データファイルおよびログファイルでベンチマークを実行します。 (ログファイルのダイレクト I/O が必要な場合、<code class="literal">innodb_flush_method</code> を設定する代わりに、マウントオプションを使用する必要があります。) Veritas ファイルシステム VxFS のユーザーは、<code class="literal">convosync=direct</code> マウントオプションを使用してください。 
          </p><p>
            ダイレクト I/O ファイルシステムに、<code class="literal">MyISAM</code> テーブルのファイルなど、ほかの MySQL データファイルを配置しないでください。 実行ファイルやライブラリは、ディレクト I/O ファイルシステムに配置<span class="emphasis"><em>しないでください</em></span>。 
          </p></li><li class="listitem"><p>
            追加のストレージデバイスの使用
          </p><p>
            RAID 構成の設定には、追加のストレージデバイスを使用できます。 関連情報については、<a class="xref" href="optimization.html#disk-issues" title="8.12.1 ディスク I/O の最適化">セクション8.12.1「ディスク I/O の最適化」</a>を参照してください。 
          </p><p>
            または、<code class="literal">InnoDB</code> テーブルスペースデータファイルおよびログファイルを別の物理ディスクに配置できます。 詳細は、次のセクションを参照してください: 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <a class="xref" href="innodb-storage-engine.html#innodb-init-startup-configuration" title="15.8.1 InnoDB の起動構成">セクション15.8.1「InnoDB の起動構成」</a>
              </p></li><li class="listitem"><p>
                <a class="xref" href="innodb-storage-engine.html#innodb-create-table-external" title="15.6.1.2 外部でのテーブルの作成">セクション15.6.1.2「外部でのテーブルの作成」</a>
              </p></li><li class="listitem"><p>
                <a class="xref" href="innodb-storage-engine.html#general-tablespaces-creating" title="一般的なテーブルスペースの作成">一般的なテーブルスペースの作成</a>
              </p></li><li class="listitem"><p>
                <a class="xref" href="innodb-storage-engine.html#innodb-migration" title="15.6.1.4 InnoDB テーブルの移動またはコピー">セクション15.6.1.4「InnoDB テーブルの移動またはコピー」</a>
              </p></li></ul></div></li><li class="listitem"><p>
            非ローテーション記憶域の検討
          </p><p>
            通常、非ローテーション記憶域を使用すると、ランダムな I/O 操作の場合はパフォーマンスが向上し、順次 I/O 操作の場合はローテーション記憶域が向上します。 ローテーションストレージデバイスと非ローテーションストレージデバイスにデータファイルとログファイルを分散する場合は、主に各ファイルで実行される I/O 操作のタイプを考慮してください。 
          </p><p>
            ランダム I/O-oriented ファイルには、通常、<a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> および <a class="link" href="glossary.html#glos_general_tablespace" title="一般テーブルスペース">general tablespace</a> データファイル、<a class="link" href="glossary.html#glos_undo_tablespace" title="Undo テーブルスペース">undo tablespace</a> ファイルおよび <a class="link" href="glossary.html#glos_temporary_tablespace" title="一時テーブルスペース">temporary tablespace</a> ファイルが含まれます。 順次 I/O-oriented ファイルには、<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">system tablespace</a> ファイル (MySQL 8.0.20 および <a class="link" href="glossary.html#glos_change_buffer" title="変更バッファー">change buffering</a> より前の <a class="link" href="glossary.html#glos_doublewrite_buffer" title="二重書き込みバッファー">doublewrite buffering</a> のため)、MySQL 8.0.20 で導入された二重書き込みファイル、およびリンク <a class="link" href="glossary.html#glos_binary_log" title="バイナリログ">binary log</a> ファイルや <a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">redo log</a> ファイルなどのログファイルが含まれます。 
          </p><p>
            非ローテーション記憶域を使用する場合は、次の構成オプションの設定を確認します:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">innodb_checksum_algorithm</code>
              </p><p>
                <code class="literal">crc32</code> オプションでは、高速チェックサムアルゴリズムが使用されるため、高速ストレージシステムにお薦めします。
              </p></li><li class="listitem"><p>
                <code class="literal">innodb_flush_neighbors</code>
              </p><p>
                ローテーションストレージデバイス用に I/O を最適化します。 非ローテーション記憶域の場合、またはローテーション記憶域と非ローテーション記憶域の混在の場合は無効にします。 デフォルトでは無効になっています。 
              </p></li><li class="listitem"><p>
                <code class="literal">innodb_idle_flush_pct</code>
              </p><p>
                アイドル期間中のページフラッシュに制限を設定できます。これにより、非ローテーション型ストレージデバイスの存続期間を延長できます。 MySQL 8.0.18 で導入されました。 
              </p></li><li class="listitem"><p>
                <code class="literal">innodb_io_capacity</code>
              </p><p>
                一般に、デフォルト設定の 200 は、ローエンドの非ローテーション型ストレージデバイスには十分です。 高エンドのバス接続デバイスの場合は、1000 などの高い設定を検討してください。 
              </p></li><li class="listitem"><p>
                <code class="literal">innodb_io_capacity_max</code>
              </p><p>
                デフォルト値 2000 は、非ローテーション記憶域を使用するワークロードを対象としています。 ハイエンドのバス接続された非ローテーション型ストレージデバイスの場合は、2500 などの高い設定を検討してください。 
              </p></li><li class="listitem"><p>
                <code class="literal">innodb_log_compressed_pages</code>
              </p><p>
                redo ログが非ローテーション記憶域にある場合は、このオプションを無効にしてロギングを減らすことを検討してください。 <a class="link" href="optimization.html#innodb-disable-log-compressed-pages">Disable logging of compressed pages</a> を参照してください。 
              </p></li><li class="listitem"><p>
                <code class="literal">innodb_log_file_size</code>
              </p><p>
                redo ログが非繰返し記憶域にある場合は、このオプションを構成してキャッシュと書込みの組合せを最大化します。
              </p></li><li class="listitem"><p>
                <code class="literal">innodb_page_size</code>
              </p><p>
                ディスクの内部セクターサイズと一致するページサイズの使用を検討してください。 早期世代 SSD デバイスは、多くの場合、セクターサイズが 4KB です。 一部の新しいデバイスには、16K バイトのセクターサイズがあります。 デフォルトの <code class="literal">InnoDB</code> ページサイズは 16KB です。 ページサイズをストレージデバイスのブロックサイズに近づけると、ディスクに書き換えられる変更されていないデータの量が最小限に抑えられます。 
              </p></li><li class="listitem"><p>
                <code class="literal">binlog_row_image</code>
              </p><p>
                バイナリログが非ローテーションストレージ上にあり、すべてのテーブルに主キーがある場合は、ロギングを減らすためにこのオプションを <code class="literal">minimal</code> に設定することを検討してください。
              </p></li></ul></div><p>
            オペレーティングシステムで TRIM サポートが有効になっていることを確認します。 通常は、デフォルトで有効になっています。 
          </p></li><li class="listitem"><p>
            バックログを回避するための I/O 容量の増加
          </p><p>
            <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_checkpoint" title="チェックポイント">チェックポイント</a>操作のため、スループットが周期的に低下する場合、<code class="literal">innodb_io_capacity</code> 構成オプションの値を増加することを考慮します。 値を大きくすると、<a class="link" href="glossary.html#glos_flush" title="フラッシュ">フラッシュ</a>が頻繁になり、スループットを低下させる可能性のある作業のバックログが避けられます。 
          </p></li><li class="listitem"><p>
            フラッシュが遅れない場合の I/O 容量の削減
          </p><p>
            <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_flush" title="フラッシュ">フラッシュ</a>操作によって、システムが遅くならない場合は、<code class="literal">innodb_io_capacity</code> 構成オプションの値を小さくすることを考慮します。 一般に、このオプション値はできるかぎり小さくしますが、前の箇条書きで示したように、スループットに周期的な低下が発生するほど小さくしないでください。 オプション値を小さくすることができる一般的なシナリオでは、<code class="literal">SHOW ENGINE INNODB STATUS</code> からの出力に、次のような組み合わせが示されることがあります。 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                履歴リストの長さが短く、数千未満です。
              </p></li><li class="listitem"><p>
                挿入バッファーマージ数が挿入された行数に近いです。
              </p></li><li class="listitem"><p>
                バッファープール内の変更されたページが、一貫してバッファープールの <code class="literal">innodb_max_dirty_pages_pct</code> をはるかに下回っています。 (サーバーが一括挿入を実行していないときに測定します。変更されたページの一括挿入時に、パーセンテージが大幅に高くなるのは正常です。) 
              </p></li><li class="listitem"><p>
                <code class="literal">Log sequence number - Last checkpoint</code> が、<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_log_file" title="ログファイル">ログファイル</a>の合計サイズの 7/8 未満か、理想的には 6/8 未満です。
              </p></li></ul></div></li><li class="listitem"><p>
            Fusion-io デバイスへのシステムテーブルスペースファイルの格納
          </p><p>
            二重書込みバッファ関連の I/O 最適化を利用するには、二重書込み記憶域を含むファイルを、アトミック書込みをサポートする Fusion-io デバイスに格納します。 (MySQL 8.0.20 より前では、二重書込みバッファ記憶域はシステムテーブルスペースデータファイルに存在していました。 MySQL 8.0.20 では、記憶域は二重書込みファイルに存在します。 <a class="xref" href="innodb-storage-engine.html#innodb-doublewrite-buffer" title="15.6.4 二重書き込みバッファー">セクション15.6.4「二重書き込みバッファー」</a>を参照してください。) 二重書き込みストレージ領域ファイルがアトミック書き込みをサポートする Fusion-io デバイスに配置されると、二重書き込みバッファーは自動的に無効になり、Fusion-io アトミック書き込みがすべてのデータファイルに使用されます。 この機能は Fusion-io ハードウェアでのみサポートされ、Linux の Fusion-io NVMFS でのみ有効になります。 この機能を最大限に活用するには、<code class="literal">O_DIRECT</code> の <code class="literal">innodb_flush_method</code> 設定をお薦めします。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              二重書込みバッファ設定はグローバルであるため、Fusion-io ハードウェアに存在しないデータファイルの二重書込みバッファも無効になります。
            </p></div></li><li class="listitem"><p><a name="innodb-disable-log-compressed-pages"></a>
            圧縮されたページのロギングの無効化
          </p><p>
            <code class="literal">InnoDB</code> テーブルの <a class="link" href="glossary.html#glos_compression" title="圧縮">compression</a> 機能を使用する場合、圧縮されたデータが変更されると、再圧縮された <a class="link" href="glossary.html#glos_page" title="ページ">pages</a> のイメージが <a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">redo log</a> に書き込まれます。 この動作は <code class="literal">innodb_log_compressed_pages</code> によって制御され、リカバリ中に異なるバージョンの <code class="literal">zlib</code> 圧縮アルゴリズムが使用された場合に発生する可能性のある破損を防ぐためにデフォルトで有効になっています。 <code class="literal">zlib</code> のバージョンが変更されないことが確実な場合は、<code class="literal">innodb_log_compressed_pages</code> を無効にして、圧縮データを変更するワークロードの redo ログ生成を減らします。 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-innodb-configuration-variables"></a>8.5.9 InnoDB 構成変数の最適化</h3></div></div></div><p>
        軽量の予測可能な負荷のあるサーバーと、常時ほぼいっぱいの容量で実行していたり、高アクティビティーの急増が発生したりするサーバーとでは、もっとも適切に機能する設定が異なります。
      </p><p>
        <code class="literal">InnoDB</code> ストレージエンジンは、多くの最適化を自動的に実行するため、多くのパフォーマンスチューニングタスクには、データベースが適切に実行していることを確認するためのモニタリングと、パフォーマンスの低下時の構成オプションの変更が含まれます。 詳細な <code class="literal">InnoDB</code> のパフォーマンスモニタリングについては、<a class="xref" href="innodb-storage-engine.html#innodb-performance-schema" title="15.16 InnoDB の MySQL パフォーマンススキーマとの統合">セクション15.16「InnoDB の MySQL パフォーマンススキーマとの統合」</a>を参照してください。 
      </p><p>
        実行できる主な構成ステップは次のようになります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">InnoDB</code> が変更されたデータをバッファするデータ変更操作のタイプを制御して、小さいディスク書込みの頻度を回避します。 <a class="xref" href="innodb-storage-engine.html#innodb-change-buffer-configuration" title="変更バッファリングの構成">変更バッファリングの構成</a>を参照してください。 デフォルトでは、すべてのタイプのデータ変更操作をバッファするため、バッファリングの量を減らす必要がある場合にのみ、この設定を変更します。 
          </p></li><li class="listitem"><p>
            <code class="literal">innodb_adaptive_hash_index</code> オプションを使用して、アダプティブハッシュインデックス機能をオンまたはオフにします。 詳しくは<a class="xref" href="innodb-storage-engine.html#innodb-adaptive-hash" title="15.5.3 適応型ハッシュインデックス">セクション15.5.3「適応型ハッシュインデックス」</a>をご覧ください。 異常なアクティビティーの間にこの設定を変更し、その後、その元の設定にリストアできます。 
          </p></li><li class="listitem"><p>
            コンテキストスイッチングがボトルネックである場合に、<code class="literal">InnoDB</code> が処理する同時スレッドの数に制限を設定します。 <a class="xref" href="innodb-storage-engine.html#innodb-performance-thread_concurrency" title="15.8.4 InnoDB のスレッド並列性の構成">セクション15.8.4「InnoDB のスレッド並列性の構成」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> がその先読み操作で実行するプリフェッチの量を制御します。 システムに未使用の I/O 容量がある場合、先読みによってクエリーのパフォーマンスが向上することがあります。 先読みが多すぎると、負荷の大きいシステムで、パフォーマンスが周期的に低下する可能性があります。 <a class="xref" href="innodb-storage-engine.html#innodb-performance-read_ahead" title="15.8.3.4 InnoDB バッファープールのプリフェッチ (先読み) の構成">セクション15.8.3.4「InnoDB バッファープールのプリフェッチ (先読み) の構成」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            デフォルト値で十分に活用されていないハイエンド I/O サブシステムがある場合、読み取りまたは書き込み操作のバックグラウンドスレッドの数を増やします。 <a class="xref" href="innodb-storage-engine.html#innodb-performance-multiple_io_threads" title="15.8.5 InnoDB バックグラウンド I/O スレッドの数の構成">セクション15.8.5「InnoDB バックグラウンド I/O スレッドの数の構成」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            バックグラウンドで <code class="literal">InnoDB</code> が実行する I/O の量を制御します。 <a class="xref" href="innodb-storage-engine.html#innodb-configuring-io-capacity" title="15.8.7 InnoDB I/O Capacity の構成">セクション15.8.7「InnoDB I/O Capacity の構成」</a>を参照してください。 パフォーマンスが定期的に低下する場合は、この設定をスケールバックできます。 
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> が特定の種類のバックグラウンドの書き込みを実行するタイミングを判断するアルゴリズムを制御します。 <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-flushing" title="15.8.3.5 バッファープールのフラッシュの構成">セクション15.8.3.5「バッファープールのフラッシュの構成」</a>を参照してください。 このアルゴリズムは一部のタイプのワークロードでは機能しますが、他のワークロードでは機能しないため、パフォーマンスが定期的に低下することがある場合は、この機能を無効にできます。 
          </p></li><li class="listitem"><p>
            コンテキストスイッチングの遅延を最小にするため、マルチコアプロセッサとそれらのキャッシュメモリー構成を利用します。 <a class="xref" href="innodb-storage-engine.html#innodb-performance-spin_lock_polling" title="15.8.8 スピンロックのポーリングの構成">セクション15.8.8「スピンロックのポーリングの構成」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            テーブルスキャンなどの一度だけの操作が、<code class="literal">InnoDB</code> バッファーキャッシュに格納された頻繁にアクセスされるデータを妨げることを防ぎます。 <a class="xref" href="innodb-storage-engine.html#innodb-performance-midpoint_insertion" title="15.8.3.3 バッファープールをスキャンに耐えられるようにする">セクション15.8.3.3「バッファープールをスキャンに耐えられるようにする」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            信頼性とクラッシュリカバリに適切なサイズにログファイルを調整します。 <code class="literal">InnoDB</code> ログファイルは、多くの場合にクラッシュ後の長い起動時間を避けるため、小さく維持されてきました。 MySQL 5.5 で導入された最適化によって、クラッシュ<a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">リカバリ</a>プロセスの特定のステップが高速化します。 特に、<a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">Redo ログ</a>のスキャンと Redo ログの適用は、メモリー管理のアルゴリズムの改善のため、高速化します。 長い起動時間を避けるため、ログファイルを人為的に小さく維持していた場合、ログファイルサイズを拡大し、Redo ログレコードのリサイクルのために発生する I/O を削減することを考慮できるようになりました。 
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> バッファープールのインスタンスのサイズと数を構成します。特に数ギガバイトのバッファープールのあるシステムに重要です。 <a class="xref" href="innodb-storage-engine.html#innodb-multiple-buffer-pools" title="15.8.3.2 複数のバッファープールインスタンスの構成">セクション15.8.3.2「複数のバッファープールインスタンスの構成」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            同時トランザクションの最大数を増やします。これはきわめてビジーなデータベースのスケーラビリティーを劇的に向上します。 <a class="xref" href="innodb-storage-engine.html#innodb-undo-logs" title="15.6.6 undo ログ">セクション15.6.6「undo ログ」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            パージ操作 (ガベージコレクションの一種) をバックグラウンドスレッドに移動します。 <a class="xref" href="innodb-storage-engine.html#innodb-purge-configuration" title="15.8.9 パージ構成">セクション15.8.9「パージ構成」</a>を参照してください。 この設定の結果を効率的に測定するには、ほかの I/O 関連およびスレッド関連の構成設定を先にチューニングします。 
          </p></li><li class="listitem"><p>
            ビジーなサーバーで SQL 操作が列を成し、<span class="quote">「<span class="quote">渋滞</span>」</span>が発生しないように、<code class="literal">InnoDB</code> が同時スレッド間で実行するスイッチングの量を削減します。 <code class="literal">innodb_thread_concurrency</code> オプションの値を設定します (強力な最新のシステムで最大約 32)。 <code class="literal">innodb_concurrency_tickets</code> オプションの値を増やします (通常は 5000 など)。 このオプションの組合せにより、<code class="literal">InnoDB</code> が一度に処理するスレッド数の上限が設定され、スワップアウトする前に各スレッドがかなりの作業を実行できるため、待機中のスレッド数は少なくなり、過剰なコンテキスト切替えなしで操作を完了できます。 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-innodb-many-tables"></a>8.5.10 多くのテーブルのあるシステムに対する InnoDB の最適化</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="link" href="innodb-storage-engine.html#innodb-statistics-estimation" title="15.8.10.2 非永続的オプティマイザ統計のパラメータの構成">non-persistent optimizer statistics</a> (デフォルト以外の構成) を構成している場合、<code class="literal">InnoDB</code> では、起動後に初めてそのテーブルにアクセスしたときに、そのような値をテーブルに格納するのではなく、テーブルのインデックス <a class="link" href="glossary.html#glos_cardinality" title="カーディナリティー">cardinality</a> 値が計算されます。 データを多くのテーブルに分割しているシステムでは、このステップに大量の時間がかかることがあります。 このオーバーヘッドは最初のテーブルオープン操作にのみ適用されるため、テーブルをあとで使用するために<span class="quote">「<span class="quote">ウォームアップ</span>」</span>するには、<code class="literal">SELECT 1 FROM <em class="replaceable"><code>tbl_name</code></em> LIMIT 1</code> などのステートメントを発行して、起動後すぐにそれにアクセスします。 
          </p><p>
            オプティマイザ統計はデフォルトでディスクに永続化され、<code class="literal">innodb_stats_persistent</code> 構成オプションによって有効化されます。 永続的オプティマイザ統計については、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="15.8.10.1 永続的オプティマイザ統計のパラメータの構成">セクション15.8.10.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。 
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="optimizing-myisam"></a>8.6 MyISAM テーブルの最適化</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#optimizing-queries-myisam">8.6.1 MyISAM クエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-myisam-bulk-data-loading">8.6.2 MyISAM テーブルの一括データロード</a></span></dt><dt><span class="section"><a href="optimization.html#repair-table-optimization">8.6.3 REPAIR TABLE ステートメントの最適化</a></span></dt></dl></div><a class="indexterm" name="idm45661476950240"></a><p>
      <code class="literal">MyISAM</code> ストレージエンジンは、テーブルロックによって同時更新を実行する機能を制限するため、読み取りが大半のデータや並列性の低い操作で最適に実行します。 MySQL では、<code class="literal">InnoDB</code> は <code class="literal">MyISAM</code> ではなくデフォルトのストレージエンジンです。 
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-queries-myisam"></a>8.6.1 MyISAM クエリーの最適化</h3></div></div></div><p>
        <code class="literal">MyISAM</code> テーブルのクエリーを高速化するためのいくつかの一般的なヒント:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL がクエリーをより適切に最適化できるようにするには、テーブルにデータがロードされたあとに、それに対して <code class="literal">ANALYZE TABLE</code> を使用するか、または <span class="command"><strong>myisamchk --analyze</strong></span> を実行します。 これにより、同じ値がある平均行数を示す各インデックスパートの値を更新します。 (一意のインデックスの場合、これは常に 1 です。) MySQL はこれを使用して、非定数式に基づいて、2 つのテーブルを結合する際に選択するインデックスを決定します。 <code class="literal">SHOW INDEX FROM <em class="replaceable"><code>tbl_name</code></em></code> を使用し、<code class="literal">Cardinality</code> 値を調べることで、テーブル分析の結果を確認できます。<span class="command"><strong>myisamchk --description --verbose</strong></span> はインデックスの分布情報を示します。 
          </p></li><li class="listitem"><p>
            インデックスに従ってインデックスとデータをソートするには、<span class="command"><strong>myisamchk --sort-index --sort-records=1</strong></span> を使用します (インデックス 1 でソートすると仮定して)。 インデックスに従って順番にすべての行を読み取りたいと考える一意のインデックスがある場合、これはクエリーを高速にする適切な方法です。 この方法で大きなテーブルをはじめてソートするときは、長い時間がかかることがあります。 
          </p></li><li class="listitem"><p>
            頻繁に更新される <code class="literal">MyISAM</code> テーブルに対する複雑な <code class="literal">SELECT</code> クエリーを避け、リーダーとライターの競合のために発生するテーブルロックの問題を回避するようにしてください。
          </p></li><li class="listitem"><p>
            <code class="literal">MyISAM</code> は同時挿入をサポートしています。テーブルのデータファイルの途中に空きブロックがなければ、ほかのスレッドがテーブルから読み取るのと同時に新しい行をそれに <code class="literal">INSERT</code> できます。 これを実行できることが重要な場合、行の削除を避けるようにテーブルを使用することを考慮してください。 別の可能性は、テーブルの大量の行を削除したあとに <code class="literal">OPTIMIZE TABLE</code> を実行して、テーブルをデフラグすることです。 この動作は <code class="literal">concurrent_insert</code> 変数の設定によって変更されます。 行を削除したテーブルにも新しい行を強制的に追加 (したがって同時挿入を許可) できます。 <a class="xref" href="optimization.html#concurrent-inserts" title="8.11.3 同時挿入">セクション8.11.3「同時挿入」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            頻繁に変更される <code class="literal">MyISAM</code> テーブルでは、すべての可変長カラム (<code class="literal">VARCHAR</code>、<code class="literal">TEXT</code>、および <code class="literal">BLOB</code>) を避けるようにします。 テーブルに 1 つしか可変長カラムが含まれていない場合でも、テーブルは動的行フォーマットを使用します。 <a class="xref" href="storage-engines.html" title="第 16 章 代替ストレージエンジン">第16章「<i>代替ストレージエンジン</i>」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            一般に、行が大きくなるためだけに、1 つのテーブルを異なるテーブルに分割することは有益ではありません。 行へのアクセスで、もっとも大きくパフォーマンスに打撃を与えるものは、行の先頭バイトを見つけるために必要なディスクシークです。 データが見つかったあとは、ほとんどの最新のディスクで、大多数のアプリケーションに十分な速度で行全体を読み取ることができます。 テーブルを分割することがかなりの違いをもたらす状況は、固定の行サイズに変更できる動的行フォーマットを使用している <code class="literal">MyISAM</code> テーブルの場合か、またはテーブルを著しく頻繁にスキャンする必要があるが、ほとんどのカラムには必要でない場合だけです。 <a class="xref" href="storage-engines.html" title="第 16 章 代替ストレージエンジン">第16章「<i>代替ストレージエンジン</i>」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            通常 <code class="literal"><em class="replaceable"><code>expr1</code></em>、<em class="replaceable"><code>expr2</code></em>、...</code> の順で行を取得する場合は、<code class="literal">ALTER TABLE ... ORDER BY <em class="replaceable"><code>expr1</code></em>, <em class="replaceable"><code>expr2</code></em>, ...</code> を使用します。 テーブルを大幅に変更したあとにこのオプションを使用することで、パフォーマンスを向上できることがあります。 
          </p></li><li class="listitem"><p>
            多数の行の情報に基づいたカウントなど、結果を頻繁に計算する必要がある場合、新しいテーブルを導入し、リアルタイムでカウンタを更新する方が望ましいことがあります。 次のような形式の更新はきわめて高速です。 
          </p><pre class="programlisting">UPDATE <em class="replaceable"><code>tbl_name</code></em> SET <em class="replaceable"><code>count_col</code></em>=<em class="replaceable"><code>count_col</code></em>+1 WHERE <em class="replaceable"><code>key_col</code></em>=<em class="replaceable"><code>constant</code></em>;
</pre><p>
            これは、テーブルレベルのロック (単一ライターと複数リーダー) しかない <code class="literal">MyISAM</code> のような MySQL ストレージエンジンを使用する場合に、きわめて重要です。 また、この場合に行ロックマネージャーが実行する必要があることは少ないため、ほとんどのデータベースシステムでパフォーマンスが向上します。 
          </p></li><li class="listitem"><p>
            定期的に <code class="literal">OPTIMIZE TABLE</code> を使用して、動的フォーマット <code class="literal">MyISAM</code> テーブルの断片化を防ぎます。 <a class="xref" href="storage-engines.html#myisam-table-formats" title="16.2.3 MyISAM テーブルのストレージフォーマット">セクション16.2.3「MyISAM テーブルのストレージフォーマット」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">DELAY_KEY_WRITE=1</code> テーブルオプションを使用して <code class="literal">MyISAM</code> テーブルを宣言すると、テーブルが閉じられるまで、ディスクにフラッシュされないため、インデックスの更新が速くなります。 ダウンサイドは、そのようなテーブルが開いているときにサーバーを強制終了する場合、<code class="literal">myisam_recover_options</code> システム変数を設定してサーバーを実行するか、サーバーを再起動する前に <span class="command"><strong>myisamchk</strong></span> を実行して、テーブルが正常であることを確認する必要があることです。 (ただし、この場合でも、キー情報は常にデータ行から生成できるため、<code class="literal">DELAY_KEY_WRITE</code> を使用しても何も失われないはずです。) 
          </p></li><li class="listitem"><p>
            <code class="literal">MyISAM</code> インデックスでは、文字列の前後のスペースが自動的に圧縮されます。 <a class="xref" href="sql-statements.html#create-index" title="13.1.15 CREATE INDEX ステートメント">セクション13.1.15「CREATE INDEX ステートメント」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            アプリケーションでクエリーや応答をキャッシュしてから、多くの挿入や更新をまとめて実行することによって、パフォーマンスを向上できます。 この操作中にテーブルをロックすることで、すべての更新後にインデックスキャッシュが 1 回だけフラッシュされます。 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-myisam-bulk-data-loading"></a>8.6.2 MyISAM テーブルの一括データロード</h3></div></div></div><a class="indexterm" name="idm45661476888768"></a><p>
        これらのパフォーマンスのヒントは、<a class="xref" href="optimization.html#insert-optimization" title="8.2.5.1 INSERT ステートメントの最適化">セクション8.2.5.1「INSERT ステートメントの最適化」</a>の高速挿入の一般的なガイドラインを補足するものです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">MyISAM</code> テーブルでは、データファイルの途中に削除された行がない場合、<code class="literal">SELECT</code> ステートメントの実行中に同時に、同時挿入を使用して行を追加できます。 <a class="xref" href="optimization.html#concurrent-inserts" title="8.11.3 同時挿入">セクション8.11.3「同時挿入」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            一部の追加作業では、テーブルに多数のインデックスがある場合に、<code class="literal">MyISAM</code> テーブルに対して <code class="literal">LOAD DATA</code> をさらに高速に実行できます。 次の手順を使用します。 
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                <code class="literal">FLUSH TABLES</code> ステートメントまたは <span class="command"><strong>mysqladmin flush-tables</strong></span> コマンドを実行します。
              </p></li><li class="listitem"><p>
                テーブルのインデックスのすべての使用を削除するには、<span class="command"><strong>myisamchk --keys-used=0 -rq <em class="replaceable"><code>/path/to/db/tbl_name</code></em></strong></span> を使用します。
              </p></li><li class="listitem"><p>
                <code class="literal">LOAD DATA</code> を使用してテーブルにデータを挿入します。 これはインデックスを更新しないため、非常に高速です。 
              </p></li><li class="listitem"><p>
                今後、テーブルから読み取りだけをする場合は、<span class="command"><strong>myisampack</strong></span> を使用してそれを圧縮します。 <a class="xref" href="storage-engines.html#compressed-format" title="16.2.3.3 圧縮テーブルの特徴">セクション16.2.3.3「圧縮テーブルの特徴」</a>を参照してください。 
              </p></li><li class="listitem"><p>
                <span class="command"><strong>myisamchk -rq <em class="replaceable"><code>/path/to/db/tbl_name</code></em></strong></span> を使用してインデックスを再作成します。 これにより、ディスクに書き込む前にメモリーにインデックスツリーが作成されます。これは、多くのディスクシークが回避されるため、<code class="literal">LOAD DATA</code> 中にインデックスを更新するよりはるかに高速です。 結果のインデックスツリーは完全にバランスも取れています。 
              </p></li><li class="listitem"><p>
                <code class="literal">FLUSH TABLES</code> ステートメントまたは <span class="command"><strong>mysqladmin flush-tables</strong></span> コマンドを実行します。
              </p></li></ol></div><p>
            データを挿入する <code class="literal">MyISAM</code> テーブルが空の場合、<code class="literal">LOAD DATA</code> は前述の最適化を自動的に実行します。 自動最適化とプロシージャの明示的な使用の主な違いは、<code class="literal">LOAD DATA</code> ステートメントの実行時にサーバーがインデックスの再作成に割り当てることができるよりも多くの一時メモリーを <span class="command"><strong>myisamchk</strong></span> でインデックス作成に割り当てることができることです。 
          </p><p>
            <span class="command"><strong>myisamchk</strong></span> の代わりに次のステートメントを使用して、<code class="literal">MyISAM</code> テーブルの一意でないインデックスを無効または有効にすることもできます。 これらのステートメントを使用する場合は、<code class="literal">FLUSH TABLES</code> 操作をスキップできます: 
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DISABLE KEYS;
ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ENABLE KEYS;
</pre></li><li class="listitem"><p>
            非トランザクションテーブルに対して、複数ステートメントで実行される <code class="literal">INSERT</code> 操作を高速化するには、テーブルをロックします。
          </p><pre class="programlisting">LOCK TABLES a WRITE;
INSERT INTO a VALUES (1,23),(2,34),(4,33);
INSERT INTO a VALUES (8,26),(6,29);
...
UNLOCK TABLES;
</pre><p>
            これは、すべての <code class="literal">INSERT</code> ステートメントの完了後に、インデックスバッファーが 1 回だけディスクにフラッシュされるため、パフォーマンスにメリットがあります。 通常は、<code class="literal">INSERT</code> ステートメントの数と同じだけ、インデックスバッファーのフラッシュが行われます。 すべての行を 1 つの <code class="literal">INSERT</code> で挿入できる場合は、明示的なロックステートメントは必要ありません。 
          </p><p>
            ロックは複数接続テストの合計時間も短縮しますが、個々の接続がロックを待機するため、それらの最大待機時間は長くなることがあります。 次のように 5 台のクライアントが同時に挿入の実行を試みるとします。 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                接続 1 は 1000 回の挿入を実行します
              </p></li><li class="listitem"><p>
                接続 2、3、および 4 は 1 回の挿入を実行します
              </p></li><li class="listitem"><p>
                接続 5 は 1000 回の挿入を実行します
              </p></li></ul></div><p>
            ロックを使用しない場合、接続 2、3、および 4 は 1 と 5 の前に終了します。 ロックを使用した場合、接続 2、3、および 4 は 1 または 5 の前に終了しない可能性がありますが、合計時間は約 40% 高速化するはずです。 
          </p><p>
            MySQL では、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> 操作はきわめて高速ですが、約 5 回超の連続した挿入や更新を実行するすべての操作の周囲にロックを追加することによって、全体のパフォーマンスを向上できます。 著しく多くの連続した挿入を実行する場合、<code class="literal">LOCK TABLES</code> のあとにときどき (1,000 行程度ごとに) <code class="literal">UNLOCK TABLES</code> を実行して、ほかのスレッドのテーブルへのアクセスを許可できます。 これによってもパフォーマンスの向上が得られます。 
          </p><p>
            <code class="literal">INSERT</code> では、前述の戦略を使用している場合でも、データのロードは <code class="literal">LOAD DATA</code> よりもはるかに遅くなります。
          </p></li><li class="listitem"><p>
            <code class="literal">MyISAM</code> テーブルのパフォーマンスを向上させるには、<code class="literal">LOAD DATA</code> と <code class="literal">INSERT</code> の両方について、<code class="literal">key_buffer_size</code> システム変数を増やしてキーキャッシュを拡大します。 <a class="xref" href="server-administration.html#server-configuration" title="5.1.1 サーバーの構成">セクション5.1.1「サーバーの構成」</a>を参照してください。 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="repair-table-optimization"></a>8.6.3 REPAIR TABLE ステートメントの最適化</h3></div></div></div><a class="indexterm" name="idm45661476823520"></a><p>
        <code class="literal">MyISAM</code> テーブルの <code class="literal">REPAIR TABLE</code> は、修復操作に <span class="command"><strong>myisamchk</strong></span> を使用することと似ており、同じパフォーマンス最適化の一部が適用されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="command"><strong>myisamchk</strong></span> にはメモリー割り当てを制御する変数があります。 <a class="xref" href="programs.html#myisamchk-memory" title="4.6.4.6 myisamchk メモリー使用量">セクション4.6.4.6「myisamchk メモリー使用量」</a>に説明するように、これらの変数を設定してパフォーマンスを向上できることがあります。 
          </p></li><li class="listitem"><p>
            <code class="literal">REPAIR TABLE</code> では、同じ原則が適用されますが、修復はサーバーによって実行されるため、<span class="command"><strong>myisamchk</strong></span> 変数の代わりに、サーバーシステム変数を設定します。 また、メモリー割り当て変数の設定に加えて、<code class="literal">myisam_max_sort_file_size</code> システム変数を増やすと、修復でより高速な filesort 方式が使用される可能性が高くなり、キーキャッシュ方式によるより遅い修復が回避されます。 テーブルファイルのコピーを保持できるだけの十分な空き領域があることを確認したら、システムの最大ファイルサイズに変数を設定します。 元のテーブルファイルを格納しているファイルシステムで、空き領域が使用できる必要があります。 
          </p></li></ul></div><p>
        次のオプションを使用して、そのメモリー割り当て変数を設定して、<span class="command"><strong>myisamchk</strong></span> テーブル修復操作が実行されたとします。
      </p><pre class="programlisting">--key_buffer_size=128M --myisam_sort_buffer_size=256M
--read_buffer_size=64M --write_buffer_size=64M
</pre><p>
        それらの <span class="command"><strong>myisamchk</strong></span> 変数の一部はサーバーシステム変数に対応します。
      </p><div class="informaltable"><table summary="myisamchk variables and corresponding server system variables."><col style="width: 50%"><col style="width: 50%"><thead><tr>
            <th><span class="command"><strong>myisamchk</strong></span> 変数</th>
            <th>システム変数</th>
          </tr></thead><tbody><tr>
            <td><code class="literal">key_buffer_size</code></td>
            <td><code class="literal">key_buffer_size</code></td>
          </tr><tr>
            <td><code class="literal">myisam_sort_buffer_size</code></td>
            <td><code class="literal">myisam_sort_buffer_size</code></td>
          </tr><tr>
            <td><code class="literal">read_buffer_size</code></td>
            <td><code class="literal">read_buffer_size</code></td>
          </tr><tr>
            <td><code class="literal">write_buffer_size</code></td>
            <td>none</td>
          </tr></tbody></table></div><p>
        各サーバーシステム変数は実行時に設定でき、それらの一部 (<code class="literal">myisam_sort_buffer_size</code>、<code class="literal">read_buffer_size</code>) にはグローバル値に加えてセッション値もあります。 セッション値を設定することで、現在のセッションへの変更の影響を制限し、ほかのユーザーに影響しません。 グローバルのみの変数 (<code class="literal">key_buffer_size</code>、<code class="literal">myisam_max_sort_file_size</code>) を変更すると、ほかのユーザーにも影響します。 <code class="literal">key_buffer_size</code> の場合、バッファーがそれらのユーザーと共有されることを考慮しておく必要があります。 たとえば、<span class="command"><strong>myisamchk</strong></span> <code class="literal">key_buffer_size</code> 変数を 128M バイトに設定した場合、対応する <code class="literal">key_buffer_size</code> システム変数をそれより大きく設定し (それがすでに大きく設定されていない場合)、ほかのセッションのアクティビティーによるキーバッファーの使用を許可できます。 ただし、グローバルキーバッファーサイズを変更すると、バッファーが無効になり、ディスク I/O が増加して、ほかのセッションが遅くなります。 この問題を回避する代替策は、個別のキーキャッシュを使用し、それを修復対象のテーブルのインデックスに割り当て、修復が完了したら、その割り当てを解除することです。 <a class="xref" href="optimization.html#multiple-key-caches" title="8.10.2.2 複合キーキャッシュ">セクション8.10.2.2「複合キーキャッシュ」</a>を参照してください。 
      </p><p>
        先述の説明に基づいて、<code class="literal">REPAIR TABLE</code> 操作は、次のように実行して、<span class="command"><strong>myisamchk</strong></span> コマンドに似た設定を使用できます。 ここでは、個別の 128M バイトのキーバッファーが割り当てられ、ファイルシステムは 100G バイト以上のファイルサイズを許可するものとします。 
      </p><pre class="programlisting">SET SESSION myisam_sort_buffer_size = 256*1024*1024;
SET SESSION read_buffer_size = 64*1024*1024;
SET GLOBAL myisam_max_sort_file_size = 100*1024*1024*1024;
SET GLOBAL repair_cache.key_buffer_size = 128*1024*1024;
CACHE INDEX <em class="replaceable"><code>tbl_name</code></em> IN repair_cache;
LOAD INDEX INTO CACHE <em class="replaceable"><code>tbl_name</code></em>;
REPAIR TABLE <em class="replaceable"><code>tbl_name</code></em> ;
SET GLOBAL repair_cache.key_buffer_size = 0;
</pre><p>
        グローバル変数を変更するが、ほかのユーザーへの影響を最小にするため、<code class="literal">REPAIR TABLE</code> 操作の間にのみ実行するようにしたい場合、その値をユーザー変数に保存して、あとでそれをリストアします。 例: 
      </p><pre class="programlisting">SET @old_myisam_sort_buffer_size = @@GLOBAL.myisam_max_sort_file_size;
SET GLOBAL myisam_max_sort_file_size = 100*1024*1024*1024;
REPAIR TABLE tbl_name ;
SET GLOBAL myisam_max_sort_file_size = @old_myisam_max_sort_file_size;
</pre><p>
        <code class="literal">REPAIR TABLE</code> に影響するシステム変数は、変数をデフォルトで有効にしたい場合、サーバーの起動時にグローバルに設定できます。 たとえば、次の行をサーバーの <code class="filename">my.cnf</code> ファイルに追加します。 
      </p><pre class="programlisting">[mysqld]
myisam_sort_buffer_size=256M
key_buffer_size=1G
myisam_max_sort_file_size=100G
</pre><p>
        これらの設定には <code class="literal">read_buffer_size</code> は含まれません。 <code class="literal">read_buffer_size</code> をグローバルに大きな値に設定すると、すべてのセッションに対してそれが実行され、多くの同時セッションのあるサーバーに過剰なメモリーが割り当てられるため、パフォーマンスが低下する可能性があります。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="optimizing-memory-tables"></a>8.7 MEMORY テーブルの最適化</h2></div></div></div><a class="indexterm" name="idm45661476761760"></a><p>
      頻繁にアクセスされ、読み取り専用かめったに更新されない非クリティカルデータに <code class="literal">MEMORY</code> テーブルを使用することを考慮します。 現実的なワークロードで、同等の <code class="literal">InnoDB</code> または <code class="literal">MyISAM</code> テーブルに対してアプリケーションのベンチマークを実行し、追加のパフォーマンスが、データの損失のリスクやアプリケーションの起動時にディスクベースのテーブルからデータをコピーすることのオーバーヘッドに値するかを確認します。 
    </p><p>
      <code class="literal">MEMORY</code> テーブルで最高のパフォーマンスを得るには、各テーブルに対するクエリーの種類を調査し、関連付けられた各インデックスに使用する B ツリーインデックスまたはハッシュインデックスのいずれかの種類を指定します。 <code class="literal">CREATE INDEX</code> ステートメントで、句 <code class="literal">USING BTREE</code> または <code class="literal">USING HASH</code> を使用します。 B ツリーインデックスは、<code class="literal">&gt;</code> や <code class="literal">BETWEEN</code> などの操作によって、greater-than または less-than の比較を実行するクエリーで高速です。 ハッシュインデックスは、<code class="literal">=</code> 演算子によって単一の値、または <code class="literal">IN</code> 演算子によって制限された値のセットをルックアップするクエリーでのみ高速です。 <code class="literal">USING BTREE</code> が多くの場合にデフォルトの <code class="literal">USING HASH</code> より適切な選択である理由については、<a class="xref" href="optimization.html#table-scan-avoidance" title="8.2.1.23 全テーブルスキャンの回避">セクション8.2.1.23「全テーブルスキャンの回避」</a>を参照してください。 さまざまな種類の <code class="literal">MEMORY</code> インデックスの実装の詳細については、<a class="xref" href="optimization.html#index-btree-hash" title="8.3.9 B ツリーインデックスとハッシュインデックスの比較">セクション8.3.9「B ツリーインデックスとハッシュインデックスの比較」</a>を参照してください。 
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="execution-plan-information"></a>8.8 クエリー実行プランの理解</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#using-explain">8.8.1 EXPLAIN によるクエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#explain-output">8.8.2 EXPLAIN 出力フォーマット</a></span></dt><dt><span class="section"><a href="optimization.html#explain-extended">8.8.3 拡張 EXPLAIN 出力形式</a></span></dt><dt><span class="section"><a href="optimization.html#explain-for-connection">8.8.4 名前付き接続の実行計画情報の取得</a></span></dt><dt><span class="section"><a href="optimization.html#estimating-performance">8.8.5 クエリーパフォーマンスの推定</a></span></dt></dl></div><p>
      <code class="literal">WHERE</code> 句内のテーブル、カラム、インデックス、および条件の詳細に応じて、MySQL オプティマイザは SQL クエリーに含まれるルックアップを効率的に実行するための多くの技法を考慮します。 巨大なテーブルに対するクエリーは、すべての行を読み取らなくても実行でき、複数のテーブルを含む結合は、行のすべての組み合わせを比較しなくても実行できます。 オプティマイザがもっとも効率的なクエリーを実行するために選択する操作のセットは、<span class="quote">「<span class="quote">クエリー実行プラン</span>」</span>と呼ばれ、<code class="literal">EXPLAIN</code> プランとも呼ばれます。 目的は、クエリーが適切に最適化されていることを示す <code class="literal">EXPLAIN</code> プランの側面を認識し、非効率的な操作が見られた場合に、プランを改善するための SQL 構文とインデックス設定技法を学ぶことです。 
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="using-explain"></a>8.8.1 EXPLAIN によるクエリーの最適化</h3></div></div></div><a class="indexterm" name="idm45661476737504"></a><a class="indexterm" name="idm45661476736192"></a><p>
        <code class="literal">EXPLAIN</code> ステートメントは、MySQL がステートメントをどのように実行するかに関する情報を提供します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">EXPLAIN</code> は、<code class="literal">SELECT</code>, <code class="literal">DELETE</code>, <code class="literal">INSERT</code>, <code class="literal">REPLACE</code> および <code class="literal">UPDATE</code> ステートメントで動作します。
          </p></li><li class="listitem"><p>
            説明可能なステートメントで <code class="literal">EXPLAIN</code> を使用すると、MySQL は、オプティマイザからのステートメント実行プランに関する情報を表示します。 つまり、MySQL はテーブルがどのように、どんな順番で結合されているかに関する情報を含む、ステートメントを処理する方法を説明します。 <code class="literal">EXPLAIN</code> を使用して、実行プラン情報を取得することについては、<a class="xref" href="optimization.html#explain-output" title="8.8.2 EXPLAIN 出力フォーマット">セクション8.8.2「EXPLAIN 出力フォーマット」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">EXPLAIN</code> を説明可能なステートメントではなく <code class="literal">FOR CONNECTION <em class="replaceable"><code>connection_id</code></em></code> とともに使用すると、名前付き接続で実行されているステートメントの実行計画が表示されます。 <a class="xref" href="optimization.html#explain-for-connection" title="8.8.4 名前付き接続の実行計画情報の取得">セクション8.8.4「名前付き接続の実行計画情報の取得」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">SELECT</code> ステートメントの場合、<code class="literal">EXPLAIN</code> は、<code class="literal">SHOW WARNINGS</code> を使用して表示できる追加の実行計画情報を生成します。 <a class="xref" href="optimization.html#explain-extended" title="8.8.3 拡張 EXPLAIN 出力形式">セクション8.8.3「拡張 EXPLAIN 出力形式」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">EXPLAIN</code> は、パーティションテーブルを含むクエリーの調査に役立ちます。 <a class="xref" href="partitioning.html#partitioning-info" title="24.3.5 パーティションに関する情報を取得する">セクション24.3.5「パーティションに関する情報を取得する」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">FORMAT</code> オプションを使用して、出力形式を選択できます。 <code class="literal">TRADITIONAL</code> は表形式で出力を表示します。 <code class="literal">FORMAT</code> オプションが存在しない場合、これはデフォルトです。 <code class="literal">JSON</code> フォーマットは JSON フォーマットで情報を表示します。 
          </p></li></ul></div><p>
        <a class="indexterm" name="idm45661476704432"></a> <code class="literal">EXPLAIN</code> によって、インデックスを使用して行を見つけることで、ステートメントが高速に実行されるように、テーブルにインデックスを追加するべき場所がわかります。 また、<code class="literal">EXPLAIN</code> を使用して、オプティマイザがテーブルを最適な順序で結合しているかどうかを確認することもできます。 <code class="literal">SELECT</code> ステートメントでテーブルが指定されている順序に対応する結合順序を使用するように、オプティマイザにヒントを提供するには、ステートメントを <code class="literal">SELECT</code> だけでなく、<code class="literal">SELECT STRAIGHT_JOIN</code> で始めます。 (<a class="xref" href="sql-statements.html#select" title="13.2.10 SELECT ステートメント">セクション13.2.10「SELECT ステートメント」</a>を参照してください。) ただし、準結合変換が無効になっているため、<code class="literal">STRAIGHT_JOIN</code> ではインデックスが使用されない場合があります。 <a class="xref" href="optimization.html#semijoins" title="8.2.2.1 準結合変換による IN および EXISTS サブクエリー述語の最適化">セクション8.2.2.1「準結合変換による IN および EXISTS サブクエリー述語の最適化」</a>を参照してください。 
      </p><p>
        オプティマイザトレースは、<code class="literal">EXPLAIN</code> のトレースを補完する情報を提供する場合があります。 ただし、オプティマイザのトレース形式と内容はバージョン間で変更される可能性があります。 詳細については、「<a class="ulink" href="https://dev.mysql.com/doc/internals/en/optimizer-tracing.html" target="_top">MySQL Internals: Tracing the Optimizer</a>」を参照してください。 
      </p><p>
        インデックスが使われるはずであると思うタイミングでそれらが使われていない問題がある場合、<code class="literal">ANALYZE TABLE</code> を実行して、オプティマイザが行う選択に影響する可能性があるキーのカーディナリティーなどのテーブル統計を更新します。 <a class="xref" href="sql-statements.html#analyze-table" title="13.7.3.1 ANALYZE TABLE ステートメント">セクション13.7.3.1「ANALYZE TABLE ステートメント」</a>を参照してください。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">EXPLAIN</code> はテーブル内のカラムに関する情報を取得するためにも使用できます。 <code class="literal">EXPLAIN <em class="replaceable"><code>tbl_name</code></em></code> は <code class="literal">DESCRIBE <em class="replaceable"><code>tbl_name</code></em></code> および <code class="literal">SHOW COLUMNS FROM <em class="replaceable"><code>tbl_name</code></em></code> と同義です。 詳細については、<a class="xref" href="sql-statements.html#describe" title="13.8.1 DESCRIBE ステートメント">セクション13.8.1「DESCRIBE ステートメント」</a>および<a class="xref" href="sql-statements.html#show-columns" title="13.7.7.5 SHOW COLUMNS ステートメント">セクション13.7.7.5「SHOW COLUMNS ステートメント」</a>を参照してください。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="explain-output"></a>8.8.2 EXPLAIN 出力フォーマット</h3></div></div></div><p>
        <code class="literal">EXPLAIN</code> ステートメントは、MySQL がステートメントを実行する方法に関する情報を提供します。 <code class="literal">EXPLAIN</code> は、<code class="literal">SELECT</code>, <code class="literal">DELETE</code>, <code class="literal">INSERT</code>, <code class="literal">REPLACE</code> および <code class="literal">UPDATE</code> ステートメントで動作します。 
      </p><p>
        <code class="literal">EXPLAIN</code> は <code class="literal">SELECT</code> ステートメントで使用される各テーブルに関する情報の行を返します。 これは、MySQL がステートメントの処理中にテーブルを読み取る順番で、出力にテーブルを一覧表示します。 これは、MySQL が最初のテーブルから行を読み取り、次に 2 番目のテーブル、3 番目のテーブルなどで一致する行を検索することを意味します。 すべてのテーブルが処理されると、MySQL は選択したカラムを出力し、さらに一致する行があるテーブルが見つかるまで、テーブルリストを逆戻りします。 次の行がテーブルから読み取られ、プロセスは次のテーブルに進みます。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL Workbench には、<code class="literal">EXPLAIN</code> 出力を視覚的に表現する Visual Explain 機能があります。 <a class="ulink" href="https://dev.mysql.com/doc/workbench/en/wb-tutorial-visual-explain-dbt3.html" target="_top">Tutorial: Using Explain to Improve Query Performance</a>を参照してください。 
        </p></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#explain-output-columns" title="EXPLAIN 出力カラム">EXPLAIN 出力カラム</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#explain-join-types" title="EXPLAIN 結合型">EXPLAIN 結合型</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#explain-extra-information" title="EXPLAIN 追加情報">EXPLAIN 追加情報</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#explain-output-interpretation" title="EXPLAIN 出力の解釈">EXPLAIN 出力の解釈</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="explain-output-columns"></a>EXPLAIN 出力カラム</h4></div></div></div><p>
          このセクションでは、<code class="literal">EXPLAIN</code> によって生成される出力カラムについて説明します。 あとのセクションで、<a class="link" href="optimization.html#explain-join-types" title="EXPLAIN 結合型"><code class="literal">type</code></a> と <a class="link" href="optimization.html#explain-extra-information" title="EXPLAIN 追加情報"><code class="literal">Extra</code></a> カラムに関する追加情報を提供します。 
        </p><p>
          <code class="literal">EXPLAIN</code> からの各出力行は 1 つのテーブルに関する情報を提供します。 各行には、<a class="xref" href="optimization.html#explain-output-column-table" title="表 8.1 EXPLAIN 出力カラム">表8.1「EXPLAIN 出力カラム」</a>で要約し、次の表に詳しく説明している値が格納されます。 テーブルの最初のカラムにはカラム名が表示されます。2 番目のカラムには、<code class="literal">FORMAT=JSON</code> を使用した場合の出力に表示される同等のプロパティ名が示されます。 
        </p><div class="table"><a name="explain-output-column-table"></a><p class="title"><b>表 8.1 EXPLAIN 出力カラム</b></p><div class="table-contents"><table summary="Output columns produced by the EXPLAIN statement."><col style="width: 25%"><col style="width: 25%"><col style="width: 50%"><thead><tr>
              <th scope="col">カラム</th>
              <th scope="col">JSON 名</th>
              <th scope="col">意味</th>
            </tr></thead><tbody><tr>
              <th scope="row"><a class="link" href="optimization.html#explain_id"><code class="literal">id</code></a></th>
              <td><code class="literal">select_id</code></td>
              <td><code class="literal">SELECT</code> 識別子。</td>
            </tr><tr>
              <th scope="row"><a class="link" href="optimization.html#explain_select_type"><code class="literal">select_type</code></a></th>
              <td>なし</td>
              <td><code class="literal">SELECT</code> 型</td>
            </tr><tr>
              <th scope="row"><a class="link" href="optimization.html#explain_table"><code class="literal">table</code></a></th>
              <td><code class="literal">table_name</code></td>
              <td>出力行のテーブル</td>
            </tr><tr>
              <th scope="row"><a class="link" href="optimization.html#explain_partitions"><code class="literal">partitions</code></a></th>
              <td><code class="literal">partitions</code></td>
              <td>一致するパーティション</td>
            </tr><tr>
              <th scope="row"><a class="link" href="optimization.html#explain_type"><code class="literal">type</code></a></th>
              <td><code class="literal">access_type</code></td>
              <td>結合型</td>
            </tr><tr>
              <th scope="row"><a class="link" href="optimization.html#explain_possible_keys"><code class="literal">possible_keys</code></a></th>
              <td><code class="literal">possible_keys</code></td>
              <td>選択可能なインデックス</td>
            </tr><tr>
              <th scope="row"><a class="link" href="optimization.html#explain_key"><code class="literal">key</code></a></th>
              <td><code class="literal">key</code></td>
              <td>実際に選択されたインデックス</td>
            </tr><tr>
              <th scope="row"><a class="link" href="optimization.html#explain_key_len"><code class="literal">key_len</code></a></th>
              <td><code class="literal">key_length</code></td>
              <td>選択されたキーの長さ</td>
            </tr><tr>
              <th scope="row"><a class="link" href="optimization.html#explain_ref"><code class="literal">ref</code></a></th>
              <td><code class="literal">ref</code></td>
              <td>インデックスと比較されるカラム</td>
            </tr><tr>
              <th scope="row"><a class="link" href="optimization.html#explain_rows"><code class="literal">rows</code></a></th>
              <td><code class="literal">rows</code></td>
              <td>調査される行の見積もり</td>
            </tr><tr>
              <th scope="row"><a class="link" href="optimization.html#explain_filtered"><code class="literal">filtered</code></a></th>
              <td><code class="literal">filtered</code></td>
              <td>テーブル条件によってフィルタ処理される行の割合</td>
            </tr><tr>
              <th scope="row"><a class="link" href="optimization.html#explain_extra"><code class="literal">Extra</code></a></th>
              <td>なし</td>
              <td>追加情報</td>
            </tr></tbody></table></div></div><br class="table-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">NULL</code> である JSON プロパティは、JSON 形式の <code class="literal">EXPLAIN</code> 出力には表示されません。
          </p></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="explain_id"></a>
              <code class="literal">id</code> (JSON 名): <code class="literal">select_id</code> )
            </p><p>
              <code class="literal">SELECT</code> 識別子。 これはクエリー内の <code class="literal">SELECT</code> の連番です。 行がほかの行の和集合結果を参照する場合に、値は <code class="literal">NULL</code> になることがあります。 この場合、<code class="literal">table</code> カラムには、<code class="literal">&lt;union<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>N</code></em>&gt;</code> などの値が表示され、行が <em class="replaceable"><code>M</code></em> および <em class="replaceable"><code>N</code></em> の <code class="literal">id</code> 値のある行の和集合を参照していることが示されます。 
            </p></li><li class="listitem"><p><a name="explain_select_type"></a>
              <code class="literal">select_type</code> (JSON 名): none)
            </p><p>
              <code class="literal">SELECT</code> の種類で、次の表に示すもののいずれかになります。 JSON 形式の <code class="literal">EXPLAIN</code> は、<code class="literal">SIMPLE</code> または <code class="literal">PRIMARY</code> でないかぎり、<code class="literal">SELECT</code> タイプを <code class="literal">query_block</code> のプロパティとして公開します。 JSON 名 (該当する場合) もテーブルに示されます。 
            </p><div class="informaltable"><table summary="select_type values and the meaning of each value."><col style="width: 25%"><col style="width: 25%"><col style="width: 50%"><thead><tr>
                  <th scope="col"><code class="literal">select_type</code> 値</th>
                  <th scope="col">JSON 名</th>
                  <th scope="col">意味</th>
                </tr></thead><tbody><tr>
                  <th scope="row"><code class="literal">SIMPLE</code></th>
                  <td>なし</td>
                  <td>単純な <code class="literal">SELECT</code> (<code class="literal">UNION</code> やサブクエリーを使用しません)</td>
                </tr><tr>
                  <th scope="row"><code class="literal">PRIMARY</code></th>
                  <td>なし</td>
                  <td>もっとも外側の <code class="literal">SELECT</code></td>
                </tr><tr>
                  <th scope="row"><code class="literal">UNION</code></th>
                  <td>なし</td>
                  <td><code class="literal">UNION</code> 内の 2 つめ以降の <code class="literal">SELECT</code> ステートメント</td>
                </tr><tr>
                  <th scope="row"><code class="literal">DEPENDENT UNION</code></th>
                  <td><code class="literal">dependent</code> (<code class="literal">true</code>)</td>
                  <td><code class="literal">UNION</code> 内の 2 つめ以降の <code class="literal">SELECT</code> ステートメントで、外側のクエリーに依存します</td>
                </tr><tr>
                  <th scope="row"><code class="literal">UNION RESULT</code></th>
                  <td><code class="literal">union_result</code></td>
                  <td><code class="literal">UNION</code> の結果。</td>
                </tr><tr>
                  <th scope="row"><code class="literal">SUBQUERY</code></th>
                  <td>なし</td>
                  <td>サブクエリー内の最初の <code class="literal">SELECT</code></td>
                </tr><tr>
                  <th scope="row"><code class="literal">DEPENDENT SUBQUERY</code></th>
                  <td><code class="literal">dependent</code> (<code class="literal">true</code>)</td>
                  <td>サブクエリー内の最初の <code class="literal">SELECT</code> で、外側のクエリーに依存します</td>
                </tr><tr>
                  <th scope="row"><code class="literal">DERIVED</code></th>
                  <td>なし</td>
                  <td>導出テーブル</td>
                </tr><tr>
                  <th scope="row"><code class="literal">DEPENDENT DERIVED</code></th>
                  <td><code class="literal">dependent</code> (<code class="literal">true</code>)</td>
                  <td>別のテーブルに依存する導出テーブル</td>
                </tr><tr>
                  <th scope="row"><code class="literal">MATERIALIZED</code></th>
                  <td><code class="literal">materialized_from_subquery</code></td>
                  <td>実体化されたサブクエリー</td>
                </tr><tr>
                  <th scope="row"><code class="literal">UNCACHEABLE SUBQUERY</code></th>
                  <td><code class="literal">cacheable</code> (<code class="literal">false</code>)</td>
                  <td>結果をキャッシュできず、外側のクエリーの行ごとに再評価される必要があるサブクエリー</td>
                </tr><tr>
                  <th scope="row"><code class="literal">UNCACHEABLE UNION</code></th>
                  <td><code class="literal">cacheable</code> (<code class="literal">false</code>)</td>
                  <td>キャッシュ不可能なサブクエリー (<code class="literal">UNCACHEABLE SUBQUERY</code> を参照してください) に属する <code class="literal">UNION</code> 内の 2 つめ以降の SELECT</td>
                </tr></tbody></table></div><p>
              <code class="literal">DEPENDENT</code> は一般に、相関サブクエリーの使用を示します。 <a class="xref" href="sql-statements.html#correlated-subqueries" title="13.2.11.7 相関サブクエリー">セクション13.2.11.7「相関サブクエリー」</a>を参照してください。 
            </p><p>
              <code class="literal">DEPENDENT SUBQUERY</code> の評価は <code class="literal">UNCACHEABLE SUBQUERY</code> の評価とは異なります。 <code class="literal">DEPENDENT SUBQUERY</code> の場合、その外部コンテキストの変数の異なる値の各セットにつき、一回だけサブクエリーが再評価されます。 <code class="literal">UNCACHEABLE SUBQUERY</code> の場合、外部コンテキストの行ごとにサブクエリーが再評価されます。 
            </p><p>
              <code class="literal">EXPLAIN</code> で <code class="literal">FORMAT=JSON</code> を指定した場合、出力には <code class="literal">select_type</code> と直接同等の単一のプロパティはありません。<code class="literal">query_block</code> プロパティは特定の <code class="literal">SELECT</code> に対応します。 表示されているほとんどの <code class="literal">SELECT</code> サブクエリータイプに相当するプロパティが使用可能で (たとえば、<code class="literal">materialized_from_subquery</code> for <code class="literal">MATERIALIZED</code>)、必要に応じて表示されます。 <code class="literal">SIMPLE</code> または <code class="literal">PRIMARY</code> に相当する JSON はありません。 
            </p><p>
              <code class="literal">SELECT</code> 以外のステートメントの <code class="literal">select_type</code> 値には、影響を受けるテーブルのステートメントタイプが表示されます。 たとえば、<code class="literal">select_type</code> は <code class="literal">DELETE</code> ステートメント用の <code class="literal">DELETE</code> です。 
            </p></li><li class="listitem"><p><a name="explain_table"></a>
              <code class="literal">table</code> (JSON 名): <code class="literal">table_name</code> )
            </p><p>
              出力の行で参照しているテーブルの名前。 これも次のいずれかの値になることがあります。 
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">&lt;union<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>N</code></em>&gt;</code>: 行は <em class="replaceable"><code>M</code></em> および <em class="replaceable"><code>N</code></em> の <code class="literal">id</code> 値のある行の和集合を参照しています。
                </p></li><li class="listitem"><p>
                  <code class="literal">&lt;derived<em class="replaceable"><code>N</code></em>&gt;</code>: 行は <em class="replaceable"><code>N</code></em> の <code class="literal">id</code> 値のある行の派生テーブル結果を参照しています。 派生テーブルは、たとえば <code class="literal">FROM</code> 句内のサブクエリーの結果などになります。 
                </p></li><li class="listitem"><p>
                  <code class="literal">&lt;subquery<em class="replaceable"><code>N</code></em>&gt;</code>: 行は <em class="replaceable"><code>N</code></em> の <code class="literal">id</code> 値のある行の実体化されたサブクエリーの結果を参照しています。 <a class="xref" href="optimization.html#subquery-materialization" title="8.2.2.2 実体化を使用したサブクエリーの最適化">セクション8.2.2.2「実体化を使用したサブクエリーの最適化」</a>を参照してください。 
                </p></li></ul></div></li><li class="listitem"><p><a name="explain_partitions"></a>
              <code class="literal">partitions</code> (JSON 名): <code class="literal">partitions</code> )
            </p><p>
              クエリーでレコードが照合されるパーティション。 パーティション化されていないテーブルの場合、この値は <code class="literal">NULL</code> です。 <a class="xref" href="partitioning.html#partitioning-info" title="24.3.5 パーティションに関する情報を取得する">セクション24.3.5「パーティションに関する情報を取得する」</a>を参照してください。 
            </p></li><li class="listitem"><p><a name="explain_type"></a>
              <code class="literal">type</code> (JSON 名): <code class="literal">access_type</code> )
            </p><p>
              結合型。 さまざまな型の説明については、「<a class="link" href="optimization.html#explain-join-types" title="EXPLAIN 結合型"><code class="literal">EXPLAIN</code> 結合型</a>」を参照してください。 
            </p></li><li class="listitem"><p><a name="explain_possible_keys"></a>
              <code class="literal">possible_keys</code> (JSON 名): <code class="literal">possible_keys</code> )
            </p><p>
              <code class="literal">possible_keys</code> カラムは、MySQL がこのテーブルの行を検索するために選択できるインデックスを示します。 このカラムは <code class="literal">EXPLAIN</code> の出力に表示されたテーブルの順序にまったく依存しません。 つまり、<code class="literal">possible_keys</code> のキーの一部は、生成されたテーブルの順序で実際に使用できないことがあります。 
            </p><p>
              このカラムが <code class="literal">NULL</code> の場合 (または JSON 形式の出力で未定義の場合)、関連するインデックスはありません。 この場合、<code class="literal">WHERE</code> 句を調査して、それがインデックス設定に適したカラムを参照しているかどうかをチェックすることで、クエリーのパフォーマンスを向上できることがあります。 その場合は、適切なインデックスを作成し、再度 <code class="literal">EXPLAIN</code> でクエリーをチェックします。 <a class="xref" href="sql-statements.html#alter-table" title="13.1.9 ALTER TABLE ステートメント">セクション13.1.9「ALTER TABLE ステートメント」</a>を参照してください。 
            </p><p>
              テーブルにあるインデックスを確認するには、<code class="literal">SHOW INDEX FROM <em class="replaceable"><code>tbl_name</code></em></code> を使用します。
            </p></li><li class="listitem"><p><a name="explain_key"></a>
              <code class="literal">key</code> (JSON 名): <code class="literal">key</code> )
            </p><p>
              <code class="literal">key</code> カラムは、MySQL が実際に使用することを決定したキー (インデックス) を示します。 MySQL が行をルックアップするために、いずれかの <code class="literal">possible_keys</code> インデックスを使用することを決定した場合、キー値としてそのインデックスが一覧表示されます。 
            </p><p>
              <code class="literal">key</code> は、<code class="literal">possible_keys</code> 値に存在しないインデックスに名前を付けることができます。 これは <code class="literal">possible_keys</code> インデックスのどれも行のルックアップに適していない場合に発生する可能性がありますが、クエリーによって選択されるすべてのカラムはほかのインデックスのカラムになります。 つまり、指定されたインデックスは選択されたカラムをカバーするため、取得する行を決定するために使用されませんが、インデックススキャンはデータ行スキャンよりも効率的です。 
            </p><p>
              <code class="literal">InnoDB</code> は各セカンダリインデックスとともに主キー値を保存するため、<code class="literal">InnoDB</code> では、クエリーで主キーも選択している場合でも、セカンダリインデックスで選択されたカラムをカバーしている可能性があります。 <code class="literal">key</code> が <code class="literal">NULL</code> の場合、MySQL はクエリーをより効率的に実行するために使用するインデックスを見つけられませんでした。 
            </p><p>
              MySQL で <code class="literal">possible_keys</code> カラムに示されたインデックスを強制的に使用させるか、無視させるには、クエリーで <code class="literal">FORCE INDEX</code>、<code class="literal">USE INDEX</code>、または <code class="literal">IGNORE INDEX</code> を使用します。 <a class="xref" href="optimization.html#index-hints" title="8.9.4 インデックスヒント">セクション8.9.4「インデックスヒント」</a>を参照してください。 
            </p><p>
              <code class="literal">MyISAM</code> テーブルの場合、<code class="literal">ANALYZE TABLE</code> を実行すると、オプティマイザがより適切なインデックスを選択するのに役立ちます。 <code class="literal">MyISAM</code> テーブルの場合、<span class="command"><strong>myisamchk --analyze</strong></span> も同様に動作します。 <a class="xref" href="sql-statements.html#analyze-table" title="13.7.3.1 ANALYZE TABLE ステートメント">セクション13.7.3.1「ANALYZE TABLE ステートメント」</a>および<a class="xref" href="backup-and-recovery.html#myisam-table-maintenance" title="7.6 MyISAM テーブルの保守とクラッシュリカバリ">セクション7.6「MyISAM テーブルの保守とクラッシュリカバリ」</a>を参照してください。 
            </p></li><li class="listitem"><p><a name="explain_key_len"></a>
              <code class="literal">key_len</code> (JSON 名): <code class="literal">key_length</code> )
            </p><p>
              <code class="literal">key_len</code> カラムは、MySQL が使用することを決定したキーの長さを示します。 <code class="literal">key_len</code> の値を使用すると、MySQL が実際に使用するマルチパーティキーの部分の数を決定できます。 <code class="literal">key</code> カラムに <code class="literal">NULL</code> と表示されている場合、<code class="literal">key_len</code> カラムにも <code class="literal">NULL</code> と表示されます。 
            </p><p>
              キーの格納形式のため、キーの長さは、<code class="literal">NULL</code> にできるカラムの長さが <code class="literal">NOT NULL</code> カラムの長さより大きくなります。
            </p></li><li class="listitem"><p><a name="explain_ref"></a>
              <code class="literal">ref</code> (JSON 名): <code class="literal">ref</code> )
            </p><p>
              <code class="literal">ref</code> カラムは、テーブルから行を選択するために、<code class="literal">key</code> カラムに指定されたインデックスに対して比較されるカラムまたは定数を示します。
            </p><p>
              値が <code class="literal">func</code> の場合、使用される値は、特定の関数の結果です。 どの関数を表示するには、<code class="literal">EXPLAIN</code> の後の <code class="literal">SHOW WARNINGS</code> を使用して、拡張 <code class="literal">EXPLAIN</code> 出力を表示します。 関数は、実際には算術演算子などの演算子である場合があります。 
            </p></li><li class="listitem"><p><a name="explain_rows"></a>
              <code class="literal">rows</code> (JSON 名): <code class="literal">rows</code> )
            </p><p>
              <code class="literal">rows</code> カラムは、MySQL がクエリーを実行するために調査する必要があると考える行数を示します。
            </p><p>
              <code class="literal">InnoDB</code> テーブルの場合、これは推定値であり、常に正確ではないことがあります。
            </p></li><li class="listitem"><p><a name="explain_filtered"></a>
              <code class="literal">filtered</code> (JSON 名): <code class="literal">filtered</code> )
            </p><p>
              <code class="literal">filtered</code> カラムは、テーブル条件でフィルタされるテーブルの行の推定割合を示します。 最大値は 100 で、これは行のフィルタリングが行われなかったことを意味します。 100 から減少する値は、フィルタリングの量が増加していることを示します。<code class="literal">rows</code> には調査された推定行数が表示され、<code class="literal">rows</code>×<code class="literal">filtered</code> には次のテーブルと結合された行数が表示されます。 たとえば、<code class="literal">rows</code> が 1000 で <code class="literal">filtered</code> が 50.00 (50%) の場合、次のテーブルと結合される行数は 1000×50% = 500 になります。 
            </p></li><li class="listitem"><p><a name="explain_extra"></a>
              <code class="literal">Extra</code> (JSON 名): none)
            </p><p>
              このカラムには、MySQL がクエリーを解決する方法に関する追加情報が含まれます。 さまざまな値の説明については、「<a class="link" href="optimization.html#explain-extra-information" title="EXPLAIN 追加情報"><code class="literal">EXPLAIN</code> の追加情報</a>」を参照してください。 
            </p><p>
              <code class="literal">Extra</code> カラムに対応する単一の JSON プロパティはありませんが、このカラムで発生する可能性のある値は JSON プロパティまたは <code class="literal">message</code> プロパティのテキストとして公開されます。
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="explain-join-types"></a>EXPLAIN 結合型</h4></div></div></div><p>
          <code class="literal">EXPLAIN</code> 出力の <code class="literal">type</code> カラムには、テーブルの結合方法が示されます。 JSON 形式の出力では、これらは <code class="literal">access_type</code> プロパティの値として検出されます。 次のリストに、もっとも適切な型からもっとも不適切な型の順番で並べた結合型を示します。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="jointype_system"></a>
              <code class="literal">system</code>
            </p><a class="indexterm" name="idm45661476369648"></a><a class="indexterm" name="idm45661476367616"></a><a class="indexterm" name="idm45661476365440"></a><p>
              テーブルには行が 1 つしかありません (= system テーブル)。 これは、<code class="literal">const</code> 結合型の特殊なケースです。 
            </p></li><li class="listitem"><p><a name="jointype_const"></a>
              <code class="literal">const</code>
            </p><a class="indexterm" name="idm45661476359616"></a><a class="indexterm" name="idm45661476357584"></a><a class="indexterm" name="idm45661476355440"></a><p>
              テーブルには、一致するレコードが最大で 1 つあり、クエリーの開始時に読み取られます。 行が 1 つしかないため、この行のカラムの値は、オプティマイザの残りによって定数とみなされることがあります。<code class="literal">const</code> テーブルは、1 回しか読み取られないため、非常に高速です。 
            </p><p>
              <code class="literal">const</code> は <code class="literal">PRIMARY KEY</code> または <code class="literal">UNIQUE</code> インデックスのすべてのパートを定数値と比較する場合に使用されます。 次のクエリーでは、<em class="replaceable"><code>tbl_name</code></em> は <code class="literal">const</code> テーブルとして使用できます。 
            </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>primary_key</code></em>=1;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>primary_key_part1</code></em>=1 AND <em class="replaceable"><code>primary_key_part2</code></em>=2;
</pre></li><li class="listitem"><p><a name="jointype_eq_ref"></a>
              <code class="literal">eq_ref</code>
            </p><a class="indexterm" name="idm45661476341440"></a><a class="indexterm" name="idm45661476339408"></a><p>
              前のテーブルの行の組み合わせごとに、このテーブルから 1 行ずつ読み取られます。 <code class="literal">system</code> と <code class="literal">const</code> 型以外で、これは最適な結合型です。 これは、結合でインデックスのすべてのパートが使用されており、インデックスが <code class="literal">PRIMARY KEY</code> または <code class="literal">UNIQUE NOT NULL</code> インデックスである場合に使用されます。 
            </p><p>
              <code class="literal">eq_ref</code> は、<code class="literal">=</code> 演算子を使用して比較されるインデックス設定されたカラムに使用できます。 比較値は、定数またはこのテーブルより前に読み取られたテーブルのカラムを使用する式を指定できます。 次の例では、MySQL は <code class="literal">eq_ref</code> 結合を使用して、<em class="replaceable"><code>ref_table</code></em> を処理できます。 
            </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>ref_table</code></em>,<em class="replaceable"><code>other_table</code></em>
  WHERE <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column</code></em>=<em class="replaceable"><code>other_table</code></em>.<em class="replaceable"><code>column</code></em>;

SELECT * FROM <em class="replaceable"><code>ref_table</code></em>,<em class="replaceable"><code>other_table</code></em>
  WHERE <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column_part1</code></em>=<em class="replaceable"><code>other_table</code></em>.<em class="replaceable"><code>column</code></em>
  AND <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column_part2</code></em>=1;
</pre></li><li class="listitem"><p><a name="jointype_ref"></a>
              <code class="literal">ref</code>
            </p><a class="indexterm" name="idm45661476319568"></a><a class="indexterm" name="idm45661476317600"></a><p>
              前のテーブルの行の組み合わせごとに、一致するインデックス値を持つすべての行がこのテーブルから読み取られます。<code class="literal">ref</code> は、結合でキーの左端のプリフィクスのみが使用される場合、またはキーが <code class="literal">PRIMARY KEY</code> や <code class="literal">UNIQUE</code> インデックスではない場合 (つまり、結合で、キー値に基づいて単一の行を選択できない場合) に使用されます。 使用されているキーがほんの数行にしか一致しない場合、これは適切な結合型です。 
            </p><p>
              <code class="literal">ref</code> は、<code class="literal">=</code> または <code class="literal">&lt;=&gt;</code> 演算子を使用して比較されるインデックス設定されたカラムに使用できます。 次の例では、MySQL は <code class="literal">ref</code> 結合を使用して、<em class="replaceable"><code>ref_table</code></em> を処理できます。 
            </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>ref_table</code></em> WHERE <em class="replaceable"><code>key_column</code></em>=<em class="replaceable"><code>expr</code></em>;

SELECT * FROM <em class="replaceable"><code>ref_table</code></em>,<em class="replaceable"><code>other_table</code></em>
  WHERE <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column</code></em>=<em class="replaceable"><code>other_table</code></em>.<em class="replaceable"><code>column</code></em>;

SELECT * FROM <em class="replaceable"><code>ref_table</code></em>,<em class="replaceable"><code>other_table</code></em>
  WHERE <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column_part1</code></em>=<em class="replaceable"><code>other_table</code></em>.<em class="replaceable"><code>column</code></em>
  AND <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column_part2</code></em>=1;
</pre></li><li class="listitem"><p><a name="jointype_fulltext"></a>
              <code class="literal">fulltext</code>
            </p><a class="indexterm" name="idm45661476295984"></a><a class="indexterm" name="idm45661476293952"></a><p>
              結合は <code class="literal">FULLTEXT</code> インデックスを使用して実行されます。
            </p></li><li class="listitem"><p><a name="jointype_ref_or_null"></a>
              <code class="literal">ref_or_null</code>
            </p><a class="indexterm" name="idm45661476288432"></a><a class="indexterm" name="idm45661476286400"></a><p>
              この結合型は、<code class="literal">ref</code> と似ていますが、MySQL が <code class="literal">NULL</code> 値を含む行の追加検索を実行することが追加されます。 この結合型の最適化は、ほとんどの場合に、サブクエリーの解決で使用されます。 次の例では、MySQL は <code class="literal">ref_or_null</code> 結合を使用して、<em class="replaceable"><code>ref_table</code></em> を処理できます。 
            </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>ref_table</code></em>
  WHERE <em class="replaceable"><code>key_column</code></em>=<em class="replaceable"><code>expr</code></em> OR <em class="replaceable"><code>key_column</code></em> IS NULL;
</pre><p>
              <a class="xref" href="optimization.html#is-null-optimization" title="8.2.1.15 IS NULL の最適化">セクション8.2.1.15「IS NULL の最適化」</a>を参照してください。
            </p></li><li class="listitem"><p><a name="jointype_index_merge"></a>
              <code class="literal">index_merge</code>
            </p><a class="indexterm" name="idm45661476274176"></a><a class="indexterm" name="idm45661476272144"></a><p>
              この結合型はインデックスマージ最適化が使用されたことを示します。 この場合、出力行の <code class="literal">key</code> カラムには使用されたインデックスのリストが含まれ、<code class="literal">key_len</code> には使用されたインデックスの最長キーパートのリストが含まれます。 詳細については、<a class="xref" href="optimization.html#index-merge-optimization" title="8.2.1.3 インデックスマージの最適化">セクション8.2.1.3「インデックスマージの最適化」</a>を参照してください。 
            </p></li><li class="listitem"><p><a name="jointype_unique_subquery"></a>
              <code class="literal">unique_subquery</code>
            </p><a class="indexterm" name="idm45661476264624"></a><a class="indexterm" name="idm45661476262592"></a><p>
              このタイプは、次の形式の一部の <code class="literal">IN</code> サブクエリーで <code class="literal">eq_ref</code> に置き換わります:
            </p><pre class="programlisting"><em class="replaceable"><code>value</code></em> IN (SELECT <em class="replaceable"><code>primary_key</code></em> FROM <em class="replaceable"><code>single_table</code></em> WHERE <em class="replaceable"><code>some_expr</code></em>)
</pre><p>
              <code class="literal">unique_subquery</code> は、効率化のため、サブクエリーを完全に置き換える単なるインデックスルックアップ関数です。
            </p></li><li class="listitem"><p><a name="jointype_index_subquery"></a>
              <code class="literal">index_subquery</code>
            </p><a class="indexterm" name="idm45661476251904"></a><a class="indexterm" name="idm45661476249872"></a><p>
              この結合型は <code class="literal">unique_subquery</code> に似ています。 <code class="literal">IN</code> サブクエリーを置き換えますが、次の形式のサブクエリー内の一意でないインデックスに対して機能します。 
            </p><pre class="programlisting"><em class="replaceable"><code>value</code></em> IN (SELECT <em class="replaceable"><code>key_column</code></em> FROM <em class="replaceable"><code>single_table</code></em> WHERE <em class="replaceable"><code>some_expr</code></em>)
</pre></li><li class="listitem"><p><a name="jointype_range"></a>
              <code class="literal">range</code>
            </p><a class="indexterm" name="idm45661476240560"></a><a class="indexterm" name="idm45661476238528"></a><p>
              行を選択するためのインデックスを使用して、特定の範囲にある行のみが取得されます。 出力行の <code class="literal">key</code> カラムは、使用されるインデックスを示します。 <code class="literal">key_len</code> には使用された最長のインデックスパートが格納されます。 この型の <code class="literal">ref</code> カラムは <code class="literal">NULL</code> です。 
            </p><p>
              <code class="literal">range</code> は、<code class="literal">=</code>, <code class="literal">&lt;&gt;</code>, <code class="literal">&gt;</code>, <code class="literal">&gt;=</code>, <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>, <code class="literal">IS NULL</code>, <code class="literal">&lt;=&gt;</code>, <code class="literal">BETWEEN</code>, <code class="literal">LIKE</code> または <code class="literal">IN()</code> 演算子のいずれかを使用してキーカラムを定数と比較する場合に使用できます:
            </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_column</code></em> = 10;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_column</code></em> BETWEEN 10 and 20;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_column</code></em> IN (10,20,30);

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_part1</code></em> = 10 AND <em class="replaceable"><code>key_part2</code></em> IN (10,20,30);
</pre></li><li class="listitem"><p><a name="jointype_index"></a>
              <code class="literal">インデックス</code>
            </p><a class="indexterm" name="idm45661476211728"></a><a class="indexterm" name="idm45661476209696"></a><p>
              <code class="literal">index</code> 結合型は、インデックスツリーがスキャンされることを除いて、<code class="literal">ALL</code> と同じです。 これは 2 つの方法で行われます。 
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  インデックスがクエリーのカバリングインデックスで、使用すると、テーブルから必要なすべてのデータを満たすことができる場合、インデックスツリーのみがスキャンされます。 この場合、<code class="literal">Extra</code> カラムには <code class="literal">Using index</code> と示されます。 インデックスのサイズは通常テーブルデータより小さいため、インデックスのみのスキャンは通常、<code class="literal">ALL</code> より高速です。 
                </p></li><li class="listitem"><p>
                  フルテーブルスキャンは、インデックスからの読み取りを使用して、インデックス順でデータ行をルックアップして実行されます。 <code class="literal">Extra</code> カラムに <code class="literal">Uses index</code> が表示されません。 
                </p></li></ul></div><p>
              MySQL は、クエリーで単一のインデックスの一部であるカラムのみが使用されている場合に、この結合型を使用できます。
            </p></li><li class="listitem"><p><a name="jointype_all"></a>
              <code class="literal">ALL</code>
            </p><a class="indexterm" name="idm45661476195072"></a><a class="indexterm" name="idm45661476193104"></a><p>
              フルテーブルスキャンは、前のテーブルの行の組み合わせごとに実行されます。 これは、通常テーブルが <code class="literal">const</code> とマークされていない最初のテーブルである場合には適しておらず、通常ほかのすべてのケースで<span class="emphasis"><em>著しく</em></span>不適切です。 通常、定数値または以前のテーブルからのカラム値に基づいて、テーブルからの行の取得を可能にするインデックスを追加することで、<code class="literal">ALL</code> を回避できます。 
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="explain-extra-information"></a>EXPLAIN 追加情報</h4></div></div></div><p>
          <code class="literal">EXPLAIN</code> 出力の <code class="literal">Extra</code> カラムには、MySQL がクエリーを解決する方法に関する追加情報が含まれます。 次のリストに、このカラムに表示される可能性のある値について説明します。 各セクション目は、JSON 形式の出力に対して、<code class="literal">Extra</code> 値を表示するプロパティも示します。 これらの一部には、特定のプロパティがあります。 その他は、<code class="literal">message</code> プロパティのテキストとして表示されます。 
        </p><p>
          クエリーをできるだけ高速にする場合は、<code class="literal">Using filesort</code> および <code class="literal">Using temporary</code> の <code class="literal">Extra</code> カラムの値を検索するか、JSON 形式の <code class="literal">EXPLAIN</code> 出力で <code class="literal">using_filesort</code> および <code class="literal">using_temporary_table</code> のプロパティが <code class="literal">true</code> に等しいかどうかを調べます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">Child of '<em class="replaceable"><code>table</code></em>' pushed join@1</code> (JSON: <code class="literal">message</code> テキスト)
            </p><p>
              このテーブルは、NDB カーネルにプッシュダウンできる結合内の <em class="replaceable"><code>table</code></em> の子として参照されます。 プッシュダウン結合が有効になっている場合、NDB Cluster でのみ適用されます。 詳細と例については、<code class="literal">ndb_join_pushdown</code> サーバーシステム変数の説明を参照してください。 
            </p></li><li class="listitem"><p>
              <code class="literal">const row not found</code> (JSON プロパティ): <code class="literal">const_row_not_found</code> )
            </p><p>
              <code class="literal">SELECT ... FROM <em class="replaceable"><code>tbl_name</code></em></code> などのクエリーの場合、テーブルは空でした。
            </p></li><li class="listitem"><p>
              <code class="literal">Deleting all rows</code> (JSON プロパティ): <code class="literal">message</code> )
            </p><p>
              <code class="literal">DELETE</code> に対し、一部のストレージエンジン (<code class="literal">MyISAM</code> など) は簡単で高速にすべての行テーブルを削除するハンドラメソッドをサポートしています。 この <code class="literal">Extra</code> 値は、エンジンでこの最適化が使用された場合に表示されます。 
            </p></li><li class="listitem"><p>
              <code class="literal">Distinct</code> (JSON プロパティ): <code class="literal">distinct</code> )
            </p><p>
              MySQL は個別の値を検索するため、最初に一致する行が見つかったら、現在の行の組み合わせについてのそれ以上の行の検索を停止します。
            </p></li><li class="listitem"><p>
              <code class="literal">FirstMatch(<em class="replaceable"><code>tbl_name</code></em>)</code> (JSON プロパティ): <code class="literal">first_match</code> )
            </p><p>
              準結合 FirstMatch 結合ショートカット戦略は、<em class="replaceable"><code>tbl_name</code></em> に使用されます。
            </p></li><li class="listitem"><p>
              <code class="literal">Full scan on NULL key</code> (JSON プロパティ): <code class="literal">message</code> )
            </p><p>
              これは、オプティマイザがインデックスルックアップアクセスメソッドを使用できない場合の代替の戦略として、サブクエリーの最適化で行われます。
            </p></li><li class="listitem"><p>
              <code class="literal">Impossible HAVING</code> (JSON プロパティ): <code class="literal">message</code> )
            </p><p>
              <code class="literal">HAVING</code> 句は常に false で、どの行も選択できません。
            </p></li><li class="listitem"><p>
              <code class="literal">Impossible WHERE</code> (JSON プロパティ): <code class="literal">message</code> )
            </p><p>
              <code class="literal">WHERE</code> 句は常に false で、どの行も選択できません。
            </p></li><li class="listitem"><p>
              <code class="literal">Impossible WHERE noticed after reading const tables</code> (JSON プロパティ): <code class="literal">message</code> )
            </p><p>
              MySQL はすべての <code class="literal">const</code> (および <code class="literal">system</code>) テーブルを読み取り、<code class="literal">WHERE</code> 句が常に false であることを通知します。
            </p></li><li class="listitem"><p>
              <code class="literal">LooseScan(<em class="replaceable"><code>m</code></em>..<em class="replaceable"><code>n</code></em>)</code> (JSON プロパティ): <code class="literal">message</code> )
            </p><p>
              準結合 LooseScan 戦略が使用されます。<em class="replaceable"><code>m</code></em> および <em class="replaceable"><code>n</code></em> は主要な部品番号です。
            </p></li><li class="listitem"><p>
              <code class="literal">No matching min/max row</code> (JSON プロパティ): <code class="literal">message</code> )
            </p><p>
              <code class="literal">SELECT MIN(...) FROM ... WHERE <em class="replaceable"><code>condition</code></em></code> などのクエリーの条件を満たす行がありません。
            </p></li><li class="listitem"><p>
              <code class="literal">no matching row in const table</code> (JSON プロパティ): <code class="literal">message</code> )
            </p><p>
              結合のあるクエリーで、空のテーブルまたは一意のインデックス条件を満足する行がないテーブルがありました。
            </p></li><li class="listitem"><p>
              <code class="literal">No matching rows after partition pruning</code> (JSON プロパティ): <code class="literal">message</code> )
            </p><p>
              <code class="literal">DELETE</code> または <code class="literal">UPDATE</code> に対し、オプティマイザはパーティションのプルーニング後に削除または更新するものが何も見つかりませんでした。 それは、<code class="literal">SELECT</code> ステートメントの <code class="literal">Impossible WHERE</code> に意味が似ています。 
            </p></li><li class="listitem"><p>
              <code class="literal">No tables used</code> (JSON プロパティ): <code class="literal">message</code> )
            </p><p>
              クエリーに <code class="literal">FROM</code> 句がないか、<code class="literal">FROM DUAL</code> 句があります。
            </p><p>
              <code class="literal">INSERT</code> または <code class="literal">REPLACE</code> ステートメントで、<code class="literal">SELECT</code> パートがない場合に、<code class="literal">EXPLAIN</code> にこの値が表示されます。 たとえば、<code class="literal">EXPLAIN INSERT INTO t VALUES(10)</code> に対して、それは <code class="literal">EXPLAIN INSERT INTO t SELECT 10 FROM DUAL</code> と同等であるために表示されます。 
            </p></li><li class="listitem"><p>
              <code class="literal">Not exists</code> (JSON プロパティ): <code class="literal">message</code> )
            </p><p>
              MySQL はクエリーに対する <code class="literal">LEFT JOIN</code> 最適化を実行でき、<code class="literal">LEFT JOIN</code> 条件に一致する 1 つの行が見つかったら、前の行の組み合わせについて、このテーブルでそれ以上の行を調査しません。 これは、このように最適化できるクエリーの種類の例です。 
            </p><pre class="programlisting">SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id
  WHERE t2.id IS NULL;
</pre><p>
              <code class="literal">t2.id</code> が <code class="literal">NOT NULL</code> で定義されているとします。 この場合、MySQL は <code class="literal">t1</code> をスキャンし、<code class="literal">t1.id</code> の値を使用して <code class="literal">t2</code> 内の行をルックアップします。 MySQL が <code class="literal">t2</code> 内に一致する行を見つけた場合、<code class="literal">t2.id</code> は <code class="literal">NULL</code> にならないことがわかっているため、同じ <code class="literal">id</code> 値を持つ <code class="literal">t2</code> 内の残りの行をスキャンしません。 つまり、<code class="literal">t1</code> の各行について、MySQL は、<code class="literal">t2</code> 内の実際に一致する行数にかかわらず、<code class="literal">t2</code> 内の単一のルックアップのみを実行する必要があります。 
            </p><p>
              MySQL 8.0.17 以降では、<code class="literal">NOT IN (<em class="replaceable"><code>subquery</code></em>)</code> または <code class="literal">NOT EXISTS (<em class="replaceable"><code>subquery</code></em>)</code> 形式の <code class="literal">WHERE</code> 条件が内部的にアンチ結合に変換されたことを示すこともできます。 これにより、サブクエリーが削除され、そのテーブルが最上位のクエリーの計画に追加され、コスト計画が改善されます。 準結合とアンチ結合をマージすることで、オプティマイザは実行計画内のテーブルの順序をより自由に変更できるため、計画が高速になる場合があります。 
            </p><p>
              特定のクエリーに対してアンチ結合変換が実行されるタイミングを確認するには、<code class="literal">EXPLAIN</code> の実行後に <code class="literal">SHOW WARNINGS</code> から <code class="literal">Message</code> カラムを確認するか、<code class="literal">EXPLAIN FORMAT=TREE</code> の出力で確認します。
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                アンチ結合は、準結合 <code class="literal"><em class="replaceable"><code>table_a</code></em> JOIN <em class="replaceable"><code>table_b</code></em> ON <em class="replaceable"><code>condition</code></em></code> を補完したものです。 アンチ結合では、<em class="replaceable"><code>condition</code></em> に一致する行が <em class="replaceable"><code>table_b</code></em> にない <em class="replaceable"><code>table_a</code></em> のすべての行が返されます。 
              </p></div></li><li class="listitem"><p>
              <code class="literal">Plan isn't ready yet</code> (JSON プロパティ): none)
            </p><p>
              この値は、オプティマイザが名前付き接続で実行中のステートメントの実行計画の作成を終了していない場合に、<code class="literal">EXPLAIN FOR CONNECTION</code> で発生します。 実行計画の出力が複数の行で構成されている場合、オプティマイザが完全な実行計画を決定する進行状況に応じて、そのいずれかまたはすべてがこの <code class="literal">Extra</code> 値を持つ可能性があります。 
            </p></li><li class="listitem"><p>
              <code class="literal">Range checked for each record (index map: <em class="replaceable"><code>N</code></em>)</code> (JSON プロパティ) : <code class="literal">message</code> )
            </p><p>
              MySQL は使用に適したインデックスを見つけられませんでしたが、前のテーブルからのカラム値がわかったあとに、いくつかのインデックスが使用できることがわかりました。 以前のテーブルの行の組み合わせごとに、MySQL は <code class="literal">range</code> または <code class="literal">index_merge</code> アクセスメソッドを使用して、行を取得できるかどうかをチェックします。 これは、非常に高速ではありませんが、インデックスがまったくない結合の実行より高速です。 前のテーブルのすべてのカラム値がわかっており、定数とみなされることを除き、適用基準は、<a class="xref" href="optimization.html#range-optimization" title="8.2.1.2 range の最適化">セクション8.2.1.2「range の最適化」</a>と<a class="xref" href="optimization.html#index-merge-optimization" title="8.2.1.3 インデックスマージの最適化">セクション8.2.1.3「インデックスマージの最適化」</a>で説明されているとおりです。 
            </p><p>
              インデックスは、テーブルの <code class="literal">SHOW INDEX</code> に示される同じ順序で 1 から番号付けされます。 インデックスマップ値 <em class="replaceable"><code>N</code></em> は、候補となるインデックスを示すビットマスク値です。 たとえば、<code class="literal">0x19</code> (バイナリ 11001) の値は、インデックス 1、4、および 5 が考慮されることを意味します。 
            </p></li><li class="listitem"><p>
              <code class="literal">Recursive</code> (JSON プロパティ): <code class="literal">recursive</code> )
            </p><p>
              これは、行が再帰的共通テーブル式の再帰的 <code class="literal">SELECT</code> 部分に適用されることを示します。 <a class="xref" href="sql-statements.html#with" title="13.2.15 WITH (共通テーブル式)">セクション13.2.15「WITH (共通テーブル式)」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              <code class="literal">Rematerialize</code> (JSON プロパティ): <code class="literal">rematerialize</code> )
            </p><a class="indexterm" name="idm45661476059328"></a><a class="indexterm" name="idm45661476057168"></a><p>
              <code class="literal">Rematerialize (X,...)</code> は、<code class="literal">T</code> テーブルの <code class="literal">EXPLAIN</code> 行に表示されます。<code class="literal">X</code> は、<code class="literal">T</code> の新しい行が読み取られたときに再実体化がトリガーされるラテラル導出テーブルです。 例: 
            </p><pre class="programlisting">SELECT
  ...
FROM
  t,
  LATERAL (<em class="replaceable"><code>derived table that refers to t</code></em>) AS dt
...
</pre><p>
              導出テーブルの内容は、上位クエリーによって <code class="literal">t</code> の新しい行が処理されるたびに最新になるように再実体化されます。
            </p></li><li class="listitem"><p>
              <code class="literal">Scanned <em class="replaceable"><code>N</code></em> databases</code> (JSON プロパティ): <code class="literal">message</code> )
            </p><p>
              これは、<a class="xref" href="optimization.html#information-schema-optimization" title="8.2.3 INFORMATION_SCHEMA クエリーの最適化">セクション8.2.3「INFORMATION_SCHEMA クエリーの最適化」</a>に説明するように、サーバーが <code class="literal">INFORMATION_SCHEMA</code> テーブルのクエリーを処理する際に実行するディレクトリスキャンの数を示します。 <em class="replaceable"><code>N</code></em> の値は 0、1、または <code class="literal">all</code> です。 
            </p></li><li class="listitem"><p>
              <code class="literal">Select tables optimized away</code> (JSON プロパティ): <code class="literal">message</code> )
            </p><p>
              オプティマイザは、1) 最大 1 つの行を戻す必要があると判断しました。2) この行を生成するには、確定的な行セットを読み取る必要があります。 読取り対象の行を最適化フェーズ中 (インデックス行の読取りなど) に読み取ることができる場合、クエリーの実行中にテーブルを読み取る必要はありません。 
            </p><p>
              最初の条件は、クエリーが暗黙的にグループ化されるときに満たされます (集計関数は含まれますが、<code class="literal">GROUP BY</code> 句は含まれません)。 2 番目の条件は、使用されるインデックスごとに 1 つの行検索が実行されるときに満たされます。 読み取られるインデックスの数によって、読み取る行数が決まります。 
            </p><p>
              暗黙的にグループ化された次のクエリーについて考えてみます:
            </p><pre class="programlisting">SELECT MIN(c1), MIN(c2) FROM t1;
</pre><p>
              あるインデックス行を読み取ることで <code class="literal">MIN(c1)</code> を取得でき、別のインデックスからある行を読み取ることで <code class="literal">MIN(c2)</code> を取得できるとします。 つまり、カラム <code class="literal">c1</code> および <code class="literal">c2</code> ごとに、カラムがインデックスの最初のカラムであるインデックスが存在します。 この場合、2 つの決定的な行を読み取ることによって生成された 1 つの行が返されます。 
            </p><p>
              読み取る行が決定的でない場合、この <code class="literal">Extra</code> 値は発生しません。 次のクエリーについて考えてみます: 
            </p><pre class="programlisting">SELECT MIN(c2) FROM t1 WHERE c1 &lt;= 10;
</pre><p>
              <code class="literal">(c1, c2)</code> がカバーインデックスであるとします。 このインデックスを使用して、<code class="literal">c1 &lt;= 10</code> のすべての行をスキャンし、<code class="literal">c2</code> の最小値を検索する必要があります。 対照的に、次のクエリーについて考えてみます: 
            </p><pre class="programlisting">SELECT MIN(c2) FROM t1 WHERE c1 = 10;
</pre><p>
              この場合、<code class="literal">c1 = 10</code> の最初のインデックス行には、<code class="literal">c2</code> の最小値が含まれます。 返される行を生成するには、1 つの行のみを読み取る必要があります。 
            </p><p>
              テーブルごとに正確な行数を保持するストレージエンジン (<code class="literal">MyISAM</code> など、<code class="literal">InnoDB</code> は保持しない) の場合、<code class="literal">WHERE</code> 句が欠落しているか常に true で、<code class="literal">GROUP BY</code> 句がない <code class="literal">COUNT(*)</code> クエリーに対してこの <code class="literal">Extra</code> 値が発生することがあります。 (これは暗黙的にグループ化されたクエリーのインスタンスであり、ストレージエンジンは確定的な行数を読み取ることができるかどうかに影響します。) 
            </p></li><li class="listitem"><p>
              <code class="literal">Skip_open_table</code>, <code class="literal">Open_frm_only</code>, <code class="literal">Open_full_table</code> (JSON プロパティ): <code class="literal">message</code> )
            </p><p>
              これらの値は、<code class="literal">INFORMATION_SCHEMA</code> テーブルのクエリーに適用されるファイルオープンの最適化を示します。
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">Skip_open_table</code>: テーブルファイルを開く必要はありません。 この情報はデータディクショナリからすでに使用可能です。 
                </p></li><li class="listitem"><p>
                  <code class="literal">Open_frm_only</code>: テーブル情報を読み取る必要があるのはデータディクショナリのみです。
                </p></li><li class="listitem"><p>
                  <code class="literal">Open_full_table</code>: 最適化されていない情報参照。 テーブル情報は、データディクショナリから、およびテーブルファイルを読み取ることによって読み取る必要があります。 
                </p></li></ul></div></li><li class="listitem"><p>
              <code class="literal">Start temporary</code>、<code class="literal">End temporary</code> (JSON プロパティ): <code class="literal">message</code> )
            </p><p>
              これは、準結合重複除去ストラテジの一時テーブルの使用を示します。
            </p></li><li class="listitem"><p>
              <code class="literal">unique row not found</code> (JSON プロパティ): <code class="literal">message</code> )
            </p><p>
              <code class="literal">SELECT ... FROM <em class="replaceable"><code>tbl_name</code></em></code> などのクエリーの場合に、テーブルに <code class="literal">UNIQUE</code> インデックスまたは <code class="literal">PRIMARY KEY</code> の条件を満たす行がありません。
            </p></li><li class="listitem"><p>
              <code class="literal">Using filesort</code> (JSON プロパティ): <code class="literal">using_filesort</code> )
            </p><p>
              MySQL はソート順で行を取得する方法を見つけるために、追加のパスを実行する必要があります。 ソートは、結合型に従ってすべての行を進み、ソートキーと <code class="literal">WHERE</code> 句に一致するすべての行について行へのポインタを格納して実行されます。 次にキーがソートされ、ソート順で行が取得されます。 <a class="xref" href="optimization.html#order-by-optimization" title="8.2.1.16 ORDER BY の最適化">セクション8.2.1.16「ORDER BY の最適化」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              <code class="literal">Using index</code> (JSON プロパティ): <code class="literal">using_index</code> )
            </p><p>
              実際の行を読み取るための追加のシークを実行する必要がなく、インデックスツリーの情報のみを使用して、テーブルからカラム情報が取得されます。 この戦略は、クエリーで単一のインデックスの一部であるカラムのみを使用している場合に使用できます。 
            </p><p>
              ユーザー定義のクラスタ化されたインデックスを持つ <code class="literal">InnoDB</code> テーブルの場合、そのインデックスは <code class="literal">Extra</code> カラムに <code class="literal">Using index</code> がない場合でも使用できます。 これは、<code class="literal">type</code> が <code class="literal">index</code> で <code class="literal">key</code> が <code class="literal">PRIMARY</code> の場合です。 
            </p></li><li class="listitem"><p>
              <code class="literal">Using index condition</code> (JSON プロパティ): <code class="literal">using_index_condition</code> )
            </p><p>
              インデックスタプルにアクセスし、まずそれらをテストして、すべてのテーブル行を読み取るかどうかを判断することによって、テーブルが読み取られます。 このように、必要でないかぎり、すべてのテーブル行の読み取りを遅延 (<span class="quote">「<span class="quote">プッシュダウン</span>」</span>) するためにインデックス情報が使用されます。 <a class="xref" href="optimization.html#index-condition-pushdown-optimization" title="8.2.1.6 インデックスコンディションプッシュダウンの最適化">セクション8.2.1.6「インデックスコンディションプッシュダウンの最適化」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              <code class="literal">Using index for group-by</code> (JSON プロパティ): <code class="literal">using_index_for_group_by</code> )
            </p><p>
              <code class="literal">Using index</code> テーブルアクセスメソッドと同様に、<code class="literal">Using index for group-by</code> は MySQL が、実際のテーブルへの追加のディスクアクセスをせずに、<code class="literal">GROUP BY</code> または <code class="literal">DISTINCT</code> クエリーのすべてのカラムを取得するために使用できるインデックスを見つけたことを示します。 さらに、各グループに対して、少数のインデックスエントリだけが読み取られるように、インデックスがもっとも効率的に使われます。 詳細は、<a class="xref" href="optimization.html#group-by-optimization" title="8.2.1.17 GROUP BY の最適化">セクション8.2.1.17「GROUP BY の最適化」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              <code class="literal">Using index for skip scan</code> (JSON プロパティ): <code class="literal">using_index_for_skip_scan</code> )
            </p><p>
              スキップスキャンアクセスメソッドが使用されていることを示します。 <a class="xref" href="optimization.html#range-access-skip-scan" title="スキャン範囲アクセス方法のスキップ">スキャン範囲アクセス方法のスキップ</a>を参照してください。 
            </p></li><li class="listitem"><p>
              <code class="literal">Using join buffer (Block Nested Loop)</code>, <code class="literal">Using join buffer (Batched Key Access)</code>, <code class="literal">Using join buffer (hash join)</code> (JSON プロパティ): <code class="literal">using_join_buffer</code> )
            </p><p>
              初期の結合からのテーブルは、部分ごとに結合バッファーに読み込まれ、それらの行がバッファーから使用されて、現在のテーブルとの結合が実行されます。 <code class="literal">(Block Nested Loop)</code> ではブロックネスト - ループアルゴリズムが使用され、<code class="literal">(Batched Key Access)</code> ではバッチキーアクセスアルゴリズムが使用され、<code class="literal">(hash join)</code> ではハッシュ結合が使用されます。 つまり、<code class="literal">EXPLAIN</code> 出力の前の行にあるテーブルのキーがバッファされ、<code class="literal">Using join buffer</code> が表示される行で表されるテーブルから一致する行がバッチでフェッチされます。 
            </p><p>
              JSON 形式の出力では、<code class="literal">using_join_buffer</code> の値は常に <code class="literal">Block Nested Loop</code>、<code class="literal">Batched Key Access</code> または <code class="literal">hash join</code> のいずれかです。
            </p><p>
              ハッシュ結合は、MySQL 8.0.18 以降で使用できます。Block Nested-Loop アルゴリズムは、MySQL 8.0.20 以降の MySQL リリースでは使用されません。 これらの最適化の詳細は、<a class="xref" href="optimization.html#hash-joins" title="8.2.1.4 ハッシュ結合の最適化">セクション8.2.1.4「ハッシュ結合の最適化」</a> および <a class="xref" href="optimization.html#block-nested-loop-join-algorithm" title="Block Nested Loop 結合アルゴリズム">Block Nested Loop 結合アルゴリズム</a> を参照してください。 
            </p><p>
              バッチキーアクセスアルゴリズムの詳細は、<a class="xref" href="optimization.html#bka-optimization" title="Batched Key Access 結合">Batched Key Access 結合</a> を参照してください。
            </p></li><li class="listitem"><p>
              <code class="literal">Using MRR</code> (JSON プロパティ): <code class="literal">message</code> )
            </p><p>
              テーブルは Multi-Range Read 最適化戦略を使用して読み取られます。 <a class="xref" href="optimization.html#mrr-optimization" title="8.2.1.11 Multi-Range Read の最適化">セクション8.2.1.11「Multi-Range Read の最適化」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              <code class="literal">Using sort_union(...)</code>, <code class="literal">Using union(...)</code>, <code class="literal">Using intersect(...)</code> (JSON プロパティ): <code class="literal">message</code> )
            </p><p>
              これらは、<code class="literal">index_merge</code> 結合タイプのインデックススキャンのマージ方法を示す特定のアルゴリズムを示します。 <a class="xref" href="optimization.html#index-merge-optimization" title="8.2.1.3 インデックスマージの最適化">セクション8.2.1.3「インデックスマージの最適化」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              <code class="literal">Using temporary</code> (JSON プロパティ): <code class="literal">using_temporary_table</code> )
            </p><p>
              クエリーを解決するために、MySQL は結果を保持する一時テーブルを作成する必要があります。 これは一般に、クエリーに、カラムを異なって一覧表示する <code class="literal">GROUP BY</code> 句と <code class="literal">ORDER BY</code> 句が含まれる場合に発生します。 
            </p></li><li class="listitem"><p>
              <code class="literal">Using where</code> (JSON プロパティ): <code class="literal">attached_condition</code> )
            </p><p>
              <code class="literal">WHERE</code> 句は、次のテーブルに対して照合されるか、またはクライアントに送信される行を制限するために使用されます。 具体的にテーブルからすべての行をフェッチするか、調査する意図がないかぎり、<code class="literal">Extra</code> 値が <code class="literal">Using where</code> でなく、テーブル結合型が <code class="literal">ALL</code> または <code class="literal">index</code> である場合、クエリーに何らかの誤りがある可能性があります。 
            </p><p>
              JSON 形式の出力では、<code class="literal">Using where</code> に直接対応するものはありません。<code class="literal">attached_condition</code> プロパティには、使用される <code class="literal">WHERE</code> 条件が含まれます。
            </p></li><li class="listitem"><p>
              <code class="literal">Using where with pushed condition</code> (JSON プロパティ): <code class="literal">message</code> )
            </p><p>
              この項目は <code class="literal">NDB</code> テーブル<span class="emphasis"><em>のみ</em></span>に適用されます。 つまり、NDB Cluster は条件プッシュダウン最適化を使用して、インデックスなしカラムと定数の間の直接比較の効率を向上させています。 そのような場合、条件がクラスタのデータノードに<span class="quote">「<span class="quote">プッシュダウン</span>」</span>され、すべてのデータノードで同時に評価されます。 これにより、一致しない行をネットワーク経由で送る必要がなくなり、コンディションプッシュダウンを使用できるが使用しない場合より、そのようなクエリーを 5 - 10 倍高速化できます。 詳細は、<a class="xref" href="optimization.html#engine-condition-pushdown-optimization" title="8.2.1.5 エンジンコンディションプッシュダウンの最適化">セクション8.2.1.5「エンジンコンディションプッシュダウンの最適化」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              <code class="literal">Zero limit</code> (JSON プロパティ): <code class="literal">message</code> )
            </p><p>
              クエリーに <code class="literal">LIMIT 0</code> 句があり、行を選択できません。
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="explain-output-interpretation"></a>EXPLAIN 出力の解釈</h4></div></div></div><p>
          <code class="literal">EXPLAIN</code> 出力の <code class="literal">rows</code> カラムの値の積を取得することで、結合がどの程度適しているかを示す適切な目安を得ることができます。 これは、クエリーを実行するために MySQL が調査する必要がある行数を大ざっぱに示すはずです。 <code class="literal">max_join_size</code> システム変数によってクエリーを制限する場合、この行の積は、どの複数テーブル <code class="literal">SELECT</code> ステートメントを実行し、どれを中止するかを判断するためにも使用されます。 <a class="xref" href="server-administration.html#server-configuration" title="5.1.1 サーバーの構成">セクション5.1.1「サーバーの構成」</a>を参照してください。 
        </p><p>
          次の例は、<code class="literal">EXPLAIN</code> によって得られた情報に基づいて、複数テーブル結合を段階的に最適化する方法を示しています。
        </p><p>
          ここに示す <code class="literal">SELECT</code> ステートメントがあり、<code class="literal">EXPLAIN</code> を使用して調査するつもりであるとします。
        </p><pre class="programlisting">EXPLAIN SELECT tt.TicketNumber, tt.TimeIn,
               tt.ProjectReference, tt.EstimatedShipDate,
               tt.ActualShipDate, tt.ClientID,
               tt.ServiceCodes, tt.RepetitiveID,
               tt.CurrentProcess, tt.CurrentDPPerson,
               tt.RecordVolume, tt.DPPrinted, et.COUNTRY,
               et_1.COUNTRY, do.CUSTNAME
        FROM tt, et, et AS et_1, do
        WHERE tt.SubmitTime IS NULL
          AND tt.ActualPC = et.EMPLOYID
          AND tt.AssignedPC = et_1.EMPLOYID
          AND tt.ClientID = do.CUSTNMBR;
</pre><p>
          この例では次のように想定しています。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              比較対象のカラムは次のように宣言されています。
            </p><div class="informaltable"><table summary="Table names, column names, and data types for the columns being compared in the EXPLAIN example described in the preceding text."><col style="width: 10%"><col style="width: 25%"><col style="width: 25%"><thead><tr>
                  <th scope="col">Table</th>
                  <th scope="col">カラム</th>
                  <th scope="col">データ型</th>
                </tr></thead><tbody><tr>
                  <th scope="row"><code class="literal">tt</code></th>
                  <td><code class="literal">ActualPC</code></td>
                  <td><code class="literal">CHAR(10)</code></td>
                </tr><tr>
                  <th scope="row"><code class="literal">tt</code></th>
                  <td><code class="literal">AssignedPC</code></td>
                  <td><code class="literal">CHAR(10)</code></td>
                </tr><tr>
                  <th scope="row"><code class="literal">tt</code></th>
                  <td><code class="literal">ClientID</code></td>
                  <td><code class="literal">CHAR(10)</code></td>
                </tr><tr>
                  <th scope="row"><code class="literal">et</code></th>
                  <td><code class="literal">EMPLOYID</code></td>
                  <td><code class="literal">CHAR(15)</code></td>
                </tr><tr>
                  <th scope="row"><code class="literal">do</code></th>
                  <td><code class="literal">CUSTNMBR</code></td>
                  <td><code class="literal">CHAR(15)</code></td>
                </tr></tbody></table></div></li><li class="listitem"><p>
              テーブルには次のインデックスがあります。
            </p><div class="informaltable"><table summary="Indexes for each of the tables that are part of the EXPLAIN example described in the preceding text."><col style="width: 10%"><col style="width: 40%"><thead><tr>
                  <th>Table</th>
                  <th>インデックス</th>
                </tr></thead><tbody><tr>
                  <td><code class="literal">tt</code></td>
                  <td><code class="literal">ActualPC</code></td>
                </tr><tr>
                  <td><code class="literal">tt</code></td>
                  <td><code class="literal">AssignedPC</code></td>
                </tr><tr>
                  <td><code class="literal">tt</code></td>
                  <td><code class="literal">ClientID</code></td>
                </tr><tr>
                  <td><code class="literal">et</code></td>
                  <td><code class="literal">EMPLOYID</code> (主キー)</td>
                </tr><tr>
                  <td><code class="literal">do</code></td>
                  <td><code class="literal">CUSTNMBR</code> (主キー)</td>
                </tr></tbody></table></div></li><li class="listitem"><p>
              <code class="literal">tt.ActualPC</code> 値は均一に分布されていません。
            </p></li></ul></div><p>
          最初、最適化が実行される前は、<code class="literal">EXPLAIN</code> ステートメントで次の情報が生成されました。
        </p><pre class="programlisting">table type possible_keys key  key_len ref  rows  Extra
et    ALL  PRIMARY       NULL NULL    NULL 74
do    ALL  PRIMARY       NULL NULL    NULL 2135
et_1  ALL  PRIMARY       NULL NULL    NULL 74
tt    ALL  AssignedPC,   NULL NULL    NULL 3872
           ClientID,
           ActualPC
      Range checked for each record (index map: 0x23)
</pre><p>
          各テーブルの <code class="literal">type</code> は <code class="literal">ALL</code> であるため、この出力は MySQL がすべてのテーブル、つまりすべての行の組み合わせのデカルト積を生成することを示しています。 これは、各テーブルの行数の積を調査する必要があるため、著しく時間がかかります。 このケースの場合は、この積が 74 × 2135 × 74 × 3872 = 45,268,558,720 行になります。 テーブルがもっと大きければ、どのくらい時間がかかっていたか簡単に想像がつきます。 
        </p><p>
          ここでの問題の 1 つは、カラムが同じ型とサイズで宣言されている場合に、MySQL はカラムに対してインデックスをより効率的に使用できることです。 このコンテキストでは、<code class="literal">VARCHAR</code> と <code class="literal">CHAR</code> は同じサイズとして宣言されている場合、それらは同じとみなされます。<code class="literal">tt.ActualPC</code> は <code class="literal">CHAR(10)</code> として宣言されており、<code class="literal">et.EMPLOYID</code> は <code class="literal">CHAR(15)</code> であるため、長さの不一致があります。 
        </p><p>
          このカラム長の不一致を修正するには、<code class="literal">ALTER TABLE</code> を使用して <code class="literal">ActualPC</code> を 10 文字から 15 文字に長くします。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE tt MODIFY ActualPC VARCHAR(15);</code></strong>
</pre><p>
          これで <code class="literal">tt.ActualPC</code> と <code class="literal">et.EMPLOYID</code> はいずれも <code class="literal">VARCHAR(15)</code> になります。 <code class="literal">EXPLAIN</code> ステートメントを再度実行すると、次の結果が生成されます。 
        </p><pre class="programlisting">table type   possible_keys key     key_len ref         rows    Extra
tt    ALL    AssignedPC,   NULL    NULL    NULL        3872    Using
             ClientID,                                         where
             ActualPC
do    ALL    PRIMARY       NULL    NULL    NULL        2135
      Range checked for each record (index map: 0x1)
et_1  ALL    PRIMARY       NULL    NULL    NULL        74
      Range checked for each record (index map: 0x1)
et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC 1
</pre><p>
          これは完全ではありませんが、はるかに改善されています。<code class="literal">rows</code> 値の積は 74 の係数分だけ少なくなります。 このバージョンは、数秒で実行します。 
        </p><p>
          2 つめの変更を実行して、<code class="literal">tt.AssignedPC = et_1.EMPLOYID</code> と <code class="literal">tt.ClientID = do.CUSTNMBR</code> の比較でのカラム長の不一致を解消できます。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE tt MODIFY AssignedPC VARCHAR(15),</code></strong>
                      <strong class="userinput"><code>MODIFY ClientID   VARCHAR(15);</code></strong>
</pre><p>
          その変更後、<code class="literal">EXPLAIN</code> は次に示す出力を生成します。
        </p><pre class="programlisting">table type   possible_keys key      key_len ref           rows Extra
et    ALL    PRIMARY       NULL     NULL    NULL          74
tt    ref    AssignedPC,   ActualPC 15      et.EMPLOYID   52   Using
             ClientID,                                         where
             ActualPC
et_1  eq_ref PRIMARY       PRIMARY  15      tt.AssignedPC 1
do    eq_ref PRIMARY       PRIMARY  15      tt.ClientID   1
</pre><p>
          この時点で、クエリーはほぼ可能なかぎり十分に最適化されています。 残りの問題は、MySQL はデフォルトで <code class="literal">tt.ActualPC</code> カラムの値が均一に分布しているものと想定しますが、<code class="literal">tt</code> テーブルにはそれが当てはまらないことです。 さいわい、MySQL にキー分布を分析するように伝えることは簡単です。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ANALYZE TABLE tt;</code></strong>
</pre><p>
          追加のインデックス情報によって、結合が完全になり、<code class="literal">EXPLAIN</code> が次の結果を生成します。
        </p><pre class="programlisting">table type   possible_keys key     key_len ref           rows Extra
tt    ALL    AssignedPC    NULL    NULL    NULL          3872 Using
             ClientID,                                        where
             ActualPC
et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC   1
et_1  eq_ref PRIMARY       PRIMARY 15      tt.AssignedPC 1
do    eq_ref PRIMARY       PRIMARY 15      tt.ClientID   1
</pre><p>
          <a class="indexterm" name="idm45661475812272"></a> <code class="literal">EXPLAIN</code> からの出力の <code class="literal">rows</code> カラムは、MySQL 結合オプティマイザからの教育を受けた推測です。 <code class="literal">rows</code> の積とクエリーが返す実際の行数を比較して、数値が実際と近いかどうかをチェックしてください。 数値がかなり異なる場合は、<code class="literal">SELECT</code> ステートメントで <code class="literal">STRAIGHT_JOIN</code> を使用し、<code class="literal">FROM</code> 句で異なる順序でテーブルを一覧表示してみるとパフォーマンスを改善できる可能性があります。 (ただし、<code class="literal">STRAIGHT_JOIN</code> では準結合変換が無効になるため、インデックスの使用が妨げられる場合があります。 <a class="xref" href="optimization.html#semijoins" title="8.2.2.1 準結合変換による IN および EXISTS サブクエリー述語の最適化">セクション8.2.2.1「準結合変換による IN および EXISTS サブクエリー述語の最適化」</a>を参照してください。) 
        </p><p>
          場合によっては、サブクエリーで <code class="literal">EXPLAIN SELECT</code> を使用するときに、データを変更するステートメントを実行できることもあります。詳細については、<a class="xref" href="sql-statements.html#derived-tables" title="13.2.11.8 導出テーブル">セクション13.2.11.8「導出テーブル」</a>を参照してください。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="explain-extended"></a>8.8.3 拡張 EXPLAIN 出力形式</h3></div></div></div><p>
        <code class="literal">EXPLAIN</code> ステートメントは、<code class="literal">EXPLAIN</code> 出力の一部ではないが、<code class="literal">EXPLAIN</code> の後に <code class="literal">SHOW WARNINGS</code> ステートメントを発行することで表示できる追加 (<span class="quote">「<span class="quote">extended</span>」</span>) 情報を生成します。 MySQL 8.0.12 では、拡張情報は <code class="literal">SELECT</code>, <code class="literal">DELETE</code>, <code class="literal">INSERT</code>, <code class="literal">REPLACE</code> および <code class="literal">UPDATE</code> ステートメントで使用できます。 8.0.12 より前のリリースでは、拡張情報は <code class="literal">SELECT</code> ステートメントでのみ使用できます。 
      </p><p>
        <code class="literal">SHOW WARNINGS</code> 出力の <code class="literal">Message</code> 値には、オプティマイザが <code class="literal">SELECT</code> ステートメント内のテーブルおよびカラム名をどのように修飾するか、書き換えおよび最適化ルールの適用後に <code class="literal">SELECT</code> がどのように見えるか、および場合によって最適化プロセスに関するその他のメモが表示されます。
      </p><p>
        <code class="literal">EXPLAIN</code> に続く <code class="literal">SHOW WARNINGS</code> ステートメントで表示可能な拡張情報は、<code class="literal">SELECT</code> ステートメントに対してのみ生成されます。 <code class="literal">SHOW WARNINGS</code> では、説明可能な他のステートメント (<code class="literal">DELETE</code>, <code class="literal">INSERT</code>, <code class="literal">REPLACE</code> および <code class="literal">UPDATE</code>) に対して空の結果が表示されます。 
      </p><p>
        次に、拡張 <code class="literal">EXPLAIN</code> 出力の例を示します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN</code></strong>
       <strong class="userinput"><code>SELECT t1.a, t1.a IN (SELECT t2.a FROM t2) FROM t1\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: t1
         type: index
possible_keys: NULL
          key: PRIMARY
      key_len: 4
          ref: NULL
         rows: 4
     filtered: 100.00
        Extra: Using index
*************************** 2. row ***************************
           id: 2
  select_type: SUBQUERY
        table: t2
         type: index
possible_keys: a
          key: a
      key_len: 5
          ref: NULL
         rows: 3
     filtered: 100.00
        Extra: Using index
2 rows in set, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select `test`.`t1`.`a` AS `a`,
         &lt;in_optimizer&gt;(`test`.`t1`.`a`,`test`.`t1`.`a` in
         ( &lt;materialize&gt; (/* select#2 */ select `test`.`t2`.`a`
         from `test`.`t2` where 1 having 1 ),
         &lt;primary_index_lookup&gt;(`test`.`t1`.`a` in
         &lt;temporary table&gt; on &lt;auto_key&gt;
         where ((`test`.`t1`.`a` = `materialized-subquery`.`a`))))) AS `t1.a
         IN (SELECT t2.a FROM t2)` from `test`.`t1`
1 row in set (0.00 sec)
</pre><p>
        <code class="literal">SHOW WARNINGS</code> によって表示されるステートメントには、クエリーの書き換えやオプティマイザのアクションに関する情報を提供する特別なマーカーが含まれることがあるため、ステートメントは必ずしも有効な SQL ではなく、実行されることを目的としていません。 出力には、オプティマイザによってとられたアクションに関する追加の SQL でない説明のメモを提供する <code class="literal">Message</code> 値のある行が含まれることもあります。 
      </p><p>
        次のリストでは、<code class="literal">SHOW WARNINGS</code> によって表示される拡張出力に表示される特殊なマーカーについて説明します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">&lt;auto_key&gt;</code>
          </p><p>
            一時テーブルの自動的に生成されるキー。
          </p></li><li class="listitem"><p>
            <code class="literal">&lt;cache&gt;(<em class="replaceable"><code>expr</code></em>)</code>
          </p><p>
            式 (スカラーサブクエリーなど) が 1 回実行され、あとで使用するために、結果の値がメモリーに保存されます。 複数の値で構成される結果の場合、一時テーブルが作成され、かわりに <code class="literal">&lt;temporary table&gt;</code> が表示されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">&lt;exists&gt;(<em class="replaceable"><code>query fragment</code></em>)</code>
          </p><p>
            サブクエリー述語は <code class="literal">EXISTS</code> 述語に変換され、サブクエリーは <code class="literal">EXISTS</code> 述語と一緒に使用できるように変換されます。
          </p></li><li class="listitem"><p>
            <code class="literal">&lt;in_optimizer&gt;(<em class="replaceable"><code>query fragment</code></em>)</code>
          </p><p>
            これは、ユーザーにとっては意味がない内部オプティマイザオブジェクトです。
          </p></li><li class="listitem"><p>
            <code class="literal">&lt;index_lookup&gt;(<em class="replaceable"><code>query fragment</code></em>)</code>
          </p><p>
            対象の行を見つけるためにインデックスルックアップを使用して、クエリーフラグメントが処理されます。
          </p></li><li class="listitem"><p>
            <code class="literal">&lt;if&gt;(<em class="replaceable"><code>condition</code></em>, <em class="replaceable"><code>expr1</code></em>, <em class="replaceable"><code>expr2</code></em>)</code>
          </p><p>
            条件が true の場合は <em class="replaceable"><code>expr1</code></em>、そうでない場合は <em class="replaceable"><code>expr2</code></em> に評価されます。
          </p></li><li class="listitem"><p>
            <code class="literal">&lt;is_not_null_test&gt;(<em class="replaceable"><code>expr</code></em>)</code>
          </p><p>
            式が <code class="literal">NULL</code> に評価されないことを確認するためのテスト。
          </p></li><li class="listitem"><p>
            <code class="literal">&lt;materialize&gt;(<em class="replaceable"><code>query fragment</code></em>)</code>
          </p><p>
            サブクエリーの実体化が使用されます。
          </p></li><li class="listitem"><p>
            <code class="literal">`materialized-subquery`.<em class="replaceable"><code>col_name</code></em></code>
          </p><p>
            サブクエリーの評価の結果を保持するために実体化された内部一時テーブル内のカラム <em class="replaceable"><code>col_name</code></em> への参照。
          </p></li><li class="listitem"><p>
            <code class="literal">&lt;primary_index_lookup&gt;(<em class="replaceable"><code>query fragment</code></em>)</code>
          </p><p>
            対象の行を見つけるために主キールックアップを使用して、クエリーフラグメントが処理されます。
          </p></li><li class="listitem"><p>
            <code class="literal">&lt;ref_null_helper&gt;(<em class="replaceable"><code>expr</code></em>)</code>
          </p><p>
            これは、ユーザーにとっては意味がない内部オプティマイザオブジェクトです。
          </p></li><li class="listitem"><p>
            <code class="literal">/* select#<em class="replaceable"><code>N</code></em> */ <em class="replaceable"><code>select_stmt</code></em></code>
          </p><p>
            <code class="literal">SELECT</code> は、<code class="literal">id</code> 値が <em class="replaceable"><code>N</code></em> の拡張されていない <code class="literal">EXPLAIN</code> 出力の行に関連付けられます。
          </p></li><li class="listitem"><p>
            <code class="literal"><em class="replaceable"><code>outer_tables</code></em> semi join (<em class="replaceable"><code>inner_tables</code></em>)</code>
          </p><p>
            準結合操作。<em class="replaceable"><code>inner_tables</code></em> には、プルされなかったテーブルが表示されます。 <a class="xref" href="optimization.html#semijoins" title="8.2.2.1 準結合変換による IN および EXISTS サブクエリー述語の最適化">セクション8.2.2.1「準結合変換による IN および EXISTS サブクエリー述語の最適化」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">&lt;temporary table&gt;</code>
          </p><p>
            これは、中間結果をキャッシュするために作成される内部一時テーブルを表します。
          </p></li></ul></div><p>
        一部のテーブルが <code class="literal">const</code> または <code class="literal">system</code> 型である場合、これらのテーブルからのカラムを含む式は、オプティマイザによって早期に評価され、表示されるステートメントに含まれません。 ただし、<code class="literal">FORMAT=JSON</code> では、一部の <code class="literal">const</code> テーブルアクセスが定数値を使用する <code class="literal">ref</code> アクセスとして表示されます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="explain-for-connection"></a>8.8.4 名前付き接続の実行計画情報の取得</h3></div></div></div><p>
        名前付き接続で実行されている説明可能なステートメントの実行計画を取得するには、次のステートメントを使用します:
      </p><pre class="programlisting">EXPLAIN [<em class="replaceable"><code>options</code></em>] FOR CONNECTION <em class="replaceable"><code>connection_id</code></em>;
</pre><p>
        <code class="literal">EXPLAIN FOR CONNECTION</code> は、特定の接続でクエリーを実行するために現在使用されている <code class="literal">EXPLAIN</code> 情報を返します。 データ (およびサポート統計) が変更されたため、同等のクエリーテキストで <code class="literal">EXPLAIN</code> を実行すると、異なる結果が生成される可能性があります。 この動作の違いは、より一時的なパフォーマンスの問題を診断する場合に役立ちます。 たとえば、あるセッションで完了までに長時間かかるステートメントを実行している場合、別のセッションで <code class="literal">EXPLAIN FOR CONNECTION</code> を使用すると、遅延の原因に関する有用な情報が得られることがあります。 
      </p><p>
        <em class="replaceable"><code>connection_id</code></em> は、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">PROCESSLIST</code> テーブルまたは <code class="literal">SHOW PROCESSLIST</code> ステートメントから取得される接続識別子です。 <code class="literal">PROCESS</code> 権限がある場合は、任意の接続の識別子を指定できます。 それ以外の場合は、独自の接続に対してのみ識別子を指定できます。 いずれの場合も、指定した接続に対するクエリーを説明するのに十分な権限が必要です。 
      </p><p>
        名前付き接続がステートメントを実行していない場合、結果は空になります。 それ以外の場合、<code class="literal">EXPLAIN FOR CONNECTION</code> は、名前付き接続で実行されているステートメントが説明可能な場合にのみ適用されます。 これには、<code class="literal">SELECT</code>, <code class="literal">DELETE</code>, <code class="literal">INSERT</code>, <code class="literal">REPLACE</code> および <code class="literal">UPDATE</code> が含まれます。 (ただし、<code class="literal">EXPLAIN FOR CONNECTION</code> は、これらのタイプのプリペアドステートメントであっても、プリペアドステートメントに対しては機能しません。) 
      </p><p>
        名前付き接続が説明可能なステートメントを実行している場合、出力はステートメント自体で <code class="literal">EXPLAIN</code> を使用して取得します。
      </p><p>
        指定された接続が説明不可能なステートメントを実行している場合は、エラーが発生します。 たとえば、<code class="literal">EXPLAIN</code> は説明できないため、現在のセッションの接続識別子に名前を付けることはできません: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT CONNECTION_ID();</code></strong>
+-----------------+
| CONNECTION_ID() |
+-----------------+
|             373 |
+-----------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>EXPLAIN FOR CONNECTION 373;</code></strong>
ERROR 1889 (HY000): EXPLAIN FOR CONNECTION command is supported
only for SELECT/UPDATE/INSERT/DELETE/REPLACE
</pre><p>
        <code class="literal">Com_explain_other</code> ステータス変数は、実行された <code class="literal">EXPLAIN FOR CONNECTION</code> ステートメントの数を示します。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="estimating-performance"></a>8.8.5 クエリーパフォーマンスの推定</h3></div></div></div><a class="indexterm" name="idm45661475681648"></a><a class="indexterm" name="idm45661475679504"></a><a class="indexterm" name="idm45661475677440"></a><p>
        ほとんどの場合、ディスクシークをカウントしてクエリーパフォーマンスを推定できます。 小さいテーブルの場合は一般に 1 回のディスクシークでレコードが見つかります (インデックスがキャッシュされている可能性が高いため)。 大きなテーブルの場合、B ツリーインデックスを使用して、それを推定できますが、行を見つけるためにこのように多くのシークが必要です。<code class="literal">log(<em class="replaceable"><code>row_count</code></em>) / log(<em class="replaceable"><code>index_block_length</code></em> / 3 * 2 / (<em class="replaceable"><code>index_length</code></em> + <em class="replaceable"><code>data_pointer_length</code></em>)) + 1</code>。 
      </p><p>
        MySQL では、インデックスブロックが通常 1,024 バイトで、データポインタは通常 4 バイトです。 3 バイトのキー値長 (<code class="literal">MEDIUMINT</code> のサイズ) の 500,000 行のテーブルの場合、この公式は <code class="literal">log(500,000)/log(1024/3*2/(3+4)) + 1</code> = <code class="literal">4</code> シークを示します。 
      </p><p>
        このインデックスには、約 500,000 * 7 * 3/2 = 5.2M バイト (2/3 の一般的なインデックスバッファー充てん率と想定して) のストレージが必要であるため、インデックスの多くをメモリーに置く可能性が高く、データを読み取り、行を見つけるために 1 つか 2 つの呼び出しだけで済みます。
      </p><p>
        ただし、書き込みについては、新しいインデックス値の配置場所を見つけるために 4 つのシークリクエスト、およびインデックスの更新と行の書き込みに通常 2 回のシークが必要になります。
      </p><p>
        前述の説明は、アプリケーションのパフォーマンスがログ <em class="replaceable"><code>N</code></em> によってゆっくりと低下することを意味しません。 OS または MySQL サーバーによってすべてがキャッシュされているかぎり、テーブルが大きくなってもほんの少し遅くなるだけです。 データがキャッシュできないほど大きくなると、アプリケーションがディスクシーク (これは log <em class="replaceable"><code>N</code></em>N ずつ増加する) によってのみ制限されるまで著しく遅くなり始めます。 これを回避するには、データの増加に合わせてキーキャッシュを増やします。 <code class="literal">MyISAM</code> テーブルでは、キーキャッシュサイズは <code class="literal">key_buffer_size</code> システム変数によって制御されます。 <a class="xref" href="server-administration.html#server-configuration" title="5.1.1 サーバーの構成">セクション5.1.1「サーバーの構成」</a>を参照してください。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="controlling-optimizer"></a>8.9 クエリーオプティマイザの制御</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#controlling-query-plan-evaluation">8.9.1 クエリー計画評価の制御</a></span></dt><dt><span class="section"><a href="optimization.html#switchable-optimizations">8.9.2 切り替え可能な最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizer-hints">8.9.3 オプティマイザヒント</a></span></dt><dt><span class="section"><a href="optimization.html#index-hints">8.9.4 インデックスヒント</a></span></dt><dt><span class="section"><a href="optimization.html#cost-model">8.9.5 オプティマイザコストモデル</a></span></dt><dt><span class="section"><a href="optimization.html#optimizer-statistics">8.9.6 オプティマイザ統計</a></span></dt></dl></div><a class="indexterm" name="idm45661475660272"></a><p>
      MySQL では、クエリー計画の評価方法、切替え可能な最適化、オプティマイザとインデックスのヒントおよびオプティマイザコストモデルに影響するシステム変数を介してオプティマイザを制御できます。
    </p><p>
      サーバーは、カラム値に関するヒストグラム統計を <code class="literal">column_statistics</code> データディクショナリテーブルに保持します (<a class="xref" href="optimization.html#optimizer-statistics" title="8.9.6 オプティマイザ統計">セクション8.9.6「オプティマイザ統計」</a> を参照)。 他のデータディクショナリテーブルと同様に、このテーブルにはユーザーは直接アクセスできません。 かわりに、データディクショナリテーブルのビューとして実装されている <code class="literal">INFORMATION_SCHEMA.COLUMN_STATISTICS</code> をクエリーすることで、ヒストグラム情報を取得できます。 <code class="literal">ANALYZE TABLE</code> ステートメントを使用してヒストグラム管理を実行することもできます。 
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="controlling-query-plan-evaluation"></a>8.9.1 クエリー計画評価の制御</h3></div></div></div><a class="indexterm" name="idm45661475651232"></a><p>
        クエリーオプティマイザのタスクは SQL クエリーを実行するために最適なプランを見つけることです。 <span class="quote">「<span class="quote">良い</span>」</span>プランと<span class="quote">「<span class="quote">悪い</span>」</span>プランのパフォーマンスの差は、桁違い (つまり、数秒に対して数時間や数日にまで) になる可能性があるため、MySQL のオプティマイザを含むほとんどのクエリーオプティマイザは、多かれ少なかれ、すべての可能なクエリー評価プランの中から最適なプランを徹底的に探します。 結合クエリーに対して、MySQL オプティマイザによって調査される可能なプランの数は、クエリーで参照されるテーブル数とともに指数関数的に増大します。 少数のテーブル (一般に 7 から 10 未満) の場合、これは問題になりません。 ただし、大きいクエリーが発行されると、クエリーの最適化に費やされる時間がサーバーのパフォーマンスの大きなボトルネックになる可能性があります。 
      </p><p>
        クエリー最適化のより柔軟な方法により、ユーザーはオプティマイザが最適なクエリー評価プランをどの程度徹底的に探すかを制御できます。 一般的な考えは、オプティマイザによって調査されるプランが少ないほど、クエリーのコンパイルに費やす時間も少なくなるということです。 一方、オプティマイザは一部のプランをスキップするため、最適なプランを見逃す可能性もあります。 
      </p><p>
        評価するプランの数に関して、オプティマイザの動作を 2 つのシステム変数を使用して制御できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">optimizer_prune_level</code> 変数は、オプティマイザに、テーブルごとにアクセスされる行数の見積もりに基づいて、特定のプランをスキップするように伝えます。 経験上、この種類の<span class="quote">「<span class="quote">学習による推測</span>」</span>は最適なプランをめったに見逃すことはなく、クエリーのコンパイル時間を劇的に短縮できます。 デフォルトでこのオプションがオン <code class="literal">optimizer_prune_level=1</code> であるのはこのためです。 ただし、オプティマイザがより適したクエリー計画を見逃したと思う場合は、クエリーのコンパイルにかなりの時間がかかるリスクを伴いますが、このオプションをオフにする (<code class="literal">optimizer_prune_level=0</code>) ことができます。 この経験則を使用しても、オプティマイザはまだ指数関数的な数のプランを探索します。 
          </p></li><li class="listitem"><p>
            <code class="literal">optimizer_search_depth</code> 変数は、オプティマイザがそれ以上拡張すべきかどうかを評価するために、不完全な各プランの<span class="quote">「<span class="quote">将来</span>」</span>をどの程度見通すかを伝えます。 <code class="literal">optimizer_search_depth</code> の値を小さくするほど、クエリーのコンパイル時間が桁違いに少なくなる可能性があります。 たとえば、12、13、またはそれ以上のテーブルのクエリーは、<code class="literal">optimizer_search_depth</code> がクエリー内のテーブル数に近い場合、コンパイルに数時間または数日間も容易に必要になることがあります。 同時に、3 か 4 に等しい <code class="literal">optimizer_search_depth</code> でコンパイルされた場合、オプティマイザは同じクエリーで 1 分以内にコンパイルできることがあります。 <code class="literal">optimizer_search_depth</code> の適切な値が不明な場合、この変数を 0 に設定することで、オプティマイザに自動的に値を決定させることができます。 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="switchable-optimizations"></a>8.9.2 切り替え可能な最適化</h3></div></div></div><a class="indexterm" name="idm45661475630192"></a><a class="indexterm" name="idm45661475628656"></a><p>
        <code class="literal">optimizer_switch</code> システム変数を使用するとオプティマイザの動作を制御できます。 その値はフラグのセットで、それぞれ対応するオプティマイザの動作を有効にするかまたは無効にするかを示す <code class="literal">on</code> または <code class="literal">off</code> の値を持ちます。 この変数はグローバル値およびセッション値を持ち、実行時に変更できます。 グローバル値のデフォルトはサーバーの起動時に設定できます。 
      </p><p>
        オプティマイザの現在のフラグセットを表示するには、変数値を選択します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@optimizer_switch\G</code></strong>
*************************** 1. row ***************************
@@optimizer_switch: index_merge=on,index_merge_union=on,
                    index_merge_sort_union=on,index_merge_intersection=on,
                    engine_condition_pushdown=on,index_condition_pushdown=on,
                    mrr=on,mrr_cost_based=on,block_nested_loop=on,
                    batched_key_access=off,materialization=on,semijoin=on,
                    loosescan=on,firstmatch=on,duplicateweedout=on,
                    subquery_materialization_cost_based=on,
                    use_index_extensions=on,condition_fanout_filter=on,
                    derived_merge=on,use_invisible_indexes=off,skip_scan=on,
                    hash_join=on,subquery_to_derived=off,
                    prefer_ordering_index=on,hypergraph_optimizer=off,
                    derived_condition_pushdown=on
1 row in set (0.00 sec)
</pre><p>
        <code class="literal">optimizer_switch</code> の値を変更するには、1 つ以上のコマンドのカンマ区切りのリストから構成される値を割り当てます。
      </p><pre class="programlisting">SET [GLOBAL|SESSION] optimizer_switch='<em class="replaceable"><code>command</code></em>[,<em class="replaceable"><code>command</code></em>]...';
</pre><p>
        各 <em class="replaceable"><code>command</code></em> 値は、次の表に示すいずれかの形式になるようにしてください。
      </p><div class="informaltable"><table summary="The syntax of the command value for SET optimizer_switch commands."><col style="width: 25%"><col style="width: 75%"><thead><tr>
            <th>コマンドの構文</th>
            <th>意味</th>
          </tr></thead><tbody><tr>
            <td><code class="literal">default</code></td>
            <td>すべての最適化をそのデフォルト値にリセットします</td>
          </tr><tr>
            <td><code class="literal"><em class="replaceable"><code>opt_name</code></em>=default</code></td>
            <td>指定した最適化をそのデフォルト値に設定します</td>
          </tr><tr>
            <td><code class="literal"><em class="replaceable"><code>opt_name</code></em>=off</code></td>
            <td>指定した最適化を無効にします</td>
          </tr><tr>
            <td><code class="literal"><em class="replaceable"><code>opt_name</code></em>=on</code></td>
            <td>指定した最適化を有効にします</td>
          </tr></tbody></table></div><p>
        <code class="literal">default</code> コマンドが存在する場合最初に実行されますが、値の中のコマンドの順序は問題ではありません。 <em class="replaceable"><code>opt_name</code></em> フラグを <code class="literal">default</code> に設定すると、そのデフォルト値が <code class="literal">on</code> または <code class="literal">off</code> のどちらであってもそれに設定されます。 値に特定の <em class="replaceable"><code>opt_name</code></em> を複数回指定することは許可されず、エラーが発生します。 値のエラーによって、割り当てがエラーを伴って失敗し、<code class="literal">optimizer_switch</code> の値が変更されないままになります。 
      </p><p>
        次のリストは、最適化戦略別にグループ化された、許可される <em class="replaceable"><code>opt_name</code></em> フラグ名を示しています:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            バッチキーアクセスフラグ
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><a name="optflag_batched-key-access"></a>
                <code class="literal">batched_key_access</code> (default <code class="literal">off</code>)
              </p><p>
                BKA 結合アルゴリズムの使用を制御します
              </p></li></ul></div><p>
            <code class="literal">batched_key_access</code> が <code class="literal">on</code> に設定されている場合に何らかの効果を持つためには、<code class="literal">mrr</code> フラグも <code class="literal">on</code> である必要があります。 現在、MRR のコスト見積もりはきわめて悲観的です。 したがって、BKA を使用するには、<code class="literal">mrr_cost_based</code> を <code class="literal">off</code> にする必要もあります。 
          </p><p>
            詳細は、<a class="xref" href="optimization.html#bnl-bka-optimization" title="8.2.1.12 Block Nested Loop 結合と Batched Key Access 結合">セクション8.2.1.12「Block Nested Loop 結合と Batched Key Access 結合」</a>を参照してください。
          </p></li><li class="listitem"><p>
            ブロックネストループフラグ
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><a name="optflag_block-nested-loop"></a>
                <code class="literal">block_nested_loop</code> (default <code class="literal">on</code>)
              </p><p>
                BNL 結合アルゴリズムの使用を制御します MySQL 8.0.18 以降では、<code class="literal">BNL</code> および <code class="literal">NO_BNL</code> オプティマイザヒントと同様に、ハッシュ結合の使用も制御します。 MySQL 8.0.20 以降では、ブロックネストループのサポートは MySQL サーバーから削除され、このフラグはハッシュ結合の使用のみを制御します。 
              </p></li></ul></div><p>
            詳細は、<a class="xref" href="optimization.html#bnl-bka-optimization" title="8.2.1.12 Block Nested Loop 結合と Batched Key Access 結合">セクション8.2.1.12「Block Nested Loop 結合と Batched Key Access 結合」</a>を参照してください。
          </p></li><li class="listitem"><p>
            条件フィルタリングフラグ
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><a name="optflag_condition-fanout-filter"></a>
                <code class="literal">condition_fanout_filter</code> (default <code class="literal">on</code>)
              </p><p>
                条件フィルタリングの使用を制御します。
              </p></li></ul></div><p>
            詳細は、<a class="xref" href="optimization.html#condition-filtering" title="8.2.1.13 条件フィルタ">セクション8.2.1.13「条件フィルタ」</a>を参照してください。
          </p></li><li class="listitem"><p>
            導出条件プッシュダウンフラグ
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><a name="optflag_derived-condition-pushdown"></a>
                <code class="literal">derived_condition_pushdown</code> (default <code class="literal">on</code>)
              </p><p>
                導出条件プッシュダウンを制御します。
              </p></li></ul></div><p>
            詳細は、<a class="xref" href="optimization.html#derived-condition-pushdown-optimization" title="8.2.2.5 導出条件プッシュダウン最適化">セクション8.2.2.5「導出条件プッシュダウン最適化」</a>を参照してください
          </p></li><li class="listitem"><p>
            導出テーブルマージフラグ
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><a name="optflag_derived-merge"></a>
                <code class="literal">derived_merge</code> (default <code class="literal">on</code>)
              </p><p>
                導出テーブルおよびビューの外部クエリーブロックへのマージを制御します。
              </p></li></ul></div><p>
            <code class="literal">derived_merge</code> フラグは、オプティマイザが導出テーブル、ビュー参照および共通テーブル式を外部クエリーブロックにマージしようとするかどうかを制御します。ただし、他のルールがマージを妨げることはないと想定しています。たとえば、ビューの <code class="literal">ALGORITHM</code> ディレクティブが <code class="literal">derived_merge</code> 設定より優先されます。 デフォルトでは、マージを有効にするフラグは <code class="literal">on</code> です。 
          </p><p>
            詳細は、<a class="xref" href="optimization.html#derived-table-optimization" title="8.2.2.4 マージまたは実体化を使用した導出テーブル、ビュー参照および共通テーブル式の最適化">セクション8.2.2.4「マージまたは実体化を使用した導出テーブル、ビュー参照および共通テーブル式の最適化」</a>を参照してください。
          </p></li><li class="listitem"><p>
            エンジン条件プッシュダウンフラグ
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><a name="optflag_engine-condition-pushdown"></a>
                <code class="literal">engine_condition_pushdown</code> (default <code class="literal">on</code>)
              </p><p>
                エンジンコンディションプッシュダウンを制御します
              </p></li></ul></div><p>
            詳細は、<a class="xref" href="optimization.html#engine-condition-pushdown-optimization" title="8.2.1.5 エンジンコンディションプッシュダウンの最適化">セクション8.2.1.5「エンジンコンディションプッシュダウンの最適化」</a>を参照してください。
          </p></li><li class="listitem"><p>
            ハッシュ結合フラグ
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><a name="optflag_hash-join"></a>
                <code class="literal">hash_join</code> (default <code class="literal">on</code>)
              </p><p>
                ハッシュ結合を制御します (MySQL 8.0.18 のみ。MySQL 8.0.19 以降では影響しません)。
              </p></li></ul></div><p>
            詳細は、<a class="xref" href="optimization.html#hash-joins" title="8.2.1.4 ハッシュ結合の最適化">セクション8.2.1.4「ハッシュ結合の最適化」</a>を参照してください。
          </p></li><li class="listitem"><p>
            インデックス条件プッシュダウンフラグ
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><a name="optflag_index-condition-pushdown"></a>
                <code class="literal">index_condition_pushdown</code> (default <code class="literal">on</code>)
              </p><p>
                インデックスコンディションプッシュダウンを制御します
              </p></li></ul></div><p>
            詳細は、<a class="xref" href="optimization.html#index-condition-pushdown-optimization" title="8.2.1.6 インデックスコンディションプッシュダウンの最適化">セクション8.2.1.6「インデックスコンディションプッシュダウンの最適化」</a>を参照してください。
          </p></li><li class="listitem"><p>
            インデックス拡張フラグ
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><a name="optflag_use-index-extensions"></a>
                <code class="literal">use_index_extensions</code> (default <code class="literal">on</code>)
              </p><p>
                インデックス拡張の使用を制御します
              </p></li></ul></div><p>
            詳細は、<a class="xref" href="optimization.html#index-extensions" title="8.3.10 インデックス拡張の使用">セクション8.3.10「インデックス拡張の使用」</a>を参照してください。
          </p></li><li class="listitem"><p>
            インデックスマージフラグ
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><a name="optflag_index-merge"></a>
                <code class="literal">index_merge</code> (default <code class="literal">on</code>)
              </p><p>
                すべてのインデックスマージ最適化を制御します
              </p></li><li class="listitem"><p><a name="optflag_index-merge-intersection"></a>
                <code class="literal">index_merge_intersection</code> (default <code class="literal">on</code>)
              </p><p>
                インデックスマージ共通集合アクセス最適化を制御します
              </p></li><li class="listitem"><p><a name="optflag_index-merge-sort-union"></a>
                <code class="literal">index_merge_sort_union</code> (default <code class="literal">on</code>)
              </p><p>
                インデックスマージソート和集合アクセス最適化を制御します
              </p></li><li class="listitem"><p><a name="optflag_index-merge-union"></a>
                <code class="literal">index_merge_union</code> (default <code class="literal">on</code>)
              </p><p>
                インデックスマージ和集合アクセス最適化を制御します
              </p></li></ul></div><p>
            詳細については、<a class="xref" href="optimization.html#index-merge-optimization" title="8.2.1.3 インデックスマージの最適化">セクション8.2.1.3「インデックスマージの最適化」</a>を参照してください。
          </p></li><li class="listitem"><p>
            インデックス可視性フラグ
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><a name="optflag_use-invisible-indexes"></a>
                <code class="literal">use_invisible_indexes</code> (default <code class="literal">off</code>)
              </p><p>
                不可視インデックスの使用を制御します。
              </p></li></ul></div><p>
            詳細は、<a class="xref" href="optimization.html#invisible-indexes" title="8.3.12 不可視のインデックス">セクション8.3.12「不可視のインデックス」</a>を参照してください。
          </p></li><li class="listitem"><p>
            制限最適化フラグ
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><a name="optflag_prefer-ordering-index"></a>
                <code class="literal">prefer_ordering_index</code> (default <code class="literal">on</code>)
              </p><p>
                <code class="literal">LIMIT</code> 句を含む <code class="literal">ORDER BY</code> または <code class="literal">GROUP BY</code> を持つクエリーの場合に、オプティマイザが順序付けされていないインデックス、filesort またはその他の最適化のかわりに順序付けられたインデックスを使用しようとするかどうかを制御します。 この最適化は、オプティマイザがこの最適化を使用するとクエリーの実行速度が速くなると判断するたびに、デフォルトで実行されます。 
              </p><p>
                この決定を行うアルゴリズムではすべての同義のケースを処理できないため (データの分散が常に均一であるか、それほど均一でないことが前提となります)、この最適化が望ましくない場合があります。 MySQL 8.0.21 より前は、この最適化を無効にすることはできませんが、MySQL 8.0.21 以降ではデフォルトの動作のままですが、<code class="literal">prefer_ordering_index</code> フラグを <code class="literal">off</code> に設定することで無効にできます。 
              </p></li></ul></div><p>
            詳細および例については、<a class="xref" href="optimization.html#limit-optimization" title="8.2.1.19 LIMIT クエリーの最適化">セクション8.2.1.19「LIMIT クエリーの最適化」</a>を参照してください。
          </p></li><li class="listitem"><p>
            複数範囲検針フラグ
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><a name="optflag_mrr"></a>
                <code class="literal">mrr</code> (default <code class="literal">on</code>)
              </p><p>
                Multi-Range Read 戦略を制御します
              </p></li><li class="listitem"><p><a name="optflag_mrr-cost-based"></a>
                <code class="literal">mrr_cost_based</code> (default <code class="literal">on</code>)
              </p><p>
                <code class="literal">mrr=on</code> の場合にコストベースの MRR の使用を制御します
              </p></li></ul></div><p>
            詳細は、<a class="xref" href="optimization.html#mrr-optimization" title="8.2.1.11 Multi-Range Read の最適化">セクション8.2.1.11「Multi-Range Read の最適化」</a>を参照してください。
          </p></li><li class="listitem"><p>
            準結合フラグ
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><a name="optflag_duplicateweedout"></a>
                <code class="literal">duplicateweedout</code> (default <code class="literal">on</code>)
              </p><p>
                準結合重複除去ストラテジを制御します。
              </p></li><li class="listitem"><p><a name="optflag_firstmatch"></a>
                <code class="literal">firstmatch</code> (default <code class="literal">on</code>)
              </p><p>
                準結合 FirstMatch 戦略を制御します。
              </p></li><li class="listitem"><p><a name="optflag_loosescan"></a>
                <code class="literal">loosescan</code> (default <code class="literal">on</code>)
              </p><p>
                準結合 LooseScan 戦略を制御します (Loose Index Scan for <code class="literal">GROUP BY</code> と混同しないでください)。
              </p></li><li class="listitem"><p><a name="optflag_semijoin"></a>
                <code class="literal">semijoin</code> (default <code class="literal">on</code>)
              </p><p>
                すべての準結合方針を制御します。
              </p><p>
                MySQL 8.0.17 以降では、これはアンチ結合の最適化にも適用されます。
              </p></li></ul></div><p>
            <code class="literal">semijoin</code>, <code class="literal">firstmatch</code>, <code class="literal">loosescan</code> および <code class="literal">duplicateweedout</code> フラグを使用すると、準結合戦略を制御できます。 <code class="literal">semijoin</code> フラグは、準結合を使用するかどうかを制御します。 <code class="literal">on</code> に設定されている場合、<code class="literal">firstmatch</code> および <code class="literal">loosescan</code> フラグを使用すると、許可された準結合戦略をより細かく制御できます。 
          </p><p>
            <code class="literal">duplicateweedout</code> 準結合戦略が無効になっている場合は、他のすべての適用可能な戦略も無効にしないかぎり、使用されません。
          </p><p>
            <code class="literal">semijoin</code> と <code class="literal">materialization</code> の両方が <code class="literal">on</code> の場合、準結合でも実体化が使用されます (該当する場合)。 これらのフラグはデフォルトで <code class="literal">on</code> です。 
          </p><p>
            詳細は、<a class="xref" href="optimization.html#semijoins" title="8.2.2.1 準結合変換による IN および EXISTS サブクエリー述語の最適化">セクション8.2.2.1「準結合変換による IN および EXISTS サブクエリー述語の最適化」</a>を参照してください。
          </p></li><li class="listitem"><p>
            スキャンフラグのスキップ
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><a name="optflag_skip-scan"></a>
                <code class="literal">skip_scan</code> (default <code class="literal">on</code>)
              </p><p>
                スキップスキャンアクセス方法の使用を制御します。
              </p></li></ul></div><p>
            詳細は、<a class="xref" href="optimization.html#range-access-skip-scan" title="スキャン範囲アクセス方法のスキップ">スキャン範囲アクセス方法のスキップ</a>を参照してください。
          </p></li><li class="listitem"><p>
            サブクエリー実体化フラグ
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><a name="optflag_materialization"></a>
                <code class="literal">materialization</code> (default <code class="literal">on</code>)
              </p><p>
                実体化 (準結合実体化を含む) を制御します。
              </p></li><li class="listitem"><p><a name="optflag_subquery-materialization-cost-based"></a>
                <code class="literal">subquery_materialization_cost_based</code> (default <code class="literal">on</code>)
              </p><p>
                原価ベースの実体化の選択を使用します。
              </p></li></ul></div><p>
            <code class="literal">materialization</code> フラグはサブクエリー実体化を使用するかどうかを制御します。 <code class="literal">semijoin</code> と <code class="literal">materialization</code> の両方が <code class="literal">on</code> の場合、準結合でも実体化が使用されます (該当する場合)。 これらのフラグはデフォルトで <code class="literal">on</code> です。 
          </p><p>
            <code class="literal">subquery_materialization_cost_based</code> フラグを使用すると、サブクエリー実体化と <code class="literal">IN</code> から <code class="literal">EXISTS</code> へのサブクエリー変換の選択を制御できます。 フラグが <code class="literal">on</code> (デフォルト) の場合、オプティマイザはサブクエリー実体化と <code class="literal">IN</code>- から -<code class="literal">EXISTS</code> サブクエリー変換 (いずれかの方法を使用できる場合) の間でコストベースの選択を実行します。 フラグが <code class="literal">off</code> の場合、オプティマイザは <code class="literal">IN</code> から <code class="literal">EXISTS</code> へのサブクエリー変換よりもサブクエリーの実体化を選択します。 
          </p><p>
            詳細は、<a class="xref" href="optimization.html#subquery-optimization" title="8.2.2 サブクエリー、導出テーブル、ビュー参照および共通テーブル式の最適化">セクション8.2.2「サブクエリー、導出テーブル、ビュー参照および共通テーブル式の最適化」</a>を参照してください。
          </p></li><li class="listitem"><p>
            サブクエリー変換フラグ
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><a name="optflag_subquery-to-derived"></a>
                <code class="literal">subquery_to_derived</code> (default <code class="literal">off</code>)
              </p><p>
                MySQL 8.0.21 以降、オプティマイザは多くの場合、<code class="literal">SELECT</code>, <code class="literal">WHERE</code>, <code class="literal">JOIN</code> または <code class="literal">HAVING</code> 句のスカラーサブクエリーを導出テーブルの左外部結合に変換できます。 (導出テーブルの NULL 値可能性によっては、内部結合にさらに簡略化される場合があります。) これは、次の条件を満たすサブクエリーに対して実行できます: 
              </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                    サブクエリーでは、<code class="literal">RAND()</code> などの非決定的関数は使用されません。
                  </p></li><li class="listitem"><p>
                    サブクエリーは、<code class="literal">MIN()</code> または <code class="literal">MAX()</code> を使用するようにリライトできる <code class="literal">ANY</code> または <code class="literal">ALL</code> サブクエリーではありません。
                  </p></li><li class="listitem"><p>
                    親クエリーはユーザー変数を設定しません。リライトすると実行順序に影響する可能性があるため、同じクエリーで変数に複数回アクセスすると、予期しない結果が発生する可能性があります。
                  </p></li><li class="listitem"><p>
                    サブクエリーは相関付けしないでください。つまり、外部クエリーのテーブルからカラムを参照したり、外部クエリーで評価される集計を含むことはできません。
                  </p></li></ul></div><p>
                MySQL 8.0.22 より前は、サブクエリーに <code class="literal">GROUP BY</code> 句を含めることはできませんでした。
              </p><p>
                この最適化は、<code class="literal">GROUP BY</code> を含まない <code class="literal">IN</code>, <code class="literal">NOT IN</code>, <code class="literal">EXISTS</code> または <code class="literal">NOT EXISTS</code> の引数であるテーブルサブクエリーにも適用できます。
              </p><p>
                このフラグのデフォルト値は <code class="literal">off</code> ですが、ほとんどの場合、この最適化を有効にしてもパフォーマンスが著しく向上することはありません (多くの場合、クエリーの実行速度が遅くなることもあります)。ただし、<code class="literal">subquery_to_derived</code> フラグを <code class="literal">on</code> に設定することで最適化を有効にできます。 主にテストで使用することを目的としています。 
              </p><p>
                スカラーサブクエリーを使用する例:
              </p><pre class="programlisting">d
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1(a INT);</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t2(a INT);</code></strong>

mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES ROW(1), ROW(2), ROW(3), ROW(4);</code></strong>

mysql&gt; <strong class="userinput"><code>INSERT INTO t2 VALUES ROW(1), ROW(2);</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT * FROM t1</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE t1.a &gt; (SELECT COUNT(a) FROM t2);</code></strong>
+------+
| a    |
+------+
|    3 |
|    4 |
+------+

mysql&gt; <strong class="userinput"><code>SELECT @@optimizer_switch LIKE '%subquery_to_derived=off%';</code></strong>
+-----------------------------------------------------+
| @@optimizer_switch LIKE '%subquery_to_derived=off%' |
+-----------------------------------------------------+
|                                                   1 |
+-----------------------------------------------------+

mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM t1 WHERE t1.a &gt; (SELECT COUNT(a) FROM t2)\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: t1
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 4
     filtered: 33.33
        Extra: Using where
*************************** 2. row ***************************
           id: 2
  select_type: SUBQUERY
        table: t2
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 2
     filtered: 100.00
        Extra: NULL

mysql&gt; <strong class="userinput"><code>SET @@optimizer_switch='subquery_to_derived=on';</code></strong>


mysql&gt; <strong class="userinput"><code>SELECT @@optimizer_switch LIKE '%subquery_to_derived=off%';</code></strong>
+-----------------------------------------------------+
| @@optimizer_switch LIKE '%subquery_to_derived=off%' |
+-----------------------------------------------------+
|                                                   0 |
+-----------------------------------------------------+

mysql&gt; <strong class="userinput"><code>SELECT @@optimizer_switch LIKE '%subquery_to_derived=on%';</code></strong>
+----------------------------------------------------+
| @@optimizer_switch LIKE '%subquery_to_derived=on%' |
+----------------------------------------------------+
|                                                  1 |
+----------------------------------------------------+

mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM t1 WHERE t1.a &gt; (SELECT COUNT(a) FROM t2)\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: &lt;derived2&gt;
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: PRIMARY
        table: t1
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 4
     filtered: 33.33
        Extra: Using where; Using join buffer (hash join)
*************************** 3. row ***************************
           id: 2
  select_type: DERIVED
        table: t2
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 2
     filtered: 100.00
        Extra: NULL
</pre><p>
                2 番目の <code class="literal">EXPLAIN</code> ステートメントの直後に <code class="literal">SHOW WARNINGS</code> を実行するとわかるように、最適化を有効にすると、クエリー <code class="literal">SELECT * FROM t1 WHERE t1.a &gt; (SELECT COUNT(a) FROM t2)</code> は次に示すような形式でリライトされます:
              </p><pre class="programlisting">SELECT t1.a FROM t1
    JOIN  ( SELECT COUNT(t2.a) AS c FROM t2 ) AS d
            WHERE t1.a &gt; d.c;
</pre><p>
                <code class="literal">IN (<em class="replaceable"><code>subquery</code></em>)</code> でクエリーを使用する例:
              </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>DROP TABLE IF EXISTS t1, t2;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (a INT, b INT);</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (a INT, b INT);</code></strong>

mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES ROW(1,10), ROW(2,20), ROW(3,30);</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t2</code></strong>
    -&gt;    <strong class="userinput"><code>VALUES ROW(1,10), ROW(2,20), ROW(3,30), ROW(1,110), ROW(2,120), ROW(3,130);</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT * FROM t1</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE   t1.b &lt; 0</code></strong>
    -&gt;             <strong class="userinput"><code>OR</code></strong>
    -&gt;             <strong class="userinput"><code>t1.a IN (SELECT t2.a + 1 FROM t2);</code></strong>
+------+------+
| a    | b    |
+------+------+
|    2 |   20 |
|    3 |   30 |
+------+------+

mysql&gt; <strong class="userinput"><code>SET @@optimizer_switch="subquery_to_derived=off";</code></strong>

mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM t1</code></strong>
    -&gt;             <strong class="userinput"><code>WHERE   t1.b &lt; 0</code></strong>
    -&gt;                     <strong class="userinput"><code>OR</code></strong>
    -&gt;                     <strong class="userinput"><code>t1.a IN (SELECT t2.a + 1 FROM t2)\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: t1
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 3
     filtered: 100.00
        Extra: Using where
*************************** 2. row ***************************
           id: 2
  select_type: DEPENDENT SUBQUERY
        table: t2
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 6
     filtered: 100.00
        Extra: Using where

mysql&gt; <strong class="userinput"><code>SET @@optimizer_switch="subquery_to_derived=on";</code></strong>

mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM t1</code></strong>
    -&gt;             <strong class="userinput"><code>WHERE   t1.b &lt; 0</code></strong>
    -&gt;                     <strong class="userinput"><code>OR</code></strong>
    -&gt;                     <strong class="userinput"><code>t1.a IN (SELECT t2.a + 1 FROM t2)\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: t1
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 3
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: PRIMARY
        table: &lt;derived2&gt;
   partitions: NULL
         type: ref
possible_keys: &lt;auto_key0&gt;
          key: &lt;auto_key0&gt;
      key_len: 9
          ref: std2.t1.a
         rows: 2
     filtered: 100.00
        Extra: Using where; Using index
*************************** 3. row ***************************
           id: 2
  select_type: DERIVED
        table: t2
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 6
     filtered: 100.00
        Extra: Using temporary
</pre><p>
                このクエリーで <code class="literal">EXPLAIN</code> を実行した後の <code class="literal">SHOW WARNINGS</code> の結果のチェックおよび簡略化は、<code class="literal">subquery_to_derived</code> フラグが有効になっている場合、<code class="literal">SELECT * FROM t1 WHERE t1.b &lt; 0 OR t1.a IN (SELECT t2.a + 1 FROM t2)</code> が次に示すような形式でリライトされることを示しています:
              </p><pre class="programlisting">SELECT a, b FROM t1
    LEFT JOIN (SELECT DISTINCT a + 1 AS e FROM t2) d
    ON t1.a = d.e
    WHERE   t1.b &lt; 0
            OR
            d.e IS NOT NULL;
</pre><p>
                例:<code class="literal">EXISTS (<em class="replaceable"><code>subquery</code></em>)</code> と前述の例と同じテーブルおよびデータを使用したクエリーを使用します:
              </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM t1</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE   t1.b &lt; 0</code></strong>
    -&gt;             <strong class="userinput"><code>OR</code></strong>
    -&gt;             <strong class="userinput"><code>EXISTS(SELECT * FROM t2 WHERE t2.a = t1.a + 1);</code></strong>
+------+------+
| a    | b    |
+------+------+
|    1 |   10 |
|    2 |   20 |
+------+------+

mysql&gt; <strong class="userinput"><code>SET @@optimizer_switch="subquery_to_derived=off";</code></strong>

mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM t1</code></strong>
    -&gt;             <strong class="userinput"><code>WHERE   t1.b &lt; 0</code></strong>
    -&gt;                     <strong class="userinput"><code>OR</code></strong>
    -&gt;                     <strong class="userinput"><code>EXISTS(SELECT * FROM t2 WHERE t2.a = t1.a + 1)\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: t1
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 3
     filtered: 100.00
        Extra: Using where
*************************** 2. row ***************************
           id: 2
  select_type: DEPENDENT SUBQUERY
        table: t2
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 6
     filtered: 16.67
        Extra: Using where

mysql&gt; <strong class="userinput"><code>SET @@optimizer_switch="subquery_to_derived=on";</code></strong>

mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM t1</code></strong>
    -&gt;             <strong class="userinput"><code>WHERE   t1.b &lt; 0</code></strong>
    -&gt;                     <strong class="userinput"><code>OR</code></strong>
    -&gt;                     <strong class="userinput"><code>EXISTS(SELECT * FROM t2 WHERE t2.a = t1.a + 1)\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: t1
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 3
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: PRIMARY
        table: &lt;derived2&gt;
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 6
     filtered: 100.00
        Extra: Using where; Using join buffer (hash join)
*************************** 3. row ***************************
           id: 2
  select_type: DERIVED
        table: t2
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 6
     filtered: 100.00
        Extra: Using temporary
</pre><p>
                <code class="literal">subquery_to_derived</code> が有効になっているときに、クエリー <code class="literal">SELECT * FROM t1 WHERE t1.b &lt; 0 OR EXISTS(SELECT * FROM t2 WHERE t2.a = t1.a + 1)</code> で <code class="literal">EXPLAIN</code> を実行した後に <code class="literal">SHOW WARNINGS</code> を実行し、結果の 2 行目を簡略化すると、次のような形式でリライトされていることがわかります:
              </p><pre class="programlisting">SELECT a, b FROM t1
LEFT JOIN (SELECT DISTINCT 1 AS e1, t2.a AS e2 FROM t2) d
ON t1.a + 1 = d.e2
WHERE   t1.b &lt; 0
        OR
        d.e1 IS NOT NULL;
</pre><p>
                詳細は、<a class="xref" href="optimization.html#derived-table-optimization" title="8.2.2.4 マージまたは実体化を使用した導出テーブル、ビュー参照および共通テーブル式の最適化">セクション8.2.2.4「マージまたは実体化を使用した導出テーブル、ビュー参照および共通テーブル式の最適化」</a>、<a class="xref" href="optimization.html#limit-optimization" title="8.2.1.19 LIMIT クエリーの最適化">セクション8.2.1.19「LIMIT クエリーの最適化」</a> および <a class="xref" href="optimization.html#semijoins" title="8.2.2.1 準結合変換による IN および EXISTS サブクエリー述語の最適化">セクション8.2.2.1「準結合変換による IN および EXISTS サブクエリー述語の最適化」</a> を参照してください。
              </p></li></ul></div></li></ul></div><p>
        <code class="literal">optimizer_switch</code> に値を割り当てると、指定されていないフラグはそれらの現在の値を維持します。 これにより、ほかの動作に影響を与えることなく、単一のステートメントで特定のオプティマイザの動作を有効または無効にできます。 ステートメントは、ほかの存在するオプティマイザフラグやそれらの値に依存しません。 すべてのインデックスマージ最適化が有効になっているとします。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@optimizer_switch\G</code></strong>
*************************** 1. row ***************************
@@optimizer_switch: index_merge=on,index_merge_union=on,
                    index_merge_sort_union=on,index_merge_intersection=on,
                    engine_condition_pushdown=on,index_condition_pushdown=on,
                    mrr=on,mrr_cost_based=on,block_nested_loop=on,
                    batched_key_access=off,materialization=on,semijoin=on,
                    loosescan=on, firstmatch=on,
                    subquery_materialization_cost_based=on,
                    use_index_extensions=on,condition_fanout_filter=on,
                    derived_merge=on,use_invisible_indexes=off,skip_scan=on,
                    hash_join=on,subquery_to_derived=off,
                    prefer_ordering_index=on
</pre><p>
        サーバーが特定のクエリーに対して Index Merge Union または Index Merge Sort-Union アクセス方法を使用しており、オプティマイザがそれらなしでパフォーマンスを向上できるかどうかを確認する場合は、次のように変数値を設定します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET optimizer_switch='index_merge_union=off,index_merge_sort_union=off';</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT @@optimizer_switch\G</code></strong>
*************************** 1. row ***************************
@@optimizer_switch: index_merge=on,index_merge_union=off,
                    index_merge_sort_union=off,index_merge_intersection=on,
                    engine_condition_pushdown=on,index_condition_pushdown=on,
                    mrr=on,mrr_cost_based=on,block_nested_loop=on,
                    batched_key_access=off,materialization=on,semijoin=on,
                    loosescan=on, firstmatch=on,
                    subquery_materialization_cost_based=on,
                    use_index_extensions=on,condition_fanout_filter=on,
                    derived_merge=on,use_invisible_indexes=off,skip_scan=on,
                    hash_join=on,subquery_to_derived=off,
                    prefer_ordering_index=on
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizer-hints"></a>8.9.3 オプティマイザヒント</h3></div></div></div><a class="indexterm" name="idm45661475307888"></a><a class="indexterm" name="idm45661475306432"></a><p>
        オプティマイザ戦略を制御する方法の 1 つは、<code class="literal">optimizer_switch</code> システム変数を設定することです (<a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2 切り替え可能な最適化">セクション8.9.2「切り替え可能な最適化」</a> を参照)。 この変数を変更すると、後続のすべてのクエリーの実行に影響します。あるクエリーと別のクエリーに影響を与えるには、各クエリーの前に <code class="literal">optimizer_switch</code> を変更する必要があります。 
      </p><p>
        オプティマイザを制御する別の方法は、オプティマイザヒントを使用することです。オプティマイザヒントは、個々のステートメント内で指定できます。 オプティマイザヒントはステートメントごとに適用されるため、<code class="literal">optimizer_switch</code> を使用して達成できるよりも詳細にステートメントの実行計画を制御できます。 たとえば、ステートメントのあるテーブルに対して最適化を有効にし、別のテーブルに対して最適化を無効にできます。 ステートメント内のヒントは、<code class="literal">optimizer_switch</code> フラグよりも優先されます。 
      </p><p>
        例:
      </p><pre class="programlisting">SELECT /*+ NO_RANGE_OPTIMIZATION(t3 PRIMARY, f2_idx) */ f1
  FROM t3 WHERE f1 &gt; 30 AND f1 &lt; 33;
SELECT /*+ BKA(t1) NO_BKA(t2) */ * FROM t1 INNER JOIN t2 WHERE ...;
SELECT /*+ NO_ICP(t1, t2) */ * FROM t1 INNER JOIN t2 WHERE ...;
SELECT /*+ SEMIJOIN(FIRSTMATCH, LOOSESCAN) */ * FROM t1 ...;
EXPLAIN SELECT /*+ NO_ICP(t1) */ * FROM t1 WHERE ...;
SELECT /*+ MERGE(dt) */ * FROM (SELECT * FROM t1) AS dt;
INSERT /*+ SET_VAR(foreign_key_checks=OFF) */ INTO t2 VALUES(2);
</pre><p>
        ここで説明するオプティマイザヒントは、<a class="xref" href="optimization.html#index-hints" title="8.9.4 インデックスヒント">セクション8.9.4「インデックスヒント」</a> で説明されているインデックスヒントとは異なります。 オプティマイザヒントとインデックスヒントは、別々に、または一緒に使用できます。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#optimizer-hints-overview" title="オプティマイザヒントの概要">オプティマイザヒントの概要</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#optimizer-hints-syntax" title="オプティマイザヒントの構文">オプティマイザヒントの構文</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#optimizer-hints-join-order" title="結合順序オプティマイザヒント">結合順序オプティマイザヒント</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#optimizer-hints-table-level" title="テーブルレベルのオプティマイザヒント">テーブルレベルのオプティマイザヒント</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#optimizer-hints-index-level" title="インデックスレベルのオプティマイザヒント">インデックスレベルのオプティマイザヒント</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#optimizer-hints-subquery" title="サブクエリーオプティマイザヒント">サブクエリーオプティマイザヒント</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#optimizer-hints-execution-time" title="ステートメント実行時オプティマイザヒント">ステートメント実行時オプティマイザヒント</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#optimizer-hints-set-var" title="可変設定のヒント構文">可変設定のヒント構文</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#optimizer-hints-resource-group" title="リソースグループのヒント構文">リソースグループのヒント構文</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#optimizer-hints-query-block-naming" title="クエリーブロックのネーミングのためのオプティマイザヒント">クエリーブロックのネーミングのためのオプティマイザヒント</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="optimizer-hints-overview"></a>オプティマイザヒントの概要</h4></div></div></div><p>
          オプティマイザヒントは、様々な有効範囲レベルで適用されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              グローバル: ヒントはステートメント全体に影響
            </p></li><li class="listitem"><p>
              クエリーブロック: ヒントは、ステートメント内の特定のクエリーブロックに影響
            </p></li><li class="listitem"><p>
              Table-level: ヒントは、クエリーブロック内の特定のテーブルに影響
            </p></li><li class="listitem"><p>
              Index-level: ヒントは、テーブル内の特定のインデックスに影響
            </p></li></ul></div><p>
          次のテーブルに、使用可能なオプティマイザヒント、それらが影響するオプティマイザ戦略、およびそれらが適用される有効範囲をまとめます。 詳細は後で説明します。 
        </p><div class="table"><a name="optimizer-hints-table"></a><p class="title"><b>表 8.2 使用可能なオプティマイザヒント</b></p><div class="table-contents"><table summary="Optimizer hint names, descriptions, and contexts in which they apply."><col style="width: 30%"><col style="width: 40%"><col style="width: 30%"><thead><tr>
              <th scope="col">ヒント名</th>
              <th scope="col">説明</th>
              <th scope="col">適用可能なスコープ</th>
            </tr></thead><tbody><tr>
              <th scope="row"><code class="literal">BKA</code>, <code class="literal">NO_BKA</code></th>
              <td>バッチキーアクセス結合処理に影響</td>
              <td>クエリーブロック、テーブル</td>
            </tr><tr>
              <th scope="row"><code class="literal">BNL</code>, <code class="literal">NO_BNL</code></th>
              <td>MySQL 8.0.20 より前: Block Nested-Loop 結合処理 (MySQL 8.0.18 以降) に影響: ハッシュ結合の最適化にも影響します (MySQL 8.0.20 以降): ハッシュ結合の最適化にのみ影響</td>
              <td>クエリーブロック、テーブル</td>
            </tr><tr>
              <th scope="row"><code class="literal">DERIVED_CONDITION_PUSHDOWN</code>, <code class="literal">NO_DERIVED_CONDITION_PUSHDOWN</code></th>
              <td>実体化導出テーブルに対する導出条件プッシュダウン最適化の使用または無視 (MySQL 8.0.22 で追加)</td>
              <td>クエリーブロック、テーブル</td>
            </tr><tr>
              <th scope="row"><code class="literal">GROUP_INDEX</code>, <code class="literal">NO_GROUP_INDEX</code></th>
              <td><code class="literal">GROUP BY</code> 操作でのインデックススキャンのための指定したインデックスの使用または無視 (MySQL 8.0.20 で追加)</td>
              <td>インデックス</td>
            </tr><tr>
              <th scope="row"><code class="literal">HASH_JOIN</code>, <code class="literal">NO_HASH_JOIN</code></th>
              <td>ハッシュ結合の最適化に影響 (MySQL 8.0.18 のみ)</td>
              <td>クエリーブロック、テーブル</td>
            </tr><tr>
              <th scope="row"><code class="literal">INDEX</code>, <code class="literal">NO_INDEX</code></th>
              <td><code class="literal">JOIN_INDEX</code>、<code class="literal">GROUP_INDEX</code> および <code class="literal">ORDER_INDEX</code> の組合せとして、または <code class="literal">NO_JOIN_INDEX</code>、<code class="literal">NO_GROUP_INDEX</code> および <code class="literal">NO_ORDER_INDEX</code> (MySQL 8.0.20 に追加) の組合せとして機能</td>
              <td>インデックス</td>
            </tr><tr>
              <th scope="row"><code class="literal">INDEX_MERGE</code>, <code class="literal">NO_INDEX_MERGE</code></th>
              <td>インデックスマージの最適化に影響</td>
              <td>Table、インデックス</td>
            </tr><tr>
              <th scope="row"><code class="literal">JOIN_FIXED_ORDER</code></th>
              <td>結合順序に <code class="literal">FROM</code> 句で指定されたテーブルの順序を使用</td>
              <td>クエリーブロック</td>
            </tr><tr>
              <th scope="row"><code class="literal">JOIN_INDEX</code>, <code class="literal">NO_JOIN_INDEX</code></th>
              <td>任意のアクセス方法に指定されたインデックスを使用または無視します (MySQL 8.0.20 で追加)</td>
              <td>インデックス</td>
            </tr><tr>
              <th scope="row"><code class="literal">JOIN_ORDER</code></th>
              <td>結合順序のヒントに指定されたテーブルの順序を使用</td>
              <td>クエリーブロック</td>
            </tr><tr>
              <th scope="row"><code class="literal">JOIN_PREFIX</code></th>
              <td>結合順序の最初のテーブルにヒントで指定されたテーブル順序を使用</td>
              <td>クエリーブロック</td>
            </tr><tr>
              <th scope="row"><code class="literal">JOIN_SUFFIX</code></th>
              <td>結合順序の最後のテーブルにヒントで指定されたテーブル順序を使用</td>
              <td>クエリーブロック</td>
            </tr><tr>
              <th scope="row"><code class="literal">MAX_EXECUTION_TIME</code></th>
              <td>ステートメントの実行時間の制限</td>
              <td>グローバル</td>
            </tr><tr>
              <th scope="row"><code class="literal">MERGE</code>, <code class="literal">NO_MERGE</code></th>
              <td>外部クエリーブロックへの導出テーブル/ビューのマージに影響</td>
              <td>Table</td>
            </tr><tr>
              <th scope="row"><code class="literal">MRR</code>, <code class="literal">NO_MRR</code></th>
              <td>マルチレンジ読取り最適化に影響</td>
              <td>Table、インデックス</td>
            </tr><tr>
              <th scope="row"><code class="literal">NO_ICP</code></th>
              <td>インデックス条件プッシュダウンの最適化に影響</td>
              <td>Table、インデックス</td>
            </tr><tr>
              <th scope="row"><code class="literal">NO_RANGE_OPTIMIZATION</code></th>
              <td>範囲の最適化に影響</td>
              <td>Table、インデックス</td>
            </tr><tr>
              <th scope="row"><code class="literal">ORDER_INDEX</code>, <code class="literal">NO_ORDER_INDEX</code></th>
              <td>指定したインデックスを使用または無視して行をソートします (MySQL 8.0.20 で追加)</td>
              <td>インデックス</td>
            </tr><tr>
              <th scope="row"><code class="literal">QB_NAME</code></th>
              <td>クエリーブロックに名前を割り当てます</td>
              <td>クエリーブロック</td>
            </tr><tr>
              <th scope="row"><code class="literal">RESOURCE_GROUP</code></th>
              <td>ステートメントの実行中にリソースグループを設定</td>
              <td>グローバル</td>
            </tr><tr>
              <th scope="row"><code class="literal">SEMIJOIN</code>, <code class="literal">NO_SEMIJOIN</code></th>
              <td>準結合戦略に影響します。MySQL 8.0.17 以降、これはアンチ結合にも適用されます</td>
              <td>クエリーブロック</td>
            </tr><tr>
              <th scope="row"><code class="literal">SKIP_SCAN</code>, <code class="literal">NO_SKIP_SCAN</code></th>
              <td>スキップスキャンの最適化に影響</td>
              <td>Table、インデックス</td>
            </tr><tr>
              <th scope="row"><code class="literal">SET_VAR</code></th>
              <td>ステートメントの実行中に変数を設定</td>
              <td>グローバル</td>
            </tr><tr>
              <th scope="row"><code class="literal">SUBQUERY</code></th>
              <td>実体化、<code class="literal">IN</code>- から -<code class="literal">EXISTS</code> サブクエリー戦略に影響</td>
              <td>クエリーブロック</td>
            </tr></tbody></table></div></div><br class="table-break"><p>
          最適化を無効にすると、オプティマイザで使用できなくなります。 最適化を有効にすることは、オプティマイザがステートメントの実行に適用する場合に、オプティマイザが戦略を自由に使用できることを意味します。オプティマイザが使用する必要はありません。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="optimizer-hints-syntax"></a>オプティマイザヒントの構文</h4></div></div></div><p>
          MySQL では、<a class="xref" href="language-structure.html#comments" title="9.7 コメント">セクション9.7「コメント」</a> で説明されているように、SQL ステートメントのコメントがサポートされます。 オプティマイザヒントは、<code class="literal">/*+ ... */</code>コメント内で指定する必要があります。 つまり、オプティマイザヒントでは、<code class="literal">/*</code> コメントのオープン順序の後に <code class="literal">+</code> 文字が付いた<code class="literal">/* ... */</code> C 形式のコメント構文のバリアントが使用されます。 例: 
        </p><pre class="programlisting">/*+ BKA(t1) */
/*+ BNL(t1, t2) */
/*+ NO_RANGE_OPTIMIZATION(t4 PRIMARY) */
/*+ QB_NAME(qb2) */
</pre><p>
          <code class="literal">+</code> 文字の後には空白を使用できます。
        </p><p>
          パーサーは、<code class="literal">SELECT</code>, <code class="literal">UPDATE</code>, <code class="literal">INSERT</code>, <code class="literal">REPLACE</code> ステートメントおよび <code class="literal">DELETE</code> ステートメントの最初のキーワードの後にオプティマイザヒントコメントを認識します。 ヒントは、次のコンテキストで使用できます: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              クエリーステートメントおよびデータ変更ステートメントの開始時:
            </p><pre class="programlisting">SELECT /*+ ... */ ...
INSERT /*+ ... */ ...
REPLACE /*+ ... */ ...
UPDATE /*+ ... */ ...
DELETE /*+ ... */ ...
</pre></li><li class="listitem"><p>
              クエリーブロックの先頭:
            </p><pre class="programlisting">(SELECT /*+ ... */ ... )
(SELECT ... ) UNION (SELECT /*+ ... */ ... )
(SELECT /*+ ... */ ... ) UNION (SELECT /*+ ... */ ... )
UPDATE ... WHERE x IN (SELECT /*+ ... */ ...)
INSERT ... SELECT /*+ ... */ ...
</pre></li><li class="listitem"><p>
              <code class="literal">EXPLAIN</code> で始まるヒント可能ステートメント。 例: 
            </p><pre class="programlisting">EXPLAIN SELECT /*+ ... */ ...
EXPLAIN UPDATE ... WHERE x IN (SELECT /*+ ... */ ...)
</pre><p>
              これは、<code class="literal">EXPLAIN</code> を使用してオプティマイザヒントが実行計画に与える影響を確認できることを意味します。 <code class="literal">EXPLAIN</code> の直後に <code class="literal">SHOW WARNINGS</code> を使用して、ヒントの使用方法を確認します。 次の <code class="literal">SHOW WARNINGS</code> によって表示される拡張 <code class="literal">EXPLAIN</code> 出力は、使用されたヒントを示します。 無視されたヒントは表示されません。 
            </p></li></ul></div><p>
          ヒントコメントには複数のヒントを含めることができますが、クエリーブロックに複数のヒントコメントを含めることはできません。 これは有効です: 
        </p><pre class="programlisting">SELECT /*+ BNL(t1) BKA(t2) */ ...
</pre><p>
          ただし、これは無効です:
        </p><pre class="programlisting">SELECT /*+ BNL(t1) */ /* BKA(t2) */ ...
</pre><p>
          ヒントコメントに複数のヒントが含まれている場合、重複および競合の可能性があります。 次の一般的なガイドラインが適用されます。 特定のヒントタイプについては、ヒントの説明に示されているように、追加のルールが適用される場合があります。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              ヒントの複製: <code class="literal">/*+ MRR(idx1) MRR(idx1) */</code>などのヒントの場合、MySQL では最初のヒントが使用され、重複ヒントに関する警告が発行されます。
            </p></li><li class="listitem"><p>
              競合するヒント: <code class="literal">/*+ MRR(idx1) NO_MRR(idx1) */</code>などのヒントの場合、MySQL は最初のヒントを使用し、競合する 2 つ目のヒントに関する警告を発行します。
            </p></li></ul></div><p>
          クエリーブロック名は識別子であり、有効な名前とその引用符の方法に関する通常のルールに従います (<a class="xref" href="language-structure.html#identifiers" title="9.2 スキーマオブジェクト名">セクション9.2「スキーマオブジェクト名」</a> を参照)。
        </p><p>
          ヒント名、クエリーブロック名および方針名では、大文字と小文字は区別されません。 テーブル名およびインデックス名への参照は、通常の識別子の大 /小文字区別ルールに従います (<a class="xref" href="language-structure.html#identifier-case-sensitivity" title="9.2.3 識別子の大文字と小文字の区別">セクション9.2.3「識別子の大文字と小文字の区別」</a> を参照)。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="optimizer-hints-join-order"></a>結合順序オプティマイザヒント</h4></div></div></div><p>
          結合順序ヒントは、オプティマイザがテーブルを結合する順序に影響します。
        </p><p>
          <code class="literal">JOIN_FIXED_ORDER</code> ヒントの構文:
        </p><pre class="programlisting"><em class="replaceable"><code>hint_name</code></em>([@<em class="replaceable"><code>query_block_name</code></em>])
</pre><p>
          その他の結合順序ヒントの構文は、次のとおりです:
        </p><pre class="programlisting"><em class="replaceable"><code>hint_name</code></em>([@<em class="replaceable"><code>query_block_name</code></em>] <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ...)
<em class="replaceable"><code>hint_name</code></em>(<em class="replaceable"><code>tbl_name</code></em>[@<em class="replaceable"><code>query_block_name</code></em>] [, <em class="replaceable"><code>tbl_name</code></em>[@<em class="replaceable"><code>query_block_name</code></em>]] ...)
</pre><p>
          構文は、次の用語を指します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <em class="replaceable"><code>hint_name</code></em> : 次のヒント名を使用できます:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">JOIN_FIXED_ORDER</code>: オプティマイザが、<code class="literal">FROM</code> 句に出現する順序を使用してテーブルを結合するように強制します。 これは、<code class="literal">SELECT STRAIGHT_JOIN</code> の指定と同じです。 
                </p></li><li class="listitem"><p>
                  <code class="literal">JOIN_ORDER</code>: 指定されたテーブルの順序を使用してテーブルを結合するようオプティマイザに指示します。 ヒントは、指定したテーブルに適用されます。 オプティマイザは、指定されたテーブルの間を含め、結合順序のどこにも名前が付いていないテーブルを配置できます。 
                </p></li><li class="listitem"><p>
                  <code class="literal">JOIN_PREFIX</code>: 結合実行計画の最初のテーブルに指定されたテーブル順序を使用してテーブルを結合するようオプティマイザに指示します。 ヒントは、指定したテーブルに適用されます。 オプティマイザは、他のすべてのテーブルを指定されたテーブルの後に配置します。 
                </p></li><li class="listitem"><p>
                  <code class="literal">JOIN_SUFFIX</code>: 結合実行計画の最後のテーブルに対して指定されたテーブルの順序を使用してテーブルを結合するようオプティマイザに指示します。 ヒントは、指定したテーブルに適用されます。 オプティマイザは、他のすべてのテーブルを名前付きテーブルの前に配置します。 
                </p></li></ul></div></li><li class="listitem"><p>
              <em class="replaceable"><code>tbl_name</code></em>: ステートメントで使用されるテーブルの名前。 テーブルに名前を付けるヒントは、名前を付けるすべてのテーブルに適用されます。 <code class="literal">JOIN_FIXED_ORDER</code> ヒントでは、テーブルに名前が付けられず、クエリーブロックの <code class="literal">FROM</code> 句のすべてのテーブルに適用されます。 
            </p><p>
              テーブルにエイリアスがある場合、ヒントはテーブル名ではなくエイリアスを参照する必要があります。
            </p><p>
              ヒントのテーブル名はスキーマ名で修飾できません。
            </p></li><li class="listitem"><p>
              <em class="replaceable"><code>query_block_name</code></em>: ヒントが適用されるクエリーブロック。 ヒントに先行する<code class="literal">@<em class="replaceable"><code>query_block_name</code></em></code> が含まれていない場合、ヒントは発生したクエリーブロックに適用されます。 <code class="literal"><em class="replaceable"><code>tbl_name</code></em>@<em class="replaceable"><code>query_block_name</code></em></code> 構文の場合、ヒントは名前付きクエリーブロック内の名前付きテーブルに適用されます。 クエリーブロックに名前を割り当てるには、<a class="xref" href="optimization.html#optimizer-hints-query-block-naming" title="クエリーブロックのネーミングのためのオプティマイザヒント">クエリーブロックのネーミングのためのオプティマイザヒント</a> を参照してください。 
            </p></li></ul></div><p>
          例:
        </p><pre class="programlisting">SELECT
/*+ JOIN_PREFIX(t2, t5@subq2, t4@subq1)
    JOIN_ORDER(t4@subq1, t3)
    JOIN_SUFFIX(t1) */
COUNT(*) FROM t1 JOIN t2 JOIN t3
           WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4)
             AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5);
</pre><p>
          ヒントは、外部クエリーブロックにマージされる準結合テーブルの動作を制御します。 サブクエリー <code class="literal">subq1</code> および <code class="literal">subq2</code> が準結合に変換されると、テーブル <code class="literal">t4@subq1</code> および <code class="literal">t5@subq2</code> が外部クエリーブロックにマージされます。 この場合、外部クエリーブロックで指定されたヒントによって、<code class="literal">t4@subq1</code>、<code class="literal">t5@subq2</code> テーブルの動作が制御されます。 
        </p><p>
          オプティマイザは、次の原則に従って結合順序のヒントを解決します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              複数のヒントインスタンス
            </p><p>
              各タイプの <code class="literal">JOIN_PREFIX</code> および <code class="literal">JOIN_SUFFIX</code> ヒントのみが適用されます。 同じタイプの後のヒントは無視され、警告が表示されます。 <code class="literal">JOIN_ORDER</code> は複数回指定できます。 
            </p><p>
              例:
            </p><pre class="programlisting">/*+ JOIN_PREFIX(t1) JOIN_PREFIX(t2) */
</pre><p>
              2 番目の <code class="literal">JOIN_PREFIX</code> ヒントは無視され、警告が表示されます。
            </p><pre class="programlisting">/*+ JOIN_PREFIX(t1) JOIN_SUFFIX(t2) */
</pre><p>
              両方のヒントが適用されます。 警告は発生しません。 
            </p><pre class="programlisting">/*+ JOIN_ORDER(t1, t2) JOIN_ORDER(t2, t3) */
</pre><p>
              両方のヒントが適用されます。 警告は発生しません。 
            </p></li><li class="listitem"><p>
              競合するヒント
            </p><p>
              <code class="literal">JOIN_ORDER</code> と <code class="literal">JOIN_PREFIX</code> に同時に適用できないテーブルの順序がある場合など、ヒントが競合することがあります:
            </p><pre class="programlisting">SELECT /*+ JOIN_ORDER(t1, t2) JOIN_PREFIX(t2, t1) */ ... FROM t1, t2;
</pre><p>
              この場合、最初に指定したヒントが適用され、後続の競合するヒントは警告なしで無視されます。 適用できない有効なヒントは、警告なしで暗黙的に無視されます。 
            </p></li><li class="listitem"><p>
              無視されたヒント
            </p><p>
              ヒントで指定されたテーブルに循環依存性がある場合、ヒントは無視されます。
            </p><p>
              例:
            </p><pre class="programlisting">/*+ JOIN_ORDER(t1, t2) JOIN_PREFIX(t2, t1) */
</pre><p>
              <code class="literal">JOIN_ORDER</code> ヒントは、<code class="literal">t1</code> に依存するテーブル <code class="literal">t2</code> を設定します。 テーブル <code class="literal">t1</code> は <code class="literal">t2</code> に依存できないため、<code class="literal">JOIN_PREFIX</code> ヒントは無視されます。 無視されたヒントは、拡張 <code class="literal">EXPLAIN</code> 出力には表示されません。 
            </p></li><li class="listitem"><p>
              <code class="literal">const</code> テーブルとの相互作用
            </p><p>
              MySQL オプティマイザは、<code class="literal">const</code> テーブルを結合順序の最初に配置し、<code class="literal">const</code> テーブルの位置はヒントの影響を受けません。 結合順序ヒント内の <code class="literal">const</code> テーブルへの参照は無視されますが、ヒントは引き続き適用可能です。 たとえば、これらは同等です: 
            </p><pre class="programlisting">JOIN_ORDER(t1, <em class="replaceable"><code>const_tbl</code></em>, t2)
JOIN_ORDER(t1, t2)
</pre><p>
              拡張 <code class="literal">EXPLAIN</code> 出力に表示される許容ヒントには、指定されたとおりに <code class="literal">const</code> テーブルが含まれます。
            </p></li><li class="listitem"><p>
              結合操作のタイプとの相互作用
            </p><p>
              MySQL では、複数のタイプの結合がサポートされています: <code class="literal">LEFT</code>, <code class="literal">RIGHT</code>, <code class="literal">INNER</code>, <code class="literal">CROSS</code>, <code class="literal">STRAIGHT_JOIN</code>。 指定したタイプの結合と競合するヒントは、警告なしで無視されます。 
            </p><p>
              例:
            </p><pre class="programlisting">SELECT /*+ JOIN_PREFIX(t1, t2) */FROM t2 LEFT JOIN t1;
</pre><p>
              ここでは、ヒント内のリクエストされた結合順序と <code class="literal">LEFT JOIN</code> に必要な順序の間で競合が発生します。 ヒントは警告なしで無視されます。 
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="optimizer-hints-table-level"></a>テーブルレベルのオプティマイザヒント</h4></div></div></div><p>
          テーブルレベルのヒントは次のものに影響します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              Block Nested-Loop (BNL) および Batched Key Access (BKA) 結合処理アルゴリズムの使用 (<a class="xref" href="optimization.html#bnl-bka-optimization" title="8.2.1.12 Block Nested Loop 結合と Batched Key Access 結合">セクション8.2.1.12「Block Nested Loop 結合と Batched Key Access 結合」</a> を参照)。
            </p></li><li class="listitem"><p>
              導出テーブル、ビュー参照または共通テーブル式を外部クエリーブロックにマージするか、内部一時テーブルを使用して実体化するか。
            </p></li><li class="listitem"><p>
              導出テーブル条件プッシュダウン最適化の使用 (MySQL 8.0.22 で追加)。 <a class="xref" href="optimization.html#derived-condition-pushdown-optimization" title="8.2.2.5 導出条件プッシュダウン最適化">セクション8.2.2.5「導出条件プッシュダウン最適化」</a>を参照してください。 
            </p></li></ul></div><p>
          これらのヒントタイプは、特定のテーブルまたはクエリーブロック内のすべてのテーブルに適用されます。
        </p><p>
          テーブルレベルのヒントの構文:
        </p><pre class="programlisting"><em class="replaceable"><code>hint_name</code></em>([@<em class="replaceable"><code>query_block_name</code></em>] [<em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ...])
<em class="replaceable"><code>hint_name</code></em>([<em class="replaceable"><code>tbl_name</code></em>@<em class="replaceable"><code>query_block_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>@<em class="replaceable"><code>query_block_name</code></em>] ...])
</pre><p>
          構文は、次の用語を指します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <em class="replaceable"><code>hint_name</code></em> : 次のヒント名を使用できます:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">BKA</code>, <code class="literal">NO_BKA</code>: 指定したテーブルに対するバッチングキーアクセスを有効または無効にします。
                </p></li><li class="listitem"><p>
                  <code class="literal">BNL</code>, <code class="literal">NO_BNL</code>: 指定したテーブルのブロックネストループを有効または無効にします。 MySQL 8.0.18 以降では、これらのヒントによってハッシュ結合の最適化も有効化および無効化されます。 
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                    ブロックネストループの最適化は MySQL 8.0.20 以降のリリースでは削除されていますが、ハッシュ結合の有効化および無効化のためにこれらのヒントは引き続きサポートされています。
                  </p></div></li><li class="listitem"><p>
                  <code class="literal">DERIVED_CONDITION_PUSHDOWN</code>, <code class="literal">NO_DERIVED_CONDITION_PUSHDOWN</code>: 指定したテーブルに対する導出表条件プッシュダウンの使用を有効または無効にします (MySQL 8.0.22 で追加)。 詳細は、<a class="xref" href="optimization.html#derived-condition-pushdown-optimization" title="8.2.2.5 導出条件プッシュダウン最適化">セクション8.2.2.5「導出条件プッシュダウン最適化」</a>を参照してください。 
                </p></li><li class="listitem"><p>
                  <code class="literal">HASH_JOIN</code>, <code class="literal">NO_HASH_JOIN</code>: 指定したテーブルに対するハッシュ結合の使用を有効または無効にします (MySQL 8.0.18 のみ。MySQL 8.0.19 以降では無効です)。
                </p></li><li class="listitem"><p>
                  <code class="literal">MERGE</code>, <code class="literal">NO_MERGE</code>: 指定したテーブル、ビュー参照または共通テーブル式のマージを有効にするか、マージを無効にしてかわりに実体化を使用してください。
                </p><a class="indexterm" name="idm45661474992224"></a><a class="indexterm" name="idm45661474990112"></a><a class="indexterm" name="idm45661474988064"></a></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                ブロックネストループまたはバッチキーアクセスヒントを使用して外部結合の内部テーブルの結合バッファリングを有効にするには、外部結合のすべての内部テーブルに対して結合バッファリングを有効にする必要があります。
              </p></div></li><li class="listitem"><p>
              <em class="replaceable"><code>tbl_name</code></em>: ステートメントで使用されるテーブルの名前。 ヒントは、名前を付けるすべてのテーブルに適用されます。 ヒントにテーブルが指定されていない場合は、そのヒントが発生したクエリーブロックのすべてのテーブルに適用されます。 
            </p><p>
              テーブルにエイリアスがある場合、ヒントはテーブル名ではなくエイリアスを参照する必要があります。
            </p><p>
              ヒントのテーブル名はスキーマ名で修飾できません。
            </p></li><li class="listitem"><p>
              <em class="replaceable"><code>query_block_name</code></em>: ヒントが適用されるクエリーブロック。 ヒントに先行する<code class="literal">@<em class="replaceable"><code>query_block_name</code></em></code> が含まれていない場合、ヒントは発生したクエリーブロックに適用されます。 <code class="literal"><em class="replaceable"><code>tbl_name</code></em>@<em class="replaceable"><code>query_block_name</code></em></code> 構文の場合、ヒントは名前付きクエリーブロック内の名前付きテーブルに適用されます。 クエリーブロックに名前を割り当てるには、<a class="xref" href="optimization.html#optimizer-hints-query-block-naming" title="クエリーブロックのネーミングのためのオプティマイザヒント">クエリーブロックのネーミングのためのオプティマイザヒント</a> を参照してください。 
            </p></li></ul></div><p>
          例:
        </p><pre class="programlisting">SELECT /*+ NO_BKA(t1, t2) */ t1.* FROM t1 INNER JOIN t2 INNER JOIN t3;
SELECT /*+ NO_BNL() BKA(t1) */ t1.* FROM t1 INNER JOIN t2 INNER JOIN t3;
SELECT /*+ NO_MERGE(dt) */ * FROM (SELECT * FROM t1) AS dt;
</pre><p>
          テーブルレベルのヒントは、送信者テーブルではなく、前のテーブルからレコードを受信するテーブルに適用されます。 次のステートメントがあるとします。 
        </p><pre class="programlisting">SELECT /*+ BNL(t2) */ FROM t1, t2;
</pre><p>
          オプティマイザが最初に <code class="literal">t1</code> を処理することを選択した場合、<code class="literal">t2</code> からの読取りを開始する前に <code class="literal">t1</code> から行をバッファリングすることで、ブロックネストループ結合が <code class="literal">t2</code> に適用されます。 オプティマイザが最初に <code class="literal">t2</code> を処理することを選択した場合、<code class="literal">t2</code> は送信者テーブルであるため、ヒントは効果がありません。 
        </p><p>
          <code class="literal">MERGE</code> ヒントおよび <code class="literal">NO_MERGE</code> ヒントには、次の優先順位ルールが適用されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              ヒントは、技術的な制約ではないオプティマイザのヒューリスティックより優先されます。 (ヒントを提案として提供しても効果がない場合、オプティマイザはヒントを無視する理由があります。) 
            </p></li><li class="listitem"><p>
              ヒントは、<code class="literal">optimizer_switch</code> システム変数の <code class="literal">derived_merge</code> フラグより優先されます。
            </p></li><li class="listitem"><p>
              ビュー参照の場合、ビュー定義の <code class="literal">ALGORITHM={MERGE|TEMPTABLE}</code> 句は、ビューを参照するクエリーで指定されたヒントよりも優先されます。
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="optimizer-hints-index-level"></a>インデックスレベルのオプティマイザヒント</h4></div></div></div><p>
          インデックスレベルのヒントは、オプティマイザが特定のテーブルまたはインデックスに使用するインデックス処理戦略に影響します。 これらのヒントタイプは、インデックス条件プッシュダウン (ICP)、マルチレンジ読取り (MRR)、インデックスマージおよび範囲最適化の使用に影響します (<a class="xref" href="optimization.html#select-optimization" title="8.2.1 SELECT ステートメントの最適化">セクション8.2.1「SELECT ステートメントの最適化」</a> を参照)。 
        </p><p>
          インデックスレベルのヒントの構文:
        </p><pre class="programlisting"><em class="replaceable"><code>hint_name</code></em>([@<em class="replaceable"><code>query_block_name</code></em>] <em class="replaceable"><code>tbl_name</code></em> [<em class="replaceable"><code>index_name</code></em> [, <em class="replaceable"><code>index_name</code></em>] ...])
<em class="replaceable"><code>hint_name</code></em>(<em class="replaceable"><code>tbl_name</code></em>@<em class="replaceable"><code>query_block_name</code></em> [<em class="replaceable"><code>index_name</code></em> [, <em class="replaceable"><code>index_name</code></em>] ...])
</pre><p>
          構文は、次の用語を指します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <em class="replaceable"><code>hint_name</code></em> : 次のヒント名を使用できます:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <a class="indexterm" name="idm45661474946928"></a> <a class="indexterm" name="idm45661474945840"></a> <code class="literal">GROUP_INDEX</code>, <code class="literal">NO_GROUP_INDEX</code>: <code class="literal">GROUP BY</code> 操作のインデックススキャンに対して、指定したインデックスを有効または無効にします。 インデックスヒント <code class="literal">FORCE INDEX FOR GROUP BY</code>、<code class="literal">IGNORE INDEX FOR GROUP BY</code> と同等です。 MySQL 8.0.20 以降で使用できます。 
                </p></li><li class="listitem"><p>
                  <a class="indexterm" name="idm45661474939440"></a> <a class="indexterm" name="idm45661474938352"></a> <code class="literal">INDEX</code>, <code class="literal">NO_INDEX</code>: <code class="literal">JOIN_INDEX</code>、<code class="literal">GROUP_INDEX</code> および <code class="literal">ORDER_INDEX</code> の組合せとして機能し、指定されたインデックスを任意のスコープおよびすべてのスコープに強制的に使用するか、<code class="literal">NO_JOIN_INDEX</code>、<code class="literal">NO_GROUP_INDEX</code> および <code class="literal">NO_ORDER_INDEX</code> の組合せとして使用します。これにより、サーバーは、任意のスコープおよびすべてのスコープに指定されたインデックスを無視します。 <code class="literal">FORCE INDEX</code>、<code class="literal">IGNORE INDEX</code> と同等です。 MySQL 8.0.20 以降で使用可能です。 
                </p></li><li class="listitem"><p>
                  <a class="indexterm" name="idm45661474926368"></a> <a class="indexterm" name="idm45661474925280"></a> <code class="literal">INDEX_MERGE</code>, <code class="literal">NO_INDEX_MERGE</code>: 指定したテーブルまたはインデックスのインデックスマージアクセス方法を有効または無効にします。 このアクセス方法の詳細は、<a class="xref" href="optimization.html#index-merge-optimization" title="8.2.1.3 インデックスマージの最適化">セクション8.2.1.3「インデックスマージの最適化」</a> を参照してください。 これらのヒントは、3 つのすべてのインデックスマージアルゴリズムに適用されます。 
                </p><p>
                  <code class="literal">INDEX_MERGE</code> ヒントでは、オプティマイザは、指定されたインデックスセットを使用して、指定されたテーブルに対してインデックスマージを強制的に使用します。 インデックスが指定されていない場合、オプティマイザは考えられるすべてのインデックスの組合せを考慮し、最もコストの低いものを選択します。 インデックスの組合せが特定のステートメントに適用できない場合、ヒントは無視されることがあります。 
                </p><p>
                  <code class="literal">NO_INDEX_MERGE</code> ヒントは、指定されたインデックスのいずれかを含むインデックスマージの組合せを無効にします。 ヒントにインデックスが指定されていない場合、テーブルに対するインデックスのマージは許可されません。 
                </p></li><li class="listitem"><p>
                  <a class="indexterm" name="idm45661474916112"></a> <a class="indexterm" name="idm45661474915024"></a> <code class="literal">JOIN_INDEX</code>, <code class="literal">NO_JOIN_INDEX</code>: MySQL で、<code class="literal">ref</code>, <code class="literal">range</code>, <code class="literal">index_merge</code> などのアクセス方法に対して指定されたインデックスを強制的に使用または無視します。 <code class="literal">FORCE INDEX FOR JOIN</code>、<code class="literal">IGNORE INDEX FOR JOIN</code> と同等です。 MySQL 8.0.20 以降で使用できます。 
                </p></li><li class="listitem"><p>
                  <a class="indexterm" name="idm45661474907056"></a> <a class="indexterm" name="idm45661474906032"></a> <code class="literal">MRR</code>, <code class="literal">NO_MRR</code>: 指定したテーブルまたはインデックスの MRR を有効または無効にします。 MRR ヒントは、<code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> テーブルにのみ適用されます。 このアクセス方法の詳細は、<a class="xref" href="optimization.html#mrr-optimization" title="8.2.1.11 Multi-Range Read の最適化">セクション8.2.1.11「Multi-Range Read の最適化」</a> を参照してください。 
                </p></li><li class="listitem"><p>
                  <a class="indexterm" name="idm45661474899712"></a> <code class="literal">NO_ICP</code>: 指定したテーブルまたはインデックスの ICP を無効にします。 デフォルトでは、ICP は最適化戦略の候補であるため、有効にするヒントはありません。 このアクセス方法の詳細は、<a class="xref" href="optimization.html#index-condition-pushdown-optimization" title="8.2.1.6 インデックスコンディションプッシュダウンの最適化">セクション8.2.1.6「インデックスコンディションプッシュダウンの最適化」</a> を参照してください。 
                </p></li><li class="listitem"><p>
                  <a class="indexterm" name="idm45661474895584"></a> <code class="literal">NO_RANGE_OPTIMIZATION</code>: 指定したテーブルまたはインデックスのインデックス範囲アクセスを無効にします。 このヒントは、テーブルまたはインデックスのインデックスマージおよびインデックスのループスキャンも無効にします。 デフォルトでは、範囲アクセスは最適化戦略の候補であるため、有効にするヒントはありません。 
                </p><p>
                  このヒントは、範囲の数が多く、範囲の最適化に多くのリソースが必要な場合に役立ちます。
                </p></li><li class="listitem"><p>
                  <a class="indexterm" name="idm45661474891424"></a> <a class="indexterm" name="idm45661474890336"></a> <code class="literal">ORDER_INDEX</code>, <code class="literal">NO_ORDER_INDEX</code>: MySQL で、指定されたインデックスを使用または無視して行をソートします。 <code class="literal">FORCE INDEX FOR ORDER BY</code>、<code class="literal">IGNORE INDEX FOR ORDER BY</code> と同等です。 MySQL 8.0.20 以降で使用可能です。 
                </p></li><li class="listitem"><p>
                  <a class="indexterm" name="idm45661474884768"></a> <a class="indexterm" name="idm45661474883680"></a> <code class="literal">SKIP_SCAN</code>, <code class="literal">NO_SKIP_SCAN</code>: 指定したテーブルまたはインデックスのスキャンのスキップアクセス方法を有効または無効にします。 このアクセス方法の詳細は、<a class="xref" href="optimization.html#range-access-skip-scan" title="スキャン範囲アクセス方法のスキップ">スキャン範囲アクセス方法のスキップ</a> を参照してください。 これらのヒントは、MySQL 8.0.13 の時点で使用できます。 
                </p><p>
                  <code class="literal">SKIP_SCAN</code> ヒントでは、オプティマイザは、指定されたインデックスセットを使用して、指定されたテーブルに対してスキップスキャンを強制的に使用します。 インデックスが指定されていない場合、オプティマイザは考えられるすべてのインデックスを考慮し、最もコストの低いインデックスを選択します。 インデックスが特定のステートメントに適用できない場合、ヒントは無視されることがあります。 
                </p><p>
                  <code class="literal">NO_SKIP_SCAN</code> ヒントは、指定されたインデックスのスキップスキャンを無効にします。 ヒントにインデックスが指定されていない場合、テーブルに対してスキップスキャンは許可されません。 
                </p></li></ul></div></li><li class="listitem"><p>
              <em class="replaceable"><code>tbl_name</code></em>: ヒントが適用されるテーブル。
            </p></li><li class="listitem"><p>
              <em class="replaceable"><code>index_name</code></em>: 指定したテーブル内のインデックスの名前。 ヒントは、名前を付けるすべてのインデックスに適用されます。 ヒントにインデックスが指定されていない場合は、テーブル内のすべてのインデックスに適用されます。 
            </p><p>
              主キーを参照するには、<code class="literal">PRIMARY</code> という名前を使用します。 テーブルのインデックス名を表示するには、<code class="literal">SHOW INDEX</code> を使用します。 
            </p></li><li class="listitem"><p>
              <em class="replaceable"><code>query_block_name</code></em>: ヒントが適用されるクエリーブロック。 ヒントに先行する<code class="literal">@<em class="replaceable"><code>query_block_name</code></em></code> が含まれていない場合、ヒントは発生したクエリーブロックに適用されます。 <code class="literal"><em class="replaceable"><code>tbl_name</code></em>@<em class="replaceable"><code>query_block_name</code></em></code> 構文の場合、ヒントは名前付きクエリーブロック内の名前付きテーブルに適用されます。 クエリーブロックに名前を割り当てるには、<a class="xref" href="optimization.html#optimizer-hints-query-block-naming" title="クエリーブロックのネーミングのためのオプティマイザヒント">クエリーブロックのネーミングのためのオプティマイザヒント</a> を参照してください。 
            </p></li></ul></div><p>
          例:
        </p><pre class="programlisting">SELECT /*+ INDEX_MERGE(t1 f3, PRIMARY) */ f2 FROM t1
  WHERE f1 = 'o' AND f2 = f3 AND f3 &lt;= 4;
SELECT /*+ MRR(t1) */ * FROM t1 WHERE f2 &lt;= 3 AND 3 &lt;= f3;
SELECT /*+ NO_RANGE_OPTIMIZATION(t3 PRIMARY, f2_idx) */ f1
  FROM t3 WHERE f1 &gt; 30 AND f1 &lt; 33;
INSERT INTO t3(f1, f2, f3)
  (SELECT /*+ NO_ICP(t2) */ t2.f1, t2.f2, t2.f3 FROM t1,t2
   WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1
   AND t1.f2 AND t2.f2 + 1 &gt;= t1.f1 + 1);
SELECT /*+ SKIP_SCAN(t1 PRIMARY) */ f1, f2
  FROM t1 WHERE f2 &gt; 40;
</pre><p>
          次の例ではインデックスマージヒントを使用しますが、他のインデックスレベルのヒントは、<code class="literal">optimizer_switch</code> システム変数またはインデックスヒントに関して、オプティマイザヒントの無視と優先順位に関して同じ原則に従います。
        </p><p>
          <code class="literal">t1</code> テーブルに <code class="literal">a</code>, <code class="literal">b</code>, <code class="literal">c</code> および <code class="literal">d</code> カラムがあり、<code class="literal">i_a</code>、<code class="literal">i_b</code> および <code class="literal">i_c</code> という名前のインデックスが <code class="literal">a</code>、<code class="literal">b</code>、および <code class="literal">c</code> にそれぞれ存在するとします:
        </p><pre class="programlisting">SELECT /*+ INDEX_MERGE(t1 i_a, i_b, i_c)*/ * FROM t1
  WHERE a = 1 AND b = 2 AND c = 3 AND d = 4;
</pre><p>
          この場合、<code class="literal">(i_a, i_b, i_c)</code> にはインデックスマージが使用されます。
        </p><pre class="programlisting">SELECT /*+ INDEX_MERGE(t1 i_a, i_b, i_c)*/ * FROM t1
  WHERE b = 1 AND c = 2 AND d = 3;
</pre><p>
          この場合、<code class="literal">(i_b, i_c)</code> にはインデックスマージが使用されます。
        </p><pre class="programlisting">/*+ INDEX_MERGE(t1 i_a, i_b) NO_INDEX_MERGE(t1 i_b) */
</pre><p>
          同じテーブルに先行するヒントがあるため、<code class="literal">NO_INDEX_MERGE</code> は無視されます。
        </p><pre class="programlisting">/*+ NO_INDEX_MERGE(t1 i_a, i_b) INDEX_MERGE(t1 i_b) */
</pre><p>
          同じテーブルに先行するヒントがあるため、<code class="literal">INDEX_MERGE</code> は無視されます。
        </p><p>
          <code class="literal">INDEX_MERGE</code> および <code class="literal">NO_INDEX_MERGE</code> オプティマイザヒントには、次の優先順位ルールが適用されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              オプティマイザヒントが指定され、適用可能な場合は、<code class="literal">optimizer_switch</code> システム変数のインデックスマージ関連フラグよりも優先されます。
            </p><pre class="programlisting">SET optimizer_switch='index_merge_intersection=off';
SELECT /*+ INDEX_MERGE(t1 i_b, i_c) */ * FROM t1
WHERE b = 1 AND c = 2 AND d = 3;
</pre><p>
              ヒントは <code class="literal">optimizer_switch</code> よりも優先されます。 この場合、<code class="literal">(i_b, i_c)</code> にはインデックスマージが使用されます。 
            </p><pre class="programlisting">SET optimizer_switch='index_merge_intersection=on';
SELECT /*+ INDEX_MERGE(t1 i_b) */ * FROM t1
WHERE b = 1 AND c = 2 AND d = 3;
</pre><p>
              ヒントには 1 つのインデックスのみが指定されているため、適用できず、<code class="literal">optimizer_switch</code> フラグ (<code class="literal">on</code>) が適用されます。 インデックスマージは、オプティマイザがコスト効率に優れていると評価した場合に使用されます。 
            </p><pre class="programlisting">SET optimizer_switch='index_merge_intersection=off';
SELECT /*+ INDEX_MERGE(t1 i_b) */ * FROM t1
WHERE b = 1 AND c = 2 AND d = 3;
</pre><p>
              ヒントには 1 つのインデックスのみが指定されているため、適用できず、<code class="literal">optimizer_switch</code> フラグ (<code class="literal">off</code>) が適用されます。 インデックスマージは使用されません。 
            </p></li><li class="listitem"><p>
              インデックスレベルのオプティマイザヒント <code class="literal">GROUP_INDEX</code>, <code class="literal">INDEX</code>, <code class="literal">JOIN_INDEX</code> および <code class="literal">ORDER_INDEX</code> はすべて、同等の <code class="literal">FORCE INDEX</code> ヒントより優先されます。つまり、<code class="literal">FORCE INDEX</code> ヒントは無視されます。 同様に、<code class="literal">NO_GROUP_INDEX</code>, <code class="literal">NO_INDEX</code>, <code class="literal">NO_JOIN_INDEX</code> および <code class="literal">NO_ORDER_INDEX</code> のヒントはすべて <code class="literal">IGNORE INDEX</code> の同等のヒントよりも優先され、無視されます。 
            </p><p>
              インデックスレベルのオプティマイザヒント <code class="literal">GROUP_INDEX</code>, <code class="literal">NO_GROUP_INDEX</code>, <code class="literal">INDEX</code>、<code class="literal">NO_INDEX</code>、<code class="literal">JOIN_INDEX</code>、<code class="literal">NO_JOIN_INDEX</code>、<code class="literal">ORDER_INDEX</code> および <code class="literal">NO_ORDER_INDEX</code> ヒントは、他のすべてのオプティマイザヒント (他のインデックスレベルのオプティマイザヒントを含む) よりも優先されます。 その他のオプティマイザヒントは、これらによって許可されるインデックスにのみ適用されます。 
            </p><p>
              <code class="literal">GROUP_INDEX</code>, <code class="literal">INDEX</code>, <code class="literal">JOIN_INDEX</code> および <code class="literal">ORDER_INDEX</code> のヒントはすべて <code class="literal">FORCE INDEX</code> と同等であり、<code class="literal">USE INDEX</code> とは同等ではありません。 これは、これらのヒントの 1 つ以上を使用することは、いずれかの名前付きインデックスを使用してテーブル内の行を検索する方法がない場合にのみテーブルスキャンが使用されることを意味するためです。 MySQL が <code class="literal">USE INDEX</code> の特定のインスタンスと同じインデックスまたはインデックスのセットを使用するようにするには、<code class="literal">NO_INDEX</code>, <code class="literal">NO_JOIN_INDEX</code>, <code class="literal">NO_GROUP_INDEX</code>, <code class="literal">NO_ORDER_INDEX</code> またはこれらの組合せを使用できます。 
            </p><p>
              <code class="literal">USE INDEX</code> がクエリー <code class="literal">SELECT a,c FROM t1 USE INDEX FOR ORDER BY (i_a) ORDER BY a</code> に与える影響をレプリケートするには、<code class="literal">NO_ORDER_INDEX</code> オプティマイザヒントを使用して、次のようなものを除くテーブルのすべてのインデックスをカバーできます:
            </p><pre class="programlisting">SELECT /*+ NO_ORDER_INDEX(t1 i_b,i_c) */ a,c
    FROM t1
    ORDER BY a;
</pre><p>
              次に示すように、<code class="literal">NO_ORDER_BY</code> によって <code class="literal">USE INDEX</code> が無視されるため、テーブル全体の <code class="literal">NO_ORDER_INDEX</code> を <code class="literal">USE INDEX FOR ORDER BY</code> と組み合せようとしても機能しません:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT /*+ NO_ORDER_INDEX(t1) */ a,c FROM t1</code></strong>
    -&gt;     <strong class="userinput"><code>USE INDEX FOR ORDER BY (i_a) ORDER BY a\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 256
     filtered: 100.00
        Extra: Using filesort
</pre></li><li class="listitem"><p>
              <code class="literal">USE INDEX</code>、<code class="literal">FORCE INDEX</code> および <code class="literal">IGNORE INDEX</code> のインデックスヒントは、<code class="literal">INDEX_MERGE</code> および <code class="literal">NO_INDEX_MERGE</code> のオプティマイザヒントよりも優先度が高くなります。
            </p><pre class="programlisting">/*+ INDEX_MERGE(t1 i_a, i_b, i_c) */ ... IGNORE INDEX i_a
</pre><p>
              <code class="literal">IGNORE INDEX</code> は <code class="literal">INDEX_MERGE</code> よりも優先されるため、インデックス <code class="literal">i_a</code> はインデックスマージで使用可能な範囲から除外されます。
            </p><pre class="programlisting">/*+ NO_INDEX_MERGE(t1 i_a, i_b) */ ... FORCE INDEX i_a, i_b
</pre><p>
              <code class="literal">FORCE INDEX</code> のため、<code class="literal">i_a, i_b</code> ではインデックスマージは許可されていませんが、オプティマイザは <code class="literal">range</code> または <code class="literal">ref</code> のアクセスに <code class="literal">i_a</code> または <code class="literal">i_b</code> のいずれかを使用するように強制されます。 競合はありません。両方のヒントを適用できます。 
            </p></li><li class="listitem"><p>
              <code class="literal">IGNORE INDEX</code> ヒントで複数のインデックスが指定されている場合、それらのインデックスはインデックスマージに使用できません。
            </p></li><li class="listitem"><p>
              <code class="literal">FORCE INDEX</code> ヒントおよび <code class="literal">USE INDEX</code> ヒントでは、名前付きインデックスのみをインデックスマージに使用できます。
            </p><pre class="programlisting">SELECT /*+ INDEX_MERGE(t1 i_a, i_b, i_c) */ a FROM t1
FORCE INDEX (i_a, i_b) WHERE c = 'h' AND a = 2 AND b = 'b';
</pre><p>
              インデックスマージ交差アクセスアルゴリズムは、<code class="literal">(i_a, i_b)</code> に使用されます。 <code class="literal">FORCE INDEX</code> が <code class="literal">USE INDEX</code> に変更された場合も同様です。 
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="optimizer-hints-subquery"></a>サブクエリーオプティマイザヒント</h4></div></div></div><p>
          サブクエリーヒントは、準結合変換を使用するかどうか、許可する準結合戦略、および準結合を使用しない場合はサブクエリー実体化と <code class="literal">IN</code> から <code class="literal">EXISTS</code> への変換のどちらを使用するかに影響します。 これらの最適化の詳細は、<a class="xref" href="optimization.html#subquery-optimization" title="8.2.2 サブクエリー、導出テーブル、ビュー参照および共通テーブル式の最適化">セクション8.2.2「サブクエリー、導出テーブル、ビュー参照および共通テーブル式の最適化」</a> を参照してください。 
        </p><p>
          準結合戦略に影響するヒントの構文は、次のとおりです:
        </p><pre class="programlisting"><em class="replaceable"><code>hint_name</code></em>([@<em class="replaceable"><code>query_block_name</code></em>] [<em class="replaceable"><code>strategy</code></em> [, <em class="replaceable"><code>strategy</code></em>] ...])
</pre><p>
          構文は、次の用語を指します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <em class="replaceable"><code>hint_name</code></em> : 次のヒント名を使用できます:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">SEMIJOIN</code>, <code class="literal">NO_SEMIJOIN</code>: 名前付き準結合戦略を有効または無効にします。
                </p></li></ul></div></li><li class="listitem"><p>
              <em class="replaceable"><code>strategy</code></em>: 有効または無効にする準結合戦略。 これらの戦略名は許可されます: <code class="literal">DUPSWEEDOUT</code>, <code class="literal">FIRSTMATCH</code>, <code class="literal">LOOSESCAN</code>, <code class="literal">MATERIALIZATION</code>。 
            </p><p>
              <code class="literal">SEMIJOIN</code> ヒントでは、戦略に名前が付けられていない場合、可能であれば、<code class="literal">optimizer_switch</code> システム変数に従って有効化された戦略に基づいて準結合が使用されます。 戦略に名前が付けられているが、ステートメントには適用できない場合は、<code class="literal">DUPSWEEDOUT</code> が使用されます。 
            </p><p>
              <code class="literal">NO_SEMIJOIN</code> ヒントでは、戦略に名前が付いていない場合、準結合は使用されません。 ステートメントに適用可能なすべての戦略を除外する戦略に名前が付けられている場合は、<code class="literal">DUPSWEEDOUT</code> が使用されます。 
            </p></li></ul></div><p>
          あるサブクエリーが別のサブクエリー内にネストされ、その両方が外部クエリーの準結合にマージされる場合、最も内側のクエリーに対する準結合戦略の指定は無視されます。 <code class="literal">SEMIJOIN</code> および <code class="literal">NO_SEMIJOIN</code> ヒントを使用して、このようなネストしたサブクエリーの準結合変換を有効化または無効化できます。 
        </p><p>
          <code class="literal">DUPSWEEDOUT</code> が無効になっている場合、オプティマイザによって最適ではないクエリー計画が生成されることがあります。 これは、最長一致検索中のヒューリスティックプルーニングが原因で発生します。これは、<code class="literal">optimizer_prune_level=0</code> を設定することで回避できます。 
        </p><p>
          例:
        </p><pre class="programlisting">SELECT /*+ NO_SEMIJOIN(@subq1 FIRSTMATCH, LOOSESCAN) */ * FROM t2
  WHERE t2.a IN (SELECT /*+ QB_NAME(subq1) */ a FROM t3);
SELECT /*+ SEMIJOIN(@subq1 MATERIALIZATION, DUPSWEEDOUT) */ * FROM t2
  WHERE t2.a IN (SELECT /*+ QB_NAME(subq1) */ a FROM t3);
</pre><p>
          サブクエリー実体化または <code class="literal">IN</code> から <code class="literal">EXISTS</code> への変換のどちらを使用するかに影響するヒントの構文は、次のとおりです:
        </p><pre class="programlisting">SUBQUERY([@<em class="replaceable"><code>query_block_name</code></em>] <em class="replaceable"><code>strategy</code></em>)
</pre><p>
          ヒント名は常に <code class="literal">SUBQUERY</code> です。
        </p><p>
          <code class="literal">SUBQUERY</code> ヒントの場合、これらの <em class="replaceable"><code>strategy</code></em> 値は許可されます: <code class="literal">INTOEXISTS</code>、<code class="literal">MATERIALIZATION</code>。
        </p><p>
          例:
        </p><pre class="programlisting">SELECT id, a IN (SELECT /*+ SUBQUERY(MATERIALIZATION) */ a FROM t1) FROM t2;
SELECT * FROM t2 WHERE t2.a IN (SELECT /*+ SUBQUERY(INTOEXISTS) */ a FROM t1);
</pre><p>
          準結合および <code class="literal">SUBQUERY</code> ヒントの場合、先頭の<code class="literal">@<em class="replaceable"><code>query_block_name</code></em></code> でヒントが適用されるクエリーブロックを指定します。 ヒントに先行する<code class="literal">@<em class="replaceable"><code>query_block_name</code></em></code> が含まれていない場合、ヒントは発生したクエリーブロックに適用されます。 クエリーブロックに名前を割り当てるには、<a class="xref" href="optimization.html#optimizer-hints-query-block-naming" title="クエリーブロックのネーミングのためのオプティマイザヒント">クエリーブロックのネーミングのためのオプティマイザヒント</a> を参照してください。 
        </p><p>
          ヒントコメントに複数のサブクエリーヒントが含まれている場合は、最初のヒントが使用されます。 そのタイプの他の後続のヒントがある場合は、警告が生成されます。 他のタイプの次のヒントは、暗黙的に無視されます。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="optimizer-hints-execution-time"></a>ステートメント実行時オプティマイザヒント</h4></div></div></div><p>
          <code class="literal">MAX_EXECUTION_TIME</code> ヒントは、<code class="literal">SELECT</code> ステートメントでのみ使用できます。 サーバーがステートメントを終了するまでに、ステートメントの実行が許可される期間に制限 <em class="replaceable"><code>N</code></em> (ミリ秒単位のタイムアウト値) を設定します: 
        </p><pre class="programlisting">MAX_EXECUTION_TIME(<em class="replaceable"><code>N</code></em>)
</pre><p>
          タイムアウトが 1 秒 (1000 ミリ秒) の例:
        </p><pre class="programlisting">SELECT /*+ MAX_EXECUTION_TIME(1000) */ * FROM t1 INNER JOIN t2 WHERE ...
</pre><p>
          <code class="literal">MAX_EXECUTION_TIME(<em class="replaceable"><code>N</code></em>)</code> ヒントは、<em class="replaceable"><code>N</code></em> ミリ秒のステートメント実行タイムアウトを設定します。 このオプションが指定されていないか、<em class="replaceable"><code>N</code></em> が 0 の場合、<code class="literal">max_execution_time</code> システム変数によって設定されたステートメントタイムアウトが適用されます。 
        </p><p>
          <code class="literal">MAX_EXECUTION_TIME</code> ヒントは次のように適用できます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              UNION やサブクエリーを含むステートメントなど、複数の <code class="literal">SELECT</code> キーワードを持つステートメントの場合、<code class="literal">MAX_EXECUTION_TIME</code> はステートメント全体に適用され、最初の <code class="literal">SELECT</code> の後に出現する必要があります。
            </p></li><li class="listitem"><p>
              読取り専用の <code class="literal">SELECT</code> ステートメントに適用されます。 読み取り専用でないステートメントは、副作用としてデータを変更するストアドファンクションを呼び出すステートメントです。 
            </p></li><li class="listitem"><p>
              ストアドプログラムの <code class="literal">SELECT</code> ステートメントには適用されず、無視されます。
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="optimizer-hints-set-var"></a>可変設定のヒント構文</h4></div></div></div><a class="indexterm" name="idm45661474697632"></a><a class="indexterm" name="idm45661474696128"></a><a class="indexterm" name="idm45661474694080"></a><a class="indexterm" name="idm45661474692144"></a><p>
          <code class="literal">SET_VAR</code> ヒントは、システム変数のセッション値を一時的に設定します (単一のステートメントの実行中)。 例: 
        </p><pre class="programlisting">SELECT /*+ SET_VAR(sort_buffer_size = 16M) */ name FROM people ORDER BY name;
INSERT /*+ SET_VAR(foreign_key_checks=OFF) */ INTO t2 VALUES(2);
SELECT /*+ SET_VAR(optimizer_switch = 'mrr_cost_based=off') */ 1;
</pre><p>
          <code class="literal">SET_VAR</code> ヒントの構文:
        </p><pre class="programlisting">SET_VAR(<em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>value</code></em>)
</pre><p>
          <em class="replaceable"><code>var_name</code></em> は、セッション値を持つシステム変数に名前を付けます (ただし、後で説明するように、そのようなすべての変数に名前を付けることはできません)。<em class="replaceable"><code>value</code></em> は変数に割り当てる値で、値はスカラーである必要があります。
        </p><p>
          次のステートメントで示すように、<code class="literal">SET_VAR</code> では一時変数が変更されます:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@unique_checks;</code></strong>
+-----------------+
| @@unique_checks |
+-----------------+
|               1 |
+-----------------+
mysql&gt; <strong class="userinput"><code>SELECT /*+ SET_VAR(unique_checks=OFF) */ @@unique_checks;</code></strong>
+-----------------+
| @@unique_checks |
+-----------------+
|               0 |
+-----------------+
mysql&gt; <strong class="userinput"><code>SELECT @@unique_checks;</code></strong>
+-----------------+
| @@unique_checks |
+-----------------+
|               1 |
+-----------------+
</pre><p>
          <code class="literal">SET_VAR</code> では、変数値を保存およびリストアする必要はありません。 これにより、複数のステートメントを単一のステートメントで置き換えることができます。 次の一連のステートメントについて考えてみます: 
        </p><pre class="programlisting">SET @saved_val = @@SESSION.<em class="replaceable"><code>var_name</code></em>;
SET @@SESSION.<em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>value</code></em>;
SELECT ...
SET @@SESSION.<em class="replaceable"><code>var_name</code></em> = @saved_val;
</pre><p>
          順序は、次の単一のステートメントで置換できます:
        </p><pre class="programlisting">SELECT /*+ SET_VAR(<em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>value</code></em>) ...
</pre><p>
          スタンドアロンの <code class="literal">SET</code> ステートメントでは、セッション変数のネーミングに次の構文を使用できます:
        </p><pre class="programlisting">SET SESSION <em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>value</code></em>;
SET @@SESSION.<em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>value</code></em>;
SET @@.<em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>value</code></em>;
</pre><p>
          <code class="literal">SET_VAR</code> ヒントはセッション変数にのみ適用されるため、セッションスコープは暗黙的であり、<code class="literal">SESSION</code>、<code class="literal">@@SESSION.</code> および<code class="literal">@@</code>は必要なく、許可されません。 明示的なセッションインジケータ構文を含めると、<code class="literal">SET_VAR</code> ヒントは無視され、警告が表示されます。 
        </p><p>
          すべてのセッション変数を <code class="literal">SET_VAR</code> で使用できるわけではありません。 個々のシステム変数の説明は、各変数がヒント可能かどうかを示します。<a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a> を参照してください。 また、システム変数を <code class="literal">SET_VAR</code> で使用して、実行時にチェックすることもできます。 変数がヒント可能でない場合は、警告が発生します: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT /*+ SET_VAR(collation_server = 'utf8') */ 1;</code></strong>
+---+
| 1 |
+---+
| 1 |
+---+
1 row in set, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Warning
   Code: 4537
Message: Variable 'collation_server' cannot be set using SET_VAR hint.
</pre><p>
          <code class="literal">SET_VAR</code> 構文では単一の変数のみを設定できますが、複数のヒントを指定して複数の変数を設定できます:
        </p><pre class="programlisting">SELECT /*+ SET_VAR(optimizer_switch = 'mrr_cost_based=off')
           SET_VAR(max_heap_table_size = 1G) */ 1;
</pre><p>
          同じ変数名を持つ複数のヒントが同じステートメントに出現すると、最初のヒントが適用され、他のヒントは警告付きで無視されます:
        </p><pre class="programlisting">SELECT /*+ SET_VAR(max_heap_table_size = 1G)
           SET_VAR(max_heap_table_size = 3G) */ 1;
</pre><p>
          この場合、2 番目のヒントは無視され、競合しているという警告が表示されます。
        </p><p>
          指定された名前を持つシステム変数がない場合、または変数値が正しくない場合、<code class="literal">SET_VAR</code> ヒントは警告付きで無視されます:
        </p><pre class="programlisting">SELECT /*+ SET_VAR(max_size = 1G) */ 1;
SELECT /*+ SET_VAR(optimizer_switch = 'mrr_cost_based=yes') */ 1;
</pre><p>
          最初のステートメントには、<code class="literal">max_size</code> 変数はありません。 2 番目のステートメントでは、<code class="literal">mrr_cost_based</code> は <code class="literal">on</code> または <code class="literal">off</code> の値を取るため、<code class="literal">yes</code> に設定しようとする試みは正しくありません。 いずれの場合も、ヒントは警告付きで無視されます。 
        </p><p>
          <code class="literal">SET_VAR</code> ヒントはステートメントレベルでのみ使用できます。 サブクエリーで使用する場合、ヒントは無視され、警告が表示されます。 
        </p><p>
          レプリカは、レプリケートされたステートメントの <code class="literal">SET_VAR</code> ヒントを無視して、セキュリティの問題が発生する可能性を回避します。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="optimizer-hints-resource-group"></a>リソースグループのヒント構文</h4></div></div></div><p>
          <code class="literal">RESOURCE_GROUP</code> オプティマイザヒントは、リソースグループの管理に使用されます (<a class="xref" href="server-administration.html#resource-groups" title="5.1.16 リソースグループ">セクション5.1.16「リソースグループ」</a> を参照)。 このヒントは、ステートメントを実行するスレッドを名前付きリソースグループに一時的に割り当てます (ステートメントの期間中)。 <code class="literal">RESOURCE_GROUP_ADMIN</code> または <code class="literal">RESOURCE_GROUP_USER</code> 権限が必要です。 
        </p><p>
          例:
        </p><pre class="programlisting">SELECT /*+ RESOURCE_GROUP(USR_default) */ name FROM people ORDER BY name;
INSERT /*+ RESOURCE_GROUP(Batch) */ INTO t2 VALUES(2);
</pre><p>
          <code class="literal">RESOURCE_GROUP</code> ヒントの構文:
        </p><pre class="programlisting">RESOURCE_GROUP(<em class="replaceable"><code>group_name</code></em>)
</pre><p>
          <em class="replaceable"><code>group_name</code></em> は、ステートメントの実行中にスレッドを割り当てるリソースグループを示します。 グループが存在しない場合、警告が発生し、ヒントは無視されます。 
        </p><p>
          <code class="literal">RESOURCE_GROUP</code> ヒントは、最初のステートメントキーワード (<code class="literal">SELECT</code>, <code class="literal">INSERT</code>, <code class="literal">REPLACE</code>, <code class="literal">UPDATE</code> または <code class="literal">DELETE</code>) の後に指定する必要があります。
        </p><p>
          <code class="literal">RESOURCE_GROUP</code> の代替手段として、一時的にスレッドをリソースグループに割り当てる <code class="literal">SET RESOURCE GROUP</code> ステートメントがあります。 <a class="xref" href="sql-statements.html#set-resource-group" title="13.7.2.4 SET RESOURCE GROUP ステートメント">セクション13.7.2.4「SET RESOURCE GROUP ステートメント」</a>を参照してください。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="optimizer-hints-query-block-naming"></a>クエリーブロックのネーミングのためのオプティマイザヒント</h4></div></div></div><p>
          テーブルレベル、インデックスレベルおよびサブクエリーオプティマイザヒントでは、特定のクエリーブロックに引数構文の一部として名前を付けることができます。 これらの名前を作成するには、<code class="literal">QB_NAME</code> ヒントを使用します。これにより、名前が発生したクエリーブロックに名前が割り当てられます: 
        </p><pre class="programlisting">QB_NAME(<em class="replaceable"><code>name</code></em>)
</pre><p>
          <code class="literal">QB_NAME</code> ヒントを使用すると、他のヒントが適用されるクエリーブロックを明確にすることができます。 また、複雑なステートメントを理解しやすくするために、すべての非クエリーブロック名ヒントを単一のヒントコメント内に指定することもできます。 次のステートメントについて考えてみます: 
        </p><pre class="programlisting">SELECT ...
  FROM (SELECT ...
  FROM (SELECT ... FROM ...)) ...
</pre><p>
          <code class="literal">QB_NAME</code> ヒントは、ステートメントのクエリーブロックに名前を割り当てます:
        </p><pre class="programlisting">SELECT /*+ QB_NAME(qb1) */ ...
  FROM (SELECT /*+ QB_NAME(qb2) */ ...
  FROM (SELECT /*+ QB_NAME(qb3) */ ... FROM ...)) ...
</pre><p>
          他のヒントでは、これらの名前を使用して適切なクエリーブロックを参照できます:
        </p><pre class="programlisting">SELECT /*+ QB_NAME(qb1) MRR(@qb1 t1) BKA(@qb2) NO_MRR(@qb3t1 idx1, id2) */ ...
  FROM (SELECT /*+ QB_NAME(qb2) */ ...
  FROM (SELECT /*+ QB_NAME(qb3) */ ... FROM ...)) ...
</pre><p>
          その結果、次のようになります:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">MRR(@qb1 t1)</code> は、クエリーブロック <code class="literal">qb1</code> のテーブル <code class="literal">t1</code> に適用されます。
            </p></li><li class="listitem"><p>
              <code class="literal">BKA(@qb2)</code> は、クエリーブロック <code class="literal">qb2</code> に適用されます。
            </p></li><li class="listitem"><p>
              <code class="literal">NO_MRR(@qb3 t1 idx1, id2)</code> は、クエリーブロック <code class="literal">qb3</code> の <code class="literal">t1</code> テーブルのインデックス <code class="literal">idx1</code> および <code class="literal">idx2</code> に適用されます。
            </p></li></ul></div><p>
          クエリーブロック名は識別子であり、有効な名前とその引用符の方法に関する通常のルールに従います (<a class="xref" href="language-structure.html#identifiers" title="9.2 スキーマオブジェクト名">セクション9.2「スキーマオブジェクト名」</a> を参照)。 たとえば、空白を含むクエリーブロック名は引用符で囲む必要があります。引用符はバックティックを使用して使用できます: 
        </p><pre class="programlisting">SELECT /*+ BKA(@`my hint name`) */ ...
  FROM (SELECT /*+ QB_NAME(`my hint name`) */ ...) ...
</pre><p>
          <code class="literal">ANSI_QUOTES</code> SQL モードが有効な場合は、クエリーブロック名を二重引用符で囲むこともできます:
        </p><pre class="programlisting">SELECT /*+ BKA(@"my hint name") */ ...
  FROM (SELECT /*+ QB_NAME("my hint name") */ ...) ...
</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="index-hints"></a>8.9.4 インデックスヒント</h3></div></div></div><a class="indexterm" name="idm45661474586608"></a><a class="indexterm" name="idm45661474585152"></a><a class="indexterm" name="idm45661474583120"></a><a class="indexterm" name="idm45661474581888"></a><a class="indexterm" name="idm45661474580544"></a><a class="indexterm" name="idm45661474579200"></a><a class="indexterm" name="idm45661474577856"></a><a class="indexterm" name="idm45661474576512"></a><p>
        インデックスヒントは、クエリー処理中にインデックスを選択する方法に関するオプティマイザ情報を提供します。 ここで説明するインデックスヒントは、<a class="xref" href="optimization.html#optimizer-hints" title="8.9.3 オプティマイザヒント">セクション8.9.3「オプティマイザヒント」</a> で説明されているオプティマイザヒントとは異なります。 インデックスヒントとオプティマイザヒントは、別々に、または一緒に使用できます。 
      </p><p>
        インデックスヒントは、<code class="literal">SELECT</code> および <code class="literal">UPDATE</code> ステートメントにのみ適用されます。
      </p><p>
        インデックスヒントは、テーブル名の後に指定します。 (<code class="literal">SELECT</code> ステートメントでテーブルを指定するための一般的な構文は、<a class="xref" href="sql-statements.html#join" title="13.2.10.2 JOIN 句">セクション13.2.10.2「JOIN 句」</a> を参照してください。) インデックスヒントを含む個々のテーブルを参照する構文は、次のようになります: 
      </p><pre class="programlisting"><em class="replaceable"><code>tbl_name</code></em> [[AS] <em class="replaceable"><code>alias</code></em>] [<em class="replaceable"><code>index_hint_list</code></em>]

<em class="replaceable"><code>index_hint_list</code></em>:
    <em class="replaceable"><code>index_hint</code></em> [<em class="replaceable"><code>index_hint</code></em>] ...

<em class="replaceable"><code>index_hint</code></em>:
    USE {INDEX|KEY}
      [FOR {JOIN|ORDER BY|GROUP BY}] ([<em class="replaceable"><code>index_list</code></em>])
  | {IGNORE|FORCE} {INDEX|KEY}
      [FOR {JOIN|ORDER BY|GROUP BY}] (<em class="replaceable"><code>index_list</code></em>)

<em class="replaceable"><code>index_list</code></em>:
    <em class="replaceable"><code>index_name</code></em> [, <em class="replaceable"><code>index_name</code></em>] ...
</pre><p>
        <code class="literal">USE INDEX (<em class="replaceable"><code>index_list</code></em>)</code> ヒントは、名前付きインデックスのいずれかのみを使用してテーブル内の行を検索するように MySQL に指示します。 代替構文 <code class="literal">IGNORE INDEX (<em class="replaceable"><code>index_list</code></em>)</code> は、特定のインデックスを使用しないように MySQL に指示します。 これらのヒントは、<code class="literal">EXPLAIN</code> によって、MySQL が可能性のあるインデックスのリストから間違ったインデックスを使用していることが示された場合に役立ちます。 
      </p><p>
        <code class="literal">FORCE INDEX</code> ヒントは <code class="literal">USE INDEX (<em class="replaceable"><code>index_list</code></em>)</code> のように機能しますが、テーブルスキャンは <span class="emphasis"><em>very</em></span> コストが高いとみなされます。 つまり、テーブルスキャンは、名前付きインデックスのいずれかを使用してテーブル内の行を検索する方法がない場合にのみ使用されます。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL 8.0.20 の時点で、サーバーは、インデックスオプティマイザヒント <code class="literal">JOIN_INDEX</code>, <code class="literal">GROUP_INDEX</code>, <code class="literal">ORDER_INDEX</code>、および <code class="literal">INDEX</code>(<code class="literal">NO_JOIN_INDEX</code>, <code class="literal">NO_GROUP_INDEX</code>, <code class="literal">NO_ORDER_INDEX</code> および <code class="literal">FORCE INDEX</code> オプティマイザヒントに相当およびを置き替える)、および <code class="literal">NO_INDEX</code> オプティマイザヒント (<code class="literal">IGNORE INDEX</code> インデックスヒントに相当し、それらを置き換える) をサポートします。 したがって、<code class="literal">USE INDEX</code>、<code class="literal">FORCE INDEX</code> および <code class="literal">IGNORE INDEX</code> は、MySQL の将来のリリースで非推奨になり、後で完全に削除される予定です。 詳細は、<a class="xref" href="optimization.html#optimizer-hints-index-level" title="インデックスレベルのオプティマイザヒント">インデックスレベルのオプティマイザヒント</a>を参照してください。 
        </p></div><p>
        各ヒントには、カラム名ではなくインデックス名が必要です。 主キーを参照するには、<code class="literal">PRIMARY</code> という名前を使用します。 テーブルのインデックス名を表示するには、<code class="literal">SHOW INDEX</code> ステートメントまたは <code class="literal">INFORMATION_SCHEMA.STATISTICS</code> テーブルを使用します。 
      </p><p>
        <em class="replaceable"><code>index_name</code></em> 値は、完全なインデックス名である必要はありません。 インデックス名のあいまいでないプリフィクスにすることができます。 プリフィクスがあいまいな場合は、エラーが発生します。 
      </p><p>
        例:
      </p><pre class="programlisting">SELECT * FROM table1 USE INDEX (col1_index,col2_index)
  WHERE col1=1 AND col2=2 AND col3=3;

SELECT * FROM table1 IGNORE INDEX (col3_index)
  WHERE col1=1 AND col2=2 AND col3=3;
</pre><p>
        インデックスヒントの構文には、次の特性があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            構文的には、<em class="replaceable"><code>index_list</code></em> for <code class="literal">USE INDEX</code> (<span class="quote">「<span class="quote">「インデックスを使用しない」</span>」</span>を意味する) を省略することが有効です。 <em class="replaceable"><code>index_list</code></em> for <code class="literal">FORCE INDEX</code> または <code class="literal">IGNORE INDEX</code> の省略は構文エラーです。 
          </p></li><li class="listitem"><p>
            ヒントに <code class="literal">FOR</code> 句を追加することで、インデックスヒントの有効範囲を指定できます。 これにより、クエリー処理の様々なフェーズの実行計画のオプティマイザ選択をよりきめ細かく制御できます。 MySQL がテーブル内の行の検索方法および結合の処理方法を決定するときに使用されるインデックスにのみ影響を与えるには、<code class="literal">FOR JOIN</code> を使用します。 行をソートまたはグループ化するためのインデックス使用に影響を与えるには、<code class="literal">FOR ORDER BY</code> または <code class="literal">FOR GROUP BY</code> を使用します。 
          </p></li><li class="listitem"><p>
            複数のインデックスヒントを指定できます。
          </p><pre class="programlisting">SELECT * FROM t1 USE INDEX (i1) IGNORE INDEX FOR ORDER BY (i2) ORDER BY a;
</pre><p>
            (同じヒント内であっても) 複数のヒントで同じインデックスに名前を付けるとエラーになりません:
          </p><pre class="programlisting">SELECT * FROM t1 USE INDEX (i1) USE INDEX (i1,i1);
</pre><p>
            ただし、同じテーブルに対して <code class="literal">USE INDEX</code> と <code class="literal">FORCE INDEX</code> を混在させると、エラーが発生します。
          </p><pre class="programlisting">SELECT * FROM t1 USE INDEX FOR JOIN (i1) FORCE INDEX FOR JOIN (i2);
</pre></li></ul></div><p>
        インデックスヒントに <code class="literal">FOR</code> 句が含まれていない場合、ヒントの有効範囲はステートメントのすべての部分に適用されます。 たとえば、次のヒント 
      </p><pre class="programlisting">IGNORE INDEX (i1)
</pre><p>
        は次のヒントの組み合わせと同等です。
      </p><pre class="programlisting">IGNORE INDEX FOR JOIN (i1)
IGNORE INDEX FOR ORDER BY (i1)
IGNORE INDEX FOR GROUP BY (i1)
</pre><p>
        MySQL 5.0 では、<code class="literal">FOR</code> 句のないヒントスコープは、行の取得にのみ適用されました。 <code class="literal">FOR</code> 句が存在しないときにサーバーがこの古い動作を使用するようにするには、サーバーの起動時に <code class="literal">old</code> システム変数を有効にします。 レプリケーションセットアップでこの変数を有効にする場合は注意してください。 ステートメントベースのバイナリロギングでは、ソースとレプリカのモードが異なると、レプリケーションエラーが発生する可能性があります。 
      </p><p>
        インデックスヒントが処理されるとき、これらのインデックスヒントは、型 (<code class="literal">USE</code>、<code class="literal">FORCE</code>、<code class="literal">IGNORE</code>) およびスコープ (<code class="literal">FOR JOIN</code>、<code class="literal">FOR ORDER BY</code>、<code class="literal">FOR GROUP BY</code>) ごとに 1 つのリストに収集されます。 例: 
      </p><pre class="programlisting">SELECT * FROM t1
  USE INDEX () IGNORE INDEX (i2) USE INDEX (i1) USE INDEX (i2);
</pre><p>
        次と同等です。
      </p><pre class="programlisting">SELECT * FROM t1
   USE INDEX (i1,i2) IGNORE INDEX (i2);
</pre><p>
        そのあと、インデックスヒントは、スコープごとに次の順序で適用されます。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <code class="literal">{USE|FORCE} INDEX</code> が存在する場合は、これが適用されます。 (存在しない場合は、オプティマイザによって決定されたインデックスのセットが使用されます。)  
          </p></li><li class="listitem"><p>
            前の手順の結果に対して、<code class="literal">IGNORE INDEX</code> が適用されます。 たとえば、次の 2 つのクエリーは同等です。 
          </p><pre class="programlisting">SELECT * FROM t1 USE INDEX (i1) IGNORE INDEX (i2) USE INDEX (i2);

SELECT * FROM t1 USE INDEX (i1);
</pre></li></ol></div><p>
        <code class="literal">FULLTEXT</code> の検索の場合、インデックスヒントは次のように機能します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            自然言語モードの検索の場合、インデックスヒントは暗黙のうちに無視されます。 たとえば、<code class="literal">IGNORE INDEX(i1)</code> は警告なしで無視され、インデックスは引き続き使用されます。 
          </p></li><li class="listitem"><p>
            ブールモードの検索の場合、<code class="literal">FOR ORDER BY</code> または <code class="literal">FOR GROUP BY</code> を含むインデックスヒントは暗黙のうちに無視されます。 <code class="literal">FOR JOIN</code> を含むインデックスヒント、または <code class="literal">FOR</code> 修飾子を含まないインデックスヒントは受け付けられます。 ヒントが <code class="literal">FULLTEXT</code> 以外の検索に適用される場合とは異なり、このヒントは、クエリー実行のすべてのフェーズ (行の検索と取得、グループ化、および順序付け) に使用されます。 これは、ヒントが <code class="literal">FULLTEXT</code> 以外のインデックスに対して指定されている場合でも当てはまります。 
          </p><p>
            たとえば、次の 2 つのクエリーは同等です。
          </p><pre class="programlisting">SELECT * FROM t
  USE INDEX (index1)
  IGNORE INDEX (index1) FOR ORDER BY
  IGNORE INDEX (index1) FOR GROUP BY
  WHERE ... IN BOOLEAN MODE ... ;

SELECT * FROM t
  USE INDEX (index1)
  WHERE ... IN BOOLEAN MODE ... ;
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="cost-model"></a>8.9.5 オプティマイザコストモデル</h3></div></div></div><a class="indexterm" name="idm45661474482688"></a><a class="indexterm" name="idm45661474480576"></a><p>
        実行計画を生成するために、オプティマイザは、クエリーの実行中に発生する様々な操作のコストの見積りに基づくコストモデルを使用します。 オプティマイザには、実行計画に関する決定を下すために、コンパイル済のデフォルトの<span class="quote">「<span class="quote">「コスト定数」</span>」</span>のセットが用意されています。 
      </p><p>
        オプティマイザには、実行計画の作成時に使用するコスト見積りのデータベースもあります。 これらの見積りは、<code class="literal">mysql</code> システムデータベースの <code class="literal">server_cost</code> テーブルおよび <code class="literal">engine_cost</code> テーブルに格納され、いつでも構成できます。 これらのテーブルの目的は、オプティマイザがクエリー実行計画に到達しようとしたときに使用するコスト見積りを簡単に調整できるようにすることです。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#cost-model-operation" title="原価モデル一般工程">原価モデル一般工程</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#cost-model-database" title="コストモデルデータベース">コストモデルデータベース</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#cost-model-database-modifications" title="コストモデルデータベースの変更">コストモデルデータベースの変更</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="cost-model-operation"></a>原価モデル一般工程</h4></div></div></div><p>
          構成可能なオプティマイザコストモデルは、次のように動作します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              サーバーは、起動時にコストモデルテーブルをメモリーに読み取り、実行時にインメモリー値を使用します。 テーブルに指定されている <code class="literal">NULL</code> 以外のコスト見積りは、対応するコンパイル済のデフォルトのコスト定数より優先されます。 <code class="literal">NULL</code> の見積りは、コンパイル済のデフォルトを使用するようオプティマイザに指示します。 
            </p></li><li class="listitem"><p>
              実行時に、サーバーはコストテーブルを再度読み取ることができます。 これは、ストレージエンジンが動的にロードされたとき、または <code class="literal">FLUSH OPTIMIZER_COSTS</code> ステートメントが実行されたときに発生します。 
            </p></li><li class="listitem"><p>
              原価テーブルを使用すると、サーバー管理者はテーブルのエントリを変更することで、原価見積を簡単に調整できます。 また、エントリコストを <code class="literal">NULL</code> に設定することで、デフォルトに戻すことも簡単です。 オプティマイザはインメモリーのコスト値を使用するため、テーブルに対する変更の後に <code class="literal">FLUSH OPTIMIZER_COSTS</code> を実行して有効にする必要があります。 
            </p></li><li class="listitem"><p>
              クライアントセッションの開始時に現在のメモリー内コストの見積りは、そのセッションが終了するまでそのセッション全体に適用されます。 特に、サーバーがコストテーブルを再度読み取る場合、変更された見積りはその後に開始されるセッションにのみ適用されます。 既存のセッションは影響を受けません。 
            </p></li><li class="listitem"><p>
              コストテーブルは、特定のサーバーインスタンスに固有です。 サーバーは、コストテーブルの変更をレプリカにレプリケートしません。 
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="cost-model-database"></a>コストモデルデータベース</h4></div></div></div><p>
          オプティマイザコストモデルデータベースは、クエリーの実行中に発生する操作のコスト見積り情報を含む、<code class="literal">mysql</code> システムデータベース内の次の 2 つのテーブルで構成されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <a class="indexterm" name="idm45661474452912"></a> <a class="indexterm" name="idm45661474450992"></a> <code class="literal">server_cost</code>: 一般的なサーバー操作のオプティマイザコストの見積り
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm45661474447648"></a> <a class="indexterm" name="idm45661474445728"></a> <code class="literal">engine_cost</code>: 特定のストレージエンジンに固有の操作のオプティマイザコストの見積り
            </p></li></ul></div><p>
          <code class="literal">server_cost</code> テーブルには、次のカラムが含まれます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">cost_name</code>
            </p><p>
              コストモデルで使用されるコスト見積の名前。 名前では大文字と小文字は区別されません。 このテーブルの読取り時にサーバーがコスト名を認識しない場合、エラーログに警告が書き込まれます。 
            </p></li><li class="listitem"><p>
              <code class="literal">cost_value</code>
            </p><p>
              コスト見積値。 値が <code class="literal">NULL</code> 以外の場合、サーバーはそれをコストとして使用します。 それ以外の場合は、デフォルトの見積り (コンパイルされた値) が使用されます。 DBA は、このカラムを更新することでコスト見積りを変更できます。 サーバーは、このテーブルの読み取り時にコスト値が無効 (正でない) であることを検出すると、エラーログに警告を書き込みます。 
            </p><p>
              (<code class="literal">NULL</code> を指定するエントリの) デフォルトのコスト見積を上書きするには、コストを <code class="literal">NULL</code> 以外の値に設定します。 デフォルトに戻すには、値を <code class="literal">NULL</code> に設定します。 次に、<code class="literal">FLUSH OPTIMIZER_COSTS</code> を実行して、コストテーブルを再度読み取るようにサーバーに指示します。 
            </p></li><li class="listitem"><p>
              <code class="literal">last_update</code>
            </p><p>
              最後の行更新の時刻。
            </p></li><li class="listitem"><p>
              <code class="literal">comment</code>
            </p><p>
              原価見積に関連付けられた摘要コメント。 DBA は、このカラムを使用して、コスト見積り行に特定の値が格納される理由に関する情報を提供できます。 
            </p></li><li class="listitem"><p>
              <code class="literal">default_value</code>
            </p><p>
              原価見積のデフォルト (コンパイル済) 値。 このカラムは、関連するコスト見積りが変更された場合でもその値を保持する読取り専用の生成カラムです。 実行時にテーブルに追加される行の場合、このカラムの値は <code class="literal">NULL</code> です。 
            </p></li></ul></div><p>
          <code class="literal">server_cost</code> テーブルの主キーは <code class="literal">cost_name</code> カラムであるため、コスト見積りに対して複数のエントリを作成することはできません。
        </p><p>
          サーバーは、<code class="literal">server_cost</code> テーブルの次の <code class="literal">cost_name</code> 値を認識します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">disk_temptable_create_cost</code>, <code class="literal">disk_temptable_row_cost</code>
            </p><p>
              ディスクベースのストレージエンジン (<code class="literal">InnoDB</code> または <code class="literal">MyISAM</code>) に格納されている内部的に作成された一時テーブルのコスト見積り。 これらの値を大きくすると、内部一時テーブルを使用するコストの見積りが増加し、オプティマイザがクエリー計画を使用しやすくなります。 このようなテーブルの詳細は、<a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4 MySQL での内部一時テーブルの使用">セクション8.4.4「MySQL での内部一時テーブルの使用」</a> を参照してください。 
            </p><p>
              これらのディスクパラメータのデフォルト値が、対応するメモリーパラメータ (<code class="literal">memory_temptable_create_cost</code>、<code class="literal">memory_temptable_row_cost</code>) のデフォルト値より大きいほど、ディスクベースのテーブルの処理コストが高くなります。
            </p></li><li class="listitem"><p>
              <code class="literal">key_compare_cost</code>
            </p><a class="indexterm" name="idm45661474410176"></a><a class="indexterm" name="idm45661474408672"></a><p>
              レコードキーを比較するコスト。 この値を増やすと、多数のキーを比較するクエリー計画のコストが高くなります。 たとえば、<code class="literal">filesort</code> を実行するクエリー計画は、インデックスを使用したソートを回避するクエリー計画よりも比較的コストが高くなります。 
            </p></li><li class="listitem"><p>
              <code class="literal">memory_temptable_create_cost</code>, <code class="literal">memory_temptable_row_cost</code>
            </p><p>
              <code class="literal">MEMORY</code> ストレージエンジンに格納されている内部的に作成された一時テーブルのコスト見積り。 これらの値を大きくすると、内部一時テーブルを使用するコストの見積りが増加し、オプティマイザがクエリー計画を使用しやすくなります。 このようなテーブルの詳細は、<a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4 MySQL での内部一時テーブルの使用">セクション8.4.4「MySQL での内部一時テーブルの使用」</a> を参照してください。 
            </p><p>
              これらのメモリーパラメータのデフォルト値が、対応するディスクパラメータ (<code class="literal">disk_temptable_create_cost</code>、<code class="literal">disk_temptable_row_cost</code>) のデフォルト値より小さいほど、メモリーベースのテーブルの処理コストは低くなります。
            </p></li><li class="listitem"><p>
              <code class="literal">row_evaluate_cost</code>
            </p><p>
              レコード条件を評価するコスト。 この値を増やすと、多数の行を調査するクエリー計画が、調査する行数が少ないクエリー計画よりもコストが高くなります。 たとえば、読取り行数が少ないレンジスキャンよりも、テーブルスキャンの方が比較的コストが高くなります。 
            </p></li></ul></div><p>
          <code class="literal">engine_cost</code> テーブルには、次のカラムが含まれます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">engine_name</code>
            </p><p>
              このコスト見積りが適用されるストレージエンジンの名前。 名前では大文字と小文字は区別されません。 値が <code class="literal">default</code> の場合は、独自の名前付きエントリを持たないすべてのストレージエンジンに適用されます。 このテーブルの読取り時にサーバーがエンジン名を認識しない場合、エラーログに警告が書き込まれます。 
            </p></li><li class="listitem"><p>
              <code class="literal">device_type</code>
            </p><p>
              この原価見積が適用される設備タイプ。 このカラムは、ハードディスクドライブとソリッドステートドライブなど、ストレージデバイスタイプごとに異なるコスト見積りを指定するためのものです。 現在、この情報は使用されず、許可される値は 0 のみです。 
            </p></li><li class="listitem"><p>
              <code class="literal">cost_name</code>
            </p><p>
              <code class="literal">server_cost</code> テーブルと同じです。
            </p></li><li class="listitem"><p>
              <code class="literal">cost_value</code>
            </p><p>
              <code class="literal">server_cost</code> テーブルと同じです。
            </p></li><li class="listitem"><p>
              <code class="literal">last_update</code>
            </p><p>
              <code class="literal">server_cost</code> テーブルと同じです。
            </p></li><li class="listitem"><p>
              <code class="literal">comment</code>
            </p><p>
              <code class="literal">server_cost</code> テーブルと同じです。
            </p></li><li class="listitem"><p>
              <code class="literal">default_value</code>
            </p><p>
              原価見積のデフォルト (コンパイル済) 値。 このカラムは、関連するコスト見積りが変更された場合でもその値を保持する読取り専用の生成カラムです。 実行時にテーブルに追加される行の場合、このカラムの値は <code class="literal">NULL</code> ですが、行の <code class="literal">cost_name</code> 値が元の行のいずれかと同じ場合、<code class="literal">default_value</code> カラムの値はその行と同じになります。 
            </p></li></ul></div><p>
          <code class="literal">engine_cost</code> テーブルの主キーは (<code class="literal">cost_name</code>, <code class="literal">engine_name</code>, <code class="literal">device_type</code>) カラムで構成されるタプルであるため、これらのカラムの値の組合せに対して複数のエントリを作成することはできません。
        </p><p>
          サーバーは、<code class="literal">engine_cost</code> テーブルの次の <code class="literal">cost_name</code> 値を認識します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">io_block_read_cost</code>
            </p><p>
              ディスクからインデックスまたはデータブロックを読み取るコスト。 この値を増やすと、多くのディスクブロックを読み取るクエリー計画が、読み取るディスクブロックが少ないクエリー計画よりもコストが高くなります。 たとえば、読取りブロック数が少ないレンジスキャンよりも、テーブルスキャンの方が比較的コストが高くなります。 
            </p></li><li class="listitem"><p>
              <code class="literal">memory_block_read_cost</code>
            </p><p>
              <code class="literal">io_block_read_cost</code> と似ていますが、インメモリーデータベースバッファからインデックスまたはデータブロックを読み取るコストを表します。
            </p></li></ul></div><p>
          <code class="literal">io_block_read_cost</code> と <code class="literal">memory_block_read_cost</code> の値が異なる場合、同じクエリーの 2 つの実行間で実行計画が変わる可能性があります。 メモリーアクセスのコストがディスクアクセスのコストよりも低いとします。 その場合、データがメモリー内にあるため、データがバッファプールに読み取られる前のサーバー起動時に、クエリーの実行後とは異なる計画が得られることがあります。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="cost-model-database-modifications"></a>コストモデルデータベースの変更</h4></div></div></div><p>
          コストモデルパラメータをデフォルトから変更する DBA の場合は、値を二重または停止して効果を測定してください。
        </p><p>
          <code class="literal">io_block_read_cost</code> および <code class="literal">memory_block_read_cost</code> パラメータを変更すると、結果が得られる価値が高くなる可能性があります。 これらのパラメータ値を使用すると、データアクセス方法のコストモデルで、様々なソースからの情報の読取りコスト (ディスクからの情報の読取りコストとメモリーバッファにすでに存在する情報の読取りコスト) を考慮できます。 たとえば、<code class="literal">io_block_read_cost</code> を <code class="literal">memory_block_read_cost</code> より大きい値に設定すると、メモリーにすでに保持されている情報を読み取るクエリー計画が、ディスクから読み取る必要がある計画よりもオプティマイザによって優先されます。 
        </p><p>
          次の例では、<code class="literal">io_block_read_cost</code> のデフォルト値を変更する方法を示します:
        </p><pre class="programlisting">UPDATE mysql.engine_cost
  SET cost_value = 2.0
  WHERE cost_name = 'io_block_read_cost';
FLUSH OPTIMIZER_COSTS;
</pre><p>
          次の例では、<code class="literal">InnoDB</code> ストレージエンジンについてのみ <code class="literal">io_block_read_cost</code> の値を変更する方法を示します:
        </p><pre class="programlisting">INSERT INTO mysql.engine_cost
  VALUES ('InnoDB', 0, 'io_block_read_cost', 3.0,
  CURRENT_TIMESTAMP, 'Using a slower disk for InnoDB');
FLUSH OPTIMIZER_COSTS;
</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizer-statistics"></a>8.9.6 オプティマイザ統計</h3></div></div></div><a class="indexterm" name="idm45661474345200"></a><a class="indexterm" name="idm45661474342992"></a><p>
        <code class="literal">column_statistics</code> データディクショナリテーブルには、オプティマイザがクエリー実行計画を作成するために使用する、カラム値に関するヒストグラム統計が格納されます。 ヒストグラム管理を実行するには、<code class="literal">ANALYZE TABLE</code> ステートメントを使用します。 
      </p><p>
        <code class="literal">column_statistics</code> テーブルには、次の特性があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            このテーブルには、ジオメトリタイプ (空間データ) および <code class="literal">JSON</code> を除くすべてのデータ型のカラムの統計が含まれます。
          </p></li><li class="listitem"><p>
            テーブルは永続的であるため、サーバーが起動するたびにカラム統計を作成する必要はありません。
          </p></li><li class="listitem"><p>
            サーバーはテーブルの更新を実行しますが、ユーザーは実行しません。
          </p></li></ul></div><p>
        <code class="literal">column_statistics</code> テーブルはデータディクショナリの一部であるため、ユーザーは直接アクセスできません。 ヒストグラム情報は、データディクショナリテーブルのビューとして実装されている <code class="literal">INFORMATION_SCHEMA.COLUMN_STATISTICS</code> を使用して入手できます。 <code class="literal">COLUMN_STATISTICS</code> には、次のカラムがあります: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">SCHEMA_NAME</code>, <code class="literal">TABLE_NAME</code>, <code class="literal">COLUMN_NAME</code>: 統計が適用されるスキーマ、テーブルおよびカラムの名前。
          </p></li><li class="listitem"><p>
            <code class="literal">HISTOGRAM</code>: ヒストグラムとして格納される、カラム統計を記述する <code class="literal">JSON</code> 値。
          </p></li></ul></div><p>
        カラムヒストグラムには、カラムに格納されている値の範囲の一部のバケットが含まれます。 ヒストグラムは、カラム統計の柔軟な表現を可能にする <code class="literal">JSON</code> オブジェクトです。 ヒストグラムオブジェクトのサンプルを次に示します: 
      </p><pre class="programlisting">{
  "buckets": [
    [
      1,
      0.3333333333333333
    ],
    [
      2,
      0.6666666666666666
    ],
    [
      3,
      1
    ]
  ],
  "null-values": 0,
  "last-updated": "2017-03-24 13:32:40.000000",
  "sampling-rate": 1,
  "histogram-type": "singleton",
  "number-of-buckets-specified": 128,
  "data-type": "int",
  "collation-id": 8
}
</pre><p>
        ヒストグラムオブジェクトには、次のキーがあります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">buckets</code>: ヒストグラムバケット。 バケット構造はヒストグラムタイプによって異なります。 
          </p><p>
            <code class="literal">singleton</code> ヒストグラムの場合、バケットには次の 2 つの値が含まれます:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                値 1: バケットの値。 型はカラムのデータ型によって異なります。 
              </p></li><li class="listitem"><p>
                値 2: 値の累積周波数を表す double。 たとえば、.25 および .75 は、カラムの値の 25% および 75% がバケット値以下であることを示します。 
              </p></li></ul></div><p>
            <code class="literal">equi-height</code> ヒストグラムの場合、バケットには次の 4 つの値が含まれます:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                値 1, 2: バケットの下限値と上限値。 型はカラムのデータ型によって異なります。 
              </p></li><li class="listitem"><p>
                値 3: 値の累積周波数を表す double。 たとえば、.25 および .75 は、カラムの値の 25% および 75% がバケットの上限値以下であることを示します。 
              </p></li><li class="listitem"><p>
                値 4: バケットの下限値から上限値までの範囲内の個別値の数。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">null-values</code>: 0.0 と 1.0 の間の数値で、SQL <code class="literal">NULL</code> 値であるカラム値の割合を示します。 0 の場合、カラムに <code class="literal">NULL</code> 値は含まれません。 
          </p></li><li class="listitem"><p>
            <code class="literal">last-updated</code> : ヒストグラムが生成された日時 (<em class="replaceable"><code>YYYY-MM-DD hh:mm:ss.uuuuuu</code></em> 形式の UTC 値として)。
          </p></li><li class="listitem"><p>
            <code class="literal">sampling-rate</code>: ヒストグラムを作成するためにサンプリングされたデータの割合を示す、0.0 と 1.0 の間の数値。 値 1 は、すべてのデータが読み取られたことを意味します (サンプリングなし)。 
          </p></li><li class="listitem"><p>
            <code class="literal">histogram-type</code> : ヒストグラムタイプ:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">singleton</code>: 1 つのバケットは、カラム内の 1 つの値を表します。 このヒストグラムタイプは、カラムの個別値の数が、ヒストグラムを生成した <code class="literal">ANALYZE TABLE</code> ステートメントで指定されたバケットの数以下の場合に作成されます。 
              </p></li><li class="listitem"><p>
                <code class="literal">equi-height</code>: 1 つのバケットは値の範囲を表します。 このヒストグラムタイプは、カラム内の個別値の数が、ヒストグラムを生成した <code class="literal">ANALYZE TABLE</code> ステートメントで指定されたバケットの数より多い場合に作成されます。 
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">number-of-buckets-specified</code>: ヒストグラムを生成した <code class="literal">ANALYZE TABLE</code> ステートメントで指定されたバケットの数。
          </p></li><li class="listitem"><p>
            <code class="literal">data-type</code>: このヒストグラムに含まれるデータのタイプ。 これは、永続記憶域からメモリーにヒストグラムを読み取って解析する場合に必要です。 値は、<code class="literal">int</code>、<code class="literal">uint</code> (符号なし整数)、<code class="literal">double</code>, <code class="literal">decimal</code>, <code class="literal">datetime</code> または <code class="literal">string</code> (文字列およびバイナリ文字列を含む) のいずれかです。 
          </p></li><li class="listitem"><p>
            <code class="literal">collation-id</code>: ヒストグラムデータの照合 ID。 これは、<code class="literal">data-type</code> 値が <code class="literal">string</code> の場合に最も意味があります。 値は、<code class="literal">INFORMATION_SCHEMA.COLLATIONS</code> テーブルの <code class="literal">ID</code> カラムの値に対応します。 
          </p></li></ul></div><p>
        ヒストグラムオブジェクトから特定の値を抽出するには、<code class="literal">JSON</code> 操作を使用できます。 例: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT</code></strong>
         <strong class="userinput"><code>TABLE_NAME, COLUMN_NAME,</code></strong>
         <strong class="userinput"><code>HISTOGRAM-&gt;&gt;'$."data-type"' AS 'data-type',</code></strong>
         <strong class="userinput"><code>JSON_LENGTH(HISTOGRAM-&gt;&gt;'$."buckets"') AS 'bucket-count'</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.COLUMN_STATISTICS;</code></strong>
+-----------------+-------------+-----------+--------------+
| TABLE_NAME      | COLUMN_NAME | data-type | bucket-count |
+-----------------+-------------+-----------+--------------+
| country         | Population  | int       |          226 |
| city            | Population  | int       |         1024 |
| countrylanguage | Language    | string    |          457 |
+-----------------+-------------+-----------+--------------+
</pre><p>
        オプティマイザは、統計が収集されるデータ型のカラムにヒストグラム統計を使用します (該当する場合)。 オプティマイザはヒストグラム統計を適用し、定数値に対するカラム値の比較の選択性 (フィルタリング効果) に基づいて行の見積りを決定します。 これらのフォームの述語は、ヒストグラムの使用に適しています: 
      </p><pre class="programlisting"><em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>constant</code></em>
<em class="replaceable"><code>col_name</code></em> &lt;&gt; <em class="replaceable"><code>constant</code></em>
<em class="replaceable"><code>col_name</code></em> != <em class="replaceable"><code>constant</code></em>
<em class="replaceable"><code>col_name</code></em> &gt; <em class="replaceable"><code>constant</code></em>
<em class="replaceable"><code>col_name</code></em> &lt; <em class="replaceable"><code>constant</code></em>
<em class="replaceable"><code>col_name</code></em> &gt;= <em class="replaceable"><code>constant</code></em>
<em class="replaceable"><code>col_name</code></em> &lt;= <em class="replaceable"><code>constant</code></em>
<em class="replaceable"><code>col_name</code></em> IS NULL
<em class="replaceable"><code>col_name</code></em> IS NOT NULL
<em class="replaceable"><code>col_name</code></em> BETWEEN <em class="replaceable"><code>constant</code></em> AND <em class="replaceable"><code>constant</code></em>
<em class="replaceable"><code>col_name</code></em> NOT BETWEEN <em class="replaceable"><code>constant</code></em> AND <em class="replaceable"><code>constant</code></em>
<em class="replaceable"><code>col_name</code></em> IN (<em class="replaceable"><code>constant</code></em>[, <em class="replaceable"><code>constant</code></em>] ...)
<em class="replaceable"><code>col_name</code></em> NOT IN (<em class="replaceable"><code>constant</code></em>[, <em class="replaceable"><code>constant</code></em>] ...)
</pre><p>
        たとえば、次のステートメントにはヒストグラムの使用に適した述語が含まれています:
      </p><pre class="programlisting">SELECT * FROM orders WHERE amount BETWEEN 100.0 AND 300.0;
SELECT * FROM tbl WHERE col1 = 15 AND col2 &gt; 100;
</pre><p>
        定数値と比較するための要件には、<code class="literal">ABS()</code> や <code class="literal">FLOOR()</code> などの定数である関数が含まれます:
      </p><pre class="programlisting">SELECT * FROM tbl WHERE col1 &lt; ABS(-34);
</pre><p>
        ヒストグラム統計は、主にインデックス付けされていないカラムに役立ちます。 ヒストグラム統計が適用可能なカラムにインデックスを追加すると、オプティマイザが行の見積りを行うのにも役立ちます。 トレードオフは次のとおりです: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブルデータが変更された場合は、インデックスを更新する必要があります。
          </p></li><li class="listitem"><p>
            ヒストグラムはオンデマンドでのみ作成または更新されるため、テーブルデータの変更時にオーバーヘッドは発生しません。 一方、統計は、次回更新されるまで、テーブルの変更が発生すると徐々に期限切れになります。 
          </p></li></ul></div><p>
        オプティマイザは、ヒストグラム統計から取得したものよりも範囲オプティマイザ行の見積りを優先します。 オプティマイザが範囲オプティマイザが適用されると判断した場合、ヒストグラム統計は使用されません。 
      </p><p>
        インデックス付けされたカラムの場合、インデックス除算を使用して等価比較のために行の見積りを取得できます (<a class="xref" href="optimization.html#range-optimization" title="8.2.1.2 range の最適化">セクション8.2.1.2「range の最適化」</a> を参照)。 この場合、ヒストグラム統計は必ずしも役に立つとはかぎりません。これは、インデックスの分割によって見積もりが向上するためです。 
      </p><p>
        ヒストグラム統計を使用しても、クエリーの実行が改善されない場合があります (統計が最新でない場合など)。 この場合に該当するかどうかを確認するには、<code class="literal">ANALYZE TABLE</code> を使用してヒストグラム統計を再生成し、クエリーを再実行します。 
      </p><p>
        または、ヒストグラム統計を無効にするには、<code class="literal">ANALYZE TABLE</code> を使用して削除します。 ヒストグラム統計を無効にする別の方法は、<code class="literal">optimizer_switch</code> システム変数の <code class="literal">condition_fanout_filter</code> フラグをオフにすることです (ただし、他の最適化も無効になる可能性があります): 
      </p><pre class="programlisting">SET optimizer_switch='condition_fanout_filter=off';
</pre><p>
        ヒストグラム統計が使用されている場合、結果の効果は <code class="literal">EXPLAIN</code> を使用して確認できます。 カラム <code class="literal">col1</code> に使用可能なインデックスがない次のクエリーについて考えてみます: 
      </p><pre class="programlisting">SELECT * FROM t1 WHERE col1 &lt; 24;
</pre><p>
        ヒストグラム統計で、<code class="literal">t1</code> の行の 57% が <code class="literal">col1 &lt; 24</code> 述語を満たしていることが示されている場合、インデックスがなくてもフィルタリングが発生し、<code class="literal">EXPLAIN</code> の <code class="literal">filtered</code> カラムに 57.00 が表示されます。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="buffering-caching"></a>8.10 バッファリングとキャッシュ</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#innodb-buffer-pool-optimization">8.10.1 InnoDB バッファプールの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#myisam-key-cache">8.10.2 MyISAM キーキャッシュ</a></span></dt><dt><span class="section"><a href="optimization.html#statement-caching">8.10.3 プリペアドステートメントおよびストアドプログラムのキャッシュ</a></span></dt></dl></div><p>
      MySQL は、パフォーマンスを向上するため、メモリーバッファーに情報をキャッシュするいくつかの戦略を使用します。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-buffer-pool-optimization"></a>8.10.1 InnoDB バッファプールの最適化</h3></div></div></div><a class="indexterm" name="idm45661474228160"></a><a class="indexterm" name="idm45661474226720"></a><a class="indexterm" name="idm45661474225344"></a><p>
        <code class="literal">InnoDB</code> は、データとインデックスをメモリーにキャッシュするための<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>と呼ばれるストレージ領域を維持しています。 <code class="literal">InnoDB</code> バッファープールの仕組みを知り、頻繁にアクセスされるデータをメモリーに維持するためにそれを利用することは、MySQL チューニングの重要な側面です。 
      </p><p>
        <code class="literal">InnoDB</code> バッファープールの内部動作、LRU 置換アルゴリズムの概要、および一般的な構成情報については、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool" title="15.5.1 バッファプール">セクション15.5.1「バッファプール」</a> を参照してください。
      </p><p>
        その他の <code class="literal">InnoDB</code> バッファープールの構成およびチューニング情報については、これらのセクションを参照してください:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="xref" href="innodb-storage-engine.html#innodb-performance-read_ahead" title="15.8.3.4 InnoDB バッファープールのプリフェッチ (先読み) の構成">セクション15.8.3.4「InnoDB バッファープールのプリフェッチ (先読み) の構成」</a>
          </p></li><li class="listitem"><p>
            <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-flushing" title="15.8.3.5 バッファープールのフラッシュの構成">セクション15.8.3.5「バッファープールのフラッシュの構成」</a>
          </p></li><li class="listitem"><p>
            <a class="xref" href="innodb-storage-engine.html#innodb-performance-midpoint_insertion" title="15.8.3.3 バッファープールをスキャンに耐えられるようにする">セクション15.8.3.3「バッファープールをスキャンに耐えられるようにする」</a>
          </p></li><li class="listitem"><p>
            <a class="xref" href="innodb-storage-engine.html#innodb-multiple-buffer-pools" title="15.8.3.2 複数のバッファープールインスタンスの構成">セクション15.8.3.2「複数のバッファープールインスタンスの構成」</a>
          </p></li><li class="listitem"><p>
            <a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="15.8.3.6 バッファープールの状態の保存と復元">セクション15.8.3.6「バッファープールの状態の保存と復元」</a>
          </p></li><li class="listitem"><p>
            <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-resize" title="15.8.3.1 InnoDB バッファプールサイズの構成">セクション15.8.3.1「InnoDB バッファプールサイズの構成」</a>
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="myisam-key-cache"></a>8.10.2 MyISAM キーキャッシュ</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#shared-key-cache">8.10.2.1 共有キーキャッシュアクセス</a></span></dt><dt><span class="section"><a href="optimization.html#multiple-key-caches">8.10.2.2 複合キーキャッシュ</a></span></dt><dt><span class="section"><a href="optimization.html#midpoint-insertion">8.10.2.3 ミッドポイント挿入戦略</a></span></dt><dt><span class="section"><a href="optimization.html#index-preloading">8.10.2.4 インデックスプリロード</a></span></dt><dt><span class="section"><a href="optimization.html#key-cache-block-size">8.10.2.5 キーキャッシュブロックサイズ</a></span></dt><dt><span class="section"><a href="optimization.html#key-cache-restructuring">8.10.2.6 キーキャッシュの再構築</a></span></dt></dl></div><a class="indexterm" name="idm45661474206272"></a><a class="indexterm" name="idm45661474204832"></a><p>
        ディスク I/O を最小にするために、<code class="literal">MyISAM</code> ストレージエンジンは多くのデータベース管理システムで使用されている戦略を利用します。 それは、もっとも頻繁にアクセスされるテーブルブロックをメモリー内で保持するキャッシュメカニズムを採用しています。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            インデックスブロックの場合、<span class="firstterm">キーキャッシュ</span> (または<span class="firstterm">キーバッファー</span>) と呼ばれる特別な構造が維持されます。 その構造には、もっとも多く使用されるインデックスブロックが置かれる多数のブロックバッファーが含まれます。 
          </p></li><li class="listitem"><p>
            データブロックに対しては、MySQL は特別なキャッシュを使用しません。 代わりに、ネイティブオペレーティングシステムのファイルシステムキャッシュに依存します。 
          </p></li></ul></div><p>
        このセクションではまず <code class="literal">MyISAM</code> キーキャッシュの基本動作について説明します。 次に、キーキャッシュパフォーマンスを向上させる機能と、キャッシュ操作をより適切に制御できるようにする機能について説明します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            複数のセッションが同時にキャッシュにアクセスできます。
          </p></li><li class="listitem"><p>
            複数のキーキャッシュをセットアップし、特定のキャッシュにテーブルインデックスを割り当てることができます。
          </p></li></ul></div><p>
        キーキャッシュのサイズを制御するには、<code class="literal">key_buffer_size</code> システム変数を使用します。 この変数がゼロに設定されている場合、キーキャッシュは使われません。 キーキャッシュは、<code class="literal">key_buffer_size</code> 値が小さすぎて、最小数のブロックバッファー (8) を割り当てられない場合も使用されません。 
      </p><p>
        キーキャッシュが動作していない場合、インデックスファイルはオペレーティングシステムによって提供されるネイティブファイルシステムバッファリングのみを使用してアクセスされます。 (つまり、テーブルインデックスブロックは、テーブルデータブロックに採用されている同じ戦略を使用してアクセスされます。) 
      </p><p>
        インデックスブロックは <code class="literal">MyISAM</code> インデックスファイルへの連続したアクセスの単位です。 通常、インデックスブロックのサイズは、インデックス B ツリーのノードのサイズと等しくなります。 (インデックスはディスク上で B ツリーデータ構造を使用して表されます。 ツリーの下部にあるノードはリーフノードです。 リーフノードの上にあるノードは非リーフノードです。)  
      </p><p>
        キーキャッシュ構造内のすべてのブロックバッファーは同じサイズです。 このサイズは、テーブルインデックスブロックのサイズと等しいか、大きいか、小さくできます。 通常これら 2 つの値のうちの一方は、他方の倍数になります。 
      </p><p>
        いずれかのテーブルインデックスブロックのデータにアクセスする必要がある場合、サーバーはまず、キーキャッシュの何らかのブロックバッファーでそれを使用できるかどうかを確認します。 そうである場合、サーバーはディスク上ではなく、キーキャッシュ内のデータにアクセスします。 つまり、ディスクから読み取ったり、それに書き込んだりするのではなく、キャッシュから読み取ったり、それに書き込んだりします。 そうでない場合、サーバーは別のテーブルインデックスブロックを含むキャッシュブロックバッファーを選択し、そのデータを必要なテーブルインデックスブロックのコピーで置き換えます。 新しいインデックスブロックがキャッシュに入れられるとただちに、インデックスデータにアクセスできます。 
      </p><p>
        置き換えのために選択されているブロックが変更されていた場合、ブロックは<span class="quote">「<span class="quote">ダーティー</span>」</span>とみなされます。 この場合、置き換えられる前に、その内容が取得元のテーブルインデックスにフラッシュされます。 
      </p><p>
        通常サーバーは <span class="firstterm">LRU (Least Recently Used)</span> 戦略に従います。置き換えるブロックを選択する場合、直近で使用されていないインデックスブロックを選択します。 この選択を簡単にするため、キーキャッシュモジュールは、使用されたすべてのブロックを特別なリスト (<span class="firstterm">LRU チェーン</span>) に使用時間で順序付けして保持しています。 ブロックがアクセスされると、それは直近で使用されたものになり、リストの末尾に置かれます。 ブロックを置き換える必要がある場合、リストの先頭にあるブロックが、直近で使用されていないことになり、エビクションの最初の候補になります。 
      </p><p>
        <code class="literal">InnoDB</code> ストレージエンジンは、そのバッファープールを管理するためにも LRU アルゴリズムを使用します。 <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool" title="15.5.1 バッファプール">セクション15.5.1「バッファプール」</a>を参照してください。 
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="shared-key-cache"></a>8.10.2.1 共有キーキャッシュアクセス</h4></div></div></div><p>
          スレッドはキーキャッシュバッファーに同時にアクセスでき、次の条件に従います。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              更新中でないバッファーは複数のセッションによってアクセスできます。
            </p></li><li class="listitem"><p>
              更新中のバッファーは、更新が完了するまで、それを使用する必要があるセッションを待機させます。
            </p></li><li class="listitem"><p>
              複数のセッションは、互いに干渉しないかぎり (つまり、それらは異なるインデックスブロックを必要とし、そのため、異なるキャッシュブロックが置き換えられるかぎり)、キャッシュブロックの置換を引き起こすリクエストを開始できます。
            </p></li></ul></div><p>
          キーキャッシュへの共有アクセスによって、サーバーのスループットを大幅に向上できます。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="multiple-key-caches"></a>8.10.2.2 複合キーキャッシュ</h4></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            MySQL 8.0 では、複数の <code class="literal">MyISAM</code> キーキャッシュを参照するためにここで説明する複合部分構造変数構文は非推奨になりました。
          </p></div><p>
          キーキャッシュへの共有アクセスはパフォーマンスを向上させますが、セッション間の競合を完全には排除しません。 それらはまだキーキャッシュバッファーへのアクセスを管理する制御構造を得るために争います。 キーキャッシュアクセスの競合をもっと軽減するために、MySQL は複合キーキャッシュも提供しています。 この機能により、異なるキーキャッシュにさまざまなテーブルインデックスを割り当てることができます。 
        </p><p>
          複合キーキャッシュがある場合、サーバーは特定の <code class="literal">MyISAM</code> テーブルに対してクエリーを処理する際に、使用すべきキャッシュを知っている必要があります。 デフォルトでは、すべての <code class="literal">MyISAM</code> テーブルインデックスはデフォルトのキーキャッシュにキャッシュされます。 テーブルインデックスを特定のキーキャッシュに割り当てるには、<code class="literal">CACHE INDEX</code> ステートメントを使用します (<a class="xref" href="sql-statements.html#cache-index" title="13.7.8.2 CACHE INDEX ステートメント">セクション13.7.8.2「CACHE INDEX ステートメント」</a>を参照してください)。 たとえば、次のステートメントは <code class="literal">t1</code>、<code class="literal">t2</code>、および <code class="literal">t3</code> テーブルから、<code class="literal">hot_cache</code> という名前のキーキャッシュにインデックスを割り当てます。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CACHE INDEX t1, t2, t3 IN hot_cache;</code></strong>
+---------+--------------------+----------+----------+
| Table   | Op                 | Msg_type | Msg_text |
+---------+--------------------+----------+----------+
| test.t1 | assign_to_keycache | status   | OK       |
| test.t2 | assign_to_keycache | status   | OK       |
| test.t3 | assign_to_keycache | status   | OK       |
+---------+--------------------+----------+----------+
</pre><p>
          <code class="literal">CACHE INDEX</code> ステートメントで参照されているキーキャッシュは、<code class="literal">SET GLOBAL</code> パラメータ設定ステートメントでそのサイズを設定するか、またはサーバー起動オプションを使用して作成できます。 例: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL keycache1.key_buffer_size=128*1024;</code></strong>
</pre><p>
          キーキャッシュを破棄するには、そのサイズをゼロに設定します。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL keycache1.key_buffer_size=0;</code></strong>
</pre><p>
          デフォルトの鍵キャッシュは破棄できません。 これを実行しようとしても無視されます: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL key_buffer_size = 0;</code></strong>

mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'key_buffer_size';</code></strong>
+-----------------+---------+
| Variable_name   | Value   |
+-----------------+---------+
| key_buffer_size | 8384512 |
+-----------------+---------+
</pre><p>
          キーキャッシュ変数は名前とコンポーネントのある構造化システム変数です。 <code class="literal">keycache1.key_buffer_size</code> の場合、<code class="literal">keycache1</code> はキャッシュ変数名であり、<code class="literal">key_buffer_size</code> はキャッシュコンポーネントです。 構造化キーキャッシュシステム変数を参照するために使用する構文の詳細については、<a class="xref" href="server-administration.html#structured-system-variables" title="5.1.9.5 構造化システム変数">セクション5.1.9.5「構造化システム変数」</a>を参照してください。 
        </p><p>
          デフォルトで、テーブルインデックスは、サーバー起動時に作成されるメイン (デフォルト) キーキャッシュに割り当てられます。 キーキャッシュが破棄されると、それに割り当てられたすべてのインデックスはデフォルトのキーキャッシュに再割り当てされます。 
        </p><p>
          ビジーなサーバーの場合、3 つのキーキャッシュを含む戦略を使用できます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              すべてのキーキャッシュに割り当てられたスペースの 20% を占める<span class="quote">「<span class="quote">ホット</span>」</span>キーキャッシュ。 これは、検索に頻繁に使用されるが、更新されないテーブルに使用します。 
            </p></li><li class="listitem"><p>
              すべてのキーキャッシュに割り当てられたスペースの 20% を占める<span class="quote">「<span class="quote">コールド</span>」</span>キーキャッシュ。 このキャッシュは、一時テーブルなどの中規模の集中的に変更されるテーブルに使用します。 
            </p></li><li class="listitem"><p>
              キーキャッシュスペースの 60% を占める<span class="quote">「<span class="quote">ウォーム</span>」</span>キーキャッシュ。 これは、デフォルトでほかのすべてのテーブルに使用されるように、デフォルトのキーキャッシュとして使用します。 
            </p></li></ul></div><p>
          3 つのキーキャッシュを使用することに利点がある理由の 1 つは、1 つのキーキャッシュ構造へのアクセスが、ほかへのアクセスをブロックしないことです。 あるキャッシュに割り当てられたテーブルにアクセスするステートメントは、ほかのキャッシュに割り当てられたテーブルにアクセスするステートメントと競合しません。 パフォーマンスの向上はほかの理由でも発生します。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              ホットキャッシュはクエリーの取得にのみ使用されるため、その内容が変更されることはありません。 その結果、インデックスブロックをディスクから取り出す必要がある場合常に、置き換えのために選択されたキャッシュブロックの内容を最初にフラッシュする必要はありません。 
            </p></li><li class="listitem"><p>
              ホットキャッシュに割り当てられたインデックスの場合、インデックススキャンを必要とするクエリーがなければ、インデックス B ツリーの非リーフノードに対応するインデックスブロックがキャッシュに残っている可能性が高くなります。
            </p></li><li class="listitem"><p>
              一時テーブルに対して最も頻繁に実行される更新操作は、更新されたノードがキャッシュ内にあり、最初にディスクから読み取る必要がない場合にはるかに高速に実行されます。 一時テーブルのインデックスのサイズがコールドキーキャッシュのサイズと同程度である場合、更新されるノードがキャッシュ内にある可能性が高くなります。 
            </p></li></ul></div><p>
          <code class="literal">CACHE INDEX</code> ステートメントは、テーブルとキーキャッシュ間のアソシエーションをセットアップしますが、そのアソシエーションはサーバーが再起動されるたびに失われます。 サーバーが起動するたびにアソシエーションを有効にするには、オプションファイルを使用: キーキャッシュを構成する変数設定と、実行する <code class="literal">CACHE INDEX</code> ステートメントを含むファイルを指定する <code class="literal">init_file</code> システム変数を含めます。 例: 
        </p><pre class="programlisting">key_buffer_size = 4G
hot_cache.key_buffer_size = 2G
cold_cache.key_buffer_size = 2G
init_file=/<em class="replaceable"><code>path</code></em>/<em class="replaceable"><code>to</code></em>/<em class="replaceable"><code>data-directory</code></em>/mysqld_init.sql
</pre><p>
          サーバーが起動するたびに <code class="filename">mysqld_init.sql</code> 内のステートメントが実行されます。 ファイルには 1 行に 1 つずつ SQL ステートメントを含めてください。 次の例は <code class="literal">hot_cache</code> と <code class="literal">cold_cache</code> に複数のテーブルをそれぞれ割り当てます。 
        </p><pre class="programlisting">CACHE INDEX db1.t1, db1.t2, db2.t3 IN hot_cache
CACHE INDEX db1.t4, db2.t5, db2.t6 IN cold_cache
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="midpoint-insertion"></a>8.10.2.3 ミッドポイント挿入戦略</h4></div></div></div><p>
          デフォルトで、キーキャッシュ管理システムは、削除されるキーキャッシュブロックの選択に、単純な LRU 戦略を使用しますが、<span class="firstterm">ミッドポイント挿入戦略</span>というさらに高度な方法もサポートしています。
        </p><p>
          ミッドポイント挿入戦略を使用すると、LRU チェーンがホットサブリストとウォームサブリストの 2 つのパートに分割されます。 2 つのパート間の分割点は固定ではありませんが、キーキャッシュ管理システムでは、ウォームパートが<span class="quote">「<span class="quote">短くなりすぎ</span>」</span>ず、常にキーキャッシュブロックの少なくとも <code class="literal">key_cache_division_limit</code> パーセントを含むように配慮されます。<code class="literal">key_cache_division_limit</code> は構造化キーキャッシュ変数のコンポーネントであるため、その値はキャッシュごとに設定可能なパラメータです。 
        </p><p>
          インデックスブロックがテーブルからキーキャッシュに読み込まれると、それはウォームサブリストの末尾に置かれます。 特定の数のヒット (ブロックのアクセス) 後、それはホットサブリストに昇格されます。 現在のところ、ブロックを昇格させるために必要なヒット数 (3) はすべてのインデックスブロックで同じです。 
        </p><p>
          ホットサブリストに昇格されるブロックはリストの末尾に置かれます。 ブロックはこのサブリスト内で循環されます。 ブロックが十分な時間サブリストの先頭にとどまっている場合、それはウォームサブリストに降格されます。 この時間はキーキャッシュの <code class="literal">key_cache_age_threshold</code> コンポーネントの値によって決定されます。 
        </p><p>
          しきい値は、<em class="replaceable"><code>N</code></em> ブロックを含むキーキャッシュの場合、最後の <code class="literal"><em class="replaceable"><code>N</code></em> * key_cache_age_threshold / 100</code> ヒット内にアクセスされないホットサブリストの先頭のブロックが、ウォームサブリストの先頭に移動されることを規定します。 置き換えられるブロックは常にウォームサブリストの先頭から取得されるため、その後、それは削除の最初の候補になります。 
        </p><p>
          ミッドポイント挿入戦略により、価値の高いブロックを常にキャッシュ内に保持できます。 単純な LRU 戦略を使用したい場合は、<code class="literal">key_cache_division_limit</code> 値をそのデフォルトの 100 に設定したままにします。 
        </p><p>
          ミッドポイント挿入戦略は、インデックススキャンを必要とするクエリーの実行で、価値の高い高レベル B ツリーノードに対応するすべてのインデックスブロックを、キャッシュから効率的に押し出す際のパフォーマンスの向上に役立ちます。 これを回避するには、<code class="literal">key_cache_division_limit</code> を 100 よりかなり小さい値に設定して、ミッドポイント挿入戦略を使用する必要があります。 これにより、インデックススキャン操作中でも、価値の高い頻繁にヒットされるノードがホットサブリストに保持されます。 
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="index-preloading"></a>8.10.2.4 インデックスプリロード</h4></div></div></div><p>
          キーキャッシュ内に、インデックス全体のブロックを保持するために十分なブロックがあるか、または少なくともその非リーフノードに対応するブロックがある場合、使用を開始する前に、キーキャッシュにインデックスブロックをプリロードすることは役立ちます。 プリロードにより、インデックスブロックをディスクから順番に読み取ることで、もっとも効率的にテーブルインデックスをキーキャッシュバッファーに挿入できます。 
        </p><p>
          プリロードしない場合、ブロックは、引き続きクエリーによって必要とされるときに、キーキャッシュに置かれます。 ブロックはキャッシュ内に残りますが、すべてのバッファが十分にあるため、ディスクからランダムな順序でフェッチされ、順次フェッチされません。 
        </p><p>
          インデックスをキャッシュにプリロードするには <code class="literal">LOAD INDEX INTO CACHE</code> ステートメントを使用します。 たとえば、次のステートメントはテーブル <code class="literal">t1</code> および <code class="literal">t2</code> のインデックスのノード (インデックスブロック) をプリロードします。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>LOAD INDEX INTO CACHE t1, t2 IGNORE LEAVES;</code></strong>
+---------+--------------+----------+----------+
| Table   | Op           | Msg_type | Msg_text |
+---------+--------------+----------+----------+
| test.t1 | preload_keys | status   | OK       |
| test.t2 | preload_keys | status   | OK       |
+---------+--------------+----------+----------+
</pre><p>
          <code class="literal">IGNORE LEAVES</code> 修飾子によって、インデックスの非リーフノードのブロックのみがプリロードされます。 したがって、上記のステートメントは <code class="literal">t1</code> からすべてのインデックスブロックをプリロードしますが、<code class="literal">t2</code> からは非リーフノードのブロックのみをプリロードします。 
        </p><p>
          インデックスが <code class="literal">CACHE INDEX</code> ステートメントを使用してキーキャッシュに割り当てられている場合、プリロードによって、インデックスブロックがそのキャッシュに置かれます。 そうでない場合は、インデックスはデフォルトのキーキャッシュにロードされます。 
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="key-cache-block-size"></a>8.10.2.5 キーキャッシュブロックサイズ</h4></div></div></div><p>
          <code class="literal">key_cache_block_size</code> 変数を使用して、個々のキーキャッシュのブロックバッファーのサイズを指定できます。 これによって、インデックスファイルの I/O 操作のパフォーマンスをチューニングできます。 
        </p><p>
          I/O 操作の最適なパフォーマンスは、読み取りバッファーのサイズがネイティブオペレーティングシステム I/O バッファーのサイズに等しい場合に達成されます。 ただし、キーノードのサイズを I/O バッファーのサイズと等しく設定しても、常に全体の最適なパフォーマンスが確保されるわけではありません。 大きなリーフノードを読み取る場合、サーバーは大量の不要なデータを取り出し、事実上ほかのリーフノードの読み取りを妨げます。 
        </p><p>
          <code class="literal">MyISAM</code> テーブルの <code class="filename">.MYI</code> インデックスファイルのブロックのサイズを制御するには、サーバーの起動時に <code class="option">--myisam-block-size</code> オプションを使用します。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="key-cache-restructuring"></a>8.10.2.6 キーキャッシュの再構築</h4></div></div></div><p>
          キーキャッシュはそのパラメータ値を更新することで、いつでも再構築できます。 例: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL cold_cache.key_buffer_size=4*1024*1024;</code></strong>
</pre><p>
          <code class="literal">key_buffer_size</code> または <code class="literal">key_cache_block_size</code> キーキャッシュコンポーネントにコンポーネントの現在の値とは異なる値を割り当てると、サーバーはキャッシュを破棄し、新しい値に基づいて新しい構造を作成します。 キャッシュにダーティーブロックが含まれる場合、サーバーはキャッシュを破棄し、再作成する前にディスクにそれらを保存します。 ほかのキーキャッシュパラメータを変更した場合は、再構築が行われません。 
        </p><p>
          キーキャッシュを再構築する場合、サーバーはまずダーティーバッファーの内容をディスクにフラッシュします。 その後、キャッシュの内容は使用できなくなります。 しかし、再構築は、キャッシュに割り当てられたインデックスを使用する必要があるクエリーをブロックしません。 代わりに、サーバーはネイティブファイルシステムキャッシュを使用して、テーブルインデックスに直接アクセスします。 ファイルシステムキャッシュはキーキャッシュを使用するときほど効率的ではないため、クエリーが実行されても速度の低下が予想されます。 キャッシュが再構築されると、それに割り当てられたインデックスをキャッシュするためにふたたび使用できるようになり、インデックスのファイルシステムキャッシュの使用は停止されます。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="statement-caching"></a>8.10.3 プリペアドステートメントおよびストアドプログラムのキャッシュ</h3></div></div></div><a class="indexterm" name="idm45661474070608"></a><a class="indexterm" name="idm45661474068464"></a><p>
        セッション中にクライアントが複数回実行する可能性がある特定のステートメントに対し、サーバーはステートメントを内部構造に変換し、実行時にその構造が使用されるようにキャッシュします。 キャッシュによって、セッション中にそれが再度必要になった場合に、ステートメントを再変換するオーバーヘッドが避けられるため、サーバーはより効率的に実行できます。 変換とキャッシュは、次のステートメントに対して行われます。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            SQL レベルで処理されるもの (<code class="literal">PREPARE</code> ステートメントを使用して) とバイナリクライアント/サーバープロトコルを使用して処理されるもの (<code class="literal">mysql_stmt_prepare()</code> C API 関数を使用して) の両方のプリペアドステートメント。 <code class="literal">max_prepared_stmt_count</code> システム変数は、サーバーがキャッシュするステートメントの合計数を制御します。 (すべてのセッションでのプリペアドステートメントの合計数。) 
          </p></li><li class="listitem"><p>
            ストアドプログラム (ストアドプロシージャーおよび関数、トリガー、およびイベント)。 この場合、サーバーはプログラム本体全体を変換し、キャッシュします。 <code class="literal">stored_program_cache</code> システム変数は、サーバーがセッションあたりにキャッシュするストアドプログラムのおおよその数を示します。 
          </p></li></ul></div><p>
        サーバーは、セッション単位でプリペアドステートメントおよびストアドプログラム用のキャッシュを保守します。 1 つのセッションでキャッシュされたステートメントは、ほかのセッションからアクセスできません。 セッションが終了すると、サーバーはそのためにキャッシュされたすべてのステートメントを破棄します。 
      </p><p>
        サーバーがキャッシュされた内部ステートメント構造を使用する場合、構造が古くなっていないことに注意する必要があります。 ステートメントによって使用されているオブジェクトにメタデータの変更があり、現在のオブジェクト定義と内部ステートメント構造で表されている定義に不一致が発生することがあります。 メタデータの変更は、テーブルの作成、削除、変更、名前変更、切り捨てを行う DDL ステートメントや、テーブルの解析、最適化、修復を行う DDL ステートメントなどに対して発生します。 テーブルの内容の変更 (<code class="literal">INSERT</code> や <code class="literal">UPDATE</code> などによる) ではメタデータが変更されず、<code class="literal">SELECT</code> ステートメントも変更されません。 
      </p><p>
        次にこの問題を説明します。 クライアントがこのステートメントを準備するとします。 
      </p><pre class="programlisting">PREPARE s1 FROM 'SELECT * FROM t1';
</pre><p>
        <code class="literal">SELECT *</code> は内部構造からテーブル内のカラムのリストに展開します。 テーブル内のカラムのセットが <code class="literal">ALTER TABLE</code> によって変更されている場合、プリペアドステートメントが古くなります。 クライアントが次回 <code class="literal">s1</code> を実行したときにサーバーがこの変更を検出しない場合、プリペアドステートメントは誤った結果を返します。 
      </p><p>
        プリペアドステートメントによって参照されているテーブルやビューのメタデータの変更に原因がある問題を避けるため、サーバーはこれらの変更を検出し、次回の実行時にステートメントを自動的に再準備します。 つまり、サーバーはステートメントを再解析し、内部構造を再構築します。 再解析は、キャッシュ内に新しいエントリのための空きを作るために暗黙的に、または <code class="literal">FLUSH TABLES</code> によって明示的に、参照されているテーブルやビューがテーブル定義キャッシュからフラッシュされたあとにも行われます。 
      </p><p>
        同様に、ストアドプログラムによって使用されているオブジェクトに変更が発生した場合、サーバーはプログラム内の影響のあるステートメントを再解析します。
      </p><p>
        サーバーは式内のオブジェクトのメタデータの変更も検出します。 これらは、<code class="literal">DECLARE CURSOR</code> などのストアドプログラムに固有のステートメントや <code class="literal">IF</code>、<code class="literal">CASE</code>、および <code class="literal">RETURN</code> などのフロー制御ステートメントで使用できます。 
      </p><p>
        ストアドプログラム全体の再解析を避けるため、サーバーは必要に応じて、プログラム内の影響のあるステートメントや式のみを再解析します。 例: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブルまたはビューのメタデータが変更されているとします。 再解析は、テーブルやビューにアクセスするプログラム内の <code class="literal">SELECT *</code> に対して行われますが、テーブルやビューにアクセスしない <code class="literal">SELECT *</code> に対しては行われません。 
          </p></li><li class="listitem"><p>
            ステートメントが影響を受ける場合、サーバーは可能なかぎり部分的にのみそれを再解析します。 この <code class="literal">CASE</code> ステートメントを考慮します。 
          </p><pre class="programlisting">CASE <em class="replaceable"><code>case_expr</code></em>
  WHEN <em class="replaceable"><code>when_expr1</code></em> ...
  WHEN <em class="replaceable"><code>when_expr2</code></em> ...
  WHEN <em class="replaceable"><code>when_expr3</code></em> ...
  ...
END CASE
</pre><p>
            メタデータの変更が <code class="literal">WHEN <em class="replaceable"><code>when_expr3</code></em></code> にのみ影響する場合、その式が再解析されます。<em class="replaceable"><code>case_expr</code></em> およびその他の <code class="literal">WHEN</code> 式は再解析されません。
          </p></li></ul></div><p>
        再解析では、元の内部形式への変換に有効であったデフォルトのデータベースと SQL モードが使われます。
      </p><p>
        サーバーは最大 3 回再解析を試みます。 すべての試みが失敗した場合、エラーが発生します。 
      </p><p>
        再解析は自動ですが、それが行われた場合、プリペアドステートメントとストアドプログラムのパフォーマンスが低下します。
      </p><p>
        プリペアドステートメントの場合、<code class="literal">Com_stmt_reprepare</code> ステータス変数が再準備の数を追跡します。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="locking-issues"></a>8.11 ロック操作の最適化</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#internal-locking">8.11.1 内部ロック方法</a></span></dt><dt><span class="section"><a href="optimization.html#table-locking">8.11.2 テーブルロックの問題</a></span></dt><dt><span class="section"><a href="optimization.html#concurrent-inserts">8.11.3 同時挿入</a></span></dt><dt><span class="section"><a href="optimization.html#metadata-locking">8.11.4 メタデータのロック</a></span></dt><dt><span class="section"><a href="optimization.html#external-locking">8.11.5 外部ロック</a></span></dt></dl></div><p>
      MySQL は<a class="link" href="glossary.html#glos_locking" title="ロック">ロック</a>を使用して、テーブルの内容の競合を管理します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          内部ロックは、複数スレッドによるテーブルの内容の競合を管理するために、MySQL サーバー自体の内部で実行されます。 この種類のロックは、完全にサーバーによって実行され、ほかのプログラムは関与しないため、内部です。 <a class="xref" href="optimization.html#internal-locking" title="8.11.1 内部ロック方法">セクション8.11.1「内部ロック方法」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          外部ロックは、サーバーとほかのプログラム間で、どのプログラムがいつテーブルにアクセスできるかを調整するために、<code class="literal">MyISAM</code> テーブルファイルをロックする場合に発生します。 <a class="xref" href="optimization.html#external-locking" title="8.11.5 外部ロック">セクション8.11.5「外部ロック」</a>を参照してください。 
        </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="internal-locking"></a>8.11.1 内部ロック方法</h3></div></div></div><a class="indexterm" name="idm45661474013584"></a><a class="indexterm" name="idm45661474012128"></a><a class="indexterm" name="idm45661474010096"></a><a class="indexterm" name="idm45661474008752"></a><a class="indexterm" name="idm45661474006720"></a><a class="indexterm" name="idm45661474005360"></a><a class="indexterm" name="idm45661474003984"></a><a class="indexterm" name="idm45661474001952"></a><a class="indexterm" name="idm45661473999920"></a><p>
        このセクションでは、内部ロック、つまり複数のセッションによるテーブル内容の競合を管理するために、MySQL サーバー自体の内部で実行されるロックについて説明します。 この種類のロックは、完全にサーバーによって実行され、ほかのプログラムは関与しないため、内部です。 ほかのプログラムによって MySQL ファイルに対して実行されるロックについては、<a class="xref" href="optimization.html#external-locking" title="8.11.5 外部ロック">セクション8.11.5「外部ロック」</a>を参照してください。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#internal-row-level-locking" title="行レベルロック">行レベルロック</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#internal-table-level-locking" title="テーブルレベルロック">テーブルレベルロック</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#internal-locking-choices" title="ロックのタイプの選択">ロックのタイプの選択</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="internal-row-level-locking"></a>行レベルロック</h4></div></div></div><p>
          MySQL は <code class="literal">InnoDB</code> テーブルに<a class="link" href="glossary.html#glos_row_lock" title="行ロック">行レベルロック</a>を使用して、複数のセッションによる同時書き込みアクセスをサポートし、それらを複数ユーザー、高度な並列性、および OLTP アプリケーションに適したものにします。
        </p><p>
          単一の <code class="literal">InnoDB</code> テーブルに対して複数の同時書込み操作を実行する場合に <a class="link" href="glossary.html#glos_deadlock" title="デッドロック">deadlocks</a> を回避するには、データ変更ステートメントがトランザクションの後半にある場合でも、変更が予想される行のグループごとに <code class="literal">SELECT ... FOR UPDATE</code> ステートメントを発行して、トランザクションの開始時に必要なロックを取得します。 トランザクションで複数のテーブルを変更またはロックする場合、各トランザクション内で、該当するステートメントを同じ順序で発行します。 デッドロックは、重大なエラーを表すのではなくパフォーマンスに影響します。これは、<code class="literal">InnoDB</code> ではデフォルトで <a class="link" href="glossary.html#glos_deadlock_detection" title="デッドロック検出">detects</a> デッドロック状態が自動的に発生し、影響を受けるトランザクションのいずれかがロールバックされるためです。 
        </p><p>
          同時実行性の高いシステムでは、多数のスレッドが同じロックを待機している場合、デッドロック検出によって速度が低下する可能性があります。 デッドロック検出を無効にし、デッドロック発生時のトランザクションロールバックの <code class="literal">innodb_lock_wait_timeout</code> 設定に依存する方が効率的な場合があります。 デッドロック検出は、<code class="literal">innodb_deadlock_detect</code> 構成オプションを使用して無効にできます。 
        </p><p>
          行レベルロックの利点:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              異なるセッションが異なる行にアクセスする場合、ロックの競合は少なくなります。
            </p></li><li class="listitem"><p>
              ロールバックする変更が少なくなります。
            </p></li><li class="listitem"><p>
              1 つの行を長時間ロックできます。
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="internal-table-level-locking"></a>テーブルレベルロック</h4></div></div></div><p>
          MySQL では、<code class="literal">MyISAM</code>、<code class="literal">MEMORY</code> および <code class="literal">MERGE</code> テーブルに <a class="link" href="glossary.html#glos_table_lock" title="テーブルロック">table-level locking</a> を使用し、一度に更新できるセッションは 1 つのみです。 このロックレベルにより、これらのストレージエンジンは読み取り専用、読み取りの大部分、またはシングルユーザーアプリケーションに適しています。 
        </p><p>
          これらのストレージエンジンは、常にクエリーの最初に 1 回だけ必要なすべてのロックをリクエストし、常に同じ順序でテーブルをロックすることによって、<a class="link" href="glossary.html#glos_deadlock" title="デッドロック">デッドロック</a>を回避します。 トレードオフとは、この戦略によって同時実行性が低下することです。テーブルを変更する他のセッションは、現在のデータ変更ステートメントが終了するまで待機する必要があります。 
        </p><p>
          テーブルレベルロックの利点:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              必要なメモリーは比較的少なくなります (行ロックでは、ロックされた行または行のグループごとにメモリーが必要です)
            </p></li><li class="listitem"><p>
              単一のロックだけが必要であるため、テーブルの大部分に対して使用する場合に高速です。
            </p></li><li class="listitem"><p>
              データの大部分に対して <code class="literal">GROUP BY</code> 操作を頻繁に実行する場合、またはテーブル全体を頻繁にスキャンする必要がある場合は高速です。
            </p></li></ul></div><p>
          MySQL はテーブル書き込みロックを次のように許可します。
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              テーブルにロックがない場合、それを書き込みロックします。
            </p></li><li class="listitem"><p>
              そうでない場合、書き込みロックキューにロックリクエストを入れます。
            </p></li></ol></div><p>
          MySQL はテーブル読み取りロックを次のように許可します。
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              テーブルに書き込みロックがない場合、それを読み取りロックします。
            </p></li><li class="listitem"><p>
              そうでない場合、読み取りロックキューにロックリクエストを入れます。
            </p></li></ol></div><p>
          テーブルの更新は、テーブルの取得よりも高い優先度が与えられます。 そのため、ロックが解放されると、ロックは書き込みロックキュー内のリクエストに使用できるようになり、次に読み取りロックキュー内のリクエストに使用できるようになります。 これにより、テーブルに大量の <code class="literal">SELECT</code> アクティビティがある場合でも、テーブルに対する更新が <span class="quote">「<span class="quote">starved</span>」</span> ではなくなります。 ただし、テーブルの更新が多数ある場合、<code class="literal">SELECT</code> ステートメントは更新がなくなるまで待機します。 
        </p><p>
          読み取りと書き込みの優先度を変更する方法については、<a class="xref" href="optimization.html#table-locking" title="8.11.2 テーブルロックの問題">セクション8.11.2「テーブルロックの問題」</a>を参照してください。
        </p><p>
          <code class="literal">Table_locks_immediate</code> および <code class="literal">Table_locks_waited</code> ステータス変数をチェックすることでシステム上のテーブルロック競合を分析できます。これらは、テーブルロックのリクエストがすぐに許可された回数と待機する必要があった回数を示します。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'Table%';</code></strong>
+-----------------------+---------+
| Variable_name         | Value   |
+-----------------------+---------+
| Table_locks_immediate | 1151552 |
| Table_locks_waited    | 15324   |
+-----------------------+---------+
</pre><p>
          パフォーマンススキーマロックテーブルは、ロック情報も提供します。 <a class="xref" href="performance-schema.html#performance-schema-lock-tables" title="27.12.13 パフォーマンススキーマロックテーブル">セクション27.12.13「パフォーマンススキーマロックテーブル」</a>を参照してください。 
        </p><a class="indexterm" name="idm45661473946000"></a><a class="indexterm" name="idm45661473944576"></a><p>
          <code class="literal">MyISAM</code> ストレージエンジンでは、特定のテーブルのリーダーとライター間の競合を軽減するために、同時挿入をサポートしています。<code class="literal">MyISAM</code> テーブルでデータファイルの途中に空きブロックがない場合、行は常にデータファイルの末尾に挿入されます。 この場合、ロックなしで <code class="literal">MyISAM</code> テーブルに対して同時 <code class="literal">INSERT</code> および <code class="literal">SELECT</code> ステートメントを自由に組み合わせることができます。 つまり、ほかのクライアントが <code class="literal">MyISAM</code> テーブルから読み取ると同時に、それに行を挿入できます。 テーブルの途中で行が削除されるか更新されると、隙間が発生します。 穴がある場合、同時挿入は無効になりますが、すべての穴が新しいデータでいっぱいになると、再度自動的に有効になります。 この動作を制御するには、<code class="literal">concurrent_insert</code> システム変数を使用します。 <a class="xref" href="optimization.html#concurrent-inserts" title="8.11.3 同時挿入">セクション8.11.3「同時挿入」</a>を参照してください。 
        </p><p>
          <code class="literal">LOCK TABLES</code> で明示的にテーブルロックを獲得する場合、<code class="literal">READ</code> ロックではなく <code class="literal">READ LOCAL</code> ロックをリクエストして、テーブルをロックしている間に、ほかのセッションが同時挿入を実行できるようにできます。
        </p><p>
          同時挿入が不可能な場合に、テーブル <code class="literal">t1</code> で多くの <code class="literal">INSERT</code> および <code class="literal">SELECT</code> 操作を実行するには、一時テーブル <code class="literal">temp_t1</code> に行を挿入し、実際のテーブルを一時テーブルの行で更新します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>LOCK TABLES t1 WRITE, temp_t1 WRITE;</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t1 SELECT * FROM temp_t1;</code></strong>
mysql&gt; <strong class="userinput"><code>DELETE FROM temp_t1;</code></strong>
mysql&gt; <strong class="userinput"><code>UNLOCK TABLES;</code></strong>
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="internal-locking-choices"></a>ロックのタイプの選択</h4></div></div></div><p>
          通常、次の場合、テーブルロックは行レベルロックよりも優れています:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              テーブルに対するほとんどのステートメントが読み取りです。
            </p></li><li class="listitem"><p>
              テーブルに対するステートメントが読み取りと書き込みの組み合わせであり、そのうち書き込みは 1 つのキーの読み取りでフェッチできる単一の行に対する更新または削除です。
            </p><pre class="programlisting">UPDATE <em class="replaceable"><code>tbl_name</code></em> SET <em class="replaceable"><code>column</code></em>=<em class="replaceable"><code>value</code></em> WHERE <em class="replaceable"><code>unique_key_col</code></em>=<em class="replaceable"><code>key_value</code></em>;
DELETE FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>unique_key_col</code></em>=<em class="replaceable"><code>key_value</code></em>;
</pre></li><li class="listitem"><p>
              同時 <code class="literal">INSERT</code> ステートメントとごく少数の <code class="literal">UPDATE</code> または <code class="literal">DELETE</code> ステートメントと組み合わされた <code class="literal">SELECT</code>。
            </p></li><li class="listitem"><p>
              ライターを使用しない、テーブル全体への多くのスキャンまたは <code class="literal">GROUP BY</code> 操作。
            </p></li></ul></div><p>
          高レベルロックでは、行レベルロックよりロックのオーバーヘッドが少ないため、様々なタイプのロックをサポートすることでアプリケーションをより簡単にチューニングできます。
        </p><p>
          行レベルロック以外のオプション:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              複数のリーダーを同時に持つことができるバージョニング (MySQL で同時挿入に使用されるものなど)。 つまり、データベースまたはテーブルでは、アクセスの開始時期に応じて異なるデータのビューがサポートされます。 この他の一般的な用語は、<span class="quote">「<span class="quote">「時間移動、」</span>」</span> <span class="quote">「<span class="quote">copy on write、</span>」</span>または<span class="quote">「<span class="quote">「オンデマンドでコピー」</span>」</span>です。 
            </p></li><li class="listitem"><p>
              コピーオンデマンドは、多くの場合、行レベルロックよりも優れています。 ただし、最悪の場合は、通常のロックを使用するよりもはるかに多くのメモリーを使用できます。 
            </p></li><li class="listitem"><p>
              行レベルロックを使用するかわりに、MySQL の <code class="literal">GET_LOCK()</code> および <code class="literal">RELEASE_LOCK()</code> で提供されるロックなど、アプリケーションレベルのロックを使用できます。 これらはアドバイザロックであるため、相互に連携するアプリケーションでのみ機能します。 <a class="xref" href="functions.html#locking-functions" title="12.15 ロック関数">セクション12.15「ロック関数」</a>を参照してください。 
            </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="table-locking"></a>8.11.2 テーブルロックの問題</h3></div></div></div><a class="indexterm" name="idm45661473895680"></a><p>
        <code class="literal">InnoDB</code> テーブルでは、複数のセッションとアプリケーションが互いに待機したり、不整合の結果を生成したりすることなく、同じテーブルに対して同時に読み取りや書き込みを実行できるように、行レベルロックを使用します。 このストレージエンジンでは、<code class="literal">LOCK TABLES</code> ステートメントは特別な保護を提供せず、代わりに並列性が低くなるため、この使用を避けてください。 自動の行レベルロックにより、これらのテーブルがもっとも重要なデータを格納するもっともビジーなデータベースに適合し、同時にテーブルのロックやロック解除が必要ないためアプリケーションロジックが簡単になります。 その結果、<code class="literal">InnoDB</code> ストレージエンジンが MySQL のデフォルトになります。 
      </p><p>
        MySQL は <code class="literal">InnoDB</code> を除く、すべてのストレージエンジンに対して、テーブルロック (ページ、行、またはカラムロックの代わりに) を使用します。 ロック操作自体には、あまりオーバーヘッドがありません。 ただし、一度に 1 つのセッションしかテーブルに書き込むことができないため、これらのほかのストレージエンジンでの最高のパフォーマンスのため、頻繁にクエリーされ、めったに挿入または更新されないテーブルに対して主にそれらを使用します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#table-locking-innodb" title="InnoDB を優先するパフォーマンスの考慮事項">InnoDB を優先するパフォーマンスの考慮事項</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#table-locking-workarounds" title="ロックパフォーマンスの問題の回避">ロックパフォーマンスの問題の回避</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="table-locking-innodb"></a>InnoDB を優先するパフォーマンスの考慮事項</h4></div></div></div><p>
          テーブルを作成するために、<code class="literal">InnoDB</code> を使用するか、別のストレージエンジンを使用するかを選択する場合、テーブルロックの次の短所を考慮してください。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              テーブルロックにより、多くのセッションを同時にテーブルから読み取ることができますが、セッションでテーブルに書き込む必要がある場合、まず排他的アクセスを取得する必要がありますが、これはまずほかのセッションがテーブルを処理し終わるのを待つ必要がある可能性があることを意味します。 更新中、この特定のテーブルにアクセスしようとするほかのすべてのセッションは、更新が完了するまで待機する必要があります。 
            </p></li><li class="listitem"><p>
              ディスクがいっぱいで、セッションを続行するには空き領域が使用できるようになる必要があるため、セッションが待機している場合にテーブルロックによって問題が発生します。 この場合、問題のテーブルにアクセスしようとするすべてのセッションが、より多くのディスク領域が使用できるようになるまで待機状態になります。 
            </p></li><li class="listitem"><p>
              実行に長時間かかる <code class="literal">SELECT</code> ステートメントにより、その間ほかのセッションのテーブルの更新が妨げられ、ほかのセッションが遅くなり、応答していないように見えます。 セッションが更新のためにテーブルへの排他的アクセスを取得するのを待機している間、<code class="literal">SELECT</code> ステートメントを発行する他のセッションはその背後でキューに入れられるため、読取り専用セッションでも同時実行性が低下します。 
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="table-locking-workarounds"></a>ロックパフォーマンスの問題の回避</h4></div></div></div><p>
          次の項目では、テーブルロックによって発生する競合を回避または軽減するいくつかの方法について説明します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              セットアップ時に <code class="literal">CREATE TABLE ... ENGINE=INNODB</code> を使用するか、既存のテーブルに対して <code class="literal">ALTER TABLE ... ENGINE=INNODB</code> を使用して、テーブルを <code class="literal">InnoDB</code> ストレージエンジンに切り替えることを考慮します。 このストレージエンジンの詳細については、<a class="xref" href="innodb-storage-engine.html" title="第 15 章 InnoDB ストレージエンジン">第15章「<i>InnoDB ストレージエンジン</i>」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              テーブルをロックする時間が短くなるように、<code class="literal">SELECT</code> ステートメントを最適化して、実行を高速化します。 これを実行するには、いくつかのサマリーテーブルを作成する必要がある場合があります。 
            </p></li><li class="listitem"><p>
              <code class="option">--low-priority-updates</code> で <span class="command"><strong>mysqld</strong></span> を起動します。 テーブルレベルロックのみを使用するストレージエンジン (<code class="literal">MyISAM</code>、<code class="literal">MEMORY</code>、および <code class="literal">MERGE</code> など) の場合、これにより、テーブルを更新 (変更) するすべてのステートメントに <code class="literal">SELECT</code> ステートメントより低い優先度を与えます。 この場合、先述のシナリオの 2 つめの <code class="literal">SELECT</code> ステートメントは <code class="literal">UPDATE</code> ステートメントの前に実行され、最初の <code class="literal">SELECT</code> の終了を待機しません。 
            </p></li><li class="listitem"><p>
              特定の接続で発行されたすべての更新を低い優先度で実行させるように指定するには、<code class="literal">low_priority_updates</code> サーバーシステム変数を 1 に等しく設定します。
            </p></li><li class="listitem"><p>
              特定の <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、または <code class="literal">DELETE</code> ステートメントに低い優先度を与えるには、<code class="literal">LOW_PRIORITY</code> 属性を使用します。
            </p></li><li class="listitem"><p>
              特定の <code class="literal">SELECT</code> ステートメントに高い優先度を与えるには、<code class="literal">HIGH_PRIORITY</code> 属性を使用します。 <a class="xref" href="sql-statements.html#select" title="13.2.10 SELECT ステートメント">セクション13.2.10「SELECT ステートメント」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              <code class="literal">max_write_lock_count</code> システム変数に低い値を指定して <span class="command"><strong>mysqld</strong></span> を起動し、テーブルに対する特定の数の書込みロックが発生した後 (挿入操作など)、テーブルを待機しているすべての <code class="literal">SELECT</code> ステートメントの優先度を MySQL によって一時的に昇格させます。 これにより、特定の数の書込みロックの後に読取りロックが許可されます。 
            </p></li><li class="listitem"><p>
              組み合わされた <code class="literal">SELECT</code> と <code class="literal">DELETE</code> ステートメントに問題がある場合、<code class="literal">DELETE</code> への <code class="literal">LIMIT</code> オプションが役立つことがあります。 <a class="xref" href="sql-statements.html#delete" title="13.2.2 DELETE ステートメント">セクション13.2.2「DELETE ステートメント」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              <code class="literal">SELECT</code> ステートメントで <code class="literal">SQL_BUFFER_RESULT</code> を使用すると、テーブルロックの時間の短縮に役立つことがあります。 <a class="xref" href="sql-statements.html#select" title="13.2.10 SELECT ステートメント">セクション13.2.10「SELECT ステートメント」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              テーブルの内容を個別のテーブルに分割すると (クエリーを 1 つのテーブルのカラムに対して実行し、更新を別のテーブルのカラムに制限することによって)、役立つことがあります。
            </p></li><li class="listitem"><p>
              単一のキューを使用するように、<code class="filename">mysys/thr_lock.c</code> のロックコードを変更できます。 この場合、書き込みロックと読み取りロックは同じ優先度を持ち、一部のアプリケーションに役立つことがあります。 
            </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="concurrent-inserts"></a>8.11.3 同時挿入</h3></div></div></div><a class="indexterm" name="idm45661473829296"></a><a class="indexterm" name="idm45661473827824"></a><p>
        <code class="literal">MyISAM</code> ストレージエンジンでは、特定のテーブルに対する読み取りと書き込みの競合を軽減するために、同時挿入をサポートしています。<code class="literal">MyISAM</code> テーブルのデータファイルに隙間 (途中の削除された行) がない場合、<code class="literal">SELECT</code> ステートメントがテーブルの行を読み取るのと同時に、<code class="literal">INSERT</code> ステートメントを実行してテーブルの末尾に行を追加できます。 複数の <code class="literal">INSERT</code> ステートメントがある場合、それらはキューに入れられ、<code class="literal">SELECT</code> ステートメントと同時に順番に実行されます。 同時 <code class="literal">INSERT</code> の結果はすぐに見られないことがあります。 
      </p><p>
        <code class="literal">concurrent_insert</code> システム変数を設定して、同時挿入の処理を変更できます。 デフォルトで、変数は <code class="literal">AUTO</code> (または 1) に設定され、同時挿入が先述のように処理されます。 <code class="literal">concurrent_insert</code> が <code class="literal">NEVER</code> (または 0) に設定されている場合、同時挿入は無効にされます。 変数が <code class="literal">ALWAYS</code> (または 2) に設定されている場合、行が削除されたテーブルに対してもテーブルの末尾での同時挿入が許可されます。 <code class="literal">concurrent_insert</code> システム変数の説明も参照してください。 
      </p><p>
        バイナリログを使用している場合、同時挿入は <code class="literal">CREATE ... SELECT</code> または <code class="literal">INSERT ... SELECT</code> ステートメントの通常の挿入に変換されます。 これは、バックアップ操作中にログを適用することでテーブルの正確なコピーを確実に再作成できるようにするために行われます。 <a class="xref" href="server-administration.html#binary-log" title="5.4.4 バイナリログ">セクション5.4.4「バイナリログ」</a>を参照してください。 また、これらのステートメントに対しては、選択元のテーブルへの挿入がブロックされるように、そのテーブルに読み取りロックが設定されます。 その結果、そのテーブルに対する同時挿入も待機する必要があります。 
      </p><p>
        <code class="literal">LOAD DATA</code> では、同時挿入の条件を満たす <code class="literal">MyISAM</code> テーブルを使用して <code class="literal">CONCURRENT</code> を指定した場合 (つまり、中央に空きブロックが含まれていない場合)、他のセッションは <code class="literal">LOAD DATA</code> の実行中にテーブルからデータを取得できます。 <code class="literal">CONCURRENT</code> オプションの使用は、同時にテーブルを使用しているほかのセッションがない場合でも、<code class="literal">LOAD DATA</code> のパフォーマンスに多少の影響があります。 
      </p><p>
        <code class="literal">HIGH_PRIORITY</code> を指定すると、サーバーが <code class="option">--low-priority-updates</code> オプションで起動されている場合に、その効果がオーバーライドされます。 また、同時挿入も使用されなくなります。 
      </p><p>
        <code class="literal">LOCK TABLE</code> の場合、<code class="literal">READ LOCAL</code> と <code class="literal">READ</code> の違いは <code class="literal">READ LOCAL</code> が、ロックが保持されている間に、競合していない <code class="literal">INSERT</code> ステートメント (同時挿入) の実行を許可することです。 ただし、ロックを保持している間にサーバーの外部のプロセスを使用してデータベースを操作する場合、これを使用することはできません。 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="metadata-locking"></a>8.11.4 メタデータのロック</h3></div></div></div><a class="indexterm" name="idm45661473791776"></a><a class="indexterm" name="idm45661473790320"></a><a class="indexterm" name="idm45661473788256"></a><p>
        MySQL では、メタデータロックを使用して、データベースオブジェクトへの同時アクセスを管理し、データの一貫性を確保します。 メタデータのロックは、テーブルのみでなく、スキーマ、ストアドプログラム (プロシージャ、ファンクション、トリガー、スケジュール済イベント)、テーブルスペース、<code class="literal">GET_LOCK()</code> 関数で取得されたユーザーロック (<a class="xref" href="functions.html#locking-functions" title="12.15 ロック関数">セクション12.15「ロック関数」</a> を参照)、および <a class="xref" href="server-administration.html#locking-service" title="5.6.8.1 ロックサービス">セクション5.6.8.1「ロックサービス」</a> で説明されているロックサービスで取得されたロックにも適用されます。 
      </p><p>
        パフォーマンススキーマ <code class="literal">metadata_locks</code> テーブルは、メタデータロック情報を公開します。この情報は、ロックを保持しているセッションや、ロックを待機してブロックされているセッションなどを確認する場合に役立ちます。 詳細は、<a class="xref" href="performance-schema.html#performance-schema-metadata-locks-table" title="27.12.13.3 metadata_locks テーブル">セクション27.12.13.3「metadata_locks テーブル」</a>を参照してください。 
      </p><p>
        メタデータロックには多少のオーバーヘッドが伴い、クエリーボリュームが増加するにつれて増加します。 複数のクエリーが同じオブジェクトにアクセスを試みることが多くなるほど、メタデータの競合が増加します。 
      </p><p>
        メタデータのロックは、テーブル定義キャッシュの代替ではなく、その相互排他ロックとロックは、<code class="literal">LOCK_open</code> 相互排他ロックと異なります。 次の説明では、メタデータのロックの仕組みに関する情報を提供します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#metadata-lock-acquisition" title="メタデータロックの取得">メタデータロックの取得</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#metadata-lock-release" title="メタデータロックの解放">メタデータロックの解放</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="metadata-lock-acquisition"></a>メタデータロックの取得</h4></div></div></div><p>
          特定のロックに複数の待機者がいる場合は、<code class="literal">max_write_lock_count</code> システム変数に関連する例外を除いて、優先度の高いロックリクエストが最初に満たされます。 書き込みロック要求の優先順位は、読み取りロック要求よりも高くなります。 ただし、<code class="literal">max_write_lock_count</code> がある程度低い値 (たとえば、10) に設定されている場合、読み取りロック要求がすでに 10 個の書き込みロック要求を優先して渡されていれば、保留中の書き込みロック要求よりも読み取りロック要求が優先されることがあります。 通常、<code class="literal">max_write_lock_count</code> のデフォルト値は非常に大きいため、この動作は発生しません。 
        </p><p>
          ステートメントは、同時にではなくメタデータロックを 1 つずつ取得し、プロセスでデッドロック検出を実行します。
        </p><p>
          DML ステートメントは、通常、ステートメントで記述されているテーブルの順序でロックを取得します。
        </p><p>
          DDL ステートメント、<code class="literal">LOCK TABLES</code> およびその他の類似するステートメントは、明示的に指定されたテーブルに対するロックを名前順に取得することで、同時 DDL ステートメント間のデッドロックの可能性のある数を減らします。 暗黙的に使用されるテーブル (ロックする必要がある外部キー関係のテーブルなど) では、ロックが異なる順序で取得される場合があります。 
        </p><p>
          たとえば、<code class="literal">RENAME TABLE</code> は、名前順にロックを取得する DDL ステートメントです:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              次の <code class="literal">RENAME TABLE</code> ステートメントは、<code class="literal">tbla</code> の名前を他の名前に変更し、<code class="literal">tblc</code> の名前を <code class="literal">tbla</code> に変更します:
            </p><pre class="programlisting">RENAME TABLE tbla TO tbld, tblc TO tbla;
</pre><p>
              このステートメントは、<code class="literal">tbla</code>、<code class="literal">tblc</code> および <code class="literal">tbld</code> でメタデータロックを順番に取得します (<code class="literal">tbld</code> は名前順に <code class="literal">tblc</code> に従うため):
            </p></li><li class="listitem"><p>
              この若干異なるステートメントによって、<code class="literal">tbla</code> の名前が他の名前に変更され、<code class="literal">tblc</code> の名前が <code class="literal">tbla</code> に変更されます:
            </p><pre class="programlisting">RENAME TABLE tbla TO tblb, tblc TO tbla;
</pre><p>
              この場合、ステートメントは <code class="literal">tbla</code>、<code class="literal">tblb</code> および <code class="literal">tblc</code> でメタデータロックを順番に取得します (<code class="literal">tblb</code> は <code class="literal">tblc</code> の前に名前順に付くため):
            </p></li></ul></div><p>
          どちらのステートメントも、<code class="literal">tbla</code> および <code class="literal">tblc</code> のロックをこの順序で取得しますが、残りのテーブル名のロックが <code class="literal">tblc</code> の前と後のどちらで取得されるかが異なります。
        </p><p>
          メタデータロックの取得順序は、次の例に示すように、複数のトランザクションが同時に実行される場合に操作結果に違いが生じる可能性があります。
        </p><p>
          同じ構造を持つ 2 つのテーブル <code class="literal">x</code> および <code class="literal">x_new</code> から開始します。 次の 3 つのクライアントが、これらのテーブルを含むステートメントを発行します: 
        </p><p>
          クライアント 1:
        </p><pre class="programlisting">LOCK TABLE x WRITE, x_new WRITE;
</pre><p>
          このステートメントは、<code class="literal">x</code> および <code class="literal">x_new</code> で名前順に書込みロックを要求および取得します。
        </p><p>
          クライアント 2:
        </p><pre class="programlisting">INSERT INTO x VALUES(1);
</pre><p>
          ステートメントは、<code class="literal">x</code> で書込みロックを待機していることをリクエストおよびブロックします。
        </p><p>
          クライアント 3:
        </p><pre class="programlisting">RENAME TABLE x TO x_old, x_new TO x;
</pre><p>
          このステートメントは、<code class="literal">x</code>、<code class="literal">x_new</code> および <code class="literal">x_old</code> で排他ロックを名前順に要求しますが、<code class="literal">x</code> でのロックの待機をブロックします。
        </p><p>
          クライアント 1:
        </p><pre class="programlisting">UNLOCK TABLES;
</pre><p>
          このステートメントは、<code class="literal">x</code> および <code class="literal">x_new</code> の書込みロックを解放します。 クライアント 3 による <code class="literal">x</code> の排他ロックリクエストは、クライアント 2 による書込みロックリクエストよりも優先度が高いため、クライアント 3 は <code class="literal">x</code> でロックを取得し、<code class="literal">x_new</code> および <code class="literal">x_old</code> でも名前変更を実行してロックを解放します。 次に、クライアント 2 は <code class="literal">x</code> でロックを取得し、挿入を実行してロックを解放します。 
        </p><p>
          ロック取得順序により、<code class="literal">INSERT</code> の前に <code class="literal">RENAME TABLE</code> が実行されます。 挿入が行われる <code class="literal">x</code> は、クライアント 2 が挿入を発行し、クライアント 3 によって <code class="literal">x</code> に名前が変更されたときに <code class="literal">x_new</code> という名前のテーブルです: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM x;</code></strong>
+------+
| i    |
+------+
|    1 |
+------+

mysql&gt; <strong class="userinput"><code>SELECT * FROM x_old;</code></strong>
Empty set (0.01 sec)
</pre><p>
          かわりに、同じ構造を持つ <code class="literal">x</code> および <code class="literal">new_x</code> という名前のテーブルから始めます。 ここでも、3 つのクライアントが、次のテーブルを含むステートメントを発行します: 
        </p><p>
          クライアント 1:
        </p><pre class="programlisting">LOCK TABLE x WRITE, new_x WRITE;
</pre><p>
          このステートメントは、<code class="literal">new_x</code> および <code class="literal">x</code> で名前順に書込みロックを要求および取得します。
        </p><p>
          クライアント 2:
        </p><pre class="programlisting">INSERT INTO x VALUES(1);
</pre><p>
          ステートメントは、<code class="literal">x</code> で書込みロックを待機していることをリクエストおよびブロックします。
        </p><p>
          クライアント 3:
        </p><pre class="programlisting">RENAME TABLE x TO old_x, new_x TO x;
</pre><p>
          このステートメントは、<code class="literal">new_x</code>、<code class="literal">old_x</code> および <code class="literal">x</code> で排他ロックを名前順に要求しますが、<code class="literal">new_x</code> でのロックの待機をブロックします。
        </p><p>
          クライアント 1:
        </p><pre class="programlisting">UNLOCK TABLES;
</pre><p>
          このステートメントは、<code class="literal">x</code> および <code class="literal">new_x</code> の書込みロックを解放します。 <code class="literal">x</code> の場合、保留中のリクエストはクライアント 2 のみであるため、クライアント 2 はロックを取得し、挿入を実行してロックを解放します。 <code class="literal">new_x</code> の場合、保留中のリクエストはクライアント 3 のみで、クライアント 3 はそのロックを取得できます (<code class="literal">old_x</code> でのロックも取得できます)。 名前変更操作は、クライアント 2 の挿入が終了してロックを解放するまで、<code class="literal">x</code> でのロックに対してブロックされます。 次に、クライアント 3 は <code class="literal">x</code> でロックを取得し、名前変更を実行してロックを解放します。 
        </p><p>
          この場合、ロック取得順序により、<code class="literal">RENAME TABLE</code> の前に <code class="literal">INSERT</code> が実行されます。 挿入先の <code class="literal">x</code> は元の <code class="literal">x</code> で、名前変更操作によって <code class="literal">old_x</code> に名前が変更されました: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM x;</code></strong>
Empty set (0.01 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM old_x;</code></strong>
+------+
| i    |
+------+
|    1 |
+------+
</pre><p>
          前述の例のように、同時ステートメントでのロック取得の順序によって操作結果のアプリケーションが異なる場合は、ロック取得の順序に影響を与えるようにテーブル名を調整できます。
        </p><a class="indexterm" name="idm45661473683232"></a><p>
          メタデータロックは、必要に応じて外部キー制約によって関連付けられたテーブルに拡張され、DML 操作と DDL 操作の競合が関連するテーブルで同時に実行されないようにします。 親テーブルを更新すると、外部キーメタデータの更新中に子テーブルのメタデータロックが取得されます。 外部キーメタデータは子テーブルによって所有されます。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="metadata-lock-release"></a>メタデータロックの解放</h4></div></div></div><p>
          トランザクションのシリアライザビリティーを確保するため、サーバーは、別のセッションで、未完了の明示的または暗黙的に開始されたトランザクションで使用されているテーブルに対して、セッションがデータ定義言語 (DDL) ステートメントを実行することを許可してはいけません。 サーバーは、トランザクション内で使用されているテーブルに対してメタデータロックを獲得し、トランザクションが終了するまでそれらのロックの解放を延期させることによって、これを実現します。 テーブルへのメタデータロックは、テーブルの構造への変更を妨げます。 このロックアプローチには、あるセッション内のトランザクションによって使用されているテーブルは、トランザクションが終了するまで、ほかのセッションによって DDL ステートメントで使用できないという問題があります。 
        </p><p>
          この原則は、トランザクションテーブルだけでなく、非トランザクションテーブルにも適用されます。 あるセッションがトランザクションテーブル <code class="literal">t</code> と非トランザクションテーブル <code class="literal">nt</code> を次のように使用するトランザクションを開始するとします。 
        </p><pre class="programlisting">START TRANSACTION;
SELECT * FROM t;
SELECT * FROM nt;
</pre><p>
          サーバーはトランザクションが終了するまで、<code class="literal">t</code> と <code class="literal">nt</code> の両方に対するメタデータロックを保持します。 別のセッションがいずれかのテーブルに対して、DDL または書き込みロック操作を試みると、それはトランザクションの終了時にメタデータロックが解放されるまでブロックされます。 たとえば、2 つめのセッションはこれらのいずれかの操作を試みるとブロックされます。 
        </p><pre class="programlisting">DROP TABLE t;
ALTER TABLE t ...;
DROP TABLE nt;
ALTER TABLE nt ...;
LOCK TABLE t ... WRITE;
</pre><p>
          <code class="literal">LOCK TABLES ... READ</code> にも同じ動作が適用されます。 つまり、テーブル (トランザクションまたは非トランザクション) ブロックを更新し、そのテーブルに対して <code class="literal">LOCK TABLES ... READ</code> によってブロックされる明示的または暗黙的に開始されたトランザクションです。 
        </p><p>
          サーバーが構文上有効であるが、実行中に失敗するステートメントのメタデータロックを獲得した場合、そのロックを早期に解放しません。 失敗したステートメントがバイナリログに書き込まれ、ロックによってログの一貫性が保護されるため、ロックの解放はまだトランザクションの終了まで延期されます。 
        </p><p>
          自動コミットモードでは、各ステートメントが事実上完全なトランザクションであるため、そのステートメントに対して獲得されたメタデータロックは、ステートメントの終了までしか保持されません。
        </p><p>
          <code class="literal">PREPARE</code> ステートメント中に獲得されたメタデータロックは、準備が複数ステートメントトランザクション内で行われる場合でも、ステートメントが準備されると解放されます。
        </p><p>
          MySQL 8.0.13 では、<code class="literal">PREPARED</code> 状態の XA トランザクションの場合、<code class="literal">XA COMMIT</code> または <code class="literal">XA ROLLBACK</code> が実行されるまで、クライアントの接続が切断され、サーバーが再起動されてもメタデータロックは維持されます。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="external-locking"></a>8.11.5 外部ロック</h3></div></div></div><a class="indexterm" name="idm45661473657760"></a><a class="indexterm" name="idm45661473656304"></a><p>
        外部ロックは、複数のプロセスによる <code class="literal">MyISAM</code> データベーステーブルの競合を管理するためのファイルシステムロックの使用です。 外部ロックは、MySQL サーバーなどの単一のプロセスが、テーブルへのアクセスを必要とする唯一のプロセスであると想定できない状況で使用されます。 次にいくつかの例を示します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            同じデータベースディレクトリを使用する複数のサーバーを実行する場合 (推奨されません)、各サーバーで外部ロックが有効になっている必要があります。
          </p></li><li class="listitem"><p>
            <span class="command"><strong>myisamchk</strong></span> を使用して <code class="literal">MyISAM</code> テーブルに対して保守操作を実行する場合、サーバーが実行中でないことを確認するか、サーバーが必要に応じてテーブルファイルをロックし、テーブルへのアクセスを <span class="command"><strong>myisamchk</strong></span> によって調整するように、サーバーで外部ロックが有効になっていることを確認する必要があります。 同じことが、<code class="literal">MyISAM</code> テーブルをパックするために <span class="command"><strong>myisampack</strong></span> を使用する場合にも当てはまります。 
          </p><p>
            外部ロックを有効にしてサーバーを実行する場合、テーブルのチェックなどの読み取り操作のために、いつでも <span class="command"><strong>myisamchk</strong></span> を使用できます。 この場合、<span class="command"><strong>myisamchk</strong></span> が使用しているテーブルをサーバーが更新しようとすると、サーバーは <span class="command"><strong>myisamchk</strong></span> が終了するまで待機してから続行します。 
          </p><p>
            テーブルの修復や最適化などの書き込み操作のために <span class="command"><strong>myisamchk</strong></span> を使用する場合、または <span class="command"><strong>myisampack</strong></span> を使用してテーブルをパックする場合は、<span class="command"><strong>mysqld</strong></span> サーバーがそのテーブルを使用していないことを常に確認する<span class="emphasis"><em>必要があります</em></span>。 <span class="command"><strong>mysqld</strong></span> を停止しない場合は、少なくとも <span class="command"><strong>mysqladmin flush-tables</strong></span> を実行してから <span class="command"><strong>myisamchk</strong></span> を実行します。 サーバーと <span class="command"><strong>myisamchk</strong></span> が同時にテーブルにアクセスすると、テーブルが<span class="emphasis"><em>破損する可能性があります</em></span>。 
          </p></li></ul></div><p>
        外部ロックが有効になっていると、テーブルへのアクセスを必要とする各プロセスは、テーブルへのアクセスに進む前にテーブルファイルに対するファイルシステムロックを獲得します。 必要なすべてのロックを獲得できない場合、(現在ロックを保持しているプロセスがそれらを解放したあとに) ロックを取得できるまで、プロセスはテーブルへのアクセスをブロックされます。 
      </p><p>
        サーバーは場合によってテーブルにアクセスできるまでほかのプロセスを待機する必要があるため、外部ロックはサーバーのパフォーマンスに影響します。
      </p><p>
        単一のサーバーを実行して特定のデータディレクトリにアクセスする場合 (これは通常のケースです) およびサーバーの実行中に <span class="command"><strong>myisamchk</strong></span> などのほかのプログラムでテーブルを変更する必要がない場合、外部ロックは不要です。 ほかのプログラムでテーブルを<span class="emphasis"><em>読み取る</em></span>だけである場合、外部ロックは不要ですが、<span class="command"><strong>myisamchk</strong></span> がテーブルを読み取っている間にサーバーがテーブルを変更すると、<span class="command"><strong>myisamchk</strong></span> が警告をレポートすることがあります。 
      </p><p>
        外部ロックが無効になっていて、<span class="command"><strong>myisamchk</strong></span> を使用するには、<span class="command"><strong>myisamchk</strong></span> の実行中にサーバーを停止するか、<span class="command"><strong>myisamchk</strong></span> を実行する前にテーブルをロックし、フラッシュする必要があります。 この要件を回避するには、<code class="literal">CHECK TABLE</code> および <code class="literal">REPAIR TABLE</code> ステートメントを使用して、<code class="literal">MyISAM</code> テーブルをチェックし、修復します。 
      </p><p>
        <span class="command"><strong>mysqld</strong></span> の場合、外部ロックは <code class="literal">skip_external_locking</code> システム変数の値で制御されます。 この変数が有効にされている場合、外部ロックは無効になり、その逆も同じです。 外部ロックはデフォルトで無効になっています。 
      </p><p>
        外部ロックの使用は、サーバーの起動時に <code class="option">--external-locking</code> または <code class="option">--skip-external-locking</code> オプションを使用して制御できます。
      </p><p>
        外部ロックオプションを使用して多数の MySQL プロセスから <code class="literal">MyISAM</code> テーブルへの更新を有効にする場合は、<code class="literal">delay_key_write</code> システム変数を <code class="literal">ALL</code> に設定してサーバーを起動したり、共有テーブルに対して <code class="literal">DELAY_KEY_WRITE=1</code> テーブルオプションを使用しないでください。 そうでないと、インデックスが破損する可能性があります。 
      </p><p>
        この条件を満たす最も簡単な方法は、常に <code class="option">--external-locking</code> を <code class="option">--delay-key-write=OFF</code> とともに使用することです。 (これは、多くのセットアップで、前述のオプションを組み合わせることが有用であるため、デフォルトで実行されません。) 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="optimizing-server"></a>8.12 MySQL サーバーの最適化</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#disk-issues">8.12.1 ディスク I/O の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#symbolic-links">8.12.2 シンボリックリンクの使用</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-memory">8.12.3 メモリーの使用の最適化</a></span></dt></dl></div><p>
      このセクションでは、主に SQL ステートメントのチューニングではなくシステム構成を扱うデータベースサーバーの最適化技法について説明します。 このセクションの情報は、管理しているサーバー全体のパフォーマンスとスケーラビリティーを確保したい DBA、データベースのセットアップを含むインストールスクリプトを構築する開発者、および生産性を最大にしたいと考え、開発、テストなどのために自分自身で MySQL を実行しているユーザーに適しています。 
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="disk-issues"></a>8.12.1 ディスク I/O の最適化</h3></div></div></div><a class="indexterm" name="idm45661473606304"></a><a class="indexterm" name="idm45661473604848"></a><a class="indexterm" name="idm45661473602816"></a><p>
        このセクションでは、より高速なストレージハードウェアをデータベースサーバー専用にできる場合に、ストレージデバイスを構成する方法について説明します。 I/O のパフォーマンスを向上させるための <code class="literal">InnoDB</code> 構成の最適化の詳細は、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8 InnoDB ディスク I/O の最適化">セクション8.5.8「InnoDB ディスク I/O の最適化」</a> を参照してください。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ディスクシークはパフォーマンスの大きなボトルネックです。 この問題は、データの量が、効果的なキャッシュが実行不能になるほど大きくなり始めると、明確になります。 多かれ少なかれランダムにデータにアクセスする大きなデータベースの場合、読み取りには最低 1 回、書き込みには 2 回のディスクシークが確実に必要になります。 この問題を最小にするには、少ないシーク回数でディスクを使用します。 
          </p></li><li class="listitem"><p>
            さまざまなディスクにファイルをシンボリックリンクするか、ディスクストライピングを行なって、使用可能なディスクスピンドル数を増やします (およびそれによってシークのオーバーヘッドを軽減します)。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                シンボリックリンクの使用
              </p><p>
                これは、<code class="literal">MyISAM</code> テーブルの場合、データディレクトリ内の通常の場所から別のディスクへのインデックスファイルやデータファイルのシンボリックリンクを作成する (ストライピングされることもある) ことを意味します。 ディスクがほかの目的にも使用されていないものとして、これによって、シークと読み取り時間がともに改善されます。 <a class="xref" href="optimization.html#symbolic-links" title="8.12.2 シンボリックリンクの使用">セクション8.12.2「シンボリックリンクの使用」</a>を参照してください。 
              </p><p>
                シンボリックリンクは、<code class="literal">InnoDB</code> テーブルでの使用はサポートされていません。 ただし、<code class="literal">InnoDB</code> データおよびログファイルを異なる物理ディスクに配置することは可能です。 詳細は、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8 InnoDB ディスク I/O の最適化">セクション8.5.8「InnoDB ディスク I/O の最適化」</a>を参照してください。 
              </p></li><li class="listitem"><p>
                <a class="indexterm" name="idm45661473587888"></a> ストライピング
              </p><p>
                ストライピングは、多数のディスクがあり、最初のブロックを最初のディスクに、2 番目のブロックを 2 番目のディスクに、<em class="replaceable"><code>N</code></em> 番目のブロックを (<code class="literal"><em class="replaceable"><code>N</code></em> MOD <em class="replaceable"><code>number_of_disks</code></em></code>) 番目のディスクにというように配置することを意味します。 つまり、通常のデータサイズがストライプサイズより小さい (または完全に一致している) 場合に、パフォーマンスが大幅に向上します。 ストライピングはオペレーティングシステムとストライプサイズに大きく依存するため、さまざまなストライプサイズでアプリケーションのベンチマークを行なってください。 <a class="xref" href="optimization.html#custom-benchmarks" title="8.13.2 独自のベンチマークの使用">セクション8.13.2「独自のベンチマークの使用」</a>を参照してください。 
              </p><p>
                ストライピングの速度の違いは、パラメータに<span class="emphasis"><em>大きく</em></span>依存します。 ストライピングパラメータの設定方法とディスク数によって、桁違いの差が測定されることがあります。 ランダムアクセスに対する最適化か順次アクセスに対する最適化かを選択する必要があります。 
              </p></li></ul></div></li><li class="listitem"><p>
            信頼性のため、RAID 0+1 (ストライピングとミラーリング) を使用したいと考える場合がありますが、この場合、<em class="replaceable"><code>N</code></em> 個のドライブのデータを保持するために 2 × <em class="replaceable"><code>N</code></em> 個のドライブが必要です。 これは、そのための資金がある場合に最適なオプションである可能性があります。 ただし、それを効率的に処理するために、何らかのボリューム管理ソフトウェアに投資する必要がある場合もあります。 
          </p></li><li class="listitem"><p>
            適切なオプションは、ある種類のデータがどのくらい重要であるかに応じて RAID レベルを変えることです。 たとえば、再生成が可能なやや重要なデータは RAID 0 ディスクに格納しますが、ホスト情報やログなどの本当に重要なデータは、RAID 0+1 または RAID <em class="replaceable"><code>N</code></em> ディスクに格納します。 RAID <em class="replaceable"><code>N</code></em> は、パリティビットの更新に必要な時間のため、多くの書き込みがある場合に問題になる可能性があります。 
          </p></li><li class="listitem"><p>
            データベースが使用するファイルシステムのパラメータを設定することもできます。
          </p><p>
            ファイルに最後にアクセスされたタイミングを知る必要がない (実際にデータベースサーバーで役立たない) 場合、<code class="option">-o noatime</code> オプションを使用してファイルシステムをマウントできます。 それは、ファイルシステム上の i ノードの最終アクセス時間への更新をスキップするため、一部のディスクシークが避けられます。 
          </p><p>
            多くのオペレーティングシステムで、<code class="option">-o async</code> オプションを使用してファイルシステムをマウントすることによって、ファイルシステムが非同期に更新されるように設定できます。 コンピュータが適度に安定している場合、これにより、それほど信頼性を犠牲にすることなく、パフォーマンスが向上するはずです。 (Linux ではこのフラグがデフォルトでオンにされています。) 
          </p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="disk-issues-nfs"></a>MySQL での NFS の使用</h4></div></div></div><p>
          MySQL で NFS を使用するかどうかを検討する場合は注意が必要です。 オペレーティングシステムおよび NFS バージョンによって異なる潜在的な問題には、次のものがあります: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              NFS ボリュームに配置された MySQL データおよびログファイルはロックされ、使用できなくなります。 ロックの問題は、MySQL の複数のインスタンスが同じデータディレクトリにアクセスする場合や、停電などが原因で MySQL が適切に停止されない場合に発生することがあります。 NFS version 4 は、アドバイザおよびリースベースのロックの導入に関する基本的なロックの問題に対処します。 ただし、MySQL インスタンス間でデータディレクトリを共有することはお薦めしません。 
            </p></li><li class="listitem"><p>
              誤った順序で受信したメッセージまたはネットワークトラフィックが失われたため、データの不整合が発生しました。 この問題を回避するには、TCP with <code class="literal">hard</code> および <code class="literal">intr</code> マウントオプションを使用します。 
            </p></li><li class="listitem"><p>
              最大ファイルサイズの制限。 NFS Version 2 クライアントは、最低 2GB のファイル (signed 32 bit offset) にのみアクセスできます。 NFS Version 3 クライアントは、より大きなファイル (最大 64 ビットオフセット) をサポートします。 サポートされる最大ファイルサイズは、NFS サーバーのローカルファイルシステムによっても異なります。 
            </p></li></ul></div><p>
          プロフェッショナル SAN 環境またはその他のストレージシステム内で NFS を使用すると、このような環境外で NFS を使用するよりも高い信頼性が得られる傾向があります。 ただし、SAN 環境内の NFS は、直接接続されたストレージまたはバス接続された非ローテーションストレージよりも低速になる可能性があります。 
        </p><p>
          NFS を使用する場合は、本番環境に配備する前に NFS 設定を徹底的にテストするため、NFS Version 4 以降をお勧めします。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="symbolic-links"></a>8.12.2 シンボリックリンクの使用</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#symbolic-links-to-databases">8.12.2.1 Unix 上のデータベースへのシンボリックリンクの使用</a></span></dt><dt><span class="section"><a href="optimization.html#symbolic-links-to-tables">8.12.2.2 Unix 上の MyISAM へのシンボリックリンクの使用</a></span></dt><dt><span class="section"><a href="optimization.html#windows-symbolic-links">8.12.2.3 Windows 上のデータベースへのシンボリックリンクの使用</a></span></dt></dl></div><a class="indexterm" name="idm45661473558016"></a><a class="indexterm" name="idm45661473556560"></a><p>
        データベースやテーブルをデータベースディレクトリからほかの場所に移動して、それらを新しい場所へのシンボリックリンクに置き換えることができます。 これを実行したいと考える可能性があるのは、たとえば、データベースを空き領域の多いファイルシステムに移動する場合や、テーブルを別のディスクに分散させてシステムの速度を高める場合です。 
      </p><p>
        <code class="literal">InnoDB</code> テーブルの場合は、<a class="xref" href="innodb-storage-engine.html#innodb-create-table-external" title="15.6.1.2 外部でのテーブルの作成">セクション15.6.1.2「外部でのテーブルの作成」</a> で説明されているように、シンボリックリンクのかわりに <code class="literal">CREATE TABLE</code> ステートメントの <code class="literal">DATA DIRECTORY</code> 句を使用します。 この新機能は、サポートされるクロスプラットフォーム技法です。 
      </p><p>
        これを実行する推奨される方法は、データベースディレクトリ全体の別のディスクへのシンボリックリンクを作成することです。 <code class="literal">MyISAM</code> テーブルのシンボルリンク作成は最後の手段として行います。 
      </p><p>
        データディレクトリの場所を特定するには、次のステートメントを使用します。
      </p><pre class="programlisting">SHOW VARIABLES LIKE 'datadir';
</pre><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="symbolic-links-to-databases"></a>8.12.2.1 Unix 上のデータベースへのシンボリックリンクの使用</h4></div></div></div><a class="indexterm" name="idm45661473545072"></a><a class="indexterm" name="idm45661473542944"></a><p>
          Unix では、次の手順を使用してデータベースを symlink します:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              <code class="literal">CREATE DATABASE</code> を使用してデータベースを作成します:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE DATABASE mydb1;</code></strong>
</pre><p>
              <code class="literal">CREATE DATABASE</code> を使用すると、MySQL データディレクトリにデータベースが作成され、サーバーはデータベースディレクトリに関する情報でデータディクショナリを更新できます。
            </p></li><li class="listitem"><p>
              サーバーを停止して、移動中に新しいデータベースでアクティビティが発生しないようにします。
            </p></li><li class="listitem"><p>
              空き領域があるディスクにデータベースディレクトリを移動します。 たとえば、<span class="command"><strong>tar</strong></span> または <span class="command"><strong>mv</strong></span> を使用します。 データベースディレクトリを移動するのではなく、コピーする方法を使用する場合は、コピー後に元のデータベースディレクトリを削除します。 
            </p></li><li class="listitem"><p>
              移動したデータベースディレクトリへのソフトリンクをデータディレクトリに作成します:
            </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>ln -s <em class="replaceable"><code>/path/to/mydb1</code></em> <em class="replaceable"><code>/path/to/datadir</code></em></code></strong>
</pre><p>
              このコマンドは、<code class="filename">mydb1</code> というシンボリックリンクをデータディレクトリに作成します。
            </p></li><li class="listitem"><p>
              サーバーを再起動します。
            </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="symbolic-links-to-tables"></a>8.12.2.2 Unix 上の MyISAM へのシンボリックリンクの使用</h4></div></div></div><a class="indexterm" name="idm45661473523008"></a><a class="indexterm" name="idm45661473520880"></a><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            ここで説明するシンボリックリンクのサポートと、それを制御する <code class="option">--symbolic-links</code> オプションは非推奨になりました。これらは将来のバージョンの MySQL で削除される予定です。 また、このオプションはデフォルトで無効になっています。 
          </p></div><p>
          シンボリックリンクは、<code class="literal">MyISAM</code> テーブルに対してのみ完全にサポートされています。 ほかのストレージエンジンのテーブルで使用されているファイルの場合、シンボリックリンクを使用しようとすると、未知の問題が発生することがあります。 <code class="literal">InnoDB</code> テーブルの場合は、代わりに<a class="xref" href="innodb-storage-engine.html#innodb-create-table-external" title="15.6.1.2 外部でのテーブルの作成">セクション15.6.1.2「外部でのテーブルの作成」</a>に説明する代替の技法を使用します。 
        </p><p>
          完全に動作する <code class="literal">realpath()</code> 呼び出しがないシステムでは、テーブルのシンボリックリンクを作成しないでください。 (Linux と Solaris では <code class="literal">realpath()</code> をサポートしています)。 システムでシンボリックリンクをサポートしているかどうかを判断するには、次のステートメントを使用して、<code class="literal">have_symlink</code> システム変数の値をチェックします。 
        </p><pre class="programlisting">SHOW VARIABLES LIKE 'have_symlink';
</pre><p>
          <code class="literal">MyISAM</code> テーブルのシンボリックリンクの処理は次のように機能します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              データディレクトリには、常にデータ (<code class="filename">.MYD</code>) ファイルとインデックス (<code class="filename">.MYI</code>) ファイルがあります。 データファイルとインデックスファイルは、ほかの場所に移動し、データディレクトリ内でシンボリックリンクによって置き換えることができます。 
            </p></li><li class="listitem"><p>
              データファイルとインデックスファイルは、独立して別々のディレクトリへのシンボリックリンクを作成できます。
            </p></li><li class="listitem"><p>
              実行中の MySQL サーバーにシンボリックリンクの作成を実行するように指示するには、<code class="literal">CREATE TABLE</code> に <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> オプションを使用します。 <a class="xref" href="sql-statements.html#create-table" title="13.1.20 CREATE TABLE ステートメント">セクション13.1.20「CREATE TABLE ステートメント」</a>を参照してください。 または、<span class="command"><strong>mysqld</strong></span> が実行中でない場合は、コマンド行から <span class="command"><strong>ln -s</strong></span> を使用して、シンボリックリンクの作成を手動で実行できます。 
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> オプションのいずれか、または両方で使用されるパスには、MySQL <code class="literal">data</code> ディレクトリを含めることができません。 (Bug #32167) 
              </p></div></li><li class="listitem"><p>
              <span class="command"><strong>myisamchk</strong></span> が、シンボリックリンクをデータファイルやインデックスファイルに置き換えません。 それは、シンボリックリンクが指しているファイルに対して直接作用します。 一時ファイルはすべてデータファイルやインデックスファイルが配置されているディレクトリに作成されます。 同じことが <code class="literal">ALTER TABLE</code>、<code class="literal">OPTIMIZE TABLE</code>、および <code class="literal">REPAIR TABLE</code> ステートメントにも当てはまります。 
            </p></li><li class="listitem"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                シンボリックリンクを使用しているテーブルを削除すると、<span class="emphasis"><em>シンボリックリンクとシンボリックリンクが指しているファイルの両方が削除されます</em></span>。 これは、<span class="command"><strong>mysqld</strong></span> を <code class="literal">root</code> オペレーティングシステムユーザーとして実行しないか、オペレーティングシステムユーザーに MySQL データベースディレクトリへの書込みアクセス権を付与しないことが非常によい理由です。 
              </p></div></li><li class="listitem"><p>
              <code class="literal">ALTER TABLE ... RENAME</code> または <code class="literal">RENAME TABLE</code> を使用してテーブルの名前を変更し、テーブルを別のデータベースに移動しない場合、データベースディレクトリのシンボリックリンクの名前が新しい名前に変更され、データファイルとインデックスファイルもそれに従って名前が変更されます。
            </p></li><li class="listitem"><p>
              <code class="literal">ALTER TABLE ... RENAME</code> または <code class="literal">RENAME TABLE</code> を使用してテーブルを別のデータベースに移動すると、テーブルが別のデータベースディレクトリに移動されます。 テーブル名が変更された場合、新しいデータベースディレクトリ内のシンボリックリンクの名前が新しい名前に変更され、データファイルとインデックスファイルもそれに従って名前が変更されます。 
            </p></li><li class="listitem"><p>
              シンボリックリンクを使用していない場合、<code class="option">--skip-symbolic-links</code> オプションを付けて <span class="command"><strong>mysqld</strong></span> を起動し、だれも <span class="command"><strong>mysqld</strong></span> を使用して、データディレクトリ外のファイルを削除したり名前を変更したりできないようにします。
            </p></li></ul></div><p>
          これらのテーブルシンボリックリンクの操作はサポートされていません。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">ALTER TABLE</code> は <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> テーブルオプションを無視します。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="windows-symbolic-links"></a>8.12.2.3 Windows 上のデータベースへのシンボリックリンクの使用</h4></div></div></div><a class="indexterm" name="idm45661473468144"></a><a class="indexterm" name="idm45661473466688"></a><a class="indexterm" name="idm45661473464736"></a><a class="indexterm" name="idm45661473463200"></a><p>
          Windows では、データベースディレクトリにシンボリックリンクを使用できます。 これにより、データベースディレクトリへのシンボリックリンクを設定して、それを別の場所 (別のディスク上など) に置くことができます。 Windows でのデータベースシンボリックリンクの使用は、Unix でのそれらの使用に似ていますが、リンクのセットアップの手順は異なります。 
        </p><p>
          <code class="literal">mydb</code> というデータベースのデータベースディレクトリを <code class="filename">D:\data\mydb</code> に配置したいとします。 これを実行するには、MySQL データディレクトリ内に <code class="filename">D:\data\mydb</code> を指すシンボリックリンクを作成します。 ただし、シンボリックリンクを作成する前に、必要に応じて <code class="filename">D:\data\mydb</code> ディレクトリを作成して、それが存在することを確認します。 データディレクトリ内に <code class="filename">mydb</code> というデータベースディレクトリがすでにある場合は、それを <code class="filename">D:\data</code> に移動します。 それ以外の場合、シンボリックリンクは無効です。 問題を避けるために、データベースディレクトリの移動時にサーバーが実行していないことを確認してください。 
        </p><p>
          Windows では、<span class="command"><strong>mklink</strong></span> コマンドを使用してシンボリックリンクを作成できます。 このコマンドには管理者権限が必要です。 
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              場所をデータディレクトリ内に変更します。
            </p><pre class="programlisting">C:\&gt; <strong class="userinput"><code>cd <em class="replaceable"><code>\path\to\datadir</code></em></code></strong>
</pre></li><li class="listitem"><p>
              データディレクトリで、データベースディレクトリの場所を指す <code class="filename">mydb</code> というシンボリックリンクを作成します。
            </p><pre class="programlisting">C:\&gt; <strong class="userinput"><code>mklink /d mydb D:\data\mydb</code></strong>
</pre></li></ol></div><p>
          このあと、データベース <code class="literal">mydb</code> に作成されるすべてのテーブルが <code class="filename">D:\data\mydb</code> に作成されます。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-memory"></a>8.12.3 メモリーの使用の最適化</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#memory-use">8.12.3.1 MySQL のメモリーの使用方法</a></span></dt><dt><span class="section"><a href="optimization.html#large-page-support">8.12.3.2 ラージページのサポートの有効化</a></span></dt></dl></div><a class="indexterm" name="idm45661473441776"></a><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="memory-use"></a>8.12.3.1 MySQL のメモリーの使用方法</h4></div></div></div><a class="indexterm" name="idm45661473438560"></a><p>
          MySQL はバッファおよびキャッシュを割り当てて、データベース操作のパフォーマンスを向上させます。 デフォルトの構成は、RAM が約 512MB の仮想マシンで MySQL サーバーを起動できるように設計されています。 特定のキャッシュおよびバッファ関連のシステム変数の値を増やすことで、MySQL のパフォーマンスを向上できます。 メモリーが制限されたシステムで MySQL を実行するように、デフォルトの構成を変更することもできます。 
        </p><p>
          次のリストでは、MySQL がメモリーを使用する方法をいくつか説明します。 該当する場合は、関連するシステム変数が参照されます。 ストレージエンジンまたは機能固有の項目もあります。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">InnoDB</code> バッファプールは、テーブル、インデックスおよびその他の補助バッファのキャッシュされた <code class="literal">InnoDB</code> データを保持するメモリー領域です。 大容量読み取り操作の効率を高めるため、バッファープールは複数行を保持できる<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>に分割されます。 キャッシュ管理の効率のために、バッファープールはページのリンクリストとして実装されます。まれにしか使用されないデータは、<a class="link" href="glossary.html#glos_lru" title="LRU">LRU</a> アルゴリズムのバリエーションを使用してキャッシュからエージアウトされます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool" title="15.5.1 バッファプール">セクション15.5.1「バッファプール」</a>を参照してください。 
            </p><p>
              バッファプールのサイズは、システムパフォーマンスのために重要です:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">InnoDB</code> は、<code class="literal">malloc()</code> 操作を使用して、サーバー起動時にバッファプール全体にメモリーを割り当てます。 <code class="literal">innodb_buffer_pool_size</code> システム変数は、バッファープールサイズを定義します。 通常、推奨される <code class="literal">innodb_buffer_pool_size</code> 値は、システムメモリーの 50 から 75% です。<code class="literal">innodb_buffer_pool_size</code> は、サーバーの実行中に動的に構成できます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-resize" title="15.8.3.1 InnoDB バッファプールサイズの構成">セクション15.8.3.1「InnoDB バッファプールサイズの構成」</a>を参照してください。 
                </p></li><li class="listitem"><p>
                  メモリーが大量にあるシステムでは、バッファプールを複数の <a class="link" href="glossary.html#glos_buffer_pool_instance" title="バッファープールインスタンス">buffer pool instances</a> に分割することで同時実行性を向上させることができます。 <code class="literal">innodb_buffer_pool_instances</code> システム変数は、バッファープールインスタンスの数を定義します。 
                </p></li><li class="listitem"><p>
                  バッファプールが小さすぎると、ページがバッファプールからフラッシュされるときに、後で再度必要になるだけであるため、過剰なチャーニングが発生する可能性があります。
                </p></li><li class="listitem"><p>
                  バッファプールが大きすぎると、メモリーの競合が原因でスワッピングが発生する場合があります。
                </p></li></ul></div></li><li class="listitem"><p>
              ストレージエンジンインタフェースを使用すると、オプティマイザは、オプティマイザが複数の行を読み取る可能性が高いスキャンに使用されるレコードバッファーのサイズに関する情報を提供できます。 バッファサイズは、見積りのサイズによって異なる場合があります。 <code class="literal">InnoDB</code> では、この可変サイズのバッファリング機能を使用して、行プリフェッチを利用し、ラッチおよび B ツリーナビゲーションのオーバーヘッドを削減します。 
            </p></li><li class="listitem"><p>
              すべてのスレッドが <code class="literal">MyISAM</code> キーバッファを共有します。 <code class="literal">key_buffer_size</code> システム変数によってサイズが決まります。 
            </p><p>
              サーバーが開く <code class="literal">MyISAM</code> テーブルごとに、インデックスファイルが一度開かれます。テーブルにアクセスする同時に実行されているスレッドごとに、データファイルが一度開かれます。 同時スレッドごとに、テーブル構造、各カラムのカラム構造、およびサイズ <code class="literal">3 * <em class="replaceable"><code>N</code></em></code> のバッファーが割り当てられます (ここで <em class="replaceable"><code>N</code></em> は最大行長で、<code class="literal">BLOB</code> カラムをカウントしていません)。 <code class="literal">BLOB</code> カラムには、5 から 8 バイト+ <code class="literal">BLOB</code> データの長さが必要です。 <code class="literal">MyISAM</code> ストレージエンジンは、内部使用のため 1 つ余分な行バッファーを保持します。 
            </p></li><li class="listitem"><p>
              <code class="literal">myisam_use_mmap</code> システム変数を 1 に設定して、すべての <code class="literal">MyISAM</code> テーブルのメモリーマッピングを有効にできます。
            </p></li><li class="listitem"><p>
              内部インメモリー一時テーブルが大きすぎる場合 (<code class="literal">tmp_table_size</code> および <code class="literal">max_heap_table_size</code> システム変数を使用して決定)、MySQL はテーブルをインメモリーからディスク上の形式に自動的に変換します。 MySQL 8.0.16 の時点では、ディスク上の一時テーブルは常に InnoDB ストレージエンジンを使用します。 (以前は、この目的に使用されていたストレージエンジンは、サポートされなくなった <code class="literal">internal_tmp_disk_storage_engine</code> システム変数によって決定されていました。) <a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4 MySQL での内部一時テーブルの使用">セクション8.4.4「MySQL での内部一時テーブルの使用」</a>に説明するように、許可される一時テーブルのサイズを増やすことができます。 
            </p><p>
              <code class="literal">CREATE TABLE</code> を使用して明示的に作成された <code class="literal">MEMORY</code> テーブルの場合、<code class="literal">max_heap_table_size</code> システム変数のみがテーブルの大きさを決定し、ディスク上の形式への変換はありません。
            </p></li><li class="listitem"><p>
              <a class="link" href="performance-schema.html" title="第 27 章 MySQL パフォーマンススキーマ">MySQL Performance Schema</a> は、MySQL サーバーの実行を低レベルで監視するための機能です。 パフォーマンススキーマは、サーバーの起動時に必要なメモリーを割り当てるのではなく、メモリー使用量を実際のサーバー負荷に合わせて増分的に割り当てます。 割り当てられたメモリーは、サーバーが再起動されるまで解放されません。 詳細は、<a class="xref" href="performance-schema.html#performance-schema-memory-model" title="27.17 パフォーマンススキーマのメモリー割り当てモデル">セクション27.17「パフォーマンススキーマのメモリー割り当てモデル」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              サーバーがクライアント接続の管理に使用する各スレッドには、スレッド固有の領域が必要です。 次のリストは、これらの変数とそのサイズを制御するシステム変数を示しています: 
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  スタック (<code class="literal">thread_stack</code>)
                </p></li><li class="listitem"><p>
                  接続バッファ (<code class="literal">net_buffer_length</code>)
                </p></li><li class="listitem"><p>
                  結果バッファ (<code class="literal">net_buffer_length</code>)
                </p></li></ul></div><p>
              接続バッファーと結果バッファーはそれぞれ <code class="literal">net_buffer_length</code> バイトに等しいサイズから開始されますが、必要に応じて <code class="literal">max_allowed_packet</code> バイトまで動的に拡大されます。 結果バッファーは各 SQL ステートメントのあとに <code class="literal">net_buffer_length</code> バイトに縮小されます。 ステートメントの実行中は現在のステートメント文字列のコピーも割り当てられます。 
            </p><p>
              各接続スレッドは、ステートメントダイジェストの計算にメモリーを使用します。 サーバーは、セッションごとに <code class="literal">max_digest_length</code> バイトを割り当てます。 <a class="xref" href="performance-schema.html#performance-schema-statement-digests" title="27.10 パフォーマンススキーマのステートメントダイジェストとサンプリング">セクション27.10「パフォーマンススキーマのステートメントダイジェストとサンプリング」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              すべてのスレッドで同じベースメモリーを共有します。
            </p></li><li class="listitem"><p>
              スレッドが必要ない場合、それに割り当てられたメモリーが解放され、スレッドがスレッドキャッシュに戻らないかぎり、システムに返されます。 その場合、メモリーは割り当てられた状態のままになります。 
            </p></li><li class="listitem"><p>
              テーブルの順次スキャンを実行する各リクエストによって、<span class="firstterm">read buffer</span> が割り当てられます。 <code class="literal">read_buffer_size</code> システム変数によってバッファサイズが決まります。 
            </p></li><li class="listitem"><p>
              任意の順序 (ソート後など) で行を読み取る場合、ディスクシークを回避するために<span class="firstterm">ランダム読取りバッファ</span>を割り当てることができます。 <code class="literal">read_rnd_buffer_size</code> システム変数によってバッファサイズが決まります。 
            </p></li><li class="listitem"><p>
              すべての結合は単一のパスで実行され、ほとんどの結合は一時テーブルも使用せずに実行できます。 ほとんどの一時テーブルはメモリーベースのハッシュテーブルです。 大きな行長 (すべてのカラム長の合計として算出される) を持つか <code class="literal">BLOB</code> カラムを含む一時テーブルはディスク上に格納されます。 
            </p></li><li class="listitem"><p>
              ソートを実行するほとんどのリクエストは、ソートバッファーおよび結果セットサイズに応じた 0 から 2 つの一時ファイルを割り当てます。 <a class="xref" href="error-handling.html#temporary-files" title="B.3.3.5 MySQL が一時ファイルを格納する場所">セクションB.3.3.5「MySQL が一時ファイルを格納する場所」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              ほとんどすべての解析と計算は、スレッドローカルの再利用可能なメモリープールで実行されます。 小さい項目にはメモリーオーバーヘッドは必要ないため、通常の低速メモリー割当ておよび解放が回避されます。 メモリーは、予測外に大きな文字列にのみ割り当てられます。 
            </p></li><li class="listitem"><p>
              <code class="literal">BLOB</code> カラムがあるテーブルごとに、大きな <code class="literal">BLOB</code> 値を読み取るためにバッファーが動的に拡大されます。 テーブルをスキャンすると、バッファは最大の <code class="literal">BLOB</code> 値と同じ大きさになります。 
            </p></li><li class="listitem"><p>
              MySQL には、テーブルキャッシュ用のメモリーおよびディスクリプタが必要です。 使用中のすべてのテーブルのハンドラ構造はテーブルキャッシュに保存され、<span class="quote">「<span class="quote">「先入れ先出し」</span>」</span> (FIFO) として管理されます。 <code class="literal">table_open_cache</code> システム変数は、初期テーブルキャッシュサイズを定義します。<a class="xref" href="optimization.html#table-cache" title="8.4.3.1 MySQL でのテーブルのオープンとクローズの方法">セクション8.4.3.1「MySQL でのテーブルのオープンとクローズの方法」</a> を参照してください。 
            </p><p>
              MySQL には、テーブル定義キャッシュ用のメモリーも必要です。 <code class="literal">table_definition_cache</code> システム変数は、テーブル定義キャッシュに格納できるテーブル定義の数を定義します。 多数のテーブルを使用する場合は、大規模なテーブル定義キャッシュを作成してテーブルのオープンを高速化できます。 テーブル定義キャッシュは、テーブルキャッシュとは異なり、使用する領域が少なく、ファイル記述子を使用しません。 
            </p></li><li class="listitem"><p>
              <code class="literal">FLUSH TABLES</code> ステートメントまたは <span class="command"><strong>mysqladmin flush-tables</strong></span> コマンドは、使用中でないすべてのテーブルを一度に閉じ、現在実行中のスレッドの終了時に閉じられるように使用中のすべてのテーブルをマークします。 これにより、事実上ほとんどの使用中のメモリーが解放されます。 <code class="literal">FLUSH TABLES</code> はすべてのテーブルが閉じられるまで戻りません。 
            </p></li><li class="listitem"><p>
              <code class="literal">GRANT</code>、<code class="literal">CREATE USER</code>、<code class="literal">CREATE SERVER</code>、および <code class="literal">INSTALL PLUGIN</code> ステートメントの結果として、サーバーは情報をメモリーにキャッシュします。 このメモリーは、対応する <code class="literal">REVOKE</code>, <code class="literal">DROP USER</code>, <code class="literal">DROP SERVER</code> ステートメントおよび <code class="literal">UNINSTALL PLUGIN</code> ステートメントによって解放されないため、キャッシュを引き起こすステートメントの多くのインスタンスを実行するサーバーでは、<code class="literal">FLUSH PRIVILEGES</code> で解放されないかぎり、キャッシュされたメモリーの使用量が増加します。 
            </p></li><li class="listitem"><p>
              レプリケーショントポロジでは、次の設定はメモリー使用量に影響し、必要に応じて調整できます:

              </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                    レプリケーションソースの <code class="literal">max_allowed_packet</code> システム変数は、ソースが処理のためにレプリカに送信する最大メッセージサイズを制限します。 この設定のデフォルトは 64M です。 
                  </p></li><li class="listitem"><p>
                    マルチスレッドレプリカ上の <code class="literal">slave_pending_jobs_size_max</code> システム変数は、処理待ちのメッセージを保持するために使用できるメモリーの最大量を設定します。 この設定のデフォルトは 128M です。 メモリーは必要な場合にのみ割り当てられますが、レプリケーショントポロジが大規模なトランザクションを処理する場合に使用されることがあります。 これは弱い制限であり、より大きなトランザクションを処理できます。 
                  </p></li><li class="listitem"><p>
                    レプリケーションソースまたはレプリカ上の <code class="literal">rpl_read_size</code> システム変数は、バイナリログファイルおよびリレーログファイルから読み取られるデータの最小量をバイト単位で制御します。 デフォルトは 8192 バイトです。 バイナリログおよびリレーログファイルから読み取るスレッドごとに、この値のバッファーが割り当てられます。これには、ソース上のダンプスレッドやレプリカ上のコーディネータスレッドも含まれます。 
                  </p></li><li class="listitem"><p>
                    <code class="literal">binlog_transaction_dependency_history_size</code> システム変数は、インメモリー履歴として保持される行ハッシュの数を制限します。
                  </p></li><li class="listitem"><p>
                    <code class="literal">max_binlog_cache_size</code> システム変数は、個々のトランザクションによるメモリー使用量の上限を指定します。
                  </p></li><li class="listitem"><p>
                    <code class="literal">max_binlog_stmt_cache_size</code> システム変数は、ステートメントキャッシュによるメモリー使用量の上限を指定します。
                  </p></li></ul></div><p>
            </p></li></ul></div><p>
          <span class="command"><strong>ps</strong></span> およびその他のステータスプログラムが、<span class="command"><strong>mysqld</strong></span> が大量のメモリーを使用していることをレポートすることがあります。 これは、さまざまなメモリーアドレス上のスレッドスタックによって発生する可能性があります。 たとえば、Solaris バージョンの <span class="command"><strong>ps</strong></span> はスタック間の未使用のメモリーが使用されているメモリーとしてカウントされます。 これを確認するには、<code class="literal">swap -s</code> で使用可能なスワップをチェックします。 いくつかのメモリーリーク検出ツール (市販とオープンソースの両方の) で <span class="command"><strong>mysqld</strong></span> をテストしているため、メモリーリークはないはずです。 
        </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="monitor-mysql-memory-use"></a>MySQL メモリー使用量の監視</h5></div></div></div><a class="indexterm" name="idm45661473313040"></a><a class="indexterm" name="idm45661473310928"></a><p>
            次の例は、<a class="link" href="performance-schema.html" title="第 27 章 MySQL パフォーマンススキーマ">Performance Schema</a> および <a class="link" href="sys-schema.html" title="第 28 章 MySQL sys スキーマ">sys schema</a> を使用して MySQL メモリー使用量を監視する方法を示しています。
          </p><p>
            ほとんどのパフォーマンススキーマメモリーインストゥルメンテーションはデフォルトで無効になっています。 インストゥルメントを有効にするには、パフォーマンススキーマ <code class="literal">setup_instruments</code> テーブルの <code class="literal">ENABLED</code> カラムを更新します。 メモリーインストゥルメントには <code class="literal">memory/<em class="replaceable"><code>code_area</code></em>/<em class="replaceable"><code>instrument_name</code></em></code> という形式の名前が付けられます。ここで、<em class="replaceable"><code>code_area</code></em> は <code class="literal">sql</code> や <code class="literal">innodb</code> などの値で、<em class="replaceable"><code>instrument_name</code></em> はインストゥルメントの詳細です。 
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                使用可能な MySQL メモリーインストゥルメントを表示するには、パフォーマンススキーマの <code class="literal">setup_instruments</code> テーブルをクエリーします。 次のクエリーは、すべてのコード領域に対して何百ものメモリーインストゥルメントを返します。 
              </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.setup_instruments</code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE '%memory%';</code></strong></pre><p>
                コード領域を指定して結果を絞り込むことができます。 たとえば、コード領域として <code class="literal">innodb</code> を指定することで、結果を <code class="literal">InnoDB</code> メモリーインストゥルメントに制限できます。 
              </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.setup_instruments</code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE '%memory/innodb%';</code></strong>
+-------------------------------------------+---------+-------+
| NAME                                      | ENABLED | TIMED |
+-------------------------------------------+---------+-------+
| memory/innodb/adaptive hash index         | NO      | NO    |
| memory/innodb/buf_buf_pool                | NO      | NO    |
| memory/innodb/dict_stats_bg_recalc_pool_t | NO      | NO    |
| memory/innodb/dict_stats_index_map_t      | NO      | NO    |
| memory/innodb/dict_stats_n_diff_on_level  | NO      | NO    |
| memory/innodb/other                       | NO      | NO    |
| memory/innodb/row_log_buf                 | NO      | NO    |
| memory/innodb/row_merge_sort              | NO      | NO    |
| memory/innodb/std                         | NO      | NO    |
| memory/innodb/trx_sys_t::rw_trx_ids       | NO      | NO    |
...
</pre><p>
                MySQL のインストールによっては、コード領域に <code class="literal">performance_schema</code>, <code class="literal">sql</code>, <code class="literal">client</code>, <code class="literal">innodb</code>, <code class="literal">myisam</code>, <code class="literal">csv</code>, <code class="literal">memory</code>, <code class="literal">blackhole</code>, <code class="literal">archive</code>, <code class="literal">partition</code> などが含まれる場合があります。
              </p></li><li class="listitem"><p>
                メモリーインストゥルメントを有効にするには、MySQL 構成ファイルに <code class="literal">performance-schema-instrument</code> ルールを追加します。 たとえば、すべてのメモリーインストゥルメントを有効にするには、このルールを構成ファイルに追加し、サーバーを再起動します: 
              </p><pre class="programlisting">performance-schema-instrument='memory/%=COUNTED'</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                  起動時にメモリーインストゥルメントを有効にすると、起動時に発生するメモリー割り当てが確実にカウントされます。
                </p></div><p>
                サーバーを再起動したあと、パフォーマンススキーマ <code class="literal">setup_instruments</code> テーブルの <code class="literal">ENABLED</code> カラムに、有効にしたメモリーインストゥルメントの <code class="literal">YES</code> が報告されます。 メモリー操作が時間指定されていないため、<code class="literal">setup_instruments</code> テーブルの <code class="literal">TIMED</code> カラムはメモリーインストルメントで無視されます。 
              </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.setup_instruments</code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE '%memory/innodb%';</code></strong>
+-------------------------------------------+---------+-------+
| NAME                                      | ENABLED | TIMED |
+-------------------------------------------+---------+-------+
| memory/innodb/adaptive hash index         | NO      | NO    |
| memory/innodb/buf_buf_pool                | NO      | NO    |
| memory/innodb/dict_stats_bg_recalc_pool_t | NO      | NO    |
| memory/innodb/dict_stats_index_map_t      | NO      | NO    |
| memory/innodb/dict_stats_n_diff_on_level  | NO      | NO    |
| memory/innodb/other                       | NO      | NO    |
| memory/innodb/row_log_buf                 | NO      | NO    |
| memory/innodb/row_merge_sort              | NO      | NO    |
| memory/innodb/std                         | NO      | NO    |
| memory/innodb/trx_sys_t::rw_trx_ids       | NO      | NO    |
...
</pre></li><li class="listitem"><p>
                メモリーインストゥルメントデータをクエリーします。 この例では、メモリーインスツルメントデータがパフォーマンススキーマ <code class="literal">memory_summary_global_by_event_name</code> テーブルでクエリーされ、<code class="literal">EVENT_NAME</code> によってデータが要約されます。 <code class="literal">EVENT_NAME</code> はインストゥルメントの名前です。 
              </p><p>
                次のクエリーは、<code class="literal">InnoDB</code> バッファプールのメモリーデータを返します。 カラムの説明は、<a class="xref" href="performance-schema.html#performance-schema-memory-summary-tables" title="27.12.18.10 メモリーサマリーテーブル">セクション27.12.18.10「メモリーサマリーテーブル」</a> を参照してください。 
              </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.memory_summary_global_by_event_name</code></strong>
       <strong class="userinput"><code>WHERE EVENT_NAME LIKE 'memory/innodb/buf_buf_pool'\G</code></strong>
                  EVENT_NAME: memory/innodb/buf_buf_pool
                 COUNT_ALLOC: 1
                  COUNT_FREE: 0
   SUM_NUMBER_OF_BYTES_ALLOC: 137428992
    SUM_NUMBER_OF_BYTES_FREE: 0
              LOW_COUNT_USED: 0
          CURRENT_COUNT_USED: 1
             HIGH_COUNT_USED: 1
    LOW_NUMBER_OF_BYTES_USED: 0
CURRENT_NUMBER_OF_BYTES_USED: 137428992
   HIGH_NUMBER_OF_BYTES_USED: 137428992
</pre><p>
                同じ基礎となるデータを <code class="literal">sys</code> スキーマ <code class="literal">memory_global_by_current_bytes</code> テーブルを使用してクエリーすることができます。このテーブルには、グローバルにサーバー内の現在のメモリー使用量が割当てタイプ別に分類されて表示されます。
              </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM sys.memory_global_by_current_bytes</code></strong>
       <strong class="userinput"><code>WHERE event_name LIKE 'memory/innodb/buf_buf_pool'\G</code></strong>
*************************** 1. row ***************************
       event_name: memory/innodb/buf_buf_pool
    current_count: 1
    current_alloc: 131.06 MiB
current_avg_alloc: 131.06 MiB
       high_count: 1
       high_alloc: 131.06 MiB
   high_avg_alloc: 131.06 MiB
</pre><p>
                この <code class="literal">sys</code> スキーマクエリーは、現在割り当てられているメモリー (<code class="literal">current_alloc</code>) をコード領域別に集計します:
              </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT SUBSTRING_INDEX(event_name,'/',2) AS</code></strong>
       <strong class="userinput"><code>code_area, FORMAT_BYTES(SUM(current_alloc))</code></strong>
       <strong class="userinput"><code>AS current_alloc</code></strong>
       <strong class="userinput"><code>FROM sys.x$memory_global_by_current_bytes</code></strong>
       <strong class="userinput"><code>GROUP BY SUBSTRING_INDEX(event_name,'/',2)</code></strong>
       <strong class="userinput"><code>ORDER BY SUM(current_alloc) DESC;</code></strong>
+---------------------------+---------------+
| code_area                 | current_alloc |
+---------------------------+---------------+
| memory/innodb             | 843.24 MiB    |
| memory/performance_schema | 81.29 MiB     |
| memory/mysys              | 8.20 MiB      |
| memory/sql                | 2.47 MiB      |
| memory/memory             | 174.01 KiB    |
| memory/myisam             | 46.53 KiB     |
| memory/blackhole          | 512 bytes     |
| memory/federated          | 512 bytes     |
| memory/csv                | 512 bytes     |
| memory/vio                | 496 bytes     |
+---------------------------+---------------+
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                  MySQL 8.0.16 より前は、<code class="literal">sys.format_bytes()</code> は <code class="literal">FORMAT_BYTES()</code> に使用されていました。
                </p></div><p>
                <code class="literal">sys</code> スキーマの詳細は、<a class="xref" href="sys-schema.html" title="第 28 章 MySQL sys スキーマ">第28章「<i>MySQL sys スキーマ</i>」</a> を参照してください。
              </p></li></ol></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="large-page-support"></a>8.12.3.2 ラージページのサポートの有効化</h4></div></div></div><a class="indexterm" name="idm45661473242464"></a><p>
          ハードウェアまたはオペレーティングシステムのアーキテクチャーによっては、デフォルト (通常は 4K バイト) よりも大きいメモリーページをサポートしています。 このサポートの実際の実装は、ベースとなるハードウェアやオペレーティングシステムに依存します。 大量のメモリーアクセスがあるアプリケーションの場合、大きいページを使用して、トランスレーションルックアサイドバッファー (TLB; Translation Lookaside Buffer) のミスが減ることによってパフォーマンスが改善される可能性があります。 
        </p><p>
          MySQL では、InnoDB でラージページを使用して、バッファープールと追加のメモリープールにメモリーを割り当てることができます。
        </p><p>
          MySQL での標準的な大規模ページの使用では、サポートされる最大サイズである 4M バイトまでの使用が試行されます。 Solaris では<span class="quote">「<span class="quote">超大規模ページ</span>」</span>機能により 256M バイトまでのページの使用が可能です。 この機能は最新の SPARC プラットフォームで使用できます。 これは <code class="option">--super-large-pages</code> または <code class="option">--skip-super-large-pages</code> オプションを使用して有効または無効にできます。 
        </p><p>
          MySQL は、ラージページのサポートの Linux 実装 (Linux では HugeTLB と呼ばれる) もサポートします。
        </p><p>
          Linux でラージページを使用する前に、カーネルで、それらをサポートできるようにする必要があり、HugeTLB メモリープールを構成する必要があります。 参考のため、HugeTBL API は、Linux ソースの <code class="filename">Documentation/vm/hugetlbpage.txt</code> ファイルで説明されています。 
        </p><p>
          Red Hat Enterprise Linux などの一部の最近のシステムのカーネルでは、ラージページ機能がデフォルトで有効にされているようです。 使用しているカーネルにこれが当てはまるかどうかを確認するには、次のコマンドを使用し、<span class="quote">「<span class="quote">huge</span>」</span> を含む出力行を探します。 
        </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>cat /proc/meminfo | grep -i huge</code></strong>
HugePages_Total:       0
HugePages_Free:        0
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       4096 kB
</pre><p>
          空でないコマンド出力は、ラージページのサポートが存在することを示しますが、ゼロの値は、使用するように構成されたページがないことを示します。
        </p><p>
          ラージページをサポートするようにカーネルを再構成する必要がある場合、手順については <code class="filename">hugetlbpage.txt</code> ファイルを参照してください。
        </p><p>
          Linux カーネルでラージページのサポートが有効にされていると仮定し、それを次のコマンドを使用して、MySQL で使用するように構成します。 通常、システムが起動するたびにコマンドが実行されるように、システムのブートシーケンス中に実行される <code class="filename">rc</code> ファイルまたは同等の起動ファイルにこれらを入れます。 コマンドは、ブートシーケンスの早期の、MySQL サーバーが起動する前に実行されるべきです。 システムに適切なように、割り当ての数値とグループ番号を変更してください。 
        </p><pre class="programlisting"># Set the number of pages to be used.
# Each page is normally 2MB, so a value of 20 = 40MB.
# This command actually allocates memory, so this much
# memory must be available.
echo 20 &gt; /proc/sys/vm/nr_hugepages

# Set the group number that is permitted to access this
# memory (102 in this case). The mysql user must be a
# member of this group.
echo 102 &gt; /proc/sys/vm/hugetlb_shm_group

# Increase the amount of shmem permitted per segment
# (12G in this case).
echo 1560281088 &gt; /proc/sys/kernel/shmmax

# Increase total amount of shared memory.  The value
# is the number of pages. At 4KB/page, 4194304 = 16GB.
echo 4194304 &gt; /proc/sys/kernel/shmall
</pre><p>
          MySQL で使用する場合、通常 <code class="literal">shmmax</code> の値を <code class="literal">shmall</code> の値に近くなるようにしたいと考えます。
        </p><p>
          ラージページの構成を確認するには、前述のとおりに再度 <code class="filename">/proc/meminfo</code> をチェックします。 これで、0 以外の値が表示されるはずです。 
        </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>cat /proc/meminfo | grep -i huge</code></strong>
HugePages_Total:      20
HugePages_Free:       20
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       4096 kB
</pre><p>
          <code class="literal">hugetlb_shm_group</code> を使用するための最後の手順は、<code class="literal">mysql</code> ユーザーに、memlock 制限として <span class="quote">「<span class="quote">unlimited</span>」</span> 値を指定することです。 これを行うには、<code class="filename">/etc/security/limits.conf</code> を編集するか、次のコマンドを <span class="command"><strong>mysqld_safe</strong></span> スクリプトに追加します: 
        </p><pre class="programlisting">ulimit -l unlimited
</pre><p>
          <span class="command"><strong>ulimit</strong></span> コマンドを <span class="command"><strong>mysqld_safe</strong></span> に追加すると、<code class="literal">mysql</code> ユーザーに切り替える前に <code class="literal">root</code> ユーザーの memlock 制限が <code class="literal">unlimited</code> に設定されます。 (これは、<span class="command"><strong>mysqld_safe</strong></span> が <code class="literal">root</code> によって起動されたものと仮定します。)  
        </p><p>
          MySQL のラージページのサポートはデフォルトで無効にされています。 それを有効にするには、サーバーを <code class="option">--large-pages</code> オプションで起動します。 たとえば、サーバー <code class="filename">my.cnf</code> ファイルで次の行を使用できます: 
        </p><pre class="programlisting">[mysqld]
large-pages
</pre><p>
          このオプションを使用すると、<code class="literal">InnoDB</code> はそのバッファープールと追加のメモリープールに自動的にラージページを使用します。 <code class="literal">InnoDB</code> がこれを実行できない場合、従来のメモリーの使用に戻り、エラーログに警告を書き込みます: <span class="errortext">Warning: Using conventional memory pool</span> 
        </p><p>
          ラージページが使用されていることを確認するには、再度 <code class="literal">/proc/meminfo</code> をチェックします。
        </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>cat /proc/meminfo | grep -i huge</code></strong>
HugePages_Total:      20
HugePages_Free:       20
HugePages_Rsvd:        2
HugePages_Surp:        0
Hugepagesize:       4096 kB
</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="optimize-benchmarking"></a>8.13 パフォーマンスの測定 (ベンチマーク)</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#select-benchmarking">8.13.1 式と関数の速度の測定</a></span></dt><dt><span class="section"><a href="optimization.html#custom-benchmarks">8.13.2 独自のベンチマークの使用</a></span></dt><dt><span class="section"><a href="optimization.html#monitoring-performance-schema">8.13.3 performance_schema によるパフォーマンスの測定</a></span></dt></dl></div><a class="indexterm" name="idm45661473195776"></a><p>
      パフォーマンスを測定するには、次の要因を考慮します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ビジーでないシステムで単一の操作の速度を測定するかどうか、一連の操作 (<span class="quote">「<span class="quote">ワークロード</span>」</span>) が一定の期間でどの程度機能するか。 単純なテストでは、通常 1 つの側面 (構成設定、テーブルのインデックスのセット、クエリー内の SQL 句) の変化がパフォーマンスにどのように影響するかをテストします。 ベンチマークは一般に長時間実行の複雑なパフォーマンステストであり、結果によって、ハードウェアやストレージ構成などの高レベルの選択や新しい MySQL バージョンにあとどのくらいでアップグレードするかが決まります。 
        </p></li><li class="listitem"><p>
          ベンチマークでは、正確な実態を得るために、重いデータベースワークロードをシミュレートする必要がある場合があります。
        </p></li><li class="listitem"><p>
          パフォーマンスはきわめて多くのさまざまな要因によって異なる可能性があり、数パーセントの違いが決定的勝利にならないことがあります。 結果は、別の環境でテストした場合に、逆の方向に転換することもあります。 
        </p></li><li class="listitem"><p>
          特定の MySQL 機能は、ワークロードに応じて、パフォーマンスに役立つ場合と役立たない場合があります。 完全性のため、常にそれらの機能をオンにした状態とオフにした状態でパフォーマンスをテストします。 各ワークロードで試行する最も重要な機能は、<code class="literal">InnoDB</code> テーブルの <a class="link" href="innodb-storage-engine.html#innodb-adaptive-hash" title="15.5.3 適応型ハッシュインデックス">adaptive hash index</a> です。 
        </p></li></ul></div><p>
      このセクションでは、1 人の開発者が実行できる単純で直接的な測定技法から、実行と結果の解釈に追加の専門技術を必要とするもっと複雑な技法に進めていきます。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="select-benchmarking"></a>8.13.1 式と関数の速度の測定</h3></div></div></div><p>
        特定の MySQL 式または関数の速度を測定するには、<span class="command"><strong>mysql</strong></span> クライアントプログラムを使用して、<code class="literal">BENCHMARK()</code> 関数を呼び出します。 構文は <code class="literal">BENCHMARK(<em class="replaceable"><code>loop_count</code></em>,<em class="replaceable"><code>expr</code></em>)</code> です。 戻り値は常に 0 ですが、<span class="command"><strong>mysql</strong></span> はステートメントの実行にどのくらいの時間を要したかを表示する行を出力します。 例: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT BENCHMARK(1000000,1+1);</code></strong>
+------------------------+
| BENCHMARK(1000000,1+1) |
+------------------------+
|                      0 |
+------------------------+
1 row in set (0.32 sec)
</pre><p>
        この結果は Pentium II 400MHz システムで取得されました。 これは、MySQL がそのシステムで 1,000,000 件の単純な加算式を 0.32 秒間で実行できることを示しています。 
      </p><p>
        組み込みの MySQL 関数は一般に高度に最適化されますが、例外がある場合もあります。 <code class="literal">BENCHMARK()</code> はクエリーで特定の関数が問題になっているかどうかを調べる場合に優れたツールです。 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="custom-benchmarks"></a>8.13.2 独自のベンチマークの使用</h3></div></div></div><a class="indexterm" name="idm45661473172000"></a><a class="indexterm" name="idm45661473170576"></a><p>
        アプリケーションとデータベースのベンチマークを行い、ボトルネックのある場所を見つけます。 1 つのボトルネックを修正 (または、それを<span class="quote">「<span class="quote">ダミー</span>」</span>モジュールで置換) することによって、次のボトルネックの識別に進むことができます。 現在のアプリケーションの全体的なパフォーマンスが許容できるものであっても、いつか実際にパフォーマンスの強化が必要になった場合に、少なくとも各ボトルネックの計画を立て、解決方法を決定しておくべきです。 
      </p><p>
        無料ベンチマークスイートは、<a class="ulink" href="http://osdb.sourceforge.net/" target="_top">http://osdb.sourceforge.net/</a> で入手可能なオープンソースデータベースベンチマークです。
      </p><p>
        システムの負荷が非常に高い場合にのみ問題が発生することはよくあることです。 (テスト済みの) システムを本稼働させて、負荷の問題が発生したときに、問い合わせてくる顧客が多数いました。 ほとんどの場合、パフォーマンスの問題は、高負荷時のテーブルスキャンの不良などデータベースの基本的な設計の問題か、オペレーティングシステムやライブラリの問題によると判明しています。 ほとんどの場合、システムがまだ本稼働に入っていない場合の方がこれらの問題の修正がはるかに容易です。 
      </p><p>
        このような問題を回避するには、可能性のある最悪の負荷でアプリケーション全体のベンチマークを行います。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            複数のクライアントが同時にクエリーを発行して生成される高い負荷をシミュレートするには、<span class="command"><strong>mysqlslap</strong></span> プログラムが役立つ可能性があります。 <a class="xref" href="programs.html#mysqlslap" title="4.5.8 mysqlslap — ロードエミュレーションクライアント">セクション4.5.8「mysqlslap — ロードエミュレーションクライアント」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            SysBench および DBT2 などのベンチマークパッケージを試してみることもできます。これは、<a class="ulink" href="https://launchpad.net/sysbench" target="_top">https://launchpad.net/sysbench</a> および <a class="ulink" href="http://osdldbt.sourceforge.net/#dbt2" target="_top">http://osdldbt.sourceforge.net/#dbt2</a> で入手できます。
          </p></li></ul></div><p>
        これらのプログラムやパッケージはシステムを破損させる可能性があるため、それらは開発システムでのみ使用するようにしてください。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="monitoring-performance-schema"></a>8.13.3 performance_schema によるパフォーマンスの測定</h3></div></div></div><a class="indexterm" name="idm45661473155328"></a><p>
        <code class="literal">performance_schema</code> データベースのテーブルをクエリーし、それを実行しているサーバーとアプリケーションのパフォーマンス特性に関するリアルタイムの情報を確認できます。 詳細は、<a class="xref" href="performance-schema.html" title="第 27 章 MySQL パフォーマンススキーマ">第27章「<i>MySQL パフォーマンススキーマ</i>」</a>を参照してください。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="thread-information"></a>8.14 サーバースレッド (プロセス) 情報の確認</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#processlist-access">8.14.1 プロセスリストへのアクセス</a></span></dt><dt><span class="section"><a href="optimization.html#thread-commands">8.14.2 スレッドのコマンド値</a></span></dt><dt><span class="section"><a href="optimization.html#general-thread-states">8.14.3 一般的なスレッドの状態</a></span></dt><dt><span class="section"><a href="optimization.html#source-thread-states">8.14.4 レプリケーションソーススレッドの状態</a></span></dt><dt><span class="section"><a href="optimization.html#replica-io-thread-states">8.14.5 レプリケーション I/O スレッドの状態</a></span></dt><dt><span class="section"><a href="optimization.html#replica-sql-thread-states">8.14.6 レプリケーション SQL スレッドの状態</a></span></dt><dt><span class="section"><a href="optimization.html#replica-connection-thread-states">8.14.7 レプリケーション接続スレッドの状態</a></span></dt><dt><span class="section"><a href="optimization.html#mysql-cluster-thread-states">8.14.8 NDB Cluster スレッドの状態</a></span></dt><dt><span class="section"><a href="optimization.html#event-scheduler-thread-states">8.14.9 イベントスケジューラスレッドの状態</a></span></dt></dl></div><a class="indexterm" name="idm45661473149648"></a><a class="indexterm" name="idm45661473147536"></a><a class="indexterm" name="idm45661473145504"></a><a class="indexterm" name="idm45661473143584"></a><p>
      MySQL サーバーの動作を確認するには、サーバー内で実行されているスレッドのセットによって現在実行されている操作を示すプロセスリストを調べると役立ちます。 例: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW PROCESSLIST\G</code></strong>
*************************** 1. row ***************************
     Id: 5
   User: event_scheduler
   Host: localhost
     db: NULL
Command: Daemon
   Time: 2756681
  State: Waiting on empty queue
   Info: NULL
*************************** 2. row ***************************
     Id: 20
   User: me
   Host: localhost:52943
     db: test
Command: Query
   Time: 0
  State: starting
   Info: SHOW PROCESSLIST
</pre><p>
      スレッドは、<code class="literal">KILL</code> ステートメントを使用して強制終了できます。 <a class="xref" href="sql-statements.html#kill" title="13.7.8.4 KILL ステートメント">セクション13.7.8.4「KILL ステートメント」</a>を参照してください。 
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="processlist-access"></a>8.14.1 プロセスリストへのアクセス</h3></div></div></div><p>
        次の説明では、プロセス情報のソース、プロセス情報の表示に必要な特権を列挙し、プロセスリストエントリの内容について説明します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#processlist-sources" title="プロセス情報のソース">プロセス情報のソース</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#processlist-privileges" title="プロセスリストへのアクセスに必要な特権">プロセスリストへのアクセスに必要な特権</a></p></li><li class="listitem"><p><a class="xref" href="optimization.html#processlist-content" title="プロセスリストエントリの内容">プロセスリストエントリの内容</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="processlist-sources"></a>プロセス情報のソース</h4></div></div></div><p>
          プロセス情報は、次のソースから入手できます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">SHOW PROCESSLIST</code> ステートメント: <a class="xref" href="sql-statements.html#show-processlist" title="13.7.7.29 SHOW PROCESSLIST ステートメント">セクション13.7.7.29「SHOW PROCESSLIST ステートメント」</a>
            </p></li><li class="listitem"><p>
              <span class="command"><strong>mysqladmin processlist</strong></span> コマンド: <a class="xref" href="programs.html#mysqladmin" title="4.5.2 mysqladmin — A MySQL Server 管理プログラム">セクション4.5.2「mysqladmin — A MySQL Server 管理プログラム」</a>
            </p></li><li class="listitem"><p>
              <code class="literal">INFORMATION_SCHEMA</code> <code class="literal">PROCESSLIST</code> テーブル: <a class="xref" href="information-schema.html#information-schema-processlist-table" title="26.23 INFORMATION_SCHEMA PROCESSLIST テーブル">セクション26.23「INFORMATION_SCHEMA PROCESSLIST テーブル」</a>
            </p></li><li class="listitem"><p>
              パフォーマンススキーマの <code class="literal">processlist</code> テーブル: <a class="xref" href="performance-schema.html#performance-schema-processlist-table" title="27.12.19.9 processlist テーブル">セクション27.12.19.9「processlist テーブル」</a>
            </p></li><li class="listitem"><p>
              接頭辞が <code class="literal">PROCESSLIST_</code>の名前を持つパフォーマンススキーマ <code class="literal">threads</code> テーブルのカラム: <a class="xref" href="performance-schema.html#performance-schema-threads-table" title="27.12.19.10 スレッドテーブル">セクション27.12.19.10「スレッドテーブル」</a>
            </p></li><li class="listitem"><p>
              <code class="literal">sys</code> スキーマの <code class="literal">processlist</code> ビューおよび <code class="literal">session</code> ビュー: <a class="xref" href="sys-schema.html#sys-processlist" title="28.4.3.22 processlist ビューと x$processlist ビュー">セクション28.4.3.22「processlist ビューと x$processlist ビュー」</a> および <a class="xref" href="sys-schema.html#sys-session" title="28.4.3.33 セッションおよび x$session ビュー">セクション28.4.3.33「セッションおよび x$session ビュー」</a>
            </p></li></ul></div><p>
          <code class="literal">threads</code> テーブルは、<code class="literal">SHOW PROCESSLIST</code>、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">PROCESSLIST</code> および <span class="command"><strong>mysqladmin processlist</strong></span> と次のように比較されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">threads</code> テーブルへのアクセスに mutex は必要なく、サーバーのパフォーマンスへの影響は最小限です。 他のソースには mutex が必要なため、パフォーマンスに悪影響があります。 
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                MySQL 8.0.22 の時点では、<code class="literal">threads</code> テーブルと同様に mutex を必要とせず、より優れたパフォーマンス特性を持つパフォーマンススキーマ <code class="literal">processlist</code> テーブルに基づいて、<code class="literal">SHOW PROCESSLIST</code> の代替実装を使用できます。 詳細は、<a class="xref" href="performance-schema.html#performance-schema-processlist-table" title="27.12.19.9 processlist テーブル">セクション27.12.19.9「processlist テーブル」</a>を参照してください。 
              </p></div></li><li class="listitem"><p>
              <code class="literal">threads</code> テーブルにバックグラウンドスレッドが表示されますが、他のソースには表示されません。 また、スレッドがフォアグラウンドまたはバックグラウンドスレッドであるかどうか、スレッドに関連付けられたサーバー内の場所など、他のソースが実行しない各スレッドの追加情報も提供します。 つまり、<code class="literal">threads</code> テーブルを使用して、他のソースが監視できないスレッドアクティビティを監視できます。 
            </p></li><li class="listitem"><p>
              <a class="xref" href="performance-schema.html#performance-schema-threads-table" title="27.12.19.10 スレッドテーブル">セクション27.12.19.10「スレッドテーブル」</a> で説明されているように、パフォーマンススキーマスレッドのモニタリングを有効または無効にできます。
            </p></li></ul></div><p>
          このような理由から、他のスレッド情報ソースのいずれかを使用してサーバー監視を実行する DBA は、かわりに <code class="literal">threads</code> テーブルを使用して監視できます。
        </p><p>
          <code class="literal">sys</code> スキーマの <code class="literal">processlist</code> ビューには、パフォーマンススキーマの <code class="literal">threads</code> テーブルの情報がよりアクセスしやすい形式で表示されます。 <code class="literal">sys</code> スキーマの <code class="literal">session</code> ビューには、<code class="literal">sys</code> スキーマの <code class="literal">processlist</code> ビューなどのユーザーセッションに関する情報が表示されますが、バックグラウンドプロセスはフィルタで除外されます。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="processlist-privileges"></a>プロセスリストへのアクセスに必要な特権</h4></div></div></div><p>
          ほとんどのプロセス情報のソースでは、<code class="literal">PROCESS</code> 権限を持っている場合、他のユーザーに属するスレッドも含めて、すべてのスレッドを表示できます。 それ以外の場合 (<code class="literal">PROCESS</code> 権限なし)、非匿名ユーザーは自分のスレッドに関する情報にはアクセスできますが、他のユーザーのスレッドにはアクセスできず、匿名ユーザーはスレッド情報にアクセスできません。 
        </p><p>
          パフォーマンススキーマ <code class="literal">threads</code> テーブルはスレッド情報も提供しますが、テーブルアクセスは別の特権モデルを使用します。 <a class="xref" href="performance-schema.html#performance-schema-threads-table" title="27.12.19.10 スレッドテーブル">セクション27.12.19.10「スレッドテーブル」</a>を参照してください。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="processlist-content"></a>プロセスリストエントリの内容</h4></div></div></div><p>
          各プロセスリストエントリには、いくつかの情報が含まれています。 次のリストでは、<code class="literal">SHOW PROCESSLIST</code> 出力のラベルを使用してこれらについて説明します。 その他のプロセス情報ソースでは、同様のラベルが使用されます。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">Id</code> は、スレッドに関連付けられているクライアントの接続識別子です。
            </p></li><li class="listitem"><p>
              <code class="literal">User</code> と <code class="literal">Host</code> は、スレッドに関連付けられているアカウントを示します。
            </p></li><li class="listitem"><p>
              <code class="literal">db</code> はスレッドのデフォルトデータベースで、何も選択されていない場合は <code class="literal">NULL</code> です。
            </p></li><li class="listitem"><p>
              <code class="literal">Command</code> と <code class="literal">State</code> は、スレッドが何を実行しているかを示します。
            </p><p>
              ほとんどの状態がきわめてすばやい操作に対応します。 スレッドの状態が何秒間も特定の状態にとどまっている場合は、調査が必要な問題が発生している可能性があります。 
            </p><p>
              以下のセクションでは、<code class="literal">Command</code> の可能な値と、カテゴリ別にグループ化した <code class="literal">State</code> の値を説明します。 これらの一部の値の意味は自明です。 その他については追加の説明を提供しています。 
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                プロセスリスト情報を検査するアプリケーションは、コマンドと状態が変更される可能性があることに注意する必要があります。
              </p></div></li><li class="listitem"><p>
              <code class="literal">Time</code> は、スレッドの現在の状態がどれだけ続いているかを示します。 特定の場合に、スレッドの現在の時間の概念が変わることがあります。スレッドは、<code class="literal">SET TIMESTAMP = <em class="replaceable"><code>value</code></em></code> によって時間を変更することがあります。 レプリカ SQL スレッドの場合、この値は、最後にレプリケートされたイベントのタイムスタンプとレプリカホストのリアルタイムの間の秒数です。 <a class="xref" href="replication.html#replication-implementation-details" title="17.2.3 レプリケーションスレッド">セクション17.2.3「レプリケーションスレッド」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              <code class="literal">Info</code> は、スレッドが実行しているステートメントを示します。ステートメントを実行していない場合は <code class="literal">NULL</code> を示します。 <code class="literal">SHOW PROCESSLIST</code> の場合、この値にはステートメントの最初の 100 文字のみが含まれます。 完全なステートメントを表示するには、<code class="literal">SHOW FULL PROCESSLIST</code> を使用します (または、異なるプロセス情報ソースをクエリーします)。 
            </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="thread-commands"></a>8.14.2 スレッドのコマンド値</h3></div></div></div><a class="indexterm" name="idm45661473048912"></a><p>
        スレッドの <code class="literal">Command</code> 値は次のいずれかになります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="indexterm" name="idm45661473045552"></a> <a class="indexterm" name="idm45661473043376"></a> <code class="literal">Binlog Dump</code>
          </p><p>
            これは、バイナリログの内容をレプリカに送信するためのレプリケーションソース上のスレッドです。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661473039248"></a> <a class="indexterm" name="idm45661473037072"></a> <code class="literal">Change user</code>
          </p><p>
            スレッドはユーザー変更操作を実行しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661473033088"></a> <a class="indexterm" name="idm45661473030912"></a> <code class="literal">Close stmt</code>
          </p><p>
            スレッドはプリペアドステートメントをクローズしています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661473026880"></a> <a class="indexterm" name="idm45661473024704"></a> <code class="literal">Connect</code>
          </p><p>
            ソースに接続されているレプリケーションレシーバスレッドおよびレプリケーションワーカースレッドによって使用されます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661473020512"></a> <a class="indexterm" name="idm45661473018336"></a> <code class="literal">Connect Out</code>
          </p><p>
            レプリカはソースに接続しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661473014384"></a> <a class="indexterm" name="idm45661473012208"></a> <code class="literal">Create DB</code>
          </p><p>
            スレッドはデータベース作成操作を実行しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661473008208"></a> <a class="indexterm" name="idm45661473006032"></a> <code class="literal">Daemon</code>
          </p><p>
            このスレッドはサーバーの内部で使用され、クライアント接続をホストするスレッドではありません。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661473001904"></a> <a class="indexterm" name="idm45661472999728"></a> <code class="literal">Debug</code>
          </p><p>
            スレッドはデバッグ情報を生成しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472995744"></a> <a class="indexterm" name="idm45661472993568"></a> <code class="literal">Delayed insert</code>
          </p><p>
            スレッドは遅延挿入ハンドラです。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472989616"></a> <a class="indexterm" name="idm45661472987440"></a> <code class="literal">Drop DB</code>
          </p><p>
            スレッドはデータベースの削除操作を実行しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472983440"></a> <a class="indexterm" name="idm45661472981264"></a> <code class="literal">Error</code>
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472977856"></a> <a class="indexterm" name="idm45661472975680"></a> <code class="literal">Execute</code>
          </p><p>
            スレッドはプリペアドステートメントを実行しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472971664"></a> <a class="indexterm" name="idm45661472969488"></a> <code class="literal">Fetch</code>
          </p><p>
            スレッドはプリペアドステートメントの実行から結果をフェッチしています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472965424"></a> <a class="indexterm" name="idm45661472963248"></a> <code class="literal">Field List</code>
          </p><p>
            スレッドはテーブルカラムの情報を取得しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472959248"></a> <a class="indexterm" name="idm45661472957072"></a> <code class="literal">Init DB</code>
          </p><p>
            スレッドはデフォルトのデータベースを選択しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472953056"></a> <a class="indexterm" name="idm45661472950880"></a> <code class="literal">Kill</code>
          </p><p>
            スレッドは別のスレッドを強制終了しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472946896"></a> <a class="indexterm" name="idm45661472944720"></a> <code class="literal">Long Data</code>
          </p><p>
            スレッドはプリペアドステートメントの実行の結果から長いデータを取得しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472940624"></a> <a class="indexterm" name="idm45661472938448"></a> <code class="literal">Ping</code>
          </p><p>
            スレッドはサーバー ping リクエストを処理しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472934448"></a> <a class="indexterm" name="idm45661472932272"></a> <code class="literal">Prepare</code>
          </p><p>
            スレッドはプリペアドステートメントを準備しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472928256"></a> <a class="indexterm" name="idm45661472926080"></a> <code class="literal">Processlist</code>
          </p><p>
            スレッドはサーバースレッドに関する情報を生成しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472922048"></a> <a class="indexterm" name="idm45661472919872"></a> <code class="literal">Query</code>
          </p><p>
            シングルスレッドレプリケーションアプライヤスレッドおよびレプリケーションコーディネータスレッドによるクエリーの実行中に、ユーザークライアントに使用されます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472915552"></a> <a class="indexterm" name="idm45661472913376"></a> <code class="literal">Quit</code>
          </p><p>
            スレッドは終了しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472909440"></a> <a class="indexterm" name="idm45661472907264"></a> <code class="literal">Refresh</code>
          </p><p>
            スレッドは、テーブル、ログ、またはキャッシュをフラッシュしているか、ステータス変数またはレプリケーションサーバーの情報をリセットしています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472902992"></a> <a class="indexterm" name="idm45661472900816"></a> <code class="literal">Register Slave</code>
          </p><p>
            スレッドはレプリカサーバーを登録しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472896832"></a> <a class="indexterm" name="idm45661472894656"></a> <code class="literal">Reset stmt</code>
          </p><p>
            スレッドはプリペアドステートメントをリセットしています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472890624"></a> <a class="indexterm" name="idm45661472888448"></a> <code class="literal">Set option</code>
          </p><p>
            スレッドはクライアントステートメントの実行オプションを設定またはリセットしています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472884336"></a> <a class="indexterm" name="idm45661472882160"></a> <code class="literal">Shutdown</code>
          </p><p>
            スレッドはサーバーをシャットダウンしています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472878160"></a> <a class="indexterm" name="idm45661472875984"></a> <code class="literal">Sleep</code>
          </p><p>
            スレッドはクライアントが新しいステートメントをそれに送信するのを待機しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472871888"></a> <a class="indexterm" name="idm45661472869712"></a> <code class="literal">Statistics</code>
          </p><p>
            スレッドはサーバーステータス情報を生成しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472865712"></a> <a class="indexterm" name="idm45661472863536"></a> <code class="literal">Time</code>
          </p><p>
            使用されません。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="general-thread-states"></a>8.14.3 一般的なスレッドの状態</h3></div></div></div><a class="indexterm" name="idm45661472858688"></a><p>
        次のリストは、レプリケーションなどの特殊なアクティビティーではなく、一般的なクエリーの処理に関連付けられた、スレッドの <code class="literal">State</code> 値を説明しています。 これらの多くは、サーバーのバグを見つけるためにのみ役立ちます。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="indexterm" name="idm45661472854160"></a> <a class="indexterm" name="idm45661472852000"></a> <code class="literal">After create</code>
          </p><p>
            これは、スレッドがテーブル (内部一時テーブルも含む) を作成する際の、テーブルを作成する関数の最後に発生します。 何らかのエラーのためテーブルを作成できなかった場合でも、この状態が使われます。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472847600"></a> <a class="indexterm" name="idm45661472845440"></a> <code class="literal">altering table</code>
          </p><p>
            サーバーはインプレース <code class="literal">ALTER TABLE</code> の実行中です。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472840512"></a> <a class="indexterm" name="idm45661472838352"></a> <code class="literal">Analyzing</code>
          </p><p>
            スレッドは <code class="literal">MyISAM</code> テーブルのキー分布を計算しています (<code class="literal">ANALYZE TABLE</code> などで)。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472832656"></a> <a class="indexterm" name="idm45661472830496"></a> <code class="literal">checking permissions</code>
          </p><p>
            スレッドは、サーバーがステートメントを実行するために必要な権限を持っているかどうかを確認しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472826352"></a> <a class="indexterm" name="idm45661472824192"></a> <code class="literal">Checking table</code>
          </p><p>
            スレッドはテーブルチェック操作を実行しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472820208"></a> <a class="indexterm" name="idm45661472818048"></a> <code class="literal">cleaning up</code>
          </p><p>
            スレッドは 1 つのコマンドを処理し、メモリーの解放と特定の状態変数のリセットを準備しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472813936"></a> <a class="indexterm" name="idm45661472811776"></a> <code class="literal">closing tables</code>
          </p><p>
            スレッドは、変更されたテーブルデータをディスクにフラッシュし、使用されたテーブルをクローズしています。 これは高速の操作であるはずです。 そうでない場合は、ディスクがいっぱいでないか、ディスクが著しく頻繁に使用されていないかを確認してください。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472807360"></a> <a class="indexterm" name="idm45661472805136"></a> <code class="literal">converting HEAP to ondisk</code>
          </p><p>
            スレッドは内部一時テーブルを <code class="literal">MEMORY</code> テーブルからディスク上のテーブルに変換しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472800272"></a> <a class="indexterm" name="idm45661472798112"></a> <code class="literal">copy to tmp table</code>
          </p><p>
            スレッドは <code class="literal">ALTER TABLE</code> ステートメントを処理しています。 この状態は、新しい構造でテーブルが作成されたあと、ただし、それに行がコピーされる前に発生します。 
          </p><p>
            この状態のスレッドの場合、パフォーマンススキーマを使用してコピー操作の進行状況を取得できます。 <a class="xref" href="performance-schema.html#performance-schema-stage-tables" title="27.12.5 パフォーマンススキーマステージイベントテーブル">セクション27.12.5「パフォーマンススキーマステージイベントテーブル」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472791376"></a> <a class="indexterm" name="idm45661472789264"></a> <code class="literal">Copying to group table</code>
          </p><p>
            ステートメントの <code class="literal">ORDER BY</code> と <code class="literal">GROUP BY</code> の基準が異なる場合、行はグループによってソートされ、一時テーブルにコピーされます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472783696"></a> <a class="indexterm" name="idm45661472781536"></a> <code class="literal">Copying to tmp table</code>
          </p><p>
            サーバーはメモリー内の一時テーブルにコピーしています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472777536"></a> <a class="indexterm" name="idm45661472775344"></a> <code class="literal">Copying to tmp table on disk</code>
          </p><p>
            サーバーはディスク上の一時テーブルにコピーしています。 一時結果セットが大きくなりすぎました (<a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4 MySQL での内部一時テーブルの使用">セクション8.4.4「MySQL での内部一時テーブルの使用」</a>を参照してください)。 その結果、スレッドは一時テーブルをインメモリーからディスクベースのフォーマットに変更して、メモリーを節約します。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472770256"></a> <a class="indexterm" name="idm45661472768144"></a> <code class="literal">Creating index</code>
          </p><p>
            スレッドは <code class="literal">MyISAM</code> テーブルに対する <code class="literal">ALTER TABLE ... ENABLE KEYS</code> を処理しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472762736"></a> <a class="indexterm" name="idm45661472760576"></a> <code class="literal">Creating sort index</code>
          </p><p>
            スレッドは内部一時テーブルを使用して解決される <code class="literal">SELECT</code> を処理しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472755568"></a> <a class="indexterm" name="idm45661472753408"></a> <code class="literal">creating table</code>
          </p><p>
            スレッドはテーブルを作成しています。 これには一時テーブルの作成が含まれます。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472749328"></a> <a class="indexterm" name="idm45661472747168"></a> <code class="literal">Creating tmp table</code>
          </p><p>
            スレッドはメモリー内またはディスク上に一時テーブルを作成しています。 テーブルがメモリー内に作成され、後でディスク上のテーブルに変換される場合、その操作中の状態は <code class="literal">Copying to tmp table on disk</code> です。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472742096"></a> <a class="indexterm" name="idm45661472739872"></a> <code class="literal">committing alter table to storage engine</code>
          </p><p>
            サーバーはインプレース <code class="literal">ALTER TABLE</code> を終了し、結果をコミットしています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472734784"></a> <a class="indexterm" name="idm45661472732592"></a> <code class="literal">deleting from main table</code>
          </p><p>
            サーバーは複数テーブル削除の最初の部分を実行しています。 最初のテーブルからのみ削除し、別の (参照) テーブルからの削除に使用されるカラムとオフセットを保存しています。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472728208"></a> <a class="indexterm" name="idm45661472726016"></a> <code class="literal">deleting from reference tables</code>
          </p><p>
            サーバーは複数テーブル削除の 2 番目の部分を実行しており、別のテーブルから一致した行を削除しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472721824"></a> <a class="indexterm" name="idm45661472719632"></a> <code class="literal">discard_or_import_tablespace</code>
          </p><p>
            スレッドは <code class="literal">ALTER TABLE ... DISCARD TABLESPACE</code> または <code class="literal">ALTER TABLE ... IMPORT TABLESPACE</code> ステートメントを処理しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472714144"></a> <a class="indexterm" name="idm45661472712048"></a> <code class="literal">end</code>
          </p><p>
            これは、<code class="literal">ALTER TABLE</code>、<code class="literal">CREATE VIEW</code>、<code class="literal">DELETE</code>、<code class="literal">INSERT</code>、<code class="literal">SELECT</code>、または <code class="literal">UPDATE</code> ステートメントの最後、ただしクリーンアップの前に発生します。
          </p><p>
            <code class="literal">end</code> 状態では、次の操作が行われることがあります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                バイナリログへのイベントの書き込み
              </p></li><li class="listitem"><p>
                BLOB 用を含むメモリーバッファーの解放
              </p></li></ul></div></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472698656"></a> <a class="indexterm" name="idm45661472696496"></a> <code class="literal">executing</code>
          </p><p>
            スレッドはステートメントの実行を開始しました。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472692512"></a> <a class="indexterm" name="idm45661472690320"></a> <code class="literal">Execution of init_command</code>
          </p><p>
            スレッドは <code class="literal">init_command</code> システム変数の値のステートメントを実行しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472685536"></a> <a class="indexterm" name="idm45661472683376"></a> <code class="literal">freeing items</code>
          </p><p>
            スレッドはコマンドを実行しました。 通常、この状態のあとは <code class="literal">cleaning up</code> になります。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472678624"></a> <a class="indexterm" name="idm45661472676464"></a> <code class="literal">FULLTEXT initialization</code>
          </p><p>
            サーバーは自然言語全文検索を実行する準備をしています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472672464"></a> <a class="indexterm" name="idm45661472670304"></a> <code class="literal">init</code>
          </p><p>
            これは、<code class="literal">ALTER TABLE</code>、<code class="literal">DELETE</code>、<code class="literal">INSERT</code>、<code class="literal">SELECT</code>、または <code class="literal">UPDATE</code> ステートメントの初期化の前に発生します。 この状態のサーバーによって実行されるアクションには、バイナリログと <code class="literal">InnoDB</code> ログのフラッシュが含まれます。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472660384"></a> <a class="indexterm" name="idm45661472658224"></a> <code class="literal">Killed</code>
          </p><p>
            だれかがスレッドに <code class="literal">KILL</code> ステートメントを送っており、スレッドは次に強制終了フラグをチェックしたときに中止するはずです。 フラグは MySQL の各主要ループ内でチェックされますが、場合によってはスレッドが停止するまでに少し時間がかかる場合があります。 スレッドがほかのスレッドにロックされている場合、強制終了はほかのスレッドがそのロックを解除するとすぐに有効になります。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472652768"></a> <a class="indexterm" name="idm45661472650576"></a> <code class="literal">Locking system tables</code>
          </p><p>
            スレッドがシステムテーブル (タイムゾーンやログテーブルなど) をロックしようとしています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472646448"></a> <a class="indexterm" name="idm45661472644288"></a> <code class="literal">logging slow query</code>
          </p><p>
            スレッドはステートメントを低速クエリーログに書き込んでいます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472640256"></a> <a class="indexterm" name="idm45661472638096"></a> <code class="literal">login</code>
          </p><p>
            クライアントが正常に認証されるまでの接続スレッドの初期状態です。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472634064"></a> <a class="indexterm" name="idm45661472631904"></a> <code class="literal">manage keys</code>
          </p><p>
            サーバーはテーブルインデックスを有効または無効にしています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472627888"></a> <a class="indexterm" name="idm45661472625696"></a> <code class="literal">Opening system tables</code>
          </p><p>
            スレッドがシステムテーブル (タイムゾーンやログテーブルなど) を開こうとしています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472621584"></a> <a class="indexterm" name="idm45661472619408"></a> <code class="literal">Opening tables</code>
          </p><p>
            スレッドはテーブルをオープンしようと試みています。 これは、何かにオープンを妨げられないかぎり、きわめて高速な手順であるはずです。 たとえば、<code class="literal">ALTER TABLE</code> または <code class="literal">LOCK TABLE</code> ステートメントは、そのステートメントが終了するまでテーブルのオープンを妨げることがあります。 <code class="literal">table_open_cache</code> 値が十分に大きいことをチェックすることも価値があります。 
          </p><p>
            システムテーブルの場合は、かわりに <code class="literal">Opening system tables</code> の状態が使用されます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472610128"></a> <a class="indexterm" name="idm45661472607968"></a> <code class="literal">optimizing</code>
          </p><p>
            サーバーはクエリーの初期最適化を実行しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472603984"></a> <a class="indexterm" name="idm45661472601824"></a> <code class="literal">preparing</code>
          </p><p>
            この状態はクエリーの最適化中に発生します。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472597856"></a> <a class="indexterm" name="idm45661472595696"></a> <code class="literal">Purging old relay logs</code>
          </p><p>
            スレッドは不要なリレーログファイルを削除しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472591696"></a> <a class="indexterm" name="idm45661472589536"></a> <code class="literal">query end</code>
          </p><p>
            この状態は、クエリーを処理したあと、ただし <code class="literal">freeing items</code> 状態の前に発生します。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472584784"></a> <a class="indexterm" name="idm45661472582592"></a> <code class="literal">Receiving from client</code>
          </p><p>
            サーバーはクライアントからパケットを読み取っています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472578560"></a> <a class="indexterm" name="idm45661472576400"></a> <code class="literal">Removing duplicates</code>
          </p><p>
            クエリーは、MySQL が早い段階で個別の操作を最適化できなくなるような方法で <code class="literal">SELECT DISTINCT</code> を使用していました。 このため、MySQL は結果をクライアントに送る前にすべての重複した行を削除するための追加の段階を必要とします。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472570720"></a> <a class="indexterm" name="idm45661472568560"></a> <code class="literal">removing tmp table</code>
          </p><p>
            スレッドは <code class="literal">SELECT</code> ステートメントを処理したあとに内部一時テーブルを削除しています。 一時テーブルが作成されなかった場合、この状態は使用されません。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472563328"></a> <a class="indexterm" name="idm45661472561168"></a> <code class="literal">rename</code>
          </p><p>
            スレッドはテーブルの名前を変更しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472557200"></a> <a class="indexterm" name="idm45661472555040"></a> <code class="literal">rename result table</code>
          </p><p>
            スレッドは <code class="literal">ALTER TABLE</code> ステートメントを処理しており、新しいテーブルを作成し、元のテーブルを置き換えるためにその名前を変更しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472549856"></a> <a class="indexterm" name="idm45661472547696"></a> <code class="literal">Reopen tables</code>
          </p><p>
            スレッドはテーブルのロックを取得しましたが、ロックの取得後、基盤となるテーブル構造が変更されたことを認識しました。 それはロックを解除し、テーブルをクローズして、再度オープンしようとしています。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472543280"></a> <a class="indexterm" name="idm45661472541120"></a> <code class="literal">Repair by sorting</code>
          </p><p>
            修復コードはインデックスを作成するためにソートを使用しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472537088"></a> <a class="indexterm" name="idm45661472534896"></a> <code class="literal">preparing for alter table</code>
          </p><p>
            サーバーはインプレース <code class="literal">ALTER TABLE</code> の実行を準備しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472529888"></a> <a class="indexterm" name="idm45661472527728"></a> <code class="literal">Repair done</code>
          </p><p>
            スレッドは <code class="literal">MyISAM</code> テーブルのマルチスレッド修復を完了しました。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472523008"></a> <a class="indexterm" name="idm45661472520848"></a> <code class="literal">Repair with keycache</code>
          </p><p>
            修復コードはキーキャッシュ経由で、1 つずつキーの作成を使用しています。 これは <code class="literal">Repair by sorting</code> よりはるかに遅くなります。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472515984"></a> <a class="indexterm" name="idm45661472513824"></a> <code class="literal">Rolling back</code>
          </p><p>
            スレッドはトランザクションをロールバックしています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472509824"></a> <a class="indexterm" name="idm45661472507664"></a> <code class="literal">Saving state</code>
          </p><p>
            <code class="literal">MyISAM</code> テーブルの修復や分析などの操作で、スレッドは新しいテーブルの状態を <code class="filename">.MYI</code> ファイルヘッダーに保存しています。 状態には、行の数、<code class="literal">AUTO_INCREMENT</code> カウンタ、キー分布などの情報が含まれています。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472501248"></a> <a class="indexterm" name="idm45661472499056"></a> <code class="literal">Searching rows for update</code>
          </p><p>
            スレッドは、すべての一致する行を更新する前に、それらを見つけるための第 1 フェーズを実行しています。 これは、<code class="literal">UPDATE</code> が、関連する行を見つけるために使用されるインデックスを変更している場合に、実行される必要があります。 
          </p></li><li class="listitem"><p>
            <code class="literal">Sending data</code>
          </p><p>
            スレッドは <code class="literal">SELECT</code> ステートメントの行を読み取り、処理して、データをクライアントに送信しています。 この状態で行われる操作は、大量のディスクアクセス (読み取り) を実行する傾向があるため、特定のクエリーの存続期間にわたる最長時間実行状態になることがあります。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472490064"></a> <a class="indexterm" name="idm45661472487856"></a> <code class="literal">Sending to client</code>
          </p><p>
            サーバーがクライアントにパケットを書き込んでいます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472483808"></a> <a class="indexterm" name="idm45661472481648"></a> <code class="literal">setup</code>
          </p><p>
            スレッドは <code class="literal">ALTER TABLE</code> 操作を開始しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472476720"></a> <a class="indexterm" name="idm45661472474560"></a> <code class="literal">Sorting for group</code>
          </p><p>
            スレッドは <code class="literal">GROUP BY</code> を満たすためにソートを実行しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472469856"></a> <a class="indexterm" name="idm45661472467696"></a> <code class="literal">Sorting for order</code>
          </p><p>
            スレッドは <code class="literal">ORDER BY</code> を満たすためにソートを実行しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472462992"></a> <a class="indexterm" name="idm45661472460832"></a> <code class="literal">Sorting index</code>
          </p><p>
            スレッドは <code class="literal">MyISAM</code> テーブルの最適化操作中に、より効率的なアクセスのためにインデックスページをソートしています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472455968"></a> <a class="indexterm" name="idm45661472453808"></a> <code class="literal">Sorting result</code>
          </p><p>
            <code class="literal">SELECT</code> ステートメントの場合、これは <code class="literal">Creating sort index</code> と似ていますが、非一時テーブルに対するものです。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472448080"></a> <a class="indexterm" name="idm45661472445920"></a> <code class="literal">starting</code>
          </p><p>
            ステートメントの実行開始時の最初のステージ。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472441952"></a> <a class="indexterm" name="idm45661472439792"></a> <code class="literal">statistics</code>
          </p><p>
            サーバーはクエリー実行プランを開発するための統計を計算しています。 スレッドが長期間この状態にある場合、サーバーはディスクに依存してほかの作業を実行している可能性があります。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472435424"></a> <a class="indexterm" name="idm45661472433968"></a> <a class="indexterm" name="idm45661472431936"></a> <a class="indexterm" name="idm45661472429888"></a> <code class="literal">System lock</code>
          </p><p>
            スレッドが <code class="literal">mysql_lock_tables()</code> を呼び出しましたが、以降スレッドの状態は更新されていません。 これは、多くの理由で発生する可能性がある非常に一般的な状態です。 
          </p><p>
            たとえば、スレッドがリクエストしようとしているか、テーブルの内部または外部システムロックを待機しています。 これは、<code class="literal">InnoDB</code> が <code class="literal">LOCK TABLES</code> の実行中にテーブルレベルのロックを待機している場合に発生することがあります。 この状態が外部ロックへのリクエストによって発生しており、同じ <code class="literal">MyISAM</code> テーブルにアクセスしている複数の <span class="command"><strong>mysqld</strong></span> サーバーを使用していない場合、<code class="option">--skip-external-locking</code> オプションによって外部システムロックを無効にできます。 ただし、外部ロックはデフォルトで無効になっているため、このオプションは無効になっている可能性があります。 <code class="literal">SHOW PROFILE</code> の場合、この状態はスレッドがロックをリクエストしている (待機しているのではなく) ことを意味します。 
          </p><p>
            システムテーブルの場合は、かわりに <code class="literal">Locking system tables</code> の状態が使用されます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472415888"></a> <a class="indexterm" name="idm45661472413728"></a> <code class="literal">update</code>
          </p><p>
            スレッドはテーブルの更新を開始する準備ができています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472409728"></a> <a class="indexterm" name="idm45661472407568"></a> <code class="literal">Updating</code>
          </p><p>
            スレッドは更新する行を探していて、それらを更新しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472403552"></a> <a class="indexterm" name="idm45661472401392"></a> <code class="literal">updating main table</code>
          </p><p>
            サーバーは複数テーブル更新の最初の部分を実行しています。 最初のテーブルのみを更新しており、別の (参照) テーブルの更新に利用されるカラムとオフセットを保存しています。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472397056"></a> <a class="indexterm" name="idm45661472394864"></a> <code class="literal">updating reference tables</code>
          </p><p>
            サーバーは複数テーブル更新の 2 番目の部分を実行しており、ほかのテーブルから一致した行を更新しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472390672"></a> <a class="indexterm" name="idm45661472388512"></a> <code class="literal">User lock</code>
          </p><p>
            スレッドは <code class="literal">GET_LOCK()</code> 呼び出しによってリクエストされたアドバイザリロックを、リクエストしようとしているか待機しています。 <code class="literal">SHOW PROFILE</code> の場合、この状態はスレッドがロックをリクエストしている (待機しているのではなく) ことを意味します。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472382080"></a> <a class="indexterm" name="idm45661472379920"></a> <code class="literal">User sleep</code>
          </p><p>
            スレッドは <code class="literal">SLEEP()</code> 呼び出しを呼び出しました。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472374992"></a> <a class="indexterm" name="idm45661472372832"></a> <code class="literal">Waiting for commit lock</code>
          </p><p>
            <code class="literal">FLUSH TABLES WITH READ LOCK</code> はコミットロックを待機しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472367936"></a> <a class="indexterm" name="idm45661472365728"></a> <code class="literal">waiting for handler commit</code>
          </p><p>
            スレッドは、クエリー処理の他の部分に対するトランザクションのコミットを待機しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472361568"></a> <a class="indexterm" name="idm45661472359376"></a> <code class="literal">Waiting for tables</code>
          </p><p>
            スレッドは、テーブルの基盤となる構造が変更され、その新しい構造を得るためにテーブルを再度オープンする必要があるという通知を受け取りました。 ただし、テーブルを再度オープンするには、ほかのすべてのスレッドが問題のテーブルをクローズするまで待機する必要があります。 
          </p><p>
            この通知は、別のスレッドが <code class="literal">FLUSH TABLES</code> か、問題のテーブルに次のステートメントのいずれかを使用した場合に、この通知が行われます: <code class="literal">FLUSH TABLES <em class="replaceable"><code>tbl_name</code></em></code>、<code class="literal">ALTER TABLE</code>、<code class="literal">RENAME TABLE</code>、<code class="literal">REPAIR TABLE</code>、<code class="literal">ANALYZE TABLE</code>、または <code class="literal">OPTIMIZE TABLE</code>。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472347200"></a> <a class="indexterm" name="idm45661472344992"></a> <code class="literal">Waiting for table flush</code>
          </p><p>
            スレッドは <code class="literal">FLUSH TABLES</code> を実行しており、すべてのスレッドがテーブルを閉じるのを待機しているか、テーブルの基礎となる構造が変更されたため、新しい構造を取得するにはテーブルを再度開く必要があるという通知をスレッドが受け取りました。 ただし、テーブルを再度オープンするには、ほかのすべてのスレッドが問題のテーブルをクローズするまで待機する必要があります。 
          </p><p>
            この通知は、別のスレッドが <code class="literal">FLUSH TABLES</code> か、問題のテーブルに次のステートメントのいずれかを使用した場合に、この通知が行われます: <code class="literal">FLUSH TABLES <em class="replaceable"><code>tbl_name</code></em></code>、<code class="literal">ALTER TABLE</code>、<code class="literal">RENAME TABLE</code>、<code class="literal">REPAIR TABLE</code>、<code class="literal">ANALYZE TABLE</code>、または <code class="literal">OPTIMIZE TABLE</code>。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472331776"></a> <a class="indexterm" name="idm45661472329584"></a> <a class="indexterm" name="idm45661472327504"></a> <a class="indexterm" name="idm45661472325536"></a> <a class="indexterm" name="idm45661472323344"></a> <a class="indexterm" name="idm45661472321376"></a> <a class="indexterm" name="idm45661472319152"></a> <a class="indexterm" name="idm45661472317152"></a> <a class="indexterm" name="idm45661472314928"></a> <a class="indexterm" name="idm45661472312928"></a> <a class="indexterm" name="idm45661472310736"></a> <a class="indexterm" name="idm45661472308768"></a> <a class="indexterm" name="idm45661472306576"></a> <a class="indexterm" name="idm45661472304608"></a> <a class="indexterm" name="idm45661472302416"></a> <code class="literal">Waiting for <em class="replaceable"><code>lock_type</code></em> lock</code>
          </p><p>
            サーバーは、メタデータロックサブシステムからの <code class="literal">THR_LOCK</code> ロックまたはロックの取得を待機しています (<em class="replaceable"><code>lock_type</code></em> はロックのタイプを示します)。
          </p><p>
            この状態は、<code class="literal">THR_LOCK</code> の待機を示します:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">Waiting for table level lock</code>
              </p></li></ul></div><p>
            次の状態は、メタデータロックの待機を示します:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">Waiting for event metadata lock</code>
              </p></li><li class="listitem"><p>
                <code class="literal">Waiting for global read lock</code>
              </p></li><li class="listitem"><p>
                <code class="literal">Waiting for schema metadata lock</code>
              </p></li><li class="listitem"><p>
                <code class="literal">Waiting for stored function metadata lock</code>
              </p></li><li class="listitem"><p>
                <code class="literal">Waiting for stored procedure metadata lock</code>
              </p></li><li class="listitem"><p>
                <code class="literal">Waiting for table metadata lock</code>
              </p></li><li class="listitem"><p>
                <code class="literal">Waiting for trigger metadata lock</code>
              </p></li></ul></div><p>
            テーブルロックインジケータの詳細は、<a class="xref" href="optimization.html#internal-locking" title="8.11.1 内部ロック方法">セクション8.11.1「内部ロック方法」</a> を参照してください。 メタデータのロックの詳細は、<a class="xref" href="optimization.html#metadata-locking" title="8.11.4 メタデータのロック">セクション8.11.4「メタデータのロック」</a> を参照してください。 ロック要求をブロックしているロックを確認するには、<a class="xref" href="performance-schema.html#performance-schema-lock-tables" title="27.12.13 パフォーマンススキーマロックテーブル">セクション27.12.13「パフォーマンススキーマロックテーブル」</a> で説明されているパフォーマンススキーマロックテーブルを使用します。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472278928"></a> <a class="indexterm" name="idm45661472276816"></a> <code class="literal">Waiting on cond</code>
          </p><p>
            スレッドが条件が true になるのを待機している一般的な状態です。 特定の状態情報は使用できません。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472272688"></a> <a class="indexterm" name="idm45661472270528"></a> <code class="literal">Writing to net</code>
          </p><p>
            サーバーはネットワークにパケットを書き込んでいます。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="source-thread-states"></a>8.14.4 レプリケーションソーススレッドの状態</h3></div></div></div><a class="indexterm" name="idm45661472265568"></a><a class="indexterm" name="idm45661472263408"></a><p>
        次のリストは、レプリケーションソースの <code class="literal">Binlog Dump</code> スレッドの <code class="literal">State</code> カラムに表示される可能性のあるもっとも一般的な状態を示しています。 ソースに <code class="literal">Binlog Dump</code> スレッドが表示されない場合は、レプリケーションが実行されていない (つまり、現在接続されているレプリカがない) ことを意味します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="indexterm" name="idm45661472257376"></a> <a class="indexterm" name="idm45661472255152"></a> <code class="literal">Finished reading one binlog; switching to next binlog</code>
          </p><p>
            スレッドはバイナリログファイルの読み取りを終了し、次にレプリカに送信するファイルを開いています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472250928"></a> <a class="indexterm" name="idm45661472248336"></a> <code class="literal">Master has sent all binlog to slave; waiting for more updates</code>
          </p><p>
            スレッドはバイナリログから残りのすべての更新を読み取り、それらをレプリカに送信しました。 スレッドはアイドル状態になり、ソースで新しい更新が発生した結果として新しいイベントがバイナリログに表示されるのを待機しています。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472243440"></a> <a class="indexterm" name="idm45661472241248"></a> <code class="literal">Sending binlog event to slave</code>
          </p><p>
            バイナリログは<span class="emphasis"><em>イベント</em></span>で構成され、そこではイベントが通常更新と何らかのその他の情報が追加されたものになります。 スレッドはバイナリログからイベントを読み取り、レプリカに送信しています。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472236656"></a> <a class="indexterm" name="idm45661472234464"></a> <code class="literal">Waiting to finalize termination</code>
          </p><p>
            スレッド停止中に発生するきわめて短い状態。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replica-io-thread-states"></a>8.14.5 レプリケーション I/O スレッドの状態</h3></div></div></div><a class="indexterm" name="idm45661472229440"></a><a class="indexterm" name="idm45661472227296"></a><p>
        次のリストに、レプリカサーバー上のレプリケーション I/O スレッドの <code class="literal">State</code> カラムに表示される最も一般的な状態を示します。 この状態は、<code class="literal">SHOW REPLICA | SLAVE STATUS</code> によって表示される <code class="literal">Replica_IO_State</code> カラムにも表示されるため、そのステートメントを使用して何が起こっているかを適切に把握できます。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="indexterm" name="idm45661472220736"></a> <a class="indexterm" name="idm45661472218576"></a> <code class="literal">Checking master version</code>
          </p><p>
            ソースへの接続が確立された後、非常に短い状態になります。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472214560"></a> <a class="indexterm" name="idm45661472212400"></a> <code class="literal">Connecting to master</code>
          </p><p>
            スレッドはソースに接続しようとしています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472208432"></a> <a class="indexterm" name="idm45661472206240"></a> <code class="literal">Queueing master event to the relay log</code>
          </p><p>
            スレッドはイベントを読み取っており、SQL スレッドがそれを処理できるように、それをリレーログにコピーしています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472202032"></a> <a class="indexterm" name="idm45661472199808"></a> <code class="literal">Reconnecting after a failed binlog dump request</code>
          </p><p>
            スレッドはソースに再接続しようとしています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472195744"></a> <a class="indexterm" name="idm45661472193520"></a> <code class="literal">Reconnecting after a failed master event read</code>
          </p><p>
            スレッドはソースに再接続しようとしています。 ふたたび接続が確立されると、状態は <code class="literal">Waiting for master to send event</code> になります。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472188576"></a> <a class="indexterm" name="idm45661472186384"></a> <code class="literal">Registering slave on master</code>
          </p><p>
            ソースへの接続が確立された後に非常に短時間発生する状態。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472182320"></a> <a class="indexterm" name="idm45661472180160"></a> <code class="literal">Requesting binlog dump</code>
          </p><p>
            ソースへの接続が確立された後、非常に短い状態になります。 スレッドは、要求されたバイナリログファイルの名前と位置から開始して、バイナリログの内容に対する要求をソースに送信します。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472175792"></a> <a class="indexterm" name="idm45661472173568"></a> <code class="literal">Waiting for its turn to commit</code>
          </p><p>
            <code class="literal">slave_preserve_commit_order</code> が有効な場合に、レプリカスレッドが古いワーカースレッドのコミットを待機しているときに発生する状態。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472168400"></a> <a class="indexterm" name="idm45661472166208"></a> <code class="literal">Waiting for master to send event</code>
          </p><p>
            スレッドはソースに接続し、バイナリログイベントの到着を待機しています。 これは、ソースがアイドル状態の場合に長時間持続することがあります。 待機が <code class="literal">slave_net_timeout</code> 秒継続した場合、タイムアウトになります。 その時点で、スレッドは接続が切断されているとみなし、再接続を試みます。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472160576"></a> <a class="indexterm" name="idm45661472158384"></a> <code class="literal">Waiting for master update</code>
          </p><p>
            <code class="literal">Connecting to master</code> の前の初期状態。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472153776"></a> <a class="indexterm" name="idm45661472151584"></a> <code class="literal">Waiting for slave mutex on exit</code>
          </p><p>
            スレッドの停止中に一時的に発生する状態。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472147568"></a> <a class="indexterm" name="idm45661472145312"></a> <code class="literal">Waiting for the slave SQL thread to free enough relay log space</code>
          </p><p>
            0 以外の <code class="literal">relay_log_space_limit</code> 値を使用しており、リレーログの組み合わせたサイズがこの値を超えるまで拡大しています。 I/O スレッドは、一部のリレーログファイルを削除できるように、リレーログ内容を処理することによって SQL スレッドが十分な領域を解放するまで、待機しています。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472139744"></a> <a class="indexterm" name="idm45661472137520"></a> <code class="literal">Waiting to reconnect after a failed binlog dump request</code>
          </p><p>
            切断のため、バイナリログダンプリクエストに失敗した場合、スレッドはスリープ中にこの状態になり、定期的に再接続を試みます。 再試行間隔は、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23 の場合) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 の場合) を使用して指定できます。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472130928"></a> <a class="indexterm" name="idm45661472128704"></a> <code class="literal">Waiting to reconnect after a failed master event read</code>
          </p><p>
            切断のため、読み取り中にエラーが発生しました。 スレッドは、再接続を試行する前に、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23 の場合) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 の場合) で設定された秒数 (デフォルトは 60) スリープしています。 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replica-sql-thread-states"></a>8.14.6 レプリケーション SQL スレッドの状態</h3></div></div></div><a class="indexterm" name="idm45661472121184"></a><a class="indexterm" name="idm45661472119040"></a><p>
        次のリストは、レプリカサーバー上のレプリケーション SQL スレッドの <code class="literal">State</code> カラムに表示される可能性のある最も一般的な状態を示しています:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="indexterm" name="idm45661472114800"></a> <a class="indexterm" name="idm45661472112544"></a> <code class="literal">Making temporary file (append) before replaying LOAD DATA INFILE</code>
          </p><p>
            スレッドは <code class="literal">LOAD DATA</code> ステートメントを実行しており、レプリカが行を読み取るデータを含む一時ファイルにデータを追加しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472107232"></a> <a class="indexterm" name="idm45661472104976"></a> <code class="literal">Making temporary file (create) before replaying LOAD DATA INFILE</code>
          </p><p>
            スレッドは <code class="literal">LOAD DATA</code> ステートメントを実行し、レプリカが行を読み取るデータを含む一時ファイルを作成しています。 この状態は、元の <code class="literal">LOAD DATA</code> ステートメントが、MySQL 5.0.3 より前のバージョンの MySQL を実行しているソースによってログに記録された場合にのみ発生します。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472098320"></a> <a class="indexterm" name="idm45661472096128"></a> <code class="literal">Reading event from the relay log</code>
          </p><p>
            スレッドはイベントを処理できるように、イベントをリレーログから読み取りました。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472092000"></a> <a class="indexterm" name="idm45661472089776"></a> <code class="literal">Slave has read all relay log; waiting for more updates</code>
          </p><p>
            スレッドはリレーログファイル内のすべてのイベントを処理しており、現在 I/O スレッドが新しいイベントをリレーログに書き込むのを待機しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472085424"></a> <a class="indexterm" name="idm45661472083184"></a> <code class="literal">Waiting for an event from Coordinator</code>
          </p><p>
            マルチスレッドレプリカ (<code class="literal">slave_parallel_workers</code> が 1 より大きい) を使用して、レプリカワーカースレッドのいずれかがコーディネータスレッドからのイベントを待機しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472077840"></a> <a class="indexterm" name="idm45661472075648"></a> <code class="literal">Waiting for slave mutex on exit</code>
          </p><p>
            スレッド停止中に発生するきわめて短い状態。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472071632"></a> <a class="indexterm" name="idm45661472069104"></a> <code class="literal">Waiting for Slave Workers to free pending events</code>
          </p><p>
            この待機処理は、ワーカーが処理しているイベントの合計サイズが <code class="literal">slave_pending_jobs_size_max</code> システム変数のサイズを超えた場合に発生します。 サイズがこの制限を下回ると、コーディネータはスケジューリングを再開します。 この状態は、<code class="literal">slave_parallel_workers</code> が 0 より大きい値に設定されている場合にのみ発生します。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472062144"></a> <a class="indexterm" name="idm45661472059952"></a> <code class="literal">Waiting for the next event in relay log</code>
          </p><p>
            <code class="literal">Reading event from the relay log</code> の前の初期状態です。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472055328"></a> <a class="indexterm" name="idm45661472053072"></a> <code class="literal">Waiting until MASTER_DELAY seconds after master executed event</code>
          </p><p>
            SQL スレッドはイベントを読み取りましたが、レプリカ遅延の経過を待機しています。 この遅延は、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23 の場合) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 の場合) の <code class="literal">SOURCE_DELAY</code> | <code class="literal">MASTER_DELAY</code> オプションを使用して設定します。 
          </p></li></ul></div><p>
        SQL スレッドの <code class="literal">Info</code> カラムには、ステートメントのテキストも表示される場合があります。 これは、スレッドがリレーログからイベントを読み取り、それからステートメントを抽出して、それを実行している可能性があることを示しています。 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replica-connection-thread-states"></a>8.14.7 レプリケーション接続スレッドの状態</h3></div></div></div><a class="indexterm" name="idm45661472042416"></a><a class="indexterm" name="idm45661472040272"></a><p>
        これらのスレッドの状態はレプリカサーバーで発生しますが、I/O または SQL スレッドではなく接続スレッドに関連付けられています。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="indexterm" name="idm45661472035904"></a> <a class="indexterm" name="idm45661472033744"></a> <code class="literal">Changing master</code>
          </p><p>
            スレッドは、(MySQL 8.0.23 の) <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントまたは (MySQL 8.0.23 の前の) <code class="literal">CHANGE MASTER TO</code> ステートメントを処理しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472027648"></a> <a class="indexterm" name="idm45661472025488"></a> <code class="literal">Killing slave</code>
          </p><p>
            スレッドは <code class="literal">STOP REPLICA | SLAVE</code> ステートメントを処理しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472020528"></a> <a class="indexterm" name="idm45661472018336"></a> <code class="literal">Opening master dump table</code>
          </p><p>
            この状態は <code class="literal">Creating table from master dump</code> のあとに発生します。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472013632"></a> <a class="indexterm" name="idm45661472011440"></a> <code class="literal">Reading master dump table data</code>
          </p><p>
            この状態は <code class="literal">Opening master dump table</code> のあとに発生します。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661472006736"></a> <a class="indexterm" name="idm45661472004512"></a> <code class="literal">Rebuilding the index on master dump table</code>
          </p><p>
            この状態は <code class="literal">Reading master dump table data</code> のあとに発生します。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="mysql-cluster-thread-states"></a>8.14.8 NDB Cluster スレッドの状態</h3></div></div></div><a class="indexterm" name="idm45661471998800"></a><a class="indexterm" name="idm45661471996800"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="indexterm" name="idm45661471993200"></a> <a class="indexterm" name="idm45661471991008"></a> <code class="literal">Committing events to binlog</code>
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661471987568"></a> <a class="indexterm" name="idm45661471985376"></a> <code class="literal">Opening mysql.ndb_apply_status</code>
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661471981936"></a> <a class="indexterm" name="idm45661471979776"></a> <code class="literal">Processing events</code>
          </p><p>
            スレッドはバイナリロギングのイベントを処理しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661471975776"></a> <a class="indexterm" name="idm45661471973584"></a> <code class="literal">Processing events from schema table</code>
          </p><p>
            スレッドはスキーマレプリケーションの作業を実行しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661471969520"></a> <a class="indexterm" name="idm45661471967360"></a> <code class="literal">Shutting down</code>
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661471963968"></a> <a class="indexterm" name="idm45661471961744"></a> <code class="literal">Syncing ndb table schema operation and binlog</code>
          </p><p>
            これは、NDB のスキーマ操作の正しいバイナリログを維持するために使用されます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661471957584"></a> <a class="indexterm" name="idm45661471955328"></a> <code class="literal">Waiting for allowed to take ndbcluster global schema lock</code>
          </p><p>
            スレッドはグローバルスキーマロックを取得する権限を待機しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661471951152"></a> <a class="indexterm" name="idm45661471948960"></a> <code class="literal">Waiting for event from ndbcluster</code>
          </p><p>
            サーバーは NDB Cluster で SQL ノードとして機能し、クラスタ管理ノードに接続されています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661471944832"></a> <a class="indexterm" name="idm45661471942640"></a> <code class="literal">Waiting for first event from ndbcluster</code>
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661471939200"></a> <a class="indexterm" name="idm45661471936944"></a> <code class="literal">Waiting for ndbcluster binlog update to reach current position</code>
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661471933408"></a> <a class="indexterm" name="idm45661471931184"></a> <code class="literal">Waiting for ndbcluster global schema lock</code>
          </p><p>
            スレッドは、別のスレッドによって保持されているグローバルスキーマロックが解放されるのを待機しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661471926944"></a> <a class="indexterm" name="idm45661471924752"></a> <code class="literal">Waiting for ndbcluster to start</code>
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661471921312"></a> <a class="indexterm" name="idm45661471919120"></a> <code class="literal">Waiting for schema epoch</code>
          </p><p>
            スレッドはスキーマエポック (つまり、グローバルチェックポイント) を待機しています。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="event-scheduler-thread-states"></a>8.14.9 イベントスケジューラスレッドの状態</h3></div></div></div><a class="indexterm" name="idm45661471914048"></a><a class="indexterm" name="idm45661471911904"></a><p>
        これらの状態は、イベントスケジューラスレッド、スケジュールされたイベントを実行するために作成されるスレッド、またはスケジューラを終了するスレッドで発生します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="indexterm" name="idm45661471908144"></a> <a class="indexterm" name="idm45661471906096"></a> <code class="literal">Clearing</code>
          </p><p>
            スケジューラスレッドまたはイベントを実行していたスレッドは終了中で、まもなく終了します。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661471901984"></a> <a class="indexterm" name="idm45661471899824"></a> <code class="literal">Initialized</code>
          </p><p>
            スケジューラスレッドまたはイベントを実行するスレッドが初期化されました。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661471895760"></a> <a class="indexterm" name="idm45661471893568"></a> <code class="literal">Waiting for next activation</code>
          </p><p>
            スケジューラには空でないイベントキューがありますが、次のアクティブ化はあとで行われます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661471889408"></a> <a class="indexterm" name="idm45661471887216"></a> <code class="literal">Waiting for scheduler to stop</code>
          </p><p>
            スレッドは <code class="literal">SET GLOBAL event_scheduler=OFF</code> を発行し、スケジューラが停止するのを待機しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45661471882416"></a> <a class="indexterm" name="idm45661471880256"></a> <code class="literal">Waiting on empty queue</code>
          </p><p>
            スケジューラのイベントキューは空で、スリープ中です。
          </p></li></ul></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="backup-and-recovery.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="language-structure.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第 7 章 バックアップとリカバリ </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第 9 章 言語構造</td></tr></table></div><div class="copyright-footer"></div></body></html>
