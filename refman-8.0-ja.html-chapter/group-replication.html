<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第 18 章 グループレプリケーション</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="MySQL 8.0 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 8.0 リファレンスマニュアル"><link rel="prev" href="replication.html" title="第 17 章 レプリケーション"><link rel="next" href="mysql-shell-userguide.html" title="第 19 章 MySQL Shell"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 18 章 グループレプリケーション</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="replication.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="mysql-shell-userguide.html">次へ</a></td></tr></table><hr></div><div class="status-header"><p class="alert">このページは機械翻訳したものです。</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="group-replication"></a>第 18 章 グループレプリケーション</h1></div></div></div><div class="toc"><p><b>目次</b></p><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-background">18.1 グループレプリケーションのバックグラウンド</a></span></dt><dd><dl><dt><span class="section"><a href="group-replication.html#group-replication-replication-technologies">18.1.1 レプリケーションテクノロジ</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-use-cases">18.1.2 グループレプリケーションのユースケース</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-deploying-in-multi-primary-or-single-primary-mode">18.1.3 マルチプライマリモードとシングルプライマリモード</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-details">18.1.4 グループレプリケーションサービス</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-plugin-architecture">18.1.5 グループレプリケーションプラグインのアーキテクチャ</a></span></dt></dl></dd><dt><span class="section"><a href="group-replication.html#group-replication-getting-started">18.2 はじめに</a></span></dt><dd><dl><dt><span class="section"><a href="group-replication.html#group-replication-deploying-in-single-primary-mode">18.2.1 単一プライマリモードでのグループレプリケーションのデプロイ</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-deploying-locally">18.2.2 グループレプリケーションのローカルでのデプロイ</a></span></dt></dl></dd><dt><span class="section"><a href="group-replication.html#group-replication-monitoring">18.3 グループレプリケーションの監視</a></span></dt><dd><dl><dt><span class="section"><a href="group-replication.html#group-replication-server-states">18.3.1 グループレプリケーションサーバーの状態</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-replication-group-members">18.3.2 replication_group_members テーブル</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-replication-group-member-stats">18.3.3 replication_group_member_stats テーブル</a></span></dt></dl></dd><dt><span class="section"><a href="group-replication.html#group-replication-operations">18.4 グループレプリケーション操作</a></span></dt><dd><dl><dt><span class="section"><a href="group-replication.html#group-replication-configuring-online-group">18.4.1 オンライングループの構成</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-consistency-guarantees">18.4.2 トランザクション一貫性保証</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-distributed-recovery">18.4.3 分散リカバリ</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-network-partitioning">18.4.4 ネットワークパーティション化</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-ipv6">18.4.5 IPv6 および IPv6 と IPv4 の混合グループのサポート</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-enterprise-backup">18.4.6 グループレプリケーションでの MySQL Enterprise Backup の使用</a></span></dt></dl></dd><dt><span class="section"><a href="group-replication.html#group-replication-security">18.5 グループレプリケーションセキュリティ</a></span></dt><dd><dl><dt><span class="section"><a href="group-replication.html#group-replication-ip-address-permissions">18.5.1 グループレプリケーション IP アドレスの権限</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-secure-socket-layer-support-ssl">18.5.2 Secure Socket Layer (SSL) を使用したグループ通信接続の保護</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-distributed-recovery-securing">18.5.3 分散リカバリ接続の保護</a></span></dt></dl></dd><dt><span class="section"><a href="group-replication.html#group-replication-performance">18.6 グループレプリケーションのパフォーマンス</a></span></dt><dd><dl><dt><span class="section"><a href="group-replication.html#group-replication-fine-tuning-the-group-communication-thread">18.6.1 グループ通信スレッドの微調整</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-flow-control">18.6.2 フロー制御</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-message-compression">18.6.3 メッセージ圧縮</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-performance-message-fragmentation">18.6.4 メッセージの断片化</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-performance-xcom-cache">18.6.5 XCom キャッシュ管理</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-responses-failure">18.6.6 障害検出およびネットワークパーティション化へのレスポンス</a></span></dt></dl></dd><dt><span class="section"><a href="group-replication.html#group-replication-upgrade">18.7 グループレプリケーションのアップグレード</a></span></dt><dd><dl><dt><span class="section"><a href="group-replication.html#group-replication-online-upgrade-combining-versions">18.7.1 グループ内の異なるメンバーバージョンの組合せ</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-offline-upgrade">18.7.2 グループレプリケーションのオフラインアップグレード</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-online-upgrade">18.7.3 グループレプリケーションのオンラインアップグレード</a></span></dt></dl></dd><dt><span class="section"><a href="group-replication.html#group-replication-options">18.8 グループレプリケーションシステム変数</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-requirements-and-limitations">18.9 要件と制限事項</a></span></dt><dd><dl><dt><span class="section"><a href="group-replication.html#group-replication-requirements">18.9.1 グループレプリケーションの要件</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-limitations">18.9.2 グループレプリケーションの制限事項</a></span></dt></dl></dd><dt><span class="section"><a href="group-replication.html#group-replication-frequently-asked-questions">18.10 よくある質問</a></span></dt></dl></div><a class="indexterm" name="idm45563248992416"></a><a class="indexterm" name="idm45563248990960"></a><p>
    この章では、MySQL Group Replication と、グループをインストール、構成および監視する方法について説明します。 MySQL Group Replication を使用すると、柔軟で可用性の高いフォルトトレラントレプリケーショントポロジを作成できます。 
  </p><p>
    グループは、一度に 1 つのサーバーのみが更新を受け入れる自動プライマリ選択を使用して、単一プライマリモードで動作できます。 または、グループをマルチプライマリモードでデプロイすることもできます。このモードでは、更新が同時に発行されても、すべてのサーバーが更新を受け入れることができます。 
  </p><p>
    グループのビューの一貫性を保ち、任意の時点ですべてのサーバーで使用できるようにする組込みグループメンバーシップサービスがあります。 サーバーはグループから退出して参加でき、それに応じてビューが更新されます。 サーバーが予期せずにグループから離れる場合があります。その場合、障害検出メカニズムはこれを検出し、ビューが変更されたことをグループに通知します。 これはすべて自動です。 
  </p><p>
    Group Replication は、データベースサービスが継続的に使用可能であることを保証します。 ただし、いずれかのグループメンバーが使用できなくなった場合、コネクタ、ロードバランサ、ルーターまたはなんらかの形式のミドルウェアを使用して、そのグループメンバーに接続されているクライアントをグループ内の別のサーバーにリダイレクトまたはフェイルオーバーする必要があることを理解することが重要です。 グループレプリケーションには、これを行う組込みの方法はありません。 たとえば、<a class="ulink" href="https://dev.mysql.com/doc/mysql-router/8.0/en/" target="_top">MySQL Router 8.0</a> を参照してください。 
  </p><p>
    Group Replication は、MySQL Server へのプラグインとして提供されます。 この章の手順に従って、グループに含める各サーバーインスタンスでプラグインを構成し、グループを起動し、グループをモニターおよび管理できます。 MySQL サーバーインスタンスのグループをデプロイする別の方法は、InnoDB クラスタ を使用することです。 
  </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">ヒント</div><p>
      MySQL の複数のインスタンスをデプロイするには、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/" target="_top">MySQL Shell</a> で MySQL サーバーインスタンスのグループを簡単に管理できるようにする <a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-innodb-cluster.html" target="_top">InnoDB クラスタ</a> を使用できます。InnoDB クラスタ は MySQL Group Replication をプログラム環境でラップするため、MySQL インスタンスのクラスタを簡単にデプロイして高可用性を実現できます。 また、InnoDB クラスタ は <a class="ulink" href="https://dev.mysql.com/doc/mysql-router/8.0/en/" target="_top">MySQL Router</a> とシームレスにインタフェースするため、アプリケーションは独自のフェイルオーバープロセスを記述せずにクラスタに接続できます。 ただし、高可用性を必要としない同様のユースケースでは、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-innodb-replicaset.html" target="_top">InnoDB ReplicaSet</a> を使用できます。 MySQL Shell のインストール手順は、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-shell-install.html" target="_top">here</a> にあります。 
    </p></div><p>
    この章の構成は次のとおりです:
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="xref" href="group-replication.html#group-replication-background" title="18.1 グループレプリケーションのバックグラウンド">セクション18.1「グループレプリケーションのバックグラウンド」</a> では、グループの概要とグループレプリケーションの仕組みについて説明します。
      </p></li><li class="listitem"><p>
        <a class="xref" href="group-replication.html#group-replication-getting-started" title="18.2 はじめに">セクション18.2「はじめに」</a> では、複数の MySQL Server インスタンスを構成してグループを作成する方法について説明します。
      </p></li><li class="listitem"><p>
        <a class="xref" href="group-replication.html#group-replication-monitoring" title="18.3 グループレプリケーションの監視">セクション18.3「グループレプリケーションの監視」</a> では、グループをモニターする方法について説明します。
      </p></li><li class="listitem"><p>
        <a class="xref" href="group-replication.html#group-replication-operations" title="18.4 グループレプリケーション操作">セクション18.4「グループレプリケーション操作」</a> では、グループの操作方法について説明します。
      </p></li><li class="listitem"><p>
        <a class="xref" href="group-replication.html#group-replication-security" title="18.5 グループレプリケーションセキュリティ">セクション18.5「グループレプリケーションセキュリティ」</a> では、グループを保護する方法について説明します。
      </p></li><li class="listitem"><p>
        <a class="xref" href="group-replication.html#group-replication-performance" title="18.6 グループレプリケーションのパフォーマンス">セクション18.6「グループレプリケーションのパフォーマンス」</a> では、グループのパフォーマンスを微調整する方法について説明します。
      </p></li><li class="listitem"><p>
        <a class="xref" href="group-replication.html#group-replication-upgrade" title="18.7 グループレプリケーションのアップグレード">セクション18.7「グループレプリケーションのアップグレード」</a> では、グループのアップグレード方法について説明します。
      </p></li><li class="listitem"><p>
        <a class="xref" href="group-replication.html#group-replication-options" title="18.8 グループレプリケーションシステム変数">セクション18.8「グループレプリケーションシステム変数」</a> は、Group Replication に固有のシステム変数のリファレンスです。
      </p></li><li class="listitem"><p>
        <a class="xref" href="group-replication.html#group-replication-requirements-and-limitations" title="18.9 要件と制限事項">セクション18.9「要件と制限事項」</a> では、Group Replication の技術要件および制限事項について説明します。
      </p></li><li class="listitem"><p>
        <a class="xref" href="group-replication.html#group-replication-frequently-asked-questions" title="18.10 よくある質問">セクション18.10「よくある質問」</a> では、グループレプリケーションのデプロイおよびオペレーティングに関する技術的な質問に対する回答を提供しています。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="group-replication-background"></a>18.1 グループレプリケーションのバックグラウンド</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-replication-technologies">18.1.1 レプリケーションテクノロジ</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-use-cases">18.1.2 グループレプリケーションのユースケース</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-deploying-in-multi-primary-or-single-primary-mode">18.1.3 マルチプライマリモードとシングルプライマリモード</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-details">18.1.4 グループレプリケーションサービス</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-plugin-architecture">18.1.5 グループレプリケーションプラグインのアーキテクチャ</a></span></dt></dl></div><a class="indexterm" name="idm45563248955760"></a><p>
    このセクションでは、MySQL Group Replication のバックグラウンド情報を提供します。
  </p><p>
    フォルトトレラントシステムを作成する最も一般的な方法は、コンポーネントを冗長にすることです。つまり、コンポーネントを削除でき、システムは引き続き予想どおりに動作する必要があります。 これにより、このようなシステムの複雑さを異なるレベル全体に引き上げる一連の課題が作成されます。 具体的には、レプリケートされたデータベースは、1 つのサーバーではなく複数のサーバーのメンテナンスおよび管理が必要であるという事実に対処する必要があります。 さらに、サーバーが連携してグループを作成しているため、ネットワークのパーティション化やスプリットブレーンシナリオなど、他のいくつかのクラシック分散システムの問題を処理する必要があります。 
  </p><p>
    したがって、最終的な課題は、データベースおよびデータレプリケーションのロジックを、一貫性のある簡単な方法で複数のサーバーを調整するロジックと融合することです。 つまり、複数のサーバーがシステムの状態と、システムが通過する各変更のデータに同意するようにします。 これは、すべてが単一のデータベースとして進行するように、または最終的に同じ状態に収束するように、サーバーが各データベースの状態遷移で承諾に到達するように要約できます。 つまり、(分散) 状態マシンとして動作する必要があります。 
  </p><p>
    MySQL Group Replication は、サーバー間で強力に調整された分散状態マシンのレプリケーションを提供します。 サーバーは、同じグループの一部である場合に自動的に調整されます。 グループは、一度に 1 つのサーバーのみが更新を受け入れる自動プライマリ選択を使用して、単一プライマリモードで動作できます。 または、より上級のユーザーの場合は、グループをマルチプライマリモードでデプロイできます。マルチプライマリモードでは、同時に発行された場合でも、すべてのサーバーが更新を受け入れることができます。 この機能は、このようなデプロイメントによって課される制限を回避する必要があるアプリケーションを犠牲にします。 
  </p><p>
    グループのビューの一貫性を保ち、任意の時点ですべてのサーバーで使用できるようにする組込みグループメンバーシップサービスがあります。 サーバーはグループから退出して参加でき、それに応じてビューが更新されます。 サーバーが予期せずにグループから離れる場合があります。その場合、障害検出メカニズムはこれを検出し、ビューが変更されたことをグループに通知します。 これはすべて自動です。 
  </p><p>
    トランザクションをコミットするには、グループの大部分が、トランザクションのグローバル順序での特定のトランザクションの順序に合意する必要があります。 トランザクションをコミットまたは中断するかどうかは、各サーバーによって個別に決定されますが、すべてのサーバーが同じ決定を行います。 ネットワークパーティションがあり、メンバーがアグリーメントに到達できない分割になった場合、この問題が解決されるまでシステムは進行しません。 したがって、ビルトインの自動スプリットブレイン保護メカニズムもあります。 
  </p><p>
    これらはすべて、提供されている Group Communication System (GCS) プロトコルによって処理されます。 これらは、障害検出メカニズム、グループメンバーシップサービス、および安全で完全に順序付けされたメッセージ配信を提供します。 これらのプロパティはすべて、サーバーのグループ間でデータが一貫してレプリケートされるようにするシステムの作成に重要です。 このテクノロジの非常にコアには、Paxos アルゴリズムの実装があります。 グループ通信エンジンとして機能します。 
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-replication-technologies"></a>18.1.1 レプリケーションテクノロジ</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-primary-secondary-replication">18.1.1.1 ソースからレプリカへのレプリケーション</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-summary">18.1.1.2 グループレプリケーション</a></span></dt></dl></div><a class="indexterm" name="idm45563248940400"></a><a class="indexterm" name="idm45563248938192"></a><p>
      このセクションでは、MySQL Group Replication の詳細を理解する前に、いくつかのバックグラウンド概念とその仕組みの概要について説明します。 これにより、グループレプリケーションに必要なものと、従来の非同期 MySQL レプリケーションとグループレプリケーションの違いを理解するのに役立つコンテキストが提供されます。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-primary-secondary-replication"></a>18.1.1.1 ソースからレプリカへのレプリケーション</h4></div></div></div><a class="indexterm" name="idm45563248934640"></a><a class="indexterm" name="idm45563248932464"></a><p>
        従来の MySQL <a class="link" href="replication.html" title="第 17 章 レプリケーション">Replication</a> は、レプリケーションへの単純なソースからレプリカへのアプローチを提供します。 ソースはプライマリであり、セカンダリである 1 つ以上のレプリカがあります。 ソースは、トランザクションを適用し、コミットした後、(ステートメントベースレプリケーションで) 再実行されるか、(行ベースレプリケーションで) 適用されるように、あとで (非同期的に) レプリカに送信されます。 これはシェアードナッシングシステムであり、すべてのサーバーにデフォルトでデータの完全なコピーがあります。 
      </p><div class="figure"><a name="idm45563248927840"></a><p class="title"><b>図 18.1 MySQL 非同期レプリケーション</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/async-replication-diagram.png" width="725" height="304" alt="ソースが受信したトランザクションが実行され、バイナリログに書き込まれてコミットされ、クライアントアプリケーションにレスポンスが送信されます。 バイナリログのレコードは、ソースでコミットが行われる前に、レプリカ 1 およびレプリカ 2 のリレーログに送信されます。 各レプリカで、トランザクションが適用され、レプリカバイナリログに書き込まれ、コミットされます。 ソースでのコミットとレプリカでのコミットはすべて独立しており、非同期です。"></div></div></div><br class="figure-break"><p>
        準同期レプリケーションもあり、プロトコルに 1 つの同期ステップが追加されます。 つまり、プライマリは適用時に、セカンダリがトランザクションを<span class="emphasis"><em>受信済</em></span>していることを確認するのを待機します。 その後でのみ、プライマリがコミット操作を再開します。 
      </p><div class="figure"><a name="idm45563248918592"></a><p class="title"><b>図 18.2 MySQL 準同期レプリケーション</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/semisync-replication-diagram.png" width="725" height="396" alt="ソースが受信したトランザクションが実行され、バイナリログに書き込まれます。 バイナリログからのレコードは、レプリカ 1 およびレプリカ 2 のリレーログに送信されます。 次に、ソースはレプリカからの確認応答を待機します。 両方のレプリカが確認応答を返すと、ソースはトランザクションをコミットし、レスポンスがクライアントアプリケーションに送信されます。 各レプリカが確認応答を返した後、トランザクションを適用し、バイナリログに書き込み、コミットします。 ソースでのコミットはレプリカからの確認応答によって異なりますが、レプリカでのコミットは互いに独立しており、ソースでのコミットからも独立しています。"></div></div></div><br class="figure-break"><p>
        この 2 つの図には、従来の非同期 MySQL レプリケーションプロトコル (およびその準同期バリアント) のダイアグラムがあります。 異なるインスタンス間の矢印は、サーバー間で交換されるメッセージまたはサーバーとクライアントアプリケーション間で交換されるメッセージを表します。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-summary"></a>18.1.1.2 グループレプリケーション</h4></div></div></div><a class="indexterm" name="idm45563248908432"></a><p>
        グループレプリケーションは、フォルトトレラントシステムの実装に使用できる手法です。 レプリケーショングループは、それぞれ独自のデータのコピー全体 (共有なしレプリケーションスキーム) を持ち、メッセージを渡して相互作用する一連のサーバーです。 通信レイヤーは、アトミックメッセージや合計オーダーメッセージ配信などの一連の保証を提供します。 これらは非常に強力なプロパティで、非常に有用な抽象化に変換され、より高度なデータベースレプリケーションソリューションを構築するために再ソートできます。 
      </p><p>
        MySQL Group Replication は、このようなプロパティおよび抽象化に基づいて構築され、どこにいてもマルチソース更新を実装します。 レプリケーショングループは複数のサーバーによって形成され、グループ内の各サーバーはいつでも個別にトランザクションを実行できます。 ただし、すべての読取り/書込みトランザクションは、グループによって承認された後にのみコミットされます。 つまり、読取り/書込みトランザクションの場合、グループはコミットするかどうかを決定する必要があるため、コミット操作は元のサーバーからの一方向の決定ではありません。 読取り専用トランザクションでは、グループ内で調整を行う必要はなく、即時にコミットされます。 
      </p><p>
        元のサーバーで読取り/書込みトランザクションをコミットする準備が整うと、サーバーは書込み値 (変更された行) および対応する書込みセット (更新された行の一意の識別子) を原子的にブロードキャストします。 トランザクションは原子性ブロードキャストを介して送信されるため、グループ内のすべてのサーバーがトランザクションを受信するか、まったく受信しないかのいずれかです。 受信した場合、すべてが以前に送信された他のトランザクションに関して同じ順序で受信します。 したがって、すべてのサーバーが同じ順序で同じトランザクションセットを受信し、トランザクションに対してグローバルな合計順序が確立されます。 
      </p><p>
        ただし、異なるサーバーで同時に実行されるトランザクション間で競合が発生する可能性があります。 このような競合は、<span class="emphasis"><em>動作保証</em></span>と呼ばれるプロセスで、異なるトランザクションと同時トランザクションの書込みセットを調べて比較することで検出されます。 動作保証中に、競合検出が行レベルで実行されます: 異なるサーバーで実行される 2 つの同時トランザクションが同じ行を更新すると、競合が発生します。 競合解決手順では、順序付けされたトランザクションが最初にすべてのサーバーでコミットされ、次に順序付けされたトランザクションは中断されるため、元のサーバーでロールバックされ、グループ内の他のサーバーによって削除されます。 たとえば、t1 と t2 が異なるサイトで同時に実行され、両方とも同じ行が変更され、t2 が t1 の前に順序付けされている場合、t2 は競合を優先し、t1 はロールバックされます。 これは、実際には分散された最初のコミット優先ルールです。 2 つのトランザクションが競合の頻度が高くなるようにバインドされている場合は、それらを同じサーバーで起動することをお薦めします。この場合、証明の結果としてロールバックされるのではなく、ローカルロックマネージャで同期化する機会があります。 
      </p><p>
        動作保証されたトランザクションを適用および外部化するために、グループレプリケーションでは、一貫性と有効性が損なわれない場合に、サーバーがトランザクションの合意された順序から逸脱することを許可します。 グループレプリケーションは最終的な一貫性システムです。つまり、受信トラフィックの速度が低下または停止するとすぐに、すべてのグループメンバーのデータコンテンツが同じになります。 トラフィックのフロー中に、トランザクションを若干異なる順序で外部化したり、一部のメンバーで外部化したりできます。 たとえば、マルチプライマリモードでは、証明書の直後にローカルトランザクションが外部化される場合がありますが、以前はグローバル順序になっていたリモートトランザクションはまだ適用されていません。 これは、トランザクション間に競合がないことが証明プロセスによって確立された場合に許可されます。 単一プライマリモードでは、プライマリサーバーで、競合しない同時ローカルトランザクションが、グループレプリケーションによって合意されたグローバル順序とは異なる順序でコミットおよび外部化される可能性があります。 クライアントからの書込みを受け入れないセカンダリでは、トランザクションは常に合意された順序でコミットおよび外部化されます。 
      </p><p>
        次の図に、MySQL Group Replication プロトコルを示します。これを MySQL Replication (または MySQL 準同期レプリケーション) と比較すると、いくつかの違いがわかります。 わかりやすくするために、基礎となるコンセンサスおよび Paxos 関連のメッセージの一部がこの写真にありません。 
      </p><div class="figure"><a name="idm45563248893008"></a><p class="title"><b>図 18.3 MySQL グループレプリケーションプロトコル</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/gr-replication-diagram.png" width="725" height="350" alt="ソース 1 が受信したトランザクションが実行されます。 次に、ソース 1 は、それ自体、ソース 2 およびソース 3 で構成されるメッセージをレプリケーショングループに送信します。 3 つのメンバーすべてがコンセンサスに到達すると、トランザクションが認証されます。 次に、ソース 1 はトランザクションをバイナリログに書き込み、コミットして、クライアントアプリケーションにレスポンスを送信します。 ソース 2 および 3 は、トランザクションをリレーログに書き込み、それを適用してバイナリログに書き込み、コミットします。"></div></div></div><br class="figure-break"></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-use-cases"></a>18.1.2 グループレプリケーションのユースケース</h3></div></div></div><a class="indexterm" name="idm45563248883600"></a><p>
      Group Replication を使用すると、システム状態を一連のサーバーにレプリケートすることで、冗長性を備えたフォルトトレラントシステムを作成できます。 その後、一部のサーバーで障害が発生した場合でも、すべてでないか大部分であるかぎり、システムは引き続き使用可能です。 グループに障害が発生したサーバーの数によっては、パフォーマンスまたはスケーラビリティが低下する可能性がありますが、まだ使用可能です。 サーバー障害は分離され、独立しています。 これらは、任意のサーバーがグループから退出したときに通知できる分散障害検出機能に依存するグループメンバーシップサービスによって追跡されます (自発的または予期しない停止のため)。 サーバーがグループに参加したときに自動的に最新の状態になるようにする分散リカバリ手順があります。 サーバーのフェイルオーバーは必要ありません。また、マルチソース更新では、単一のサーバーに障害が発生した場合にも更新がブロックされないように、あらゆる性質があります。 要約すると、MySQL Group Replication では、データベースサービスが継続的に使用可能であることが保証されます。 
    </p><p>
      データベースサービスは使用可能ですが、予期しないサーバーの終了時には、接続しているクライアントを別のサーバーにリダイレクトまたはフェイルオーバーする必要があることを理解することが重要です。 これは Group Replication が解決しようとするものではありません。 コネクタ、ロードバランサ、ルーターまたはなんらかの形式のミドルウェアは、この問題の処理に適しています。 たとえば、<a class="ulink" href="https://dev.mysql.com/doc/mysql-router/8.0/en/" target="_top">MySQL Router 8.0</a> を参照してください。 
    </p><p>
      要約すると、MySQL Group Replication は、可用性が高く、柔軟性の高い、信頼性の高い MySQL サービスを提供します。
    </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">ヒント</div><p>
        MySQL の複数のインスタンスをデプロイするには、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/" target="_top">MySQL Shell</a> で MySQL サーバーインスタンスのグループを簡単に管理できるようにする <a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-innodb-cluster.html" target="_top">InnoDB クラスタ</a> を使用できます。InnoDB クラスタ は MySQL Group Replication をプログラム環境でラップするため、MySQL インスタンスのクラスタを簡単にデプロイして高可用性を実現できます。 また、InnoDB クラスタ は <a class="ulink" href="https://dev.mysql.com/doc/mysql-router/8.0/en/" target="_top">MySQL Router</a> とシームレスにインタフェースするため、アプリケーションは独自のフェイルオーバープロセスを記述せずにクラスタに接続できます。 ただし、高可用性を必要としない同様のユースケースでは、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-innodb-replicaset.html" target="_top">InnoDB ReplicaSet</a> を使用できます。 MySQL Shell のインストール手順は、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-shell-install.html" target="_top">here</a> にあります。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-examples-of-use-case-scenarios"></a>ユースケースの例</h4></div></div></div><a class="indexterm" name="idm45563248869568"></a><p>
        次に、グループレプリケーションの一般的なユースケースの例を示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="emphasis"><em>エラスティックレプリケーション</em></span> - 非常に流体的なレプリケーションインフラストラクチャを必要とする環境。サーバーの数は、可能なかぎり少ない副作用で動的に増加または縮小する必要があります。 たとえば、クラウドのデータベースサービスです。 
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>高可用性シャード</em></span> - シャーディングは、書込みスケールアウトを実現するための一般的なアプローチです。 MySQL Group Replication を使用して、各シャードがレプリケーショングループにマップされる高可用性シャードを実装します。 
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>非同期ソース - レプリケーションレプリケーションの代替</em></span> - 特定の状況では、単一のソースサーバーを使用すると、単一の競合ポイントになります。 グループ全体への書込みは、特定の状況下でよりスケーラブルであることが証明される場合があります。 
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>自律システム</em></span> - また、レプリケーションプロトコルに組み込まれている自動化のためにのみ、MySQL Group Replication をデプロイできます (この章および前の章ですでに説明しています)。
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-deploying-in-multi-primary-or-single-primary-mode"></a>18.1.3 マルチプライマリモードとシングルプライマリモード</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-single-primary-mode">18.1.3.1 シングルプライマリモード</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-multi-primary-mode">18.1.3.2 マルチプライマリモード</a></span></dt></dl></div><a class="indexterm" name="idm45563248856528"></a><a class="indexterm" name="idm45563248854224"></a><a class="indexterm" name="idm45563248852160"></a><p>
      グループレプリケーションは、単一プライマリモードまたはマルチプライマリモードで動作します。 グループモードは、<code class="literal">group_replication_single_primary_mode</code> システム変数で指定されるグループ全体の構成設定で、すべてのメンバーで同じである必要があります。 <code class="literal">ON</code> はシングルプライマリモード (デフォルトモード) を意味し、<code class="literal">OFF</code> はマルチプライマリモードを意味します。 グループのメンバーを異なるモードでデプロイすることはできません。たとえば、あるメンバーをマルチプライマリモードで構成し、別のメンバーをシングルプライマリモードにすることはできません。 
    </p><p>
      グループレプリケーションの実行中は、<code class="literal">group_replication_single_primary_mode</code> の値を手動で変更できません。 MySQL 8.0.13 から、<code class="literal">group_replication_switch_to_single_primary_mode()</code> および <code class="literal">group_replication_switch_to_multi_primary_mode()</code> UDF を使用して、グループレプリケーションの実行中にグループをあるモードから別のモードに移動できます。 これらの UDF は、グループモードを変更するプロセスを管理し、データの安全性と一貫性を確保します。 以前のリリースでは、グループモードを変更するには、グループレプリケーションを停止し、すべてのメンバーで <code class="literal">group_replication_single_primary_mode</code> の値を変更する必要がありました。 次に、グループ (<code class="literal">group_replication_bootstrap_group=ON</code> を使用したサーバーによるブートストラップ) の完全再起動を実行して、新しいオペレーティング構成への変更を実装します。 サーバーを再起動する必要はありません。 
    </p><p>
      デプロイされたモードに関係なく、グループレプリケーションはクライアント側のフェイルオーバーを処理しません。 これは、<a class="ulink" href="https://dev.mysql.com/doc/mysql-router/8.0/en/" target="_top">MySQL Router 8.0</a>、プロキシ、コネクタまたはアプリケーション自体などのミドルウェアフレームワークによって処理される必要があります。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-single-primary-mode"></a>18.1.3.1 シングルプライマリモード</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-primary-election">18.1.3.1.1 プライマリ選択アルゴリズム</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-find-primary">18.1.3.1.2 プライマリの検索</a></span></dt></dl></div><a class="indexterm" name="idm45563248836320"></a><a class="indexterm" name="idm45563248834112"></a><p>
        シングルプライマリモード (<code class="literal">group_replication_single_primary_mode=ON</code>) では、グループに読取り/書込みモードに設定された単一のプライマリサーバーがあります。 グループ内の他のすべてのメンバーは読取り専用モードに設定されます (<code class="literal">super_read_only=ON</code> を使用)。 プライマリは通常、グループをブートストラップする最初のサーバーです。 グループに参加する他のすべてのサーバーはプライマリサーバーについて学習し、自動的に読取り専用モードに設定されます。 
      </p><p>
        単一プライマリモードでは、グループレプリケーションにより、単一サーバーのみがグループに書き込まれるように強制されるため、マルチプライマリモードと比較すると、一貫性チェックの制限が少なくなり、DDL ステートメントを特別に処理する必要はありません。 オプション <code class="literal">group_replication_enforce_update_everywhere_checks</code> は、グループの厳密な整合性チェックを有効または無効にします。 シングルプライマリモードでデプロイする場合、またはグループをシングルプライマリモードに変更する場合は、このシステム変数を <code class="literal">OFF</code> に設定する必要があります。 
      </p><p>
        プライマリサーバーとして指定されたメンバーは、次の方法で変更できます:

        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              既存のプライマリがグループから退出した場合は、自発的か予期せず、新しいプライマリが自動的に選択されます。
            </p></li><li class="listitem"><p>
              <code class="literal">group_replication_set_as_primary()</code> UDF を使用して、特定のメンバーを新しいプライマリとして指名できます。
            </p></li><li class="listitem"><p>
              <code class="literal">group_replication_switch_to_single_primary_mode()</code> UDF を使用して、マルチプライマリモードで実行されていたグループをシングルプライマリモードで実行するように変更した場合は、新しいプライマリが自動的に選択されるか、UDF で指定して新しいプライマリを指名できます。
            </p></li></ul></div><p>

        UDF は、すべてのグループメンバーが MySQL 8.0.13 以上を実行している場合にのみ使用できます。 新しいプライマリサーバーが自動的に選択されるか、手動で指定されると、自動的に読取り /書込みに設定され、他のグループメンバーはセカンダリとして残り、読取り専用のままになります。<a class="xref" href="group-replication.html#group-replication-primary-election-diagram" title="図 18.4 新規プライマリ選択">図18.4「新規プライマリ選択」</a> にこのプロセスが表示されます。 
      </p><div class="figure"><a name="group-replication-primary-election-diagram"></a><p class="title"><b>図 18.4 新規プライマリ選択</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/single-primary-election.png" width="948" height="327" alt="インターコネクトされたグループとして、5 つのサーバーインスタンス (S1、S2、S3、S4 および S5) がデプロイされます。 Server S1 がプライマリです。 書込みクライアントはサーバー S1 と通信しており、読取りクライアントはサーバー S4 と通信しています。 サーバー S1 が失敗し、書込みクライアントとの通信が切断されます。 その後、サーバー S2 が新しいプライマリを引き継ぎ、書込みクライアントがサーバー S2 と通信するようになります。"></div></div></div><br class="figure-break"><p>
        新しいプライマリが選択または指名されると、古いプライマリに適用されたが、このサーバーにはまだ適用されていない変更のバックログがある可能性があります。 この状況では、新しいプライマリが古いプライマリと捕捉されるまで、読取り/書込みトランザクションによって競合が発生してロールバックされ、読取り専用トランザクションによって読取りが失効する可能性があります。 高速メンバーと低速メンバーの違いを最小限に抑えるグループレプリケーションのフロー制御メカニズムにより、アクティブ化され適切にチューニングされた場合に発生する可能性が軽減されます。 フロー制御の詳細は、<a class="xref" href="group-replication.html#group-replication-flow-control" title="18.6.2 フロー制御">セクション18.6.2「フロー制御」</a> を参照してください。 MySQL 8.0.14 から、<code class="literal">group_replication_consistency</code> システム変数を使用してトランザクション一貫性のグループレベルを構成し、この問題を回避することもできます。 <code class="literal">BEFORE_ON_PRIMARY_FAILOVER</code> (またはそれ以上の整合性レベル) を設定すると、バックログが適用されるまで、新しく選択されたプライマリに新しいトランザクションが保持されます。 トランザクションの一貫性の詳細は、<a class="xref" href="group-replication.html#group-replication-consistency-guarantees" title="18.4.2 トランザクション一貫性保証">セクション18.4.2「トランザクション一貫性保証」</a> を参照してください。 フロー制御およびトランザクションの一貫性保証がグループに使用されていない場合は、クライアントアプリケーションを再ルーティングする前に、新しいプライマリがレプリケーション関連のリレーログを適用するのを待機することをお薦めします。 
      </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-primary-election"></a>18.1.3.1.1 プライマリ選択アルゴリズム</h5></div></div></div><p>
          プライマリメンバーの自動選択プロセスでは、各メンバーがグループの新しいビューを参照し、潜在的な新しいプライマリメンバーを順序付けし、最も適したメンバーを選択します。 各メンバーは、MySQL Server リリースのプライマリ選択アルゴリズムに従って、独自の決定をローカルで行います。 すべてのメンバーは同じ決定に到達する必要があるため、他のグループメンバーがより低い MySQL Server バージョンを実行している場合、メンバーはプライマリ選択アルゴリズムを調整して、グループ内で最も低い MySQL Server バージョンのメンバーと同じ動作をします。 
        </p><p>
          プライマリを選択するときにメンバーが考慮するファクタは、次のとおりです:

          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                最初に考慮される要因は、MySQL Server の最下位バージョンを実行しているメンバーです。 すべてのグループメンバーが MySQL 8.0.17 以上を実行している場合、メンバーは最初にそのリリースのパッチバージョンで順序付けされます。 MySQL Server 5.7 または MySQL 8.0.16 以下を実行しているメンバーがある場合、メンバーは最初にメジャーバージョンのリリースで順序付けされ、パッチバージョンは無視されます。 
              </p></li><li class="listitem"><p>
                複数のメンバーで最低バージョンの MySQL Server が実行されている場合、考慮される 2 番目のファクタは、メンバーの <code class="literal">group_replication_member_weight</code> システム変数で指定されている各メンバーのメンバーの重みです。 このシステム変数を使用できなかった MySQL Server 5.7 をグループのいずれかのメンバーが実行している場合、この係数は無視されます。 
              </p><p>
                <code class="literal">group_replication_member_weight</code> システム変数は、0-100 の範囲の数値を指定します。 すべてのメンバーのデフォルトの重みは 50 であるため、順序を下げるにはこの値より下の重みを設定し、順序を上げるにはその上の重みを設定します。 この重み付け機能を使用すると、より適切なハードウェアの使用に優先順位を付けることや、プライマリのスケジュールされたメンテナンス中に特定のメンバーにフェイルオーバーすることができます。 
              </p></li><li class="listitem"><p>
                複数のメンバーで最低バージョンの MySQL Server が実行されており、それらのメンバーのうち複数のメンバーの重みが最高である (またはメンバーの重みが無視されている) 場合、3 番目の要因は、<code class="literal">server_uuid</code> システム変数で指定されているように、各メンバーの生成されたサーバー UUID の辞書順であるとみなされます。 サーバー UUID が最も低いメンバーがプライマリとして選択されます。 このファクタは、すべてのグループメンバーが重要なファクタによって決定できない場合に同じ決定に到達するように、保証付きで予測可能なタイエリアとして機能します。 
              </p></li></ol></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-find-primary"></a>18.1.3.1.2 プライマリの検索</h5></div></div></div><a class="indexterm" name="idm45563248787024"></a><p>
          シングルプライマリモードでデプロイされたときに現在プライマリであるサーバーを確認するには、<code class="literal">performance_schema.replication_group_members</code> テーブルの <code class="literal">MEMBER_ROLE</code> カラムを使用します。 例: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT MEMBER_HOST, MEMBER_ROLE FROM performance_schema.replication_group_members;</code></strong>
+-------------------------+-------------+
| MEMBER_HOST             | MEMBER_ROLE |
+-------------------------+-------------+
| remote1.example.com     | PRIMARY     |
| remote2.example.com     | SECONDARY   |
| remote3.example.com     | SECONDARY   |
+-------------------------+-------------+
</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
            <code class="literal">group_replication_primary_member</code> ステータス変数は非推奨になり、将来のバージョンで削除される予定です。
          </p></div><p>
          または、<code class="literal">group_replication_primary_member</code> ステータス変数を使用します。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'group_replication_primary_member'</code></strong>
</pre></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-multi-primary-mode"></a>18.1.3.2 マルチプライマリモード</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-multi-primary-checks">18.1.3.2.1 トランザクションチェック</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-data-definition-statements">18.1.3.2.2 データ定義ステートメント</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-multi-primary-compatibility">18.1.3.2.3 バージョンの互換性</a></span></dt></dl></div><a class="indexterm" name="idm45563248774336"></a><p>
        マルチプライマリモード (<code class="literal">group_replication_single_primary_mode=OFF</code>) では、メンバーに特別なロールはありません。 他のグループメンバーと互換性のあるメンバーは、グループへの参加時に読取り/書込みモードに設定され、同時に発行された場合でも書込みトランザクションを処理できます。 
      </p><p>
        たとえば、予期しないサーバーの終了時に書込みトランザクションの受入れを停止したメンバーに接続されているクライアントは、読取り/書込みモードの他のメンバーにリダイレクトまたはフェイルオーバーできます。 グループレプリケーションはクライアント側フェイルオーバー自体を処理しないため、<a class="ulink" href="https://dev.mysql.com/doc/mysql-router/8.0/en/" target="_top">MySQL Router 8.0</a>、プロキシ、コネクタまたはアプリケーション自体などのミドルウェアフレームワークを使用してこれを調整する必要があります。<a class="xref" href="group-replication.html#group-replication-multi-primary-diagram" title="図 18.5 クライアントフェイルオーバー">図18.5「クライアントフェイルオーバー」</a> は、メンバーがグループを離れた場合に、クライアントが代替グループメンバーに再接続する方法を示します。 
      </p><div class="figure"><a name="group-replication-multi-primary-diagram"></a><p class="title"><b>図 18.5 クライアントフェイルオーバー</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/multi-primary.png" width="948" height="327" alt="インターコネクトされたグループとして、5 つのサーバーインスタンス (S1、S2、S3、S4 および S5) がデプロイされます。 すべてのサーバーがプライマリです。 書込みクライアントはサーバー S1 および S2 と通信し、読取りクライアントはサーバー S4 と通信しています。 Server S1 が失敗し、書込みクライアントとの通信が切断されます。 このクライアントは、サーバー S3 に再接続します。"></div></div></div><br class="figure-break"><p>
        グループレプリケーションは、最終的な一貫性システムです。 つまり、受信トラフィックの速度が低下または停止するとすぐに、すべてのグループメンバーのデータコンテンツが同じになります。 トラフィックが流れている間、特に一部のメンバーの書込みスループットが他のメンバーより低い場合、トランザクションを他のメンバーの前に外部化でき、失効した読取りの可能性があります。 マルチプライマリモードでは、低速なメンバーがトランザクションの過剰なバックログを構築して認証および適用することもでき、競合および証明の失敗のリスクが高くなります。 これらの問題を制限するには、グループレプリケーションのフロー制御メカニズムをアクティブ化およびチューニングして、高速メンバーと低速メンバーの違いを最小限に抑えることができます。 フロー制御の詳細は、<a class="xref" href="group-replication.html#group-replication-flow-control" title="18.6.2 フロー制御">セクション18.6.2「フロー制御」</a> を参照してください。 
      </p><p>
        MySQL 8.0.14 から、グループ内のすべてのトランザクションに対してトランザクションの一貫性を保証する場合は、<code class="literal">group_replication_consistency</code> システム変数を使用してこれを実行できます。 一貫性の向上に必要な同期のパフォーマンスへの影響を考慮して、グループのワークロードおよびデータの読取りおよび書込みの優先度に適した設定を選択できます。 また、個々のセッションのシステム変数を設定して、特に同時実行に注意の必要なトランザクションを保護することもできます。 トランザクションの一貫性の詳細は、<a class="xref" href="group-replication.html#group-replication-consistency-guarantees" title="18.4.2 トランザクション一貫性保証">セクション18.4.2「トランザクション一貫性保証」</a> を参照してください。 
      </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-multi-primary-checks"></a>18.1.3.2.1 トランザクションチェック</h5></div></div></div><p>
          グループがマルチプライマリモードでデプロイされている場合、トランザクションはモードと互換性があることを確認するためにチェックされます。 グループレプリケーションがマルチプライマリモードでデプロイされると、次の厳密な整合性チェックが行われます: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              SERIALIZABLE 分離レベルでトランザクションが実行されると、トランザクション自体をグループと同期するときにコミットが失敗します。
            </p></li><li class="listitem"><p>
              カスケード制約を持つ外部キーを持つテーブルに対してトランザクションが実行される場合、トランザクション自体をグループと同期するとコミットは失敗します。
            </p></li></ul></div><p>
          チェックは、<code class="literal">group_replication_enforce_update_everywhere_checks</code> システム変数によって制御されます。 マルチプライマリモードでは、システム変数は通常 <code class="literal">ON</code> に設定する必要がありますが、システム変数を <code class="literal">OFF</code> に設定することで、オプションでチェックを非アクティブ化できます。 シングルプライマリモードでデプロイする場合は、システム変数を <code class="literal">OFF</code> に設定する必要があります。 
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-data-definition-statements"></a>18.1.3.2.2 データ定義ステートメント</h5></div></div></div><a class="indexterm" name="idm45563248742768"></a><p>
          マルチプライマリモードのグループレプリケーショントポロジでは、一般にデータ定義言語 (DDL) とも呼ばれるデータ定義ステートメントの実行時に注意する必要があります。
        </p><p>
          MySQL 8.0 では、完全な DDL ステートメントが単一のアトミックトランザクションとしてコミットまたはロールバックされるアトミックデータ定義言語 (DDL) ステートメントのサポートが導入されています。 ただし、DDL ステートメント (アトミックまたはそれ以外) は、ステートメントを実行する前に <code class="literal">COMMIT</code> を実行したかのように、現在のセッションでアクティブなトランザクションを暗黙的に終了します。 つまり、DDL ステートメントは、別のトランザクション内、<code class="literal">START TRANSACTION ... COMMIT</code> などのトランザクション制御ステートメント内、または同じトランザクション内の他のステートメントと組み合せることはできません。 
        </p><p>
          グループレプリケーションはオプティミスティックレプリケーションパラダイムに基づいており、必要に応じてステートメントがオプティミスティックに実行され、後でロールバックされます。 各サーバーは、最初にグループ承諾を保護せずに実行されます。 したがって、マルチプライマリモードで DDL ステートメントをレプリケートする場合は、より注意する必要があります。 (DDL を使用して) スキーマを変更し、同じオブジェクトに対してオブジェクトに含まれるデータを (DML を使用して) 変更する場合は、スキーマ操作がまだ完了しておらず、どこにもレプリケートされていない間に、同じサーバーを介して変更を処理する必要があります。 そうしないと、操作が中断されたとき、または部分的にしか完了しなかったときに、データの不整合が発生する可能性があります。 グループがシングルプライマリモードでデプロイされている場合、この問題は発生しません。これは、すべての変更が同じサーバー (プライマリ) を介して実行されるためです。 
        </p><p>
          MySQL 8.0 でのアトミック DDL のサポート、および特定のステートメントのレプリケーションの動作の変更の詳細は、<a class="xref" href="sql-statements.html#atomic-ddl" title="13.1.1 アトミックデータ定義ステートメントのサポート">セクション13.1.1「アトミックデータ定義ステートメントのサポート」</a> を参照してください。
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-multi-primary-compatibility"></a>18.1.3.2.3 バージョンの互換性</h5></div></div></div><p>
          最適な互換性とパフォーマンスを得るには、グループのすべてのメンバーが同じバージョンの MySQL Server を実行する必要があるため、グループレプリケーションを実行する必要があります。 マルチプライマリモードでは、通常、すべてのメンバーが読取り/書込みモードでグループに参加するため、これはより重要です。 グループに複数の MySQL Server バージョンを実行しているメンバーが含まれている場合、一部のメンバーは他のメンバーがサポートしていないか、他のメンバーが持っている関数がないため、他のメンバーと互換性がない可能性があります。 これを防ぐために、新しいメンバー (アップグレードおよび再起動された以前のメンバーを含む) が参加すると、メンバーは残りのグループに対して互換性チェックを実行します。 
        </p><p>
          これらの互換性チェックの結果の 1 つは、マルチプライマリモードで特に重要です。 参加メンバーが、既存のグループメンバーが実行されている最下位バージョンより上位の MySQL Server バージョンを実行している場合、そのメンバーはグループに参加しますが、読取り専用モードのままです。 (単一プライマリモードで実行されているグループでは、新しく追加されたメンバーは、いずれの場合も読取り専用にデフォルト設定されます。) MySQL 8.0.17 以上を実行しているメンバーは、互換性をチェックするときにリリースのパッチバージョンを考慮します。 MySQL 8.0.16 以下または MySQL 5.7 を実行しているメンバーには、メジャーバージョンのみが考慮されます。 
        </p><p>
          異なる MySQL Server バージョンを使用するメンバーを持つマルチプライマリモードで実行されているグループでは、グループレプリケーションは、MySQL 8.0.17 以上を実行しているメンバーの読取り/書込みおよび読取り専用ステータスを自動的に管理します。 メンバーがグループから離れると、現在最も低いバージョンを実行しているメンバーは自動的に読取り/書込みモードに設定されます。 シングルプライマリモードで実行されていたグループをマルチプライマリモードで実行するように変更すると、<code class="literal">group_replication_switch_to_multi_primary_mode()</code> UDF を使用して、グループレプリケーションによって自動的にメンバーが正しいモードに設定されます。 メンバーは、グループに存在する最低バージョンより上位の MySQL サーバーバージョンを実行しており、最低バージョンを実行しているメンバーが読取り/書込みモードになっている場合、自動的に読取り専用モードになります。 
        </p><p>
          グループ内のバージョンの互換性、およびこれがアップグレードプロセス中にグループの動作に与える影響の詳細は、<a class="xref" href="group-replication.html#group-replication-online-upgrade-combining-versions" title="18.7.1 グループ内の異なるメンバーバージョンの組合せ">セクション18.7.1「グループ内の異なるメンバーバージョンの組合せ」</a> を参照してください。
        </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-details"></a>18.1.4 グループレプリケーションサービス</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-group-membership">18.1.4.1 グループメンバーシップ</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-failure-detection">18.1.4.2 障害検出</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-fault-tolerance">18.1.4.3 Fault-tolerance</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-observability">18.1.4.4 可観測性</a></span></dt></dl></div><a class="indexterm" name="idm45563248719600"></a><p>
      このセクションでは、Group Replication が構築されるサービスの一部を紹介します。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-group-membership"></a>18.1.4.1 グループメンバーシップ</h4></div></div></div><a class="indexterm" name="idm45563248716000"></a><a class="indexterm" name="idm45563248713824"></a><a class="indexterm" name="idm45563248711728"></a><p>
        MySQL Group Replication では、一連のサーバーがレプリケーショングループを形成します。 グループには UUID の形式をとる名前があります。 このグループは動的であり、サーバーはいつでも (自発的または無関係に) 離脱して参加できます。 サーバーが参加または退出するたびに、グループ自体が調整されます。 
      </p><p>
        サーバーがグループに参加すると、既存のサーバーから欠落している状態がフェッチされ、自動的に最新の状態になります。 サーバーがグループから離れると (たとえば、メンテナンスのために停止された場合)、残りのサーバーは自動的にグループを離れて再構成したことに気付きます。 
      </p><p>
        グループレプリケーションには、オンラインでグループに参加しているサーバーを定義するグループメンバーシップサービスがあります。 オンラインサーバーのリストは <span class="emphasis"><em>view</em></span> と呼ばれます。 グループ内のすべてのサーバーには、特定の時点でグループにアクティブに参加しているサーバーの一貫したビューがあります。 
      </p><p>
        グループメンバーは、トランザクションのコミットのみでなく、現在のビューでも一致する必要があります。 既存のメンバーが新しいサーバーをグループの一部にする必要があることに同意すると、そのサーバーを統合するようにグループが再構成され、ビューの変更がトリガーされます。 サーバーが自発的にグループから離れるかどうかにかかわらず、グループはその構成を動的に再配置し、ビューの変更がトリガーされます。 
      </p><p>
        メンバーが自発的にグループから離れる場合、最初に動的グループ再構成を開始し、その間、すべてのメンバーはサーバーから離れることなく新しいビューに同意する必要があります。 ただし、予期せず停止した場合やネットワーク接続が停止している場合などに、メンバーがグループを離れると、再構成を開始できません。 この状況では、グループレプリケーションの障害検出メカニズムは、メンバーが残っている短期間を認識し、障害が発生したメンバーのないグループの再構成を提案します。 自発的に退職するメンバーと同様に、再構成にはグループ内の大部分のサーバーからの同意が必要です。 ただし、大部分のサーバーがオンラインにならないようにパーティション化されているなどの理由で、グループがアグリーメントに到達できない場合、システムは構成を動的に変更できず、スプリットブレインの状況を防ぐためにブロックされます。 この状況では、管理者の介入が必要です。 
      </p><p>
        メンバーが短時間オフラインになってから、障害検出メカニズムによって障害が検出される前、およびグループが再構成されてメンバーが削除される前に、グループへの再参加を再試行できます。 この場合、再参加メンバーは以前の状態を忘れますが、他のメンバーがその前の状態を意図したメッセージを送信すると、データの不整合などの問題が発生する可能性があります。 この状況のメンバーが XCom コンセンサスプロトコルに参加している場合、障害の前後に異なる決定を行うことで、XCom が同じコンセンサスラウンドに対して異なる値を配信する可能性があります。 
      </p><p>
        この可能性に対処するために、MySQL 5.7.22 および MySQL 8.0 では、グループレプリケーションは、(同じアドレスとポート番号を持つ) 古いインカネーションがメンバーとしてリストされているときに、同じサーバーの新しいインカネーションがグループに参加しようとしている状況をチェックします。 新しいインカネーションは、再構成によって古いインカネーションを削除できるようになるまで、グループへの参加をブロックされます。 メンバーが削除される前にグループに再接続できるように、待機期間が <code class="literal">group_replication_member_expel_timeout</code> システム変数によって追加されている場合、疑わしいメンバーが疑わしいタイムアウトの前にグループに再接続すると、疑わしいメンバーが現在のインカネーションとして再度アクティブになる可能性があります。 メンバーが expel タイムアウトを超えてグループから削除された場合、または <code class="literal">STOP GROUP_REPLICATION</code> ステートメントまたはサーバー障害によってサーバーでグループレプリケーションが停止された場合は、新しいインカネーションとして再結合する必要があります。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-failure-detection"></a>18.1.4.2 障害検出</h4></div></div></div><a class="indexterm" name="idm45563248694544"></a><a class="indexterm" name="idm45563248692400"></a><p>
        Group Replication には、障害検出メカニズムが含まれています。このメカニズムを使用すると、どのサーバーがサイレントで、どのサーバーが停止していると想定されているかを検出してレポートできます。 高レベルでは、障害検出機能は、どのサーバーが停止する可能性があるか (疑わしい) に関する情報を提供する分散サービスです。 疑いは、サーバーがミュートされるとトリガーされます。 指定した期間中にサーバー A がサーバー B からメッセージを受信しないと、タイムアウトが発生し、疑いが発生します。 その後、グループが疑いが真であることに同意した場合、グループは特定のサーバーに実際に障害が発生したと判断します。 つまり、グループ内の残りのメンバーは、調整された決定を受けて特定のメンバーを明示します。 
      </p><p>
        サーバーがグループの他の部分から分離されると、他のすべてのサーバーで障害が発生している可能性があります。 グループとのアグリーメントを保護できません (クォーラムを保護できないため)。疑いはありません。 この方法でサーバーをグループから分離すると、ローカルトランザクションを実行できなくなります。 
      </p><p>
        ネットワークが不安定であり、メンバーが異なる組合せで相互に頻繁に接続を失い、回復する場合、理論的には、グループがすべてのメンバーに強制マークを付けることができます。その後、グループは存在しなくなり、再度設定する必要があります。 この可能性に対処するために、MySQL 8.0.20 から、Group Replication Group Communication System (GCS) は説明のためにマークされたグループメンバーを追跡し、大多数があるかどうかを判断する際に疑わしいメンバーのグループ内にあるかのように処理します。 これにより、グループに少なくとも 1 つのメンバーが残っていることが保証され、グループは引き続き存在できます。 削除されたメンバーがグループから実際に削除されると、GCS は、メンバーに強制マークを付けたレコードを削除して、メンバーがグループに再度参加できるようにします。 
      </p><p>
        障害状況に対する作業グループメンバーのレスポンスを指定するために構成できるグループレプリケーションシステム変数、および障害が疑われるグループメンバーが実行するアクションの詳細は、<a class="xref" href="group-replication.html#group-replication-responses-failure" title="18.6.6 障害検出およびネットワークパーティション化へのレスポンス">セクション18.6.6「障害検出およびネットワークパーティション化へのレスポンス」</a> を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-fault-tolerance"></a>18.1.4.3 Fault-tolerance</h4></div></div></div><p>
        MySQL Group Replication は、Paxos 分散アルゴリズムの実装に基づいて構築され、サーバー間の分散調整を提供します。 そのため、定足数に到達して決定するには、大部分のサーバーがアクティブである必要があります。 これは、システム自体とその全体的な機能を損なわずに許容できる障害の数に直接影響します。 <code class="literal">f</code> 障害を許容するために必要なサーバーの数 (n) は、<code class="literal">n = 2 x f + 1</code> です。 
      </p><p>
        これは、1 つの障害を許容するには、グループに 3 つのサーバーが含まれている必要があることを意味します。 そのため、1 台のサーバで障害が発生した場合でも、大多数のサーバ (3 台のうち 2 台) を形成し、システムが自動的に意思決定を継続して進行できるようにします。 ただし、別のサーバーで <span class="emphasis"><em>involuntarily</em></span> に障害が発生した場合は、決定に到達する大部分がないため、グループがブロックされます (1 つのサーバーが残っています)。 
      </p><p>
        次のテーブルに、前述の式を示します。
      </p><div class="informaltable"><table summary="Relationship between replication group size, the number of servers that constitute a majority, and the number of instant failures that can be tolerated."><col style="width: 23%"><col style="width: 18%"><col style="width: 59%"><thead><tr>
            <th scope="col"><p>
                グループサイズ
              </p></th>
            <th scope="col"><p>
                過半数
              </p></th>
            <th scope="col"><p>
                許容される即時障害
              </p></th>
          </tr></thead><tbody><tr>
            <th scope="row"><p>
                1
              </p></th>
            <td><p>
                1
              </p></td>
            <td><p>
                0
              </p></td>
          </tr><tr>
            <th scope="row"><p>
                2
              </p></th>
            <td><p>
                2
              </p></td>
            <td><p>
                0
              </p></td>
          </tr><tr>
            <th scope="row"><p>
                3
              </p></th>
            <td><p>
                2
              </p></td>
            <td><p>
                1
              </p></td>
          </tr><tr>
            <th scope="row"><p>
                4
              </p></th>
            <td><p>
                3
              </p></td>
            <td><p>
                1
              </p></td>
          </tr><tr>
            <th scope="row"><p>
                5
              </p></th>
            <td><p>
                3
              </p></td>
            <td><p>
                2
              </p></td>
          </tr><tr>
            <th scope="row"><p>
                6
              </p></th>
            <td><p>
                4
              </p></td>
            <td><p>
                2
              </p></td>
          </tr><tr>
            <th scope="row"><p>
                7
              </p></th>
            <td><p>
                4
              </p></td>
            <td><p>
                3
              </p></td>
          </tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-observability"></a>18.1.4.4 可観測性</h4></div></div></div><a class="indexterm" name="idm45563248640832"></a><p>
        Group Replication プラグインには多くの自動化が組み込まれています。 それでも、バックグラウンドで何が起こっているかを理解する必要がある場合があります。 ここでは、グループレプリケーションおよびパフォーマンススキーマのインストゥルメンテーションが重要になります。 システム全体の状態 (ビュー、競合統計およびサービス状態を含む) は、「パフォーマンススキーマ」テーブルを介してクエリーすることができます。 レプリケーションプロトコルの分散特性と、サーバーインスタンスが合意してトランザクションおよびメタデータで同期化されるという事実により、グループの状態を簡単に検査できます。 たとえば、グループレプリケーション関連の「パフォーマンススキーマ」テーブルに対して SELECT ステートメントを発行することで、グループ内の単一のサーバーに接続し、ローカル情報とグローバル情報の両方を取得できます。 詳細は、<a class="xref" href="group-replication.html#group-replication-monitoring" title="18.3 グループレプリケーションの監視">セクション18.3「グループレプリケーションの監視」</a>を参照してください。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-plugin-architecture"></a>18.1.5 グループレプリケーションプラグインのアーキテクチャ</h3></div></div></div><a class="indexterm" name="idm45563248634480"></a><a class="indexterm" name="idm45563248632320"></a><a class="indexterm" name="idm45563248630224"></a><p>
      MySQL Group Replication は MySQL プラグインであり、バイナリログ、行ベースのロギング、グローバルトランザクション識別子などの機能を利用して、既存の MySQL レプリケーションインフラストラクチャ上に構築されます。 パフォーマンススキーマやプラグイン、サービスインフラストラクチャなど、現在の MySQL フレームワークと統合されます。 次の図に、MySQL Group Replication の全体的なアーキテクチャを示すブロック図を示します。 
    </p><div class="figure"><a name="idm45563248627216"></a><p class="title"><b>図 18.6 グループ複製プラグインのブロック図</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/gr-plugin-blocks.png" width="455" height="393" alt="図の後のテキストは、ダイアグラムの内容を説明しています。"></div></div></div><br class="figure-break"><p>
      MySQL Group Replication プラグインには、プラグインが MySQL Server とどのように相互作用するかを制御する、取得、適用およびライフサイクル用の一連の API が含まれています。 サーバーからプラグインへ、またはその逆への情報フローを行うインタフェースがあります。 これらのインタフェースは、MySQL Server コアを Group Replication プラグインから分離し、ほとんどの場合、トランザクション実行パイプラインに配置されるフックです。 サーバーからプラグインへの一方向に、サーバーの起動、サーバーのリカバリ、接続を受け入れる準備ができているサーバー、トランザクションをコミットしようとしているサーバーなどのイベントの通知があります。 もう一方の方向では、プラグインは進行中のトランザクションのコミットや中断、リレーログ内のトランザクションのキューイングなどのアクションを実行するようにサーバーに指示します。 
    </p><p>
      Group Replication プラグインアーキテクチャーの次のレイヤーは、通知がルーティングされたときに反応する一連のコンポーネントです。 取得コンポーネントは、実行中のトランザクションに関連するコンテキストを追跡します。 applier コンポーネントは、データベースでリモートトランザクションを実行します。 リカバリコンポーネントは分散リカバリを管理し、ドナーを選択してキャッチアップ手順を管理し、ドナー障害に対応することで、グループに最新の状態で参加しているサーバーを取得します。 
    </p><p>
      スタックを続行すると、レプリケーションプロトコルモジュールにはレプリケーションプロトコルの特定のロジックが含まれます。 競合検出を処理し、トランザクションを受信してグループに伝播します。 
    </p><p>
      Group Replication プラグインアーキテクチャの最後の 2 つのレイヤーは、Group Communication System (GCS) API と Paxos ベースのグループ通信エンジン (XCom) の実装です。 GCS API は、レプリケートされた状態マシンの構築に必要なプロパティを抽象化する高レベルの API です (<a class="xref" href="group-replication.html#group-replication-background" title="18.1 グループレプリケーションのバックグラウンド">セクション18.1「グループレプリケーションのバックグラウンド」</a> を参照)。 したがって、メッセージングレイヤーの実装がプラグインの残りの上位レイヤーから切り離されます。 グループ通信エンジンは、レプリケーショングループのメンバーとの通信を処理します。 
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="group-replication-getting-started"></a>18.2 はじめに</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-deploying-in-single-primary-mode">18.2.1 単一プライマリモードでのグループレプリケーションのデプロイ</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-deploying-locally">18.2.2 グループレプリケーションのローカルでのデプロイ</a></span></dt></dl></div><a class="indexterm" name="idm45563248611664"></a><p>
    MySQL Group Replication は MySQL サーバーへのプラグインとして提供され、グループ内の各サーバーにはプラグインの構成とインストールが必要です。 このセクションでは、少なくとも 3 つのメンバーを含むレプリケーショングループを作成するために必要なステップを含む詳細なチュートリアルを提供します。 
  </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">ヒント</div><p>
      MySQL の複数のインスタンスをデプロイするには、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/" target="_top">MySQL Shell</a> で MySQL サーバーインスタンスのグループを簡単に管理できるようにする <a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-innodb-cluster.html" target="_top">InnoDB クラスタ</a> を使用できます。InnoDB クラスタ は MySQL Group Replication をプログラム環境でラップするため、MySQL インスタンスのクラスタを簡単にデプロイして高可用性を実現できます。 また、InnoDB クラスタ は <a class="ulink" href="https://dev.mysql.com/doc/mysql-router/8.0/en/" target="_top">MySQL Router</a> とシームレスにインタフェースするため、アプリケーションは独自のフェイルオーバープロセスを記述せずにクラスタに接続できます。 ただし、高可用性を必要としない同様のユースケースでは、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-innodb-replicaset.html" target="_top">InnoDB ReplicaSet</a> を使用できます。 MySQL Shell のインストール手順は、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/mysql-shell-install.html" target="_top">here</a> にあります。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-deploying-in-single-primary-mode"></a>18.2.1 単一プライマリモードでのグループレプリケーションのデプロイ</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-getting-started-deploying-instances">18.2.1.1 グループレプリケーション用のインスタンスのデプロイ</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-configuring-instances">18.2.1.2 グループレプリケーション用のインスタンスの構成</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-user-credentials">18.2.1.3 分散リカバリのユーザー資格証明</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-launching">18.2.1.4 グループレプリケーションの起動</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-bootstrap">18.2.1.5 グループのブートストラップ</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-adding-instances">18.2.1.6 グループへのインスタンスの追加</a></span></dt></dl></div><a class="indexterm" name="idm45563248601456"></a><p>
      グループ内の各 MySQL サーバーインスタンスは、グループレプリケーションをデプロイするための推奨方法である独立した物理ホストマシン上で実行できます。 このセクションでは、それぞれ異なるホストマシンで実行されている 3 つの MySQL Server インスタンスでレプリケーショングループを作成する方法について説明します。 テスト目的など、グループレプリケーションを実行している複数の MySQL サーバーインスタンスを同じホストマシンにデプロイする方法の詳細は、<a class="xref" href="group-replication.html#group-replication-deploying-locally" title="18.2.2 グループレプリケーションのローカルでのデプロイ">セクション18.2.2「グループレプリケーションのローカルでのデプロイ」</a> を参照してください。 
    </p><div class="figure"><a name="idm45563248596944"></a><p class="title"><b>図 18.7 グループアーキテクチャ</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/gr-3-server-group.png" width="312" height="332" alt="3 つのサーバーインスタンス (S1、S2 および S3) がインターコネクトされたグループとしてデプロイされ、クライアントは各サーバーインスタンスと通信します。"></div></div></div><br class="figure-break"><p>
      このチュートリアルでは、Group Replication プラグインを使用して MySQL Server を取得および配備する方法、グループを作成する前に各サーバーインスタンスを構成する方法、およびパフォーマンススキーマのモニタリングを使用してすべてが正しく動作していることを確認する方法について説明します。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-getting-started-deploying-instances"></a>18.2.1.1 グループレプリケーション用のインスタンスのデプロイ</h4></div></div></div><a class="indexterm" name="idm45563248587584"></a><p>
        最初のステップは、MySQL Server の少なくとも 3 つのインスタンスをデプロイすることです。この手順では、s1、s2 および s3 という名前のインスタンスに複数のホストを使用する方法を示します。 各ホストに MySQL Server がインストールされていることを前提としています。<a class="xref" href="installing.html" title="第 2 章 MySQL のインストールとアップグレード">第2章「<i>MySQL のインストールとアップグレード</i>」</a> を参照してください。 Group Replication は、MySQL Server 8.0 で提供される組込みの MySQL プラグインであるため、追加のインストールは必要ありません。 MySQL プラグインの背景情報の詳細は、<a class="xref" href="server-administration.html#server-plugins" title="5.6 MySQL Server プラグイン">セクション5.6「MySQL Server プラグイン」</a> を参照してください。 
      </p><p>
        この例では、グループに 3 つのインスタンスが使用されています。これは、グループを作成するための最小インスタンス数です。 インスタンスを追加すると、グループのフォルトトレランスが増加します。 たとえば、グループが 3 つのメンバーで構成されている場合、1 つのインスタンスで障害が発生しても、グループは続行できます。 ただし、別の障害が発生した場合、グループは書込みトランザクションの処理を続行できなくなります。 さらにインスタンスを追加することで、グループがトランザクションの処理を続行している間に失敗する可能性のあるサーバーの数も増加します。 グループで使用できるインスタンスの最大数は 9 です。 詳細は、<a class="xref" href="group-replication.html#group-replication-failure-detection" title="18.1.4.2 障害検出">セクション18.1.4.2「障害検出」</a> を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-configuring-instances"></a>18.2.1.2 グループレプリケーション用のインスタンスの構成</h4></div></div></div><a class="indexterm" name="idm45563248578256"></a><p>
        このセクションでは、グループレプリケーションに使用する MySQL Server インスタンスに必要な構成設定について説明します。 背景情報については、<a class="xref" href="group-replication.html#group-replication-requirements-and-limitations" title="18.9 要件と制限事項">セクション18.9「要件と制限事項」</a> を参照してください。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="group-replication.html#group-replication-storage-engines" title="Storage Engines (ストレージエンジン)">Storage Engines (ストレージエンジン)</a></p></li><li class="listitem"><p><a class="xref" href="group-replication.html#group-replication-configure-replication-framework" title="レプリケーションフレームワーク">レプリケーションフレームワーク</a></p></li><li class="listitem"><p><a class="xref" href="group-replication.html#group-replication-configure-plugin" title="グループレプリケーション設定">グループレプリケーション設定</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-storage-engines"></a>Storage Engines (ストレージエンジン)</h5></div></div></div><p>
          Group Replication の場合、データは InnoDB トランザクションストレージエンジンに格納される必要があります (理由の詳細は、<a class="xref" href="group-replication.html#group-replication-requirements" title="18.9.1 グループレプリケーションの要件">セクション18.9.1「グループレプリケーションの要件」</a> を参照してください)。 一時的な <code class="literal">MEMORY</code> ストレージエンジンを含むほかのストレージエンジンを使用すると、Group Replication でエラーが発生する可能性があります。 <code class="literal">disabled_storage_engines</code> システム変数を次のように設定して、使用しないようにします: 
        </p><pre class="programlisting">disabled_storage_engines="MyISAM,BLACKHOLE,FEDERATED,ARCHIVE,MEMORY"
</pre><p>
          <code class="literal">MyISAM</code> ストレージエンジンが無効になっている場合、<span class="command"><strong>mysql_upgrade</strong></span> がまだ使用されているリリース (MySQL 8.0.16 より前) に MySQL インスタンスをアップグレードすると、<span class="command"><strong>mysql_upgrade</strong></span> がエラーで失敗することがあります。 これを処理するには、<span class="command"><strong>mysql_upgrade</strong></span> の実行中にそのストレージエンジンを再度有効にし、サーバーの再起動時に再度無効にします。 詳細は、<a class="xref" href="programs.html#mysql-upgrade" title="4.4.5 mysql_upgrade — MySQL テーブルのチェックとアップグレード">セクション4.4.5「mysql_upgrade — MySQL テーブルのチェックとアップグレード」</a>を参照してください。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-configure-replication-framework"></a>レプリケーションフレームワーク</h5></div></div></div><p>
          次の設定では、MySQL Group Replication の要件に従ってレプリケーションを構成します。
        </p><pre class="programlisting">server_id=1
gtid_mode=ON
enforce_gtid_consistency=ON</pre><p>
          これらの設定は、一意の識別子番号 1 を使用して <a class="xref" href="replication.html#replication-gtids" title="17.1.3 グローバルトランザクション識別子を使用したレプリケーション">セクション17.1.3「グローバルトランザクション識別子を使用したレプリケーション」</a> を有効にし、GTID を使用して安全にログに記録できるステートメントのみを実行できるようにサーバーを構成します。
        </p><p>
          MySQL 8.0.20 までは、次の設定も必要です:
        </p><pre class="programlisting">binlog_checksum=NONE
</pre><p>
          この設定により、バイナリログに書き込まれたイベントのチェックサムが無効になり、デフォルトで有効になります。 MySQL 8.0.21 から、Group Replication はバイナリログ内のチェックサムの存在をサポートし、それらを使用して一部のチャネルでのイベントの整合性を検証できるため、デフォルト設定を使用できます。 詳細は、<a class="xref" href="group-replication.html#group-replication-limitations" title="18.9.2 グループレプリケーションの制限事項">セクション18.9.2「グループレプリケーションの制限事項」</a>を参照してください。 
        </p><p>
          レプリケーションのデフォルトが改善された 8.0.3 より前のバージョンの MySQL を使用している場合は、これらの行をメンバーオプションファイルに追加する必要もあります。 以降のバージョンのオプションファイルにこれらのシステム変数が含まれている場合は、それらが次のように設定されていることを確認します。 詳細は、<a class="xref" href="group-replication.html#group-replication-requirements" title="18.9.1 グループレプリケーションの要件">セクション18.9.1「グループレプリケーションの要件」</a> を参照してください。 
        </p><pre class="programlisting">log_bin=binlog
log_slave_updates=ON
binlog_format=ROW
master_info_repository=TABLE
relay_log_info_repository=TABLE
transaction_write_set_extraction=XXHASH64
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-configure-plugin"></a>グループレプリケーション設定</h5></div></div></div><p>
          この時点で、オプションファイルによってサーバーが構成され、特定の構成でレプリケーションインフラストラクチャをインスタンス化するように指示されます。 次のセクションでは、サーバーのグループレプリケーション設定を構成します。 
        </p><pre class="programlisting">plugin_load_add='group_replication.so'
group_replication_group_name="aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa"
group_replication_start_on_boot=off
group_replication_local_address= "s1:33061"
group_replication_group_seeds= "s1:33061,s2:33061,s3:33061"
group_replication_bootstrap_group=off
</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="option">plugin-load-add</code> は、起動時にサーバーがロードするプラグインのリストに Group Replication プラグインを追加します。 これは、プラグインを手動でインストールするよりも本番デプロイメントでお薦めします。 
            </p></li><li class="listitem"><p>
              <code class="literal">group_replication_group_name</code> の構成は、参加または作成しているグループの名前が "aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa" であることをプラグインに伝えます。
            </p><p>
              <code class="literal">group_replication_group_name</code> の値は有効な UUID である必要があります。 この UUID は、バイナリログ内のグループレプリケーションイベントの GTID を設定するときに内部的に使用されます。 <code class="literal">SELECT UUID()</code> を使用して UUID を生成できます。 
            </p></li><li class="listitem"><p>
              <code class="literal">off</code> に <code class="literal">group_replication_start_on_boot</code> 変数を構成すると、サーバーの起動時に自動的に操作を開始しないようにプラグインに指示されます。 これは、プラグインを手動で起動する前にサーバーを構成できるようにするため、Group Replication を設定する際に重要です。 メンバーを構成したら、サーバーの起動時にグループレプリケーションが自動的に開始されるように、<code class="literal">group_replication_start_on_boot</code> を <code class="literal">on</code> に設定できます。 
            </p></li><li class="listitem"><p>
              <code class="literal">group_replication_local_address</code> を構成すると、メンバーがグループ内の他のメンバーとの内部通信に使用するネットワークアドレスとポートが設定されます。 グループレプリケーションは、グループ通信エンジン (XCom、Paxos バリアント) のリモートインスタンスを含む内部メンバーからメンバーへの接続にこのアドレスを使用します。 
            </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
                グループレプリケーションのローカルアドレスは、MySQL Server <code class="literal">hostname</code> および <code class="literal">port</code> システム変数で定義される SQL クライアント接続に使用されるホスト名およびポートとは異なる必要があります。 クライアントアプリケーションには使用しないでください。 グループレプリケーションの実行中にグループのメンバー間の内部通信にのみ使用する必要があります。 
              </p></div><p>
              <code class="literal">group_replication_local_address</code> によって構成されたネットワークアドレスは、すべてのグループメンバーが解決できる必要があります。 たとえば、各サーバーインスタンスが固定ネットワークアドレスを持つ異なるマシン上にある場合、10.0.0.1 などのマシンの IP アドレスを使用できます。 ホスト名を使用する場合は、完全修飾名を使用し、DNS、正しく構成された<code class="literal">/etc/hosts</code> ファイルまたはその他の名前解決プロセスを介して解決できることを確認する必要があります。 MySQL 8.0.14 からは、IPv6 アドレス (またはそれらに解決されるホスト名) と IPv4 アドレスを使用できます。 グループには、IPv6 を使用するメンバーと IPv4 を使用するメンバーを混在させることができます。 IPv6 ネットワークおよび IPv4 と IPv6 の混合グループに対するグループレプリケーションサポートの詳細は、<a class="xref" href="group-replication.html#group-replication-ipv6" title="18.4.5 IPv6 および IPv6 と IPv4 の混合グループのサポート">セクション18.4.5「IPv6 および IPv6 と IPv4 の混合グループのサポート」</a> を参照してください。 
            </p><p>
              <code class="literal">group_replication_local_address</code> の推奨ポートは 33061 です。<code class="literal">group_replication_local_address</code> は、グループレプリケーションによって、レプリケーショングループ内のグループメンバーの一意の識別子として使用されます。 このチュートリアルで示すように、ホスト名または IP アドレスがすべて異なるかぎり、レプリケーショングループのすべてのメンバーに同じポートを使用できます。 または、<a class="xref" href="group-replication.html#group-replication-deploying-locally" title="18.2.2 グループレプリケーションのローカルでのデプロイ">セクション18.2.2「グループレプリケーションのローカルでのデプロイ」</a> に示すように、ポートがすべて異なるかぎり、すべてのメンバーに同じホスト名または IP アドレスを使用できます。 
            </p><p>
              グループレプリケーション分散リカバリプロセスで既存のメンバーが参加メンバーに提供する接続は、<code class="literal">group_replication_local_address</code> によって構成されたネットワークアドレスではありません。 MySQL 8.0.20 まで、グループメンバーは、MySQL Server <code class="literal">hostname</code> および <code class="literal">port</code> システム変数で指定されている分散リカバリのためにメンバーを結合するための標準 SQL クライアント接続を提供します。 MySQL 8.0.21 から、グループメンバーは分散リカバリエンドポイントの代替リストをメンバー参加専用のクライアント接続として通知できます。 詳細は、<a class="xref" href="group-replication.html#group-replication-distributed-recovery-connections" title="18.4.3.1 分散リカバリの接続">セクション18.4.3.1「分散リカバリの接続」</a>を参照してください。 
            </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
                結合メンバーが、MySQL Server <code class="literal">hostname</code> システム変数で定義されたホスト名を使用して他のメンバーを正しく識別できない場合、分散リカバリは失敗する可能性があります。 MySQL を実行しているオペレーティングシステムでは、DNS またはローカル設定を使用して、一意のホスト名を適切に構成することをお薦めします。 サーバーが SQL クライアント接続に使用しているホスト名は、「パフォーマンススキーマ」テーブル <code class="literal">replication_group_members</code> の <code class="literal">Member_host</code> カラムで確認できます。 複数のグループメンバーがオペレーティングシステムによって設定されたデフォルトのホスト名を外部化する場合、参加メンバーが正しいメンバーアドレスに解決せず、分散リカバリのために接続できない可能性があります。 この状況では、MySQL Server <code class="literal">report_host</code> システム変数を使用して、各サーバーによって外部化される一意のホスト名を構成できます。 
              </p></div></li><li class="listitem"><p>
              <code class="literal">group_replication_group_seeds</code> を構成すると、新しいメンバーがグループへの接続を確立するために使用するグループメンバーのホスト名とポートが設定されます。 これらのメンバーはシードメンバーと呼ばれます。 接続が確立されると、グループメンバーシップ情報が「パフォーマンススキーマ」テーブル <code class="literal">replication_group_members</code> にリストされます。 通常、<code class="literal">group_replication_group_seeds</code> リストには各グループメンバー <code class="literal">group_replication_local_address</code> の <code class="literal">hostname:port</code> が含まれますが、これは義務ではなく、グループメンバーのサブセットをシードとして選択できます。 
            </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
                <code class="literal">group_replication_group_seeds</code> にリストされている <code class="literal">hostname:port</code> は、<code class="literal">group_replication_local_address</code> によって構成されたシードメンバーの内部ネットワークアドレスであり、「パフォーマンススキーマ」テーブル <code class="literal">replication_group_members</code> などに示されている SQL クライアント接続に使用される <code class="literal">hostname:port</code> ではありません。
              </p></div><p>
              グループを起動するサーバーは、このオプションを使用しません。これは、このオプションが初期サーバーであり、グループのブートストラップを担当しているためです。 つまり、グループをブートストラップするサーバー上の既存のデータは、次の結合メンバーのデータとして使用されます。 2 つ目のサーバーを結合すると、グループ内の 1 つのメンバーと唯一のメンバーに参加するように要求され、2 つ目のサーバー上の欠落しているデータはブートストラップメンバー上のドナーデータからレプリケートされ、グループが展開されます。 3 つ目のサーバー結合では、これらの 2 つのいずれかを結合するように要求できます。データは新しいメンバーに同期され、グループが再度展開されます。 後続のサーバーは、参加時にこの手順を繰り返します。 
            </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
                複数のサーバーに同時に参加する場合は、グループにすでに存在するシードメンバーを指していることを確認してください。 グループに参加しているメンバーは、連絡時にまだグループに属していない可能性があるため、シードとして使用しないでください。 
              </p><p>
                ブートストラップメンバーを最初に起動し、グループを作成することをお薦めします。 次に、参加している残りのメンバーのシードメンバーにします。 これにより、残りのメンバーを結合するときにグループが形成されます。 
              </p><p>
                グループの作成と複数のメンバーの同時参加はサポートされていません。 これは機能する可能性がありますが、操作が競合してから、グループに参加する操作がエラーまたはタイムアウトで終了する可能性があります。 
              </p></div><p>
              参加メンバーは、シードメンバーが <code class="literal">group_replication_group_seeds</code> オプションで通知するプロトコル (IPv4 または IPv6) と同じプロトコルを使用してシードメンバーと通信する必要があります。 グループレプリケーションの IP アドレス権限のために、シードメンバーの許可リストには、シードメンバーが提供するプロトコルの参加メンバーの IP アドレス、またはそのプロトコルのアドレスに解決されるホスト名が含まれている必要があります。 このアドレスのプロトコルがシードメンバーに通知されたプロトコルと一致しない場合は、参加メンバー <code class="literal">group_replication_local_address</code> に加えて、このアドレスまたはホスト名を設定して許可する必要があります。 参加メンバーに適切なプロトコルの許可されたアドレスがない場合、その接続試行は拒否されます。 詳細は、<a class="xref" href="group-replication.html#group-replication-ip-address-permissions" title="18.5.1 グループレプリケーション IP アドレスの権限">セクション18.5.1「グループレプリケーション IP アドレスの権限」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              <code class="literal">group_replication_bootstrap_group</code> を構成すると、グループをブートストラップするかどうかをプラグインに指示します。 この場合、s1 がグループの最初のメンバーであっても、オプションファイルでこの変数を off に設定します。 かわりに、インスタンスの実行中に <code class="literal">group_replication_bootstrap_group</code> を構成して、実際にグループをブートストラップするメンバーが 1 人のみであることを確認します。 
            </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
                <code class="literal">group_replication_bootstrap_group</code> 変数は、グループに属しているあるサーバーインスタンスでのみ有効にする必要があります。通常は、グループを初めてブートストラップするとき (または、グループ全体を停止して再度起動する場合) に有効にします。 グループを複数回ブートストラップする場合 (たとえば、複数のサーバーインスタンスにこのオプションが設定されている場合)、同じ名前の異なる 2 つのグループが存在する人工的な分割ブレーンシナリオを作成できます。 最初のサーバーインスタンスがオンラインになった後は、必ず <code class="literal">group_replication_bootstrap_group=off</code> を設定してください。 
              </p></div></li></ul></div><p>
          グループ内のすべてのサーバーの構成は非常に似ています。 各サーバー (<code class="literal">server_id</code>, <code class="literal">datadir</code>, <code class="literal">group_replication_local_address</code> など) の詳細を変更する必要があります。 これは、このチュートリアルの後半で説明します。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-user-credentials"></a>18.2.1.3 分散リカバリのユーザー資格証明</h4></div></div></div><a class="indexterm" name="idm45563248472048"></a><p>
        グループレプリケーションでは、分散リカバリプロセスを使用して、グループに参加するときにグループメンバーを同期します。 分散リカバリでは、<code class="literal">group_replication_recovery</code> という名前のレプリケーションチャネルを使用して、ドナーのバイナリログから参加メンバーにトランザクションを転送します。 したがって、グループレプリケーションが直接メンバー間レプリケーションチャネルを確立できるように、適切な権限を持つレプリケーションユーザーを設定する必要があります。 MySQL 8.0.17 から使用可能な分散リカバリの一部としてリモートクローニング操作の使用をサポートするようにグループメンバーが設定されている場合、このレプリケーションユーザーはドナーのクローンユーザーとしても使用され、このロールに対する正しい権限も必要です。 分散リカバリの詳細は、<a class="xref" href="group-replication.html#group-replication-distributed-recovery" title="18.4.3 分散リカバリ">セクション18.4.3「分散リカバリ」</a> を参照してください。 
      </p><p>
        すべてのグループメンバーで分散リカバリに同じレプリケーションユーザーを使用する必要があります。 分散リカバリ用のレプリケーションユーザーを作成するプロセスをバイナリログに取得し、分散リカバリを使用してユーザーの作成に使用されるステートメントをレプリケートできます。 または、レプリケーションユーザーを作成する前にバイナリロギングを無効にし、変更が他のサーバーインスタンスに伝播されないようにする場合などは、各メンバーでユーザーを手動で作成することもできます。 これを行う場合は、ユーザーを構成したあとでバイナリロギングを再度有効にしてください。 
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          グループの分散リカバリ接続で SSL を使用する場合は、参加メンバーがドナーに接続する前に、各サーバーにレプリケーションユーザーを作成する必要があります。 分散リカバリ接続用に SSL を設定し、SSL を必要とするレプリケーションユーザーを作成する手順は、<a class="xref" href="group-replication.html#group-replication-distributed-recovery-securing" title="18.5.3 分散リカバリ接続の保護">セクション18.5.3「分散リカバリ接続の保護」</a> を参照してください 
        </p></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          デフォルトでは、MySQL 8 で作成されたユーザーは <a class="xref" href="security.html#caching-sha2-pluggable-authentication" title="6.4.1.2 SHA-2 プラガブル認証のキャッシュ">セクション6.4.1.2「SHA-2 プラガブル認証のキャッシュ」</a> を使用します。 分散リカバリのレプリケーションユーザーがキャッシュ SHA-2 認証プラグインを使用しており、分散リカバリ接続に SSL を使用していない場合、RSA キーペアがパスワード交換に使用されます。 レプリケーションユーザーの公開キーを参加メンバーにコピーするか、リクエスト時に公開キーを提供するようにドナーを構成できます。 これを行う手順は、<a class="xref" href="group-replication.html#group-replication-secure-user" title="18.5.3.1 分散リカバリのためのセキュアなユーザー資格証明">セクション18.5.3.1「分散リカバリのためのセキュアなユーザー資格証明」</a> を参照してください。 
        </p></div><p>
        分散リカバリのレプリケーションユーザーを作成するには、次のステップに従います:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            MySQL サーバーインスタンスを起動し、それにクライアントを接続します。
          </p></li><li class="listitem"><p>
            レプリケーションユーザーをインスタンスごとに個別に作成するためにバイナリロギングを無効にする場合は、次のステートメントを発行します:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET SQL_LOG_BIN=0;</code></strong>
</pre></li><li class="listitem"><p>
            分散リカバリに使用する <code class="literal">REPLICATION SLAVE</code> 権限を持つ MySQL ユーザーを作成し、クローニングをサポートするようにサーバーが設定されている場合は、クローニング操作でドナーとして使用する <code class="literal">BACKUP_ADMIN</code> 権限を作成します。 この例では、パスワード <em class="replaceable"><code>password</code></em> を持つユーザー <em class="replaceable"><code>rpl_user</code></em> が表示されます。 サーバーを構成するときは、適切なユーザー名とパスワードを使用します: 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE USER <em class="replaceable"><code>rpl_user</code></em>@'%' IDENTIFIED BY '<em class="replaceable"><code>password</code></em>';</code></strong>
mysql&gt; <strong class="userinput"><code>GRANT REPLICATION SLAVE ON *.* TO <em class="replaceable"><code>rpl_user</code></em>@'%';</code></strong>
mysql&gt; <strong class="userinput"><code>GRANT BACKUP_ADMIN ON *.* TO <em class="replaceable"><code>rpl_user</code></em>@'%';</code></strong>
mysql&gt; <strong class="userinput"><code>FLUSH PRIVILEGES;</code></strong>
</pre></li><li class="listitem"><p>
            バイナリロギングを無効にした場合は、次のステートメントを発行して、ユーザーを作成した直後に再度有効にします:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET SQL_LOG_BIN=1;</code></strong>
</pre></li><li class="listitem"><p>
            レプリケーションユーザーを作成したら、分散リカバリで使用するユーザー資格証明をサーバーに指定する必要があります。 これを行うには、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23 の場合) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 の場合) を使用して、ユーザー資格証明を <code class="literal">group_replication_recovery</code> チャネルの資格証明として設定します。 または、MySQL 8.0.21 から、<code class="literal">START GROUP_REPLICATION</code> ステートメントで分散リカバリのユーザー資格証明を指定できます。 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> を使用して設定されたユーザー資格証明は、サーバー上のレプリケーションメタデータリポジトリにプレーンテキストで格納されます。 これらは、<code class="literal">group_replication_start_on_boot</code> システム変数が <code class="literal">ON</code> に設定されている場合は自動起動を含め、グループレプリケーションが開始されるたびに適用されます。 
              </p></li><li class="listitem"><p>
                <code class="literal">START GROUP_REPLICATION</code> で指定されたユーザー資格証明はメモリーにのみ保存され、<code class="literal">STOP GROUP_REPLICATION</code> ステートメントまたはサーバーの停止によって削除されます。 <code class="literal">START GROUP_REPLICATION</code> ステートメントを発行して資格証明を再度指定する必要があるため、これらの資格証明を使用してグループレプリケーションを自動的に開始することはできません。 ユーザー資格証明を指定するこの方法は、認可されていないアクセスからグループレプリケーションサーバーを保護するのに役立ちます。 
              </p></li></ul></div><p>
            ユーザー資格証明を提供する各方法のセキュリティへの影響の詳細は、<a class="xref" href="group-replication.html#group-replication-secure-user-provide" title="18.5.3.1.3 レプリケーションユーザー資格証明のセキュアな提供">セクション18.5.3.1.3「レプリケーションユーザー資格証明のセキュアな提供」</a> を参照してください。 <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントを使用してユーザー資格証明を指定する場合は、<em class="replaceable"><code>rpl_user</code></em> および <em class="replaceable"><code>password</code></em> をユーザーの作成時に使用した値に置き換えて、サーバーインスタンスで次のステートメントを発行します: 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO MASTER_USER='<em class="replaceable"><code>rpl_user</code></em>', MASTER_PASSWORD='<em class="replaceable"><code>password</code></em>' \\
		      FOR CHANNEL 'group_replication_recovery';</code></strong>

Or from MySQL 8.0.23:
mysql&gt; <strong class="userinput"><code>CHANGE REPLICATION SOURCE TO SOURCE_USER='<em class="replaceable"><code>rpl_user</code></em>', SOURCE_PASSWORD='<em class="replaceable"><code>password</code></em>' \\
		      FOR CHANNEL 'group_replication_recovery';</code></strong>
      </pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-launching"></a>18.2.1.4 グループレプリケーションの起動</h4></div></div></div><a class="indexterm" name="idm45563248414016"></a><p>
        サーバー s1 を構成して起動したら、Group Replication プラグインをインストールします。 オプションファイルで <code class="literal">plugin_load_add='group_replication.so'</code>を使用した場合、Group Replication プラグインがインストールされ、次のステップに進むことができます。 プラグインを手動でインストールすることを決定した場合は、サーバーに接続して次を発行します: 
      </p><pre class="programlisting"><strong class="userinput"><code>INSTALL PLUGIN group_replication SONAME 'group_replication.so';</code></strong></pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          Group Replication をロードする前に、<code class="literal">mysql.session</code> ユーザーが存在している必要があります。<code class="literal">mysql.session</code> は、MySQL バージョン 8.0.2 で追加されました。 データディクショナリが以前のバージョンを使用して初期化された場合は、MySQL のアップグレード手順を実行する必要があります (<a class="xref" href="installing.html#upgrading" title="2.11 MySQL のアップグレード">セクション2.11「MySQL のアップグレード」</a> を参照)。 アップグレードが実行されていない場合、Group Replication は起動に失敗し、ユーザーがサーバーにアクセスしようとしたときに <span class="errortext">There がエラーメッセージを返します: mysql.session @localhost. ユーザーがサーバーに存在し、mysql_upgrade がサーバー update.</span> の後に実行されたことを確認してください。 
        </p></div><p>
        プラグインが正常にインストールされたことを確認するには、<code class="literal">SHOW PLUGINS;</code>を発行して出力を確認します。 次のように表示されます: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW PLUGINS;</code></strong>
+----------------------------+----------+--------------------+----------------------+-------------+
| Name                       | Status   | Type               | Library              | License     |
+----------------------------+----------+--------------------+----------------------+-------------+
| binlog                     | ACTIVE   | STORAGE ENGINE     | NULL                 | PROPRIETARY |

(...)

| group_replication          | ACTIVE   | GROUP REPLICATION  | group_replication.so | PROPRIETARY |
+----------------------------+----------+--------------------+----------------------+-------------+</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-bootstrap"></a>18.2.1.5 グループのブートストラップ</h4></div></div></div><p>
        グループを初めて起動するプロセスはブートストラップと呼ばれます。 グループをブートストラップするには、<code class="literal">group_replication_bootstrap_group</code> システム変数を使用します。 ブートストラップは、単一のサーバー (グループを起動するサーバー) によって一度のみ実行する必要があります。 このため、<code class="literal">group_replication_bootstrap_group</code> オプションの値がインスタンスオプションファイルに格納されませんでした。 オプションファイルに保存されている場合、サーバーの再起動時に同じ名前の別のグループが自動的にブートストラップされます。 これにより、同じ名前を持つ 2 つの異なるグループが作成されます。 このオプションを <code class="literal">ON</code> に設定してプラグインを停止および再起動する場合も、同じ推論が適用されます。 したがって、グループを安全にブートストラップするには、s1 に接続し、次のステートメントを発行します: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL group_replication_bootstrap_group=ON;</code></strong>
mysql&gt; <strong class="userinput"><code>START GROUP_REPLICATION;</code></strong>
mysql&gt; <strong class="userinput"><code>SET GLOBAL group_replication_bootstrap_group=OFF;</code></strong>
</pre><p>
        または、<code class="literal">START GROUP_REPLICATION</code> ステートメント (MySQL 8.0.21 から実行可能) で分散リカバリ用のユーザー資格証明を指定する場合は、次のステートメントを発行します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL group_replication_bootstrap_group=ON;</code></strong>
mysql&gt; <strong class="userinput"><code>START GROUP_REPLICATION USER='<em class="replaceable"><code>rpl_user</code></em>', PASSWORD='<em class="replaceable"><code>password</code></em>';</code></strong>
mysql&gt; <strong class="userinput"><code>SET GLOBAL group_replication_bootstrap_group=OFF;</code></strong>
</pre><p>
        <code class="literal">START GROUP_REPLICATION</code> ステートメントが戻ると、グループは起動しています。 グループが作成され、その中に 1 つのメンバーが存在することを確認できます: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.replication_group_members;</code></strong>
+---------------------------+--------------------------------------+-------------+-------------+---------------+
| CHANNEL_NAME              | MEMBER_ID                            | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE  |
+---------------------------+--------------------------------------+-------------+-------------+---------------+
| group_replication_applier | ce9be252-2b71-11e6-b8f4-00212844f856 |   s1        |       3306  | ONLINE        |
+---------------------------+--------------------------------------+-------------+-------------+---------------+
</pre><p>
        このテーブルの情報は、一意の識別子 <code class="literal">ce9be252-2b71-11e6-b8f4-00212844f856</code> を持つメンバーがグループに存在し、それが <code class="literal">ONLINE</code> であり、<code class="literal">s1</code> がポート <code class="literal">3306</code> でクライアント接続をリスニングしていることを確認します。
      </p><p>
        サーバーが実際にはグループ内にあり、ロードを処理できることを示す目的で、テーブルを作成し、そのテーブルにコンテンツを追加します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE DATABASE test;</code></strong>
mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT PRIMARY KEY, c2 TEXT NOT NULL);</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES (1, 'Luis');</code></strong>
</pre><p>
        テーブル <code class="literal">t1</code> とバイナリログの内容を確認します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM t1;</code></strong>
+----+------+
| c1 | c2   |
+----+------+
|  1 | Luis |
+----+------+

mysql&gt; <strong class="userinput"><code>SHOW BINLOG EVENTS;</code></strong>
+---------------+-----+----------------+-----------+-------------+--------------------------------------------------------------------+
| Log_name      | Pos | Event_type     | Server_id | End_log_pos | Info                                                               |
+---------------+-----+----------------+-----------+-------------+--------------------------------------------------------------------+
| binlog.000001 |   4 | Format_desc    |         1 |         123 | Server ver: 8.0.25-log, Binlog ver: 4                              |
| binlog.000001 | 123 | Previous_gtids |         1 |         150 |                                                                    |
| binlog.000001 | 150 | Gtid           |         1 |         211 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1'  |
| binlog.000001 | 211 | Query          |         1 |         270 | BEGIN                                                              |
| binlog.000001 | 270 | View_change    |         1 |         369 | view_id=14724817264259180:1                                        |
| binlog.000001 | 369 | Query          |         1 |         434 | COMMIT                                                             |
| binlog.000001 | 434 | Gtid           |         1 |         495 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:2'  |
| binlog.000001 | 495 | Query          |         1 |         585 | CREATE DATABASE test                                               |
| binlog.000001 | 585 | Gtid           |         1 |         646 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:3'  |
| binlog.000001 | 646 | Query          |         1 |         770 | use `test`; CREATE TABLE t1 (c1 INT PRIMARY KEY, c2 TEXT NOT NULL) |
| binlog.000001 | 770 | Gtid           |         1 |         831 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:4'  |
| binlog.000001 | 831 | Query          |         1 |         899 | BEGIN                                                              |
| binlog.000001 | 899 | Table_map      |         1 |         942 | table_id: 108 (test.t1)                                            |
| binlog.000001 | 942 | Write_rows     |         1 |         984 | table_id: 108 flags: STMT_END_F                                    |
| binlog.000001 | 984 | Xid            |         1 |        1011 | COMMIT /* xid=38 */                                                |
+---------------+-----+----------------+-----------+-------------+--------------------------------------------------------------------+
</pre><p>
        前述のように、データベースとテーブルオブジェクトが作成され、対応する DDL ステートメントがバイナリログに書き込まれました。 また、データはテーブルに挿入されてバイナリログに書き込まれたため、ドナーのバイナリログからの状態転送によって分散回復に使用できます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-adding-instances"></a>18.2.1.6 グループへのインスタンスの追加</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-adding-a-second-instance">18.2.1.6.1 2 番目のインスタンスの追加</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-adding-additional-instances">18.2.1.6.2 インスタンスの追加</a></span></dt></dl></div><a class="indexterm" name="idm45563248362576"></a><p>
        この時点で、グループにはサーバー s1 というメンバーがあり、サーバー s1 にはデータが含まれています。 ここで、以前に構成した他の 2 つのサーバーを追加して、グループを拡張します。 
      </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-adding-a-second-instance"></a>18.2.1.6.1 2 番目のインスタンスの追加</h5></div></div></div><a class="indexterm" name="idm45563248358496"></a><p>
          別のインスタンスであるサーバー s2 を追加するには、最初にその構成ファイルを作成します。 この構成は、<code class="literal">server_id</code> などを除き、サーバー s1 に使用される構成と似ています。 これらの異なる行は、次のリストで強調表示されています。 
        </p><pre class="programlisting">[mysqld]

#
# Disable other storage engines
#
disabled_storage_engines="MyISAM,BLACKHOLE,FEDERATED,ARCHIVE,MEMORY"

#
# Replication configuration parameters
#
server_id=2
gtid_mode=ON
enforce_gtid_consistency=ON
binlog_checksum=NONE           # Not needed from 8.0.21

#
# Group Replication configuration
#
plugin_load_add='group_replication.so'
group_replication_group_name="aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa"
group_replication_start_on_boot=off
group_replication_local_address= "s2:33061"
group_replication_group_seeds= "s1:33061,s2:33061,s3:33061"
group_replication_bootstrap_group= off
</pre><p>
          サーバー s1 の手順と似ていますが、サーバーを起動するオプションファイルが配置されています。 次に、分散リカバリ資格証明を次のように構成します。 これらのコマンドは、ユーザーがグループ内で共有されるため、サーバー s1 の設定時に使用されるコマンドと同じです。 このメンバーは、<a class="xref" href="group-replication.html#group-replication-user-credentials" title="18.2.1.3 分散リカバリのユーザー資格証明">セクション18.2.1.3「分散リカバリのユーザー資格証明」</a> で同じレプリケーションユーザーが構成されている必要があります。 分散リカバリを使用してすべてのメンバーでユーザーを構成する場合、s2 がシード s1 に接続すると、レプリケーションユーザーは s1 にレプリケートまたはクローニングされます。 s1 でユーザー資格証明を構成したときにバイナリロギングを有効にしておらず、リモートクローニング操作が状態転送に使用されない場合は、s2 でレプリケーションユーザーを作成する必要があります。 この場合は、s2 に接続して次のコマンドを発行します: 
        </p><pre class="programlisting"><strong class="userinput"><code>SET SQL_LOG_BIN=0;</code></strong>
<strong class="userinput"><code>CREATE USER <em class="replaceable"><code>rpl_user</code></em>@'%' IDENTIFIED BY '<em class="replaceable"><code>password</code></em>';</code></strong>
<strong class="userinput"><code>GRANT REPLICATION SLAVE ON *.* TO <em class="replaceable"><code>rpl_user</code></em>@'%';</code></strong>
<strong class="userinput"><code>GRANT BACKUP_ADMIN ON *.* TO <em class="replaceable"><code>rpl_user</code></em>@'%';</code></strong>
<strong class="userinput"><code>FLUSH PRIVILEGES;</code></strong>
<strong class="userinput"><code>SET SQL_LOG_BIN=1;</code></strong>
</pre><p>
          <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントを使用してユーザー資格証明を指定する場合は、その後に次のステートメントを発行します:
        </p><pre class="programlisting"><strong class="userinput"><code>CHANGE MASTER TO MASTER_USER='<em class="replaceable"><code>rpl_user</code></em>', MASTER_PASSWORD='<em class="replaceable"><code>password</code></em>' \\
	FOR CHANNEL 'group_replication_recovery';</code></strong>

Or from MySQL 8.0.23:
<strong class="userinput"><code>CHANGE REPLICATION SOURCE TO SOURCE_USER='<em class="replaceable"><code>rpl_user</code></em>', SOURCE_PASSWORD='<em class="replaceable"><code>password</code></em>' \\
	FOR CHANNEL 'group_replication_recovery';</code></strong>
</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">ヒント</div><p>
            MySQL 8 のデフォルトであるキャッシュ SHA-2 認証プラグインを使用している場合は、<a class="xref" href="group-replication.html#group-replication-caching-sha2-user-credentials" title="18.5.3.1.1 キャッシュ SHA-2 認証プラグインを使用するレプリケーションユーザー">セクション18.5.3.1.1「キャッシュ SHA-2 認証プラグインを使用するレプリケーションユーザー」</a> を参照してください。
          </p></div><p>
          必要に応じて、Group Replication プラグインをインストールします。<a class="xref" href="group-replication.html#group-replication-launching" title="18.2.1.4 グループレプリケーションの起動">セクション18.2.1.4「グループレプリケーションの起動」</a> を参照してください。
        </p><p>
          グループレプリケーションを開始し、s2 がグループに参加するプロセスを開始します。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>START GROUP_REPLICATION;</code></strong>
</pre><p>
          または、<code class="literal">START GROUP_REPLICATION</code> ステートメント (MySQL 8.0.21 から) で分散リカバリ用のユーザー資格証明を指定する場合は、次の手順を実行します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>START GROUP_REPLICATION USER='<em class="replaceable"><code>rpl_user</code></em>', PASSWORD='<em class="replaceable"><code>password</code></em>';</code></strong>
</pre><p>
          s1 で実行されたステップと同じステップとは異なり、グループはすでに存在するため、グループをブートストラップする必要はありません。 つまり、s2 <code class="literal">group_replication_bootstrap_group</code> では <code class="literal">OFF</code> に設定されており、グループレプリケーションを開始する前に <code class="literal">SET GLOBAL group_replication_bootstrap_group=ON;</code>を発行しません。これは、グループがすでにサーバー s1 によって作成およびブートストラップされているためです。 この時点で、s2 は既存のグループにのみ追加する必要があります。 
        </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">ヒント</div><p>
            グループレプリケーションが正常に開始され、サーバーがグループに参加すると、<code class="literal">super_read_only</code> 変数がチェックされます。 メンバー構成ファイルで <code class="literal">super_read_only</code> を ON に設定すると、なんらかの理由でグループレプリケーションの起動時に失敗したサーバーがトランザクションを受け入れないようにすることができます。 サーバーが読取り/書込みインスタンスとしてグループに参加する必要がある場合 (たとえば、単一プライマリグループのプライマリまたはマルチプライマリグループのメンバーとして)、<code class="literal">super_read_only</code> 変数が ON に設定されていると、グループへの参加時に OFF に設定されます。 
          </p></div><p>
          <code class="literal">performance_schema.replication_group_members</code> テーブルを再度チェックすると、グループに 2 つの <code class="literal">ONLINE</code> サーバーが存在することがわかります。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.replication_group_members;</code></strong>
+---------------------------+--------------------------------------+-------------+-------------+---------------+
| CHANNEL_NAME              | MEMBER_ID                            | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE  |
+---------------------------+--------------------------------------+-------------+-------------+---------------+
| group_replication_applier | 395409e1-6dfa-11e6-970b-00212844f856 |   s1        |        3306 | ONLINE        |
| group_replication_applier | ac39f1e6-6dfa-11e6-a69d-00212844f856 |   s2        |        3306 | ONLINE        |
+---------------------------+--------------------------------------+-------------+-------------+---------------+
</pre><p>
          s2 がグループに参加しようとすると、<a class="xref" href="group-replication.html#group-replication-distributed-recovery" title="18.4.3 分散リカバリ">セクション18.4.3「分散リカバリ」</a> は、s1 が適用したのと同じトランザクションを s2 が適用したことを確認しました。 このプロセスが完了すると、s2 はグループをメンバーとして参加でき、この時点で <code class="literal">ONLINE</code> としてマークされます。 つまり、サーバー s1 を自動的に捕捉しておく必要があります。 s2 が <code class="literal">ONLINE</code> になると、グループとのトランザクションの処理が開始されます。 次のように、s2 がサーバー s1 と実際に同期されていることを確認します。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW DATABASES LIKE 'test';</code></strong>
+-----------------+
| Database (test) |
+-----------------+
| test            |
+-----------------+

mysql&gt; <strong class="userinput"><code>SELECT * FROM test.t1;</code></strong>
+----+------+
| c1 | c2   |
+----+------+
|  1 | Luis |
+----+------+

mysql&gt; <strong class="userinput"><code>SHOW BINLOG EVENTS;</code></strong>
+---------------+------+----------------+-----------+-------------+--------------------------------------------------------------------+
| Log_name      | Pos  | Event_type     | Server_id | End_log_pos | Info                                                               |
+---------------+------+----------------+-----------+-------------+--------------------------------------------------------------------+
| binlog.000001 |    4 | Format_desc    |         2 |         123 | Server ver: 8.0.25-log, Binlog ver: 4                              |
| binlog.000001 |  123 | Previous_gtids |         2 |         150 |                                                                    |
| binlog.000001 |  150 | Gtid           |         1 |         211 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1'  |
| binlog.000001 |  211 | Query          |         1 |         270 | BEGIN                                                              |
| binlog.000001 |  270 | View_change    |         1 |         369 | view_id=14724832985483517:1                                        |
| binlog.000001 |  369 | Query          |         1 |         434 | COMMIT                                                             |
| binlog.000001 |  434 | Gtid           |         1 |         495 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:2'  |
| binlog.000001 |  495 | Query          |         1 |         585 | CREATE DATABASE test                                               |
| binlog.000001 |  585 | Gtid           |         1 |         646 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:3'  |
| binlog.000001 |  646 | Query          |         1 |         770 | use `test`; CREATE TABLE t1 (c1 INT PRIMARY KEY, c2 TEXT NOT NULL) |
| binlog.000001 |  770 | Gtid           |         1 |         831 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:4'  |
| binlog.000001 |  831 | Query          |         1 |         890 | BEGIN                                                              |
| binlog.000001 |  890 | Table_map      |         1 |         933 | table_id: 108 (test.t1)                                            |
| binlog.000001 |  933 | Write_rows     |         1 |         975 | table_id: 108 flags: STMT_END_F                                    |
| binlog.000001 |  975 | Xid            |         1 |        1002 | COMMIT /* xid=30 */                                                |
| binlog.000001 | 1002 | Gtid           |         1 |        1063 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:5'  |
| binlog.000001 | 1063 | Query          |         1 |        1122 | BEGIN                                                              |
| binlog.000001 | 1122 | View_change    |         1 |        1261 | view_id=14724832985483517:2                                        |
| binlog.000001 | 1261 | Query          |         1 |        1326 | COMMIT                                                             |
+---------------+------+----------------+-----------+-------------+--------------------------------------------------------------------+
</pre><p>
          前述のように、2 つ目のサーバーがグループに追加され、サーバー s1 から変更が自動的にレプリケートされました。 つまり、s2 がグループに参加した時点までに s1 で適用されたトランザクションは、s2 にレプリケートされています。 
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-adding-additional-instances"></a>18.2.1.6.2 インスタンスの追加</h5></div></div></div><a class="indexterm" name="idm45563248300496"></a><p>
          グループへのインスタンスの追加は、サーバー s2 の場合と同様に構成を変更する必要があることを除き、基本的には 2 つ目のサーバーの追加と同じステップのシーケンスです。 必要なコマンドを要約するには: 
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              構成ファイルを作成します。
            </p><pre class="programlisting">[mysqld]

#
# Disable other storage engines
#
disabled_storage_engines="MyISAM,BLACKHOLE,FEDERATED,ARCHIVE,MEMORY"

#
# Replication configuration parameters
#
server_id=3
gtid_mode=ON
enforce_gtid_consistency=ON
binlog_checksum=NONE           # Not needed from 8.0.21

#
# Group Replication configuration
#
plugin_load_add='group_replication.so'
group_replication_group_name="aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa"
group_replication_start_on_boot=off
group_replication_local_address= "s3:33061"
group_replication_group_seeds= "s1:33061,s2:33061,s3:33061"
group_replication_bootstrap_group= off
</pre></li><li class="listitem"><p>
              サーバーを起動して接続します。 分散リカバリ用のレプリケーションユーザーを作成します。 
            </p><pre class="programlisting"><strong class="userinput"><code>SET SQL_LOG_BIN=0;</code></strong>
<strong class="userinput"><code>CREATE USER <em class="replaceable"><code>rpl_user</code></em>@'%' IDENTIFIED BY '<em class="replaceable"><code>password</code></em>';</code></strong>
<strong class="userinput"><code>GRANT REPLICATION SLAVE ON *.* TO <em class="replaceable"><code>rpl_user</code></em>@'%';</code></strong>
<strong class="userinput"><code>GRANT BACKUP_ADMIN ON *.* TO <em class="replaceable"><code>rpl_user</code></em>@'%';</code></strong>
<strong class="userinput"><code>FLUSH PRIVILEGES;</code></strong>
<strong class="userinput"><code>SET SQL_LOG_BIN=1;</code></strong>
</pre><p>
              <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントを使用してユーザー資格証明を指定する場合は、その後に次のステートメントを発行します:
            </p><pre class="programlisting"><strong class="userinput"><code>CHANGE MASTER TO MASTER_USER='<em class="replaceable"><code>rpl_user</code></em>', MASTER_PASSWORD='<em class="replaceable"><code>password</code></em>' \\
	FOR CHANNEL 'group_replication_recovery';</code></strong>

Or from MySQL 8.0.23:
<strong class="userinput"><code>CHANGE REPLICATION SOURCE TO SOURCE_USER='<em class="replaceable"><code>rpl_user</code></em>', SOURCE_PASSWORD='<em class="replaceable"><code>password</code></em>' \\
	FOR CHANNEL 'group_replication_recovery';</code></strong></pre></li><li class="listitem"><p>
              必要に応じて、Group Replication プラグインをインストールします。
            </p><pre class="programlisting"><strong class="userinput"><code>
INSTALL PLUGIN group_replication SONAME 'group_replication.so';
</code></strong></pre></li><li class="listitem"><p>
              グループレプリケーションを開始します。
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>START GROUP_REPLICATION;</code></strong>
</pre><p>
              または、<code class="literal">START GROUP_REPLICATION</code> ステートメント (MySQL 8.0.21 から) で分散リカバリ用のユーザー資格証明を指定する場合は、次の手順を実行します:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>START GROUP_REPLICATION USER='<em class="replaceable"><code>rpl_user</code></em>', PASSWORD='<em class="replaceable"><code>password</code></em>';</code></strong>
</pre></li></ol></div><p>
          この時点で、s3 は起動して実行され、グループに参加して、グループ内の他のサーバーと捕捉されています。 <code class="literal">performance_schema.replication_group_members</code> テーブルを再度参照して、これが当てはまることを確認します。 
        </p><pre class="programlisting">mysql&gt; SELECT * FROM performance_schema.replication_group_members;
+---------------------------+--------------------------------------+-------------+-------------+---------------+
| CHANNEL_NAME              | MEMBER_ID                            | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE  |
+---------------------------+--------------------------------------+-------------+-------------+---------------+
| group_replication_applier | 395409e1-6dfa-11e6-970b-00212844f856 |   s1        |       3306  | ONLINE        |
| group_replication_applier | 7eb217ff-6df3-11e6-966c-00212844f856 |   s3        |       3306  | ONLINE        |
| group_replication_applier | ac39f1e6-6dfa-11e6-a69d-00212844f856 |   s2        |       3306  | ONLINE        |
+---------------------------+--------------------------------------+-------------+-------------+---------------+
</pre><p>
          サーバー s2 またはサーバー s1 でこの同じクエリーを発行すると、同じ結果になります。 また、サーバー s3 が捕捉されたことを確認できます: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW DATABASES LIKE 'test';</code></strong>
+-----------------+
| Database (test) |
+-----------------+
| test            |
+-----------------+

mysql&gt; <strong class="userinput"><code>SELECT * FROM test.t1;</code></strong>
+----+------+
| c1 | c2   |
+----+------+
|  1 | Luis |
+----+------+

mysql&gt; <strong class="userinput"><code>SHOW BINLOG EVENTS;</code></strong>
+---------------+------+----------------+-----------+-------------+--------------------------------------------------------------------+
| Log_name      | Pos  | Event_type     | Server_id | End_log_pos | Info                                                               |
+---------------+------+----------------+-----------+-------------+--------------------------------------------------------------------+
| binlog.000001 |    4 | Format_desc    |         3 |         123 | Server ver: 8.0.25-log, Binlog ver: 4                              |
| binlog.000001 |  123 | Previous_gtids |         3 |         150 |                                                                    |
| binlog.000001 |  150 | Gtid           |         1 |         211 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1'  |
| binlog.000001 |  211 | Query          |         1 |         270 | BEGIN                                                              |
| binlog.000001 |  270 | View_change    |         1 |         369 | view_id=14724832985483517:1                                        |
| binlog.000001 |  369 | Query          |         1 |         434 | COMMIT                                                             |
| binlog.000001 |  434 | Gtid           |         1 |         495 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:2'  |
| binlog.000001 |  495 | Query          |         1 |         585 | CREATE DATABASE test                                               |
| binlog.000001 |  585 | Gtid           |         1 |         646 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:3'  |
| binlog.000001 |  646 | Query          |         1 |         770 | use `test`; CREATE TABLE t1 (c1 INT PRIMARY KEY, c2 TEXT NOT NULL) |
| binlog.000001 |  770 | Gtid           |         1 |         831 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:4'  |
| binlog.000001 |  831 | Query          |         1 |         890 | BEGIN                                                              |
| binlog.000001 |  890 | Table_map      |         1 |         933 | table_id: 108 (test.t1)                                            |
| binlog.000001 |  933 | Write_rows     |         1 |         975 | table_id: 108 flags: STMT_END_F                                    |
| binlog.000001 |  975 | Xid            |         1 |        1002 | COMMIT /* xid=29 */                                                |
| binlog.000001 | 1002 | Gtid           |         1 |        1063 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:5'  |
| binlog.000001 | 1063 | Query          |         1 |        1122 | BEGIN                                                              |
| binlog.000001 | 1122 | View_change    |         1 |        1261 | view_id=14724832985483517:2                                        |
| binlog.000001 | 1261 | Query          |         1 |        1326 | COMMIT                                                             |
| binlog.000001 | 1326 | Gtid           |         1 |        1387 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:6'  |
| binlog.000001 | 1387 | Query          |         1 |        1446 | BEGIN                                                              |
| binlog.000001 | 1446 | View_change    |         1 |        1585 | view_id=14724832985483517:3                                        |
| binlog.000001 | 1585 | Query          |         1 |        1650 | COMMIT                                                             |
+---------------+------+----------------+-----------+-------------+--------------------------------------------------------------------+
</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-deploying-locally"></a>18.2.2 グループレプリケーションのローカルでのデプロイ</h3></div></div></div><p>
      グループレプリケーションをデプロイする最も一般的な方法は、複数のサーバーインスタンスを使用して高可用性を提供することです。 テスト目的などで、グループレプリケーションをローカルにデプロイすることもできます。 このセクションでは、グループレプリケーションをローカルにデプロイする方法について説明します。 
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        グループレプリケーションは、高可用性が保証されるため、通常は複数のホストにデプロイされます。 すべての MySQL サーバーインスタンスが同じ単一ホスト上で実行されているため、このセクションの手順は本番デプロイメントには適していません。 このホストに障害が発生した場合、グループ全体が失敗します。 したがって、この情報はテスト目的で使用する必要があり、本番環境では使用しないでください。 
      </p></div><p>
      このセクションでは、1 つの物理マシン上に 3 つの MySQL Server インスタンスを持つレプリケーショングループを作成する方法について説明します。 これは、3 つのデータディレクトリ (サーバーインスタンスごとに 1 つ) が必要であり、各インスタンスを個別に構成する必要があることを意味します。 これは - この手順では、MySQL Server がダウンロードおよび解凍されていることを前提としています - <code class="literal">mysql-8.0</code> という名前のディレクトリに格納します。 各 MySQL サーバーインスタンスには、特定のデータディレクトリが必要です。 <code class="literal">data</code> という名前のディレクトリを作成し、そのディレクトリに各サーバーインスタンス (s1、s2 および s3 など) のサブディレクトリを作成して、それぞれを初期化します。 
    </p><pre class="programlisting"><strong class="userinput"><code>mysql-8.0/bin/mysqld --initialize-insecure --basedir=$PWD/mysql-8.0 --datadir=$PWD/data/s1</code></strong>
<strong class="userinput"><code>mysql-8.0/bin/mysqld --initialize-insecure --basedir=$PWD/mysql-8.0 --datadir=$PWD/data/s2</code></strong>
<strong class="userinput"><code>mysql-8.0/bin/mysqld --initialize-insecure --basedir=$PWD/mysql-8.0 --datadir=$PWD/data/s3</code></strong>
</pre><p>
      <code class="literal">data/s1</code>, <code class="literal">data/s2</code>, <code class="literal">data/s3</code> 内には初期化されたデータディレクトリがあり、mysql システムデータベースや関連テーブルなどが含まれています。 初期化手順の詳細は、<a class="xref" href="installing.html#data-directory-initialization" title="2.10.1 データディレクトリの初期化">セクション2.10.1「データディレクトリの初期化」</a> を参照してください。 
    </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
        本番環境では <code class="literal">-initialize-insecure</code> を使用しないでください。チュートリアルを簡略化するためにここでのみ使用します。 セキュリティ設定の詳細は、<a class="xref" href="group-replication.html#group-replication-security" title="18.5 グループレプリケーションセキュリティ">セクション18.5「グループレプリケーションセキュリティ」</a> を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="configure-local-group-members"></a>ローカルグループレプリケーションメンバーの構成</h4></div></div></div><p>
        <a class="xref" href="group-replication.html#group-replication-configuring-instances" title="18.2.1.2 グループレプリケーション用のインスタンスの構成">セクション18.2.1.2「グループレプリケーション用のインスタンスの構成」</a> をフォローしている場合、前のセクションで追加したデータディレクトリの構成を追加する必要があります。 例: 
      </p><pre class="programlisting">[mysqld]

# server configuration
datadir=&lt;full_path_to_data&gt;/data/s1
basedir=&lt;full_path_to_bin&gt;/mysql-8.0/

port=24801
socket=&lt;full_path_to_sock_dir&gt;/s1.sock</pre><p>
        これらの設定では、以前に作成したデータディレクトリと、サーバーが受信接続のリスニングを開始するポートを使用するように MySQL サーバーを構成します。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          このチュートリアルでは、3 つのサーバーインスタンスが同じホスト名を使用するため、24801 のデフォルト以外のポートが使用されます。 3 つの異なるマシンがあるセットアップでは、これは必要ありません。 
        </p></div><p>
        グループレプリケーションでは、メンバー間のネットワーク接続が必要です。つまり、各メンバーは他のすべてのメンバーのネットワークアドレスを解決できる必要があります。 たとえば、このチュートリアルでは、3 つのインスタンスすべてが 1 つのマシンで実行されるため、メンバーが相互に接続できるように、<code class="literal">report_host=127.0.0.1</code> などのオプションファイルに行を追加できます。 
      </p><p>
        その後、各メンバーは <code class="literal">group_replication_local_address</code> 上の他のメンバーに接続できる必要があります。 たとえば、メンバー s1 のオプションファイルで、次のように追加します: 
      </p><pre class="programlisting">group_replication_local_address= "127.0.0.1:24901"
group_replication_group_seeds= "127.0.0.1:24901,127.0.0.1:24902,127.0.0.1:24903"
</pre><p>
        これにより、シードメンバーとの内部グループ通信にポート 24901 を使用するように s1 が構成されます。 グループに追加するサーバーインスタンスごとに、メンバーのオプションファイルでこれらの変更を行います。 メンバーごとに一意のアドレスを指定する必要があるため、<code class="literal">group_replication_local_address</code> のインスタンスごとに一意のポートを使用します。 通常、すべてのメンバーを、グループに参加しており、グループで処理されたトランザクションを取得していないメンバーのシードとして機能させる必要があります。 この場合は、前述のように、すべてのポートを <code class="literal">group_replication_group_seeds</code> に追加します。 
      </p><p>
        <a class="xref" href="group-replication.html#group-replication-deploying-in-single-primary-mode" title="18.2.1 単一プライマリモードでのグループレプリケーションのデプロイ">セクション18.2.1「単一プライマリモードでのグループレプリケーションのデプロイ」</a> の残りのステップは、この方法でローカルにデプロイしたグループにも同様に適用されます。
      </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="group-replication-monitoring"></a>18.3 グループレプリケーションの監視</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-server-states">18.3.1 グループレプリケーションサーバーの状態</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-replication-group-members">18.3.2 replication_group_members テーブル</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-replication-group-member-stats">18.3.3 replication_group_member_stats テーブル</a></span></dt></dl></div><a class="indexterm" name="idm45563248218992"></a><p>
    <a class="ulink" href="performance-schema-quick-start" target="_top">「パフォーマンススキーマ」</a>が有効になっている場合は、「パフォーマンススキーマ」テーブルを使用してグループレプリケーションを監視します。 グループレプリケーションにより、次のテーブルが追加されます: 
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">performance_schema.replication_group_member_stats</code>
      </p></li><li class="listitem"><p>
        <code class="literal">performance_schema.replication_group_members</code>
      </p></li></ul></div><p>
    これらのパフォーマンススキーマレプリケーションテーブルには、グループレプリケーションに関する情報も表示されます:
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">performance_schema.replication_connection_status</code> には、グループから受信してアプライヤキュー (リレーログ) にキューに入れられたトランザクションなど、グループレプリケーションに関する情報が表示されます。
      </p></li><li class="listitem"><p>
        <code class="literal">performance_schema.replication_applier_status</code> には、Group Replication 関連のチャネルおよびスレッドの状態が表示されます。トランザクションを適用するワーカースレッドが多数ある場合は、ワーカーテーブルを使用して、各ワーカースレッドの実行内容を監視することもできます。
      </p></li></ul></div><p>
    Group Replication プラグインによって作成されるレプリケーションチャネルの名前は次のとおりです:
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">group_replication_recovery</code> - このチャネルは、分散リカバリフェーズに関連するレプリケーション変更に使用されます。
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_applier</code> - このチャネルは、グループからの着信変更に使用されます。 これは、グループから直接取得したトランザクションを適用するために使用されるチャネルです。 
      </p></li></ul></div><p>
    MySQL 8.0.21 からは、エラー以外の状況のグループレプリケーションライフサイクルイベントはシステムメッセージとして分類され、レプリケーショングループメンバーのサーバーエラーログに常に記録されます。 この情報を使用して、レプリケーショングループ内のサーバーメンバーシップの履歴を確認できます。 以前のリリースでは、エラー以外の状況のグループレプリケーションライフサイクルイベントは情報メッセージとして分類され、サーバーに <code class="literal">log_error_verbosity</code> レベル 3 を指定することでエラーログに追加できました。 
  </p><p>
    グループ全体に影響するライフサイクルイベントの中には、グループで <code class="literal">ONLINE</code> ステータスになった新しいメンバーやプライマリ選択など、すべてのグループメンバーに記録されるものがあります。 他のイベントは、メンバーで有効化または無効化されているスーパー読取り専用モードやグループを離れたメンバーなど、発生したメンバーにのみ記録されます。 頻繁に発生した場合に問題を示すことができる多数のライフサイクルイベントは、メンバーが到達不能になり再度到達可能になるなどの警告メッセージとしてログに記録され、メンバーはバイナリログまたはリモートクローニング操作からの状態転送によって分散リカバリを開始します。 
  </p><p>
    次の各セクションでは、グループレプリケーションで使用可能な監視情報を解釈する方法について説明します。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-server-states"></a>18.3.1 グループレプリケーションサーバーの状態</h3></div></div></div><a class="indexterm" name="idm45563248194528"></a><p>
      サーバーインスタンスには様々な状態があります。 サーバーが適切に通信している場合、すべてのサーバーで同じ状態が報告されます。 ただし、ネットワークパーティションがある場合、またはサーバーがグループから離れる場合は、クエリー対象のサーバーに応じて異なる情報がレポートされる可能性があります。 サーバーがグループを離れた場合、他のサーバーの状態に関する更新された情報をレポートすることはできません。 クォーラムが失われるようなパーティションがある場合、サーバーはそれ自体を調整できません。 その結果、異なるサーバーのステータスを推測できません。 したがって、状態を推測するのではなく、一部のサーバーにアクセスできないことが報告されます。 
    </p><div class="table"><a name="idm45563248190400"></a><p class="title"><b>表 18.1 サーバーの状態</b></p><div class="table-contents"><table><col style="width: 38%"><col style="width: 50%"><col style="width: 12%"><thead><tr>
          <th scope="col"><p>
              Field
            </p></th>
          <th scope="col"><p>
              説明
            </p></th>
          <th scope="col"><p>
              グループ同期済
            </p></th>
        </tr></thead><tbody><tr>
          <th scope="row"><p>
              <code class="literal">ONLINE</code>
            </p></th>
          <td><p>
              メンバーは、完全に機能するグループメンバーとして機能する準備ができています。つまり、クライアントはトランザクションの接続および実行を開始できます。
            </p></td>
          <td><p>
              はい
            </p></td>
        </tr><tr>
          <th scope="row"><p>
              <code class="literal">RECOVERING</code>
            </p></th>
          <td><p>
              メンバーはグループのアクティブメンバーになる処理中で、現在リカバリプロセスを実行中で、ドナーから状態転送を受信しています。
            </p></td>
          <td><p>
              いいえ
            </p></td>
        </tr><tr>
          <th scope="row"><p>
              <code class="literal">OFFLINE</code>
            </p></th>
          <td><p>
              Group Replication プラグインがロードされましたが、メンバーはどのグループにも属していません。
            </p></td>
          <td><p>
              いいえ
            </p></td>
        </tr><tr>
          <th scope="row"><p>
              <code class="literal">ERROR</code>
            </p></th>
          <td><p>
              メンバーはエラー状態であり、グループメンバーとして正しく機能していません。 <code class="literal">group_replication_exit_state_action</code> によって設定された終了アクションに応じて、メンバーは読取り専用モード (<code class="literal">super_read_only=ON</code>) であり、オフラインモード (<code class="literal">offline_mode=ON</code>) にすることもできます。 <code class="literal">OFFLINE_MODE</code> 終了アクションに続くオフラインモードのサーバーは、<code class="literal">OFFLINE</code> ではなく <code class="literal">ERROR</code> ステータスで表示されることに注意してください。 終了アクションが <code class="literal">ABORT_SERVER</code> のサーバーが停止し、グループのビューから削除されます。 
            </p></td>
          <td><p>
              いいえ
            </p></td>
        </tr><tr>
          <th scope="row"><p>
              <code class="literal">UNREACHABLE</code>
            </p></th>
          <td><p>
              ローカル障害検出機能は、たとえば切断されたために特定のサーバーにアクセスできないと疑われる場合は常に、そのサーバーの状態を <code class="literal">UNREACHABLE</code> として表示します。
            </p></td>
          <td><p>
              いいえ
            </p></td>
        </tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-replication-group-members"></a>18.3.2 replication_group_members テーブル</h3></div></div></div><a class="indexterm" name="idm45563248149488"></a><p>
      <code class="literal">performance_schema.replication_group_members</code> テーブルは、グループのメンバーである様々なサーバーインスタンスのステータスの監視に使用されます。 新しいメンバーが結合されたときにグループの構成が動的に変更された場合など、ビューが変更されるたびにテーブルの情報が更新されます。 その時点で、サーバーはメタデータの一部を交換して同期し、連携を続行します。 この情報は、レプリケーショングループのメンバーであるすべてのサーバーインスタンス間で共有されるため、すべてのグループメンバーに関する情報を任意のメンバーからクエリーすることができます。 このテーブルを使用して、レプリケーショングループの状態の高レベルビューを取得できます。たとえば、次のように発行します: 
    </p><pre class="programlisting"><strong class="userinput"><code>SELECT * FROM performance_schema.replication_group_members;</code></strong>
+---------------------------+--------------------------------------+--------------+-------------+--------------+-------------+----------------+
| CHANNEL_NAME              | MEMBER_ID	                           | MEMBER_HOST  | MEMBER_PORT | MEMBER_STATE | MEMBER_ROLE | MEMBER_VERSION |
+---------------------------+--------------------------------------+--------------+-------------+--------------+-------------+----------------+
| group_replication_applier | 041f26d8-f3f3-11e8-adff-080027337932 | example1     |      3306   | ONLINE       | SECONDARY   | 8.0.13         |
| group_replication_applier | f60a3e10-f3f2-11e8-8258-080027337932 | example2     |      3306   | ONLINE       | PRIMARY     | 8.0.13         |
| group_replication_applier | fc890014-f3f2-11e8-a9fd-080027337932 | example3     |      3306   | ONLINE       | SECONDARY   | 8.0.13         |
+---------------------------+--------------------------------------+--------------+-------------+--------------+-------------+----------------+
</pre><p>
      この結果に基づいて、グループが 3 つのメンバー、クライアントがメンバーへの接続に使用する各メンバーホストとポート番号、およびメンバーの <code class="literal">server_uuid</code> で構成されていることがわかります。 <code class="literal">MEMBER_STATE</code> カラムには <a class="xref" href="group-replication.html#group-replication-server-states" title="18.3.1 グループレプリケーションサーバーの状態">セクション18.3.1「グループレプリケーションサーバーの状態」</a> のいずれかが表示されます。この場合、このグループの 3 つのメンバーはすべて <code class="literal">ONLINE</code> であり、<code class="literal">MEMBER_ROLE</code> カラムにはセカンダリが 2 つあり、プライマリが 1 つであることが示されています。 したがって、このグループはシングルプライマリモードで実行されている必要があります。 <code class="literal">MEMBER_VERSION</code> カラムは、グループをアップグレードし、異なる MySQL バージョンを実行しているメンバーを結合する場合に役立ちます。 詳しくは<a class="xref" href="group-replication.html#group-replication-server-states" title="18.3.1 グループレプリケーションサーバーの状態">セクション18.3.1「グループレプリケーションサーバーの状態」</a>をご覧ください。 
    </p><p>
      <code class="literal">Member_host</code> の値と分散リカバリプロセスへの影響の詳細は、<a class="xref" href="group-replication.html#group-replication-user-credentials" title="18.2.1.3 分散リカバリのユーザー資格証明">セクション18.2.1.3「分散リカバリのユーザー資格証明」</a> を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-replication-group-member-stats"></a>18.3.3 replication_group_member_stats テーブル</h3></div></div></div><a class="indexterm" name="idm45563248131136"></a><p>
      レプリケーショングループ内の各メンバーは、グループが受信したトランザクションを証明して適用します。 証明者および適用者プロシージャに関する統計は、適用者キューの増加状況、検出された競合の数、チェックされたトランザクションの数、すべての場所でコミットされたトランザクションなどを理解するために役立ちます。 
    </p><p>
      <code class="literal">performance_schema.replication_group_member_stats</code> テーブルには、証明プロセスに関連するグループレベルの情報と、レプリケーショングループの個々のメンバーが受信および発生したトランザクションの統計が表示されます。 この情報は、レプリケーショングループのメンバーであるすべてのサーバーインスタンス間で共有されるため、すべてのグループメンバーに関する情報を任意のメンバーからクエリーすることができます。 リモートメンバーの統計のリフレッシュは、<code class="literal">group_replication_flow_control_period</code> オプションで指定されたメッセージ期間によって制御されるため、クエリーが行われたメンバーのローカルに収集された統計とは若干異なる場合があります。 このテーブルを使用してグループレプリケーションメンバーを監視するには、次のコマンドを発行します: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.replication_group_member_stats\G</code></strong></pre><p>
      これらのフィールドは、グループに接続されているメンバーのパフォーマンスを監視するために重要です。 たとえば、グループのいずれかのメンバーが、他のメンバーと比較して常にキュー内の多数のトランザクションをレポートするとします。 これは、メンバーが遅延し、グループの他のメンバーと最新の状態を維持できないことを意味します。 この情報に基づいて、キューに入れられたトランザクションの数を減らすために、グループからメンバーを削除するか、グループの他のメンバーでトランザクションの処理を遅延するかを決定できます。 この情報は、Group Replication プラグインのフロー制御の調整方法の決定にも役立ちます。<a class="xref" href="group-replication.html#group-replication-flow-control" title="18.6.2 フロー制御">セクション18.6.2「フロー制御」</a> を参照してください。 
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="group-replication-operations"></a>18.4 グループレプリケーション操作</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-configuring-online-group">18.4.1 オンライングループの構成</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-consistency-guarantees">18.4.2 トランザクション一貫性保証</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-distributed-recovery">18.4.3 分散リカバリ</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-network-partitioning">18.4.4 ネットワークパーティション化</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-ipv6">18.4.5 IPv6 および IPv6 と IPv4 の混合グループのサポート</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-enterprise-backup">18.4.6 グループレプリケーションでの MySQL Enterprise Backup の使用</a></span></dt></dl></div><a class="indexterm" name="idm45563248118848"></a><p>
    このセクションでは、グループを管理するための一般的な操作について説明します。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-configuring-online-group"></a>18.4.1 オンライングループの構成</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-changing-primary-member">18.4.1.1 グループプライマリメンバーの変更</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-changing-group-mode">18.4.1.2 グループモードの変更</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-group-write-consensus">18.4.1.3 グループレプリケーショングループ書込みコンセンサスの使用</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-communication-protocol">18.4.1.4 グループ通信プロトコルバージョンの設定</a></span></dt></dl></div><a class="indexterm" name="idm45563248115200"></a><a class="indexterm" name="idm45563248113040"></a><p>
      グループレプリケーションの実行中に、グループアクションコーディネータに依存する UDF のセットを使用してオンライングループを構成できます。 これらの UDF は、バージョン 8.0.13 以上の Group Replication プラグインによってインストールされます。 このセクションでは、実行中のグループに対する変更方法と使用可能な UDF について説明します。 
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        コーディネータが実行中のグループに対してグループ全体のアクションを構成できるようにするには、すべてのメンバーが MySQL 8.0.13 以上を実行しており、UDF がインストールされている必要があります。
      </p></div><p>
      UDF を使用するには、実行中のグループのメンバーに接続し、<code class="literal">SELECT</code> ステートメントを使用して UDF を発行します。 Group Replication プラグインはアクションとそのパラメータを処理し、UDF を発行したメンバーに表示されるすべてのメンバーにコーディネータが送信します。 アクションが受け入れられると、すべてのメンバーがアクションを実行し、完了時に終了メッセージを送信します。 すべてのメンバーがアクションを終了として宣言すると、呼出し側メンバーは結果をクライアントに返します。 
    </p><p>
      グループ全体を構成する場合、操作の分散特性は、グループレプリケーションプラグインの多くのプロセスと相互作用するため、次の点に注意する必要があることを意味します:
    </p><p><b>あらゆる場所で構成操作を発行できます. </b>
        メンバー A を新しいプライマリにする場合、メンバー A に対する操作を呼び出す必要はありません。 すべての操作は、すべてのグループメンバーに対して調整された方法で送信および実行されます。 また、この分散操作の実行には異なる影響があります: 呼出し側メンバーが停止した場合、すでに実行中の構成プロセスは他のメンバーで引き続き実行されます。 呼出し側メンバーが異常終了した場合でも、監視機能を使用して、他のメンバーが正常に操作を完了していることを確認できます。 
      </p><p><b>すべてのメンバーがオンラインである必要があります. </b>
        移行または選択プロセスを簡略化し、できるだけ高速であることを保証するために、グループには現在分散リカバリプロセスにあるメンバーを含めないでください。そうしないと、構成アクションはステートメントを発行したメンバーによって拒否されます。
      </p><p><b>構成の変更中にメンバーはグループに参加できません. </b>
        調整された構成変更中にグループに参加しようとするメンバーは、グループを離れ、その結合プロセスを取り消します。
      </p><p><b>一度に 1 つの構成のみ. </b>
        同時構成操作はメンバーの相違につながる可能性があるため、構成変更を実行しているグループは他のグループ構成変更を受け入れることができません。
      </p><p><b>すべてのメンバーで MySQL 8.0.13 以上が実行されている必要があります. </b>
        構成アクションは分散されているため、実行するにはすべてのメンバーが認識する必要があります。 したがって、MySQL Server バージョン 8.0.12 以下を実行しているサーバーがグループに存在する場合、操作は拒否されます。 
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-changing-primary-member"></a>18.4.1.1 グループプライマリメンバーの変更</h4></div></div></div><a class="indexterm" name="idm45563248094880"></a><p>
        このセクションでは、単一プライマリグループのどのメンバーがプライマリであるかを変更する方法について説明します。 グループモードの変更に使用される関数は、任意のメンバーで実行できます。 
      </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-change-primary"></a>プライマリのメンバーの変更</h5></div></div></div><a class="indexterm" name="idm45563248090848"></a><a class="indexterm" name="idm45563248088608"></a><a class="indexterm" name="idm45563248087600"></a><a class="indexterm" name="idm45563248085600"></a><p>
          <code class="literal">group_replication_set_as_primary()</code> UDF を使用して、どのメンバーが単一プライマリグループのプライマリであるかを変更します。 マルチプライマリグループのメンバーに対して発行された場合、この関数は無効です。 プライマリメンバーのみがグループに書き込むことができるため、そのメンバーで非同期チャネルが実行されている場合、非同期チャネルが停止するまで切替えは許可されません。 
        </p><p>
          8.0.17 から MySQL Server バージョンを実行しているメンバーで UDF を発行し、すべてのメンバーが MySQL Server バージョン 8.0.17 以上を実行している場合、パッチバージョンに基づいて、グループ内の最下位の MySQL Server バージョンを実行している新規プライマリメンバーのみを指定できます。 この保護策は、グループが新しい機能との互換性を維持するために適用されます。 いずれかのメンバーが MySQL 8.0.13 と MySQL 8.0.16 の間で MySQL Server バージョンを実行している場合、この保護策はグループに適用されず、新しいプライマリメンバーを指定できますが、グループ内で最も低い MySQL Server バージョンを実行しているプライマリを選択することをお薦めします。 
        </p><p>
          次のコマンドを発行して、グループの新しいプライマリにするメンバーの <code class="literal">server_uuid</code> を渡します:
        </p><pre class="programlisting"><strong class="userinput"><code>SELECT group_replication_set_as_primary(member_uuid);</code></strong>
</pre><p>
          アクションの実行中に、次のコマンドを発行して進行状況を確認できます:
        </p><pre class="programlisting"><strong class="userinput"><code>SELECT event_name, work_completed, work_estimated FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";</code></strong>
+----------------------------------------------------------------------------------+----------------+----------------+
| event_name                                                                       | work_completed | work_estimated |
+----------------------------------------------------------------------------------+----------------+----------------+
| stage/group_rpl/Primary Election: Waiting for members to turn on super_read_only |              3 |              5 |
+----------------------------------------------------------------------------------+----------------+----------------+
</pre></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-changing-group-mode"></a>18.4.1.2 グループモードの変更</h4></div></div></div><a class="indexterm" name="idm45563248071904"></a><p>
        このセクションでは、グループが実行されているモード (単一プライマリまたはマルチプライマリ) を変更する方法について説明します。 グループモードの変更に使用される関数は、任意のメンバーで実行できます。 
      </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-switch-to-single"></a>シングルプライマリモードへの変更</h5></div></div></div><a class="indexterm" name="idm45563248067792"></a><a class="indexterm" name="idm45563248065600"></a><a class="indexterm" name="idm45563248064560"></a><a class="indexterm" name="idm45563248062560"></a><p>
          <code class="literal">group_replication_switch_to_single_primary_mode()</code> UDF を使用して、マルチプライマリモードで実行されているグループをシングルプライマリモードに変更するには、次を発行します:
        </p><pre class="programlisting"><strong class="userinput"><code>SELECT group_replication_switch_to_single_primary_mode()</code></strong>
</pre><p>
          シングルプライマリモードに変更すると、シングルプライマリモード (<code class="literal">group_replication_enforce_update_everywhere_checks=OFF</code>) での必要に応じて、すべてのグループメンバーで厳密な整合性チェックも無効になります。
        </p><p>
          文字列が渡されない場合、結果の単一プライマリグループでの新しいプライマリの選択は、<a class="xref" href="group-replication.html#group-replication-single-primary-mode" title="18.1.3.1 シングルプライマリモード">セクション18.1.3.1「シングルプライマリモード」</a> で説明されている選択ポリシーに従います。 選択プロセスを上書きし、マルチプライマリグループの特定のメンバーをプロセスの新しいプライマリとして構成するには、メンバーの <code class="literal">server_uuid</code> を取得して<code class="literal"> group_replication_switch_to_single_primary_mode()</code> に渡します。 たとえば、次のコマンドを発行します: 
        </p><pre class="programlisting"><strong class="userinput"><code>SELECT group_replication_switch_to_single_primary_mode(<em class="replaceable"><code>member_uuid</code></em>);</code></strong>
</pre><p>
          8.0.17 から MySQL Server バージョンを実行しているメンバーで UDF を発行し、すべてのメンバーが MySQL Server バージョン 8.0.17 以上を実行している場合、パッチバージョンに基づいて、グループ内の最下位の MySQL Server バージョンを実行している新規プライマリメンバーのみを指定できます。 この保護策は、グループが新しい機能との互換性を維持するために適用されます。 新しいプライマリメンバーを指定しない場合、選択プロセスではグループメンバーのパッチバージョンが考慮されます。 
        </p><p>
          いずれかのメンバーが MySQL 8.0.13 と MySQL 8.0.16 の間で MySQL Server バージョンを実行している場合、この保護策はグループに適用されず、新しいプライマリメンバーを指定できますが、グループ内で最も低い MySQL Server バージョンを実行しているプライマリを選択することをお薦めします。 新しいプライマリメンバーを指定しない場合、選択プロセスではグループメンバーのメジャーバージョンのみが考慮されます。 
        </p><p>
          アクションの実行中に、次のコマンドを発行して進行状況を確認できます:
        </p><pre class="programlisting"><strong class="userinput"><code>SELECT event_name, work_completed, work_estimated FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";</code></strong>
+----------------------------------------------------------------------------+----------------+----------------+
| event_name                                                                 | work_completed | work_estimated |
+----------------------------------------------------------------------------+----------------+----------------+
| stage/group_rpl/Primary Switch: waiting for pending transactions to finish |              4 |             20 |
+----------------------------------------------------------------------------+----------------+----------------+
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-switch-to-multi"></a>マルチプライマリモードへの変更</h5></div></div></div><a class="indexterm" name="idm45563248042208"></a><a class="indexterm" name="idm45563248040016"></a><a class="indexterm" name="idm45563248038976"></a><a class="indexterm" name="idm45563248036976"></a><p>
          <code class="literal">group_replication_switch_to_multi_primary_mode()</code> UDF を使用して、単一プライマリモードで実行されているグループをマルチプライマリモードに変更するには、次のように発行します:
        </p><pre class="programlisting"><strong class="userinput"><code>SELECT group_replication_switch_to_multi_primary_mode()</code></strong>
</pre><p>
          データの安全性と一貫性を確保するために調整されたグループ操作の後、グループに属するすべてのメンバーがプライマリになります。
        </p><p>
          シングルプライマリモードで実行されていたグループをマルチプライマリモードで実行するように変更すると、MySQL 8.0.17 以上を実行しているメンバーは、グループに存在する最低バージョンより上位の MySQL サーバーバージョンを実行している場合、自動的に読取り専用モードになります。 MySQL 8.0.16 以下を実行しているメンバーはこのチェックを実行せず、常に読取り/書込みモードになります。 
        </p><p>
          アクションの実行中に、次のコマンドを発行して進行状況を確認できます:
        </p><pre class="programlisting">SELECT event_name, work_completed, work_estimated FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl%";
+----------------------------------------------------------------------+----------------+----------------+
| event_name                                                           | work_completed | work_estimated |
+----------------------------------------------------------------------+----------------+----------------+
| stage/group_rpl/Multi-primary Switch: applying buffered transactions |              0 |              1 |
+----------------------------------------------------------------------+----------------+----------------+
</pre></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-group-write-consensus"></a>18.4.1.3 グループレプリケーショングループ書込みコンセンサスの使用</h4></div></div></div><a class="indexterm" name="idm45563248026032"></a><a class="indexterm" name="idm45563248023856"></a><p>
        このセクションでは、グループのコンセンサスインスタンスの最大数をいつでも検査および構成する方法について説明します。 この最大値はグループのイベント範囲と呼ばれ、グループがパラレルに実行できるコンセンサスインスタンスの最大数です。 これにより、Group Replication デプロイメントのパフォーマンスを微調整できます。 たとえば、LAN 上で実行されているグループにはデフォルト値の 10 が適していますが、WAN などの低速なネットワーク上で動作しているグループには、この数値を増やしてパフォーマンスを向上させます。 
      </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-inspect-write-concurrency"></a>グループ書込み同時実行性の検査</h5></div></div></div><a class="indexterm" name="idm45563248019424"></a><a class="indexterm" name="idm45563248017168"></a><a class="indexterm" name="idm45563248016128"></a><a class="indexterm" name="idm45563248014128"></a><p>
          <code class="literal">group_replication_get_write_concurrency()</code> UDF を使用して、実行時に次を発行してグループイベント範囲値を検査します:
        </p><pre class="programlisting"><strong class="userinput"><code>SELECT group_replication_get_write_concurrency();</code></strong>
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-configure-write-concurrency"></a>グループ書込み同時実行性の構成</h5></div></div></div><a class="indexterm" name="idm45563248007568"></a><a class="indexterm" name="idm45563248005312"></a><a class="indexterm" name="idm45563248004272"></a><a class="indexterm" name="idm45563248002272"></a><p>
          <code class="literal">group_replication_set_write_concurrency()</code> UDF を使用して、次を発行することでシステムが並行して実行できるコンセンサスインスタンスの最大数を設定します:
        </p><pre class="programlisting"><strong class="userinput"><code>SELECT group_replication_set_write_concurrency(<em class="replaceable"><code>instances</code></em>);</code></strong>
</pre><p>
          ここで、<em class="replaceable"><code>instances</code></em> はコンセンサスインスタンスの新しい最大数です。 この UDF を使用するには、<code class="literal">GROUP_REPLICATION_ADMIN</code> 権限が必要です。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-communication-protocol"></a>18.4.1.4 グループ通信プロトコルバージョンの設定</h4></div></div></div><a class="indexterm" name="idm45563247992848"></a><p>
        MySQL 8.0.16 から、グループレプリケーションにはグループの通信プロトコルの概念があります。 Group Replication 通信プロトコルのバージョンは明示的に管理でき、グループでサポートする最も古い MySQL Server バージョンに対応するように設定できます。 これにより、下位互換性を確保しながら、異なる MySQL Server バージョンのメンバーからグループを形成できます。 MySQL 5.7.14 のバージョンではメッセージを圧縮でき、MySQL 8.0.16 のバージョンではメッセージを断片化することもできます。 グループメンバーが異なる MySQL Server リリースを使用できるように、グループのすべてのメンバーは同じ通信プロトコルバージョンを使用する必要がありますが、すべてのグループメンバーが理解できるメッセージのみを送信します。 
      </p><p>
        バージョン X の MySQL サーバーは、グループ通信プロトコルのバージョンが X 以下の場合にのみ、レプリケーショングループの <code class="literal">ONLINE</code> ステータスに参加して到達できます。 新しいメンバーがレプリケーショングループに参加すると、グループの既存のメンバーによって通知される通信プロトコルバージョンがチェックされます。 参加メンバーがそのバージョンをサポートしている場合、メンバーが追加の通信機能をサポートしていても、参加メンバーはグループに参加し、グループが発表した通信プロトコルを使用します。 参加メンバーが通信プロトコルバージョンをサポートしていない場合は、グループから削除されます。 
      </p><p>
        2 つのメンバーが同じメンバーシップ変更イベントに参加しようとすると、両方のメンバーの通信プロトコルバージョンがすでにグループ通信プロトコルバージョンと互換性がある場合にのみ参加できます。 グループとは異なる通信プロトコルバージョンを持つメンバーは、分離して参加する必要があります。 例: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            一方の MySQL Server 8.0.16 インスタンスは、通信プロトコルバージョン 5.7.24 を使用するグループに正常に参加できます。
          </p></li><li class="listitem"><p>
            一方の MySQL Server 5.7.24 インスタンスは、通信プロトコルバージョン 8.0.16 を使用するグループに正常に参加できません。
          </p></li><li class="listitem"><p>
            2 つの MySQL Server 8.0.16 インスタンスは、通信プロトコルバージョン 5.7.24 を使用するグループに同時に参加することはできません。
          </p></li><li class="listitem"><p>
            2 つの MySQL Server 8.0.16 インスタンスは、通信プロトコルバージョン 8.0.16 を使用するグループに同時に参加できます。
          </p></li></ul></div><p>
        グループがサポートしている最も古い MySQL Server バージョンを返す <code class="literal">group_replication_get_communication_protocol()</code> UDF を使用して、グループが使用している通信プロトコルを検査できます。 グループの既存のすべてのメンバーは、同じ通信プロトコルバージョンを返します。 例: 
      </p><pre class="programlisting">SELECT group_replication_get_communication_protocol();
+------------------------------------------------+
| group_replication_get_communication_protocol() |
+------------------------------------------------+
| 8.0.16                                         |
+------------------------------------------------+
</pre><p>
        <code class="literal">group_replication_get_communication_protocol()</code> UDF は、グループがサポートする MySQL の最小バージョンを返します。これは、<code class="literal">group_replication_set_communication_protocol()</code> UDF に渡されたバージョン番号、および UDF を使用するメンバーにインストールされている MySQL Server バージョンとは異なる場合があります。
      </p><p>
        以前のリリースのメンバーが参加できるようにグループの通信プロトコルバージョンを変更する必要がある場合は、<code class="literal">group_replication_set_communication_protocol()</code> UDF を使用して、許可する最も古いメンバーの MySQL Server バージョンを指定します。 これにより、可能であれば、グループは互換性のある通信プロトコルバージョンにフォールバックされます。 この UDF を使用するには <code class="literal">GROUP_REPLICATION_ADMIN</code> 権限が必要です。また、ステートメントを発行するときは、大部分を失うことなく、既存のすべてのグループメンバーがオンラインである必要があります。 例: 
      </p><pre class="programlisting"><strong class="userinput"><code>SELECT group_replication_set_communication_protocol("5.7.25");</code></strong>
</pre><p>
        レプリケーショングループのすべてのメンバーを新しい MySQL Server リリースにアップグレードしても、グループ通信プロトコルのバージョンは一致するように自動的にアップグレードされません。 以前のリリースでメンバーをサポートする必要がなくなった場合は、<code class="literal">group_replication_set_communication_protocol()</code> UDF を使用して、通信プロトコルバージョンを、メンバーをアップグレードした新しい MySQL Server バージョンに設定できます。 例: 
      </p><pre class="programlisting"><strong class="userinput"><code>SELECT group_replication_set_communication_protocol("8.0.16");</code></strong>
</pre><p>
        <code class="literal">group_replication_set_communication_protocol()</code> UDF はグループアクションとして実装されるため、グループのすべてのメンバーで同時に実行されます。 グループアクションはメッセージのバッファリングを開始し、すでに進行中の送信メッセージの配信が完了するまで待機してから、通信プロトコルのバージョンを変更し、バッファされたメッセージを送信します。 通信プロトコルバージョンを変更した後、メンバーがいつでもグループに参加しようとすると、グループメンバーは新しいプロトコルバージョンを通知します。 
      </p><p>
        MySQL InnoDB クラスタは、AdminAPI 操作を使用してクラスタトポロジが変更されるたびに、そのメンバーの通信プロトコルバージョンを自動的かつ透過的に管理します。 InnoDB クラスタでは、現在クラスタの一部であるか、クラスタに参加しているすべてのインスタンスでサポートされている最新の通信プロトコルバージョンが常に使用されます。 詳細は、<a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/ja/monitoring-innodb-cluster.html#innodb-cluster-group-replication-protocol" target="_top">InnoDB クラスタ およびグループのレプリケーションプロトコル</a>を参照してください。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-consistency-guarantees"></a>18.4.2 トランザクション一貫性保証</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-understanding-consistency-guarantees">18.4.2.1 トランザクションの一貫性保証の理解</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-configuring-consistency-guarantees">18.4.2.2 トランザクション一貫性保証の構成</a></span></dt></dl></div><a class="indexterm" name="idm45563247958224"></a><p>
      グループレプリケーションなどの分散システムの主な影響の 1 つは、グループとして提供される一貫性保証です。 つまり、グループのメンバーに分散されたトランザクションのグローバル同期の一貫性。 このセクションでは、グループ内で発生するイベントに応じてグループレプリケーションが一貫性保証を処理する方法と、グループの一貫性保証を最適に構成する方法について説明します。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-understanding-consistency-guarantees"></a>18.4.2.1 トランザクションの一貫性保証の理解</h4></div></div></div><a class="indexterm" name="idm45563247954128"></a><a class="indexterm" name="idm45563247951872"></a><p>
        分散一貫性保証では、通常の修復操作または障害修復操作のいずれかにおいて、グループレプリケーションは常に最終的な一貫性システムでした。 つまり、受信トラフィックの速度が低下または停止するとすぐに、すべてのグループメンバーのデータコンテンツが同じになります。 システムの整合性に関連するイベントは、手動または障害によって自動的にトリガーされる制御操作と、データフロー操作に分割できます。 
      </p><p>
        グループレプリケーションの場合、一貫性の観点から評価できる制御操作は次のとおりです:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            グループレプリケーション <a class="xref" href="group-replication.html#group-replication-distributed-recovery" title="18.4.3 分散リカバリ">セクション18.4.3「分散リカバリ」</a> および書込み保護でカバーされるメンバーの参加または離脱。
          </p></li><li class="listitem"><p>
            ネットワーク障害。フェンシングモードでカバーされます。
          </p></li><li class="listitem"><p>
            単一プライマリグループのプライマリフェイルオーバー (<code class="literal">group_replication_set_as_primary()</code> によってトリガーされる操作の場合もあります)。
          </p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-control-operation-failover"></a>一貫性保証とプライマリフェイルオーバー</h5></div></div></div><a class="indexterm" name="idm45563247940864"></a><a class="indexterm" name="idm45563247938672"></a><p>
          単一プライマリグループでは、セカンダリがプライマリに昇格されたときにプライマリフェイルオーバーが発生した場合、レプリケーションバックログの大きさに関係なく、新しいプライマリをアプリケーショントラフィックですぐに使用可能にすることも、バックログが適用されるまでアクセスを制限することもできます。
        </p><p>
          最初のアプローチでは、新しいプライマリを選択し、古いプライマリから可能性のあるバックログをまだ適用している間にデータアクセスをすぐに許可することで、プライマリの障害後に安定したグループメンバーシップを保護できる最小時間がグループにかかります。 書込み一貫性は保証されますが、読取りでは、新しいプライマリがバックログを適用している間、失効したデータを一時的に取得できます。 たとえば、クライアント C1 が障害の直前に古いプライマリに <code class="literal">A=2 WHERE A=1</code> を書き込んだ場合、クライアント C1 が新しいプライマリに再接続されると、新しいプライマリがバックログを適用してグループを離れる前の古いプライマリの状態でキャッチアップするまで、<code class="literal">A=1</code> を読み取る可能性があります。 
        </p><p>
          2 つ目の代替方法では、プライマリ障害後に安定したグループメンバーシップが保護され、最初の代替方法と同じ方法で新しいプライマリが選択されますが、この場合、グループは新しいプライマリがすべてのバックログを適用するまで待機してから、データアクセスを許可します。 これにより、前述のような状況で、クライアント C1 が新しいプライマリに再接続されると、<code class="literal">A=2</code> が読み取られます。 ただし、フェイルオーバーに必要な時間はバックログのサイズに比例するため、適切に構成されたグループでは小さいにする必要があります。 
        </p><p>
          MySQL 8.0.14 より前は、フェイルオーバーポリシーを構成する方法はありませんでした。デフォルトでは、可用性は最初のアプローチで説明されているように最大化されていました。 MySQL 8.0.14 以上を実行しているメンバーがいるグループでは、<code class="literal">group_replication_consistency</code> 変数を使用して、プライマリフェイルオーバー時にメンバーによって提供されるトランザクション一貫性保証のレベルを構成できます。 <a class="xref" href="group-replication.html#group-replication-consistency-level-impact-election" title="プライマリ選択に対する整合性の影響">プライマリ選択に対する整合性の影響</a>を参照してください。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-data-flow-operations"></a>データフロー操作</h5></div></div></div><a class="indexterm" name="idm45563247923328"></a><p>
          データフローは、特にこれらの操作がすべてのメンバーに分散されている場合に、グループに対して実行される読取りおよび書込みによるグループの一貫性保証に関連します。 データフロー操作は、グループレプリケーションの両方のモードに適用されます: ただし、この説明を明確にするために、シングルプライマリモードとマルチプライマリモードに制限されています。 単一プライマリグループメンバー間で受信読取りまたは書込みトランザクションを分割する通常の方法は、書込みをプライマリにルーティングし、読取りをセカンダリに均等に分散することです。 グループは単一のエンティティとして動作する必要があるため、プライマリでの書込みがセカンダリで即時に使用可能であることを期待することが妥当です。 Group Replication は Paxos アルゴリズムを実装する Group Communication System (GCS) プロトコルを使用して記述されますが、Group Replication の一部は非同期であり、これはデータがセカンダリに非同期に適用されることを意味します。 これは、クライアント C2 がプライマリに <code class="literal">B=2 WHERE B=1</code> を書き込んで、すぐにセカンダリに接続し、<code class="literal">B=1</code> を読み取ることができることを意味します。 これは、セカンダリがまだバックログを適用しており、プライマリによって適用されたトランザクションを適用していないためです。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-synchronization-points"></a>トランザクション同期ポイント</h5></div></div></div><a class="indexterm" name="idm45563247915776"></a><p>
          グループ全体でトランザクションを同期する時点に基づいて、グループの一貫性保証を構成します。 このセクションでは、概念を理解しやすくするために、読取り操作時または書込み操作時にグループ全体でトランザクションを同期するポイントを簡略化します。 読取り時にデータが同期化された場合、現在のクライアントセッションは、特定の時点 (前のすべての更新トランザクションが適用された時点) まで待機してから、実行を開始します。 このアプローチでは、このセッションのみが影響を受け、他のすべての同時データ操作は影響を受けません。 
        </p><p>
          書き込み時にデータが同期された場合、書き込みセッションはすべてのセカンダリがデータを書き込むまで待機します。 グループレプリケーションでは書込みの合計順序が使用されるため、これは、セカンダリのキューにあるこの書込みおよびそれより前のすべての書込みが適用されるのを待機していることを意味します。 したがって、この同期ポイントを使用する場合、書き込みセッションはすべてのセカンダリキューが適用されるまで待機します。 
        </p><p>
          代替方法により、クライアントに説明されている状況では、すぐにセカンダリに接続されていても、C2 は常に <code class="literal">B=2</code> を読み取るようになります。 それぞれの代替方法には、システムワークロードに直接関連する利点とデメリットがあります。 次の例では、様々なタイプのワークロードについて説明し、適切な同期ポイントをアドバイスします。 
        </p><p>
          次の状況を考えてみます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              失効したデータの読取りを回避するために、読取り元のサーバーに追加の制限をデプロイせずに読取りのロードバランシングを行う場合、グループ書込みはグループ読取りよりもはるかに一般的ではありません。
            </p></li><li class="listitem"><p>
              主に読取り専用データを持つグループがある場合、コミットされたすべての場所に読取り/書込みトランザクションを適用して、最新の書込みを含む最新のデータに対して後続の読取りが実行されるようにします。 これにより、すべての RO トランザクションに対して同期コストを支払うのではなく、RW トランザクションに対してのみ支払うようになります。 
            </p></li></ul></div><p>
          このような場合は、書込み時に同期化することを選択する必要があります。
        </p><p>
          次の状況を考えてみます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              失効したデータの読取りを回避するために、読取り元のサーバーに追加の制限をデプロイせずに読取りのロードバランシングを行う場合、グループ書込みはグループ読取りよりもはるかに一般的です。
            </p></li><li class="listitem"><p>
              ワークロード内の特定のトランザクションで、機密データ (ファイルの資格証明や類似データなど) が更新され、読取りで最新の値が取得されるように強制する場合などに、常にグループから最新のデータを読み取る必要があります。
            </p></li></ul></div><p>
          このような場合は、読取り時に同期化することを選択する必要があります。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-configuring-consistency-guarantees"></a>18.4.2.2 トランザクション一貫性保証の構成</h4></div></div></div><a class="indexterm" name="idm45563247897936"></a><p>
        <a class="xref" href="group-replication.html#group-replication-synchronization-points" title="トランザクション同期ポイント">トランザクション同期ポイント</a> のセクションでは概念的に説明していますが、選択できる同期ポイントは 2 つあります: 読取り時または書込み時、これらの用語は簡略化されており、グループレプリケーションで使用される用語は次のとおりです: トランザクション実行の前後。 このセクションで示すように、一貫性レベルは、グループによって処理される読取り専用 (RO) トランザクションと読取り/書込み (RW) トランザクションに異なる影響を与える可能性があります。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="group-replication.html#group-replication-choose-consistency-level" title="整合性レベルの選択方法">整合性レベルの選択方法</a></p></li><li class="listitem"><p><a class="xref" href="group-replication.html#group-replication-consistency-level-impacts" title="整合性レベルの影響">整合性レベルの影響</a></p></li><li class="listitem"><p><a class="xref" href="group-replication.html#group-replication-consistency-level-impact-election" title="プライマリ選択に対する整合性の影響">プライマリ選択に対する整合性の影響</a></p></li></ul></div><p>
        次のリストは、トランザクションの一貫性保証を高めるために、<code class="literal">group_replication_consistency</code> 変数を使用してグループレプリケーションで構成できる一貫性レベルを示しています:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">EVENTUAL</code>
          </p><p>
            RO トランザクションと RW トランザクションはどちらも、実行前に先行するトランザクションが適用されるのを待機しません。 これは、<code class="literal">group_replication_consistency</code> 変数が追加される前の Group Replication の動作でした。 RW トランザクションは、他のメンバーがトランザクションを適用するのを待機しません。 つまり、あるメンバーでトランザクションを外部化してから別のメンバーに外部化できます。 つまり、プライマリフェイルオーバーが発生した場合、新しいプライマリは、前のプライマリトランザクションがすべて適用される前に新しい RO および RW トランザクションを受け入れることができます。 RO トランザクションは古い値になる可能性があり、RW トランザクションは競合のためロールバックする可能性があります。 
          </p></li><li class="listitem"><p>
            <code class="literal">BEFORE_ON_PRIMARY_FAILOVER</code>
          </p><p>
            古いプライマリからバックログを適用している、新しく選択されたプライマリを持つ新しい RO または RW トランザクションは、バックログが適用されるまで保持されます (適用されません)。 これにより、プライマリフェイルオーバーが意図的に発生したかどうかにかかわらず、クライアントには常にプライマリの最新の値が表示されます。 これにより一貫性が保証されますが、バックログが適用されている場合、クライアントは遅延を処理できる必要があります。 通常、この遅延は最小限に抑える必要がありますが、バックログのサイズによって異なります。 
          </p></li><li class="listitem"><p>
            <code class="literal">BEFORE</code>
          </p><p>
            RW トランザクションは、先行するすべてのトランザクションが完了するまで待機してから適用されます。 RO トランザクションは、先行するすべてのトランザクションが完了するまで待機してから実行されます。 これにより、トランザクションのレイテンシにのみ影響を与えることで、このトランザクションが最新の値を読み取るようになります。 これにより、RO トランザクションでのみ同期が使用されるようになるため、すべての RW トランザクションでの同期のオーバーヘッドが削減されます。 この一貫性レベルには、<code class="literal">BEFORE_ON_PRIMARY_FAILOVER</code> によって提供される一貫性保証も含まれます。 
          </p></li><li class="listitem"><p>
            <code class="literal">AFTER</code>
          </p><p>
            RW トランザクションは、その変更が他のすべてのメンバーに適用されるまで待機します。 この値は RO トランザクションには影響しません。 このモードでは、トランザクションがローカルメンバーでコミットされたときに、後続のトランザクションが書込み値またはグループメンバーのより新しい値を読み取ることが保証されます。 このモードは、主に RO 操作に使用されるグループとともに使用して、適用された RW トランザクションがコミット後のすべての場所に確実に適用されるようにします。 これは、後続の読取りで最新の書込みを含む最新のデータがフェッチされるようにするために、アプリケーションで使用できます。 これにより、RW トランザクションでのみ同期が使用されるようになるため、RO トランザクションごとの同期のオーバーヘッドが削減されます。 この一貫性レベルには、<code class="literal">BEFORE_ON_PRIMARY_FAILOVER</code> によって提供される一貫性保証も含まれます。 
          </p></li><li class="listitem"><p>
            <code class="literal">BEFORE_AND_AFTER</code>
          </p><p>
            RW トランザクションは、1) 前のすべてのトランザクションが適用されるまで待機し、2) 変更が他のメンバーに適用されるまで待機します。 RO トランザクションは、先行するすべてのトランザクションが完了するまで待機してから実行されます。 この一貫性レベルには、<code class="literal">BEFORE_ON_PRIMARY_FAILOVER</code> によって提供される一貫性保証も含まれます。 
          </p></li></ul></div><p>
        RO および RW トランザクションでは、<code class="literal">BEFORE</code> と <code class="literal">BEFORE_AND_AFTER</code> の両方の一貫性レベルを使用できます。 RO トランザクションは変更を生成しないため、<code class="literal">AFTER</code> の一貫性レベルは RO トランザクションに影響しません。 
      </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-choose-consistency-level"></a>整合性レベルの選択方法</h5></div></div></div><a class="indexterm" name="idm45563247863808"></a><p>
          一貫性レベルが異なると、両方の DBA に柔軟性が提供されます。DBA は、DBA を使用してインフラストラクチャを設定できます。また、アプリケーション要件に最適な整合性レベルを使用できる開発者にも柔軟性があります。 次のシナリオでは、グループの使用方法に基づいて一貫性保証レベルを選択する方法を示します: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <span class="emphasis"><em>シナリオ 1</em></span>では、失効した読取りを気にすることなく読取りのロードバランシングを行う場合、グループの書込み操作はグループの読取り操作よりかなり少なくなります。 この場合、<code class="literal">AFTER</code> を選択する必要があります。 
            </p></li><li class="listitem"><p>
              <span class="emphasis"><em>シナリオ 2</em></span>には、大量の書込みを適用するデータセットがあり、失効したデータの読取りを気にすることなく、場合によっては読取りを実行する必要があります。 この場合、<code class="literal">BEFORE</code> を選択する必要があります。 
            </p></li><li class="listitem"><p>
              <span class="emphasis"><em>シナリオ 3</em></span>では、ワークロード内の特定のトランザクションが常にグループから最新のデータを読み取るようにし、機密データ (ファイルの資格証明や類似データなど) が更新されるたびに常に最新の値を読み取るように強制します。 この場合、<code class="literal">BEFORE</code> を選択する必要があります。 
            </p></li><li class="listitem"><p>
              <span class="emphasis"><em>シナリオ 4</em></span>には、主に読取り専用 (RO) データを持つグループがあり、コミットされたすべての場所に読取り/書込み (RW) トランザクションを適用して、後続の読取りが最新の書込みを含む最新データに対して実行され、すべての RO トランザクションで同期を支払わず、RW トランザクションでのみ行われるようにします。 この場合、<code class="literal">AFTER</code> を選択する必要があります。 
            </p></li><li class="listitem"><p>
              <span class="emphasis"><em>シナリオ 5</em></span>には、主に読取り/書込み (RW) トランザクションが含まれるグループがあり、読取り/書込み (RW) トランザクションは常にグループから最新のデータを読み取り、コミットされるとすべての場所に適用されるため、後続の読取りは最新の書込みを含む最新のデータに対して実行され、読取り専用 (RO) トランザクションごとに同期化を支払わずに RW トランザクションに対してのみ行われます。 この場合、<code class="literal">BEFORE_AND_AFTER</code> を選択する必要があります。 
            </p></li></ul></div><p>
          一貫性レベルが適用されるスコープを自由に選択できます。 整合性レベルをグローバルスコープで設定すると、グループのパフォーマンスに悪影響を与える可能性があるため、これは重要です。 したがって、異なるスコープで <code class="literal">group_replication_consistency</code> システム変数を使用して、グループの一貫性レベルを構成できます。 
        </p><p>
          現在のセッションで整合性レベルを強制するには、セッションスコープを使用します:
        </p><pre class="programlisting">&gt; SET @@SESSION.group_replication_consistency= 'BEFORE';
</pre><p>
          すべてのセッションで整合性レベルを強制するには、グローバルスコープを使用します:
        </p><pre class="programlisting">&gt; SET @@GLOBAL.group_replication_consistency= 'BEFORE';
</pre><p>
          特定のセッションで一貫性レベルを設定できるため、次のようなシナリオを利用できます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <span class="emphasis"><em>シナリオ 6</em></span>特定のシステムは、強力な整合性レベルを必要としない命令をいくつか処理しますが、一方の命令には強力な整合性が必要です: ドキュメントへのアクセス権の管理。 このシナリオでは、システムによってアクセス権限が変更され、すべてのクライアントに正しい権限が表示されるようにする必要があります。 これらの手順では <code class="literal">SET @@SESSION.group_replication_consistency= ‘AFTER’</code>のみが必要で、他の手順はグローバルスコープで設定された <code class="literal">EVENTUAL</code> で実行するように残しておきます。 
            </p></li><li class="listitem"><p>
              <span class="emphasis"><em>シナリオ 7</em></span>シナリオ 6 で説明したのと同じシステムでは、命令は毎日分析処理を実行する必要があるため、常に最新のデータを読み取る必要があります。 これを実現するには、その特定の手順でのみ <code class="literal">SET @@SESSION.group_replication_consistency= ‘BEFORE’</code>を実行する必要があります。 
            </p></li></ul></div><p>
          要約すると、特定の一貫性レベルですべてのトランザクションを実行する必要はありません (特に、一部のトランザクションのみが実際に必要な場合)。
        </p><p>
          グループレプリケーションではすべての読取り/書込みトランザクションが完全に順序付けされるため、現在のセッションの一貫性レベルを <code class="literal">AFTER</code> に設定した場合でも、このトランザクションはその変更がすべてのメンバーに適用されるまで待機します。つまり、セカンダリキューに存在する可能性のあるこのトランザクションおよびそれより前のすべてのトランザクションを待機します。 実際には、一貫性レベルの <code class="literal">AFTER</code> は、このトランザクションまで、およびこのトランザクションを含むすべてを待機します。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-consistency-level-impacts"></a>整合性レベルの影響</h5></div></div></div><a class="indexterm" name="idm45563247829392"></a><p>
          一貫性レベルを分類する別の方法は、グループへの影響、つまり、一貫性レベルが他のメンバーに与える影響です。
        </p><p>
          トランザクションストリームでの順序付けとは別に、<code class="literal">BEFORE</code> の整合性レベルはローカルメンバーにのみ影響します。 つまり、他のメンバーとの調整は不要で、トランザクションに再フォーカスはありません。 つまり、<code class="literal">BEFORE</code> は、使用されているトランザクションにのみ影響します。 
        </p><p>
          <code class="literal">AFTER</code> と <code class="literal">BEFORE_AND_AFTER</code> の一貫性レベルは、他のメンバーで実行される同時トランザクションに副作用します。 これらの一貫性レベルでは、<code class="literal">AFTER</code> または <code class="literal">BEFORE_AND_AFTER</code> とのトランザクションの実行中に <code class="literal">EVENTUAL</code> 一貫性レベルのトランザクションが開始されると、他のメンバートランザクションが待機します。 他のメンバーは、他のメンバートランザクションに <code class="literal">EVENTUAL</code> 一貫性レベルがある場合でも、そのメンバーで <code class="literal">AFTER</code> トランザクションがコミットされるまで待機します。 つまり、<code class="literal">AFTER</code> および <code class="literal">BEFORE_AND_AFTER</code> は <span class="emphasis"><em>all</em></span> <code class="literal">ONLINE</code> グループメンバーに影響します。 
        </p><p>
          これをさらに説明するために、3 つのメンバー、M1、M2 および M3 を持つグループを想定します。 メンバー M1 では、クライアントは次を発行します: 
        </p><pre class="programlisting">&gt; SET @@SESSION.group_replication_consistency= AFTER;
&gt; BEGIN;
&gt; INSERT INTO t1 VALUES (1);
&gt; COMMIT;
</pre><p>
          次に、前述のトランザクションが適用されている間に、メンバー M2 でクライアントが発行します:
        </p><pre class="programlisting">&gt; SET SESSION group_replication_consistency= EVENTUAL;
</pre><p>
          この状況では、2 つ目のトランザクションの一貫性レベルは <code class="literal">EVENTUAL</code> ですが、最初のトランザクションが M2 ですでにコミットフェーズにある間に実行を開始するため、2 つ目のトランザクションは最初のトランザクションがコミットを終了するまで待機する必要があり、その後実行できるだけです。
        </p><p>
          <code class="literal">ONLINE</code> メンバーで使用できるのは一貫性レベルの <code class="literal">BEFORE</code>、<code class="literal">AFTER</code> および <code class="literal">BEFORE_AND_AFTER</code> のみで、他の状態のメンバーで使用しようとするとセッションエラーが発生します。
        </p><p>
          一貫性レベルが <code class="literal">EVENTUAL</code> でないトランザクションは、<code class="literal">wait_timeout</code> 値で構成されたタイムアウトに達するまで実行を保持し、デフォルトは 8 時間です。 タイムアウトに達すると、<code class="literal">ER_GR_HOLD_WAIT_TIMEOUT</code> エラーがスローされます。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-consistency-level-impact-election"></a>プライマリ選択に対する整合性の影響</h5></div></div></div><a class="indexterm" name="idm45563247801392"></a><p>
          このセクションでは、グループの一貫性レベルが、新しいプライマリを選択した単一プライマリグループに与える影響について説明します。 このようなグループは、障害を自動的に検出し、アクティブなメンバー (メンバーシップ構成) のビューを調整します。 さらに、グループがシングルプライマリモードでデプロイされている場合、グループメンバーシップが変更されるたびに、グループにプライマリメンバーがまだ存在するかどうかを検出するチェックが実行されます。 存在しない場合は、セカンダリメンバーのリストから新しいメンバーが選択されます。 通常、これはセカンダリプロモーションと呼ばれます。 
        </p><p>
          システムが障害を自動的に検出して再構成するという事実を考慮すると、ユーザーは昇格が行われると、新しいプライマリが古いプライマリのデータに関する正確な状態になることを期待する場合もあります。 つまり、レプリケートされたトランザクションの読取りおよび書込みが可能になると、そのトランザクションのバックログが新しいプライマリに適用されないことが予想される場合があります。 実際には、アプリケーションが新しいプライマリにフェイルオーバーすると、一時的に古いデータを読み取ったり、古いデータレコードに書き込んだりする機会がなくなります。 
        </p><p>
          フロー制御がアクティブ化され、グループで適切にチューニングされた場合、バックログが存在しないか、または小さい必要があるため、昇格の直後に新しく選択されたプライマリから失効したデータを一時的に読み取る機会はごくわずかです。 さらに、昇格後にプライマリへのアプリケーションアクセスを制御し、そのレベルで一貫性基準を強制するプロキシレイヤーまたはミドルウェアレイヤーがある場合があります。 グループメンバーが MySQL 8.0.14 以上を使用している場合は、<code class="literal">group_replication_consistency</code> 変数を使用して新しいプライマリの動作を指定できます。この変数は、新しく選択されたプライマリが、バックログが完全に適用されるまで、または MySQL 8.0.13 以前を実行しているメンバーの動作まで読取りと書込みの両方をブロックするかどうかを制御します。 バックログが適用される新しく選択されたプライマリで <code class="literal">group_replication_consistency</code> オプションが <code class="literal">BEFORE_ON_PRIMARY_FAILOVER</code> に設定され、バックログの適用中に新しいプライマリに対してトランザクションが発行された場合、バックログが完全に適用されるまで受信トランザクションはブロックされます。 したがって、次の異常は回避されます: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              読取り専用および読取り/書込みトランザクションに対して失効した読取りはありません。 これにより、失効した読取りが新しいプライマリによってアプリケーションに外部化されるのを防ぎます。 
            </p></li><li class="listitem"><p>
              適用を待機しているバックログ内のレプリケートされた読取り/書込みトランザクションとの書込み競合のため、読取り/書込みトランザクションの擬似ロールバックはありません。
            </p></li><li class="listitem"><p>
              読取り/書込みトランザクションでは、次のような読取りスキューはありません:
            </p><pre class="programlisting">&gt; BEGIN;
&gt; SELECT x FROM t1; -- x=1 because x=2 is in the backlog;
&gt; INSERT x INTO t2;
&gt; COMMIT;
</pre><p>
              このクエリーによって競合は発生しませんが、古い値が書き込まれます。
            </p></li></ul></div><p>
          要約すると、<code class="literal">group_replication_consistency</code> が <code class="literal">BEFORE_ON_PRIMARY_FAILOVER</code> に設定されている場合は、新しいプライマリが選択されるたびに読取りおよび書込みが保持されるため、可用性よりも一貫性の優先順位を付けることを選択します。 これは、グループを構成する際に考慮する必要があるトレードオフです。 また、フロー制御が正常に機能している場合は、バックログを最小限に抑える必要があることにも注意してください。 <code class="literal">BEFORE</code>、<code class="literal">AFTER</code> および <code class="literal">BEFORE_AND_AFTER</code> の一貫性レベルが高いほど、<code class="literal">BEFORE_ON_PRIMARY_FAILOVER</code> によって提供される一貫性保証も含まれることに注意してください。 
        </p><p>
          プライマリに昇格されるメンバーに関係なく、グループが同じ一貫性レベルを提供するようにするには、グループのすべてのメンバーの <code class="literal">BEFORE_ON_PRIMARY_FAILOVER</code> (またはそれ以上の整合性レベル) が構成に永続化されている必要があります。 たとえば、メンバーごとに次のコマンドを発行します: 
        </p><pre class="programlisting">&gt; SET PERSIST group_replication_consistency='BEFORE_ON_PRIMARY_FAILOVER';
</pre><p>
          これにより、すべてのメンバーが同じように動作し、メンバーの再起動後に構成が保持されます。
        </p><p>
          <code class="literal">BEFORE_ON_PRIMARY_FAILOVER</code> 整合性レベルを使用している場合、すべての書込みは保持されますが、昇格の実行後にバックログを適用している間もサーバーを検査できるように、すべての読取りがブロックされるわけではありません。 これは、デバッグ、監視、可観測性およびトラブルシューティングに役立ちます。 データを変更しないクエリーには、次のようなものがあります: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">SHOW</code> ステートメント
            </p></li><li class="listitem"><p>
              <code class="literal">SET</code> ステートメント
            </p></li><li class="listitem"><p>
              <code class="literal">DO</code> ステートメント
            </p></li><li class="listitem"><p>
              <code class="literal">EMPTY</code> ステートメント
            </p></li><li class="listitem"><p>
              <code class="literal">USE</code> ステートメント
            </p></li><li class="listitem"><p>
              <code class="literal">performance_schema</code> および <code class="literal">sys</code> データベースに対する <code class="literal">SELECT</code> ステートメントの使用
            </p></li><li class="listitem"><p>
              <code class="literal">infoschema</code> データベースの <code class="literal">PROCESSLIST</code> テーブルに対する <code class="literal">SELECT</code> ステートメントの使用
            </p></li><li class="listitem"><p>
              テーブルまたはユーザー定義関数を使用しない <code class="literal">SELECT</code> ステートメント
            </p></li><li class="listitem"><p>
              <code class="literal">STOP GROUP_REPLICATION</code> ステートメント
            </p></li><li class="listitem"><p>
              <code class="literal">SHUTDOWN</code> ステートメント
            </p></li><li class="listitem"><p>
              <code class="literal">RESET PERSIST</code> ステートメント
            </p></li></ul></div><p>
          トランザクションを永久に保留にすることはできず、保留時間が <code class="literal">wait_timeout</code> を超えると、<span class="errortext">ER_GR_HOLD_WAIT_TIMEOUT</span> エラーが返されます。
        </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-distributed-recovery"></a>18.4.3 分散リカバリ</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-distributed-recovery-connections">18.4.3.1 分散リカバリの接続</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-cloning">18.4.3.2 分散リカバリのためのクローニング</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-tuning-recovery">18.4.3.3 分散リカバリの構成</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-distributed-recovery-fault">18.4.3.4 分散リカバリのフォルトトレランス</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-view-changes">18.4.3.5 分散リカバリの仕組み</a></span></dt></dl></div><a class="indexterm" name="idm45563247745328"></a><p>
      メンバーがレプリケーショングループに参加したり、レプリケーショングループに再度参加したりする場合は、参加前または退席中にグループメンバーによって適用されたトランザクションをキャッチアップする必要があります。 このプロセスは分散リカバリと呼ばれます。 
    </p><p>
      参加メンバーは、グループからすでに受信したがまだ適用されていないトランザクションについて、その <code class="literal">group_replication_applier</code> チャネルのリレーログを確認することから始まります。 結合メンバーが以前にグループに属していた場合は、そのメンバーが残ってから未適用のトランザクションが見つかる可能性があります。その場合は、これらを最初のステップとして適用します。 グループの新規メンバーには適用するものがありません。 
    </p><p>
      その後、参加メンバーはオンラインの既存のメンバーに接続して状態の転送を実行します。 参加メンバーは、既存のメンバー (<span class="emphasis"><em>ドナー</em></span>と呼ばれる) によって提供されている、参加前または退席中にグループで発生したすべてのトランザクションを転送します。 次に、参加メンバーは、この状態の転送の進行中にグループで行われたトランザクションを適用します。 このプロセスが完了すると、参加メンバーはグループ内の残りのサーバーで捕捉され、グループへの通常の参加を開始します。 
    </p><p>
      グループレプリケーションでは、分散リカバリ中の状態転送に次の方法の組合せを使用します:

      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            クローンプラグイン機能を使用したリモートクローニング操作 (MySQL 8.0.17 から使用可能)。 この状態転送方法を有効にするには、グループメンバーと参加メンバーにクローンプラグインをインストールする必要があります。 Group Replication は、必要なクローンプラグイン設定を自動的に構成し、リモートクローニング操作を管理します。 
          </p></li><li class="listitem"><p>
            ドナーバイナリログからレプリケートし、参加メンバーにトランザクションを適用します。 この方法では、ドナーと参加メンバーの間に確立された <code class="literal">group_replication_recovery</code> という名前の標準非同期レプリケーションチャネルを使用します。 
          </p></li></ul></div><p>
    </p><p>
      グループレプリケーションでは、参加メンバーに対して <code class="literal">START GROUP_REPLICATION</code> を発行した後、これらの方法の最適な組合せが状態転送に自動的に選択されます。 これを行うために、グループレプリケーションでは、ドナーとして適切な既存のメンバー、ドナーからの参加メンバーに必要なトランザクションの数、およびグループメンバーのバイナリログファイルに必要なトランザクションが存在しなくなったかどうかがチェックされます。 参加メンバーと適切なドナーの間のトランザクションギャップが大きい場合、または一部の必要なトランザクションがドナーのバイナリログファイルにない場合、Group Replication はリモートクローニング操作で分散リカバリを開始します。 大きなトランザクションギャップがない場合、またはクローンプラグインがインストールされていない場合、Group Replication はドナーのバイナリログからの状態転送に直接進みます。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          リモートクローニング操作中に、参加メンバーの既存のデータが削除され、ドナーデータのコピーに置き換えられます。 リモートクローニング操作が完了し、参加メンバーが再起動すると、ドナーのバイナリログから状態転送が実行され、リモートクローニング操作の進行中にグループが適用したトランザクションが取得されます。 
        </p></li><li class="listitem"><p>
          ドナーのバイナリログからの状態転送中に、結合メンバーはドナーのバイナリログから必要なトランザクションを複製して適用し、受信されたトランザクションを、結合メンバーがグループに参加したことをバイナリログが記録するポイント (ビュー変更イベント) まで適用します。 これが進行中の場合、参加メンバーはグループが適用する新しいトランザクションをバッファします。 バイナリログからの状態転送が完了すると、結合メンバーはバッファートランザクションを適用します。 
        </p></li></ul></div><p>
      参加メンバーは、すべてのグループトランザクションで最新の状態である場合、オンラインとして宣言され、通常のメンバーとしてグループに参加でき、分散リカバリが完了します。
    </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">ヒント</div><p>
        バイナリログからの状態転送は、分散回復のためのグループレプリケーションベースメカニズムであり、レプリケーショングループ内のドナーおよび参加メンバーがクローニングをサポートするように設定されていない場合は、これが唯一使用可能なオプションです。 バイナリログからの状態転送はクラシック非同期レプリケーションに基づいているため、グループに参加しているサーバーにグループデータがまったくない場合、または非常に古いバックアップイメージから取得されたデータがある場合は、非常に長い時間がかかることがあります。 したがって、この状況では、サーバーをグループに追加する前に、グループ内にすでに存在するサーバーのかなり最近のスナップショットを転送して、グループデータを使用して設定することをお勧めします。 これにより、分散リカバリにかかる時間が最小限に抑えられ、保持および転送が必要なバイナリログファイルが少なくなるため、ドナーサーバーへの影響が軽減されます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-distributed-recovery-connections"></a>18.4.3.1 分散リカバリの接続</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-distributed-recovery-connections-endpoints">18.4.3.1.1 分散リカバリエンドポイントのアドレスの選択</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-recovery-compression">18.4.3.1.2 分散リカバリの圧縮</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-distributed-recovery-connections-user">18.4.3.1.3 分散リカバリのレプリケーションユーザー</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-distributed-recovery-connections-ssl">18.4.3.1.4 分散リカバリの SSL および認証</a></span></dt></dl></div><p>
        参加メンバーが分散リカバリ中に状態転送のためにオンラインの既存メンバーに接続すると、参加メンバーは接続のクライアントとして機能し、既存のメンバーはサーバーとして機能します。 ドナーバイナリログからの状態転送がこの接続で (非同期レプリケーションチャネル <code class="literal">group_replication_recovery</code> を使用して) 進行中の場合、参加メンバーはレプリカとして機能し、既存のメンバーはソースとして機能します。 リモートクローニング操作がこの接続で進行中の場合、参加メンバーは受信者として機能し、既存のメンバーはドナーとして機能します。 グループレプリケーションコンテキスト外のロールに適用される構成設定は、グループレプリケーション固有の構成設定または動作によってオーバーライドされないかぎり、グループレプリケーションにも適用できます。 
      </p><p>
        既存のメンバーが分散リカバリのために参加メンバーに提供する接続は、グループのオンラインメンバー間の通信にグループレプリケーションで使用される接続と同じではありません。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            リモート XCom インスタンス間の TCP 通信用のグループレプリケーション (XCom、Paxos バリアント) のためにグループ通信エンジンによって使用される接続は、<code class="literal">group_replication_local_address</code> システム変数によって指定されます。 この接続は、オンラインメンバー間の TCP/IP メッセージに使用されます。 ローカルインスタンスとの通信は、共有メモリーを使用して入力チャネルを介して行われます。 
          </p></li><li class="listitem"><p>
            分散リカバリの場合、MySQL 8.0.20 まで、グループメンバーは、MySQL Server <code class="literal">hostname</code> および <code class="literal">port</code> システム変数で指定された、結合メンバーへの標準 SQL クライアント接続を提供します。 <code class="literal">report_port</code> システム変数で代替ポート番号が指定されている場合は、かわりにそのポート番号が使用されます。 
          </p></li><li class="listitem"><p>
            MySQL 8.0.21 から、グループメンバーは分散リカバリエンドポイントの代替リストをメンバー参加専用クライアント接続として通知できるため、メンバーの通常のクライアントユーザーによる接続とは別に分散リカバリトラフィックを制御できます。 このリストは <code class="literal">group_replication_advertise_recovery_endpoints</code> システム変数を使用して指定し、メンバーはグループに参加するときに分散リカバリエンドポイントのリストをグループに送信します。 デフォルトでは、メンバーは以前のリリースと同様に標準 SQL クライアント接続を引き続き提供します。 
          </p></li></ul></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          結合メンバーが、MySQL Server <code class="literal">hostname</code> システム変数で定義されたホスト名を使用して他のメンバーを正しく識別できない場合、分散リカバリは失敗する可能性があります。 MySQL を実行しているオペレーティングシステムでは、DNS またはローカル設定を使用して、一意のホスト名を適切に構成することをお薦めします。 サーバーが SQL クライアント接続に使用しているホスト名は、「パフォーマンススキーマ」テーブル <code class="literal">replication_group_members</code> の <code class="literal">Member_host</code> カラムで確認できます。 複数のグループメンバーがオペレーティングシステムによって設定されたデフォルトのホスト名を外部化する場合、参加メンバーが正しいメンバーアドレスに解決せず、分散リカバリのために接続できない可能性があります。 この状況では、MySQL Server <code class="literal">report_host</code> システム変数を使用して、各サーバーによって外部化される一意のホスト名を構成できます。 
        </p></div><p>
        結合メンバーが分散リカバリ用の接続を確立するステップは、次のとおりです:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            メンバーがグループに参加すると、<code class="literal">group_replication_group_seeds</code> システム変数のリストに含まれているシードメンバーのいずれかに接続され、最初はそのリストで指定されている <code class="literal">group_replication_local_address</code> 接続が使用されます。 シードメンバーは、グループのサブセットである場合があります。 
          </p></li><li class="listitem"><p>
            この接続を介して、シードメンバーはグループレプリケーションメンバーシップサービスを使用して、グループ内のオンラインのすべてのメンバーのリストをビューの形式で結合メンバーに提供します。 メンバーシップ情報には、分散リカバリのために各メンバーが提供する分散リカバリエンドポイントまたは標準 SQL クライアント接続の詳細が含まれます。 
          </p></li><li class="listitem"><p>
            参加メンバーは、<a class="xref" href="group-replication.html#group-replication-distributed-recovery-fault" title="18.4.3.4 分散リカバリのフォルトトレランス">セクション18.4.3.4「分散リカバリのフォルトトレランス」</a> で説明されている動作に従って、分散リカバリのドナーとなる適切なグループメンバーをこのリストから選択します。
          </p></li><li class="listitem"><p>
            その後、参加メンバーは、ドナーによって通知された分散リカバリエンドポイントを使用してドナーへの接続を試行し、それぞれをリストに指定された順序で試行します。 ドナーがエンドポイントを提供しない場合、参加メンバーはドナー標準 SQL クライアント接続を使用して接続を試みます。 接続の SSL 要件は、<a class="xref" href="group-replication.html#group-replication-distributed-recovery-connections-ssl" title="18.4.3.1.4 分散リカバリの SSL および認証">セクション18.4.3.1.4「分散リカバリの SSL および認証」</a> で説明されている <code class="literal">group_replication_recovery_ssl_*</code> オプションで指定されているとおりです。 
          </p></li><li class="listitem"><p>
            参加メンバーが選択したドナーに接続できない場合、<a class="xref" href="group-replication.html#group-replication-distributed-recovery-fault" title="18.4.3.4 分散リカバリのフォルトトレランス">セクション18.4.3.4「分散リカバリのフォルトトレランス」</a> で説明されている動作に従って、他の適切なドナーで再試行します。 参加メンバーが接続を確立せずに通知されたエンドポイントのリストを使い果たした場合、ドナー標準 SQL クライアント接続にフォールバックするのではなく、別のドナーに切り替えることに注意してください。 
          </p></li><li class="listitem"><p>
            参加メンバーがドナーとの分散リカバリ接続を確立すると、<a class="xref" href="group-replication.html#group-replication-distributed-recovery" title="18.4.3 分散リカバリ">セクション18.4.3「分散リカバリ」</a> で説明されているように、その接続が状態転送に使用されます。 使用される接続のホストとポートは、参加メンバーログに表示されます。 リモートクローニング操作を使用する場合、参加メンバーが操作の最後に再起動すると、バイナリログからの状態転送用に新しいドナーとの接続が確立されます。 これは、リモートクローニング操作に使用される元のドナーとは異なるメンバーへの接続であるか、元のドナーへの別の接続である可能性があります。 いずれの場合も、分散リカバリプロセスは元のドナーと同じ方法で続行されます。 
          </p></li></ol></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-distributed-recovery-connections-endpoints"></a>18.4.3.1.1 分散リカバリエンドポイントのアドレスの選択</h5></div></div></div><p>
          分散リカバリエンドポイントとして <code class="literal">group_replication_advertise_recovery_endpoints</code> システム変数によって提供される IP アドレスは、MySQL Server 用に構成する必要はありません (つまり、<code class="literal">admin_address</code> システム変数または <code class="literal">bind_address</code> システム変数のリストで指定する必要はありません)。 これらはサーバーに割り当てる必要があります。 使用するホスト名は、ローカル IP アドレスに解決される必要があります。 IPv4 および IPv6 アドレスを使用できます。 
        </p><p>
          分散リカバリエンドポイントに指定するポートは、MySQL Server 用に構成する必要があるため、<code class="literal">port</code>、<code class="literal">report_port</code> または <code class="literal">admin_port</code> システム変数で指定する必要があります。 サーバーは、これらのポートで TCP/IP 接続をリスニングする必要があります。 <code class="literal">admin_port</code> を指定する場合、分散リカバリのレプリケーションユーザーが接続するには <code class="literal">SERVICE_CONNECTION_ADMIN</code> 権限が必要です。 <code class="literal">admin_port</code> を選択すると、分散リカバリ接続が通常の MySQL クライアント接続とは別に維持されます。 
        </p><p>
          メンバーの結合では、リストで指定された順序で各エンドポイントが順に試行されます。 <code class="literal">group_replication_advertise_recovery_endpoints</code> がエンドポイントのリストではなく <code class="literal">DEFAULT</code> に設定されている場合、標準 SQL クライアント接続が提供されます。 標準 SQL クライアント接続は分散リカバリエンドポイントのリストに自動的には含まれず、エンドポイントのドナーリストが接続なしで使い果たされた場合、フォールバックとして提供されないことに注意してください。 標準 SQL クライアント接続を多数の分散リカバリエンドポイントのいずれかとして提供する場合は、<code class="literal">group_replication_advertise_recovery_endpoints</code> で指定されたリストに明示的に含める必要があります。 接続の最後の手段として機能するように、最後の場所に配置できます。 
        </p><p>
          グループメンバー分散リカバリエンドポイント (エンドポイントが指定されていない場合は標準 SQL クライアント接続) は、<code class="literal">group_replication_ip_allowlist</code> (MySQL 8.0.22) または <code class="literal">group_replication_ip_whitelist</code> システム変数で指定されたグループレプリケーション許可リストに追加する必要はありません。 allowlist は、メンバーごとに <code class="literal">group_replication_local_address</code> によって指定されたアドレスに対してのみ使用されます。 分散リカバリのためにアドレスを取得するには、参加メンバーは allowlist によって許可されたグループへの初期接続を持っている必要があります。 
        </p><p>
          リストした分散リカバリエンドポイントは、システム変数が設定されたとき、および <code class="literal">START GROUP_REPLICATION</code> ステートメントが発行されたときに検証されます。 リストを正しく解析できない場合、またはサーバーがリスニングしていないためにホスト上でいずれかのエンドポイントにアクセスできない場合、Group Replication はエラーをログに記録し、起動しません。 
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-recovery-compression"></a>18.4.3.1.2 分散リカバリの圧縮</h5></div></div></div><p>
          MySQL 8.0.18 から、ドナーバイナリログからの状態転送によって、分散リカバリの圧縮をオプションで構成できます。 圧縮は、ネットワーク帯域幅が制限され、ドナーが多数のトランザクションを参加メンバーに転送する必要がある分散リカバリに役立ちます。 <code class="literal">group_replication_recovery_compression_algorithm</code> および <code class="literal">group_replication_recovery_zstd_compression_level</code> システム変数は、ドナーのバイナリログから状態転送を実行するときに使用される、許可される圧縮アルゴリズムと <code class="literal">zstd</code> 圧縮レベルを構成します。 詳細は、<a class="xref" href="programs.html#connection-compression-control" title="4.2.8 接続圧縮制御">セクション4.2.8「接続圧縮制御」</a>を参照してください。 
        </p><p>
          これらの圧縮設定は、リモートクローニング操作には適用されないことに注意してください。 リモートクローニング操作を分散リカバリに使用する場合、クローンプラグインの <code class="literal">clone_enable_compression</code> 設定が適用されます。 
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-distributed-recovery-connections-user"></a>18.4.3.1.3 分散リカバリのレプリケーションユーザー</h5></div></div></div><p>
          分散リカバリでは、グループレプリケーションがメンバー間の直接レプリケーションチャネルを確立できるように、適切な権限を持つレプリケーションユーザーが必要です。 レプリケーションユーザーには、リモートクローニング操作のためにドナーでクローンユーザーとして機能する適切な権限も必要です。 すべてのグループメンバーで分散リカバリに同じレプリケーションユーザーを使用する必要があります。 このレプリケーションユーザーを設定する手順は、<a class="xref" href="group-replication.html#group-replication-user-credentials" title="18.2.1.3 分散リカバリのユーザー資格証明">セクション18.2.1.3「分散リカバリのユーザー資格証明」</a> を参照してください。 レプリケーションユーザー資格証明を保護する手順は、<a class="xref" href="group-replication.html#group-replication-secure-user" title="18.5.3.1 分散リカバリのためのセキュアなユーザー資格証明">セクション18.5.3.1「分散リカバリのためのセキュアなユーザー資格証明」</a> を参照してください。 
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-distributed-recovery-connections-ssl"></a>18.4.3.1.4 分散リカバリの SSL および認証</h5></div></div></div><p>
          分散リカバリ用の SSL は、サーバーの SSL 設定および <code class="literal">group_replication_ssl_mode</code> システム変数によって決定される通常のグループ通信用の SSL とは別に構成されます。 分散リカバリ接続の場合、専用のグループレプリケーション分散リカバリ SSL システム変数を使用して、分散リカバリ専用の証明書および暗号の使用を構成できます。 
        </p><p>
          デフォルトでは、分散リカバリ接続に SSL は使用されません。 これをアクティブ化するには、<a class="xref" href="group-replication.html#group-replication-distributed-recovery-securing" title="18.5.3 分散リカバリ接続の保護">セクション18.5.3「分散リカバリ接続の保護」</a> の説明に従って、<code class="literal">group_replication_recovery_use_ssl=ON</code> を設定し、Group Replication 分散リカバリ SSL システム変数を構成します。 SSL を使用するように設定されたレプリケーションユーザーが必要です。 
        </p><p>
          分散リカバリが SSL を使用するように構成されている場合、グループレプリケーションは、リモートクローニング操作およびドナーのバイナリログからの状態転送にこの設定を適用します。 Group Replication は、クローン SSL オプション (<code class="literal">clone_ssl_ca</code>、<code class="literal">clone_ssl_cert</code> および <code class="literal">clone_ssl_key</code>) の設定を、対応する Group Replication 分散リカバリオプション (<code class="literal">group_replication_recovery_ssl_ca</code>、<code class="literal">group_replication_recovery_ssl_cert</code> および <code class="literal">group_replication_recovery_ssl_key</code>) の設定と一致するように自動的に構成します。 
        </p><p>
          分散リカバリに SSL を使用せず (<code class="literal">group_replication_recovery_use_ssl</code> が <code class="literal">OFF</code> に設定されている)、Group Replication のレプリケーションユーザーアカウントが <code class="literal">caching_sha2_password</code> プラグイン (MySQL 8.0 のデフォルト) または <code class="literal">sha256_password</code> プラグインで認証される場合、RSA キーペアがパスワード交換に使用されます。 この場合、<a class="xref" href="group-replication.html#group-replication-caching-sha2-user-credentials" title="18.5.3.1.1 キャッシュ SHA-2 認証プラグインを使用するレプリケーションユーザー">セクション18.5.3.1.1「キャッシュ SHA-2 認証プラグインを使用するレプリケーションユーザー」</a> で説明されているように、<code class="literal">group_replication_recovery_public_key_path</code> システム変数を使用して RSA 公開キーファイルを指定するか、<code class="literal">group_replication_recovery_get_public_key</code> システム変数を使用してソースから公開キーをリクエストします。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-cloning"></a>18.4.3.2 分散リカバリのためのクローニング</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-cloning-prerequisites">18.4.3.2.1 クローニングの前提条件</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-cloning-threshold">18.4.3.2.2 クローニングのしきい値</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-cloning-operations">18.4.3.2.3 クローニング操作</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-cloning-manual">18.4.3.2.4 その他の目的でのクローニング</a></span></dt></dl></div><p>
        MySQL Server クローンプラグインは、MySQL 8.0.17 から入手できます。 グループ内の分散リカバリにリモートクローニング操作を使用する場合は、この機能をサポートするために、事前に既存のメンバーを設定してメンバーを結合する必要があります。 この関数をグループで使用しない場合は、設定しないでください。この場合、Group Replication はバイナリログからの状態転送のみを使用します。 
      </p><p>
        クローニングを使用するには、リモートクローニング操作をサポートするために、少なくとも 1 つの既存のグループメンバーと参加メンバーを事前に設定する必要があります。 少なくとも、クローンプラグインをドナーにインストールしてメンバーに参加し、分散リカバリのためにレプリケーションユーザーに <code class="literal">BACKUP_ADMIN</code> 権限を付与し、<code class="literal">group_replication_clone_threshold</code> システム変数を適切なレベルに設定する必要があります。 ドナーの最大可用性を確保するには、リモートクローニング操作をサポートするように、現在および将来のすべてのグループメンバーを設定することをお薦めします。 
      </p><p>
        リモートクローニング操作では、ドナーからデータを転送する前に、結合メンバーからユーザー作成のテーブルスペースおよびデータが削除されることに注意してください。 進行中に操作が停止した場合、結合メンバーに部分データが残されるか、データが残されない可能性があります。 これを修復するには、Group Replication が自動的に行うリモートクローニング操作を再試行します。 
      </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-cloning-prerequisites"></a>18.4.3.2.1 クローニングの前提条件</h5></div></div></div><p>
          クローンプラグインを設定および構成する完全な手順については、<a class="xref" href="server-administration.html#clone-plugin" title="5.6.7 クローンプラグイン">セクション5.6.7「クローンプラグイン」</a> を参照してください。 リモートクローニング操作の詳細な前提条件については、<a class="xref" href="server-administration.html#clone-plugin-remote" title="5.6.7.3 リモートデータのクローニング">セクション5.6.7.3「リモートデータのクローニング」</a> を参照してください。 Group Replication の場合、次の重要なポイントと相違点に注意してください: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              ドナー (既存のグループメンバー) および受信者 (参加メンバー) にクローンプラグインがインストールされ、アクティブである必要があります。 これを行う手順は、<a class="xref" href="server-administration.html#clone-plugin-installation" title="5.6.7.1 クローンプラグインのインストール">セクション5.6.7.1「クローンプラグインのインストール」</a> を参照してください。 
            </p></li><li class="listitem"><p>
              ドナーと受信者は、同じオペレーティングシステム上で実行され、同じ MySQL Server バージョン (MySQL 8.0.17 以上でクローンプラグインをサポートする必要があります) である必要があります。 したがって、クローニングは、メンバーが異なる MySQL Server バージョンを実行するグループには適していません。 
            </p></li><li class="listitem"><p>
              ドナーと受信者は Group Replication プラグインをインストールしてアクティブにする必要があり、ドナーでアクティブなその他のプラグイン (キーリングプラグインなど) も受信者でアクティブにする必要があります。
            </p></li><li class="listitem"><p>
              分散リカバリが SSL (<code class="literal">group_replication_recovery_use_ssl=ON</code>) を使用するように構成されている場合、グループレプリケーションはリモートクローニング操作にこの設定を適用します。 Group Replication は、クローン SSL オプション (<code class="literal">clone_ssl_ca</code>、<code class="literal">clone_ssl_cert</code> および <code class="literal">clone_ssl_key</code>) の設定を、対応する Group Replication 分散リカバリオプション (<code class="literal">group_replication_recovery_ssl_ca</code>、<code class="literal">group_replication_recovery_ssl_cert</code> および <code class="literal">group_replication_recovery_ssl_key</code>) の設定と一致するように自動的に構成します。 
            </p></li><li class="listitem"><p>
              レプリケーショングループに参加するために、<code class="literal">clone_valid_donor_list</code> システム変数に有効なドナーのリストを設定する必要はありません。 グループレプリケーションは、既存のグループメンバーからドナーを選択した後、この設定を自動的に構成します。 リモートクローニング操作では、サーバー SQL プロトコルのホスト名とポートが使用されることに注意してください。 
            </p></li><li class="listitem"><p>
              クローンプラグインには、リモートクローニング操作のネットワーク負荷およびパフォーマンスへの影響を管理するための多数のシステム変数があります。 グループレプリケーションではこれらの設定は構成されないため、必要に応じて設定したり、デフォルト設定を許可できます。 リモートクローニング操作を分散リカバリに使用する場合は、Group Replication 圧縮設定ではなくクローンプラグインの <code class="literal">clone_enable_compression</code> 設定が操作に適用されることに注意してください。 
            </p></li><li class="listitem"><p>
              受信者に対してリモートクローニング操作を起動するために、グループレプリケーションでは、<code class="literal">CLONE_ADMIN</code> 権限がすでにある内部 <code class="literal">mysql.session</code> ユーザーが使用されるため、これを設定する必要はありません。
            </p></li><li class="listitem"><p>
              リモートクローニング操作のドナーのクローンユーザーとして、Group Replication では分散リカバリ用に設定したレプリケーションユーザー (<a class="xref" href="group-replication.html#group-replication-user-credentials" title="18.2.1.3 分散リカバリのユーザー資格証明">セクション18.2.1.3「分散リカバリのユーザー資格証明」</a> で説明) が使用されます。 したがって、クローニングをサポートするすべてのグループメンバーに対して、このレプリケーションユーザーに <code class="literal">BACKUP_ADMIN</code> 権限を付与する必要があります。 また、グループレプリケーション用にメンバーを構成する場合は、レプリケーションユーザーにメンバーへの参加権限を付与します。これは、メンバーがグループに参加した後にドナーとして機能できるためです。 すべてのグループメンバーで分散リカバリに同じレプリケーションユーザーが使用されます。 既存のメンバーに対してこの権限をレプリケーションユーザーに付与するには、バイナリロギングを無効にして各グループメンバーに対して、またはバイナリロギングを有効にしているグループメンバーに対して、次のステートメントを発行します: 
            </p><pre class="programlisting">GRANT BACKUP_ADMIN ON *.* TO <em class="replaceable"><code>rpl_user</code></em>@'%';
</pre></li><li class="listitem"><p>
              <code class="literal">START GROUP_REPLICATION</code> を使用して、以前に <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> を使用してユーザー資格証明を提供したサーバー上のレプリケーションユーザー資格証明を指定する場合は、リモートクローニング操作を実行する前に、必ずレプリケーションメタデータリポジトリからユーザー資格証明を削除してください。 また、結合メンバーに <code class="literal">group_replication_start_on_boot=OFF</code> が設定されていることを確認します。 その手順は、<a class="xref" href="group-replication.html#group-replication-distributed-recovery-securing" title="18.5.3 分散リカバリ接続の保護">セクション18.5.3「分散リカバリ接続の保護」</a>を参照してください。 ユーザー資格証明の設定を解除しない場合、リモートクローニング操作中に参加メンバーに転送されます。 その後、元のメンバーまたはそこからクローニングされたメンバーのいずれかで、<code class="literal">group_replication_recovery</code> チャネルが誤って格納された資格証明で起動される可能性があります。 サーバー起動時のグループレプリケーションの自動開始 (リモートクローニング操作後を含む) では、格納されたユーザー資格証明が使用され、オペレータが <code class="literal">START GROUP_REPLICATION</code> コマンドで分散リカバリ資格証明を指定しなかった場合にも使用されます。 
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-cloning-threshold"></a>18.4.3.2.2 クローニングのしきい値</h5></div></div></div><p>
          グループメンバーがクローニングをサポートするように設定されている場合、<code class="literal">group_replication_clone_threshold</code> システム変数は、分散リカバリでリモートクローニング操作を使用するためのしきい値をトランザクション数で指定します。 ドナー上のトランザクションと参加メンバー上のトランザクションの間のギャップがこの数より大きい場合は、技術的に可能であれば、参加メンバーへの状態転送にリモートクローニング操作が使用されます。 グループレプリケーションでは、既存のグループメンバーの <code class="literal">gtid_executed</code> セットに基づいて、しきい値を超えたかどうかが計算されます。 トランザクションのギャップが大きい場合にリモートクローニング操作を使用すると、事前にグループデータをサーバーに手動で転送せずに新しいメンバーをグループに追加できます。また、非常に古いメンバーをより効率的にキャッチアップできます。 
        </p><p>
          <code class="literal">group_replication_clone_threshold</code> Group Replication システム変数のデフォルト設定は非常に高いため (GTID 内のトランザクションに許可されている最大シーケンス番号)、バイナリログからの状態転送が可能な場合は、クローニングが事実上非アクティブ化されます。 グループレプリケーションで、より適切な状態転送のリモートクローニング操作を選択できるようにするには、システム変数を設定して、クローニングを実行するトランザクションのギャップとしてトランザクション数を指定します。 
        </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
            アクティブグループの <code class="literal">group_replication_clone_threshold</code> には低い設定を使用しないでください。 リモートクローニング操作の進行中にしきい値を超える数のトランザクションがグループで発生した場合、参加メンバーは再起動後にリモートクローニング操作を再度トリガーし、これを無期限に続行できます。 この状況を回避するには、リモートクローニング操作にかかる時間内にグループ内で発生すると予想されるトランザクション数よりも大きい数をしきい値に設定してください。 
          </p></div><p>
          ドナーバイナリログからの状態転送が不可能な場合、たとえば、参加メンバーに必要なトランザクションが既存のグループメンバーのバイナリログで使用できないため、グループレプリケーションはしきい値に関係なくリモートクローニング操作を実行しようとします。 グループレプリケーションは、既存のグループメンバーの <code class="literal">gtid_purged</code> セットに基づいてこれを識別します。 必要なトランザクションがどのメンバーバイナリログファイルでも使用できない場合、<code class="literal">group_replication_clone_threshold</code> システム変数を使用してクローニングを非アクティブ化することはできません。この状況では、クローニングは、結合するメンバーに手動でデータを転送する唯一の代替手段であるためです。 
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-cloning-operations"></a>18.4.3.2.3 クローニング操作</h5></div></div></div><p>
          グループメンバーおよび参加メンバーがクローニング用に設定されている場合、グループレプリケーションによってリモートクローニング操作が管理されます。 データのサイズによっては、リモートクローニング操作の完了に時間がかかる場合があります。 プロセスの監視の詳細は、<a class="xref" href="server-administration.html#clone-plugin-monitoring" title="5.6.7.9 クローニング操作の監視">セクション5.6.7.9「クローニング操作の監視」</a> を参照してください。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            状態の転送が完了すると、Group Replication は参加メンバーを再起動してプロセスを完了します。 <code class="literal">START GROUP_REPLICATION</code> ステートメントでレプリケーションユーザー資格証明を指定するなどの理由で、参加メンバーに <code class="literal">group_replication_start_on_boot=OFF</code> が設定されている場合は、この再起動後に <code class="literal">START GROUP_REPLICATION</code> を手動で再発行する必要があります。 グループレプリケーションの開始に必要な <code class="literal">group_replication_start_on_boot=ON</code> およびその他の設定が構成ファイルで設定されている場合、または <code class="literal">SET PERSIST</code> ステートメントを使用して設定されている場合は、介入する必要はなく、参加メンバーを自動的にオンラインにするプロセスが続行されます。 
          </p></div><p>
          リモートクローニング手順に時間がかかる場合、MySQL 8.0.22 より前のリリースでは、その期間中にグループに対して蓄積された一連の動作保証情報が大きすぎて、参加メンバーに転送できなくなる可能性があります。 その場合、参加メンバーはエラーメッセージをログに記録し、グループには参加しません。 MySQL 8.0.22 から、Group Replication は、このシナリオを回避するために、適用されたトランザクションのガベージコレクションプロセスを異なる方法で管理します。 以前のリリースでは、このエラーが表示された場合、リモートクローニング操作の完了後、2 分間待ってガベージコレクションが行われるようにし、グループ証明情報のサイズを小さくしてください。 次に、結合メンバーに対して次のステートメントを発行して、前の一連の証明情報の適用を停止します: 
        </p><pre class="programlisting">RESET SLAVE FOR CHANNEL group_replication_recovery;
Or from MySQL 8.0.22:
RESET REPLICA FOR CHANNEL group_replication_recovery;
</pre><p>
          リモートクローニング操作では、ドナーから受信者へのテーブルに保持されている設定およびデータがクローニングされます。 Group Replication は、Group Replication チャネルに特に関連する設定を管理します。 グループレプリケーションのローカルアドレスなどの構成ファイルに保持されているグループレプリケーションメンバー設定はクローニングされず、参加メンバーでは変更されません。 グループレプリケーションでは、SSL の使用に関連するチャネル設定も保持されるため、これらは個々のメンバーに固有です。 
        </p><p>
          <code class="literal">group_replication_recovery</code> レプリケーションチャネルのドナーが使用するレプリケーションユーザー資格証明が <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントを使用してレプリケーションメタデータリポジトリに格納されている場合、クローニング後にメンバーに転送されて使用され、そこで有効である必要があります。 格納された資格証明を使用すると、リモートクローニング操作によって状態転送を受信したすべてのグループメンバーは、分散リカバリのレプリケーションユーザーおよびパスワードを自動的に受信します。 <code class="literal">START GROUP_REPLICATION</code> ステートメントでレプリケーションユーザーの資格証明を指定すると、リモートクローニング操作の開始に使用されますが、クローニング後に参加メンバーに転送されず、メンバーによって使用されることはありません。 資格証明を新しいジョイナに転送せず、そこで記録する場合は、<a class="xref" href="group-replication.html#group-replication-distributed-recovery-securing" title="18.5.3 分散リカバリ接続の保護">セクション18.5.3「分散リカバリ接続の保護」</a> の説明に従ってリモートクローニング操作を実行する前に資格証明の設定を解除し、かわりに <code class="literal">START GROUP_REPLICATION</code> を使用してそれらを指定してください。 
        </p><p>
          レプリケーションアプライアンスを保護するために <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントが使用されている場合 (<a class="xref" href="replication.html#replication-privilege-checks-gr" title="17.3.3.2 グループレプリケーションチャネルの権限チェック">セクション17.3.3.2「グループレプリケーションチャネルの権限チェック」</a> を参照)、MySQL 8.0.19 から、ドナーの <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントおよび関連設定が結合メンバーにクローニングされます。 参加メンバーがブート時にグループレプリケーションを開始するように設定されている場合、適切なレプリケーションチャネルの権限チェックにアカウントが自動的に使用されます。 (MySQL 8.0.18 では、多くの制限により、グループレプリケーションチャネルで <code class="literal">PRIVILEGE_CHECKS_USER</code> アカウントを使用しないことをお薦めします。) 
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-cloning-manual"></a>18.4.3.2.4 その他の目的でのクローニング</h5></div></div></div><p>
          Group Replication は、分散リカバリのクローニング操作を開始および管理します。 クローニングをサポートするように設定されたグループメンバーは、ユーザーが手動で開始するクローニング操作にも参加できます。 たとえば、グループメンバーからドナーとしてクローニングして新しいサーバーインスタンスを作成するが、新しいサーバーインスタンスをすぐにグループに参加させない場合やそうでない場合があります。 
        </p><p>
          クローニングをサポートするすべてのリリースで、グループレプリケーションを停止するグループメンバーを含むクローニング操作を手動で開始できます。 クローニングではドナーと受信者のアクティブなプラグインが一致する必要があるため、そのサーバーインスタンスをグループに参加させない場合でも、グループレプリケーションプラグインを他のサーバーインスタンスにインストールしてアクティブにする必要があります。 プラグインをインストールするには、次のステートメントを発行します: 
        </p><pre class="programlisting">INSTALL PLUGIN group_replication SONAME 'group_replication.so';
</pre><p>
          MySQL 8.0.20 より前のリリースでは、操作にグループレプリケーションが実行されているグループメンバーが含まれる場合、クローニング操作を手動で開始することはできません。 クローニング操作で受信者のデータが削除および置換されない場合は、MySQL 8.0.20 からこれを実行できます。 したがって、Group Replication が実行されている場合は、クローニング操作を開始するステートメントに <code class="literal">DATA DIRECTORY</code> 句を含める必要があります。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-tuning-recovery"></a>18.4.3.3 分散リカバリの構成</h4></div></div></div><a class="indexterm" name="idm45563247528144"></a><p>
        グループレプリケーション分散リカバリプロセスのいくつかの側面は、システムに合せて構成できます。
      </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="idm45563247525472"></a>接続試行回数</h5></div></div></div><p>
          バイナリログからの状態転送の場合、Group Replication は、ドナーのプールからドナーに接続しようとしたときに参加メンバーが試行する回数を制限します。 接続が成功せずに接続再試行の制限に達すると、分散リカバリプロシージャはエラーで終了します。 この制限は、参加メンバーがドナーへの接続を試行する合計回数を指定することに注意してください。 たとえば、2 つのグループメンバーが適切なドナーで、接続再試行制限が 4 に設定されている場合、参加メンバーは制限に達する前に各ドナーへの接続を 2 回試行します。 
        </p><p>
          デフォルトの接続再試行制限は 10 です。 この設定は、<code class="literal">group_replication_recovery_retry_count</code> システム変数を使用して構成できます。 次のコマンドは、ドナーへの接続の最大試行回数を 5 に設定します: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL group_replication_recovery_retry_count= 5;</code></strong>
</pre><p>
          リモートクローニング操作の場合、この制限は適用されません。 Group Replication は、バイナリログからの状態転送を開始する前に、クローニングに適した各ドナーへの接続を 1 つだけ試みます。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="idm45563247518400"></a>接続試行のスリープ間隔</h5></div></div></div><p>
          バイナリログからの状態転送の場合、<code class="literal">group_replication_recovery_reconnect_interval</code> システム変数は、ドナーの接続試行の間に分散回復プロセスがスリープする時間を定義します。 分散リカバリは、ドナー接続が試行されるたびにスリープしないことに注意してください。 参加メンバーが同じサーバーに繰り返し接続するのではなく、異なるサーバーに接続しているため、サーバー A に影響する問題がサーバー B に影響しないと想定できます。 したがって、分散リカバリは、可能性のあるすべてのドナーを通過した場合にのみ一時停止します。 グループに参加しているサーバーがグループ内の適切な各ドナーに接続しようとすると、分散リカバリプロセスは <code class="literal">group_replication_recovery_reconnect_interval</code> システム変数で構成された秒数スリープします。 たとえば、2 つのグループメンバーが適切なドナーで、接続再試行制限が 4 に設定されている場合、参加メンバーは各ドナーへの接続を 1 回試行し、接続再試行間隔でスリープしてから、制限に達する前に各ドナーへの接続をさらに試行します。 
        </p><p>
          デフォルトの接続再試行間隔は 60 秒で、この値は動的に変更できます。 次のコマンドは、分散リカバリドナー接続再試行間隔を 120 秒に設定します: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL group_replication_recovery_reconnect_interval= 120;</code></strong>
</pre><p>
          リモートクローニング操作の場合、この間隔は適用されません。 Group Replication は、バイナリログからの状態転送を開始する前に、クローニングに適した各ドナーへの接続を 1 つだけ試みます。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="idm45563247509392"></a>参加メンバーをオンラインとしてマーク</h5></div></div></div><p>
          分散リカバリがドナーから参加メンバーへの状態転送を正常に完了したら、参加メンバーをグループ内でオンラインとしてマークし、参加の準備ができます。 デフォルトでは、これは参加メンバーが欠落していたすべてのトランザクションを受信して適用した後に実行されます。 必要に応じて、参加メンバーが欠落していたすべてのトランザクションを受信して認証 (つまり、競合検出が完了) した後、適用する前に、参加メンバーをオンラインとしてマークできます。 これを行う場合は、<code class="literal">group_replication_recovery_complete_at</code> システム変数を使用して代替設定の <code class="literal">TRANSACTIONS_CERTIFIED</code> を指定します。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-distributed-recovery-fault"></a>18.4.3.4 分散リカバリのフォルトトレランス</h4></div></div></div><p>
        グループレプリケーション分散リカバリプロセスには、プロセス中に問題が発生した場合にフォルトトレランスを確保するためのいくつかの組込みメジャーがあります。
      </p><p>
        分散リカバリのドナーは、現在のビューの適切なオンライングループメンバーの既存のリストからランダムに選択されます。 ランダムドナーを選択することは、複数のメンバーがグループに入るときに同じサーバーが複数回選択されない可能性があることを意味します。 MySQL 8.0.17 からは、バイナリログからの状態転送の場合、ジョイナは、それ自体と比較して下位または同等のパッチバージョンの MySQL Server を実行しているドナーのみを選択します。 以前のリリースでは、すべてのオンラインメンバーがドナーになることが許可されていました。 リモートクローニング操作の場合、ジョイナは、それ自体と同じパッチバージョンを実行しているドナーのみを選択します。 結合メンバーは、操作の最後に再起動すると、バイナリログからの状態転送用に新しいドナーとの接続を確立します。これは、リモートクローニング操作に使用される元のドナーとは異なるメンバーである可能性があります。 
      </p><p>
        次の状況では、Group Replication は分散リカバリのエラーを検出し、新しいドナーに自動的にスイッチオーバーして、状態転送を再試行します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="emphasis"><em>接続エラー</em></span> - 候補者ドナーへの接続に認証の問題があるか、別の問題があります。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>レプリケーションエラー</em></span> - バイナリログからの状態転送に使用されているレプリケーションスレッド (受信側スレッドまたは適用側スレッド) のいずれかが失敗します。 この状態転送方法では既存の MySQL レプリケーションフレームワークが使用されるため、一時的なエラーによってレシーバスレッドまたはアプライヤスレッドでエラーが発生する可能性があります。 
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>リモートクローニング操作エラー</em></span> - リモートクローニング操作が失敗するか、完了する前に停止します。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>ドナーがグループから離れる</em></span> - ドナーはグループを離れるか、状態転送の進行中にドナーで Group Replication が停止します。
          </p></li></ul></div><p>
        「パフォーマンススキーマ」テーブル <code class="literal">replication_applier_status_by_worker</code> に、最後の再試行の原因となったエラーが表示されます。 このような状況では、エラーに続く新しい接続が新しい候補者ドナーで試行されます。 エラーが発生した場合に別のドナーを選択することは、新しい候補者ドナーに同じエラーがない可能性があることを意味します。 クローンプラグインがインストールされている場合、Group Replication は、適切なオンラインクローンサポートドナーをそれぞれ最初に使用してリモートクローニング操作を試みます。 これらの試行がすべて失敗した場合、グループレプリケーションはバイナリログからの状態転送を、可能であればすべての適切なドナーとともに順に試行します。 
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          リモートクローニング操作の場合、リモートクローニング操作でドナーからのデータの転送が開始される前に、受信者 (参加メンバー) のユーザー作成のテーブルスペースおよびデータが削除されます。 リモートクローニング操作が開始しても完了しない場合、参加メンバーは元のデータファイルの一部またはユーザーデータなしで残される可能性があります。 データが完全にクローニングされる前にクローニング操作が停止した場合、ドナーによって転送されたデータは受信者から削除されます。 この状況は、Group Replication が自動的に行うクローニング操作を再試行することで修復できます。 
        </p></div><p>
        次の状況では、分散リカバリプロセスを完了できず、参加メンバーはグループを離れます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="emphasis"><em>パージ済トランザクション</em></span> - 参加メンバーに必要なトランザクションがオンライングループメンバーのバイナリログファイルに存在せず、リモートクローニング操作でデータを取得できません (クローンプラグインがインストールされていないか、クローニングが可能なすべてのドナーで試行されたが失敗したため)。 したがって、参加メンバーはグループをキャッチアップできません。 
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>競合するトランザクション</em></span> - 結合メンバーには、グループに存在しないトランザクションがすでに含まれています。 リモートクローニング操作が実行された場合、結合メンバーのデータディレクトリが消去されるため、これらのトランザクションは削除されて失われます。 ドナーバイナリログからの状態転送が実行された場合、これらのトランザクションはグループトランザクションと競合する可能性があります。 
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>接続再試行制限に達しました</em></span> - 参加メンバーは、接続再試行制限で許可されているすべての接続試行を行いました。 これは、<code class="literal">group_replication_recovery_retry_count</code> システム変数を使用して構成できます (<a class="xref" href="group-replication.html#group-replication-tuning-recovery" title="18.4.3.3 分散リカバリの構成">セクション18.4.3.3「分散リカバリの構成」</a> を参照)。 
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>ドナーはこれ以上いません</em></span> - 参加メンバーは、オンラインクローンがサポートする各ドナーとのリモートクローニング操作を順に試行し (クローンプラグインがインストールされている場合)、可能であれば適切な各オンラインドナーを使用してバイナリログからの状態転送を正常に試行しませんでした。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>参加メンバーはグループから退出</em></span> - 参加メンバーはグループを離れるか、状態転送の進行中に参加メンバーで Group Replication が停止します。
          </p></li></ul></div><p>
        参加メンバーが意図せずグループを離れた場合、最後のメンバーを除く前述の状況では、<code class="literal">group_replication_exit_state_action</code> システム変数で指定されたアクションの実行に進みます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-view-changes"></a>18.4.3.5 分散リカバリの仕組み</h4></div></div></div><a class="indexterm" name="idm45563247472832"></a><a class="indexterm" name="idm45563247470640"></a><p>
        Group Replication 分散回復プロセスがバイナリログから状態転送を実行しているときに、参加メンバーを特定の時点までドナーと同期するために、参加メンバーとドナーは GTID を利用します (<a class="xref" href="replication.html#replication-gtids" title="17.1.3 グローバルトランザクション識別子を使用したレプリケーション">セクション17.1.3「グローバルトランザクション識別子を使用したレプリケーション」</a> を参照)。 ただし、GTID は、参加メンバーが欠落しているトランザクションを認識する手段のみを提供します。 グループに参加するサーバーがキャッチアップする必要がある特定の時点をマークしたり、証明書情報を伝達したりするのに役立ちません。 これはバイナリログビューマーカーのジョブであり、バイナリログストリーム内のビューの変更をマークし、追加のメタデータ情報も含まれており、結合するメンバーに動作保証関連データが提供されます。 
      </p><p>
        このトピックでは、ビュー変更の役割とビュー変更識別子、およびバイナリログから状態転送を実行する手順について説明します。
      </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-view-and-view-changes"></a>変更の表示および表示</h5></div></div></div><p>
          <span class="emphasis"><em>view</em></span> は、現在の構成にアクティブに参加しているメンバーのグループ (特定の時点) に対応します。 グループ内で正しくオンラインで機能しています。 
        </p><p>
          <span class="emphasis"><em>変更の表示</em></span>は、メンバーの参加や離脱など、グループ構成の変更が発生したときに発生します。 グループメンバーシップが変更されると、独立したビュー変更が同じ論理ポイントインタイムのすべてのメンバーに伝達されます。 
        </p><p>
          <span class="emphasis"><em>ビュー識別子</em></span>はビューを一意に識別します。 ビューの変更が発生するたびに生成されます。 
        </p><p>
          グループ通信レイヤーでは、ビューの変更とそれに関連付けられたビュー識別子により、メンバー結合の前後に交換されたデータ間の境界がマークされます。 この概念はバイナリログイベントを介して実装されます:「変更ログイベントの表示」。 ビュー識別子は、グループメンバーシップでの変更の前後に送信されたトランザクションを境界設定するために記録されます。 
        </p><p>
          ビュー識別子自体は 2 つの部分から作成されます: ランダムに生成された部分と単調に増加する整数。 ランダムに生成されたパーツは、グループの作成時に生成され、グループに少なくとも 1 つのメンバーが存在する間は変更されません。 整数は、ビューの変更が発生するたびに増分されます。 これら 2 つの異なる部分を使用すると、ビュー識別子で、メンバーの参加または離脱によって発生した増分グループ変更を識別したり、すべてのメンバーがグループ全体の停止でグループを離れる状況を識別したりできます。したがって、グループがどのビューにあったかに関する情報は残りません。 グループが最初から起動されたときに識別子の一部をランダムに生成することで、バイナリログ内のデータマーカーが一意のままになり、今後分散リカバリで問題が発生する可能性があるため、完全グループのシャットダウン後も同じ識別子は再利用されません。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-begin-stable-group"></a>Begin: 安定グループ</h5></div></div></div><p>
          すべてのサーバーはオンラインであり、グループからの受信トランザクションを処理しています。 一部のサーバーは、レプリケートされたトランザクションに関して少し遅れている可能性がありますが、最終的には収束します。 グループは、分散データベースおよびレプリケートされたデータベースとして機能します。 
        </p><div class="figure"><a name="idm45563247454592"></a><p class="title"><b>図 18.8 安定グループ</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/gr-recovery-1.png" width="534" height="525" alt="サーバー S1、S2 および S3 はグループのメンバーです。 すべてのバイナリログの最新の項目は、トランザクション T20 です。"></div></div></div><br class="figure-break"></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-view-change-member-joins"></a>変更の表示: メンバー結合</h5></div></div></div><p>
          新しいメンバーがグループに参加してビューの変更が実行されるたびに、すべてのオンラインサーバーは実行のためにビュー変更ログイベントをキューに入れます。 これは、ビューが変更される前に、複数のトランザクションをサーバー上でキューに入れて適用できるため、キューに入れられます。そのため、これらのトランザクションは古いビューに属します。 ビュー変更イベントをキューに入れると、その発生時の正しいマーキングが保証されます。 
        </p><p>
          一方、参加メンバーは、ビュー抽象化を介してメンバーシップサービスによって記述されているように、オンラインサーバーのリストから適切なドナーを選択します。 メンバーがビュー 4 に参加し、オンラインメンバーがビュー変更イベントをバイナリログに書き込みます。 
        </p><div class="figure"><a name="idm45563247443744"></a><p class="title"><b>図 18.9 A メンバー結合</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/gr-recovery-2.png" width="654" height="559" alt="Server S4 がグループに参加し、ドナーを探します。 サーバー S1、S2 および S3 は、それぞれバイナリログのビューチェンジエントリ VC4 をキューに入れます。 一方、サーバー S1 は新しいトランザクション T21 を受信しています。"></div></div></div><br class="figure-break"></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-state-transfer-catching-up"></a>州移管: キャッチアップ</h5></div></div></div><p>
          グループメンバーと結合メンバーがクローンプラグインを使用して設定されていて (<a class="xref" href="group-replication.html#group-replication-cloning" title="18.4.3.2 分散リカバリのためのクローニング">セクション18.4.3.2「分散リカバリのためのクローニング」</a> を参照)、結合メンバーとグループの間のトランザクションの差がリモートクローニング操作 (<code class="literal">group_replication_clone_threshold</code>) に設定されたしきい値を超えた場合、グループレプリケーションはリモートクローニング操作で分散回復を開始します。 必要なトランザクションがどのグループメンバーのバイナリログファイルにも存在しない場合は、リモートクローニング操作も実行されます。 リモートクローニング操作中に、参加メンバーの既存のデータが削除され、ドナーデータのコピーに置き換えられます。 リモートクローニング操作が完了し、参加メンバーが再起動すると、ドナーのバイナリログから状態転送が実行され、リモートクローニング操作の進行中にグループが適用したトランザクションが取得されます。 大きなトランザクションギャップがない場合、またはクローンプラグインがインストールされていない場合、Group Replication はドナーのバイナリログからの状態転送に直接進みます。 
        </p><p>
          ドナーバイナリログからのステート転送の場合、参加メンバーとドナーとステート転送の間の接続が確立されます。 このドナーとの相互作用は、グループアプライヤスレッドに参加しているサーバーが、グループに参加しているサーバーがグループに入ったときにトリガーされたビュー変更に対応するビュー変更ログイベントを処理するまで続きます。 つまり、グループに参加するサーバーは、すでに存在するビューマーカーと一致するビュー識別子を持つマーカーに到達するまで、ドナーからレプリケートします。 
        </p><div class="figure"><a name="idm45563247428880"></a><p class="title"><b>図 18.10 州移管: キャッチアップ</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/gr-recovery-3.png" width="603" height="525" alt="Server S4 は、ドナーとしてサーバー S2 を選択しました。 状態転送は、ビューチェンジエントリ VC4 に到達する (view_id = VC4) まで、サーバー S2 からサーバー S4 に実行されます。 Server S4 では、状態転送に一時的なアプライヤバッファが使用され、そのバイナリログは現在空です。"></div></div></div><br class="figure-break"><p>
          ビュー識別子はグループ内のすべてのメンバーに同時に送信されるため、グループに参加しているサーバーはレプリケートを停止するビュー識別子を認識します。 これにより、ビュー識別子によって各グループビューに属するデータが明確にマークされるため、複雑な GTID セット計算が回避されます。 
        </p><p>
          グループに参加するサーバーはドナーからレプリケートしていますが、グループからの受信トランザクションもキャッシュしています。 最終的に、ドナーからのレプリケートを停止し、キャッシュされているものを適用するように切り替えます。 
        </p><div class="figure"><a name="idm45563247419648"></a><p class="title"><b>図 18.11 キュー済トランザクション</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/gr-recovery-4.png" width="644" height="525" alt="状態転送が完了しました。 Server S4 は、T20 までのトランザクションを適用し、それらをバイナリログに書き込みました。 Server S4 には、ビューの変更後に到着したトランザクション T21 が、リカバリ中に一時的なアプライヤバッファにキャッシュされています。"></div></div></div><br class="figure-break"></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-finish-caught-up"></a>終了: キャッチアップ</h5></div></div></div><p>
          グループに参加しているサーバーが予想されるビュー識別子を持つビュー変更ログイベントを認識すると、ドナーへの接続が終了し、キャッシュされたトランザクションの適用が開始されます。 これはバイナリログのマーカーとして機能し、ビューの変更を区切りますが、ビューの変更ログイベントも別の役割を果たします。 これは、グループに参加しているサーバーがグループに入ったときにすべてのサーバーによって認識される動作保証情報、つまり最後のビューの変更を伝達します。 そうしないと、グループに参加しているサーバーには、後続のトランザクションを認証 (競合の検出) するために必要な情報がありません。 
        </p><p>
          キャッチアップの期間は、ワークロードおよびグループへの受信トランザクションの割合に依存するため、決定的ではありません。 このプロセスは完全にオンラインであり、グループに参加しているサーバーはグループ内の他のサーバーをキャッチアップ中にブロックしません。 したがって、このステージに移動すると、サーバーがグループに参加しているトランザクションの数が遅れるため、ワークロードに応じて増減できます。 
        </p><p>
          グループに参加しているサーバーがキューに入れられていないトランザクションに到達し、格納されているデータが他のメンバーと等しい場合、パブリック状態はオンラインに変わります。
        </p><div class="figure"><a name="idm45563247406992"></a><p class="title"><b>図 18.12 インスタンスオンライン</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/gr-recovery-5.png" width="597" height="525" alt="Server S4 がグループのオンラインメンバーになりました。 キャッシュされたトランザクション T21 が適用されているため、バイナリログには他のグループメンバーのバイナリログと同じ項目が表示され、一時的なアプライヤバッファは不要になりました。 新しい受信トランザクション T22 が受信され、すべてのグループメンバーによって適用されるようになりました。"></div></div></div><br class="figure-break"></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-network-partitioning"></a>18.4.4 ネットワークパーティション化</h3></div></div></div><a class="indexterm" name="idm45563247398208"></a><p>
      レプリケートする必要がある変更が発生するたびに、グループはコンセンサスを達成する必要があります。 これは通常のトランザクションの場合ですが、グループメンバーシップの変更およびグループの一貫性を維持する一部の内部メッセージングにも必要です。 コンセンサスでは、グループメンバーの大部分が特定の決定に同意する必要があります。 大部分のグループメンバーが失われると、大部分またはクォーラムを保護できないため、グループは進行できず、ブロックされます。 
    </p><p>
      複数の標準的な障害が発生するとクォーラムが失われ、大部分のサーバーがグループから突然削除される可能性があります。 たとえば、5 つのサーバーのグループでは、それらの 3 つが一度にサイレントになった場合、大部分が危険にさらされるため、クォーラムを達成できません。 実際、残りの 2 つは、他の 3 つのサーバーがクラッシュしたかどうか、またはネットワークパーティションがこれら 2 つのみを分離しているため、グループを自動的に再構成できません。 
    </p><p>
      一方、サーバーが自発的にグループを終了した場合は、再構成する必要があることをグループに指示します。 これは実際には、離れるサーバーが他のサーバーに離れることを通知することを意味します。 つまり、他のメンバーはグループを適切に再構成でき、メンバーシップの一貫性が維持され、大部分が再計算されます。 たとえば、3 つのサーバーが一度に残る 5 つのサーバーの前述のシナリオでは、3 つのサーバーが 1 つずつ離脱していることをグループに警告した場合、メンバーシップは 5 から 2 に調整でき、同時にクォーラムを保護できます。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        クォーラムの損失は、それ自体が不正な計画の副作用です。 予想される障害の数 (連続しているか、一度にすべて発生しているか、散発的であるかに関係なく) のグループサイズを計画します。 
      </p></div><p>
      次のセクションでは、グループ内のサーバーによって定足数が自動的に実現されないようにシステムがパーティション化された場合の対処方法について説明します。
    </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">ヒント</div><p>
        過半数の損失後にグループから除外されたプライマリには、新しいグループに含まれていない追加のトランザクションが含まれる場合があります。 これが発生した場合、グループから除外されたメンバーを追加しなおそうとすると、<span class="errortext">「このメンバーには、グループに存在するトランザクションよりも多くの実行済トランザクションがあります」</span>というメッセージが表示されてエラーが発生します。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-detecting-partitions"></a>パーティションの検出</h4></div></div></div><p>
        <code class="literal">replication_group_members</code> パフォーマンススキーマテーブルには、このサーバーの観点から見た現在のビューの各サーバーのステータスが表示されます。 システムがパーティション化に実行されない時間の大部分であるため、テーブルにはグループ内のすべてのサーバー間で一貫性のある情報が表示されます。 つまり、このテーブルの各サーバーのステータスは、現在のビューのすべてによって一致します。 ただし、ネットワークのパーティション化があり、クォーラムが失われた場合は、接続できないサーバーのステータス <code class="literal">UNREACHABLE</code> がテーブルに表示されます。 この情報は、Group Replication に組み込まれているローカル障害検出プログラムによってエクスポートされます。 
      </p><div class="figure"><a name="idm45563247380976"></a><p class="title"><b>図 18.13 損失クォーラム</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/gr-majority-lost.png" width="265" height="417" alt="5 つのサーバーインスタンス (S1、S2、S3、S4 および S5) が、相互接続されたグループ (安定したグループ) としてデプロイされます。 S3、S4 および S5 の 3 つのサーバーで障害が発生すると、大部分が失われ、グループは介入せずに続行できなくなります。"></div></div></div><br class="figure-break"><p>
        このタイプのネットワークパーティションを理解するために、次のセクションでは、最初に 5 つのサーバーが正常に連携し、2 つのサーバーのみがオンラインになった後にグループに対して行われる変更のシナリオについて説明します。 シナリオをの図に示します。 
      </p><p>
        そのため、これらの 5 つのサーバーを含むグループが存在するとします: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            メンバー識別子 <code class="literal">199b2df7-4aaf-11e6-bb16-28b2bd168d07</code> を持つサーバー s1
          </p></li><li class="listitem"><p>
            メンバー識別子 <code class="literal">199bb88e-4aaf-11e6-babe-28b2bd168d07</code> を持つサーバー s2
          </p></li><li class="listitem"><p>
            メンバー識別子 <code class="literal">1999b9fb-4aaf-11e6-bb54-28b2bd168d07</code> を持つサーバー s3
          </p></li><li class="listitem"><p>
            メンバー識別子 <code class="literal">19ab72fc-4aaf-11e6-bb51-28b2bd168d07</code> を持つサーバー s4
          </p></li><li class="listitem"><p>
            メンバー識別子 <code class="literal">19b33846-4aaf-11e6-ba81-28b2bd168d07</code> を持つサーバー s5
          </p></li></ul></div><p>
        最初はグループは正常に実行されており、サーバーはお互いに通信しています。 これを確認するには、s1 にログインし、その <code class="literal">replication_group_members</code> パフォーマンススキーマテーブルを参照します。 例: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT MEMBER_ID,MEMBER_STATE, MEMBER_ROLE FROM performance_schema.replication_group_members;</code></strong>
+--------------------------------------+--------------+-------------+
| MEMBER_ID                            | MEMBER_STATE |-MEMBER_ROLE |
+--------------------------------------+--------------+-------------+
| 1999b9fb-4aaf-11e6-bb54-28b2bd168d07 | ONLINE       | SECONDARY   |
| 199b2df7-4aaf-11e6-bb16-28b2bd168d07 | ONLINE       | PRIMARY     |
| 199bb88e-4aaf-11e6-babe-28b2bd168d07 | ONLINE       | SECONDARY   |
| 19ab72fc-4aaf-11e6-bb51-28b2bd168d07 | ONLINE       | SECONDARY   |
| 19b33846-4aaf-11e6-ba81-28b2bd168d07 | ONLINE       | SECONDARY   |
+--------------------------------------+--------------+-------------+
</pre><p>
        ただし、後で致命的な障害が発生し、サーバー s3、s4 および s5 が予期せず停止します。 この数秒後、s1 の <code class="literal">replication_group_members</code> テーブルを再度参照すると、まだオンラインであることが示されますが、他のいくつかのメンバーはオンラインではありません。 実際には、次に示すように、<code class="literal">UNREACHABLE</code> としてマークされます。 さらに、大部分が失われたため、システム自体を再構成してメンバーシップを変更できませんでした。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT MEMBER_ID,MEMBER_STATE FROM performance_schema.replication_group_members;</code></strong>
+--------------------------------------+--------------+
| MEMBER_ID                            | MEMBER_STATE |
+--------------------------------------+--------------+
| 1999b9fb-4aaf-11e6-bb54-28b2bd168d07 | UNREACHABLE  |
| 199b2df7-4aaf-11e6-bb16-28b2bd168d07 | ONLINE       |
| 199bb88e-4aaf-11e6-babe-28b2bd168d07 | ONLINE       |
| 19ab72fc-4aaf-11e6-bb51-28b2bd168d07 | UNREACHABLE  |
| 19b33846-4aaf-11e6-ba81-28b2bd168d07 | UNREACHABLE  |
+--------------------------------------+--------------+
</pre><p>
        このテーブルは、大部分のサーバーにアクセスできないため、s1 が外部介入なしで進行できないグループになったことを示しています。 この場合、このセクションで説明するように、システムを続行できるようにグループメンバーシップリストをリセットする必要があります。 または、s1 および s2 でのグループレプリケーションの停止 (または完全に s1 および s2) を選択し、s3、s4 および s5 で発生したことを確認してから、グループレプリケーション (またはサーバー) を再起動することもできます。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-unblocking-a-partition"></a>パーティションのブロック解除</h4></div></div></div><p>
        グループレプリケーションを使用すると、特定の構成を強制することでグループメンバーシップリストをリセットできます。 たとえば、s1 および s2 のみがオンラインのサーバーである前述の場合、s1 および s2 のみで構成されるメンバーシップ構成を強制することを選択できます。 これには、s1 および s2 に関する一部の情報を確認してから、<code class="literal">group_replication_force_members</code> 変数を使用する必要があります。 
      </p><div class="figure"><a name="idm45563247346992"></a><p class="title"><b>図 18.14 新規メンバーシップの強制</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/gr-majority-lost-to-stable-group.png" width="266" height="414" alt="グループ内の 3 つのサーバー (S3、S4 および S5) で障害が発生したため、大部分が失われ、グループは介入せずに続行できなくなりました。 次のテキストで説明する介入により、S1 および S2 はそれ自体で安定したグループを形成できます。"></div></div></div><br class="figure-break"><p>
        s1 および s2 がグループに残されている唯一のサーバーである状況に戻るとします。 サーバー s3、s4 および s5 が予期せずグループから退出しました。 サーバー s1 および s2 を続行するには、s1 および s2 のみを含むメンバーシップ構成を強制します。 
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          この手順では <code class="literal">group_replication_force_members</code> を使用するため、最後のリゾート処置とみなすようにしてください。 クォーラムの損失をオーバーライドする場合にのみ、十分に注意して使用する必要があります。 誤用された場合は、人工的なスプリットブレインシナリオを作成するか、システム全体を完全にブロックする可能性があります。 
        </p></div><p>
        システムがブロックされ、現在の構成が次のようになっていることを思い出してください (s1 のローカル障害検出で認識されます):
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT MEMBER_ID,MEMBER_STATE FROM performance_schema.replication_group_members;</code></strong>
+--------------------------------------+--------------+
| MEMBER_ID                            | MEMBER_STATE |
+--------------------------------------+--------------+
| 1999b9fb-4aaf-11e6-bb54-28b2bd168d07 | UNREACHABLE  |
| 199b2df7-4aaf-11e6-bb16-28b2bd168d07 | ONLINE       |
| 199bb88e-4aaf-11e6-babe-28b2bd168d07 | ONLINE       |
| 19ab72fc-4aaf-11e6-bb51-28b2bd168d07 | UNREACHABLE  |
| 19b33846-4aaf-11e6-ba81-28b2bd168d07 | UNREACHABLE  |
+--------------------------------------+--------------+
</pre><p>
        最初に行うことは、s1 および s2 のローカルアドレス (グループ通信識別子) を確認することです。 s1 および s2 にログインし、その情報を次のように取得します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@group_replication_local_address;</code></strong>
</pre><p>
        s1 (<code class="literal">127.0.0.1:10000</code>) および s2 (<code class="literal">127.0.0.1:10001</code>) のグループ通信アドレスがわかったら、いずれかのサーバーでそれを使用して新しいメンバーシップ構成を注入し、クォーラムを失った既存の構成をオーバーライドできます。 s1 でこれを行うには: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL group_replication_force_members="</code></strong>127.0.0.1:10000,127.0.0.1:10001";
</pre><p>
        これにより、別の構成が強制され、グループのブロックが解除されます。 この変更後にグループメンバーシップを確認するには、s1 と s2 の両方で <code class="literal">replication_group_members</code> をチェックします。 s1 では最初。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT MEMBER_ID,MEMBER_STATE FROM performance_schema.replication_group_members;</code></strong>
+--------------------------------------+--------------+
| MEMBER_ID                            | MEMBER_STATE |
+--------------------------------------+--------------+
| b5ffe505-4ab6-11e6-b04b-28b2bd168d07 | ONLINE       |
| b60907e7-4ab6-11e6-afb7-28b2bd168d07 | ONLINE       |
+--------------------------------------+--------------+
</pre><p>
        次に、s2 で行います。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.replication_group_members;</code></strong>
+--------------------------------------+--------------+
| MEMBER_ID                            | MEMBER_STATE |
+--------------------------------------+--------------+
| b5ffe505-4ab6-11e6-b04b-28b2bd168d07 | ONLINE       |
| b60907e7-4ab6-11e6-afb7-28b2bd168d07 | ONLINE       |
+--------------------------------------+--------------+
</pre><p>
        新しいメンバーシップ構成を強制する場合は、グループから強制的に除外されるすべてのサーバーが実際に停止されていることを確認します。 前述のシナリオでは、s3、s4 および s5 に実際にアクセスできないが、かわりにオンラインの場合、独自の機能パーティションを形成している可能性があります (5 つのうち 3 つであるため、大部分があります)。 その場合、s1 および s2 を使用してグループメンバーシップリストを強制すると、人工的なスプリットブレイン状況が発生する可能性があります。 したがって、新しいメンバーシップ構成を強制的に実行する前に、除外するサーバーが実際に停止されていることを確認し、停止されていない場合は続行する前に停止することが重要です。 
      </p><p>
        <code class="literal">group_replication_force_members</code> システム変数を使用して新しいグループメンバーシップを強制し、グループのブロックを解除した後、必ずシステム変数をクリアしてください。<code class="literal">START GROUP_REPLICATION</code> ステートメントを発行するには、<code class="literal">group_replication_force_members</code> が空である必要があります。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-ipv6"></a>18.4.5 IPv6 および IPv6 と IPv4 の混合グループのサポート</h3></div></div></div><a class="indexterm" name="idm45563247312992"></a><a class="indexterm" name="idm45563247310960"></a><p>
      MySQL 8.0.14 から、グループレプリケーショングループメンバーは、グループ内の通信用の IPv4 アドレスのかわりに IPv6 アドレスを使用できます。 IPv6 アドレスを使用するには、サーバーホストと MySQL Server インスタンスの両方のオペレーティングシステムが IPv6 をサポートするように構成されている必要があります。 サーバーインスタンスの IPv6 サポートを設定する手順は、<a class="xref" href="server-administration.html#ipv6-support" title="5.1.13 IPv6 サポート">セクション5.1.13「IPv6 サポート」</a> を参照してください。 
    </p><p>
      IPv6 アドレス、またはそれらに解決されるホスト名は、メンバーが他のメンバーからの接続用に <code class="literal">group_replication_local_address</code> オプションで提供するネットワークアドレスとして指定できます。 ポート番号とともに指定する場合、IPv6 アドレスは大カッコで囲んで指定する必要があります。次に例を示します: 
    </p><pre class="programlisting">group_replication_local_address= "[2001:db8:85a3:8d3:1319:8a2e:370:7348]:33061"</pre><p>
      <code class="literal">group_replication_local_address</code> で指定されたネットワークアドレスまたはホスト名は、グループレプリケーションによって、レプリケーショングループ内のグループメンバーの一意の識別子として使用されます。 サーバーインスタンスのグループレプリケーションのローカルアドレスとして指定されたホスト名が IPv4 アドレスと IPv6 アドレスの両方に解決される場合、IPv4 アドレスは常にグループレプリケーション接続に使用されます。 グループレプリケーションのローカルアドレスとして指定されたアドレスまたはホスト名が MySQL サーバーの SQL プロトコルのホストおよびポートと同じではなく、サーバーインスタンスの <code class="literal">bind_address</code> システム変数で指定されていません。 グループレプリケーションの IP アドレス権限 (<a class="xref" href="group-replication.html#group-replication-ip-address-permissions" title="18.5.1 グループレプリケーション IP アドレスの権限">セクション18.5.1「グループレプリケーション IP アドレスの権限」</a> を参照) のために、<code class="literal">group_replication_local_address</code> の各グループメンバーに指定するアドレスを、レプリケーショングループ内の他のサーバー上の <code class="literal">group_replication_ip_allowlist</code> (MySQL 8.0.22 から) または <code class="literal">group_replication_ip_whitelist</code> システム変数のリストに追加する必要があります。 
    </p><p>
      レプリケーショングループには、IPv6 アドレスをグループレプリケーションローカルアドレスとして提示するメンバーと、IPv4 アドレスを提示するメンバーの組合せを含めることができます。 サーバーがこのような混合グループに参加する場合、シードメンバーが <code class="literal">group_replication_group_seeds</code> オプションで通知するプロトコル (IPv4 か IPv6 かにかかわらず) を使用して、シードメンバーとの初期接続を確立する必要があります。 参加メンバーに IPv4 Group Replication のローカルアドレスがある場合、またはその逆の場合に、グループのシードメンバーのいずれかが IPv6 アドレスとともに <code class="literal">group_replication_group_seeds</code> オプションにリストされている場合は、必要なプロトコル (またはそのプロトコルのアドレスに解決されるホスト名) の参加メンバーの代替アドレスも設定して許可する必要があります。 参加メンバーに適切なプロトコルの許可されたアドレスがない場合、その接続試行は拒否されます。 代替アドレスまたはホスト名は、レプリケーショングループ内の他のサーバーの <code class="literal">group_replication_ip_allowlist</code> (MySQL 8.0.22) または <code class="literal">group_replication_ip_whitelist</code> システム変数にのみ追加する必要があり、参加メンバーの <code class="literal">group_replication_local_address</code> 値には追加できません (単一のアドレスのみを含めることができます)。 
    </p><p>
      たとえば、サーバー A はグループのシードメンバーであり、<code class="literal">group_replication_group_seeds</code> オプションで IPv6 アドレスを通知するために、グループレプリケーションには次の構成設定があります:
    </p><pre class="programlisting">group_replication_bootstrap_group=on
group_replication_local_address= "[2001:db8:85a3:8d3:1319:8a2e:370:7348]:33061"
group_replication_group_seeds= "[2001:db8:85a3:8d3:1319:8a2e:370:7348]:33061"</pre><p>
      サーバー B はグループの参加メンバーであり、グループレプリケーションの次の構成設定があるため、IPv4 グループレプリケーションのローカルアドレスを持ちます:
    </p><pre class="programlisting">group_replication_bootstrap_group=off
group_replication_local_address= "203.0.113.21:33061"
group_replication_group_seeds= "[2001:db8:85a3:8d3:1319:8a2e:370:7348]:33061"</pre><p>
      サーバー B には、代替の IPv6 アドレス <code class="literal">2001:db8:8b0:40:3d9c:cc43:e006:19e8</code> もあります。 サーバー B がグループに正常に参加するには、次の例のように、IPv4 Group Replication のローカルアドレスと代替 IPv6 アドレスの両方をサーバー A の許可リストにリストする必要があります: 
    </p><pre class="programlisting">group_replication_ip_allowlist=
"203.0.113.0/24,2001:db8:85a3:8d3:1319:8a2e:370:7348,
2001:db8:8b0:40:3d9c:cc43:e006:19e8"</pre><p>
      グループレプリケーションの IP アドレス権限のベストプラクティスとして、サーバー B (および他のすべてのグループメンバー) は、セキュリティ要件で特に要求されないかぎり、サーバー A と同じ許可リストを持つ必要があります。
    </p><p>
      レプリケーショングループの一部またはすべてのメンバーが、グループレプリケーションでの IPv6 アドレスの使用をサポートしていない古い MySQL Server バージョンを使用している場合、IPv6 アドレス (またはそれに解決されるホスト名) をグループレプリケーションローカルアドレスとして使用してグループに参加することはできません。 これは、少なくとも 1 つの既存のメンバーが IPv6 アドレスを使用している場合と、この参加試行をサポートしていない新しいメンバーの両方に適用されます。また、新しいメンバーが IPv6 アドレスを使用して参加しようとしたが、このアドレスをサポートしていないメンバーがグループに少なくとも 1 つ含まれている場合にも適用されます。 どの状況でも、新しいメンバーは参加できません。 参加メンバーがグループ通信用の IPv4 アドレスを提示するようにするには、<code class="literal">group_replication_local_address</code> の値を IPv4 アドレスに変更するか、参加メンバーの既存のホスト名を IPv4 アドレスに解決するように DNS を構成します。 すべてのグループメンバーを、グループレプリケーション用の IPv6 をサポートする MySQL Server バージョンにアップグレードした後、各メンバーの <code class="literal">group_replication_local_address</code> 値を IPv6 アドレスに変更するか、IPv6 アドレスを表示するように DNS を構成できます。 <code class="literal">group_replication_local_address</code> の値の変更は、Group Replication を停止して再起動した場合にのみ有効になります。 
    </p><p>
      IPv6 アドレスは、<code class="literal">group_replication_advertise_recovery_endpoints</code> システム変数を使用して MySQL 8.0.21 から指定できる分散リカバリエンドポイントとしても使用できます。 このリストで使用されるアドレスにも同じルールが適用されます。 <a class="xref" href="group-replication.html#group-replication-distributed-recovery-connections" title="18.4.3.1 分散リカバリの接続">セクション18.4.3.1「分散リカバリの接続」</a>を参照してください。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-enterprise-backup"></a>18.4.6 グループレプリケーションでの MySQL Enterprise Backup の使用</h3></div></div></div><a class="indexterm" name="idm45563247268608"></a><a class="indexterm" name="idm45563247266592"></a><p>
      <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/8.0/en/" target="_top">MySQL Enterprise Backup</a> は、<a class="ulink" href="https://www.mysql.com/products/enterprise/" target="_top">MySQL Enterprise Edition</a> で使用可能な MySQL Server の商用ライセンスバックアップユーティリティです。 このセクションでは、MySQL Enterprise Backup を使用してグループレプリケーションメンバーをバックアップしてからリストアする方法について説明します。 同じ方法を使用して、新しいメンバーをグループにすばやく追加できます。 
    </p><h4><a name="idm45563247261792"></a>MySQL Enterprise Backup を使用したグループレプリケーションメンバーのバックアップ</h4><p>
      グループレプリケーションメンバーのバックアップは、スタンドアロンの MySQL インスタンスのバックアップと似ています。 次の手順は、MySQL Enterprise Backup を使用してバックアップを実行する方法をすでに理解していることを前提としています。そうでない場合は、<a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/8.0/en/" target="_top">「MySQL Enterprise Backup 8.0 ユーザーガイド」</a> (特に <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/8.0/en/backing-up.html" target="_top">Backing Up a Database Server</a>) を確認してください。 <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/8.0/en/mysqlbackup.privileges.html" target="_top">Grant MySQL Privileges to Backup Administrator</a> および <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/8.0/en/meb-group-replication.html" target="_top">Using MySQL Enterprise Backup with Group Replication</a> で説明されている要件にも注意してください。 
    </p><p>
      同じ名前のホストで実行されている <code class="literal">s1</code>、<code class="literal">s2</code> および <code class="literal">s3</code> の 3 つのメンバーを持つ次のグループについて考えてみます:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT member_host, member_port, member_state FROM performance_schema.replication_group_members;</code></strong>
+-------------+-------------+--------------+
| member_host | member_port | member_state |
+-------------+-------------+--------------+
| s1          |        3306 | ONLINE       |
| s2          |        3306 | ONLINE       |
| s3          |        3306 | ONLINE       |
+-------------+-------------+--------------+
</pre><p>
      MySQL Enterprise Backup を使用して、そのホストで次のコマンドなどを発行し、<code class="literal">s2</code> のバックアップを作成します:
    </p><pre class="programlisting">s2&gt; <strong class="userinput"><code>mysqlbackup --defaults-file=/etc/my.cnf --backup-image=/backups/my.mbi_`date +%d%m_%H%M` \
		      --backup-dir=/backups/backup_`date +%d%m_%H%M` --user=root -p \
		      --host=127.0.0.1 backup-to-image</code></strong></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">メモ</div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="emphasis"><em>MySQL Enterprise Backup 8.0.18 以前の場合</em></span>システム変数 <code class="literal">sql_require_primary_key</code> がグループに対して <code class="literal">ON</code> に設定されている場合、MySQL Enterprise Backup はバックアップの進行状況をサーバーに記録できません。 これは、サーバー上の <code class="literal">backup_progress</code> テーブルが CSV テーブルであり、主キーがサポートされていないためです。 その場合、<span class="command"><strong>mysqlbackup</strong></span> はバックアップ操作中に次の警告を発行します: 
          </p><pre class="programlisting">181011 11:17:06 MAIN WARNING: MySQL query 'CREATE TABLE IF NOT EXISTS
mysql.backup_progress( `backup_id` BIGINT NOT NULL, `tool_name` VARCHAR(4096)
NOT NULL, `error_code` INT NOT NULL, `error_message` VARCHAR(4096) NOT NULL,
`current_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP               ON
UPDATE CURRENT_TIMESTAMP,`current_state` VARCHAR(200) NOT NULL ) ENGINE=CSV
DEFAULT CHARSET=utf8 COLLATE=utf8_bin': 3750, Unable to create a table
without PK, when system variable 'sql_require_primary_key' is set. Add a PK
to the table or unset this variable to avoid this message. Note that tables
without PK can cause performance problems in row-based replication, so please
consult your DBA before changing this setting.
181011 11:17:06 MAIN WARNING: This backup operation's progress info cannot be
logged.</pre><p>
            ただし、<span class="command"><strong>mysqlbackup</strong></span> によるバックアップの終了は妨げられません。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>MySQL Enterprise Backup 8.0.20 以前の場合</em></span>では、セカンダリメンバーをバックアップするときに、MySQL Enterprise Backup が読取り専用サーバーインスタンスにバックアップステータスおよびメタデータを書き込むことができないため、バックアップ操作中に次のような警告が発行される場合があります:
          </p><pre class="programlisting">181113 21:31:08 MAIN WARNING: This backup operation cannot write to backup
progress. The MySQL server is running with the --super-read-only option.</pre><p>
            警告を回避するには、backup コマンドで <code class="option">--no-history-logging</code> オプションを使用します。 これは MySQL Enterprise Backup 8.0.21 以上の問題ではありません。詳細は、<a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/8.0/en/meb-group-replication.html" target="_top">Using MySQL Enterprise Backup with Group Replication</a> を参照してください。 
          </p></li></ul></div></div><h4><a name="group-replication-restore-failed-member"></a>失敗したメンバーのリストア</h4><p>
      いずれかのメンバー (次の例では <code class="literal">s3</code>) が破損しているとします。 グループメンバー <code class="literal">s2</code> の最新のバックアップを使用して、<code class="literal">s3</code> をリストアできます。 リストアを実行するステップは次のとおりです: 
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          <span class="emphasis"><em>s2 のバックアップを s3 のホストにコピーします。</em></span> バックアップをコピーする正確な方法は、使用可能なオペレーティングシステムおよびツールによって異なります。 この例では、ホストが両方とも Linux サーバーであると想定し、SCP を使用してホスト間でファイルをコピーします: 
        </p><pre class="programlisting">s2/backups&gt; <strong class="userinput"><code>scp my.mbi_2206_1429 s3:/backups</code></strong></pre></li><li class="listitem"><p>
          <span class="emphasis"><em>バックアップをリストアします。</em></span> ターゲットホスト (この場合は <code class="literal">s3</code> のホスト) に接続し、MySQL Enterprise Backup を使用してバックアップをリストアします。 ステップは次のとおりです: 
        </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>
              破損したサーバーがまだ実行されている場合は、停止します。 たとえば、systemd を使用する Linux ディストリビューションの場合: 
            </p><pre class="programlisting">s3&gt; systemctl stop mysqld</pre></li><li class="listitem"><p>
              破損したサーバーデータディレクトリ (<code class="filename">auto.cnf</code> および <code class="filename">mysqld-auto.cnf</code> が存在する場合) 内の 2 つの構成ファイルを、データディレクトリ外の安全な場所にコピーして保持します。 これは、次のステップで必要な <a class="link" href="replication.html#sysvar_server_uuid">server UUID</a> および <a class="xref" href="server-administration.html#persisted-system-variables" title="5.1.9.3 永続化されるシステム変数">セクション5.1.9.3「永続化されるシステム変数」</a>(使用する場合) を保持するためのものです。 
            </p></li><li class="listitem"><p>
              <code class="literal">s3</code> のデータディレクトリ内のすべてのコンテンツを削除します。 例: 
            </p><pre class="programlisting">s3&gt; rm -rf /var/lib/mysql/*</pre><p>
              システム変数 <code class="literal">innodb_data_home_dir</code>、<code class="literal">innodb_log_group_home_dir</code> および <code class="literal">innodb_undo_directory</code> がデータディレクトリ以外のディレクトリを指している場合は、それらも空にする必要があります。そうしないと、リストア操作は失敗します。
            </p></li><li class="listitem"><p>
              <code class="literal">s2</code> のバックアップを <code class="literal">s3</code> のホストにリストアします:
            </p><pre class="programlisting">s3&gt; <strong class="userinput"><code>mysqlbackup --defaults-file=/etc/my.cnf \
  --datadir=/var/lib/mysql \
  --backup-image=/backups/my.mbi_2206_1429  \
  --backup-dir=/tmp/restore_`date +%d%m_%H%M` copy-back-and-apply-log</code></strong></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                前述のコマンドでは、<code class="literal">s2</code> と <code class="literal">s3</code> のバイナリログとリレーログのベース名が同じで、2 つのサーバー上の同じ場所にあることを前提としています。 これらの条件が満たされていない場合は、<code class="option">--log-bin</code> および <code class="option">--relay-log</code> オプションを使用してバイナリログを復元し、<code class="literal">s3</code> 上の元のファイルパスにログをリレーするようにしてください。 たとえば、<code class="literal">s3</code> でバイナリログベース名が <code class="literal">s3-bin</code> で、リレーログベース名が <code class="literal">s3-relay-bin</code> であることがわかっている場合、restore コマンドは次のようになります: 
              </p><pre class="programlisting"><strong class="userinput"><code>mysqlbackup --defaults-file=/etc/my.cnf \
  --datadir=/var/lib/mysql \
  --backup-image=/backups/my.mbi_2206_1429  \
  --log-bin=s3-bin --relay-log=s3-relay-bin \
  --backup-dir=/tmp/restore_`date +%d%m_%H%M` copy-back-and-apply-log</code></strong></pre><p>
                バイナリログとリレーログを正しいファイルパスに復元できるため、復元プロセスが容易になります。何らかの理由で復元できない場合は、<a class="xref" href="group-replication.html#group-replication-rebuild-member" title="新規メンバーとして再結合するための失敗したメンバーの再構築">新規メンバーとして再結合するための失敗したメンバーの再構築</a> を参照してください。
              </p></div></li></ol></div></li><li class="listitem"><p>
          <span class="emphasis"><em>s3 の <code class="filename">auto.cnf</code> ファイルをリストアします。</em></span> レプリケーショングループに再度参加するには、リストアされたメンバーが以前にグループへの参加に使用したものと同じ <code class="literal">server_uuid</code> を持っている必要があります。 前述のステップ 2 で保持した <code class="filename">auto.cnf</code> ファイルをリストアされたメンバーのデータディレクトリにコピーして、古いサーバー UUID を指定します。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            古い <code class="filename">auto.cnf</code> ファイルをリストアして、障害が発生したメンバーの元の <code class="literal">server_uuid</code> をリストアされたメンバーに提供できない場合は、リストアされたメンバーを新しいメンバーとしてグループに参加させる必要があります。その方法は、次の <a class="xref" href="group-replication.html#group-replication-rebuild-member" title="新規メンバーとして再結合するための失敗したメンバーの再構築">新規メンバーとして再結合するための失敗したメンバーの再構築</a> の手順を参照してください。
          </p></div></li><li class="listitem"><p>
          <span class="emphasis"><em>s3 の <code class="filename">mysqld-auto.cnf</code> ファイルをリストアします (s3 で永続システム変数が使用されている場合にのみ必要)。</em></span> 失敗したメンバーの構成に使用された <a class="xref" href="server-administration.html#persisted-system-variables" title="5.1.9.3 永続化されるシステム変数">セクション5.1.9.3「永続化されるシステム変数」</a> の設定は、リストアされたメンバーに指定する必要があります。 これらの設定は、前述のステップ 2 で保持した障害が発生したサーバーの <code class="filename">mysqld-auto.cnf</code> ファイルにあります。 リストアされたサーバーのデータディレクトリにファイルをリストアします。 ファイルのコピーがない場合の対処方法は、<a class="xref" href="group-replication.html#group-replication-meb-restore-persisted-variables" title="永続化されたシステム変数のリストア">永続化されたシステム変数のリストア</a> を参照してください。 
        </p></li><li class="listitem"><p>
          <span class="emphasis"><em>リストアされたサーバーを起動します。</em></span> たとえば、systemd を使用する Linux ディストリビューションの場合: 
        </p><pre class="programlisting">systemctl start mysqld</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            リストアするサーバーがプライマリメンバーである場合は、<a class="xref" href="group-replication.html#group-replication-meb-restore-primary" title="プライマリメンバーのリストア">プライマリメンバーのリストア</a><span class="emphasis"><em>リストアされたサーバーを起動する前</em></span>で説明されているステップを実行します。
          </p></div></li><li class="listitem"><p>
          <span class="emphasis"><em>Group Replication を再起動します。</em></span> <span class="command"><strong>mysql</strong></span> クライアントなどを使用して再起動した <code class="literal">s3</code> に接続し、次のコマンドを発行します: 
        </p><pre class="programlisting">mysql&gt; START GROUP_REPLICATION;</pre><p>
          リストアされたインスタンスがグループのオンラインメンバーになる前に、バックアップの作成後にグループに発生したトランザクションを適用する必要があります。これは Group Replication <a class="link" href="group-replication.html#group-replication-distributed-recovery" title="18.4.3 分散リカバリ">distributed recovery</a> メカニズムを使用して実現され、<a class="link" href="sql-statements.html#start-group-replication" title="13.4.3.1 START GROUP_REPLICATION ステートメント">START GROUP_REPLICATION</a> ステートメントの発行後にプロセスが開始されます。 リストアされたインスタンスのメンバーステータスを確認するには、次のコマンドを発行します: 
        </p><pre class="programlisting">mysql&gt; SELECT member_host, member_port, member_state FROM performance_schema.replication_group_members;
+-------------+-------------+--------------+
| member_host | member_port | member_state |
+-------------+-------------+--------------+
| s1          |        3306 | ONLINE       |
| s2          |        3306 | ONLINE       |
| s3          |        3306 | RECOVERING   |
+-------------+-------------+--------------+
</pre><p>
          これは、<code class="literal">s3</code> がグループをキャッチアップするためにトランザクションを適用していることを示しています。 残りのグループで捕捉されると、その <code class="literal">member_state</code> は <code class="literal">ONLINE</code> に変更されます: 
        </p><pre class="programlisting">mysql&gt; SELECT member_host, member_port, member_state FROM performance_schema.replication_group_members;
+-------------+-------------+--------------+
| member_host | member_port | member_state |
+-------------+-------------+--------------+
| s1          |        3306 | ONLINE       |
| s2          |        3306 | ONLINE       |
| s3          |        3306 | ONLINE       |
+-------------+-------------+--------------+
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            リストアするサーバーがプライマリメンバーである場合、グループとの同期を取得して <code class="literal">ONLINE</code> になったら、<a class="xref" href="group-replication.html#group-replication-meb-restore-primary" title="プライマリメンバーのリストア">プライマリメンバーのリストア</a> の最後に記載されているステップを実行して、サーバーを起動する前に行った構成の変更を元に戻します。
          </p></div></li></ol></div><p>
      これで、メンバーはバックアップから完全にリストアされ、グループの通常のメンバーとして機能します。
    </p><h4><a name="group-replication-rebuild-member"></a>新規メンバーとして再結合するための失敗したメンバーの再構築</h4><p>
      バイナリログまたはリレーログが破損している、あるいは単にバックアップから欠落しているなどの理由で、<a class="xref" href="group-replication.html#group-replication-restore-failed-member" title="失敗したメンバーのリストア">失敗したメンバーのリストア</a> で前述の手順を実行できない場合があります。 このような場合は、バックアップを使用してメンバーを再構築し、新しいメンバーとしてグループに追加します。 次のステップでは、再構築されたメンバーは、障害が発生したメンバーと同様に <code class="literal">s3</code> という名前であり、<code class="literal">s3</code> と同じホスト上で実行されていると想定しています: 
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          <span class="emphasis"><em>s2 のバックアップを s3 のホストにコピーします。</em></span> バックアップをコピーする正確な方法は、使用可能なオペレーティングシステムおよびツールによって異なります。 この例では、ホストが両方とも Linux サーバーであり、SCP を使用してホスト間でファイルをコピーすることを前提としています: 
        </p><pre class="programlisting">s2/backups&gt; <strong class="userinput"><code>scp my.mbi_2206_1429 s3:/backups</code></strong></pre></li><li class="listitem"><p>
          <span class="emphasis"><em>バックアップをリストアします。</em></span> ターゲットホスト (この場合は <code class="literal">s3</code> のホスト) に接続し、MySQL Enterprise Backup を使用してバックアップをリストアします。 ステップは次のとおりです: 
        </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>
              破損したサーバーがまだ実行されている場合は、停止します。 たとえば、systemd を使用する Linux ディストリビューションの場合: 
            </p><pre class="programlisting">s3&gt; systemctl stop mysqld</pre></li><li class="listitem"><p>
              破損したサーバーデータディレクトリに見つかった場合は、データディレクトリ外の安全な場所にコピーして、構成ファイル <code class="filename">mysqld-auto.cnf</code> を保持します。 これは、あとで必要になるサーバー <a class="xref" href="server-administration.html#persisted-system-variables" title="5.1.9.3 永続化されるシステム変数">セクション5.1.9.3「永続化されるシステム変数」</a> を保持するためのものです。 
            </p></li><li class="listitem"><p>
              <code class="literal">s3</code> のデータディレクトリ内のすべてのコンテンツを削除します。 例: 
            </p><pre class="programlisting">s3&gt; rm -rf /var/lib/mysql/*</pre><p>
              システム変数 <code class="literal">innodb_data_home_dir</code>、<code class="literal">innodb_log_group_home_dir</code> および <code class="literal">innodb_undo_directory</code> がデータディレクトリ以外のディレクトリを指している場合は、それらも空にする必要があります。そうしないと、リストア操作は失敗します。
            </p></li><li class="listitem"><p>
              <code class="literal">s2</code> のバックアップを <code class="literal">s3</code> のホストにリストアします。 このアプローチでは、<code class="literal"><code class="literal">s3</code> </code>を新しいメンバーとして再構築するため、古いバイナリログおよびリレーログをバックアップで使用する必要はありません。したがって、これらのログがバックアップに含まれている場合は、<code class="option">--skip-binlog</code> および <code class="option">--skip-relaylog</code> オプションを使用して除外します: 
            </p><pre class="programlisting">s3&gt; <strong class="userinput"><code>mysqlbackup --defaults-file=/etc/my.cnf \
  --datadir=/var/lib/mysql \
  --backup-image=/backups/my.mbi_2206_1429  \
  --backup-dir=/tmp/restore_`date +%d%m_%H%M` \
  --skip-binlog --skip-relaylog \
  copy-back-and-apply-log</code></strong></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                問題なくターゲットホストに転送できる正常なバイナリログおよびリレーログがバックアップにある場合は、前述の <a class="xref" href="group-replication.html#group-replication-restore-failed-member" title="失敗したメンバーのリストア">失敗したメンバーのリストア</a> で説明した簡単な手順に従うことをお薦めします。
              </p></div></li></ol></div></li><li class="listitem"><p>
          <span class="emphasis"><em>s3 の <code class="filename">mysqld-auto.cnf</code> ファイルをリストアします (s3 で永続システム変数が使用されている場合にのみ必要)。</em></span> 障害が発生したメンバーの構成に使用された <a class="xref" href="server-administration.html#persisted-system-variables" title="5.1.9.3 永続化されるシステム変数">セクション5.1.9.3「永続化されるシステム変数」</a> の設定は、リストアされたサーバーに指定する必要があります。 これらの設定は、前述のステップ 2 で保持した障害が発生したサーバーの <code class="filename">mysqld-auto.cnf</code> ファイルにあります。 リストアされたサーバーのデータディレクトリにファイルをリストアします。 ファイルのコピーがない場合の対処方法は、<a class="xref" href="group-replication.html#group-replication-meb-restore-persisted-variables" title="永続化されたシステム変数のリストア">永続化されたシステム変数のリストア</a> を参照してください。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            破損したサーバー <code class="filename">auto.cnf</code> ファイルを新しいメンバーのデータディレクトリにリストアしないでください。再構築された <code class="literal">s3</code> が新しいメンバーとしてグループに参加すると、新しいサーバー UUID が割り当てられます。
          </p></div></li><li class="listitem"><p>
          <span class="emphasis"><em>リストアされたサーバーを起動します。</em></span> たとえば、systemd を使用する Linux ディストリビューションの場合: 
        </p><pre class="programlisting">systemctl start mysqld</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            リストアするサーバーがプライマリメンバーである場合は、<a class="xref" href="group-replication.html#group-replication-meb-restore-primary" title="プライマリメンバーのリストア">プライマリメンバーのリストア</a><span class="emphasis"><em>リストアされたサーバーを起動する前</em></span>で説明されているステップを実行します。
          </p></div></li><li class="listitem"><p>
          <span class="emphasis"><em>グループレプリケーションに参加するようにリストアされたメンバーを再構成します。</em></span> <span class="command"><strong>mysql</strong></span> クライアントを使用してリストアされたサーバーに接続し、次のコマンドを使用してソースおよびレプリカ情報をリセットします: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>RESET MASTER;</code></strong></pre><pre class="programlisting">mysql&gt; <strong class="userinput"><code>RESET SLAVE ALL;</code></strong>
Or from MySQL 8.0.22:
mysql&gt; <strong class="userinput"><code>RESET REPLICA ALL;</code></strong>
</pre><p>
          <a class="link" href="group-replication.html#group-replication-distributed-recovery" title="18.4.3 分散リカバリ">distributed recovery</a> の Group Replication 組込みメカニズムを使用して、リストアされたサーバーを自動的にリカバリできるようにするには、サーバーの <code class="literal">gtid_executed</code> 変数を構成します。 これを行うには、<code class="literal">s2</code> のバックアップに含まれる <code class="filename">backup_gtid_executed.sql</code> ファイルを使用します。これは通常、リストアされたメンバーデータディレクトリの下にリストアされます。 バイナリロギングを無効にし、<code class="filename">backup_gtid_executed.sql</code> ファイルを使用して <code class="literal">gtid_executed</code> を構成してから、<span class="command"><strong>mysql</strong></span> クライアントで次のステートメントを発行してバイナリロギングを再度有効にします: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET SQL_LOG_BIN=OFF;</code></strong>
mysql&gt; <strong class="userinput"><code>SOURCE <em class="replaceable"><code>datadir</code></em>/backup_gtid_executed.sql</code></strong>
mysql&gt; <strong class="userinput"><code>SET SQL_LOG_BIN=ON;</code></strong>
</pre><p>
          次に、メンバーで <a class="link" href="group-replication.html#group-replication-user-credentials" title="18.2.1.3 分散リカバリのユーザー資格証明">Group Replication user credentials</a> を構成します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO MASTER_USER='<em class="replaceable"><code>rpl_user</code></em>', MASTER_PASSWORD='<em class="replaceable"><code>password</code></em>' /
		FOR CHANNEL 'group_replication_recovery';</code></strong>

Or from MySQL 8.0.23:
mysql&gt; <strong class="userinput"><code>CHANGE REPLICATION SOURCE TO SOURCE_USER='<em class="replaceable"><code>rpl_user</code></em>', SOURCE_PASSWORD='<em class="replaceable"><code>password</code></em>' /
		FOR CHANNEL 'group_replication_recovery';</code></strong>
</pre></li><li class="listitem"><p>
          <span class="emphasis"><em>Group Replication を再起動します。</em></span> <span class="command"><strong>mysql</strong></span> クライアントを使用して、リストアされたサーバーに次のコマンドを発行します: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>START GROUP_REPLICATION;</code></strong></pre><p>
          リストアされたインスタンスがグループのオンラインメンバーになる前に、バックアップの作成後にグループに発生したトランザクションを適用する必要があります。これは Group Replication <a class="link" href="group-replication.html#group-replication-distributed-recovery" title="18.4.3 分散リカバリ">distributed recovery</a> メカニズムを使用して実現され、<a class="link" href="sql-statements.html#start-group-replication" title="13.4.3.1 START GROUP_REPLICATION ステートメント">START GROUP_REPLICATION</a> ステートメントの発行後にプロセスが開始されます。 リストアされたインスタンスのメンバーステータスを確認するには、次のコマンドを発行します: 
        </p><pre class="programlisting">mysql&gt; SELECT member_host, member_port, member_state FROM performance_schema.replication_group_members;
+-------------+-------------+--------------+
| member_host | member_port | member_state |
+-------------+-------------+--------------+
| s3          |        3306 | RECOVERING   |
| s2          |        3306 | ONLINE       |
| s1          |        3306 | ONLINE       |
+-------------+-------------+--------------+
</pre><p>
          これは、<code class="literal">s3</code> がグループをキャッチアップするためにトランザクションを適用していることを示しています。 残りのグループで捕捉されると、その <code class="literal">member_state</code> は <code class="literal">ONLINE</code> に変更されます: 
        </p><pre class="programlisting">mysql&gt; SELECT member_host, member_port, member_state FROM performance_schema.replication_group_members;
+-------------+-------------+--------------+
| member_host | member_port | member_state |
+-------------+-------------+--------------+
| s3          |        3306 | ONLINE       |
| s2          |        3306 | ONLINE       |
| s1          |        3306 | ONLINE       |
+-------------+-------------+--------------+
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            リストアするサーバーがプライマリメンバーである場合、グループとの同期を取得して <code class="literal">ONLINE</code> になったら、<a class="xref" href="group-replication.html#group-replication-meb-restore-primary" title="プライマリメンバーのリストア">プライマリメンバーのリストア</a> の最後に記載されているステップを実行して、サーバーを起動する前に行った構成の変更を元に戻します。
          </p></div></li></ol></div><p>
      これで、メンバーは新しいメンバーとしてグループに復元されました。
    </p><p><a name="group-replication-meb-restore-persisted-variables"></a><b>永続化されたシステム変数のリストア. </b>
        <span class="command"><strong>mysqlbackup</strong></span> では、<a class="xref" href="server-administration.html#persisted-system-variables" title="5.1.9.3 永続化されるシステム変数">セクション5.1.9.3「永続化されるシステム変数」</a>-the ファイルのバックアップまたは保存をサポートしていません <code class="filename">mysqld-auto.cnf</code> はバックアップに含まれていません。 リストアされたメンバーを永続変数設定で開始するには、次のいずれかを実行する必要があります: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          破損したサーバーからの <code class="filename">mysqld-auto.cnf</code> ファイルのコピーを保持し、リストアしたサーバーデータディレクトリにコピーします。
        </p></li><li class="listitem"><p>
          <code class="filename">mysqld-auto.cnf</code> ファイルをグループの別のメンバーからリストアされたサーバーデータディレクトリにコピーします (そのメンバーに破損したメンバーと同じ永続システム変数設定がある場合)。
        </p></li><li class="listitem"><p>
          リストアされたサーバーの起動後、グループレプリケーションを再起動する前に、<span class="command"><strong>mysql</strong></span> クライアントを介してすべてのシステム変数を手動で永続化された値に設定します。
        </p></li></ul></div><p><a name="group-replication-meb-restore-primary"></a><b>プライマリメンバーのリストア. </b>
        リストアされたメンバーがグループ内のプライマリである場合は、グループレプリケーション分散リカバリプロセス中にリストアされたデータベースへの書込みを防ぐように注意する必要があります。 クライアントによるグループへのアクセス方法に応じて、リストアされたメンバーがネットワーク上でアクセス可能になると、メンバーがグループ外でミスしたアクティビティのキャッチアップを終了する前に、そのメンバーに対して DML ステートメントが実行される可能性があります。 これを回避するには、<span class="emphasis"><em>リストアされたサーバーを起動する前</em></span>でサーバーオプションファイルに次のシステム変数を構成します: 
      </p><pre class="programlisting">group_replication_start_on_boot=OFF
super_read_only=ON
event_scheduler=OFF
</pre><p>
      これらの設定により、起動時にメンバーが読取り専用になり、分散リカバリプロセス中にメンバーがグループで捕捉されている間、イベントスケジューラがオフになります。 適切なエラー処理は、リストアされたメンバーでこの期間中に一時的に DML 操作を実行できないように、クライアントでも構成する必要があります。 リストアプロセスが完全に完了し、リストアされたメンバーがグループの残りの部分と同期したら、これらの変更を元に戻し、イベントスケジューラを再起動します: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET global event_scheduler=ON;</code></strong>
</pre><p>
      メンバーオプションファイルで次のシステム変数を編集して、次回の起動時に正しく構成されるようにします:
    </p><pre class="programlisting">group_replication_start_on_boot=ON
super_read_only=OFF
event_scheduler=ON</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="group-replication-security"></a>18.5 グループレプリケーションセキュリティ</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-ip-address-permissions">18.5.1 グループレプリケーション IP アドレスの権限</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-secure-socket-layer-support-ssl">18.5.2 Secure Socket Layer (SSL) を使用したグループ通信接続の保護</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-distributed-recovery-securing">18.5.3 分散リカバリ接続の保護</a></span></dt></dl></div><a class="indexterm" name="idm45563247056384"></a><p>
    このセクションでは、グループを保護する方法、グループのメンバー間の接続を保護する方法、または IP アドレス許可リストを使用してセキュリティ境界を確立する方法について説明します。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-ip-address-permissions"></a>18.5.1 グループレプリケーション IP アドレスの権限</h3></div></div></div><a class="indexterm" name="idm45563247052416"></a><a class="indexterm" name="idm45563247050192"></a><a class="indexterm" name="idm45563247048240"></a><a class="indexterm" name="idm45563247046144"></a><p>
      Group Replication プラグインでは、受信グループ通信システム接続を受け入れることができるホストの許可リストを指定できます。 サーバー s1 で allowlist を指定した場合、グループ通信を行うためにサーバー s2 が s1 への接続を確立すると、s1 はまず allowlist をチェックしてから s2 からの接続を受け入れます。 s2 が許可リストにある場合、s1 は接続を受け入れます。そうでない場合、s1 は s2 による接続試行を拒否します。 MySQL 8.0.22 からは、システム変数 <code class="literal">group_replication_ip_allowlist</code> を使用して許可リストが指定され、MySQL 8.0.22 より前のリリースでは、システム変数 <code class="literal">group_replication_ip_whitelist</code> が使用されます。 新しいシステム変数は古いシステム変数と同じように機能しますが、用語のみが変更されています。 
    </p><p>
      allowlist を明示的に指定しない場合、グループ通信エンジン (XCom) はホスト上のアクティブなインタフェースを自動的にスキャンし、プライベートサブネットワーク上のアドレスを持つインタフェースと、各インタフェースに構成されているサブネットマスクを識別します。 これらのアドレス、および IPv4 と (MySQL 8.0.14 の) IPv6 の <code class="literal">localhost</code> IP アドレスは、自動 Group Replication 許可リストの作成に使用されます。 したがって、自動許可リストには、適切なサブネットマスクが適用された後に次の範囲でホストに対して検出された IP アドレスが含まれます: 
    </p><pre class="programlisting">IPv4 (as defined in RFC 1918)
10/8 prefix       (10.0.0.0 - 10.255.255.255) - Class A
172.16/12 prefix  (172.16.0.0 - 172.31.255.255) - Class B
192.168/16 prefix (192.168.0.0 - 192.168.255.255) - Class C

IPv6 (as defined in RFC 4193 and RFC 5156)
fc00:/7 prefix    - unique-local addresses
fe80::/10 prefix  - link-local unicast addresses

127.0.0.1 - localhost for IPv4
::1       - localhost for IPv6</pre><p>
      ホストに対して自動的に許可されたアドレスを示すエントリがエラーログに追加されます。
    </p><p>
      プライベートアドレスの自動許可リストはプライベートネットワーク外のサーバーからの接続には使用できないため、パブリック IP 上にインタフェースがある場合でも、サーバーはデフォルトで外部ホストからのグループレプリケーション接続を許可しません。 異なるマシン上にあるサーバーインスタンス間のグループレプリケーション接続の場合、パブリック IP アドレスを指定し、明示的な許可リストとして指定する必要があります。 許可リストにエントリを指定した場合、プライベートアドレスおよび <code class="literal">localhost</code> アドレスは自動的に追加されないため、これらのいずれかを使用する場合は、明示的に指定する必要があります。 
    </p><p>
      許可リストを手動で指定するには、<code class="literal">group_replication_ip_allowlist</code> (MySQL 8.0.22) または <code class="literal">group_replication_ip_whitelist</code> システム変数を使用します。 サーバーがレプリケーショングループのアクティブメンバーである間は、そのサーバーの許可リストを変更できません。 メンバーがアクティブな場合は、許可リストを変更する前に <code class="literal">STOP GROUP_REPLICATION</code> を実行し、後で <code class="literal">START GROUP_REPLICATION</code> を実行する必要があります。 
    </p><p>
      allowlist には、各メンバーの <code class="literal">group_replication_local_address</code> システム変数で指定された IP アドレスまたはホスト名が含まれている必要があります。 このアドレスは、MySQL サーバーの SQL プロトコルのホストおよびポートと同じではなく、サーバーインスタンスの <code class="literal">bind_address</code> システム変数で指定されていません。 サーバーインスタンスのグループレプリケーションのローカルアドレスとして使用されるホスト名が IPv4 アドレスと IPv6 アドレスの両方に解決される場合、グループレプリケーション接続には IPv4 アドレスが優先されます。 
    </p><p>
      分散リカバリエンドポイントとして指定された IP アドレス、および分散リカバリ (デフォルト) に使用される場合はメンバー標準 SQL クライアント接続の IP アドレスを許可リストに追加する必要はありません。 allowlist は、メンバーごとに <code class="literal">group_replication_local_address</code> によって指定されたアドレスに対してのみ使用されます。 分散リカバリのためにアドレスを取得するには、参加メンバーは allowlist によって許可されたグループへの初期接続を持っている必要があります。 
    </p><p>
      allowlist では、次の任意の組合せを指定できます:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          IPv4 アドレス (<code class="literal">198.51.100.44</code> など)
        </p></li><li class="listitem"><p>
          CIDR 表記を使用した IPv4 アドレス (<code class="literal">192.0.2.21/24</code> など)
        </p></li><li class="listitem"><p>
          MySQL 8.0.14 からの IPv6 アドレス (<code class="literal">2001:db8:85a3:8d3:1319:8a2e:370:7348</code> など)
        </p></li><li class="listitem"><p>
          MySQL 8.0.14 からの CIDR 表記の IPv6 アドレス (<code class="literal">2001:db8:85a3:8d3::/64</code> など)
        </p></li><li class="listitem"><p>
          ホスト名 (<code class="literal">example.org</code> など)
        </p></li><li class="listitem"><p>
          CIDR 表記法を使用したホスト名 (<code class="literal">www.example.com/24</code> など)
        </p></li></ul></div><p>
      MySQL 8.0.14 より前では、ホスト名は IPv4 アドレスにのみ解決できました。 MySQL 8.0.14 から、ホスト名は IPv4 アドレス、IPv6 アドレス、またはその両方に解決できます。 ホスト名が IPv4 アドレスと IPv6 アドレスの両方に解決される場合、IPv4 アドレスは常にグループレプリケーション接続に使用されます。 CIDR 表記をホスト名または IP アドレスと組み合せて使用すると、特定のネットワーク接頭辞を持つ IP アドレスのブロックを許可できますが、指定したサブネット内のすべての IP アドレスが制御下にあることを確認してください。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        IP アドレスが許可リストにないために IP アドレスからの接続試行が拒否された場合、拒否メッセージは常に IPv6 形式で IP アドレスを出力します。 IPv4 アドレスの前には、この形式 (IPV4-mapped IPv6 アドレス) の<code class="literal">::ffff:</code>が付きます。 許可リストで IPv4 アドレスを指定するためにこの形式を使用する必要はありません。標準の IPv4 形式を使用します。 
      </p></div><p>
      許可リストを変更するには、メンバーのグループレプリケーションを停止して再起動する必要があります。 allowlist の各エントリはカンマで区切る必要があります。 例: 
    </p><pre class="programlisting">mysql&gt; STOP GROUP_REPLICATION;
mysql&gt; SET GLOBAL group_replication_ip_allowlist="192.0.2.21/24,198.51.100.44,203.0.113.0/24,2001:db8:85a3:8d3:1319:8a2e:370:7348,example.org,www.example.com/24";
mysql&gt; START GROUP_REPLICATION;</pre><p>
      レプリケーショングループに参加するには、グループへの参加をリクエストするシードメンバーでサーバーが許可されている必要があります。 通常、これはレプリケーショングループのブートストラップメンバーですが、グループに参加するサーバーの構成で <code class="literal">group_replication_group_seeds</code> オプションによってリストされた任意のサーバーを指定できます。 結合メンバーに IPv4 <code class="literal">group_replication_local_address</code> がある場合、またはその逆の場合に、グループのシードメンバーのいずれかが IPv6 アドレスとともに <code class="literal">group_replication_group_seeds</code> オプションにリストされている場合は、シードメンバーによって提供されるプロトコル (またはそのプロトコルのアドレスに解決されるホスト名) の結合メンバーの代替アドレスも設定して許可する必要があります。 これは、サーバーがレプリケーショングループに参加するときに、シードメンバーが <code class="literal">group_replication_group_seeds</code> オプションで通知するプロトコル (IPv4 か IPv6 かにかかわらず) を使用して、シードメンバーとの初期接続を行う必要があるためです。 参加メンバーに適切なプロトコルの許可されたアドレスがない場合、その接続試行は拒否されます。 IPv4 と IPv6 の混在レプリケーショングループの管理の詳細は、<a class="xref" href="group-replication.html#group-replication-ipv6" title="18.4.5 IPv6 および IPv6 と IPv4 の混合グループのサポート">セクション18.4.5「IPv6 および IPv6 と IPv4 の混合グループのサポート」</a> を参照してください。 
    </p><p>
      レプリケーショングループが再構成されると (たとえば、新しいプライマリが選択された場合、メンバーが参加または離脱した場合)、グループメンバーは自身の間の接続を再確立します。 再構成後にレプリケーショングループに含まれなくなったサーバーによってのみグループメンバーが許可されている場合、レプリケーショングループ内で許可されていない残りのサーバーには再接続できません。 このシナリオを完全に回避するには、レプリケーショングループのメンバーであるすべてのサーバーに同じ allowlist を指定します。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        たとえば、異なるサブネットを分離しておくために、セキュリティ要件に応じて異なるグループメンバーに異なる許可リストを構成できます。 セキュリティ要件を満たすために異なる許可リストを構成する必要がある場合は、レプリケーショングループ内の許可リスト間に十分な重複があることを確認して、元のシードメンバーが存在しない場合にサーバーが再接続できる可能性を最大化します。 
      </p></div><p>
      ホスト名の場合、名前解決は、別のサーバーによって接続リクエストが行われた場合にのみ行われます。 解決できないホスト名は許可リストの検証で考慮されず、警告メッセージがエラーログに書き込まれます。 前方確認の逆引き DNS (FCrDNS) 検証は、解決されたホスト名に対して実行されます。 
    </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
        ホスト名は本質的に許可リストの IP アドレスより安全性が低くなります。 FCrDNS の検証は適切なレベルの保護を提供しますが、特定のタイプの攻撃によって危険にさらされる可能性があります。 厳密に必要な場合にのみ許可リストにホスト名を指定し、名前解決に使用されるすべてのコンポーネント (DNS サーバーなど) が制御下に保持されていることを確認します。 外部コンポーネントを使用しないように、hosts ファイルを使用して名前解決をローカルに実装することもできます。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-secure-socket-layer-support-ssl"></a>18.5.2 Secure Socket Layer (SSL) を使用したグループ通信接続の保護</h3></div></div></div><a class="indexterm" name="idm45563246989408"></a><a class="indexterm" name="idm45563246987264"></a><p>
      セキュアソケットは、グループのメンバー間のグループ通信接続に使用できます。 Group Replication システム変数 <code class="literal">group_replication_ssl_mode</code> は、グループ通信接続の SSL の使用をアクティブ化し、接続のセキュリティモードを指定するために使用されます。 デフォルト設定は、SSL が使用されないことを意味します。 このオプションには、次の値を指定できます: 
    </p><div class="table"><a name="idm45563246982976"></a><p class="title"><b>表 18.2 group_replication_ssl_mode 構成値</b></p><div class="table-contents"><table summary="Lists the possible values for group_replication_ssl_mode and describes their effect on how replication group members connect to each other."><col style="width: 35%"><col style="width: 65%"><thead><tr>
          <th><p>
              値
            </p></th>
          <th><p>
              説明
            </p></th>
        </tr></thead><tbody><tr>
          <td><p>
              DISABLED
            </p></td>
          <td><p>
              暗号化されていない接続を確立します (デフォルト)。
            </p></td>
        </tr><tr>
          <td><p>
              REQUIRED
            </p></td>
          <td><p>
              サーバーがセキュアな接続をサポートしている場合は、セキュアな接続を確立します。
            </p></td>
        </tr><tr>
          <td><p>
              VERIFY_CA
            </p></td>
          <td><p>
              REQUIRED と似ていますが、さらに、構成された認証局 (CA) 証明書に対してサーバー TLS 証明書を検証します。
            </p></td>
        </tr><tr>
          <td><p>
              VERIFY_IDENTITY
            </p></td>
          <td><p>
              VERIFY_CA と似ていますが、さらに、サーバー証明書が接続が試行されるホストと一致することを確認します。
            </p></td>
        </tr></tbody></table></div></div><br class="table-break"><p>
      グループレプリケーショングループ通信接続の残りの構成は、サーバー SSL 構成から取得されます。 サーバー SSL を構成するオプションの詳細は、<a class="xref" href="programs.html#encrypted-connection-options" title="暗号化接続のコマンドオプション">暗号化接続のコマンドオプション</a> を参照してください。 グループレプリケーショングループの通信接続に適用されるサーバー SSL オプションは、次のとおりです: 
    </p><div class="table"><a name="idm45563246964048"></a><p class="title"><b>表 18.3 SSL オプション</b></p><div class="table-contents"><table summary="Lists the server configuration options for SSL and describes their effect on the configuration of the Group Replication plugin for SSL."><col style="width: 35%"><col style="width: 65%"><thead><tr>
          <th><p>
              サーバー構成
            </p></th>
          <th><p>
              説明
            </p></th>
        </tr></thead><tbody><tr>
          <td><p>
              <code class="literal">ssl_key</code>
            </p></td>
          <td><p>
              PEM 形式の SSL 秘密キーファイルのパス名。 クライアント側では、これはクライアント秘密キーです。 サーバー側では、これはサーバーの秘密キーです。 
            </p></td>
        </tr><tr>
          <td><p>
              <code class="literal">ssl_cert</code>
            </p></td>
          <td><p>
              PEM 形式の SSL 公開キー証明書ファイルのパス名。 クライアント側では、これはクライアント公開キー証明書です。 サーバー側では、これはサーバー公開キー証明書です。 
            </p></td>
        </tr><tr>
          <td><p>
              <code class="literal">ssl_ca</code>
            </p></td>
          <td><p>
              PEM 形式の認証局 (CA) 証明書ファイルのパス名。
            </p></td>
        </tr><tr>
          <td><p>
              <code class="literal">ssl_capath</code>
            </p></td>
          <td><p>
              PEM 形式の信頼できる SSL 認証局 (CA) 証明書ファイルを含むディレクトリのパス名。
            </p></td>
        </tr><tr>
          <td><p>
              <code class="literal">ssl_crl</code>
            </p></td>
          <td><p>
              PEM 形式の証明書失効リストを含むファイルのパス名。
            </p></td>
        </tr><tr>
          <td><p>
              <code class="literal">ssl_crlpath</code>
            </p></td>
          <td><p>
              PEM 形式の証明書失効リストファイルを含むディレクトリのパス名。
            </p></td>
        </tr><tr>
          <td><p>
              <code class="literal">ssl_cipher</code>
            </p></td>
          <td><p>
              暗号化された接続に許可される暗号のリスト。
            </p></td>
        </tr><tr>
          <td><p>
              <code class="literal">tls_version</code>
            </p></td>
          <td><p>
              サーバーが暗号化された接続に対して許可する TLS プロトコルのリスト。
            </p></td>
        </tr><tr>
          <td><p>
              <code class="literal">tls_ciphersuites</code>
            </p></td>
          <td><p>
              サーバーが暗号化された接続に対して許可する TLSv1.3 暗号スイート。
            </p></td>
        </tr></tbody></table></div></div><br class="table-break"><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            TLSv1.3 プロトコルのサポートは、MySQL 8.0.16 の MySQL Server で使用できます (MySQL が OpenSSL 1.1.1 以上を使用してコンパイルされている場合)。 グループレプリケーションは、MySQL 8.0.18 からの TLSv1.3 をサポートしています。 MySQL 8.0.16 および MySQL 8.0.17 では、サーバーが TLSv1.3 をサポートしている場合、プロトコルはグループ通信エンジンではサポートされず、Group Replication では使用できません。 
          </p></li><li class="listitem"><p>
            <code class="literal">tls_version</code> システム変数で指定された TLS プロトコルのリストで、指定されたバージョンが連続していることを確認します (たとえば、<code class="literal">TLSv1,TLSv1.1,TLSv1.2</code>)。 プロトコルのリストにギャップがある場合 (たとえば、<code class="literal">TLSv1,TLSv1.2</code> を指定し、TLS 1.1 を省略した場合)、Group Replication はグループ通信接続を確立できない可能性があります。 
          </p></li><li class="listitem"><p>
            MySQL 8.0.18 では、TLSv1.3 を分散リカバリ接続のグループレプリケーションで使用できますが、<code class="literal">group_replication_recovery_tls_version</code> および <code class="literal">group_replication_recovery_tls_ciphersuites</code> システム変数は使用できません。 したがって、ドナーサーバーでは、<a class="xref" href="security.html#encrypted-connection-protocols-ciphers" title="6.3.2 暗号化された接続 TLS プロトコルおよび暗号">セクション6.3.2「暗号化された接続 TLS プロトコルおよび暗号」</a> にリストされているように、デフォルトで有効になっている TLSv1.3 暗号スイートを少なくとも 1 つ使用できる必要があります。 MySQL 8.0.19 から、オプションを使用して、必要に応じてデフォルト以外の暗号スイートのみを含む任意の暗号スイートのクライアントサポートを構成できます。 
          </p></li></ul></div></div><p>
      レプリケーショングループでは、OpenSSL は、すべてのメンバーでサポートされている最上位 TLS プロトコルの使用をネゴシエーションします。 TLSv1.3 (<code class="literal">tls_version=TLSv1.3</code>) のみを使用するように構成された結合メンバーは、既存のメンバーが TLSv1.3 をサポートしていないレプリケーショングループに参加できません。その場合、グループメンバーは TLS プロトコルバージョンが低いためです。 メンバーをグループに参加させるには、参加メンバーを構成して、既存のグループメンバーでサポートされている下位 TLS プロトコルバージョンの使用も許可する必要があります。 逆に、参加メンバーが TLSv1.3 をサポートしていないが、既存のグループメンバーが相互の接続にそのバージョンをすべて使用している場合、既存のグループメンバーがすでに適切な下位 TLS プロトコルバージョンの使用を許可しているか、それを許可するように構成すると、メンバーは参加できます。 この状況では、OpenSSL は、各メンバーから参加メンバーへの接続に TLS プロトコルの下位バージョンを使用します。 他の既存のメンバーへの各メンバー接続では、両方のメンバーがサポートする使用可能な最高のプロトコルが引き続き使用されます。 
    </p><p>
      MySQL 8.0.16 から、実行時に <code class="literal">tls_version</code> システム変数を変更して、サーバーで許可されている TLS プロトコルバージョンのリストを変更できます。 Group Replication の場合、コンテキストを定義するシステム変数の現在の値からサーバー TLS コンテキストを再構成する <code class="literal">ALTER INSTANCE RELOAD TLS</code> ステートメントは、Group Replication の実行中に Group Replication グループ通信接続の TLS コンテキストを変更しないことに注意してください。 これらの接続に再構成を適用するには、<code class="literal">STOP GROUP_REPLICATION</code> の後に <code class="literal">START GROUP_REPLICATION</code> を実行して、<code class="literal">tls_version</code> システム変数を変更したメンバーでグループレプリケーションを再起動する必要があります。 同様に、グループのすべてのメンバーが上位または下位の TLS プロトコルバージョンを使用するように変更する場合は、許可された TLS プロトコルバージョンのリストを変更した後に、メンバーでグループレプリケーションのローリング再起動を実行して、ローリング再起動の完了時に OpenSSL が上位 TLS プロトコルバージョンの使用をネゴシエートできるようにする必要があります。 実行時に許可される TLS プロトコルバージョンのリストを変更する手順については、<a class="xref" href="security.html#encrypted-connection-protocols-ciphers" title="6.3.2 暗号化された接続 TLS プロトコルおよび暗号">セクション6.3.2「暗号化された接続 TLS プロトコルおよび暗号」</a>and <a class="xref" href="security.html#using-encrypted-connections-server-side-runtime-configuration" title="サーバー側のランタイム構成および暗号化された接続の監視">サーバー側のランタイム構成および暗号化された接続の監視</a> を参照してください。 
    </p><p>
      次の例は、サーバーで SSL を構成し、グループレプリケーショングループ通信接続の SSL をアクティブ化する <code class="literal">my.cnf</code> ファイルのセクションを示しています:
    </p><pre class="programlisting">[mysqld]
ssl_ca = "cacert.pem"
ssl_capath = "/.../ca_directory"
ssl_cert = "server-cert.pem"
ssl_cipher = "DHE-RSA-AEs256-SHA"
ssl_crl = "crl-server-revoked.crl"
ssl_crlpath = "/.../crl_directory"
ssl_key = "server-key.pem"
group_replication_ssl_mode= REQUIRED</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        コンテキストを定義するシステム変数の現在の値からサーバー TLS コンテキストを再構成する <code class="literal">ALTER INSTANCE RELOAD TLS</code> ステートメントは、Group Replication の実行中に Group Replication グループ通信接続の TLS コンテキストを変更しません。 これらの接続に再構成を適用するには、<code class="literal">STOP GROUP_REPLICATION</code> を実行してから <code class="literal">START GROUP_REPLICATION</code> を実行し、Group Replication を再起動する必要があります。 
      </p></div><p>
      分散リカバリのために結合メンバーと既存のメンバーの間で行われた接続は、前述のオプションではカバーされません。 これらの接続では、<a class="xref" href="group-replication.html#group-replication-configuring-ssl-for-recovery" title="18.5.3.2 分散リカバリのための Secure Socket Layer (SSL) 接続">セクション18.5.3.2「分散リカバリのための Secure Socket Layer (SSL) 接続」</a> で説明されているグループレプリケーション専用分散リカバリ SSL オプションが使用されます。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-distributed-recovery-securing"></a>18.5.3 分散リカバリ接続の保護</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-secure-user">18.5.3.1 分散リカバリのためのセキュアなユーザー資格証明</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-configuring-ssl-for-recovery">18.5.3.2 分散リカバリのための Secure Socket Layer (SSL) 接続</a></span></dt></dl></div><p>
      メンバーがグループに参加すると、リモートクローニング操作 (使用可能で適切な場合) と非同期レプリケーション接続の組合せを使用して分散リカバリが実行されます。 分散リカバリの詳細は、<a class="xref" href="group-replication.html#group-replication-distributed-recovery" title="18.4.3 分散リカバリ">セクション18.4.3「分散リカバリ」</a> を参照してください。 
    </p><p>
      既存のメンバーが分散リカバリのために参加メンバーに提供する接続は、グループのオンラインメンバー間の通信にグループレプリケーションで使用される接続と同じではありません。 MySQL 8.0.20 まで、グループメンバーは、MySQL Server <code class="literal">hostname</code> および <code class="literal">port</code> システム変数で指定されている分散リカバリのためにメンバーを結合するための標準 SQL クライアント接続を提供します。 MySQL 8.0.21 から、グループメンバーは分散リカバリエンドポイントの代替リストをメンバー参加専用のクライアント接続として通知できます。 詳細は、<a class="xref" href="group-replication.html#group-replication-distributed-recovery-connections" title="18.4.3.1 分散リカバリの接続">セクション18.4.3.1「分散リカバリの接続」</a>を参照してください。 
    </p><p>
      グループ内の分散リカバリ接続を保護するには、レプリケーションユーザーのユーザー資格証明が適切に保護されていることを確認し、可能な場合は分散リカバリ接続に SSL を使用します。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-secure-user"></a>18.5.3.1 分散リカバリのためのセキュアなユーザー資格証明</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-caching-sha2-user-credentials">18.5.3.1.1 キャッシュ SHA-2 認証プラグインを使用するレプリケーションユーザー</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-secure-user-ssl">18.5.3.1.2 SSL を使用したレプリケーションユーザー</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-secure-user-provide">18.5.3.1.3 レプリケーションユーザー資格証明のセキュアな提供</a></span></dt></dl></div><p>
        バイナリログからの状態転送では、グループレプリケーションがメンバー間の直接レプリケーションチャネルを確立できるように、適切な権限を持つレプリケーションユーザーが必要です。 すべてのグループメンバーで分散リカバリに同じレプリケーションユーザーが使用されます。 MySQL 8.0.17 から使用可能な分散リカバリの一部としてリモートクローニング操作の使用をサポートするようにグループメンバーが設定されている場合、このレプリケーションユーザーはドナーのクローンユーザーとしても使用され、このロールに対する正しい権限も必要です。 このユーザーを設定する手順の詳細は、<a class="xref" href="group-replication.html#group-replication-user-credentials" title="18.2.1.3 分散リカバリのユーザー資格証明">セクション18.2.1.3「分散リカバリのユーザー資格証明」</a> を参照してください。 
      </p><p>
        ユーザー資格証明を保護するには、ユーザーアカウントとの接続に SSL を要求し、(MySQL 8.0.21 から) グループレプリケーションの起動時に、レプリカステータステーブルに格納するのではなく、ユーザー資格証明を指定できます。 また、キャッシュ SHA-2 認証を使用している場合は、グループメンバーに RSA キーペアを設定する必要があります。 
      </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-caching-sha2-user-credentials"></a>18.5.3.1.1 キャッシュ SHA-2 認証プラグインを使用するレプリケーションユーザー</h5></div></div></div><p>
          デフォルトでは、MySQL 8 で作成されたユーザーは <a class="xref" href="security.html#caching-sha2-pluggable-authentication" title="6.4.1.2 SHA-2 プラガブル認証のキャッシュ">セクション6.4.1.2「SHA-2 プラガブル認証のキャッシュ」</a> を使用します。 分散リカバリ用に構成するレプリケーションユーザーがキャッシュ SHA-2 認証プラグインを使用し、分散リカバリ接続に SSL を使用しない場合、RSA キーペアがパスワード交換に使用されます。 RSA キーペアの詳細は、<a class="xref" href="security.html#creating-ssl-rsa-files" title="6.3.3 SSL および RSA 証明書とキーの作成">セクション6.3.3「SSL および RSA 証明書とキーの作成」</a> を参照してください。 
        </p><p>
          この状況では、<code class="literal">rpl_user</code> の公開キーを結合メンバーにコピーするか、リクエスト時に公開キーを提供するようにドナーを構成できます。 よりセキュアなアプローチは、レプリケーションユーザーアカウントの公開キーを参加メンバーにコピーすることです。 次に、レプリケーションユーザーアカウントの公開キーへのパスを使用して、結合メンバーで <code class="literal">group_replication_recovery_public_key_path</code> システム変数を構成する必要があります。 
        </p><p>
          安全性の低いアプローチは、メンバーに参加するためにレプリケーションユーザーアカウントの公開キーを提供するようにドナーに <code class="literal">group_replication_recovery_get_public_key=ON</code> を設定することです。 サーバーのアイデンティティを検証する方法はないため、中間者攻撃などによってサーバーアイデンティティが損なわれるリスクがないことが確実な場合にのみ、<code class="literal">group_replication_recovery_get_public_key=ON</code> を設定してください。 
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-secure-user-ssl"></a>18.5.3.1.2 SSL を使用したレプリケーションユーザー</h5></div></div></div><p>
          グループに参加するサーバー (参加メンバー) がドナーに接続する前に、SSL 接続を必要とするレプリケーションユーザーを作成する必要があります。 通常、これはサーバーをプロビジョニングしてグループに参加するときに設定されます。 SSL 接続を必要とする分散リカバリのレプリケーションユーザーを作成するには、グループに参加するすべてのサーバーで次のステートメントを発行します: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET SQL_LOG_BIN=0;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE USER '<em class="replaceable"><code>rec_ssl_user</code></em>'@'%' IDENTIFIED BY '<em class="replaceable"><code>password</code></em>' REQUIRE SSL;</code></strong>
mysql&gt; <strong class="userinput"><code>GRANT replication slave ON *.* TO '<em class="replaceable"><code>rec_ssl_user</code></em>'@'%';</code></strong>
mysql&gt; <strong class="userinput"><code>GRANT BACKUP_ADMIN ON *.* TO '<em class="replaceable"><code>rec_ssl_user</code></em>'@'%';</code></strong>
mysql&gt; <strong class="userinput"><code>FLUSH PRIVILEGES;</code></strong>
mysql&gt; <strong class="userinput"><code>SET SQL_LOG_BIN=1;</code></strong></pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-secure-user-provide"></a>18.5.3.1.3 レプリケーションユーザー資格証明のセキュアな提供</h5></div></div></div><p>
          レプリケーションユーザーのユーザー資格証明を指定するには、<code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントを使用して、<code class="literal">group_replication_recovery</code> チャネルの資格証明として永続的に設定します。 または、MySQL 8.0.21 から、グループレプリケーションが開始されるたびに <code class="literal">START GROUP_REPLICATION</code> ステートメントで指定できます。 <code class="literal">START GROUP_REPLICATION</code> で指定されたユーザー資格証明は、<code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントを使用して設定されたユーザー資格証明よりも優先されます。 
        </p><p>
          <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> を使用して設定されたユーザー資格証明は、サーバー上のレプリケーションメタデータリポジトリにプレーンテキストで格納されますが、<code class="literal">START GROUP_REPLICATION</code> で指定されたユーザー資格証明はメモリーにのみ保存され、<code class="literal">STOP GROUP_REPLICATION</code> ステートメントまたはサーバーの停止によって削除されます。 したがって、<code class="literal">START GROUP_REPLICATION</code> を使用してユーザー資格証明を指定すると、不正なアクセスからグループレプリケーションサーバーを保護するのに役立ちます。 ただし、この方法は、<code class="literal">group_replication_start_on_boot</code> システム変数で指定された Group Replication の自動起動とは互換性がありません。 
        </p><p>
          <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントを使用してユーザー資格証明を永続的に設定する場合は、グループに参加するメンバーに対して次のステートメントを発行します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO MASTER_USER='<em class="replaceable"><code>rec_ssl_user</code></em>', MASTER_PASSWORD='<em class="replaceable"><code>password</code></em>' 
            FOR CHANNEL 'group_replication_recovery';</code></strong>

Or from MySQL 8.0.23:
mysql&gt; <strong class="userinput"><code>CHANGE REPLICATION SOURCE TO SOURCE_USER='<em class="replaceable"><code>rec_ssl_user</code></em>', SOURCE_PASSWORD='<em class="replaceable"><code>password</code></em>' 
            FOR CHANNEL 'group_replication_recovery';</code></strong>
</pre><p>
          <code class="literal">START GROUP_REPLICATION</code> でユーザー資格証明を指定するには、グループレプリケーションの初回起動時またはサーバーの再起動後に次のステートメントを発行します:
        </p><pre class="programlisting">mysql&gt; START GROUP_REPLICATION USER='<em class="replaceable"><code>rec_ssl_user</code></em>', PASSWORD='<em class="replaceable"><code>password</code></em>';
</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
            <code class="literal">START GROUP_REPLICATION</code> を使用して、以前に <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> を使用して資格証明を提供したサーバー上のユーザー資格証明を指定するには、次のステップを実行して、この変更のセキュリティ上の利点を得る必要があります。
          </p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              <code class="literal">STOP GROUP_REPLICATION</code> ステートメントを使用して、グループメンバーのグループレプリケーションを停止します。 グループレプリケーションの実行中に次の 2 つのステップを実行できますが、変更を実装するにはグループレプリケーションを再起動する必要があります。 
            </p></li><li class="listitem"><p>
              <code class="literal">group_replication_start_on_boot</code> システム変数の値を <code class="literal">OFF</code> (デフォルトは <code class="literal">ON</code>) に設定します。
            </p></li><li class="listitem"><p>
              次のステートメントを発行して、レプリカステータステーブルから分散リカバリ資格証明を削除します:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO MASTER_USER='', MASTER_PASSWORD='' 
            FOR CHANNEL 'group_replication_recovery';</code></strong>

Or from MySQL 8.0.23:
mysql&gt; <strong class="userinput"><code>CHANGE REPLICATION SOURCE TO SOURCE_USER='', SOURCE_PASSWORD='' 
            FOR CHANNEL 'group_replication_recovery';</code></strong>
</pre></li><li class="listitem"><p>
              分散リカバリユーザー資格証明を指定する <code class="literal">START GROUP_REPLICATION</code> ステートメントを使用して、グループメンバーでグループレプリケーションを再起動します。
            </p></li></ol></div><p>
          これらのステップを実行しないと、資格証明はレプリカステータステーブルに格納されたままになり、分散リカバリのリモートクローニング操作中に他のグループメンバーに転送することもできます。 その後、元のメンバーまたはそこからクローニングされたメンバーのいずれかで、<code class="literal">group_replication_recovery</code> チャネルが誤って格納された資格証明で起動される可能性があります。 サーバー起動時のグループレプリケーションの自動開始 (リモートクローニング操作後を含む) では、格納されたユーザー資格証明が使用され、オペレータが <code class="literal">START GROUP_REPLICATION</code> コマンドで分散リカバリ資格証明を指定しなかった場合にも使用されます。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-configuring-ssl-for-recovery"></a>18.5.3.2 分散リカバリのための Secure Socket Layer (SSL) 接続</h4></div></div></div><p>
        標準 SQL クライアント接続と分散リカバリエンドポイントのどちらを使用して分散リカバリ接続を確立する場合でも、セキュアに接続を構成するために Group Replication 専用の分散リカバリ SSL オプションを使用できます。 これらのオプションは、グループ通信接続に使用されるサーバー SSL オプションに対応していますが、分散リカバリ接続にのみ適用されます。 デフォルトでは、グループ通信接続に対して SSL をアクティブ化した場合でも、分散リカバリ接続では SSL は使用されず、分散リカバリ接続にはサーバー SSL オプションは適用されません。 これらの接続は個別に構成する必要があります。 
      </p><p>
        リモートクローニング操作が分散リカバリの一部として使用される場合、Group Replication は、分散リカバリ SSL オプションの設定と一致するようにクローンプラグイン SSL オプションを自動的に構成します。 (クローンプラグインが SSL を使用する方法の詳細は、<a class="xref" href="server-administration.html#clone-plugin-remote-ssl" title="クローニング用の暗号化された接続の構成">クローニング用の暗号化された接続の構成</a> を参照してください。) 
      </p><p>
        分散リカバリの SSL オプションは次のとおりです:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">group_replication_recovery_use_ssl</code>: グループレプリケーションが分散リカバリ接続に SSL を使用するようにするには、<code class="literal">ON</code> に設定します。これには、リモートクローニング操作やドナーのバイナリログからの状態転送が含まれます。 このオプションを設定するだけで、他の分散リカバリ SSL オプションは設定できません。この場合、サーバーは接続に使用する証明書を自動的に生成し、デフォルトの暗号スイートを使用します。 接続用の証明書および暗号スイートを構成する場合は、他の分散リカバリ SSL オプションを使用して構成します。 
          </p></li><li class="listitem"><p>
            <code class="literal">group_replication_recovery_ssl_ca</code>: 分散リカバリ接続に使用する認証局 (CA) ファイルのパス名。 グループレプリケーションでは、クローン SSL オプション <code class="literal">clone_ssl_ca</code> がこれに一致するように自動的に構成されます。 
          </p><p>
            <code class="literal">group_replication_recovery_ssl_capath</code>: 信頼できる SSL 認証局 (CA) 証明書ファイルを含むディレクトリのパス名。
          </p></li><li class="listitem"><p>
            <code class="literal">group_replication_recovery_ssl_cert</code>: 分散リカバリ接続に使用する SSL 公開キー証明書ファイルのパス名。 グループレプリケーションでは、クローン SSL オプション <code class="literal">clone_ssl_cert</code> がこれに一致するように自動的に構成されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">group_replication_recovery_ssl_key</code>: 分散リカバリ接続に使用する SSL 秘密キーファイルのパス名。 グループレプリケーションでは、クローン SSL オプション <code class="literal">clone_ssl_cert</code> がこれに一致するように自動的に構成されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">group_replication_recovery_ssl_verify_server_cert</code>: 分散リカバリ接続で、ドナーが送信した証明書のサーバーの共通名の値をチェックします。 このオプションを <code class="literal">ON</code> に設定することは、グループ通信接続の <code class="literal">group_replication_ssl_mode</code> オプションに <code class="literal">VERIFY_IDENTITY</code> を設定する分散リカバリ接続の場合と同じです。 
          </p></li><li class="listitem"><p>
            <code class="literal">group_replication_recovery_ssl_crl</code>: 証明書失効リストを含むファイルのパス名。
          </p></li><li class="listitem"><p>
            <code class="literal">group_replication_recovery_ssl_crlpath</code>: 証明書失効リストを含むディレクトリのパス名。
          </p></li><li class="listitem"><p>
            <code class="literal">group_replication_recovery_ssl_cipher</code>: 分散リカバリ接続の接続暗号化に許可される暗号のリスト。 コロンで区切られた 1 つ以上の暗号名のリストを指定します。 MySQL がサポートする暗号化暗号の詳細は、<a class="xref" href="security.html#encrypted-connection-protocols-ciphers" title="6.3.2 暗号化された接続 TLS プロトコルおよび暗号">セクション6.3.2「暗号化された接続 TLS プロトコルおよび暗号」</a> を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">group_replication_recovery_tls_version</code>: このサーバーインスタンスが分散リカバリ接続のクライアント (参加メンバー) である場合に、接続暗号化に許可される 1 つ以上の TLS プロトコルのカンマ区切りリスト。 指定したバージョンが連続していることを確認します (たとえば、<span class="quote">「<span class="quote"><code class="literal">TLSv1,TLSv1.1,TLSv1.2</code></span>」</span>)。 このシステム変数が設定されていない場合、デフォルトの <span class="quote">「<span class="quote"><code class="literal">TLSv1,TLSv1.1,TLSv1.2,TLSv1.3</code></span>」</span> が使用されます。 クライアント (参加メンバー) およびサーバー (ドナー) としての各分散リカバリ接続に含まれるグループメンバーは、どちらもサポートするように設定されている最高のプロトコルバージョンをネゴシエートします。 このシステム変数は、MySQL 8.0.19 から使用できます。 
          </p></li><li class="listitem"><p>
            <code class="literal">group_replication_recovery_tls_ciphersuites</code>: 分散リカバリ接続の接続暗号化に TLSv1.3 が使用され、このサーバーインスタンスが分散リカバリ接続のクライアント (参加メンバー) である場合に許可される暗号スイートのコロン区切りリスト。 TLSv1.3 の使用時にこのシステム変数が <code class="literal">NULL</code> に設定されている場合 (システム変数を設定しない場合のデフォルト)、<a class="xref" href="security.html#encrypted-connection-protocols-ciphers" title="6.3.2 暗号化された接続 TLS プロトコルおよび暗号">セクション6.3.2「暗号化された接続 TLS プロトコルおよび暗号」</a> にリストされているように、デフォルトで有効になっている暗号スイートが許可されます。 このシステム変数が空の文字列に設定されている場合、暗号スイートは許可されないため、TLSv1.3 は使用されません。 このシステム変数は、MySQL 8.0.19 以降で使用できます。 
          </p></li></ul></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="group-replication-performance"></a>18.6 グループレプリケーションのパフォーマンス</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-fine-tuning-the-group-communication-thread">18.6.1 グループ通信スレッドの微調整</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-flow-control">18.6.2 フロー制御</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-message-compression">18.6.3 メッセージ圧縮</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-performance-message-fragmentation">18.6.4 メッセージの断片化</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-performance-xcom-cache">18.6.5 XCom キャッシュ管理</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-responses-failure">18.6.6 障害検出およびネットワークパーティション化へのレスポンス</a></span></dt></dl></div><a class="indexterm" name="idm45563246768128"></a><p>
    このセクションでは、使用可能な構成オプションを使用してレプリケーショングループから最高のパフォーマンスを得る方法について説明します。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-fine-tuning-the-group-communication-thread"></a>18.6.1 グループ通信スレッドの微調整</h3></div></div></div><a class="indexterm" name="idm45563246764192"></a><a class="indexterm" name="idm45563246762016"></a><p>
      Group Replication プラグインがロードされている間、グループ通信スレッド (GCT) はループで実行されます。 GCT は、グループおよびプラグインからメッセージを受信し、定足数および障害検出関連タスクを処理し、キープアライブメッセージをいくつか送信し、サーバー/グループとの送受信トランザクションも処理します。 GCT は、キュー内の受信メッセージを待機します。 メッセージがない場合、GCT は待機します。 この待機を (アクティブな待機を行う) 少し長く構成することで、実際にスリープになる前に、場合によっては有益であることが証明されます。 これは、オペレーティングシステムがプロセッサから GCT を切り替えてコンテキストスイッチを実行するためです。 
    </p><p>
      GCT で強制的にアクティブな待機を実行するには、<code class="literal">group_replication_poll_spin_loops</code> オプションを使用します。これにより、GCT ループは、次のメッセージのキューを実際にポーリングする前に、構成されたループ数に関係なく何も実行されません。
    </p><p>
      例:
    </p><pre class="programlisting">mysql&gt; SET GLOBAL group_replication_poll_spin_loops= 10000;</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-flow-control"></a>18.6.2 フロー制御</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-probes-and-statistics">18.6.2.1 プローブと統計</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-throttling">18.6.2.2 グループレプリケーションスロットル</a></span></dt></dl></div><a class="indexterm" name="idm45563246752960"></a><p>
      グループレプリケーションでは、グループ内の大部分のメンバーがトランザクションを受信し、同時に送信されたすべてのトランザクション間の相対的な順序で合意した後にのみ、トランザクションがコミットされます。 この方法は、グループへの書込みの合計数がグループ内のどのメンバーの書込み容量も超えない場合に適しています。 書込みスループットが他のメンバーよりも低い場合 (特にライターメンバーよりも低い場合)、これらのメンバーはライターの遅延を開始できます。 
    </p><p>
      一部のメンバーがグループより遅れていると、問題のある結果が発生します。特に、このようなメンバーに対する読取りによって、非常に古いデータが外部化される可能性があります。 メンバーが遅れている理由によっては、低速メンバーからの潜在的なデータ転送リクエストを満たすために、グループ内の他のメンバーがより多くのレプリケーションコンテキストを保存する必要がある場合があります。 
    </p><p>
      ただし、レプリケーションプロトコルには、高速メンバーと低速メンバーの間に適用されるトランザクションに関して距離が多すぎることを回避するメカニズムがあります。 これはフロー制御メカニズムと呼ばれます。 いくつかの目標に対処しようとします: 
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          メンバー間でバッファリングおよび同期解除を行うのに十分な大きさにメンバーを近づけることは、小さい問題です
        </p></li><li class="listitem"><p>
          グループ内の異なるワークロードやより多くのライターなどの条件の変化に迅速に適応できます
        </p></li><li class="listitem"><p>
          各メンバーに使用可能な書込み容量のフェアシェアを付与
        </p></li><li class="listitem"><p>
          リソースの無駄を避けるために必要以上のスループットを削減しません。
        </p></li></ol></div><p>
      グループレプリケーションの設計では、2 つの作業キューを考慮してスロットルするかどうかを決定できます: <span class="emphasis"><em>動作保証</em></span>キュー、<span class="emphasis"><em>(ii)</em></span> およびバイナリログ <span class="emphasis"><em>applier</em></span> キューで <span class="emphasis"><em>(i)</em></span> を実行します。 これらのキューのいずれかのサイズがユーザー定義のしきい値を超えると、スロットルメカニズムがトリガーされます。 構成のみ: <span class="emphasis"><em>(i)</em></span> では、認証者レベルまたはアプライヤレベル (あるいはその両方) でフロー制御を実行するかどうか、および <span class="emphasis"><em>(ii)</em></span> では各キューのしきい値は何ですか。 
    </p><p>
      フロー制御は、次の 2 つの基本メカニズムに依存します:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          すべてのグループメンバーのスループットおよびキューサイズに関するいくつかの統計を収集するためのメンバーの監視。各メンバーの最大書込み圧力を測定
        </p></li><li class="listitem"><p>
          各時点で使用可能な容量の公平配分を超えて書き込もうとしているメンバーのスロットル。
        </p></li></ol></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-probes-and-statistics"></a>18.6.2.1 プローブと統計</h4></div></div></div><a class="indexterm" name="idm45563246733040"></a><p>
        監視メカニズムは、各メンバーが一連のプローブをデプロイして、そのワークキューおよびスループットに関する情報を収集するようにすることで機能します。 次に、その情報を定期的にグループに伝播して、そのデータを他のメンバーと共有します。 
      </p><p>
        このようなプローブはプラグインスタック全体に分散され、次のようなメトリックを確立できます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            証明者のキューサイズ
          </p></li><li class="listitem"><p>
            レプリケーションアプライアンスのキューサイズ
          </p></li><li class="listitem"><p>
            動作保証されたトランザクションの合計数
          </p></li><li class="listitem"><p>
            メンバーに適用されたリモートトランザクションの合計数
          </p></li><li class="listitem"><p>
            ローカルトランザクションの総数。
          </p></li></ul></div><p>
        メンバーは、別のメンバーからの統計を含むメッセージを受信すると、最後の監視期間中に動作保証、適用およびローカルに実行されたトランザクションの数に関する追加メトリックを計算します。
      </p><p>
        監視データは、グループ内の他のユーザーと定期的に共有されます。 監視期間は、他のメンバーが現在の書込みリクエストを決定できるように十分に長くする必要がありますが、グループ帯域幅への影響を最小限に抑えるには十分です。 情報は毎秒共有され、この期間で両方の懸案に対処できます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-throttling"></a>18.6.2.2 グループレプリケーションスロットル</h4></div></div></div><a class="indexterm" name="idm45563246721056"></a><p>
        グループ内のすべてのサーバーにわたって収集されたメトリックに基づいて、スロットルメカニズムが開始され、メンバーが新しいトランザクションを実行/コミットできるレートを制限するかどうかが決定されます。
      </p><p>
        したがって、すべてのメンバーから取得されたメトリックは、各メンバーの容量を計算するための基準となります: メンバーに大規模なキュー (証明またはアプライヤスレッド用) がある場合、新しいトランザクションを実行するための容量は、最後の期間に動作保証または適用された容量に近い必要があります。
      </p><p>
        グループ内のすべてのメンバーの最小容量によってグループの実際の容量が決まりますが、ローカルトランザクションの数によって書込み中のメンバーの数が決まり、その結果、使用可能な容量を共有するメンバーの数が決まります。
      </p><p>
        これは、すべてのメンバーが使用可能な容量に基づいて書込み割当て制限を確立していることを意味します。つまり、次の期間に安全に発行できるトランザクションの数が多くなります。 ライター割当て制限は、証明者またはバイナリログアプライアンスのキューサイズがユーザー定義のしきい値を超えると、スロットルメカニズムによって強制されます。 
      </p><p>
        割当て制限は、前の期間に遅延したトランザクションの数だけ削減され、さらに 10% 削減されて、問題をトリガーしたキューのサイズを縮小できるようになります。 キューサイズがしきい値を超えるとスループットのジャンプが大きくならないようにするために、スループットはその後の期間ごとに同じ 10% 増加することのみが許可されます。 
      </p><p>
        現在のスロットルメカニズムでは、割当て制限を下回るトランザクションはペナル化されませんが、監視期間が終了するまで、それを超えるトランザクションの終了は遅延されます。 その結果、発行された書込みリクエストの割当て制限が非常に小さい場合、一部のトランザクションで待機時間が監視期間に近い可能性があります。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-message-compression"></a>18.6.3 メッセージ圧縮</h3></div></div></div><a class="indexterm" name="idm45563246710976"></a><p>
      オンライングループメンバー間で送信されるメッセージの場合、グループレプリケーションはデフォルトでメッセージ圧縮を有効にします。 特定のメッセージが圧縮されるかどうかは、<code class="literal">group_replication_compression_threshold</code> システム変数を使用して構成するしきい値によって決まります。 ペイロードが指定されたバイト数より大きいメッセージは圧縮されます。 
    </p><p>
      デフォルトの圧縮しきい値は 1000000 バイトです。 たとえば、次のステートメントを使用して、圧縮しきい値を 2MB に増やすことができます: 
    </p><pre class="programlisting">STOP GROUP_REPLICATION;
SET GLOBAL group_replication_compression_threshold = 2097152;
START GROUP_REPLICATION;</pre><p>
      <code class="literal">group_replication_compression_threshold</code> をゼロに設定すると、メッセージ圧縮は無効になります。
    </p><p>
      グループレプリケーションでは、LZ4 圧縮アルゴリズムを使用して、グループで送信されるメッセージを圧縮します。 LZ4 圧縮アルゴリズムでサポートされる最大入力サイズは 2113929216 バイトです。 この制限は、XCom で受け入れられる最大メッセージサイズと一致する、<code class="literal">group_replication_compression_threshold</code> システム変数の最大可能値を下回っています。 したがって、LZ4 の最大入力サイズはメッセージ圧縮の実用的な制限であり、メッセージ圧縮が有効な場合、このサイズを超えるトランザクションはコミットできません。 LZ4 圧縮アルゴリズムでは、<code class="literal">group_replication_compression_threshold</code> に 2113929216 バイトを超える値を設定しないでください。 
    </p><p>
      グループレプリケーションでは、<code class="literal">group_replication_compression_threshold</code> の値はすべてのグループメンバーで同じである必要はありません。 ただし、トランザクションの不要なロールバック、メッセージ配信の失敗またはメッセージリカバリの失敗を回避するために、すべてのグループメンバーに同じ値を設定することをお薦めします。 
    </p><p>
      MySQL 8.0.18 から、ドナーバイナリログからの状態転送によって分散リカバリ用に送信されるメッセージの圧縮を構成することもできます。 グループ内にすでに存在するドナーから参加メンバーに送信されるこれらのメッセージの圧縮は、<code class="literal">group_replication_recovery_compression_algorithm</code> および <code class="literal">group_replication_recovery_zstd_compression_level</code> システム変数を使用して個別に制御されます。 詳細は、<a class="xref" href="programs.html#connection-compression-control" title="4.2.8 接続圧縮制御">セクション4.2.8「接続圧縮制御」</a>を参照してください。 
    </p><p>
      <code class="literal">binlog_transaction_compression</code> システム変数によってアクティブ化されるバイナリログトランザクション圧縮 (MySQL 8.0.20 で使用可能) を使用して帯域幅を節約することもできます。 トランザクションペイロードは、グループメンバー間で転送されても圧縮されたままです。 バイナリログトランザクションの圧縮を Group Replication メッセージの圧縮と組み合わせて使用する場合、メッセージの圧縮ではデータを処理する機会は少なくなりますが、ヘッダーと、圧縮されていないイベントおよびトランザクションペイロードは圧縮できます。 バイナリログのトランザクション圧縮の詳細は、<a class="xref" href="server-administration.html#binary-log-transaction-compression" title="5.4.4.5 バイナリログトランザクション圧縮">セクション5.4.4.5「バイナリログトランザクション圧縮」</a> を参照してください。 
    </p><p>
      グループ内で送信されるメッセージの圧縮は、データがグループ通信スレッドに渡される前に、グループ通信エンジンレベルで行われるため、<code class="literal">mysql</code> ユーザーセッションスレッドのコンテキスト内で行われます。 メッセージペイロードサイズが <code class="literal">group_replication_compression_threshold</code> で設定されたしきい値を超えると、トランザクションペイロードはグループに送信される前に圧縮され、受信時に解凍されます。 メッセージを受信すると、メンバーはメッセージエンベロープをチェックして、圧縮されているかどうかを確認します。 必要に応じて、メンバーは上位レイヤーに配信する前にトランザクションを解凍します。 このプロセスを次の図に示します。 
    </p><div class="figure"><a name="idm45563246686704"></a><p class="title"><b>図 18.15 圧縮のサポート</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/gr-compress-decompress.png" width="603" height="492" alt="MySQL Group Replication プラグインアーキテクチャーは、前のトピックで説明したように、プラグインの 5 つのレイヤーが MySQL サーバーとレプリケーショングループの間に配置されています。 圧縮と解凍は、Group Replication プラグインの第 4 層である Group Communication System API によって処理されます。 グループ通信エンジン (プラグインの第 5 層) とグループメンバーは、より小さいデータサイズの圧縮トランザクションを使用します。 MySQL Server コアおよび Group Replication プラグインの上位 3 つのレイヤー (API、キャプチャ、適用機能およびリカバリコンポーネント、およびレプリケーションプロトコルモジュール) では、より大きいデータサイズの元のトランザクションが使用されます。"></div></div></div><br class="figure-break"><p>
      ネットワーク帯域幅がボトルネックの場合、メッセージ圧縮により、グループ通信レベルでスループットが最大 30 から 40% 向上します。 これは、負荷の高い大規模なサーバーグループのコンテキスト内で特に重要です。 グループ内の <span class="emphasis"><em>N</em></span> 参加者間の相互接続の TCP ピアツーピアの性質により、送信者は同じ量のデータを <span class="emphasis"><em>N</em></span> 回送信します。 さらに、バイナリログは高い圧縮率を示している可能性があります。 これにより、圧縮は、大規模なトランザクションを含むグループレプリケーションワークロードにとって魅力的な機能になります。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-performance-message-fragmentation"></a>18.6.4 メッセージの断片化</h3></div></div></div><a class="indexterm" name="idm45563246674656"></a><p>
      グループレプリケーショングループメンバー間で異常に大きいメッセージが送信されると、一部のグループメンバーが失敗としてレポートされ、グループから除外される可能性があります。 これは、Group Replication グループ通信エンジン (XCom、Paxos バリアント) で使用されるシングルスレッドがメッセージの処理に時間がかかりすぎるため、一部のグループメンバーが受信者を失敗として報告する可能性があるためです。 デフォルトでは、MySQL 8.0.16 から、大きいメッセージは自動的にフラグメントに分割され、受信者によって個別に送信されて再アセンブルされます。 
    </p><p>
      システム変数 <code class="literal">group_replication_communication_max_message_size</code> は、グループレプリケーション通信の最大メッセージサイズを指定します。このサイズを超えると、メッセージは断片化されます。 デフォルトの最大メッセージサイズは 10485760 バイト (10 MiB) です。 最大許容値は、<code class="literal">slave_max_allowed_packet</code> システム変数の最大値 1073741824 バイト (1 GB) と同じです。 アプライヤスレッドは <code class="literal">slave_max_allowed_packet</code> より大きいメッセージフラグメントを処理できないため、<code class="literal">group_replication_communication_max_message_size</code> の設定は <code class="literal">slave_max_allowed_packet</code> の設定より小さくする必要があります。 断片化をオフにするには、<code class="literal">group_replication_communication_max_message_size</code> にゼロ値を指定します。 
    </p><p>
      他のほとんどの Group Replication システム変数と同様に、変更を有効にするには Group Replication プラグインを再起動する必要があります。 例: 
    </p><pre class="programlisting">STOP GROUP_REPLICATION;
SET GLOBAL group_replication_communication_max_message_size= 5242880;
START GROUP_REPLICATION;</pre><p>
      断片化されたメッセージのメッセージ配信は、メッセージのすべてのフラグメントが受信され、すべてのグループメンバーによって再アセンブルされると完了とみなされます。 断片化されたメッセージには、ヘッダー内の情報が含まれます。この情報を使用すると、メッセージ転送中にメンバーを結合して、参加前に送信された以前のフラグメントをリカバリできます。 結合メンバーがフラグメントのリカバリに失敗すると、グループから削除されます。 
    </p><p>
      レプリケーショングループで断片化を使用するには、すべてのグループメンバーが MySQL 8.0.16 以上であり、グループで使用されている Group Replication 通信プロトコルバージョンで断片化が許可されている必要があります。 グループがサポートしている最も古い MySQL Server バージョンを返す <code class="literal">group_replication_get_communication_protocol()</code> UDF を使用して、グループが使用している通信プロトコルを検査できます。 MySQL 5.7.14 のバージョンではメッセージを圧縮でき、MySQL 8.0.16 のバージョンではメッセージを断片化することもできます。 すべてのグループメンバーが MySQL 8.0.16 以上で、以前のリリースのメンバーの参加を許可する必要がない場合は、<code class="literal">group_replication_set_communication_protocol()</code> UDF を使用して通信プロトコルバージョンを MySQL 8.0.16 以上に設定し、断片化を許可できます。 詳細は、<a class="xref" href="group-replication.html#group-replication-communication-protocol" title="18.4.1.4 グループ通信プロトコルバージョンの設定">セクション18.4.1.4「グループ通信プロトコルバージョンの設定」</a>を参照してください。 
    </p><p>
      一部のメンバーが断片化をサポートしていないためにレプリケーショングループが断片化を使用できない場合は、システム変数 <code class="literal">group_replication_transaction_size_limit</code> を使用して、グループが受け入れるトランザクションの最大サイズを制限できます。 MySQL 8.0 では、デフォルト設定は約 143 MB です。 このサイズを超えるトランザクションはロールバックされます。 システム変数 <code class="literal">group_replication_member_expel_timeout</code> を使用して、失敗した疑いがあるメンバーがグループから削除されるまでの追加時間 (最大 1 時間) を許可することもできます。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-performance-xcom-cache"></a>18.6.5 XCom キャッシュ管理</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-performance-xcom-cache-increase">18.6.5.1 キャッシュサイズの増加</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-performance-xcom-cache-reduce">18.6.5.2 キャッシュサイズの削減</a></span></dt></dl></div><a class="indexterm" name="idm45563246649872"></a><p>
      グループレプリケーションのグループ通信エンジン (XCom、Paxos バリアント) には、コンセンサスプロトコルの一部としてグループメンバー間で交換されるメッセージ (およびそのメタデータ) のキャッシュが含まれます。 メッセージキャッシュは、他のグループメンバーと通信できなかった期間後にグループに再接続するメンバーによる、欠落したメッセージのリカバリに使用されます。 
    </p><p>
      MySQL 8.0.16 から、<code class="literal">group_replication_message_cache_size</code> システム変数を使用して XCom メッセージキャッシュのキャッシュサイズ制限を設定できます。 キャッシュサイズ制限に達すると、XCom は決定され配信された最も古いエントリを削除します。 再接続しようとしている到達不能なメンバーは、欠落したメッセージをリカバリするために他のメンバーをランダムに選択するため、すべてのグループメンバーに同じキャッシュサイズ制限を設定する必要があります。 したがって、各メンバーキャッシュで同じメッセージを使用できる必要があります。 
    </p><p>
      MySQL 8.0.16 より前では、キャッシュサイズは 1 GB で、MySQL 8.0.16 のキャッシュサイズのデフォルト設定は同じです。 MySQL Server の他のキャッシュおよびオブジェクトプールのサイズを考慮して、選択したキャッシュサイズ制限に十分なメモリーがシステムで使用可能であることを確認します。 <code class="literal">group_replication_message_cache_size</code> を使用して設定された制限はキャッシュに格納されているデータにのみ適用され、キャッシュ構造には追加の 50 MB のメモリーが必要です。 
    </p><p>
      <code class="literal">group_replication_message_cache_size</code> 設定を選択する場合は、メンバーが削除されるまでの期間内の予想されるメッセージ量を参照してください。 この期間の長さは、メンバーが明示されるのではなくグループに戻るための最初の 5 秒間の検出期間に加えて許可される待機期間 (最大時間) を決定する <code class="literal">group_replication_member_expel_timeout</code> システム変数によって制御されます。 MySQL 8.0.21 より前は、<code class="literal">group_replication_member_expel_timeout</code> システム変数によって設定された追加の明示タイムアウトがデフォルトでゼロに設定されているため、この期間はメンバーが使用できなくなるまでの 5 秒にデフォルト設定されることに注意してください。これは疑わしいが作成されるまでの検出期間です。 8.0.21 からは、expel タイムアウトはデフォルトで 5 秒に設定されるため、メンバーは少なくとも 10 秒間存在しなくなるまで削除されません。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-performance-xcom-cache-increase"></a>18.6.5.1 キャッシュサイズの増加</h4></div></div></div><p>
        メンバーがグループから削除されるのに十分な長さでない期間存在しない場合、別のメンバーの XCom メッセージキャッシュから欠落したトランザクションを取得することで、再接続してグループへの参加を再開できます。 ただし、メンバーの休暇欠勤中に発生したトランザクションが、最大サイズ制限に達したために他のメンバーの XCom メッセージキャッシュから削除された場合、メンバーはこの方法で再接続できません。 
      </p><p>
        Group Replication Group Communication System (GCS) は、現在アクセスできないメンバーによるリカバリに必要と思われるメッセージがメッセージキャッシュから削除されたときに、警告メッセージでアラートを生成します。 この警告メッセージは、すべてのアクティブなグループメンバーに記録されます (アクセスできないメンバーごとに一度のみ)。 グループメンバーは、アクセスできないメンバーに最後に表示されたメッセージを確認できませんが、警告メッセージには、メンバーが削除される前に、選択した待機期間をサポートするのに十分なキャッシュサイズがない可能性があることが示されます。 
      </p><p>
        この状況では、メンバーが正常に戻るために必要なすべての欠落メッセージがキャッシュに含まれるように、<code class="literal">group_replication_member_expel_timeout</code> システム変数で指定された期間内の予想されるメッセージ量に 5 秒の検出期間を加えて、<code class="literal">group_replication_message_cache_size</code> の制限を増やすことを検討してください。 メンバーが異常な期間使用不可になると予想される場合は、キャッシュサイズ制限を一時的に増やすことも検討できます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-performance-xcom-cache-reduce"></a>18.6.5.2 キャッシュサイズの削減</h4></div></div></div><p>
        XCom メッセージキャッシュサイズの最小設定は、1 GB から MySQL 8.0.20 までです。 MySQL 8.0.21 からは、最小設定は 134217728 バイト (128 MB) で、使用可能なメモリー量が制限されたホストへのデプロイメントを可能にします。 ホストが不安定なネットワーク上にある場合、<code class="literal">group_replication_message_cache_size</code> 設定を非常に低くすることはお薦めしません。これは、メッセージキャッシュが小さいほど、接続が一時的に失われた後にグループメンバーが再接続するのが困難になるためです。 
      </p><p>
        再接続するメンバーが XCom メッセージキャッシュから必要なすべてのメッセージを取得できない場合、分散リカバリを使用して別のメンバーバイナリログから欠落しているトランザクションを取得するには、メンバーはグループから移動して再結合する必要があります。 MySQL 8.0.21 から、グループを離れたメンバーはデフォルトで 3 回の自動再結合を試行するため、オペレータの介入なしでもグループの再結合プロセスを実行できます。 ただし、分散リカバリを使用した再結合は、XCom メッセージキャッシュからメッセージを取得するよりも大幅に長く複雑なプロセスであるため、メンバーが使用可能になり、グループのパフォーマンスが影響を受ける可能性があります。 安定したネットワーク (メンバーの接続の一時的な損失の頻度と期間を最小限に抑える) では、この発生の頻度も最小限に抑える必要があるため、グループはパフォーマンスに大きな影響を与えずに、より小さい XCom メッセージキャッシュサイズを許容できる可能性があります。 
      </p><p>
        キャッシュサイズ制限を減らすことを検討している場合は、次のステートメントを使用して「パフォーマンススキーマ」テーブル <code class="literal">memory_summary_global_by_event_name</code> をクエリーすることができます:
      </p><pre class="programlisting">SELECT * FROM performance_schema.memory_summary_global_by_event_name
  WHERE EVENT_NAME LIKE 'memory/group_rpl/GCS_XCom::xcom_cache';
</pre><p>
        これは、キャッシュされたエントリの現在の数やキャッシュの現在のサイズなど、メッセージキャッシュのメモリー使用量の統計を返します。 キャッシュサイズ制限を小さくすると、XCom では、現在のサイズが制限を下回るまで、決定および配信された最も古いエントリが削除されます。 この削除プロセスの進行中に、XCom が一時的にキャッシュサイズ制限を超えている可能性があります。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-responses-failure"></a>18.6.6 障害検出およびネットワークパーティション化へのレスポンス</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-responses-failure-expel">18.6.6.1 Expel タイムアウト</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-responses-failure-partition">18.6.6.2 使用できない大多数のタイムアウト</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-responses-failure-rejoin">18.6.6.3 Auto-Rejoin</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-responses-failure-exit">18.6.6.4 終了処理</a></span></dt></dl></div><a class="indexterm" name="idm45563246617744"></a><a class="indexterm" name="idm45563246615552"></a><a class="indexterm" name="idm45563246613472"></a><p>
      グループレプリケーション障害検出メカニズムは、グループと通信しなくなったグループメンバーを識別し、障害が発生した可能性があると思われる場合に明示するように設計されています。 障害検出メカニズムを使用すると、グループに正しく機能するメンバーの大部分が含まれ、そのためクライアントからのリクエストが正しく処理される可能性が高くなります。 
    </p><p>
      通常、すべてのグループメンバーは、他のすべてのグループメンバーと定期的にメッセージを交換します。 グループメンバーが特定のフェローメンバーからのメッセージを 5 秒間受信しない場合、この検出期間が終了すると、フェローメンバーの疑いが生じます。 疑わしいメンバーがタイムアウトすると、疑わしいメンバーは失敗したとみなされ、グループから削除されます。 削除されたメンバーは、他のメンバーに表示されるメンバーシップリストから削除されますが、グループから削除されたことは認識されないため、オンラインとして表示され、他のメンバーは使用不可として表示されます。 メンバーが実際に失敗しておらず (たとえば、一時的なネットワークの問題のために切断されたばかりのため)、他のメンバーとの通信を再開できる場合は、グループから削除された情報を含むビューを受信します。 
    </p><p>
      これらの状況に対するグループメンバーのレスポンス (失敗したメンバー自体を含む) は、プロセスのいくつかのポイントで構成できます。 デフォルトでは、メンバーに障害が発生した疑いがある場合、次の動作が発生します: 
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          MySQL 8.0.20 までは、疑いが作成されるとすぐにタイムアウトします。 疑わしいメンバーは、失効した疑いがグループによって識別されるとすぐに削除の責任を負います。 期限切れの疑いのチェックは定期的に実行されるため、メンバーはタイムアウト後数秒間存続する可能性があります。 MySQL 8.0.21 からは、疑わしいメンバーが削除の責任を負うまで、5 秒の待機期間が追加されます。 
        </p></li><li class="listitem"><p>
          削除されたメンバーが通信を再開し、MySQL 8.0.20 まで削除されたことを認識した場合、グループへの再参加は試行されません。 MySQL 8.0.21 からは、グループへの再参加が 3 回自動的に試行され (試行ごとに 5 分)、この自動再結合プロシージャが機能しない場合は、グループへの再参加の試行が停止されます。 
        </p></li><li class="listitem"><p>
          削除されたメンバーがグループに再度参加しようとしていない場合、スーパー読取り専用モードに切り替わり、オペレータの注意を待ちます。 (ただし、MySQL 8.0.12 から 8.0.15 へのリリースでは例外です。デフォルトでは、メンバー自体がシャットダウンされます。 MySQL 8.0.16 から、MySQL 5.7 の動作と一致するように動作が変更されました。) 
        </p></li></ol></div><p>
      このセクションで説明する Group Replication 構成オプションを使用すると、システム要件および優先順位に合せて、これらの動作を永続的または一時的に変更できます。 低速なネットワークまたはマシン、予期しない一時的な停止率の高いネットワーク、または計画的なネットワーク停止が原因で不要な削除が発生した場合は、expel timeout および auto-rejoin の試行を増やすことを検討してください。 MySQL 8.0.21 からは、この方向にデフォルト設定が変更され、これらの状況でメンバーを解放するためにオペレータの介入が必要になる頻度が削減されました。 メンバーは前述のデフォルトの動作のいずれかを実行していますが、書込みを受け入れませんが、メンバーがクライアントと通信している場合は、時間の経過とともに失効した読取りの可能性が高くなり、読取りを行うことができます。 失効した読取りの回避は、演算子の介入を回避するよりも優先度が高い場合は、expel timeout および auto-rejoin の試行を減らすか、ゼロに設定することを検討してください。 
    </p><p>
      障害が発生していないメンバーは、ネットワークパーティションのためにレプリケーショングループの一部 (すべてではない) との接続を失う可能性があります。 たとえば、5 つのサーバー (S1、S2、S3、S4、S5) のグループでは、(S1、S2) と (S3、S4、S5) の間に切断がある場合、ネットワークパーティションがあります。 最初のグループ (S1、S2) は、半分を超えるグループにコンタクトできないため、少数民族になりました。 少数民族グループのメンバーによって処理されるトランザクションはブロックされます。これは、グループの大部分にアクセスできないため、グループはクォーラムを達成できないためです。 このシナリオの詳細は、<a class="xref" href="group-replication.html#group-replication-network-partitioning" title="18.4.4 ネットワークパーティション化">セクション18.4.4「ネットワークパーティション化」</a> を参照してください。 この場合、デフォルトの動作では、少数民族と大多数のメンバーがグループに残り、(少数民族のメンバーでブロックされていても) トランザクションの受入れを続行し、オペレータの介入を待機します。 この動作も構成可能です。 
    </p><p>
      関連する設定をサポートしていない古い MySQL Server リリースのグループメンバー、または異なるデフォルトのリリースのグループメンバーは、前述のデフォルトの動作に従って自身および他のグループメンバーに作用します。 たとえば、<code class="literal">group_replication_member_expel_timeout</code> システム変数をサポートしていないメンバーは、期限切れの疑いが検出されるとすぐに他のメンバーを削除し、システム変数をサポートしており、タイムアウトが長く設定されている場合でも、この削除は他のメンバーによって受け入れられます。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-responses-failure-expel"></a>18.6.6.1 Expel タイムアウト</h4></div></div></div><p>
        MySQL 8.0.13 から使用可能な <code class="literal">group_replication_member_expel_timeout</code> システム変数を使用すると、疑わしいメンバーの作成と削除の間に時間を追加できます。 疑わしいのは、<a class="xref" href="group-replication.html#group-replication-failure-detection" title="18.1.4.2 障害検出">セクション18.1.4.2「障害検出」</a> で説明されているように、あるサーバーが別のサーバーからメッセージを受信しない場合です。 
      </p><p>
        グループレプリケーショングループメンバーが別のメンバー (またはそれ自体) の疑いを作成する前に、最初の 5 秒の検出期間があります。 グループメンバーは、その別のメンバーの疑い (またはそれ自体の疑い) がタイムアウトしたときに削除されます。 それよりも短い時間が経過すると、削除メカニズムが削除を検出して実装する前に経過する可能性があります。<code class="literal">group_replication_member_expel_timeout</code> では、expel timeout と呼ばれる、疑わしいメンバーの作成と疑わしいメンバーの削除の間にグループメンバーが待機する時間を秒単位で指定します。 サスペクトメンバーは、この待機期間中は <code class="literal">UNREACHABLE</code> としてリストされますが、グループメンバーシップリストからは削除されません。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            疑わしいメンバーが待機期間の終了時にタイムアウトする前に再度アクティブになった場合、メンバーは XCom メッセージキャッシュ内の残りのグループメンバーによってバッファされたすべてのメッセージを適用し、オペレータの介入なしで <code class="literal">ONLINE</code> 状態になります。 この状況では、メンバーは同じインカネーションとしてグループによって考慮されます。 
          </p></li><li class="listitem"><p>
            疑わしいメンバーがアクティブになるのは、疑わしいメンバーがタイムアウトして通信を再開できる場合のみで、削除されたビューを受信し、その時点で削除されたことを認識します。 MySQL 8.0.16 から使用可能な <code class="literal">group_replication_autorejoin_tries</code> システム変数を使用して、この時点でメンバーがグループへの再参加を自動的に試行するようにできます。 MySQL 8.0.21 からは、この機能はデフォルトでアクティブ化され、メンバーは 3 回の自動再結合を試行します。 自動再結合プロシージャが成功しなかった場合、または試行されなかった場合、削除されたメンバーは <code class="literal">group_replication_exit_state_action</code> で指定された終了アクションに従います。 
          </p></li></ul></div><p>
        メンバーを削除するまでの待機期間は、以前にグループ内でアクティブになっていたメンバーにのみ適用されます。 グループ内でアクティブになっていなかった非メンバーは、この待機期間を取得せず、最初の検出期間の後に削除されます。これは、参加に時間がかかりすぎるためです。 
      </p><p>
        <code class="literal">group_replication_member_expel_timeout</code> が 0 に設定されている場合、待機期間はなく、疑わしいメンバーは 5 秒間の検出期間が終了した直後に削除する責任があります。 この設定は、MySQL 8.0.20 までのデフォルトです。 これは、<code class="literal">group_replication_member_expel_timeout</code> システム変数をサポートしていない MySQL Server バージョンのグループメンバーの動作でもあります。 MySQL 8.0.21 からは、値はデフォルトで 5 に設定されます。つまり、疑わしいメンバーは、5 秒間の検出期間の 5 秒後に強制的に実行されます。 グループのすべてのメンバーが <code class="literal">group_replication_member_expel_timeout</code> に対して同じ設定を持つことは必須ではありませんが、予期しない実行を回避するためにお薦めします。 すべてのメンバーは、それ自体を含む他のメンバーの疑わしいものを作成できるため、有効な明示タイムアウトは、設定が最も小さいメンバーの疑わしいタイムアウトです。 
      </p><p>
        次のシナリオでは、<code class="literal">group_replication_member_expel_timeout</code> の値をデフォルトから増やすことを検討してください:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ネットワークの速度が遅く、強制終了までのデフォルトの 5 秒または 10 秒の長さが不足しているため、グループメンバーは常に少なくとも 1 つのメッセージを交換できません。
          </p></li><li class="listitem"><p>
            ネットワークに一時的な停止があり、この時点で不要な削除およびプライマリメンバーの変更を回避する必要がある場合があります。
          </p></li><li class="listitem"><p>
            ネットワークは直接制御されておらず、オペレータの介入の必要性を最小限に抑える必要があります。
          </p></li><li class="listitem"><p>
            一時的なネットワーク停止が予想され、このために一部またはすべてのメンバーを削除しない場合。
          </p></li><li class="listitem"><p>
            個々のマシンで速度が低下しており、グループから削除しない場合。
          </p></li></ul></div><p>
        最大 3600 秒 (1 時間) までの指数タイムアウトを指定できます。 XCom メッセージキャッシュが、指定した期間内の予想されるメッセージ量に最初の 5 秒の検出期間を加えて十分に大きいことを確認することが重要です。そうしないと、メンバーは再接続できません。 <code class="literal">group_replication_message_cache_size</code> システム変数を使用して、キャッシュサイズ制限を調整できます。 詳細は、<a class="xref" href="group-replication.html#group-replication-performance-xcom-cache" title="18.6.5 XCom キャッシュ管理">セクション18.6.5「XCom キャッシュ管理」</a>を参照してください。 
      </p><p>
        グループ内のいずれかのメンバーが現在疑わしい場合、グループメンバーシップを再構成することはできません (メンバーを追加または削除するか、新しいリーダーを選択します)。 1 つ以上のメンバーが疑わしいときにグループメンバーシップの変更を実装する必要があり、疑わしいメンバーをグループに残す場合は、可能であれば、メンバーを再度アクティブにするために必要なアクションを実行します。 メンバーを再度アクティブにできず、グループから削除する場合は、疑わしいメンバーをただちに強制的にタイムアウトさせることができます。 これを行うには、アクティブなメンバーの <code class="literal">group_replication_member_expel_timeout</code> の値を、疑いが作成されてからすでに経過した時間より小さい値に変更します。 疑わしいメンバーはすぐに強制の責任を負います。 
      </p><p>
        レプリケーショングループメンバーが予期せず停止し、すぐに再起動された場合 (たとえば、<code class="literal">mysqld_safe</code> で起動されたため)、<code class="literal">group_replication_start_on_boot=on</code> が設定されている場合は、グループへの再参加が自動的に試行されます。 この状況では、メンバーの前のインカネーションがグループから削除される前に、再起動および再結合の試行が行われる可能性があります。その場合、メンバーは再結合できません。 MySQL 8.0.19 からは、グループレプリケーションはグループ通信システム (GCS) 機能を自動的に使用して、再試行ごとに 5 秒間隔でメンバーの再結合試行を 10 回再試行します。 これはほとんどのケースに対応し、前のインカネーションをグループから削除してメンバーを再結合できるようにするのに十分な時間を確保する必要があります。 メンバーが削除される前に、より長い待機期間を指定するように <code class="literal">group_replication_member_expel_timeout</code> システム変数が設定されている場合でも、自動再結合の試行は成功しない可能性があります。 
      </p><p>
        <code class="literal">group_replication_member_expel_timeout</code> システム変数が使用できない場合に不要な削除を回避するための代替軽減戦略については、<a class="xref" href="group-replication.html#group-replication-limitations" title="18.9.2 グループレプリケーションの制限事項">セクション18.9.2「グループレプリケーションの制限事項」</a> を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-responses-failure-partition"></a>18.6.6.2 使用できない大多数のタイムアウト</h4></div></div></div><p>
        デフォルトでは、ネットワークパーティションのために少数民族で自分自身を検索するメンバーは、グループから自動的に退出しません。 システム変数 <code class="literal">group_replication_unreachable_majority_timeout</code> を使用して、大部分のグループメンバーとの接続が失われた後にメンバーが待機する秒数を設定し、グループを終了できます。 タイムアウトを設定すると、ネットワークパーティション後に少数民族グループ内のサーバーをプロアクティブに監視する必要がなくなり、不適切な介入のためにスプリットブレイン状況 (グループメンバーシップの 2 つのバージョン) を作成する可能性を回避できます。 
      </p><p>
        <code class="literal">group_replication_unreachable_majority_timeout</code> で指定されたタイムアウトが経過すると、メンバーおよび少数民族グループ内の他のユーザーによって処理された保留中のすべてのトランザクションがロールバックされ、そのグループ内のサーバーは <code class="literal">ERROR</code> 状態に移行します。 MySQL 8.0.16 から使用可能な <code class="literal">group_replication_autorejoin_tries</code> システム変数を使用して、この時点でメンバーがグループへの再参加を自動的に試行するようにできます。 MySQL 8.0.21 からは、この機能はデフォルトでアクティブ化され、メンバーは 3 回の自動再結合を試行します。 自動再結合プロシージャが成功しなかった場合、または試行されなかった場合、少数民族メンバーは <code class="literal">group_replication_exit_state_action</code> で指定された終了アクションに従います。 
      </p><p>
        到達不能な大多数のタイムアウトを設定するかどうかを決定する場合は、次の点を考慮してください:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            対称グループ (たとえば、2 つまたは 4 つのサーバーを含むグループ) では、両方のパーティションに同数のサーバーが含まれている場合、両方のグループが自分自身を少数民族とみなし、<code class="literal">ERROR</code> 状態になります。 この場合、グループには機能パーティションがありません。 
          </p></li><li class="listitem"><p>
            少数民族グループが存在する間、少数民族グループによって処理されたトランザクションは受け入れられますが、少数民族サーバーがクォーラムに到達できないため、これらのサーバーで <code class="literal">STOP GROUP_REPLICATION</code> が発行されるか、大多数のタイムアウトに達するまでブロックされます。
          </p></li><li class="listitem"><p>
            到達不能な大多数のタイムアウトを設定しない場合、少数民族グループのサーバーは <code class="literal">ERROR</code> 状態に自動的に入らないため、手動で停止する必要があります。
          </p></li><li class="listitem"><p>
            過半数の損失が検出された後に少数民族グループのサーバーに設定されている場合、大多数のタイムアウトを設定しても効果はありません。
          </p></li></ul></div><p>
        <code class="literal">group_replication_unreachable_majority_timeout</code> システム変数を使用しない場合、ネットワークパーティションの発生時にオペレータが発明するプロセスについては、<a class="xref" href="group-replication.html#group-replication-network-partitioning" title="18.4.4 ネットワークパーティション化">セクション18.4.4「ネットワークパーティション化」</a> を参照してください。 このプロセスでは、どのサーバーが機能しているかを確認し、必要に応じて新しいグループメンバーシップを強制します。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-responses-failure-rejoin"></a>18.6.6.3 Auto-Rejoin</h4></div></div></div><p>
        MySQL 8.0.16 から使用可能な <code class="literal">group_replication_autorejoin_tries</code> システム変数を使用すると、大多数のメンバーが削除されるか、アクセスできないタイムアウトに達した場合に、グループへの再参加が自動的に試行されます。 MySQL 8.0.20 までは、システム変数の値はデフォルトで 0 になるため、自動再結合はデフォルトではアクティブ化されません。 MySQL 8.0.21 からは、システム変数の値はデフォルトで 3 に設定されます。これは、メンバーがグループへの再参加を自動的に 3 回試行することを意味し、それぞれの間隔は 5 分です。 
      </p><p>
        自動再結合がアクティブ化されていない場合、メンバーは通信を再開するとすぐに式を受け入れ、<code class="literal">group_replication_exit_state_action</code> システム変数で指定されたアクションに進みます。 この後、メンバーをグループに戻すには手動操作が必要です。 自動再結合機能の使用は、失効した読取りの可能性を許容でき、特に一時的なネットワークの問題によってメンバーが説明されることがかなり多い場合に、手動操作の必要性を最小限に抑える場合に適しています。 
      </p><p>
        自動再結合では、メンバー削除または到達不能な大部分のタイムアウトに達すると、(現在のプラグインオプション値を使用して) 再結合が試行され、指定された試行回数までさらに自動再結合が試行されます。 自動再結合の試行に失敗すると、メンバーは次の試行の 5 分前に待機します。 自動再結合の試行とその間の時間は、自動再結合プロシージャと呼ばれます。 指定された試行回数がメンバーの再参加または停止なしで使い果たされた場合、メンバーは <code class="literal">group_replication_exit_state_action</code> システム変数で指定されたアクションに進みます。 
      </p><p>
        自動再結合の試行の間、メンバーはスーパー読取り専用モードのままで、レプリケーショングループのビューに <code class="literal">ERROR</code> の状態が表示されます。 この間、メンバーは書込みを受け入れません。 ただし、時間の経過とともに失効した読取りの可能性を高くすることで、メンバーに対して読取りを実行できます。 自動再結合プロシージャ中にメンバーをオフラインにするために介入する場合は、<code class="literal">STOP GROUP_REPLICATION</code> ステートメントを使用するか、サーバーを停止することで、いつでも手動でメンバーを停止できます。 一定期間失効した読取りの可能性を許容できない場合は、<code class="literal">group_replication_autorejoin_tries</code> システム変数を 0 に設定します。 
      </p><p>
        パフォーマンススキーマを使用して自動再結合手順をモニターできます。 自動再結合プロシージャが実行されている間、「パフォーマンススキーマ」テーブル <code class="literal">events_stages_current</code> にはイベント<span class="quote">「<span class="quote">「進行中の自動再結合プロシージャ」</span>」</span>が表示され、プロシージャのこのインスタンス (<code class="literal">WORK_COMPLETED</code> フィールド内) でこれまでに試行された再試行回数が示されます。 <code class="literal">events_stages_summary_global_by_event_name</code> テーブルには、(<code class="literal">COUNT_STAR</code> フィールドの) サーバーインスタンスが自動再結合プロシージャを開始した回数が表示されます。 <code class="literal">events_stages_history_long</code> テーブルには、これらの各自動再結合プロシージャが完了した時間 (<code class="literal">TIMER_END</code> フィールド内) が表示されます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-responses-failure-exit"></a>18.6.6.4 終了処理</h4></div></div></div><p>
        MySQL 8.0.12 および MySQL 5.7.24 から使用可能な <code class="literal">group_replication_exit_state_action</code> システム変数は、エラーまたは問題が原因でメンバーが意図せずグループを離れたときに行われるグループレプリケーションを指定し、自動再結合に失敗するか、試行しません。 削除されたメンバーの場合、メンバーはグループに再接続するまで削除されたことを認識しないため、指定されたアクションが実行されるのは、メンバーが再接続を管理している場合、またはメンバー自体で疑わしい場合のみです。 
      </p><p>
        影響を受ける順序で、exit アクションは次のとおりです:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <code class="literal">READ_ONLY</code> が終了アクションの場合、インスタンスはシステム変数 <code class="literal">super_read_only</code> を <code class="literal">ON</code> に設定することで、MySQL をスーパー読取り専用モードに切り替えます。 メンバーがスーパー読取り専用モードの場合、クライアントは <code class="literal">CONNECTION_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) を持っていても更新を実行できません。 ただし、クライアントはデータを読み取ることができ、更新が行われなくなったため、時間の経過とともに増加する失効した読取りの確率があります。 したがって、この設定では、サーバーの障害をプロアクティブに監視する必要があります。 この終了アクションは、MySQL 8.0.15 のデフォルトです。 この exit アクションが実行されると、グループのビューにメンバーステータスが <code class="literal">ERROR</code> として表示されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">OFFLINE_MODE</code> が終了アクションの場合、インスタンスはシステム変数 <code class="literal">offline_mode</code> を <code class="literal">ON</code> に設定することで、MySQL をオフラインモードに切り替えます。 メンバーがオフラインモードの場合、接続されたクライアントユーザーは次のリクエストで切断され、<code class="literal">CONNECTION_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) を持つクライアントユーザーを除き、接続は受け入れられなくなります。 Group Replication は、システム変数 <code class="literal">super_read_only</code> を <code class="literal">ON</code> に設定することもできるため、クライアントが <code class="literal">CONNECTION_ADMIN</code> または <code class="literal">SUPER</code> 権限で接続されていても更新を行うことはできません。 この終了アクションは、更新と失効した読取りの両方を防止し (指定された権限を持つクライアントユーザーによる読取りを除く)、MySQL Router などのプロキシツールがサーバーが使用不可であることを認識し、クライアント接続をリダイレクトできるようにします。 また、管理者が MySQL を停止せずに問題の解決を試みることができるように、インスタンスは実行されたままになります。 この終了アクションは、MySQL 8.0.18 から使用できます。 この終了アクションが実行されると、(<code class="literal">OFFLINE</code> ではなく) グループのビューにメンバーステータスが <code class="literal">ERROR</code> として表示されます。つまり、メンバーはグループレプリケーション機能を使用できますが、現在グループに属していません。 
          </p></li><li class="listitem"><p>
            <code class="literal">ABORT_SERVER</code> が exit アクションの場合、インスタンスは MySQL を停止します。 メンバーに自身を停止するよう指示すると、失効したすべての読取りおよびクライアントの更新が防止されますが、そのステップなしで問題が解決された可能性がある場合でも、MySQL Server インスタンスは使用できないため、再起動する必要があります。 この終了アクションは、システム変数が MySQL 8.0.15 に追加されたときの MySQL 8.0.12 のデフォルトでした。 この exit アクションが実行されると、グループのビュー内のサーバーのリストからメンバーが削除されます。 
          </p></li></ol></div><p>
        自動再結合の試行を使い果たした (または一度も削除されていない)、グループレプリケーションを再起動せずにグループから再度参加することは許可されていないため、設定されている終了アクションにはオペレータの介入が必要であることに注意してください。 exit アクションは、クライアントがグループに再参加できなかったサーバー上のデータを読み取ることができるかどうか、およびサーバーが実行中かどうかにのみ影響します。 
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          メンバーがグループに正常に参加する前に障害が発生した場合は、<code class="literal">group_replication_exit_state_action</code> <span class="emphasis"><em>取得されません</em></span>で指定されている終了アクション。 これは、ローカル構成チェック中に障害が発生した場合、または参加メンバーの構成とグループの構成が一致しない場合です。 このような状況では、<code class="literal">super_read_only</code> システム変数は元の値のままで、サーバーは MySQL を停止しません。 したがって、Group Replication が起動しなかったときにサーバーが更新を受け入れられないようにするには、起動時に <code class="literal">super_read_only=ON</code> をサーバー構成ファイルに設定することをお薦めします。これは、正常に起動された後、プライマリメンバー上の <code class="literal">OFF</code> にグループレプリケーションが変更されます。 この保護策は、サーバーがサーバー起動時に Group Replication (<code class="literal">group_replication_start_on_boot=ON</code>) を起動するように構成されている場合に特に重要ですが、<code class="literal">START GROUP_REPLICATION</code> コマンドを使用して Group Replication を手動で起動する場合にも役立ちます。 
        </p></div><p>
        メンバーがグループに正常に参加した後に障害が発生した場合は、指定された exit アクションが実行されます。 これは、次の状況で発生します: 
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <span class="emphasis"><em>アプライヤエラー</em></span> - レプリケーションアプライアンスにエラーがあります。 この問題はリカバリできません。 
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>分散リカバリはできません</em></span> - Group Replication 分散リカバリプロセス (バイナリログからのリモートクローニング操作と状態転送を使用) を完了できないことを意味する問題があります。 グループレプリケーションは、意味のある場所で分散リカバリを自動的に再試行しますが、プロセスを完了するオプションがなくなると停止します。 詳細は、<a class="xref" href="group-replication.html#group-replication-distributed-recovery-fault" title="18.4.3.4 分散リカバリのフォルトトレランス">セクション18.4.3.4「分散リカバリのフォルトトレランス」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>グループ構成変更エラー</em></span> - <a class="xref" href="group-replication.html#group-replication-configuring-online-group" title="18.4.1 オンライングループの構成">セクション18.4.1「オンライングループの構成」</a> で説明されているように、UDF を使用して実行されたグループ全体の構成変更中にエラーが発生しました。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>プライマリ選択エラー</em></span> - <a class="xref" href="group-replication.html#group-replication-single-primary-mode" title="18.1.3.1 シングルプライマリモード">セクション18.1.3.1「シングルプライマリモード」</a> で説明されているように、シングルプライマリモードでのグループの新規プライマリメンバーの選択中にエラーが発生しました。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>大部分のタイムアウトに到達できません</em></span> - メンバーは大部分のグループメンバーとの連絡を失ったため、少数民族になり、<code class="literal">group_replication_unreachable_majority_timeout</code> システム変数によって設定されたタイムアウトの期限が切れました。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>グループから削除されたメンバー</em></span> - メンバーで疑いが発生し、<code class="literal">group_replication_member_expel_timeout</code> システム変数によって設定されたタイムアウトが期限切れになり、メンバーがグループとの通信を再開し、削除されたことがわかりました。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>自動再結合試行の範囲外</em></span> - <code class="literal">group_replication_autorejoin_tries</code> システム変数は、大部分または明示が失われた後の自動再結合の試行回数を指定するように設定されており、メンバーは成功せずにこの回数の試行を完了しました。
          </p></li></ol></div><p>
        次のテーブルに、失敗のシナリオと各ケースのアクションをまとめます:
      </p><div class="table"><a name="idm45563246451792"></a><p class="title"><b>表 18.4 Group Replication の失敗状況での終了アクション</b></p><div class="table-contents"><table frame="all" summary="Summarizes how the selected exit action does or does not operate depending on the failure situation"><col style="width: 33%" align="left"><col style="width: 33%" align="left"><col style="width: 33%" align="left"><thead><tr>
            <th scope="col"><p>
                失敗状況
              </p></th>
            <th scope="col"><p>
                グループレプリケーションが <code class="literal">START GROUP_REPLICATION</code> で開始されました
              </p></th>
            <th scope="col"><p>
                グループレプリケーションが <code class="literal">group_replication_start_on_boot =ON</code> で開始されました
              </p></th>
          </tr></thead><tbody><tr>
            <th scope="row"><p>
                メンバーがローカル構成チェックに失敗しました
              </p><p>
                参加メンバーとグループ構成が一致しません
              </p></th>
            <td><p>
                <code class="literal">super_read_only</code> および <code class="literal">offline_mode</code> は変更されません
              </p><p>
                MySQL は実行を継続
              </p><p>
                起動時に <code class="literal">super_read_only=ON</code> を設定して更新を防止
              </p></td>
            <td><p>
                <code class="literal">super_read_only</code> および <code class="literal">offline_mode</code> は変更されません
              </p><p>
                MySQL は実行を継続
              </p><p>
                起動時に <code class="literal">super_read_only=ON</code> を設定して更新を防止 (重要)
              </p></td>
          </tr><tr>
            <th scope="row"><p>
                メンバーの適用者エラー
              </p><p>
                分散リカバリはできません
              </p><p>
                グループ構成変更エラー
              </p><p>
                プライマリ選択エラー
              </p><p>
                大部分のタイムアウトに到達できません
              </p><p>
                グループから削除されたメンバー
              </p><p>
                自動再結合試行の範囲外
              </p></th>
            <td><p>
                <code class="literal">super_read_only</code> を <code class="literal">ON</code> に設定
              </p><p>
                OR
              </p><p>
                <code class="literal">offline_mode</code> および <code class="literal">super_read_only</code> が <code class="literal">ON</code> に設定されている
              </p><p>
                OR
              </p><p>
                MySQL が停止
              </p></td>
            <td><p>
                <code class="literal">super_read_only</code> を <code class="literal">ON</code> に設定
              </p><p>
                OR
              </p><p>
                <code class="literal">offline_mode</code> および <code class="literal">super_read_only</code> が <code class="literal">ON</code> に設定されている
              </p><p>
                OR
              </p><p>
                MySQL が停止
              </p></td>
          </tr></tbody></table></div></div><br class="table-break"></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="group-replication-upgrade"></a>18.7 グループレプリケーションのアップグレード</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-online-upgrade-combining-versions">18.7.1 グループ内の異なるメンバーバージョンの組合せ</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-offline-upgrade">18.7.2 グループレプリケーションのオフラインアップグレード</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-online-upgrade">18.7.3 グループレプリケーションのオンラインアップグレード</a></span></dt></dl></div><a class="indexterm" name="idm45563246412448"></a><p>
    このセクションでは、グループレプリケーション設定をアップグレードする方法について説明します。 グループのメンバーをアップグレードする基本プロセスは、スタンドアロンインスタンスのアップグレードと同じです。使用可能なアップグレードおよびタイプを実行する実際のプロセスは、<a class="xref" href="installing.html#upgrading" title="2.11 MySQL のアップグレード">セクション2.11「MySQL のアップグレード」</a> を参照してください。 インプレースアップグレードと論理アップグレードのどちらを選択するかは、グループに格納されているデータの量によって異なります。 通常、インプレースアップグレードは高速であるため、お薦めします。 <a class="xref" href="replication.html#replication-upgrade" title="17.5.3 レプリケーションセットアップをアップグレードする">セクション17.5.3「レプリケーションセットアップをアップグレードする」</a> も参照してください。 
  </p><p>
    オンライングループのアップグレード中に、可用性を最大化するには、異なる MySQL Server バージョンのメンバーを同時に実行する必要がある場合があります。 グループレプリケーションには、アップグレード手順中に同じグループ内で異なるバージョンの MySQL を実行しているメンバーを安全に結合できる互換性ポリシーが含まれています。 グループによっては、これらのポリシーの影響がグループメンバーのアップグレード順序に影響する場合があります。 詳細は、<a class="xref" href="group-replication.html#group-replication-online-upgrade-combining-versions" title="18.7.1 グループ内の異なるメンバーバージョンの組合せ">セクション18.7.1「グループ内の異なるメンバーバージョンの組合せ」</a>を参照してください。 
  </p><p>
    グループを完全にオフラインにできる場合は、<a class="xref" href="group-replication.html#group-replication-offline-upgrade" title="18.7.2 グループレプリケーションのオフラインアップグレード">セクション18.7.2「グループレプリケーションのオフラインアップグレード」</a> を参照してください。 本番デプロイメントと同様に、グループをオンラインのままにする必要がある場合は、停止時間を最小限に抑えてグループをアップグレードするために使用できる様々なアプローチについて <a class="xref" href="group-replication.html#group-replication-online-upgrade" title="18.7.3 グループレプリケーションのオンラインアップグレード">セクション18.7.3「グループレプリケーションのオンラインアップグレード」</a> を参照してください。 
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-online-upgrade-combining-versions"></a>18.7.1 グループ内の異なるメンバーバージョンの組合せ</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-compatibility-upgrade">18.7.1.1 アップグレード中のメンバーバージョン</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-compatibility-communication">18.7.1.2 グループレプリケーション通信プロトコルのバージョン</a></span></dt></dl></div><a class="indexterm" name="idm45563246401024"></a><p>
      Group Replication は、Group Replication プラグインがバンドルされている MySQL Server のバージョンに従ってバージョン管理されます。 たとえば、メンバーが MySQL 5.7.26 を実行している場合、これは Group Replication プラグインのバージョンです。 グループメンバーの MySQL Server のバージョンを確認するには、次のコマンドを発行します: 
    </p><pre class="programlisting"><strong class="userinput"><code>SELECT MEMBER_HOST,MEMBER_PORT,MEMBER_VERSION FROM performance_schema.replication_group_members;</code></strong>
+-------------+-------------+----------------+
| member_host | member_port | member_version |
+-------------+-------------+----------------+
| example.com |	   3306     |   8.0.13	     |
+-------------+-------------+----------------+
      </pre><p>
      MySQL Server のバージョンの理解およびバージョンの選択に関するガイダンスは、<a class="xref" href="installing.html#which-version" title="2.1.2 インストールする MySQL のバージョンと配布の選択">セクション2.1.2「インストールする MySQL のバージョンと配布の選択」</a> を参照してください。
    </p><p>
      最適な互換性とパフォーマンスを得るには、グループのすべてのメンバーが同じバージョンの MySQL Server を実行する必要があるため、グループレプリケーションを実行する必要があります。 ただし、オンライングループのアップグレード中は、可用性を最大化するために、異なる MySQL Server バージョンのメンバーを同時に実行する必要がある場合があります。 MySQL のバージョン間で行われた変更によっては、この状況で非互換性が発生する可能性があります。 たとえば、メジャーバージョン間で機能が非推奨になっている場合、グループ内のバージョンを組み合せると、非推奨機能に依存するメンバーで障害が発生する可能性があります。 逆に、古い MySQL バージョンを実行しているグループに読取り/書込みメンバーが存在する間に、新しい MySQL バージョンを実行しているメンバーに書き込むと、新しいリリースで導入された関数がないメンバーで問題が発生する可能性があります。 
    </p><p>
      これらの問題を回避するために、グループレプリケーションには、同じグループ内で異なるバージョンの MySQL を実行しているメンバーを安全に結合できる互換性ポリシーが含まれています。 メンバーはこれらのポリシーを適用して、グループに通常参加するか、読取り専用モードで参加するか、またはグループに参加しないかを決定します。どちらを選択すると、参加メンバーおよびグループの既存のメンバーの安全な操作が行われます。 アップグレードシナリオでは、各サーバーはグループを離れてアップグレードし、新しいサーバーバージョンでグループに再度参加する必要があります。 この時点で、メンバーは新しいサーバーバージョンにポリシーを適用します。これは、最初にグループに参加したときに適用したポリシーから変更された可能性があります。 
    </p><p>
      管理者は、サーバーを適切に構成して <code class="literal">START GROUP_REPLICATION</code> ステートメントを発行することで、任意のグループへの参加を試行するようにサーバーに指示できます。 グループに参加するかどうか、または読取り専用モードでグループに参加するかどうかは、グループにメンバーを追加しようとした後に結合メンバー自体によって決定および実装されます。 参加メンバーは、現在のグループメンバーの MySQL Server バージョンに関する情報を受け取り、それらのメンバーとの独自の互換性を評価して、互換性があるかどうかを判断するために (既存のメンバーで使用されるポリシーではなく) 独自の MySQL Server バージョンで使用されるポリシーを適用します。 
    </p><p>
      グループに参加しようとしたときに参加メンバーが適用される互換性ポリシーは次のとおりです:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          既存のグループメンバーが実行されている最下位バージョンより下位の MySQL Server バージョンを実行している場合、メンバーはグループに参加しません。
        </p></li><li class="listitem"><p>
          メンバーは、既存のグループメンバーが実行されている最下位バージョンと同じ MySQL Server バージョンを実行している場合、通常、グループに参加します。
        </p></li><li class="listitem"><p>
          メンバーはグループに参加しますが、既存のグループメンバーが実行されている最下位バージョンより上位の MySQL Server バージョンを実行している場合、読取り専用モードのままです。 この動作は、グループがマルチプライマリモードで実行されている場合にのみ異なります。これは、シングルプライマリモードで実行されているグループでは、新しく追加されたメンバーはデフォルトで読取り専用になるためです。 
        </p></li></ul></div><p>
      MySQL 8.0.17 以上を実行しているメンバーは、互換性をチェックするときにリリースのパッチバージョンを考慮します。 MySQL 8.0.16 以下または MySQL 5.7 を実行しているメンバーには、メジャーバージョンのみが考慮されます。 たとえば、すべてのメンバーが MySQL バージョン 8.0.13 を実行しているグループがある場合は、次のようにします: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          MySQL バージョン 5.7 を実行しているメンバーは結合されません。
        </p></li><li class="listitem"><p>
          MySQL 8.0.16 を実行しているメンバーは正常に結合されます (メジャーバージョンを考慮しているため)。
        </p></li><li class="listitem"><p>
          MySQL 8.0.17 を実行しているメンバーは結合されますが、読取り専用モードのままです (パッチバージョンが考慮されるため)。
        </p></li></ul></div><p>
      MySQL 5.7.27 より前のリリースを実行しているメンバーを結合すると、すべてのグループメンバーがチェックされ、独自の MySQL Server メジャーバージョンが低いかどうかが確認されます。 したがって、いずれかのメンバーが MySQL 8.0 リリースを実行しているグループに対してこのチェックが失敗し、MySQL 5.7 を実行している他のメンバーがすでに存在する場合でもグループに参加できません。 MySQL 5.7.27 から、メンバーを結合すると、最下位メジャーバージョンを実行しているグループメンバーのみがチェックされるため、他の MySQL 5.7 サーバーが存在する混合バージョングループに参加できます。 
    </p><p>
      異なる MySQL Server バージョンを使用するメンバーを持つマルチプライマリモードグループでは、グループレプリケーションは、MySQL 8.0.17 以上を実行しているメンバーの読取り/書込みおよび読取り専用ステータスを自動的に管理します。 メンバーがグループから離れると、現在最も低いバージョンを実行しているメンバーは自動的に読取り/書込みモードに設定されます。 シングルプライマリモードで実行されていたグループをマルチプライマリモードで実行するように変更すると、<code class="literal">group_replication_switch_to_multi_primary_mode()</code> UDF を使用して、グループレプリケーションによって自動的にメンバーが正しいモードに設定されます。 メンバーは、グループに存在する最低バージョンより上位の MySQL サーバーバージョンを実行しており、最低バージョンを実行しているメンバーが読取り/書込みモードになっている場合、自動的に読取り専用モードになります。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-compatibility-upgrade"></a>18.7.1.1 アップグレード中のメンバーバージョン</h4></div></div></div><p>
        オンラインアップグレード手順中に、グループがシングルプライマリモードの場合、アップグレード用に現在オフラインになっていないすべてのサーバーは、以前と同様に機能します。 グループは、<a class="xref" href="group-replication.html#group-replication-single-primary-mode" title="18.1.3.1 シングルプライマリモード">セクション18.1.3.1「シングルプライマリモード」</a> で説明されている選択ポリシーに従って、必要に応じて新しいプライマリを選択します。 プライマリを全体で同じに保つ必要がある場合 (アップグレード時を除く)、最初にすべてのセカンダリをターゲットプライマリメンバーバージョン以上のバージョンにアップグレードしてから、プライマリを最後にアップグレードする必要があります。 プライマリは、グループ内で最も低い MySQL Server バージョンを実行していないかぎり、プライマリとして残すことはできません。 プライマリがアップグレードされた後、<code class="literal">group_replication_set_as_primary()</code> UDF を使用してプライマリとして再サポートできます。 
      </p><p>
        グループがマルチプライマリモードの場合、アップグレードされたメンバーはアップグレード後に読取り専用モードで結合されるため、アップグレード手順中に書込みを実行できるオンラインメンバーは少なくなります。 MySQL 8.0.17 から、これはパッチバージョン間のアップグレードに適用され、以前のリリースではメジャーバージョン間のアップグレードにのみ適用されます。 すべてのメンバーが MySQL 8.0.17 から同じリリースにアップグレードされると、読取り/書込みモードに自動的に戻ります。 以前のリリースでは、アップグレード後にプライマリとして機能する各メンバーで、<code class="literal">super_read_only</code> を <code class="literal">OFF</code> に手動で設定する必要があります。 
      </p><p>
        アップグレードをロールバックする必要がある場合や緊急時にグループに容量を追加する必要がある場合など、問題の状況に対処するために、他のグループメンバーが使用している最低バージョンより低い MySQL Server バージョンを実行していても、メンバーがオンライングループに参加できるようにすることができます。 Group Replication システム変数 <code class="literal">group_replication_allow_local_lower_version_join</code> は、このような状況で通常の互換性ポリシーをオーバーライドするために使用できます。 オプションを <code class="literal">ON</code> に設定しても、新しいメンバーはグループと互換性がなく、既存のメンバーによる互換性のない動作から保護せずにグループに参加できることに注意してください。 したがって、このオプションは特定の状況でのみ慎重に使用する必要があり、通常のグループアクティビティが原因で新しいメンバーが失敗しないように、追加の注意事項を講じる必要があります。 これらの注意事項の詳細は、<code class="literal">group_replication_allow_local_lower_version_join</code> の説明を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-compatibility-communication"></a>18.7.1.2 グループレプリケーション通信プロトコルのバージョン</h4></div></div></div><p>
        レプリケーショングループは、MySQL Server バージョンのメンバーとは異なるグループレプリケーション通信プロトコルバージョンを使用します。 グループ通信プロトコルのバージョンを確認するには、任意のメンバーに対して次のステートメントを発行します: 
      </p><pre class="programlisting"><strong class="userinput"><code>SELECT group_replication_get_communication_protocol();</code></strong>
</pre><p>
        戻り値は、このグループに参加してグループ通信プロトコルを使用できる最も古い MySQL Server バージョンを示します。 MySQL 5.7.14 のバージョンではメッセージを圧縮でき、MySQL 8.0.16 のバージョンではメッセージを断片化することもできます。 <code class="literal">group_replication_get_communication_protocol()</code> UDF は、グループがサポートする MySQL の最小バージョンを返します。これは、<code class="literal">group_replication_set_communication_protocol()</code> UDF に渡されたバージョン番号、および UDF を使用するメンバーにインストールされている MySQL Server バージョンとは異なる場合があります。 
      </p><p>
        レプリケーショングループのすべてのメンバーを新しい MySQL Server リリースにアップグレードしても、以前のリリースのメンバーが参加できるようにする必要がある場合に備えて、グループレプリケーション通信プロトコルのバージョンは自動的にはアップグレードされません。 古いメンバーをサポートする必要がなく、アップグレードされたメンバーが追加された通信機能を使用できるようにする場合は、アップグレード後に <code class="literal">group_replication_set_communication_protocol()</code> UDF を使用して通信プロトコルをアップグレードし、メンバーのアップグレード先の新しい MySQL Server バージョンを指定します。 詳細は、<a class="xref" href="group-replication.html#group-replication-communication-protocol" title="18.4.1.4 グループ通信プロトコルバージョンの設定">セクション18.4.1.4「グループ通信プロトコルバージョンの設定」</a>を参照してください。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-offline-upgrade"></a>18.7.2 グループレプリケーションのオフラインアップグレード</h3></div></div></div><a class="indexterm" name="idm45563246346352"></a><p>
      グループレプリケーショングループのオフラインアップグレードを実行するには、グループから各メンバーを削除し、メンバーのアップグレードを実行してから、通常どおりにグループを再起動します。 マルチプライマリグループでは、任意の順序でメンバーを停止できます。 単一プライマリグループでは、最初に各セカンダリを停止してから、最後にプライマリを停止します。 グループからメンバーを削除して MySQL を停止する方法は、<a class="xref" href="group-replication.html#group-replication-upgrading-member" title="18.7.3.2 グループレプリケーションメンバーのアップグレード">セクション18.7.3.2「グループレプリケーションメンバーのアップグレード」</a> を参照してください。 
    </p><p>
      グループがオフラインになったら、すべてのメンバーをアップグレードします。 アップグレードの実行方法は、<a class="xref" href="installing.html#upgrading" title="2.11 MySQL のアップグレード">セクション2.11「MySQL のアップグレード」</a> を参照してください。 すべてのメンバーがアップグレードされたら、メンバーを再起動します。 
    </p><p>
      レプリケーショングループがオフラインのときにすべてのメンバーをアップグレードしてからグループを再起動すると、メンバーは新しいリリースのグループレプリケーション通信プロトコルバージョンを使用して参加し、グループ通信プロトコルバージョンになります。 以前のリリースのメンバーの参加を許可する要件がある場合は、<code class="literal">group_replication_set_communication_protocol()</code> UDF を使用して通信プロトコルバージョンをダウングレードし、最も古いサーバーバージョンがインストールされている見込みグループメンバーの MySQL Server バージョンを指定できます。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-online-upgrade"></a>18.7.3 グループレプリケーションのオンラインアップグレード</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-online-upgrade-considerations">18.7.3.1 オンラインアップグレードに関する考慮事項</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-upgrading-member">18.7.3.2 グループレプリケーションメンバーのアップグレード</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-online-upgrade-methods">18.7.3.3 グループレプリケーションのオンラインアップグレード方法</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-upgrade-with-mysqlbackup">18.7.3.4 <span class="command"><strong>mysqlbackup</strong></span> を使用したグループレプリケーションアップグレード</a></span></dt></dl></div><a class="indexterm" name="idm45563246337040"></a><p>
      アップグレードするグループを実行しているが、アプリケーションを提供するためにグループをオンラインのままにする必要がある場合は、アップグレードのアプローチを検討する必要があります。 このセクションでは、オンラインアップグレードに関連する様々な要素と、グループのアップグレード方法について説明します。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-online-upgrade-considerations"></a>18.7.3.1 オンラインアップグレードに関する考慮事項</h4></div></div></div><a class="indexterm" name="idm45563246332896"></a><p>
        オンライングループをアップグレードする場合は、次の点を考慮する必要があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            グループのアップグレード方法に関係なく、グループメンバーへの書込みは、グループに再度参加する準備ができるまで無効にすることが重要です。
          </p></li><li class="listitem"><p>
            メンバーが停止すると、<code class="literal">super_read_only</code> 変数は自動的にオンに設定されますが、この変更は永続化されません。
          </p></li><li class="listitem"><p>
            MySQL 5.7.22 または MySQL 8.0.11 が MySQL 5.7.21 以下を実行しているグループに参加しようとすると、MySQL 5.7.21 は <code class="literal">lower_case_table_names</code> の値を送信しないため、グループへの参加に失敗します。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-upgrading-member"></a>18.7.3.2 グループレプリケーションメンバーのアップグレード</h4></div></div></div><a class="indexterm" name="idm45563246323072"></a><p>
        このセクションでは、グループのメンバーをアップグレードするために必要なステップについて説明します。 このプロシージャは、<a class="xref" href="group-replication.html#group-replication-online-upgrade-methods" title="18.7.3.3 グループレプリケーションのオンラインアップグレード方法">セクション18.7.3.3「グループレプリケーションのオンラインアップグレード方法」</a> で説明されているメソッドの一部です。 グループのメンバーをアップグレードするプロセスは、すべての方法に共通であり、最初に説明します。 アップグレードしたメンバーを結合する方法は、フォローしている方法、およびグループがシングルプライマリモードで動作しているかマルチプライマリモードで動作しているかなどのその他の要因によって異なります。 インプレースまたはプロビジョニングのいずれかのアプローチを使用してサーバーインスタンスをアップグレードする方法は、ここで説明する方法には影響しません。 
      </p><p>
        メンバーをアップグレードするプロセスは、メンバーをアップグレードしてからアップグレードしたメンバーをグループに再度参加させる選択した方法に従って、メンバーをグループから削除することです。 単一プライマリグループのメンバーのアップグレードの推奨順序は、すべてのセカンダリをアップグレードしてから、プライマリを最後にアップグレードすることです。 プライマリがセカンダリの前にアップグレードされた場合、古い MySQL バージョンを使用する新しいプライマリが選択されますが、このステップは必要ありません。 
      </p><p>
        グループのメンバーをアップグレードするには:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            クライアントをグループメンバーに接続し、<code class="literal">STOP GROUP_REPLICATION</code> を発行します。 続行する前に、<code class="literal">replication_group_members</code> テーブルを監視して、メンバーステータスが <code class="literal">OFFLINE</code> であることを確認します。 
          </p></li><li class="listitem"><p>
            グループレプリケーションが自動的に起動しないようにして、アップグレード後に安全にメンバーに接続し、<code class="literal"> group_replication_start_on_boot=0</code> を設定してグループに再参加せずにメンバーを構成できるようにします。
          </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
              アップグレードされたメンバーに<code class="literal"> group_replication_start_on_boot=1</code> がある場合、MySQL のアップグレード手順を実行する前にグループに再度参加すると、問題が発生する可能性があります。 たとえば、アップグレードが失敗し、サーバーが再起動した場合、破損している可能性のあるサーバーがグループに参加しようとする可能性があります。 
            </p></div></li><li class="listitem"><p>
            たとえば、<span class="command"><strong>mysqladmin shutdown</strong></span> または <code class="literal">SHUTDOWN</code> ステートメントを使用してメンバーを停止します。 グループ内の他のメンバーは引き続き実行されます。 
          </p></li><li class="listitem"><p>
            インプレースまたはプロビジョニングのアプローチを使用して、メンバーをアップグレードします。 詳細は、<a class="xref" href="installing.html#upgrading" title="2.11 MySQL のアップグレード">セクション2.11「MySQL のアップグレード」</a> を参照してください。 アップグレードしたメンバーを再起動する場合、<code class="literal"> group_replication_start_on_boot</code> が 0 に設定されているため、グループレプリケーションはインスタンスで開始されないため、グループに再参加しません。 
          </p></li><li class="listitem"><p>
            メンバーで MySQL のアップグレード手順が実行されたら、<code class="literal">group_replication_start_on_boot</code> を 1 に設定して、再起動後にグループレプリケーションが正しく開始されるようにする必要があります。 メンバーを再起動します。 
          </p></li><li class="listitem"><p>
            アップグレードしたメンバーに接続し、<code class="literal">START GROUP_REPLICATION</code> を発行します。 これにより、メンバーがグループに再結合されます。 グループレプリケーションメタデータはアップグレードされたサーバーに配置されているため、通常はグループレプリケーションを再構成する必要はありません。 サーバーは、サーバーがオフラインのときにグループによって処理されたトランザクションをキャッチアップする必要があります。 グループで捕捉されると、グループのオンラインメンバーになります。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              サーバーのアップグレードにかかる時間が長くなるほど、メンバーがオフラインになる時間が長くなるため、サーバーがグループに追加して戻されるまでにかかる時間が長くなります。
            </p></div></li></ul></div><p>
        アップグレードされたメンバーが、以前の MySQL Server バージョンを実行しているメンバーを持つグループに参加すると、アップグレードされたメンバーは <code class="literal">super_read_only=on</code> と結合されます。 これにより、すべてのメンバーが新しいバージョンを実行するまで、アップグレードされたメンバーへの書込みが行われなくなります。 マルチプライマリモードグループでは、アップグレードが正常に完了し、グループがトランザクションを処理する準備ができたら、書込み可能なプライマリとして意図されているメンバーを読取り/書込みモードに設定する必要があります。 MySQL 8.0.17 からは、グループのすべてのメンバーが同じリリースにアップグレードされると、読取り/書込みモードに自動的に戻ります。 以前のリリースでは、各メンバーを手動で読取り/書込みモードに設定する必要があります。 各メンバーに接続し、次を発行します: 
      </p><pre class="programlisting"><strong class="userinput"><code>SET GLOBAL super_read_only=OFF;</code></strong></pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-online-upgrade-methods"></a>18.7.3.3 グループレプリケーションのオンラインアップグレード方法</h4></div></div></div><a class="indexterm" name="idm45563246287856"></a><p>
        グループレプリケーショングループをアップグレードするには、次のいずれかの方法を選択します:
      </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-upgrading-rolling-in-group"></a>ローリングアップグレード</h5></div></div></div><p>
          この方法は、新しいバージョンを実行しているサーバーがグループにワークロードを生成せず、古いバージョンのサーバーが存在する場合にサポートされます。 つまり、新しいバージョンのサーバーは、セカンダリとしてのみグループに参加できます。 この方法では、1 つのグループのみが存在し、各サーバーインスタンスがグループから削除され、アップグレードされてグループに再度参加します。 
        </p><p>
          この方法は、単一プライマリグループに適しています。 グループがシングルプライマリモードで動作しているときに、プライマリを全体で同じにしておく必要がある場合 (アップグレードされる場合を除く)、アップグレードされる最後のメンバーである必要があります。 プライマリは、グループ内で最も低い MySQL Server バージョンを実行していないかぎり、プライマリとして残すことはできません。 プライマリがアップグレードされた後、<code class="literal">group_replication_set_as_primary()</code> UDF を使用してプライマリとして再サポートできます。 どのメンバーがプライマリであるかわからない場合は、任意の順序でメンバーをアップグレードできます。 グループは、<a class="xref" href="group-replication.html#group-replication-single-primary-mode" title="18.1.3.1 シングルプライマリモード">セクション18.1.3.1「シングルプライマリモード」</a> で説明されている選択ポリシーに従って、MySQL Server の最低バージョンを実行しているメンバーの中から必要に応じて新しいプライマリを選択します。 
        </p><p>
          マルチプライマリモードで動作するグループの場合、ローリングアップグレード中にプライマリの数が減り、書込み可用性が低下します。 これは、既存のグループメンバーが実行されている最下位バージョンより上位の MySQL Server バージョンを実行している場合、メンバーがグループに参加すると、自動的に読取り専用モード (<code class="literal">super_read_only=ON</code>) のままになるためです。 MySQL 8.0.17 以上を実行しているメンバーは、これをチェックするときにリリースのパッチバージョンを考慮しますが、MySQL 8.0.16 以下または MySQL 5.7 を実行しているメンバーはメジャーバージョンのみを考慮します。 すべてのメンバーが MySQL 8.0.17 から同じリリースにアップグレードされると、読取り/書込みモードに自動的に戻ります。 以前のリリースでは、アップグレード後にプライマリとして機能する必要がある各メンバーで <code class="literal">super_read_only=OFF</code> を手動で設定する必要があります。 
        </p><p>
          グループ内のバージョンの互換性、およびこれがアップグレードプロセス中にグループの動作に与える影響の詳細は、<a class="xref" href="group-replication.html#group-replication-online-upgrade-combining-versions" title="18.7.1 グループ内の異なるメンバーバージョンの組合せ">セクション18.7.1「グループ内の異なるメンバーバージョンの組合せ」</a> を参照してください。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-upgrading-rolling-migration"></a>ローリング移行のアップグレード</h5></div></div></div><p>
          この方法では、グループからメンバーを削除し、アップグレードしたメンバーを使用して別のグループを作成します。 マルチプライマリモードで動作するグループの場合、このプロセス中にプライマリの数が減り、書込み可用性が低下します。 これは、シングルプライマリモードで動作するグループには影響しません。 
        </p><p>
          古いバージョンを実行しているグループは、メンバーのアップグレード中にオンラインであるため、メンバーのアップグレード中に実行されたトランザクションを捕捉するには、新しいバージョンを実行しているグループが必要です。 したがって、新しいグループ内のいずれかのサーバーは、古いグループのプライマリのレプリカとして構成されます。 これにより、新しいグループが古いグループに追いつくようになります。 この方法は、あるグループから別のグループへのデータのレプリケートに使用される非同期レプリケーションチャネルに依存するため、非同期ソースレプリケーションレプリケーションと同じ前提および要件でサポートされます。<a class="xref" href="replication.html" title="第 17 章 レプリケーション">第17章「<i>レプリケーション</i>」</a> を参照してください。 シングルプライマリモードで動作するグループの場合、古いグループへの非同期レプリケーション接続では、新しいグループのプライマリにデータを送信する必要があります。マルチプライマリグループの場合、非同期レプリケーションチャネルは任意のプライマリに接続できます。 
        </p><p>
          プロセスは次のとおりです:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              古いサーバーバージョンを実行している元のグループからメンバーを削除します。<a class="xref" href="group-replication.html#group-replication-upgrading-member" title="18.7.3.2 グループレプリケーションメンバーのアップグレード">セクション18.7.3.2「グループレプリケーションメンバーのアップグレード」</a> を参照してください
            </p></li><li class="listitem"><p>
              メンバーで実行されているサーバーバージョンをアップグレードします。<a class="xref" href="installing.html#upgrading" title="2.11 MySQL のアップグレード">セクション2.11「MySQL のアップグレード」</a> を参照してください。 インプレースまたはプロビジョニングのアプローチに従ってアップグレードできます。 
            </p></li><li class="listitem"><p>
              アップグレードしたメンバーで新しいグループを作成します。<a class="xref" href="group-replication.html" title="第 18 章 グループレプリケーション">第18章「<i>グループレプリケーション</i>」</a> を参照してください。 この場合、(古いグループがまだ実行中で古い名前を使用しているため) 各メンバーに新しいグループ名を構成し、最初にアップグレードしたメンバーをブートストラップしてから、残りのアップグレード済メンバーを追加する必要があります。 
            </p></li><li class="listitem"><p>
              古いグループと新しいグループの間に非同期レプリケーションチャネルを設定します。<a class="xref" href="replication.html#replication-gtids-howto" title="17.1.3.4 GTID を使用したレプリケーションのセットアップ">セクション17.1.3.4「GTID を使用したレプリケーションのセットアップ」</a> を参照してください。 古いプライマリが非同期レプリケーションソースサーバーとして機能し、新しいグループメンバーが GTID ベースのレプリカとして機能するように構成します。 
            </p></li></ul></div><p>
          アプリケーションを新しいグループにリダイレクトする前に、グループがメンバーの障害を処理できるように、新しいグループに適切な数のメンバーがあることを確認する必要があります。 <code class="literal">SELECT * FROM performance_schema.replication_group_members</code> を発行し、初期グループサイズと新しいグループサイズを比較します。 古いグループのすべてのデータが新しいグループに伝播されるまで待機してから、非同期レプリケーション接続を削除し、欠落しているメンバーをアップグレードします。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="group-replication-upgrading-rolling-duplication"></a>ローリングアップグレード</h5></div></div></div><p>
          この方法では、新しいバージョンを実行しているメンバーで構成される別のグループを作成し、古いグループから欠落しているデータは新しいグループにレプリケートされます。 これは、両方のグループを同時に実行するのに十分なサーバーがあることを前提としています。 このプロセス中にプライマリの数が減少しないため、マルチプライマリモードで動作するグループの場合、書込み可用性は低下しません。 これにより、ローリングアップグレードはマルチプライマリモードで動作するグループに適しています。 これは、シングルプライマリモードで動作するグループには影響しません。 
        </p><p>
          新しいグループのメンバーをプロビジョニングしている間、古いバージョンを実行しているグループはオンラインであるため、メンバーのプロビジョニング中に実行されたトランザクションを捕捉するには、新しいバージョンを実行しているグループが必要です。 したがって、新しいグループ内のいずれかのサーバーは、古いグループのプライマリのレプリカとして構成されます。 これにより、新しいグループが古いグループに追いつくようになります。 この方法は、あるグループから別のグループへのデータのレプリケートに使用される非同期レプリケーションチャネルに依存するため、非同期ソースレプリケーションレプリケーションと同じ前提および要件でサポートされます。<a class="xref" href="replication.html" title="第 17 章 レプリケーション">第17章「<i>レプリケーション</i>」</a> を参照してください。 シングルプライマリモードで動作するグループの場合、古いグループへの非同期レプリケーション接続では、新しいグループのプライマリにデータを送信する必要があります。マルチプライマリグループの場合、非同期レプリケーションチャネルは任意のプライマリに接続できます。 
        </p><p>
          プロセスは次のとおりです:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              新しいバージョンを実行しているグループがメンバーの障害を処理できるように、適切な数のメンバーをデプロイ
            </p></li><li class="listitem"><p>
              グループのメンバーから既存のデータのバックアップを取得
            </p></li><li class="listitem"><p>
              古いメンバーのバックアップを使用して、新しいグループのメンバーをプロビジョニングします。方法については、<a class="xref" href="group-replication.html#group-replication-upgrade-with-mysqlbackup" title="18.7.3.4 mysqlbackup を使用したグループレプリケーションアップグレード">セクション18.7.3.4「<span class="command"><strong>mysqlbackup</strong></span> を使用したグループレプリケーションアップグレード」</a> を参照してください。
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                バックアップは、バックアップ元と同じバージョンの MySQL にリストアしてから、インプレースアップグレードを実行する必要があります。 その手順は、<a class="xref" href="installing.html#upgrading" title="2.11 MySQL のアップグレード">セクション2.11「MySQL のアップグレード」</a>を参照してください。 
              </p></div></li><li class="listitem"><p>
              アップグレードしたメンバーで新しいグループを作成します。<a class="xref" href="group-replication.html" title="第 18 章 グループレプリケーション">第18章「<i>グループレプリケーション</i>」</a> を参照してください。 この場合、(古いグループがまだ実行中で古い名前を使用しているため) 各メンバーに新しいグループ名を構成し、最初にアップグレードしたメンバーをブートストラップしてから、残りのアップグレード済メンバーを追加する必要があります。 
            </p></li><li class="listitem"><p>
              古いグループと新しいグループの間に非同期レプリケーションチャネルを設定します。<a class="xref" href="replication.html#replication-gtids-howto" title="17.1.3.4 GTID を使用したレプリケーションのセットアップ">セクション17.1.3.4「GTID を使用したレプリケーションのセットアップ」</a> を参照してください。 古いプライマリが非同期レプリケーションソースサーバーとして機能し、新しいグループメンバーが GTID ベースのレプリカとして機能するように構成します。 
            </p></li></ul></div><p>
          新しいグループから欠落している進行中のデータが、迅速に転送できるほど小さい場合は、書込み操作を新しいグループにリダイレクトする必要があります。 古いグループのすべてのデータが新しいグループに伝播されるまで待機してから、非同期レプリケーション接続を削除します。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-upgrade-with-mysqlbackup"></a>18.7.3.4 <span class="command"><strong>mysqlbackup</strong></span> を使用したグループレプリケーションアップグレード</h4></div></div></div><p>
        プロビジョニング方法の一環として、MySQL Enterprise Backup を使用して、グループメンバーから新しいメンバーにデータをコピーおよびリストアできます。 ただし、この方法を使用して、古いバージョンの MySQL を実行しているメンバーから、新しいバージョンの MySQL を実行しているメンバーにバックアップを直接リストアすることはできません。 解決策は、バックアップ元のメンバーと同じバージョンの MySQL を実行している新しいサーバーインスタンスにバックアップをリストアしてから、インスタンスをアップグレードすることです。 このプロセスの内容は次のとおりです: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="command"><strong>mysqlbackup</strong></span> を使用して、古いグループのメンバーからバックアップを取得します。 <a class="xref" href="group-replication.html#group-replication-enterprise-backup" title="18.4.6 グループレプリケーションでの MySQL Enterprise Backup の使用">セクション18.4.6「グループレプリケーションでの MySQL Enterprise Backup の使用」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            新しいサーバーインスタンスをデプロイします。これは、バックアップが作成された古いメンバーと同じバージョンの MySQL を実行している必要があります。
          </p></li><li class="listitem"><p>
            <span class="command"><strong>mysqlbackup</strong></span> を使用して、古いメンバーから新しいインスタンスにバックアップをリストアします。
          </p></li><li class="listitem"><p>
            新しいインスタンスで MySQL をアップグレードします。<a class="xref" href="installing.html#upgrading" title="2.11 MySQL のアップグレード">セクション2.11「MySQL のアップグレード」</a> を参照してください。
          </p></li></ul></div><p>
        フェイルオーバーを処理できるように、このプロセスを繰り返して適切な数の新規インスタンスを作成します。 次に、<a class="xref" href="group-replication.html#group-replication-online-upgrade-methods" title="18.7.3.3 グループレプリケーションのオンラインアップグレード方法">セクション18.7.3.3「グループレプリケーションのオンラインアップグレード方法」</a> に基づいてインスタンスをグループに結合します。` 
      </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="group-replication-options"></a>18.8 グループレプリケーションシステム変数</h2></div></div></div><a class="indexterm" name="idm45563246219632"></a><p>
    このセクションでは、Group Replication プラグインに固有のシステム変数を一覧表示します。 すべての構成オプションには、接頭辞として "<code class="literal">group_replication</code> " が付きます。 
  </p><p>
    Group Replication のほとんどのシステム変数は動的と記述され、その値はサーバーの実行中に変更できます。 ただし、ほとんどの場合、変更が有効になるのは、<code class="literal">STOP GROUP_REPLICATION</code> ステートメントの後に <code class="literal">START GROUP_REPLICATION</code> ステートメントを使用してグループメンバーでグループレプリケーションを停止して再起動した後のみです。 Group Replication を停止および再起動せずに、次のシステム変数への変更が有効になります: 
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">group_replication_advertise_recovery_endpoints</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_autorejoin_tries</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_consistency</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_exit_state_action</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_flow_control_applier_threshold</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_flow_control_certifier_threshold</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_flow_control_hold_percent</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_flow_control_max_commit_quota</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_flow_control_member_quota_percent</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_flow_control_min_quota</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_flow_control_min_recovery_quota</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_flow_control_mode</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_flow_control_period</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_flow_control_release_percent</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_force_members</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_member_expel_timeout</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_member_weight</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_transaction_size_limit</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_unreachable_majority_timeout</code>
      </p></li></ul></div><p>
    グループレプリケーションのほとんどのシステム変数は、グループメンバーごとに異なる値を持つことができます。 次のシステム変数では、トランザクションの不要なロールバック、メッセージ配信の失敗またはメッセージリカバリの失敗を回避するために、グループのすべてのメンバーに同じ値を設定することをお薦めします: 
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">group_replication_auto_increment_increment</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_communication_max_message_size</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_compression_threshold</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_message_cache_size</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_transaction_size_limit</code>
      </p></li></ul></div><p>
    グループレプリケーション固有のシステム変数や一般的なシステム変数など、グループレプリケーショングループメンバーの一部のシステム変数は、グループ全体の構成設定です。 これらのシステム変数は、すべてのグループメンバーで同じ値を持つ必要があり、グループレプリケーションの実行中は変更できません。また、値の変更を有効にするには、グループの完全な再起動 (<code class="literal">group_replication_bootstrap_group=ON</code> を使用したサーバーによるブートストラップ) が必要です。 これらの条件は、次のシステム変数に適用されます: 
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">group_replication_single_primary_mode</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_enforce_update_everywhere_checks</code>
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_gtid_assignment_block_size</code>
      </p></li><li class="listitem"><p>
        <code class="literal">default_table_encryption</code>
      </p></li><li class="listitem"><p>
        <code class="literal">lower_case_table_names</code>
      </p></li><li class="listitem"><p>
        <code class="literal">transaction_write_set_extraction</code>
      </p></li></ul></div><p>
    MySQL 8.0.16 から、<code class="literal">group_replication_switch_to_single_primary_mode()</code> および <code class="literal">group_replication_switch_to_multi_primary_mode()</code> UDF を使用して、グループの実行中に <code class="literal">group_replication_single_primary_mode</code> および <code class="literal">group_replication_enforce_update_everywhere_checks</code> の値を変更できます。 詳細は、<a class="xref" href="group-replication.html#group-replication-changing-group-mode" title="18.4.1.2 グループモードの変更">セクション18.4.1.2「グループモードの変更」</a>を参照してください。 
  </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          グループレプリケーションの多くのシステム変数は、コマンドライン引数としてサーバーに渡された場合、サーバーの起動時に完全には検証されません。 これらのシステム変数には、<code class="literal">group_replication_group_name</code>, <code class="literal">group_replication_single_primary_mode</code>, <code class="literal">group_replication_force_members</code>、SSL 変数およびフロー制御システム変数が含まれます。 これらは、サーバーの起動後にのみ完全に検証されます。 
        </p></li><li class="listitem"><p>
          グループメンバーの IP アドレスまたはホスト名を指定するグループレプリケーションのシステム変数は、<code class="literal">START GROUP_REPLICATION</code> ステートメントが発行されるまで検証されません。 グループレプリケーショングループ通信システム (GCS) は、その時点まで値を検証できません。 
        </p></li></ul></div></div><p>
    Group Replication プラグインに固有のシステム変数は次のとおりです:
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="sysvar_group_replication_advertise_recovery_endpoints"></a>
        <code class="literal">group_replication_advertise_recovery_endpoints</code>
      </p><a class="indexterm" name="idm45563246139856"></a><a class="indexterm" name="idm45563246138704"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_advertise_recovery_endpoints"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-advertise-recovery-endpoints=value</code></td>
</tr><tr><th>導入</th>
<td>8.0.21</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_advertise_recovery_endpoints">group_replication_advertise_recovery_endpoints</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">DEFAULT</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できます。 変更はすぐにメンバーに反映されます。 ただし、システム変数の以前の値をすでに受け取っている結合メンバーは、その値を引き続き使用します。 値の変更後に結合されたメンバーのみが新しい値を受け取ります。 
      </p><p>
        <code class="literal">group_replication_advertise_recovery_endpoints</code> は、結合メンバーが分散リカバリのために状態転送のために既存のメンバーへの接続を確立する方法を指定します。 この接続は、リモートクローニング操作とドナーのバイナリログからの状態転送の両方に使用されます。 
      </p><p>
        デフォルト設定の <code class="literal">DEFAULT</code> の値は、参加メンバーが MySQL Server <code class="literal">hostname</code> および <code class="literal">port</code> システム変数で指定されている既存のメンバー標準 SQL クライアント接続を使用することを意味します。 <code class="literal">report_port</code> システム変数で代替ポート番号が指定されている場合は、かわりにそのポート番号が使用されます。 「パフォーマンススキーマ」テーブル <code class="literal">replication_group_members</code> では、この接続アドレスとポート番号が <code class="literal">MEMBER_HOST</code> および <code class="literal">MEMBER_PORT</code> フィールドに表示されます。 これは、MySQL 8.0.20 までのリリースでのグループメンバーの動作です。 
      </p><p>
        <code class="literal">DEFAULT</code> のかわりに、既存のメンバーが使用する参加メンバーに通知する分散リカバリエンドポイントを指定できます。 分散リカバリエンドポイントを提供することで、管理者は、グループメンバーへの通常の MySQL クライアント接続とは別に分散リカバリトラフィックを制御できます。 メンバーの結合では、リストで指定された順序で各エンドポイントが順に試行されます。 
      </p><p>
        分散リカバリエンドポイントを IP アドレスとポート番号のカンマ区切りリストとして指定します。次に例を示します:
      </p><pre class="programlisting">group_replication_advertise_recovery_endpoints= "127.0.0.1:3306,127.0.0.1:4567,[::1]:3306,localhost:3306"
</pre><p>
        IPv4 アドレスと IPv6 アドレスおよびホスト名は、任意の組合せで使用できます。 IPv6 アドレスは大カッコで囲んで指定する必要があります。 ホスト名はローカル IP アドレスに解決される必要があります。 ワイルドカードアドレス書式は使用できず、空のリストは指定できません。 標準 SQL クライアント接続は、分散リカバリエンドポイントのリストに自動的には含まれないことに注意してください。 エンドポイントとして使用する場合は、リストに明示的に含める必要があります。 
      </p><p>
        分散リカバリエンドポイントとして IP アドレスとポートを選択する方法、およびメンバーを結合する方法の詳細は、<a class="xref" href="group-replication.html#group-replication-distributed-recovery-connections-endpoints" title="18.4.3.1.1 分散リカバリエンドポイントのアドレスの選択">セクション18.4.3.1.1「分散リカバリエンドポイントのアドレスの選択」</a> を参照してください。 要件のサマリーは次のとおりです: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
            IP アドレスは MySQL Server 用に構成する必要はありませんが、サーバーに割り当てる必要があります。
          </p></li><li class="listitem"><p>
            ポートは、<code class="literal">port</code>、<code class="literal">report_port</code> または <code class="literal">admin_port</code> システム変数を使用して MySQL Server 用に構成する必要があります。
          </p></li><li class="listitem"><p>
            <code class="literal">admin_port</code> を使用する場合は、分散リカバリのレプリケーションユーザーに適切な権限が必要です。
          </p></li><li class="listitem"><p>
            <code class="literal">group_replication_ip_allowlist</code> または <code class="literal">group_replication_ip_whitelist</code> システム変数で指定された Group Replication 許可リストに IP アドレスを追加する必要はありません。
          </p></li><li class="listitem"><p>
            接続の SSL 要件は、<code class="literal">group_replication_recovery_ssl_*</code> オプションで指定されたとおりです。
          </p></li></ul></div></li><li class="listitem"><p><a name="sysvar_group_replication_allow_local_lower_version_join"></a>
        <code class="literal">group_replication_allow_local_lower_version_join</code>
      </p><a class="indexterm" name="idm45563246082048"></a><a class="indexterm" name="idm45563246080416"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_allow_local_lower_version_join"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-allow-local-lower-version-join[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_allow_local_lower_version_join">group_replication_allow_local_lower_version_join</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_allow_local_lower_version_join</code> では、現在のサーバーがグループより低いバージョンの MySQL Server を実行している場合でも、グループに参加できます。 デフォルト設定の <code class="literal">OFF</code> では、既存のグループメンバーより低いバージョンを実行しているサーバーはレプリケーショングループに参加できません。 この標準ポリシーは、グループのすべてのメンバーがメッセージを交換し、トランザクションを適用できることを確認します。 MySQL 8.0.17 以上を実行しているメンバーは、互換性をチェックするときにリリースのパッチバージョンを考慮することに注意してください。 MySQL 8.0.16 以下または MySQL 5.7 を実行しているメンバーには、メジャーバージョンのみが考慮されます。 
      </p><p>
        次のシナリオでのみ、<code class="literal">group_replication_allow_local_lower_version_join</code> を <code class="literal">ON</code> に設定します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
            グループのフォルトトレランスを改善するには、緊急時にサーバーをグループに追加する必要があり、古いバージョンのみを使用できます。
          </p></li><li class="listitem"><p>
            グループ全体を停止して再度ブートストラップせずに、1 つ以上のレプリケーショングループメンバーのアップグレードをロールバックする場合。
          </p></li></ul></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          このオプションを <code class="literal">ON</code> に設定しても、新しいメンバーはグループと互換性がなく、既存のメンバーによる互換性のない動作から保護されずにグループに参加できます。 新しいメンバーが正しく動作するようにするには、次の予防措置の <span class="emphasis"><em>both</em></span> を使用します: 
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              下位バージョンを実行しているサーバーがグループに参加する前に、そのサーバーでのすべての書込みを停止します。
            </p></li><li class="listitem"><p>
              下位バージョンを実行しているサーバーがグループに参加した時点から、グループ内の他のサーバーに対するすべての書込みを停止します。
            </p></li></ol></div><p>
          これらの予防措置がないと、低いバージョンを実行しているサーバーで問題が発生し、エラーで終了する可能性があります。
        </p></div></li><li class="listitem"><p><a name="sysvar_group_replication_auto_increment_increment"></a>
        <code class="literal">group_replication_auto_increment_increment</code>
      </p><a class="indexterm" name="idm45563246039712"></a><a class="indexterm" name="idm45563246038096"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_auto_increment_increment"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-auto-increment-increment=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_auto_increment_increment">group_replication_auto_increment_increment</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">7</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">65535</code></td>
</tr></tbody></table></div><p>
        このシステム変数は、すべてのグループメンバーで同じ値を持つ必要があります。 グループレプリケーションの実行中は、このシステム変数の値を変更できません。 各グループメンバーでグループレプリケーションを停止し、システム変数の値を変更してから、グループレプリケーションを再起動する必要があります。 このプロセス中、システム変数の値はグループメンバー間で異なってもかまいませんが、グループメンバーの一部のトランザクションはロールバックされる可能性があります。 
      </p><p>
        <code class="literal">group_replication_auto_increment_increment</code> は、このサーバーインスタンスで実行されるトランザクションの自動増分カラムの連続する値の間隔を決定します。 間隔を追加すると、グループメンバーに対する書込みに対して重複する自動増分値が選択されないため、トランザクションがロールバックされます。 デフォルト値の 7 は、使用可能な値の数とレプリケーショングループの最大許容サイズ (9 メンバー) のバランスを表します。 グループのメンバー数が多いか少ない場合は、グループレプリケーションが開始される前に、グループメンバーの予想数と一致するようにこのシステム変数を設定できます。 
      </p><p>
        グループレプリケーションがサーバーインスタンスで開始されると、サーバーシステム変数 <code class="literal">auto_increment_increment</code> の値がこの値に変更され、サーバーシステム変数 <code class="literal">auto_increment_offset</code> の値がサーバー ID に変更されます。 グループレプリケーションが停止すると、変更は元に戻されます。 これらの変更は、<code class="literal">auto_increment_increment</code> および <code class="literal">auto_increment_offset</code> のそれぞれのデフォルト値が 1 の場合にのみ行われ、元に戻されます。 これらの値がすでにデフォルトから変更されている場合、Group Replication はそれらを変更しません。 MySQL 8.0 からは、グループレプリケーションが単一プライマリモードで、サーバー書込みが 1 つのみの場合も、システム変数は変更されません。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_autorejoin_tries"></a>
        <code class="literal">group_replication_autorejoin_tries</code>
      </p><a class="indexterm" name="idm45563245998384"></a><a class="indexterm" name="idm45563245996784"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_autorejoin_tries"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-autorejoin-tries=#</code></td>
</tr><tr><th>導入</th>
<td>8.0.16</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_autorejoin_tries">group_replication_autorejoin_tries</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値 (≥ 8.0.21)</th>
<td><code class="literal">3</code></td>
</tr><tr><th>デフォルト値 (≤ 8.0.20)</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">2016</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更でき、変更はただちに有効になります。 動作が必要であることを意味する問題が発生すると、システム変数 current 値が読み取られます。 
      </p><p>
        <code class="literal">group_replication_autorejoin_tries</code> では、メンバーが明示された場合、または <code class="literal">group_replication_unreachable_majority_timeout</code> 設定に到達する前にグループの大部分にアクセスできない場合に、メンバーが自動的にグループに再参加しようとする試行回数を指定します。 メンバー削除または到達不能な大部分のタイムアウトに達すると、(現在のプラグインオプション値を使用して) 再結合を試みてから、指定された試行回数までさらに自動再結合を試みます。 自動再結合の試行に失敗すると、メンバーは次の試行の 5 分前に待機します。 指定された試行回数がメンバーの再参加または停止なしで使い果たされた場合、メンバーは <code class="literal">group_replication_exit_state_action</code> システム変数で指定されたアクションに進みます。 
      </p><p>
        MySQL 8.0.20 までは、デフォルト設定は 0 です。つまり、メンバーは自動的に再結合を試みません。 MySQL 8.0.21 からは、デフォルト設定は 3 です。これは、メンバーがグループへの再参加を自動的に 3 回試行し、それぞれの間に 5 分間試行することを意味します。 最大 2016 回の試行を指定できます。 
      </p><p>
        自動再結合の試行中および試行の間、メンバーはスーパー読取り専用モードのままで書込みを受け入れませんが、時間の経過とともに失効した読取りの可能性を高くして、メンバーに対して読取りを実行できます。 一定期間失効した読取りの可能性を許容できない場合は、<code class="literal">group_replication_autorejoin_tries</code> を 0 に設定します。 自動再結合機能、およびこのオプションの値を選択する際の考慮事項の詳細は、<a class="xref" href="group-replication.html#group-replication-responses-failure-rejoin" title="18.6.6.3 Auto-Rejoin">セクション18.6.6.3「Auto-Rejoin」</a> を参照してください。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_bootstrap_group"></a>
        <code class="literal">group_replication_bootstrap_group</code>
      </p><a class="indexterm" name="idm45563245952928"></a><a class="indexterm" name="idm45563245951328"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_bootstrap_group"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-bootstrap-group[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group">group_replication_bootstrap_group</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
        <code class="literal">group_replication_bootstrap_group</code> は、グループをブートストラップするようにこのサーバーを構成します。 このシステム変数は、グループを初めて起動するとき、またはグループ全体を再起動するときに、あるサーバーおよび<span class="emphasis"><em>のみ</em></span>で設定する必要があります。 グループがブートストラップされたら、このオプションを <code class="literal">OFF</code> に設定します。 動的にも構成ファイルでも、<code class="literal">OFF</code> に設定する必要があります。 グループの実行中に 2 つのサーバーを起動するか、このオプションを設定して 1 つのサーバーを再起動すると、人工的なスプリットブレーン状況が発生し、同じ名前の独立した 2 つのグループがブートストラップされる場合があります。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_clone_threshold"></a>
        <code class="literal">group_replication_clone_threshold</code>
      </p><a class="indexterm" name="idm45563245922528"></a><a class="indexterm" name="idm45563245920928"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_clone_threshold"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-clone-threshold=#</code></td>
</tr><tr><th>導入</th>
<td>8.0.17</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_clone_threshold">group_replication_clone_threshold</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">9223372036854775807</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">9223372036854775807</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_clone_threshold</code> では、分散リカバリプロセス中に参加メンバーへの状態転送のためにリモートクローニング操作の使用をトリガーする既存のメンバー (ドナー) と参加メンバー (受信者) の間のトランザクションギャップを多数のトランザクションとして指定します。 参加メンバーと適切なドナーの間のトランザクションギャップがしきい値を超えると、グループレプリケーションはリモートクローニング操作で分散リカバリを開始します。 トランザクションギャップがしきい値を下回る場合、またはリモートクローニング操作が技術的に可能でない場合、Group Replication はドナーのバイナリログからの状態転送に直接進みます。 
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          アクティブグループの <code class="literal">group_replication_clone_threshold</code> には低い設定を使用しないでください。 リモートクローニング操作の進行中にしきい値を超える数のトランザクションがグループで発生した場合、参加メンバーは再起動後にリモートクローニング操作を再度トリガーし、これを無期限に続行できます。 この状況を回避するには、リモートクローニング操作にかかる時間内にグループ内で発生すると予想されるトランザクション数よりも大きい数をしきい値に設定してください。 
        </p></div><p>
        この関数を使用するには、クローニングをサポートするようにドナーと参加メンバーの両方を事前に設定する必要があります。 その手順は、<a class="xref" href="group-replication.html#group-replication-cloning" title="18.4.3.2 分散リカバリのためのクローニング">セクション18.4.3.2「分散リカバリのためのクローニング」</a>を参照してください。 リモートクローニング操作が実行されると、<code class="literal">group_replication_start_on_boot=ON</code> が設定されている場合は、グループレプリケーションによって管理され、必要なサーバーの再起動も含まれます。 そうでない場合は、サーバーを手動で再起動する必要があります。 リモートクローニング操作では、結合メンバーの既存のデータディクショナリが置換されますが、結合メンバーに他のグループメンバーに存在しない追加のトランザクションがある場合、これらのトランザクションはクローニング操作によって消去されるため、グループレプリケーションによってチェックされ、続行されません。 
      </p><p>
        デフォルト設定 (GTID 内のトランザクションに許可される最大シーケンス番号) は、ドナーのバイナリログからの状態転送が、クローニングではなく実質的に常に試行されることを意味します。 ただし、結合メンバーに必要なトランザクションが既存のグループメンバーのバイナリログで使用できないためなど、ドナーバイナリログからの状態転送が不可能な場合、グループレプリケーションはしきい値に関係なく常にクローニング操作を実行しようとします。 レプリケーショングループでクローニングをまったく使用しない場合は、クローンプラグインをメンバーにインストールしないでください。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_communication_debug_options"></a>
        <code class="literal">group_replication_communication_debug_options</code>
      </p><a class="indexterm" name="idm45563245877344"></a><a class="indexterm" name="idm45563245875728"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_communication_debug_options"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-communication-debug-options=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_communication_debug_options">group_replication_communication_debug_options</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">GCS_DEBUG_NONE</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">GCS_DEBUG_NONE</code></p><p class="valid-value"><code class="literal">GCS_DEBUG_BASIC</code></p><p class="valid-value"><code class="literal">GCS_DEBUG_TRACE</code></p><p class="valid-value"><code class="literal">XCOM_DEBUG_BASIC</code></p><p class="valid-value"><code class="literal">XCOM_DEBUG_TRACE</code></p><p class="valid-value"><code class="literal">GCS_DEBUG_ALL</code></p></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_communication_debug_options</code> は、グループ通信システム (GCS) やグループ通信エンジン (XCom、Paxos バリアント) などの様々なグループレプリケーションコンポーネントに提供するデバッグメッセージのレベルを構成します。 デバッグ情報は、データディレクトリの <code class="filename">GCS_DEBUG_TRACE</code> ファイルに格納されます。 
      </p><p>
        文字列として指定された使用可能なオプションのセットを組み合せることができます。 次のオプションを使用できます。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
            <code class="literal">GCS_DEBUG_NONE</code> では、GCS と XCom の両方のデバッグレベルがすべて無効になります。
          </p></li><li class="listitem"><p>
            <code class="literal">GCS_DEBUG_BASIC</code> を使用すると、GCS で基本的なデバッグ情報を使用できます。
          </p></li><li class="listitem"><p>
            <code class="literal">GCS_DEBUG_TRACE</code> は GCS でトレース情報を有効にします。
          </p></li><li class="listitem"><p>
            <code class="literal">XCOM_DEBUG_BASIC</code> を使用すると、XCom の基本的なデバッグ情報を使用できます。
          </p></li><li class="listitem"><p>
            <code class="literal">XCOM_DEBUG_TRACE</code> を使用すると、XCom でトレース情報を使用できます。
          </p></li><li class="listitem"><p>
            <code class="literal">GCS_DEBUG_ALL</code> では、GCS と XCom の両方ですべてのデバッグレベルが有効になります。
          </p></li></ul></div><p>
        デバッグレベルを <code class="literal">GCS_DEBUG_NONE</code> に設定すると、他のオプションを指定せずに指定した場合にのみ有効になります。 デバッグレベルを <code class="literal">GCS_DEBUG_ALL</code> に設定すると、他のすべてのオプションがオーバーライドされます。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_communication_max_message_size"></a>
        <code class="literal">group_replication_communication_max_message_size</code>
      </p><a class="indexterm" name="idm45563245826608"></a><a class="indexterm" name="idm45563245824976"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_communication_max_message_size"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-communication-max-message-size=#</code></td>
</tr><tr><th>導入</th>
<td>8.0.16</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_communication_max_message_size">group_replication_communication_max_message_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">10485760</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">1073741824</code></td>
</tr></tbody></table></div><p>
        このシステム変数は、すべてのグループメンバーで同じ値を持つ必要があります。 グループレプリケーションの実行中は、このシステム変数の値を変更できません。 各グループメンバーでグループレプリケーションを停止し、システム変数の値を変更してから、グループレプリケーションを再起動する必要があります。 このプロセス中、システム変数の値はグループメンバー間で異なってもかまいませんが、グループメンバーの一部のトランザクションはロールバックされる可能性があります。 
      </p><p>
        <code class="literal">group_replication_communication_max_message_size</code> では、グループレプリケーション通信の最大メッセージサイズを指定します。 このサイズより大きいメッセージは、個別に送信され、受信者によって再アセンブルされるフラグメントに自動的に分割されます。 詳細は、<a class="xref" href="group-replication.html#group-replication-performance-message-fragmentation" title="18.6.4 メッセージの断片化">セクション18.6.4「メッセージの断片化」</a>を参照してください。 
      </p><p>
        10485760 バイト (10 MiB) の最大メッセージサイズがデフォルトで設定されています。つまり、MySQL 8.0.16 からのリリースでは、断片化がデフォルトで使用されます。 最大許容値は、<code class="literal">slave_max_allowed_packet</code> システム変数の最大値 1073741824 バイト (1 GB) と同じです。 アプライヤスレッドは <code class="literal">slave_max_allowed_packet</code> より大きいメッセージフラグメントを処理できないため、<code class="literal">group_replication_communication_max_message_size</code> の設定は <code class="literal">slave_max_allowed_packet</code> の設定より小さくする必要があります。 断片化をオフにするには、<code class="literal">group_replication_communication_max_message_size</code> にゼロ値を指定します。 
      </p><p>
        レプリケーショングループのメンバーが断片化を使用するには、グループ通信プロトコルのバージョンが MySQL 8.0.16 以上である必要があります。 <code class="literal">group_replication_get_communication_protocol()</code> UDF を使用して、グループ通信プロトコルのバージョンを表示します。 下位バージョンが使用されている場合、グループメンバーはメッセージを断片化しません。 すべてのグループメンバーがサポートしている場合は、<code class="literal">group_replication_set_communication_protocol()</code> UDF を使用して、グループ通信プロトコルを上位バージョンに設定できます。 詳細は、<a class="xref" href="group-replication.html#group-replication-communication-protocol" title="18.4.1.4 グループ通信プロトコルバージョンの設定">セクション18.4.1.4「グループ通信プロトコルバージョンの設定」</a>を参照してください。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_components_stop_timeout"></a>
        <code class="literal">group_replication_components_stop_timeout</code>
      </p><a class="indexterm" name="idm45563245778096"></a><a class="indexterm" name="idm45563245776480"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_components_stop_timeout"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-components-stop-timeout=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_components_stop_timeout">group_replication_components_stop_timeout</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">31536000</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">2</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">31536000</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_components_stop_timeout</code> では、グループレプリケーションが停止時に各コンポーネントを待機するタイムアウトを秒単位で指定します。
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_compression_threshold"></a>
        <code class="literal">group_replication_compression_threshold</code>
      </p><a class="indexterm" name="idm45563245744608"></a><a class="indexterm" name="idm45563245743008"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_compression_threshold"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-compression-threshold=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_compression_threshold">group_replication_compression_threshold</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">1000000</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
        このシステム変数は、すべてのグループメンバーで同じ値を持つ必要があります。 このシステム変数の値は、Group Replication の実行中に変更できます。 変更は、メンバーでグループレプリケーションを停止して再起動した後、各グループメンバーで有効になります。 このプロセス中、システム変数の値はグループメンバー間で異なってもかまいませんが、メッセージ配信の効率はすべてのメンバーで同じではありません。 
      </p><p>
        <code class="literal">group_replication_compression_threshold</code> では、グループメンバー間で送信されるメッセージに圧縮が適用されるしきい値をバイト単位で指定します。 このシステム変数をゼロに設定すると、圧縮は無効になります。 
      </p><p>
        グループレプリケーションでは、LZ4 圧縮アルゴリズムを使用して、グループで送信されるメッセージを圧縮します。 LZ4 圧縮アルゴリズムでサポートされる最大入力サイズは 2113929216 バイトです。 この制限は、XCom で受け入れられる最大メッセージサイズと一致する、<code class="literal">group_replication_compression_threshold</code> システム変数の最大可能値を下回っています。 LZ4 圧縮アルゴリズムでは、メッセージ圧縮が有効な場合、このサイズを超えるトランザクションはコミットできないため、<code class="literal">group_replication_compression_threshold</code> に 2113929216 バイトを超える値を設定しないでください。 
      </p><p>
        詳細は、<a class="xref" href="group-replication.html#group-replication-message-compression" title="18.6.3 メッセージ圧縮">セクション18.6.3「メッセージ圧縮」</a>を参照してください。
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_consistency"></a>
        <code class="literal">group_replication_consistency</code>
      </p><a class="indexterm" name="idm45563245706288"></a><a class="indexterm" name="idm45563245704720"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_consistency"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-consistency=value</code></td>
</tr><tr><th>導入</th>
<td>8.0.14</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_consistency">group_replication_consistency</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル、セッション</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">EVENTUAL</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">EVENTUAL</code></p><p class="valid-value"><code class="literal">BEFORE_ON_PRIMARY_FAILOVER</code></p><p class="valid-value"><code class="literal">BEFORE</code></p><p class="valid-value"><code class="literal">AFTER</code></p><p class="valid-value"><code class="literal">BEFORE_AND_AFTER</code></p></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できます。<code class="literal">group_replication_consistency</code> は Group Replication プラグイン固有の変数ではなくサーバーシステム変数であるため、変更を有効にするために Group Replication を再起動する必要はありません。 システム変数のセッション値の変更はただちに有効になり、グローバル値の変更は変更後に開始される新しいセッションに対して有効になります。 このシステム変数のグローバル設定を変更するには、<code class="literal">GROUP_REPLICATION_ADMIN</code> 権限が必要です。 
      </p><p>
        <code class="literal">group_replication_consistency</code> は、グループが提供するトランザクションの一貫性保証を制御します。 一貫性はグローバルに構成することも、トランザクションごとに構成することもできます。<code class="literal">group_replication_consistency</code> は、単一のプライマリグループで新しく選択されたプライマリによって使用されるフェンシングメカニズムも構成します。 変数の効果は、読取り専用 (RO) トランザクションと読取り/書込み (RW) トランザクションの両方で考慮する必要があります。 次のリストは、トランザクションの一貫性保証を高めるために、この変数に指定できる値を示しています: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
            <code class="literal">EVENTUAL</code>
          </p><p>
            RO トランザクションと RW トランザクションはどちらも、実行前に先行するトランザクションが適用されるのを待機しません。 これは、この変数が追加される前の Group Replication の動作です。 RW トランザクションは、他のメンバーがトランザクションを適用するのを待機しません。 つまり、あるメンバーでトランザクションを外部化してから別のメンバーに外部化できます。 つまり、プライマリフェイルオーバーが発生した場合、新しいプライマリは、前のプライマリトランザクションがすべて適用される前に新しい RO および RW トランザクションを受け入れることができます。 RO トランザクションは古い値になる可能性があり、RW トランザクションは競合のためロールバックする可能性があります。 
          </p></li><li class="listitem"><p>
            <code class="literal">BEFORE_ON_PRIMARY_FAILOVER</code>
          </p><p>
            古いプライマリからバックログを適用している、新しく選択されたプライマリを持つ新しい RO または RW トランザクションは、バックログが適用されるまで保持されます (適用されません)。 これにより、プライマリフェイルオーバーが意図的に発生したかどうかにかかわらず、クライアントには常にプライマリの最新の値が表示されます。 これにより一貫性が保証されますが、バックログが適用されている場合、クライアントは遅延を処理できる必要があります。 通常、この遅延は最小限に抑える必要がありますが、バックログのサイズによって異なります。 
          </p></li><li class="listitem"><p>
            <code class="literal">BEFORE</code>
          </p><p>
            RW トランザクションは、先行するすべてのトランザクションが完了するまで待機してから適用されます。 RO トランザクションは、先行するすべてのトランザクションが完了するまで待機してから実行されます。 これにより、トランザクションのレイテンシにのみ影響を与えることで、このトランザクションが最新の値を読み取るようになります。 これにより、RO トランザクションでのみ同期が使用されるようになるため、すべての RW トランザクションでの同期のオーバーヘッドが削減されます。 この一貫性レベルには、<code class="literal">BEFORE_ON_PRIMARY_FAILOVER</code> によって提供される一貫性保証も含まれます。 
          </p></li><li class="listitem"><p>
            <code class="literal">AFTER</code>
          </p><p>
            RW トランザクションは、その変更が他のすべてのメンバーに適用されるまで待機します。 この値は RO トランザクションには影響しません。 このモードでは、トランザクションがローカルメンバーでコミットされたときに、後続のトランザクションが書込み値またはグループメンバーのより新しい値を読み取ることが保証されます。 このモードは、主に RO 操作に使用されるグループとともに使用して、適用された RW トランザクションがコミット後のすべての場所に確実に適用されるようにします。 これは、後続の読取りで最新の書込みを含む最新のデータがフェッチされるようにするために、アプリケーションで使用できます。 これにより、RW トランザクションでのみ同期が使用されるようになるため、RO トランザクションごとの同期のオーバーヘッドが削減されます。 この一貫性レベルには、<code class="literal">BEFORE_ON_PRIMARY_FAILOVER</code> によって提供される一貫性保証も含まれます。 
          </p></li><li class="listitem"><p>
            <code class="literal">BEFORE_AND_AFTER</code>
          </p><p>
            RW トランザクションは、1) 前のすべてのトランザクションが適用されるまで待機し、2) 変更が他のメンバーに適用されるまで待機します。 RO トランザクションは、先行するすべてのトランザクションが完了するまで待機してから実行されます。 この一貫性レベルには、<code class="literal">BEFORE_ON_PRIMARY_FAILOVER</code> によって提供される一貫性保証も含まれます。 
          </p></li></ul></div><p>
        詳細は、<a class="xref" href="group-replication.html#group-replication-consistency-guarantees" title="18.4.2 トランザクション一貫性保証">セクション18.4.2「トランザクション一貫性保証」</a>を参照してください。
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_enforce_update_everywhere_checks"></a>
        <code class="literal">group_replication_enforce_update_everywhere_checks</code>
      </p><a class="indexterm" name="idm45563245643952"></a><a class="indexterm" name="idm45563245642304"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_enforce_update_everywhere_checks"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-enforce-update-everywhere-checks[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_enforce_update_everywhere_checks">group_replication_enforce_update_everywhere_checks</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
        このシステム変数は、グループ全体の構成設定です。 値の変更を有効にするには、すべてのグループメンバーで同じ値を持つ必要があり、グループレプリケーションの実行中は変更できず、グループ (<code class="literal">group_replication_bootstrap_group=ON</code> を使用したサーバーによるブートストラップ) を完全に再起動する必要があります。 MySQL 8.0.16 から、<code class="literal">group_replication_switch_to_single_primary_mode()</code> および <code class="literal">group_replication_switch_to_multi_primary_mode()</code> UDF を使用して、グループの実行中にこのシステム変数の値を変更できます。 詳細は、<a class="xref" href="group-replication.html#group-replication-changing-group-mode" title="18.4.1.2 グループモードの変更">セクション18.4.1.2「グループモードの変更」</a>を参照してください。 
      </p><p>
        <code class="literal">group_replication_enforce_update_everywhere_checks</code> は、マルチプライマリ更新の厳密な整合性チェックをどこでも有効または無効にします。 デフォルトでは、チェックは無効になっています。 シングルプライマリモードでは、すべてのグループメンバーでこのオプションを無効にする必要があります。 マルチプライマリモードでは、このオプションを有効にすると、ステートメントは次のようにチェックされ、マルチプライマリモードと互換性があることが確認されます: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
            トランザクションが <code class="literal">SERIALIZABLE</code> 分離レベルで実行される場合、トランザクション自体をグループと同期するとコミットは失敗します。
          </p></li><li class="listitem"><p>
            カスケード制約を持つ外部キーを持つテーブルに対してトランザクションが実行される場合、トランザクションはグループとの同期時にコミットに失敗します。
          </p></li></ul></div></li><li class="listitem"><p><a name="sysvar_group_replication_exit_state_action"></a>
        <code class="literal">group_replication_exit_state_action</code>
      </p><a class="indexterm" name="idm45563245607120"></a><a class="indexterm" name="idm45563245605600"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_exit_state_action"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-exit-state-action=value</code></td>
</tr><tr><th>導入</th>
<td>8.0.12</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_exit_state_action">group_replication_exit_state_action</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値 (≥ 8.0.16)</th>
<td><code class="literal">READ_ONLY</code></td>
</tr><tr><th>デフォルト値 (≥ 8.0.12, ≤ 8.0.15)</th>
<td><code class="literal">ABORT_SERVER</code></td>
</tr><tr><th>有効な値 (≥ 8.0.18)</th>
<td><p class="valid-value"><code class="literal">ABORT_SERVER</code></p><p class="valid-value"><code class="literal">OFFLINE_MODE</code></p><p class="valid-value"><code class="literal">READ_ONLY</code></p></td>
</tr><tr><th>有効な値 (≥ 8.0.12, ≤ 8.0.17)</th>
<td><p class="valid-value"><code class="literal">ABORT_SERVER</code></p><p class="valid-value"><code class="literal">READ_ONLY</code></p></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更でき、変更はただちに有効になります。 動作が必要であることを意味する問題が発生すると、システム変数 current 値が読み取られます。 
      </p><p>
        <code class="literal">group_replication_exit_state_action</code> では、たとえばアプライヤエラーが発生した後、大部分が失われた場合、または疑わしいタイムアウトのためにグループの別のメンバーがグループを明示する場合などに、このサーバーインスタンスが意図せずグループを離れたときのグループレプリケーションの動作を構成します。 大部分が失われた場合にメンバーがグループを離れるタイムアウト期間は <code class="literal">group_replication_unreachable_majority_timeout</code> システム変数によって設定され、疑わしい場合のタイムアウト期間は <code class="literal">group_replication_member_expel_timeout</code> システム変数によって設定されます。 削除されたグループメンバーは、グループに再接続するまで削除されたことを認識しないため、指定されたアクションが実行されるのは、メンバーが再接続を管理している場合、またはメンバーがそれ自体で疑わしいことを引き起こして削除した場合のみです。 
      </p><p>
        疑わしいタイムアウトまたは大部分の損失が原因でグループメンバーが削除された場合、メンバーの <code class="literal">group_replication_autorejoin_tries</code> システム変数が自動再結合の試行回数を指定するように設定されていると、最初にスーパー読取り専用モードで指定された回数試行し、次に <code class="literal">group_replication_exit_state_action</code> で指定されたアクションに従います。 アプライヤエラーの場合、自動再結合はリカバリできないため試行されません。 
      </p><p>
        <code class="literal">group_replication_exit_state_action</code> が <code class="literal">READ_ONLY</code> に設定されている場合、メンバーが誤ってグループを終了するか、自動再結合の試行を使い果たすと、インスタンスは MySQL をスーパー読取り専用モードに切り替えます (システム変数 <code class="literal">super_read_only</code> を <code class="literal">ON</code> に設定します)。 <code class="literal">READ_ONLY</code> 終了アクションは、システム変数が導入される前の MySQL 8.0 リリースの動作であり、MySQL 8.0.16 から再度デフォルトになりました。 
      </p><p>
        <code class="literal">group_replication_exit_state_action</code> が <code class="literal">OFFLINE_MODE</code> に設定されている場合、メンバーが誤ってグループを終了するか、自動再結合の試行を使い果たすと、インスタンスは MySQL をオフラインモードに切り替えます (システム変数 <code class="literal">offline_mode</code> を <code class="literal">ON</code> に設定します)。 このモードでは、接続クライアントユーザーは次のリクエストで切断され、<code class="literal">CONNECTION_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) を持つクライアントユーザーを除き、接続は受け入れられなくなります。 Group Replication は、システム変数 <code class="literal">super_read_only</code> を <code class="literal">ON</code> に設定することもできるため、クライアントが <code class="literal">CONNECTION_ADMIN</code> または <code class="literal">SUPER</code> 権限で接続されていても更新を行うことはできません。 <code class="literal">OFFLINE_MODE</code> 終了アクションは、MySQL 8.0.18 から使用できます。 
      </p><p>
        <code class="literal">group_replication_exit_state_action</code> が <code class="literal">ABORT_SERVER</code> に設定されている場合、メンバーが意図せずグループを終了するか、自動再結合の試行を使い果たすと、インスタンスは MySQL を停止します。 この設定は、システム変数が MySQL 8.0.15 に追加されたときの MySQL 8.0.12 のデフォルトでした。 
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          メンバーがグループに正常に参加する前に障害が発生した場合、指定された終了アクション<span class="emphasis"><em>取得されません</em></span>。 これは、ローカル構成チェック中に障害が発生した場合、または参加メンバーの構成とグループの構成が一致しない場合です。 このような状況では、<code class="literal">super_read_only</code> システム変数は元の値のままで、接続は引き続き受け入れられ、サーバーは MySQL を停止しません。 したがって、Group Replication が起動しなかったときにサーバーが更新を受け入れられないようにするには、起動時に <code class="literal">super_read_only=ON</code> をサーバー構成ファイルに設定することをお薦めします。これは、正常に起動された後、プライマリメンバー上の <code class="literal">OFF</code> にグループレプリケーションが変更されます。 この保護策は、サーバーがサーバー起動時に Group Replication (<code class="literal">group_replication_start_on_boot=ON</code>) を起動するように構成されている場合に特に重要ですが、<code class="literal">START GROUP_REPLICATION</code> コマンドを使用して Group Replication を手動で起動する場合にも役立ちます。 
        </p></div><p>
        このオプションの使用方法および exit アクションが実行される状況の完全なリストの詳細は、<a class="xref" href="group-replication.html#group-replication-responses-failure-exit" title="18.6.6.4 終了処理">セクション18.6.6.4「終了処理」</a> を参照してください。
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_applier_threshold"></a>
        <code class="literal">group_replication_flow_control_applier_threshold</code>
      </p><a class="indexterm" name="idm45563245530000"></a><a class="indexterm" name="idm45563245528368"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_flow_control_applier_threshold"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-flow-control-applier-threshold=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_applier_threshold">group_replication_flow_control_applier_threshold</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">25000</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">2147483647</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更でき、変更はただちに有効になります。
      </p><p>
        <code class="literal">group_replication_flow_control_applier_threshold</code> では、フロー制御をトリガーするアプライヤキュー内の待機中トランザクションの数を指定します。
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_certifier_threshold"></a>
        <code class="literal">group_replication_flow_control_certifier_threshold</code>
      </p><a class="indexterm" name="idm45563245496640"></a><a class="indexterm" name="idm45563245494992"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_flow_control_certifier_threshold"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-flow-control-certifier-threshold=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_certifier_threshold">group_replication_flow_control_certifier_threshold</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">25000</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">2147483647</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更でき、変更はただちに有効になります。
      </p><p>
        <code class="literal">group_replication_flow_control_certifier_threshold</code> では、フロー制御をトリガーする証明者キュー内の待機中トランザクションの数を指定します。
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_hold_percent"></a>
        <code class="literal">group_replication_flow_control_hold_percent</code>
      </p><a class="indexterm" name="idm45563245463360"></a><a class="indexterm" name="idm45563245461824"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_flow_control_hold_percent"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-flow-control-hold-percent=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_hold_percent">group_replication_flow_control_hold_percent</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">10</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">100</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更でき、変更はただちに有効になります。
      </p><p>
        <code class="literal">group_replication_flow_control_hold_percent</code> では、フロー制御下のクラスタがバックログで捕捉できるように、未使用のままになるグループ割当ての割合を定義します。 値 0 は、作業バックログを捕捉するために割当て制限の一部が予約されていないことを意味します。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_max_commit_quota"></a>
        <code class="literal">group_replication_flow_control_max_commit_quota</code>
      </p><a class="indexterm" name="idm45563245429952"></a><a class="indexterm" name="idm45563245428320"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_flow_control_max_commit_quota"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-flow-control-max-commit-quota=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_max_commit_quota">group_replication_flow_control_max_commit_quota</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">2147483647</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更でき、変更はただちに有効になります。
      </p><p>
        <code class="literal">group_replication_flow_control_max_commit_quota</code> では、フロー制御が有効になっている間、グループの最大フロー制御割当て制限または任意の期間の最大使用可能割当て制限が定義されます。 値 0 は、最大割当て制限が設定されていないことを意味します。 このシステム変数の値は、<code class="literal">group_replication_flow_control_min_quota</code> および <code class="literal">group_replication_flow_control_min_recovery_quota</code> より小さくできません。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_member_quota_percent"></a>
        <code class="literal">group_replication_flow_control_member_quota_percent</code>
      </p><a class="indexterm" name="idm45563245394464"></a><a class="indexterm" name="idm45563245392816"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_flow_control_member_quota_percent"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-flow-control-member-quota-percent=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_member_quota_percent">group_replication_flow_control_member_quota_percent</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">100</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更でき、変更はただちに有効になります。
      </p><p>
        <code class="literal">group_replication_flow_control_member_quota_percent</code> では、割当て制限の計算時にメンバーが使用可能とみなす必要がある割当て制限の割合が定義されます。 値 0 は、割当て制限を最後の期間のライターであったメンバー間で均等に分割する必要があることを意味します。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_min_quota"></a>
        <code class="literal">group_replication_flow_control_min_quota</code>
      </p><a class="indexterm" name="idm45563245360912"></a><a class="indexterm" name="idm45563245359392"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_flow_control_min_quota"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-flow-control-min-quota=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_min_quota">group_replication_flow_control_min_quota</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">2147483647</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更でき、変更はただちに有効になります。
      </p><p>
        <code class="literal">group_replication_flow_control_min_quota</code> は、最後の期間に実行された計算済の最小目標とは関係なく、メンバーに割り当てることができる最小フロー制御目標を制御します。 値 0 は、最小割当て制限がないことを意味します。 このシステム変数の値は <code class="literal">group_replication_flow_control_max_commit_quota</code> より大きくできません。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_min_recovery_quota"></a>
        <code class="literal">group_replication_flow_control_min_recovery_quota</code>
      </p><a class="indexterm" name="idm45563245326336"></a><a class="indexterm" name="idm45563245324688"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_flow_control_min_recovery_quota"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-flow-control-min-recovery-quota=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_min_recovery_quota">group_replication_flow_control_min_recovery_quota</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">2147483647</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更でき、変更はただちに有効になります。
      </p><p>
        <code class="literal">group_replication_flow_control_min_recovery_quota</code> は、最後の期間に実行された計算済の最小割当て制限とは関係なく、グループ内の別のリカバリメンバーのためにメンバーに割り当てることができる最小割当て制限を制御します。 値 0 は、最小割当て制限がないことを意味します。 このシステム変数の値は <code class="literal">group_replication_flow_control_max_commit_quota</code> より大きくできません。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_mode"></a>
        <code class="literal">group_replication_flow_control_mode</code>
      </p><a class="indexterm" name="idm45563245291888"></a><a class="indexterm" name="idm45563245290368"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_flow_control_mode"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-flow-control-mode=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_mode">group_replication_flow_control_mode</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">QUOTA</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">DISABLED</code></p><p class="valid-value"><code class="literal">QUOTA</code></p></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更でき、変更はただちに有効になります。
      </p><p>
        <code class="literal">group_replication_flow_control_mode</code> では、フロー制御に使用されるモードを指定します。
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_period"></a>
        <code class="literal">group_replication_flow_control_period</code>
      </p><a class="indexterm" name="idm45563245260032"></a><a class="indexterm" name="idm45563245258432"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_flow_control_period"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-flow-control-period=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_period">group_replication_flow_control_period</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">60</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更でき、変更はただちに有効になります。
      </p><p>
        <code class="literal">group_replication_flow_control_period</code> では、フロー制御メッセージが送信されてフロー制御管理タスクが実行されるまで待機する秒数を定義します。
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_release_percent"></a>
        <code class="literal">group_replication_flow_control_release_percent</code>
      </p><a class="indexterm" name="idm45563245226992"></a><a class="indexterm" name="idm45563245225376"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_flow_control_release_percent"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-flow-control-release-percent=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_release_percent">group_replication_flow_control_release_percent</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">50</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">1000</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更でき、変更はただちに有効になります。
      </p><p>
        <code class="literal">group_replication_flow_control_release_percent</code> では、フロー制御でライターメンバーを制限する必要がなくなった場合に、グループ割当て制限を解放する方法を定義します。この割合は、フロー制御期間ごとの割当て制限の増加です。 値 0 は、フロー制御しきい値が制限内になると、割当て制限が単一のフロー制御反復で解放されることを意味します。 範囲を使用すると、割当て制限を現在の割当て制限の最大 10 倍までリリースできます。これにより、主にフロー制御期間が大きく、割当て制限が非常に小さい場合に、より高度な適応が可能になります。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_force_members"></a>
        <code class="literal">group_replication_force_members</code>
      </p><a class="indexterm" name="idm45563245192736"></a><a class="indexterm" name="idm45563245191152"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_force_members"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-force-members=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_force_members">group_replication_force_members</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
        このシステム変数は、新しいグループメンバーシップを強制するために使用されます。 このシステム変数の値は、Group Replication の実行中に変更でき、変更はただちに有効になります。 システム変数の値を設定する必要があるのは、グループに残すグループメンバーのいずれかのみです。 新しいグループメンバーシップを強制的に実行する必要がある状況と、このシステム変数を使用する際に従う手順の詳細は、<a class="xref" href="group-replication.html#group-replication-network-partitioning" title="18.4.4 ネットワークパーティション化">セクション18.4.4「ネットワークパーティション化」</a> を参照してください。 
      </p><p>
        <code class="literal">group_replication_force_members</code> では、ピアアドレスのリストをカンマ区切りリスト (<code class="literal">host1:port1</code>、<code class="literal">host2:port2</code> など) として指定します。 リストに含まれていない既存のメンバーは、グループの新しいビューを受信せず、ブロックされます。 メンバーとして続行する既存のメンバーごとに、各メンバーの <code class="literal">group_replication_local_address</code> システム変数で指定されているように、IP アドレスまたはホスト名とポートを含める必要があります。 IPv6 アドレスは大カッコで囲んで指定する必要があります。 例: 
      </p><pre class="programlisting">"198.51.100.44:33061,[2001:db8:85a3:8d3:1319:8a2e:370:7348]:33061,example.org:33061"</pre><p>
        Group Replication (XCom) のグループ通信エンジンは、指定された IP アドレスが有効な形式であることをチェックし、現在アクセスできないグループメンバーが含まれていないことをチェックします。 それ以外の場合、新しい構成は検証されないため、グループのアクセス可能なメンバーであるオンラインサーバーのみを含めるように注意する必要があります。 リスト内の不正な値または無効なホスト名があると、グループが無効な構成でブロックされる可能性があります。 
      </p><p>
        新しいメンバーシップ構成を強制的に実行する前に、除外するサーバーが停止していることを確認することが重要です。 そうでない場合は、停止してから続行します。 まだオンラインのグループメンバーは新しい構成を自動的に形成でき、これがすでに行われている場合は、さらに新しい構成を強制すると、グループに人工的なスプリットブレイン状況が作成される可能性があります。 
      </p><p>
        <code class="literal">group_replication_force_members</code> システム変数を使用して新しいグループメンバーシップを強制し、グループのブロックを解除した後、必ずシステム変数をクリアしてください。<code class="literal">START GROUP_REPLICATION</code> ステートメントを発行するには、<code class="literal">group_replication_force_members</code> が空である必要があります。
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_group_name"></a>
        <code class="literal">group_replication_group_name</code>
      </p><a class="indexterm" name="idm45563245155600"></a><a class="indexterm" name="idm45563245154032"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_group_name"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-group-name=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_group_name">group_replication_group_name</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_group_name</code> は、このサーバーインスタンスが属するグループの名前を指定します。これは有効な UUID である必要があります。 この UUID は、バイナリログ内のグループレプリケーショントランザクションの GTID を設定するときに内部的に使用されます。 
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          一意の UUID を使用する必要があります。
        </p></div></li><li class="listitem"><p><a name="sysvar_group_replication_group_seeds"></a>
        <code class="literal">group_replication_group_seeds</code>
      </p><a class="indexterm" name="idm45563245128480"></a><a class="indexterm" name="idm45563245126912"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_group_seeds"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-group-seeds=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_group_seeds">group_replication_group_seeds</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_group_seeds</code> は、参加メンバーが現在のすべてのグループメンバーの詳細を取得するために接続できるグループメンバーのリストです。 参加メンバーは、これらの詳細を使用してグループメンバーを選択して接続し、グループとの同期に必要なデータを取得します。 このリストは、シードメンバーの <code class="literal">group_replication_local_address</code> システム変数 (MySQL Server <code class="literal">hostname</code> および <code class="literal">port</code> システム変数で指定されたシードメンバーの SQL クライアント接続ではなく) で構成されている、含まれる各シードメンバーの単一の内部ネットワークアドレスまたはホスト名で構成されます。 シードメンバーのアドレスは、<code class="literal">host1:port1</code>、<code class="literal">host2:port2</code> などのカンマ区切りリストとして指定されます。 IPv6 アドレスは大カッコで囲んで指定する必要があります。 例: 
      </p><pre class="programlisting">group_replication_group_seeds= "198.51.100.44:33061,[2001:db8:85a3:8d3:1319:8a2e:370:7348]:33061, example.org:33061"</pre><p>
        この変数に指定する値は、<code class="literal">START GROUP_REPLICATION</code> ステートメントが発行され、Group Communication System (GCS) が使用可能になるまで検証されないことに注意してください。
      </p><p>
        通常、このリストはグループのすべてのメンバーで構成されますが、シードするグループメンバーのサブセットを選択できます。 リストには、少なくとも 1 つの有効なメンバーアドレスが含まれている必要があります。 各アドレスは、Group Replication の開始時に検証されます。 リストに有効なメンバーアドレスが含まれていない場合、<code class="literal">START GROUP_REPLICATION</code> の発行は失敗します。 
      </p><p>
        サーバーは、レプリケーショングループに参加するときに、その <code class="literal">group_replication_group_seeds</code> システム変数にリストされている最初のシードメンバーに接続しようとします。 接続が拒否された場合、参加メンバーはリスト内の他の各シードメンバーに順番に接続しようとします。 結合メンバーがシードメンバーに接続しても、結果としてレプリケーショングループに追加されない場合 (たとえば、シードメンバーの allowlist に結合メンバーアドレスがなく、接続を閉じているため)、結合メンバーはリスト内の残りのシードメンバーを順番に試行し続けます。 
      </p><p>
        参加メンバーは、シードメンバーが <code class="literal">group_replication_group_seeds</code> オプションで通知するプロトコル (IPv4 または IPv6) と同じプロトコルを使用してシードメンバーと通信する必要があります。 グループレプリケーションの IP アドレス権限のために、シードメンバーの許可リストには、シードメンバーが提供するプロトコルの参加メンバーの IP アドレス、またはそのプロトコルのアドレスに解決されるホスト名が含まれている必要があります。 このアドレスのプロトコルがシードメンバーに通知されたプロトコルと一致しない場合は、参加メンバー <code class="literal">group_replication_local_address</code> に加えて、このアドレスまたはホスト名を設定して許可する必要があります。 参加メンバーに適切なプロトコルの許可されたアドレスがない場合、その接続試行は拒否されます。 詳細は、<a class="xref" href="group-replication.html#group-replication-ip-address-permissions" title="18.5.1 グループレプリケーション IP アドレスの権限">セクション18.5.1「グループレプリケーション IP アドレスの権限」</a>を参照してください。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_gtid_assignment_block_size"></a>
        <code class="literal">group_replication_gtid_assignment_block_size</code>
      </p><a class="indexterm" name="idm45563245084000"></a><a class="indexterm" name="idm45563245082384"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_gtid_assignment_block_size"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-gtid-assignment-block-size=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_gtid_assignment_block_size">group_replication_gtid_assignment_block_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">1000000</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値 (64 ビットプラットフォーム)</th>
<td><code class="literal">9223372036854775807</code></td>
</tr><tr><th>最大値 (32 ビットプラットフォーム)</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
        このシステム変数は、グループ全体の構成設定です。 値の変更を有効にするには、すべてのグループメンバーで同じ値を持つ必要があり、グループレプリケーションの実行中は変更できず、グループ (<code class="literal">group_replication_bootstrap_group=ON</code> を使用したサーバーによるブートストラップ) を完全に再起動する必要があります。 
      </p><p>
        <code class="literal">group_replication_gtid_assignment_block_size</code> では、各グループメンバー用に予約されている連続 GTID の数を指定します。 各メンバーは独自のブロックを消費し、必要に応じてより多くのブロックを予約します。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_ip_allowlist"></a>
        <code class="literal">group_replication_ip_allowlist</code>
      </p><a class="indexterm" name="idm45563245046624"></a><a class="indexterm" name="idm45563245045504"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_ip_allowlist"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-ip-allowlist=value</code></td>
</tr><tr><th>導入</th>
<td>8.0.22</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_ip_allowlist">group_replication_ip_allowlist</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">AUTOMATIC</code></td>
</tr></tbody></table></div><p>
        <code class="literal">group_replication_ip_allowlist</code> は、<code class="literal">group_replication_ip_whitelist</code> のかわりに MySQL 8.0.22 から使用できます。 グループレプリケーションの実行中は、このシステム変数の値を変更できません。 
      </p><p>
        <code class="literal">group_replication_ip_allowlist</code> は、グループへの接続を許可するホストを指定します。 <code class="literal">group_replication_local_address</code> の各グループメンバーに指定するアドレスは、レプリケーショングループ内の他のサーバーで許可されている必要があります。 この変数に指定する値は、<code class="literal">START GROUP_REPLICATION</code> ステートメントが発行され、Group Communication System (GCS) が使用可能になるまで検証されないことに注意してください。 
      </p><p>
        デフォルトでは、このシステム変数は、ホスト上でアクティブなプライベートサブネットワークからの接続を許可する <code class="literal">AUTOMATIC</code> に設定されています。 Group Replication (XCom) のグループ通信エンジンは、ホスト上のアクティブなインタフェースを自動的にスキャンし、プライベートサブネットワーク上のアドレスを持つインタフェースを識別します。 IPv4 および (MySQL 8.0.14 から) IPv6 のこれらのアドレスと <code class="literal">localhost</code> IP アドレスを使用して、Group Replication 許可リストを作成します。 アドレスが自動的に許可される範囲のリストについては、<a class="xref" href="group-replication.html#group-replication-ip-address-permissions" title="18.5.1 グループレプリケーション IP アドレスの権限">セクション18.5.1「グループレプリケーション IP アドレスの権限」</a> を参照してください。 
      </p><p>
        プライベートアドレスの自動許可リストは、プライベートネットワーク外のサーバーからの接続には使用できません。 異なるマシン上にあるサーバーインスタンス間のグループレプリケーション接続の場合、パブリック IP アドレスを指定し、明示的な許可リストとして指定する必要があります。 許可リストにエントリを指定した場合、プライベートアドレスは自動的に追加されないため、これらのいずれかを使用する場合は、明示的に指定する必要があります。 <code class="literal">localhost</code> IP アドレスは自動的に追加されます。 
      </p><p>
        <code class="literal">group_replication_ip_allowlist</code> オプションの値として、次の任意の組合せを指定できます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
            IPv4 アドレス (<code class="literal">198.51.100.44</code> など)
          </p></li><li class="listitem"><p>
            CIDR 表記を使用した IPv4 アドレス (<code class="literal">192.0.2.21/24</code> など)
          </p></li><li class="listitem"><p>
            MySQL 8.0.14 からの IPv6 アドレス (<code class="literal">2001:db8:85a3:8d3:1319:8a2e:370:7348</code> など)
          </p></li><li class="listitem"><p>
            MySQL 8.0.14 からの CIDR 表記の IPv6 アドレス (<code class="literal">2001:db8:85a3:8d3::/64</code> など)
          </p></li><li class="listitem"><p>
            ホスト名 (<code class="literal">example.org</code> など)
          </p></li><li class="listitem"><p>
            CIDR 表記法を使用したホスト名 (<code class="literal">www.example.com/24</code> など)
          </p></li></ul></div><p>
        MySQL 8.0.14 より前では、ホスト名は IPv4 アドレスにのみ解決できました。 MySQL 8.0.14 から、ホスト名は IPv4 アドレス、IPv6 アドレス、またはその両方に解決できます。 ホスト名が IPv4 アドレスと IPv6 アドレスの両方に解決される場合、IPv4 アドレスは常にグループレプリケーション接続に使用されます。 CIDR 表記をホスト名または IP アドレスと組み合せて使用すると、特定のネットワーク接頭辞を持つ IP アドレスのブロックを許可できますが、指定したサブネット内のすべての IP アドレスが制御下にあることを確認してください。 
      </p><p>
        allowlist の各エントリはカンマで区切る必要があります。 例: 
      </p><pre class="programlisting">"192.0.2.21/24,198.51.100.44,203.0.113.0/24,2001:db8:85a3:8d3:1319:8a2e:370:7348,example.org,www.example.com/24"</pre><p>
        結合メンバーに IPv4 <code class="literal">group_replication_local_address</code> がある場合、またはその逆の場合に、グループのシードメンバーのいずれかが IPv6 アドレスとともに <code class="literal">group_replication_group_seeds</code> オプションにリストされている場合は、シードメンバーによって提供されるプロトコル (またはそのプロトコルのアドレスに解決されるホスト名) の結合メンバーの代替アドレスも設定して許可する必要があります。 詳細は、<a class="xref" href="group-replication.html#group-replication-ip-address-permissions" title="18.5.1 グループレプリケーション IP アドレスの権限">セクション18.5.1「グループレプリケーション IP アドレスの権限」</a>を参照してください。 
      </p><p>
        たとえば、異なるサブネットを分離しておくために、セキュリティ要件に応じて異なるグループメンバーに異なる許可リストを構成できます。 ただし、これにより、グループの再構成時に問題が発生する可能性があります。 それ以外の場合に特定のセキュリティ要件がない場合は、グループのすべてのメンバーで同じ許可リストを使用します。 詳細は、<a class="xref" href="group-replication.html#group-replication-ip-address-permissions" title="18.5.1 グループレプリケーション IP アドレスの権限">セクション18.5.1「グループレプリケーション IP アドレスの権限」</a>を参照してください。 
      </p><p>
        ホスト名の場合、名前解決は、別のサーバーによって接続リクエストが行われた場合にのみ行われます。 解決できないホスト名は許可リストの検証で考慮されず、警告メッセージがエラーログに書き込まれます。 前方確認の逆引き DNS (FCrDNS) 検証は、解決されたホスト名に対して実行されます。 
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          ホスト名は本質的に許可リストの IP アドレスより安全性が低くなります。 FCrDNS の検証は適切なレベルの保護を提供しますが、特定のタイプの攻撃によって危険にさらされる可能性があります。 厳密に必要な場合にのみ許可リストにホスト名を指定し、名前解決に使用されるすべてのコンポーネント (DNS サーバーなど) が制御下に保持されていることを確認します。 外部コンポーネントを使用しないように、hosts ファイルを使用して名前解決をローカルに実装することもできます。 
        </p></div></li><li class="listitem"><p><a name="sysvar_group_replication_ip_whitelist"></a>
        <code class="literal">group_replication_ip_whitelist</code>
      </p><a class="indexterm" name="idm45563244981456"></a><a class="indexterm" name="idm45563244980336"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_ip_whitelist"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-ip-whitelist=value</code></td>
</tr><tr><th>非推奨</th>
<td>8.0.22</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_ip_whitelist">group_replication_ip_whitelist</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">AUTOMATIC</code></td>
</tr></tbody></table></div><p>
        MySQL 8.0.22 からは、<code class="literal">group_replication_ip_whitelist</code> は非推奨であり、<code class="literal">group_replication_ip_allowlist</code> を使用して置き換えられます。 どちらのシステム変数の場合も、デフォルト値は <code class="literal">AUTOMATIC</code> です。 いずれかのシステム変数がユーザー定義値に設定されていて、もう一方が設定されていない場合は、変更された値が使用されます。 両方のシステム変数がユーザー定義の値に設定されている場合は、<code class="literal">group_replication_ip_allowlist</code> の値が使用されます。 
      </p><p>
        新しいシステム変数は古いシステム変数と同じように機能しますが、用語のみが変更されています。 <code class="literal">group_replication_ip_allowlist</code> の動作の説明は、古いシステム変数と新しいシステム変数の両方に適用されます。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_local_address"></a>
        <code class="literal">group_replication_local_address</code>
      </p><a class="indexterm" name="idm45563244946976"></a><a class="indexterm" name="idm45563244945392"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_local_address"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-local-address=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_local_address">group_replication_local_address</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_local_address</code> は、メンバーが他のメンバーからの接続用に提供するネットワークアドレスを、<code class="literal">host:port</code> フォーマット文字列として指定して設定します。 このアドレスは、リモート XCom インスタンス間の TCP 通信用のグループレプリケーション (XCom、Paxos バリアント) のためにグループ通信エンジンによって使用されるため、グループのすべてのメンバーがアクセスできる必要があります。 ローカルインスタンスとの通信は、共有メモリーを使用して入力チャネルを介して行われます。 
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          メンバーとの通信にこのアドレスを使用しないでください。 これは、MySQL サーバーの SQL プロトコルのホストおよびポートではありません。 
        </p></div><p>
        <code class="literal">group_replication_local_address</code> で指定するアドレスまたはホスト名は、グループレプリケーションによって、レプリケーショングループ内のグループメンバーの一意の識別子として使用されます。 ホスト名または IP アドレスがすべて異なるかぎり、レプリケーショングループのすべてのメンバーに同じポートを使用でき、ポートがすべて異なるかぎり、すべてのメンバーに同じホスト名または IP アドレスを使用できます。 <code class="literal">group_replication_local_address</code> の推奨ポートは 33061 です。 この変数に指定した値は、<code class="literal">START GROUP_REPLICATION</code> ステートメントが発行され、Group Communication System (GCS) が使用可能になるまで検証されないことに注意してください。 
      </p><p>
        <code class="literal">group_replication_local_address</code> によって構成されたネットワークアドレスは、すべてのグループメンバーが解決できる必要があります。 たとえば、各サーバーインスタンスが固定ネットワークアドレスを持つ異なるマシン上にある場合、10.0.0.1 などのマシンの IP アドレスを使用できます。 ホスト名を使用する場合は、完全修飾名を使用し、DNS、正しく構成された<code class="literal">/etc/hosts</code> ファイルまたはその他の名前解決プロセスを介して解決できることを確認する必要があります。 MySQL 8.0.14 からは、IPv6 アドレス (またはそれらに解決されるホスト名) と IPv4 アドレスを使用できます。 IPv6 アドレスは、ポート番号を区別するために大カッコで囲む必要があります。次に例を示します: 
      </p><pre class="programlisting">group_replication_local_address= "[2001:db8:85a3:8d3:1319:8a2e:370:7348]:33061"</pre><p>
        サーバーインスタンスのグループレプリケーションのローカルアドレスとして指定されたホスト名が IPv4 アドレスと IPv6 アドレスの両方に解決される場合、IPv4 アドレスは常にグループレプリケーション接続に使用されます。 IPv6 ネットワークおよび IPv4 を使用するメンバーと IPv6 を使用するメンバーが混在するレプリケーショングループに対するグループレプリケーションサポートの詳細は、<a class="xref" href="group-replication.html#group-replication-ipv6" title="18.4.5 IPv6 および IPv6 と IPv4 の混合グループのサポート">セクション18.4.5「IPv6 および IPv6 と IPv4 の混合グループのサポート」</a> を参照してください。 
      </p><p>
        グループレプリケーションの IP アドレス権限のために、<code class="literal">group_replication_local_address</code> の各グループメンバーに指定するアドレスを、レプリケーショングループ内の他のサーバー上の <code class="literal">group_replication_ip_allowlist</code> (MySQL 8.0.22 から) または <code class="literal">group_replication_ip_whitelist</code> システム変数のリストに追加する必要があります。 グループのシードメンバーのいずれかが IPv6 アドレスとともに <code class="literal">group_replication_group_seeds</code> オプションにリストされている場合このメンバーが IPV4 <code class="literal">group_replication_local_address</code> であれば (またはその逆の場合)、必要なプロトコル (またはそのプロトコルのアドレスに解決されるホスト名) に対してこのメンバーの代替アドレスを設定して許可する必要もあります。 詳細は、<a class="xref" href="group-replication.html#group-replication-ip-address-permissions" title="18.5.1 グループレプリケーション IP アドレスの権限">セクション18.5.1「グループレプリケーション IP アドレスの権限」</a>を参照してください。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_member_expel_timeout"></a>
        <code class="literal">group_replication_member_expel_timeout</code>
      </p><a class="indexterm" name="idm45563244900416"></a><a class="indexterm" name="idm45563244898816"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_member_expel_timeout"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-member-expel-timeout=#</code></td>
</tr><tr><th>導入</th>
<td>8.0.13</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_member_expel_timeout">group_replication_member_expel_timeout</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値 (≥ 8.0.21)</th>
<td><code class="literal">5</code></td>
</tr><tr><th>デフォルト値 (≤ 8.0.20)</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値 (≥ 8.0.14)</th>
<td><code class="literal">3600</code></td>
</tr><tr><th>最大値 (≤ 8.0.13)</th>
<td><code class="literal">31536000</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更でき、変更はただちに有効になります。 Group Replication がタイムアウトをチェックするたびに、システム変数の現在の値が読み取られます。 グループのすべてのメンバーが同じ設定を持つことは必須ではありませんが、予期しない実行を回避するためにお薦めします。 
      </p><p>
        <code class="literal">group_replication_member_expel_timeout</code> では、疑わしいグループを作成した後、メンバーが失敗した疑いがあるグループから追い出されるまでにグループレプリケーショングループメンバーが待機する期間を秒単位で指定します。 疑いが作成される前の最初の 5 秒間の検出期間は、この時間の一部としてカウントされません。 MySQL 8.0.20 まで、<code class="literal">group_replication_member_expel_timeout</code> の値はデフォルトで 0 に設定されます。これは、待機期間がなく、疑わしいメンバーが 5 秒間の検出期間の終了直後に実行できることを意味します。 MySQL 8.0.21 からは、値はデフォルトで 5 に設定されます。つまり、疑わしいメンバーは、5 秒間の検出期間の 5 秒後に強制的に実行されます。 
      </p><p>
        グループメンバーの <code class="literal">group_replication_member_expel_timeout</code> の値の変更は、そのグループメンバーの既存および将来の疑いに対してただちに有効になります。 したがって、これを方法として使用すると、疑わしいメンバーを強制的にタイムアウトして削除し、グループ構成を変更できます。 詳細は、<a class="xref" href="group-replication.html#group-replication-responses-failure-expel" title="18.6.6.1 Expel タイムアウト">セクション18.6.6.1「Expel タイムアウト」</a>を参照してください。 
      </p><p>
        <code class="literal">group_replication_member_expel_timeout</code> の値を大きくすると、低速または安定していないネットワークで不要な削除が発生しないようにしたり、一時的なネットワークの停止やマシンの速度低下が予想される場合に役立ちます。 疑わしいメンバーがタイムアウトする前に再度アクティブになると、残りのグループメンバーによってバッファされたすべてのメッセージが適用され、オペレータの介入なしで <code class="literal">ONLINE</code> 状態になります。 最大 3600 秒 (1 時間) までのタイムアウト値を指定できます。 XCom メッセージキャッシュが、指定した期間内の予想されるメッセージ量と最初の 5 秒間の検出期間を含むのに十分な大きさであることを確認することが重要です。そうでない場合、メンバーは再接続できません。 <code class="literal">group_replication_message_cache_size</code> システム変数を使用して、キャッシュサイズ制限を調整できます。 詳細は、<a class="xref" href="group-replication.html#group-replication-performance-xcom-cache" title="18.6.5 XCom キャッシュ管理">セクション18.6.5「XCom キャッシュ管理」</a>を参照してください。 
      </p><p>
        タイムアウトを超えた場合、疑わしいメンバーは疑わしいタイムアウトの直後に削除する責任があります。 メンバーが通信を再開でき、削除されたビューを受信し、メンバーに自動再結合の試行回数を指定する <code class="literal">group_replication_autorejoin_tries</code> システム変数が設定されている場合、スーパー読取り専用モードでは、指定された回数グループへの再参加を試行します。 メンバーに自動再結合の試行が指定されていない場合、または指定された試行回数を使い果たした場合は、システム変数 <code class="literal">group_replication_exit_state_action</code> で指定されたアクションに従います。 
      </p><p>
        <code class="literal">group_replication_member_expel_timeout</code> 設定の使用の詳細は、<a class="xref" href="group-replication.html#group-replication-responses-failure-expel" title="18.6.6.1 Expel タイムアウト">セクション18.6.6.1「Expel タイムアウト」</a> を参照してください。 このシステム変数が使用できない場合に不要な削除を回避するための代替軽減戦略については、<a class="xref" href="group-replication.html#group-replication-limitations" title="18.9.2 グループレプリケーションの制限事項">セクション18.9.2「グループレプリケーションの制限事項」</a> を参照してください。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_member_weight"></a>
        <code class="literal">group_replication_member_weight</code>
      </p><a class="indexterm" name="idm45563244843120"></a><a class="indexterm" name="idm45563244841536"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_member_weight"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-member-weight=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_member_weight">group_replication_member_weight</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">50</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">100</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更でき、変更はただちに有効になります。 システム変数の現在の値は、フェイルオーバー状況が発生したときに読み取られます。 
      </p><p>
        <code class="literal">group_replication_member_weight</code> では、既存のプライマリが単一プライマリグループから離れる場合など、フェイルオーバー時にプライマリとして選択されるメンバーの可能性に影響を与えるためにメンバーに割り当てることができる重みの割合を指定します。 プライマリのスケジュールされたメンテナンス中やフェイルオーバー時に特定のハードウェアが優先されるように、メンバーに数値の重みを割り当てて特定のメンバーが選択されるようにします。 
      </p><p>
        メンバーが次のように構成されているグループの場合:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
            <code class="literal">member-1</code>: group_replication_member_weight=30, server_uuid=aaaa
          </p></li><li class="listitem"><p>
            <code class="literal">member-2</code>: group_replication_member_weight=40, server_uuid=bbbb
          </p></li><li class="listitem"><p>
            <code class="literal">member-3</code>: group_replication_member_weight=40, server_uuid=cccc
          </p></li><li class="listitem"><p>
            <code class="literal">member-4</code>: group_replication_member_weight=40, server_uuid=dddd
          </p></li></ul></div><p>
        新しいプライマリの選択時に、前述のメンバーは <code class="literal">member-2</code>, <code class="literal">member-3</code>, <code class="literal">member-4</code> および <code class="literal">member-1</code> としてソートされます。 これにより、フェイルオーバー時に新しいプライマリとして <code class="literal">member</code>-2 が選択されます。 詳細は、<a class="xref" href="group-replication.html#group-replication-single-primary-mode" title="18.1.3.1 シングルプライマリモード">セクション18.1.3.1「シングルプライマリモード」</a>を参照してください。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_message_cache_size"></a>
        <code class="literal">group_replication_message_cache_size</code>
      </p><a class="indexterm" name="idm45563244797296"></a><a class="indexterm" name="idm45563244795696"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_message_cache_size"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-message-cache-size=#</code></td>
</tr><tr><th>導入</th>
<td>8.0.16</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_message_cache_size">group_replication_message_cache_size</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">1073741824 (1 GB)</code></td>
</tr><tr><th>最小値 (64 ビットプラットフォーム, ≥ 8.0.21)</th>
<td><code class="literal">134217728 (128 MB)</code></td>
</tr><tr><th>最小値 (64 ビットプラットフォーム, ≤ 8.0.20)</th>
<td><code class="literal">1073741824 (1 GB)</code></td>
</tr><tr><th>最小値 (32 ビットプラットフォーム, ≥ 8.0.21)</th>
<td><code class="literal">134217728 (128 MB)</code></td>
</tr><tr><th>最小値 (32 ビットプラットフォーム, ≤ 8.0.20)</th>
<td><code class="literal">1073741824 (1 GB)</code></td>
</tr><tr><th>最大値 (64 ビットプラットフォーム)</th>
<td><code class="literal">18446744073709551615 (16 EiB)</code></td>
</tr><tr><th>最大値 (32 ビットプラットフォーム)</th>
<td><code class="literal">315360004294967295 (4 GB)</code></td>
</tr></tbody></table></div><p>
        このシステム変数は、すべてのグループメンバーで同じ値を持つ必要があります。 このシステム変数の値は、Group Replication の実行中に変更できます。 変更は、メンバーでグループレプリケーションを停止して再起動した後、各グループメンバーで有効になります。 このプロセス中、システム変数の値はグループメンバー間で異なってもかまいませんが、切断された場合にメンバーが再接続できないことがあります。 
      </p><p>
        <code class="literal">group_replication_message_cache_size</code> は、グループレプリケーション (XCom) のグループ通信エンジンでメッセージキャッシュに使用可能なメモリーの最大量を設定します。 XCom メッセージキャッシュには、コンセンサスプロトコルの一部としてグループメンバー間で交換されるメッセージ (およびそのメタデータ) が保持されます。 メッセージキャッシュは、他のグループメンバーと通信できなかった期間後にグループに再接続するメンバーによる、欠落したメッセージのリカバリに使用されます。 
      </p><p>
        <code class="literal">group_replication_member_expel_timeout</code> システム変数は、メンバーが明示されるのではなくグループに戻るための最初の 5 秒間の検出期間に加えて許可される待機期間 (最大 1 時間) を決定します。 XCom メッセージキャッシュのサイズは、メンバーが正常に戻るために必要なすべての欠落メッセージが含まれるように、この期間内の予想されるメッセージ量を参照して設定する必要があります。 MySQL 8.0.20 までは、デフォルトは 5 秒の検出期間のみですが、MySQL 8.0.21 からは、合計 10 秒間、5 秒の検出期間後の待機期間は 5 秒です。 
      </p><p>
        MySQL Server の他のキャッシュおよびオブジェクトプールのサイズを考慮して、選択したキャッシュサイズ制限に十分なメモリーがシステムで使用可能であることを確認します。 デフォルト設定は 1073741824 バイト (1 GB) です。 最小設定は、MySQL 8.0.20 まで 1 GB です。 MySQL 8.0.21 からは、最小設定は 134217728 バイト (128 MB) で、使用可能なメモリー量が制限されたホストへのデプロイメントが可能になり、グループメンバーの接続の一時的な損失の頻度と期間を最小限に抑えるための適切なネットワーク接続が可能になります。 <code class="literal">group_replication_message_cache_size</code> を使用して設定された制限はキャッシュに格納されているデータにのみ適用され、キャッシュ構造には追加の 50 MB のメモリーが必要です。 
      </p><p>
        キャッシュサイズ制限は、実行時に動的に増減できます。 キャッシュサイズ制限を小さくすると、XCom では、現在のサイズが制限を下回るまで、決定および配信された最も古いエントリが削除されます。 Group Replication Group Communication System (GCS) は、現在アクセスできないメンバーによるリカバリに必要と思われるメッセージがメッセージキャッシュから削除されたときに、警告メッセージでアラートを生成します。 メッセージキャッシュサイズのチューニングの詳細は、<a class="xref" href="group-replication.html#group-replication-performance-xcom-cache" title="18.6.5 XCom キャッシュ管理">セクション18.6.5「XCom キャッシュ管理」</a> を参照してください。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_poll_spin_loops"></a>
        <code class="literal">group_replication_poll_spin_loops</code>
      </p><a class="indexterm" name="idm45563244742224"></a><a class="indexterm" name="idm45563244740624"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_poll_spin_loops"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-poll-spin-loops=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_poll_spin_loops">group_replication_poll_spin_loops</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値 (64 ビットプラットフォーム)</th>
<td><code class="literal">18446744073709551615</code></td>
</tr><tr><th>最大値 (32 ビットプラットフォーム)</th>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_poll_spin_loops</code> では、グループ通信スレッドが通信エンジン mutex の解放を待機する回数を指定します。この回数を超えると、スレッドは追加の着信ネットワークメッセージを待機します。
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_complete_at"></a>
        <code class="literal">group_replication_recovery_complete_at</code>
      </p><a class="indexterm" name="idm45563244706272"></a><a class="indexterm" name="idm45563244704672"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_recovery_complete_at"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-recovery-complete-at=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_complete_at">group_replication_recovery_complete_at</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">TRANSACTIONS_APPLIED</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">TRANSACTIONS_CERTIFIED</code></p><p class="valid-value"><code class="literal">TRANSACTIONS_APPLIED</code></p></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_recovery_complete_at</code> では、既存のメンバーからの状態転送後にキャッシュされたトランザクションを処理する際に、分散リカバリプロセス中に適用されるポリシーを指定します。 メンバーがグループ (<code class="literal">TRANSACTIONS_CERTIFIED</code>) に参加する前に見逃したすべてのトランザクションを受信して認証した後、または受信、認証および適用した後 (<code class="literal">TRANSACTIONS_APPLIED</code>) にのみ、メンバーをオンラインとしてマークするかどうかを選択できます。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_compression_algorithm"></a>
        <code class="literal">group_replication_recovery_compression_algorithm</code>
      </p><a class="indexterm" name="idm45563244671936"></a><a class="indexterm" name="idm45563244670304"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_recovery_compression_algorithm"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-recovery-compression-algorithm=value</code></td>
</tr><tr><th>導入</th>
<td>8.0.18</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_compression_algorithm">group_replication_recovery_compression_algorithm</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Set</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">uncompressed</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">zlib</code></p><p class="valid-value"><code class="literal">zstd</code></p><p class="valid-value"><code class="literal">uncompressed</code></p></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_recovery_compression_algorithm</code> では、ドナーバイナリログからの状態転送用のグループレプリケーション分散リカバリ接続に許可される圧縮アルゴリズムを指定します。 使用可能なアルゴリズムは、<code class="literal">protocol_compression_algorithms</code> システム変数の場合と同じです。 詳細は、<a class="xref" href="programs.html#connection-compression-control" title="4.2.8 接続圧縮制御">セクション4.2.8「接続圧縮制御」</a>を参照してください。 
      </p><p>
        この設定は、クローニングをサポートするようにサーバーが設定されており (<a class="xref" href="group-replication.html#group-replication-cloning" title="18.4.3.2 分散リカバリのためのクローニング">セクション18.4.3.2「分散リカバリのためのクローニング」</a> を参照)、分散リカバリ中にリモートクローニング操作が使用されている場合は適用されません。 この状態転送方法では、クローンプラグインの <code class="literal">clone_enable_compression</code> 設定が適用されます。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_get_public_key"></a>
        <code class="literal">group_replication_recovery_get_public_key</code>
      </p><a class="indexterm" name="idm45563244631808"></a><a class="indexterm" name="idm45563244630192"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_recovery_get_public_key"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-recovery-get-public-key[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_get_public_key">group_replication_recovery_get_public_key</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_recovery_get_public_key</code> は、RSA キーペアベースのパスワード交換に必要な公開キーをソースからリクエストするかどうかを指定します。 <code class="literal">group_replication_recovery_public_key_path</code> が有効な公開キーファイルに設定されている場合は、<code class="literal">group_replication_recovery_get_public_key</code> よりも優先されます。 この変数は、<code class="literal">group_replication_recovery</code> チャネル (<code class="literal">group_replication_recovery_use_ssl=ON</code>) を介した分散リカバリに SSL を使用せず、グループレプリケーションのレプリケーションユーザーアカウントが <code class="literal">caching_sha2_password</code> プラグイン (MySQL 8.0 のデフォルト) で認証される場合に適用されます。 詳細は、<a class="xref" href="group-replication.html#group-replication-caching-sha2-user-credentials" title="18.5.3.1.1 キャッシュ SHA-2 認証プラグインを使用するレプリケーションユーザー">セクション18.5.3.1.1「キャッシュ SHA-2 認証プラグインを使用するレプリケーションユーザー」</a>を参照してください。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_public_key_path"></a>
        <code class="literal">group_replication_recovery_public_key_path</code>
      </p><a class="indexterm" name="idm45563244597296"></a><a class="indexterm" name="idm45563244595680"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_recovery_public_key_path"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-recovery-public-key-path=file_name</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_public_key_path">group_replication_recovery_public_key_path</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>ファイル名</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">NULL</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_recovery_public_key_path</code> では、RSA キーペアベースのパスワード交換のソースで必要な公開キーのレプリカ側コピーを含むファイルへのパス名を指定します。 ファイルは PEM 形式である必要があります。 <code class="literal">group_replication_recovery_public_key_path</code> が有効な公開キーファイルに設定されている場合は、<code class="literal">group_replication_recovery_get_public_key</code> よりも優先されます。 この変数は、<code class="literal">group_replication_recovery</code> チャネルを介した分散リカバリに SSL を使用しておらず (<code class="literal">group_replication_recovery_use_ssl</code> が <code class="literal">OFF</code> に設定されている場合)、Group Replication のレプリケーションユーザーアカウントが <code class="literal">caching_sha2_password</code> プラグイン (MySQL 8.0 のデフォルト) または <code class="literal">sha256_password</code> プラグインで認証される場合に適用されます。 (<code class="literal">sha256_password</code> の場合、<code class="literal">group_replication_recovery_public_key_path</code> の設定は、MySQL が OpenSSL を使用して構築された場合にのみ適用されます。) 詳細は、<a class="xref" href="group-replication.html#group-replication-caching-sha2-user-credentials" title="18.5.3.1.1 キャッシュ SHA-2 認証プラグインを使用するレプリケーションユーザー">セクション18.5.3.1.1「キャッシュ SHA-2 認証プラグインを使用するレプリケーションユーザー」</a>を参照してください。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_reconnect_interval"></a>
        <code class="literal">group_replication_recovery_reconnect_interval</code>
      </p><a class="indexterm" name="idm45563244559424"></a><a class="indexterm" name="idm45563244557808"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_recovery_reconnect_interval"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-recovery-reconnect-interval=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_reconnect_interval">group_replication_recovery_reconnect_interval</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">60</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">31536000</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_recovery_reconnect_interval</code> では、分散リカバリに適したドナーがグループに見つからなかった場合の再接続試行の間隔を秒単位で指定します。
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_retry_count"></a>
        <code class="literal">group_replication_recovery_retry_count</code>
      </p><a class="indexterm" name="idm45563244525952"></a><a class="indexterm" name="idm45563244524352"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_recovery_retry_count"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-recovery-retry-count=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_retry_count">group_replication_recovery_retry_count</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">10</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">31536000</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_recovery_retry_count</code> は、参加しているメンバーが分散リカバリに使用可能なドナーへの接続を試みる回数を指定します。
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_ca"></a>
        <code class="literal">group_replication_recovery_ssl_ca</code>
      </p><a class="indexterm" name="idm45563244492688"></a><a class="indexterm" name="idm45563244491088"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_ca"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-recovery-ssl-ca=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_ca">group_replication_recovery_ssl_ca</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_recovery_ssl_ca</code> は、分散リカバリ接続用の信頼できる SSL 認証局のリストを含むファイルへのパスを指定します。 分散リカバリのための SSL の構成の詳細は、<a class="xref" href="group-replication.html#group-replication-secure-socket-layer-support-ssl" title="18.5.2 Secure Socket Layer (SSL) を使用したグループ通信接続の保護">セクション18.5.2「Secure Socket Layer (SSL) を使用したグループ通信接続の保護」</a> を参照してください。 
      </p><p>
        このサーバーがクローニングをサポートするように設定されていて (<a class="xref" href="group-replication.html#group-replication-cloning" title="18.4.3.2 分散リカバリのためのクローニング">セクション18.4.3.2「分散リカバリのためのクローニング」</a> を参照)、<code class="literal">group_replication_recovery_use_ssl</code> を <code class="literal">ON</code> に設定している場合、Group Replication はクローン SSL オプション <code class="literal">clone_ssl_ca</code> の設定を <code class="literal">group_replication_recovery_ssl_ca</code> の設定と一致するように自動的に構成します。
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_capath"></a>
        <code class="literal">group_replication_recovery_ssl_capath</code>
      </p><a class="indexterm" name="idm45563244460480"></a><a class="indexterm" name="idm45563244458880"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_capath"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-recovery-ssl-capath=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_capath">group_replication_recovery_ssl_capath</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_recovery_ssl_capath</code> は、分散リカバリ接続用の信頼できる SSL 認証局証明書を含むディレクトリへのパスを指定します。 分散リカバリのための SSL の構成の詳細は、<a class="xref" href="group-replication.html#group-replication-secure-socket-layer-support-ssl" title="18.5.2 Secure Socket Layer (SSL) を使用したグループ通信接続の保護">セクション18.5.2「Secure Socket Layer (SSL) を使用したグループ通信接続の保護」</a> を参照してください。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_cert"></a>
        <code class="literal">group_replication_recovery_ssl_cert</code>
      </p><a class="indexterm" name="idm45563244433600"></a><a class="indexterm" name="idm45563244432000"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_cert"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-recovery-ssl-cert=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_cert">group_replication_recovery_ssl_cert</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_recovery_ssl_cert</code> では、分散リカバリ用のセキュアな接続を確立するために使用する SSL 証明書ファイルの名前を指定します。 分散リカバリのための SSL の構成の詳細は、<a class="xref" href="group-replication.html#group-replication-secure-socket-layer-support-ssl" title="18.5.2 Secure Socket Layer (SSL) を使用したグループ通信接続の保護">セクション18.5.2「Secure Socket Layer (SSL) を使用したグループ通信接続の保護」</a> を参照してください。 
      </p><p>
        このサーバーがクローニングをサポートするように設定されていて (<a class="xref" href="group-replication.html#group-replication-cloning" title="18.4.3.2 分散リカバリのためのクローニング">セクション18.4.3.2「分散リカバリのためのクローニング」</a> を参照)、<code class="literal">group_replication_recovery_use_ssl</code> を <code class="literal">ON</code> に設定している場合、Group Replication はクローン SSL オプション <code class="literal">clone_ssl_cert</code> の設定を <code class="literal">group_replication_recovery_ssl_cert</code> の設定と一致するように自動的に構成します。
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_cipher"></a>
        <code class="literal">group_replication_recovery_ssl_cipher</code>
      </p><a class="indexterm" name="idm45563244401360"></a><a class="indexterm" name="idm45563244399760"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_cipher"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-recovery-ssl-cipher=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_cipher">group_replication_recovery_ssl_cipher</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_recovery_ssl_cipher</code> では、SSL 暗号化に許可される暗号のリストを指定します。 分散リカバリのための SSL の構成の詳細は、<a class="xref" href="group-replication.html#group-replication-secure-socket-layer-support-ssl" title="18.5.2 Secure Socket Layer (SSL) を使用したグループ通信接続の保護">セクション18.5.2「Secure Socket Layer (SSL) を使用したグループ通信接続の保護」</a> を参照してください。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_crl"></a>
        <code class="literal">group_replication_recovery_ssl_crl</code>
      </p><a class="indexterm" name="idm45563244374640"></a><a class="indexterm" name="idm45563244373040"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_crl"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-recovery-ssl-crl=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_crl">group_replication_recovery_ssl_crl</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>ファイル名</td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_recovery_ssl_crl</code> は、証明書失効リストを含むファイルを含むディレクトリへのパスを指定します。 分散リカバリのための SSL の構成の詳細は、<a class="xref" href="group-replication.html#group-replication-secure-socket-layer-support-ssl" title="18.5.2 Secure Socket Layer (SSL) を使用したグループ通信接続の保護">セクション18.5.2「Secure Socket Layer (SSL) を使用したグループ通信接続の保護」</a> を参照してください。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_crlpath"></a>
        <code class="literal">group_replication_recovery_ssl_crlpath</code>
      </p><a class="indexterm" name="idm45563244347792"></a><a class="indexterm" name="idm45563244346192"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_crlpath"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-recovery-ssl-crlpath=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_crlpath">group_replication_recovery_ssl_crlpath</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>ディレクトリ名</td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_recovery_ssl_crlpath</code> は、証明書失効リストを含むファイルを含むディレクトリへのパスを指定します。 分散リカバリのための SSL の構成の詳細は、<a class="xref" href="group-replication.html#group-replication-secure-socket-layer-support-ssl" title="18.5.2 Secure Socket Layer (SSL) を使用したグループ通信接続の保護">セクション18.5.2「Secure Socket Layer (SSL) を使用したグループ通信接続の保護」</a> を参照してください。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_key"></a>
        <code class="literal">group_replication_recovery_ssl_key</code>
      </p><a class="indexterm" name="idm45563244320944"></a><a class="indexterm" name="idm45563244319344"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_key"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-recovery-ssl-key=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_key">group_replication_recovery_ssl_key</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_recovery_ssl_key</code> では、セキュアな接続の確立に使用する SSL キーファイルの名前を指定します。 分散リカバリのための SSL の構成の詳細は、<a class="xref" href="group-replication.html#group-replication-secure-socket-layer-support-ssl" title="18.5.2 Secure Socket Layer (SSL) を使用したグループ通信接続の保護">セクション18.5.2「Secure Socket Layer (SSL) を使用したグループ通信接続の保護」</a> を参照してください。 
      </p><p>
        このサーバーがクローニングをサポートするように設定されていて (<a class="xref" href="group-replication.html#group-replication-cloning" title="18.4.3.2 分散リカバリのためのクローニング">セクション18.4.3.2「分散リカバリのためのクローニング」</a> を参照)、<code class="literal">group_replication_recovery_use_ssl</code> を <code class="literal">ON</code> に設定している場合、Group Replication はクローン SSL オプション <code class="literal">clone_ssl_key</code> の設定を <code class="literal">group_replication_recovery_ssl_key</code> の設定と一致するように自動的に構成します。
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_verify_server_cert"></a>
        <code class="literal">group_replication_recovery_ssl_verify_server_cert</code>
      </p><a class="indexterm" name="idm45563244288720"></a><a class="indexterm" name="idm45563244287072"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_verify_server_cert"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-recovery-ssl-verify-server-cert[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_verify_server_cert">group_replication_recovery_ssl_verify_server_cert</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_recovery_ssl_verify_server_cert</code> では、分散リカバリ接続でドナーによって送信された証明書のサーバー共通名の値をチェックするかどうかを指定します。 分散リカバリのための SSL の構成の詳細は、<a class="xref" href="group-replication.html#group-replication-secure-socket-layer-support-ssl" title="18.5.2 Secure Socket Layer (SSL) を使用したグループ通信接続の保護">セクション18.5.2「Secure Socket Layer (SSL) を使用したグループ通信接続の保護」</a> を参照してください。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_tls_ciphersuites"></a>
        <code class="literal">group_replication_recovery_tls_ciphersuites</code>
      </p><a class="indexterm" name="idm45563244259168"></a><a class="indexterm" name="idm45563244257632"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_recovery_tls_ciphersuites"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-recovery-tls-ciphersuites=value</code></td>
</tr><tr><th>導入</th>
<td>8.0.19</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_tls_ciphersuites">group_replication_recovery_tls_ciphersuites</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">NULL</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_recovery_tls_ciphersuites</code> では、分散リカバリ接続の接続暗号化に TLSv1.3 が使用され、このサーバーインスタンスが分散リカバリ接続のクライアント (参加メンバー) である場合に、許可されている 1 つ以上の暗号スイートのコロン区切りリストを指定します。 TLSv1.3 の使用時にこのシステム変数が <code class="literal">NULL</code> に設定されている場合 (システム変数を設定しない場合のデフォルト)、<a class="xref" href="security.html#encrypted-connection-protocols-ciphers" title="6.3.2 暗号化された接続 TLS プロトコルおよび暗号">セクション6.3.2「暗号化された接続 TLS プロトコルおよび暗号」</a> にリストされているように、デフォルトで有効になっている暗号スイートが許可されます。 このシステム変数が空の文字列に設定されている場合、暗号スイートは許可されないため、TLSv1.3 は使用されません。 このシステム変数は、MySQL 8.0.19 以降で使用できます。 分散リカバリのための SSL の構成の詳細は、<a class="xref" href="group-replication.html#group-replication-secure-socket-layer-support-ssl" title="18.5.2 Secure Socket Layer (SSL) を使用したグループ通信接続の保護">セクション18.5.2「Secure Socket Layer (SSL) を使用したグループ通信接続の保護」</a> を参照してください。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_tls_version"></a>
        <code class="literal">group_replication_recovery_tls_version</code>
      </p><a class="indexterm" name="idm45563244225296"></a><a class="indexterm" name="idm45563244223696"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_recovery_tls_version"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-recovery-tls-version=value</code></td>
</tr><tr><th>導入</th>
<td>8.0.19</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_tls_version">group_replication_recovery_tls_version</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>文字列</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">TLSv1,TLSv1.1,TLSv1.2,TLSv1.3</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_recovery_tls_version</code> では、このサーバーインスタンスが分散リカバリ接続のクライアント (参加メンバー) である場合に、接続暗号化に許可される TLS プロトコルのカンマ区切りリストを指定します。 指定したバージョンが連続していることを確認します (たとえば、<span class="quote">「<span class="quote"><code class="literal">TLSv1,TLSv1.1,TLSv1.2</code></span>」</span>)。 このシステム変数が設定されていない場合、デフォルトの <span class="quote">「<span class="quote"><code class="literal">TLSv1,TLSv1.1,TLSv1.2,TLSv1.3</code></span>」</span> が使用されます。 クライアント (参加メンバー) およびサーバー (ドナー) としての各分散リカバリ接続に含まれるグループメンバーは、どちらもサポートするように設定されている最高のプロトコルバージョンをネゴシエートします。 このシステム変数は、MySQL 8.0.19 から使用できます。 分散リカバリのための SSL の構成の詳細は、<a class="xref" href="group-replication.html#group-replication-secure-socket-layer-support-ssl" title="18.5.2 Secure Socket Layer (SSL) を使用したグループ通信接続の保護">セクション18.5.2「Secure Socket Layer (SSL) を使用したグループ通信接続の保護」</a> を参照してください。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_use_ssl"></a>
        <code class="literal">group_replication_recovery_use_ssl</code>
      </p><a class="indexterm" name="idm45563244191216"></a><a class="indexterm" name="idm45563244189616"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_recovery_use_ssl"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-recovery-use-ssl[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_use_ssl">group_replication_recovery_use_ssl</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">OFF</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_recovery_use_ssl</code> では、グループメンバー間のグループレプリケーション分散リカバリ接続で SSL を使用するかどうかを指定します。 分散リカバリのための SSL の構成の詳細は、<a class="xref" href="group-replication.html#group-replication-secure-socket-layer-support-ssl" title="18.5.2 Secure Socket Layer (SSL) を使用したグループ通信接続の保護">セクション18.5.2「Secure Socket Layer (SSL) を使用したグループ通信接続の保護」</a> を参照してください。 
      </p><p>
        このサーバーがクローニングをサポートするように設定されている場合 (<a class="xref" href="group-replication.html#group-replication-cloning" title="18.4.3.2 分散リカバリのためのクローニング">セクション18.4.3.2「分散リカバリのためのクローニング」</a> を参照)、このオプションを <code class="literal">ON</code> に設定すると、グループレプリケーションでは、リモートクローニング操作およびドナーのバイナリログからの状態転送に SSL が使用されます。 このオプションを <code class="literal">OFF</code> に設定すると、グループレプリケーションはリモートクローニング操作に SSL を使用しません。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_zstd_compression_level"></a>
        <code class="literal">group_replication_recovery_zstd_compression_level</code>
      </p><a class="indexterm" name="idm45563244158320"></a><a class="indexterm" name="idm45563244156672"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_recovery_zstd_compression_level"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-recovery-zstd-compression-level=#</code></td>
</tr><tr><th>導入</th>
<td>8.0.18</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_zstd_compression_level">group_replication_recovery_zstd_compression_level</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">3</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">1</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">22</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_recovery_zstd_compression_level</code> では、<code class="literal">zstd</code> 圧縮アルゴリズムを使用するグループレプリケーション分散リカバリ接続に使用する圧縮レベルを指定します。 許可されるレベルは 1 から 22 で、大きい値は圧縮レベルの増加を示します。 デフォルトの <code class="literal">zstd</code> 圧縮レベルは 3 です。 <code class="literal">zstd</code> 圧縮を使用しない分散リカバリ接続の場合、この変数は無効です。 
      </p><p>
        詳細は、<a class="xref" href="programs.html#connection-compression-control" title="4.2.8 接続圧縮制御">セクション4.2.8「接続圧縮制御」</a>を参照してください。
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_single_primary_mode"></a>
        <code class="literal">group_replication_single_primary_mode</code>
      </p><a class="indexterm" name="idm45563244119056"></a><a class="indexterm" name="idm45563244117536"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_single_primary_mode"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-single-primary-mode[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_single_primary_mode">group_replication_single_primary_mode</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
        このシステム変数は、グループ全体の構成設定です。 値の変更を有効にするには、すべてのグループメンバーで同じ値を持つ必要があり、グループレプリケーションの実行中は変更できず、グループ (<code class="literal">group_replication_bootstrap_group=ON</code> を使用したサーバーによるブートストラップ) を完全に再起動する必要があります。 MySQL 8.0.16 から、<code class="literal">group_replication_switch_to_single_primary_mode()</code> および <code class="literal">group_replication_switch_to_multi_primary_mode()</code> UDF を使用して、グループの実行中にこのシステム変数の値を変更できます。 詳細は、<a class="xref" href="group-replication.html#group-replication-changing-group-mode" title="18.4.1.2 グループモードの変更">セクション18.4.1.2「グループモードの変更」</a>を参照してください。 
      </p><p>
        <code class="literal">group_replication_single_primary_mode</code> は、読取り/書込みワークロードを処理する単一のサーバーを自動的に選択するようにグループに指示します。 このサーバーは PRIMARY で、その他はすべて SECONDARIES です。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_ssl_mode"></a>
        <code class="literal">group_replication_ssl_mode</code>
      </p><a class="indexterm" name="idm45563244086288"></a><a class="indexterm" name="idm45563244084720"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_ssl_mode"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-ssl-mode=value</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_ssl_mode">group_replication_ssl_mode</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">DISABLED</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">DISABLED</code></p><p class="valid-value"><code class="literal">REQUIRED</code></p><p class="valid-value"><code class="literal">VERIFY_CA</code></p><p class="valid-value"><code class="literal">VERIFY_IDENTITY</code></p></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_ssl_mode</code> は、グループレプリケーションメンバー間のグループ通信接続のセキュリティ状態を設定します。 使用可能な値は次のとおりです: 
      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"> DISABLED </span></dt><dd><p>
              暗号化されていない接続を確立します (デフォルト)。
            </p></dd><dt><span class="term"> REQUIRED </span></dt><dd><p>
              サーバーがセキュアな接続をサポートしている場合は、セキュアな接続を確立します。
            </p></dd><dt><span class="term"> VERIFY_CA </span></dt><dd><p>
              <code class="literal">REQUIRED</code> と似ていますが、さらに、構成された認証局 (CA) 証明書に対してサーバー TLS 証明書を検証します。
            </p></dd><dt><span class="term"> VERIFY_IDENTITY </span></dt><dd><p>
              <code class="literal">VERIFY_CA</code> と似ていますが、さらに、サーバー証明書が接続が試行されるホストと一致することを確認します。
            </p></dd></dl></div><p>
        グループ通信用の SSL の構成の詳細は、<a class="xref" href="group-replication.html#group-replication-secure-socket-layer-support-ssl" title="18.5.2 Secure Socket Layer (SSL) を使用したグループ通信接続の保護">セクション18.5.2「Secure Socket Layer (SSL) を使用したグループ通信接続の保護」</a> を参照してください。
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_start_on_boot"></a>
        <code class="literal">group_replication_start_on_boot</code>
      </p><a class="indexterm" name="idm45563244041632"></a><a class="indexterm" name="idm45563244040048"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_start_on_boot"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-start-on-boot[={OFF|ON}]</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_start_on_boot">group_replication_start_on_boot</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Boolean</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">ON</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_start_on_boot</code> では、サーバーの起動時にグループレプリケーションを自動的に起動するか (<code class="literal">ON</code>) 起動しないか (<code class="literal">OFF</code>) を指定します。 このオプションを <code class="literal">ON</code> に設定すると、リモートクローニング操作を分散リカバリに使用した後、グループレプリケーションが自動的に再起動されます。 
      </p><p>
        サーバーの起動時に Group Replication を自動的に起動するには、<code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントを使用して、分散リカバリのユーザー資格証明をサーバー上のレプリケーションメタデータリポジトリに格納する必要があります。 ユーザー資格証明をメモリーにのみ格納する <code class="literal">START GROUP_REPLICATION</code> ステートメントでユーザー資格証明を指定する場合は、<code class="literal">group_replication_start_on_boot</code> が <code class="literal">OFF</code> に設定されていることを確認します。 


      </p></li><li class="listitem"><p><a name="sysvar_group_replication_tls_source"></a>
        <code class="literal">group_replication_tls_source</code>
      </p><a class="indexterm" name="idm45563244004864"></a><a class="indexterm" name="idm45563244003296"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_tls_source"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-tls-source=value</code></td>
</tr><tr><th>導入</th>
<td>8.0.21</td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_tls_source">group_replication_tls_source</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>列挙</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">mysql_main</code></td>
</tr><tr><th>有効な値</th>
<td><p class="valid-value"><code class="literal">mysql_main</code></p><p class="valid-value"><code class="literal">mysql_admin</code></p></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更できますが、変更はグループメンバーで Group Replication を停止して再起動した後にのみ有効になります。
      </p><p>
        <code class="literal">group_replication_tls_source</code> は、Group Replication の TLS 材料のソースを指定します。
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_transaction_size_limit"></a>
        <code class="literal">group_replication_transaction_size_limit</code>
      </p><a class="indexterm" name="idm45563243970768"></a><a class="indexterm" name="idm45563243969168"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_transaction_size_limit"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-transaction-size-limit=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_transaction_size_limit">group_replication_transaction_size_limit</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">150000000</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">2147483647</code></td>
</tr></tbody></table></div><p>
        このシステム変数は、すべてのグループメンバーで同じ値を持つ必要があります。 このシステム変数の値は、Group Replication の実行中に変更できます。 変更はグループメンバーに対して即時に有効になり、そのメンバーで開始された次のトランザクションから適用されます。 このプロセス中、システム変数の値はグループメンバー間で異なってもかまいませんが、一部のトランザクションは拒否される可能性があります。 
      </p><p>
        <code class="literal">group_replication_transaction_size_limit</code> は、レプリケーショングループが受け入れる最大トランザクションサイズをバイト単位で構成します。 このサイズより大きいトランザクションは受信側メンバーによってロールバックされ、グループにブロードキャストされません。 大規模なトランザクションでは、システムの速度が低下する原因となる可能性のあるメモリー割当て、または大規模なトランザクションの処理がビジー状態であるためにメンバーに障害が発生した疑いがあるネットワーク帯域幅消費の観点から、レプリケーショングループの問題が発生する可能性があります。 
      </p><p>
        このシステム変数が 0 に設定されている場合、グループが受け入れるトランザクションのサイズに制限はありません。 MySQL 8.0 からは、このシステム変数のデフォルト設定は 150000000 バイト (約 143 MB) です。 トランザクションの処理にかかる時間はそのサイズに比例することに注意して、グループが許容する必要がある最大メッセージサイズに応じて、このシステム変数の値を調整します。 <code class="literal">group_replication_transaction_size_limit</code> の値は、すべてのグループメンバーで同じである必要があります。 大規模トランザクションの軽減戦略の詳細は、<a class="xref" href="group-replication.html#group-replication-limitations" title="18.9.2 グループレプリケーションの制限事項">セクション18.9.2「グループレプリケーションの制限事項」</a> を参照してください。 
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_unreachable_majority_timeout"></a>
        <code class="literal">group_replication_unreachable_majority_timeout</code>
      </p><a class="indexterm" name="idm45563243932880"></a><a class="indexterm" name="idm45563243931728"></a><div class="informaltable"><table frame="box" rules="all" summary="Properties for group_replication_unreachable_majority_timeout"><col style="width: 30%"><col style="width: 70%"><tbody><tr><th>コマンド行形式</th>
<td><code class="literal">--group-replication-unreachable-majority-timeout=#</code></td>
</tr><tr><th>システム変数</th>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_unreachable_majority_timeout">group_replication_unreachable_majority_timeout</a></code></td>
</tr><tr><th>スコープ</th>
<td>グローバル</td>
</tr><tr><th>動的</th>
<td>はい</td>
</tr><tr><th><code class="literal">SET_VAR</code> ヒントの適用</th>
<td>いいえ</td>
</tr><tr><th>型</th>
<td>Integer</td>
</tr><tr><th>デフォルト値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最小値</th>
<td><code class="literal">0</code></td>
</tr><tr><th>最大値</th>
<td><code class="literal">31536000</code></td>
</tr></tbody></table></div><p>
        このシステム変数の値は、Group Replication の実行中に変更でき、変更はただちに有効になります。 システム変数の現在の値は、動作が必要であることを意味する問題が発生したときに読み取られます。 
      </p><p>
        <code class="literal">group_replication_unreachable_majority_timeout</code> では、ネットワークパーティションが不足し、大部分のメンバーがグループを離れるまで待機できないメンバーの秒数を指定します。 5 つのサーバー (S1、S2、S3、S4、S5) のグループでは、(S1、S2) と (S3、S4、S5) の間に切断がある場合、ネットワークパーティションがあります。 最初のグループ (S1、S2) は、半分を超えるグループにコンタクトできないため、少数民族になりました。 大多数のグループ (S3、S4、S5) が実行されている間、少数民族グループはネットワークの再接続を指定された時間待機します。 このシナリオの詳細は、<a class="xref" href="group-replication.html#group-replication-network-partitioning" title="18.4.4 ネットワークパーティション化">セクション18.4.4「ネットワークパーティション化」</a> を参照してください。 
      </p><p>
        デフォルトでは、<code class="literal">group_replication_unreachable_majority_timeout</code> は 0 に設定されています。これは、ネットワークパーティションのために少数民族で自身を検索するメンバーが、グループから離れるまで永久に待機することを意味します。 タイムアウトを設定した場合、指定した時間が経過すると、その少数民族によって処理されたすべての保留中のトランザクションがロールバックされ、少数パーティション内のサーバーは <code class="literal">ERROR</code> 状態に移行します。 メンバーの <code class="literal">group_replication_autorejoin_tries</code> システム変数が自動再結合の試行回数を指定するように設定されている場合、スーパー読取り専用モードでは、指定された回数だけグループへの再結合が試行されます。 メンバーに自動再結合の試行が指定されていない場合、または指定された試行回数を使い果たした場合は、システム変数 <code class="literal">group_replication_exit_state_action</code> で指定されたアクションに従います。 
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          対称グループがあり、たとえば (S0、S2) のメンバーが 2 つのみで、ネットワークパーティションがあり、大部分がない場合、構成されたタイムアウトの後、すべてのメンバーが <code class="literal">ERROR</code> 状態になります。
        </p></div><p>
        このオプションの使用方法の詳細は、<a class="xref" href="group-replication.html#group-replication-responses-failure-partition" title="18.6.6.2 使用できない大多数のタイムアウト">セクション18.6.6.2「使用できない大多数のタイムアウト」</a> を参照してください。
      </p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-status-variables"></a>グループのレプリケーションステータス変数</h3></div></div></div><p>
      このセクションでは、グループレプリケーションに関する情報を提供する status 変数について説明します。 変数の意味は次のとおりです: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">group_replication_primary_member</code>
        </p><p>
          グループがシングルプライマリモードで動作している場合、プライマリメンバー UUID を表示します。 グループがマルチプライマリモードで動作している場合は、空の文字列が表示されます。 
        </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
            <code class="literal">group_replication_primary_member</code> ステータス変数は非推奨になり、将来のバージョンで削除される予定です。
          </p></div><p>
          <a class="xref" href="group-replication.html#group-replication-find-primary" title="18.1.3.1.2 プライマリの検索">セクション18.1.3.1.2「プライマリの検索」</a>を参照してください。
        </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="group-replication-requirements-and-limitations"></a>18.9 要件と制限事項</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-requirements">18.9.1 グループレプリケーションの要件</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-limitations">18.9.2 グループレプリケーションの制限事項</a></span></dt></dl></div><a class="indexterm" name="idm45563243881216"></a><p>
    このセクションでは、グループレプリケーションの要件および制限事項をリストし、説明します。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-requirements"></a>18.9.1 グループレプリケーションの要件</h3></div></div></div><a class="indexterm" name="idm45563243877552"></a><p>
      グループレプリケーションに使用するサーバーインスタンスは、次の要件を満たす必要があります。
    </p><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-infrastructure"></a>インフラストラクチャ</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>InnoDB ストレージエンジン. </b>
              データは、<code class="literal">InnoDB</code> トランザクションストレージエンジンに格納する必要があります。 トランザクションはオプティミスティックに実行され、コミット時に競合がないかチェックされます。 競合がある場合、グループ間の一貫性を維持するために、一部のトランザクションがロールバックされます。 つまり、トランザクションストレージエンジンが必要です。 さらに、<code class="literal">InnoDB</code> には、グループレプリケーションと連携して動作する場合の競合の管理および処理を向上させる追加機能がいくつか用意されています。 一時的な <code class="literal">MEMORY</code> ストレージエンジンを含むほかのストレージエンジンを使用すると、Group Replication でエラーが発生する可能性があります。 グループメンバーに <code class="literal">disabled_storage_engines</code> システム変数を設定することで、ほかのストレージエンジンの使用を防止できます。次に例を示します: 
            </p><pre class="programlisting">disabled_storage_engines="MyISAM,BLACKHOLE,FEDERATED,ARCHIVE,MEMORY"
</pre></li><li class="listitem"><p><b>主キー. </b>
              グループによってレプリケートされるすべてのテーブルには、定義済の主キー、または同等の主キー (同等のものが NULL 以外の一意キー) が必要です。 このようなキーは、テーブル内のすべての行の一意の識別子として必要です。これにより、各トランザクションが変更された行を正確に識別することで、競合するトランザクションをシステムで判別できます。 Group Replication には、主キーまたは主キーに相当するチェックの独自の組込みセットがあり、<code class="literal">sql_require_primary_key</code> システム変数によって実行されるチェックは使用されません。 Group Replication が実行されているサーバーインスタンスに対して <code class="literal">sql_require_primary_key=ON</code> を設定でき、Group Replication チャネルに対して <code class="literal">CHANGE REPLICATION SOURCE TO</code>|<code class="literal">CHANGE MASTER TO</code> ステートメントの <code class="literal">REQUIRE_TABLE_PRIMARY_KEY_CHECK</code> オプションを <code class="literal">ON</code> に設定できます。 ただし、グループレプリケーションの組込みチェックで許可されている一部のトランザクションは、<code class="literal">sql_require_primary_key=ON</code> または <code class="literal">REQUIRE_TABLE_PRIMARY_KEY_CHECK=ON</code> の設定時に実行されるチェックでは許可されない場合があることに注意してください。 
            </p></li><li class="listitem"><p><b>ネットワークパフォーマンス. </b>
              MySQL Group Replication は、サーバーインスタンスが相互に非常に近いクラスタ環境にデプロイされるように設計されています。 グループのパフォーマンスと安定性は、ネットワーク待機時間とネットワーク帯域幅の両方の影響を受ける可能性があります。 双方向通信は、すべてのグループメンバー間で常に維持する必要があります。 インバウンド通信またはアウトバウンド通信のいずれかがサーバーインスタンスでブロックされている場合 (ファイアウォールや接続の問題など)、メンバーはグループ内で機能できず、グループメンバー (問題のあるメンバーを含む) は影響を受けるサーバーインスタンスの正しいメンバーステータスをレポートできない可能性があります。 
            </p><p>
            MySQL 8.0.14 からは、リモートグループレプリケーションサーバー間の TCP 通信に IPv4 または IPv6 ネットワークインフラストラクチャを使用することも、これらの組合せを使用することもできます。 また、グループレプリケーションが仮想プライベートネットワーク (VPN) 上で動作しなくなることもありません。 
          </p><p>
            また、グループレプリケーションサーバーインスタンスが同じ場所に配置され、ローカルグループ通信エンジン (XCom) インスタンスを共有する MySQL 8.0.14 から、TCP ソケットではなく可能なかぎり、通信にオーバーヘッドの低い専用の入力チャネルが使用されます。 グループへの参加など、リモートの XCom インスタンス間の通信を必要とする特定のグループレプリケーションタスクでは、TCP ネットワークが引き続き使用されるため、ネットワークパフォーマンスがグループのパフォーマンスに影響します。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-configuration"></a>サーバーインスタンス構成</h4></div></div></div><p>
        次のオプションは、グループのメンバーであるサーバーインスタンスに表示されるように構成する必要があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>一意のサーバー識別子. </b>
              レプリケーショントポロジのすべてのサーバーで必要に応じて、<code class="literal">server_id</code> システム変数を使用して一意のサーバー ID でサーバーを構成します。 サーバー ID は、1 から (2 <sup>32</sup>)−1 までの正の整数である必要があり、レプリケーショントポロジ内の他のサーバーで使用されている他のすべてのサーバー ID とは異なる必要があります。 
            </p></li><li class="listitem"><p><b>バイナリログアクティブ. </b>
              <code class="literal">--log-bin[=log_file_name]</code>を設定します。 MySQL Group Replication はバイナリログの内容をレプリケートするため、バイナリログを操作するにはバイナリログがオンになっている必要があります。 このオプションはデフォルトで有効となっています。 <a class="xref" href="server-administration.html#binary-log" title="5.4.4 バイナリログ">セクション5.4.4「バイナリログ」</a>を参照してください。 
            </p></li><li class="listitem"><p><b>記録されたレプリカ更新. </b>
              <code class="literal">--log-slave-updates</code> を設定します。 このオプションはデフォルトで有効となっています。 グループメンバーは、参加時にドナーから受信し、レプリケーションアプライアンスを介して適用されるトランザクションをログに記録し、グループから受信して適用するすべてのトランザクションをログに記録する必要があります。 これにより、グループレプリケーションは、既存のグループメンバーバイナリログから状態転送による分散リカバリを実行できます。 
            </p></li><li class="listitem"><p><b>バイナリログ行の形式. </b>
              <code class="literal">--binlog-format=row</code> を設定します。 グループレプリケーションは、行ベースのレプリケーション形式に依存して、グループ内のサーバー間で一貫して変更を伝播します。 グループ内の異なるサーバーで同時に実行されるトランザクション間の競合を検出するために必要な情報を抽出できるように、行ベースのインフラストラクチャに依存します。 MySQL 8.0.19 から、<code class="literal">REQUIRE_ROW_FORMAT</code> 設定がグループレプリケーションチャネルに自動的に追加され、トランザクションの適用時に行ベースのレプリケーションの使用が強制されます。 <a class="xref" href="replication.html#replication-formats" title="17.2.1 レプリケーション形式">セクション17.2.1「レプリケーション形式」</a> および <a class="xref" href="replication.html#replication-privilege-checks" title="17.3.3 レプリケーション権限チェック">セクション17.3.3「レプリケーション権限チェック」</a> を参照してください。 
            </p></li><li class="listitem"><p><b>バイナリログチェックサムオフ (MySQL 8.0.20). </b>
              MySQL 8.0.20 まで、およびそれを含めて、<code class="literal">--binlog-checksum=NONE</code> を設定します。 これらのリリースでは、Group Replication はチェックサムを使用できず、バイナリログ内でのチェックサムの存在をサポートしていません。 MySQL 8.0.21 からは、グループレプリケーションでチェックサムがサポートされるため、グループメンバーはデフォルト設定を使用できます。 
            </p></li><li class="listitem"><p><b>グローバルトランザクション識別子オン. </b>
              <code class="literal">gtid_mode=ON</code> および <code class="literal">enforce_gtid_consistency=ON</code> を設定します。 グループレプリケーションでは、グローバルトランザクション識別子を使用して、すべてのサーバーインスタンスでコミットされたトランザクションを正確に追跡するため、すでにコミットされているトランザクションと競合する可能性のあるトランザクションを実行したサーバーを推測できます。 つまり、明示的なトランザクション識別子は、競合する可能性のあるトランザクションを判別できるフレームワークの基本的な部分です。 <a class="xref" href="replication.html#replication-gtids" title="17.1.3 グローバルトランザクション識別子を使用したレプリケーション">セクション17.1.3「グローバルトランザクション識別子を使用したレプリケーション」</a>を参照してください。 
            </p></li><li class="listitem"><p><b>レプリケーション情報リポジトリ. </b>
              <code class="literal">master_info_repository=TABLE</code> および <code class="literal">relay_log_info_repository=TABLE</code> を設定します。 MySQL 8.0 では、この設定はデフォルトであり、<code class="literal">FILE</code> 設定は非推奨です。 MySQL 8.0.23 では、これらのシステム変数の使用は非推奨であるため、システム変数を省略してデフォルトをそのまま使用します。 Group Replication プラグインがレプリケーションメタデータの一貫したリカバリ可能性とトランザクション管理を持つように、レプリケーションアプライアンスは <code class="literal">mysql.slave_master_info</code> および <code class="literal">mysql.slave_relay_log_info</code> システムテーブルにレプリケーションメタデータを書き込む必要があります。 <a class="xref" href="replication.html#replica-logs-status" title="17.2.4.2 レプリケーションメタデータリポジトリ">セクション17.2.4.2「レプリケーションメタデータリポジトリ」</a>を参照してください。 
            </p></li><li class="listitem"><p><b>トランザクション書込みセット抽出. </b>
              行を収集してバイナリログに記録するときに、サーバーが書き込みセットも収集するように <code class="literal">--transaction-write-set-extraction=XXHASH64</code> を設定します。 書込みセットは各行の主キーに基づいており、変更された行を一意に識別するタグの簡略化されたコンパクトなビューです。 このタグは、競合の検出に使用されます。 このオプションはデフォルトで有効となっています。 
            </p></li><li class="listitem"><p><b>バイナリログの依存性トラッキング. </b>
              <code class="literal">binlog_transaction_dependency_tracking=WRITESET_SESSION</code> を設定すると、グループワークロードに応じて、グループメンバーのパフォーマンスを向上させることができます。 Group Replication は、<code class="literal">binlog_transaction_dependency_tracking</code> に設定された値とは関係なく、リレーログからトランザクションを適用するときに、証明後に独自のパラレル化を実行します。 ただし、<code class="literal">binlog_transaction_dependency_tracking</code> の値は、グループレプリケーションメンバーのバイナリログへのトランザクションの書込み方法に影響します。 これらのログ内の依存関係情報は、メンバーがグループに参加または再参加するたびに発生する分散リカバリのドナーバイナリログからの状態転送プロセスを支援するために使用されます。 
            </p></li><li class="listitem"><p><b>デフォルトのテーブル暗号化. </b>
              すべてのグループメンバーで <code class="literal">--default-table-encryption</code> を同じ値に設定します。 デフォルトのスキーマおよびテーブルスペースの暗号化は、設定がすべてのメンバーで同じであるかぎり、有効 (<code class="literal">ON</code>) または無効 (<code class="literal">OFF</code>、デフォルト) のいずれかにできます。 
            </p></li><li class="listitem"><p><b>小文字のテーブル名. </b>
              すべてのグループメンバーで <code class="literal">--lower-case-table-names</code> を同じ値に設定します。 グループレプリケーションに必要な <code class="literal">InnoDB</code> ストレージエンジンを使用するには、1 の設定が適切です。 この設定は、すべてのプラットフォームでデフォルトであるわけではありません。 
            </p></li><li class="listitem"><p><b>マルチスレッドアプライアンス. </b>

              グループレプリケーションメンバーはマルチスレッドレプリカとして構成できるため、トランザクションをパラレルに適用できます。 <code class="literal">slave_parallel_workers</code> にゼロ以外の値を指定すると、メンバーのマルチスレッドアプライアンスが有効になり、最大 1024 のパラレルアプライヤスレッドを指定できます。 <code class="literal">slave_preserve_commit_order=1</code> を設定すると、パラレルトランザクションの最終コミットは、グループレプリケーションに必要な元のトランザクションと同じ順序で行われます。これは、すべての参加メンバーがコミットされたトランザクションを同じ順序で受信および適用することを保証するために構築された一貫性メカニズムに依存します。 最後に、レプリカでパラレルに実行できるトランザクションを決定するために使用されるポリシーを指定する <code class="literal">slave_parallel_type=LOGICAL_CLOCK</code> の設定が、<code class="literal">slave_preserve_commit_order=1</code> で必要です。 


              <code class="literal">slave_parallel_workers=0</code> を設定すると、パラレル実行が無効になり、レプリカに単一のアプライヤスレッドが付与され、コーディネータスレッドは付与されません。 この設定では、<code class="literal">slave_parallel_type</code> および <code class="literal">slave_preserve_commit_order</code> オプションは効果がなく、無視されます。 
            </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-limitations"></a>18.9.2 グループレプリケーションの制限事項</h3></div></div></div><a class="indexterm" name="idm45563243783600"></a><p>
      グループレプリケーションには、次の既知の制限事項があります。 マルチプライマリモードグループについて説明されている制限事項と問題は、フェイルオーバーイベント中にシングルプライマリモードクラスタにも適用できますが、新しく選択されたプライマリは古いプライマリからアプライヤキューをフラッシュします。 
    </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">ヒント</div><p>
        グループレプリケーションは GTID ベースのレプリケーション上に構築されるため、<a class="xref" href="replication.html#replication-gtids-restrictions" title="17.1.3.7 GTID ベースレプリケーションの制約">セクション17.1.3.7「GTID ベースレプリケーションの制約」</a> にも注意する必要があります。
      </p></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b><code class="literal">--upgrade=MINIMAL</code> オプション. </b>
            レプリケーション内部が依存するシステムテーブルをアップグレードしない MINIMAL オプション (<code class="literal">--upgrade=MINIMAL</code>) を使用する MySQL Server のアップグレード後は、グループレプリケーションを開始できません。
          </p></li><li class="listitem"><p><b>ギャップロック. </b>
            ギャップロックに関する情報は <code class="literal">InnoDB</code> の外部では使用できないため、同時トランザクションのグループレプリケーション動作保証プロセスでは <a class="link" href="glossary.html#glos_gap_lock" title="ギャップロック">gap locks</a> は考慮されません。 詳しくは<a class="xref" href="innodb-storage-engine.html#innodb-gap-locks" title="ギャップロック">ギャップロック</a>をご覧ください。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            マルチプライマリモードのグループの場合、アプリケーションで <code class="literal">REPEATABLE READ</code> セマンティクスに依存しないかぎり、グループレプリケーションで <code class="literal">READ COMMITTED</code> 分離レベルを使用することをお薦めします。 InnoDB では、<code class="literal">READ COMMITTED</code> のギャップロックは使用されません。これにより、InnoDB 内のローカル競合検出が、グループレプリケーションによって実行される分散競合検出に位置合せされます。 シングルプライマリモードのグループの場合、プライマリのみが書込みを受け入れるため、<code class="literal">READ COMMITTED</code> 分離レベルはグループレプリケーションにとって重要ではありません。 
          </p></div></li><li class="listitem"><p><b>テーブルロックおよび名前付きロック. </b>
            証明プロセスでは、テーブルロック (<a class="xref" href="sql-statements.html#lock-tables" title="13.3.6 LOCK TABLES および UNLOCK TABLES ステートメント">セクション13.3.6「LOCK TABLES および UNLOCK TABLES ステートメント」</a> を参照) または名前付きロック (<code class="literal">GET_LOCK()</code> を参照) は考慮されません。
          </p></li><li class="listitem"><p><b>バイナリログチェックサム. </b>
            MySQL 8.0.20 まで、グループレプリケーションはチェックサムを使用できず、バイナリログでのチェックサムの存在をサポートしないため、サーバーインスタンスがグループメンバーになるように構成するときに <code class="literal">binlog_checksum=NONE</code> を設定する必要があります。 MySQL 8.0.21 からは、グループレプリケーションでチェックサムがサポートされるため、グループメンバーはデフォルト設定の <code class="literal">binlog_checksum=CRC32</code> を使用できます。 <code class="literal">binlog_checksum</code> の設定は、グループのすべてのメンバーで同じである必要はありません。 
          </p><p>
          チェックサムが使用可能な場合、Group Replication はそれらを使用して <code class="literal">group_replication_applier</code> チャネル上の着信イベントを検証しません。これは、イベントが複数のソースからそのリレーログに書き込まれ、実際に元のサーバーのバイナリログに書き込まれる前 (チェックサムが生成されるとき) であるためです。 チェックサムは、<code class="literal">group_replication_recovery</code> チャネルおよびグループメンバー上の他のレプリケーションチャネルでイベントの整合性を検証するために使用されます。 
        </p></li><li class="listitem"><p><b>SERIALIZABLE 分離レベル. </b>
            <code class="literal">SERIALIZABLE</code> 分離レベルは、マルチプライマリグループではデフォルトでサポートされていません。 トランザクション分離レベルを <code class="literal">SERIALIZABLE</code> に設定すると、トランザクションのコミットを拒否するようにグループレプリケーションが構成されます。 
          </p></li><li class="listitem"><p><b>同時 DDL 操作と DML 操作. </b>
            マルチプライマリモードを使用している場合、同じオブジェクトに対して実行されるが異なるサーバーで実行される同時データ定義ステートメントおよびデータ操作ステートメントはサポートされません。 オブジェクトに対するデータ定義言語 (DDL) ステートメントの実行中に、同じオブジェクトで異なるサーバーインスタンスで同時データ操作言語 (DML) を実行すると、異なるインスタンスで競合する DDL が検出されないリスクがあります。 
          </p></li><li class="listitem"><p><b>カスケード制約のある外部キー. </b>
            マルチプライマリモードグループ (すべて <code class="literal">group_replication_single_primary_mode=OFF</code> で構成されたメンバー) は、マルチレベルの外部キー依存性を持つテーブル (特に <code class="literal">CASCADING</code> <a class="link" href="glossary.html#glos_foreign_key_constraint" title="FOREIGN KEY 制約">foreign key constraints</a> を定義したテーブル) をサポートしていません。 これは、マルチプライマリモードグループによってカスケード操作が実行される外部キー制約により、競合が検出されず、グループのメンバー間でデータの一貫性がなくなる可能性があるためです。 したがって、検出されない競合を回避するために、マルチプライマリモードグループで使用されるサーバーインスタンスに <code class="literal">group_replication_enforce_update_everywhere_checks=ON</code> を設定することをお薦めします。 
          </p><p>
          シングルプライマリモードでは、グループの複数のメンバーへの同時書込みが許可されないため、これは問題ではありません。したがって、検出されない競合のリスクはありません。
        </p></li><li class="listitem"><p><b>マルチプライマリモードのデッドロック. </b>
            グループがマルチプライマリモードで動作している場合、<code class="literal">SELECT .. FOR UPDATE</code> ステートメントによってデッドロックが発生する可能性があります。 これは、ロックがグループのメンバー間で共有されていないため、このようなステートメントの期待に到達しない可能性があるためです。 
          </p></li><li class="listitem"><p><b>レプリケーションフィルタ. </b>
            グループレプリケーション用に構成された MySQL サーバーインスタンスでは、グローバルレプリケーションフィルタを使用できません。これは、一部のサーバーでトランザクションをフィルタすると、グループが一貫性のある状態で承諾に到達できなくなるためです。 グループメンバーがグループ外のソースへのレプリカとしても機能する場合など、グループレプリケーションに直接関与しないレプリケーションチャネルでチャネル固有のレプリケーションフィルタを使用できます。 <code class="literal">group_replication_applier</code> または <code class="literal">group_replication_recovery</code> チャネルでは使用できません。 
          </p></li><li class="listitem"><p><b>暗号化接続. </b>
            TLSv1.3 プロトコルのサポートは、MySQL 8.0.16 の MySQL Server で使用できます (MySQL が OpenSSL 1.1.1 以上を使用してコンパイルされている場合)。 MySQL 8.0.16 および MySQL 8.0.17 では、サーバーが TLSv1.3 をサポートしている場合、プロトコルはグループ通信エンジンではサポートされず、Group Replication では使用できません。 グループレプリケーションでは、MySQL 8.0.18 からの TLSv1.3 がサポートされており、グループ通信接続および分散リカバリ接続に使用できます。 
          </p><p>
          MySQL 8.0.18 では、TLSv1.3 を分散リカバリ接続のグループレプリケーションで使用できますが、<code class="literal">group_replication_recovery_tls_version</code> および <code class="literal">group_replication_recovery_tls_ciphersuites</code> システム変数は使用できません。 したがって、ドナーサーバーでは、<a class="xref" href="security.html#encrypted-connection-protocols-ciphers" title="6.3.2 暗号化された接続 TLS プロトコルおよび暗号">セクション6.3.2「暗号化された接続 TLS プロトコルおよび暗号」</a> にリストされているように、デフォルトで有効になっている TLSv1.3 暗号スイートを少なくとも 1 つ使用できる必要があります。 MySQL 8.0.19 から、オプションを使用して、必要に応じてデフォルト以外の暗号スイートのみを含む任意の暗号スイートのクライアントサポートを構成できます。 
        </p></li><li class="listitem"><p><b>クローニング操作. </b>
            グループレプリケーションは分散リカバリのクローニング操作を開始および管理しますが、クローニングをサポートするように設定されているグループメンバーは、ユーザーが手動で開始するクローニング操作にも関与する場合があります。 MySQL 8.0.20 より前のリリースでは、操作にグループレプリケーションが実行されているグループメンバーが含まれる場合、クローニング操作を手動で開始することはできません。 クローニング操作で受信者のデータが削除および置換されない場合は、MySQL 8.0.20 からこれを実行できます。 したがって、Group Replication が実行されている場合は、クローニング操作を開始するステートメントに <code class="literal">DATA DIRECTORY</code> 句を含める必要があります。 <a class="xref" href="group-replication.html#group-replication-cloning-manual" title="18.4.3.2.4 その他の目的でのクローニング">セクション18.4.3.2.4「その他の目的でのクローニング」</a>を参照してください。 
          </p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="idm45563243719824"></a>グループサイズの制限</h4></div></div></div><p>
        単一のレプリケーショングループのメンバーにできる MySQL サーバーの最大数は 9 です。 さらにメンバーがグループに参加しようとすると、そのリクエストは拒否されます。 この制限は、安定したローカルエリアネットワーク上でグループが確実に実行される安全な境界としてのテストおよびベンチマークから特定されています。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-limitations-transaction-size"></a>トランザクションサイズの制限</h4></div></div></div><p>
        個々のトランザクションの結果、5 秒以内にメッセージをネットワーク上のグループメンバー間でコピーできない十分な大きさのメッセージコンテンツが生成された場合、メンバーはトランザクションの処理にビジー状態であるため、失敗した疑いがあります。 また、トランザクションが大きいと、メモリー割当ての問題が原因でシステムが遅くなる可能性があります。 これらの問題を回避するには、次の軽減策を使用します: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            大量のメッセージが原因で不要な削除が発生した場合は、システム変数 <code class="literal">group_replication_member_expel_timeout</code> を使用して、失敗した疑いがあるメンバーが削除されるまでの追加時間を許可します。 疑わしいメンバーがグループから削除されるまで、最初の 5 秒間の検出期間の 1 時間以内に許可できます。 MySQL 8.0.21 からは、デフォルトで追加の 5 秒が許可されます。 
          </p></li><li class="listitem"><p>
            可能な場合は、グループレプリケーションによって処理される前に、トランザクションのサイズを試行して制限してください。 たとえば、<code class="literal">LOAD DATA</code> で使用されるファイルを小さいチャンクに分割します。 
          </p></li><li class="listitem"><p>
            システム変数 <code class="literal">group_replication_transaction_size_limit</code> を使用して、グループが受け入れる最大トランザクションサイズを指定します。 MySQL 8.0 では、このシステム変数はデフォルトで 150000000 バイト (約 143 MB) の最大トランザクションサイズに設定されます。 このサイズを超えるトランザクションはロールバックされ、グループへの配布のために Group Replication Group Communication System (GCS) に送信されません。 トランザクションの処理にかかる時間はそのサイズに比例することに注意して、グループが許容する必要がある最大メッセージサイズに応じて、この変数の値を調整します。 
          </p></li><li class="listitem"><p>
            システム変数 <code class="literal">group_replication_compression_threshold</code> を使用して、圧縮が適用されるメッセージサイズを指定します。 このシステム変数のデフォルトは 1000000 バイト (1 MB) であるため、大きなメッセージは自動的に圧縮されます。 圧縮は、<code class="literal">group_replication_transaction_size_limit</code> 設定で許可されたが <code class="literal">group_replication_compression_threshold</code> 設定を超えたメッセージを受信したときに、Group Replication Group Communication System (GCS) によって実行されます。 詳細は、<a class="xref" href="group-replication.html#group-replication-message-compression" title="18.6.3 メッセージ圧縮">セクション18.6.3「メッセージ圧縮」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            システム変数 <code class="literal">group_replication_communication_max_message_size</code> を使用して、メッセージが断片化されるメッセージサイズを指定します。 このシステム変数のデフォルトは 10485760 バイト (10 MiB) であるため、大きなメッセージは自動的に断片化されます。 GCS は、圧縮されたメッセージが <code class="literal">group_replication_communication_max_message_size</code> 制限を超えたままである場合、圧縮後に断片化を実行します。 レプリケーショングループで断片化を使用するには、すべてのグループメンバーが MySQL 8.0.16 以上であり、グループで使用されている Group Replication 通信プロトコルバージョンで断片化が許可されている必要があります。 詳細は、<a class="xref" href="group-replication.html#group-replication-performance-message-fragmentation" title="18.6.4 メッセージの断片化">セクション18.6.4「メッセージの断片化」</a>を参照してください。 
          </p></li></ul></div><p>
        関連するシステム変数にゼロ値を指定すると、最大トランザクションサイズ、メッセージ圧縮およびメッセージの断片化をすべて非アクティブ化できます。 これらすべての保護を非アクティブ化した場合、レプリケーショングループのメンバーの適用者スレッドで処理できるメッセージの上限サイズは、デフォルト値および最大値 1073741824 バイト (1 GB) のメンバー <code class="literal">slave_max_allowed_packet</code> システム変数の値です。 この制限を超えるメッセージは、受信側メンバーが処理しようとすると失敗します。 グループメンバーが送信できるメッセージの上限サイズは 4294967295 バイト (約 4 GB) です。 これは、GCS が処理した後にメッセージを受信するグループレプリケーション (XCom、Paxos バリアント) のためにグループ通信エンジンによって受け入れられるパケットサイズの強い制限です。 この制限を超えるメッセージは、元のメンバーがブロードキャストしようとすると失敗します。 
      </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="group-replication-frequently-asked-questions"></a>18.10 よくある質問</h2></div></div></div><a class="indexterm" name="idm45563243691904"></a><p>
    このセクションでは、よくある質問への回答を示します。
  </p><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-maximum-number-servers"></a>グループ内の MySQL サーバーの最大数はいくつですか。</h3></div></div></div><p>
      グループは、最大 9 台のサーバーで構成できます。 9 つのメンバーを持つグループに別のサーバーを追加しようとすると、リクエストは拒否されます。 この制限は、安定したローカルエリアネットワーク上でグループが確実に実行される安全な境界としてのテストおよびベンチマークから特定されています。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-servers-in-a-group-connected"></a>グループ内のサーバーはどのように接続されていますか。</h3></div></div></div><p>
      グループ内のサーバーは、ピアツーピア TCP 接続を開いてグループ内の他のサーバーに接続します。 これらの接続は、グループ内のサーバー間の内部通信およびメッセージの受渡しにのみ使用されます。 このアドレスは、<code class="literal">group_replication_local_address</code> 変数によって構成されます。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-what-is-the-group-replication-bootstrap-group-option-used-for"></a>group_replication_bootstrap_group オプションは何に使用されますか。</h3></div></div></div><p>
      ブートストラップフラグは、メンバーにグループを <span class="emphasis"><em>create</em></span> に指示し、初期シードサーバーとして機能します。 グループに参加する 2 つ目のメンバーは、グループに追加するために構成を動的に変更するようにグループをブートストラップしたメンバーに依頼する必要があります。 
    </p><p>
      メンバーは、2 つのシナリオでグループをブートストラップする必要があります。 グループが最初に作成されたとき、またはグループ全体を停止して再起動したとき。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-credentials-for-recovery"></a>分散リカバリプロセスの資格証明を設定するにはどうすればよいですか。</h3></div></div></div><p>
      ユーザー資格証明は、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23 の場合) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 の場合) を使用して、<code class="literal">group_replication_recovery</code> チャネルの資格証明として永続的に設定できます。 または、MySQL 8.0.21 から、グループレプリケーションが開始されるたびに <code class="literal">START GROUP_REPLICATION</code> ステートメントで指定できます。 
    </p><p>
      <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> を使用して設定されたユーザー資格証明は、サーバー上のレプリケーションメタデータリポジトリにプレーンテキストで格納されますが、<code class="literal">START GROUP_REPLICATION</code> で指定されたユーザー資格証明はメモリーにのみ保存され、<code class="literal">STOP GROUP_REPLICATION</code> ステートメントまたはサーバーの停止によって削除されます。 したがって、<code class="literal">START GROUP_REPLICATION</code> を使用してユーザー資格証明を指定すると、不正なアクセスからグループレプリケーションサーバーを保護するのに役立ちます。 ただし、この方法は、<code class="literal">group_replication_start_on_boot</code> システム変数で指定された Group Replication の自動起動とは互換性がありません。 詳細は、<a class="xref" href="group-replication.html#group-replication-secure-user" title="18.5.3.1 分散リカバリのためのセキュアなユーザー資格証明">セクション18.5.3.1「分散リカバリのためのセキュアなユーザー資格証明」</a>を参照してください。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-scale-out-write-load"></a>グループレプリケーションを使用して書込みロードをスケールアウトできますか。</h3></div></div></div><p>
      直接ではありませんが、MySQL Group レプリケーションは、グループ内のすべてのサーバーが同じ量のデータをレプリケートする、何も共有しない完全レプリケーションソリューションです。 したがって、トランザクションのコミット操作の結果として、グループ内のあるメンバーが N バイトをストレージに書き込む場合、トランザクションはどこにでもレプリケートされるため、他のメンバーのストレージにも約 N バイトが書き込まれます。 
    </p><p>
      ただし、最初にトランザクションを実行したときに元のメンバーが実行する必要があったのと同じ量の処理を他のメンバーが実行する必要がない場合は、変更がより高速に適用されます。 トランザクションは、行変換の適用にのみ使用される形式でレプリケートされ、トランザクションを再実行する必要はありません (行ベースの形式)。 
    </p><p>
      さらに、変更が行ベースの形式で伝播および適用される場合、それらは最適化されたコンパクトな形式で受信され、元のメンバーと比較して必要な IO 操作の数が削減される可能性があります。
    </p><p>
      要約すると、競合のないトランザクションをグループ内の様々なメンバーに分散することで、処理をスケールアウトできます。 また、リモートサーバーは安定したストレージへの読取り/変更/書込み変更に必要な変更のみを受信するため、IO 操作のごく一部をスケールアウトできます。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-performance-compared"></a>グループレプリケーションでは、単純なレプリケーションと比較して、同じワークロードでより多くのネットワーク帯域幅と CPU が必要ですか。</h3></div></div></div><p>
      同期化のためにサーバーが相互に常に相互作用する必要があるため、追加のロードが必要になります。 これ以上のデータ量を定量化することは困難です。 また、グループのサイズによっても異なります (3 台のサーバは、グループ内の 9 台のサーバよりも帯域幅要件に応力を軽減します)。 
    </p><p>
      また、サーバー同期部分およびグループメッセージングではより複雑な作業が行われるため、メモリーおよび CPU フットプリントも大きくなります。
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-deploy-across-wide-area-network"></a>広域ネットワーク間でグループレプリケーションをデプロイできますか。</h3></div></div></div><p>
      はい。ただし、各メンバー間のネットワーク接続は信頼性が高く、適切なパフォーマンスを備えている必要があります。 最適なパフォーマンスを得るには、低レイテンシで高帯域幅のネットワーク接続が必要です。 
    </p><p>
      ネットワーク帯域幅のみに問題がある場合、<a class="xref" href="group-replication.html#group-replication-message-compression" title="18.6.3 メッセージ圧縮">セクション18.6.3「メッセージ圧縮」</a> を使用して必要な帯域幅を減らすことができます。 ただし、ネットワークがパケットをドロップし、再送信とエンドツーエンドの待機時間が長くなると、スループットと待機時間の両方に悪影響を与えます。 
    </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
        いずれかのグループメンバー間のネットワークラウンドトリップ時間 (RTT) が 5 秒以上の場合、組込みの障害検出メカニズムが誤ってトリガーされる可能性があるため、問題が発生する可能性があります。
      </p></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-automatically-rejoin-temporary-problems"></a>一時的な接続の問題が発生した場合、メンバーは自動的にグループに再参加しますか。</h3></div></div></div><p>
      これは、接続の問題の理由によって異なります。 接続の問題が一時的で、障害検出で認識されないほど迅速に再接続できる場合、サーバーはグループから削除されない可能性があります。 接続性の問題が長い場合、障害検出機能は最終的に問題を疑い、サーバーはグループから削除されます。 
    </p><p>
      MySQL 8.0 から、グループに残っているメンバーまたはグループに再参加するメンバーの可能性を高めるために、次の 2 つの設定を使用できます:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">group_replication_member_expel_timeout</code> では、疑いの作成 (最初の 5 秒間の検出期間の後に発生) とメンバーの削除の間の時間が長くなります。 最大 1 時間の待機期間を設定できます。 MySQL 8.0.21 からは、待機期間はデフォルトで 5 秒に設定されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">group_replication_autorejoin_tries</code> では、メンバーは強制タイムアウトまたは到達不能な大多数のタイムアウトの後にグループへの再参加を試行します。 メンバーは、指定された数の自動再結合試行を 5 分間隔で行います。 MySQL 8.0.21 からは、この機能はデフォルトでアクティブ化され、メンバーは 3 回の自動再結合を試行します。 
        </p></li></ul></div><p>
      サーバーがグループから削除され、自動再結合の試行が成功しない場合は、再度参加する必要があります。 つまり、サーバーがグループから明示的に削除された後、手動で再結合する (またはスクリプトで自動的に再結合する) 必要があります。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-member-excluded"></a>メンバーがグループから除外されるのはいつですか。</h3></div></div></div><p>
      メンバーがサイレントになると、他のメンバーはグループ構成からメンバーを削除します。 実際には、これはメンバーがクラッシュしたか、ネットワークが切断された場合に発生することがあります。 
    </p><p>
      指定されたメンバーの指定されたタイムアウトが経過し、サイレントメンバーが作成されずに新しい構成が作成されると、障害が検出されます。
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-node-lag"></a>1 つのノードが大幅に遅れているとどうなりますか。</h3></div></div></div><p>
      メンバーをグループから自動的に削除するタイミングのポリシーを定義する方法はありません。 メンバーが遅れている理由を確認し、それを修正するか、グループからメンバーを削除する必要があります。 そうでない場合、サーバーが非常に低速でフロー制御をトリガーすると、グループ全体も低速になります。 フロー制御は、必要に応じて構成できます。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-member-responsible-reconfiguration"></a>グループ内の問題が疑われる場合、再構成のトリガーを担当する特別なメンバーはいますか。</h3></div></div></div><p>
      いいえ。再構成のトリガーを担当する特別なメンバーはグループにありません。
    </p><p>
      どのメンバーも問題がある疑いがあります。 すべてのメンバーは、特定のメンバーが失敗したことを (自動的に) 同意する必要があります。 1 人のメンバーが、再構成をトリガーすることでグループから明示的に削除されます。 どのメンバーがメンバーの明示を担当しているかは、ユーザーが制御または設定できないものです。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-provide-sharding"></a>シャーディングにグループレプリケーションを使用できますか。</h3></div></div></div><p>
      グループレプリケーションは、可用性の高いレプリカセットを提供するように設計されています。データおよび書込みは、グループ内の各メンバーで複製されます。 単一システムが提供できるものを超えるスケーリングのために、オーケストレーションおよびシャーディングフレームワークが多数のグループレプリケーションセットを中心に構築されている必要があります。各レプリカセットは、データセット全体の特定のシャードまたはパーティションを保持および管理します。 このタイプの設定 (<span class="quote">「<span class="quote">「シャードクラスタ」</span>」</span>とも呼ばれる) では、読取りおよび書込みを制限なしで線形的にスケーリングできます。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-using-selinux"></a>SELinux でグループレプリケーションを使用するにはどうすればよいですか。</h3></div></div></div><p>
      <span class="command"><strong>sestatus -v</strong></span> を使用して検証できる SELinux が有効になっている場合は、Group Replication 通信ポートの使用を有効にする必要があります。 <a class="xref" href="security.html#selinux-context-group-replication-port" title="グループレプリケーションの TCP ポートコンテキストの設定">グループレプリケーションの TCP ポートコンテキストの設定</a>を参照してください。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-using-iptables"></a>iptables でグループレプリケーションを使用するにはどうすればよいですか。</h3></div></div></div><p>
      <span class="command"><strong>iptables</strong></span> が有効な場合は、マシン間の通信用にグループレプリケーションポートを開く必要があります。 各マシンに設定されている現在のルールを確認するには、<span class="command"><strong>iptables -L</strong></span> を発行します。 構成されているポートが 33061 の場合は、<span class="command"><strong>iptables -A INPUT -p tcp --dport 33061 -j ACCEPT</strong></span> を発行して、必要なポート経由の通信を有効にします。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-recover-relay-log"></a>グループメンバーが使用するレプリケーションチャネルのリレーログをリカバリするにはどうすればよいですか。</h3></div></div></div><p>
      グループレプリケーションで使用されるレプリケーションチャネルは、レプリカレプリケーションへの非同期ソースで使用されるレプリケーションチャネルと同じように動作し、リレーログに依存します。 <code class="literal">relay_log</code> 変数が変更された場合、またはオプションが設定されておらず、ホスト名が変更された場合は、エラーが発生する可能性があります。 この状況でのリカバリ手順については、<a class="xref" href="replication.html#replica-logs-relaylog" title="17.2.4.1 リレーログ">セクション17.2.4.1「リレーログ」</a> を参照してください。 または、Group Replication で特に問題を修正する別の方法は、<code class="literal">STOP GROUP_REPLICATION</code> ステートメントを発行してから、<code class="literal">START GROUP_REPLICATION</code> ステートメントを発行してインスタンスを再起動することです。 Group Replication プラグインは、<code class="literal">group_replication_applier</code> チャネルを再度作成します。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-two-bind-addresses"></a>グループレプリケーションで 2 つのバインドアドレスが使用されるのはなぜですか。</h3></div></div></div><p>
      グループレプリケーションでは、クライアントがメンバーと通信するために使用する SQL アドレスと、通信するためにグループメンバーによって内部的に使用される <code class="literal">group_replication_local_address</code> の間でネットワークトラフィックを分割するために、2 つのバインドアドレスが使用されます。 たとえば、ネットワークアドレス <code class="literal">203.0.113.1</code> および <code class="literal">198.51.100.179</code> に 2 つのネットワークインタフェースが割り当てられているサーバーがあるとします。 このような状況では、<code class="literal">group_replication_local_address=203.0.113.1:33061</code> を設定して、内部グループのネットワークアドレスに <code class="literal">203.0.113.1:33061</code> を使用できます。 その後、<code class="literal">198.51.100.179</code> for <code class="literal">hostname</code> および <code class="literal">3306</code> for the <code class="literal">port</code> を使用できます。 その後、クライアント SQL アプリケーションは <code class="literal">198.51.100.179:3306</code> のメンバーに接続します。 これにより、ネットワークごとに異なるルールを構成できます。 同様に、内部グループ通信をクライアントアプリケーションに使用されるネットワーク接続と分離して、セキュリティを向上させることができます。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-hostnames"></a>グループレプリケーションでは、ネットワークアドレスとホスト名はどのように使用されますか。</h3></div></div></div><p>
      グループレプリケーションではメンバー間のネットワーク接続が使用されるため、その機能はホスト名とポートの構成方法によって直接影響を受けます。 たとえば、Group Replication 分散リカバリプロセスでは、サーバーのホスト名とポートを使用して既存のグループメンバーへの接続が作成されます。 メンバーがグループに参加すると、<code class="literal">performance_schema.replication_group_members</code> にリストされているネットワークアドレス情報を使用してグループメンバーシップ情報を受け取ります。 そのテーブルにリストされているメンバーのいずれかが、グループから結合メンバーへの欠落データのドナーとして選択されます。 
    </p><p>
      つまり、SQL ネットワークアドレスやグループシードアドレスなど、ホスト名を使用して構成する値は、完全修飾名であり、グループの各メンバーによって解決可能である必要があります。 たとえば、DNS、正しく構成された<code class="filename">/etc/hosts</code> ファイルまたはその他のローカルプロセスを使用して、これを確認できます。 サーバーで <code class="literal">MEMBER_HOST</code> 値を構成する場合は、グループに参加する前に、サーバーで <code class="option">--report-host</code> オプションを使用して指定します。 
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        割り当てられた値は直接使用され、<code class="literal">skip_name_resolve</code> システム変数の影響を受けません。
      </p></div><p>
      サーバーで <code class="literal">MEMBER_PORT</code> を構成するには、<code class="literal">report_port</code> システム変数を使用して指定します。
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-auto-increment-increment"></a>サーバーの自動増分設定が変更されたのはなぜですか。</h3></div></div></div><p>
      グループレプリケーションがサーバーで開始されると、<code class="literal">auto_increment_increment</code> の値は <code class="literal">group_replication_auto_increment_increment</code> の値に変更され (デフォルトは 7 )、<code class="literal">auto_increment_offset</code> の値はサーバー ID に変更されます。 グループレプリケーションが停止すると、変更は元に戻されます。 これらの設定では、グループメンバーに対する書込みに対して重複する自動増分値が選択されないため、トランザクションがロールバックされます。 グループレプリケーションのデフォルトの自動増分値 7 は、使用可能な値の数とレプリケーショングループの最大許容サイズ (9 メンバー) のバランスを表します。 
    </p><p>
      変更は、<code class="literal">auto_increment_increment</code> および <code class="literal">auto_increment_offset</code> のそれぞれのデフォルト値が 1 の場合にのみ行われ、元に戻されます。 これらの値がすでにデフォルトから変更されている場合、Group Replication はそれらを変更しません。 MySQL 8.0 からは、グループレプリケーションが単一プライマリモードで、サーバー書込みが 1 つのみの場合も、システム変数は変更されません。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="group-replication-how-to-find-primary"></a>プライマリを見つけるにはどうすればよいですか。</h3></div></div></div><p>
      グループがシングルプライマリモードで動作している場合は、どのメンバーがプライマリであるかを確認すると役立ちます。 <a class="xref" href="group-replication.html#group-replication-find-primary" title="18.1.3.1.2 プライマリの検索">セクション18.1.3.1.2「プライマリの検索」</a>を参照してください 
    </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="replication.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="mysql-shell-userguide.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第 17 章 レプリケーション </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第 19 章 MySQL Shell</td></tr></table></div><div class="copyright-footer"></div></body></html>
