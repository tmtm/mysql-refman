<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第 3 章 チュートリアル</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="MySQL 8.0 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 8.0 リファレンスマニュアル"><link rel="prev" href="installing.html" title="第 2 章 MySQL のインストールとアップグレード"><link rel="next" href="programs.html" title="第 4 章 MySQL プログラム"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 3 章 チュートリアル</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="installing.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="programs.html">次へ</a></td></tr></table><hr></div><div class="status-header"><p class="alert">このページは機械翻訳したものです。</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="tutorial"></a>第 3 章 チュートリアル</h1></div></div></div><div class="toc"><p><b>目次</b></p><dl class="toc"><dt><span class="section"><a href="tutorial.html#connecting-disconnecting">3.1 サーバーへの接続とサーバーからの切断</a></span></dt><dt><span class="section"><a href="tutorial.html#entering-queries">3.2 クエリーの入力</a></span></dt><dt><span class="section"><a href="tutorial.html#database-use">3.3 データベースの作成と使用</a></span></dt><dd><dl><dt><span class="section"><a href="tutorial.html#creating-database">3.3.1 データベースの作成と選択</a></span></dt><dt><span class="section"><a href="tutorial.html#creating-tables">3.3.2 テーブルの作成</a></span></dt><dt><span class="section"><a href="tutorial.html#loading-tables">3.3.3 テーブルへのデータのロード</a></span></dt><dt><span class="section"><a href="tutorial.html#retrieving-data">3.3.4 テーブルからの情報の取り出し</a></span></dt></dl></dd><dt><span class="section"><a href="tutorial.html#getting-information">3.4 データベースとテーブルに関する情報の取得</a></span></dt><dt><span class="section"><a href="tutorial.html#batch-mode">3.5 バッチモードでの MySQL の使用</a></span></dt><dt><span class="section"><a href="tutorial.html#examples">3.6 一般的なクエリーの例</a></span></dt><dd><dl><dt><span class="section"><a href="tutorial.html#example-maximum-column">3.6.1 カラムの最大値</a></span></dt><dt><span class="section"><a href="tutorial.html#example-maximum-row">3.6.2 特定のカラムの最大値が格納されている行</a></span></dt><dt><span class="section"><a href="tutorial.html#example-maximum-column-group">3.6.3 グループごとのカラムの最大値</a></span></dt><dt><span class="section"><a href="tutorial.html#example-maximum-column-group-row">3.6.4 特定のカラムのグループごとの最大値が格納されている行</a></span></dt><dt><span class="section"><a href="tutorial.html#example-user-variables">3.6.5 ユーザー定義の変数の使用</a></span></dt><dt><span class="section"><a href="tutorial.html#example-foreign-keys">3.6.6 外部キーの使用</a></span></dt><dt><span class="section"><a href="tutorial.html#searching-on-two-keys">3.6.7 2 つのキーを使用した検索</a></span></dt><dt><span class="section"><a href="tutorial.html#calculating-days">3.6.8 日ごとの訪問数の計算</a></span></dt><dt><span class="section"><a href="tutorial.html#example-auto-increment">3.6.9 AUTO_INCREMENT の使用</a></span></dt></dl></dd><dt><span class="section"><a href="tutorial.html#apache">3.7 Apache での MySQL の使用</a></span></dt></dl></div><a class="indexterm" name="idm45879497656304"></a><a class="indexterm" name="idm45879497654848"></a><a class="indexterm" name="idm45879497652800"></a><a class="indexterm" name="idm45879497650768"></a><p>
    この章では、<span class="command"><strong>mysql</strong></span> クライアントプログラムを使用して、簡単なデータベースを作成して使用する方法を示すことで、MySQL のチュートリアルを提供します。<span class="command"><strong>mysql</strong></span> (<span class="quote">「<span class="quote">端末モニター</span>」</span>または単に<span class="quote">「<span class="quote">モニター</span>」</span>と呼ばれることもあります) は、MySQL Server への接続、クエリーの実行、および結果の表示を可能にするインタラクティブなプログラムです。<span class="command"><strong>mysql</strong></span> は、バッチモードでも使用できます。クエリーを前もってファイルに入れておき、<span class="command"><strong>mysql</strong></span> にファイルのコンテンツを実行するよう指示します。 ここでは、<span class="command"><strong>mysql</strong></span> の両方の使用方法について説明します。 
  </p><p>
    <span class="command"><strong>mysql</strong></span> で提供されているオプションのリストを表示するには、<code class="option">--help</code> オプションを指定して mysql を起動します。
  </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysql --help</code></strong>
</pre><p>
    この章では、<span class="command"><strong>mysql</strong></span> がマシンにインストールされていることと、接続可能な MySQL Server が存在することを前提にしています。 そうでない場合は、MySQL 管理者に問い合わせてください。 (<span class="emphasis"><em>ご自身</em></span>が管理者の場合は、このドキュメントの<a class="xref" href="server-administration.html" title="第 5 章 MySQL サーバーの管理">第5章「<i>MySQL サーバーの管理</i>」</a>などの関連部分を参照してください。) 
  </p><p>
    この章では、データベースの設定と使用の手順全体について説明します。 既存のデータベースへのアクセスのみに関心がある場合は、データベースおよびそのデータベースに含まれるテーブルの作成方法を説明するセクションをスキップできます。 
  </p><p>
    この章はチュートリアルであるため、必然的に多くの詳細が省略されています。 ここで説明されているトピックの詳細については、ドキュメントの関連セクションを参照してください。 
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="connecting-disconnecting"></a>3.1 サーバーへの接続とサーバーからの切断</h2></div></div></div><a class="indexterm" name="idm45879497633200"></a><a class="indexterm" name="idm45879497631088"></a><a class="indexterm" name="idm45879497629056"></a><a class="indexterm" name="idm45879497627024"></a><p>
      サーバーに接続するには、通常、<span class="command"><strong>mysql</strong></span> の起動時に MySQL ユーザー名とパスワードを指定する必要があります。 サーバーがログインしたマシン以外で実行されている場合は、ホスト名も指定する必要があります。 接続に使用する接続パラメータ (使用するホスト、ユーザー名、およびパスワード) については、管理者に問い合わせてください。 正しいパラメータがわかったら、次の方法で接続できます。 
    </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysql -h <em class="replaceable"><code>host</code></em> -u <em class="replaceable"><code>user</code></em> -p</code></strong>
Enter password: <strong class="userinput"><code>********</code></strong>
</pre><p>
      <em class="replaceable"><code>host</code></em> は MySQL サーバーが稼働しているホストの名前、<em class="replaceable"><code>user</code></em> はユーザーの MySQL アカウントのユーザー名です。 設定に応じて適切な値で置き換えてください。 <code class="literal">********</code> はユーザーのパスワードです。<span class="command"><strong>mysql</strong></span> で<code class="literal">「Enter password:」</code>というプロンプトが表示されたら入力してください。 
    </p><p>
      それが機能すると、照会情報に続いて <code class="literal">mysql&gt;</code> プロンプトが表示されるはずです。
    </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysql -h <em class="replaceable"><code>host</code></em> -u <em class="replaceable"><code>user</code></em> -p</code></strong>
Enter password: <strong class="userinput"><code>********</code></strong>
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 25338 to server version: 8.0.25-standard

Type 'help;' or '\h' for help. Type '\c' to clear the buffer.

mysql&gt;
</pre><p>
      <code class="literal">mysql&gt;</code> プロンプトに、<span class="command"><strong>mysql</strong></span> で SQL ステートメントを入力する準備ができていることが示されます。
    </p><p>
      MySQL が稼働しているマシンと同じマシンにログインしている場合は、ホストを省略して次を使用できます。
    </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysql -u <em class="replaceable"><code>user</code></em> -p</code></strong>
</pre><p>
      ログイン時に次のようなエラーメッセージが表示される場合があります。 <span class="errortext">ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock' (2)</span>。これは、MySQL サーバーデーモン (Unix) またはサービス (Windows) が起動していないことを示しています。 管理者に問い合わせるか、オペレーティングシステムに応じて<a class="xref" href="installing.html" title="第 2 章 MySQL のインストールとアップグレード">第2章「<i>MySQL のインストールとアップグレード</i>」</a>の適切なセクションを参照してください。 
    </p><p>
      ログイン時によく発生するほかの問題については、<a class="xref" href="error-handling.html#common-errors" title="B.3.2 MySQL プログラム使用時の一般的なエラー">セクションB.3.2「MySQL プログラム使用時の一般的なエラー」</a>を参照してください。
    </p><p>
      一部の MySQL インストールでは、ローカルホストで稼働しているサーバーに、ユーザーが匿名 (名前を指定しない) ユーザーとして接続できます。 これに該当するマシンでは、オプションを何も指定せずに <span class="command"><strong>mysql</strong></span> を起動すると、そのサーバーに接続できるはずです。 
    </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysql</code></strong>
</pre><p>
      接続に成功したら、<code class="literal">QUIT</code> (または <code class="literal">\q</code>) と <code class="literal">mysql&gt;</code> プロンプトに入力することで、いつでも切断できます。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>QUIT</code></strong>
Bye
</pre><p>
      Unix では、Control+D を押しても切断できます。
    </p><p>
      以降のセクションに示すほとんどの例では、サーバーに接続していることを前提にしています。 このことは、<code class="literal">mysql&gt;</code> プロンプトによって示されます。 
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="entering-queries"></a>3.2 クエリーの入力</h2></div></div></div><a class="indexterm" name="idm45879497591696"></a><a class="indexterm" name="idm45879497589552"></a><a class="indexterm" name="idm45879497587520"></a><p>
      前のセクションで説明したように、サーバーに接続していることを確認します。 それだけでは操作するデータベースは選択されていませんが、それでかまいません。 この時点では、テーブルの作成、テーブルへのデータのロード、テーブルからのデータの取り出しに今すぐ進むのではなく、クエリーの発行方法を学ぶことが重要です。 このセクションでは、<span class="command"><strong>mysql</strong></span> の動作を理解するために試みることができるいくつかのクエリーを使用して、クエリーを入力する基本原則について説明します。 
    </p><p>
      ここでは、サーバーにバージョン番号と現在の日付を尋ねる簡単なクエリーを示します。 <code class="literal">mysql&gt;</code> プロンプトに続けて、次に示すように入力してから Enter を押します。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT VERSION(), CURRENT_DATE;</code></strong>
+-----------+--------------+
| VERSION() | CURRENT_DATE |
+-----------+--------------+
| 5.8.0-m17 | 2015-12-21   |
+-----------+--------------+
1 row in set (0.02 sec)
mysql&gt;
</pre><p>
      このクエリーには、<span class="command"><strong>mysql</strong></span> に関するいくつかの事項が示されています。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          クエリーは通常、SQL ステートメントの後にセミコロンが続くもので構成されます。 (セミコロンを省略できる例外もいくつかあります。 前述の <code class="literal">QUIT</code> もその 1 つです。 ほかのものについてはあとで説明します。) 
        </p></li><li class="listitem"><p>
          クエリーを発行すると、<span class="command"><strong>mysql</strong></span> はそのクエリーをサーバーに送信して実行し、結果を表示してから、別のクエリーの準備ができていることを示す別の <code class="literal">mysql&gt;</code> プロンプトを出力します。
        </p></li><li class="listitem"><p>
          <span class="command"><strong>mysql</strong></span> は、クエリーの出力を表形式 (行とカラム) で表示します。 最初の行には、カラムのラベルが表示されます。 以降の行はクエリーの結果です。 通常、カラムラベルは、データベーステーブルからフェッチされるカラムの名前です。 次の例のように、テーブルカラムではなく式の値を取得する場合、<span class="command"><strong>mysql</strong></span> ではカラムのラベルとして式自体が使用されます。 
        </p></li><li class="listitem"><p>
          <span class="command"><strong>mysql</strong></span> では、返された行の数とクエリーの実行にかかった時間が表示されるため、サーバーの大まかなパフォーマンスがわかります。 これらの値は、CPU 時間やマシン時間ではなく時計の時間で表されるため、また、サーバー負荷やネットワーク待機時間などの要因に影響されるため、正確ではありません。 (簡略化のために、この章のほかの例では<span class="quote">「<span class="quote">rows in set</span>」</span>の行が省略されている場合もあります。) 
        </p></li></ul></div><p>
      キーワードは大文字でも小文字でも入力できます。 次のクエリーは同等です。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT VERSION(), CURRENT_DATE;</code></strong>
mysql&gt; <strong class="userinput"><code>select version(), current_date;</code></strong>
mysql&gt; <strong class="userinput"><code>SeLeCt vErSiOn(), current_DATE;</code></strong>
</pre><p>
      次に、別のクエリーを示します。 これは、<span class="command"><strong>mysql</strong></span> を簡単な計算機として使用できることを示しています。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT SIN(PI()/4), (4+1)*5;</code></strong>
+------------------+---------+
| SIN(PI()/4)      | (4+1)*5 |
+------------------+---------+
| 0.70710678118655 |      25 |
+------------------+---------+
1 row in set (0.02 sec)
</pre><p>
      これまでに示したクエリーは、比較的に短い、1 行のステートメントでした。 1 行に複数のステートメントを入力することもできます。 各ステートメントの末尾にはセミコロンを付加してください。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT VERSION(); SELECT NOW();</code></strong>
+-----------+
| VERSION() |
+-----------+
| 8.0.13    |
+-----------+
1 row in set (0.00 sec)

+---------------------+
| NOW()               |
+---------------------+
| 2018-08-24 00:56:40 |
+---------------------+
1 row in set (0.00 sec)
</pre><p>
      クエリーのすべてを単一行で指定する必要はないため、複数の行を必要とする長いクエリーでも問題になりません。<span class="command"><strong>mysql</strong></span> では、入力行の終わりを探すのではなく、終了セミコロンを探すことによって、ステートメントの終了位置が決定されます。 (つまり、<span class="command"><strong>mysql</strong></span> は自由形式の入力を受け入れます。入力行を収集しますが、セミコロンが見つかるまでは実行しません。) 
    </p><p>
      次に、単純な複数行ステートメントを示します。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT</code></strong>
    -&gt; <strong class="userinput"><code>USER()</code></strong>
    -&gt; <strong class="userinput"><code>,</code></strong>
    -&gt; <strong class="userinput"><code>CURRENT_DATE;</code></strong>
+---------------+--------------+
| USER()        | CURRENT_DATE |
+---------------+--------------+
| jon@localhost | 2018-08-24   |
+---------------+--------------+
</pre><p>
      この例では、複数行にわたるクエリーの最初の行を入力したあと、プロンプトが <code class="literal">mysql&gt;</code> から <code class="literal">-&gt;</code> に変化することに注意してください。 これは、<span class="command"><strong>mysql</strong></span> がまだ完全なステートメントを検出しておらず、残りの入力を待機していることを示しています。 プロンプトは貴重なフィードバックを提供してくれる味方です。 そのフィードバックを使用すれば、<span class="command"><strong>mysql</strong></span> が何を待機しているのかを、常に認識することができます。 
    </p><p>
      入力処理中のクエリーを実行しない場合は、<code class="literal">\c</code> と入力して取り消します:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT</code></strong>
    -&gt; <strong class="userinput"><code>USER()</code></strong>
    -&gt; <strong class="userinput"><code>\c</code></strong>
mysql&gt;
</pre><p>
      ここでもプロンプトに注目してください。 <code class="literal">\c</code> の入力後に <code class="literal">mysql&gt;</code> に戻り、<span class="command"><strong>mysql</strong></span> が新しいクエリーの準備ができたことを示すフィードバックを提供します。 
    </p><p>
      次の表に、表示される各プロンプトとそれらが示す <span class="command"><strong>mysql</strong></span> の状態をまとめます。
    </p><a class="indexterm" name="idm45879497537904"></a><div class="informaltable"><table summary="MySQL prompts and the meaning of each prompt."><col width="10%"><col width="80%"><thead><tr>
          <th>プロンプト</th>
          <th>意味</th>
        </tr></thead><tbody><tr>
          <td><code class="literal">mysql&gt;</code></td>
          <td>新規クエリーの準備完了</td>
        </tr><tr>
          <td><code class="literal">-&gt;</code></td>
          <td>複数行クエリーの次の行を待機しています</td>
        </tr><tr>
          <td><code class="literal">'&gt;</code></td>
          <td>次の行を待機しており、一重引用符 (<code class="literal">'</code>) で始まる文字列の完了を待機しています</td>
        </tr><tr>
          <td><code class="literal">"&gt;</code></td>
          <td>次の行を待機し、二重引用符 (<code class="literal">"</code>) で始まる文字列の完了を待機しています</td>
        </tr><tr>
          <td><code class="literal">`&gt;</code></td>
          <td>次の行を待機しており、バックティック (<code class="literal">`</code>) で始まる識別子の完了を待機しています</td>
        </tr><tr>
          <td><code class="literal">/*&gt;</code></td>
          <td><code class="literal">/*</code> で始まったコメントが完了するまで次の行を待機しています</td>
        </tr></tbody></table></div><p>
      複数行のステートメントは、通常、単一行に対してクエリーを発行しようとしたが、終了セミコロンを忘れた場合に発生します。 この場合、<span class="command"><strong>mysql</strong></span> は追加の入力を待機します。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT USER()</code></strong>
    -&gt;
</pre><p>
      これが起きた場合 (ステートメントを入力したのに <code class="literal">-&gt;</code> プロンプトの応答が示される) は、<span class="command"><strong>mysql</strong></span> がセミコロンを待機している可能性が高くなります。 プロンプトの意味に気付かなければ、何をするべきか理解するまでに時間がかかるかもしれません。 セミコロンを入力してステートメントを完了すると、<span class="command"><strong>mysql</strong></span> で実行されます。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT USER()</code></strong>
    -&gt; <strong class="userinput"><code>;</code></strong>
+---------------+
| USER()        |
+---------------+
| jon@localhost |
+---------------+
</pre><p>
      <code class="literal">'&gt;</code> および <code class="literal">"&gt;</code> プロンプトは、文字列の収集中に発生します (MySQL が文字列の完了を待機しているという意味です)。 MySQL では、<code class="literal">'</code>または<code class="literal">"</code>文字 (<code class="literal">'hello'</code>や<code class="literal">"goodbye"</code>など) で囲まれた文字列を記述でき、<span class="command"><strong>mysql</strong></span> では複数行にまたがる文字列を入力できます。 <code class="literal">'&gt;</code> または<code class="literal">"&gt;</code> プロンプトが表示された場合は、<code class="literal">'</code>または<code class="literal">"</code>の引用符文字で始まる文字列を含む行を入力したが、その文字列を終了する一致する引用符をまだ入力していないことを意味します。 このような場合、引用符の入力を忘れていることがよくあります。 例: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM my_table WHERE name = 'Smith AND age &lt; 30;</code></strong>
    '&gt;
</pre><p>
      この <code class="literal">SELECT</code> ステートメントを入力し、<span class="keycap"><strong>Enter</strong></span> を押して結果を待っても、何も起きません。 このクエリーがなぜそれほど時間がかかるのかと不思議に思うのではなく、<code class="literal">'&gt;</code> プロンプトで示される手がかりに注目してください。 このプロンプトは、<span class="command"><strong>mysql</strong></span> が完了していない文字列の残りを待機していることを示しています。 (このステートメントの間違いに気付きましたか。 文字列 <code class="literal">'Smith</code> には、2 番目の一重引用符がありません。) 
    </p><p>
      では、どうしますか。 最も簡単なのは、クエリーを取り消すことです。 ただし、この場合は単に <code class="literal">\c</code> と入力することはできません。なぜなら、<span class="command"><strong>mysql</strong></span> で収集中の文字列の一部とみなされるからです。 代わりに、閉じる引用符を入力して (つまり、文字列が完了したことを <span class="command"><strong>mysql</strong></span> に認識させ)、次に <code class="literal">\c</code> と入力します。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM my_table WHERE name = 'Smith AND age &lt; 30;</code></strong>
    '&gt; <strong class="userinput"><code>'\c</code></strong>
mysql&gt;
</pre><p>
      プロンプトが <code class="literal">mysql&gt;</code> に戻り、<span class="command"><strong>mysql</strong></span> で新しいクエリーの準備ができたことが示されます。
    </p><p>
      <code class="literal">`&gt;</code> プロンプトは <code class="literal">'&gt;</code> および <code class="literal">"&gt;</code> プロンプトと同様ですが、逆引用符を開始したがまだ終了していないことを示しています。
    </p><p>
      <code class="literal">'&gt;</code>、<code class="literal">"&gt;</code>、および <code class="literal">`&gt;</code> の各プロンプトが何を意味するかを理解することが重要です。なぜなら、誤って未終了の文字列を入力した場合、それ以降の入力行は <code class="literal">QUIT</code> を含む行も含めて、<span class="command"><strong>mysql</strong></span> に無視されるように見えるからです。 これは、特に、現在のクエリーを取り消す前に終了引用符を指定する必要があることがわからない場合は、非常に混乱している可能性があります。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        この時点からの複数行のステートメントは、セカンダリ (<code class="literal">-&gt;</code> またはその他) プロンプトなしで記述されるため、ステートメントをコピーして自分で試すのが容易になります。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="database-use"></a>3.3 データベースの作成と使用</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="tutorial.html#creating-database">3.3.1 データベースの作成と選択</a></span></dt><dt><span class="section"><a href="tutorial.html#creating-tables">3.3.2 テーブルの作成</a></span></dt><dt><span class="section"><a href="tutorial.html#loading-tables">3.3.3 テーブルへのデータのロード</a></span></dt><dt><span class="section"><a href="tutorial.html#retrieving-data">3.3.4 テーブルからの情報の取り出し</a></span></dt></dl></div><a class="indexterm" name="idm45879497467504"></a><a class="indexterm" name="idm45879497465392"></a><a class="indexterm" name="idm45879497463360"></a><p>
      SQL ステートメントの入力方法がわかったら、データベースにアクセスできます。
    </p><p>
      何匹かのペット (menagerie、動物) を家で飼っているとします。これらのペットについてさまざまな種類の情報の記録をつける場合を考えます。 これは、データを保持するためのテーブルを作成し、必要な情報をテーブルにロードすることで実現できます。 次に、テーブルからデータを取り出すことで、ペットに関する各種の質問に回答できます。 このセクションでは、次の操作の実行方法について説明します。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          データベースを作成する
        </p></li><li class="listitem"><p>
          テーブルを作成する
        </p></li><li class="listitem"><p>
          テーブルにデータをロードする
        </p></li><li class="listitem"><p>
          さまざまな方法でテーブルからデータを取り出す
        </p></li><li class="listitem"><p>
          複数のテーブルを使用する
        </p></li></ul></div><p>
      menagerie データベースは意図的に単純になっていますが、類似のデータベースを使用するような実際の状況を考えることは難しくありません。 たとえば、これに似たデータベースを使用して農場主が家畜の記録をつけたり、獣医が患者の記録をつけたりできます。 次のセクションで使用するクエリーおよびサンプルデータの一部を含む menagerie ディストリビューションは、MySQL の web サイトから取得できます。 圧縮 <span class="command"><strong>tar</strong></span> ファイル形式および Zip 形式の両方で、<a class="ulink" href="https://dev.mysql.com/doc/" target="_top">https://dev.mysql.com/doc/</a> で入手できます。 
    </p><p>
      <code class="literal">SHOW</code> ステートメントを使用して、サーバーに現在どのようなデータベースが存在するかを調べます。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW DATABASES;</code></strong>
+----------+
| Database |
+----------+
| mysql    |
| test     |
| tmp      |
+----------+
</pre><p>
      <code class="literal">mysql</code> データベースは、ユーザーのアクセス権限を記述します。 <code class="literal">test</code> データベースは、多くの場合、ユーザーが各種の試行をするための作業スペースとして用意されています。 
    </p><p>
      このステートメントで表示されるデータベースのリストは、マシンによって異なる場合があります。ユーザーが <code class="literal">SHOW DATABASES</code> 権限を持っていない場合、ユーザーにまったく権限のないデータベースは <code class="literal">SHOW DATABASES</code> で表示されません。 <a class="xref" href="sql-statements.html#show-databases" title="13.7.7.14 SHOW DATABASES ステートメント">セクション13.7.7.14「SHOW DATABASES ステートメント」</a>を参照してください。 
    </p><p>
      <code class="literal">test</code> データベースが存在する場合は、アクセスしてみます。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>USE test</code></strong>
Database changed
</pre><p>
      <code class="literal">QUIT</code> と同様に、<code class="literal">USE</code> にもセミコロンは必要ありません。 (これらのステートメントの末尾にセミコロンを付加しても問題はありません。)  <code class="literal">USE</code> ステートメントは、1 行に記述する必要があるという点でも特殊です。 
    </p><p>
      <code class="literal">test</code> データベースへのアクセス権限を持っている場合は以降の例に使用できますが、そのデータベース内に作成した内容は、アクセス権限を持っているほかのユーザーによって削除される可能性があります。 この理由から、自分専用のデータベースを使用する許可を MySQL 管理者に依頼するとよいでしょう。 自分のデータベースに <code class="literal">menagerie</code> という名前を付けるとします。 管理者は、次のようなステートメントを実行する必要があります: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>GRANT ALL ON menagerie.* TO 'your_mysql_name'@'your_client_host';</code></strong>
</pre><p>
      ここで、<code class="literal">your_mysql_name</code> はユーザーに割り当てられた MySQL ユーザー名、<code class="literal">your_client_host</code> はサーバーに接続するホストです。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="creating-database"></a>3.3.1 データベースの作成と選択</h3></div></div></div><a class="indexterm" name="idm45879497428880"></a><a class="indexterm" name="idm45879497426768"></a><p>
        管理者がユーザーのアクセス権を設定する際にユーザー用のデータベースを作成した場合、ユーザーはそのデータベースを使用し始めることができます。 そうでない場合は、ユーザー自身で作成する必要があります。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE DATABASE menagerie;</code></strong>
</pre><p>
        Unix では、データベース名は大/小文字が区別されるため (SQL キーワードとは異なり)、データベースは常に <code class="literal">Menagerie</code>、<code class="literal">MENAGERIE</code> または他のバリアントとしてではなく、<code class="literal">menagerie</code> として参照する必要があります。 これはテーブル名にも当てはまります。 (Windows の場合、この制限は適用されませんが、データベースとテーブルの表記は 1 つのクエリー内では統一する必要があります。 ただし、さまざまな理由から、データベースの作成時に使用した表記を常に使用することをお勧めします。) 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          データベースを作成しようとしたときに<span class="errortext">「ERROR 1044 (42000): データベース'menagerie'へのユーザー'micah'@'localhost'のアクセスが拒否されました」</span>などのエラーが発生した場合は、そのために必要な権限がユーザーアカウントにないことを意味します。 これについては管理者に問い合わせるか、<a class="xref" href="security.html#access-control" title="6.2 アクセス制御とアカウント管理">セクション6.2「アクセス制御とアカウント管理」</a>を参照してください。 
        </p></div><p>
        データベースを作成しても、そのデータベースは選択されません。使用するには明示的に選択する必要があります。 <code class="literal">menagerie</code> を現行のデータベースにするには、次のステートメントを使用します: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>USE menagerie</code></strong>
Database changed
</pre><p>
        データベースの作成は 1 回だけ必要ですが、使用するには <span class="command"><strong>mysql</strong></span> セッションを開始するたびにデータベースを選択する必要があります。 そのためには、例のように <code class="literal">USE</code> ステートメントを発行します。 または、<span class="command"><strong>mysql</strong></span> を起動するときにコマンド行でデータベースを選択できます。 必要な接続パラメータをすべて指定したあとに、データベースの名前を指定します。 例: 
      </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysql -h <em class="replaceable"><code>host</code></em> -u <em class="replaceable"><code>user</code></em> -p menagerie</code></strong>
Enter password: <strong class="userinput"><code>********</code></strong>
</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          このコマンド内の <code class="literal">menagerie</code> はパスワードでは<span class="bold"><strong>ありません</strong></span>。 <code class="literal">-p</code> オプションの後にコマンドラインでパスワードを指定する場合は、スペースを介さずに指定する必要があります (たとえば、<code class="literal">-p <em class="replaceable"><code>password</code></em></code> としてではなく <code class="literal">-p<em class="replaceable"><code>password</code></em></code> として指定します)。 ただし、コマンド行にパスワードを入力することは、同じマシンにログインしているほかのユーザーに覗き見られるおそれがあるため、お勧めできません。 
        </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">SELECT</code> <code class="literal">DATABASE()</code> を使用すると、現在どのデータベースが選択されているかをいつでも調べることができます。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="creating-tables"></a>3.3.2 テーブルの作成</h3></div></div></div><a class="indexterm" name="idm45879497395872"></a><a class="indexterm" name="idm45879497393728"></a><p>
        データベースの作成は簡単な部分ですが、<code class="literal">SHOW TABLES</code> が示すとおり、この時点では空です。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW TABLES;</code></strong>
Empty set (0.00 sec)
</pre><p>
        難しい部分は、データベースの構造、つまり、どのようなテーブルが必要で各テーブルにどのようなカラムを含めるかを決定することです。
      </p><p>
        各ペットの記録を格納するテーブルが必要です。 このテーブルには、<code class="literal">pet</code> という名前を付けることができ、少なくとも各ペットの名前を含めるべきです。 名前自体には深い意味はないため、このテーブルにはほかの情報も含めるとよいでしょう。 たとえば、家族の複数のメンバーがペットを飼っている場合は、各ペットの所有者を記録することができます。 種や性別などの基本的な説明も記録できます。 
      </p><p>
        年齢はどうでしょうか。 重要な情報ではありますが、データベースに格納するには適しません。 年齢は時間の経過によって変化するため、記録を頻繁に更新する必要が生じます。 代わりに、生年月日などの固定値を格納する方が適切です。 そうしておけば、年齢が必要になったときに、現在の日付と生年月日の差として計算することができます。 MySQL には日付演算を行う関数が用意されているため、これは難しくありません。 年齢の代わりに生年月日を格納することには、ほかの利点もあります。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            たとえば、ペットの誕生日が近づいたらリマインダを生成するといったタスクにデータベースを使用できます。 (このようなクエリーには意味がないと感じる場合、現在の週や月で誕生祝いのメッセージを送信する必要のあるクライアントを特定するためにビジネスデータベースを使用する場合と、コンピュータ支援の接客という点で同じ問題であることに注目してください。) 
          </p></li><li class="listitem"><p>
            現在の日付ではなく、別の日付を基にして年齢を計算することもできます。 たとえば、データベースに死亡日を格納すると、ペットが何歳で死んだかを簡単に計算できます。 
          </p></li></ul></div><p>
        <code class="literal">pet</code> テーブルに含めると役立ちそうな情報はほかにもあるでしょうが、ここまでに挙げた名前 (name)、所有者 (owner)、種 (species)、性別 (sex)、生年月日 (birth)、および死亡年月日 (death) で十分です。
      </p><p>
        <code class="literal">CREATE TABLE</code> ステートメントを使用して、テーブルのレイアウトを指定します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE pet (name VARCHAR(20), owner VARCHAR(20),</code></strong>
       <strong class="userinput"><code>species VARCHAR(20), sex CHAR(1), birth DATE, death DATE);</code></strong>
</pre><p>
        <code class="literal">name</code>、<code class="literal">owner</code>、および <code class="literal">species</code> の各カラムではカラム値の長さが変化するため、これらのカラムに <code class="literal">VARCHAR</code> を選択することは適切です。 これらのカラム定義の長さは、すべて同じである必要はなく、<code class="literal">20</code> である必要もありません。 通常は、<code class="literal">1</code> から <code class="literal">65535</code> までの範囲で、もっとも適切と思われる任意の長さを選択できます。 選択が適切でなく、あとでより長いフィールドが必要になった場合は、MySQL の <code class="literal">ALTER TABLE</code> ステートメントを利用できます。 
      </p><p>
        ペットのレコードで性別を表す値としては、<code class="literal">'m'</code> と <code class="literal">'f'</code>、または <code class="literal">'male'</code> と <code class="literal">'female'</code> など、いくつかの種類を選択できます。 1 文字の <code class="literal">'m'</code> と <code class="literal">'f'</code> を使用するのがもっとも簡単です。 
      </p><p>
        <code class="literal">birth</code> カラムと <code class="literal">death</code> カラムに <code class="literal">DATE</code> データ型を使用することはかなり明白な選択です。
      </p><p>
        テーブルを作成したあとは、<code class="literal">SHOW TABLES</code> で何か出力されるはずです。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW TABLES;</code></strong>
+---------------------+
| Tables in menagerie |
+---------------------+
| pet                 |
+---------------------+
</pre><p>
        想定どおりにテーブルが作成されたことを確認するには、<code class="literal">DESCRIBE</code> ステートメントを使用します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>DESCRIBE pet;</code></strong>
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| name    | varchar(20) | YES  |     | NULL    |       |
| owner   | varchar(20) | YES  |     | NULL    |       |
| species | varchar(20) | YES  |     | NULL    |       |
| sex     | char(1)     | YES  |     | NULL    |       |
| birth   | date        | YES  |     | NULL    |       |
| death   | date        | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
</pre><p>
        <code class="literal">DESCRIBE</code> ステートメントは、テーブル内のカラムの名前や型を忘れた場合などに、いつでも使用できます。
      </p><p>
        MySQL のデータ型に関する詳細は、<a class="xref" href="data-types.html" title="第 11 章 データ型">第11章「<i>データ型</i>」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="loading-tables"></a>3.3.3 テーブルへのデータのロード</h3></div></div></div><a class="indexterm" name="idm45879497348352"></a><a class="indexterm" name="idm45879497346240"></a><a class="indexterm" name="idm45879497344208"></a><p>
        テーブルを作成したら、データを移入する必要があります。 これには、<code class="literal">LOAD DATA</code> ステートメントと <code class="literal">INSERT</code> ステートメントが役立ちます。 
      </p><p>
        ペットのレコードを次のように記述できると仮定します。 (MySQL では、<code class="literal">'<em class="replaceable"><code>YYYY-MM-DD</code></em>'</code>形式の日付が想定されていることを確認します。これは、使用しているものとは異なる場合があります。) 
      </p><div class="informaltable"><table summary="Example of pet records mentioned in the preceding text."><col width="10%"><col width="10%"><col width="10%"><col width="05%"><col width="20%"><col width="20%"><thead><tr>
            <th scope="col">name</th>
            <th scope="col">owner</th>
            <th scope="col">species</th>
            <th scope="col">sex</th>
            <th scope="col">birth</th>
            <th scope="col">death</th>
          </tr></thead><tbody><tr>
            <th scope="row">Fluffy</th>
            <td>Harold</td>
            <td>cat</td>
            <td>f</td>
            <td>1993-02-04</td>
            <td></td>
          </tr><tr>
            <th scope="row">Claws</th>
            <td>Gwen</td>
            <td>cat</td>
            <td>m</td>
            <td>1994-03-17</td>
            <td></td>
          </tr><tr>
            <th scope="row">Buffy</th>
            <td>Harold</td>
            <td>dog</td>
            <td>f</td>
            <td>1989-05-13</td>
            <td></td>
          </tr><tr>
            <th scope="row">Fang</th>
            <td>Benny</td>
            <td>dog</td>
            <td>m</td>
            <td>1990-08-27</td>
            <td></td>
          </tr><tr>
            <th scope="row">Bowser</th>
            <td>Diane</td>
            <td>dog</td>
            <td>m</td>
            <td>1979-08-31</td>
            <td>1995-07-29</td>
          </tr><tr>
            <th scope="row">Chirpy</th>
            <td>Gwen</td>
            <td>bird</td>
            <td>f</td>
            <td>1998-09-11</td>
            <td></td>
          </tr><tr>
            <th scope="row">Whistler</th>
            <td>Gwen</td>
            <td>bird</td>
            <td></td>
            <td>1997-12-09</td>
            <td></td>
          </tr><tr>
            <th scope="row">Slim</th>
            <td>Benny</td>
            <td>snake</td>
            <td>m</td>
            <td>1996-04-29</td>
            <td></td>
          </tr></tbody></table></div><p>
        空のテーブルから始めているため、データを移入する簡単な方法は、各ペットに対応する行を記述したテキストファイルを作成してから、1 つのステートメントでそのファイルの内容をテーブルにロードすることです。
      </p><p>
        たとえば、テキストファイル <code class="filename">pet.txt</code> を作成し、1 行に 1 レコードを記述します。値は、<code class="literal">CREATE TABLE</code> ステートメントに指定したカラムの順序に従い、タブで区切って指定します。 性別が不明な場合やまだ生きているペットの死亡年月日など、不足している値には <code class="literal">NULL</code> 値を使用できます。 テキストファイルでこれらを表現するには、<code class="literal">\N</code> (バックスラッシュと大文字の N) を使用します。 たとえば、Whistler という鳥のレコードは次のようになります (値の間の空白は 1 つのタブ文字です)。 
      </p><pre class="programlisting">Whistler        Gwen    bird    \N      1997-12-09      \N
</pre><p>
        テキストファイル <code class="filename">pet.txt</code> を <code class="literal">pet</code> テーブルにロードするには、次のステートメントを使用します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>LOAD DATA LOCAL INFILE '/path/pet.txt' INTO TABLE pet;</code></strong>
</pre><p>
        このファイルを Windows で作成した場合、作成に使用したエディタで <code class="literal">\r\n</code> が行ターミネータとして使用されているときは、代わりに次のステートメントを使用します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>LOAD DATA LOCAL INFILE '/path/pet.txt' INTO TABLE pet</code></strong>
       <strong class="userinput"><code>LINES TERMINATED BY '\r\n';</code></strong>
</pre><p>
        (macOS を実行している Apple マシンでは、<code class="literal">LINES TERMINATED BY '\r'</code>を使用する可能性があります。)
      </p><p>
        カラム値の区切り文字と行末マーカーは、必要に応じて <code class="literal">LOAD DATA</code> ステートメントで明示的に指定できますが、デフォルトではタブと改行です。 ステートメントで <code class="filename">pet.txt</code> ファイルを正しく読み取るにはこれで十分です。 
      </p><p>
        ステートメントが失敗する場合、使用している MySQL インストールではローカルファイル機能がデフォルトで有効になっていない可能性があります。 これを変更する方法については、<a class="xref" href="security.html#load-data-local-security" title="6.1.6 LOAD DATA LOCAL のセキュリティー上の考慮事項">セクション6.1.6「LOAD DATA LOCAL のセキュリティー上の考慮事項」</a>を参照してください。 
      </p><p>
        新しいレコードを 1 つずつ追加する場合は、<code class="literal">INSERT</code> ステートメントが役立ちます。 もっとも単純な形式では、<code class="literal">CREATE TABLE</code> ステートメントに指定したカラムの順序に従って、各カラムの値を入力します。 Diane が、<span class="quote">「<span class="quote">Puffball</span>」</span> という名前の新しいハムスターを手に入れたとします。 次のように、<code class="literal">INSERT</code> ステートメントを使用して新しいレコードを追加できます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO pet</code></strong>
       <strong class="userinput"><code>VALUES ('Puffball','Diane','hamster','f','1999-03-30',NULL);</code></strong>
</pre><p>
        ここでは、文字値と日付値を、引用符付きの文字列で指定しています。 また、<code class="literal">INSERT</code> では、不足している値を表す <code class="literal">NULL</code> を直接挿入することができます。 <code class="literal">LOAD DATA</code> の場合のように <code class="literal">\N</code> を使用することはありません。 
      </p><p>
        この例からわかるとおり、初期レコードをロードするために複数の <code class="literal">INSERT</code> ステートメントを使用すると、1 つの <code class="literal">LOAD DATA</code> ステートメントを使用する場合よりもかなり多くの入力が必要になります。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="retrieving-data"></a>3.3.4 テーブルからの情報の取り出し</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="tutorial.html#selecting-all">3.3.4.1 すべてのデータの選択</a></span></dt><dt><span class="section"><a href="tutorial.html#selecting-rows">3.3.4.2 特定の行の選択</a></span></dt><dt><span class="section"><a href="tutorial.html#selecting-columns">3.3.4.3 特定のカラムの選択</a></span></dt><dt><span class="section"><a href="tutorial.html#sorting-rows">3.3.4.4 行のソート</a></span></dt><dt><span class="section"><a href="tutorial.html#date-calculations">3.3.4.5 日付の計算</a></span></dt><dt><span class="section"><a href="tutorial.html#working-with-null">3.3.4.6 NULL 値の操作</a></span></dt><dt><span class="section"><a href="tutorial.html#pattern-matching">3.3.4.7 パターンマッチング</a></span></dt><dt><span class="section"><a href="tutorial.html#counting-rows">3.3.4.8 行のカウント</a></span></dt><dt><span class="section"><a href="tutorial.html#multiple-tables">3.3.4.9 複数のテーブルの使用</a></span></dt></dl></div><a class="indexterm" name="idm45879497242576"></a><a class="indexterm" name="idm45879497240464"></a><a class="indexterm" name="idm45879497238400"></a><a class="indexterm" name="idm45879497236336"></a><p>
        テーブルから情報を取り出すには、<code class="literal">SELECT</code> ステートメントを使用します。 このステートメントの一般的な形式は次のとおりです。 
      </p><pre class="programlisting">SELECT <em class="replaceable"><code>what_to_select</code></em>
FROM <em class="replaceable"><code>which_table</code></em>
WHERE <em class="replaceable"><code>conditions_to_satisfy</code></em>;
</pre><p>
        <em class="replaceable"><code>what_to_select</code></em> は取得する対象です。 これには、カラムのリストか、<span class="quote">「<span class="quote">すべてのカラム</span>」</span>を表す <code class="literal">*</code> を指定できます。<em class="replaceable"><code>which_table</code></em> は、データを取り出すテーブルです。 <code class="literal">WHERE</code> 句はオプションです。 指定する場合は、取得対象となる行の条件を 1 つまたは複数 <em class="replaceable"><code>conditions_to_satisfy</code></em> に指定します。 
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="selecting-all"></a>3.3.4.1 すべてのデータの選択</h4></div></div></div><p>
          <code class="literal">SELECT</code> のもっとも単純な形式では、テーブルのすべての内容が取り出されます。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM pet;</code></strong>
+----------+--------+---------+------+------------+------------+
| name     | owner  | species | sex  | birth      | death      |
+----------+--------+---------+------+------------+------------+
| Fluffy   | Harold | cat     | f    | 1993-02-04 | NULL       |
| Claws    | Gwen   | cat     | m    | 1994-03-17 | NULL       |
| Buffy    | Harold | dog     | f    | 1989-05-13 | NULL       |
| Fang     | Benny  | dog     | m    | 1990-08-27 | NULL       |
| Bowser   | Diane  | dog     | m    | 1979-08-31 | 1995-07-29 |
| Chirpy   | Gwen   | bird    | f    | 1998-09-11 | NULL       |
| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |
| Slim     | Benny  | snake   | m    | 1996-04-29 | NULL       |
| Puffball | Diane  | hamster | f    | 1999-03-30 | NULL       |
+----------+--------+---------+------+------------+------------+
</pre><p>
          この形式の <code class="literal">SELECT</code> では、<span class="quote">「<span class="quote">「すべてのカラムの選択」</span>」</span>の短縮形である <code class="literal">*</code> を使用します。 これは、初期データセットとともにロードした後など、テーブル全体を確認する場合に便利です。 たとえば、Bowser の生年月日が正しくないようだと気付いたとします。 血統書の原本を確認すると、正しい生年は 1979 年ではなく 1989 年であるとわかりました。 
        </p><p>
          これを修正するには、少なくとも 2 つの方法があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              ファイル <code class="filename">pet.txt</code> を編集して間違いを修正したあと、<code class="literal">DELETE</code> と <code class="literal">LOAD DATA</code> を使用してテーブルを空にしてからリロードします。
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>DELETE FROM pet;</code></strong>
mysql&gt; <strong class="userinput"><code>LOAD DATA LOCAL INFILE 'pet.txt' INTO TABLE pet;</code></strong>
</pre><p>
              ただし、この方法では、Puffball のレコードも再度入力する必要があります。
            </p></li><li class="listitem"><p>
              <code class="literal">UPDATE</code> ステートメントを使用して、間違ったレコードだけを修正します。
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE pet SET birth = '1989-08-31' WHERE name = 'Bowser';</code></strong>
</pre><p>
              <code class="literal">UPDATE</code> は該当するレコードだけを変更するため、テーブルをリロードする必要はありません。
            </p></li></ul></div><p>
          <code class="literal">SELECT *</code> がすべてのカラムを選択するという原則には例外があります。 テーブルに非表示カラムが含まれている場合、<code class="literal">*</code> には非表示カラムは含まれません。 詳細は、<a class="xref" href="sql-statements.html#invisible-columns" title="13.1.20.10 非表示カラム">セクション13.1.20.10「非表示カラム」</a>を参照してください。 
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="selecting-rows"></a>3.3.4.2 特定の行の選択</h4></div></div></div><a class="indexterm" name="idm45879497201504"></a><a class="indexterm" name="idm45879497199360"></a><p>
          前のセクションで説明したとおり、テーブル全体を取り出すことは簡単です。 <code class="literal">SELECT</code> ステートメントから <code class="literal">WHERE</code> 句を省略するだけで済みます。 ただし、特にテーブルが大きくなってくると、テーブル全体を取り出すことは通常ありません。 通常は特定の質問に対する回答が必要であり、そのために、取得する情報に関していくつかの制約を指定します。 ペットに関する質問に対して回答を得る選択クエリーをいくつか見てみましょう。 
        </p><p>
          テーブルから特定の行だけを選択することができます。 たとえば、Bowser の誕生日に加えた変更を確認するには、次のように Bowser のレコードを選択します。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM pet WHERE name = 'Bowser';</code></strong>
+--------+-------+---------+------+------------+------------+
| name   | owner | species | sex  | birth      | death      |
+--------+-------+---------+------+------------+------------+
| Bowser | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+-------+---------+------+------------+------------+
</pre><p>
          出力から、1979 年ではなく 1989 年と正しく記録されていることが確認されます。
        </p><p>
          通常、文字列の比較では大文字と小文字が区別されないため、名前の指定には <code class="literal">'bowser'</code> や <code class="literal">'BOWSER'</code> などを使用できます。 クエリーの結果は同じになります。 
        </p><p>
          <code class="literal">name</code> だけでなく、任意のカラムに条件を指定できます。 たとえば、1998 年以降に生まれたペットを調べるには、<code class="literal">birth</code> カラムを検査します。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM pet WHERE birth &gt;= '1998-1-1';</code></strong>
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Puffball | Diane | hamster | f    | 1999-03-30 | NULL  |
+----------+-------+---------+------+------------+-------+
</pre><p>
          条件を組み合わせて、たとえば雌の犬を特定することができます。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM pet WHERE species = 'dog' AND sex = 'f';</code></strong>
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</pre><p>
          前のクエリーでは、<code class="literal">AND</code> 論理演算子が使用されています。 <code class="literal">OR</code> 演算子もあります。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM pet WHERE species = 'snake' OR species = 'bird';</code></strong>
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL  |
| Slim     | Benny | snake   | m    | 1996-04-29 | NULL  |
+----------+-------+---------+------+------------+-------+
</pre><p>
          <code class="literal">AND</code> と <code class="literal">OR</code> は一緒に使用できますが、<code class="literal">AND</code> は <code class="literal">OR</code> よりも高い優先順位を持っています。 両方の演算子を一緒に使用する場合は、括弧を使用して条件の組み合わせ方を明示的に示すことをお勧めします。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM pet WHERE (species = 'cat' AND sex = 'm')</code></strong>
       <strong class="userinput"><code>OR (species = 'dog' AND sex = 'f');</code></strong>
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="selecting-columns"></a>3.3.4.3 特定のカラムの選択</h4></div></div></div><a class="indexterm" name="idm45879497169904"></a><a class="indexterm" name="idm45879497167792"></a><p>
          テーブルの行全体ではなく特定のカラムを取得するには、カラムの名前をカンマで区切って指定します。 たとえば、ペットの生年月日を調べるには、<code class="literal">name</code> カラムと <code class="literal">birth</code> カラムを選択します。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT name, birth FROM pet;</code></strong>
+----------+------------+
| name     | birth      |
+----------+------------+
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Buffy    | 1989-05-13 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Puffball | 1999-03-30 |
+----------+------------+
</pre><p>
          ペットの所有者を調べるには、次のクエリーを使用します。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT owner FROM pet;</code></strong>
+--------+
| owner  |
+--------+
| Harold |
| Gwen   |
| Harold |
| Benny  |
| Diane  |
| Gwen   |
| Gwen   |
| Benny  |
| Diane  |
+--------+
</pre><a class="indexterm" name="idm45879497159488"></a><p>
          このクエリーは各レコードから <code class="literal">owner</code> カラムを取り出すだけなため、一部は複数回出現しています。 出力を最小化するには、キーワード <code class="literal">DISTINCT</code> を追加して、一意の出力レコードをそれぞれ 1 回だけ取り出すようにします。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT DISTINCT owner FROM pet;</code></strong>
+--------+
| owner  |
+--------+
| Benny  |
| Diane  |
| Gwen   |
| Harold |
+--------+
</pre><p>
          <code class="literal">WHERE</code> 句を使用して、行の選択とカラムの選択を組み合わせることができます。 たとえば、犬と猫だけについて生年月日を調べるには、次のクエリーを使用します。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT name, species, birth FROM pet</code></strong>
       <strong class="userinput"><code>WHERE species = 'dog' OR species = 'cat';</code></strong>
+--------+---------+------------+
| name   | species | birth      |
+--------+---------+------------+
| Fluffy | cat     | 1993-02-04 |
| Claws  | cat     | 1994-03-17 |
| Buffy  | dog     | 1989-05-13 |
| Fang   | dog     | 1990-08-27 |
| Bowser | dog     | 1989-08-31 |
+--------+---------+------------+
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sorting-rows"></a>3.3.4.4 行のソート</h4></div></div></div><a class="indexterm" name="idm45879497148544"></a><a class="indexterm" name="idm45879497147200"></a><a class="indexterm" name="idm45879497145056"></a><a class="indexterm" name="idm45879497143008"></a><a class="indexterm" name="idm45879497140976"></a><p>
          前の例で、結果の行の表示には特定の順序がないことに気付いたでしょう。 多くの場合、クエリーの出力は、行を何らかの意味のある順序でソートすると確認しやすくなります。 結果をソートするには、<code class="literal">ORDER BY</code> 句を使用します。 
        </p><p>
          次に、ペットの生年月日を日付でソートしたものを示します。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT name, birth FROM pet ORDER BY birth;</code></strong>
+----------+------------+
| name     | birth      |
+----------+------------+
| Buffy    | 1989-05-13 |
| Bowser   | 1989-08-31 |
| Fang     | 1990-08-27 |
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Slim     | 1996-04-29 |
| Whistler | 1997-12-09 |
| Chirpy   | 1998-09-11 |
| Puffball | 1999-03-30 |
+----------+------------+
</pre><p>
          文字型のカラムでは、ソートはほかのすべての比較演算と同様に、通常大文字小文字の区別なしで実行されます。 したがって、大文字と小文字の違いしかないカラムの場合、順序は未定義になります。 カラムのソートで大文字と小文字を区別するには、<code class="literal">BINARY</code> を使用し、<code class="literal">ORDER BY BINARY <em class="replaceable"><code>col_name</code></em></code> のように指定します。 
        </p><p>
          デフォルトのソート順序は昇順で、最小値が最初になります。 逆順 (降順) でソートするには、ソートするカラムの名前に <code class="literal">DESC</code> キーワードを加えてください。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT name, birth FROM pet ORDER BY birth DESC;</code></strong>
+----------+------------+
| name     | birth      |
+----------+------------+
| Puffball | 1999-03-30 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Claws    | 1994-03-17 |
| Fluffy   | 1993-02-04 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Buffy    | 1989-05-13 |
+----------+------------+
</pre><p>
          複数のカラムでソートでき、ソートの方向はカラムごとに変えることができます。 たとえば、ペットの種類で昇順にソートしてから、同じ種類の中では生年月日で降順に (若い順に) ソートするには、次のクエリーを使用します。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT name, species, birth FROM pet</code></strong>
       <strong class="userinput"><code>ORDER BY species, birth DESC;</code></strong>
+----------+---------+------------+
| name     | species | birth      |
+----------+---------+------------+
| Chirpy   | bird    | 1998-09-11 |
| Whistler | bird    | 1997-12-09 |
| Claws    | cat     | 1994-03-17 |
| Fluffy   | cat     | 1993-02-04 |
| Fang     | dog     | 1990-08-27 |
| Bowser   | dog     | 1989-08-31 |
| Buffy    | dog     | 1989-05-13 |
| Puffball | hamster | 1999-03-30 |
| Slim     | snake   | 1996-04-29 |
+----------+---------+------------+
</pre><p>
          <code class="literal">DESC</code> キーワードはその直前のカラム名 (<code class="literal">birth</code>) だけに適用されます。<code class="literal">species</code> カラムのソート順序には影響を与えません。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="date-calculations"></a>3.3.4.5 日付の計算</h4></div></div></div><a class="indexterm" name="idm45879497120672"></a><a class="indexterm" name="idm45879497119200"></a><a class="indexterm" name="idm45879497117168"></a><a class="indexterm" name="idm45879497115136"></a><p>
          MySQL には、年齢の計算や日付の一部の抽出など、日付の計算に使用できる関数がいくつか用意されています。
        </p><p>
          それぞれのペットが何歳なのかを判別するには、<code class="literal">TIMESTAMPDIFF()</code> 関数を使用します。 引数は、結果を表す単位と、差異を取る 2 つの日付です。 次のクエリーでは、各ペットの生年月日、現在の日付、および年齢が表示されます。 出力の最後のカラムラベルに意味を持たせるために、<span class="emphasis"><em>エイリアス</em></span> (<code class="literal">age</code>) が使用されています。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT name, birth, CURDATE(),</code></strong>
       <strong class="userinput"><code>TIMESTAMPDIFF(YEAR,birth,CURDATE()) AS age</code></strong>
       <strong class="userinput"><code>FROM pet;</code></strong>
+----------+------------+------------+------+
| name     | birth      | CURDATE()  | age  |
+----------+------------+------------+------+
| Fluffy   | 1993-02-04 | 2003-08-19 |   10 |
| Claws    | 1994-03-17 | 2003-08-19 |    9 |
| Buffy    | 1989-05-13 | 2003-08-19 |   14 |
| Fang     | 1990-08-27 | 2003-08-19 |   12 |
| Bowser   | 1989-08-31 | 2003-08-19 |   13 |
| Chirpy   | 1998-09-11 | 2003-08-19 |    4 |
| Whistler | 1997-12-09 | 2003-08-19 |    5 |
| Slim     | 1996-04-29 | 2003-08-19 |    7 |
| Puffball | 1999-03-30 | 2003-08-19 |    4 |
+----------+------------+------------+------+
</pre><p>
          このクエリーは正しく動作しますが、結果の行を何らかの順序で表示すると確認しやすくなるでしょう。 そのためには、<code class="literal">ORDER BY name</code> 句を追加することで、出力を名前でソートできます。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT name, birth, CURDATE(),</code></strong>
       <strong class="userinput"><code>TIMESTAMPDIFF(YEAR,birth,CURDATE()) AS age</code></strong>
       <strong class="userinput"><code>FROM pet ORDER BY name;</code></strong>
+----------+------------+------------+------+
| name     | birth      | CURDATE()  | age  |
+----------+------------+------------+------+
| Bowser   | 1989-08-31 | 2003-08-19 |   13 |
| Buffy    | 1989-05-13 | 2003-08-19 |   14 |
| Chirpy   | 1998-09-11 | 2003-08-19 |    4 |
| Claws    | 1994-03-17 | 2003-08-19 |    9 |
| Fang     | 1990-08-27 | 2003-08-19 |   12 |
| Fluffy   | 1993-02-04 | 2003-08-19 |   10 |
| Puffball | 1999-03-30 | 2003-08-19 |    4 |
| Slim     | 1996-04-29 | 2003-08-19 |    7 |
| Whistler | 1997-12-09 | 2003-08-19 |    5 |
+----------+------------+------------+------+
</pre><p>
          出力を <code class="literal">name</code> ではなく <code class="literal">age</code> でソートするには、異なる <code class="literal">ORDER BY</code> 句を使用します。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT name, birth, CURDATE(),</code></strong>
       <strong class="userinput"><code>TIMESTAMPDIFF(YEAR,birth,CURDATE()) AS age</code></strong>
       <strong class="userinput"><code>FROM pet ORDER BY age;</code></strong>
+----------+------------+------------+------+
| name     | birth      | CURDATE()  | age  |
+----------+------------+------------+------+
| Chirpy   | 1998-09-11 | 2003-08-19 |    4 |
| Puffball | 1999-03-30 | 2003-08-19 |    4 |
| Whistler | 1997-12-09 | 2003-08-19 |    5 |
| Slim     | 1996-04-29 | 2003-08-19 |    7 |
| Claws    | 1994-03-17 | 2003-08-19 |    9 |
| Fluffy   | 1993-02-04 | 2003-08-19 |   10 |
| Fang     | 1990-08-27 | 2003-08-19 |   12 |
| Bowser   | 1989-08-31 | 2003-08-19 |   13 |
| Buffy    | 1989-05-13 | 2003-08-19 |   14 |
+----------+------------+------------+------+
</pre><p>
          類似のクエリーを使用して、死んだペットの死亡時の年齢を求めることができます。 どのペットなのかを判断するには、<code class="literal">death</code> 値が <code class="literal">NULL</code> かどうかを確認します。 次に、<code class="literal">NULL</code> でない値について、<code class="literal">death</code> 値と <code class="literal">birth</code> 値の差を計算します。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT name, birth, death,</code></strong>
       <strong class="userinput"><code>TIMESTAMPDIFF(YEAR,birth,death) AS age</code></strong>
       <strong class="userinput"><code>FROM pet WHERE death IS NOT NULL ORDER BY age;</code></strong>
+--------+------------+------------+------+
| name   | birth      | death      | age  |
+--------+------------+------------+------+
| Bowser | 1989-08-31 | 1995-07-29 |    5 |
+--------+------------+------------+------+
</pre><p>
          このクエリーでは、<code class="literal">death &lt;&gt; NULL</code> ではなく <code class="literal">death IS NOT NULL</code> を使用します。<code class="literal">NULL</code> は通常の比較演算子を使用して比較することができない特殊な値であるためです。 これについてはあとで説明します。 <a class="xref" href="tutorial.html#working-with-null" title="3.3.4.6 NULL 値の操作">セクション3.3.4.6「NULL 値の操作」</a>を参照してください。 
        </p><p>
          来月誕生日を迎えるペットを調べるにはどうしますか。 このような計算の場合、年と日は無関係で、<code class="literal">birth</code> カラムの月の部分を抽出するだけで済みます。 MySQL には、<code class="literal">YEAR()</code>、<code class="literal">MONTH()</code>、<code class="literal">DAYOFMONTH()</code> など、日付の一部を抽出する関数がいくつか用意されています。 ここでは <code class="literal">MONTH()</code> 関数が適しています。 動作の仕組みを確認するために、<code class="literal">birth</code> と <code class="literal">MONTH(birth)</code> の両方の値を表示する単純なクエリーを実行します。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT name, birth, MONTH(birth) FROM pet;</code></strong>
+----------+------------+--------------+
| name     | birth      | MONTH(birth) |
+----------+------------+--------------+
| Fluffy   | 1993-02-04 |            2 |
| Claws    | 1994-03-17 |            3 |
| Buffy    | 1989-05-13 |            5 |
| Fang     | 1990-08-27 |            8 |
| Bowser   | 1989-08-31 |            8 |
| Chirpy   | 1998-09-11 |            9 |
| Whistler | 1997-12-09 |           12 |
| Slim     | 1996-04-29 |            4 |
| Puffball | 1999-03-30 |            3 |
+----------+------------+--------------+
</pre><p>
          来月誕生日を迎えるペットを見つけることも簡単です。 今月は 4 月だとします。 月の値は <code class="literal">4</code> であるため、5 月 (月 <code class="literal">5</code>) に生まれたペットは次のように探すことができます。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT name, birth FROM pet WHERE MONTH(birth) = 5;</code></strong>
+-------+------------+
| name  | birth      |
+-------+------------+
| Buffy | 1989-05-13 |
+-------+------------+
</pre><p>
          今月が 12 月の場合は多少複雑になります。 月の番号 (<code class="literal">12</code>) に単に 1 を加算して <code class="literal">13</code> 月に生まれたペットを探すということはできません。そのような月は存在しないからです。 代わりに、1 月 (月 <code class="literal">1</code>) に生まれたペットを探します。 
        </p><p>
          現在が何月であっても機能するクエリーを記述すると、特定の月の番号を使用する必要がなくなります。 <code class="literal">DATE_ADD()</code> を使用すると、所定の日付に時間間隔を加算できます。 <code class="literal">CURDATE()</code> の値に 1 か月を加算してから、月の部分を <code class="literal">MONTH()</code> で抽出すると、誕生日を調べる月が得られます。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT name, birth FROM pet</code></strong>
       <strong class="userinput"><code>WHERE MONTH(birth) = MONTH(DATE_ADD(CURDATE(),INTERVAL 1 MONTH));</code></strong>
</pre><p>
          現在の月の値が <code class="literal">12</code> の場合はモジュロ関数 (<code class="literal">MOD</code>) を適用して <code class="literal">0</code> に折り返してから、<code class="literal">1</code> を加算する方法でも、同じタスクを達成できます。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT name, birth FROM pet</code></strong>
       <strong class="userinput"><code>WHERE MONTH(birth) = MOD(MONTH(CURDATE()), 12) + 1;</code></strong>
</pre><p>
          <code class="literal">MONTH()</code> は <code class="literal">1</code> から <code class="literal">12</code> までの数値を返します。 また、<code class="literal">MOD(something,12)</code> は <code class="literal">0</code> から <code class="literal">11</code> までの数値を返します。 したがって、<code class="literal">MOD()</code> のあとで加算を行わないと、<code class="literal">11</code> 月から <code class="literal">1</code> 月に進んでしまいます。 
        </p><p>
          計算に無効な日付が使用されている場合、計算は失敗し、警告が生成されます:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT '2018-10-31' + INTERVAL 1 DAY;</code></strong>
+-------------------------------+
| '2018-10-31' + INTERVAL 1 DAY |
+-------------------------------+
| 2018-11-01                    |
+-------------------------------+
mysql&gt; <strong class="userinput"><code>SELECT '2018-10-32' + INTERVAL 1 DAY;</code></strong>
+-------------------------------+
| '2018-10-32' + INTERVAL 1 DAY |
+-------------------------------+
| NULL                          |
+-------------------------------+
mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+---------+------+----------------------------------------+
| Level   | Code | Message                                |
+---------+------+----------------------------------------+
| Warning | 1292 | Incorrect datetime value: '2018-10-32' |
+---------+------+----------------------------------------+
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="working-with-null"></a>3.3.4.6 NULL 値の操作</h4></div></div></div><a class="indexterm" name="idm45879497039984"></a><a class="indexterm" name="idm45879497038672"></a><p>
          <code class="literal">NULL</code> 値に慣れるまでは驚くかもしれません。 概念的には、<code class="literal">NULL</code> は<span class="quote">「<span class="quote">存在しない不明な値</span>」</span>を意味し、ほかの値とは多少異なる方法で扱われます。 
        </p><p>
          <code class="literal">NULL</code> を調べるために、次に示すように <code class="literal">IS NULL</code> および <code class="literal">IS NOT NULL</code> 演算子を使用します。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT 1 IS NULL, 1 IS NOT NULL;</code></strong>
+-----------+---------------+
| 1 IS NULL | 1 IS NOT NULL |
+-----------+---------------+
|         0 |             1 |
+-----------+---------------+
</pre><p>
          <code class="literal">=</code>、<code class="literal">&lt;</code>、または <code class="literal">&lt;&gt;</code> などの算術比較演算子を使用して <code class="literal">NULL</code> をテストすることはできません。 これを自分で確認するために、次のクエリーを実行してみてください。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT 1 = NULL, 1 &lt;&gt; NULL, 1 &lt; NULL, 1 &gt; NULL;</code></strong>
+----------+-----------+----------+----------+
| 1 = NULL | 1 &lt;&gt; NULL | 1 &lt; NULL | 1 &gt; NULL |
+----------+-----------+----------+----------+
|     NULL |      NULL |     NULL |     NULL |
+----------+-----------+----------+----------+
</pre><p>
          <code class="literal">NULL</code> に関する算術比較は、結果もすべて <code class="literal">NULL</code> になるため、このような比較から意味のある結果を得ることはできません。
        </p><p>
          MySQL では、<code class="literal">0</code> や <code class="literal">NULL</code> は false を意味し、それ以外はすべて true を意味します。 ブール演算のデフォルトの真理値は <code class="literal">1</code> です。 
        </p><p>
          <code class="literal">NULL</code> がこのように特殊な方法で扱われているため、前のセクションで、どの動物がもう生きていいないのかを判断するために、<code class="literal">death &lt;&gt; NULL</code> ではなく <code class="literal">death IS NOT NULL</code> を使用することが必要だったのです。
        </p><p>
          <code class="literal">GROUP BY</code> では、2 つの <code class="literal">NULL</code> 値は等しいとみなされます。
        </p><p>
          <code class="literal">ORDER BY</code> を実行する場合、<code class="literal">NULL</code> 値は <code class="literal">ORDER BY ... ASC</code> では最初に表示され、<code class="literal">ORDER BY ... DESC</code> では最後に表示されます。
        </p><p>
          <code class="literal">NULL</code> を操作するときによくある間違いは、<code class="literal">NOT NULL</code> と定義されたカラムにはゼロや空の文字列は挿入できないと想定することです。 これらは実際に値ですが、一方 <code class="literal">NULL</code> は<span class="quote">「<span class="quote">値がない</span>」</span>ことを意味します。 このことは、次に示すように <code class="literal">IS [NOT] NULL</code> を使用してとても簡単にテストできます。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT 0 IS NULL, 0 IS NOT NULL, '' IS NULL, '' IS NOT NULL;</code></strong>
+-----------+---------------+------------+----------------+
| 0 IS NULL | 0 IS NOT NULL | '' IS NULL | '' IS NOT NULL |
+-----------+---------------+------------+----------------+
|         0 |             1 |          0 |              1 |
+-----------+---------------+------------+----------------+
</pre><p>
          このように、ゼロや空の文字列は実際に <code class="literal">NOT NULL</code> であるため、<code class="literal">NOT NULL</code> カラムに挿入することができます。 <a class="xref" href="error-handling.html#problems-with-null" title="B.3.4.3 NULL 値に関する問題">セクションB.3.4.3「NULL 値に関する問題」</a>を参照してください。 
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="pattern-matching"></a>3.3.4.7 パターンマッチング</h4></div></div></div><a class="indexterm" name="idm45879496998736"></a><a class="indexterm" name="idm45879496997280"></a><a class="indexterm" name="idm45879496995248"></a><p>
          MySQL では、標準の SQL パターンマッチングに加え、<span class="command"><strong>vi</strong></span>、<span class="command"><strong>grep</strong></span>、<span class="command"><strong>sed</strong></span> などの Unix ユーティリティーで使用されるものに似た拡張正規表現に基づくパターンマッチング形式が提供されています。
        </p><p>
          SQL パターン一致を使用すると、<code class="literal">_</code>を使用して任意の単一文字を照合し、<code class="literal">%</code> を使用して任意の数の文字 (ゼロ文字を含む) を照合できます。 MySQL のデフォルトでは、SQL パターンでは大文字と小文字が区別されません。 次にいくつかの例を示します。 SQL パターンを使用する場合は、<code class="literal">=</code> または <code class="literal">&lt;&gt;</code> を使用しないでください。 かわりに、<code class="literal">LIKE</code> または <code class="literal">NOT LIKE</code> の比較演算子を使用します。 
        </p><p>
          <code class="literal">b</code>で始まる名前を探すには:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM pet WHERE name LIKE 'b%';</code></strong>
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+--------+---------+------+------------+------------+
</pre><p>
          <code class="literal">fy</code>で終わる名前を探すには:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM pet WHERE name LIKE '%fy';</code></strong>
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | f    | 1993-02-04 | NULL  |
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL  |
+--------+--------+---------+------+------------+-------+
</pre><p>
          <code class="literal">w</code>を含む名前を探すには:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM pet WHERE name LIKE '%w%';</code></strong>
+----------+-------+---------+------+------------+------------+
| name     | owner | species | sex  | birth      | death      |
+----------+-------+---------+------+------------+------------+
| Claws    | Gwen  | cat     | m    | 1994-03-17 | NULL       |
| Bowser   | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL       |
+----------+-------+---------+------+------------+------------+
</pre><p>
          ちょうど 5 文字の名前を探すには、<code class="literal">_</code>パターン文字の 5 つのインスタンスを使用します。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM pet WHERE name LIKE '_____';</code></strong>
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</pre><p>
          MySQL で提供されているもう 1 種類のパターンマッチングは、拡張正規表現を使用します。 このタイプのパターンの一致をテストする場合は、<code class="literal">REGEXP_LIKE()</code> 関数 (または <code class="literal">REGEXP_LIKE()</code> のシノニムである <code class="literal">REGEXP</code> または <code class="literal">RLIKE</code> 演算子) を使用します。 
        </p><p>
          次の表に、拡張正規表現の特徴の一部を示します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">.</code>は任意の 1 文字に一致します。
            </p></li><li class="listitem"><p>
              文字クラス<code class="literal">[...]</code>は、括弧内のいずれかの文字に一致します。 たとえば、<code class="literal">[abc]</code>は <code class="literal">a</code>、<code class="literal">b</code> または <code class="literal">c</code> と一致します。 文字の範囲に名前を付けるには、ダッシュを使用します。<code class="literal">[a-z]</code>は任意の文字に一致しますが、<code class="literal">[0-9]</code>は任意の数字に一致します。 
            </p></li><li class="listitem"><p>
              <code class="literal">*</code>は直前の文字の 0 個以上のインスタンスに一致します。 たとえば、<code class="literal">x*</code> は任意の数の <code class="literal">x</code> 文字に一致し、<code class="literal">[0-9]*</code> は任意の数の数字に一致し、<code class="literal">.*</code> は任意の数の任意の数の文字に一致します。 
            </p></li><li class="listitem"><p>
              正規表現パターン一致は、パターンがテスト対象の値のいずれかと一致する場合に成功します。 (これとは異なり、<code class="literal">LIKE</code> パターンマッチングは、パターンが値全体に一致する場合のみ成功です。) 
            </p></li><li class="listitem"><p>
              テストする値の先頭または末尾と一致するようにパターンをアンカーするには、パターンの先頭で <code class="literal">^</code> を使用するか、パターンの末尾で <code class="literal">$</code> を使用します。
            </p></li></ul></div><p>
          拡張正規表現がどのように機能するかを示すために、前述の <code class="literal">LIKE</code> クエリーは <code class="literal">REGEXP_LIKE()</code> を使用するようにここにリライトされます。
        </p><p>
          <code class="literal">b</code> で始まる名前を検索するには、<code class="literal">^</code> を使用して名前の先頭と一致させます:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM pet WHERE REGEXP_LIKE(name, '^b');</code></strong>
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | m    | 1979-08-31 | 1995-07-29 |
+--------+--------+---------+------+------------+------------+
</pre><p>
          正規表現の比較を強制的に大/小文字を区別するには、大/小文字を区別する照合を使用するか、<code class="literal">BINARY</code> キーワードを使用して文字列のいずれかをバイナリ文字列にするか、<code class="literal">c</code> 一致制御文字を指定します。 これらの各クエリーは、名前の先頭にある小文字の <code class="literal">b</code> のみに一致します: 
        </p><pre class="programlisting">SELECT * FROM pet WHERE REGEXP_LIKE(name, '^b' COLLATE utf8mb4_0900_as_cs);
SELECT * FROM pet WHERE REGEXP_LIKE(name, BINARY '^b');
SELECT * FROM pet WHERE REGEXP_LIKE(name, '^b', 'c');
</pre><p>
          <code class="literal">fy</code> で終わる名前を検索するには、<code class="literal">$</code> を使用して名前の末尾に一致させます:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM pet WHERE REGEXP_LIKE(name, 'fy$');</code></strong>
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | f    | 1993-02-04 | NULL  |
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL  |
+--------+--------+---------+------+------------+-------+
</pre><p>
          <code class="literal">w</code>を含む名前を探すには、次のクエリーを使用します。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM pet WHERE REGEXP_LIKE(name, 'w');</code></strong>
+----------+-------+---------+------+------------+------------+
| name     | owner | species | sex  | birth      | death      |
+----------+-------+---------+------+------------+------------+
| Claws    | Gwen  | cat     | m    | 1994-03-17 | NULL       |
| Bowser   | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL       |
+----------+-------+---------+------+------------+------------+
</pre><p>
          正規表現パターンは値のどこかに出現した場合に一致するため、前のクエリーではワイルドカードをパターンの両側に配置して、SQL パターンの場合と同様に値全体に一致させる必要はありません。
        </p><p>
          正確に 5 文字を含む名前を検索するには、<code class="literal">^</code> と <code class="literal">$</code> を使用して名前の先頭と末尾を照合し、<code class="literal">.</code> の 5 つのインスタンスを次の間で照合します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM pet WHERE REGEXP_LIKE(name, '^.....$');</code></strong>
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</pre><p>
          このクエリーは、<code class="literal">{<em class="replaceable"><code>n</code></em>}</code> (<span class="quote">「<span class="quote"><em class="replaceable"><code>n</code></em> 回繰り返し</span>」</span>) 演算子を使用して記述することもできます。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM pet WHERE REGEXP_LIKE(name, '^.{5}$');</code></strong>
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</pre><p>
          正規表現の構文の詳細は、<a class="xref" href="functions.html#regexp" title="12.8.2 正規表現">セクション12.8.2「正規表現」</a> を参照してください。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="counting-rows"></a>3.3.4.8 行のカウント</h4></div></div></div><a class="indexterm" name="idm45879496919744"></a><a class="indexterm" name="idm45879496917600"></a><a class="indexterm" name="idm45879496915552"></a><p>
          データベースは、<span class="quote">「<span class="quote">テーブルの中に、特定のタイプのデータがどの程度の頻度で現れるか</span>」</span>という質問に答えるために使用されることがよくあります。 たとえば、何匹ペットを飼っているのか、それぞれの所有者が何匹のペットを所有しているかを調べたり、または動物に対してさまざまな個体数調査を実施したりすることがあるでしょう。 
        </p><p>
          ペットの総数をカウントすることは、<span class="quote">「<span class="quote"><code class="literal">pet</code> テーブルには何行あるか</span>」</span>という質問と同等です。このテーブルにはペットごとに 1 つのレコードが存在するからです。 <code class="literal">COUNT(*)</code> は行数をカウントするため、ペットの数をカウントするクエリーは次のようになります。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT COUNT(*) FROM pet;</code></strong>
+----------+
| COUNT(*) |
+----------+
|        9 |
+----------+
</pre><p>
          前に、ペットの所有者の名前を取得しました。 <code class="literal">COUNT()</code> を使用して、各所有者のペットの数を調べることができます。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT owner, COUNT(*) FROM pet GROUP BY owner;</code></strong>
+--------+----------+
| owner  | COUNT(*) |
+--------+----------+
| Benny  |        2 |
| Diane  |        2 |
| Gwen   |        3 |
| Harold |        2 |
+--------+----------+
</pre><p>
          このクエリーは <code class="literal">GROUP BY</code> を使用して各 <code class="literal">owner</code> のすべてのレコードをグループ化しています。 <code class="literal">COUNT()</code> を <code class="literal">GROUP BY</code> とともに使用すると、さまざまなグループ化の下でデータの特徴を示すことができます。 次の例では、ペットの個体数調査を実行するさまざまな方法を示します。 
        </p><p>
          種ごとのペット数
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT species, COUNT(*) FROM pet GROUP BY species;</code></strong>
+---------+----------+
| species | COUNT(*) |
+---------+----------+
| bird    |        2 |
| cat     |        2 |
| dog     |        3 |
| hamster |        1 |
| snake   |        1 |
+---------+----------+
</pre><p>
          性別ごとのペット数
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT sex, COUNT(*) FROM pet GROUP BY sex;</code></strong>
+------+----------+
| sex  | COUNT(*) |
+------+----------+
| NULL |        1 |
| f    |        4 |
| m    |        4 |
+------+----------+
</pre><p>
          (この出力で、<code class="literal">NULL</code> は性別不明を示します。)
        </p><p>
          種と性別の組み合わせごとのペット数
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT species, sex, COUNT(*) FROM pet GROUP BY species, sex;</code></strong>
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| bird    | NULL |        1 |
| bird    | f    |        1 |
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
| hamster | f    |        1 |
| snake   | m    |        1 |
+---------+------+----------+
</pre><p>
          <code class="literal">COUNT()</code> を使用するときにテーブル全体を取り出す必要はありません。 たとえば、前のクエリーを犬と猫だけに対して実行する場合は、次のようになります。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT species, sex, COUNT(*) FROM pet</code></strong>
       <strong class="userinput"><code>WHERE species = 'dog' OR species = 'cat'</code></strong>
       <strong class="userinput"><code>GROUP BY species, sex;</code></strong>
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
+---------+------+----------+
</pre><p>
          または、性別のわかっているペットについてのみ性別ごとのペット数を調べるには:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT species, sex, COUNT(*) FROM pet</code></strong>
       <strong class="userinput"><code>WHERE sex IS NOT NULL</code></strong>
       <strong class="userinput"><code>GROUP BY species, sex;</code></strong>
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| bird    | f    |        1 |
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
| hamster | f    |        1 |
| snake   | m    |        1 |
+---------+------+----------+
</pre><p>
          <code class="literal">COUNT()</code> 値に加え、選択するカラムを指定する場合は、それらのカラムを <code class="literal">GROUP BY</code> 句で指定する必要があります。 そうでない場合は、次のようになります。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">ONLY_FULL_GROUP_BY</code> SQL モードが有効である場合は、エラーが発生します。
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET sql_mode = 'ONLY_FULL_GROUP_BY';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT owner, COUNT(*) FROM pet;</code></strong>
ERROR 1140 (42000): In aggregated query without GROUP BY, expression
#1 of SELECT list contains nonaggregated column 'menagerie.pet.owner';
this is incompatible with sql_mode=only_full_group_by
</pre></li><li class="listitem"><p>
              <code class="literal">ONLY_FULL_GROUP_BY</code> が有効になっていない場合、クエリーはすべての行を単一のグループとして扱うことで処理されますが、各名前付きカラムに選択された値は非決定的です。 サーバーによって任意の行の値が自由に選択されます。 
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET sql_mode = '';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT owner, COUNT(*) FROM pet;</code></strong>
+--------+----------+
| owner  | COUNT(*) |
+--------+----------+
| Harold |        8 |
+--------+----------+
1 row in set (0.00 sec)
</pre></li></ul></div><p>
          <a class="xref" href="functions.html#group-by-handling" title="12.20.3 MySQL での GROUP BY の処理">セクション12.20.3「MySQL での GROUP BY の処理」</a>も参照してください。 <code class="literal">COUNT(<em class="replaceable"><code>expr</code></em>)</code> の動作および関連する最適化の詳細は、<a class="xref" href="functions.html#aggregate-functions" title="12.20.1 集計関数の説明">セクション12.20.1「集計関数の説明」</a> を参照してください。 
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="multiple-tables"></a>3.3.4.9 複数のテーブルの使用</h4></div></div></div><a class="indexterm" name="idm45879496865024"></a><p>
          <code class="literal">pet</code> テーブルはペットの記録を保持します。 獣医の診察や出産といったペットの生涯におけるイベントなど、ペットに関するほかの情報を記録するには、別のテーブルが必要です。 このテーブルはどのようなものにしたらよいでしょうか。 次の情報を含める必要があります。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              各イベントがどのペットに関するものかを示すためのペット名。
            </p></li><li class="listitem"><p>
              イベントがいつ発生したかを示す日付。
            </p></li><li class="listitem"><p>
              イベントを説明するフィールド。
            </p></li><li class="listitem"><p>
              イベントを分類できるようにする場合は、イベントタイプのフィールド。
            </p></li></ul></div><p>
          これらを考慮すると、<code class="literal">event</code> テーブルの <code class="literal">CREATE TABLE</code> ステートメントは次のようになります。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE event (name VARCHAR(20), date DATE,</code></strong>
       <strong class="userinput"><code>type VARCHAR(15), remark VARCHAR(255));</code></strong>
</pre><p>
          <code class="literal">pet</code> テーブルの場合と同様に、初期レコードをロードするもっとも簡単な方法として、次の情報を記述したタブ区切りのテキストファイルを作成します。
        </p><div class="informaltable"><table summary="pet record data that appears in a tab delimited text file, as described in the preceding text."><col width="15%"><col width="15%"><col width="15%"><col width="35%"><thead><tr>
              <th scope="col">name</th>
              <th scope="col">date</th>
              <th scope="col">type</th>
              <th scope="col">remark</th>
            </tr></thead><tbody><tr>
              <th scope="row">Fluffy</th>
              <td>1995-05-15</td>
              <td>litter</td>
              <td>4 kittens, 3 female, 1 male</td>
            </tr><tr>
              <th scope="row">Buffy</th>
              <td>1993-06-23</td>
              <td>litter</td>
              <td>5 puppies, 2 female, 3 male</td>
            </tr><tr>
              <th scope="row">Buffy</th>
              <td>1994-06-19</td>
              <td>litter</td>
              <td>3 puppies, 3 female</td>
            </tr><tr>
              <th scope="row">Chirpy</th>
              <td>1999-03-21</td>
              <td>vet</td>
              <td>needed beak straightened</td>
            </tr><tr>
              <th scope="row">Slim</th>
              <td>1997-08-03</td>
              <td>vet</td>
              <td>broken rib</td>
            </tr><tr>
              <th scope="row">Bowser</th>
              <td>1991-10-12</td>
              <td>kennel</td>
              <td></td>
            </tr><tr>
              <th scope="row">Fang</th>
              <td>1991-10-12</td>
              <td>kennel</td>
              <td></td>
            </tr><tr>
              <th scope="row">Fang</th>
              <td>1998-08-28</td>
              <td>birthday</td>
              <td>Gave him a new chew toy</td>
            </tr><tr>
              <th scope="row">Claws</th>
              <td>1998-03-17</td>
              <td>birthday</td>
              <td>Gave him a new flea collar</td>
            </tr><tr>
              <th scope="row">Whistler</th>
              <td>1998-12-09</td>
              <td>birthday</td>
              <td>First birthday</td>
            </tr></tbody></table></div><p>
          次のようにレコードをロードします。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>LOAD DATA LOCAL INFILE 'event.txt' INTO TABLE event;</code></strong>
</pre><p>
          <code class="literal">pet</code> テーブルで実行したクエリーから学んだことを基にすれば、原則は同じであるため <code class="literal">event</code> テーブルのレコードも取得できるはずです。 ただし、<code class="literal">event</code> テーブルだけでは質問に回答できない場合はどのようなときでしょうか。 
        </p><p>
          各ペットの出産時の年齢を調べるとします。 前に、2 つの日付から年齢を計算する方法を学びました。 ペットの出産日は <code class="literal">event</code> テーブルにありますが、その日付での年齢を計算するには生年月日が必要で、それは <code class="literal">pet</code> テーブルにあります。 したがって、このクエリーには両方のテーブルが必要です。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT pet.name,</code></strong>
       <strong class="userinput"><code>TIMESTAMPDIFF(YEAR,birth,date) AS age,</code></strong>
       <strong class="userinput"><code>remark</code></strong>
       <strong class="userinput"><code>FROM pet INNER JOIN event</code></strong>
         <strong class="userinput"><code>ON pet.name = event.name</code></strong>
       <strong class="userinput"><code>WHERE event.type = 'litter';</code></strong>
+--------+------+-----------------------------+
| name   | age  | remark                      |
+--------+------+-----------------------------+
| Fluffy |    2 | 4 kittens, 3 female, 1 male |
| Buffy  |    4 | 5 puppies, 2 female, 3 male |
| Buffy  |    5 | 3 puppies, 3 female         |
+--------+------+-----------------------------+
</pre><p>
          このクエリーには注目するべき点がいくつかあります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              このクエリーは両方のテーブルから情報を取り出す必要があるため、<code class="literal">FROM</code> 句で 2 つのテーブルを結合しています。
            </p></li><li class="listitem"><p>
              複数のテーブルの情報を組み合わせる (結合する) 場合、1 つのテーブルのレコードとほかのテーブルのレコードがどのように対応するかを指定する必要があります。 両方のテーブルに <code class="literal">name</code> カラムがあるため、これは簡単です。 このクエリーは、<code class="literal">ON</code> 句を使用して、2 つのテーブルのレコードを <code class="literal">name</code> 値に基づいて対応させています。 
            </p><p>
              このクエリーは <code class="literal">INNER JOIN</code> を使用してテーブルを結合しています。 <code class="literal">INNER JOIN</code> では、<code class="option">ON</code> 句で指定された条件を両方のテーブルが満たす場合にかぎって、結果にテーブルの行が許可されます。 この例では、<code class="literal">pet</code> テーブルの <code class="literal">name</code> カラムと <code class="literal">event</code> テーブルの <code class="literal">name</code> カラムが一致する必要があると <code class="literal">ON</code> 句で指定しています。 一方のテーブルに名前が表示され、他方のテーブルには表示されない場合、<code class="literal">ON</code> 句の条件が失敗するため、結果に行は表示されません。 
            </p></li><li class="listitem"><p>
              <code class="literal">name</code> カラムは両方のテーブルにあるため、このカラムを参照するときはどちらのテーブルのものかを明確に示す必要があります。 そのためには、カラム名の前にテーブル名を付加します。 
            </p></li></ul></div><p>
          2 つの異なるテーブルでなくても結合は実行できます。 テーブル内のレコードをその同じテーブル内のほかのレコードと比較する場合に、テーブルをそれ自体に結合すると役立つことがあります。 たとえば、ペットどうしの飼育ペアを検索するには、<code class="literal">pet</code> テーブルを自分自身と結合して、存命の雄と同一種の雌の候補ペアを生成します: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT p1.name, p1.sex, p2.name, p2.sex, p1.species</code></strong>
       <strong class="userinput"><code>FROM pet AS p1 INNER JOIN pet AS p2</code></strong>
         <strong class="userinput"><code>ON p1.species = p2.species</code></strong>
         <strong class="userinput"><code>AND p1.sex = 'f' AND p1.death IS NULL</code></strong>
         <strong class="userinput"><code>AND p2.sex = 'm' AND p2.death IS NULL;</code></strong>
+--------+------+-------+------+---------+
| name   | sex  | name  | sex  | species |
+--------+------+-------+------+---------+
| Fluffy | f    | Claws | m    | cat     |
| Buffy  | f    | Fang  | m    | dog     |
+--------+------+-------+------+---------+
</pre><p>
          このクエリーでは、テーブル名のエイリアスを指定してカラムを参照し、各カラムがテーブルのどちらのインスタンスに関連するかを必ず明確にしています。
        </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="getting-information"></a>3.4 データベースとテーブルに関する情報の取得</h2></div></div></div><a class="indexterm" name="idm45879496761104"></a><a class="indexterm" name="idm45879496758992"></a><a class="indexterm" name="idm45879496756960"></a><p>
      データベースやテーブルの名前を忘れた場合や、特定のテーブルの構造 (カラムの名前など) を忘れた場合はどうしますか。 MySQL では、この問題に対処するために、サポートしているデータベースとテーブルについて情報を提供するステートメントがいくつか用意されています。 
    </p><p>
      前出の <code class="literal">SHOW DATABASES</code> は、サーバーで管理されているデータベースのリストを表示します。 現在どのデータベースが選択されているかを調べるには、<code class="literal">DATABASE()</code> 関数を使用します。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT DATABASE();</code></strong>
+------------+
| DATABASE() |
+------------+
| menagerie  |
+------------+
</pre><p>
      まだどのデータベースも選択していない場合、結果は <code class="literal">NULL</code> になります。
    </p><p>
      デフォルトデータベースに含まれるテーブルを確認するには (たとえば、テーブルの名前がわからない場合)、次のステートメントを使用します:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW TABLES;</code></strong>
+---------------------+
| Tables_in_menagerie |
+---------------------+
| event               |
| pet                 |
+---------------------+
</pre><p>
      このステートメントで生成される出力のカラム名は常に <code class="literal">Tables_in_<em class="replaceable"><code>db_name</code></em></code> になります。ここで、<em class="replaceable"><code>db_name</code></em> はデータベースの名前です。 詳細については、<a class="xref" href="sql-statements.html#show-tables" title="13.7.7.39 SHOW TABLES ステートメント">セクション13.7.7.39「SHOW TABLES ステートメント」</a>を参照してください。 
    </p><p>
      テーブルの構造を知りたい場合は、<code class="literal">DESCRIBE</code> ステートメントが役に立ちます。このステートメントはテーブルの各カラムの情報を表示します。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>DESCRIBE pet;</code></strong>
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| name    | varchar(20) | YES  |     | NULL    |       |
| owner   | varchar(20) | YES  |     | NULL    |       |
| species | varchar(20) | YES  |     | NULL    |       |
| sex     | char(1)     | YES  |     | NULL    |       |
| birth   | date        | YES  |     | NULL    |       |
| death   | date        | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
</pre><p>
      <code class="literal">Field</code> はカラム名、<code class="literal">Type</code> はそのカラムのデータ型、<code class="literal">NULL</code> はカラムに <code class="literal">NULL</code> 値を含められるかどうか、<code class="literal">Key</code> はカラムにインデックスが設定されているかどうか、<code class="literal">Default</code> はカラムのデフォルト値を示します。 <code class="literal">Extra</code> には、カラムに関する特別な情報が表示されます: <code class="literal">AUTO_INCREMENT</code> オプションを使用してカラムが作成された場合、値は空ではなく <code class="literal">auto_increment</code> です。 
    </p><p>
      <code class="literal">DESC</code> は <code class="literal">DESCRIBE</code> の省略形式です。 詳細については、<a class="xref" href="sql-statements.html#describe" title="13.8.1 DESCRIBE ステートメント">セクション13.8.1「DESCRIBE ステートメント」</a>を参照してください。 
    </p><p>
      既存のテーブルを作成するために必要な <code class="literal">CREATE TABLE</code> ステートメントを、<code class="literal">SHOW CREATE TABLE</code> ステートメントを使用して取得できます。 <a class="xref" href="sql-statements.html#show-create-table" title="13.7.7.10 SHOW CREATE TABLE ステートメント">セクション13.7.7.10「SHOW CREATE TABLE ステートメント」</a>を参照してください。 
    </p><p>
      テーブルにインデックスが設定されている場合は、<code class="literal">SHOW INDEX FROM <em class="replaceable"><code>tbl_name</code></em></code> でその情報を表示できます。 このステートメントの詳細については、<a class="xref" href="sql-statements.html#show-index" title="13.7.7.22 SHOW INDEX ステートメント">セクション13.7.7.22「SHOW INDEX ステートメント」</a>を参照してください。 
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="batch-mode"></a>3.5 バッチモードでの MySQL の使用</h2></div></div></div><a class="indexterm" name="idm45879496721296"></a><a class="indexterm" name="idm45879496719184"></a><a class="indexterm" name="idm45879496717840"></a><a class="indexterm" name="idm45879496715808"></a><a class="indexterm" name="idm45879496714432"></a><a class="indexterm" name="idm45879496712400"></a><p>
      前のセクションでは、<span class="command"><strong>mysql</strong></span> を対話形式で使用してステートメントを入力し、結果を表示しました。 <span class="command"><strong>mysql</strong></span> をバッチモードで実行することもできます。 これを行うには、実行するステートメントをファイルに入れてから、その入力をファイルから読み取るように <span class="command"><strong>mysql</strong></span> に指示します: 
    </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysql &lt; <em class="replaceable"><code>batch-file</code></em></code></strong>
</pre><p>
      <span class="command"><strong>mysql</strong></span> を Windows で実行する場合に、ファイル内の一部の特殊文字によって問題が発生するときは、次のように実行できます。
    </p><pre class="programlisting">C:\&gt; <strong class="userinput"><code>mysql -e "source <em class="replaceable"><code>batch-file</code></em>"</code></strong>
</pre><p>
      コマンド行で接続パラメータを指定する必要がある場合、コマンドは次のようになります。
    </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysql -h <em class="replaceable"><code>host</code></em> -u <em class="replaceable"><code>user</code></em> -p &lt; <em class="replaceable"><code>batch-file</code></em></code></strong>
Enter password: <strong class="userinput"><code>********</code></strong>
</pre><p>
      この方法で <span class="command"><strong>mysql</strong></span> を使用する場合は、スクリプトファイルを作成してから、そのスクリプトを実行することになります。
    </p><p>
      スクリプト内の一部のステートメントでエラーが発生してもスクリプトを続行する場合は、<code class="option">--force</code> コマンド行オプションを使用します。
    </p><p>
      なぜスクリプトを使用するのでしょうか。 いくつかの理由を次に示します。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          クエリーを繰り返し実行する場合 (毎日、毎週など)、スクリプトにすると、実行するたびに入力し直す必要がなくなります。
        </p></li><li class="listitem"><p>
          既存のクエリーのスクリプトファイルをコピーして編集することによって、類似の新しいクエリーを作成できます。
        </p></li><li class="listitem"><p>
          バッチモードは、特に複数行のステートメントまたは一続きの複数ステートメントのクエリーを開発する場合にも役立ちます。 間違いがあっても、すべてを入力し直す必要はありません。 スクリプトを編集して間違いを修正してから、<span class="command"><strong>mysql</strong></span> で再度実行するだけで済みます。 
        </p></li><li class="listitem"><p>
          多量の出力を生成するクエリーの場合、画面でスクロールアップする出力を見る代わりに、pager を介して出力できます。
        </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysql &lt; <em class="replaceable"><code>batch-file</code></em> | more</code></strong>
</pre></li><li class="listitem"><p>
          あとで処理できるように出力をファイルに取り込むことができます。
        </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysql &lt; <em class="replaceable"><code>batch-file</code></em> &gt; mysql.out</code></strong>
</pre></li><li class="listitem"><p>
          スクリプトを他のユーザーに配布して、そのユーザーがステートメントを実行できるようにすることができます。
        </p></li><li class="listitem"><p>
          <span class="command"><strong>cron</strong></span> ジョブからクエリーを実行する場合など、インタラクティブには使用できないことがあります。 この場合はバッチモードを使用する必要があります。 
        </p></li></ul></div><p>
      <span class="command"><strong>mysql</strong></span> をバッチモードで実行したときのデフォルトの出力形式は、インタラクティブに使用した場合とは異なり、より簡潔になります。 たとえば、<span class="command"><strong>mysql</strong></span> をインタラクティブに実行すると、<code class="literal">SELECT DISTINCT species FROM pet</code> の出力は次のようになります。 
    </p><pre class="programlisting">+---------+
| species |
+---------+
| bird    |
| cat     |
| dog     |
| hamster |
| snake   |
+---------+
</pre><p>
      これに対し、バッチモードの出力は次のようになります。
    </p><pre class="programlisting">species
bird
cat
dog
hamster
snake
</pre><p>
      バッチモードで、インタラクティブ出力形式のデータを取得するには、<span class="command"><strong>mysql -t</strong></span> を使用します。 実行されるステートメントを出力にエコーするには、<span class="command"><strong>mysql -v</strong></span> を使用します。 
    </p><a class="indexterm" name="idm45879496672320"></a><a class="indexterm" name="idm45879496670752"></a><a class="indexterm" name="idm45879496669312"></a><a class="indexterm" name="idm45879496667760"></a><p>
      <code class="literal">source</code> コマンドまたは <code class="literal">\.</code> コマンドを使用すると、<span class="command"><strong>mysql</strong></span> プロンプトからでもスクリプトを使用できます。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>source <em class="replaceable"><code>filename</code></em>;</code></strong>
mysql&gt; <strong class="userinput"><code>\. <em class="replaceable"><code>filename</code></em></code></strong>
</pre><p>
      詳細については、<a class="xref" href="programs.html#mysql-batch-commands" title="4.5.1.5 テキストファイルから SQL ステートメントを実行する">セクション4.5.1.5「テキストファイルから SQL ステートメントを実行する」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples"></a>3.6 一般的なクエリーの例</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="tutorial.html#example-maximum-column">3.6.1 カラムの最大値</a></span></dt><dt><span class="section"><a href="tutorial.html#example-maximum-row">3.6.2 特定のカラムの最大値が格納されている行</a></span></dt><dt><span class="section"><a href="tutorial.html#example-maximum-column-group">3.6.3 グループごとのカラムの最大値</a></span></dt><dt><span class="section"><a href="tutorial.html#example-maximum-column-group-row">3.6.4 特定のカラムのグループごとの最大値が格納されている行</a></span></dt><dt><span class="section"><a href="tutorial.html#example-user-variables">3.6.5 ユーザー定義の変数の使用</a></span></dt><dt><span class="section"><a href="tutorial.html#example-foreign-keys">3.6.6 外部キーの使用</a></span></dt><dt><span class="section"><a href="tutorial.html#searching-on-two-keys">3.6.7 2 つのキーを使用した検索</a></span></dt><dt><span class="section"><a href="tutorial.html#calculating-days">3.6.8 日ごとの訪問数の計算</a></span></dt><dt><span class="section"><a href="tutorial.html#example-auto-increment">3.6.9 AUTO_INCREMENT の使用</a></span></dt></dl></div><a class="indexterm" name="idm45879496657952"></a><a class="indexterm" name="idm45879496655840"></a><p>
      ここでは、MySQL に関する一般的な問題を解決する方法の例を示します。
    </p><p>
      一部の例では、テーブル <code class="literal">shop</code> を使用します。このテーブルには、業者 (ディーラー) の物品 (品番) ごとの価格が格納されます。 各業者は物品ごとに 1 つの定価を付けていると仮定すると、(<code class="literal">article</code>, <code class="literal">dealer</code>) がレコードの主キーになります。 
    </p><p>
      コマンド行ツール <span class="command"><strong>mysql</strong></span> を起動し、データベースを選択します。
    </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysql <em class="replaceable"><code>your-database-name</code></em></code></strong>
</pre><p>
      サンプルテーブルを作成して移入するには、次のステートメントを使用します:
    </p><pre class="programlisting">CREATE TABLE shop (
    article INT UNSIGNED  DEFAULT '0000' NOT NULL,
    dealer  CHAR(20)      DEFAULT ''     NOT NULL,
    price   DECIMAL(16,2) DEFAULT '0.00' NOT NULL,
    PRIMARY KEY(article, dealer));
INSERT INTO shop VALUES
    (1,'A',3.45),(1,'B',3.99),(2,'A',10.99),(3,'B',1.45),
    (3,'C',1.69),(3,'D',1.25),(4,'D',19.95);
</pre><p>
      これらのステートメントを発行したあと、テーブルには次の内容が格納されています。
    </p><pre class="programlisting">SELECT * FROM shop ORDER BY article;

+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|       1 | A      |  3.45 |
|       1 | B      |  3.99 |
|       2 | A      | 10.99 |
|       3 | B      |  1.45 |
|       3 | C      |  1.69 |
|       3 | D      |  1.25 |
|       4 | D      | 19.95 |
+---------+--------+-------+
</pre><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="example-maximum-column"></a>3.6.1 カラムの最大値</h3></div></div></div><p>
        <span class="quote">「<span class="quote">もっとも大きい品番は?</span>」</span>
      </p><pre class="programlisting">SELECT MAX(article) AS article FROM shop;

+---------+
| article |
+---------+
|       4 |
+---------+
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="example-maximum-row"></a>3.6.2 特定のカラムの最大値が格納されている行</h3></div></div></div><p>
        <span class="emphasis"><em>タスク: もっとも高価な物品の品番、業者、および価格を調べます。</em></span>
      </p><p>
        これはサブクエリーを使用して簡単に実行できます。
      </p><pre class="programlisting">SELECT article, dealer, price
FROM   shop
WHERE  price=(SELECT MAX(price) FROM shop);

+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0004 | D      | 19.95 |
+---------+--------+-------+
</pre><p>
        ほかにも、<code class="literal">LEFT JOIN</code> を使用する方法や、すべての行を価格の降順でソートしてから MySQL 固有の <code class="literal">LIMIT</code> 句を使用して最初の行だけを取得する方法もあります。
      </p><pre class="programlisting">SELECT s1.article, s1.dealer, s1.price
FROM shop s1
LEFT JOIN shop s2 ON s1.price &lt; s2.price
WHERE s2.article IS NULL;

SELECT article, dealer, price
FROM shop
ORDER BY price DESC
LIMIT 1;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          最高価格のものが複数あり、価格が 19.95 の場合、<code class="literal">LIMIT</code> を使用した方法では、その中の 1 つしか取得できません。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="example-maximum-column-group"></a>3.6.3 グループごとのカラムの最大値</h3></div></div></div><p>
        <span class="emphasis"><em>タスク: 物品ごとの最高値を調べます。</em></span>
      </p><pre class="programlisting">SELECT article, MAX(price) AS price
FROM   shop
GROUP BY article
ORDER BY article;

+---------+-------+
| article | price |
+---------+-------+
|    0001 |  3.99 |
|    0002 | 10.99 |
|    0003 |  1.69 |
|    0004 | 19.95 |
+---------+-------+
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="example-maximum-column-group-row"></a>3.6.4 特定のカラムのグループごとの最大値が格納されている行</h3></div></div></div><p>
        <span class="emphasis"><em>タスク: 物品ごとに最高値を付けている業者 (複数可) を調べます。</em></span>
      </p><p>
        この問題は、次のようなサブクエリーを使用して解決できます。
      </p><pre class="programlisting">SELECT article, dealer, price
FROM   shop s1
WHERE  price=(SELECT MAX(s2.price)
              FROM shop s2
              WHERE s1.article = s2.article)
ORDER BY article;

+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0001 | B      |  3.99 |
|    0002 | A      | 10.99 |
|    0003 | C      |  1.69 |
|    0004 | D      | 19.95 |
+---------+--------+-------+
</pre><p>
        この例では相関サブクエリーを使用していますが、これは十分でない場合があります (<a class="xref" href="sql-statements.html#correlated-subqueries" title="13.2.11.7 相関サブクエリー">セクション13.2.11.7「相関サブクエリー」</a>を参照してください)。 問題を解決する他の可能性があるのは、<code class="literal">FROM</code> 句、<code class="literal">LEFT JOIN</code> またはウィンドウ関数を使用した共通テーブル式で、関連のないサブクエリーを使用することです。 
      </p><p>
        非相関サブクエリー
      </p><pre class="programlisting">SELECT s1.article, dealer, s1.price
FROM shop s1
JOIN (
  SELECT article, MAX(price) AS price
  FROM shop
  GROUP BY article) AS s2
  ON s1.article = s2.article AND s1.price = s2.price
ORDER BY article;
</pre><p>
        <code class="literal">LEFT JOIN</code>:
      </p><pre class="programlisting">SELECT s1.article, s1.dealer, s1.price
FROM shop s1
LEFT JOIN shop s2 ON s1.article = s2.article AND s1.price &lt; s2.price
WHERE s2.article IS NULL
ORDER BY s1.article;
</pre><p>
        <code class="literal">LEFT JOIN</code> は、<code class="literal">s1.price</code> が最大値である場合に、大きい値を持つ <code class="literal">s2.price</code> がないため、対応する <code class="literal">s2.article</code> 値が <code class="literal">NULL</code> であることに基づいて動作します。 <a class="xref" href="sql-statements.html#join" title="13.2.10.2 JOIN 句">セクション13.2.10.2「JOIN 句」</a>を参照してください。 
      </p><p>
        ウィンドウ関数を使用した共通テーブル式:
      </p><a class="indexterm" name="idm45879496611104"></a><a class="indexterm" name="idm45879496609664"></a><pre class="programlisting">WITH s1 AS (
   SELECT article, dealer, price,
          RANK() OVER (PARTITION BY article
                           ORDER BY price DESC
                      ) AS `Rank`
     FROM shop
)
SELECT article, dealer, price
  FROM s1
  WHERE `Rank` = 1
ORDER BY article;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="example-user-variables"></a>3.6.5 ユーザー定義の変数の使用</h3></div></div></div><p>
        MySQL ユーザー変数を使用すると、クライアント側で一時変数を使用せずに結果を記憶することができます。 (<a class="xref" href="language-structure.html#user-variables" title="9.4 ユーザー定義変数">セクション9.4「ユーザー定義変数」</a>を参照してください。) 
      </p><p>
        たとえば、最高値および最安値が付けられている物品を取得するには、次を実行します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @min_price:=MIN(price),@max_price:=MAX(price) FROM shop;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM shop WHERE price=@min_price OR price=@max_price;</code></strong>
+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0003 | D      |  1.25 |
|    0004 | D      | 19.95 |
+---------+--------+-------+
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          また、テーブルやカラムといったデータベースオブジェクトの名前をユーザー変数に格納してから、この変数を SQL ステートメントで使用することもできます。ただし、これにはプリペアドステートメントを使用する必要があります。 詳しくは<a class="xref" href="sql-statements.html#sql-prepared-statements" title="13.5 プリペアドステートメント">セクション13.5「プリペアドステートメント」</a>,をご覧ください。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="example-foreign-keys"></a>3.6.6 外部キーの使用</h3></div></div></div><a class="indexterm" name="idm45879496597760"></a><a class="indexterm" name="idm45879496596304"></a><p>
        MySQL では、<code class="literal">InnoDB</code> テーブルで外部キー制約の確認をサポートしています。 <a class="xref" href="innodb-storage-engine.html" title="第 15 章 InnoDB ストレージエンジン">第15章「<i>InnoDB ストレージエンジン</i>」</a>および<a class="xref" href="introduction.html#ansi-diff-foreign-keys" title="1.7.2.3 FOREIGN KEY 制約の違い">セクション1.7.2.3「FOREIGN KEY 制約の違い」</a>を参照してください。 
      </p><p>
        2 つのテーブルを結合するだけの場合は、外部キー制約は必要ありません。 <code class="literal">InnoDB</code> 以外のストレージエンジンの場合、カラムを定義するときに <code class="literal">REFERENCES <em class="replaceable"><code>tbl_name</code></em>(<em class="replaceable"><code>col_name</code></em>)</code> 句を使用できます。これは実際の効果はありませんが、<span class="emphasis"><em>現在定義しようとしているカラムが別のテーブルのカラムを参照する予定であるという自分のメモまたはコメントとして役立ちます</em></span>。 この構文を使用するときは、次の点を理解しておくことが非常に重要です。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL では、<em class="replaceable"><code>col_name</code></em> が実際に <em class="replaceable"><code>tbl_name</code></em> に存在するかどうか (または <em class="replaceable"><code>tbl_name</code></em> 自体が存在するかどうか) を確認するチェックは実行されません。
          </p></li><li class="listitem"><p>
            MySQL は、<em class="replaceable"><code>tbl_name</code></em> に対してどのようなアクションも実行しません。たとえば、定義しようとしているテーブルの行に実行されたアクションに対応して行を削除することなどはありません。つまり、この構文にはどのような <code class="literal">ON DELETE</code> 動作や <code class="literal">ON UPDATE</code> 動作もありません。 (<code class="literal">REFERENCES</code> 句の一部として <code class="literal">ON DELETE</code> 句や <code class="literal">ON UPDATE</code> 句を記述することはできますが、これらも無視されます。) 
          </p></li><li class="listitem"><p>
            この構文は<span class="emphasis"><em>カラム</em></span>を作成します。どのようなインデックスやキーも作成<span class="bold"><strong>しません</strong></span>。
          </p></li></ul></div><p>
        このように作成したカラムを、次のように結合カラムとして使用できます。
      </p><pre class="programlisting">CREATE TABLE person (
    id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    name CHAR(60) NOT NULL,
    PRIMARY KEY (id)
);

CREATE TABLE shirt (
    id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    style ENUM('t-shirt', 'polo', 'dress') NOT NULL,
    color ENUM('red', 'blue', 'orange', 'white', 'black') NOT NULL,
    owner SMALLINT UNSIGNED NOT NULL REFERENCES person(id),
    PRIMARY KEY (id)
);

INSERT INTO person VALUES (NULL, 'Antonio Paz');

SELECT @last := LAST_INSERT_ID();

INSERT INTO shirt VALUES
(NULL, 'polo', 'blue', @last),
(NULL, 'dress', 'white', @last),
(NULL, 't-shirt', 'blue', @last);

INSERT INTO person VALUES (NULL, 'Lilliana Angelovska');

SELECT @last := LAST_INSERT_ID();

INSERT INTO shirt VALUES
(NULL, 'dress', 'orange', @last),
(NULL, 'polo', 'red', @last),
(NULL, 'dress', 'blue', @last),
(NULL, 't-shirt', 'white', @last);

SELECT * FROM person;
+----+---------------------+
| id | name                |
+----+---------------------+
|  1 | Antonio Paz         |
|  2 | Lilliana Angelovska |
+----+---------------------+

SELECT * FROM shirt;
+----+---------+--------+-------+
| id | style   | color  | owner |
+----+---------+--------+-------+
|  1 | polo    | blue   |     1 |
|  2 | dress   | white  |     1 |
|  3 | t-shirt | blue   |     1 |
|  4 | dress   | orange |     2 |
|  5 | polo    | red    |     2 |
|  6 | dress   | blue   |     2 |
|  7 | t-shirt | white  |     2 |
+----+---------+--------+-------+


SELECT s.* FROM person p INNER JOIN shirt s
   ON s.owner = p.id
 WHERE p.name LIKE 'Lilliana%'
   AND s.color &lt;&gt; 'white';

+----+-------+--------+-------+
| id | style | color  | owner |
+----+-------+--------+-------+
|  4 | dress | orange |     2 |
|  5 | polo  | red    |     2 |
|  6 | dress | blue   |     2 |
+----+-------+--------+-------+
</pre><p>
        この方法で使用する場合、<code class="literal">REFERENCES</code> 句は <code class="literal">SHOW CREATE TABLE</code> や <code class="literal">DESCRIBE</code> の出力に表示されません。
      </p><pre class="programlisting">SHOW CREATE TABLE shirt\G
*************************** 1. row ***************************
Table: shirt
Create Table: CREATE TABLE `shirt` (
`id` smallint(5) unsigned NOT NULL auto_increment,
`style` enum('t-shirt','polo','dress') NOT NULL,
`color` enum('red','blue','orange','white','black') NOT NULL,
`owner` smallint(5) unsigned NOT NULL,
PRIMARY KEY  (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4
</pre><p>
        <code class="literal">REFERENCES</code> をこのようにカラム定義のコメントまたは<span class="quote">「<span class="quote">リマインダ</span>」</span>として使用する方法は、<code class="literal">MyISAM</code> テーブルで機能します。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="searching-on-two-keys"></a>3.6.7 2 つのキーを使用した検索</h3></div></div></div><a class="indexterm" name="idm45879496564256"></a><a class="indexterm" name="idm45879496563008"></a><a class="indexterm" name="idm45879496561664"></a><a class="indexterm" name="idm45879496559504"></a><p>
        1 つのキーを使用した <code class="literal">OR</code> の処理は、<code class="literal">AND</code> の処理と同様にかなり最適化されています。
      </p><p>
        注意が必要なのは、<code class="literal">OR</code> で結合された 2 つの異なるキーを使用して検索する場合です。
      </p><pre class="programlisting">SELECT field1_index, field2_index FROM test_table
WHERE field1_index = '1' OR  field2_index = '1'
</pre><p>
        この場合は最適化されています。 <a class="xref" href="optimization.html#index-merge-optimization" title="8.2.1.3 インデックスマージの最適化">セクション8.2.1.3「インデックスマージの最適化」</a>を参照してください。 
      </p><p>
        2 つの異なる <code class="literal">SELECT</code> ステートメントの出力を結合する <code class="literal">UNION</code> を使用することでも、この問題を効率的に解決できます。 <a class="xref" href="sql-statements.html#union" title="13.2.10.3 UNION 句">セクション13.2.10.3「UNION 句」</a>を参照してください。 
      </p><p>
        各 <code class="literal">SELECT</code> は 1 つのキーだけを検索するため、最適化できます。
      </p><pre class="programlisting">SELECT field1_index, field2_index
    FROM test_table WHERE field1_index = '1'
UNION
SELECT field1_index, field2_index
    FROM test_table WHERE field2_index = '1';
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="calculating-days"></a>3.6.8 日ごとの訪問数の計算</h3></div></div></div><a class="indexterm" name="idm45879496543792"></a><a class="indexterm" name="idm45879496542480"></a><a class="indexterm" name="idm45879496541136"></a><a class="indexterm" name="idm45879496539664"></a><p>
        ビットグループ関数を使用して、あるユーザーが Web ページを訪問した月ごとの日数を計算する方法の例を次に示します。
      </p><pre class="programlisting">CREATE TABLE t1 (year YEAR, month INT UNSIGNED,
             day INT UNSIGNED);
INSERT INTO t1 VALUES(2000,1,1),(2000,1,20),(2000,1,30),(2000,2,2),
            (2000,2,23),(2000,2,23);
</pre><p>
        このテーブルには、ユーザーがページを訪問した日付を表す年月日の値が格納されています。 月ごとの訪問日数を取得するには、次のクエリーを実行します。 
      </p><pre class="programlisting">SELECT year,month,BIT_COUNT(BIT_OR(1&lt;&lt;day)) AS days FROM t1
       GROUP BY year,month;
</pre><p>
        次の結果が表示されます。
      </p><pre class="programlisting">+------+-------+------+
| year | month | days |
+------+-------+------+
| 2000 |     1 |    3 |
| 2000 |     2 |    2 |
+------+-------+------+
</pre><p>
        このクエリーでは、年と月の組み合わせに対して異なる日付が何回テーブルに出現するかを、自動的に重複エントリを除去することによって計算しています。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="example-auto-increment"></a>3.6.9 AUTO_INCREMENT の使用</h3></div></div></div><a class="indexterm" name="idm45879496529264"></a><a class="indexterm" name="idm45879496527920"></a><a class="indexterm" name="idm45879496526576"></a><p>
        <code class="literal">AUTO_INCREMENT</code> 属性を使用すると、新しい行に一意の識別子を生成できます。
      </p><pre class="programlisting">CREATE TABLE animals (
     id MEDIUMINT NOT NULL AUTO_INCREMENT,
     name CHAR(30) NOT NULL,
     PRIMARY KEY (id)
);

INSERT INTO animals (name) VALUES
    ('dog'),('cat'),('penguin'),
    ('lax'),('whale'),('ostrich');

SELECT * FROM animals;
</pre><p>
        次の結果が表示されます。
      </p><pre class="programlisting">+----+---------+
| id | name    |
+----+---------+
|  1 | dog     |
|  2 | cat     |
|  3 | penguin |
|  4 | lax     |
|  5 | whale   |
|  6 | ostrich |
+----+---------+
</pre><p>
        <code class="literal">AUTO_INCREMENT</code> カラムには値が指定されなかったため、MySQL が自動的にシーケンス番号を割り当てました。 <code class="literal">NO_AUTO_VALUE_ON_ZERO</code> SQL モードが有効になっていないかぎり、カラムに 0 を明示的に割り当てて順序番号を生成することもできます。 例: 
      </p><pre class="programlisting">INSERT INTO animals (id,name) VALUES(0,'groundhog');
</pre><p>
        カラムが <code class="literal">NOT NULL</code> と宣言されている場合は、<code class="literal">NULL</code> 割り当ててシーケンス番号を生成することもできます。 例: 
      </p><pre class="programlisting">INSERT INTO animals (id,name) VALUES(NULL,'squirrel');
</pre><p>
        他の値を <code class="literal">AUTO_INCREMENT</code> カラムに挿入すると、カラムはその値に設定され、次に自動的に生成される値が最大のカラム値から順番に続くように順序がリセットされます。 例: 
      </p><pre class="programlisting"><strong class="userinput"><code>INSERT INTO animals (id,name) VALUES(100,'rabbit');</code></strong>
<strong class="userinput"><code>INSERT INTO animals (id,name) VALUES(NULL,'mouse');</code></strong>
<strong class="userinput"><code>SELECT * FROM animals;</code></strong>
+-----+-----------+
| id  | name      |
+-----+-----------+
|   1 | dog       |
|   2 | cat       |
|   3 | penguin   |
|   4 | lax       |
|   5 | whale     |
|   6 | ostrich   |
|   7 | groundhog |
|   8 | squirrel  |
| 100 | rabbit    |
| 101 | mouse     |
+-----+-----------+
</pre><p>
        既存の <code class="literal">AUTO_INCREMENT</code> カラム値を更新すると、<code class="literal">AUTO_INCREMENT</code> 順序もリセットされます。
      </p><p>
        <code class="literal">LAST_INSERT_ID()</code> SQL 関数または <code class="literal">mysql_insert_id()</code> C API 関数を使用して、自動的に生成された最新の <code class="literal">AUTO_INCREMENT</code> 値を取得できます。 これらの関数は接続に固有の関数であるため、別の接続が同様に挿入を実行していても、戻り値は影響を受けません。 
      </p><p>
        必要な最大順序値を保持するのに十分な大きさの <code class="literal">AUTO_INCREMENT</code> カラムには、最小の整数データ型を使用します。 カラムがデータ型の上限値に到達すると、次にシーケンス番号を生成しようとしたときには失敗します。 可能であれば、より広い範囲を可能にするために <code class="literal">UNSIGNED</code> 属性を使用します。 たとえば、<code class="literal">TINYINT</code> を使用する場合、許可される最大のシーケンス番号は 127 です。 <code class="literal">TINYINT UNSIGNED</code> の場合は最大値は 255 です。 すべての整数型の範囲は、<a class="xref" href="data-types.html#integer-types" title="11.1.2 整数型 (真数値) - INTEGER、INT、SMALLINT、TINYINT、MEDIUMINT、BIGINT">セクション11.1.2「整数型 (真数値) - INTEGER、INT、SMALLINT、TINYINT、MEDIUMINT、BIGINT」</a>を参照してください。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          複数行を同時に挿入する場合、<code class="literal">LAST_INSERT_ID()</code> と <code class="literal">mysql_insert_id()</code> は、実際には<span class="emphasis"><em>最初に</em></span>挿入した行の <code class="literal">AUTO_INCREMENT</code> キーを返します。 これにより、レプリケーションセットアップで複数行の挿入を別のサーバーで正しく再現できます。 
        </p></div><p>
        1 以外の <code class="literal">AUTO_INCREMENT</code> 値で開始するには、次のように、その値を <code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> でセットします。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE tbl AUTO_INCREMENT = 100;</code></strong>
</pre><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="example-auto-increment-innodb-notes"></a>InnoDB の注意</h4></div></div></div><p>
          <code class="literal">InnoDB</code> に固有の <code class="literal">AUTO_INCREMENT</code> の使用方法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-handling" title="15.6.1.6 InnoDB での AUTO_INCREMENT 処理">セクション15.6.1.6「InnoDB での AUTO_INCREMENT 処理」</a> を参照してください。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="example-auto-increment-myisam-notes"></a>MyISAM の注意</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">MyISAM</code> テーブルには、マルチカラムインデックス内のセカンダリカラムに <code class="literal">AUTO_INCREMENT</code> を指定することができます。 この場合、<code class="literal">AUTO_INCREMENT</code> カラムに生成される値は、<code class="literal">MAX(<em class="replaceable"><code>auto_increment_column</code></em>) + 1 WHERE prefix=<em class="replaceable"><code>given-prefix</code></em></code> として計算されます。 これは、データを順序付きのグループに分割する場合に便利です。 
            </p><pre class="programlisting">CREATE TABLE animals (
    grp ENUM('fish','mammal','bird') NOT NULL,
    id MEDIUMINT NOT NULL AUTO_INCREMENT,
    name CHAR(30) NOT NULL,
    PRIMARY KEY (grp,id)
) ENGINE=MyISAM;

INSERT INTO animals (grp,name) VALUES
    ('mammal','dog'),('mammal','cat'),
    ('bird','penguin'),('fish','lax'),('mammal','whale'),
    ('bird','ostrich');

SELECT * FROM animals ORDER BY grp,id;
</pre><p>
              次の結果が表示されます。
            </p><pre class="programlisting">+--------+----+---------+
| grp    | id | name    |
+--------+----+---------+
| fish   |  1 | lax     |
| mammal |  1 | dog     |
| mammal |  2 | cat     |
| mammal |  3 | whale   |
| bird   |  1 | penguin |
| bird   |  2 | ostrich |
+--------+----+---------+
</pre><p>
              この場合 (<code class="literal">AUTO_INCREMENT</code> カラムがマルチカラムインデックスの一部として使用されている場合)、グループ内で最大の <code class="literal">AUTO_INCREMENT</code> 値を持つ行を削除すると、そのグループで同じ <code class="literal">AUTO_INCREMENT</code> 値が再使用されることになります。 これは、通常は <code class="literal">AUTO_INCREMENT</code> 値が再使用されることのない <code class="literal">MyISAM</code> テーブルの場合にも発生します。 
            </p></li><li class="listitem"><p>
              <code class="literal">AUTO_INCREMENT</code> カラムが複合インデックスの一部である場合、MySQL は <code class="literal">AUTO_INCREMENT</code> カラムで始まるインデックスを使用してシーケンス値を生成します (ある場合)。 たとえば、<code class="literal">animals</code> テーブルにインデックス <code class="literal">PRIMARY KEY (grp, id)</code> と <code class="literal">INDEX (id)</code> が含まれている場合、MySQL はシーケンス値の生成で <code class="literal">PRIMARY KEY</code> を無視します。 その結果、テーブルには <code class="literal">grp</code> 値ごとに 1 つのシーケンスではなく、単一のシーケンスが含まれることになります。 
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="example-auto-increment-further-reading"></a>参照情報</h4></div></div></div><p>
          <code class="literal">AUTO_INCREMENT</code> に関する詳細の参照先を次に示します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              カラムに <code class="literal">AUTO_INCREMENT</code> 属性を割り当てる方法: <a class="xref" href="sql-statements.html#create-table" title="13.1.20 CREATE TABLE ステートメント">セクション13.1.20「CREATE TABLE ステートメント」</a>、および<a class="xref" href="sql-statements.html#alter-table" title="13.1.9 ALTER TABLE ステートメント">セクション13.1.9「ALTER TABLE ステートメント」</a>。
            </p></li><li class="listitem"><p>
              <code class="literal">AUTO_INCREMENT</code> の、<code class="literal">NO_AUTO_VALUE_ON_ZERO</code> SQL モードによる動作の違い: <a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a>。
            </p></li><li class="listitem"><p>
              <code class="literal">LAST_INSERT_ID()</code> 関数を使用して最新の <code class="literal">AUTO_INCREMENT</code> 値を見つける方法: <a class="xref" href="functions.html#information-functions" title="12.16 情報関数">セクション12.16「情報関数」</a>。
            </p></li><li class="listitem"><p>
              使用する <code class="literal">AUTO_INCREMENT</code> 値の設定: <a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>。
            </p></li><li class="listitem"><p>
              <a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-handling" title="15.6.1.6 InnoDB での AUTO_INCREMENT 処理">セクション15.6.1.6「InnoDB での AUTO_INCREMENT 処理」</a>
            </p></li><li class="listitem"><p>
              <code class="literal">AUTO_INCREMENT</code> とレプリケーション: <a class="xref" href="replication.html#replication-features-auto-increment" title="17.5.1.1 レプリケーションと AUTO_INCREMENT">セクション17.5.1.1「レプリケーションと AUTO_INCREMENT」</a>。
            </p></li><li class="listitem"><p>
              レプリケーションに使用できる <code class="literal">AUTO_INCREMENT</code> 関連のサーバーシステム変数 (<code class="literal">auto_increment_increment</code> と <code class="literal">auto_increment_offset</code>): <a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>。
            </p></li></ul></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="apache"></a>3.7 Apache での MySQL の使用</h2></div></div></div><a class="indexterm" name="idm45879496436624"></a><p>
      MySQL データベースを使用してユーザーを認証し、ログファイルを MySQL のテーブルに書き込むプログラムがあります。
    </p><p>
      Apache 構成ファイルに次を追加することで、MySQL に簡単に読み込めるように Apache のロギング形式を変更することができます。
    </p><pre class="programlisting">LogFormat \
        "\"%h\",%{%Y%m%d%H%M%S}t,%&gt;s,\"%b\",\"%{Content-Type}o\",  \
        \"%U\",\"%{Referer}i\",\"%{User-Agent}i\""
</pre><p>
      この形式のログファイルを MySQL にロードするには、次のようなステートメントを使用します。
    </p><pre class="programlisting">LOAD DATA INFILE '<em class="replaceable"><code>/local/access_log</code></em>' INTO TABLE <em class="replaceable"><code>tbl_name</code></em>
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' ESCAPED BY '\\'
</pre><p>
      <code class="literal">LogFormat</code> 行がログファイルに書き込むデータに対応して、指定するテーブルのカラムを作成する必要があります。
    </p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="installing.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="programs.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第 2 章 MySQL のインストールとアップグレード </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第 4 章 MySQL プログラム</td></tr></table></div><div class="copyright-footer"></div></body></html>
