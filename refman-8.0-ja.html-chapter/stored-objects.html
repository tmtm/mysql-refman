<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第 25 章 ストアドオブジェクト</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="MySQL 8.0 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 8.0 リファレンスマニュアル"><link rel="prev" href="partitioning.html" title="第 24 章 パーティション化"><link rel="next" href="information-schema.html" title="第 26 章 INFORMATION_SCHEMA テーブル"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 25 章 ストアドオブジェクト</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="partitioning.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="information-schema.html">次へ</a></td></tr></table><hr></div><div class="status-header"><p class="alert">このページは機械翻訳したものです。</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="stored-objects"></a>第 25 章 ストアドオブジェクト</h1></div></div></div><div class="toc"><p><b>目次</b></p><dl class="toc"><dt><span class="section"><a href="stored-objects.html#stored-programs-defining">25.1 ストアドプログラムの定義</a></span></dt><dt><span class="section"><a href="stored-objects.html#stored-routines">25.2 ストアドルーチンの使用</a></span></dt><dd><dl><dt><span class="section"><a href="stored-objects.html#stored-routines-syntax">25.2.1 ストアドルーチンの構文</a></span></dt><dt><span class="section"><a href="stored-objects.html#stored-routines-privileges">25.2.2 ストアドルーチンと MySQL 権限</a></span></dt><dt><span class="section"><a href="stored-objects.html#stored-routines-metadata">25.2.3 ストアドルーチンのメタデータ</a></span></dt><dt><span class="section"><a href="stored-objects.html#stored-routines-last-insert-id">25.2.4 ストアドプロシージャー、関数、トリガー、および LAST_INSERT_ID()</a></span></dt></dl></dd><dt><span class="section"><a href="stored-objects.html#triggers">25.3 トリガーの使用</a></span></dt><dd><dl><dt><span class="section"><a href="stored-objects.html#trigger-syntax">25.3.1 トリガーの構文と例</a></span></dt><dt><span class="section"><a href="stored-objects.html#trigger-metadata">25.3.2 トリガーのメタデータ</a></span></dt></dl></dd><dt><span class="section"><a href="stored-objects.html#event-scheduler">25.4 イベントスケジューラの使用</a></span></dt><dd><dl><dt><span class="section"><a href="stored-objects.html#events-overview">25.4.1 イベントスケジューラの概要</a></span></dt><dt><span class="section"><a href="stored-objects.html#events-configuration">25.4.2 イベントスケジューラの構成</a></span></dt><dt><span class="section"><a href="stored-objects.html#events-syntax">25.4.3 イベント構文</a></span></dt><dt><span class="section"><a href="stored-objects.html#events-metadata">25.4.4 イベントメタデータ</a></span></dt><dt><span class="section"><a href="stored-objects.html#events-status-info">25.4.5 イベントスケジューラのステータス</a></span></dt><dt><span class="section"><a href="stored-objects.html#events-privileges">25.4.6 イベントスケジューラと MySQL 権限</a></span></dt></dl></dd><dt><span class="section"><a href="stored-objects.html#views">25.5 ビューの使用</a></span></dt><dd><dl><dt><span class="section"><a href="stored-objects.html#view-syntax">25.5.1 ビューの構文</a></span></dt><dt><span class="section"><a href="stored-objects.html#view-algorithms">25.5.2 ビュー処理アルゴリズム</a></span></dt><dt><span class="section"><a href="stored-objects.html#view-updatability">25.5.3 更新可能および挿入可能なビュー</a></span></dt><dt><span class="section"><a href="stored-objects.html#view-check-option">25.5.4 WITH CHECK OPTION 句の表示</a></span></dt><dt><span class="section"><a href="stored-objects.html#view-metadata">25.5.5 ビューのメタデータ</a></span></dt></dl></dd><dt><span class="section"><a href="stored-objects.html#stored-objects-security">25.6 ストアドオブジェクトのアクセス制御</a></span></dt><dt><span class="section"><a href="stored-objects.html#stored-programs-logging">25.7 ストアドプログラムバイナリロギング</a></span></dt><dt><span class="section"><a href="stored-objects.html#stored-program-restrictions">25.8 ストアドプログラムの制約</a></span></dt><dt><span class="section"><a href="stored-objects.html#view-restrictions">25.9 ビューの制約</a></span></dt></dl></div><a class="indexterm" name="idm46065428987664"></a><a class="indexterm" name="idm46065428986208"></a><a class="indexterm" name="idm46065428984832"></a><a class="indexterm" name="idm46065428983456"></a><a class="indexterm" name="idm46065428981536"></a><a class="indexterm" name="idm46065428979504"></a><a class="indexterm" name="idm46065428977472"></a><a class="indexterm" name="idm46065428976016"></a><a class="indexterm" name="idm46065428975040"></a><a class="indexterm" name="idm46065428973552"></a><p>
    この章では、後で実行するためにサーバーに格納される SQL コードで定義されるストアドデータベースオブジェクトについて説明します。
  </p><p>
    ストアドオブジェクトには、次のオブジェクトタイプが含まれます:
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        ストアドプロシージャ: <code class="literal">CREATE PROCEDURE</code> で作成され、<code class="literal">CALL</code> ステートメントを使用して起動されるオブジェクト。 プロシージャーは、戻り値がありませんが、呼び出し元があとから検査できるようにそのパラメータを変更できます。 また、クライアントプログラムに戻される結果セットも生成できます。 
      </p></li><li class="listitem"><p>
        ストアドファンクション: <code class="literal">CREATE FUNCTION</code> で作成され、組込み関数と同様に使用されるオブジェクト。 式で呼び出し、式の評価中に値を返します。 
      </p></li><li class="listitem"><p>
        トリガー: テーブルに関連付けられた <code class="literal">CREATE TRIGGER</code> で作成されたオブジェクト。 トリガーは、テーブルに対して挿入や更新などの特定のイベントが発生したときにアクティブ化されます。 
      </p></li><li class="listitem"><p>
        Event: <code class="literal">CREATE EVENT</code> で作成され、スケジュールに従ってサーバーによって起動されるオブジェクト。
      </p></li><li class="listitem"><p>
        表示: 参照時に結果セットを生成する <code class="literal">CREATE VIEW</code> で作成されるオブジェクト。 ビューは仮想テーブルとして機能します。 
      </p></li></ul></div><p>
    このドキュメントで使用されている用語は、格納されているオブジェクト階層を反映しています:
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        ストアドルーチンには、ストアドプロシージャーとストアドファンクションが含まれます。
      </p></li><li class="listitem"><p>
        ストアドプログラムには、ストアドルーチン、トリガー、およびイベントが含まれます。
      </p></li><li class="listitem"><p>
        ストアドオブジェクトには、ストアドプログラムおよびビューが含まれます。
      </p></li></ul></div><p>
    この章では、ストアドオブジェクトの使用方法について説明します。 次の各セクションでは、これらのオブジェクトに関連するステートメントの SQL 構文およびオブジェクト処理に関する追加情報を示します: 
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        オブジェクト型ごとに、どのオブジェクトが存在し、どのように定義されているかを制御する <code class="literal">CREATE</code>、<code class="literal">ALTER</code>、および <code class="literal">DROP</code> ステートメントがあります。 <a class="xref" href="sql-statements.html#sql-data-definition-statements" title="13.1 データ定義ステートメント">セクション13.1「データ定義ステートメント」</a>を参照してください。 
      </p></li><li class="listitem"><p>
        <code class="literal">CALL</code> ステートメントは、ストアドプロシージャーの呼び出しに使用されます。 <a class="xref" href="sql-statements.html#call" title="13.2.1 CALL ステートメント">セクション13.2.1「CALL ステートメント」</a>を参照してください。 
      </p></li><li class="listitem"><p>
        ストアドプログラム定義には、複合ステートメント、ループ、条件文、および宣言された変数を使用できる本体が含まれます。 <a class="xref" href="sql-statements.html#sql-compound-statements" title="13.6 複合ステートメントの構文">セクション13.6「複合ステートメントの構文」</a>を参照してください。 
      </p></li><li class="listitem"><p>
        ストアドプログラムによって参照されるオブジェクトに対するメタデータの変更が検出され、プログラムが次に実行されるときに、影響を受けるステートメントが自動的に再解析されます。 詳細については、<a class="xref" href="optimization.html#statement-caching" title="8.10.3 プリペアドステートメントおよびストアドプログラムのキャッシュ">セクション8.10.3「プリペアドステートメントおよびストアドプログラムのキャッシュ」</a>を参照してください。 
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="stored-programs-defining"></a>25.1 ストアドプログラムの定義</h2></div></div></div><p>
      各ストアドプログラムには、SQL ステートメントから構成される本体が含まれます。 このステートメントは、セミコロン (<code class="literal">;</code>) 文字で区切られた複数のステートメントから構成される複合ステートメントの場合があります。 たとえば、次のストアドプロシージャーには、<code class="literal">SET</code> ステートメントと <code class="literal">REPEAT</code> ループ (ループ自体に別の <code class="literal">SET</code> ステートメントが含まれます) を含む <code class="literal">BEGIN ... END</code> ブロックから構成される本体があります。 
    </p><pre class="programlisting">CREATE PROCEDURE dorepeat(p1 INT)
BEGIN
  SET @x = 0;
  REPEAT SET @x = @x + 1; UNTIL @x &gt; p1 END REPEAT;
END;
</pre><p>
      <span class="command"><strong>mysql</strong></span> クライアントプログラムを使用してセミコロン文字を含むストアドプログラムを定義すると、問題が発生します。 デフォルトでは、<span class="command"><strong>mysql</strong></span> 自体はセミコロンをステートメント区切り文字と認識します。したがって、<span class="command"><strong>mysql</strong></span> がストアドプログラム定義全体をサーバーに渡すように、区切り文字を一時的に再定義する必要があります。 
    </p><p>
      <span class="command"><strong>mysql</strong></span> の区切り文字を再定義するには、<code class="literal">delimiter</code> コマンドを使用します。 次の例は、上記の <code class="literal">dorepeat()</code> プロシージャーについてこれを行う方法を示しています。 区切り文字は <code class="literal">//</code> に変更され、定義全体を単一のステートメントとしてサーバーに渡して、プロシージャーの呼び出し前に <code class="literal">;</code> にリストアできます。 これにより、プロシージャー本体で使用される <code class="literal">;</code> 区切り文字を、<span class="command"><strong>mysql</strong></span> 自体が解釈するのではなく、サーバーに渡すようにすることができます。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>delimiter //</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE PROCEDURE dorepeat(p1 INT)</code></strong>
    -&gt; <strong class="userinput"><code>BEGIN</code></strong>
    -&gt;   <strong class="userinput"><code>SET @x = 0;</code></strong>
    -&gt;   <strong class="userinput"><code>REPEAT SET @x = @x + 1; UNTIL @x &gt; p1 END REPEAT;</code></strong>
    -&gt; <strong class="userinput"><code>END</code></strong>
    -&gt; <strong class="userinput"><code>//</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>delimiter ;</code></strong>

mysql&gt; <strong class="userinput"><code>CALL dorepeat(1000);</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @x;</code></strong>
+------+
| @x   |
+------+
| 1001 |
+------+
1 row in set (0.00 sec)
</pre><p>
      区切り文字を <code class="literal">//</code> 以外の文字列に再定義でき、区切り文字は単一の文字から構成することも、複数の文字から構成することもできます。 バックスラッシュ (<code class="literal">\</code>) 文字は、MySQL のエスケープ文字なので使用しないでください。 
    </p><p>
      次に、パラメータを受け取り、SQL 関数を使用して操作を実行したあと、結果を返す関数例を示します。 この場合は、関数定義に内部の <code class="literal">;</code> ステートメント区切り文字が含まれていないため、<code class="literal">delimiter</code> を使用する必要はありません。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE FUNCTION hello (s CHAR(20))</code></strong>
mysql&gt; <strong class="userinput"><code>RETURNS CHAR(50) DETERMINISTIC</code></strong>
    -&gt; <strong class="userinput"><code>RETURN CONCAT('Hello, ',s,'!');</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT hello('world');</code></strong>
+----------------+
| hello('world') |
+----------------+
| Hello, world!  |
+----------------+
1 row in set (0.00 sec)
</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="stored-routines"></a>25.2 ストアドルーチンの使用</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="stored-objects.html#stored-routines-syntax">25.2.1 ストアドルーチンの構文</a></span></dt><dt><span class="section"><a href="stored-objects.html#stored-routines-privileges">25.2.2 ストアドルーチンと MySQL 権限</a></span></dt><dt><span class="section"><a href="stored-objects.html#stored-routines-metadata">25.2.3 ストアドルーチンのメタデータ</a></span></dt><dt><span class="section"><a href="stored-objects.html#stored-routines-last-insert-id">25.2.4 ストアドプロシージャー、関数、トリガー、および LAST_INSERT_ID()</a></span></dt></dl></div><a class="indexterm" name="idm46065428905152"></a><a class="indexterm" name="idm46065428903696"></a><a class="indexterm" name="idm46065428901776"></a><a class="indexterm" name="idm46065428900288"></a><a class="indexterm" name="idm46065428898368"></a><a class="indexterm" name="idm46065428896880"></a><p>
    MySQL は、ストアドルーチン (プロシージャーとファンクション) をサポートしています。 ストアドルーチンとは、サーバーに格納できる一連の SQL ステートメントです。 これが行われていると、クライアントは個々のステートメントを繰り返し発行し続ける必要はなく、代わりにストアドルーチンを参照できます。 
  </p><p>
    ストアドルーチンは特に、次のような特定の状況で役立ちます。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        クライアントアプリケーションが異なる言語で作成されているか、異なるプラットフォームで動作しているが、同じデータベース操作を実行する必要がある場合。
      </p></li><li class="listitem"><p>
        セキュリティーが最重要である場合。 たとえば、銀行では、すべての一般的な操作に対してストアドプロシージャーおよびストアドファンクションを使用します。 これにより一貫したセキュアな環境が得られ、ルーチンによってそれぞれの操作が正しく記録されるようになります。 このようなセットアップでは、アプリケーションおよびユーザーはデータベーステーブルに直接アクセスできませんが、特定のストアドルーチンだけを実行できます。 
      </p></li></ul></div><p>
    ストアドルーチンは、サーバーとクライアント間で送信する必要のある情報が少なくなるので、パフォーマンスを改善できます。 そのトレードオフでは、これによりサーバー側で行われる作業が増え、クライアント (アプリケーション) 側で行われる作業が少なくなるので、データベースサーバーでのロードが増大します。 1 台または少数のデータベースサーバーだけで多数のクライアントマシン (Web サーバーなど) にサービスを提供している場合にはこれを検討してください。 
  </p><p>
    ストアドルーチンを使用すれば、データベースサーバーで関数のライブラリを保持することもできます。 これは、内部的に (たとえばクラスを使用して) このような設計を可能にする、現代のアプリケーション言語で共有されている機能です。 これらのクライアントアプリケーションの言語機能を使用すると、データベース使用のスコープ外でもプログラマにとって利点があります。 
  </p><p>
    MySQL はストアドルーチンについて SQL:2003 構文に従っており、これは IBM の DB2 でも使用されています。 ここで説明するすべての構文はサポートされており、すべての制限と拡張が適宜ドキュメント化されています。 
  </p><h3><a name="idm46065428886736"></a>追加のリソース</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        ストアドプロシージャーおよびストアドファンクションを扱うときに、<a class="ulink" href="https://forums.mysql.com/list.php?98" target="_top">ストアドプロシージャーのユーザーフォーラム</a>が役立ちます。
      </p></li><li class="listitem"><p>
        MySQL のストアドルーチンに関するよくある質問とその回答については、<a class="xref" href="faqs.html#faqs-stored-procs" title="A.4 MySQL 8.0 FAQ: ストアドプロシージャーおよびストアドファンクション">セクションA.4「MySQL 8.0 FAQ: ストアドプロシージャーおよびストアドファンクション」</a>を参照してください。
      </p></li><li class="listitem"><p>
        ストアドルーチンの使用にはいくつかの制限があります。 <a class="xref" href="stored-objects.html#stored-program-restrictions" title="25.8 ストアドプログラムの制約">セクション25.8「ストアドプログラムの制約」</a>を参照してください。 
      </p></li><li class="listitem"><p>
        ストアドルーチンのバイナリロギングは、<a class="xref" href="stored-objects.html#stored-programs-logging" title="25.7 ストアドプログラムバイナリロギング">セクション25.7「ストアドプログラムバイナリロギング」</a>で説明しているように行われます。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="stored-routines-syntax"></a>25.2.1 ストアドルーチンの構文</h3></div></div></div><p>
      ストアドルーチンはプロシージャーまたは関数のどちらかです。 ストアドルーチンは、<code class="literal">CREATE PROCEDURE</code> および <code class="literal">CREATE FUNCTION</code> ステートメントで作成されます (<a class="xref" href="sql-statements.html#create-procedure" title="13.1.17 CREATE PROCEDURE ステートメントおよび CREATE FUNCTION ステートメント">セクション13.1.17「CREATE PROCEDURE ステートメントおよび CREATE FUNCTION ステートメント」</a>を参照してください)。 プロシージャーは <code class="literal">CALL</code> ステートメントを使用して呼び出され (<a class="xref" href="sql-statements.html#call" title="13.2.1 CALL ステートメント">セクション13.2.1「CALL ステートメント」</a>を参照してください)、出力変数の使用でのみ値を戻すことができます。 関数は、ほかの関数とまったく同様に (つまり、関数の名前を呼び出すことによって) ステートメント内部から呼び出すことができ、スカラー値を戻すことができます。 ストアドルーチンの本体では、複合ステートメントを使用できます (<a class="xref" href="sql-statements.html#sql-compound-statements" title="13.6 複合ステートメントの構文">セクション13.6「複合ステートメントの構文」</a>を参照してください)。 
    </p><p>
      ストアドルーチンは、<code class="literal">DROP PROCEDURE</code> および <code class="literal">DROP FUNCTION</code> ステートメントで削除でき (<a class="xref" href="sql-statements.html#drop-procedure" title="13.1.29 DROP PROCEDURE および DROP FUNCTION ステートメント">セクション13.1.29「DROP PROCEDURE および DROP FUNCTION ステートメント」</a>を参照してください)、<code class="literal">ALTER PROCEDURE</code> および <code class="literal">ALTER FUNCTION</code> ステートメントで変更できます (<a class="xref" href="sql-statements.html#alter-procedure" title="13.1.7 ALTER PROCEDURE ステートメント">セクション13.1.7「ALTER PROCEDURE ステートメント」</a>を参照してください)。
    </p><p>
      ストアドプロシージャーまたはストアドファンクションは、特定のデータベースに関連付けられています。 これにはいくつかの問題があります。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ルーチンが呼び出されると、暗黙の <code class="literal">USE <em class="replaceable"><code>db_name</code></em></code> が実行されます (その後、ルーチンが終了すると元に戻ります)。 ストアドルーチン内での <code class="literal">USE</code> ステートメントは許可されていません。 
        </p></li><li class="listitem"><p>
          データベース名でルーチン名を修飾できます。 これは現在のデータベースに存在しないルーチンを参照する場合に使用できます。 たとえば、<code class="literal">test</code>データベースに関連するストアドプロシージャー <code class="literal">p</code> またはストアドファンクション <code class="literal">f</code> を呼び出すには、<code class="literal">CALL test.p()</code> または <code class="literal">test.f()</code> と指定します。 
        </p></li><li class="listitem"><p>
          データベースを削除すると、そのデータベースに関連付けられたすべてのストアドルーチンも削除されます。
        </p></li></ul></div><p>
      ストアドファンクションは再帰関数にはできません。
    </p><p>
      ストアドプロシージャーでの再帰は許可されていますが、デフォルトでは無効になっています。 再帰を有効にするには、<code class="literal">max_sp_recursion_depth</code> サーバーシステム変数を正の値に設定します。 ストアドプロシージャーの再帰により、スレッドスタック領域の要求が増加します。 <code class="literal">max_sp_recursion_depth</code> の値を増やした場合、サーバー起動時に <code class="literal">thread_stack</code> の値を増やすことによってスレッドスタックサイズを増やすことが必要な場合もあります。 詳細は、<a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>を参照してください。 
    </p><p>
      MySQL では、通常の <code class="literal">SELECT</code> ステートメントをストアドプロシージャー内で (つまり、カーソルまたはローカル変数を使用せずに) 使用できるようにする非常に役立つ拡張をサポートしています。 このようなクエリーの結果セットは単にクライアントに直接送信されます。 複数の <code class="literal">SELECT</code> ステートメントは複数の結果セットを生成するので、クライアントは複数の結果セットをサポートしている MySQL クライアントライブラリを使用する必要があります。 これは、クライアントが、4.1 以降の MySQL のバージョンからクライアントライブラリを使用する必要があることを意味します。 クライアントは、接続するときに、<code class="literal">CLIENT_MULTI_RESULTS</code> オプションも指定する必要があります。 C プログラムの場合、これは、<code class="literal">mysql_real_connect()</code>C API 関数で実行できます。 <a class="ulink" href="https://dev.mysql.com/doc/c-api/8.0/en/mysql-real-connect.html" target="_top">mysql_real_connect()</a>および<a class="ulink" href="https://dev.mysql.com/doc/c-api/8.0/en/c-api-multiple-queries.html" target="_top">Multiple Statement Execution Support</a>を参照してください。 
    </p><p>
      MySQL 8.0.22 以降では、ストアドプロシージャのステートメントによって参照されるユーザー変数のタイプは、プロシージャの初回起動時に決定され、その後プロシージャが起動されるたびにこのタイプが保持されます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="stored-routines-privileges"></a>25.2.2 ストアドルーチンと MySQL 権限</h3></div></div></div><p>
      MySQL 許可システムはストアドルーチンを次のように考慮します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ストアドルーチンを生成するには、<code class="literal">CREATE ROUTINE</code> 権限が必要です。
        </p></li><li class="listitem"><p>
          ストアドルーチンを変更または削除するには、<code class="literal">ALTER ROUTINE</code> 権限が必要です。 この権限は、必要に応じて、ルーチンの作成者に自動的に与えられ、ルーチンが削除されると作成者から削除されます。 
        </p></li><li class="listitem"><p>
          ストアドルーチンを実行するには、<code class="literal">EXECUTE</code> 権限が必要です。 ただし、この権限は、必要に応じて、ルーチンの作成者に自動的に与えられます (ルーチンが削除されると作成者から削除されます)。 また、ルーチンのデフォルトの <code class="literal">SQL SECURITY</code> 特性は <code class="literal">DEFINER</code> であり、これにより、ルーチンが関連付けられているデータベースにアクセス可能なユーザーがルーチンを実行できるようになります。 
        </p></li><li class="listitem"><p>
          <code class="literal">automatic_sp_privileges</code> システム変数が 0 である場合、<code class="literal">EXECUTE</code> および <code class="literal">ALTER ROUTINE</code> 権限は作成者に対して自動的には付与および削除されません。
        </p></li><li class="listitem"><p>
          ルーチンの作成者は、ルーチンの <code class="literal">CREATE</code> ステートメントを実行するために使用されるアカウントです。 これは、ルーチン定義で <code class="literal">DEFINER</code> として名前が指定されているアカウントと同じでないことがあります。 
        </p></li><li class="listitem"><p>
          ルーチン <code class="literal">DEFINER</code> として指定されたアカウントは、その定義を含むすべてのルーチンプロパティーを表示できます。 したがって、アカウントは、次によって生成されるルーチン出力への完全なアクセス権を持ちます: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">INFORMATION_SCHEMA.ROUTINES</code> テーブルの内容。
            </p></li><li class="listitem"><p>
              <code class="literal">SHOW CREATE FUNCTION</code> および <code class="literal">SHOW CREATE PROCEDURE</code> ステートメント。
            </p></li><li class="listitem"><p>
              <code class="literal">SHOW FUNCTION CODE</code> および <code class="literal">SHOW PROCEDURE CODE</code> ステートメント。
            </p></li><li class="listitem"><p>
              <code class="literal">SHOW FUNCTION STATUS</code> および <code class="literal">SHOW PROCEDURE STATUS</code> ステートメント。
            </p></li></ul></div></li><li class="listitem"><p>
          ルーチン <code class="literal">DEFINER</code> として指定されたアカウント以外のアカウントのルーチンプロパティーへのアクセスは、アカウントに付与された権限によって異なります:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">SHOW_ROUTINE</code> 権限またはグローバル <code class="literal">SELECT</code> 権限を持つアカウントは、その定義を含むすべてのルーチンプロパティを表示できます。
            </p></li><li class="listitem"><p>
              <code class="literal">CREATE ROUTINE</code>、<code class="literal">ALTER ROUTINE</code> または <code class="literal">EXECUTE</code> 権限がルーチンを含むスコープで付与されている場合、アカウントはその定義を除くすべてのルーチンプロパティを表示できます。
            </p></li></ul></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="stored-routines-metadata"></a>25.2.3 ストアドルーチンのメタデータ</h3></div></div></div><a class="indexterm" name="idm46065428799760"></a><a class="indexterm" name="idm46065428797632"></a><p>
      ストアドルーチンに関するメタデータを取得するには:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">INFORMATION_SCHEMA</code> データベースの <code class="literal">ROUTINES</code> テーブルをクエリーします。 <a class="xref" href="information-schema.html#information-schema-routines-table" title="26.30 INFORMATION_SCHEMA ROUTINES テーブル">セクション26.30「INFORMATION_SCHEMA ROUTINES テーブル」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW CREATE PROCEDURE</code> および <code class="literal">SHOW CREATE FUNCTION</code> ステートメントを使用して、ルーチン定義を表示します。 <a class="xref" href="sql-statements.html#show-create-procedure" title="13.7.7.9 SHOW CREATE PROCEDURE ステートメント">セクション13.7.7.9「SHOW CREATE PROCEDURE ステートメント」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW PROCEDURE STATUS</code> および <code class="literal">SHOW FUNCTION STATUS</code> ステートメントを使用して、ルーチン特性を表示します。 <a class="xref" href="sql-statements.html#show-procedure-status" title="13.7.7.28 SHOW PROCEDURE STATUS ステートメント">セクション13.7.7.28「SHOW PROCEDURE STATUS ステートメント」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW PROCEDURE CODE</code> および <code class="literal">SHOW FUNCTION CODE</code> ステートメントを使用して、ルーチンの内部実装の表現を確認します。 <a class="xref" href="sql-statements.html#show-procedure-code" title="13.7.7.27 SHOW PROCEDURE CODE ステートメント">セクション13.7.7.27「SHOW PROCEDURE CODE ステートメント」</a>を参照してください。 
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="stored-routines-last-insert-id"></a>25.2.4 ストアドプロシージャー、関数、トリガー、および LAST_INSERT_ID()</h3></div></div></div><a class="indexterm" name="idm46065428779216"></a><a class="indexterm" name="idm46065428777120"></a><a class="indexterm" name="idm46065428775088"></a><a class="indexterm" name="idm46065428773136"></a><p>
      ストアドルーチン (プロシージャーまたは関数) またはトリガーの本体内では、<code class="literal">LAST_INSERT_ID()</code> の値は、このような種類のオブジェクトの本体外で実行されたステートメントと同様に変更されます (<a class="xref" href="functions.html#information-functions" title="12.16 情報関数">セクション12.16「情報関数」</a>を参照してください)。 あとに続くステートメントで参照される <code class="literal">LAST_INSERT_ID()</code> の値でのストアドルーチンまたはトリガーの効果は、ルーチンの種類によって異なります。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ストアドプロシージャーで <code class="literal">LAST_INSERT_ID()</code> の値を変更するステートメントが実行される場合は、プロシージャー呼び出しが続くステートメントで変更された値が参照されます。
        </p></li><li class="listitem"><p>
          値を変更するストアドファンクションやトリガーでは、値は関数やトリガーが終了したときにリストアされるので、後続のステートメントは変更された値を表示しません。
        </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="triggers"></a>25.3 トリガーの使用</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="stored-objects.html#trigger-syntax">25.3.1 トリガーの構文と例</a></span></dt><dt><span class="section"><a href="stored-objects.html#trigger-metadata">25.3.2 トリガーのメタデータ</a></span></dt></dl></div><a class="indexterm" name="idm46065428762000"></a><p>
    トリガーとは、テーブルに関連付けられ、そのテーブルに対して特定のイベントが発生するとアクティブ化される名前付きデータベースオブジェクトのことです。 トリガーを使用する場合には、テーブルに挿入する値のチェックを実行したり、更新にかかわる値の計算を実行したりする場合があります。 
  </p><p>
    トリガーは、関連付けられたテーブルでステートメントが行の挿入、更新、または削除を行なったときにアクティブ化するように定義されます。 これらの行操作がトリガーイベントになります。 たとえば、行は、<code class="literal">INSERT</code> または <code class="literal">LOAD DATA</code> ステートメントで挿入でき、挿入トリガーは挿入された行ごとにアクティブ化します。 トリガーは、トリガーイベントの前または後のどちらかでアクティブ化するように設定できます。 たとえば、テーブルに挿入される各行の前、または更新される各行のあとでトリガーをアクティブ化させることができます。 
  </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
      MySQL のトリガーは、SQL ステートメントがテーブルに対して行なった変更の場合にのみアクティブ化します。 これには、更新可能なビューの基礎となる実テーブルに対する変更が含まれます。 トリガーでは、SQL ステートメントを MySQL Server に送信しない API によって行われたテーブルに対する変更はアクティブ化されません。 これは、トリガーが <code class="literal">NDB</code> API を使用して行われた更新によってアクティブ化されないことを意味します。 
    </p><p>
      トリガーは、<code class="literal">INFORMATION_SCHEMA</code> テーブルまたは <code class="literal">performance_schema</code> テーブルの変更によってアクティブ化されません。 これらのテーブルは実際にはビューであり、トリガーはビューでは許可されません。 
    </p></div><p>
    次のセクションでは、トリガーを作成および削除するための構文について説明し、使用方法の例をいくつか挙げ、トリガーメタデータを取得する方法を示します。
  </p><h3><a name="idm46065428750288"></a>追加のリソース</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        トリガーを扱うときには、<a class="ulink" href="https://forums.mysql.com/list.php?100" target="_top">トリガーユーザーフォーラム</a>が役立ちます。
      </p></li><li class="listitem"><p>
        MySQL でのトリガーに関するよくある質問とその回答については、<a class="xref" href="faqs.html#faqs-triggers" title="A.5 MySQL 8.0 FAQ: トリガー">セクションA.5「MySQL 8.0 FAQ: トリガー」</a>を参照してください。
      </p></li><li class="listitem"><p>
        トリガーの使用にはいくつかの制限があります。<a class="xref" href="stored-objects.html#stored-program-restrictions" title="25.8 ストアドプログラムの制約">セクション25.8「ストアドプログラムの制約」</a>を参照してください。
      </p></li><li class="listitem"><p>
        トリガーのバイナリロギングは、<a class="xref" href="stored-objects.html#stored-programs-logging" title="25.7 ストアドプログラムバイナリロギング">セクション25.7「ストアドプログラムバイナリロギング」</a>で説明しているように行います。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="trigger-syntax"></a>25.3.1 トリガーの構文と例</h3></div></div></div><p>
      トリガーを作成したり、トリガーを削除したりするには、<a class="xref" href="sql-statements.html#create-trigger" title="13.1.22 CREATE TRIGGER ステートメント">セクション13.1.22「CREATE TRIGGER ステートメント」</a>および<a class="xref" href="sql-statements.html#drop-trigger" title="13.1.34 DROP TRIGGER ステートメント">セクション13.1.34「DROP TRIGGER ステートメント」</a>で説明しているように、<code class="literal">CREATE TRIGGER</code> または <code class="literal">DROP TRIGGER</code> ステートメントを使用します。
    </p><p>
      次に、<code class="literal">INSERT</code> 操作に対してアクティブ化するトリガーをテーブルに関連付ける簡単な例を示します。 このトリガーは加算器として機能し、テーブルのいずれかのカラムに挿入された値を合計します。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE account (acct_num INT, amount DECIMAL(10,2));</code></strong>
Query OK, 0 rows affected (0.03 sec)

mysql&gt; <strong class="userinput"><code>CREATE TRIGGER ins_sum BEFORE INSERT ON account</code></strong>
       <strong class="userinput"><code>FOR EACH ROW SET @sum = @sum + NEW.amount;</code></strong>
Query OK, 0 rows affected (0.01 sec)
</pre><p>
      <code class="literal">CREATE TRIGGER</code> ステートメントは、<code class="literal">account</code> テーブルに関連付けられている <code class="literal">ins_sum</code> という名前のトリガーを作成します。 トリガーアクションタイム、トリガーイベント、およびトリガーがアクティブ化したときに行う動作を指定する句も含みます。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          キーワード <code class="literal">BEFORE</code> は、トリガーアクションタイムを示します。 この場合、トリガーは、テーブルに挿入された各行の前にアクティブ化します。 ここで許可されている別のキーワードは <code class="literal">AFTER</code> です。 
        </p></li><li class="listitem"><p>
          キーワード <code class="literal">INSERT</code> は、トリガーイベント、つまりトリガーをアクティブ化する操作の種類を示します。 例では、<code class="literal">INSERT</code> 操作がトリガーのアクティブ化を引き起こします。 <code class="literal">DELETE</code> および <code class="literal">UPDATE</code> 操作に対するトリガーも作成できます。 
        </p></li><li class="listitem"><p>
          <code class="literal">FOR EACH ROW</code> に続くステートメントは、トリガー本体を定義します。これは、トリガーがアクティブ化するたびに実行するステートメントであり、トリガーイベントによって影響される行ごとに一度行われます。 この例では、トリガー本体は、<code class="literal">amount</code> カラムに挿入された値をユーザー変数に累積する単純な <code class="literal">SET</code> です。 このステートメントは、<span class="quote">「<span class="quote">新しい行に挿入される <code class="literal">amount</code> カラムの値</span>」</span>を意味する <code class="literal">NEW.amount</code> としてカラムを参照します。 
        </p></li></ul></div><p>
      トリガーを使用するには、加算器変数をゼロにセットし、<code class="literal">INSERT</code> ステートメントを実行して、その後変数がどの値になっているかを確認します。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET @sum = 0;</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO account VALUES(137,14.98),(141,1937.50),(97,-100.00);</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT @sum AS 'Total amount inserted';</code></strong>
+-----------------------+
| Total amount inserted |
+-----------------------+
|               1852.48 |
+-----------------------+
</pre><p>
      この場合、<code class="literal">INSERT</code> ステートメントの実行後の <code class="literal">@sum</code> の値は <code class="literal">14.98 + 1937.50 - 100</code> または <code class="literal">1852.48</code> です。
    </p><p>
      トリガーを破棄するには、<code class="literal">DROP TRIGGER</code> ステートメントを使用します。 トリガーがデフォルトスキーマにない場合、スキーマ名を指定する必要があります。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>DROP TRIGGER test.ins_sum;</code></strong>
</pre><p>
      テーブルを削除すると、そのテーブルのトリガーもすべて削除されます。
    </p><p>
      トリガー名はスキーマの名前空間内に存在します。つまり、すべてのトリガーがスキーマ内で一意の名前を持つ必要があります。 異なるスキーマ内のトリガーは同じ名前を持つことができます。 
    </p><p>
      同じトリガーイベントおよびアクション時間を持つ特定のテーブルに対して複数のトリガーを定義できます。 たとえば、1 つのテーブルに対して 2 つの <code class="literal">BEFORE UPDATE</code> トリガーを定義できます。 デフォルトでは、同じトリガーイベントおよびアクション時間を持つトリガーは、作成された順序で実行されます。 トリガーの順序を指定するには、<code class="literal">FOR EACH ROW</code> のあとに <code class="literal">FOLLOWS</code> または <code class="literal">PRECEDES</code> を示す句、および同じトリガーイベントとアクション時間を持つ既存のトリガーの名前を指定します。 <code class="literal">FOLLOWS</code> を指定すると、新しいトリガーは既存のトリガーのあとに実行されます。 <code class="literal">PRECEDES</code> を指定すると、新しいトリガーは既存のトリガーの前に実行されます。 
    </p><p>
      たとえば、次のトリガー定義では、<code class="literal">account</code> テーブルに対して別の <code class="literal">BEFORE INSERT</code> トリガーを定義します:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TRIGGER ins_transaction BEFORE INSERT ON account</code></strong>
       <strong class="userinput"><code>FOR EACH ROW PRECEDES ins_sum</code></strong>
       <strong class="userinput"><code>SET</code></strong>
       <strong class="userinput"><code>@deposits = @deposits + IF(NEW.amount&gt;0,NEW.amount,0),</code></strong>
       <strong class="userinput"><code>@withdrawals = @withdrawals + IF(NEW.amount&lt;0,-NEW.amount,0);</code></strong>
Query OK, 0 rows affected (0.01 sec)
</pre><p>
      このトリガーである <code class="literal">ins_transaction</code> は、<code class="literal">ins_sum</code> と似ていますが、デポジットと引出しを別々に累計します。 これには、<code class="literal">ins_sum</code> の前にアクティブ化する <code class="literal">PRECEDES</code> 句があります。この句がない場合、<code class="literal">ins_sum</code> の後に作成されるため、<code class="literal">ins_sum</code> の後にアクティブ化されます。 
    </p><p>
      トリガー本体内で、<code class="literal">OLD</code> および <code class="literal">NEW</code> キーワードを使用すると、トリガーの影響を受ける行のカラムにアクセスできます。 <code class="literal">OLD</code> および <code class="literal">NEW</code> は、トリガーに対する MySQL の拡張機能であり、大/小文字は区別されません。 
    </p><p>
      <code class="literal">INSERT</code> トリガー内では、<code class="literal">NEW.<em class="replaceable"><code>col_name</code></em></code> だけを使用できます。古い行はありません。 <code class="literal">DELETE</code> トリガーでは、<code class="literal">OLD.<em class="replaceable"><code>col_name</code></em></code> だけを使用できます。新しい行はありません。 <code class="literal">UPDATE</code> トリガーでは、<code class="literal">OLD.<em class="replaceable"><code>col_name</code></em></code> を使用して、更新される前の行のカラムを参照でき、<code class="literal">NEW.<em class="replaceable"><code>col_name</code></em></code> を使用して、更新されたあとの行のカラムを参照できます。 
    </p><p>
      <code class="literal">OLD</code> で指名されたカラムは読み取り専用です。 (それに対する <code class="literal">SELECT</code> 権限がある場合) 参照はできますが、変更はできません。 <code class="literal">NEW</code> で指名されたカラムは、それに対する <code class="literal">SELECT</code> 権限がある場合に参照できます。 <code class="literal">BEFORE</code> トリガーでは、それに対する <code class="literal">UPDATE</code> 権限がある場合、<code class="literal">SET NEW.<em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>value</code></em></code> でその値を変更することもできます。 これは、トリガーを使用して、新しい行に挿入する値または行の更新に使用される値を変更できることを意味します。 (このような <code class="literal">SET</code> ステートメントは、行の変更がすでに発生しているため、<code class="literal">AFTER</code> トリガーには影響しません。) 
    </p><p>
      <code class="literal">BEFORE</code> トリガーでは、<code class="literal">AUTO_INCREMENT</code> カラムの <code class="literal">NEW</code> 値は 0 であり、新しい行が実際に挿入されるときに自動的に生成されるシーケンス番号ではありません。
    </p><p>
      <code class="literal">BEGIN ... END</code> 構造構文を使用することにより、複数のステートメントを実行するトリガーを定義できます。 <code class="literal">BEGIN</code> ブロック内では、条件文やループなど、ストアドルーチン内で許可されたほかの構文を使用することもできます。 ただし、ストアドルーチンの場合と同様に、<span class="command"><strong>mysql</strong></span> プログラムを使用して、複数のステートメントを実行するトリガーを定義する場合、トリガー定義内で <code class="literal">;</code> ステートメント区切り文字を使用できるように、<span class="command"><strong>mysql</strong></span> ステートメント区切り文字を再定義する必要があります。 次の例はこれらの要点を示しています。 ここでは、各行の更新に使用する新しい値をチェックし、0 から 100 の範囲に収まるように値を変更する <code class="literal">UPDATE</code> トリガーを定義しています。 行の更新に使用される前に値をチェックする必要があるので、これは <code class="literal">BEFORE</code> トリガーにする必要があります。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>delimiter //</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TRIGGER upd_check BEFORE UPDATE ON account</code></strong>
       <strong class="userinput"><code>FOR EACH ROW</code></strong>
       <strong class="userinput"><code>BEGIN</code></strong>
           <strong class="userinput"><code>IF NEW.amount &lt; 0 THEN</code></strong>
               <strong class="userinput"><code>SET NEW.amount = 0;</code></strong>
           <strong class="userinput"><code>ELSEIF NEW.amount &gt; 100 THEN</code></strong>
               <strong class="userinput"><code>SET NEW.amount = 100;</code></strong>
           <strong class="userinput"><code>END IF;</code></strong>
       <strong class="userinput"><code>END;//</code></strong>
mysql&gt; <strong class="userinput"><code>delimiter ;</code></strong>
</pre><p>
      ストアドプロシージャーを個別に定義してから、単純な <code class="literal">CALL</code> ステートメントを使用してトリガーから呼び出したほうが簡単になる場合があります。 これは、複数のトリガー内から同じコードを実行する場合にも便利です。 
    </p><p>
      アクティブ化したときにトリガーが実行するステートメントに表示できる対象には制限があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          トリガーは、<code class="literal">CALL</code> ステートメントを使用して、データをクライアントに戻すストアドプロシージャーや、ダイナミック SQL を使用するストアドプロシージャーの呼び出しはできません。 (ストアドプロシージャーは、<code class="literal">OUT</code> または <code class="literal">INOUT</code> パラメータを通じてトリガーにデータを返すことが許可されています。) 
        </p></li><li class="listitem"><p>
          トリガーは、<code class="literal">START TRANSACTION</code>、<code class="literal">COMMIT</code>、<code class="literal">ROLLBACK</code> など、トランザクションを明示的または暗黙的に開始したり終了したりするステートメントを使用できません。 (<code class="literal">ROLLBACK to SAVEPOINT</code> はトランザクションを終了しないため、許可されます。)。 
        </p></li></ul></div><p>
      <a class="xref" href="stored-objects.html#stored-program-restrictions" title="25.8 ストアドプログラムの制約">セクション25.8「ストアドプログラムの制約」</a>も参照してください。
    </p><p>
      MySQL は次のようにトリガー実行中にエラーを処理します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">BEFORE</code> トリガーが失敗した場合、対応する行に対する操作は実行されません。
        </p></li><li class="listitem"><p>
          <code class="literal">BEFORE</code> トリガーは、行を挿入または変更しようとする<span class="emphasis"><em>試行</em></span> によってアクティブ化され、その試行がその後成功するかどうかには関係ありません。
        </p></li><li class="listitem"><p>
          <code class="literal">AFTER</code> トリガーは、すべての <code class="literal">BEFORE</code> トリガーと行操作の実行が成功した場合にのみ実行されます。
        </p></li><li class="listitem"><p>
          <code class="literal">BEFORE</code> または <code class="literal">AFTER</code> トリガーのどちらかの実行中にエラーが発生すると、トリガーの呼び出しを起こしたステートメント全体が失敗します。
        </p></li><li class="listitem"><p>
          トランザクションテーブルの場合、ステートメントの失敗により、ステートメントが実行したすべての変更がロールバックされます。 トリガーの失敗はステートメントの失敗を招くので、トリガーの失敗はロールバックも引き起こします。 非トランザクションテーブルの場合、このようなロールバックは行えないので、ステートメントが失敗しても、エラーの時点以前に実行されたすべて変更は有効なままです。 
        </p></li></ul></div><p>
      次の例に示す <code class="literal">testref</code> という名前のトリガーなど、トリガーには、名前によるテーブルへの直接の参照を含めることができます。
    </p><pre class="programlisting">CREATE TABLE test1(a1 INT);
CREATE TABLE test2(a2 INT);
CREATE TABLE test3(a3 INT NOT NULL AUTO_INCREMENT PRIMARY KEY);
CREATE TABLE test4(
  a4 INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
  b4 INT DEFAULT 0
);

delimiter |

CREATE TRIGGER testref BEFORE INSERT ON test1
  FOR EACH ROW
  BEGIN
    INSERT INTO test2 SET a2 = NEW.a1;
    DELETE FROM test3 WHERE a3 = NEW.a1;
    UPDATE test4 SET b4 = b4 + 1 WHERE a4 = NEW.a1;
  END;
|

delimiter ;

INSERT INTO test3 (a3) VALUES
  (NULL), (NULL), (NULL), (NULL), (NULL),
  (NULL), (NULL), (NULL), (NULL), (NULL);

INSERT INTO test4 (a4) VALUES
  (0), (0), (0), (0), (0), (0), (0), (0), (0), (0);
</pre><p>
      次に示すように、テーブル <code class="literal">test1</code> に次の値を挿入するとします。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO test1 VALUES </code></strong>
       <strong class="userinput"><code>(1), (3), (1), (7), (1), (8), (4), (4);</code></strong>
Query OK, 8 rows affected (0.01 sec)
Records: 8  Duplicates: 0  Warnings: 0
</pre><p>
      この結果、4 つのテーブルに次のデータが含まれます。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM test1;</code></strong>
+------+
| a1   |
+------+
|    1 |
|    3 |
|    1 |
|    7 |
|    1 |
|    8 |
|    4 |
|    4 |
+------+
8 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM test2;</code></strong>
+------+
| a2   |
+------+
|    1 |
|    3 |
|    1 |
|    7 |
|    1 |
|    8 |
|    4 |
|    4 |
+------+
8 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM test3;</code></strong>
+----+
| a3 |
+----+
|  2 |
|  5 |
|  6 |
|  9 |
| 10 |
+----+
5 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM test4;</code></strong>
+----+------+
| a4 | b4   |
+----+------+
|  1 |    3 |
|  2 |    0 |
|  3 |    1 |
|  4 |    2 |
|  5 |    0 |
|  6 |    0 |
|  7 |    1 |
|  8 |    1 |
|  9 |    0 |
| 10 |    0 |
+----+------+
10 rows in set (0.00 sec)
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="trigger-metadata"></a>25.3.2 トリガーのメタデータ</h3></div></div></div><a class="indexterm" name="idm46065428604160"></a><a class="indexterm" name="idm46065428602048"></a><p>
      トリガーに関するメタデータを取得するには:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">INFORMATION_SCHEMA</code> データベースの <code class="literal">TRIGGERS</code> テーブルをクエリーします。 <a class="xref" href="information-schema.html#information-schema-triggers-table" title="26.45 INFORMATION_SCHEMA TRIGGERS テーブル">セクション26.45「INFORMATION_SCHEMA TRIGGERS テーブル」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW CREATE TRIGGER</code> ステートメントを使用します。 <a class="xref" href="sql-statements.html#show-create-trigger" title="13.7.7.11 SHOW CREATE TRIGGER ステートメント">セクション13.7.7.11「SHOW CREATE TRIGGER ステートメント」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW TRIGGERS</code> ステートメントを使用します。 <a class="xref" href="sql-statements.html#show-triggers" title="13.7.7.40 SHOW TRIGGERS ステートメント">セクション13.7.7.40「SHOW TRIGGERS ステートメント」</a>を参照してください。 
        </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="event-scheduler"></a>25.4 イベントスケジューラの使用</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="stored-objects.html#events-overview">25.4.1 イベントスケジューラの概要</a></span></dt><dt><span class="section"><a href="stored-objects.html#events-configuration">25.4.2 イベントスケジューラの構成</a></span></dt><dt><span class="section"><a href="stored-objects.html#events-syntax">25.4.3 イベント構文</a></span></dt><dt><span class="section"><a href="stored-objects.html#events-metadata">25.4.4 イベントメタデータ</a></span></dt><dt><span class="section"><a href="stored-objects.html#events-status-info">25.4.5 イベントスケジューラのステータス</a></span></dt><dt><span class="section"><a href="stored-objects.html#events-privileges">25.4.6 イベントスケジューラと MySQL 権限</a></span></dt></dl></div><a class="indexterm" name="idm46065428589296"></a><a class="indexterm" name="idm46065428587840"></a><p>
    <span class="firstterm">MySQL イベントスケジューラ</span>は、イベント、つまりスケジュールに従って実行するタスクのスケジュール設定および実行を管理します。 次の説明では、イベントスケジューラを取り上げ、次のセクションに分かれています。 
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="xref" href="stored-objects.html#events-overview" title="25.4.1 イベントスケジューラの概要">セクション25.4.1「イベントスケジューラの概要」</a>では、MySQL イベントの概論と概念的概要を示します。
      </p></li><li class="listitem"><p>
        <a class="xref" href="stored-objects.html#events-syntax" title="25.4.3 イベント構文">セクション25.4.3「イベント構文」</a>では、MySQL イベントを作成、変更、および削除するための SQL ステートメントについて説明します。
      </p></li><li class="listitem"><p>
        <a class="xref" href="stored-objects.html#events-metadata" title="25.4.4 イベントメタデータ">セクション25.4.4「イベントメタデータ」</a>では、イベントに関する情報の取得方法と、MySQL Server でのこの情報の格納方法を示します。
      </p></li><li class="listitem"><p>
        <a class="xref" href="stored-objects.html#events-privileges" title="25.4.6 イベントスケジューラと MySQL 権限">セクション25.4.6「イベントスケジューラと MySQL 権限」</a>では、イベントを処理するために必要な権限と、実行時に権限に関してイベントが持つ派生問題について説明します。
      </p></li></ul></div><p>
    ストアドルーチンには、<code class="literal">mysql</code> システムデータベース内の <code class="literal">events</code> データディクショナリテーブルが必要です。 このテーブルは、MySQL 8.0 インストール手順中に作成されます。 以前のバージョンから MySQL 8.0 にアップグレードする場合は、アップグレード手順を実行して、システムデータベースが最新であることを確認してください。 <a class="xref" href="installing.html#upgrading" title="2.11 MySQL のアップグレード">セクション2.11「MySQL のアップグレード」</a>を参照してください。 
  </p><h3><a name="idm46065428574080"></a>追加のリソース</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        スケジュール設定済みイベントを扱うときには、「<a class="ulink" href="https://forums.mysql.com/list.php?119" target="_top">MySQL Event Scheduler User Forum</a>」が役立ちます。
      </p></li><li class="listitem"><p>
        イベントの使用にはいくつかの制限があります。<a class="xref" href="stored-objects.html#stored-program-restrictions" title="25.8 ストアドプログラムの制約">セクション25.8「ストアドプログラムの制約」</a>を参照してください。
      </p></li><li class="listitem"><p>
        イベントのバイナリロギングは、<a class="xref" href="stored-objects.html#stored-programs-logging" title="25.7 ストアドプログラムバイナリロギング">セクション25.7「ストアドプログラムバイナリロギング」</a>で説明しているように行われます。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="events-overview"></a>25.4.1 イベントスケジューラの概要</h3></div></div></div><a class="indexterm" name="idm46065428567040"></a><p>
      MySQL イベントはスケジュールに従って実行するタスクです。 したがって、これらを<span class="emphasis"><em>スケジュール設定済み</em></span>イベントと呼ぶことがあります。 イベントの作成時には、特定の日時に開始して終了し、1 つ以上の定期的な間隔で実行される 1 つ以上の SQL ステートメントを含んだ、名前付きデータベースオブジェクトを作成します。 概念的には、このことは Unix の <code class="literal">crontab</code> (<span class="quote">「<span class="quote">cron ジョブ</span>」</span>とも呼ばれます) や、Windows のタスクスケジューラの考え方に似ています。 
    </p><p>
      この種のスケジュール設定済みのタスクは、<span class="quote">「<span class="quote">時間トリガー</span>」</span>と呼ばれる場合もあり、これらが時間の経過によってトリガーされるオブジェクトであることを示しています。 これは基本的には正しいのですが、<a class="xref" href="stored-objects.html#triggers" title="25.3 トリガーの使用">セクション25.3「トリガーの使用」</a>で説明している種類のトリガーと混同しないように、<span class="emphasis"><em>イベント</em></span>の用語を使用します。 さらに厳密にいえば、イベントは<span class="quote">「<span class="quote">時間トリガー</span>」</span>と混同しないようにする必要があります。 トリガーは、指定したテーブルで行われるイベントの特定の種類に応じて実行されるステートメントを持つデータベースオブジェクトですが、(スケジュール設定済み) イベントは、指定された時間間隔の経過に応じて実行されるステートメントを持つオブジェクトです。 
    </p><p>
      SQL 標準にはイベントのスケジュール設定への対応はありませんが、ほかのデータベースシステムには先例があり、これらの実装と MySQL Server で見られる実装との間には一定の類似性が認められます。
    </p><p>
      MySQL イベントには次の主要機能およびプロパティーがあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          MySQL では、イベントはその名前およびイベントが割り当てられているスキーマによって一意に識別されます。
        </p></li><li class="listitem"><p>
          イベントは、スケジュールに従って特定のアクションを実行します。 このアクションは、SQL ステートメントから構成され、必要に応じて <code class="literal">BEGIN ... END</code> ブロック内の複合ステートメントにできます (<a class="xref" href="sql-statements.html#sql-compound-statements" title="13.6 複合ステートメントの構文">セクション13.6「複合ステートメントの構文」</a>を参照してください)。 イベントのタイミングは<span class="firstterm">一度だけ</span>または<span class="firstterm">繰り返し</span>のどちらかです。 一度だけのイベントは一度しか実行しません。 繰り返しのイベントは、一定の間隔でアクションを繰り返し、イベントを繰り返すためのスケジュールに、特定の開始日時と終了日時の両方または一方を割り当てるか、どちらも割り当てないことができます。 (デフォルトで、繰り返しイベントのスケジュールは作成されるとすぐに開始し、無効または削除されるまで継続します。) 
        </p><p>
          繰り返しイベントがスケジュール間隔内に終了しない場合は、イベントの複数のインスタンスが同時に実行される可能性があります。 これが好ましくない場合は、同時インスタンスを回避するためのメカニズムを設けてください。 たとえば、<code class="literal">GET_LOCK()</code> 関数や、行またはテーブルのロックを使用できます。 
        </p></li><li class="listitem"><p>
          ユーザーは、これらの目的用の SQL ステートメントを使用してスケジュール設定済みイベントを作成、変更、および削除できます。 構文が無効なイベント作成および変更ステートメントは失敗し、対応するエラーメッセージが表示されます。 <span class="emphasis"><em>ユーザーは、実際には自身が保有していない権限を必要とするステートメントを、イベントのアクションに含めることがあります</em></span>。 イベントの作成または変更ステートメントは成功しますが、イベントのアクションは失敗します。 詳細は、<a class="xref" href="stored-objects.html#events-privileges" title="25.4.6 イベントスケジューラと MySQL 権限">セクション25.4.6「イベントスケジューラと MySQL 権限」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          イベントのプロパティーの多くは、SQL ステートメントを使用して設定または変更できます。 これらのプロパティーには、イベントの名前、タイミング、持続性 (つまり、そのスケジュールの有効期限が切れたあとも保持されるかどうか)、ステータス (有効または無効)、実行するアクション、および割り当て先のスキーマが含まれます。 <a class="xref" href="sql-statements.html#alter-event" title="13.1.3 ALTER EVENT ステートメント">セクション13.1.3「ALTER EVENT ステートメント」</a>を参照してください。 
        </p><p>
          イベントのデフォルトの定義者は、イベントが変更されていない場合は、イベントを作成したユーザーであり、変更されている場合は、定義者はそのイベントに影響する <code class="literal">ALTER EVENT</code> ステートメントを最後に発行したユーザーです。 イベントが定義されているデータベースに対する <code class="literal">EVENT</code> 権限を保有するすべてのユーザーは、そのイベントを変更できます。 <a class="xref" href="stored-objects.html#events-privileges" title="25.4.6 イベントスケジューラと MySQL 権限">セクション25.4.6「イベントスケジューラと MySQL 権限」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          イベントのアクションステートメントには、ストアドルーチン内で許可されているほとんどの SQL ステートメントを含めることができます。 制限については、<a class="xref" href="stored-objects.html#stored-program-restrictions" title="25.8 ストアドプログラムの制約">セクション25.8「ストアドプログラムの制約」</a>を参照してください。 
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="events-configuration"></a>25.4.2 イベントスケジューラの構成</h3></div></div></div><p>
      イベントは、特別な<span class="firstterm">イベントスケジューラスレッド</span>によって実行されます。イベントスケジューラと呼ぶ場合、実際にはこのスレッドを指しています。 実行中、イベントスケジューラスレッドとその現在の状態は、次の説明で示すように、<code class="literal">PROCESS</code> 権限を保有するユーザーが <code class="literal">SHOW PROCESSLIST</code> の出力で確認できます。 
    </p><a class="indexterm" name="idm46065428531616"></a><a class="indexterm" name="idm46065428529424"></a><p>
      <code class="literal">event_scheduler</code> グローバルシステム変数によって、イベントスケジューラがサーバー上で有効であり実行しているかどうかが決まります。 ここで説明するように、これらの 3 つの値のいずれかがイベントのスケジューリングに影響します。 デフォルトは <code class="literal">ON</code> です。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">ON</code>: イベントスケジューラが開始され、イベントスケジューラスレッドがすべてのスケジュール設定済みイベントを実行しています。
        </p><a class="indexterm" name="idm46065428522848"></a><p>
          イベントスケジューラが <code class="literal">ON</code> の場合、イベントスケジューラスレッドは、デーモンプロセスとして <code class="literal">SHOW PROCESSLIST</code> の出力に一覧表示され、その状態は次に示すように表示されます。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW PROCESSLIST\G</code></strong>
*************************** 1. row ***************************
     Id: 1
   User: root
   Host: localhost
     db: NULL
Command: Query
   Time: 0
  State: NULL
   Info: show processlist
*************************** 2. row ***************************
     Id: 2
   User: event_scheduler
   Host: localhost
     db: NULL
Command: Daemon
   Time: 3
  State: Waiting for next activation
   Info: NULL
2 rows in set (0.00 sec)
</pre><p>
          イベントスケジュール設定は、<code class="literal">event_scheduler</code> の値を <code class="literal">OFF</code> に設定することで停止できます。
        </p></li><li class="listitem"><p>
          <code class="literal">OFF</code>: イベントスケジューラは停止しています。 イベントスケジューラスレッドは実行されておらず、<code class="literal">SHOW PROCESSLIST</code> の出力に表示されておらず、スケジュール設定済みイベントが実行されていません。 
        </p><p>
          イベントスケジューラが停止している場合 (<code class="literal">event_scheduler</code> が <code class="literal">OFF</code> です)、<code class="literal">event_scheduler</code> の値を <code class="literal">ON</code> に設定することで開始できます。 (次の項目を参照してください。) 
        </p></li><li class="listitem"><p>
          <code class="literal">DISABLED</code>: この値はイベントスケジューラを動作しないようにします。 イベントスケジューラが <code class="literal">DISABLED</code> の場合、イベントスケジューラスレッドは実行していません (また、<code class="literal">SHOW PROCESSLIST</code> の出力にも表示されません)。 また、イベントスケジューラの状態は実行時に変更できません。 
        </p></li></ul></div><p>
      イベントスケジューラのステータスが <code class="literal">DISABLED</code> に設定されていない場合、(<code class="literal">SET</code> を使用して) <code class="literal">event_scheduler</code> の <code class="literal">ON</code> と <code class="literal">OFF</code> を切り替えることができます。 この変数を設定するときに、<code class="literal">OFF</code> に <code class="literal">0</code> を、<code class="literal">ON</code> に <code class="literal">1</code> を使用することも可能です。 したがって、<span class="command"><strong>mysql</strong></span> クライアントで次の 4 つのどのステートメントを使用しても、イベントスケジューラをオンにできます。 
    </p><pre class="programlisting">SET GLOBAL event_scheduler = ON;
SET @@GLOBAL.event_scheduler = ON;
SET GLOBAL event_scheduler = 1;
SET @@GLOBAL.event_scheduler = 1;
</pre><p>
      同様に、次の 4 つのどのステートメントを使用してもイベントスケジューラをオフにできます。
    </p><pre class="programlisting">SET GLOBAL event_scheduler = OFF;
SET @@GLOBAL.event_scheduler = OFF;
SET GLOBAL event_scheduler = 0;
SET @@GLOBAL.event_scheduler = 0;
</pre><p>
      <code class="literal">ON</code> と <code class="literal">OFF</code> には対応する数値がありますが、<code class="literal">SELECT</code> または <code class="literal">SHOW VARIABLES</code> によって <code class="literal">event_scheduler</code> に対して表示される値は、常に <code class="literal">OFF</code>、<code class="literal">ON</code>、または <code class="literal">DISABLED</code> のいずれかになります。 <span class="emphasis"><em><code class="literal">DISABLED</code> に対応する数値はありません</em></span>。 このため、この変数を設定するときに、<code class="literal">ON</code> と <code class="literal">OFF</code> は通常 <code class="literal">1</code> と <code class="literal">0</code> よりも優先されます。 
    </p><p>
      グローバル変数として指定しないで <code class="literal">event_scheduler</code> を設定しようとすると、エラーが発生します。
    </p><pre class="programlisting">mysql&lt; <strong class="userinput"><code>SET @@event_scheduler = OFF;</code></strong>
<span class="errortext">ERROR 1229 (HY000): Variable 'event_scheduler' is a GLOBAL
variable and should be set with SET GLOBAL</span>
</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        イベントスケジューラを <code class="literal">DISABLED</code> に設定できるのは、サーバーの起動時だけです。 <code class="literal">event_scheduler</code> が <code class="literal">ON</code> または <code class="literal">OFF</code> の場合、実行時にこれを <code class="literal">DISABLED</code> には設定できません。 また、イベントスケジューラが起動時に <code class="literal">DISABLED</code> に設定されている場合、実行時に <code class="literal">event_scheduler</code> の値に変更できません。 
      </p></div><p>
      イベントスケジューラを無効にするには、次の 2 つの方法のいずれかを使用します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          サーバーの起動時のコマンド行オプションとして
        </p><pre class="programlisting">--event-scheduler=DISABLED
</pre></li><li class="listitem"><p>
          サーバー構成ファイル (<code class="filename">my.cnf</code> または Windows システム上の <code class="filename">my.ini</code>) に、サーバーが読み取ることができる行を含めます (<code class="literal">[mysqld]</code>セクションなど):
        </p><pre class="programlisting">event_scheduler=DISABLED
</pre></li></ul></div><p>
      イベントスケジューラを有効にするには、必要に応じて、<code class="option">--event-scheduler=DISABLED</code> コマンド行オプションを使用しないでサーバーを再起動するか、サーバー構成ファイルの <code class="option">event-scheduler=DISABLED</code> を含む行を削除するかコメントアウトしたあとでサーバーを再起動します。 または、サーバーの起動時に <code class="literal">DISABLED</code> 値の代わりに <code class="literal">ON</code> (または <code class="literal">1</code>) か <code class="literal">OFF</code> (または <code class="literal">0</code>) を使用できます。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">event_scheduler</code> が <code class="literal">DISABLED</code> に設定されている場合、イベント操作ステートメントを発行できます。 このような場合には警告もエラーも生成されません (ステートメント自体が有効であるとします)。 ただし、この変数を <code class="literal">ON</code> (または <code class="literal">1</code>) に設定するまで、スケジュール設定済みイベントは実行できません。 これが行われると、イベントスケジューラスレッドは、スケジュール設定条件が満たされているすべてのイベントを実行します。 
      </p></div><p>
      <code class="option">--skip-grant-tables</code> オプションを使用して MySQL Server を起動すると、<code class="literal">event_scheduler</code> が <code class="literal">DISABLED</code> に設定され、コマンド行や <code class="filename">my.cnf</code> または <code class="filename">my.ini</code> ファイルで設定されたほかのすべての値をオーバーライドします (Bug #26807)。
    </p><p>
      イベントの作成、変更、または削除に使用される SQL ステートメントについては、<a class="xref" href="stored-objects.html#events-syntax" title="25.4.3 イベント構文">セクション25.4.3「イベント構文」</a>を参照してください。
    </p><p>
      MySQL は、<code class="literal">INFORMATION_SCHEMA</code> データベースに <code class="literal">EVENTS</code> テーブルを提供します。 このテーブルは、サーバー上で定義されているスケジュール設定済みイベントに関する情報を取得するためにクエリーできます。 詳細は、<a class="xref" href="stored-objects.html#events-metadata" title="25.4.4 イベントメタデータ">セクション25.4.4「イベントメタデータ」</a>および<a class="xref" href="information-schema.html#information-schema-events-table" title="26.14 INFORMATION_SCHEMA EVENTS テーブル">セクション26.14「INFORMATION_SCHEMA EVENTS テーブル」</a>を参照してください。 
    </p><p>
      イベントスケジュール設定と MySQL 権限システムに関する情報については、<a class="xref" href="stored-objects.html#events-privileges" title="25.4.6 イベントスケジューラと MySQL 権限">セクション25.4.6「イベントスケジューラと MySQL 権限」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="events-syntax"></a>25.4.3 イベント構文</h3></div></div></div><a class="indexterm" name="idm46065428438816"></a><p>
      MySQL には、スケジュールされたイベントを操作するための複数の SQL ステートメントが用意されています:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          新しいイベントは <code class="literal">CREATE EVENT</code> ステートメントを使用して定義されます。 <a class="xref" href="sql-statements.html#create-event" title="13.1.13 CREATE EVENT ステートメント">セクション13.1.13「CREATE EVENT ステートメント」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          既存のイベントの定義は、<code class="literal">ALTER EVENT</code> ステートメントによって変更できます。 <a class="xref" href="sql-statements.html#alter-event" title="13.1.3 ALTER EVENT ステートメント">セクション13.1.3「ALTER EVENT ステートメント」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          スケジュール設定済みイベントが不要になった場合は、その定義者が、<code class="literal">DROP EVENT</code> ステートメントを使用してサーバーから削除できます。 <a class="xref" href="sql-statements.html#drop-event" title="13.1.25 DROP EVENT ステートメント">セクション13.1.25「DROP EVENT ステートメント」</a>を参照してください。 イベントがそのスケジュールの終了を過ぎても持続されるかどうかは、<code class="literal">ON COMPLETION</code> 句がある場合、この句によって決まります。 <a class="xref" href="sql-statements.html#create-event" title="13.1.13 CREATE EVENT ステートメント">セクション13.1.13「CREATE EVENT ステートメント」</a>を参照してください。 
        </p><p>
          イベントが定義されているデータベースに対する <code class="literal">EVENT</code> 権限を保有するすべてのユーザーは、そのイベントをドロップできます。 <a class="xref" href="stored-objects.html#events-privileges" title="25.4.6 イベントスケジューラと MySQL 権限">セクション25.4.6「イベントスケジューラと MySQL 権限」</a>を参照してください。 
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="events-metadata"></a>25.4.4 イベントメタデータ</h3></div></div></div><a class="indexterm" name="idm46065428422048"></a><a class="indexterm" name="idm46065428419872"></a><p>
      イベントに関するメタデータを取得するには:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">INFORMATION_SCHEMA</code> データベースの <code class="literal">EVENTS</code> テーブルをクエリーします。 <a class="xref" href="information-schema.html#information-schema-events-table" title="26.14 INFORMATION_SCHEMA EVENTS テーブル">セクション26.14「INFORMATION_SCHEMA EVENTS テーブル」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW CREATE EVENT</code> ステートメントを使用します。 <a class="xref" href="sql-statements.html#show-create-event" title="13.7.7.7 SHOW CREATE EVENT ステートメント">セクション13.7.7.7「SHOW CREATE EVENT ステートメント」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW EVENTS</code> ステートメントを使用します。 <a class="xref" href="sql-statements.html#show-events" title="13.7.7.18 SHOW EVENTS ステートメント">セクション13.7.7.18「SHOW EVENTS ステートメント」</a>を参照してください。 
        </p></li></ul></div><p>
      <span class="bold"><strong>イベントスケジューラの時間表現</strong></span>
    </p><a class="indexterm" name="idm46065428407488"></a><a class="indexterm" name="idm46065428405296"></a><p>
      MySQL の各セッションには、セッションタイムゾーン (STZ) があります。 これは、セッションの開始時にサーバーの <code class="literal">time_zone</code> グローバル値から初期化される <code class="literal">time_zone</code> セッション値ですが、セッション中に変更される可能性があります。 
    </p><p>
      <code class="literal">CREATE EVENT</code> または <code class="literal">ALTER EVENT</code> ステートメントが実行するときに使用されているセッションタイムゾーンが、イベント定義で指定されている時間の解釈に使用されます。 これがイベントタイムゾーン (ETZ) になります。つまり、イベントのスケジュール設定に使用され、イベントが実行するときにそのイベント内で有効になるタイムゾーンになります。 
    </p><p>
      データディクショナリでのイベント情報の表現では、<code class="literal">execute_at</code>、<code class="literal">starts</code> および <code class="literal">ends</code> の時間は UTC に変換され、イベントタイムゾーンとともに格納されます。 これにより、サーバータイムゾーンまたはサマータイムの影響に対し生じた変更とは無関係に、定義されたとおりにイベントの実行を処理できます。 <code class="literal">last_executed</code> 時間も UTC で格納されます。 
    </p><p>
      イベント時間は、<code class="literal">INFORMATION_SCHEMA.EVENTS</code> テーブルまたは <code class="literal">SHOW EVENTS</code> から選択することで取得できますが、ETZ または STZ 値としてレポートされます。 次の表は、イベント時間の表現をまとめています。 
    </p><div class="informaltable"><table summary="Summary of event time representation (as UTC, EZT, or STZ values) from INFORMATION_SCHEMA.EVENTS, and SHOW EVENTS."><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><thead><tr>
          <th scope="col">値</th>
          <th scope="col"><code class="literal">INFORMATION_SCHEMA.EVENTS</code></th>
          <th scope="col"><code class="literal">SHOW EVENTS</code></th>
        </tr></thead><tbody><tr>
          <th scope="row">Execute at</th>
          <td>ETZ</td>
          <td>ETZ</td>
        </tr><tr>
          <th scope="row">Starts</th>
          <td>ETZ</td>
          <td>ETZ</td>
        </tr><tr>
          <th scope="row">Ends</th>
          <td>ETZ</td>
          <td>ETZ</td>
        </tr><tr>
          <th scope="row">Last executed</th>
          <td>ETZ</td>
          <td>該当なし</td>
        </tr><tr>
          <th scope="row">Created</th>
          <td>STZ</td>
          <td>該当なし</td>
        </tr><tr>
          <th scope="row">Last altered</th>
          <td>STZ</td>
          <td>該当なし</td>
        </tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="events-status-info"></a>25.4.5 イベントスケジューラのステータス</h3></div></div></div><a class="indexterm" name="idm46065428360656"></a><a class="indexterm" name="idm46065428358464"></a><a class="indexterm" name="idm46065428357232"></a><p>
      イベントスケジューラは、エラーまたは警告で終了したイベント実行に関する情報を、MySQL Server のエラーログに書き込みます。 例については <a class="xref" href="stored-objects.html#events-privileges" title="25.4.6 イベントスケジューラと MySQL 権限">セクション25.4.6「イベントスケジューラと MySQL 権限」</a>を参照してください。 
    </p><p>
      デバッグおよびトラブルシューティングのためにイベントスケジューラの状態に関する状態を取得するには、<span class="command"><strong>mysqladmin debug</strong></span> を実行します (<a class="xref" href="programs.html#mysqladmin" title="4.5.2 mysqladmin — A MySQL Server 管理プログラム">セクション4.5.2「mysqladmin — A MySQL Server 管理プログラム」</a>を参照してください)。このコマンドの実行後に、ここに示すようなイベントスケジューラに関連した出力がサーバーのエラーログに含まれます。
    </p><pre class="programlisting">Events status:
LLA = Last Locked At  LUA = Last Unlocked At
WOC = Waiting On Condition  DL = Data Locked

Event scheduler status:
State      : INITIALIZED
Thread id  : 0
LLA        : n/a:0
LUA        : n/a:0
WOC        : NO
Workers    : 0
Executed   : 0
Data locked: NO

Event queue status:
Element count   : 0
Data locked     : NO
Attempting lock : NO
LLA             : init_queue:95
LUA             : init_queue:103
WOC             : NO
Next activation : never
</pre><p>
      イベントスケジューラが実行するイベントの一部として生じるステートメント内で、診断メッセージ (エラーだけでなく警告も) がエラーログと、Windows ではアプリケーションイベントログに書き込まれます。 頻繁に実行するイベントの場合、これにより、多数のメッセージが記録される結果になることがあります。 たとえば、<code class="literal">SELECT ... INTO <em class="replaceable"><code>var_list</code></em></code> ステートメントの場合、クエリーが行を返さなければ、エラーコード 1329 で警告が発生し (<code class="literal">No data</code>)、変数値は変更されないままになります。 クエリーが複数の行を返す場合は、エラー 1172 が発生します (<code class="literal">結果が 2 行以上です</code>)。 どちらの条件についても、条件ハンドラを宣言すると、警告を記録させないようにできます。<a class="xref" href="sql-statements.html#declare-handler" title="13.6.7.2 DECLARE ... HANDLER ステートメント">セクション13.6.7.2「DECLARE ... HANDLER ステートメント」</a>を参照してください。 複数の行を取得できるステートメントの場合、<code class="literal">LIMIT 1</code> を使用して結果セットを単一の行に制限するという別の方法があります。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="events-privileges"></a>25.4.6 イベントスケジューラと MySQL 権限</h3></div></div></div><a class="indexterm" name="idm46065428342736"></a><p>
      スケジュール設定済みイベントの実行を有効または無効にするには、<code class="literal">event_scheduler</code> グローバルシステム変数の値を設定する必要があります。 これには、グローバルシステム変数を設定するのに十分な権限が必要です。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 
    </p><p>
      <code class="literal">EVENT</code> 権限は、イベントの作成、変更、および削除を制御します。 この権限は、<code class="literal">GRANT</code> を使用して与えることができます。 たとえば、次の <code class="literal">GRANT</code> ステートメントは、<code class="literal">myschema</code> という名前のスキーマに対する <code class="literal">EVENT</code> 権限を、ユーザー <code class="literal">jon@ghidora</code> に与えます。 
    </p><pre class="programlisting">GRANT EVENT ON myschema.* TO jon@ghidora;
</pre><p>
      (このユーザーアカウントがすでに存在していることと、その他の点では変更されないままであると想定しています。)
    </p><p>
      この同じユーザーにすべてのスキーマに対する <code class="literal">EVENT</code> 権限を認めるには、次のステートメントを使用します。
    </p><pre class="programlisting">GRANT EVENT ON *.* TO jon@ghidora;
</pre><p>
      <code class="literal">EVENT</code> 権限にはグローバルまたはスキーマレベルのスコープがあります。 このため、単一のテーブルに対してこれを与えようとすると、次のようなエラーが生じます。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>GRANT EVENT ON myschema.mytable TO jon@ghidora;</code></strong>
<span class="errortext">ERROR 1144 (42000): Illegal GRANT/REVOKE command; please
consult the manual to see which privileges can be used</span>
</pre><p>
      イベントはその定義者の権限で実行され、定義者が必須の権限を保有していないアクションは実行できません。 たとえば、<code class="literal">jon@ghidora</code> が <code class="literal">myschema</code> に対する <code class="literal">EVENT</code> 権限を保有しているとします。 また、このユーザーは <code class="literal">myschema</code> に対する <code class="literal">SELECT</code> 権限は保有しているが、このスキーマに対するほかの権限は保有していないとします。 <code class="literal">jon@ghidora</code> は、次のような新しいイベントを作成できます。 
    </p><pre class="programlisting">CREATE EVENT e_store_ts
    ON SCHEDULE
      EVERY 10 SECOND
    DO
      INSERT INTO myschema.mytable VALUES (UNIX_TIMESTAMP());
</pre><p>
      このユーザーは 1 分ほど待機したあと、テーブルに複数の新しい行が表示されることを予想して <code class="literal">SELECT * FROM mytable;</code> クエリーを実行します。 実際は、テーブルは空です。 ユーザーは該当するテーブルに対する <code class="literal">INSERT</code> 権限がないので、イベントの効果はありませんでした。 
    </p><p>
      MySQL エラーログ (<code class="filename"><em class="replaceable"><code>hostname</code></em>.err</code>) を調べると、イベントが実行中であることがわかりますが、実行しようとしているアクションは失敗します:
    </p><pre class="programlisting">2013-09-24T12:41:31.261992Z 25 [ERROR] Event Scheduler:
[jon@ghidora][cookbook.e_store_ts] INSERT command denied to user
'jon'@'ghidora' for table 'mytable'
2013-09-24T12:41:31.262022Z 25 [Note] Event Scheduler:
[jon@ghidora].[myschema.e_store_ts] event execution failed.
2013-09-24T12:41:41.271796Z 26 [ERROR] Event Scheduler:
[jon@ghidora][cookbook.e_store_ts] INSERT command denied to user
'jon'@'ghidora' for table 'mytable'
2013-09-24T12:41:41.272761Z 26 [Note] Event Scheduler:
[jon@ghidora].[myschema.e_store_ts] event execution failed.
</pre><p>
      このユーザーは、エラーログにアクセスできない可能性が非常に高いので、直接それを実行することによって、イベントのアクションステートメントが有効であるかどうか検証できます。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO myschema.mytable VALUES (UNIX_TIMESTAMP());</code></strong>
<span class="errortext">ERROR 1142 (42000): INSERT command denied to user
'jon'@'ghidora' for table 'mytable'</span>
</pre><a class="indexterm" name="idm46065428307184"></a><p>
      <code class="literal">INFORMATION_SCHEMA.EVENTS</code> テーブルを調べることによって、<code class="literal">e_store_ts</code> が存在し有効になっているが、その <code class="literal">LAST_EXECUTED</code> カラムが <code class="literal">NULL</code> になっていることがわかります。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.EVENTS</code></strong>
     &gt;     <strong class="userinput"><code>WHERE EVENT_NAME='e_store_ts'</code></strong>
     &gt;     <strong class="userinput"><code>AND EVENT_SCHEMA='myschema'\G</code></strong>
*************************** 1. row ***************************
   EVENT_CATALOG: NULL
    EVENT_SCHEMA: myschema
      EVENT_NAME: e_store_ts
         DEFINER: jon@ghidora
      EVENT_BODY: SQL
EVENT_DEFINITION: INSERT INTO myschema.mytable VALUES (UNIX_TIMESTAMP())
      EVENT_TYPE: RECURRING
      EXECUTE_AT: NULL
  INTERVAL_VALUE: 5
  INTERVAL_FIELD: SECOND
        SQL_MODE: NULL
          STARTS: 0000-00-00 00:00:00
            ENDS: 0000-00-00 00:00:00
          STATUS: ENABLED
   ON_COMPLETION: NOT PRESERVE
         CREATED: 2006-02-09 22:36:06
    LAST_ALTERED: 2006-02-09 22:36:06
   LAST_EXECUTED: NULL
   EVENT_COMMENT:
1 row in set (0.00 sec)
</pre><p>
      <code class="literal">EVENT</code> 権限を取り消すには、<code class="literal">REVOKE</code> ステートメントを使用します。 この例では、スキーマ <code class="literal">myschema</code> に対する <code class="literal">EVENT</code> 権限が <code class="literal">jon@ghidora</code> ユーザーアカウントから削除されます。 
    </p><pre class="programlisting">REVOKE EVENT ON myschema.* FROM jon@ghidora;
</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        ユーザーから <code class="literal">EVENT</code> 権限を取り消しても、そのユーザーが作成したイベントが削除されたり無効にされたりすることはありません。
      </p><p>
        作成したユーザーの名前を変更したり削除したりしても、イベントが移行または削除されることはありません。
      </p></div><p>
      ユーザー <code class="literal">jon@ghidora</code> に、<code class="literal">myschema</code> スキーマに対する <code class="literal">EVENT</code> および <code class="literal">INSERT</code> 権限が与えられているとします。 続いてこのユーザーが次のイベントを作成します。 
    </p><pre class="programlisting">CREATE EVENT e_insert
    ON SCHEDULE
      EVERY 7 SECOND
    DO
      INSERT INTO myschema.mytable;
</pre><p>
      このイベントの作成後、<code class="literal">root</code> は <code class="literal">jon@ghidora</code> の <code class="literal">EVENT</code> 権限を取り消します。 ただし、<code class="literal">e_insert</code> は実行し続け、7 秒ごとに新しい行が <code class="literal">mytable</code> に挿入されます。 <code class="literal">root</code> が次のどちらかのステートメントを発行した場合も、同じことが当てはまります。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">DROP USER jon@ghidora;</code>
        </p></li><li class="listitem"><p>
          <code class="literal">RENAME USER jon@ghidora TO someotherguy@ghidora;</code>
        </p></li></ul></div><p>
      これが正しいことを確認するには、<code class="literal">DROP USER</code> または <code class="literal">RENAME USER</code> ステートメントの発行前後に <code class="literal">INFORMATION_SCHEMA.EVENTS</code> テーブル (<a class="xref" href="information-schema.html#information-schema-events-table" title="26.14 INFORMATION_SCHEMA EVENTS テーブル">セクション26.14「INFORMATION_SCHEMA EVENTS テーブル」</a> を参照) を調べます。
    </p><p>
      イベント定義はデータディクショナリに格納されます。 別のユーザーアカウントによって作成されたイベントを削除するには、MySQL <code class="literal">root</code> ユーザーまたは必要な権限を持つ別のユーザーである必要があります。 
    </p><p>
      ユーザーの <code class="literal">EVENT</code> 権限は、<code class="literal">mysql.user</code> および <code class="literal">mysql.db</code> テーブルの <code class="literal">Event_priv</code> カラムに格納されています。 どちらの場合でも、このカラムには、<code class="literal">「Y」</code>または<code class="literal">「N」</code>のどちらかの値が含まれています。 <code class="literal">「N」</code>がデフォルトです。指定されたユーザーがグローバルな <code class="literal">EVENT</code> 権限を保有している場合 (つまり、<code class="literal">GRANT EVENT ON *.*</code> を使用して権限が与えられた場合) にのみ、そのユーザーの <code class="literal">mysql.user.Event_priv</code> は<code class="literal">「Y」</code>に設定されます。 スキーマレベルの <code class="literal">EVENT</code> 権限の場合、<code class="literal">GRANT</code> は、<code class="literal">mysql.db</code> に行を作成し、その行の <code class="literal">Db</code> カラムをスキーマの名前に、<code class="literal">User</code> カラムをユーザーの名前に、<code class="literal">Event_priv</code> カラムを<code class="literal">「Y」</code>に設定します。 <code class="literal">GRANT EVENT</code> および <code class="literal">REVOKE EVENT</code> ステートメントがこれらのテーブルでの必要な操作を実行するので、これらのテーブルを直接操作する必要はありません。 
    </p><a class="indexterm" name="idm46065428251040"></a><p>
      5 つのステータス変数が、イベント関連操作のカウントを提供します (ただし、イベントが実行するステートメントのカウントは提供<span class="emphasis"><em>しません</em></span>。<a class="xref" href="stored-objects.html#stored-program-restrictions" title="25.8 ストアドプログラムの制約">セクション25.8「ストアドプログラムの制約」</a>を参照してください)。 これらを次に示します。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">Com_create_event</code>: サーバーが最後に再起動してから実行された <code class="literal">CREATE EVENT</code> ステートメントの数。
        </p></li><li class="listitem"><p>
          <code class="literal">Com_alter_event</code>: サーバーが最後に再起動してから実行された <code class="literal">ALTER EVENT</code> ステートメントの数。
        </p></li><li class="listitem"><p>
          <code class="literal">Com_drop_event</code>: サーバーが最後に再起動してから実行された <code class="literal">DROP EVENT</code> ステートメントの数。
        </p></li><li class="listitem"><p>
          <code class="literal">Com_show_create_event</code>: サーバーが最後に再起動してから実行された <code class="literal">SHOW CREATE EVENT</code> ステートメントの数。
        </p></li><li class="listitem"><p>
          <code class="literal">Com_show_events</code>: サーバーが最後に再起動してから実行された <code class="literal">SHOW EVENTS</code> ステートメントの数。
        </p></li></ul></div><p>
      ステートメント <code class="literal">SHOW STATUS LIKE '%event%';</code> を実行すると、これらのすべての現在値を一度に表示できます。
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="views"></a>25.5 ビューの使用</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="stored-objects.html#view-syntax">25.5.1 ビューの構文</a></span></dt><dt><span class="section"><a href="stored-objects.html#view-algorithms">25.5.2 ビュー処理アルゴリズム</a></span></dt><dt><span class="section"><a href="stored-objects.html#view-updatability">25.5.3 更新可能および挿入可能なビュー</a></span></dt><dt><span class="section"><a href="stored-objects.html#view-check-option">25.5.4 WITH CHECK OPTION 句の表示</a></span></dt><dt><span class="section"><a href="stored-objects.html#view-metadata">25.5.5 ビューのメタデータ</a></span></dt></dl></div><a class="indexterm" name="idm46065428230624"></a><p>
    MySQL では、更新可能なビューを含むビューがサポートされています。 ビューは、呼び出されたときに結果セットを生成するストアドクエリーです。 ビューは仮想テーブルとして機能します。 
  </p><p>
    次の説明では、ビューを作成し削除するための構文について記述し、それらの使用法の例をいくつか示します。
  </p><h3><a name="idm46065428227520"></a>追加のリソース</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        ビューを扱うときには、「<a class="ulink" href="https://forums.mysql.com/list.php?100" target="_top">Views User Forum</a>」が役立ちます。
      </p></li><li class="listitem"><p>
        MySQL のビューに関するよくある質問とその回答については、<a class="xref" href="faqs.html#faqs-views" title="A.6 MySQL 8.0 FAQ: ビュー">セクションA.6「MySQL 8.0 FAQ: ビュー」</a>を参照してください。
      </p></li><li class="listitem"><p>
        ビューの使用にはいくつかの制限があります。<a class="xref" href="stored-objects.html#view-restrictions" title="25.9 ビューの制約">セクション25.9「ビューの制約」</a>を参照してください。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="view-syntax"></a>25.5.1 ビューの構文</h3></div></div></div><p>
      <code class="literal">CREATE VIEW</code> ステートメントは新しいビューを作成します (<a class="xref" href="sql-statements.html#create-view" title="13.1.23 CREATE VIEW ステートメント">セクション13.1.23「CREATE VIEW ステートメント」</a>を参照してください)。 ビューの定義を変更したり、ビューを削除したりするには、<code class="literal">ALTER VIEW</code> (<a class="xref" href="sql-statements.html#alter-view" title="13.1.11 ALTER VIEW ステートメント">セクション13.1.11「ALTER VIEW ステートメント」</a>を参照してください) または <code class="literal">DROP VIEW</code> (<a class="xref" href="sql-statements.html#drop-view" title="13.1.35 DROP VIEW ステートメント">セクション13.1.35「DROP VIEW ステートメント」</a>を参照してください) を使用します。 
    </p><p>
      ビューは、多くの種類の <code class="literal">SELECT</code> ステートメントから作成できできます。 ベーステーブルまたはほかのビューを参照できます。 結合、<code class="literal">UNION</code>、およびサブクエリーを使用できます。 <code class="literal">SELECT</code> がテーブルをまったく参照しなくてもかまいません。 次の例では、別のテーブルからの 2 つのカラムに加え、それらのカラムから計算される式を選択するビューを定義しています。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t (qty INT, price INT);</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t VALUES(3, 50), (5, 60);</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE VIEW v AS SELECT qty, price, qty*price AS value FROM t;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM v;</code></strong>
+------+-------+-------+
| qty  | price | value |
+------+-------+-------+
|    3 |    50 |   150 |
|    5 |    60 |   300 |
+------+-------+-------+
mysql&gt; <strong class="userinput"><code>SELECT * FROM v WHERE qty = 5;</code></strong>
+------+-------+-------+
| qty  | price | value |
+------+-------+-------+
|    5 |    60 |   300 |
+------+-------+-------+
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="view-algorithms"></a>25.5.2 ビュー処理アルゴリズム</h3></div></div></div><a class="indexterm" name="idm46065428204128"></a><p>
      <code class="literal">CREATE VIEW</code> または <code class="literal">ALTER VIEW</code> のオプションの <code class="literal">ALGORITHM</code> 句は、標準 SQL に対する MySQL 拡張です。 これは、MySQL によるビューの処理方法に影響を与えます。 <code class="literal">ALGORITHM</code> は、<code class="literal">MERGE</code>、<code class="literal">TEMPTABLE</code>、または <code class="literal">UNDEFINED</code> の 3 つの値を受け取ります。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">MERGE</code> の場合、ビューを参照するステートメントのテキストとビュー定義がマージされ、ビュー定義の部分が対応するステートメントの部分と置き換えられます。
        </p></li><li class="listitem"><p>
          <code class="literal">TEMPTABLE</code> の場合、ビューの結果が一時テーブル内に取得され、その後、ステートメントを実行するために使用されます。
        </p></li><li class="listitem"><p>
          <code class="literal">UNDEFINED</code> の場合、MySQL は使用するアルゴリズムを選択します。 できるかぎり <code class="literal">TEMPTABLE</code> より <code class="literal">MERGE</code> が優先されます。これは通常、<code class="literal">MERGE</code> のほうが効率性が高く、一時テーブルを使用するとビューを更新できなくなるためです。 
        </p></li><li class="listitem"><p>
          <code class="literal">ALGORITHM</code> 句が存在しない場合、デフォルトのアルゴリズムは <code class="literal">optimizer_switch</code> システム変数の <code class="literal">derived_merge</code> フラグの値によって決定されます。 詳細は、<a class="xref" href="optimization.html#derived-table-optimization" title="8.2.2.4 マージまたは実体化を使用した導出テーブル、ビュー参照および共通テーブル式の最適化">セクション8.2.2.4「マージまたは実体化を使用した導出テーブル、ビュー参照および共通テーブル式の最適化」</a>を参照してください。 
        </p></li></ul></div><p>
      <code class="literal">TEMPTABLE</code> を明示的に指定する理由は、一時テーブルの作成後、ステートメントの処理を終了するために使用する前に、基礎となるテーブルでロックを解放できるためです。 その結果、<code class="literal">MERGE</code> アルゴリズムよりもすみやかにロックが解除され、ビューを使用するほかのクライアントが長時間ブロックされることがなくなります。 
    </p><p>
      次の 3 つの理由によって、ビューアルゴリズムを<code class="literal">UNDEFINED</code> にできます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">CREATE VIEW</code> ステートメントの中に <code class="literal">ALGORITHM</code> 句が存在しない。
        </p></li><li class="listitem"><p>
          <code class="literal">CREATE VIEW</code> ステートメントに明示的な <code class="literal">ALGORITHM = UNDEFINED</code> 句が含まれている。
        </p></li><li class="listitem"><p>
          一時テーブルだけでしか処理できないビューに対して、<code class="literal">ALGORITHM = MERGE</code> が指定されている。 この場合、MySQL は警告を発し、アルゴリズムを <code class="literal">UNDEFINED</code> に設定します。 
        </p></li></ul></div><p>
      前述のように、<code class="literal">MERGE</code> は、ビュー定義の対応する部分を、ビューを参照するステートメントにマージして処理されます。 次の例で、<code class="literal">MERGE</code> アルゴリズムの動作について簡単に説明します。 例では、次の定義を含むビュー <code class="literal">v_merge</code> が存在していると想定します。 
    </p><pre class="programlisting">CREATE ALGORITHM = MERGE VIEW v_merge (vc1, vc2) AS
SELECT c1, c2 FROM t WHERE c3 &gt; 100;
</pre><p>
      例 1: 次のステートメントを発行するとします。
    </p><pre class="programlisting">SELECT * FROM v_merge;
</pre><p>
      MySQL は次のようにステートメントを処理します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">v_merge</code> は <code class="literal">t</code> になる
        </p></li><li class="listitem"><p>
          <code class="literal">*</code> は <code class="literal">vc1, vc2</code> となり、<code class="literal">c1, c2</code> と一致する
        </p></li><li class="listitem"><p>
          ビュー <code class="literal">WHERE</code> 句が追加される
        </p></li></ul></div><p>
      結果が実行されるステートメントは次のようになります。
    </p><pre class="programlisting">SELECT c1, c2 FROM t WHERE c3 &gt; 100;
</pre><p>
      例 2: 次のステートメントを発行するとします。
    </p><pre class="programlisting">SELECT * FROM v_merge WHERE vc1 &lt; 100;
</pre><p>
      このステートメントは、前述のステートメントと同様に処理されますが、<code class="literal">vc1 &lt; 100</code> が <code class="literal">c1 &lt; 100</code> になり、<code class="literal">AND</code> 連結詞を使用してビュー <code class="literal">WHERE</code> 句がステートメント <code class="literal">WHERE</code> 句に追加される点が異なります (また、句の一部が確実に正しい優先順位で実行されるように、かっこが追加されます)。 結果が実行されるステートメントは次のようになります。 
    </p><pre class="programlisting">SELECT c1, c2 FROM t WHERE (c3 &gt; 100) AND (c1 &lt; 100);
</pre><p>
      事実上、実行されるステートメントには、次の形式の <code class="literal">WHERE</code> 句が含まれます。
    </p><pre class="programlisting">WHERE (select WHERE) AND (view WHERE)
</pre><p>
      <code class="literal">MERGE</code> アルゴリズムを使用できない場合、一時テーブルを代わりに使用する必要があります。 マージを防止する構成要素は、導出テーブルおよび共通テーブル式でのマージを防止する構成要素と同じです。 例として、サブクエリー内の <code class="literal">SELECT DISTINCT</code> または <code class="literal">LIMIT</code> があります。 詳細は、<a class="xref" href="optimization.html#derived-table-optimization" title="8.2.2.4 マージまたは実体化を使用した導出テーブル、ビュー参照および共通テーブル式の最適化">セクション8.2.2.4「マージまたは実体化を使用した導出テーブル、ビュー参照および共通テーブル式の最適化」</a>を参照してください。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="view-updatability"></a>25.5.3 更新可能および挿入可能なビュー</h3></div></div></div><a class="indexterm" name="idm46065428140960"></a><a class="indexterm" name="idm46065428139504"></a><a class="indexterm" name="idm46065428137472"></a><a class="indexterm" name="idm46065428135520"></a><p>
      一部のビューは更新可能であり、それらへの参照を使用して、データ変更ステートメントで更新するテーブルを指定できます。 つまり、これらのビューを <code class="literal">UPDATE</code>、<code class="literal">DELETE</code>、<code class="literal">INSERT</code> などのステートメントで使用して、ベースとなるテーブルの内容を更新できます。 導出テーブルおよび共通テーブル式は、複数テーブルの <code class="literal">UPDATE</code> ステートメントおよび <code class="literal">DELETE</code> ステートメントでも指定できますが、更新または削除する行を指定するためのデータの読取りにのみ使用できます。 通常、ビュー参照は更新可能である必要があります。つまり、マージされて実体化されない場合があります。 コンポジットビューには、より複雑なルールがあります。 
    </p><p>
      ビューが更新可能であるためには、そのビュー内の行とベースとなるテーブル内の行の間に 1 対 1 の関係が存在する必要があります。 また、ビューを更新不可能にするその他の特定の構造構文も存在します。 より具体的には、次のいずれかを含む場合、ビューは更新可能ではありません。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          集計関数またはウィンドウ関数 (<code class="literal">SUM()</code>, <code class="literal">MIN()</code>, <code class="literal">MAX()</code>, <code class="literal">COUNT()</code> など)
        </p></li><li class="listitem"><p>
          <code class="literal">DISTINCT</code>
        </p></li><li class="listitem"><p>
          <code class="literal">GROUP BY</code>
        </p></li><li class="listitem"><p>
          <code class="literal">HAVING</code>
        </p></li><li class="listitem"><p>
          <code class="literal">UNION</code> または <code class="literal">UNION ALL</code>
        </p></li><li class="listitem"><p>
          選択リスト内のサブクエリー
        </p><p>
          選択リスト内の非依存サブクエリーは、<code class="literal">INSERT</code> では失敗しますが、<code class="literal">UPDATE</code>、<code class="literal">DELETE</code> では問題ありません。 選択リスト内の依存サブクエリーの場合、データ変更ステートメントは許可されません。 
        </p></li><li class="listitem"><p>
          特定の結合 (このセクションで後述する結合に関する追加説明を参照してください)
        </p></li><li class="listitem"><p>
          <code class="literal">FROM</code> 句内の更新不可ビューへの参照
        </p></li><li class="listitem"><p>
          <code class="literal">FROM</code> 句のテーブルを参照する <code class="literal">WHERE</code> 句のサブクエリー
        </p></li><li class="listitem"><p>
          リテラル値だけの参照 (この場合、更新するベースとなるテーブルがありません)
        </p></li><li class="listitem"><p>
          <code class="literal">ALGORITHM = TEMPTABLE</code> (一時テーブルを使用すると、常にビューが更新不可になります)
        </p></li><li class="listitem"><p>
          実テーブルの任意のカラムへの複数の参照 (<code class="literal">INSERT</code> では失敗、<code class="literal">UPDATE</code>、<code class="literal">DELETE</code> では OK)
        </p></li></ul></div><a class="indexterm" name="idm46065428096752"></a><p>
      ビュー内の生成されたカラムは、割り当て可能であるため、更新可能とみなされます。 ただし、このようなカラムが明示的に更新される場合、許可される値は <code class="literal">DEFAULT</code> のみです。 生成されるカラムの詳細は、<a class="xref" href="sql-statements.html#create-table-generated-columns" title="13.1.20.8 CREATE TABLE および生成されるカラム">セクション13.1.20.8「CREATE TABLE および生成されるカラム」</a> を参照してください。 
    </p><p>
      <code class="literal">MERGE</code> アルゴリズムで処理できるとすれば、複数テーブルビューが更新できる可能性があります。 これを実現するには、ビューで (外部結合または <code class="literal">UNION</code> ではなく) 内部結合を使用する必要があります。 また、ビュー定義内の単一のテーブルだけを更新できるので、<code class="literal">SET</code> 句は、ビュー内のいずれかのテーブルのカラムだけを指名する必要があります。 理論的には更新可能であっても、<code class="literal">UNION ALL</code> を使用するビューは許可されません。 
    </p><p>
      挿入可能性 (<code class="literal">INSERT</code> ステートメントで更新可能であること) については、更新可能なビューがビューカラムに対する次の追加要件も満たしている場合に挿入可能になります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          重複したビューカラム名が存在しないようにする必要があります。
        </p></li><li class="listitem"><p>
          ビューには、デフォルト値を持たない、ベーステーブル内のすべてのカラムが含まれている必要があります。
        </p></li><li class="listitem"><p>
          ビューカラムは単純なカラム参照である必要があります。 次のような式は使用できません: 
        </p><pre class="programlisting">3.14159
col1 + 3
UPPER(col2)
col3 / col4
(<em class="replaceable"><code>subquery</code></em>)
</pre></li></ul></div><p>
      MySQL は、<code class="literal">CREATE VIEW</code> 時に、ビューの更新可能性フラグというフラグを設定します。 <code class="literal">UPDATE</code> および <code class="literal">DELETE</code> (および同様の操作) がビューで有効な場合、フラグは <code class="literal">YES</code> (true) に設定されます。 それ以外の場合、フラグは <code class="literal">NO</code> (false) に設定されます。 <code class="literal">INFORMATION_SCHEMA.VIEWS</code> テーブルの <code class="literal">IS_UPDATABLE</code> カラムは、このフラグのステータスを表示します。 これは、ビューが更新可能であるかどうかをサーバーが常に把握していることを意味します。 
    </p><p>
      ビューが更新可能でない場合、<code class="literal">UPDATE</code>、<code class="literal">DELETE</code> および <code class="literal">INSERT</code> などのステートメントは無効であり、拒否されます。 (ビューが更新可能であっても、このセクションの別の場所で説明されているように、ビューに挿入できない場合があります。) 
    </p><p>
      ビューを更新できるかどうかは、<code class="literal">updatable_views_with_limit</code> システム変数の値に影響されます。 <a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>を参照してください。 
    </p><p>
      次の説明では、これらのテーブルおよびビューが存在するとします:
    </p><pre class="programlisting">CREATE TABLE t1 (x INTEGER);
CREATE TABLE t2 (c INTEGER);
CREATE VIEW vmat AS SELECT SUM(x) AS s FROM t1;
CREATE VIEW vup AS SELECT * FROM t2;
CREATE VIEW vjoin AS SELECT * FROM vmat JOIN vup ON vmat.s=vup.c;
</pre><p>
      <code class="literal">INSERT</code>、<code class="literal">UPDATE</code> および <code class="literal">DELETE</code> ステートメントは、次のように許可されます:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">INSERT</code>: <code class="literal">INSERT</code> ステートメントの挿入テーブルは、マージされるビュー参照である場合があります。 ビューが結合ビューの場合、ビューのすべてのコンポーネントは更新可能である必要があります (実体化されていません)。 更新可能な複数テーブルビューでは、<code class="literal">INSERT</code> は、単一のテーブルに挿入する場合に機能します。 
        </p><p>
          結合ビューのいずれかのコンポーネントが更新不可であるため、このステートメントは無効です:
        </p><pre class="programlisting">INSERT INTO vjoin (c) VALUES (1);
</pre><p>
          このステートメントは有効です。ビューには実体化コンポーネントが含まれていません:
        </p><pre class="programlisting">INSERT INTO vup (c) VALUES (1);
</pre></li><li class="listitem"><p>
          <code class="literal">UPDATE</code>: <code class="literal">UPDATE</code> ステートメントで更新されるテーブルは、マージされるビュー参照である場合があります。 ビューが結合ビューの場合、ビューの少なくとも 1 つのコンポーネントが更新可能である必要があります (<code class="literal">INSERT</code> とは異なります)。 
        </p><p>
          複数テーブルの <code class="literal">UPDATE</code> ステートメントでは、ステートメントの更新されたテーブル参照は実テーブルまたは更新可能なビュー参照である必要があります。 更新されていないテーブル参照は、実体化ビューまたは導出テーブルです。 
        </p><p>
          次のステートメントは有効です。カラム <code class="literal">c</code> は結合ビューの更新可能な部分のものです:
        </p><pre class="programlisting">UPDATE vjoin SET c=c+1;
</pre><p>
          このステートメントは無効です。カラム <code class="literal">x</code> は更新不可能な部分のものです:
        </p><pre class="programlisting">UPDATE vjoin SET x=x+1;
</pre><p>
          次のステートメントは有効です。複数テーブルの <code class="literal">UPDATE</code> の更新されたテーブル参照は更新可能なビュー (<code class="literal">vup</code>) です:
        </p><pre class="programlisting">UPDATE vup JOIN (SELECT SUM(x) AS s FROM t1) AS dt ON ...
SET c=c+1;
</pre><p>
          このステートメントは無効です。実体化導出テーブルを更新しようとしています:
        </p><pre class="programlisting">UPDATE vup JOIN (SELECT SUM(x) AS s FROM t1) AS dt ON ...
SET s=s+1;
</pre></li><li class="listitem"><p>
          <code class="literal">DELETE</code>: <code class="literal">DELETE</code> ステートメントで削除するテーブルは、マージビューである必要があります。 結合ビューは使用できません (<code class="literal">INSERT</code> および <code class="literal">UPDATE</code> とは異なります)。 
        </p><p>
          ビューが結合ビューであるため、このステートメントは無効です:
        </p><pre class="programlisting">DELETE vjoin WHERE ...;
</pre><p>
          このステートメントは、ビューがマージ (更新可能) ビューであるため有効です:
        </p><pre class="programlisting">DELETE vup WHERE ...;
</pre><p>
          このステートメントは、マージされた (更新可能な) ビューから削除されるため有効です:
        </p><pre class="programlisting">DELETE vup FROM vup JOIN (SELECT SUM(x) AS s FROM t1) AS dt ON ...;
</pre></li></ul></div><p>
      その他の説明と例を次に示します。
    </p><p>
      このセクションの以前の説明では、すべてのカラムが単純なカラム参照ではない場合 (たとえば、式または複合式であるカラムが含まれている場合)、ビューを挿入できないことを指摘していました。 このようなビューは挿入できませんが、式ではないカラムのみを更新すると更新できます。 次のビューを考えてみてください。 
    </p><pre class="programlisting">CREATE VIEW v AS SELECT col1, 1 AS col2 FROM t;
</pre><p>
      <code class="literal">col2</code> が式であるため、このビューは挿入できません。 ただし、更新で <code class="literal">col2</code> を更新しようとしていない場合は、更新可能になります。 次の更新は許可されます。 
    </p><pre class="programlisting">UPDATE v SET col1 = 0;
</pre><p>
      式カラムを更新しようとしているため、この更新は許可されません:
    </p><pre class="programlisting">UPDATE v SET col2 = 0;
</pre><p>
      テーブルに <code class="literal">AUTO_INCREMENT</code> カラムが含まれている場合、<code class="literal">AUTO_INCREMENT</code> カラムが含まれていないテーブル上の挿入可能なビューに挿入すると、<code class="literal">LAST_INSERT_ID()</code> の値を変更しません。これは、ビューの一部ではないカラムにデフォルト値を挿入した副作用が現れないようにするためです。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="view-check-option"></a>25.5.4 WITH CHECK OPTION 句の表示</h3></div></div></div><p>
      更新可能なビューに <code class="literal">WITH CHECK OPTION</code> 句を指定して、<em class="replaceable"><code>select_statement</code></em> の <code class="literal">WHERE</code> 句が true でない行への挿入を防止できます。 また、<code class="literal">WHERE</code> 句が true であるが、更新によって true にならない行の更新も防止されます (つまり、表示可能な行が非表示の行に更新されないようにします)。 
    </p><p>
      更新可能なビューに対する <code class="literal">WITH CHECK OPTION</code> 句では、そのビューが別のビューとの関連で定義されている場合、<code class="literal">LOCAL</code> および <code class="literal">CASCADED</code> キーワードによってチェックテストのスコープが決定されます。 どちらのキーワードも指定されていない場合、デフォルトは <code class="literal">CASCADED</code> になります。 
    </p><p>
      <code class="literal">WITH CHECK OPTION</code> テストは標準に準拠しています:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">LOCAL</code> では、ビューの <code class="literal">WHERE</code> 句がチェックされ、基礎となるビューに対してチェックが繰り返され、同じルールが適用されます。
        </p></li><li class="listitem"><p>
          <code class="literal">CASCADED</code> では、ビューの <code class="literal">WHERE</code> 句がチェックされ、基礎となるビューに対してチェックが繰り返され、<code class="literal">WITH CASCADED CHECK OPTION</code> が追加されて (チェックの目的で、定義は変更されません)、同じルールが適用されます。
        </p></li><li class="listitem"><p>
          チェックオプションを指定しない場合、ビューの <code class="literal">WHERE</code> 句はチェックされず、基礎となるビューに対してチェックが繰り返され、同じルールが適用されます。
        </p></li></ul></div><p>
      次のテーブルと一連のビューの定義を考えてみてください。
    </p><pre class="programlisting">CREATE TABLE t1 (a INT);
CREATE VIEW v1 AS SELECT * FROM t1 WHERE a &lt; 2
WITH CHECK OPTION;
CREATE VIEW v2 AS SELECT * FROM v1 WHERE a &gt; 0
WITH LOCAL CHECK OPTION;
CREATE VIEW v3 AS SELECT * FROM v1 WHERE a &gt; 0
WITH CASCADED CHECK OPTION;
</pre><p>
      ここで、<code class="literal">v2</code> ビューと <code class="literal">v3</code> ビューは、別のビュー <code class="literal">v1</code> で定義されています。
    </p><p>
      <code class="literal">v2</code> の挿入が <code class="literal">LOCAL</code> チェックオプションに対してチェックされ、チェックが <code class="literal">v1</code> に対して繰り返され、ルールが再度適用されます。 <code class="literal">v1</code> のルールによってチェックが失敗します。 <code class="literal">v3</code> のチェックも失敗します: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO v2 VALUES (2);</code></strong>
ERROR 1369 (HY000): CHECK OPTION failed 'test.v2'
mysql&gt; <strong class="userinput"><code>INSERT INTO v3 VALUES (2);</code></strong>
ERROR 1369 (HY000): CHECK OPTION failed 'test.v3'
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="view-metadata"></a>25.5.5 ビューのメタデータ</h3></div></div></div><a class="indexterm" name="idm46065427986400"></a><a class="indexterm" name="idm46065427984288"></a><p>
      ビューに関するメタデータを取得するには:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">INFORMATION_SCHEMA</code> データベースの <code class="literal">VIEWS</code> テーブルをクエリーします。 <a class="xref" href="information-schema.html#information-schema-views-table" title="26.48 INFORMATION_SCHEMA VIEWS テーブル">セクション26.48「INFORMATION_SCHEMA VIEWS テーブル」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW CREATE VIEW</code> ステートメントを使用します。 <a class="xref" href="sql-statements.html#show-create-view" title="13.7.7.13 SHOW CREATE VIEW ステートメント">セクション13.7.7.13「SHOW CREATE VIEW ステートメント」</a>を参照してください。 
        </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="stored-objects-security"></a>25.6 ストアドオブジェクトのアクセス制御</h2></div></div></div><a class="indexterm" name="idm46065427974192"></a><a class="indexterm" name="idm46065427972048"></a><a class="indexterm" name="idm46065427970656"></a><a class="indexterm" name="idm46065427968608"></a><a class="indexterm" name="idm46065427966944"></a><a class="indexterm" name="idm46065427965168"></a><a class="indexterm" name="idm46065427963696"></a><a class="indexterm" name="idm46065427962032"></a><p>
      ストアドプログラム (プロシージャ、ファンクション、トリガーおよびイベント) およびビューは、使用前に定義され、参照されると、権限を決定するセキュリティコンテキスト内で実行されます。 ストアドオブジェクトの実行に適用可能な権限は、その <code class="literal">DEFINER</code> 属性および <code class="literal">SQL SECURITY</code> 特性によって制御されます。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="stored-objects.html#stored-objects-security-definer" title="DEFINER 属性">DEFINER 属性</a></p></li><li class="listitem"><p><a class="xref" href="stored-objects.html#stored-objects-security-sql-security" title="SQL SECURITY 特性">SQL SECURITY 特性</a></p></li><li class="listitem"><p><a class="xref" href="stored-objects.html#stored-objects-security-examples" title="例">例</a></p></li><li class="listitem"><p><a class="xref" href="stored-objects.html#stored-objects-security-orphan-objects" title="孤立したストアドオブジェクト">孤立したストアドオブジェクト</a></p></li><li class="listitem"><p><a class="xref" href="stored-objects.html#stored-objects-security-guidelines" title="リスク最小化のガイドライン">リスク最小化のガイドライン</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="stored-objects-security-definer"></a>DEFINER 属性</h3></div></div></div><p>
        格納されたオブジェクト定義には、MySQL アカウントを指定する <code class="literal">DEFINER</code> 属性を含めることができます。 定義で <code class="literal">DEFINER</code> 属性が省略されている場合、デフォルトのオブジェクト定義者はそれを作成したユーザーです。 
      </p><p>
        次のルールによって、格納されたオブジェクトの <code class="literal">DEFINER</code> 属性として指定できるアカウントが決定されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">SET_USER_ID</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) がある場合は、任意のアカウントを <code class="literal">DEFINER</code> 属性として指定できます。 アカウントが存在しない場合は、警告が生成されます。 また、ストアドオブジェクトの <code class="literal">DEFINER</code> 属性を <code class="literal">SYSTEM_USER</code> 権限を持つアカウントに設定するには、<code class="literal">SYSTEM_USER</code> 権限が必要です。 
          </p></li><li class="listitem"><p>
            それ以外の場合、許可されるアカウントは、文字どおり、または <code class="literal">CURRENT_USER</code> または <code class="literal">CURRENT_USER()</code> として指定された独自のアカウントのみです。 定義者は他のアカウントに設定できません。 
          </p></li></ul></div><p>
        存在しない <code class="literal">DEFINER</code> アカウントでストアドオブジェクトを作成すると、孤立したオブジェクトが作成され、負の結果になる可能性があります。<a class="xref" href="stored-objects.html#stored-objects-security-orphan-objects" title="孤立したストアドオブジェクト">孤立したストアドオブジェクト</a> を参照してください。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="stored-objects-security-sql-security"></a>SQL SECURITY 特性</h3></div></div></div><p>
        ストアドルーチン (プロシージャおよびファンクション) およびビューの場合、オブジェクト定義に <code class="literal">DEFINER</code> または <code class="literal">INVOKER</code> の値を持つ <code class="literal">SQL SECURITY</code> 特性を含めて、オブジェクトが定義者コンテキストで実行されるか起動側コンテキストで実行されるかを指定できます。 定義で <code class="literal">SQL SECURITY</code> 特性が省略されている場合、デフォルトは定義者コンテキストです。 
      </p><p>
        トリガーとイベントには、<code class="literal">SQL SECURITY</code> 特性がなく、常に定義側のコンテキストで実行します。 サーバーが必要に応じて自動的にこれらのオブジェクトを呼び出すので、呼び出し元ユーザーは存在しません。 
      </p><p>
        定義側と呼び出し元のセキュリティーのコンテキストは次のように異なります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            定義者セキュリティコンテキストで実行されるストアドオブジェクトは、その <code class="literal">DEFINER</code> 属性で指定されたアカウントの権限で実行されます。 これらの権限は、呼び出し元ユーザーの権限とは完全に異なる場合があります。 実行者は、オブジェクトを参照する適切な権限 (たとえば、ストアドプロシージャをコールするための <code class="literal">EXECUTE</code> またはビューから選択する <code class="literal">SELECT</code> など) を持っている必要がありますが、オブジェクトの実行中、実行者権限は無視され、<code class="literal">DEFINER</code> アカウント権限のみが関係します。 <code class="literal">DEFINER</code> アカウントに少数の権限がある場合、オブジェクトは実行可能な操作に対応して制限されます。 <code class="literal">DEFINER</code> アカウントが高い権限を持つ場合 (管理アカウントなど)、オブジェクトは強力な操作<span class="emphasis"><em>誰が呼び出すかに関係なく</em></span>を実行できます。 
          </p></li><li class="listitem"><p>
            呼び出し元のセキュリティーコンテキストで実行するストアドルーチンまたはビューは、呼び出し元が権限を持つ操作だけを実行できます。 <code class="literal">DEFINER</code> 属性はオブジェクトの実行には影響しません。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="stored-objects-security-examples"></a>例</h3></div></div></div><p>
        定義者セキュリティコンテキストで実行するために <code class="literal">SQL SECURITY DEFINER</code> で宣言されている次のストアドプロシージャについて考えてみます:
      </p><pre class="programlisting">CREATE DEFINER = 'admin'@'localhost' PROCEDURE p1()
SQL SECURITY DEFINER
BEGIN
  UPDATE t1 SET counter = counter + 1;
END;
</pre><p>
        <code class="literal">p1</code> に対する <code class="literal">EXECUTE</code> 権限を持つどのユーザーでも、<code class="literal">CALL</code> ステートメントを使用してこれを呼び出すことができます。 ただし、<code class="literal">p1</code> を実行すると、定義者セキュリティコンテキストで実行されるため、<code class="literal">DEFINER</code> 属性として指定されたアカウントである<code class="literal">'admin'@'localhost'</code>の権限で実行されます。 このアカウントには、<code class="literal">p1</code> に対する <code class="literal">EXECUTE</code> 権限と、オブジェクト本体内で参照される <code class="literal">t1</code> テーブルに対する <code class="literal">UPDATE</code> 権限が必要です。 それ以外の場合、プロシージャーは失敗します。 
      </p><p>
        続いて次のストアドプロシージャーを検討してください。これは <code class="literal">p1</code> と同じですが、その <code class="literal">SQL SECURITY</code> 特性が <code class="literal">INVOKER</code> である点が異なります。
      </p><pre class="programlisting">CREATE DEFINER = 'admin'@'localhost' PROCEDURE p2()
SQL SECURITY INVOKER
BEGIN
  UPDATE t1 SET counter = counter + 1;
END;
</pre><p>
        <code class="literal">p1</code> とは異なり、<code class="literal">p2</code> は起動側セキュリティコンテキストで実行されるため、<code class="literal">DEFINER</code> 属性値に関係なく、起動側ユーザーの権限を使用します。実行者に <code class="literal">p2</code> に対する <code class="literal">EXECUTE</code> 権限または <code class="literal">t1</code> テーブルに対する <code class="literal">UPDATE</code> 権限がない場合、<code class="literal">p2</code> は失敗します。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="stored-objects-security-orphan-objects"></a>孤立したストアドオブジェクト</h3></div></div></div><a class="indexterm" name="idm46065427892048"></a><a class="indexterm" name="idm46065427889920"></a><a class="indexterm" name="idm46065427888512"></a><a class="indexterm" name="idm46065427886400"></a><p>
        孤立したストアドオブジェクトは、その <code class="literal">DEFINER</code> 属性が存在しないアカウントを指定するオブジェクトです:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            孤立したストアドオブジェクトは、オブジェクトの作成時に存在しない <code class="literal">DEFINER</code> アカウントを指定することで作成できます。
          </p></li><li class="listitem"><p>
            既存のストアドオブジェクトは、オブジェクトの <code class="literal">DEFINER</code> アカウントを削除する <code class="literal">DROP USER</code> ステートメント、またはオブジェクトの <code class="literal">DEFINER</code> アカウントの名前を変更する <code class="literal">RENAME USER</code> ステートメントの実行によって孤立する可能性があります。
          </p></li></ul></div><p>
        孤立したストアドオブジェクトには、次のような問題がある可能性があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">DEFINER</code> アカウントが存在しないため、定義者セキュリティコンテキストで実行される場合、オブジェクトは予想どおりに動作しない可能性があります:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                ストアドルーチンの場合、<code class="literal">SQL SECURITY</code> 値が <code class="literal">DEFINER</code> で定義者アカウントが存在しないと、ルーチンの実行時にエラーが発生します。
              </p></li><li class="listitem"><p>
                トリガーの場合、アカウントが実際に存在するまでトリガーのアクティブ化を行うことはお薦めしません。 それ以外の権限確認に関する動作は定義されていません。 
              </p></li><li class="listitem"><p>
                イベントの場合、アカウントが存在しないと、イベントの実行時にエラーが発生します。
              </p></li><li class="listitem"><p>
                ビューでは、<code class="literal">SQL SECURITY</code> 値が <code class="literal">DEFINER</code> で定義者アカウントが存在しない場合にビューが参照されると、エラーが発生します。
              </p></li></ul></div></li><li class="listitem"><p>
            その後、オブジェクトに関連しない目的で存在しない <code class="literal">DEFINER</code> アカウントが再作成されると、オブジェクトにセキュリティリスクが生じる可能性があります。 この場合、オブジェクトと適切な権限を持つアカウント<span class="quote">「<span class="quote">「採用」</span>」</span>は、意図していない場合でもオブジェクトを実行できます。 
          </p></li></ul></div><p>
        MySQL 8.0.22 の時点では、サーバーは、(おそらく誤って) 格納されたオブジェクトが孤立したり、現在孤立している格納されたオブジェクトを採用する原因となる操作を防ぐために設計された追加のアカウント管理セキュリティチェックを強制します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            削除するアカウントが格納されたオブジェクトの <code class="literal">DEFINER</code> 属性として指定されている場合、<code class="literal">DROP USER</code> はエラーで失敗します。 (つまり、アカウントを削除すると、格納されたオブジェクトが孤立する場合、ステートメントは失敗します。) 
          </p></li><li class="listitem"><p>
            名前を変更するアカウントが格納されているオブジェクトの <code class="literal">DEFINER</code> 属性として指定されている場合、<code class="literal">RENAME USER</code> はエラーで失敗します。 (つまり、アカウントの名前を変更すると、格納されているオブジェクトが孤立する場合、ステートメントは失敗します。) 
          </p></li><li class="listitem"><p>
            作成するアカウントの名前が格納されたオブジェクトの <code class="literal">DEFINER</code> 属性として指定されている場合、<code class="literal">CREATE USER</code> はエラーで失敗します。 (つまり、アカウントを作成すると、アカウントが現在孤立しているストアドオブジェクトを採用する場合、ステートメントは失敗します。) 
          </p></li></ul></div><p>
        特定の状況では、これらのアカウント管理ステートメントは、それ以外の場合でも意図せずに実行する必要がある場合があります。 これを可能にするために、ユーザーが <code class="literal">SET_USER_ID</code> 権限を持っている場合、その権限は孤立したオブジェクトセキュリティチェックをオーバーライドし、ステートメントはエラーで失敗するのではなく警告で成功します。 
      </p><p>
        MySQL インストールでストアドオブジェクト定義者として使用されるアカウントに関する情報を取得するには、<code class="literal">INFORMATION_SCHEMA</code> にクエリーします。
      </p><p>
        このクエリーは、<code class="literal">DEFINER</code> 属性を持つオブジェクトを記述する <code class="literal">INFORMATION_SCHEMA</code> テーブルを識別します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_SCHEMA, TABLE_NAME FROM INFORMATION_SCHEMA.COLUMNS</code></strong>
       <strong class="userinput"><code>WHERE COLUMN_NAME = 'DEFINER';</code></strong>
+--------------------+------------+
| TABLE_SCHEMA       | TABLE_NAME |
+--------------------+------------+
| information_schema | EVENTS     |
| information_schema | ROUTINES   |
| information_schema | TRIGGERS   |
| information_schema | VIEWS      |
+--------------------+------------+
</pre><p>
        結果には、どのテーブルをクエリーして、どのストアドオブジェクト <code class="literal">DEFINER</code> 値が存在するか、およびどのオブジェクトが特定の <code class="literal">DEFINER</code> 値を持つかが示されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            各テーブルに存在する <code class="literal">DEFINER</code> 値を識別するには、次のクエリーを使用します:
          </p><pre class="programlisting">SELECT DISTINCT DEFINER FROM INFORMATION_SCHEMA.EVENTS;
SELECT DISTINCT DEFINER FROM INFORMATION_SCHEMA.ROUTINES;
SELECT DISTINCT DEFINER FROM INFORMATION_SCHEMA.TRIGGERS;
SELECT DISTINCT DEFINER FROM INFORMATION_SCHEMA.VIEWS;
</pre><p>
            クエリー結果は、次のように表示されるすべてのアカウントにとって重要です:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                アカウントが存在する場合、アカウントを削除または名前変更すると、格納されているオブジェクトが孤立します。 アカウントを削除または名前変更する場合は、まず、関連付けられているストアドオブジェクトを削除するか、別の定義者を持つように再定義することを検討してください。 
              </p></li><li class="listitem"><p>
                アカウントが存在しない場合は作成すると、現在孤立している格納済オブジェクトが採用されます。 アカウントを作成する場合は、孤立したオブジェクトを関連付けるかどうかを検討してください。 そうでない場合は、別の定義者を持つように再定義します。 
              </p></li></ul></div><p>
            別の定義者でオブジェクトを再定義するには、<code class="literal">ALTER EVENT</code> または <code class="literal">ALTER VIEW</code> を使用して、イベントおよびビューの <code class="literal">DEFINER</code> アカウントを直接変更できます。 ストアドプロシージャとストアドファンクションおよびトリガーの場合は、オブジェクトを削除して再作成し、別の <code class="literal">DEFINER</code> アカウントを割り当てる必要があります 
          </p></li><li class="listitem"><p>
            特定の <code class="literal">DEFINER</code> アカウントを持つオブジェクトを識別するには、次のクエリーを使用して、対象のアカウントを <code class="literal"><em class="replaceable"><code>user_name</code></em>@<em class="replaceable"><code>host_name</code></em></code> に置き換えます:
          </p><pre class="programlisting">SELECT EVENT_SCHEMA, EVENT_NAME FROM INFORMATION_SCHEMA.EVENTS
WHERE DEFINER = '<em class="replaceable"><code>user_name</code></em>@<em class="replaceable"><code>host_name</code></em>';
SELECT ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE
FROM INFORMATION_SCHEMA.ROUTINES
WHERE DEFINER = '<em class="replaceable"><code>user_name</code></em>@<em class="replaceable"><code>host_name</code></em>';
SELECT TRIGGER_SCHEMA, TRIGGER_NAME FROM INFORMATION_SCHEMA.TRIGGERS
WHERE DEFINER = '<em class="replaceable"><code>user_name</code></em>@<em class="replaceable"><code>host_name</code></em>';
SELECT TABLE_SCHEMA, TABLE_NAME FROM INFORMATION_SCHEMA.VIEWS
WHERE DEFINER = '<em class="replaceable"><code>user_name</code></em>@<em class="replaceable"><code>host_name</code></em>';
</pre><p>
            <code class="literal">ROUTINES</code> テーブルの場合、クエリーには <code class="literal">ROUTINE_TYPE</code> カラムが含まれるため、出力行は <code class="literal">DEFINER</code> がストアドプロシージャ用かストアドファンクション用かを区別します。
          </p><p>
            検索するアカウントが存在しない場合、それらのクエリーによって表示されるオブジェクトは孤立したオブジェクトです。
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="stored-objects-security-guidelines"></a>リスク最小化のガイドライン</h3></div></div></div><p>
        ストアドオブジェクトの作成および使用のリスクを最小限に抑えるには、次のガイドラインに従います:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            孤立したストアドオブジェクト (<code class="literal">DEFINER</code> 属性が存在しないアカウントを指定するオブジェクト) は作成しないでください。 既存のオブジェクトの <code class="literal">DEFINER</code> 属性で指定されたアカウントを削除または名前変更して、格納されたオブジェクトを孤立させないでください。 
          </p></li><li class="listitem"><p>
            可能な場合は、ストアドルーチンまたはビューに対して、オブジェクト定義の <code class="literal">SQL SECURITY INVOKER</code> を使用して、オブジェクトが実行する操作に適したアクセス許可を持つユーザーだけが使用できるようにします。
          </p></li><li class="listitem"><p>
            <code class="literal">SET_USER_ID</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) を持つアカウントの使用中に定義者コンテキストストアドオブジェクトを作成する場合は、オブジェクトで実行される操作に必要な権限のみを持つアカウントを指定する明示的な <code class="literal">DEFINER</code> 属性を指定します。 高い権限を持つ <code class="literal">DEFINER</code> アカウントは、絶対に必要な場合にのみ指定してください。 
          </p></li><li class="listitem"><p>
            管理者は、<code class="literal">SET_USER_ID</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) を付与しないことで、高い権限を持つ <code class="literal">DEFINER</code> アカウントを指定するストアドオブジェクトをユーザーが作成できないようにできます。
          </p></li><li class="listitem"><p>
            定義側のコンテキストのオブジェクトを作成するときには、呼び出し元ユーザーに権限のないデータに定義側がアクセスできる場合があります。 場合によっては、権限のないユーザーに特定の権限を付与しないことで、これらのオブジェクトへの参照を防止できます: 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                ストアドルーチンに対する <code class="literal">EXECUTE</code> 権限を持たないユーザーは、ストアドルーチンを参照できません。
              </p></li><li class="listitem"><p>
                ビューに対する適切な権限 (ビューから選択するための <code class="literal">SELECT</code>、ビューに挿入するための <code class="literal">INSERT</code> など) を持っていないユーザーは、ビューを参照できません。
              </p></li></ul></div><p>
            ただし、トリガーおよびイベントは常に定義者コンテキストで実行されるため、これらのコントロールは存在しません。 サーバーは必要に応じてこれらのオブジェクトを自動的に呼び出し、ユーザーはこれらを直接参照しません: 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                トリガーは、トリガーが関連付けられているテーブルへのアクセスによってアクティブ化されます。特別な権限を持たないユーザーによる通常のテーブルアクセスでもアクティブ化されます。
              </p></li><li class="listitem"><p>
                イベントは、スケジュールに基づいてサーバーによって実行されます。
              </p></li></ul></div><p>
            どちらの場合も、<code class="literal">DEFINER</code> アカウントが高い権限を持つ場合、オブジェクトは機密操作または危険な操作を実行できる可能性があります。 これは、オブジェクトの作成に必要な権限が、そのオブジェクトを作成したユーザーのアカウントから取り消された場合も当てはまります。 管理者は、特にユーザーへのオブジェクト作成権限の付与に注意する必要があります。 
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="stored-programs-logging"></a>25.7 ストアドプログラムバイナリロギング</h2></div></div></div><p>
      バイナリログには、データベースの内容を変更する SQL ステートメントに関する情報が含まれます。 この情報は、変更について記述した<span class="quote">「<span class="quote">イベント</span>」</span>の形式で格納されます。 (バイナリログイベントは、スケジュールされたイベントストアドオブジェクトとは異なります。) バイナリログには 2 つの重要な目的があります。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          レプリケーションの場合、バイナリログは、レプリカサーバーに送信されるステートメントのレコードとしてソースレプリケーションサーバーで使用されます。 ソースは、バイナリログに含まれているイベントをそのレプリカに送信します。このレプリカは、それらのイベントを実行して、ソースで行われたものと同じデータ変更を行います。 <a class="xref" href="replication.html#replication-implementation" title="17.2 レプリケーションの実装">セクション17.2「レプリケーションの実装」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          ある特定のデータリカバリ操作には、バイナリログの使用が必要です。 バックアップファイルがリストアされたあと、バックアップの作成後に記録されたバイナリログ内のイベントが、再度実行されます。 これらのイベントは、データベースをバックアップのポイントから最新の状態に持って行きます。 <a class="xref" href="backup-and-recovery.html#recovery-from-backups" title="7.3.2 リカバリへのバックアップの使用">セクション7.3.2「リカバリへのバックアップの使用」</a>を参照してください。 
        </p></li></ul></div><p>
      ただし、ステートメントレベルでロギングが発生した場合は、ストアドプログラム (ストアドプロシージャーとストアドファンクション、トリガー、およびイベント) に関する特定のバイナリロギングの問題があります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          場合によっては、ステートメントがソースとレプリカの異なる行セットに影響することがあります。
        </p></li><li class="listitem"><p>
          レプリカで実行されるレプリケートされたステートメントは、完全な権限を持つレプリカ SQL スレッドによって処理されます。 プロシージャは、ソースサーバーとレプリカサーバーで異なる実行パスに従うことができるため、ユーザーは、完全な権限を持つスレッドによって処理されるレプリカでのみ実行される危険なステートメントを含むルーチンを記述できます。 
        </p></li><li class="listitem"><p>
          データを変更するストアドプログラムが非決定的である場合、再現可能ではありません。 これにより、ソースとレプリカでデータが異なる場合や、リストアされたデータが元のデータと異なる場合があります。 
        </p></li></ul></div><p>
      このセクションでは、MySQL がストアドプログラムのバイナリロギングを処理する方法について説明します。 これは、実装がストアドプログラムの使用に適用する現在の状態と、ロギングの問題を回避するために実行できることを示します。 また、これらの条件の理由に関する追加情報も示します。 
    </p><p>
      一般に、ここで説明する問題は、バイナリロギングが SQL ステートメントレベル (ステートメントベースのバイナリロギング) で発生した場合に発生します。 行ベースのバイナリロギングを使用する場合、ログには、SQL ステートメントを実行した結果として個々の行に行われた変更が含まれます。 ルーチンまたはトリガーが実行されると、行の変更が記録されますが、変更を行なったステートメントは記録されません。 ストアドプロシージャーの場合、これは <code class="literal">CALL</code> ステートメントが記録されないことを意味します。 ストアドファンクションの場合、関数内で行われた行の変更が記録され、関数呼び出しは記録されません。 トリガーの場合、トリガーによって行われた行の変更が記録されます。 レプリカ側では、行の変更のみが表示され、ストアドプログラムの起動は表示されません。 
    </p><p>
      混合形式のバイナリロギング (<code class="literal">binlog_format=MIXED</code>) では、ステートメントベースのバイナリロギングが使用されますが、行ベースのバイナリロギングのみが正しい結果になることが保証されている場合を除きます。 混合形式では、ストアドファンクション、ストアドプロシージャー、トリガー、イベント、またはプリペアドステートメントにステートメントベースのバイナリロギングに安全でないものが含まれている場合、ステートメント全体が安全でないとマークされ、行形式で記録されます。 プロシージャ、関数、トリガーおよびイベントの作成および削除に使用されるステートメントは、常に安全であり、ステートメントの形式で記録されます。 行ベース、混合およびステートメントベースのロギング、および安全なステートメントと安全でないステートメントの決定方法の詳細は、<a class="xref" href="replication.html#replication-formats" title="17.2.1 レプリケーション形式">セクション17.2.1「レプリケーション形式」</a> を参照してください。 
    </p><p>
      特に明記されていないかぎり、ここでの備考は、バイナリロギングがサーバーで有効になっていることを前提としています (<a class="xref" href="server-administration.html#binary-log" title="5.4.4 バイナリログ">セクション5.4.4「バイナリログ」</a> を参照)。) バイナリログが有効でない場合、レプリケーションは可能でなく、バイナリログをデータリカバリに利用することもできません。 
    </p><p>
      MySQL でストアドファンクションを使用する場合の条件は、次のとおりです。 これらの条件は、ストアドプロシージャーまたはイベントスケジューラのイベントには適用されず、バイナリロギングが有効でないかぎり適用されません。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ストアドファンクションを作成または変更するには、通常必要な <code class="literal">CREATE ROUTINE</code> または <code class="literal">ALTER ROUTINE</code> 権限に加えて、<code class="literal">SET_USER_ID</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。 (関数定義の <code class="literal">DEFINER</code> 値によっては、バイナリロギングが有効になっているかどうかに関係なく、<code class="literal">SET_USER_ID</code> または <code class="literal">SUPER</code> が必要になる場合があります。 <a class="xref" href="sql-statements.html#create-procedure" title="13.1.17 CREATE PROCEDURE ステートメントおよび CREATE FUNCTION ステートメント">セクション13.1.17「CREATE PROCEDURE ステートメントおよび CREATE FUNCTION ステートメント」</a>を参照してください。) 
        </p></li><li class="listitem"><p>
          ストアドファンクションを作成するとき、その関数が決定的であるということ、またはデータを変更しないということを宣言する必要があります。 そのようにしないと、データリカバリまたレプリケーションにとって安全でなくなる可能性があります。 
        </p><p>
          デフォルトでは、<code class="literal">CREATE FUNCTION</code> ステートメントを受け入れるには、<code class="literal">DETERMINISTIC</code>、<code class="literal">NO SQL</code>、または <code class="literal">READS SQL DATA</code> の少なくとも 1 つを明示的に指定する必要があります。 そうでない場合はエラーが発生します。 
        </p><pre class="programlisting">ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL,
or READS SQL DATA in its declaration and binary logging is enabled
(you *might* want to use the less safe log_bin_trust_function_creators
variable)
</pre><p>
          次の関数は決定的なため (また、データを変更しません)、安全です。
        </p><pre class="programlisting">CREATE FUNCTION f1(i INT)
RETURNS INT
DETERMINISTIC
READS SQL DATA
BEGIN
  RETURN i;
END;
</pre><p>
          次の関数は <code class="literal">UUID()</code> を使用しますが、これは決定的でないため、関数も決定的でなく、安全ではありません。
        </p><pre class="programlisting">CREATE FUNCTION f2()
RETURNS CHAR(36) CHARACTER SET utf8
BEGIN
  RETURN UUID();
END;
</pre><p>
          次の関数はデータを変更するので、安全ではない可能性があります。
        </p><pre class="programlisting">CREATE FUNCTION f3(p_id INT)
RETURNS INT
BEGIN
  UPDATE t SET modtime = NOW() WHERE id = p_id;
  RETURN ROW_COUNT();
END;
</pre><p>
          関数の性質の評価は、作成者の<span class="quote">「<span class="quote">「正直」</span>」</span>に基づきます。 MySQL では、<code class="literal">DETERMINISTIC</code> と宣言された関数が、非決定的な結果を生成するステートメントを持たないかどうかはチェックされません。 
        </p></li><li class="listitem"><p>
          ストアドファンクションを実行しようとするときに、<code class="literal">binlog_format=STATEMENT</code> が設定されている場合は、関数定義に <code class="literal">DETERMINISTIC</code> キーワードを指定する必要があります。 そうでない場合は、このチェックをオーバーライドするように <code class="literal">log_bin_trust_function_creators=1</code> が指定されていないかぎり、エラーが生成され、関数は実行されません (次を参照)。 再帰的関数コールの場合、<code class="literal">DETERMINISTIC</code> キーワードは最も外側のコールでのみ必要です。 行ベースまたは混合バイナリロギングが使用されている場合、関数が <code class="literal">DETERMINISTIC</code> キーワードなしで定義されていても、ステートメントは受け入れられ、レプリケートされます。 
        </p></li><li class="listitem"><p>
          MySQL では、関数が作成時に実際に決定的かどうかはチェックされないため、<code class="literal">DETERMINISTIC</code> キーワードを使用してストアドファンクションを起動すると、ステートメントベースのロギングに対して安全でないアクションが実行されたり、安全でないステートメントを含むファンクションまたはプロシージャが起動される可能性があります。 これが <code class="literal">binlog_format=STATEMENT</code> の設定時に発生した場合は、警告メッセージが発行されます。 行ベースまたは混合バイナリロギングが使用されている場合、警告は発行されず、ステートメントは行ベースの形式でレプリケートされます。 
        </p></li><li class="listitem"><p>
          関数作成に関する前述の条件 (<code class="literal">SUPER</code> 権限を持つ必要があることと、関数が決定的であるか、データを変更しないと宣言する必要があること) を緩和するには、<code class="literal">log_bin_trust_function_creators</code> グローバルシステム変数を 1 に設定します。 デフォルトでこの変数には 0 の値が設定されていますが、次のように変更できます。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL log_bin_trust_function_creators = 1;</code></strong>
</pre><p>
          この変数は、サーバー起動時に設定することもできます。
        </p><p>
          バイナリロギングが有効でない場合、<code class="literal">log_bin_trust_function_creators</code> は適用されません。 前述のように、関数定義の <code class="literal">DEFINER</code> 値が必要としないかぎり、関数の作成に <code class="literal">SUPER</code> は必要ありません。 
        </p></li><li class="listitem"><p>
          レプリケーションで安全ではない可能性のある (そのため、これらを使用するストアドファンクションも安全でなくなります) 組み込み関数の詳細は、<a class="xref" href="replication.html#replication-features" title="17.5.1 レプリケーションの機能と問題">セクション17.5.1「レプリケーションの機能と問題」</a>を参照してください。
        </p></li></ul></div><p>
      トリガーは、ストアドファンクションと似ているので、関数に関する前述の説明がトリガーにも当てはまりますが、<code class="literal">CREATE TRIGGER</code> にはオプションの <code class="literal">DETERMINISTIC</code> 特性がないため、トリガーは常に決定的であると想定されるという点が異なります。 ただし、場合によっては、この仮定が無効になることがあります。 たとえば、<code class="literal">UUID()</code> 関数は非決定的です (また、複製しません)。 トリガーでのこのような関数の使用には注意してください。 
    </p><p>
      トリガーはテーブルを更新できるので、必要な権限がない場合には、<code class="literal">CREATE TRIGGER</code> で、ストアドファンクションの場合と同様のエラーメッセージが表示されます。 レプリカ側では、レプリカはトリガー <code class="literal">DEFINER</code> 属性を使用して、トリガーの作成者とみなされるユーザーを決定します。 
    </p><p>
      このセクションの残りの部分では、ロギングの実装とその意味に関する追加詳細について説明します。 ストアドルーチンの使用に関する現在のロギング関連の条件の理論的根拠についての背景に関心がある場合には、こちらをお読みください。 この説明はステートメントベースのロギングにのみ該当し、行ベースのロギングには該当しませんが、<code class="literal">CREATE</code> および <code class="literal">DROP</code> ステートメントは、ロギングモードとは無関係にステートメントとして記録されるという最初の項目は除きます。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          サーバーは、<code class="literal">CREATE EVENT</code>、<code class="literal">CREATE PROCEDURE</code>、<code class="literal">CREATE FUNCTION</code>、<code class="literal">ALTER EVENT</code>、<code class="literal">ALTER PROCEDURE</code>、<code class="literal">ALTER FUNCTION</code>、<code class="literal">DROP EVENT</code>、<code class="literal">DROP PROCEDURE</code>、および <code class="literal">DROP FUNCTION</code> ステートメントをバイナリログに書き込みます。
        </p></li><li class="listitem"><p>
          ストアドファンクションの呼び出しは、この関数がデータを変更し、それ以外では記録されないようなステートメント内で行われた場合に、<code class="literal">SELECT</code> ステートメントとして記録されます。 これにより、記録されないステートメントでストアドファンクションを使用した結果生じたデータの変更をレプリケーションできなくなるという事態が防止されます。 たとえば、<code class="literal">SELECT</code> ステートメントはバイナリログに書き込まれませんが、<code class="literal">SELECT</code> は、変更を行うストアドファンクションを呼び出す場合があります。 これを扱うため、<code class="literal">SELECT <em class="replaceable"><code>func_name</code></em>()</code> ステートメントは、指定した関数が変更を行うときにバイナリログに書き込まれます。 次のステートメントがソースサーバーで実行されるとします: 
        </p><pre class="programlisting">CREATE FUNCTION f1(a INT) RETURNS INT
BEGIN
  IF (a &lt; 3) THEN
    INSERT INTO t2 VALUES (a);
  END IF;
  RETURN 0;
END;

CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1),(2),(3);

SELECT f1(a) FROM t1;
</pre><p>
          <code class="literal">SELECT</code> ステートメントが実行されると、関数 <code class="literal">f1()</code> は 3 回呼び出されます。 このうち 2 回の呼び出しで行を挿入し、MySQL は各行に対し <code class="literal">SELECT</code> ステートメントを記録します。 つまり、MySQL は次のステートメントをバイナリログに書き込みます。 
        </p><pre class="programlisting">SELECT f1(1);
SELECT f1(2);
</pre><p>
          サーバーは、エラーを発生させるストアドプロシージャーをストアドファンクションが呼び出すときに、そのストアドファンクションの呼び出しに対する <code class="literal">SELECT</code> ステートメントも記録します。 この場合、サーバーは、予想されるエラーコードとともに、<code class="literal">SELECT</code> ステートメントをログに書き込みます。 レプリカで同じエラーが発生した場合は、予想される結果となり、レプリケーションが続行されます。 それ以外の場合は、レプリケーションは停止します。 
        </p></li><li class="listitem"><p>
          関数によって実行されるステートメントではなく、ストアドファンクションの呼び出しのロギングは、レプリケーションでは、次の 2 つの要因から生じるセキュリティー上の意味があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              関数は、ソースサーバーとレプリカサーバーで異なる実行パスに従うことができます。
            </p></li><li class="listitem"><p>
              レプリカで実行されるステートメントは、完全な権限を持つレプリカ SQL スレッドによって処理されます。
            </p></li></ul></div><p>
          つまり、ユーザーは関数を作成するために <code class="literal">CREATE ROUTINE</code> 権限を持っている必要がありますが、完全な権限を持つスレッドによって処理されるレプリカに対してのみ実行される危険なステートメントを含む関数を記述できます。 たとえば、ソースサーバーとレプリカサーバーのサーバー ID 値がそれぞれ 1 と 2 の場合、ソースサーバー上のユーザーは、次のように安全でない関数 <code class="literal">unsafe_func()</code> を作成して起動できます: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>delimiter //</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE FUNCTION unsafe_func () RETURNS INT</code></strong>
    -&gt; <strong class="userinput"><code>BEGIN</code></strong>
    -&gt;   <strong class="userinput"><code>IF @@server_id=2 THEN <em class="replaceable"><code>dangerous_statement</code></em>; END IF;</code></strong>
    -&gt;   <strong class="userinput"><code>RETURN 1;</code></strong>
    -&gt; <strong class="userinput"><code>END;</code></strong>
    -&gt; <strong class="userinput"><code>//</code></strong>
mysql&gt; <strong class="userinput"><code>delimiter ;</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t VALUES(unsafe_func());</code></strong>
</pre><p>
          <code class="literal">CREATE FUNCTION</code> および <code class="literal">INSERT</code> ステートメントはバイナリログに書き込まれるため、レプリカはそれらを実行します。 レプリカ SQL スレッドには完全な権限があるため、危険なステートメントが実行されます。 したがって、関数の呼出しはソースとレプリカに異なる影響を与えるため、レプリケーションに対して安全ではありません。 
        </p><p>
          バイナリロギングを有効にしているサーバーに対するこの危険から保護するために、ストアドファンクションの作成者は、必要な通常の <code class="literal">CREATE ROUTINE</code> 権限に加え、<code class="literal">SUPER</code> 権限も持つ必要があります。 同様に、<code class="literal">ALTER FUNCTION</code> を使用するには、ユーザーは <code class="literal">ALTER ROUTINE</code> 権限に加え、<code class="literal">SUPER</code> 権限を持つ必要があります。 <code class="literal">SUPER</code> 権限がない場合は、次のエラーが発生します: 
        </p><pre class="programlisting">ERROR 1419 (HY000): You do not have the SUPER privilege and
binary logging is enabled (you *might* want to use the less safe
log_bin_trust_function_creators variable)
</pre><p>
          関数作成者が <code class="literal">SUPER</code> 権限を持つよう要求しない場合 (たとえば、システム上の <code class="literal">CREATE ROUTINE</code> 権限を持つすべてのユーザーが経験豊かなアプリケーション開発者である場合)、<code class="literal">log_bin_trust_function_creators</code> グローバルシステム変数を 1 に設定します。 この変数は、サーバー起動時に設定することもできます。 バイナリロギングが有効でない場合、<code class="literal">log_bin_trust_function_creators</code> は適用されません。 前述のように、関数定義の <code class="literal">DEFINER</code> 値が必要としないかぎり、関数の作成に <code class="literal">SUPER</code> は必要ありません。 
        </p></li><li class="listitem"><p>
          更新を実行する関数が非決定的である場合、再現可能ではありません。 これは次の 2 つの望ましくない影響を及ぼす可能性があります。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              これにより、レプリカがソースと異なります。
            </p></li><li class="listitem"><p>
              リストアされたデータが元のデータと一致しません。
            </p></li></ul></div><p>
          これらの問題に対処するために、MySQL では次の要件が適用されます: ソースサーバーでは、関数を決定的に宣言するか、データを変更しない場合を除き、関数の作成および変更は拒否されます。 ここでは次の 2 つの関数特性セットが適用されます。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">DETERMINISTIC</code> 特性と <code class="literal">NOT DETERMINISTIC</code> 特性は、関数が一定の入力に対して常に同じ結果を生成するかどうかを示します。 どちらの特性も指定されていない場合は、デフォルトは <code class="literal">NOT DETERMINISTIC</code> です。 関数が決定的であることを宣言するには、明示的に <code class="literal">DETERMINISTIC</code> を指定する必要があります。 
            </p></li><li class="listitem"><p>
              <code class="literal">CONTAINS SQL</code>、<code class="literal">NO SQL</code>、<code class="literal">READS SQL DATA</code>、および <code class="literal">MODIFIES SQL DATA</code> 特性は、関数がデータを読み取るか書き込むかに関する情報を示します。 <code class="literal">NO SQL</code> または <code class="literal">READS SQL DATA</code> は、関数がデータを変更しないことを示しますが、特性が指定されていない場合にデフォルトは <code class="literal">CONTAINS SQL</code> になるので、これらのどちらかを明示的に指定する必要があります。 
            </p></li></ul></div><p>
          デフォルトでは、<code class="literal">CREATE FUNCTION</code> ステートメントを受け入れるには、<code class="literal">DETERMINISTIC</code>、<code class="literal">NO SQL</code>、または <code class="literal">READS SQL DATA</code> の少なくとも 1 つを明示的に指定する必要があります。 そうでない場合はエラーが発生します。 
        </p><pre class="programlisting">ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL,
or READS SQL DATA in its declaration and binary logging is enabled
(you *might* want to use the less safe log_bin_trust_function_creators
variable)
</pre><p>
          <code class="literal">log_bin_trust_function_creators</code> を 1 に設定した場合、関数が決定的であるか、データを変更しないという要件は破棄されます。
        </p></li><li class="listitem"><p>
          ストアドプロシージャーの呼び出しは <code class="literal">CALL</code> レベルでなく、ステートメントレベルで記録されます。 つまり、サーバーは、<code class="literal">CALL</code> ステートメントを記録せず、実際に実行するプロシージャー内のステートメントを記録します。 その結果、ソースサーバーで発生するのと同じ変更がレプリカでも発生します。 これにより、別々のマシン上で異なる実行パスを持つプロシージャーから生じる問題が防止されます。 
        </p><p>
          一般に、ストアドプロシージャー内で実行されるステートメントは、スタンドアロンでステートメントを実行した場合に適用されるものと同じルールを使用して、バイナリログに書き込まれます。 プロシージャー内でのステートメントの実行は、非プロシージャーのコンテキストとまったく同じにはならないので、プロシージャーステートメントのロギング時には、十分に注意してください。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <a class="indexterm" name="idm46065427619424"></a> 記録されるステートメントには、ローカルプロシージャー変数への参照が含まれる場合があります。 これらの変数は、ストアドプロシージャーのコンテキスト外に存在しないので、このような変数を参照するステートメントは、文字どおりには記録できません。 代わりに、ローカル変数のそれぞれの参照は、ロギングのために次の構造構文に置き換えられます。 
            </p><pre class="programlisting">NAME_CONST(<em class="replaceable"><code>var_name</code></em>, <em class="replaceable"><code>var_value</code></em>)
</pre><p>
              <em class="replaceable"><code>var_name</code></em> はローカル変数名であり、<em class="replaceable"><code>var_value</code></em> は、ステートメントの記録時に変数に含まれていた値を示す定数です。 <code class="literal">NAME_CONST()</code> には <em class="replaceable"><code>var_value</code></em> の値と <em class="replaceable"><code>var_name</code></em> の<span class="quote">「<span class="quote">名前</span>」</span>が含まれます。 したがって、この関数を直接呼び出した場合、次のような結果が得られます。 
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT NAME_CONST('myname', 14);</code></strong>
+--------+
| myname |
+--------+
|     14 |
+--------+
</pre><p>
              <code class="literal">NAME_CONST()</code> では、ログに記録されたスタンドアロンステートメントを、ストアドプロシージャ内のソースで実行された元のステートメントと同じ効果でレプリカで実行できます。
            </p><p>
              <code class="literal">NAME_CONST()</code> を使用した結果、ソースカラム式がローカル変数を参照するときに、<code class="literal">CREATE TABLE ... SELECT</code> ステートメントの問題が生じる場合があります。 これらの参照を <code class="literal">NAME_CONST()</code> 式に変換すると、ソースサーバーとレプリカサーバーで異なるカラム名、または名前が長すぎて有効なカラム識別子にならない場合があります。 回避策では、ローカル変数を参照するカラムのエイリアスを指定します。 <code class="literal">myvar</code> の値が 1 の場合は次のステートメントを検討してください。 
            </p><pre class="programlisting">CREATE TABLE t1 SELECT myvar;
</pre><p>
              これは次のように書き換えられます:
            </p><pre class="programlisting">CREATE TABLE t1 SELECT NAME_CONST(myvar, 1);
</pre><p>
              ソーステーブルとレプリカテーブルのカラム名が同じであることを確認するには、次のようなステートメントを記述します:
            </p><pre class="programlisting">CREATE TABLE t1 SELECT myvar AS myvar;
</pre><p>
              書き換えられたステートメントは次のようになります。
            </p><pre class="programlisting">CREATE TABLE t1 SELECT NAME_CONST(myvar, 1) AS myvar;
</pre></li><li class="listitem"><p>
              記録されるステートメントには、ユーザー定義変数への参照が含まれる場合があります。 これを処理するために、MySQL はバイナリログに <code class="literal">SET</code> ステートメントを書き込み、ソースと同じ値を持つ変数がレプリカに存在することを確認します。 たとえば、ステートメントが変数<code class="literal">@my_var</code> を参照している場合、バイナリログ内でそのステートメントの前に次のステートメントが続きます。ここで、<em class="replaceable"><code>value</code></em> はソース上の<code class="literal">@my_var</code> の値です: 
            </p><pre class="programlisting">SET @my_var = <em class="replaceable"><code>value</code></em>;
</pre></li><li class="listitem"><p>
              プロシージャーの呼び出しは、コミットまたはロールバックしたトランザクション内で行えます。 プロシージャー実行のトランザクションの側面が正しく複製されるように、トランザクションのコンテキストが説明されます。 つまり、サーバーは、実際にデータを実行し修正するプロシージャー内のステートメントを記録し、<code class="literal">BEGIN</code>、<code class="literal">COMMIT</code>、および <code class="literal">ROLLBACK</code> ステートメントも必要に応じて記録します。 たとえば、プロシージャーがトランザクションテーブルだけを更新し、ロールバックされるトランザクション内で実行される場合、これらの更新は記録されません。 プロシージャーがコミットされたトランザクション内で行われた場合、<code class="literal">BEGIN</code> および <code class="literal">COMMIT</code> ステートメントが更新とともに記録されます。 ロールバックしたトランザクション内で実行するプロシージャーの場合、そのステートメントは、ステートメントがスタンドアロンで実行された場合に適用されるものと同じルールを使用して記録されます。 
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                  トランザクションテーブルに対する更新は記録されません。
                </p></li><li class="listitem"><p>
                  非トランザクションテーブルに対する更新は、ロールバックで取り消されないので、記録されます。
                </p></li><li class="listitem"><p>
                  トランザクションテーブルと非トランザクションテーブルの混在に対する更新は、レプリカがソースと同じ変更およびロールバックを行うように、<code class="literal">BEGIN</code> と <code class="literal">ROLLBACK</code> で囲まれて記録されます。
                </p></li></ul></div></li></ul></div></li><li class="listitem"><p>
          ストアドプロシージャーの呼び出しは、ストアドファンクション内から呼び出される場合、ステートメントレベルのバイナリログに書き込まれ<span class="emphasis"><em>ません</em></span>。 この場合、記録される唯一の対象は、関数を呼び出すステートメント (記録されたステートメント内で行われた場合) または <code class="literal">DO</code> ステートメント (記録されないステートメント内で行われた場合) です。 このため、それ以外の場合にプロシージャー自体が安全であっても、プロシージャーを呼び出すストアドファンクションを使用するときには注意を払う必要があります。 
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="stored-program-restrictions"></a>25.8 ストアドプログラムの制約</h2></div></div></div><a class="indexterm" name="idm46065427570672"></a><a class="indexterm" name="idm46065427568496"></a><a class="indexterm" name="idm46065427566432"></a><a class="indexterm" name="idm46065427564400"></a><a class="indexterm" name="idm46065427562368"></a><a class="indexterm" name="idm46065427560336"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="stored-objects.html#stored-routine-sql-restrictions" title="ストアドルーチンでは許可されていない SQL ステートメント">ストアドルーチンでは許可されていない SQL ステートメント</a></p></li><li class="listitem"><p><a class="xref" href="stored-objects.html#stored-routines-function-restrictions" title="ストアドファンクションの制約">ストアドファンクションの制約</a></p></li><li class="listitem"><p><a class="xref" href="stored-objects.html#stored-routines-trigger-restrictions" title="トリガーの制約">トリガーの制約</a></p></li><li class="listitem"><p><a class="xref" href="stored-objects.html#stored-routine-name-conflicts" title="ストアドルーチン内の名前競合">ストアドルーチン内の名前競合</a></p></li><li class="listitem"><p><a class="xref" href="stored-objects.html#stored-routines-replication-restrictions" title="レプリケーションに関する考慮事項">レプリケーションに関する考慮事項</a></p></li><li class="listitem"><p><a class="xref" href="stored-objects.html#stored-routines-debugging-restrictions" title="デバッグに関する考慮事項">デバッグに関する考慮事項</a></p></li><li class="listitem"><p><a class="xref" href="stored-objects.html#stored-routines-standard-restrictions" title="SQL:2003 標準のサポート外の構文">SQL:2003 標準のサポート外の構文</a></p></li><li class="listitem"><p><a class="xref" href="stored-objects.html#stored-routines-concurrency-restrictions" title="ストアドルーチンの同時実行性に関する考慮事項">ストアドルーチンの同時実行性に関する考慮事項</a></p></li><li class="listitem"><p><a class="xref" href="stored-objects.html#stored-routines-event-restrictions" title="イベントスケジューラの制約">イベントスケジューラの制約</a></p></li><li class="listitem"><p><a class="xref" href="stored-objects.html#stored-routines-ndbcluster" title="NDB Cluster 内のストアドルーチンとトリガー">NDB Cluster 内のストアドルーチンとトリガー</a></p></li></ul></div><p>
      これらの制約は、<a class="xref" href="stored-objects.html" title="第 25 章 ストアドオブジェクト">第25章「<i>ストアドオブジェクト</i>」</a>で説明している機能に適用されます。
    </p><p>
      ここに記載されている制約の中には、すべてのストアドルーチン、つまりストアドプロシージャーとストアドファンクションの両方に適用されるものがあります。 また、ストアドプロシージャーには適用されず、<a class="link" href="stored-objects.html#stored-routines-function-restrictions" title="ストアドファンクションの制約">ストアドファンクションに固有の制約</a>もいくつか存在します。 
    </p><p>
      ストアドファンクションの制約は、トリガーにも適用されます。 <a class="link" href="stored-objects.html#stored-routines-trigger-restrictions" title="トリガーの制約">トリガーに固有の制約</a>もいくつかあります。 
    </p><p>
      ストアドプロシージャーの制約は、イベントスケジューラのイベント定義の <code class="literal">DO</code> 句にも適用されます。 <a class="link" href="stored-objects.html#stored-routines-event-restrictions" title="イベントスケジューラの制約">イベントに固有の制約</a>もいくつかあります。 
    </p><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="stored-routine-sql-restrictions"></a>ストアドルーチンでは許可されていない SQL ステートメント</h3></div></div></div><p>
        ストアドルーチンには自由に SQL ステートメントを含めることはできません。 次のステートメントは許可されていません。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">LOCK TABLES</code> および <code class="literal">UNLOCK TABLES</code> のロックステートメント。
          </p></li><li class="listitem"><p>
            <code class="literal">ALTER VIEW</code>
          </p></li><li class="listitem"><p>
            <code class="literal">LOAD DATA</code>。
          </p></li><li class="listitem"><p>
            SQL 準備済みステートメント (<code class="literal">PREPARE</code>、<code class="literal">EXECUTE</code>、<code class="literal">DEALLOCATE PREPARE</code>) は、ストアドプロシージャーで使用できますが、ストアドファンクションやトリガーでは使用できません。 そのため、ストアドファンクションとトリガーは動的 SQL (この場合はステートメントを文字列として構築してから実行します) を使用できません。 
          </p></li><li class="listitem"><p>
            通常、SQL 準備済みステートメントで許可されていないステートメントは、ストアドプログラムでも許可されません。 準備済みステートメントとしてサポートされているステートメントのリストについては、<a class="xref" href="sql-statements.html#sql-prepared-statements" title="13.5 プリペアドステートメント">セクション13.5「プリペアドステートメント」</a>を参照してください。 例外は <code class="literal">SIGNAL</code>、<code class="literal">RESIGNAL</code>、および <code class="literal">GET DIAGNOSTICS</code> であり、これらは準備済みステートメントとして許可されていませんが、ストアドプログラムで許可されます。 
          </p></li><li class="listitem"><p>
            ローカル変数はストアドプログラムの実行中にのみスコープ内にあるので、これらの参照は、ストアドプログラム内で作成された準備済みステートメントでは許可されていません。 準備済みステートメントのスコープは現在のセッションであり、ストアドプログラムではないので、ステートメントはプログラムの終了後に実行でき、この時点で変数はスコープ内に存在しなくなります。 たとえば、<code class="literal">SELECT ... INTO <em class="replaceable"><code>local_var</code></em></code> は準備済みステートメントとして使用できません。 この制約は、ストアドプロシージャーおよびストアドファンクションのパラメータにも適用されます。 <a class="xref" href="sql-statements.html#prepare" title="13.5.1 PREPARE ステートメント">セクション13.5.1「PREPARE ステートメント」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            すべてのストアドプログラム (ストアドプロシージャーとストアドファンクション、トリガー、およびイベント) 内で、パーサーは、<code class="literal">BEGIN [WORK]</code> を <code class="literal">BEGIN ... END</code> ブロックの開始として扱います。 このコンテキストでトランザクションを開始するには、代わりに <code class="literal">START TRANSACTION</code> を使用します。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="stored-routines-function-restrictions"></a>ストアドファンクションの制約</h3></div></div></div><p>
        次の追加ステートメントまたは操作は、ストアドファンクション内で許可されていません。 これらはストアドプロシージャーで許可されていますが、ストアドファンクションまたはトリガー内から呼び出されるストアドプロシージャーを除きます。 たとえば、ストアドプロシージャーで <code class="literal">FLUSH</code> を使用する場合、ストアドファンクションまたはトリガーからそのストアドプロシージャーを呼び出すことはできません。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            明示的または暗黙的なコミットまたはロールバックを実行するステートメント。 これらのステートメントのサポートは、SQL 標準では必要ありません。SQL 標準では、各 DBMS ベンダーがこれらのステートメントを許可するかどうかを決められると定めています。 
          </p></li><li class="listitem"><p>
            結果セットを返すステートメント。 これには、<code class="literal">INTO <em class="replaceable"><code>var_list</code></em></code> 句を含まない <code class="literal">SELECT</code> ステートメントや、<code class="literal">SHOW</code>、<code class="literal">EXPLAIN</code>、および <code class="literal">CHECK TABLE</code> などのほかのステートメントも含まれます。 関数は、<code class="literal">SELECT ... INTO <em class="replaceable"><code>var_list</code></em></code> を使用するか、カーソルと <code class="literal">FETCH</code> ステートメントを使用すると、結果セットを処理できます。 <a class="xref" href="sql-statements.html#select-into" title="13.2.10.1 SELECT ... INTO ステートメント">セクション13.2.10.1「SELECT ... INTO ステートメント」</a>および<a class="xref" href="sql-statements.html#cursors" title="13.6.6 カーソル">セクション13.6.6「カーソル」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">FLUSH</code> ステートメント。
          </p></li><li class="listitem"><p>
            ストアドファンクションは再帰的に使用できません。
          </p></li><li class="listitem"><p>
            ストアドファンクションまたはトリガーは、そのストアドファンクションまたはトリガーを呼び出したステートメントによって (読み取りまたは書き込みに) すでに使用されているテーブルを変更できません。
          </p></li><li class="listitem"><p>
            ストアドファンクションで、一時テーブルを異なるエイリアスで複数回参照する場合、ストアドファンクション内の別々のステートメントで参照を行う場合でも、<code class="literal">「表を再オープンできません: '<em class="replaceable"><code>tbl_name</code></em><code class="literal"></code>'」</code> というエラーが発生します。
          </p></li><li class="listitem"><p>
            ストアドファンクションを呼び出す <code class="literal">HANDLER ... READ</code> ステートメントは、レプリケーションエラーを引き起こす可能性があり、許可されません。
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="stored-routines-trigger-restrictions"></a>トリガーの制約</h3></div></div></div><p>
        トリガーの場合、さらに次の制約が適用されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            トリガーは外部キーアクションでアクティブ化されません。
          </p></li><li class="listitem"><p>
            行ベースのレプリケーションを使用している場合、レプリカのトリガーは、ソースで発生したステートメントによってアクティブ化されません。 レプリカのトリガーは、ステートメントベースレプリケーションを使用している場合にアクティブになります。 詳細は、<a class="xref" href="replication.html#replication-features-triggers" title="17.5.1.36 レプリケーションとトリガー">セクション17.5.1.36「レプリケーションとトリガー」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">RETURN</code> ステートメントはトリガーでは許可されていません。トリガーは値を返すことができません。 すぐにトリガーを終了するには、<code class="literal">LEAVE</code> ステートメントを使用します。 
          </p></li><li class="listitem"><p>
            トリガーは、<code class="literal">mysql</code> データベース内のテーブルでは許可されていません。 <code class="literal">INFORMATION_SCHEMA</code> または <code class="literal">performance_schema</code> テーブルでも許可されていません。 これらのテーブルは実際にはビューであり、トリガーはビューでは許可されません。 
          </p></li><li class="listitem"><p>
            トリガーキャッシュは、ベースとなるオブジェクトのメタデータが変更された場合は検出しません。 トリガーがテーブルを使用し、トリガーがキャッシュにロードされたあとにそのテーブルに変更があった場合、トリガーは古いメタデータを使用して動作します。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="stored-routine-name-conflicts"></a>ストアドルーチン内の名前競合</h3></div></div></div><p>
        ルーチンパラメータ、ローカル変数、およびテーブルカラムに同じ識別子が使用される場合があります。 また、同じローカル変数名を、ネスト化されたブロックで使用することもできます。 例: 
      </p><pre class="programlisting">CREATE PROCEDURE p (i INT)
BEGIN
  DECLARE i INT DEFAULT 0;
  SELECT i FROM t;
  BEGIN
    DECLARE i INT DEFAULT 1;
    SELECT i FROM t;
  END;
END;
</pre><p>
        このような場合、識別子はあいまいになり、次の優先順位ルールが適用されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ローカル変数では、ルーチンパラメータやテーブルカラムが優先されます。
          </p></li><li class="listitem"><p>
            ルーチンパラメータでは、テーブルカラムが優先されます。
          </p></li><li class="listitem"><p>
            内部ブロック内のローカル変数では、外部ブロック内のローカル変数が優先されます。
          </p></li></ul></div><p>
        変数でテーブルカラムが優先される動作は、非標準です。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="stored-routines-replication-restrictions"></a>レプリケーションに関する考慮事項</h3></div></div></div><p>
        ストアドルーチンを使用すると、レプリケーションの問題が生じることがあります。 この問題については、<a class="xref" href="stored-objects.html#stored-programs-logging" title="25.7 ストアドプログラムバイナリロギング">セクション25.7「ストアドプログラムバイナリロギング」</a>で詳しく述べられています。 
      </p><p>
        <code class="option">--replicate-wild-do-table=<em class="replaceable"><code>db_name.tbl_name</code></em></code> オプションはテーブル、ビュー、およびトリガーに適用されます。 ストアドプロシージャーと関数、またはイベントには適用されません。 後者のオブジェクトで作用するステートメントをフィルタするには、1 つまたは複数の <code class="option">--replicate-*-db</code> オプションを使用します。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="stored-routines-debugging-restrictions"></a>デバッグに関する考慮事項</h3></div></div></div><p>
        ストアドルーチンのデバッグ機能は存在しません。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="stored-routines-standard-restrictions"></a>SQL:2003 標準のサポート外の構文</h3></div></div></div><p>
        MySQL ストアドルーチン構文は SQL:2003 標準に基づきます。 この標準の次の項目は現在サポートされていません。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">UNDO</code> ハンドラ
          </p></li><li class="listitem"><p>
            <code class="literal">FOR</code> ループ
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="stored-routines-concurrency-restrictions"></a>ストアドルーチンの同時実行性に関する考慮事項</h3></div></div></div><p>
        セッション間のやり取りの問題を防止するために、クライアントのステートメント発行時、サーバーではステートメントの実行に利用できるルーチンとトリガーのスナップショットが使用されます。 つまり、サーバーは、ステートメントの実行中に使用される可能性のあるプロシージャー、関数、およびトリガーのリストを算出してロードし、ステートメントの実行に進みます。 ステートメントの実行時は、ほかのセッションが実行するルーチンへの変更は認識されません。 
      </p><p>
        並列性を最大にするために、ストアドファンクションでは、その副作用を最小限に抑える必要があります。特に、ストアドファンクション内のテーブルを更新することにより、そのテーブルでの並列操作が減少することがあります。 ストアドファンクションは、実行前にテーブルロックを取得して、ステートメントが実行する順序とログに表示されるときの順序の不一致によるバイナリログの不整合を回避します。 ステートメントベースのバイナリロギングが使用される場合、関数内で実行されるステートメントではなく、関数を呼び出すステートメントが記録されます。 その結果、ベースとなる同じテーブルを更新するストアドファンクションは、並列で実行しません。 対照的に、ストアドプロシージャーはテーブルレベルのロックを取得しません。 ストアドプロシージャー内で実行されたすべてのステートメントは、ステートメントベースのバイナリロギングの場合でも、バイナリログに書き込まれます。 <a class="xref" href="stored-objects.html#stored-programs-logging" title="25.7 ストアドプログラムバイナリロギング">セクション25.7「ストアドプログラムバイナリロギング」</a>を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="stored-routines-event-restrictions"></a>イベントスケジューラの制約</h3></div></div></div><p>
        次の制限は、イベントスケジューラに固有のものです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            イベント名は大文字と小文字を区別せずに処理されます。 たとえば、<code class="literal">anEvent</code> と <code class="literal">AnEvent</code> という名前の 2 つのイベントを同じデータベース内に含めることはできません。 
          </p></li><li class="listitem"><p>
            イベント名が変数によって指定されている場合、ストアドプログラム内からイベントを作成、変更、または削除することはできません。 イベントは、ストアドルーチンやトリガーを作成、変更、削除することもできません。 
          </p></li><li class="listitem"><p>
            <code class="literal">LOCK TABLES</code> ステートメントの有効時は、イベントでの DDL ステートメントは禁止されています。
          </p></li><li class="listitem"><p>
            <code class="literal">YEAR</code>、<code class="literal">QUARTER</code>、<code class="literal">MONTH</code>、および <code class="literal">YEAR_MONTH</code> の間隔を使用したイベントのタイミングは、月で解決されます。ほかの間隔を使用したタイミングは秒で解決されます。 同時に行われるようにスケジュール設定されたイベントは、指定の順序で実行できません。 さらに、丸め、スレッドアプリケーションの特性、およびイベントを作成しその実行を信号で伝えるためにゼロ以外の時間長が必要になるため、イベントが 1、2 秒ほど遅れる場合があります。 ただし、<code class="literal">INFORMATION_SCHEMA.EVENTS</code> テーブルの <code class="literal">LAST_EXECUTED</code> カラムに表示される時間は、常に実際のイベント実行時間の 1 秒以内に正確です。 (Bug #16522 も参照してください。) 
          </p></li><li class="listitem"><p>
            イベントの本体に含まれるステートメントの各実行は、新しい接続で行われます。したがって、これらのステートメントは、<code class="literal">SHOW STATUS</code> によって表示される <code class="literal">Com_select</code> や <code class="literal">Com_insert</code> などのサーバーステートメント数に対する特定のユーザーセッションには影響しません。 ただし、このような数はグローバルスコープで更新<span class="emphasis"><em>されます</em></span>。 (Bug #16422) 
          </p></li><li class="listitem"><p>
            イベントは、Unix エポックの最後の時間以降をサポートしません。この時間は 2038 年の年頭あたりになります。 このような日付はイベントスケジューラで特に許可されません。 (Bug #16396) 
          </p></li><li class="listitem"><p>
            <code class="literal">CREATE EVENT</code> および <code class="literal">ALTER EVENT</code> ステートメントの <code class="literal">ON SCHEDULE</code> 句でのストアドファンクション、ユーザー定義関数、およびテーブルの参照はサポートされていません。 このような種類の参照は許可されていません。 (詳細は Bug #22830 を参照してください。) 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="stored-routines-ndbcluster"></a>NDB Cluster 内のストアドルーチンとトリガー</h3></div></div></div><p>
        ストアドプロシージャ、ストアドファンクション、トリガーおよびスケジュール済イベントはすべて、<code class="literal">NDB</code> ストレージエンジンを使用するテーブルでサポートされますが、これらはクラスタ SQL ノードとして機能する MySQL Servers 間で自動的に伝播されないことに注意する必要があります。 これは、ストアドルーチンおよびトリガー定義が、クラスタノード間でコピーされない <code class="literal">InnoDB</code> テーブルを使用して <code class="literal">mysql</code> システムデータベース内のテーブルに格納されるためです。 
      </p><p>
        MySQL Cluster テーブルと対話するストアドルーチンまたはトリガーは、ストアドルーチンまたはトリガーを使用するクラスタに参加する各 MySQL Server で適切な <code class="literal">CREATE PROCEDURE</code>、<code class="literal">CREATE FUNCTION</code>、または <code class="literal">CREATE TRIGGER</code> ステートメントを実行して再作成する必要があります。 同様に、既存のストアドルーチンまたはトリガーに対する変更は、クラスタにアクセスする各 MySQL Server で適切な <code class="literal">ALTER</code> ステートメントまたは <code class="literal">DROP</code> ステートメントを使用して、すべてのクラスタ SQL ノードで明示的に実行する必要があります。 
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          <code class="literal">NDB</code> ストレージエンジンを使用するように <code class="literal">mysql</code> データベーステーブルを変換して、ここで説明した問題を回避しないでください。 <span class="emphasis"><em>「<code class="literal">mysql</code> データベースでのシステムテーブルの変更はサポートされていません」</em></span>では、望ましくない結果が生成される可能性があります。 
        </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-restrictions"></a>25.9 ビューの制約</h2></div></div></div><a class="indexterm" name="idm46065427406880"></a><a class="indexterm" name="idm46065427404736"></a><a class="indexterm" name="idm46065427402704"></a><a class="indexterm" name="idm46065427400608"></a><p>
      ビューの定義で参照できるテーブルの最大数は 61 です。
    </p><p>
      ビューの処理は最適化されていません。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ビューにはインデックスを作成できません。
        </p></li><li class="listitem"><p>
          マージアルゴリズムを使用して処理されたビューに、インデックスを使用することは可能です。 ただし、TEMPTABLE アルゴリズムで処理されたビューは、そのベースとなるテーブルのインデックスを利用できません (ただし、一時テーブルの作成中にはインデックスを使用できます)。 
        </p></li></ul></div><p>
      一般的な原則では、テーブルを変更することも、サブクエリーの同じテーブルから選択することもできません。 <a class="xref" href="sql-statements.html#subquery-restrictions" title="13.2.11.12 サブクエリーの制約">セクション13.2.11.12「サブクエリーの制約」</a>を参照してください。 
    </p><p>
      テーブルから選択するビューを選ぶ場合、ビューがサブクエリーのテーブルから選択される場合や、ビューがマージアルゴリズムを使用して評価される場合にも、同じ原則が適用されます。 例: 
    </p><pre class="programlisting">CREATE VIEW v1 AS
SELECT * FROM t2 WHERE EXISTS (SELECT 1 FROM t1 WHERE t1.a = t2.a);

UPDATE t1, v2 SET t1.a = 1 WHERE t1.b = v2.b;
</pre><p>
      一時テーブルを使用してビューが評価される場合、ビューサブクエリーのテーブルから選択し、さらに外部クエリーでそのテーブルを変更することが<span class="emphasis"><em>可能</em></span>です。 この場合、ビューは一時テーブルに格納されるため、サブクエリーのテーブルから選択して同時に変更することはありません。 (これは、ビュー定義で <code class="literal">ALGORITHM = TEMPTABLE</code> を指定することによって、MySQL で TEMPTABLE アルゴリズムを強制的に使用させる 1 つの理由です。) 
    </p><p>
      <code class="literal">DROP TABLE</code> または <code class="literal">ALTER TABLE</code> を使用すると、ビュー定義で使用されているテーブルを削除または変更できます。 ビューを無効化する場合でも、<code class="literal">DROP</code> または <code class="literal">ALTER</code> 操作によって警告が発せられることはありません。 代わりに、あとからビューを使用するときにエラーが発生します。 <code class="literal">CHECK TABLE</code> は、<code class="literal">DROP</code> または <code class="literal">ALTER</code> 操作で無効化されたビューのチェックに使用できます。 
    </p><p>
      ビューの更新可能性に関しては、どのビューでも理論的に更新可能であれば、実際に更新可能である必要があるというのがビューの全体的な目的です。 MySQL はできるだけ迅速に実行できます。 理論的には多くの更新可能なビューを更新できるようになりましたが、まだ制限があります。 詳細は、<a class="xref" href="stored-objects.html#view-updatability" title="25.5.3 更新可能および挿入可能なビュー">セクション25.5.3「更新可能および挿入可能なビュー」</a>を参照してください。 
    </p><a class="indexterm" name="idm46065427380288"></a><a class="indexterm" name="idm46065427378176"></a><a class="indexterm" name="idm46065427376144"></a><a class="indexterm" name="idm46065427374112"></a><a class="indexterm" name="idm46065427372080"></a><a class="indexterm" name="idm46065427370048"></a><p>
      ビューの現在の実装には欠点があります。 ビューの作成に必要な基本権限 (<code class="literal">CREATE VIEW</code> および <code class="literal">SELECT</code> 権限) がユーザーに付与されている場合、そのユーザーに <code class="literal">SHOW VIEW</code> 権限も付与されていないかぎり、そのユーザーはそのオブジェクトに対して <code class="literal">SHOW CREATE VIEW</code> をコールできません。 
    </p><p>
      権限の不足のために <span class="command"><strong>mysqldump</strong></span> が失敗する可能性があるという欠点によって、このコマンドを使用したデータベースのバックアップで問題が発生する場合があります。 この問題については Bug #22062 で説明しています。 
    </p><p>
      問題の回避策として、ビューが作成されたときに MySQL が暗黙的に <code class="literal">SHOW VIEW</code> 権限を与えないため、<code class="literal">CREATE VIEW</code> を認められているユーザーに、管理者が手動でこの権限を付与します。
    </p><p>
      ビューにはインデックスがないので、インデックスのヒントは適用されません。 ビューからの選択時のインデックスヒントの使用は許可されていません。 
    </p><p>
      <code class="literal">SHOW CREATE VIEW</code> は、カラムごとに <code class="literal">AS <em class="replaceable"><code>alias_name</code></em></code> 句を使用してビュー定義を表示します。 式からカラムを作成する場合、デフォルトのエイリアスは式テキストになり、かなり長くなることがあります。 <code class="literal">CREATE VIEW</code> ステートメント内のカラム名に対するエイリアスは、(256 文字の最大のエイリアス長ではなく) 64 文字の最大のカラム長に対してチェックされます。 その結果、いずれかのカラムエイリアスが 64 文字を超えた場合、<code class="literal">SHOW CREATE VIEW</code> の出力から作成されたビューは失敗します。 これによって、長すぎるエイリアスを持つビューに対し、次の環境で問題が起きる可能性があります。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ビュー定義は、カラム長制限を強制する新しいレプリカへのレプリケートに失敗します。
        </p></li><li class="listitem"><p>
          <span class="command"><strong>mysqldump</strong></span> で作成されたダンプファイルは、カラム長の制約を強制するサーバーにロードできません。
        </p></li></ul></div><p>
      これらの問題を回避するには、短いカラム名を提供するエイリアスを使用するように、問題のある各ビュー定義を変更します。 その後、ビューは適切にレプリケートされ、エラーを発生させずにダンプおよびリロードできます。 定義を変更するには、<code class="literal">DROP VIEW</code> および <code class="literal">CREATE VIEW</code> でビューを削除してから再度作成するか、<code class="literal">CREATE OR REPLACE VIEW</code> を使用して定義を置き換えます。 
    </p><p>
      ダンプファイルのビュー定義リロード時に問題が発生する場合は、<code class="literal">CREATE VIEW</code> ステートメントを変更するようにダンプファイルを編集するとこの問題を回避できます。 ただし、これは元のビュー定義を変更しないので、その後のダンプ操作の問題を引き起こす可能性があります。 
    </p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="partitioning.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="information-schema.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第 24 章 パーティション化 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第 26 章 INFORMATION_SCHEMA テーブル</td></tr></table></div><div class="copyright-footer"></div></body></html>
