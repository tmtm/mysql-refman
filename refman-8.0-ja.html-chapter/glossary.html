<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>MySQL 用語集</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="MySQL 8.0 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 8.0 リファレンスマニュアル"><link rel="prev" href="indexes.html" title="付録 C インデックス"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">MySQL 用語集</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="indexes.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> </td></tr></table><hr></div><div class="status-header"><p class="alert">このページは機械翻訳したものです。</p></div><div class="glossary"><div class="titlepage"><div><div><h1 class="title"><a name="glossary"></a>MySQL 用語集</h1></div></div></div><p>
    これらの用語は、MySQL データベースサーバーに関する情報で一般的に使用されます。 この用語集は、InnoDB ストレージエンジンに関する用語のリファレンスとして作成され、大部分の定義は InnoDB 関連です。 
  </p><div class="glossdiv"><h3 class="title">.</h3><dl><dt><a name="glos_arm_file"></a><span class="glossterm">.ARM ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766752192"></a>
        <code class="literal">ARCHIVE</code> テーブルのメタデータ。 <span class="bold"><strong>.ARZ ファイル</strong></span>と対比してください。 この拡張子を持つファイルは常に、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品の <code class="literal">mysqlbackup</code> コマンドで生成されるバックアップに含められます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_arz_file">.ARZ ファイル</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_mysqlbackup_command">mysqlbackup コマンド</a>も参照</p></dd><dt><a name="glos_arz_file"></a><span class="glossterm">.ARZ ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766744816"></a>
        ARCHIVE テーブルのデータ。 <span class="bold"><strong>.ARM ファイル</strong></span>と対比してください。 この拡張子を持つファイルは常に、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品の <code class="literal">mysqlbackup</code> コマンドで生成されるバックアップに含められます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_arm_file">.ARM ファイル</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_mysqlbackup_command">mysqlbackup コマンド</a>も参照</p></dd><dt><a name="glos_cfg_file"></a><span class="glossterm">.cfg ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766738304"></a>
        <code class="literal">InnoDB</code> <span class="bold"><strong>トランスポータブルテーブルスペース</strong></span>機能で使用するメタデータファイル。 これは、コマンド <code class="literal">FLUSH TABLES ... FOR EXPORT</code> で生成され、1 つまたは複数のテーブルを、別のサーバーにコピーできる一貫した状態にします。 <code class="literal">.cfg</code> ファイルは、対応する <span class="bold"><strong>.ibd ファイル</strong></span>とともにコピーされ、<code class="literal">ALTER TABLE ... IMPORT TABLESPACE</code> ステップ中に <span class="bold"><strong>space ID</strong></span> などの <code class="literal">.ibd</code> ファイルの内部値を調整するために使用されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_space_id">スペース ID</a>, <a class="glossseealso" href="glossary.html#glos_transportable_tablespace">トランスポータブルテーブルスペース</a>も参照</p></dd><dt><a name="glos_frm_file"></a><span class="glossterm">.frm ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766727856"></a>
        MySQL テーブルのメタデータ (テーブル定義など) を含むファイル。<code class="filename">.frm</code> ファイルは MySQL 8.0 で削除されましたが、以前の MySQL リリースでは引き続き使用されています。 MySQL 8.0 では、以前に <code class="filename">.frm</code> ファイルに格納されたデータは<span class="bold"><strong>データディクショナリ</strong></span>テーブルに格納されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_data_dictionary">データディクショナリ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>も参照</p></dd><dt><a name="glos_ibd_file"></a><span class="glossterm">.ibd ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766721216"></a>
        <span class="bold"><strong>file-per-table</strong></span> テーブルスペースおよび一般テーブルスペースのデータファイル。 File-per-table テーブルスペースの <code class="literal">.ibd</code> ファイルには、単一のテーブルおよび関連するインデックスデータが含まれます。 <span class="bold"><strong>一般テーブルスペース</strong></span> <code class="literal">.ibd</code> ファイルには、複数のテーブルのテーブルおよびインデックスデータを含めることができます。 
      </p><p>
        <code class="literal">.ibd</code> ファイル拡張子は、1 つ以上の<span class="bold"><strong>ibdata ファイル</strong></span>で構成される<span class="bold"><strong>システムテーブルスペース</strong></span>には適用されません。
      </p><p>
        file-per-table テーブルスペースまたは一般テーブルスペースが <code class="literal">DATA DIRECTORY =</code> 句を使用して作成された場合、<code class="literal">.ibd</code> ファイルは通常のデータディレクトリ外の指定されたパスにあります。
      </p><p>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品によって <code class="literal">.ibd</code> ファイルが圧縮バックアップに含まれるとき、圧縮版は <code class="literal">.ibz</code> ファイルです。
      </p><p><a class="glossseealso" href="glossary.html#glos_database">データベース</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_general_tablespace">一般テーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_ibdata_file">ibdata ファイル</a>, <a class="glossseealso" href="glossary.html#glos_ibz_file">.ibz ファイル</a>, <a class="glossseealso" href="glossary.html#glos_innodb_file_per_table">innodb_file_per_table</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>も参照</p></dd><dt><a name="glos_ibz_file"></a><span class="glossterm">.ibz ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766703088"></a>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品が<span class="bold"><strong>圧縮バックアップ</strong></span>を実行するときに、これは、<span class="bold"><strong>file-per-table</strong></span> 設定を使用して作成される各<span class="bold"><strong>テーブルスペース</strong></span>ファイルを、<code class="literal">.ibd</code> 拡張子から <code class="literal">.ibz</code> 拡張子に変換します。
      </p><p>
        バックアップ中に適用される圧縮は、通常操作中にテーブルデータを圧縮されたままにする<span class="bold"><strong>圧縮行フォーマット</strong></span>とは異なります。 圧縮バックアップ操作では、すでに圧縮行フォーマットであるテーブルスペースについては圧縮ステップをスキップします。2 回目の圧縮では、バックアップ速度を低下させるだけで、ほとんどまたはまったく領域を節約しないためです。 
      </p><p><a class="glossseealso" href="glossary.html#glos_compressed_backup">圧縮バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_compressed_row_format">圧縮行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd><dt><a name="glos_mrg_file"></a><span class="glossterm">.MRG ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766691008"></a>
        <code class="literal">MERGE</code> ストレージエンジンで使用される、ほかのテーブルへの参照を含むファイル。 この拡張子を持つファイルは常に、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品の <span class="command"><strong>mysqlbackup</strong></span> コマンドで生成されるバックアップに含められます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_mysqlbackup_command">mysqlbackup コマンド</a>も参照</p></dd><dt><a name="glos_myd_file"></a><span class="glossterm">.MYD ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766684928"></a>
        MySQL が <code class="literal">MyISAM</code> テーブルのデータを格納するために使用するファイル。
      </p><p><a class="glossseealso" href="glossary.html#glos_myi_file">.MYI ファイル</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_mysqlbackup_command">mysqlbackup コマンド</a>も参照</p></dd><dt><a name="glos_myi_file"></a><span class="glossterm">.MYI ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766679600"></a>
        MySQL が <code class="literal">MyISAM</code> テーブルのインデックスを格納するために使用するファイル。
      </p><p><a class="glossseealso" href="glossary.html#glos_myd_file">.MYD ファイル</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_mysqlbackup_command">mysqlbackup コマンド</a>も参照</p></dd><dt><a name="glos__net"></a><span class="glossterm">.NET</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766674512"></a></p><p><a class="glossseealso" href="glossary.html#glos_ado_net">ADO.NET</a>, <a class="glossseealso" href="glossary.html#glos_asp_net">ASP.net</a>, <a class="glossseealso" href="glossary.html#glos_connector_net">Connector/NET</a>, <a class="glossseealso" href="glossary.html#glos_mono">モノ</a>, <a class="glossseealso" href="glossary.html#glos_visual_studio">Visual Studio</a>も参照</p></dd><dt><a name="glos_opt_file"></a><span class="glossterm">.OPT ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766669440"></a>
        データベース構成情報を含むファイル。 この拡張子のファイルは、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品の <span class="command"><strong>mysqlbackup</strong></span> コマンドによって生成されたバックアップに含まれます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_mysqlbackup_command">mysqlbackup コマンド</a>も参照</p></dd><dt><a name="glos_par_file"></a><span class="glossterm">.par ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766664192"></a>
        パーティション定義を含むファイル。 この拡張子のファイルは、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品の <code class="literal">mysqlbackup</code> コマンドによって生成されたバックアップに含まれます。 
      </p><p>
        MySQL 5.7.6 での <code class="literal">InnoDB</code> テーブルのネイティブパーティション化サポートの導入により、パーティション化された <code class="literal">InnoDB</code> テーブルの <code class="filename">.par</code> ファイルは作成されなくなりました。 パーティション化された <code class="literal">MyISAM</code> テーブルでは、MySQL 5.7 の <code class="filename">.par</code> ファイルが引き続き使用されます。 MySQL 8.0 では、パーティション分割のサポートは <code class="literal">InnoDB</code> ストレージエンジンによってのみ提供されます。 そのため、<code class="filename">.par</code> ファイルは MySQL 8.0 の時点では使用されなくなりました。 
      </p><p><a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_mysqlbackup_command">mysqlbackup コマンド</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">2</h3><dl><dt><a name="glos_two_phase_commit"></a><span class="glossterm">2 フェーズコミット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766651760"></a>
        <span class="bold"><strong>XA</strong></span> 仕様に基づく分散型<span class="bold"><strong>トランザクション</strong></span>の一部である操作。 (2PC と略記されることがあります。) 複数のデータベースがトランザクションに参加する場合、すべてのデータベースが変更を<span class="bold"><strong>コミット</strong></span>するか、すべてのデータベースが変更を<span class="bold"><strong>ロールバック</strong></span>します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_xa">XA</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">A</h3><dl><dt><a name="glos_acid"></a><span class="glossterm">ACID</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766643680"></a>
        原子性 (atomicity)、一貫性 (consistency)、分離性 (isolation)、持続性 (durability) を表す頭字語。 これらの特性はすべてデータベースシステムで望ましく、すべて<span class="bold"><strong>トランザクション</strong></span>の概念に密接に結び付けられています。 <code class="literal">InnoDB</code> のトランザクション機能は ACID の原則に準拠しています。 
      </p><p>
        トランザクションは、<span class="bold"><strong>コミット</strong></span>または<span class="bold"><strong>ロールバック</strong></span>できる<span class="bold"><strong>原子的</strong></span>な作業単位です。 トランザクションによってデータベースに複数の変更が行われた場合、トランザクションがコミットされるとすべての変更が完了し、トランザクションがロールバックされるとすべての変更が元に戻されます。 
      </p><p>
        データベースは常に一貫性のある状態のままです - 各コミットまたはロールバックの後、およびトランザクションの進行中。 関連データが複数のテーブルにわたって更新されている場合、クエリーは、古い値と新しい値の混合ではなく、すべて古い値か、すべて新しい値のどちらかを見ます。 
      </p><p>
        トランザクションは進行中、互いから保護 (分離) されます。それらは互いに干渉できず、互いのコミットされていないデータを見ることはできません。 この分離性は、<span class="bold"><strong>ロック</strong></span>メカニズムを通じて実現します。 経験豊富なユーザーは、実際にトランザクションが互いに干渉しないと確信できれば、パフォーマンスと<span class="bold"><strong>並列性</strong></span>の向上の代わりに保護の低下をトレードオフするように<span class="bold"><strong>分離レベル</strong></span>を調整できます。 
      </p><p>
        トランザクションの結果は持続的です。コミット操作が成功すると、そのトランザクションによって行われた変更は、データベース以外の多くのアプリケーションが脆弱である停電、システムのクラッシュ、競合状況、またはほかの潜在的な危険から保護されます。 持続性には通常、ディスクストレージへの書き込みがかかわっており、書き込み操作中の停電またはソフトウェアクラッシュに対して保護するために一定の冗長性を備えています。 (<code class="literal">InnoDB</code> では、<span class="bold"><strong>二重書込みバッファ</strong></span>は永続性を支援します。) 
      </p><p><a class="glossseealso" href="glossary.html#glos_atomic">原子的</a>, <a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_doublewrite_buffer">二重書き込みバッファー</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_ado_net"></a><span class="glossterm">ADO.NET</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766625200"></a>
        <span class="bold"><strong>ASP.NET</strong></span> などの .NET テクノロジを使用して構築されたアプリケーション用のオブジェクトリレーショナルマッピング (ORM) フレームワーク。 このようなアプリケーションは、<span class="bold"><strong>Connector/NET</strong></span> コンポーネントを介して MySQL とインタフェースできます。 
      </p><p><a class="glossseealso" href="glossary.html#glos__net">.NET</a>, <a class="glossseealso" href="glossary.html#glos_asp_net">ASP.net</a>, <a class="glossseealso" href="glossary.html#glos_connector_net">Connector/NET</a>, <a class="glossseealso" href="glossary.html#glos_mono">モノ</a>, <a class="glossseealso" href="glossary.html#glos_visual_studio">Visual Studio</a>も参照</p></dd><dt><a name="glos_aio"></a><span class="glossterm">AIO</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766618400"></a>
        <span class="bold"><strong>非同期 I/O (Asynchronous I/O)</strong></span> の頭字語。 この頭字語は、<code class="literal">InnoDB</code> メッセージまたはキーワードに表示される場合があります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_asynchronous_io">非同期 I/O</a>も参照</p></dd><dt><a name="glos_ansi"></a><span class="glossterm">ANSI</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766614240"></a>
        <span class="bold"><strong>ODBC</strong></span> では、文字セットおよびその他の国際化の側面をサポートする代替方法。 <span class="bold"><strong>Unicode</strong></span> と対比してください。 <span class="bold"><strong>Connector/ODBC</strong></span> 3.51 は ANSI ドライバですが、Connector/ODBC 5.1 は Unicode ドライバです。 
      </p><p><a class="glossseealso" href="glossary.html#glos_connector_odbc">Connector/ODBC</a>, <a class="glossseealso" href="glossary.html#glos_odbc">ODBC</a>, <a class="glossseealso" href="glossary.html#glos_unicode">Unicode</a>も参照</p></dd><dt><a name="glos_api"></a><span class="glossterm">API</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766607632"></a>
        API は、<span class="bold"><strong>client</strong></span> プログラムから MySQL プロトコルおよび MySQL リソースへの低レベルのアクセスを提供します。 <span class="bold"><strong>Connector</strong></span> によって提供される上位レベルのアクセスと対比してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_c_api">C API</a>, <a class="glossseealso" href="glossary.html#glos_client">クライアント</a>, <a class="glossseealso" href="glossary.html#glos_connector">コネクタ</a>, <a class="glossseealso" href="glossary.html#glos_native_c_api">ネイティブ C API</a>, <a class="glossseealso" href="glossary.html#glos_perl_api">Perl API</a>, <a class="glossseealso" href="glossary.html#glos_php_api">PHP API</a>, <a class="glossseealso" href="glossary.html#glos_python_api">Python API</a>, <a class="glossseealso" href="glossary.html#glos_ruby_api">Ruby API</a>も参照</p></dd><dt><a name="glos_asp_net"></a><span class="glossterm">ASP.net</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766598688"></a>
        <span class="bold"><strong>.NET</strong></span> テクノロジおよび言語を使用して web ベースのアプリケーションを開発するためのフレームワーク。 このようなアプリケーションは、<span class="bold"><strong>Connector/NET</strong></span> コンポーネントを介して MySQL とインタフェースできます。 
      </p><p>
        MySQL を使用してサーバー側の web ページを作成する別のテクノロジは、<span class="bold"><strong>PHP</strong></span> です。
      </p><p><a class="glossseealso" href="glossary.html#glos__net">.NET</a>, <a class="glossseealso" href="glossary.html#glos_ado_net">ADO.NET</a>, <a class="glossseealso" href="glossary.html#glos_connector_net">Connector/NET</a>, <a class="glossseealso" href="glossary.html#glos_mono">モノ</a>, <a class="glossseealso" href="glossary.html#glos_php">PHP</a>, <a class="glossseealso" href="glossary.html#glos_visual_studio">Visual Studio</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">B</h3><dl><dt><a name="glos_b_tree"></a><span class="glossterm">B ツリー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766589552"></a>
        データベースインデックスに一般的に使用されるツリーデータ構造。 この構造は、常にソートされ続け、正確な一致 (等号演算子) および範囲 (大なり、小なり、<code class="literal">BETWEEN</code> 演算子など) の高速ルックアップを可能にします。 このタイプのインデックスは、<code class="literal">InnoDB</code> や <code class="literal">MyISAM</code> などのほとんどのストレージエンジンで使用できます。 
      </p><p>
        B ツリーノードには多くの子を含むことができるので、B ツリーは、ノードごとに 2 つの子に限られているバイナリツリーと同じではありません。
      </p><p>
        <code class="literal">MEMORY</code> ストレージエンジンでのみ使用可能な<span class="bold"><strong>ハッシュインデックス</strong></span>と対比してください。 <code class="literal">MEMORY</code> ストレージエンジンでは B ツリーインデックスも使用でき、一部のクエリーで範囲演算子が使用されている場合は、<code class="literal">MEMORY</code> テーブルに B ツリーインデックスを選択する必要があります。 
      </p><p>
        B ツリーという用語の使用は、インデックス設計の一般クラスへの参照として意図されています。 MySQL ストレージエンジンで使用される B ツリー構造は、従来の B ツリー設計には存在しないため、バリアントとみなされることがあります。 関連情報は、<a class="ulink" href="https://dev.mysql.com/doc/internals/en/index.html" target="_top">MySQL Internals Manual</a> の <code class="literal">InnoDB</code> Page Structure <a class="ulink" href="https://dev.mysql.com/doc/internals/en/innodb-fil-header.html" target="_top">「ファイルヘッダー」</a>のセクションを参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_hash_index">ハッシュインデックス</a>も参照</p></dd><dt><a name="glos_binlog"></a><span class="glossterm">binlog</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766575008"></a>
        <span class="bold"><strong>バイナリログ</strong></span>ファイルの非公式名。 たとえば、電子メールメッセージやフォーラムディスカッションでこの略語を見ることがあります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_binary_log">バイナリログ</a>も参照</p></dd><dt><a name="glos_blob"></a><span class="glossterm">BLOB</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766571520"></a>
        任意のサイズの任意の種類のバイナリデータを含むオブジェクトの SQL データ型 (<code class="literal">TINYBLOB</code>, <code class="literal">BLOB</code>, <code class="literal">MEDIUMBLOB</code> および <code class="literal">LONGBLOB</code>)。 MySQL テーブル内の行およびカラムに簡単に分解できないドキュメント、イメージ、サウンドファイルおよびその他の種類の情報を格納するために使用されます。 MySQL アプリケーション内で BLOB を処理する手法は、<span class="bold"><strong>Connector</strong></span> および <span class="bold"><strong>API</strong></span> ごとに異なります。 MySQL <code class="literal">Connector/ODBC</code> では、<code class="literal">BLOB</code> 値を <code class="literal">LONGVARBINARY</code> として定義します。 文字データの大規模で自由形式のコレクションの場合、業界用語は MySQL <code class="literal">TEXT</code> データ型で表される <span class="bold"><strong>CLOB</strong></span> です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_api">API</a>, <a class="glossseealso" href="glossary.html#glos_clob">CLOB</a>, <a class="glossseealso" href="glossary.html#glos_connector">コネクタ</a>, <a class="glossseealso" href="glossary.html#glos_connector_odbc">Connector/ODBC</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">C</h3><dl><dt><a name="glos_c"></a><span class="glossterm">C</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766556416"></a>
        移植性とパフォーマンスを組み合わせ、低レベルのハードウェア機能にアクセスし、オペレーティングシステム、ドライバ、およびその他の種類のシステムソフトウェアを記述するための一般的な選択を可能にするプログラミング言語。 C で記述された複雑なアプリケーション、言語および再利用可能なモジュールの多くは、他の言語で記述された高レベルのコンポーネントと結び付けられています。 そのコア構文は、<span class="bold"><strong>C++</strong></span>、<span class="bold"><strong>Java</strong></span> および <span class="bold"><strong>C#</strong></span>の開発者によく知られています。 
      </p><p><a class="glossseealso" href="glossary.html#glos_c_api">C API</a>, <a class="glossseealso" href="glossary.html#glos_cplusplus">C++</a>, <a class="glossseealso" href="glossary.html#glos_csharp">C#</a>, <a class="glossseealso" href="glossary.html#glos_java">Java</a>も参照</p></dd><dt><a name="glos_c_api"></a><span class="glossterm">C API</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766549232"></a>
        C <span class="bold"><strong>API</strong></span> コードは、MySQL とともに配布されます。 これは <span class="bold"><strong>libmysqlclient</strong></span> ライブラリに含まれ、<span class="bold"><strong>C</strong></span> プログラムがデータベースにアクセスできるようにします。 
      </p><p><a class="glossseealso" href="glossary.html#glos_api">API</a>, <a class="glossseealso" href="glossary.html#glos_c">C</a>, <a class="glossseealso" href="glossary.html#glos_libmysqlclient">libmysqlclient</a>も参照</p></dd><dt><a name="glos_csharp"></a><span class="glossterm">C#</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766543024"></a>
        強力な型付け機能とオブジェクト指向機能を組み合せたプログラミング言語で、Microsoft <span class="bold"><strong>.NET</strong></span> フレームワークまたはそれに対応するオープンソースの<span class="bold"><strong>モノ</strong></span>内で実行されます。 多くの場合、<span class="bold"><strong>ASP.net</strong></span> フレームワークを使用したアプリケーションの作成に使用されます。 この構文は、<span class="bold"><strong>C</strong></span>、<span class="bold"><strong>C++</strong></span> および <span class="bold"><strong>Java</strong></span> 開発者によく知られています。 
      </p><p><a class="glossseealso" href="glossary.html#glos__net">.NET</a>, <a class="glossseealso" href="glossary.html#glos_asp_net">ASP.net</a>, <a class="glossseealso" href="glossary.html#glos_c">C</a>, <a class="glossseealso" href="glossary.html#glos_connector_net">Connector/NET</a>, <a class="glossseealso" href="glossary.html#glos_cplusplus">C++</a>, <a class="glossseealso" href="glossary.html#glos_java">Java</a>, <a class="glossseealso" href="glossary.html#glos_mono">モノ</a>も参照</p></dd><dt><a name="glos_cplusplus"></a><span class="glossterm">C++</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766532464"></a>
        <span class="bold"><strong>C</strong></span> 開発者に精通したコア構文を持つプログラミング言語。 高レベルのデータ型、オブジェクト指向機能およびガベージコレクションと組み合せて、パフォーマンスのための低レベルの操作へのアクセスを提供します。 MySQL 用の C++ アプリケーションを作成するには、<span class="bold"><strong>Connector/C++</strong></span> コンポーネントを使用します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_c">C</a>, <a class="glossseealso" href="glossary.html#glos_connector_c__">Connector/C++</a>も参照</p></dd><dt><a name="glos_clob"></a><span class="glossterm">CLOB</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766527328"></a>
        任意のサイズの任意の種類の文字データを含むオブジェクトの SQL データ型 (<code class="literal">TINYTEXT</code>, <code class="literal">TEXT</code>, <code class="literal">MEDIUMTEXT</code> または <code class="literal">LONGTEXT</code>)。 関連付けられた文字セットおよび照合順序とともにテキストベースのドキュメントを格納するために使用されます。 MySQL アプリケーション内で CLOB を処理する手法は、<span class="bold"><strong>Connector</strong></span> および <span class="bold"><strong>API</strong></span> ごとに異なります。 MySQL Connector/ODBC では、<code class="literal">TEXT</code> 値を <code class="literal">LONGVARCHAR</code> として定義します。 バイナリデータを格納する場合、<span class="bold"><strong>BLOB</strong></span> 型に相当します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_api">API</a>, <a class="glossseealso" href="glossary.html#glos_blob">BLOB</a>, <a class="glossseealso" href="glossary.html#glos_connector">コネクタ</a>, <a class="glossseealso" href="glossary.html#glos_connector_odbc">Connector/ODBC</a>も参照</p></dd><dt><a name="glos_connector_c__"></a><span class="glossterm">Connector/C++</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766514736"></a>
        Connector/C++ 8.0 を使用すると、<a class="link" href="document-store.html" title="第 20 章 ドキュメントストアとしての MySQL の使用">document store</a> を実装する MySQL サーバーにアクセスしたり、SQL クエリーを使用して従来の方法でアクセスできます。 これにより、X DevAPI を使用した C++ アプリケーションの開発、または X DevAPI for C を使用したプレーン C アプリケーションの開発が可能になります。 また、Connector/C++ 1.1 から従来の JDBC ベース API を使用する C++ アプリケーションの開発も可能です。 詳細は、<a class="ulink" href="https://dev.mysql.com/doc/connector-cpp/8.0/en/" target="_top">MySQL Connector/C++ 8.0 Developer Guide</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_client">クライアント</a>, <a class="glossseealso" href="glossary.html#glos_connector">コネクタ</a>, <a class="glossseealso" href="glossary.html#glos_jdbc">JDBC</a>も参照</p></dd><dt><a name="glos_connector_j"></a><span class="glossterm">Connector/J</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766508672"></a>
        <span class="bold"><strong>Java</strong></span> プログラミング言語で開発された <span class="bold"><strong>client</strong></span> アプリケーションの接続を提供する <span class="bold"><strong>JDBC</strong></span> ドライバ。 MySQL Connector/J は JDBC タイプ 4 ドライバです: MySQL <span class="bold"><strong>クライアントライブラリ</strong></span>に依存しない MySQL プロトコルのピュア Java 実装。 詳細は、<a class="ulink" href="https://dev.mysql.com/doc/connector-j/8.0/en/" target="_top">MySQL Connector/J 8.0 Developer Guide</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_client">クライアント</a>, <a class="glossseealso" href="glossary.html#glos_client_libraries">クライアントライブラリ</a>, <a class="glossseealso" href="glossary.html#glos_connector">コネクタ</a>, <a class="glossseealso" href="glossary.html#glos_java">Java</a>, <a class="glossseealso" href="glossary.html#glos_jdbc">JDBC</a>も参照</p></dd><dt><a name="glos_connector_net"></a><span class="glossterm">Connector/NET</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766499968"></a>
        <span class="bold"><strong>C#</strong></span>、<span class="bold"><strong>.NET</strong></span>、<span class="bold"><strong>モノ</strong></span>、<span class="bold"><strong>Visual Studio</strong></span>、<span class="bold"><strong>ASP.net</strong></span>、および <span class="bold"><strong>ADO.net</strong></span> などのアプリケーションを記述する開発者向けの MySQL <span class="bold"><strong>コネクタ</strong></span>。
      </p><p><a class="glossseealso" href="glossary.html#glos_ado_net">ADO.NET</a>, <a class="glossseealso" href="glossary.html#glos_asp_net">ASP.net</a>, <a class="glossseealso" href="glossary.html#glos_connector">コネクタ</a>, <a class="glossseealso" href="glossary.html#glos_csharp">C#</a>, <a class="glossseealso" href="glossary.html#glos_mono">モノ</a>, <a class="glossseealso" href="glossary.html#glos_visual_studio">Visual Studio</a>も参照</p></dd><dt><a name="glos_connector_odbc"></a><span class="glossterm">Connector/ODBC</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766489776"></a>
        業界標準の Open Database Connectivity (<span class="bold"><strong>ODBC</strong></span>) API を使用して MySQL データベースへのアクセスを提供する MySQL ODBC ドライバのファミリ。 以前の名前は MyODBC ドライバです。 詳細は、<a class="ulink" href="https://dev.mysql.com/doc/connector-odbc/en/" target="_top">MySQL Connector/ODBC Developer Guide</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_connector">コネクタ</a>, <a class="glossseealso" href="glossary.html#glos_odbc">ODBC</a>も参照</p></dd><dt><a name="glos_connector_php"></a><span class="glossterm">Connector/PHP</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766484736"></a>
        Windows オペレーティングシステム用に最適化された <code class="literal">mysql</code> および <code class="literal">mysqli</code> <span class="bold"><strong>APIs</strong></span> for <span class="bold"><strong>PHP</strong></span> のバージョン。
      </p><p><a class="glossseealso" href="glossary.html#glos_connector">コネクタ</a>, <a class="glossseealso" href="glossary.html#glos_php">PHP</a>, <a class="glossseealso" href="glossary.html#glos_php_api">PHP API</a>も参照</p></dd><dt><a name="glos_cpu_bound"></a><span class="glossterm">CPU バウンド</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766478128"></a>
        <span class="bold"><strong>ワークロード</strong></span>の種類の 1つ。主な<span class="bold"><strong>ボトルネック</strong></span>がメモリー内の CPU 操作であるもの。 通常、<span class="bold"><strong>バッファープール</strong></span>内にすべての結果をキャッシュできる、読み取り中心の操作を含みます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_bottleneck">ボトルネック</a>, <a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_workload">ワークロード</a>も参照</p></dd><dt><a name="glos_crud"></a><span class="glossterm">CRUD</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766471904"></a>
        <span class="quote">「<span class="quote">「作成、読取り、更新、削除」</span>」</span>の頭字語。データベースアプリケーションでの一般的な一連の操作です。 多くの場合、どの言語でもすばやく実装でき、比較的単純にデータベースを使用するタイプのアプリケーション (基本的な <span class="bold"><strong>DDL</strong></span>、<span class="bold"><strong>DML</strong></span>、および <span class="bold"><strong>SQL</strong></span> の<span class="bold"><strong>クエリー</strong></span>ステートメント) を示します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">D</h3><dl><dt><a name="glos_dcl"></a><span class="glossterm">DCL</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766463632"></a>
        データ制御言語 (Data Control Language)。権限を管理するための <span class="bold"><strong>SQL</strong></span> ステートメントのセット。 MySQL では、<code class="literal">GRANT</code> および <code class="literal">REVOKE</code> ステートメントから構成されます。 <span class="bold"><strong>DDL</strong></span> および <span class="bold"><strong>DML</strong></span> と対比してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>も参照</p></dd><dt><a name="glos_ddex_provider"></a><span class="glossterm">DDEX プロバイダ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766455520"></a>
        <span class="bold"><strong>Visual Studio</strong></span> 内のデータ設計ツールを使用して、MySQL データベース内のスキーマおよびオブジェクトを操作できる機能。 <span class="bold"><strong>Connector/NET</strong></span> を使用する MySQL アプリケーションの場合、MySQL Visual Studio プラグインは MySQL 5.0 以降で DDEX プロバイダとして機能します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_visual_studio">Visual Studio</a>も参照</p></dd><dt><a name="glos_ddl"></a><span class="glossterm">DDL</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766450704"></a>
        データ定義言語 (Data Definition Language)。個々のテーブル行ではなくデータベース自体を操作するための <span class="bold"><strong>SQL</strong></span> ステートメントのセット。 <code class="literal">CREATE</code>、<code class="literal">ALTER</code>、および <code class="literal">DROP</code> ステートメントのすべての形式を含みます。 <code class="literal">TRUNCATE</code> ステートメントも含まれます。<code class="literal">DELETE FROM <em class="replaceable"><code>table_name</code></em></code> ステートメントと動作が異なるためです (最終的な効果は似ていますが) 。 
      </p><p>
        DDL ステートメントは自動的に現在の<span class="bold"><strong>トランザクション</strong></span>を<span class="bold"><strong>コミット</strong></span>します。それらを<span class="bold"><strong>ロールバック</strong></span>することはできません。
      </p><p>
        <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_online_ddl" title="オンライン DDL">online DDL</a> 機能により、<code class="literal">CREATE INDEX</code>、<code class="literal">DROP INDEX</code>、および多くのタイプの <code class="literal">ALTER TABLE</code> 操作のパフォーマンスが向上します。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl" title="15.12 InnoDB とオンライン DDL">セクション15.12「InnoDB とオンライン DDL」</a>を参照してください。 また、<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> 設定は、<code class="literal">DROP TABLE</code> および <code class="literal">TRUNCATE TABLE</code> 操作の動作に影響を与える可能性があります。 
      </p><p>
        <span class="bold"><strong>DML</strong></span> および <span class="bold"><strong>DCL</strong></span> と対比してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_dcl">DCL</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_dml"></a><span class="glossterm">DML</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766425872"></a>
        データ操作言語。<code class="literal">INSERT</code>、<code class="literal">UPDATE</code> および <code class="literal">DELETE</code> 操作を実行するための一連の <span class="bold"><strong>SQL</strong></span> ステートメント。 <code class="literal">SELECT</code> ステートメントが DML ステートメントと見なされる場合があります。<code class="literal">SELECT ... FOR UPDATE</code> 形式が、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> と同じ、<span class="bold"><strong>ロック</strong></span>に関する考慮事項に従うためです。 
      </p><p>
        <code class="literal">InnoDB</code> テーブルの DML ステートメントは<span class="bold"><strong>トランザクション</strong></span>のコンテキストで動作するため、<span class="bold"><strong>committed</strong></span> または<span class="bold"><strong>ロールバック済</strong></span>を単一ユニットとして使用できます。
      </p><p>
        <span class="bold"><strong>DDL</strong></span> および <span class="bold"><strong>DCL</strong></span> と対比してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_dcl">DCL</a>, <a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_dsn"></a><span class="glossterm">DSN</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766405440"></a>
        <span class="quote">「<span class="quote">「データベースソース名」</span>」</span>の頭字語。 これは、<span class="bold"><strong>Connector/ODBC</strong></span> 内の <span class="bold"><strong>connection</strong></span> 情報のエンコーディングです。 詳細は、<a class="ulink" href="https://dev.mysql.com/doc/connector-odbc/en/connector-odbc-configuration-dsn-windows.html" target="_top">Configuring a Connector/ODBC DSN on Windows</a>を参照してください。 これは、<span class="bold"><strong>Connector/NET</strong></span> で使用される<span class="bold"><strong>接続文字列</strong></span>と同等です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_connection">接続</a>, <a class="glossseealso" href="glossary.html#glos_connection_string">接続文字列</a>, <a class="glossseealso" href="glossary.html#glos_connector_net">Connector/NET</a>, <a class="glossseealso" href="glossary.html#glos_connector_odbc">Connector/ODBC</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">E</h3><dl><dt><a name="glos_eiffel"></a><span class="glossterm">Eiffel</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766396080"></a>
        多くのオブジェクト指向機能を含むプログラミング言語。 その概念の一部は、<span class="bold"><strong>Java</strong></span> および <span class="bold"><strong>C#</strong></span>の開発者によく知られています。 オープンソース Eiffel <span class="bold"><strong>API</strong></span> for MySQL については、<a class="xref" href="connectors-apis.html#apis-eiffel" title="29.13 MySQL Eiffel ラッパー">セクション29.13「MySQL Eiffel ラッパー」</a> を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_api">API</a>, <a class="glossseealso" href="glossary.html#glos_csharp">C#</a>, <a class="glossseealso" href="glossary.html#glos_java">Java</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">F</h3><dl><dt><a name="glos_failover"></a><span class="glossterm">failover</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766388624"></a>
        障害発生時にスタンバイサーバーに自動的に切り替える機能。 MySQL コンテキストでは、フェイルオーバーにはスタンバイデータベースサーバーが含まれます。 多くの場合、アプリケーションサーバーまたはフレームワークによって <span class="bold"><strong>J2EE</strong></span> 環境内でサポートされます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_connector_j">Connector/J</a>, <a class="glossseealso" href="glossary.html#glos_j2ee">J2EE</a>も参照</p></dd><dt><a name="glos_file_per_table"></a><span class="glossterm">file-per-table</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766383936"></a>
        <code class="literal">innodb_file_per_table</code> オプションによって制御される設定の一般名。これは、<code class="literal">InnoDB</code> ファイルの記憶域、機能の可用性および I/O 特性の側面に影響を与える重要な構成オプションです。 MySQL 5.6.7 では、<code class="literal">innodb_file_per_table</code> はデフォルトで有効になっています。 
      </p><p>
        <code class="literal">innodb_file_per_table</code> オプションを有効にすると、<span class="bold"><strong>システムテーブルスペース</strong></span>の共有<span class="bold"><strong>ibdata ファイル</strong></span>ではなく、独自の<span class="bold"><strong>.ibd ファイル</strong></span>にテーブルを作成できます。 テーブルデータが個々の<span class="bold"><strong>.ibd ファイル</strong></span>に格納されている場合、データ <span class="bold"><strong>compression</strong></span> などの機能に必要な<span class="bold"><strong>行フォーマット</strong></span>を柔軟に選択できます。 <code class="literal">TRUNCATE TABLE</code> 操作も高速であり、<code class="literal">InnoDB</code> 用に予約されている残りの領域ではなく、オペレーティングシステムで再利用された領域を使用できます。 
      </p><p>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品は、テーブルがその独自のファイルに格納されるので柔軟性が高くなります。 たとえば、テーブルをバックアップから排除できますが、これは個別のファイルに格納されている場合に限られます。 したがって、この設定は、あまり頻繁にはバックアップされない、または異なるスケジュールでバックアップされるテーブルに適しています。 
      </p><p><a class="glossseealso" href="glossary.html#glos_compressed_row_format">圧縮行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_compression">圧縮</a>, <a class="glossseealso" href="glossary.html#glos_file_format">ファイル形式</a>, <a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_ibdata_file">ibdata ファイル</a>, <a class="glossseealso" href="glossary.html#glos_innodb_file_per_table">innodb_file_per_table</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_row_format">行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>も参照</p></dd><dt><a name="glos_foreign_key_constraint"></a><span class="glossterm">FOREIGN KEY 制約</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766364032"></a>
        <span class="bold"><strong>外部キー</strong></span>関係を通じてデータベース一貫性を維持するタイプの<span class="bold"><strong>制約</strong></span>。 ほかの種類の制約と同様に、データが一貫性を失った場合にデータが挿入または更新されるのを防止できます。ここでは、複数のテーブル内のデータ間の一貫性が失われることが防止されます。 または、<span class="bold"><strong>DML</strong></span> 操作が実行されるときに <code class="literal">FOREIGN KEY</code> 制約によって、外部キー作成時に指定された <code class="literal">ON CASCADE</code> オプションに基づいて、<span class="bold"><strong>子行</strong></span>内のデータが削除されたり、別の値に変更されたり、<span class="bold"><strong>NULL</strong></span> に設定されたりします。 
      </p><p><a class="glossseealso" href="glossary.html#glos_child_table">子テーブル</a>, <a class="glossseealso" href="glossary.html#glos_constraint">制約</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_foreign_key">外部キー</a>, <a class="glossseealso" href="glossary.html#glos_null">NULL</a>も参照</p></dd><dt><a name="glos_fts"></a><span class="glossterm">FTS</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766353216"></a>
        ほとんどのコンテキストで、<span class="bold"><strong>全文検索 (Full-Text Search)</strong></span> の頭字語。 パフォーマンスディスカッションでは、<span class="bold"><strong>フルテーブルスキャン (Full Table Scan)</strong></span> の頭字語の場合があります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_full_table_scan">テーブルの完全スキャン</a>, <a class="glossseealso" href="glossary.html#glos_full_text_search">全文検索</a>も参照</p></dd><dt><a name="glos_fulltext_index"></a><span class="glossterm">FULLTEXT インデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766348288"></a>
        MySQL <span class="bold"><strong>全文検索</strong></span>メカニズムでの<span class="bold"><strong>検索インデックス</strong></span>を保持する、特殊な<span class="bold"><strong>インデックス</strong></span>。 <span class="bold"><strong>ストップワード</strong></span>として指定されたものを飛ばして、カラムの値からの単語を表します。 もともとは、利用できるのは <code class="literal">MyISAM</code> テーブルだけでした。 MySQL 5.6.4 以降では、<span class="bold"><strong>InnoDB</strong></span> テーブルでも利用できます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_full_text_search">全文検索</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_search_index">検索インデックス</a>, <a class="glossseealso" href="glossary.html#glos_stopword">ストップワード</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">G</h3><dl><dt><a name="glos_ga"></a><span class="glossterm">GA</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766337904"></a>
        <span class="quote">「<span class="quote">「一般に使用可能」</span>」</span>は、ソフトウェア製品が<span class="bold"><strong>ベータ</strong></span>から退出し、販売、公式サポートおよび本番で使用できる段階です。
      </p><p><a class="glossseealso" href="glossary.html#glos_beta">ベータ</a>も参照</p></dd><dt><a name="glos_gac"></a><span class="glossterm">GAC</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766333920"></a>
        <span class="quote">「<span class="quote">「グローバルアセンブリキャッシュ」</span>」</span>の頭字語。 <span class="bold"><strong>.NET</strong></span> システムにライブラリ (<span class="bold"><strong>アセンブリ</strong></span>) を格納するための中心的な領域。 物理的にはネストされたフォルダで構成され、<span class="bold"><strong>.NET</strong></span> CLR によって単一の仮想フォルダとして扱われます。 
      </p><p><a class="glossseealso" href="glossary.html#glos__net">.NET</a>, <a class="glossseealso" href="glossary.html#glos_assembly">アセンブリ</a>も参照</p></dd><dt><a name="glos_glassfish"></a><span class="glossterm">Glassfish</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766327712"></a></p><p><a class="glossseealso" href="glossary.html#glos_j2ee">J2EE</a>も参照</p></dd><dt><a name="glos_guid"></a><span class="glossterm">GUID</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766325296"></a>
        <span class="quote">「<span class="quote">「グローバル一意識別子」</span>」</span>の頭字語。異なるデータベース、言語、オペレーティングシステムなど間でデータを関連付けるために使用できる ID 値。 (同じ値が異なるテーブルやデータベースなどで異なるデータを参照する場合がある、順次整数を使用するかわりに使用します。) 古い MySQL バージョンでは、<code class="literal">BINARY(16)</code> として表されていました。 現在、<code class="literal">CHAR(36)</code> として表されています。 MySQL には、GUID 値を文字形式で返す <code class="literal">UUID()</code> 関数と、GUID 値を整数形式で返す <code class="literal">UUID_SHORT()</code> 関数があります。 連続する GUID 値は必ずしも昇順ではないため、大きな InnoDB テーブルの主キーとして使用すると効率的な値ではありません。 
      </p></dd></dl></div><div class="glossdiv"><h3 class="title">H</h3><dl><dt><a name="glos_hdd"></a><span class="glossterm">HDD</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766317840"></a>
        <span class="quote">「<span class="quote">「ハードディスクドライブ」</span>」</span>の頭字語。 <span class="bold"><strong>SSD</strong></span> と対比されることが多く、スピニングプラッターを使用するストレージメディアを指します。 そのパフォーマンス特性は<span class="bold"><strong>ディスクベース</strong></span>ワークロードのスループットに影響を与えることがあります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_disk_based">ディスクベース</a>, <a class="glossseealso" href="glossary.html#glos_ssd">SSD</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">I</h3><dl><dt><a name="glos_io_bound"></a><span class="glossterm">I/O バウンド</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_disk_bound">ディスクバウンド</a>も参照</p></dd><dt><a name="glos_ib_file_set"></a><span class="glossterm">ib-file セット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766310400"></a>
        MySQL データベース内で <code class="literal">InnoDB</code> によって管理される一連のファイル: <span class="bold"><strong>システムテーブルスペース</strong></span>、<span class="bold"><strong>file-per-table</strong></span> テーブルスペースファイルおよび<span class="bold"><strong>redo ログ</strong></span>ファイル。 MySQL のバージョンおよび <code class="literal">InnoDB</code> の構成によっては、<span class="bold"><strong>一般テーブルスペース</strong></span>、<span class="bold"><strong>一時テーブルスペース</strong></span>および<span class="bold"><strong>undo テーブルスペース</strong></span>ファイルも含まれる場合があります。 この用語は、MySQL データベース内の <code class="literal">InnoDB</code> によって管理される一連のファイルを指すために、<code class="literal">InnoDB</code> のファイル構造および形式の詳細な説明で使用されることがあります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_database">データベース</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_general_tablespace">一般テーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_temporary_tablespace">一時テーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_undo_tablespace">Undo テーブルスペース</a>も参照</p></dd><dt><a name="glos_ibbackup_logfile"></a><span class="glossterm">ibbackup_logfile</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766287152"></a>
        <span class="bold"><strong>ホットバックアップ</strong></span>操作中に <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品により作成される補助的なバックアップファイル。 ここには、バックアップの実行中に行われたデータ変更に関する情報が含まれます。 <code class="literal">ibbackup_logfile</code> などの初期バックアップファイルは、バックアップ操作中に行われた変更がまだ組み込まれていないので、<span class="bold"><strong>raw バックアップ</strong></span>と呼ばれます。 raw バックアップファイルへの<span class="bold"><strong>適用</strong></span>ステップを実行したあと、結果として得られるファイルは、最終データ変更を含んでおり、<span class="bold"><strong>準備されたバックアップ</strong></span>と呼ばれます。 この段階で、<code class="literal">ibbackup_logfile</code> ファイルは必要なくなります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_apply">適用</a>, <a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_prepared_backup">準備されたバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_raw_backup">raw バックアップ</a>も参照</p></dd><dt><a name="glos_ibdata_file"></a><span class="glossterm">ibdata ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766275984"></a>
        <code class="literal">InnoDB</code> <span class="bold"><strong>システムテーブルスペース</strong></span>を構成する、<code class="literal">ibdata1</code>、<code class="literal">ibdata2</code> などの名前を持つファイルのセット。 システムテーブルスペースの <code class="filename">ibdata</code> ファイルに存在する構造およびデータの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-system-tablespace" title="15.6.3.1 システムテーブルスペース">セクション15.6.3.1「システムテーブルスペース」</a> を参照してください。 
      </p><p>
        <code class="literal">ibdata</code> ファイルの増加は、<code class="literal">innodb_autoextend_increment</code> 構成オプションの影響を受けます。
      </p><p><a class="glossseealso" href="glossary.html#glos_change_buffer">変更バッファー</a>, <a class="glossseealso" href="glossary.html#glos_data_dictionary">データディクショナリ</a>, <a class="glossseealso" href="glossary.html#glos_doublewrite_buffer">二重書き込みバッファー</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_innodb_file_per_table">innodb_file_per_table</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_undo_log">Undo ログ</a>も参照</p></dd><dt><a name="glos_ibtmp_file"></a><span class="glossterm">ibtmp ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766262624"></a>
        圧縮されていない <code class="literal">InnoDB</code> <span class="bold"><strong>一時テーブル</strong></span>および関連オブジェクトの <code class="literal">InnoDB</code> <span class="bold"><strong>一時テーブルスペース</strong></span> <span class="bold"><strong>データファイル</strong></span>。 構成ファイルオプション <code class="literal">innodb_temp_data_file_path</code> を使用すると、ユーザーは一時テーブルスペースデータファイルの相対パスを定義できます。 <code class="literal">innodb_temp_data_file_path</code> が指定されない場合のデフォルト動作は、データディレクトリ内に <code class="filename">ibdata1</code> と一緒に、<code class="filename">ibtmp1</code> という名前の単一自動拡張 12M バイトデータファイルを作成することです。 
      </p><p><a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_temporary_table">一時テーブル</a>, <a class="glossseealso" href="glossary.html#glos_temporary_tablespace">一時テーブルスペース</a>も参照</p></dd><dt><a name="glos_ib_logfile"></a><span class="glossterm">ib_logfile</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766296464"></a>
        通常は <code class="literal">ib_logfile0</code> および <code class="literal">ib_logfile1</code> という名前が付けられ、<span class="bold"><strong>Redo ログ</strong></span>を形成するファイルのセット。 <span class="bold"><strong>ロググループ</strong></span>と呼ばれることもあります。 これらのファイルには、<code class="literal">InnoDB</code> テーブルのデータを変更しようとするステートメントが記録されます。 これらのステートメントは、クラッシュ後の起動時に、未完了のトランザクションで書き込まれたデータを修正するために自動的に再現されます。 
      </p><p>
        このデータは手動リカバリには使用できません。このタイプの操作には、<span class="bold"><strong>バイナリログ</strong></span>を使用してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_binary_log">バイナリログ</a>, <a class="glossseealso" href="glossary.html#glos_log_group">ロググループ</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>も参照</p></dd><dt><a name="glos_ilist"></a><span class="glossterm">ilist</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766250928"></a>
        <code class="literal">InnoDB</code> <span class="bold"><strong>FULLTEXT インデックス</strong></span>内では、トークン (特定の単語) のドキュメント ID と位置情報で構成されるデータ構造。
      </p><p><a class="glossseealso" href="glossary.html#glos_fulltext_index">FULLTEXT インデックス</a>も参照</p></dd><dt><a name="glos_information_schema"></a><span class="glossterm">INFORMATION_SCHEMA</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766246816"></a>
        MySQL <span class="bold"><strong>データディクショナリ</strong></span>へのクエリーインタフェースを提供する<span class="bold"><strong>データベース</strong></span>の名前。 (この名前は ANSI SQL 標準で定義されています。) データベースに関する情報 (メタデータ) を調べるには、構造化されていない出力を返す <code class="literal">SHOW</code> コマンドを使用する代わりに、<code class="literal">INFORMATION_SCHEMA.TABLES</code> や <code class="literal">INFORMATION_SCHEMA.COLUMNS</code> などのテーブルを照会できます。 
      </p><p>
        <code class="literal">INFORMATION_SCHEMA</code> データベースには、<code class="literal">InnoDB</code> データディクショナリへのクエリーインタフェースを提供する <span class="bold"><strong>InnoDB</strong></span> 固有のテーブルも含まれています。 これらのテーブルは、データベースの構造を確認するのではなく、パフォーマンスの監視、チューニングおよびトラブルシューティングに役立つように、<code class="literal">InnoDB</code> テーブルの動作に関するリアルタイム情報を取得するために使用します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_data_dictionary">データディクショナリ</a>, <a class="glossseealso" href="glossary.html#glos_database">データベース</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>も参照</p></dd><dt><a name="glos_innodb"></a><span class="glossterm">InnoDB</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766235072"></a>
        高いパフォーマンスと、信頼性、堅牢性、および同時アクセスのための<span class="bold"><strong>トランザクション</strong></span>機能とを結合する MySQL コンポーネント。 これは <span class="bold"><strong>ACID</strong></span> 設計概念を具体化したものです。 <span class="bold"><strong>ストレージエンジン</strong></span>として表現され、<code class="literal">ENGINE=INNODB</code> 句で作成または変更されたテーブルを処理します。 アーキテクチャーの詳細および管理手順については<a class="xref" href="innodb-storage-engine.html" title="第 15 章 InnoDB ストレージエンジン">第15章「<i>InnoDB ストレージエンジン</i>」</a>、パフォーマンスのアドバイスについては<a class="xref" href="optimization.html#optimizing-innodb" title="8.5 InnoDB テーブルの最適化">セクション8.5「InnoDB テーブルの最適化」</a>を参照してください。 
      </p><p>
        MySQL 5.5 以上では、<code class="literal">InnoDB</code> が新しいテーブルのデフォルトのストレージエンジンであり、<code class="literal">ENGINE=INNODB</code> 句は必要ありません。
      </p><p>
        <code class="literal">InnoDB</code> テーブルは、<span class="bold"><strong>ホットバックアップ</strong></span>に最適です。 通常の処理を妨げることなく MySQL Server をバックアップできる <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品の詳細は、<a class="xref" href="mysql-enterprise.html#mysql-enterprise-backup" title="30.2 MySQL Enterprise Backup の概要">セクション30.2「MySQL Enterprise Backup の概要」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_storage_engine">ストレージエンジン</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_innodb_autoinc_lock_mode"></a><span class="glossterm">innodb_autoinc_lock_mode</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766219904"></a>
        <code class="literal">innodb_autoinc_lock_mode</code> オプションは、<span class="bold"><strong>自動インクリメントロック</strong></span>に使用されるアルゴリズムを制御します。 自動インクリメントする<span class="bold"><strong>主キー</strong></span>がある場合は、<code class="literal">innodb_autoinc_lock_mode=1</code> 設定でのみステートメントベースレプリケーションを使用できます。 この設定は、トランザクション内の複数行挿入が連続自動インクリメント値を受け取るため、<span class="emphasis"><em>連続</em></span>ロックモードと呼ばれます。 挿入操作でより高い並列性を許可する <code class="literal">innodb_autoinc_lock_mode=2</code> を使用する場合は、ステートメントベースレプリケーションではなく行ベースレプリケーションを使用してください。 この設定は<span class="emphasis"><em>インターリーブ</em></span>ロックモードと呼ばれます。これは、同時に実行される複数行の挿入ステートメントがインターリーブされる <span class="bold"><strong>auto-increment</strong></span> 値を受信できるためです。 互換性の目的以外は、<code class="literal">innodb_autoinc_lock_mode=0</code> の設定を使用しないでください。 
      </p><p>
        連続ロックモード (<code class="literal">innodb_autoinc_lock_mode=1</code>) は、MySQL 8.0.3 より前のデフォルト設定です。 MySQL 8.0.3 の時点では、インターリーブロックモード (<code class="literal">innodb_autoinc_lock_mode=2</code>) がデフォルトであり、デフォルトのレプリケーションタイプとしてステートメントベースから行ベースのレプリケーションへの変更が反映されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_auto_increment">自動インクリメント</a>, <a class="glossseealso" href="glossary.html#glos_auto_increment_locking">自動インクリメントロック</a>, <a class="glossseealso" href="glossary.html#glos_mixed_mode_insert">混在モード挿入</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>も参照</p></dd><dt><a name="glos_innodb_file_per_table"></a><span class="glossterm">innodb_file_per_table</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766203936"></a>
        <code class="literal">InnoDB</code> ファイルストレージの様々な側面、機能の可用性および I/O 特性に影響する重要な構成オプション。 MySQL 5.6.7 以降ではデフォルトで有効になっています。 <code class="literal">innodb_file_per_table</code> オプションは、<span class="bold"><strong>file-per-table</strong></span> モードをオンにします。 このモードを有効にすると、新しく作成された <code class="literal">InnoDB</code> テーブルおよび関連するインデックスを<span class="bold"><strong>システムテーブルスペース</strong></span>の外部の file-per-table <span class="bold"><strong>.ibd ファイル</strong></span>に格納できます。 
      </p><p>
        このオプションは、<code class="literal">DROP TABLE</code> や <code class="literal">TRUNCATE TABLE</code> など、いくつかの SQL ステートメントのパフォーマンスおよびストレージに関する考慮事項に影響します。
      </p><p>
        <code class="literal">innodb_file_per_table</code> オプションを有効にすると、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> のテーブル <span class="bold"><strong>compression</strong></span> や名前付きテーブルバックアップなどの機能を利用できます。
      </p><p>
        詳細は、<code class="literal">innodb_file_per_table</code> および <a class="xref" href="innodb-storage-engine.html#innodb-file-per-table-tablespaces" title="15.6.3.2 File-Per-Table テーブルスペース">セクション15.6.3.2「File-Per-Table テーブルスペース」</a> を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_compression">圧縮</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>も参照</p></dd><dt><a name="glos_innodb_lock_wait_timeout"></a><span class="glossterm">innodb_lock_wait_timeout</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766185888"></a>
        <code class="literal">innodb_lock_wait_timeout</code> オプションは、共有リソースが利用できるようになるまで<span class="bold"><strong>待機</strong></span>するか、または放棄してエラーを処理したり、再試行したり、アプリケーションで代替処理を行ったりするかのバランスを設定します。 指定した時間を超えて <span class="bold"><strong>lock</strong></span> を取得するのを待機している <code class="literal">InnoDB</code> トランザクションをロールバックします。 特に、異なるストレージエンジンで制御される複数のテーブルへの更新によって<span class="bold"><strong>デッドロック</strong></span>が発生した場合に役立ちます。このようなデッドロックは自動的には<span class="bold"><strong>検出</strong></span>されません。 
      </p><p><a class="glossseealso" href="glossary.html#glos_deadlock">デッドロック</a>, <a class="glossseealso" href="glossary.html#glos_deadlock_detection">デッドロック検出</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_wait">待機</a>も参照</p></dd><dt><a name="glos_innodb_strict_mode"></a><span class="glossterm">innodb_strict_mode</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766176336"></a>
        <code class="literal">innodb_strict_mode</code> オプションは、<code class="literal">InnoDB</code> が<span class="bold"><strong>strict モード</strong></span>で動作するかどうかを制御します。通常は警告として処理される条件では、かわりにエラーが発生します (基礎となるステートメントは失敗します)。
      </p><p><a class="glossseealso" href="glossary.html#glos_strict_mode">厳密モード</a>も参照</p></dd><dt><a name="glos_interceptor"></a><span class="glossterm">interceptor</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766171056"></a>
        アプリケーションの一部の側面を計測またはデバッグするためのコード。アプリケーション自体のソースを再コンパイルまたは変更せずに有効にできます。
      </p><p><a class="glossseealso" href="glossary.html#glos_command_interceptor">コマンドインタセプタ</a>, <a class="glossseealso" href="glossary.html#glos_connector_j">Connector/J</a>, <a class="glossseealso" href="glossary.html#glos_connector_net">Connector/NET</a>, <a class="glossseealso" href="glossary.html#glos_exception_interceptor">例外インターセプタ</a>も参照</p></dd><dt><a name="glos_iops"></a><span class="glossterm">IOPS</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766166160"></a>
        <span class="bold"><strong>1 秒あたりの I/O 操作 (I/O Operations Per Second) </strong></span>の頭字語。 ビジーシステム、特に <span class="bold"><strong>OLTP</strong></span> アプリケーションの一般的な測定基準。 ストレージデバイスが処理できる最大値にこの値が近い場合、アプリケーションは<span class="bold"><strong>ディスクバウンド</strong></span>になり、<span class="bold"><strong>スケーラビリティー</strong></span>を制限する場合があります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_disk_bound">ディスクバウンド</a>, <a class="glossseealso" href="glossary.html#glos_oltp">OLTP</a>, <a class="glossseealso" href="glossary.html#glos_scalability">スケーラビリティー</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">J</h3><dl><dt><a name="glos_j2ee"></a><span class="glossterm">J2EE</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766158544"></a>
        Java プラットフォーム、Enterprise Edition: Oracle エンタープライズ Java プラットフォーム。 これは、エンタープライズクラスの Java アプリケーションの API およびランタイム環境で構成されます。 詳細は、<a class="ulink" href="http://www.oracle.com/technetwork/java/javaee/overview/index.html" target="_top">http://www.oracle.com/technetwork/java/javaee/overview/index.html</a>を参照してください。 MySQL アプリケーションでは、通常、<span class="bold"><strong>Connector/J</strong></span> をデータベースアクセスに使用し、<span class="bold"><strong>Tomcat</strong></span> や <span class="bold"><strong>JBoss</strong></span> などのアプリケーションサーバーを使用して中間層の作業を処理し、オプションで <span class="bold"><strong>Spring</strong></span> などのフレームワークを処理します。 多くの場合、J2EE スタック内で提供されるデータベース関連の機能には、<span class="bold"><strong>接続プール</strong></span>および <span class="bold"><strong>failover</strong></span> のサポートが含まれます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_connection_pool">接続プール</a>, <a class="glossseealso" href="glossary.html#glos_connector_j">Connector/J</a>, <a class="glossseealso" href="glossary.html#glos_failover">failover</a>, <a class="glossseealso" href="glossary.html#glos_java">Java</a>, <a class="glossseealso" href="glossary.html#glos_jboss">JBoss</a>, <a class="glossseealso" href="glossary.html#glos_spring">Spring</a>, <a class="glossseealso" href="glossary.html#glos_tomcat">Tomcat</a>も参照</p></dd><dt><a name="glos_java"></a><span class="glossterm">Java</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766146048"></a>
        高性能で豊富な組込み機能とデータ型、オブジェクト指向メカニズム、広範な標準ライブラリ、および幅広い再利用可能なサードパーティモジュールを組み合せたプログラミング言語。 エンタープライズ開発は、多くのフレームワーク、アプリケーションサーバーおよびその他のテクノロジでサポートされています。 その構文の多くは、<span class="bold"><strong>C</strong></span> および <span class="bold"><strong>C++</strong></span> の開発者によく知られています。 MySQL を使用して Java アプリケーションを作成するには、<span class="bold"><strong>Connector/J</strong></span> と呼ばれる <span class="bold"><strong>JDBC</strong></span> ドライバを使用します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_c">C</a>, <a class="glossseealso" href="glossary.html#glos_connector_j">Connector/J</a>, <a class="glossseealso" href="glossary.html#glos_cplusplus">C++</a>, <a class="glossseealso" href="glossary.html#glos_jdbc">JDBC</a>も参照</p></dd><dt><a name="glos_jboss"></a><span class="glossterm">JBoss</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766138256"></a></p><p><a class="glossseealso" href="glossary.html#glos_j2ee">J2EE</a>も参照</p></dd><dt><a name="glos_jdbc"></a><span class="glossterm">JDBC</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766135888"></a>
        <span class="bold"><strong>Java</strong></span> アプリケーションからのデータベースアクセス用の <span class="bold"><strong>API</strong></span> である<span class="quote">「<span class="quote">「Java データベース接続」</span>」</span>の略称。 MySQL アプリケーションを作成する Java 開発者は、<span class="bold"><strong>Connector/J</strong></span> コンポーネントを JDBC ドライバとして使用します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_api">API</a>, <a class="glossseealso" href="glossary.html#glos_connector_j">Connector/J</a>, <a class="glossseealso" href="glossary.html#glos_j2ee">J2EE</a>, <a class="glossseealso" href="glossary.html#glos_java">Java</a>も参照</p></dd><dt><a name="glos_jndi"></a><span class="glossterm">JNDI</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766128880"></a></p><p><a class="glossseealso" href="glossary.html#glos_java">Java</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">K</h3><dl><dt><a name="glos_keystore"></a><span class="glossterm">keystore</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766116976"></a></p><p><a class="glossseealso" href="glossary.html#glos_ssl">SSL</a>も参照</p></dd><dt><a name="glos_key_block_size"></a><span class="glossterm">KEY_BLOCK_SIZE</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766125760"></a>
        <span class="bold"><strong>圧縮行形式</strong></span>を使用する <code class="literal">InnoDB</code> テーブル内のデータページのサイズを指定するオプション。 デフォルトは 8K バイトです。 値を小さくすると、行サイズと圧縮比率の組み合わせによって内部制限に達する恐れがあります。 
      </p><p>
        <code class="literal">MyISAM</code> テーブルの場合、<code class="literal">KEY_BLOCK_SIZE</code> はオプションで、インデックスキーブロックに使用するサイズをバイト単位で指定します。 この値はヒントとして扱われます。必要に応じて、異なるサイズが使用される可能性があります。 個々のインデックス定義に指定された <code class="literal">KEY_BLOCK_SIZE</code> 値は、テーブルレベルの <code class="literal">KEY_BLOCK_SIZE</code> 値をオーバーライドします。 
      </p><p><a class="glossseealso" href="glossary.html#glos_compressed_row_format">圧縮行フォーマット</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">L</h3><dl><dt><a name="glos_libmysql"></a><span class="glossterm">libmysql</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766113680"></a>
        <span class="bold"><strong>libmysqlclient</strong></span> ライブラリの非公式名。
      </p><p><a class="glossseealso" href="glossary.html#glos_libmysqlclient">libmysqlclient</a>も参照</p></dd><dt><a name="glos_libmysqlclient"></a><span class="glossterm">libmysqlclient</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766110400"></a>
        <code class="filename">libmysqlclient.a</code> または <code class="filename">libmysqlclient.so</code> という名前のライブラリファイル。通常、<span class="bold"><strong>C</strong></span> で記述された <span class="bold"><strong>client</strong></span> プログラムにリンクされています。 非公式には <span class="bold"><strong>libmysql</strong></span> または <span class="bold"><strong>mysqlclient</strong></span> ライブラリと呼ばれることもあります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_client">クライアント</a>, <a class="glossseealso" href="glossary.html#glos_libmysql">libmysql</a>, <a class="glossseealso" href="glossary.html#glos_mysqlclient">mysqlclient</a>も参照</p></dd><dt><a name="glos_libmysqld"></a><span class="glossterm">libmysqld</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766102016"></a>
        この<span class="bold"><strong>埋込み</strong></span> MySQL サーバーライブラリを使用すると、<span class="bold"><strong>client</strong></span> アプリケーション内でフル機能の MySQL サーバーを実行できます。 この主なメリットは組み込みアプリケーションの速度の向上と管理の単純化です。 <span class="bold"><strong>libmysqlclient</strong></span> ではなく <code class="literal">libmysqld</code> ライブラリとリンクします。 API は、これらの 3 つのライブラリすべてで同一です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_client">クライアント</a>, <a class="glossseealso" href="glossary.html#glos_embedded">埋込み</a>, <a class="glossseealso" href="glossary.html#glos_libmysql">libmysql</a>, <a class="glossseealso" href="glossary.html#glos_libmysqlclient">libmysqlclient</a>も参照</p></dd><dt><a name="glos_localhost"></a><span class="glossterm">localhost</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766094048"></a></p><p><a class="glossseealso" href="glossary.html#glos_connection">接続</a>も参照</p></dd><dt><a name="glos_lock_mode"></a><span class="glossterm">lock mode</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766091680"></a>
        共有 <span class="bold"><strong>lock</strong></span> を使用すると、<span class="bold"><strong>トランザクション</strong></span>で行を読み取ることができます。 複数のトランザクションが同時にその同じ行で S ロックを獲得できます。 
      </p><p>
        排他 (X) ロックでは、トランザクションは行を更新または削除できます。 ほかのトランザクションは、同時にその同じ行でどのようなロックも獲得できません。 
      </p><p>
        <span class="bold"><strong>インテンションロック</strong></span>はテーブルに適用され、トランザクションがテーブルの行で取得するロックの種類を示すために使用されます。 トランザクションごとに異なる種類のインテンションロックを同じテーブルで獲得できますが、最初のトランザクションがあるテーブルでインテンション排他 (IX) ロックを獲得すると、ほかのトランザクションはそのテーブルで S または X ロックを獲得できません。 反対に、最初のトランザクションがあるテーブルでインテンション共有 (IS) ロックを獲得すると、ほかのトランザクションはそのテーブルで X ロックを獲得できません。 2 フェーズプロセスは、ロックおよび互換性のある対応操作をブロックせずに、ロックリクエストを順番に解決できます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_intention_lock">インテンションロック</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_loose_"></a><span class="glossterm">loose_</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766082688"></a>
        サーバー <span class="bold"><strong>startup</strong></span> の後に <code class="literal">InnoDB</code> 構成オプションに追加された接頭辞。そのため、現在のレベルの MySQL で認識されない新しい構成オプションは起動に失敗しません。 MySQL は、このプリフィクスで始まる構成オプションを処理しますが、プリフィクスに続く部分が認識されるオプションでない場合、エラーではなく警告を返します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_startup">起動</a>も参照</p></dd><dt><a name="glos_lru"></a><span class="glossterm">LRU</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766077920"></a>
        <span class="quote">「<span class="quote">「最低使用頻度」</span>」</span>の頭字語。記憶域を管理するための一般的な方法です。 より新しい項目をキャッシュするための領域が必要なときは、最近使用されていない項目は<span class="bold"><strong>削除</strong></span>されます。 <code class="literal">InnoDB</code> では、<span class="bold"><strong>バッファプール</strong></span>内で <span class="bold"><strong>pages</strong></span> を管理するために LRU メカニズムがデフォルトで使用されますが、<span class="bold"><strong>全テーブルスキャン</strong></span>中など、ページが一度のみ読み取られる可能性がある場合は例外が発生します。 LRU アルゴリズムのこのバリエーションは<span class="bold"><strong>ミッドポイント挿入戦略</strong></span>と呼ばれます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool" title="15.5.1 バッファプール">セクション15.5.1「バッファプール」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_eviction">エビクション</a>, <a class="glossseealso" href="glossary.html#glos_full_table_scan">テーブルの完全スキャン</a>, <a class="glossseealso" href="glossary.html#glos_midpoint_insertion_strategy">ミッドポイント挿入戦略</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>も参照</p></dd><dt><a name="glos_lsn"></a><span class="glossterm">LSN</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766067232"></a>
        <span class="quote">「<span class="quote">ログシーケンス番号</span>」</span>の頭字語。 この任意の増加し続ける値は、<span class="bold"><strong>Redo ログ</strong></span>に記録される操作に対応する時点を表します。 (この時点は、<span class="bold"><strong>トランザクション</strong></span>境界を意識しません。1 つ以上のトランザクションの中間になることがあります。) これは、<span class="bold"><strong>クラッシュリカバリ</strong></span>の実行中および<span class="bold"><strong>バッファプール</strong></span>の管理のために <code class="literal">InnoDB</code> によって内部的に使用されます。 
      </p><p>
        MySQL 5.6.3 より前では、LSN は 4 バイト符号なし整数でした。 LSN は、MySQL 5.6.3 で 8 バイト符号なし整数になりました。追加サイズ情報を格納するために追加バイトが必要だったので、Redo ログファイルサイズ限度が 4G バイトから 512G バイトに増加したためです。 MySQL 5.6.3 以降でビルドされたアプリケーションのうち LSN 値を使用するものは、32 ビット変数ではなく 64 ビット変数を使用して LSN 値を格納および比較することをお勧めします。 
      </p><p>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品では、<span class="bold"><strong>増分バックアップ</strong></span>を取得する時点を表す LSN を指定できます。 該当する LSN は、<span class="command"><strong>mysqlbackup</strong></span> コマンドの出力で表示されます。 完全バックアップの時点に対応する LSN がわかれば、後続の増分バックアップを取得するためにその値を指定でき、その出力には次の増分バックアップのもう 1 つの LSN が含まれます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_crash_recovery">クラッシュリカバリ</a>, <a class="glossseealso" href="glossary.html#glos_incremental_backup">増分バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">M</h3><dl><dt><a name="glos_mdl"></a><span class="glossterm">MDL</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766052832"></a>
        <span class="quote">「<span class="quote">「メタデータロック」</span>」</span>の頭字語。
      </p><p><a class="glossseealso" href="glossary.html#glos_metadata_lock">メタデータロック</a>も参照</p></dd><dt><a name="glos_memcached"></a><span class="glossterm">memcached</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766049888"></a>
        多くの MySQL および <span class="bold"><strong>NoSQL</strong></span> ソフトウェアスタックで広く使用されているコンポーネント。単一値を高速で読み書きでき、結果全体をメモリーにキャッシュします。 アプリケーションは従来、永続的ストレージに同じデータを MySQL データベースに書き込むため、またはまだメモリーにキャッシュされていない場合は MySQL データベースからデータを読み取るために、特別なロジックを必要としていました。 アプリケーションでは、多くの言語のクライアントライブラリでサポートされている単純な <span class="command"><strong>memcached</strong></span> プロトコルを使用して、<code class="literal">InnoDB</code> または <code class="literal">NDB</code> テーブルを使用して MySQL サーバーと直接通信できるようになりました。 MySQL テーブルへのこれらの NoSQL インタフェースを使用すると、アプリケーションは SQL ステートメントを直接発行するよりも高い読取りおよび書込みパフォーマンスを実現でき、インメモリーキャッシュ用に <span class="command"><strong>memcached</strong></span> がすでに組み込まれているシステムのアプリケーションロジックおよびデプロイメント構成を簡略化できます。 
      </p><p>
        <code class="literal">InnoDB</code> テーブルへの <span class="command"><strong>memcached</strong></span> インタフェースは、MySQL 5.6 以上で使用できます。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached" title="15.20 InnoDB memcached プラグイン">セクション15.20「InnoDB memcached プラグイン」</a> を参照してください。 <code class="literal">NDB</code> テーブルへの <span class="command"><strong>memcached</strong></span> インタフェースは NDB Cluster 7.2 以降で使用できます。詳細は <a class="ulink" href="http://dev.mysql.com/doc/ndbapi/en/ndbmemcache.html" target="_top">http://dev.mysql.com/doc/ndbapi/en/ndbmemcache.html</a> を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_nosql">NoSQL</a>も参照</p></dd><dt><a name="glos_mm_mysql"></a><span class="glossterm">MM.MySQL</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766035904"></a>
        MySQL 製品と統合されたときに <span class="bold"><strong>Connector/J</strong></span> に進化した MySQL 用の古い JDBC ドライバ。
      </p><p><a class="glossseealso" href="glossary.html#glos_connector_j">Connector/J</a>も参照</p></dd><dt><a name="glos_mtr"></a><span class="glossterm">mtr</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_mini_transaction">ミニトランザクション</a>も参照</p></dd><dt><a name="glos_mvcc"></a><span class="glossterm">MVCC</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766030928"></a>
        <span class="quote">「<span class="quote">「マルチバージョン同時実行性制御」</span>」</span>の頭字語。 この手法により、特定の<span class="bold"><strong>分離レベル</strong></span>を使用した <code class="literal">InnoDB</code> <span class="bold"><strong>transactions</strong></span> は<span class="bold"><strong>読取り一貫性</strong></span>操作を実行できます。つまり、他のトランザクションによって更新されている行をクエリーして、それらの更新が発生する前の値を確認できます。 これは、ほかのトランザクションが保持している<span class="bold"><strong>ロック</strong></span>のために待機することなく、クエリーが進行できるようにすることによって、<span class="bold"><strong>並列性</strong></span>を高める強力な方法です。 
      </p><p>
        この方法は、データベース世界で共通のものではありません。 ほかのデータベース製品やほかの MySQL ストレージエンジンの中には、これをサポートしないものがあります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_consistent_read">一貫性読み取り</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_my_cnf"></a><span class="glossterm">my.cnf</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766019744"></a>
        MySQL <span class="bold"><strong>オプションファイル</strong></span>の名前 (Unix または Linux システムの場合)。
      </p><p><a class="glossseealso" href="glossary.html#glos_my_ini">my.ini</a>, <a class="glossseealso" href="glossary.html#glos_option_file">オプションファイル</a>も参照</p></dd><dt><a name="glos_my_ini"></a><span class="glossterm">my.ini</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766015744"></a>
        MySQL <span class="bold"><strong>オプションファイル</strong></span>の名前 (Windows システムの場合)。
      </p><p><a class="glossseealso" href="glossary.html#glos_my_cnf">my.cnf</a>, <a class="glossseealso" href="glossary.html#glos_option_file">オプションファイル</a>も参照</p></dd><dt><a name="glos_myodbc_drivers"></a><span class="glossterm">MyODBC ドライバ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766011776"></a>
        <span class="bold"><strong>Connector/ODBC</strong></span> の廃止された名前。
      </p><p><a class="glossseealso" href="glossary.html#glos_connector_odbc">Connector/ODBC</a>も参照</p></dd><dt><a name="glos_mysql"></a><span class="glossterm">mysql</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766008144"></a>
        <span class="command"><strong>mysql</strong></span> プログラムは MySQL データベース用のコマンド行インタープリターです。 <span class="bold"><strong>SQL</strong></span> ステートメントを処理し、<span class="command"><strong>mysqld</strong></span> デーモンにリクエストを渡すことによって <code class="literal">SHOW TABLES</code> などの MySQL 固有コマンドも処理します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_mysqld">mysqld</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>も参照</p></dd><dt><a name="glos_mysql_enterprise_backup"></a><span class="glossterm">MySQL Enterprise Backup</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318766001312"></a>
        MySQL データベースの<span class="bold"><strong>ホットバックアップ</strong></span>を実行するライセンス製品。 <code class="literal">InnoDB</code> テーブルをバックアップする場合、最も効率的で柔軟性がありますが、<code class="literal">MyISAM</code> およびその他の種類のテーブルをバックアップすることもできます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>も参照</p></dd><dt><a name="glos_mysqlbackup_command"></a><span class="glossterm">mysqlbackup コマンド</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765995056"></a>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品のコマンド行ツール。 <code class="literal">InnoDB</code> テーブルに対して<span class="bold"><strong>ホットバックアップ</strong></span>操作を実行し、<code class="literal">MyISAM</code> およびその他の種類のテーブルに対して <a class="link" href="glossary.html#glos_warm_backup" title="ウォームバックアップ">warm backup</a> を実行します。 このコマンドの詳細は、<a class="xref" href="mysql-enterprise.html#mysql-enterprise-backup" title="30.2 MySQL Enterprise Backup の概要">セクション30.2「MySQL Enterprise Backup の概要」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_warm_backup">ウォームバックアップ</a>も参照</p></dd><dt><a name="glos_mysqlclient"></a><span class="glossterm">mysqlclient</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765986016"></a>
        ファイル <span class="bold"><strong>libmysqlclient</strong></span> によって実装されるライブラリの非公式名で、拡張子は <code class="literal">.a</code> または <code class="literal">.so</code> です。
      </p><p><a class="glossseealso" href="glossary.html#glos_libmysqlclient">libmysqlclient</a>も参照</p></dd><dt><a name="glos_mysqld"></a><span class="glossterm">mysqld</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765981152"></a>
        <span class="command"><strong>mysqld</strong></span> (MySQL Server とも呼ばれる) は、MySQL インストールでほとんどの作業を実行する単一のマルチスレッドプログラムです。 追加プロセスは生成されません。 MySQL Server は、データベース、テーブル、およびログファイルやステータスファイルなどのその他の情報を含む MySQL データディレクトリへのアクセスを管理します。 
      </p><p>
        <span class="command"><strong>mysqld</strong></span> は、Unix デーモンまたは Windows サービスとして実行され、リクエストを常に待機し、バックグラウンドでメンテナンス作業を実行します。
      </p><p><a class="glossseealso" href="glossary.html#glos_instance">インスタンス</a>, <a class="glossseealso" href="glossary.html#glos_mysql">mysql</a>も参照</p></dd><dt><a name="glos_mysqldb"></a><span class="glossterm">MySQLdb</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765975216"></a>
        MySQL <span class="bold"><strong>Python API</strong></span> の基礎を形成するオープンソース <span class="bold"><strong>Python</strong></span> モジュールの名前。
      </p><p><a class="glossseealso" href="glossary.html#glos_python">Python</a>, <a class="glossseealso" href="glossary.html#glos_python_api">Python API</a>も参照</p></dd><dt><a name="glos_mysqldump"></a><span class="glossterm">mysqldump</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765970448"></a>
        データベース、テーブル、およびテーブルデータの組み合わせの<span class="bold"><strong>論理バックアップ</strong></span>を実行するコマンド。 結果は、元のスキーマオブジェクトまたはデータ、あるいはその両方を再現する SQL ステートメントです。 相当な量のデータの場合、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> などの<span class="bold"><strong>物理バックアップ</strong></span>ソリューションが高速です (特に<span class="bold"><strong>リストア</strong></span>操作で)。 
      </p><p><a class="glossseealso" href="glossary.html#glos_logical_backup">論理バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_physical_backup">物理バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_restore">リストア</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">N</h3><dl><dt><a name="glos_nosql"></a><span class="glossterm">NoSQL</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765962224"></a>
        データ読み書きの主要なメカニズムとして <span class="bold"><strong>SQL</strong></span> 言語を使用しない、一連のデータアクセステクノロジの一般的な用語。 NoSQL テクノロジの中には、単一値の読み取りと買い込みだけを受け入れるキー値ストアとして機能するものがあります。<span class="bold"><strong>ACID</strong></span> 原理の制限を緩和するものや、事前に計画された<span class="bold"><strong>スキーマ</strong></span>が不要なものもあります。 MySQL ユーザーは、<span class="bold"><strong>memcached</strong></span> API を使用して何らかの MySQL テーブルに直接アクセスすることにより、速度と簡略化のための NoSQL スタイル処理と、柔軟性と利便性のための SQL 操作を組み合わせることができます。 <code class="literal">InnoDB</code> テーブルへの <span class="command"><strong>memcached</strong></span> インタフェースは、MySQL 5.6 以上で使用できます。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached" title="15.20 InnoDB memcached プラグイン">セクション15.20「InnoDB memcached プラグイン」</a> を参照してください。 <code class="literal">NDB</code> テーブルへの <span class="command"><strong>memcached</strong></span> インタフェースは NDB Cluster 7.2 以降で使用できます。<a class="ulink" href="https://dev.mysql.com/doc/ndbapi/en/ndbmemcache.html" target="_top">ndbmemcache—Memcache API for NDB Cluster (NO LONGER SUPPORTED)</a> を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_memcached">memcached</a>, <a class="glossseealso" href="glossary.html#glos_schema">スキーマ</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>も参照</p></dd><dt><a name="glos_not_null_constraint"></a><span class="glossterm">NOT NULL 制約</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765948288"></a>
        <span class="bold"><strong>カラム</strong></span>が <span class="bold"><strong>NULL</strong></span> 値を含むことができないと規定するタイプの<span class="bold"><strong>制約</strong></span>。 これは、データベースサーバーが誤って値が失われているデータを識別できるので、<span class="bold"><strong>参照整合性</strong></span>の維持に役立ちます。 また、オプティマイザはそのカラムのインデックス内のエントリ数を予測できるので、クエリー最適化に関係する演算でも役立ちます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_column">カラム</a>, <a class="glossseealso" href="glossary.html#glos_constraint">制約</a>, <a class="glossseealso" href="glossary.html#glos_null">NULL</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>, <a class="glossseealso" href="glossary.html#glos_referential_integrity">参照整合性</a>も参照</p></dd><dt><a name="glos_null"></a><span class="glossterm">NULL</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765939984"></a>
        データが存在しないことを示す、<span class="bold"><strong>SQL</strong></span> での特殊な値。 算術演算や等価性テストに <code class="literal">NULL</code> 値が含まれる場合は、それらは <code class="literal">NULL</code> 結果を返します。 (したがって、NaN、<span class="quote">「<span class="quote">「数値ではない」</span>」</span>の IEEE 浮動小数点概念に似ています。) <code class="literal">AVG()</code> などの集計計算は、除算の分母となる行数を決定するときに、<code class="literal">NULL</code> 値を含む行を無視します。 <code class="literal">NULL</code> 値を扱う唯一のテストは、SQL イディオム <code class="literal">IS NULL</code> または <code class="literal">IS NOT NULL</code> を使用します。 
      </p><p>
        パフォーマンスのために、データベースでは欠落したデータ値を追跡するオーバーヘッドを最小限に抑える必要があるため、<code class="literal">NULL</code> の値は <span class="bold"><strong>index</strong></span> 操作に関与します。 <code class="literal">NULL</code> 値は通常、インデックスに格納されません。標準比較演算子を使用してインデックスカラムをテストするクエリーは、そのカラムの行を <code class="literal">NULL</code> 値に照合することはできないためです。 同じ理由で、一意のインデックスは <code class="literal">NULL</code> 値を防止しません。これらの値は単純にインデックスに表示されません。 カラムで <code class="literal">NOT NULL</code> 制約を宣言することで、インデックスから外れる行がないことが再保証され、クエリー最適化が向上します (行数カウントおよびインデックスを使用するかどうかの評価の精度)。 
      </p><p>
        <span class="bold"><strong>主キー</strong></span>はテーブル内のすべての行を一意に識別できる必要があるので、単一カラム主キーには <code class="literal">NULL</code> 値を含めることはできず、複数カラム主キーにはすべてのカラムで <code class="literal">NULL</code> 値を持つ行を含めることはできません。
      </p><p>
        Oracle データベースでは <code class="literal">NULL</code> 値を文字列と連結できますが、<code class="literal">InnoDB</code> ではこのような操作の結果を <code class="literal">NULL</code> として扱います。
      </p><p><a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">O</h3><dl><dt><a name="glos_odbc"></a><span class="glossterm">ODBC</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765916720"></a>
        業界標準の API である Open Database Connectivity の頭字語。 通常、MySQL との通信に ODBC を必要とする Windows ベースのサーバーまたはアプリケーションで使用されます。 MySQL ODBC ドライバは <span class="bold"><strong>Connector/ODBC</strong></span> と呼ばれます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_connector_odbc">Connector/ODBC</a>も参照</p></dd><dt><a name="glos_oltp"></a><span class="glossterm">OLTP</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765912864"></a>
        <span class="quote">「<span class="quote">「オンライントランザクション処理」</span>」</span>の頭字語。 データベースシステムまたはデータベースアプリケーションの 1 つ。多数の<span class="bold"><strong>トランザクション</strong></span>、頻繁な書き込みと読み取りのワークロードを実行し、通常は一度に少量のデータに影響します。 たとえば、航空便予約システムや銀行預金を処理するアプリケーションがあります。 <span class="bold"><strong>DML</strong></span> (挿入/更新/削除) 効率性と<span class="bold"><strong>クエリー</strong></span>効率性とのバランスを取るために、データは<span class="bold"><strong>正規化</strong></span>形式で編成される場合があります。 <span class="bold"><strong>データウェアハウス</strong></span>と対比してください。 
      </p><p>
        <span class="bold"><strong>InnoDB</strong></span> は、<span class="bold"><strong>行レベルロック</strong></span>と<span class="bold"><strong>トランザクション</strong></span>機能を備え、OLT アプリケーションで使用される MySQL テーブルに理想的なストレージエンジンです。
      </p><p><a class="glossseealso" href="glossary.html#glos_data_warehouse">データウェアハウス</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>, <a class="glossseealso" href="glossary.html#glos_row_lock">行ロック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">P</h3><dl><dt><a name="glos_page_size"></a><span class="glossterm">page size</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765899904"></a>
        MySQL 5.5 までのリリースでは、各 <code class="literal">InnoDB</code> <span class="bold"><strong>page</strong></span> のサイズは 16 キロバイトに固定されています。 この値は、ほとんどの行のデータを保持できる大きさと、不要なデータをメモリーに転送するパフォーマンスオーバーヘッドを最小化できる小ささとを、調和させたものです。 ほかの値は未テストで、サポートされません。 
      </p><p>
        MySQL 5.6 以降、<code class="literal">InnoDB</code> <span class="bold"><strong>instance</strong></span> のページサイズは、<code class="literal">innodb_page_size</code> 構成オプションによって制御される 4KB、8KB または 16KB のいずれかになります。 MySQL 5.7.6 では、<code class="literal">InnoDB</code> は 32KB および 64KB のページサイズもサポートしています。 32KB および 64KB のページサイズの場合、<code class="literal">ROW_FORMAT=COMPRESSED</code> はサポートされず、最大レコードサイズは 16KB です。 
      </p><p>
        ページサイズは、MySQL インスタンスの作成時に設定され、その後は一定のままです。 <span class="bold"><strong>システムテーブルスペース</strong></span>、<span class="bold"><strong>file-per-table</strong></span> テーブルスペースおよび<span class="bold"><strong>一般テーブルスペース</strong></span>を含むすべての <code class="literal">InnoDB</code> <span class="bold"><strong>テーブルスペース</strong></span>に同じページサイズが適用されます。 
      </p><p>
        ページサイズが小さいほど、小さなブロックサイズを使用するストレージデバイス (特に、<span class="bold"><strong>OLTP</strong></span> アプリケーションなどの<span class="bold"><strong>ディスクバウンド</strong></span>ワークロードでの <span class="bold"><strong>SSD</strong></span> デバイス) のパフォーマンスに役立ちます。 個々の行が更新されるときに、メモリーにコピーされたり、ディスクに書き込まれたり、再編成されたり、ロックされたりするときのデータ量が少なくなります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_disk_bound">ディスクバウンド</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_general_tablespace">一般テーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_instance">インスタンス</a>, <a class="glossseealso" href="glossary.html#glos_oltp">OLTP</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_ssd">SSD</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd><dt><a name="glos_perl"></a><span class="glossterm">Perl</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765878288"></a>
        Unix スクリプトおよびレポート生成のルートを持つプログラミング言語。 高パフォーマンスの正規表現およびファイル I/O を組み込みます。 CPAN などのリポジトリを介して使用可能な再利用可能なモジュールの大規模なコレクション。 
      </p><p><a class="glossseealso" href="glossary.html#glos_perl_api">Perl API</a>も参照</p></dd><dt><a name="glos_perl_api"></a><span class="glossterm">Perl API</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765875152"></a>
        <span class="bold"><strong>Perl</strong></span> 言語で記述された MySQL アプリケーション用のオープンソース <span class="bold"><strong>API</strong></span>。 <code class="literal">DBI</code> および <code class="literal">DBD::mysql</code> モジュールを介して実装されます。 詳細は、<a class="xref" href="connectors-apis.html#apis-perl" title="29.9 MySQL Perl API">セクション29.9「MySQL Perl API」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_api">API</a>, <a class="glossseealso" href="glossary.html#glos_perl">Perl</a>も参照</p></dd><dt><a name="glos_php"></a><span class="glossterm">PHP</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765868304"></a>
        web アプリケーションからのプログラミング言語。 通常、コードは web ページのソース内にブロックとして埋め込まれ、出力は Web サーバーによって送信されるときにページに置換されます。 これは、web ページ全体の形式で出力を印刷する CGI スクリプトなどのアプリケーションとは対照的です。 PHP 形式のコーディングは、高度に対話型で動的な web ページに使用されます。 最新の PHP プログラムは、コマンドラインまたは GUI アプリケーションとして実行することもできます。 
      </p><p>
        MySQL アプリケーションは、<span class="bold"><strong>PHP APIs</strong></span> のいずれかを使用して記述されます。 再利用可能なモジュールは、<span class="bold"><strong>C</strong></span> で記述し、PHP から呼び出すことができます。 
      </p><p>
        MySQL を使用してサーバー側の web ページを作成する別のテクノロジは、<span class="bold"><strong>ASP.net</strong></span> です。
      </p><p><a class="glossseealso" href="glossary.html#glos_asp_net">ASP.net</a>, <a class="glossseealso" href="glossary.html#glos_c">C</a>, <a class="glossseealso" href="glossary.html#glos_php_api">PHP API</a>も参照</p></dd><dt><a name="glos_php_api"></a><span class="glossterm">PHP API</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765859872"></a>
        <span class="bold"><strong>PHP</strong></span> 言語での MySQL アプリケーションの記述には、いくつかの <span class="bold"><strong>APIs</strong></span> を使用できます: 元の MySQL API (<code class="literal">Mysql</code>) である MySQL 拡張機能 (<code class="literal">Mysqli</code>) である MySQL ネイティブドライバ (<code class="literal">Mysqlnd</code>) によって、MySQL 関数 (<code class="literal">PDO_MYSQL</code>) およびコネクタ/PHP が改善されました。 詳細は、<a class="ulink" href="https://dev.mysql.com/doc/apis-php/en/" target="_top">MySQL and PHP</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_api">API</a>, <a class="glossseealso" href="glossary.html#glos_php">PHP</a>も参照</p></dd><dt><a name="glos_pitr"></a><span class="glossterm">PITR</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765851200"></a>
        <span class="bold"><strong>ポイントインタイムリカバリ (Point-In-Time Recovery)</strong></span> の頭字語。
      </p><p><a class="glossseealso" href="glossary.html#glos_point_in_time_recovery">ポイントインタイムリカバリ</a>も参照</p></dd><dt><a name="glos_port"></a><span class="glossterm">port</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765847648"></a>
        データベースサーバーがリスニングする TCP/IP ソケットの番号で、<span class="bold"><strong>connection</strong></span> の確立に使用されます。 多くの場合、<span class="bold"><strong>host</strong></span> と組み合せて指定されます。 ネットワーク暗号化の使用方法によっては、暗号化されていないトラフィック用のポートと <span class="bold"><strong>SSL</strong></span> 接続用のポートが異なる場合があります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_connection">接続</a>, <a class="glossseealso" href="glossary.html#glos_host">ホスト</a>, <a class="glossseealso" href="glossary.html#glos_ssl">SSL</a>も参照</p></dd><dt><a name="glos_pthreads"></a><span class="glossterm">Pthreads</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765841040"></a>
        POSIX スレッド標準。Unix および Linux システムでのスレッド操作およびロック操作用の API を定義します。 Unix および Linux システムでは、<code class="literal">InnoDB</code> は <span class="bold"><strong>mutexes</strong></span> に対してこの実装を使用します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_mutex">相互排他ロック</a>も参照</p></dd><dt><a name="glos_python"></a><span class="glossterm">Python</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765836544"></a>
        Unix スクリプトから大規模アプリケーションまで、幅広いフィールドで使用されるプログラミング言語。 実行時の型指定、組込みの高レベルデータ型、オブジェクト指向機能、および広範な標準ライブラリが含まれます。 多くの場合、他の言語で記述されたコンポーネント間の <span class="quote">「<span class="quote">glue</span>」</span> 言語として使用されます。 MySQL <span class="bold"><strong>Python API</strong></span> は、オープンソースの <span class="bold"><strong>MySQLdb</strong></span> モジュールです。 
      </p><p><a class="glossseealso" href="glossary.html#glos_mysqldb">MySQLdb</a>, <a class="glossseealso" href="glossary.html#glos_python_api">Python API</a>も参照</p></dd><dt><a name="glos_python_api"></a><span class="glossterm">Python API</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765830688"></a></p><p><a class="glossseealso" href="glossary.html#glos_api">API</a>, <a class="glossseealso" href="glossary.html#glos_python">Python</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">R</h3><dl><dt><a name="glos_r_tree"></a><span class="glossterm">R-tree</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765827168"></a>
        地理座標、矩形、ポリゴンなどの多次元データの空間インデックス付けに使用されるツリーデータ構造。
      </p><p><a class="glossseealso" href="glossary.html#glos_b_tree">B ツリー</a>も参照</p></dd><dt><a name="glos_raid"></a><span class="glossterm">RAID</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765824224"></a>
        <span class="quote">「<span class="quote">「低コストのドライブの冗長アレイ」</span>」</span>の頭字語。 複数のドライブに I/O 操作を分散することにより、ハードウェアレベルで<span class="bold"><strong>並列性</strong></span>が向上し、低レベル書き込み操作の効率性が改善します (そうしない場合は順番に実行されます)。 
      </p><p><a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>も参照</p></dd><dt><a name="glos_raw_backup"></a><span class="glossterm">raw バックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765820240"></a>
        <span class="bold"><strong>バイナリログ</strong></span>と<span class="bold"><strong>増分バックアップ</strong></span>に反映される変更が適用される前の、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品によって生成されるバックアップファイルの初期セット。 この段階では、ファイルは<span class="bold"><strong>リストア</strong></span>する準備ができていません。 これらの変更が適用されたあと、ファイルは<span class="bold"><strong>準備されたバックアップ</strong></span>と呼ばれます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_binary_log">バイナリログ</a>, <a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_ibbackup_logfile">ibbackup_logfile</a>, <a class="glossseealso" href="glossary.html#glos_incremental_backup">増分バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_prepared_backup">準備されたバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_restore">リストア</a>も参照</p></dd><dt><a name="glos_read_committed"></a><span class="glossterm">READ COMMITTED</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765810272"></a>
        <span class="bold"><strong>分離レベル</strong></span>の 1 つ。パフォーマンスを向上させるために、<span class="bold"><strong>トランザクション</strong></span>間の保護を一部緩和する<span class="bold"><strong>ロック</strong></span>戦略を使用します。 トランザクションは、ほかのトランザクションからのコミットされていないデータを見ることはできませんが、現在のトランザクションが開始したあとに別のトランザクションによってコミットされるデータを見ることはできます。 したがって、トランザクションは不良データを見ることはありませんが、見るデータはある程度ほかのトランザクションのタイミングに依存する場合があります。 
      </p><p>
        この分離レベルのトランザクションが <code class="literal">UPDATE ... WHERE</code> または <code class="literal">DELETE ... WHERE</code> 操作を実行するときに、ほかのトランザクションは待機が必要な場合があります。 このトランザクションは、ほかのトランザクションを待機させずに <code class="literal">SELECT ... FOR UPDATE</code> および <code class="literal">LOCK IN SHARE MODE</code> 操作を実行できます。 
      </p><p>
        MySQL 8.0.1 の <code class="literal">SELECT ... LOCK IN SHARE MODE</code> は <code class="literal">SELECT ... FOR SHARE</code> に置き換わりますが、<code class="literal">LOCK IN SHARE MODE</code> は下位互換性のために引き続き使用できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_repeatable_read">REPEATABLE READ</a>, <a class="glossseealso" href="glossary.html#glos_serializable">SERIALIZABLE</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_read_uncommitted"></a><span class="glossterm">READ UNCOMMITTED</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765794912"></a>
        トランザクション間にもっとも少ない量の保護を提供する<span class="bold"><strong>分離レベル</strong></span>。 クエリーは、通常は別のトランザクションを待機する状況で進行することを許可される<span class="bold"><strong>ロック</strong></span>戦略を採用します。 ただし、この追加パフォーマンスには、ほかのトランザクションによって変更されたけれどもまだコミットされていないデータ (<span class="bold"><strong>ダーティー読み取り</strong></span>と呼ばれます) など、結果の信頼性の低いという犠牲が伴います。 この分離レベルは慎重に使用してください。また、他のトランザクションが同時に実行している内容によっては、結果が一貫していないか再現できない可能性があることに注意してください。 通常、この分離レベルのトランザクションはクエリーのみを実行し、挿入、更新または削除操作は実行しません。 
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_dirty_read">ダーティー読み取り</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_redo"></a><span class="glossterm">Redo</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765786576"></a>
        <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> ステートメントによって <code class="literal">InnoDB</code> テーブルが変更されたときに<span class="bold"><strong>redo ログ</strong></span>に記録されるレコード単位のデータ。 <span class="bold"><strong>クラッシュリカバリ</strong></span>中に、不完全な<span class="bold"><strong>トランザクション</strong></span>によって書き込まれるデータを訂正するために使用されます。 増加し続ける <span class="bold"><strong>LSN</strong></span> 値は、Redo ログを通過した Redo データの累積量を表します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_crash_recovery">クラッシュリカバリ</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_lsn">LSN</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_redo_log"></a><span class="glossterm">Redo ログ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765777168"></a>
        <span class="bold"><strong>クラッシュリカバリ</strong></span>中に、不完全な<span class="bold"><strong>トランザクション</strong></span>によって書き込まれるデータを訂正するために使用されるディスクベースデータ構造。 通常の操作では、<code class="literal">InnoDB</code> テーブルデータを変更するリクエストがエンコードされます。これは、NoSQL インタフェースを介した SQL ステートメントまたは低レベルの API コールの結果です。 予期しない<span class="bold"><strong>シャットダウン</strong></span>前に<span class="bold"><strong>データファイル</strong></span>の更新を終了していない変更は、自動的に再現されます。 
      </p><p>
        Redo ログはファイルセットとして物理的に表され、通常は <code class="filename">ib_logfile0</code> および <code class="filename">ib_logfile1</code> という名前が付けられます。 Redo ログ内のデータは、該当するレコードの単位でエンコードされます。このデータはまとめて <span class="bold"><strong>Redo</strong></span> と呼ばれます。 Redo ログをデータが通貨したことは、増加し続ける <span class="bold"><strong>LSN</strong></span> 値で表されます。 Redo ログの最大サイズは、最初は 4G バイトに制限されていましたが、MySQL 5.6.3 で 512G バイトに上げられています。 
      </p><p>
        Redo ログのディスクレイアウトは、構成オプション <code class="literal">innodb_log_file_size</code>、<code class="literal">innodb_log_group_home_dir</code>、および (まれに) <code class="literal">innodb_log_files_in_group</code> に影響されます。 Redo ログ操作のパフォーマンスは、<span class="bold"><strong>ログバッファー</strong></span>にも影響されます。これは <code class="literal">innodb_log_buffer_size</code> 構成オプションによって制御されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_crash_recovery">クラッシュリカバリ</a>, <a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_ib_logfile">ib_logfile</a>, <a class="glossseealso" href="glossary.html#glos_log_buffer">ログバッファー</a>, <a class="glossseealso" href="glossary.html#glos_lsn">LSN</a>, <a class="glossseealso" href="glossary.html#glos_redo">Redo</a>, <a class="glossseealso" href="glossary.html#glos_shutdown">シャットダウン</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_redo_log_archiving"></a><span class="glossterm">redo ログのアーカイブ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765756464"></a>
        バックアップ操作の進行中にバックアップユーティリティが redo ログの生成に失敗した場合に発生する可能性のあるデータ損失を回避するために、redo ログレコードをアーカイブファイルに順次書き込む <code class="literal">InnoDB</code> 機能。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-redo-log-archiving" title="redo ログのアーカイブ">redo ログのアーカイブ</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>も参照</p></dd><dt><a name="glos_repeatable_read"></a><span class="glossterm">REPEATABLE READ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765751552"></a>
        <code class="literal">InnoDB</code> のデフォルトの<span class="bold"><strong>分離レベル</strong></span>。 クエリー対象の行が他の <span class="bold"><strong>transactions</strong></span> によって変更されないようにするため、<span class="bold"><strong>反復不可能な読み取り</strong></span>はブロックされますが、<span class="bold"><strong>phantom</strong></span> の読取りはブロックされません。 トランザクション内のすべてのクエリーが同じスナップショットからのデータを見る、つまりトランザクションが開始した時点のデータを見るように、適度に厳密な<span class="bold"><strong>ロック</strong></span>戦略を使用します。 
      </p><p>
        この分離レベルのトランザクションが <code class="literal">UPDATE ... WHERE</code>、<code class="literal">DELETE ... WHERE</code>、<code class="literal">SELECT ... FOR UPDATE</code>、および <code class="literal">LOCK IN SHARE MODE</code> 操作を実行するときに、ほかのトランザクションは待機しなければいけない場合があります。
      </p><p>
        MySQL 8.0.1 の <code class="literal">SELECT ... LOCK IN SHARE MODE</code> は <code class="literal">SELECT ... FOR SHARE</code> に置き換わりますが、<code class="literal">LOCK IN SHARE MODE</code> は下位互換性のために引き続き使用できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_consistent_read">一貫性読み取り</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_phantom">ファントム</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_ruby"></a><span class="glossterm">Ruby</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765734768"></a>
        動的型付けおよびオブジェクト指向プログラミングを強調するプログラミング言語。 一部の構文は、<span class="bold"><strong>Perl</strong></span> 開発者によく知られています。 MySQL アプリケーションの開発には、一般的な <span class="bold"><strong>Ruby APIs</strong></span> が 2 つあります。 (このマニュアルでは、上位レベルの Ruby フレームワークについては説明しません。) 
      </p><p><a class="glossseealso" href="glossary.html#glos_api">API</a>, <a class="glossseealso" href="glossary.html#glos_perl">Perl</a>, <a class="glossseealso" href="glossary.html#glos_ruby_api">Ruby API</a>も参照</p></dd><dt><a name="glos_ruby_api"></a><span class="glossterm">Ruby API</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765729040"></a>
        MySQL アプリケーションを開発する Ruby プログラマは、2 つの API を使用できます。 MySQL/Ruby API は <span class="bold"><strong>libmysqlclient</strong></span> API ライブラリに基づいています。 Ruby/MySQL API はネイティブ MySQL ネットワークプロトコル (ネイティブドライバ) を使用するために書かれています。 詳細は、<a class="xref" href="connectors-apis.html#apis-ruby" title="29.11 MySQL Ruby API">セクション29.11「MySQL Ruby API」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_libmysql">libmysql</a>, <a class="glossseealso" href="glossary.html#glos_ruby">Ruby</a>も参照</p></dd><dt><a name="glos_rw_lock"></a><span class="glossterm">rw ロック (読み書きロック)</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765723632"></a>
        特定のルールに従って、<code class="literal">InnoDB</code> が内部インメモリーデータ構造への共有アクセス<span class="bold"><strong>ロック</strong></span>を表現および強制するために使用する低レベルオブジェクト。 <code class="literal">InnoDB</code> が内部インメモリーデータ構造への排他的アクセスを表すために使用する <span class="bold"><strong>mutexes</strong></span> と対比してください。 相互排他ロックと読み書きロックはまとめて、<span class="bold"><strong>ラッチ</strong></span>と呼ばれます。 
      </p><p>
        <code class="literal">rw ロック</code>タイプには、<code class="literal">s ロック</code> (共有ロック)、<code class="literal">x ロック</code> (排他ロック)、および <code class="literal">sx ロック</code> (共有排他ロック) などがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">s ロック</code>は、共有リソースへの読み取りアクセスを提供します。
          </p></li><li class="listitem"><p>
            <code class="literal">x ロック</code>は、共有リソースへの書き込みアクセスを提供し、ほかのスレッドによる不整合読み取りを許可しません。
          </p></li><li class="listitem"><p>
            <code class="literal">sx ロック</code>は、共有リソースへの書き込みアクセスを提供し、ほかのスレッドによる不整合読み取りを許可します。<code class="literal">sx ロック</code>は、読み取り/書き込みワークロードの並列性を最適化し、スケーラビリティーを改善するために MySQL 5.7 で導入されました。
          </p></li></ul></div><p>
        次の表に rw ロックタイプ互換性をまとめます。
      </p><div class="informaltable"><table summary="Compatibility matrix for rw-lock types. Each cell in the matrix is marked as either Compatible or Conflict."><col style="width=20%"><col style="width=20%"><col style="width=20%"><col style="width=20%"><thead><tr>
            <th scope="col"></th>
            <th scope="col"><em class="replaceable"><code>S</code></em></th>
            <th scope="col"><em class="replaceable"><code>SX</code></em></th>
            <th scope="col"><em class="replaceable"><code>X</code></em></th>
          </tr></thead><tbody><tr>
            <td scope="row"><em class="replaceable"><code>S</code></em></td>
            <td>互換</td>
            <td>互換</td>
            <td>競合</td>
          </tr><tr>
            <td scope="row"><em class="replaceable"><code>SX</code></em></td>
            <td>互換</td>
            <td>競合</td>
            <td>競合</td>
          </tr><tr>
            <td scope="row"><em class="replaceable"><code>X</code></em></td>
            <td>競合</td>
            <td>競合</td>
            <td>競合</td>
          </tr></tbody></table></div><p><a class="glossseealso" href="glossary.html#glos_latch">ラッチ</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_mutex">相互排他ロック</a>, <a class="glossseealso" href="glossary.html#glos_performance_schema">パフォーマンススキーマ</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">S</h3><dl><dt><a name="glos_sdi"></a><span class="glossterm">SDI</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765681536"></a>
        <span class="quote">「<span class="quote">「シリアライズされたディクショナリ情報」</span>」</span>の頭字語。
      </p><a class="indexterm" name="idm46318765680160"></a><a class="indexterm" name="idm46318765679136"></a><p><a class="glossseealso" href="glossary.html#glos_serialized_dictionary_information">シリアライズディクショナリ情報 (SDI)</a>も参照</p></dd><dt><a name="glos_serializable"></a><span class="glossterm">SERIALIZABLE</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765675696"></a>
        最も保守的なロック戦略を使用して、このトランザクションによって読み取られたデータが他の <span class="bold"><strong>transactions</strong></span> によって挿入または変更されないようにする<span class="bold"><strong>分離レベル</strong></span>。 この方法では、トランザクション内で同じクエリーを何度も実行でき、そのたびに同じ結果セットを取得することを保証できます。 現在のトランザクションが開始してから別のトランザクションによってコミットされたデータを変更しようとすると、現在のトランザクションは待機します。 
      </p><p>
        これは、SQL 標準で指定されるデフォルト分離レベルです。 実際には、この強度が必要になることはほとんどないため、<code class="literal">InnoDB</code> のデフォルトの分離レベルは次に厳しい <span class="bold"><strong>REPEATABLE READ</strong></span> です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_consistent_read">一貫性読み取り</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_repeatable_read">REPEATABLE READ</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_servlet"></a><span class="glossterm">servlet</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765665664"></a></p><p><a class="glossseealso" href="glossary.html#glos_connector_j">Connector/J</a>も参照</p></dd><dt><a name="glos_source"></a><span class="glossterm">source</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765663184"></a>
        <span class="bold"><strong>レプリケーション</strong></span>シナリオでのデータベースサーバーマシンで、データの初期挿入、更新、および削除リクエストを処理します。 これらの変更は、<span class="bold"><strong>レプリカ</strong></span>と呼ばれる他のサーバーに伝播され、繰り返されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_replica">レプリカ</a>, <a class="glossseealso" href="glossary.html#glos_replication">レプリケーション</a>も参照</p></dd><dt><a name="glos_spring"></a><span class="glossterm">Spring</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765658272"></a>
        コンポーネントを構成する方法を提供することで、アプリケーション設計を支援するために設計された Java ベースのアプリケーションフレームワーク。
      </p><p><a class="glossseealso" href="glossary.html#glos_j2ee">J2EE</a>も参照</p></dd><dt><a name="glos_sql"></a><span class="glossterm">SQL</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765655312"></a>
        データベース操作を実行するための標準である構造化クエリー言語。 多くの場合、カテゴリ <span class="bold"><strong>DDL</strong></span>、<span class="bold"><strong>DML</strong></span>、および<span class="bold"><strong>クエリー</strong></span>に分けられます。 MySQL には、<span class="bold"><strong>レプリケーション</strong></span>などのいくつかの追加ステートメントカテゴリが含まれます。 SQL 構文の構成ブロックについては<a class="xref" href="language-structure.html" title="第 9 章 言語構造">第9章「<i>言語構造</i>」</a>、MySQL テーブルカラムに使用するデータ型については<a class="xref" href="data-types.html" title="第 11 章 データ型">第11章「<i>データ型</i>」</a>、SQL ステートメントとそれらに関連付けられるカテゴリの詳細は<a class="xref" href="sql-statements.html" title="第 13 章 SQL ステートメント">第13章「<i>SQL ステートメント</i>」</a>、クエリーで使用する標準および MySQL 固有の関数については<a class="xref" href="functions.html" title="第 12 章 関数と演算子">第12章「<i>関数と演算子</i>」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>, <a class="glossseealso" href="glossary.html#glos_replication">レプリケーション</a>も参照</p></dd><dt><a name="glos_sqlstate"></a><span class="glossterm">SQLState</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765644992"></a>
        <span class="bold"><strong>Connector/J</strong></span> を使用するアプリケーションによる例外処理のために、<span class="bold"><strong>JDBC</strong></span> 標準で定義されているエラーコード。
      </p><p><a class="glossseealso" href="glossary.html#glos_connector_j">Connector/J</a>, <a class="glossseealso" href="glossary.html#glos_jdbc">JDBC</a>も参照</p></dd><dt><a name="glos_ssd"></a><span class="glossterm">SSD</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765640240"></a>
        <span class="quote">「<span class="quote">「ソリッドステートドライブ」</span>」</span>の頭字語。 従来のハードディスクドライブ (<span class="bold"><strong>HDD</strong></span>) とパフォーマンス特性が異なるタイプのストレージデバイス。ストレージ容量が小さく、ランダム読み取りが高速で、可動部分がなく、書き込みパフォーマンスに影響する考慮事項がいくつかあります。 そのパフォーマンス特性は、<span class="bold"><strong>ディスクバウンド</strong></span>ワークロードのスループットに影響を与えることがあります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_disk_bound">ディスクバウンド</a>, <a class="glossseealso" href="glossary.html#glos_hdd">HDD</a>も参照</p></dd><dt><a name="glos_ssl"></a><span class="glossterm">SSL</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765634672"></a>
        <span class="quote">「<span class="quote">「セキュアソケットレイヤー」</span>」</span>の頭字語。 アプリケーションと MySQL データベースサーバー間のネットワーク通信用の暗号化レイヤーを提供します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_keystore">keystore</a>, <a class="glossseealso" href="glossary.html#glos_truststore">トラストストア</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">T</h3><dl><dt><a name="glos_tcl"></a><span class="glossterm">Tcl</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765630176"></a>
        Unix スクリプトワールドからのプログラミング言語。 <span class="bold"><strong>C</strong></span>、<span class="bold"><strong>C++</strong></span> または <span class="bold"><strong>Java</strong></span> で記述されたコードによって拡張される場合があります。 オープンソース Tcl <span class="bold"><strong>API</strong></span> for MySQL については、<a class="xref" href="connectors-apis.html#apis-tcl" title="29.12 MySQL Tcl API">セクション29.12「MySQL Tcl API」</a> を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_api">API</a>も参照</p></dd><dt><a name="glos_tomcat"></a><span class="glossterm">Tomcat</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765623808"></a>
        オープンソースの <span class="bold"><strong>J2EE</strong></span> アプリケーションサーバー。Java サーブレットおよび JavaServer Pages プログラミングテクノロジを実装します。 web サーバーと Java サーブレットコンテナで構成されます。 MySQL では、通常、<span class="bold"><strong>Connector/J</strong></span> とともに使用されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_j2ee">J2EE</a>も参照</p></dd><dt><a name="glos_tps"></a><span class="glossterm">TPS</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765619136"></a>
        <span class="quote">「<span class="quote">「<span class="bold"><strong>transactions</strong></span>/秒」</span>」</span>の頭字語。ベンチマークで使用されることがある測定単位です。 その値は、特定のベンチマークテストで表される<span class="bold"><strong>ワークロード</strong></span>と、ハードウェア能力やデータベース構成などの制御要因との組み合わせに応じて異なります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_workload">ワークロード</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">U</h3><dl><dt><a name="glos_undo"></a><span class="glossterm">Undo</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765613344"></a>
        <span class="bold"><strong>トランザクション</strong></span>の生存期間保持されるデータ。<span class="bold"><strong>ロールバック</strong></span>操作の場合に元に戻せるようにすべての変更を記録します。 これは、<span class="bold"><strong>システムテーブルスペース</strong></span> (MySQL 5.7 以前) 内または別の<span class="bold"><strong>undo テーブルスペース</strong></span>内の<span class="bold"><strong>undo ログ</strong></span>に格納されます。 MySQL 8.0 では、undo ログはデフォルトで undo テーブルスペースに存在します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_rollback_segment">ロールバックセグメント</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_undo_log">Undo ログ</a>, <a class="glossseealso" href="glossary.html#glos_undo_tablespace">Undo テーブルスペース</a>も参照</p></dd><dt><a name="glos_undo_tablespace"></a><span class="glossterm">Undo テーブルスペース</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765604240"></a>
        undo テーブルスペースには、<span class="bold"><strong>undo ログ</strong></span>が含まれます。 undo ログは、<span class="bold"><strong>ロールバックセグメント</strong></span>内に含まれる<span class="bold"><strong>undo ログセグメント</strong></span>内に存在します。 ロールバックセグメントは、従来はシステムテーブルスペースに存在していました。 MySQL 5.6 では、ロールバックセグメントは undo テーブルスペースに存在できます。 MySQL 5.6 および MySQL 5.7 では、undo テーブルスペースの数は <code class="literal">innodb_undo_tablespaces</code> 構成オプションによって制御されます。 MySQL 8.0 では、MySQL インスタンスの初期化時に 2 つのデフォルト undo テーブルスペースが作成され、<code class="literal">CREATE UNDO TABLESPACE</code> 構文を使用して追加の undo テーブルスペースを作成できます。 
      </p><p>
        詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-undo-tablespaces" title="15.6.3.4 undo テーブルスペース">セクション15.6.3.4「undo テーブルスペース」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_rollback_segment">ロールバックセグメント</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_undo_log">Undo ログ</a>, <a class="glossseealso" href="glossary.html#glos_undo_log_segment">undo ログセグメント</a>も参照</p></dd><dt><a name="glos_undo_buffer"></a><span class="glossterm">Undo バッファー</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_undo_log">Undo ログ</a>も参照</p></dd><dt><a name="glos_undo_log"></a><span class="glossterm">Undo ログ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765591488"></a>
        アクティブ<span class="bold"><strong>トランザクション</strong></span>によって変更されたデータのコピーを保持するストレージ領域。 別のトランザクションが (<span class="bold"><strong>一貫性読み取り</strong></span>操作の一部として) 元のデータを見る必要がある場合に、未変更データがこのストレージ領域から取得されます。 
      </p><p>
        MySQL 5.6 および MySQL 5.7 では、<code class="literal">innodb_undo_tablespaces</code> 変数を使用して、<span class="bold"><strong>undo テーブルスペース</strong></span>に undo ログを配置できます。これは <span class="bold"><strong>SSD</strong></span> などの別のストレージデバイスに配置できます。 MySQL 8.0 では、undo ログは MySQL の初期化時に作成されるデフォルトの undo テーブルスペースに存在し、<code class="literal">CREATE UNDO TABLESPACE</code> 構文を使用して追加の undo テーブルスペースを作成できます。 
      </p><p>
        Undo ログは、別個の部分、<span class="bold"><strong>挿入 Undo バッファー</strong></span>と<span class="bold"><strong>更新 Undo バッファー</strong></span>に分割されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_consistent_read">一貫性読み取り</a>, <a class="glossseealso" href="glossary.html#glos_rollback_segment">ロールバックセグメント</a>, <a class="glossseealso" href="glossary.html#glos_ssd">SSD</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_undo_tablespace">Undo テーブルスペース</a>も参照</p></dd><dt><a name="glos_undo_log_segment"></a><span class="glossterm">undo ログセグメント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765577488"></a>
        <span class="bold"><strong>undo ログ</strong></span>のコレクション。 undo ログセグメントは<span class="bold"><strong>ロールバックセグメント</strong></span>内に存在します。 undo ログセグメントには、複数のトランザクションからの undo ログが含まれる場合があります。 undo ログセグメントは、一度に 1 つのトランザクションでのみ使用できますが、トランザクション <span class="bold"><strong>commit</strong></span> または <span class="bold"><strong>rollback</strong></span> で解放された後で再利用できます。 <span class="quote">「<span class="quote">「undo セグメント」</span>」</span>とも呼ばれます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_rollback_segment">ロールバックセグメント</a>, <a class="glossseealso" href="glossary.html#glos_undo_log">Undo ログ</a>も参照</p></dd><dt><a name="glos_unicode"></a><span class="glossterm">Unicode</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765569344"></a>
        各国語文字、文字セット、コードページおよびその他の国際化の側面を柔軟かつ標準化された方法でサポートするためのシステム。
      </p><p>
        Unicode サポートは、<span class="bold"><strong>ODBC</strong></span> 標準の重要な側面です。 <span class="bold"><strong>Connector/ODBC</strong></span> 5.1 は Unicode ドライバであり、<span class="bold"><strong>ANSI</strong></span> ドライバである Connector/ODBC 3.51 とは対照的です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_ansi">ANSI</a>, <a class="glossseealso" href="glossary.html#glos_connector_odbc">Connector/ODBC</a>, <a class="glossseealso" href="glossary.html#glos_odbc">ODBC</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">V</h3><dl><dt><a name="glos_view"></a><span class="glossterm">view</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765561744"></a>
        呼び出されたときに結果セットを生成するストアドクエリー。 ビューは仮想テーブルとして機能します。 
      </p></dd><dt><a name="glos_visual_studio"></a><span class="glossterm">Visual Studio</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765559360"></a>
        サポートされている Visual Studio のバージョンについては、次のリファレンスを参照してください:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            Connector/NET: <a class="ulink" href="https://dev.mysql.com/doc/connector-net/en/connector-net-versions.html" target="_top">Connector/NET Versions</a>
          </p></li><li class="listitem"><p>
            Connector/C++ 8.0: <a class="ulink" href="https://dev.mysql.com/doc/connector-cpp/8.0/en/connector-cpp-introduction.html#connector-cpp-prerequisites" target="_top">Platform Support and Prerequisites</a>
          </p></li></ul></div><p><a class="glossseealso" href="glossary.html#glos_connector_c__">Connector/C++</a>, <a class="glossseealso" href="glossary.html#glos_connector_net">Connector/NET</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">X</h3><dl><dt><a name="glos_xa"></a><span class="glossterm">XA</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765551856"></a>
        分散型<span class="bold"><strong>トランザクション</strong></span>を調整するための標準インタフェース。<span class="bold"><strong>ACID</strong></span> コンプライアンスを維持しながら、複数のデータベースがトランザクションに参加できます。 詳細は、<a class="xref" href="sql-statements.html#xa" title="13.3.8 XA トランザクション">セクション13.3.8「XA トランザクション」</a>を参照してください。 
      </p><p>
        XA 分散トランザクションのサポートはデフォルトで有効になっています。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_binary_log">バイナリログ</a>, <a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_two_phase_commit">2 フェーズコミット</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ア</h3><dl><dt><a name="glos_assembly"></a><span class="glossterm">アセンブリ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765539584"></a>
        <span class="bold"><strong>Connector/NET</strong></span> を介してアクセスされる、<span class="bold"><strong>.NET</strong></span> システム内のコンパイル済コードのライブラリ。 <span class="bold"><strong>GAC</strong></span> に格納され、名前の競合なしでバージョニングできるようにします。 
      </p><p><a class="glossseealso" href="glossary.html#glos__net">.NET</a>, <a class="glossseealso" href="glossary.html#glos_gac">GAC</a>も参照</p></dd><dt><a name="glos_atomic_ddl"></a><span class="glossterm">アトミック DDL</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765467696"></a>
        アトミック <span class="emphasis"><em>DDL</em></span> ステートメントは、DDL 操作に関連付けられた<span class="emphasis"><em>データディクショナリ</em></span>更新、<span class="emphasis"><em>ストレージエンジン</em></span>操作および<span class="emphasis"><em>バイナリログ</em></span>書込みを単一のアトミックトランザクションに結合するステートメントです。 操作中にサーバーが停止した場合でも、トランザクションは完全にコミットまたはロールバックされます。 アトミック DDL サポートが MySQL 8.0 で追加されました。 詳細は、<a class="xref" href="sql-statements.html#atomic-ddl" title="13.1.1 アトミックデータ定義ステートメントのサポート">セクション13.1.1「アトミックデータ定義ステートメントのサポート」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_binary_log">バイナリログ</a>, <a class="glossseealso" href="glossary.html#glos_data_dictionary">データディクショナリ</a>, <a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_storage_engine">ストレージエンジン</a>も参照</p></dd><dt><a name="glos_atomic_instruction"></a><span class="glossterm">アトミック命令</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765460016"></a>
        重要な低レベル操作を中断できないようにするために、CPU によって提供される特殊な命令。
      </p></dd><dt><a name="glos_application_programming_interface"></a><span class="glossterm">アプリケーションプログラミングインタフェース (API)</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765457248"></a>
        関数またはプロシージャーのセット。 API は、関数、プロシージャー、パラメータ、および戻り値の名前と型の安定的なセットです。 
      </p></dd><dt><a name="glos_early_adopter"></a><span class="glossterm">アーリーアダプタ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765543456"></a>
        ソフトウェア製品のパフォーマンス、機能および互換性が non-mission-critical 設定で通常評価される、<span class="bold"><strong>ベータ</strong></span>と同様のステージ。
      </p><p><a class="glossseealso" href="glossary.html#glos_beta">ベータ</a>も参照</p></dd><dt><a name="glos_compression"></a><span class="glossterm">圧縮</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765523936"></a>
        使用するディスク領域の縮小、実行する I/O の減少、および使用するキャッシュ用のメモリーの軽減による幅広いメリットを伴う機能。
      </p><p>
        <code class="literal">InnoDB</code> では、テーブルレベルとページレベルの両方の圧縮がサポートされます。 <code class="literal">InnoDB</code> のページ圧縮は、<span class="bold"><strong>透過的ページ圧縮</strong></span>とも呼ばれます。 <code class="literal">InnoDB</code> 圧縮の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-compression" title="15.9 InnoDB のテーブルおよびページの圧縮">セクション15.9「InnoDB のテーブルおよびページの圧縮」</a> を参照してください。 
      </p><p>
        別の種類の圧縮は、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品の<span class="bold"><strong>圧縮バックアップ</strong></span>機能です。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_compressed_backup">圧縮バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_compressed_row_format">圧縮行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_transparent_page_compression">透過的ページ圧縮</a>も参照</p></dd><dt><a name="glos_compressed_table"></a><span class="glossterm">圧縮テーブル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765499168"></a>
        データが圧縮形式で格納されたテーブル。 <code class="literal">InnoDB</code> の場合、これは <code class="literal">ROW_FORMAT=COMPRESSED</code> で作成されたテーブルです。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-compression" title="15.9 InnoDB のテーブルおよびページの圧縮">セクション15.9「InnoDB のテーブルおよびページの圧縮」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_compressed_row_format">圧縮行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_compression">圧縮</a>も参照</p></dd><dt><a name="glos_compressed_backup"></a><span class="glossterm">圧縮バックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765493328"></a>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品の圧縮機能は、各テーブルスペースの圧縮コピーを作成し、<code class="literal">.ibd</code> から <code class="literal">.ibz</code> に拡張子を変更します。 バックアップデータを圧縮すると、より多くのバックアップを手元に保持し、バックアップを別のサーバーに転送する時間を短縮できます。 データはリストア操作中に圧縮解除されます。 圧縮バックアップ操作は、すでに圧縮されているテーブルを処理するときに、ふたたび圧縮してもほとんどまたはまったく領域の節約にならないので、そのテーブルの圧縮ステップをスキップします。 
      </p><p>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品が生成するファイルセット。ここでは、各<span class="bold"><strong>テーブルスペース</strong></span>が圧縮されます。 圧縮ファイルは、<code class="literal">.ibz</code> ファイル拡張子を使用して名前が変更されます。 
      </p><p>
        バックアッププロセスの開始時に <span class="bold"><strong>compression</strong></span> を適用すると、圧縮プロセス中の記憶域のオーバーヘッドを回避し、バックアップファイルを別のサーバーに転送する際のネットワークオーバーヘッドを回避できます。 <span class="bold"><strong>バイナリログ</strong></span>を<span class="bold"><strong>適用する</strong></span>プロセスはさらに時間がかかるようになり、バックアップファイルの圧縮解除が必要になります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_apply">適用</a>, <a class="glossseealso" href="glossary.html#glos_binary_log">バイナリログ</a>, <a class="glossseealso" href="glossary.html#glos_compression">圧縮</a>, <a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd><dt><a name="glos_compression_failure"></a><span class="glossterm">圧縮失敗</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765512336"></a>
        実際にはエラーではなくむしろ、<span class="bold"><strong>圧縮</strong></span>を <span class="bold"><strong>DML</strong></span> 操作と組み合わせて使用するときに起きる可能性のある負荷のかかる操作です。 これは、圧縮<span class="bold"><strong>ページ</strong></span>への更新が変更記録に予約されたページ上の領域からオーバーフローするとき、すべての変更がテーブルデータに適用してページが再度圧縮されたとき、再圧縮されたデータが元のページ上で適合せず、MySQL がデータを 2 つの新しいページに分割しそれぞれを個別に圧縮するように要求するときに起こります。 この条件の頻度を確認するには、<code class="literal">INFORMATION_SCHEMA.INNODB_CMP</code> テーブルをクエリーして、<code class="literal">COMPRESS_OPS</code> カラムの値が <code class="literal">COMPRESS_OPS_OK</code> カラムの値を超えているかどうかを確認します。 理想的には、圧縮の失敗は頻繁には発生しません。その場合は、<code class="literal">innodb_compression_level</code>、<code class="literal">innodb_compression_failure_threshold_pct</code> および <code class="literal">innodb_compression_pad_pct_max</code> の構成オプションを調整できます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_compression">圧縮</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>も参照</p></dd><dt><a name="glos_compressed_row_format"></a><span class="glossterm">圧縮行フォーマット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765478896"></a>
        <code class="literal">InnoDB</code> テーブルのデータおよびインデックス<span class="bold"><strong>圧縮</strong></span>を有効にする<span class="bold"><strong>行フォーマット</strong></span>。 ラージフィールドは、<span class="bold"><strong>動的行フォーマット</strong></span>と同様に、残りの行データを保持するページとは別に格納されます。 インデックスページとラージフィールドの両方が圧縮され、メモリーとディスクの節約をもたらします。 データの構造に応じて、メモリーおよびディスク使用量の減少は、使用時にデータを圧縮解除するときのパフォーマンスオーバーヘッドを上回る場合も、上回らない場合もあります。 使用法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-compression" title="15.9 InnoDB のテーブルおよびページの圧縮">セクション15.9「InnoDB のテーブルおよびページの圧縮」</a>を参照してください。 
      </p><p>
        <code class="literal">InnoDB</code> <code class="literal">COMPRESSED</code> 行フォーマットの追加情報については、<a class="xref" href="innodb-storage-engine.html#innodb-row-format-dynamic" title="DYNAMIC 行フォーマット">DYNAMIC 行フォーマット</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_compression">圧縮</a>, <a class="glossseealso" href="glossary.html#glos_dynamic_row_format">動的行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_row_format">行フォーマット</a>も参照</p></dd><dt><a name="glos_young"></a><span class="glossterm">新しい</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765533616"></a>
        <code class="literal">InnoDB</code> <span class="bold"><strong>バッファプール</strong></span>の <span class="bold"><strong>page</strong></span> の特性は、最近アクセスされたことを意味し、<span class="bold"><strong>LRU</strong></span> アルゴリズムによって <span class="bold"><strong>flushed</strong></span> がすぐに使用されないようにバッファープールのデータ構造内で移動されます。 この用語は、バッファープールに関連するテーブルの一部の <span class="bold"><strong>INFORMATION_SCHEMA</strong></span> カラム名で使用されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_information_schema">INFORMATION_SCHEMA</a>, <a class="glossseealso" href="glossary.html#glos_lru">LRU</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>も参照</p></dd><dt><a name="glos_implicit_row_lock"></a><span class="glossterm">暗黙の行ロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765454448"></a>
        一貫性を確保するために <code class="literal">InnoDB</code> が取得する行ロック (特にリクエストしない場合)。
      </p><p><a class="glossseealso" href="glossary.html#glos_row_lock">行ロック</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">イ</h3><dl><dt><a name="glos_instance"></a><span class="glossterm">インスタンス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765369344"></a>
        単一の <span class="bold"><strong>mysqld</strong></span> デーモン。<span class="bold"><strong>テーブル</strong></span>のセットで 1 つ以上の<span class="bold"><strong>データベース</strong></span>を表す<span class="bold"><strong>データディレクトリ</strong></span>を管理します。 同じ<span class="bold"><strong>サーバー</strong></span>マシン上に複数のインスタンスを持ち、それぞれが専用のデータディレクトリを管理し、独自のポートまたはソケットで待機することは、開発、テスト、および一部の<span class="bold"><strong>レプリケーション</strong></span>シナリオにおいて一般的です。 あるインスタンスが<span class="bold"><strong>ディスクバウンド</strong></span>ワークロードを実行している状態でも、サーバーは追加インスタンスを実行するために余分な CPU およびメモリー容量を持つことができます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_data_directory">データディレクトリ</a>, <a class="glossseealso" href="glossary.html#glos_database">データベース</a>, <a class="glossseealso" href="glossary.html#glos_disk_bound">ディスクバウンド</a>, <a class="glossseealso" href="glossary.html#glos_mysqld">mysqld</a>, <a class="glossseealso" href="glossary.html#glos_replication">レプリケーション</a>, <a class="glossseealso" href="glossary.html#glos_server">サーバー</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd><dt><a name="glos_instrumentation"></a><span class="glossterm">インストゥルメンテーション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765357888"></a>
        ソースコードレベルでの、チューニングおよびデバッグのパフォーマンスデータを収集するための変更。 MySQL では、インスツルメンテーションによって収集されたデータは、<code class="literal">INFORMATION_SCHEMA</code> および <code class="literal">PERFORMANCE_SCHEMA</code> データベースを使用して SQL インタフェースを介して公開されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_information_schema">INFORMATION_SCHEMA</a>, <a class="glossseealso" href="glossary.html#glos_performance_schema">パフォーマンススキーマ</a>も参照</p></dd><dt><a name="glos_intention_lock"></a><span class="glossterm">インテンションロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765289712"></a>
        テーブルに適用される <span class="bold"><strong>lock</strong></span> の一種で、<span class="bold"><strong>トランザクション</strong></span>がテーブル内の行に対して取得するロックの種類を示すために使用されます。 トランザクションごとに異なる種類のインテンションロックを取得できますが、最初のトランザクションがあるテーブルで <span class="emphasis"><em>インテンション排他</em></span> (IX) ロックを獲得すると、ほかのトランザクションはそのテーブルで S または X ロックを獲得できません。 反対に、最初のトランザクションがあるテーブルで<span class="emphasis"><em>インテンション共有</em></span> (IS) ロックを獲得すると、ほかのトランザクションはそのテーブルで X ロックを獲得できません。 2 フェーズプロセスは、ロックおよび互換性のある対応操作をブロックせずに、ロックリクエストを順番に解決できます。 このロックメカニズムの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-locking" title="15.7.1 InnoDB ロック">セクション15.7.1「InnoDB ロック」</a> を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_lock_mode">lock mode</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_insert_intention_lock"></a><span class="glossterm">インテンションロックの挿入</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765280784"></a>
        行の挿入前に <code class="literal">INSERT</code> 操作によって設定される<span class="bold"><strong>ギャップロック</strong></span>のタイプ。 このタイプの <span class="bold"><strong>lock</strong></span> は、同じインデックスギャップに挿入される複数のトランザクションがギャップ内の同じ位置に挿入されない場合に相互に待機する必要がないような方法で、挿入の意図を示します。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-locking" title="15.7.1 InnoDB ロック">セクション15.7.1「InnoDB ロック」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_gap_lock">ギャップロック</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_next_key_lock">ネクストキーロック</a>も参照</p></dd><dt><a name="glos_intention_shared_lock"></a><span class="glossterm">インテンション共有ロック</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_intention_lock">インテンションロック</a>も参照</p></dd><dt><a name="glos_intention_exclusive_lock"></a><span class="glossterm">インテンション排他ロック</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_intention_lock">インテンションロック</a>も参照</p></dd><dt><a name="glos_index"></a><span class="glossterm">インデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765352464"></a>
        <span class="bold"><strong>テーブル</strong></span>の<span class="bold"><strong>行</strong></span>を高速ルックアップする機能を提供するデータ構造。通常はこのために、特定の<span class="bold"><strong>カラム</strong></span>またはカラムセットのすべての値を表すツリー構造 (<span class="bold"><strong>B ツリー)</strong></span> を形成します。
      </p><p>
        <code class="literal">InnoDB</code> テーブルには、常に<span class="bold"><strong>主キー</strong></span>を表す<span class="bold"><strong>クラスタインデックス</strong></span>があります。 1 つ以上のカラムに 1 つ以上の<span class="bold"><strong>セカンダリインデックス</strong></span>を定義することもできます。 セカンダリインデックスは、その構造に応じて、<span class="bold"><strong>部分</strong></span>、<span class="bold"><strong>カラム</strong></span>、または<span class="bold"><strong>複合</strong></span>インデックスとして分類できます。 
      </p><p>
        インデックスは、<span class="bold"><strong>クエリー</strong></span>パフォーマンスの重要な側面です。 データベースアーキテクトは、アプリケーションが必要とするデータを高速なルックアップできるように、テーブル、クエリー、およびインデックスを設計します。 理想的なデータベース設計では、有用なときは<span class="bold"><strong>カバリングインデックス</strong></span>を使用します。クエリー結果は、実際のテーブルデータを読み取らずに完全にインデックスから計算されます。 <span class="bold"><strong>親</strong></span>テーブルと<span class="bold"><strong>子</strong></span>テーブルの両方に値が存在するかどうかを効率的に確認するために、各<span class="bold"><strong>外部キー</strong></span>制約にもインデックスが必要です。 
      </p><p>
        B ツリーインデックスは最も一般的ですが、<code class="literal">MEMORY</code> ストレージエンジンや <code class="literal">InnoDB</code> <span class="bold"><strong>適応型ハッシュインデックス</strong></span>のように、<span class="bold"><strong>ハッシュインデックス</strong></span>には異なる種類のデータ構造が使用されます。 <span class="bold"><strong>R-tree</strong></span> インデックスは、多次元情報の空間インデックス付けに使用されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_adaptive_hash_index">適応型ハッシュインデックス</a>, <a class="glossseealso" href="glossary.html#glos_b_tree">B ツリー</a>, <a class="glossseealso" href="glossary.html#glos_child_table">子テーブル</a>, <a class="glossseealso" href="glossary.html#glos_clustered_index">クラスタ化されたインデックス</a>, <a class="glossseealso" href="glossary.html#glos_column_index">カラムインデックス</a>, <a class="glossseealso" href="glossary.html#glos_composite_index">複合インデックス</a>, <a class="glossseealso" href="glossary.html#glos_covering_index">カバリングインデックス</a>, <a class="glossseealso" href="glossary.html#glos_foreign_key">外部キー</a>, <a class="glossseealso" href="glossary.html#glos_hash_index">ハッシュインデックス</a>, <a class="glossseealso" href="glossary.html#glos_parent_table">親テーブル</a>, <a class="glossseealso" href="glossary.html#glos_partial_index">部分インデックス</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>, <a class="glossseealso" href="glossary.html#glos_r_tree">R-tree</a>, <a class="glossseealso" href="glossary.html#glos_row">行</a>, <a class="glossseealso" href="glossary.html#glos_secondary_index">セカンダリインデックス</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd><dt><a name="glos_index_cache"></a><span class="glossterm">インデックスキャッシュ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765322720"></a>
        <code class="literal">InnoDB</code> <span class="bold"><strong>全文検索</strong></span>のトークンデータを保持するメモリー領域。 <span class="bold"><strong>FULLTEXT インデックス</strong></span>の一部であるカラムでデータが挿入または更新されるときのディスク I/O を最小限に抑えるために、データをバッファリングします。 インデックスキャッシュがいっぱいになると、トークンデータがディスクに書き込まれます。 各 <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> インデックスには独自のインデックスキャッシュがあり、そのサイズは構成オプション <code class="literal">innodb_ft_cache_size</code> によって制御されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_full_text_search">全文検索</a>, <a class="glossseealso" href="glossary.html#glos_fulltext_index">FULLTEXT インデックス</a>も参照</p></dd><dt><a name="glos_index_hint"></a><span class="glossterm">インデックスヒント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765305392"></a>
        オプティマイザが推奨する<span class="bold"><strong>インデックス</strong></span>をオーバーライドするための拡張 SQL 構文。 たとえば、<code class="literal">FORCE INDEX</code>、<code class="literal">USE INDEX</code>、および <code class="literal">IGNORE INDEX</code> 句。 通常は、インデックス付きカラムに値が不均等に分散されていて、<span class="bold"><strong>カーディナリティー</strong></span>を正確に見積もれないときに使用されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_cardinality">カーディナリティー</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>も参照</p></dd><dt><a name="glos_index_prefix"></a><span class="glossterm">インデックスプリフィクス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765298048"></a>
        複数のカラムに適用される<span class="bold"><strong>インデックス</strong></span> (<span class="bold"><strong>複合インデックス</strong></span>と呼ばれます) で、インデックスの先頭または末尾カラム。 複合インデックスの最初の 1、2、3 などのカラムを参照するクエリーはインデックスを使用できます (クエリーがインデックス内のすべてのカラムを参照するわけではない場合でも)。 
      </p><p><a class="glossseealso" href="glossary.html#glos_composite_index">複合インデックス</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>も参照</p></dd><dt><a name="glos_index_condition_pushdown"></a><span class="glossterm">インデックス条件プッシュダウン</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765313680"></a>
        インデックス条件プッシュダウン (ICP) は、<span class="bold"><strong>index</strong></span> のフィールドを使用して条件の一部を評価できる場合に、<code class="literal">WHERE</code> 条件の一部をストレージエンジンにプッシュダウンする最適化です。 ICP は、<span class="bold"><strong>ストレージエンジン</strong></span>が実テーブルにアクセスする必要がある回数と、MySQL サーバーがストレージエンジンにアクセスする必要がある回数を減らすことができます。 詳細は、<a class="xref" href="optimization.html#index-condition-pushdown-optimization" title="8.2.1.6 インデックスコンディションプッシュダウンの最適化">セクション8.2.1.6「インデックスコンディションプッシュダウンの最適化」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_storage_engine">ストレージエンジン</a>も参照</p></dd><dt><a name="glos_index_statistics"></a><span class="glossterm">インデックス統計</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_statistics">統計</a>も参照</p></dd><dt><a name="glos_in_memory_database"></a><span class="glossterm">インメモリーデータベース</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765273040"></a>
        ディスクブロックとメモリー領域間のディスク I/O および変換によるオーバーヘッドを回避するために、メモリー内にデータを保持するタイプのデータベースシステム。 一部のインメモリーデータベースは耐久性 (<span class="bold"><strong>ACID</strong></span> 設計理念の <span class="quote">「<span class="quote">D</span>」</span>) を犠牲にしており、ハードウェア、電源およびその他のタイプの障害に対して脆弱であるため、読取り専用操作に適しています。 ほかのインメモリーデータベースでは、変更ログをディスクに記録したり不揮発性メモリーを使用したりなどの持続性メカニズムを使用します。 
      </p><p>
        同じ種類のメモリー集中型処理に対処する MySQL 機能には、<code class="literal">InnoDB</code> <span class="bold"><strong>バッファプール</strong></span>、<span class="bold"><strong>適応型ハッシュインデックス</strong></span>および<span class="bold"><strong>読取り専用トランザクション</strong></span>の最適化、<code class="literal">MEMORY</code> ストレージエンジン、<code class="literal">MyISAM</code> キーキャッシュおよび MySQL クエリーキャッシュが含まれます。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_adaptive_hash_index">適応型ハッシュインデックス</a>, <a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_disk_based">ディスクベース</a>, <a class="glossseealso" href="glossary.html#glos_read_only_transaction">読み取り専用トランザクション</a>も参照</p></dd><dt><a name="glos_unique_index"></a><span class="glossterm">一意のインデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765443200"></a>
        <span class="bold"><strong>一意制約</strong></span>が適用されるカラムまたはカラムセットのインデックス。 インデックスが重複値を含まないことがわかっているので、特定の種類のルックアップとカウント操作が通常の種類のインデックスよりも効率的になります。 このタイプのインデックスに対するほとんどのルックアップは、単純に特定の値が存在するかどうかを判断することです。 インデックス内の値の数は、テーブル内の行数と同じであるか、関連付けられたカラムが NULL 以外の値である行の数以上です。 
      </p><p>
        <span class="bold"><strong>バッファリングの変更</strong></span>の最適化は、一意インデックスには適用されません。 回避策として、<code class="literal">InnoDB</code> テーブルへのバルクデータロードの実行中に <code class="literal">unique_checks=0</code> を一時的に設定できます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_cardinality">カーディナリティー</a>, <a class="glossseealso" href="glossary.html#glos_change_buffering">変更バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_unique_constraint">一意制約</a>, <a class="glossseealso" href="glossary.html#glos_unique_key">一意のキー</a>も参照</p></dd><dt><a name="glos_unique_key"></a><span class="glossterm">一意のキー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765433920"></a>
        <span class="bold"><strong>一意のインデックス</strong></span>を構成するカラムセット (1 つまたは複数)。 正確に 1 行に一致する <code class="literal">WHERE</code> 条件を定義でき、クエリーが関連付けられた一意のインデックスを使用できるときは、ルックアップおよびエラー処理を非常に効率的に実行できます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_cardinality">カーディナリティー</a>, <a class="glossseealso" href="glossary.html#glos_unique_constraint">一意制約</a>, <a class="glossseealso" href="glossary.html#glos_unique_index">一意のインデックス</a>も参照</p></dd><dt><a name="glos_unique_constraint"></a><span class="glossterm">一意制約</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765449920"></a>
        重複値をカラムに含むことができないと表明するタイプの<span class="bold"><strong>制約</strong></span>。 <span class="bold"><strong>リレーショナル</strong></span>代数の観点では、1 対 1 関係を指定するために使用されます。 ある値を挿入できるかどうかをチェックするときの効率性のために (つまり、その値がカラムにまだ存在していない)、一意制約が基礎となる<span class="bold"><strong>一意のインデックス</strong></span>でサポートされます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_constraint">制約</a>, <a class="glossseealso" href="glossary.html#glos_relational">リレーショナル</a>, <a class="glossseealso" href="glossary.html#glos_unique_index">一意のインデックス</a>も参照</p></dd><dt><a name="glos_temporary_table"></a><span class="glossterm">一時テーブル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765428176"></a>
        データを真に永続的にする必要がない <span class="bold"><strong>table</strong></span>。 たとえば、一時テーブルを複雑な計算または変換の中間結果のストレージ領域として使用できます。この中間データはクラッシュ後にリカバリする必要がありません。 データベース製品は、データをディスクに書き込むことや再起動をまたがってデータを保護する手段について緻密さを軽減することで、一時テーブルに対する操作パフォーマンスを手軽に改善できます。 
      </p><p>
        トランザクション終了時やセッション終了時などに、データ自体が所定時に自動的に削除されることもあります。 一部のデータベース製品では、テーブル自体も自動的に削除されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd><dt><a name="glos_temporary_tablespace"></a><span class="glossterm">一時テーブルスペース</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765422352"></a>
        <code class="literal">InnoDB</code> では、2 つのタイプの一時テーブルスペースを使用します。 <span class="emphasis"><em>セッション一時テーブルスペース</em></span>には、オプティマイザによって作成されたユーザー作成一時テーブルおよび内部一時テーブルが格納されます。 <span class="emphasis"><em>グローバル一時テーブルスペース</em></span>には、ユーザーが作成した一時テーブルに対して行われた変更のために<span class="emphasis"><em>ロールバックセグメント</em></span>が格納されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_global_temporary_tablespace">グローバル一時テーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_session_temporary_tablespace">セッション一時テーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_temporary_table">一時テーブル</a>も参照</p></dd><dt><a name="glos_general_query_log"></a><span class="glossterm">一般クエリーログ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765397520"></a>
        MySQL Server によって処理された SQL ステートメントの診断およびトラブルシューティングに使用されるタイプの<span class="bold"><strong>ログ</strong></span>。 ファイルまたはデータベーステーブルにも格納できます。 この機能を使用するには、<code class="literal">general_log</code> 構成オプションを通じて有効にする必要があります。 <code class="literal">sql_log_off</code> 構成オプションを通じて特定の接続に対してこれを無効にできます。 
      </p><p>
        <span class="bold"><strong>スロークエリーログ</strong></span>よりも広い範囲のクエリーを記録します。 レプリケーションに使用される<span class="bold"><strong>バイナリログ</strong></span>とは異なり、一般クエリーログは <code class="literal">SELECT</code> ステートメントを含み、厳密な順序を維持しません。 詳細は、<a class="xref" href="server-administration.html#query-log" title="5.4.3 一般クエリーログ">セクション5.4.3「一般クエリーログ」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_binary_log">バイナリログ</a>, <a class="glossseealso" href="glossary.html#glos_log">ログ</a>, <a class="glossseealso" href="glossary.html#glos_slow_query_log">スロークエリーログ</a>も参照</p></dd><dt><a name="glos_general_tablespace"></a><span class="glossterm">一般テーブルスペース</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765386208"></a>
        <code class="literal">CREATE TABLESPACE</code> 構文を使用して作成された共有 <code class="literal">InnoDB</code> <span class="bold"><strong>テーブルスペース</strong></span>。 一般テーブルスペースは、MySQL データディレクトリの外部に作成でき、複数の<span class="bold"><strong>テーブル</strong></span>を保持でき、すべての行形式のテーブルをサポートします。 一般的なテーブルスペースは、MySQL 5.7.6 で導入されました。 
      </p><p>
        テーブルは、<code class="literal">CREATE TABLE <em class="replaceable"><code>tbl_name</code></em> ... TABLESPACE [=] <em class="replaceable"><code>tablespace_name</code></em></code> または <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> TABLESPACE [=] <em class="replaceable"><code>tablespace_name</code></em></code> 構文を使用して一般テーブルスペースに追加されます。
      </p><p>
        <span class="bold"><strong>システムテーブルスペース</strong></span>および <span class="bold"><strong>file-per-table</strong></span> テーブルスペースと対比してください。
      </p><p>
        詳細は、<a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="15.6.3.3 一般テーブルスペース">セクション15.6.3.3「一般テーブルスペース」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd><dt><a name="glos_general_log"></a><span class="glossterm">一般ログ</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_general_query_log">一般クエリーログ</a>も参照</p></dd><dt><a name="glos_consistent_read"></a><span class="glossterm">一貫性読み取り</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765415872"></a>
        <span class="bold"><strong>snapshot</strong></span> 情報を使用して、同時に実行されている他のトランザクションによって実行された変更に関係なく、ある時点に基づいてクエリー結果を表示する読取り操作。 照会されるデータが別のトランザクションによって変更されている場合、元のデータは <span class="bold"><strong>Undo ログ</strong></span>の内容に基づいて再構築されます。 この方法は、ほかのトランザクションが終了するのを待機するようにトランザクションを強制することによって、<span class="bold"><strong>並列性</strong></span>を減少させる可能性のあるいくつかの<span class="bold"><strong>ロック</strong></span>問題を回避します。 
      </p><p>
        <span class="bold"><strong>REPEATABLE READ</strong></span> <span class="bold"><strong>分離レベル</strong></span>では、スナップショットは最初の読取り操作が実行された時間に基づきます。 <span class="bold"><strong>READ COMMITTED</strong></span> 分離レベルでは、スナップショットは各読取り一貫性操作の時間にリセットされます。 
      </p><p>
        一貫性読み取りは、<code class="literal">InnoDB</code> が <span class="bold"><strong>READ COMMITTED</strong></span> および <span class="bold"><strong>REPEATABLE READ</strong></span> 分離レベルで <code class="literal">SELECT</code> ステートメントを処理する際のデフォルトモードです。 一貫性読み取りはアクセスするテーブルでロックを設定しないので、テーブルで一貫性読み取りが実行されている間、ほかのセッションはそれらのテーブルを自由に変更できます。 
      </p><p>
        適用可能な分離レベルの技術的な詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-consistent-read" title="15.7.2.3 一貫性非ロック読み取り">セクション15.7.2.3「一貫性非ロック読み取り」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_read_committed">READ COMMITTED</a>, <a class="glossseealso" href="glossary.html#glos_repeatable_read">REPEATABLE READ</a>, <a class="glossseealso" href="glossary.html#glos_snapshot">スナップショット</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_undo_log">Undo ログ</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ウ</h3><dl><dt><a name="glos_warm_up"></a><span class="glossterm">ウォームアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765259616"></a>
        起動後の一定期間、標準的な<span class="bold"><strong>ワークロード</strong></span>でシステムを実行すること。通常の状況時のように<span class="bold"><strong>バッファープール</strong></span>とほかのメモリー領域がいっぱいになります。 このプロセスは、MySQL Server が再起動したり新しいワークロードを課せられたりしたときに、一定時間をかけて自然に発生します。 
      </p><p>
        通常は、複数の実行間で一貫した結果を保証するために、一定期間ワークロードを実行してバッファープールをウォームアップしてから、パフォーマンステストを実行してください。そのようにしない場合、パフォーマンスが最初の実行中に不自然に低くなる場合があります。
      </p><p>
        MySQL 5.6 では、<code class="literal">innodb_buffer_pool_dump_at_shutdown</code> および <code class="literal">innodb_buffer_pool_load_at_startup</code> 構成オプションを有効にしてウォームアッププロセスを高速化し、再起動後にバッファープールの内容をメモリーに戻すことができます。 これらのオプションは、MySQL 5.7 ではデフォルトで有効になっています。 <a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="15.8.3.6 バッファープールの状態の保存と復元">セクション15.8.3.6「バッファープールの状態の保存と復元」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_workload">ワークロード</a>も参照</p></dd><dt><a name="glos_warm_backup"></a><span class="glossterm">ウォームバックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765249648"></a>
        データベースの実行中に行われるが、バックアッププロセス中に一部のデータベース操作を制限する<span class="bold"><strong>バックアップ</strong></span>。 たとえば、テーブルが読み取り専用になることがあります。 ビジー状態のアプリケーションおよび web サイトの場合は、<span class="bold"><strong>ホットバックアップ</strong></span>を使用することをお薦めします。 
      </p><p><a class="glossseealso" href="glossary.html#glos_backup">バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_cold_backup">コールドバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>も参照</p></dd><dt><a name="glos_embedded"></a><span class="glossterm">埋込み</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765243744"></a>
        埋込み MySQL サーバーライブラリ (<span class="bold"><strong>libmysqld</strong></span>) を使用すると、<span class="bold"><strong>client</strong></span> アプリケーション内でフル機能の MySQL サーバーを実行できます。 この主なメリットは組み込みアプリケーションの速度の向上と管理の単純化です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_client">クライアント</a>, <a class="glossseealso" href="glossary.html#glos_libmysqld">libmysqld</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">エ</h3><dl><dt><a name="glos_extent"></a><span class="glossterm">エクステント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765228496"></a>
        <span class="bold"><strong>テーブルスペース</strong></span>内の<span class="bold"><strong>ページ</strong></span>のグループ。 デフォルトの<span class="bold"><strong>ページサイズ</strong></span>が 16KB の場合、エクステントには 64 ページが含まれます。 MySQL 5.6 では、<code class="literal">InnoDB</code> インスタンスのページサイズには 4K バイト、8K バイト、16K バイトがあり、<code class="literal">innodb_page_size</code> 構成オプションで制御されます。 4K バイト、8K バイト、および 16K バイトのページサイズでは、エクステントサイズは常に 1M バイト (つまり 1048576 バイト) です。 
      </p><p>
        32K バイトおよび 64K バイトの <code class="literal">InnoDB</code> ページサイズのサポートが MySQL 5.7.6 で追加されました。 32K バイトページサイズの場合、エクステントサイズは 2M バイトです。 64K バイトページサイズの場合、エクステントサイズは 4M バイトです。 
      </p><p>
        <span class="bold"><strong>セグメント</strong></span>、<span class="bold"><strong>先読み</strong></span>リクエスト、および<span class="bold"><strong>二重書き込みバッファー</strong></span>などの <code class="literal">InnoDB</code> 機能は、一度に 1 つのエクステントでデータの読み取り、書き込み、割り当て、または解放を行う I/O 操作を使用します。
      </p><p><a class="glossseealso" href="glossary.html#glos_doublewrite_buffer">二重書き込みバッファー</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_page_size">page size</a>, <a class="glossseealso" href="glossary.html#glos_read_ahead">先読み</a>, <a class="glossseealso" href="glossary.html#glos_segment">セグメント</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd><dt><a name="glos_eviction"></a><span class="glossterm">エビクション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765213440"></a>
        キャッシュまたはその他の一時記憶域 (<code class="literal">InnoDB</code> <span class="bold"><strong>バッファプール</strong></span>など) からアイテムを削除するプロセス。 常にではないけれども多くの場合、<span class="bold"><strong>LRU</strong></span> アルゴリズムを使用して、削除する項目を決定します。 <span class="bold"><strong>ダーティページ</strong></span>が削除されると、その内容は <span class="bold"><strong>flushed</strong></span> からディスクになり、使用済の<span class="bold"><strong>ネイバーページ</strong></span>もフラッシュされる可能性があります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_dirty_page">ダーティーページ</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_lru">LRU</a>, <a class="glossseealso" href="glossary.html#glos_neighbor_page">隣接ページ</a>も参照</p></dd><dt><a name="glos_error_log"></a><span class="glossterm">エラーログ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765203776"></a>
        MySQL 起動に関する情報と、重要な実行時エラーおよび<span class="bold"><strong>クラッシュ</strong></span>情報を示すタイプの<span class="bold"><strong>ログ</strong></span>。 詳細は、<a class="xref" href="server-administration.html#error-log" title="5.4.2 エラーログ">セクション5.4.2「エラーログ」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_crash">クラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_log">ログ</a>も参照</p></dd><dt><a name="glos_persistent_statistics"></a><span class="glossterm">永続的統計</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765237648"></a>
        <code class="literal">InnoDB</code> <span class="bold"><strong>テーブル</strong></span>の <span class="bold"><strong>index</strong></span> 統計をディスクに格納し、<span class="bold"><strong>クエリー</strong></span>の<span class="bold"><strong>プランスタビリティ</strong></span>を向上させる機能。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="15.8.10.1 永続的オプティマイザ統計のパラメータの構成">セクション15.8.10.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_optimizer">オプティマイザ</a>, <a class="glossseealso" href="glossary.html#glos_plan_stability">計画安定性</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">オ</h3><dl><dt><a name="glos_off_page_column"></a><span class="glossterm">オフページカラム</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765153184"></a>
        長すぎるため <span class="bold"><strong>B ツリー</strong></span>ページに収まらない可変長データを含むカラム (<code class="literal">BLOB</code> や <code class="literal">VARCHAR</code> など)。 データは<span class="bold"><strong>オーバーフローページ</strong></span>に格納されます。 <span class="bold"><strong>DYNAMIC</strong></span> の行形式は、古い <span class="bold"><strong>COMPACT</strong></span> の行形式よりもこのような記憶域の方が効率的です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_b_tree">B ツリー</a>, <a class="glossseealso" href="glossary.html#glos_compact_row_format">コンパクト行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_dynamic_row_format">動的行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_overflow_page">オーバーフローページ</a>も参照</p></dd><dt><a name="glos_option"></a><span class="glossterm">オプション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765189520"></a>
        MySQL の構成パラメータ。<span class="bold"><strong>オプションファイル</strong></span>に格納されるか、コマンド行で渡されます。
      </p><p>
        <span class="bold"><strong>InnoDB</strong></span> テーブルに適用される <span class="bold"><strong>options</strong></span> の場合、各オプション名は接頭辞 <code class="literal">innodb_</code>で始まります。
      </p><p><a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_option">オプション</a>, <a class="glossseealso" href="glossary.html#glos_option_file">オプションファイル</a>も参照</p></dd><dt><a name="glos_option_file"></a><span class="glossterm">オプションファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765181984"></a>
        MySQL インスタンスの構成<span class="bold"><strong>オプション</strong></span>を保持するファイル。 従来、Linux および Unix では、このファイルの名前は <code class="literal">my.cnf</code> で、Windows では <code class="literal">my.ini</code> です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_configuration_file">構成ファイル</a>, <a class="glossseealso" href="glossary.html#glos_my_cnf">my.cnf</a>, <a class="glossseealso" href="glossary.html#glos_my_ini">my.ini</a>, <a class="glossseealso" href="glossary.html#glos_option">オプション</a>も参照</p></dd><dt><a name="glos_optimizer"></a><span class="glossterm">オプティマイザ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765175232"></a>
        該当する<span class="bold"><strong>テーブル</strong></span>の特性とデータ分布に基づいて、<span class="bold"><strong>クエリー</strong></span>に使用する最適な<span class="bold"><strong>インデックス</strong></span>および<span class="bold"><strong>結合</strong></span>順序を決定する MySQL コンポーネント。
      </p><p><a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_join">結合</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd><dt><a name="glos_optimistic"></a><span class="glossterm">オプティミスティック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765167776"></a>
        リレーショナルデータベースシステムの低レベル実装決定を導く概念。 リレーショナルデータベースでパフォーマンスと<span class="bold"><strong>並列性</strong></span>が必要であることは、操作を迅速に開始またはディスパッチする必要があることを意味します。 一貫性と<span class="bold"><strong>参照整合性</strong></span>が必要であることは、どの操作も失敗する可能性があることを意味します。つまり、トランザクションがロールバックされ、<span class="bold"><strong>DML</strong></span> 操作が制約を違反し、ロックのリクエストがデッドロックになり、ネットワークエラーがタイムアウトになる可能性があります。 オプティミスティック戦略は、ほとんどのリクエストまたは試行が成功したことを前提としているため、失敗ケースを準備するために比較的少ない作業が行われます。 この想定が true のときは、データベースは不要な作業をほとんど行いません。リクエストが失敗したときは、変更をクリーンアップして元に戻すために追加作業が必要になります。 
      </p><p>
        <code class="literal">InnoDB</code> では、<span class="bold"><strong>ロック</strong></span>、<span class="bold"><strong>commits</strong></span> などの操作にオプティミスティック戦略を使用します。 たとえば、トランザクションによって変更されたデータは、コミットが発生する前にデータファイルに書き込むことができるため、コミット自体は非常に速いですが、トランザクションがロールバックされた場合に変更を元に戻すためにより多くの作業が必要です。 
      </p><p>
        オプティミスティック戦略の反対が<span class="bold"><strong>ペシミスティック</strong></span>戦略で、信頼性が低く頻繁に失敗する操作に対応するようにシステムが最適化されます。 この概念はデータベースシステムではまれです。信頼性の高いハードウェア、ネットワーク、およびアルゴリズムを選択することに非常の多くの努力が注ぎ込まれるためです。 
      </p><p><a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_pessimistic">ペシミスティック</a>, <a class="glossseealso" href="glossary.html#glos_referential_integrity">参照整合性</a>も参照</p></dd><dt><a name="glos_online"></a><span class="glossterm">オンライン</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765143600"></a>
        データベースのダウンタイム、ブロック、または制限された操作のないタイプの操作。 通常は <span class="bold"><strong>DDL</strong></span> に適用されます。 <span class="bold"><strong>高速インデックス作成</strong></span>など、制限された操作の期間を短かくする操作は、MySQL 5.6 で 幅広い<span class="bold"><strong>オンライン DDL</strong></span> 操作セットに進化しました。 
      </p><p>
        バックアップのコンテキストでは、<span class="bold"><strong>ホットバックアップ</strong></span>はオンライン操作、<span class="bold"><strong>ウォームバックアップ</strong></span>は部分的にオンライン操作です。
      </p><p><a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_fast_index_creation">高速インデックス作成</a>, <a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_online_ddl">オンライン DDL</a>, <a class="glossseealso" href="glossary.html#glos_warm_backup">ウォームバックアップ</a>も参照</p></dd><dt><a name="glos_online_ddl"></a><span class="glossterm">オンライン DDL</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765134128"></a>
        <span class="bold"><strong>DDL</strong></span>(主に <code class="literal">ALTER TABLE</code>) 操作中の <code class="literal">InnoDB</code> テーブルのパフォーマンス、同時実行性および可用性を向上させる機能。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl" title="15.12 InnoDB とオンライン DDL">セクション15.12「InnoDB とオンライン DDL」</a>を参照してください。 
      </p><p>
        詳細は、操作の種類に応じて異なります。 場合によっては、<code class="literal">ALTER TABLE</code> の進行中にテーブルを同時に変更できます。 操作は、テーブルコピーなしで実行することも、特別に最適化されたタイプのテーブルコピーを使用して実行することもできます。 インプレース操作の DML ログ領域使用量は、<code class="literal">innodb_online_alter_log_max_size</code> 構成オプションによって制御されます。 
      </p><p>
        この機能は、MySQL 5.5 の<span class="bold"><strong>高速インデックス作成</strong></span>機能の拡張です。
      </p><p><a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_fast_index_creation">高速インデックス作成</a>, <a class="glossseealso" href="glossary.html#glos_online">オンライン</a>も参照</p></dd><dt><a name="glos_overflow_page"></a><span class="glossterm">オーバーフローページ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765197216"></a>
        可変長カラム (<code class="literal">BLOB</code> や <code class="literal">VARCHAR</code> など) が長すぎて <span class="bold"><strong>B ツリー</strong></span>ページに収まらない場合に、それらを保持するために別個に割り当てられたディスク<span class="bold"><strong>ページ</strong></span>。 関連付けられたカラムは<span class="bold"><strong>オフページカラム</strong></span>と呼ばれます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_b_tree">B ツリー</a>, <a class="glossseealso" href="glossary.html#glos_off_page_column">オフページカラム</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">カ</h3><dl><dt><a name="glos_counter"></a><span class="glossterm">カウンタ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765083184"></a>
        特定の種類の <code class="literal">InnoDB</code> 操作によって増分される値。 サーバーがどれだけビジーかを測定する、パフォーマンス問題の原因をトラブルシューティングする、(たとえば、クエリーが使用する構成設定またはインデックスへの) 変更が目的の低レベル効果を持っているかどうかをテストする場合に役立ちます。 <span class="bold"><strong>パフォーマンススキーマ</strong></span>テーブルおよび <span class="bold"><strong>INFORMATION_SCHEMA</strong></span> テーブル (特に <code class="literal">INFORMATION_SCHEMA.INNODB_METRICS</code>) では、様々な種類のカウンタを使用できます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_information_schema">INFORMATION_SCHEMA</a>, <a class="glossseealso" href="glossary.html#glos_metrics_counter">メトリックカウンタ</a>, <a class="glossseealso" href="glossary.html#glos_performance_schema">パフォーマンススキーマ</a>も参照</p></dd><dt><a name="glos_covering_index"></a><span class="glossterm">カバリングインデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765053440"></a>
        クエリーによって取得されたすべてのカラムを含む<span class="bold"><strong>インデックス</strong></span>。 完全なテーブル行を見つけるためのポインタとしてインデックス値を使用する代わりに、クエリーはインデックス構造から値を返し、ディスク I/O を節約します。 <code class="literal">InnoDB</code> <span class="bold"><strong>セカンダリインデックス</strong></span>には<span class="bold"><strong>主キー</strong></span>カラムも含まれているため、<code class="literal">InnoDB</code> では、MyISAM で可能なより多くのインデックスにこの最適化手法を適用できます。 <code class="literal">InnoDB</code> では、トランザクションが終了するまで、トランザクションによって変更されたテーブルに対するクエリーにこの方法を適用できません。 
      </p><p>
        正しいクエリーの場合、どの<span class="bold"><strong>カラムインデックス</strong></span>または<span class="bold"><strong>複合インデックス</strong></span>でも、カバリングインデックスとして機能できます。 可能な場合は必ず、この最適化方法を活用するようにインデックスおよびクエリーを設計してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_column_index">カラムインデックス</a>, <a class="glossseealso" href="glossary.html#glos_composite_index">複合インデックス</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>, <a class="glossseealso" href="glossary.html#glos_secondary_index">セカンダリインデックス</a>も参照</p></dd><dt><a name="glos_column"></a><span class="glossterm">カラム</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765025648"></a>
        ストレージおよびセマンティクスがデータ型によって定義される、<span class="bold"><strong>行</strong></span>内のデータ項目。 それぞれの<span class="bold"><strong>テーブル</strong></span>および<span class="bold"><strong>インデックス</strong></span>は主に、そこに含まれるカラムセットによって定義されます。 
      </p><p>
        それぞれのカラムには<span class="bold"><strong>カーディナリティー</strong></span>値があります。 カラムは、そのテーブルの<span class="bold"><strong>主キー</strong></span>であったり、主キーの一部であったりします。 カラムは、<span class="bold"><strong>一意制約</strong></span>または <span class="bold"><strong>NOT NULL 制約</strong></span>、あるいはその両方により制限される場合があります。 別のカラム内の値には、異なるテーブルにまたがっている場合でも、<span class="bold"><strong>外部キー</strong></span>関係によってリンクできます。 
      </p><p>
        MySQL 内部操作についてディスカッションするときに、シノニムとして<span class="bold"><strong>フィールド</strong></span>が使用されることがあります。
      </p><p><a class="glossseealso" href="glossary.html#glos_cardinality">カーディナリティー</a>, <a class="glossseealso" href="glossary.html#glos_foreign_key">外部キー</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_not_null_constraint">NOT NULL 制約</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>, <a class="glossseealso" href="glossary.html#glos_row">行</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>, <a class="glossseealso" href="glossary.html#glos_unique_constraint">一意制約</a>も参照</p></dd><dt><a name="glos_column_index"></a><span class="glossterm">カラムインデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765011104"></a>
        単一カラムの<span class="bold"><strong>インデックス</strong></span>。
      </p><p><a class="glossseealso" href="glossary.html#glos_composite_index">複合インデックス</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>も参照</p></dd><dt><a name="glos_column_prefix"></a><span class="glossterm">カラムプリフィクス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765006928"></a>
        <span class="bold"><strong>index</strong></span> が長さ指定 (<code class="literal">CREATE INDEX idx ON t1 (c1(N))</code> など) で作成されると、カラム値の最初の N 文字のみがインデックスに格納されます。 インデックスプリフィクスを小さいまま維持すると、インデックスがコンパクトになり、メモリーとディスク I/O の節約によりパフォーマンスが向上します。 (ただし、インデックスプリフィクスを小さくし過ぎると、値の異なる行がクエリーオプティマイザには重複していると見えるようになり、クエリー最適化を妨げる可能性があります。) 
      </p><p>
        バイナリ値や長いテキスト文字列を含むカラムの場合、ソートは主な考慮事項ではなく、値全体をインデックスに格納すると領域が浪費されるので、インデックスは自動的に、最初の N (通常 768) 文字を使用してルックアップおよびソートを行います。
      </p><p><a class="glossseealso" href="glossary.html#glos_index">インデックス</a>も参照</p></dd><dt><a name="glos_cursor"></a><span class="glossterm">カーソル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765121968"></a>
        SQL ステートメントの結果セットを表す内部 MySQL データ構造。 多くの場合、<span class="bold"><strong>プリペアドステートメント</strong></span>および<span class="bold"><strong>動的 SQL</strong></span>で使用されます。 これは、ほかの高級言語でのイテレータのように機能し、リクエストに応じて結果セットからそれぞれの値を生成します。 
      </p><p>
        通常、SQL はカーソルの処理を処理しますが、パフォーマンスが重視されるコードを処理する際には、内部の作業に深刻になる可能性があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_dynamic_sql">動的 SQL</a>, <a class="glossseealso" href="glossary.html#glos_prepared_statement">プリペアドステートメント</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>も参照</p></dd><dt><a name="glos_cardinality"></a><span class="glossterm">カーディナリティー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765115136"></a>
        テーブル<span class="bold"><strong>カラム</strong></span>内の異なる値の数。 <span class="bold"><strong>インデックス</strong></span>が関連付けられたカラムをクエリーが参照するときに、各カラムのカーディナリティーはどのアクセス方法がもっとも効率的かに影響します。 たとえば、<span class="bold"><strong>一意制約</strong></span>が適用されるカラムの場合、異なる値の数はテーブル内の行数に等しくなります。 テーブル内の行数が 100 万なのに、特定のカラムの異なる値が 10 個だけの場合は、各値は (平均) 100,000 回発生します。 したがって、<code class="literal">SELECT c1 FROM t1 WHERE c1 = 50;</code> などのクエリーが 1 行を返したり非常に多数の行を返したりする可能性があり、データベースサーバーはこのクエリーを <code class="literal">c1</code> のカーディナリティーに応じてさまざまに処理できます。 
      </p><p>
        カラム内の値が非常に不規則に分布している場合は、カーディナリティーが最善のクエリー計画を決定するうえで適切な方法でないことがあります。 たとえば、<code class="literal">SELECT c1 FROM t1 WHERE c1 = x;</code> は <code class="literal">x=50</code> のときに 1 行を返し、<code class="literal">x=30</code> のときに 100 万行を返します。 このような場合、どのルックアップ方法が特定のクエリーにより効率的かについてアドバイスを伝えるために、<span class="bold"><strong>インデックスヒント</strong></span>を使用する必要があります。 
      </p><p>
        カーディナリティーは、<span class="bold"><strong>複合インデックス</strong></span>の場合と同様に、複数のカラムに存在する異なる値の数にも適用できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_column">カラム</a>, <a class="glossseealso" href="glossary.html#glos_composite_index">複合インデックス</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_index_hint">インデックスヒント</a>, <a class="glossseealso" href="glossary.html#glos_persistent_statistics">永続的統計</a>, <a class="glossseealso" href="glossary.html#glos_random_dive">ランダムダイブ</a>, <a class="glossseealso" href="glossary.html#glos_selectivity">選択性</a>, <a class="glossseealso" href="glossary.html#glos_unique_constraint">一意制約</a>も参照</p></dd><dt><a name="glos_virtual_index"></a><span class="glossterm">仮想インデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765068464"></a>
        仮想インデックスは、1 つ以上の<span class="bold"><strong>仮想生成カラム</strong></span>上、または仮想生成カラムと通常のカラムまたは格納された生成カラムの組合せ上の<span class="bold"><strong>セカンダリインデックス</strong></span>です。 詳細は、<a class="xref" href="sql-statements.html#create-table-secondary-indexes" title="13.1.20.9 セカンダリインデックスと生成されたカラム">セクション13.1.20.9「セカンダリインデックスと生成されたカラム」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_secondary_index">セカンダリインデックス</a>, <a class="glossseealso" href="glossary.html#glos_stored_generated_column">ストアド生成カラム</a>, <a class="glossseealso" href="glossary.html#glos_virtual_generated_column">仮想生成カラム</a>も参照</p></dd><dt><a name="glos_virtual_column"></a><span class="glossterm">仮想カラム</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_virtual_generated_column">仮想生成カラム</a>も参照</p></dd><dt><a name="glos_virtual_generated_column"></a><span class="glossterm">仮想生成カラム</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765060688"></a>
        カラム定義に含まれる式から値が計算されるカラム。 カラム値は格納されませんが、<code class="literal">BEFORE</code> トリガーの直後に行が読み取られたときに評価されます。 仮想生成カラムは記憶域を取りません。 <code class="literal">InnoDB</code> では、仮想生成カラムのセカンダリインデックスがサポートされます。 
      </p><p>
        <span class="bold"><strong>ストアド生成カラム</strong></span>と対比してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_base_column">ベースカラム</a>, <a class="glossseealso" href="glossary.html#glos_generated_column">生成されるカラム</a>, <a class="glossseealso" href="glossary.html#glos_stored_generated_column">ストアド生成カラム</a>も参照</p></dd><dt><a name="glos_variable_length_type"></a><span class="glossterm">可変長型</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765041024"></a>
        可変長のデータ型。 <code class="literal">VARCHAR</code>、<code class="literal">VARBINARY</code>、<code class="literal">BLOB</code> および <code class="literal">TEXT</code> 型は可変長型です。 
      </p><p>
        <code class="literal">InnoDB</code> では、768 バイト以上の固定長フィールドは可変長フィールドとして扱われ、<span class="bold"><strong>off-page</strong></span> に格納できます。 たとえば、<code class="literal">utf8mb4</code> と同様に、文字セットの最大バイト長が 3 より大きい場合、<code class="literal">CHAR(255)</code> カラムは 768 バイトを超えることがあります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_off_page_column">オフページカラム</a>, <a class="glossseealso" href="glossary.html#glos_overflow_page">オーバーフローページ</a>も参照</p></dd><dt><a name="glos_availability"></a><span class="glossterm">可用性</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765029808"></a>
        ホストでの障害 (MySQL、オペレーティングシステム、ハードウェア、メンテナンス作業での障害を含む) に対処し、必要に応じてリカバリする能力 (ない場合は、ダウンタイムが発生する可能性があります)。 多くの場合、大規模開発の重要な側面として、<span class="bold"><strong>スケーラビリティー</strong></span>と組み合わされます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_scalability">スケーラビリティー</a>も参照</p></dd><dt><a name="glos_foreign_key"></a><span class="glossterm">外部キー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765098496"></a>
        個別の <code class="literal">InnoDB</code> テーブルの行間のポインタ関係のタイプ。 外部キー関係は、<span class="bold"><strong>親テーブル</strong></span>および<span class="bold"><strong>子テーブル</strong></span>の 1 つのカラムに定義されます。 
      </p><p>
        外部キーは、関連情報の高速ルックアップを有効にすることに加えて、データが挿入、更新、および削除されるときにこれらのポインタが無効になるのを防ぐことによって<span class="bold"><strong>参照整合性</strong></span>を適用するのに役立ちます。 この適用メカニズムは一種の<span class="bold"><strong>制約</strong></span>です。 別のテーブルをポイントする行は、関連付けられた外部キー値がその別のテーブルに存在しない場合、挿入できません。 行が削除されているか、その外部キー値が変化していて、別のテーブル内の行がその外部キー値をポイントしている場合は、削除を防止したり、ほかのテーブル内の対応するカラム値が <span class="bold"><strong>NULL</strong></span> になるようにしたり、ほかのテーブル内の対応する行を自動的に削除したりするように外部キーを設定できます。 
      </p><p>
        <span class="bold"><strong>正規化</strong></span>データベースを設計する際の段階の 1 つは、複製されるデータを特定し、そのデータを新しいテーブルに分離し、<span class="bold"><strong>結合</strong></span>操作を使用して複数のテーブルを単一テーブルのように照会できるように外部キー関係を設定することです。
      </p><p><a class="glossseealso" href="glossary.html#glos_child_table">子テーブル</a>, <a class="glossseealso" href="glossary.html#glos_foreign_key_constraint">FOREIGN KEY 制約</a>, <a class="glossseealso" href="glossary.html#glos_join">結合</a>, <a class="glossseealso" href="glossary.html#glos_normalized">正規化</a>, <a class="glossseealso" href="glossary.html#glos_null">NULL</a>, <a class="glossseealso" href="glossary.html#glos_parent_table">親テーブル</a>, <a class="glossseealso" href="glossary.html#glos_referential_integrity">参照整合性</a>, <a class="glossseealso" href="glossary.html#glos_relational">リレーショナル</a>も参照</p></dd><dt><a name="glos_full_backup"></a><span class="glossterm">完全バックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765000912"></a>
        各 MySQL <span class="bold"><strong>データベース</strong></span>内のすべての<span class="bold"><strong>テーブル</strong></span>と MySQL <span class="bold"><strong>インスタンス</strong></span>内のすべてのデータベースを含む<span class="bold"><strong>バックアップ</strong></span>。 <span class="bold"><strong>部分バックアップ</strong></span>と対比してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_backup">バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_database">データベース</a>, <a class="glossseealso" href="glossary.html#glos_instance">インスタンス</a>, <a class="glossseealso" href="glossary.html#glos_partial_backup">部分バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd><dt><a name="glos_write_combining"></a><span class="glossterm">書き込み結合</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318765075808"></a>
        <span class="bold"><strong>ダーティページ</strong></span>が <code class="literal">InnoDB</code> <span class="bold"><strong>バッファプール</strong></span>の <span class="bold"><strong>flushed</strong></span> である場合に書込み操作を減らす最適化手法。 ページ内の行が複数回更新されたり、同じページ上の複数の行が更新されたりする場合、変更ごとに一度の書き込みではなく、単一書き込み操作でこれらのすべての変更がデータファイルに格納されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_dirty_page">ダーティーページ</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>も参照</p></dd><dt><a name="glos_relevance"></a><span class="glossterm">関連性</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764992160"></a>
        <span class="bold"><strong>全文検索</strong></span>機能で、検索文字列と <span class="bold"><strong>FULLTEXT インデックス</strong></span>内のデータとの間の類似性を示す数字。 たとえば、単一の単語を検索する場合、その単語は通常、1 回のみ表示される行よりもテキスト内で複数回出現する行に関連します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_full_text_search">全文検索</a>, <a class="glossseealso" href="glossary.html#glos_fulltext_index">FULLTEXT インデックス</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">キ</h3><dl><dt><a name="glos_cache"></a><span class="glossterm">キャッシュ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764967168"></a>
        頻繁または高速に取り出せるようにデータのコピーを格納するメモリー領域を表す一般的な用語。 <code class="literal">InnoDB</code> では、キャッシュ構造の主な種類は<span class="bold"><strong>バッファプール</strong></span>です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer">バッファー</a>, <a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>も参照</p></dd><dt><a name="glos_gap"></a><span class="glossterm">ギャップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764961888"></a>
        新しい値を挿入できる <code class="literal">InnoDB</code> <span class="bold"><strong>index</strong></span> データ構造内の場所。 <code class="literal">SELECT ... FOR UPDATE</code> などのステートメントを使用して行のセットをロックすると、<code class="literal">InnoDB</code> ではギャップおよびインデックス内の実際の値に適用されるロックを作成できます。 たとえば、更新に 10 より大きな値をすべて選択した場合、ギャップロックはほかのトランザクションが 10 を超える新しい値を挿入するのを妨げます。 <span class="bold"><strong>最小上限レコード</strong></span>と<span class="bold"><strong>最大下限レコード</strong></span>は、現在のすべてのインデックス値よりも大きな値または小さな値をすべて含むギャップを表します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_gap_lock">ギャップロック</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_infimum_record">最大下限レコード</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_supremum_record">最小上限レコード</a>も参照</p></dd><dt><a name="glos_gap_lock"></a><span class="glossterm">ギャップロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764951216"></a>
        インデックスレコード間の<span class="bold"><strong>ギャップ</strong></span>の<span class="bold"><strong>ロック</strong></span>、または先頭インデックスレコードの前や末尾インデックスレコードのあとのギャップのロック。 たとえば、<code class="literal">SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;</code>では、範囲内の既存のすべての値間のギャップがロックされているため、カラムにそのような値がすでに存在するかどうかにかかわらず、他のトランザクションが 15 の値を <code class="literal">t.c1</code> カラムに挿入することを防ぎます。 <span class="bold"><strong>レコードロック</strong></span>および<span class="bold"><strong>ネクストキーロック</strong></span>と対比してください。 
      </p><p>
        ギャップロックは、パフォーマンスと<span class="bold"><strong>並列性</strong></span>とのトレードオフの一環であり、一部のトランザクション<span class="bold"><strong>分離レベル</strong></span>で使用され、ほかでは使用されません。
      </p><p><a class="glossseealso" href="glossary.html#glos_gap">ギャップ</a>, <a class="glossseealso" href="glossary.html#glos_infimum_record">最大下限レコード</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_next_key_lock">ネクストキーロック</a>, <a class="glossseealso" href="glossary.html#glos_record_lock">レコードロック</a>, <a class="glossseealso" href="glossary.html#glos_supremum_record">最小上限レコード</a>も参照</p></dd><dt><a name="glos_shared_tablespace"></a><span class="glossterm">共有テーブルスペース</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764938656"></a>
        <span class="bold"><strong>システムテーブルスペース</strong></span>または<span class="bold"><strong>一般テーブルスペース</strong></span>を参照する別の方法。 一般的なテーブルスペースは、MySQL 5.7 で導入されました。 複数のテーブルを共有テーブルスペースに配置できます。 単一のテーブルのみが <span class="emphasis"><em>file-per-table</em></span> テーブルスペースに存在できます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_general_tablespace">一般テーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>も参照</p></dd><dt><a name="glos_shared_lock"></a><span class="glossterm">共有ロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764933152"></a>
        <span class="bold"><strong>ロック</strong></span>の一種。ほかの<span class="bold"><strong>トランザクション</strong></span>がロックされたオブジェクトを読み取ることを許可し、それに対するほかの共有ロックを獲得することも許可するけれども、それに書き込むことは許可しません。 <span class="bold"><strong>排他ロック</strong></span>の反対。 
      </p><p><a class="glossseealso" href="glossary.html#glos_exclusive_lock">排他ロック</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_truncate"></a><span class="glossterm">切り捨て</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764926896"></a>
        テーブルおよび関連するインデックスを残しながら、テーブルの内容全体を削除する <span class="bold"><strong>DDL</strong></span> 操作。 <span class="bold"><strong>ドロップ</strong></span>と対比してください。 概念的には、<code class="literal">WHERE</code> 句のない <code class="literal">DELETE</code> ステートメントと同じ結果になりますが、バックグラウンドでの動作は異なります: <code class="literal">InnoDB</code> は新しい空のテーブルを作成し、古いテーブルを削除してから、古いテーブルのかわりに新しいテーブルの名前を変更します。 これは DDL 操作なので、<span class="bold"><strong>ロールバック</strong></span>できません。 
      </p><p>
        切り捨てられるテーブルに、別のテーブルを参照する<span class="bold"><strong>外部キー</strong></span>が含まれている場合、切捨て操作では、<code class="literal">ON DELETE CASCADE</code> 句で必要に応じて参照テーブルの対応する行を削除できるように、処理速度の遅い行を一度に削除します。 (MySQL 5.5 以降では、このより遅い形式の切り捨てを許可しない代わりに、外部キーが含まれている場合はエラーを返します。 この場合は、代わりに <code class="literal">DELETE</code> ステートメントを使用してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_drop">ドロップ</a>, <a class="glossseealso" href="glossary.html#glos_foreign_key">外部キー</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>も参照</p></dd><dt><a name="glos_pseudo_record"></a><span class="glossterm">疑似レコード</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764986448"></a>
        現在存在しないキー値または範囲を<span class="bold"><strong>ロック</strong></span>するために使用される、インデックス内の人為レコード。
      </p><p><a class="glossseealso" href="glossary.html#glos_infimum_record">最大下限レコード</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_supremum_record">最小上限レコード</a>も参照</p></dd><dt><a name="glos_startup"></a><span class="glossterm">起動</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764981456"></a>
        MySQL Server を起動させるプロセス。 通常、<a class="xref" href="programs.html#programs-server" title="4.3 サーバーおよびサーバーの起動プログラム">セクション4.3「サーバーおよびサーバーの起動プログラム」</a>に示すプログラムのいずれかによって行われます。 <span class="bold"><strong>シャットダウン</strong></span>の反対。 
      </p><p><a class="glossseealso" href="glossary.html#glos_shutdown">シャットダウン</a>も参照</p></dd><dt><a name="glos_backticks"></a><span class="glossterm">逆引用符</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764977056"></a>
        MySQL SQL ステートメント内の識別子は、特殊文字または予約語を含んでいる場合、逆引用符文字 (<code class="literal">`</code>) で囲む必要があります。 たとえば、<code class="literal">FOO#BAR</code> というテーブルまたは <code class="literal">SELECT</code> というカラムを参照するには、<code class="literal">`FOO#BAR`</code> および <code class="literal">`SELECT`</code> として識別子を指定します。 逆引用符は、安全性のレベルをさらに高めるので、識別子名が前もってわかっていない可能性のあるプログラム生成の SQL ステートメントで広く使用されています。 
      </p><p>
        ほかのデータベースシステムの多くでは、このような特別な名前には二重引用符 (<code class="literal">"</code>) を使用します。 MySQL では移植性のために、<code class="literal">ANSI_QUOTES</code> モードを有効にして、逆引用符の代わりに二重引用符を使用して識別子名を修飾できます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_sql">SQL</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ク</h3><dl><dt><a name="glos_query"></a><span class="glossterm">クエリー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764913056"></a>
        <span class="bold"><strong>SQL</strong></span> で、1 つ以上の<span class="bold"><strong>テーブル</strong></span>から情報を読み取る操作。 データの編成とクエリーのパラメータに応じて、ルックアップは<span class="bold"><strong>インデックス</strong></span>を参照することで最適化される可能性があります。 複数のテーブルが使用される場合、そのクエリーは<span class="bold"><strong>結合</strong></span>と呼ばれます。 
      </p><p>
        歴史的な理由から、ステートメントの内部処理のディスカッションでは、<span class="bold"><strong>DDL</strong></span> ステートメントや <span class="bold"><strong>DML</strong></span> ステートメントなどの他のタイプの MySQL ステートメントを含む、より広範な意味で <span class="quote">「<span class="quote">query</span>」</span> が使用される場合があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_join">結合</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd><dt><a name="glos_query_log"></a><span class="glossterm">クエリーログ</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_general_query_log">一般クエリーログ</a>も参照</p></dd><dt><a name="glos_query_execution_plan"></a><span class="glossterm">クエリー実行計画</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764901744"></a>
        使用する<span class="bold"><strong>インデックス</strong></span>やテーブルを<span class="bold"><strong>結合</strong></span>する順序など、<span class="bold"><strong>クエリー</strong></span>をもっとも効率的に実行する方法についてオプティマイザによって行われる決定のセット。 <span class="bold"><strong>計画安定性</strong></span>には、特定のクエリーについて一貫して行われている同じ選択が含まれます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_join">結合</a>, <a class="glossseealso" href="glossary.html#glos_plan_stability">計画安定性</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>も参照</p></dd><dt><a name="glos_client"></a><span class="glossterm">クライアント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764818320"></a>
        データベースサーバーの外部で実行され、<span class="bold"><strong>Connector</strong></span> を介してリクエストを送信してデータベースと通信するプログラム、または<span class="bold"><strong>クライアントライブラリ</strong></span>を介して使用可能になった <span class="bold"><strong>API</strong></span>。 データベースサーバーと同じ物理マシン上、またはネットワーク経由で接続されたリモートマシン上で実行できます。 これは、特別な目的のデータベースアプリケーション、または <span class="command"><strong>mysql</strong></span> コマンドラインプロセッサなどの汎用プログラムです。 
      </p><p><a class="glossseealso" href="glossary.html#glos_api">API</a>, <a class="glossseealso" href="glossary.html#glos_client_libraries">クライアントライブラリ</a>, <a class="glossseealso" href="glossary.html#glos_connector">コネクタ</a>, <a class="glossseealso" href="glossary.html#glos_mysql">mysql</a>, <a class="glossseealso" href="glossary.html#glos_server">サーバー</a>も参照</p></dd><dt><a name="glos_client_libraries"></a><span class="glossterm">クライアントライブラリ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764800960"></a>
        データベースを操作するための関数のコレクションを含むファイル。 これらのライブラリを使用してプログラムをコンパイルするか、アプリケーションと同じシステムにインストールすることで、MySQL サーバーがインストールされていないマシンでデータベースアプリケーション (<span class="bold"><strong>client</strong></span> と呼ばれる) を実行できます。アプリケーションはネットワークを介してデータベースにアクセスします。 MySQL では、MySQL サーバー自体から <span class="bold"><strong>libmysqlclient</strong></span> ライブラリを使用できます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_client">クライアント</a>, <a class="glossseealso" href="glossary.html#glos_libmysqlclient">libmysqlclient</a>も参照</p></dd><dt><a name="glos_client_side_prepared_statement"></a><span class="glossterm">クライアント側のプリペアドステートメント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764809888"></a>
        キャッシュおよび再利用がローカルで管理され、<span class="bold"><strong>サーバー側のプリペアドステートメント</strong></span>の機能をエミュレートする<span class="bold"><strong>プリペアドステートメント</strong></span>のタイプ。 従来は、一部の <span class="bold"><strong>Connector/J</strong></span>、<span class="bold"><strong>Connector/ODBC</strong></span> および <span class="bold"><strong>Connector/PHP</strong></span> 開発者がサーバー側ストアドプロシージャの問題を回避するために使用していました。 最新の MySQL サーバーバージョンでは、パフォーマンス、スケーラビリティー、およびメモリー効率を向上させるために、サーバー側のプリペアドステートメントをお勧めします。 
      </p><p><a class="glossseealso" href="glossary.html#glos_connector_j">Connector/J</a>, <a class="glossseealso" href="glossary.html#glos_connector_odbc">Connector/ODBC</a>, <a class="glossseealso" href="glossary.html#glos_connector_php">Connector/PHP</a>, <a class="glossseealso" href="glossary.html#glos_prepared_statement">プリペアドステートメント</a>も参照</p></dd><dt><a name="glos_clustered_index"></a><span class="glossterm">クラスタ化されたインデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764795088"></a>
        <span class="bold"><strong>主キー</strong></span>インデックスの <code class="literal">InnoDB</code> 用語。 <code class="literal">InnoDB</code> テーブルの記憶域は、主キーカラムの値に基づいて編成され、主キーカラムに関連するクエリーおよびソートを高速化します。 パフォーマンスが最適になるように、パフォーマンスがもっとも重要なクエリーに基づいて、主キーカラムを慎重に選択してください。 クラスタ化されたインデックスのカラムを変更することは負荷のかかる操作なので、まれにしか、またはまったく更新されない主カラムを選択してください。 
      </p><p>
        Oracle Database 製品では、この種のテーブルは<span class="bold"><strong>インデックス編成テーブル</strong></span>と呼ばれています。
      </p><p><a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>, <a class="glossseealso" href="glossary.html#glos_secondary_index">セカンダリインデックス</a>も参照</p></dd><dt><a name="glos_crash"></a><span class="glossterm">クラッシュ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764787168"></a>
        MySQL では、通常、<span class="quote">「<span class="quote">crash</span>」</span> という用語は、サーバーが通常のクリーンアップを実行できない予期しない <span class="bold"><strong>shutdown</strong></span> 操作を指します。 たとえば、クラッシュは、データベースサーバーマシンまたはストレージデバイスでのハードウェア障害、電源障害、MySQL Server の停止を招く潜在的なデータ不一致、DBA で開始された<span class="bold"><strong>高速シャットダウン</strong></span>、またはその他の多くの理由によって発生することがあります。 <span class="bold"><strong>InnoDB</strong></span> テーブルの堅牢で自動的な<span class="bold"><strong>クラッシュリカバリ</strong></span>は、DBA が追加作業を行うことなく、サーバーが再起動するときにデータの一貫性を保証します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_crash_recovery">クラッシュリカバリ</a>, <a class="glossseealso" href="glossary.html#glos_fast_shutdown">高速シャットダウン</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_shutdown">シャットダウン</a>も参照</p></dd><dt><a name="glos_crash_recovery"></a><span class="glossterm">クラッシュリカバリ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764778320"></a>
        <span class="bold"><strong>クラッシュ</strong></span>後に MySQL が再度起動したときに行われるクリーンアップアクティビティー。 <span class="bold"><strong>InnoDB</strong></span> テーブルの場合、不完全なトランザクションからの変更は、<span class="bold"><strong>Redo ログ</strong></span>からのデータを使用して再現されます。 クラッシュ前に<span class="bold"><strong>コミット</strong></span>されたけれども、まだ<span class="bold"><strong>データファイル</strong></span>に書き込まれていない変更は、<span class="bold"><strong>二重書き込みバッファー</strong></span>から再構築されます。 通常どおりデータベースがシャットダウンした場合、このタイプのアクティビティーは、<span class="bold"><strong>パージ</strong></span>操作によってシャットダウン中に実行されます。 
      </p><p>
        通常操作中、コミットされたデータは、データファイルに書き込まれる前に、一定期間<span class="bold"><strong>変更バッファー</strong></span>に格納できます。 データファイルを最新の状態に維持すること (通常の操作中にパフォーマンスオーバーヘッドをもたらす) と、データのバッファリング (シャットダウンおよびクラッシュリカバリの時間を長くする可能性がある) との間には、常にトレードオフがあります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_change_buffer">変更バッファー</a>, <a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_crash">クラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_doublewrite_buffer">二重書き込みバッファー</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_purge">パージ</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>も参照</p></dd><dt><a name="glos_clean_shutdown"></a><span class="glossterm">クリーンシャットダウン</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764764208"></a>
        <span class="bold"><strong>crash</strong></span> または<span class="bold"><strong>高速シャットダウン</strong></span>ではなく、エラーなしで完了し、終了前にすべての変更を <code class="literal">InnoDB</code> テーブルに適用する <span class="bold"><strong>shutdown</strong></span>。 <span class="bold"><strong>低速シャットダウン</strong></span>のシノニム。 
      </p><p><a class="glossseealso" href="glossary.html#glos_crash">クラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_fast_shutdown">高速シャットダウン</a>, <a class="glossseealso" href="glossary.html#glos_shutdown">シャットダウン</a>, <a class="glossseealso" href="glossary.html#glos_slow_shutdown">低速シャットダウン</a>も参照</p></dd><dt><a name="glos_clean_page"></a><span class="glossterm">クリーンページ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764756096"></a>
        <code class="literal">InnoDB</code> <span class="bold"><strong>バッファプール</strong></span>内の <span class="bold"><strong>page</strong></span> は、メモリー内で行われたすべての変更も <a class="link" href="glossary.html#glos_data_files" title="データファイル">data files</a> に書き込まれます (<span class="bold"><strong>flushed</strong></span>)。 <span class="bold"><strong>ダーティーページ</strong></span>の反対です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_dirty_page">ダーティーページ</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>も参照</p></dd><dt><a name="glos_group_commit"></a><span class="glossterm">グループコミット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764746608"></a>
        コミットごとに別々にフラッシュおよび同期するのではなく、一連の<span class="bold"><strong>コミット</strong></span>操作に対して一度、いくつかの低レベル I/O 操作 (ログ書き込み) を実行する <code class="literal">InnoDB</code> 最適化。
      </p><p><a class="glossseealso" href="glossary.html#glos_binary_log">バイナリログ</a>, <a class="glossseealso" href="glossary.html#glos_commit">コミット</a>も参照</p></dd><dt><a name="glos_global_transaction"></a><span class="glossterm">グローバルトランザクション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764737344"></a>
        <span class="bold"><strong>XA</strong></span> 操作に含まれるタイプの<span class="bold"><strong>トランザクション</strong></span>。 これは、それ自体はトランザクションであるけれども、すべてがグループとして正しく完了する必要があるか、グループとしてロールバックされる必要がある、いくつかのアクションから構成されます。 基本的に、これは <span class="bold"><strong>ACID</strong></span> プロパティ<span class="quote">「<span class="quote">「レベルを上げる」</span>」</span>を拡張して、ACID プロパティも持つグローバル操作のコンポーネントとして複数の ACID トランザクションを同時に実行できるようにします。 
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_xa">XA</a>も参照</p></dd><dt><a name="glos_global_temporary_tablespace"></a><span class="glossterm">グローバル一時テーブルスペース</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764741408"></a>
        ユーザーが作成した一時テーブルに加えた変更のために<span class="emphasis"><em>ロールバックセグメント</em></span>を格納する<span class="emphasis"><em>一時テーブルスペース</em></span>。
      </p><p><a class="glossseealso" href="glossary.html#glos_temporary_tablespace">一時テーブルスペース</a>も参照</p></dd><dt><a name="glos_built_in"></a><span class="glossterm">組み込み</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764829744"></a>
        MySQL 内の組み込みの <code class="literal">InnoDB</code> ストレージエンジンは、ストレージエンジンの元の配布形式です。 <span class="bold"><strong>InnoDB Plugin</strong></span> と対比してください。 MySQL 5.5 以降、InnoDB プラグインは組込み <code class="literal">InnoDB</code> ストレージエンジン (InnoDB 1.1 と呼ばれる) として MySQL コードベースにマージされます。 
      </p><p>
        この区別は主に MySQL 5.1 で重要です。この場合、機能またはバグの修正が InnoDB プラグインに適用される可能性がありますが、組込み <code class="literal">InnoDB</code> には適用されません。その逆も同様です。
      </p><p><a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>も参照</p></dd><dt><a name="glos_intrinsic_temporary_table"></a><span class="glossterm">組み込み一時テーブル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764822336"></a>
        <span class="emphasis"><em>オプティマイザ</em></span>で使用される最適化された内部 <code class="literal">InnoDB</code> 一時テーブル。
      </p><p><a class="glossseealso" href="glossary.html#glos_optimizer">オプティマイザ</a>も参照</p></dd><dt><a name="glos_row"></a><span class="glossterm">行</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764892944"></a>
        <span class="bold"><strong>カラム</strong></span>セットによって定義される論理データ構造。 行セットが<span class="bold"><strong>テーブル</strong></span>を構成します。 <code class="literal">InnoDB</code> <span class="bold"><strong>データファイル</strong></span>内では、各 <span class="bold"><strong>page</strong></span> に 1 つ以上の行を含めることができます。 
      </p><p>
        <code class="literal">InnoDB</code> では、MySQL 構文との一貫性のために<span class="bold"><strong>行フォーマット</strong></span>という用語を使用しますが、行形式は各テーブルのプロパティであり、そのテーブルのすべての行に適用されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_column">カラム</a>, <a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_row_format">行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd><dt><a name="glos_row_format"></a><span class="glossterm">行フォーマット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764882272"></a>
        <code class="literal">InnoDB</code> <span class="bold"><strong>table</strong></span> の <span class="bold"><strong>rows</strong></span> のディスク記憶域形式。 <code class="literal">InnoDB</code> が <span class="bold"><strong>compression</strong></span> などの新機能を取得すると、新しい行形式が導入され、記憶域の効率とパフォーマンスが向上します。 
      </p><p>
        <code class="literal">InnoDB</code> テーブルの行形式は、<code class="literal">ROW_FORMAT</code> オプションまたは <code class="literal">innodb_default_row_format</code> 構成オプション (MySQL 5.7.9 で導入) によって指定されます。 行フォーマットには、<code class="literal">REDUNDANT</code>, <code class="literal">COMPACT</code>, <code class="literal">COMPRESSED</code> および <code class="literal">DYNAMIC</code> が含まれます。 <code class="literal">InnoDB</code> テーブルの行形式を表示するには、<code class="literal">SHOW TABLE STATUS</code> ステートメントを発行するか、<code class="literal">INFORMATION_SCHEMA</code> で <code class="literal">InnoDB</code> テーブルメタデータをクエリーします。 
      </p><p><a class="glossseealso" href="glossary.html#glos_compact_row_format">コンパクト行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_compressed_row_format">圧縮行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_compression">圧縮</a>, <a class="glossseealso" href="glossary.html#glos_dynamic_row_format">動的行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_redundant_row_format">冗長行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_row">行</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd><dt><a name="glos_row_based_replication"></a><span class="glossterm">行ベースレプリケーション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764862656"></a>
        <span class="bold"><strong>レプリカ</strong></span>上の個々の行の変更方法を指定する <span class="bold"><strong>source</strong></span> からイベントが伝播される<span class="bold"><strong>レプリケーション</strong></span>の形式。 <code class="literal">innodb_autoinc_lock_mode</code> オプションのすべての設定に安全に使用できます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_auto_increment_locking">自動インクリメントロック</a>, <a class="glossseealso" href="glossary.html#glos_innodb_autoinc_lock_mode">innodb_autoinc_lock_mode</a>, <a class="glossseealso" href="glossary.html#glos_replica">レプリカ</a>, <a class="glossseealso" href="glossary.html#glos_replication">レプリケーション</a>, <a class="glossseealso" href="glossary.html#glos_source">source</a>, <a class="glossseealso" href="glossary.html#glos_statement_based_replication">ステートメントベースレプリケーション</a>も参照</p></dd><dt><a name="glos_row_level_locking"></a><span class="glossterm">行レベルロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764853376"></a>
        <span class="bold"><strong>InnoDB</strong></span> テーブルに使用される<span class="bold"><strong>ロック</strong></span>メカニズム。<span class="bold"><strong>テーブルロック</strong></span>ではなく<span class="bold"><strong>行ロック</strong></span>に依存します。 複数の<span class="bold"><strong>トランザクション</strong></span>が同時に同じテーブルを変更できます。 2 つのトランザクションが同じ行を変更しようとした場合にのみ、トランザクションの一方は他方が終わる (およびその行ロックを解放する) まで待機します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_row_lock">行ロック</a>, <a class="glossseealso" href="glossary.html#glos_table_lock">テーブルロック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_row_lock"></a><span class="glossterm">行ロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764844544"></a>
        <span class="bold"><strong>ロック</strong></span>の 1 つ。互換性のない方法で別の<span class="bold"><strong>トランザクション</strong></span>が行にアクセスするのを防ぎます。 同じテーブル内のほかの行には、ほかのトランザクションが自由に書き込むことができます。 これは、<span class="bold"><strong>InnoDB</strong></span> テーブルでの <span class="bold"><strong>DML</strong></span> 操作によって行われるタイプの<span class="bold"><strong>ロック</strong></span>です。 
      </p><p>
        <code class="literal">MyISAM</code> で使用される<span class="bold"><strong>テーブルロック</strong></span>とは対照的に、または<span class="bold"><strong>オンライン DDL</strong></span>では実行できない <code class="literal">InnoDB</code> テーブルに対する <span class="bold"><strong>DDL</strong></span> 操作中には、これらのロックによってテーブルへの同時アクセスがブロックされます。
      </p><p><a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_online_ddl">オンライン DDL</a>, <a class="glossseealso" href="glossary.html#glos_table_lock">テーブルロック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ケ</h3><dl><dt><a name="glos_atomic"></a><span class="glossterm">原子的</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764706496"></a>
        SQL コンテキストでは、<span class="bold"><strong>トランザクション</strong></span>とは、完全に完了する (<span class="bold"><strong>コミット</strong></span>時)、またはまったく効果がない (<span class="bold"><strong>ロールバック</strong></span>時) 作業の単位です。 トランザクションの不可視 (アトミック) プロパティは、頭字語 <span class="bold"><strong>ACID</strong></span> の <span class="quote">「<span class="quote">A</span>」</span> です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_strict_mode"></a><span class="glossterm">厳密モード</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764698560"></a>
        <code class="literal">innodb_strict_mode</code> オプションで制御される設定の一般名。 この設定をオンにすると、通常は警告として扱われる条件がエラーと見なされます。 たとえば、通常は警告を生成してデフォルト値で続行する<span class="bold"><strong>ファイル形式</strong></span>と<span class="bold"><strong>行フォーマット</strong></span>に関連するオプションの特定の無効な組合せによって、<code class="literal">CREATE TABLE</code> 操作が失敗するようになりました。<code class="literal">innodb_strict_mode</code> は MySQL 5.7 でデフォルトで有効になっています。 
      </p><p>
        MySQL にも厳密モードと呼ばれるものがあります。 <a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_file_format">ファイル形式</a>, <a class="glossseealso" href="glossary.html#glos_innodb_strict_mode">innodb_strict_mode</a>, <a class="glossseealso" href="glossary.html#glos_row_format">行フォーマット</a>も参照</p></dd><dt><a name="glos_search_index"></a><span class="glossterm">検索インデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764714592"></a>
        MySQL では、<span class="bold"><strong>全文検索</strong></span>クエリーは特別な種類のインデックス (<span class="bold"><strong>FULLTEXT インデックス</strong></span>) を使用します。 MySQL 5.6.4 以降で、<code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> テーブルの両方は <code class="literal">FULLTEXT</code> インデックスをサポートします。以前はこれらのインデックスは <code class="literal">MyISAM</code> テーブルでのみ利用可能でした。 
      </p><p><a class="glossseealso" href="glossary.html#glos_full_text_search">全文検索</a>, <a class="glossseealso" href="glossary.html#glos_fulltext_index">FULLTEXT インデックス</a>も参照</p></dd><dt><a name="glos_join"></a><span class="glossterm">結合</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764724400"></a>
        同じ値を保持するテーブル内のカラムを参照することによって、複数のテーブルからデータを取得する<span class="bold"><strong>クエリー</strong></span>。 理想的には、これらのカラムは <code class="literal">InnoDB</code> <span class="bold"><strong>外部キー</strong></span>関係の一部であり、<span class="bold"><strong>参照整合性</strong></span>および結合カラムが<span class="bold"><strong>インデックス付き</strong></span>であることを確認します。 多くの場合、<span class="bold"><strong>正規化</strong></span>データ設計で、繰り返される文字列を数値 ID に置き換えることによって領域を節約してクエリーパフォーマンスを改善するために、使用されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_foreign_key">外部キー</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_normalized">正規化</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>, <a class="glossseealso" href="glossary.html#glos_referential_integrity">参照整合性</a>も参照</p></dd><dt><a name="glos_plan_stability"></a><span class="glossterm">計画安定性</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764729376"></a>
        <span class="bold"><strong>クエリー実行計画</strong></span>のプロパティーの 1 つ。オプティマイザが渡された<span class="bold"><strong>クエリー</strong></span>に毎回同じ選択を行うことで、パフォーマンスが一貫して予測可能になります。
      </p><p><a class="glossseealso" href="glossary.html#glos_query">クエリー</a>, <a class="glossseealso" href="glossary.html#glos_query_execution_plan">クエリー実行計画</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">コ</h3><dl><dt><a name="glos_connector"></a><span class="glossterm">コネクタ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764604256"></a>
        MySQL コネクタは、<span class="bold"><strong>client</strong></span> プログラム用の MySQL サーバーへの接続を提供します。 いくつかのプログラミング言語およびフレームワークには、それぞれ独自のコネクタが関連付けられています。 <span class="bold"><strong>API</strong></span> によって提供される下位レベルのアクセスと対比してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_api">API</a>, <a class="glossseealso" href="glossary.html#glos_client">クライアント</a>, <a class="glossseealso" href="glossary.html#glos_connector_c__">Connector/C++</a>, <a class="glossseealso" href="glossary.html#glos_connector_j">Connector/J</a>, <a class="glossseealso" href="glossary.html#glos_connector_net">Connector/NET</a>, <a class="glossseealso" href="glossary.html#glos_connector_odbc">Connector/ODBC</a>も参照</p></dd><dt><a name="glos_command_interceptor"></a><span class="glossterm">コマンドインタセプタ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764597024"></a>
        <span class="bold"><strong>ステートメントインターセプタ</strong></span>と同義です。 <span class="bold"><strong>Connector/NET</strong></span> と <span class="bold"><strong>Connector/J</strong></span> の両方で使用可能な <span class="bold"><strong>interceptor</strong></span> デザインパターンの一部分。 Connector/NET がコマンドをコールする内容。Connector/J はステートメントと呼ばれます。 <span class="bold"><strong>例外インターセプタ</strong></span>と対比してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_connector_j">Connector/J</a>, <a class="glossseealso" href="glossary.html#glos_connector_net">Connector/NET</a>, <a class="glossseealso" href="glossary.html#glos_exception_interceptor">例外インターセプタ</a>, <a class="glossseealso" href="glossary.html#glos_interceptor">interceptor</a>, <a class="glossseealso" href="glossary.html#glos_statement_interceptor">ステートメントインターセプタ</a>も参照</p></dd><dt><a name="glos_commit"></a><span class="glossterm">コミット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764587792"></a>
        <span class="bold"><strong>トランザクション</strong></span>を終了させ、トランザクションによって行われた変更を永続的にする <span class="bold"><strong>SQL</strong></span> ステートメント。 これは、トランザクションで行われた変更を元どおりにする<span class="bold"><strong>ロールバック</strong></span>の反対です。 
      </p><p>
        <code class="literal">InnoDB</code> では、コミットに <span class="bold"><strong>optimistic</strong></span> メカニズムを使用するため、コミットが実際に発生する前に変更をデータファイルに書き込むことができます。 この方法は、コミット自体をより高速にしますが、ロールバックの場合には必要な作業が増えるというトレードオフが生じます。 
      </p><p>
        MySQL はデフォルトで、各 SQL ステートメントに続いてコミットを自動的に発行する<span class="bold"><strong>自動コミット</strong></span>設定を使用します。
      </p><p><a class="glossseealso" href="glossary.html#glos_autocommit">自動コミット</a>, <a class="glossseealso" href="glossary.html#glos_optimistic">オプティミスティック</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_compact_row_format"></a><span class="glossterm">コンパクト行フォーマット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764559952"></a>
        InnoDB テーブル用の<span class="bold"><strong>行フォーマット</strong></span>。 これは、MySQL 5.0.3 から MySQL 5.7.8 へのデフォルトの行形式でした。 MySQL 8.0 では、デフォルトの行フォーマットは、<span class="bold"><strong>DYNAMIC</strong></span> のデフォルト設定を持つ <code class="literal">innodb_default_row_format</code> 構成オプションによって定義されます。 <span class="bold"><strong>COMPACT</strong></span> の行形式では、<span class="bold"><strong>REDUNDANT</strong></span> の行形式よりも NULL および可変長のカラムをよりコンパクトに表現できます。 
      </p><p>
        <code class="literal">InnoDB</code> <code class="literal">COMPACT</code> 行フォーマットの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="15.10 InnoDB の行フォーマット">セクション15.10「InnoDB の行フォーマット」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_dynamic_row_format">動的行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_file_format">ファイル形式</a>, <a class="glossseealso" href="glossary.html#glos_redundant_row_format">冗長行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_row_format">行フォーマット</a>も参照</p></dd><dt><a name="glos_cold_backup"></a><span class="glossterm">コールドバックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764630528"></a>
        データベースがシャットダウンしている間に行われる<span class="bold"><strong>バックアップ</strong></span>。 ビジー状態のアプリケーションおよび web サイトの場合、これは実用的ではなく、<span class="bold"><strong>ウォームバックアップ</strong></span>または<span class="bold"><strong>ホットバックアップ</strong></span>が望ましい場合があります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_backup">バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_warm_backup">ウォームバックアップ</a>も参照</p></dd><dt><a name="glos_synthetic_key"></a><span class="glossterm">合成キー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764678880"></a>
        インデックス付けされたカラム (通常は<span class="bold"><strong>主キー</strong></span>)。値は任意に割り当てられます。 多くの場合、<span class="bold"><strong>自動インクリメント</strong></span>カラムを使用して行われます。 完全に任意として値を扱うことによって、過度に制限されたルールと欠陥のあるアプリケーション想定を回避できます。 たとえば、ある従業員が雇用を承認されたけれども、実際には入社していない場合、従業員数を表す数値シーケンスにギャップがある可能性があります。 または、従業員番号 100 と従業員番号 500 が会社を退職してあとで再入社した場合、前者が後者よりもあとの雇用日になることがあります。 数値も、予測可能な長さより短い値になります。 たとえば、<span class="quote">「<span class="quote">Road</span>」</span>、<span class="quote">「<span class="quote">Boulevard</span>」</span>、<span class="quote">「<span class="quote">Expressway</span>」</span> などを意味する数値コードを格納すると、これらの文字列を繰り返し使用するよりも領域効率が高くなります。 
      </p><p>
        <span class="bold"><strong>サロゲートキー</strong></span>とも呼ばれます。 <span class="bold"><strong>ナチュラルキー</strong></span>と対比してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_auto_increment">自動インクリメント</a>, <a class="glossseealso" href="glossary.html#glos_natural_key">ナチュラルキー</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>, <a class="glossseealso" href="glossary.html#glos_surrogate_key">サロゲートキー</a>も参照</p></dd><dt><a name="glos_fixed_row_format"></a><span class="glossterm">固定行フォーマット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764624080"></a>
        この行フォーマットは、<code class="literal">InnoDB</code> ではなく <code class="literal">MyISAM</code> ストレージエンジンによって使用されます。 MySQL 5.7.6 以前で <code class="literal">ROW_FORMAT=FIXED</code> オプションを指定して <code class="literal">InnoDB</code> テーブルを作成した場合、<code class="literal">InnoDB</code> は<span class="bold"><strong>コンパクトな行形式</strong></span>をかわりに使用しますが、<code class="literal">FIXED</code> の値が <code class="literal">SHOW TABLE STATUS</code> レポートなどの出力に表示されることがあります。 MySQL 5.7.7 では、<code class="literal">ROW_FORMAT=FIXED</code> が指定されている場合、<code class="literal">InnoDB</code> はエラーを返します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_compact_row_format">コンパクト行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_row_format">行フォーマット</a>も参照</p></dd><dt><a name="glos_child_table"></a><span class="glossterm">子テーブル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764612832"></a>
        <span class="bold"><strong>外部キー</strong></span>関係で子テーブルとは、その行が別のテーブル内の行を参照 (またはポイント) し、特定のカラムについて同じ値を持つもののことです。 これは、<code class="literal">FOREIGN KEY ... REFERENCES</code> 句、およびオプションで <code class="literal">ON UPDATE</code> および <code class="literal">ON DELETE</code> 句を含むテーブルです。 行を子テーブル内に作成するには、その前に<span class="bold"><strong>親テーブル</strong></span>内に対応する行が存在している必要があります。 子テーブル内の値は、外部キーの作成時に使用される <code class="literal">ON CASCADE</code> に基づいて、親テーブルでの削除または更新操作を禁止したり、子テーブル内で自動的に削除または更新したりする場合があります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_foreign_key">外部キー</a>, <a class="glossseealso" href="glossary.html#glos_parent_table">親テーブル</a>も参照</p></dd><dt><a name="glos_configuration_file"></a><span class="glossterm">構成ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764667872"></a>
        起動時に MySQL が使用する<span class="bold"><strong>オプション</strong></span>値を保持するファイル。 従来、Linux および Unix では、このファイルの名前は <code class="literal">my.cnf</code> で、Windows では <code class="literal">my.ini</code> です。 ファイルの <code class="literal">[mysqld]</code> セクションで、InnoDB に関連した多数のオプションを設定できます。 
      </p><p>
        MySQL が構成ファイルを検索する場所の詳細は、<a class="xref" href="programs.html#option-files" title="4.2.2.2 オプションファイルの使用">セクション4.2.2.2「オプションファイルの使用」</a> を参照してください。
      </p><p>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品を使用する場合、通常は 2 つの構成ファイルを使用: データの取得元とその構造化方法 (サーバーの元の構成ファイルである可能性がある) を指定するものと、バックアップデータの移動先と構造化方法を指定する小さなオプションセットのみを含むストリップダウンされたもの。 <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品で使用される構成ファイルには、通常は通常の構成ファイルから除外される特定のオプションが含まれている必要があるため、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> で使用するために既存の構成ファイルにオプションを追加する必要がある場合があります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_my_cnf">my.cnf</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_option">オプション</a>, <a class="glossseealso" href="glossary.html#glos_option_file">オプションファイル</a>も参照</p></dd><dt><a name="glos_mixed_mode_insert"></a><span class="glossterm">混在モード挿入</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764576704"></a>
        <code class="literal">INSERT</code> ステートメントの 1 つ。<span class="bold"><strong>自動インクリメント</strong></span>値が新しい行のすべてではなく一部に指定されます。 たとえば、複数値 <code class="literal">INSERT</code> では、一部のケースで自動インクリメントカラムの値を、ほかのケースで <code class="literal">NULL</code> を指定できます。 <code class="literal">InnoDB</code> は、カラム値が <code class="literal">NULL</code> として指定された行に自動インクリメント値を生成します。 別の例が、<code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> ステートメントです。ここでは、<code class="literal">INSERT</code> ではなく <code class="literal">UPDATE</code> ステートメントとして処理される重複行がある場合、それらに自動インクリメント値が生成されますが、使用されません。 
      </p><p>
        <span class="bold"><strong>レプリケーション</strong></span>構成の <span class="bold"><strong>source</strong></span> サーバーと<span class="bold"><strong>レプリカ</strong></span>サーバーの間で整合性の問題が発生する可能性があります。 <span class="bold"><strong>innodb_autoinc_lock_mode</strong></span> 構成オプションの値の調整が必要な場合があります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_auto_increment">自動インクリメント</a>, <a class="glossseealso" href="glossary.html#glos_innodb_autoinc_lock_mode">innodb_autoinc_lock_mode</a>, <a class="glossseealso" href="glossary.html#glos_replica">レプリカ</a>, <a class="glossseealso" href="glossary.html#glos_replication">レプリケーション</a>, <a class="glossseealso" href="glossary.html#glos_source">source</a>も参照</p></dd><dt><a name="glos_descending_index"></a><span class="glossterm">降順インデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764683760"></a>
        <code class="literal">ORDER BY <em class="replaceable"><code>column</code></em> DESC</code> 句を処理するためにインデックス記憶域が最適化される <span class="bold"><strong>index</strong></span> のタイプ。
      </p><p><a class="glossseealso" href="glossary.html#glos_index">インデックス</a>も参照</p></dd><dt><a name="glos_high_water_mark"></a><span class="glossterm">高位境界値</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764687776"></a>
        上限を表す値。実行時に超えるべきでないハード制限、または実際に到達した最大値の記録。 <span class="bold"><strong>低位境界値</strong></span>と対比してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_low_water_mark">低位境界値</a>も参照</p></dd><dt><a name="glos_fast_index_creation"></a><span class="glossterm">高速インデックス作成</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764655104"></a>
        InnoDB プラグインで最初に導入された機能は、5.5 以上の MySQL の一部であり、関連付けられたテーブルを完全にリライトする必要がなくなるため、<code class="literal">InnoDB</code> <span class="bold"><strong>セカンダリインデックス</strong></span>の作成が高速化されます。 高速化はセカンダリインデックスの削除にも適用されます。 
      </p><p>
        インデックスを保守することで多数のデータ転送操作にパフォーマンスオーバーヘッドを増やす場合があるので、セカンダリインデックスを用意せずに <code class="literal">ALTER TABLE ... ENGINE=INNODB</code> や <code class="literal">INSERT INTO ... SELECT * FROM ...</code> などの操作を行い、あとでインデックスを作成することを検討してみてください。
      </p><p>
        MySQL 5.6 では、この機能がより一般的になります。 インデックスの作成中にテーブルの読取りおよび書込みを行うことができ、テーブルをコピーせずに、または <span class="bold"><strong>DML</strong></span> 操作をブロックせずに、あるいはその両方で、より多くの種類の <code class="literal">ALTER TABLE</code> 操作を実行できます。 したがって、MySQL 5.6 以上では、この機能セットは高速インデックス作成ではなく<span class="bold"><strong>オンライン DDL</strong></span>と呼ばれます。 
      </p><p>
        関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl" title="15.12 InnoDB とオンライン DDL">セクション15.12「InnoDB とオンライン DDL」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_online_ddl">オンライン DDL</a>, <a class="glossseealso" href="glossary.html#glos_secondary_index">セカンダリインデックス</a>も参照</p></dd><dt><a name="glos_fast_shutdown"></a><span class="glossterm">高速シャットダウン</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764641376"></a>
        <code class="literal">innodb_fast_shutdown=1</code> の構成設定に基づく、<code class="literal">InnoDB</code> のデフォルトの <span class="bold"><strong>shutdown</strong></span> プロシージャ。 時間を節約するために、特定の<span class="bold"><strong>フラッシュ</strong></span>操作がスキップされます。 フラッシュ操作は次の起動中に<span class="bold"><strong>クラッシュリカバリ</strong></span>の場合と同じメカニズムを使用して実行されるので、通常の使用中にはこのタイプのシャットダウンが安全です。 アップグレードまたはダウングレードのためにデータベースをシャットダウンしている場合は、代わりに<span class="bold"><strong>低速シャットダウン</strong></span>を行なって、すべての該当する変更がシャットダウン中に<span class="bold"><strong>データファイル</strong></span>に適用されることを保証してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_crash_recovery">クラッシュリカバリ</a>, <a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_shutdown">シャットダウン</a>, <a class="glossseealso" href="glossary.html#glos_slow_shutdown">低速シャットダウン</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">サ</h3><dl><dt><a name="glos_sublist"></a><span class="glossterm">サブリスト</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764493936"></a>
        <span class="bold"><strong>バッファプール</strong></span>を表すリスト構造内では、比較的古いページと比較的新しいページは、<span class="bold"><strong>list</strong></span> の様々な部分によって表されます。 パラメータセットは、これらの部分のサイズと、新しいページと古いページ間の分割ポイントを制御します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_eviction">エビクション</a>, <a class="glossseealso" href="glossary.html#glos_list">リスト</a>, <a class="glossseealso" href="glossary.html#glos_lru">LRU</a>も参照</p></dd><dt><a name="glos_surrogate_key"></a><span class="glossterm">サロゲートキー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764487600"></a>
        <span class="bold"><strong>合成キー</strong></span>のシノニム名。
      </p><p><a class="glossseealso" href="glossary.html#glos_synthetic_key">合成キー</a>も参照</p></dd><dt><a name="glos_server"></a><span class="glossterm">サーバー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764547824"></a>
        継続的に実行され、別のプログラム (<span class="bold"><strong>client</strong></span>) からのリクエストの受信および処理を待機するプログラムのタイプ。 多くの場合、コンピュータ全体が 1 つ以上のサーバープログラムを実行することを目的とするため (データベースサーバー、Web サーバー、アプリケーションサーバー、これらの組み合わせなど)、用語<span class="bold"><strong>サーバー</strong></span>はサーバーソフトウェアを実行するコンピュータを指す場合もあります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_client">クライアント</a>, <a class="glossseealso" href="glossary.html#glos_mysqld">mysqld</a>も参照</p></dd><dt><a name="glos_server_side_prepared_statement"></a><span class="glossterm">サーバー側のプリペアドステートメント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764542096"></a>
        MySQL サーバーによって管理される<span class="bold"><strong>プリペアドステートメント</strong></span>。 これまで、サーバー側のプリペアドステートメントの問題により、<span class="bold"><strong>Connector/J</strong></span> および <span class="bold"><strong>Connector/PHP</strong></span> 開発者はかわりに<span class="bold"><strong>クライアント側のプリペアドステートメント</strong></span>を使用する場合がありました。 最新の MySQL サーバーバージョンでは、パフォーマンス、スケーラビリティー、およびメモリー効率を向上させるために、サーバー側のプリペアドステートメントをお勧めします。 
      </p><p><a class="glossseealso" href="glossary.html#glos_client_side_prepared_statement">クライアント側のプリペアドステートメント</a>, <a class="glossseealso" href="glossary.html#glos_connector_j">Connector/J</a>, <a class="glossseealso" href="glossary.html#glos_connector_php">Connector/PHP</a>, <a class="glossseealso" href="glossary.html#glos_prepared_statement">プリペアドステートメント</a>も参照</p></dd><dt><a name="glos_read_ahead"></a><span class="glossterm">先読み</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764520128"></a>
        <span class="bold"><strong>pages</strong></span>(<span class="bold"><strong>extent</strong></span> 全体) のグループを<span class="bold"><strong>バッファプール</strong></span>に非同期にプリフェッチする I/O リクエストのタイプ。これらのページがまもなく必要になる場合に使用します。 線形先読み手法では、前のエクステントのページのアクセスパターンに基づいて、1 つのエクステントのすべてのページがプリフェッチされます。 ランダム先読み方法は、エクステントから特定数のページがバッファープールに入ると、同じエクステントのすべてのページをプリフェッチするものです。 ランダム先読みは、MySQL 5.5 には組み込まれていませんが、<code class="literal">innodb_random_read_ahead</code> 構成オプションの制御下で、MySQL 5.6 に再導入されています。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_extent">エクステント</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>も参照</p></dd><dt><a name="glos_delete"></a><span class="glossterm">削除</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764511776"></a>
        <code class="literal">InnoDB</code> が <code class="literal">DELETE</code> ステートメントを処理すると、行はすぐに削除対象としてマークされ、クエリーによって返されなくなります。 記憶域は、後で、<span class="bold"><strong>purge</strong></span> 操作と呼ばれる定期的なガベージコレクション中に再利用されます。 大量のデータを削除する場合、独自のパフォーマンス特性を持つ関連操作は <span class="bold"><strong>TRUNCATE</strong></span> および <span class="bold"><strong>DROP</strong></span> です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_drop">ドロップ</a>, <a class="glossseealso" href="glossary.html#glos_purge">パージ</a>, <a class="glossseealso" href="glossary.html#glos_truncate">切り捨て</a>も参照</p></dd><dt><a name="glos_delete_buffering"></a><span class="glossterm">削除バッファリング</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764503488"></a>
        ランダムな I/O を最小限に抑えるために物理書込みを実行できるように、変更を即座に書き込むのではなく、<code class="literal">DELETE</code> 操作によって生成されたセカンダリインデックスページへの変更を<span class="bold"><strong>変更バッファ</strong></span>に格納する方法。 (削除操作は 2 ステッププロセスなので、この操作は、通常はインデックスレコードに削除とマークする書き込みをバッファーに入れます。) これは<span class="bold"><strong>変更バッファリング</strong></span>の一種です。ほかのタイプには<span class="bold"><strong>挿入バッファリング</strong></span>と<span class="bold"><strong>パージバッファリング</strong></span>があります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_change_buffer">変更バッファー</a>, <a class="glossseealso" href="glossary.html#glos_change_buffering">変更バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_insert_buffer">挿入バッファー</a>, <a class="glossseealso" href="glossary.html#glos_insert_buffering">挿入バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_purge_buffering">パージバッファリング</a>も参照</p></dd><dt><a name="glos_referential_integrity"></a><span class="glossterm">参照整合性</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764483952"></a>
        常に一貫する形式でデータを保守する方法。<span class="bold"><strong>ACID</strong></span> 概念の一部です。 特に、異なるテーブル内のデータは<span class="bold"><strong>外部キー制約</strong></span>の使用を通じて一貫性が保持され、これによって変更が発生するのを防止したり、それらの変更をすべての関連テーブルに自動的に伝播したりできます。 関連メカニズムには、重複値が間違って挿入されるのを防ぐ<span class="bold"><strong>一意制約</strong></span>と、ブランク値が間違って挿入されるのを防ぐ <span class="bold"><strong>NOT NULL 制約</strong></span>が含まれます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_foreign_key_constraint">FOREIGN KEY 制約</a>, <a class="glossseealso" href="glossary.html#glos_not_null_constraint">NOT NULL 制約</a>, <a class="glossseealso" href="glossary.html#glos_unique_constraint">一意制約</a>も参照</p></dd><dt><a name="glos_infimum_record"></a><span class="glossterm">最大下限レコード</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764527664"></a>
        <span class="bold"><strong>インデックス</strong></span>内の<span class="bold"><strong>疑似レコード</strong></span>で、そのインデックスの最小値を下回る<span class="bold"><strong>ギャップ</strong></span>を表します。 トランザクションに <code class="literal">SELECT ... FROM ... WHERE col &lt; 10 FOR UPDATE;</code>などのステートメントがあり、カラム内の最小値が 5 の場合、他のトランザクションが 0 や -10 などの小さい値を挿入できないようにするための、最小レコードに対するロックです。 
      </p><p><a class="glossseealso" href="glossary.html#glos_gap">ギャップ</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_pseudo_record">疑似レコード</a>, <a class="glossseealso" href="glossary.html#glos_supremum_record">最小上限レコード</a>も参照</p></dd><dt><a name="glos_supremum_record"></a><span class="glossterm">最小上限レコード</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764534192"></a>
        インデックス内の<span class="bold"><strong>疑似レコード</strong></span>で、そのインデックスの最大値を上回る<span class="bold"><strong>ギャップ</strong></span>を表します。 トランザクションに <code class="literal">SELECT ... FROM ... WHERE col &gt; 10 FOR UPDATE;</code>などのステートメントがあり、カラムの最大値が 20 の場合、他のトランザクションが 50、100 などの大きな値を挿入できないようにするために、そのトランザクションは最高レコードをロックします。 
      </p><p><a class="glossseealso" href="glossary.html#glos_gap">ギャップ</a>, <a class="glossseealso" href="glossary.html#glos_infimum_record">最大下限レコード</a>, <a class="glossseealso" href="glossary.html#glos_pseudo_record">疑似レコード</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">シ</h3><dl><dt><a name="glos_system_tablespace"></a><span class="glossterm">システムテーブルスペース</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764475376"></a>
        <code class="literal">InnoDB</code> 関連オブジェクトのメタデータ、<span class="bold"><strong>変更バッファ</strong></span>の記憶域および<span class="bold"><strong>二重書込みバッファ</strong></span>を含む 1 つ以上のデータファイル (<span class="bold"><strong>ibdata ファイル</strong></span>)。 <span class="bold"><strong>file-per-table</strong></span> または<span class="bold"><strong>一般テーブルスペース</strong></span>ではなくシステムテーブルスペースにテーブルが作成された場合、<code class="literal">InnoDB</code> テーブルのテーブルおよびインデックスデータが含まれることもあります。 システムテーブルスペースのデータおよびメタデータは、MySQL <span class="bold"><strong>instance</strong></span> のすべての<span class="bold"><strong>データベース</strong></span>に適用されます。 
      </p><p>
        MySQL 5.6.7 より前のデフォルトでは、すべての <code class="literal">InnoDB</code> テーブルおよびインデックスがシステムテーブルスペース内に保持されるため、多くの場合、このファイルは非常に大きくなりました。 システムテーブルスペースは決して縮小しないので、大容量の一時データがロードされてから削除された場合、ストレージの問題が発生する可能性があります。 MySQL 8.0 では、デフォルトは <span class="bold"><strong>file-per-table</strong></span> モードで、各テーブルとそれに関連付けられたインデックスは別々の<span class="bold"><strong>.ibd ファイル</strong></span>に格納されます。 このデフォルトでは、テーブル <span class="bold"><strong>compression</strong></span>、<span class="bold"><strong>オフページカラム</strong></span>の効率的な格納、大規模なインデックスキー接頭辞など、<code class="literal">DYNAMIC</code> および <code class="literal">COMPRESSED</code> の行形式に依存する <code class="literal">InnoDB</code> 機能を簡単に使用できます。 
      </p><p>
        すべてのテーブルデータをシステムテーブルスペースまたは別個の <code class="filename">.ibd</code> ファイルのどちらに保持するかは、ストレージ管理全般に影響します。 <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品は、大きなファイルの小さなセットをバックアップすることも、多数のより小さなファイルをバックアップすることもできます。 何千ものテーブルがあるシステムでは、何千もの <code class="filename">.ibd</code> ファイルを処理するファイルシステム操作によってボトルネックが発生する可能性があります。 
      </p><p>
        <code class="literal">InnoDB</code> では、MySQL 5.7.6 に一般的なテーブルスペースが導入されました。これらは <code class="filename">.ibd</code> ファイルでも表されます。 一般テーブルスペースは、<code class="literal">CREATE TABLESPACE</code> 構文を使用して作成される共有テーブルスペースです。 これらはデータディレクトリの外部で作成でき、複数のテーブルを保持でき、すべての行形式のテーブルをサポートします。 
      </p><p><a class="glossseealso" href="glossary.html#glos_change_buffer">変更バッファー</a>, <a class="glossseealso" href="glossary.html#glos_compression">圧縮</a>, <a class="glossseealso" href="glossary.html#glos_data_dictionary">データディクショナリ</a>, <a class="glossseealso" href="glossary.html#glos_database">データベース</a>, <a class="glossseealso" href="glossary.html#glos_doublewrite_buffer">二重書き込みバッファー</a>, <a class="glossseealso" href="glossary.html#glos_dynamic_row_format">動的行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_general_tablespace">一般テーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_ibdata_file">ibdata ファイル</a>, <a class="glossseealso" href="glossary.html#glos_innodb_file_per_table">innodb_file_per_table</a>, <a class="glossseealso" href="glossary.html#glos_instance">インスタンス</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_off_page_column">オフページカラム</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_undo_log">Undo ログ</a>も参照</p></dd><dt><a name="glos_shutdown"></a><span class="glossterm">シャットダウン</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764396336"></a>
        MySQL Server を停止させるプロセス。 デフォルトでは、このプロセスは <span class="bold"><strong>InnoDB</strong></span> テーブルの操作をクリーンアップするため、<code class="literal">InnoDB</code> は<span class="bold"><strong>低速</strong></span>で停止できますが、後で高速に起動できます。 クリーンアップ操作をスキップすると、<span class="bold"><strong>高速</strong></span>で停止しますが、次回の再起動時にクリーンアップを実行する必要があります。 
      </p><p>
        <code class="literal">InnoDB</code> の停止モードは、<code class="literal">innodb_fast_shutdown</code> オプションによって制御されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_fast_shutdown">高速シャットダウン</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_slow_shutdown">低速シャットダウン</a>, <a class="glossseealso" href="glossary.html#glos_startup">起動</a>も参照</p></dd><dt><a name="glos_sharp_checkpoint"></a><span class="glossterm">シャープチェックポイント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764404704"></a>
        すべての<span class="bold"><strong>ダーティー</strong></span>バッファープールページ (その Redo エントリが <span class="bold"><strong>Redo ログ</strong></span>のどこかに含まれている) をディスクに<span class="bold"><strong>フラッシュ</strong></span>するプロセス。 <code class="literal">InnoDB</code> がログファイルの一部を再利用する前に発生します。ログファイルは循環的に使用されます。 通常は、書き込みの多い<span class="bold"><strong>ワークロード</strong></span>で発生します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_dirty_page">ダーティーページ</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>, <a class="glossseealso" href="glossary.html#glos_workload">ワークロード</a>も参照</p></dd><dt><a name="glos_serialized_dictionary_information"></a><span class="glossterm">シリアライズディクショナリ情報 (SDI)</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764354304"></a>
        シリアライズされた形式のディクショナリオブジェクトメタデータ。 SDI は <code class="literal">JSON</code> 形式で格納されます。 
      </p><p>
        MySQL 8.0.3 では、SDI は一時テーブルスペースおよび undo テーブルスペースファイルを除くすべての <code class="literal">InnoDB</code> テーブルスペースファイルに存在します。 SDI がテーブルスペースファイルに存在すると、メタデータの冗長性が提供されます。 たとえば、データディクショナリが使用できなくなった場合は、<span class="command"><strong>ibd2sdi</strong></span> ユーティリティを使用してテーブルスペースファイルからディクショナリオブジェクトメタデータを抽出できます。 
      </p><p>
        <code class="literal">MyISAM</code> テーブルの場合、SDI はスキーマディレクトリの <code class="filename">.sdi</code> メタデータファイルに格納されます。 <code class="literal">IMPORT TABLE</code> 操作を実行するには SDI メタデータファイルが必要です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_general_tablespace">一般テーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd><dt><a name="glos_primary_key"></a><span class="glossterm">主キー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764386400"></a>
        テーブル内のすべての行を一意に識別できる、このカラムセットに基づくインデックス。 したがって、<code class="literal">NULL</code> 値を一切含まない一意インデックスである必要があります。 
      </p><p>
        <code class="literal">InnoDB</code> では、すべてのテーブルにこのようなインデックス (<span class="bold"><strong>クラスタインデックス</strong></span>または<span class="bold"><strong>クラスタインデックス</strong></span>とも呼ばれます) があり、主キーのカラム値に基づいてテーブル記憶域を編成する必要があります。
      </p><p>
        主キー値を選択するときは、ほかの何らかのソースから派生した値 (<span class="bold"><strong>ナチュラルキー</strong></span>) に依存するのではなく、任意の値 (<span class="bold"><strong>合成キー</strong></span>) を使用することを検討してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_clustered_index">クラスタ化されたインデックス</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_natural_key">ナチュラルキー</a>, <a class="glossseealso" href="glossary.html#glos_synthetic_key">合成キー</a>も参照</p></dd><dt><a name="glos_redundant_row_format"></a><span class="glossterm">冗長行フォーマット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764366256"></a>
        最も古い <code class="literal">InnoDB</code> <span class="bold"><strong>行フォーマット</strong></span>。 MySQL 5.0.3 より前は、これが <code class="literal">InnoDB</code> で利用できる唯一の行フォーマットでした。 MySQL 5.0.3 から MySQL 5.7.8 へのデフォルトの行フォーマットは <span class="bold"><strong>COMPACT</strong></span> です。 MySQL 5.7.9 では、デフォルトの行フォーマットは、<span class="bold"><strong>DYNAMIC</strong></span> のデフォルト設定を持つ <code class="literal">innodb_default_row_format</code> 構成オプションによって定義されます。 古い <code class="literal">InnoDB</code> テーブルとの互換性のために、引き続き <span class="bold"><strong>REDUNDANT</strong></span> の行形式を指定できます。 
      </p><p>
        詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="15.10 InnoDB の行フォーマット">セクション15.10「InnoDB の行フォーマット」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_compact_row_format">コンパクト行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_dynamic_row_format">動的行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_row_format">行フォーマット</a>も参照</p></dd><dt><a name="glos_prepared_backup"></a><span class="glossterm">準備されたバックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764375712"></a>
        バックアップファイルセットの 1 つ。<span class="bold"><strong>バイナリログ</strong></span>および<span class="bold"><strong>増分バックアップ</strong></span>を適用するすべての段階が終了したあとに、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品によって生成されます。 結果ファイルは、<span class="bold"><strong>リストア</strong></span>できる状態です。 適用ステップより前のファイルは <span class="bold"><strong>raw バックアップ</strong></span>と呼ばれます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_binary_log">バイナリログ</a>, <a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_incremental_backup">増分バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_raw_backup">raw バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_restore">リストア</a>も参照</p></dd><dt><a name="glos_auto_increment"></a><span class="glossterm">自動インクリメント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764442976"></a>
        カラム内に昇順で値を自動的に追加する、テーブルカラムのプロパティー (<code class="literal">AUTO_INCREMENT</code> キーワードで指定します)。
      </p><p>
        これにより、開発者の作業が節約され、新しい行を挿入するときに新しい一意値を生成する必要はありません。 カラムには NULL でなく一意値が含まれているとわかっているので、クエリーオプティマイザに有用な情報をもたらします。 このようなカラムからの値は、さまざまなコンテキストでルックアップキーとして使用でき、自動生成されるので絶えず変更する理由はありません。このため、多くの場合、主キーカラムは自動インクリメントとして指定されます。 
      </p><p>
        タイミングの問題により、レプリカでステートメントをリプレイしてもソースと同じカラム値のセットが生成されない場合があるため、ステートメントベースのレプリケーションでは自動増分カラムに問題が発生する可能性があります。 自動インクリメントする主キーがある場合は、<code class="literal">innodb_autoinc_lock_mode=1</code> の設定だけでステートメントベースレプリケーションを使用できます。 挿入操作でより高い並列性を許可する <code class="literal">innodb_autoinc_lock_mode=2</code> を使用する場合は、<span class="bold"><strong>ステートメントベースレプリケーション</strong></span>ではなく<span class="bold"><strong>行ベースレプリケーション</strong></span>を使用してください。 互換性の目的以外は、<code class="literal">innodb_autoinc_lock_mode=0</code> の設定を使用しないでください。 
      </p><p>
        連続ロックモード (<code class="literal">innodb_autoinc_lock_mode=1</code>) は、MySQL 8.0.3 より前のデフォルト設定です。 MySQL 8.0.3 の時点では、インターリーブロックモード (<code class="literal">innodb_autoinc_lock_mode=2</code>) がデフォルトであり、デフォルトのレプリケーションタイプとしてステートメントベースから行ベースのレプリケーションへの変更が反映されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_auto_increment_locking">自動インクリメントロック</a>, <a class="glossseealso" href="glossary.html#glos_innodb_autoinc_lock_mode">innodb_autoinc_lock_mode</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>, <a class="glossseealso" href="glossary.html#glos_row_based_replication">行ベースレプリケーション</a>, <a class="glossseealso" href="glossary.html#glos_statement_based_replication">ステートメントベースレプリケーション</a>も参照</p></dd><dt><a name="glos_auto_increment_locking"></a><span class="glossterm">自動インクリメントロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764425952"></a>
        <span class="bold"><strong>自動インクリメント</strong></span>主キーの利便性には、並列性とのトレードオフが若干伴います。 もっとも単純なケースでは、あるトランザクションがテーブルに値を挿入している場合に、ほかのトランザクションはそのテーブルへのそれぞれの挿入を待機する必要があるので、最初のトランザクションによって挿入された行が、連続する主キー値を受け取ります。 <code class="literal">InnoDB</code> には最適化と <code class="literal">innodb_autoinc_lock_mode</code> オプションが含まれているため、自動インクリメント値の予測可能なシーケンスと挿入操作のための最大<span class="bold"><strong>同時実行性</strong></span>の間で最適なバランスを構成できます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_auto_increment">自動インクリメント</a>, <a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_innodb_autoinc_lock_mode">innodb_autoinc_lock_mode</a>も参照</p></dd><dt><a name="glos_autocommit"></a><span class="glossterm">自動コミット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764417632"></a>
        各 <span class="bold"><strong>SQL</strong></span> ステートメントのあとに<span class="bold"><strong>コミット</strong></span>操作を実行する設定。 複数のステートメントにまたがる <span class="bold"><strong>transactions</strong></span> で <code class="literal">InnoDB</code> テーブルを操作する場合、このモードはお薦めしません。 これは、特に MySQL 5.6.4 以上で、<span class="bold"><strong>ロック</strong></span>からのオーバーヘッドおよび<span class="bold"><strong>元に戻す</strong></span>データの生成を最小限に抑える <code class="literal">InnoDB</code> テーブルの<span class="bold"><strong>読取り専用トランザクション</strong></span>のパフォーマンスに役立ちます。 また、トランザクションを適用できない <code class="literal">MyISAM</code> テーブルの操作にも適しています。 
      </p><p><a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_read_only_transaction">読み取り専用トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_undo">Undo</a>も参照</p></dd><dt><a name="glos_parent_table"></a><span class="glossterm">親テーブル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764342832"></a>
        <span class="bold"><strong>子テーブル</strong></span>に (から) ポイントされた初期カラム値を保持する、<span class="bold"><strong>外部キー</strong></span>関係のテーブル。 親テーブル内の行を削除または更新したときの結果は、外部キー定義の <code class="literal">ON UPDATE</code> および <code class="literal">ON DELETE</code> 句によって異なります。 子テーブル内の対応する値の行が、それに合わせて自動的に削除または更新されたり、これらのカラムが <code class="literal">NULL</code> に設定されたり、操作が妨げられたりします。 
      </p><p><a class="glossseealso" href="glossary.html#glos_child_table">子テーブル</a>, <a class="glossseealso" href="glossary.html#glos_foreign_key">外部キー</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ス</h3><dl><dt><a name="glos_schema"></a><span class="glossterm">スキーマ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764334656"></a>
        概念的には、スキーマは、テーブル、テーブルカラム、カラムのデータ型、インデックス、外部キーなど、相互に関連するデータベースオブジェクトのセットです。 カラムがテーブルを構成する、外部キーがテーブルやカラムを参照するなどの理由で、これらのオブジェクトは SQL 構文を通じて接続されます。 理論的には、これらは論理的にも接続し、統合されたアプリケーションまたは柔軟なフレームワークの一部として連携します。 たとえば、<span class="bold"><strong>INFORMATION_SCHEMA</strong></span> および <span class="bold"><strong>performance_schema</strong></span> データベースでは、名前に <span class="quote">「<span class="quote">schema</span>」</span> を使用して、含まれるテーブルとカラムの間の密接な関係を強調します。 
      </p><p>
        MySQL では、<span class="bold"><strong>スキーマ</strong></span>は物理的に<span class="bold"><strong>データベース</strong></span>と同義です。 MySQL SQL 構文で、<code class="literal">DATABASE</code> の代わりにキーワード <code class="literal">SCHEMA</code> を代用できます。たとえば、<code class="literal">CREATE DATABASE</code> の代わりに <code class="literal">CREATE SCHEMA</code> を使用できます。 
      </p><p>
        ほかのデータベース製品では区別しているものがあります。 たとえば、Oracle Database 製品では、<span class="bold"><strong>スキーマ</strong></span>はデータベースの一部、つまり単一ユーザーが所有するテーブルおよびほかのオブジェクトだけを表します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_database">データベース</a>, <a class="glossseealso" href="glossary.html#glos_information_schema">INFORMATION_SCHEMA</a>, <a class="glossseealso" href="glossary.html#glos_performance_schema">パフォーマンススキーマ</a>も参照</p></dd><dt><a name="glos_scalability"></a><span class="glossterm">スケーラビリティー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764321440"></a>
        システム能力の限界を超えてもパフォーマンスが突然落ちることがなく、システムにより多くの作業を追加したりより多くの同時リクエストを発行したりできること。 ソフトウェアアーキテクチャー、ハードウェア構成、アプリケーションコーディング、およびワークロードのタイプはすべて、スケーラビリティーで役割を担います。 システムがその最大能力に達したときにスケーラビリティーを増やす一般的な方法には、<span class="bold"><strong>スケールアップ</strong></span> (既存のハードウェアまたはソフトウェアの能力を増大させる) と<span class="bold"><strong>スケールアウト</strong></span> (新しいサーバーやより多くの MySQL インスタンスを追加する) があります。 多くの場合、大規模開発の重要な側面として、<span class="bold"><strong>可用性</strong></span>と組み合わされます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_availability">可用性</a>, <a class="glossseealso" href="glossary.html#glos_scale_out">スケールアウト</a>, <a class="glossseealso" href="glossary.html#glos_scale_up">スケールアップ</a>も参照</p></dd><dt><a name="glos_scale_out"></a><span class="glossterm">スケールアウト</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764314000"></a>
        新しいサーバーやより多くの MySQL インスタンスを追加することによって<span class="bold"><strong>スケーラビリティー</strong></span>を増大させる方法。 たとえば、レプリケーション、NDB Cluster、接続プーリング、またはサーバーのグループ全体に機能を分散させるその他の機能を設定します。 <span class="bold"><strong>スケールアップ</strong></span>と対比してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_scalability">スケーラビリティー</a>, <a class="glossseealso" href="glossary.html#glos_scale_up">スケールアップ</a>も参照</p></dd><dt><a name="glos_scale_up"></a><span class="glossterm">スケールアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764308752"></a>
        既存のハードウェアまたはソフトウェアの能力を高めることにより<span class="bold"><strong>スケーラビリティー</strong></span>を増大させる方法。 たとえば、サーバー上でメモリーを増やすこと、<code class="literal">innodb_buffer_pool_size</code> や <code class="literal">innodb_buffer_pool_instances</code> などのメモリー関連パラメータを調整すること。 <span class="bold"><strong>スケールアウト</strong></span>と対比してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_scalability">スケーラビリティー</a>, <a class="glossseealso" href="glossary.html#glos_scale_out">スケールアウト</a>も参照</p></dd><dt><a name="glos_stemming"></a><span class="glossterm">ステミング</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764276560"></a>
        単数形と複数形、過去、現在、および未来時制など、共通語幹に基づいて単語のさまざまなバリエーションを検索する機能。 この機能は現在、<code class="literal">MyISAM</code> <span class="bold"><strong>全文検索</strong></span>機能でサポートされていますが、<code class="literal">InnoDB</code> テーブルの<span class="bold"><strong>FULLTEXT インデックス</strong></span>ではサポートされていません。 
      </p><p><a class="glossseealso" href="glossary.html#glos_full_text_search">全文検索</a>, <a class="glossseealso" href="glossary.html#glos_fulltext_index">FULLTEXT インデックス</a>も参照</p></dd><dt><a name="glos_statement_interceptor"></a><span class="glossterm">ステートメントインターセプタ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764301440"></a>
        データベースアプリケーションによって発行された SQL ステートメントをトレース、デバッグまたは拡張するための <span class="bold"><strong>interceptor</strong></span> のタイプ。 <span class="bold"><strong>コマンドインタセプタ</strong></span>とも呼ばれます。 
      </p><p>
        <span class="bold"><strong>Connector/J</strong></span> を使用する <span class="bold"><strong>Java</strong></span> アプリケーションでは、このタイプのインターセプタを設定するには、<code class="literal">com.mysql.jdbc.StatementInterceptorV2</code> インタフェースを実装し、<code class="literal">statementInterceptors</code> プロパティを<span class="bold"><strong>接続文字列</strong></span>に追加します。
      </p><p>
        <span class="bold"><strong>Connector/NET</strong></span> を使用する <span class="bold"><strong>Visual Studio</strong></span> アプリケーションでは、このタイプのインターセプタを設定するには、<code class="literal">BaseCommandInterceptor</code> クラスから継承するクラスを定義し、そのクラス名を接続文字列の一部として指定する必要があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_command_interceptor">コマンドインタセプタ</a>, <a class="glossseealso" href="glossary.html#glos_connection_string">接続文字列</a>, <a class="glossseealso" href="glossary.html#glos_connector_j">Connector/J</a>, <a class="glossseealso" href="glossary.html#glos_connector_net">Connector/NET</a>, <a class="glossseealso" href="glossary.html#glos_interceptor">interceptor</a>, <a class="glossseealso" href="glossary.html#glos_java">Java</a>, <a class="glossseealso" href="glossary.html#glos_visual_studio">Visual Studio</a>も参照</p></dd><dt><a name="glos_statement_based_replication"></a><span class="glossterm">ステートメントベースレプリケーション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764286288"></a>
        SQL ステートメントが <span class="bold"><strong>source</strong></span> から送信され、<span class="bold"><strong>レプリカ</strong></span>でリプレイされる<span class="bold"><strong>レプリケーション</strong></span>の形式。 <span class="bold"><strong>auto-increment locking</strong></span> の潜在的なタイミング問題を回避するために、<code class="literal">innodb_autoinc_lock_mode</code> オプションの設定には注意が必要です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_auto_increment_locking">自動インクリメントロック</a>, <a class="glossseealso" href="glossary.html#glos_innodb_autoinc_lock_mode">innodb_autoinc_lock_mode</a>, <a class="glossseealso" href="glossary.html#glos_replica">レプリカ</a>, <a class="glossseealso" href="glossary.html#glos_replication">レプリケーション</a>, <a class="glossseealso" href="glossary.html#glos_row_based_replication">行ベースレプリケーション</a>, <a class="glossseealso" href="glossary.html#glos_source">source</a>も参照</p></dd><dt><a name="glos_stored-object"></a><span class="glossterm">ストアドオブジェクト</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764269744"></a>
        ストアドプログラムまたはビュー。
      </p></dd><dt><a name="glos_stored-program"></a><span class="glossterm">ストアドプログラム</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764261584"></a>
        ストアドルーチン (プロシージャーまたはファンクション)、トリガー、またはイベントスケジューライベント。
      </p></dd><dt><a name="glos_stored-routine"></a><span class="glossterm">ストアドルーチン</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764258880"></a>
        ストアドプロシージャまたはファンクション。
      </p></dd><dt><a name="glos_stored_generated_column"></a><span class="glossterm">ストアド生成カラム</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764267296"></a>
        カラム定義に含まれる式から値が計算されるカラム。 カラム値は、行の挿入または更新時に評価および格納されます。 格納された生成カラムには記憶領域が必要で、インデックス付けできます。 
      </p><p>
        <span class="bold"><strong>仮想生成カラム</strong></span>と対比してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_base_column">ベースカラム</a>, <a class="glossseealso" href="glossary.html#glos_generated_column">生成されるカラム</a>, <a class="glossseealso" href="glossary.html#glos_virtual_generated_column">仮想生成カラム</a>も参照</p></dd><dt><a name="glos_stopword"></a><span class="glossterm">ストップワード</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764256448"></a>
        <span class="bold"><strong>FULLTEXT インデックス</strong></span>で、十分に一般的または些細なので<span class="bold"><strong>検索インデックス</strong></span>から除外し、検索クエリーで無視できると考えられている単語。 <code class="literal">InnoDB</code> テーブルと <code class="literal">MyISAM</code> テーブルとでは、異なる構成設定がストップワード処理を制御します。 詳細は、<a class="xref" href="functions.html#fulltext-stopwords" title="12.10.4 全文ストップワード">セクション12.10.4「全文ストップワード」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_fulltext_index">FULLTEXT インデックス</a>, <a class="glossseealso" href="glossary.html#glos_search_index">検索インデックス</a>も参照</p></dd><dt><a name="glos_storage_engine"></a><span class="glossterm">ストレージエンジン</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764249168"></a>
        MySQL データベースのコンポーネントの 1 つ。データの格納、更新、および照会という低レベル作業を実行します。 MySQL 5.5 以上では、<span class="bold"><strong>InnoDB</strong></span> が新しいテーブルのデフォルトのストレージエンジンであり、<code class="literal">MyISAM</code> よりも優先されます。 メモリー使用とディスク使用、読み取り速度と書き込み速度、速度と堅牢性など、異なる要因間トレードオフのために異なるストレージエンジンが設計されています。 各ストレージエンジンが特定のテーブルを管理するので、<code class="literal">InnoDB</code> テーブル、<code class="literal">MyISAM</code> テーブルなどと呼びます。 
      </p><p>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品は、<code class="literal">InnoDB</code> テーブルのバックアップ用に最適化されています。 また、<code class="literal">MyISAM</code> およびその他のストレージエンジンによって処理されるテーブルをバックアップすることもできます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_table_type">テーブルタイプ</a>も参照</p></dd><dt><a name="glos_snapshot"></a><span class="glossterm">スナップショット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764237600"></a>
        特定時点のデータの表現。ほかの<span class="bold"><strong>トランザクション</strong></span>によって変更が<span class="bold"><strong>コミット</strong></span>されても変化しません。 <span class="bold"><strong>一貫性読み取り</strong></span>を許可する<span class="bold"><strong>分離レベル</strong></span>で使用されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_consistent_read">一貫性読み取り</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_sparse_file"></a><span class="glossterm">スパースファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764230080"></a>
        実際の空の領域を書き込むのではなく、空のブロックを表すメタデータをディスクに書き込むことで、ファイルシステム領域をより効率的に使用するファイルのタイプ。 <code class="literal">InnoDB</code> <span class="bold"><strong>透過的ページ圧縮</strong></span>機能は、スパースファイルサポートに依存します。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-page-compression" title="15.9.2 InnoDB ページ圧縮">セクション15.9.2「InnoDB ページ圧縮」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_hole_punching">ホールパンチング</a>, <a class="glossseealso" href="glossary.html#glos_transparent_page_compression">透過的ページ圧縮</a>も参照</p></dd><dt><a name="glos_spin"></a><span class="glossterm">スピン</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764223984"></a>
        リソースが利用できるようになるかどうかを継続的にテストするタイプの<span class="bold"><strong>待機</strong></span>操作。 この手法は、スレッドをスリープさせてコンテキスト切替えを実行するよりも<span class="quote">「<span class="quote">「ビジーループ」</span>」</span>で待機する方が効率的な短い期間のみ保持されるリソースに使用されます。 リソースが短時間で利用できなくなると、スピンループは中止し、別の待機方法が使用されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_latch">ラッチ</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_mutex">相互排他ロック</a>, <a class="glossseealso" href="glossary.html#glos_wait">待機</a>も参照</p></dd><dt><a name="glos_space_id"></a><span class="glossterm">スペース ID</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764217984"></a>
        MySQL インスタンス内で <code class="literal">InnoDB</code> <span class="bold"><strong>テーブルスペース</strong></span>を一意に識別するために使用される識別子。 <span class="bold"><strong>システムテーブルスペース</strong></span>の領域 ID は常にゼロです。この同じ ID は、システムテーブルスペース内または一般テーブルスペース内のすべてのテーブルに適用されます。 各 <span class="bold"><strong>file-per-table</strong></span> テーブルスペースおよび<span class="bold"><strong>一般テーブルスペース</strong></span>には、独自の領域 ID があります。 
      </p><p>
        MySQL 5.6 より前では、このハードコードされた値によって、MySQL インスタンス間で <code class="literal">InnoDB</code> テーブルスペースファイルを移動することが困難でした。 MySQL 5.6 以降では、ステートメント <code class="literal">FLUSH TABLES ... FOR EXPORT</code>、<code class="literal">ALTER TABLE ... DISCARD TABLESPACE</code>、および <code class="literal">ALTER TABLE ... IMPORT TABLESPACE</code> を含む<span class="bold"><strong>トランスポータブルテーブルスペース</strong></span>機能を使用することによって、インスタンス間でテーブルスペースファイルをコピーできます。 スペース ID を調整するために必要な情報は、テーブルスペースとともにコピーする <span class="bold"><strong>.cfg ファイル</strong></span>で伝えられます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-table-import" title="15.6.1.3 InnoDB テーブルのインポート">セクション15.6.1.3「InnoDB テーブルのインポート」</a> を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_cfg_file">.cfg ファイル</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_general_tablespace">一般テーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_transportable_tablespace">トランスポータブルテーブルスペース</a>も参照</p></dd><dt><a name="glos_thread"></a><span class="glossterm">スレッド</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764200352"></a>
        通常は<span class="bold"><strong>プロセス</strong></span>より軽量で、高度な<span class="bold"><strong>並列性</strong></span>に対応できる処理単位。
      </p><p><a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_master_thread">マスタースレッド</a>, <a class="glossseealso" href="glossary.html#glos_process">プロセス</a>, <a class="glossseealso" href="glossary.html#glos_pthreads">Pthreads</a>も参照</p></dd><dt><a name="glos_slave_server"></a><span class="glossterm">スレーブ</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_replica">レプリカ</a>も参照</p></dd><dt><a name="glos_slow_query_log"></a><span class="glossterm">スロークエリーログ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764194224"></a>
        MySQL Server によって処理される SQL ステートメントのパフォーマンスチューニングに使用されるタイプの<span class="bold"><strong>ログ</strong></span>。 ログ情報はファイルに格納されます。 使用するにはこの機能を有効にする必要があります。 ログに記録する<span class="quote">「<span class="quote">「低速」</span>」</span> SQL ステートメントのカテゴリを制御します。 詳細は、<a class="xref" href="server-administration.html#slow-query-log" title="5.4.5 スロークエリーログ">セクション5.4.5「スロークエリーログ」</a>を参照してください。 

      </p><p><a class="glossseealso" href="glossary.html#glos_general_query_log">一般クエリーログ</a>, <a class="glossseealso" href="glossary.html#glos_log">ログ</a>も参照</p></dd><dt><a name="glos_read_phenomena"></a><span class="glossterm">既読現象</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764188480"></a>
        <span class="bold"><strong>ダーティリード</strong></span>、<span class="bold"><strong>反復不可能な読み取り</strong></span>、<span class="bold"><strong>phantom</strong></span> などの現象は、トランザクションが別のトランザクションによって変更されたデータを読み取るときに発生する可能性があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_dirty_read">ダーティー読み取り</a>, <a class="glossseealso" href="glossary.html#glos_non_repeatable_read">反復不可能読み取り</a>, <a class="glossseealso" href="glossary.html#glos_phantom">ファントム</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">セ</h3><dl><dt><a name="glos_secondary_index"></a><span class="glossterm">セカンダリインデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764137712"></a>
        テーブルのカラムのサブセットを表す <code class="literal">InnoDB</code> <span class="bold"><strong>index</strong></span> のタイプ。 <code class="literal">InnoDB</code> テーブルには、ゼロ、1 つまたは複数のセカンダリインデックスを含めることができます。 (各 <code class="literal">InnoDB</code> テーブルに必要な<span class="bold"><strong>クラスタインデックス</strong></span>と対比して、すべてのテーブルのカラムのデータを格納します。) 
      </p><p>
        セカンダリインデックスは、インデックスカラムからの値だけを必要とするクエリーを満たすために使用できます。 より複雑なクエリーの場合、テーブル内の該当行を識別するために使用でき、それらはクラスタ化されたインデックスを使用するルックアップで取得されます。 
      </p><p>
        セカンダリインデックスの作成および削除には、従来、<code class="literal">InnoDB</code> テーブルのすべてのデータのコピーによる大きなオーバーヘッドが伴いました。 <span class="bold"><strong>高速インデックス作成</strong></span>機能を使用すると、<code class="literal">InnoDB</code> セカンダリインデックスに対して <code class="literal">CREATE INDEX</code> ステートメントと <code class="literal">DROP INDEX</code> ステートメントの両方がはるかに高速になります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_clustered_index">クラスタ化されたインデックス</a>, <a class="glossseealso" href="glossary.html#glos_fast_index_creation">高速インデックス作成</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>も参照</p></dd><dt><a name="glos_segment"></a><span class="glossterm">セグメント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764124096"></a>
        <code class="literal">InnoDB</code> <span class="bold"><strong>テーブルスペース</strong></span>内のディビジョン。 テーブルスペースをディレクトリに例えると、セグメントはそのディレクトリ内のファイルに似ています。 セグメントは増えることができます。 新しいセグメントを作成できます。 
      </p><p>
        たとえば、<span class="bold"><strong>file-per-table</strong></span> テーブルスペース内では、テーブルデータは 1 つのセグメントにあり、関連付けられた各インデックスは独自のセグメントにあります。 <span class="bold"><strong>システムテーブルスペース</strong></span>は、多くのテーブルとそれらに関連付けられたインデックスを保持できるため、多くの異なるセグメントを含みます。 MySQL 8.0 より前のシステムテーブルスペースには、<span class="bold"><strong>undo ログ</strong></span>に使用される 1 つ以上の<span class="bold"><strong>ロールバックセグメント</strong></span>も含まれていました。 
      </p><p>
        セグメントは、データの挿入と削除に応じて拡大、縮小します。 セグメントがより多くの領域を必要とする場合、一度に 1 <span class="bold"><strong>エクステント</strong></span> (1M バイト) ずつ拡張されます。 同様に、セグメントは、あるエクステント内のすべてのデータが不要になると、そのエクステント分の領域を解放します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_extent">エクステント</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_rollback_segment">ロールバックセグメント</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_undo_log">Undo ログ</a>も参照</p></dd><dt><a name="glos_session_temporary_tablespace"></a><span class="glossterm">セッション一時テーブルスペース</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764111088"></a>
        <code class="literal">InnoDB</code> が内部一時テーブルのディスク上のストレージエンジンとして構成されている場合に、<span class="emphasis"><em>オプティマイザ</em></span>によって作成されたユーザー作成の<span class="emphasis"><em>一時テーブル</em></span>および内部一時テーブルを格納する<span class="emphasis"><em>一時テーブルスペース</em></span>。
      </p><p><a class="glossseealso" href="glossary.html#glos_optimizer">オプティマイザ</a>, <a class="glossseealso" href="glossary.html#glos_temporary_table">一時テーブル</a>, <a class="glossseealso" href="glossary.html#glos_temporary_tablespace">一時テーブルスペース</a>も参照</p></dd><dt><a name="glos_savepoint"></a><span class="glossterm">セーブポイント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764143728"></a>
        セーブポイントは、ネストされた<span class="bold"><strong>トランザクション</strong></span>の実装に役立ちます。 それらは、lより大きなトランザクションの一部であるテーブル上での操作にスコープを提供するために使用できます。 たとえば、予約システムで旅行をスケジュールするときに、いくつかの異なる航空便を予約する場合があります。希望の航空便を利用できない場合、予約に成功したそれより早い航空便をロールバックすることなく、その 1 行程の予約に関与する変更を<span class="bold"><strong>ロールバック</strong></span>できます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_full_text_search"></a><span class="glossterm">全文検索</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764068096"></a>
        SQL <code class="literal">LIKE</code> 演算子を使用したり、アプリケーションレベル検索アルゴリズムを作成したりするよりも、より高速、より便利で、かつより柔軟な方法で単語、語句、単語のブール結合などをテーブルデータ内で検索するための MySQL 機能。 これは、SQL 関数 <code class="literal">MATCH()</code> および <span class="bold"><strong>FULLTEXT インデックス</strong></span>を使用します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_fulltext_index">FULLTEXT インデックス</a>も参照</p></dd><dt><a name="glos_constraint"></a><span class="glossterm">制約</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764150496"></a>
        データが一貫性を失うのを防ぐために、データベース変更をブロックできる自動テスト。 (コンピュータサイエンス用語では、不変条件に関連する一種のアサーション。) 制約は、データ一貫性を維持するための、<span class="bold"><strong>ACID</strong></span> 概念の重要な構成要素です。 MySQL によってサポートされる制約には、<span class="bold"><strong>FOREIGN KEY 制約</strong></span>と<span class="bold"><strong>一意制約</strong></span>があります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_foreign_key">外部キー</a>, <a class="glossseealso" href="glossary.html#glos_unique_constraint">一意制約</a>も参照</p></dd><dt><a name="glos_connection"></a><span class="glossterm">接続</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764104800"></a>
        アプリケーションと MySQL サーバー間の通信チャネル。 データベースアプリケーションのパフォーマンスおよびスケーラビリティは、データベース接続の確立速度、同時に実行できる数、および永続化の期間に影響されます。 <span class="bold"><strong>host</strong></span>、<span class="bold"><strong>port</strong></span> などのパラメータは、<span class="bold"><strong>Connector/NET</strong></span> では<span class="bold"><strong>接続文字列</strong></span>として、<span class="bold"><strong>Connector/ODBC</strong></span> では <span class="bold"><strong>DSN</strong></span> として表されます。 高トラフィックシステムは、<span class="bold"><strong>接続プール</strong></span>と呼ばれる最適化を利用します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_connection_pool">接続プール</a>, <a class="glossseealso" href="glossary.html#glos_connection_string">接続文字列</a>, <a class="glossseealso" href="glossary.html#glos_connector_net">Connector/NET</a>, <a class="glossseealso" href="glossary.html#glos_connector_odbc">Connector/ODBC</a>, <a class="glossseealso" href="glossary.html#glos_dsn">DSN</a>, <a class="glossseealso" href="glossary.html#glos_host">ホスト</a>, <a class="glossseealso" href="glossary.html#glos_port">port</a>も参照</p></dd><dt><a name="glos_connection_pool"></a><span class="glossterm">接続プール</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764092960"></a>
        データベース操作ごとに新しい接続を設定および切断するのではなく、同じアプリケーション内または異なるアプリケーション間でデータベース <span class="bold"><strong>connections</strong></span> を再利用できるキャッシュ領域。 この手法は、<span class="bold"><strong>J2EE</strong></span> アプリケーションサーバーで共通です。 <span class="bold"><strong>Connector/J</strong></span> を使用する <span class="bold"><strong>Java</strong></span> アプリケーションでは、<span class="bold"><strong>Tomcat</strong></span> および他のアプリケーションサーバーの接続プール機能を使用できます。 再利用はアプリケーションに対して透過的です。アプリケーションは通常どおり接続を開いて閉じます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_connection">接続</a>, <a class="glossseealso" href="glossary.html#glos_connector_j">Connector/J</a>, <a class="glossseealso" href="glossary.html#glos_j2ee">J2EE</a>, <a class="glossseealso" href="glossary.html#glos_tomcat">Tomcat</a>も参照</p></dd><dt><a name="glos_connection_string"></a><span class="glossterm">接続文字列</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764083808"></a>
        プログラムコードで使用できるように文字列リテラルとしてエンコードされた、データベース <span class="bold"><strong>connection</strong></span> のパラメータの表現。 文字列の一部は、<span class="bold"><strong>host</strong></span> や <span class="bold"><strong>port</strong></span> などの接続パラメータを表します。 接続文字列には、セミコロンで区切られた複数のキーと値のペアが含まれます。 各キーと値のペアは等号で結合されます。 <span class="bold"><strong>Connector/NET</strong></span> アプリケーションで頻繁に使用されます。詳細は、<a class="ulink" href="https://dev.mysql.com/doc/connector-net/en/connector-net-connections-string.html" target="_top">Creating a Connector/NET Connection String</a> を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_connection">接続</a>, <a class="glossseealso" href="glossary.html#glos_connector_net">Connector/NET</a>, <a class="glossseealso" href="glossary.html#glos_host">ホスト</a>, <a class="glossseealso" href="glossary.html#glos_port">port</a>も参照</p></dd><dt><a name="glos_normalized"></a><span class="glossterm">正規化</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764181280"></a>
        データベース設計戦略の 1 つ。データは複数のテーブルに分割されていて、圧縮された値を ID で表された単一行に複製することで、冗長または長い値を格納、照会、および更新することを回避します。 通常は <span class="bold"><strong>OLTP</strong></span> アプリケーションで使用されます。 
      </p><p>
        たとえば、住所に一意 ID を与えることで、国勢調査データベースはその ID を家族の各メンバーに関連付けることによって、<span class="bold"><strong>この住所の住居人</strong></span>という関係を表現できます (<span class="bold"><strong>米国のある街のメインストリート 123</strong></span> などの複雑な値のコピーを複数格納するのではなく)。
      </p><p>
        別の例としては、単純な住所録アプリケーションでは、ある人の名前および住所と同じテーブルにそれぞれの電話番号を格納しますが、電話会社データベースでは、各電話番号に特別な ID を与えてその番号と ID を別のテーブルに格納します。 この正規化表現によって、市外局番が分かれるときの大幅な更新を簡略化できます。 
      </p><p>
        正規化が常に推奨されるわけではありません。 主に照会されるだけで、更新されるのは全体を削除してリロードする場合だけのデータは、多くの場合、重複値の冗長コピーを持つ少数の大きなテーブルで保持されます。 このデータ表現は、<span class="bold"><strong>非正規化</strong></span>と呼ばれ、データウェアハウスアプリケーションでよく見られます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_denormalized">非正規化</a>, <a class="glossseealso" href="glossary.html#glos_foreign_key">外部キー</a>, <a class="glossseealso" href="glossary.html#glos_oltp">OLTP</a>, <a class="glossseealso" href="glossary.html#glos_relational">リレーショナル</a>も参照</p></dd><dt><a name="glos_generated_stored_column"></a><span class="glossterm">生成されたストアドカラム</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_stored_generated_column">ストアド生成カラム</a>も参照</p></dd><dt><a name="glos_generated_virtual_column"></a><span class="glossterm">生成された仮想カラム</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_virtual_generated_column">仮想生成カラム</a>も参照</p></dd><dt><a name="glos_generated_column"></a><span class="glossterm">生成されるカラム</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764156160"></a>
        カラム定義に含まれる式から値が計算されるカラム。 生成されるカラムは、<span class="bold"><strong>virtual</strong></span> または <span class="bold"><strong>stored</strong></span> です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_base_column">ベースカラム</a>, <a class="glossseealso" href="glossary.html#glos_stored_generated_column">ストアド生成カラム</a>, <a class="glossseealso" href="glossary.html#glos_virtual_generated_column">仮想生成カラム</a>も参照</p></dd><dt><a name="glos_selectivity"></a><span class="glossterm">選択性</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764074736"></a>
        データ分布のプロパティーの 1 つ。カラム内の個別値の数 (その <span class="bold"><strong>カーディナリティー</strong></span>) をテーブル内のレコード数で割ったもの。 高い選択性は、カラム値が比較的一意であり、インデックスを通じて効率的に取得できることを意味します。 <code class="literal">WHERE</code> 句内のテストがテーブル内の少ない数 (または割合) の行にのみ一致すると予測できる場合 (またはクエリーオプティマイザがそう予測する場合)、<span class="bold"><strong>クエリー</strong></span>がインデックスを使用してそのテストを最初に評価すると、全体的に効率的である傾向があります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_cardinality">カーディナリティー</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>も参照</p></dd><dt><a name="glos_quiesce"></a><span class="glossterm">静止</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764170160"></a>
        データベースアクティビティーの量を減らすこと。多くの場合、<code class="literal">ALTER TABLE</code>、<span class="bold"><strong>バックアップ</strong></span>、<span class="bold"><strong>シャットダウン</strong></span>などの操作に備えるためです。 最大限の<span class="bold"><strong>フラッシュ</strong></span>の実行を伴う場合があるため (そうでない場合もありますが)、<span class="bold"><strong>InnoDB</strong></span> はバックグラウンド I/O の実行を継続しません。 
      </p><p>
        MySQL 5.6 以降では、構文 <code class="literal">FLUSH TABLES ... FOR EXPORT</code> によって <code class="literal">InnoDB</code> テーブルの一部のデータがディスクに書き込まれるので、そのデータファイルをコピーすることでこれらのテーブルをより簡単にバックアップできます。
      </p><p><a class="glossseealso" href="glossary.html#glos_backup">バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_shutdown">シャットダウン</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ソ</h3><dl><dt><a name="glos_sort_buffer"></a><span class="glossterm">ソートバッファー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764010560"></a>
        <code class="literal">InnoDB</code> インデックスの作成中にデータをソートするために使用されるバッファー。 ソートバッファーサイズは、<code class="literal">innodb_sort_buffer_size</code> 構成オプションを使用して構成されます。 
      </p></dd><dt><a name="glos_incremental_backup"></a><span class="glossterm">増分バックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764018608"></a>
        ある時点以降に変更されたデータだけを保存する、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品で実行されるタイプの<span class="bold"><strong>ホットバックアップ</strong></span>。 完全バックアップと一連の増分バックアップがあれば、いくつかの完全バックアップを手元においておくストレージオーバーヘッドなしで、長期間にわたるバックアップデータを再構築できます。 完全バックアップをリストアしてから各増分バックアップを連続して適用したり、各増分バックアップを完全バックアップに適用することでこれを最新の状態に保った状態で単一リストア操作を実行したりできます。 
      </p><p>
        変更データの粒度は<span class="bold"><strong>ページ</strong></span>レベルです。 実際は 1 つのページが複数の行をカバーすることがあります。 変更された各ページがバックアップに含まれます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>も参照</p></dd><dt><a name="glos_insert"></a><span class="glossterm">挿入</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764050768"></a>
        <span class="bold"><strong>SQL</strong></span> での主要な <span class="bold"><strong>DML</strong></span> 操作の 1 つ。 挿入のパフォーマンスは、<span class="bold"><strong>データウェアハウス</strong></span>システム (数百万行をテーブルにロードする) と <span class="bold"><strong>OLTP</strong></span> システム (多数の並列接続が行を同じテーブルに任意の順序で挿入する可能性がある) で重要な要因です。 挿入パフォーマンスが重要な場合は、<span class="bold"><strong>変更バッファリング</strong></span>で使用される<span class="bold"><strong>挿入バッファー</strong></span>や<span class="bold"><strong>自動インクリメント</strong></span>カラムなどの <span class="bold"><strong>InnoDB</strong></span> 機能を学習することをお勧めします。 
      </p><p><a class="glossseealso" href="glossary.html#glos_auto_increment">自動インクリメント</a>, <a class="glossseealso" href="glossary.html#glos_change_buffering">変更バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_data_warehouse">データウェアハウス</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_insert_buffer">挿入バッファー</a>, <a class="glossseealso" href="glossary.html#glos_oltp">OLTP</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>も参照</p></dd><dt><a name="glos_insert_buffering"></a><span class="glossterm">挿入バッファリング</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764030032"></a>
        ランダムな I/O を最小限に抑えるために物理書込みを実行できるように、変更を即座に書き込むのではなく、<code class="literal">INSERT</code> 操作によって生成されたセカンダリインデックスページへの変更を<span class="bold"><strong>変更バッファ</strong></span>に格納する方法。 これは<span class="bold"><strong>変更バッファリング</strong></span>の 1 つのタイプです。ほかに<span class="bold"><strong>削除バッファリング</strong></span>と<span class="bold"><strong>パージバッファリング</strong></span>があります。 
      </p><p>
        セカンダリインデックスが<span class="bold"><strong>一意</strong></span>の場合には挿入バッファリングは使用されません。新しいエントリが書き出される前に新しい値の一意性を検証できないためです。 ほかの種類の変更バッファリングは一意インデックスに有効です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_change_buffer">変更バッファー</a>, <a class="glossseealso" href="glossary.html#glos_change_buffering">変更バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_delete_buffering">削除バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_insert_buffer">挿入バッファー</a>, <a class="glossseealso" href="glossary.html#glos_purge_buffering">パージバッファリング</a>, <a class="glossseealso" href="glossary.html#glos_unique_index">一意のインデックス</a>も参照</p></dd><dt><a name="glos_insert_buffer"></a><span class="glossterm">挿入バッファー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764038032"></a>
        <span class="bold"><strong>変更バッファ</strong></span>の以前の名前。 MySQL 5.5 では、<code class="literal">DELETE</code> および <code class="literal">UPDATE</code> 操作のセカンダリインデックスページへの変更をバッファリングするためのサポートが追加されました。 以前は、<code class="literal">INSERT</code> 操作による変更のみがバッファされていました。 現在推奨されている用語は<span class="emphasis"><em>変更バッファ</em></span>です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_change_buffer">変更バッファー</a>, <a class="glossseealso" href="glossary.html#glos_change_buffering">変更バッファリング</a>も参照</p></dd><dt><a name="glos_mutex"></a><span class="glossterm">相互排他ロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764061536"></a>
        <span class="quote">「<span class="quote">「mutex 変数」</span>」</span>の非公式略称。 (Mutex 自体は<span class="quote">「<span class="quote">「相互排他」</span>」</span>の短縮形です。) <code class="literal">InnoDB</code> が内部インメモリーデータ構造への排他的アクセス<span class="bold"><strong>ロック</strong></span>を表現および強制するために使用する低レベルオブジェクト。 ロックが獲得されると、ほかのプロセスやスレッドなどは同じロックを獲得できなくなります。 <code class="literal">InnoDB</code> が内部インメモリーデータ構造への共有アクセス<span class="bold"><strong>ロック</strong></span>を表現および強制するために使用する <span class="bold"><strong>rw-locks</strong></span> と対比してください。 相互排他ロックと読み書きロックはまとめて、<span class="bold"><strong>ラッチ</strong></span>と呼ばれます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_latch">ラッチ</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_performance_schema">パフォーマンススキーマ</a>, <a class="glossseealso" href="glossary.html#glos_pthreads">Pthreads</a>, <a class="glossseealso" href="glossary.html#glos_rw_lock">rw ロック (読み書きロック)</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">タ</h3><dl><dt><a name="glos_tuple"></a><span class="glossterm">タプル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763968784"></a>
        順序付けられた要素セットを指定する技術用語。 これは抽象概念で、データベース理論の公式ディスカッションで使用されます。 データベースフィールドでのタプルは通常、テーブル行のカラムによって表されます。 これらはクエリー (テーブルの一部のカラムだけ、または結合されたテーブルからのカラムを取得したクエリー、など) の結果セットで表される場合もあります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_cursor">カーソル</a>も参照</p></dd><dt><a name="glos_dirty_page"></a><span class="glossterm">ダーティーページ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318764005488"></a>
        <code class="literal">InnoDB</code> <span class="bold"><strong>バッファプール</strong></span>内の <span class="bold"><strong>page</strong></span> は、メモリー内で更新され、<span class="bold"><strong>データファイル</strong></span>に変更がまだ書き込まれていません (<span class="bold"><strong>flushed</strong></span>)。 <span class="bold"><strong>クリーンページ</strong></span>の反対です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_clean_page">クリーンページ</a>, <a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>も参照</p></dd><dt><a name="glos_dirty_read"></a><span class="glossterm">ダーティー読み取り</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763996160"></a>
        信頼できないデータ、つまり別のトランザクションによって更新されたけれども、まだ<span class="bold"><strong>コミット</strong></span>されていないデータを取得する操作。 これは、<span class="bold"><strong>コミットされた読み取り</strong></span>と呼ばれる<span class="bold"><strong>分離レベル</strong></span>でのみ可能です。 
      </p><p>
        この種の操作は、データベース設計の <span class="bold"><strong>ACID</strong></span> 原則には準拠しません。 これは非常にリスクが高いと見なされます。データを<span class="bold"><strong>ロールバック</strong></span>できたり、コミットされる前にさらに更新できたりするためです。この場合、ダーティー読み取りを行うトランザクションは、正確であると確定されていないデータを使用することになります。 
      </p><p>
        その反対は<span class="bold"><strong>読取り一貫性</strong></span>であり、一方で他のトランザクションがコミットしても、<code class="literal">InnoDB</code> によって、別のトランザクションによって更新された情報が読み取られないことが保証されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_consistent_read">一貫性読み取り</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_read_uncommitted">READ UNCOMMITTED</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>も参照</p></dd><dt><a name="glos_wait"></a><span class="glossterm">待機</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763983552"></a>
        <span class="bold"><strong>lock</strong></span>、<span class="bold"><strong>mutex</strong></span> または <span class="bold"><strong>latch</strong></span> の取得などの操作をすぐに完了できない場合、<code class="literal">InnoDB</code> は一時停止して再試行します。 この一時停止のメカニズムはかなり入念に設計されているため、この操作には独自の名前、<span class="bold"><strong>待機</strong></span>が付けられています。 個々のスレッドは、内部 <code class="literal">InnoDB</code> スケジューリング、オペレーティングシステムの <code class="literal">wait()</code> コールおよび短期<span class="bold"><strong>スピン</strong></span>ループの組合せを使用して一時停止されます。 
      </p><p>
        負荷が高く、多くのトランザクションがあるシステムでは、<code class="literal">SHOW INNODB STATUS</code> コマンドまたは<span class="bold"><strong>パフォーマンススキーマ</strong></span>からの出力を使用して、スレッドが待機時間を過度に費やしているかどうか、および費やしている場合は<span class="bold"><strong>同時実行性</strong></span>を改善する方法を判断できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_latch">ラッチ</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_mutex">相互排他ロック</a>, <a class="glossseealso" href="glossary.html#glos_performance_schema">パフォーマンススキーマ</a>, <a class="glossseealso" href="glossary.html#glos_spin">スピン</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">チ</h3><dl><dt><a name="glos_checksum"></a><span class="glossterm">チェックサム</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763964640"></a>
        <code class="literal">InnoDB</code> で、<span class="bold"><strong>テーブルスペース</strong></span>内の <span class="bold"><strong>page</strong></span> がディスクから <code class="literal">InnoDB</code> <span class="bold"><strong>バッファプール</strong></span>に読み取られたときに破損を検出する検証メカニズム。 この機能は、MySQL 5.5 の <code class="literal">innodb_checksums</code> 構成オプションによって制御されます。<code class="literal">innodb_checksums</code> は、<code class="literal">innodb_checksum_algorithm</code> に置き換えられた MySQL 5.6.3 で非推奨になりました。 
      </p><p>
        <span class="command"><strong>innochecksum</strong></span> コマンドは、MySQL サーバーの停止中に指定された<span class="bold"><strong>テーブルスペース</strong></span>ファイルのチェックサム値をテストすることで、破損の問題の診断に役立ちます。
      </p><p>
        MySQL はレプリケーションのためにチェックサムも使用します。 詳細は、構成オプション <code class="literal">binlog_checksum</code>、<code class="literal">master_verify_checksum</code>、および <code class="literal">slave_sql_verify_checksum</code> を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd><dt><a name="glos_checkpoint"></a><span class="glossterm">チェックポイント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763948032"></a>
        <span class="bold"><strong>バッファープール</strong></span>にキャッシュされているデータページに変更が行われると、これらの変更は少しあとから<span class="bold"><strong>データファイル</strong></span>に書き込まれます。これは<span class="bold"><strong>フラッシュ</strong></span>と呼ばれるプロセスです。 チェックポイントは、データファイルに正しく書き込まれている (<span class="bold"><strong>LSN</strong></span> 値で表される) 最新の変更のレコードです。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_fuzzy_checkpointing">ファジーチェックポイント</a>, <a class="glossseealso" href="glossary.html#glos_lsn">LSN</a>も参照</p></dd><dt><a name="glos_medium_trust"></a><span class="glossterm">中規模の信頼</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763939840"></a>
        <span class="bold"><strong>部分信頼</strong></span>と同義です。 信頼設定の範囲は非常に広いため、<span class="quote">「<span class="quote">「部分信頼」</span>」</span>をお薦めします。これは、レベルが 3 つのみ (低、中および完全) であることを回避するためです。 
      </p><p><a class="glossseealso" href="glossary.html#glos_connector_net">Connector/NET</a>, <a class="glossseealso" href="glossary.html#glos_partial_trust">部分信頼</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">テ</h3><dl><dt><a name="glos_text_collection"></a><span class="glossterm">テキストコレクション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763712096"></a>
        <span class="bold"><strong>FULLTEXT インデックス</strong></span>に含まれるカラムセット。
      </p><p><a class="glossseealso" href="glossary.html#glos_fulltext_index">FULLTEXT インデックス</a>も参照</p></dd><dt><a name="glos_table"></a><span class="glossterm">テーブル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763832960"></a>
        各 MySQL テーブルは、特定の<span class="bold"><strong>ストレージエンジン</strong></span>に関連付けられます。 <span class="bold"><strong>InnoDB</strong></span> テーブルは、パフォーマンス、<span class="bold"><strong>スケーラビリティー</strong></span>、<span class="bold"><strong>バックアップ</strong></span>、管理、およびアプリケーション開発に影響する、特定の<span class="bold"><strong>物理</strong></span>および<span class="bold"><strong>論理</strong></span>特性を持っています。 
      </p><p>
        ファイル記憶域に関して、<code class="literal">InnoDB</code> テーブルは次のいずれかのテーブルスペースタイプに属します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            共有 <code class="literal">InnoDB</code> <span class="bold"><strong>システムテーブルスペース</strong></span>。1 つ以上の<span class="bold"><strong>ibdata ファイル</strong></span>で構成されます。
          </p></li><li class="listitem"><p>
            個々の<span class="bold"><strong>.ibd ファイル</strong></span>で構成される <span class="bold"><strong>file-per-table</strong></span> テーブルスペース。
          </p></li><li class="listitem"><p>
            個々の <code class="filename">.ibd</code> ファイルで構成される共有<span class="bold"><strong>一般テーブルスペース</strong></span>。 一般的なテーブルスペースは、MySQL 5.7.6 で導入されました。 
          </p></li></ul></div><p>
        <span class="bold"><strong><code class="literal">.ibd</code></strong></span> データファイルには、テーブルデータと <span class="bold"><strong>index</strong></span> データの両方が含まれます。
      </p><p>
        file-per-table テーブルスペースに作成された <code class="literal">InnoDB</code> テーブルでは、<span class="bold"><strong>DYNAMIC</strong></span> または <span class="bold"><strong>COMPRESSED</strong></span> の行形式を使用できます。 これらの行形式により、<span class="bold"><strong>compression</strong></span> などの <code class="literal">InnoDB</code> 機能、<span class="bold"><strong>オフページカラム</strong></span>の効率的な格納、大規模なインデックスキー接頭辞が可能になります。 一般テーブルスペースでは、すべての行形式がサポートされます。 
      </p><p>
        システムテーブルスペースは、<span class="bold"><strong>REDUNDANT</strong></span>、<span class="bold"><strong>COMPACT</strong></span> および <span class="bold"><strong>DYNAMIC</strong></span> の行形式を使用するテーブルをサポートしています。 <span class="bold"><strong>DYNAMIC</strong></span> 行形式のシステムテーブルスペースサポートが MySQL 5.7.6 で追加されました。 
      </p><p>
        <code class="literal">InnoDB</code> テーブルの <span class="bold"><strong>rows</strong></span> は、<span class="bold"><strong>クラスタインデックス</strong></span>と呼ばれるインデックス構造に編成され、テーブルの<span class="bold"><strong>主キー</strong></span>カラムに基づいてエントリがソートされます。 データアクセスは主キーカラムでフィルタおよびソートするクエリーに最適化され、各インデックスには各エントリに関連付けられた主キーカラムのコピーが含まれます。 主キーカラムの値を変更することは負荷の高い操作です。 したがって、<code class="literal">InnoDB</code> テーブル設計の重要な側面は、最も重要なクエリーで使用されるカラムを持つ主キーを選択し、値をほとんど変更せずに主キーを短く保つことです。 
      </p><p><a class="glossseealso" href="glossary.html#glos_backup">バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_clustered_index">クラスタ化されたインデックス</a>, <a class="glossseealso" href="glossary.html#glos_compact_row_format">コンパクト行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_compressed_row_format">圧縮行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_compression">圧縮</a>, <a class="glossseealso" href="glossary.html#glos_dynamic_row_format">動的行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_fast_index_creation">高速インデックス作成</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_off_page_column">オフページカラム</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>, <a class="glossseealso" href="glossary.html#glos_redundant_row_format">冗長行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_row">行</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd><dt><a name="glos_full_table_scan"></a><span class="glossterm">テーブルの完全スキャン</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763762608"></a>
        <span class="bold"><strong>index</strong></span> を使用して選択した部分のみでなく、テーブルの内容全体を読み取る必要がある操作。 通常は、小さなルックアップテーブル、またはすべての利用可能なデータが集約および分析される大きなテーブルを持つデータウェアハウジング状況で実行されます。 これらの操作が発生する頻度、および使用可能なメモリーに対するテーブルのサイズは、クエリーの最適化および<span class="bold"><strong>バッファプール</strong></span>の管理で使用されるアルゴリズムに影響します。 
      </p><p>
        インデックスの目的は、大きなテーブル内で特定の値または値の範囲をルックアップできるようにし、したがって有用なときはフルテーブルスキャンを回避することです。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>も参照</p></dd><dt><a name="glos_table_scan"></a><span class="glossterm">テーブルスキャン</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_full_table_scan">テーブルの完全スキャン</a>も参照</p></dd><dt><a name="glos_tablespace"></a><span class="glossterm">テーブルスペース</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763790256"></a>
        <code class="literal">InnoDB</code> <span class="bold"><strong>テーブル</strong></span>および関連する<span class="bold"><strong>インデックス</strong></span>のデータを保持できるデータファイル。
      </p><p>
        <span class="bold"><strong>システムテーブルスペース</strong></span>には <code class="literal">InnoDB</code> <span class="bold"><strong>データディクショナリ</strong></span>が含まれており、MySQL 5.6 より前は、デフォルトで他のすべての <code class="literal">InnoDB</code> テーブルが保持されます。
      </p><p>
        <code class="literal">innodb_file_per_table</code> オプションは、MySQL 5.6 以上でデフォルトで有効になっており、独自のテーブルスペースにテーブルを作成できます。 File-per-table テーブルスペースは、<span class="bold"><strong>オフページカラム</strong></span>、テーブル圧縮、トランスポータブルテーブルスペースの効率的なストレージなどの機能をサポートします。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-file-per-table-tablespaces" title="15.6.3.2 File-Per-Table テーブルスペース">セクション15.6.3.2「File-Per-Table テーブルスペース」</a> を参照してください。 
      </p><p>
        <code class="literal">InnoDB</code> では、MySQL 5.7.6 に一般テーブルスペースが導入されました。 一般テーブルスペースは、<code class="literal">CREATE TABLESPACE</code> 構文を使用して作成される共有テーブルスペースです。 これらは MySQL データディレクトリの外部で作成でき、複数のテーブルを保持でき、すべての行形式のテーブルをサポートします。 
      </p><p>
        また、MySQL NDB Cluster はそのテーブルをテーブルスペースにグループ化します。 詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data-objects" title="23.5.10.1 NDB Cluster ディスクデータオブジェクト">セクション23.5.10.1「NDB Cluster ディスクデータオブジェクト」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_compressed_row_format">圧縮行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_data_dictionary">データディクショナリ</a>, <a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_general_tablespace">一般テーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_innodb_file_per_table">innodb_file_per_table</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd><dt><a name="glos_table_type"></a><span class="glossterm">テーブルタイプ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763770112"></a>
        <span class="bold"><strong>ストレージエンジン</strong></span>の古いシノニムです。 <code class="literal">InnoDB</code> テーブル、<code class="literal">MyISAM</code> テーブルなどと呼びます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_storage_engine">ストレージエンジン</a>も参照</p></dd><dt><a name="glos_table_lock"></a><span class="glossterm">テーブルロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763756336"></a>
        ほかの<span class="bold"><strong>トランザクション</strong></span>がテーブルにアクセスすることを防ぐロック。 <code class="literal">InnoDB</code> では、<span class="bold"><strong>DML</strong></span> ステートメントおよび<span class="bold"><strong>クエリー</strong></span>の処理に<span class="bold"><strong>オンライン DDL</strong></span>、<span class="bold"><strong>行ロック</strong></span>、<span class="bold"><strong>読取り一貫性</strong></span>などの技術を使用することで、このようなロックを不要にするためにかなりの労力があります。 SQL から <code class="literal">LOCK TABLE</code> ステートメントを使用してこのようなロックを作成できます。ほかのデータベースシステムまたは MySQL ストレージエンジンから移行するステップの 1 つは、可能なときはこのようなステートメントを削除することです。 
      </p><p><a class="glossseealso" href="glossary.html#glos_consistent_read">一貫性読み取り</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_online_ddl">オンライン DDL</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>, <a class="glossseealso" href="glossary.html#glos_row_lock">行ロック</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_table_statistics"></a><span class="glossterm">テーブル統計</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_statistics">統計</a>も参照</p></dd><dt><a name="glos_dictionary_object_cache"></a><span class="glossterm">ディクショナリオブジェクトキャッシュ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763930112"></a>
        ディクショナリオブジェクトキャッシュは、以前にアクセスした<span class="bold"><strong>データディクショナリ</strong></span>オブジェクトをメモリーに格納して、オブジェクトの再利用を可能にし、ディスク I/O を最小化します。 <span class="bold"><strong>LRU</strong></span> ベースのエビクション戦略を使用して、メモリーから最近使用されていないオブジェクトを除去します。 キャッシュは、様々なオブジェクトタイプを格納する複数のパーティションで構成されます。 
      </p><p>
        詳細は、<a class="xref" href="data-dictionary.html#data-dictionary-object-cache" title="14.4 ディクショナリオブジェクトキャッシュ">セクション14.4「ディクショナリオブジェクトキャッシュ」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_data_dictionary">データディクショナリ</a>, <a class="glossseealso" href="glossary.html#glos_lru">LRU</a>も参照</p></dd><dt><a name="glos_disk_bound"></a><span class="glossterm">ディスクバウンド</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763923328"></a>
        主な<span class="bold"><strong>ボトルネック</strong></span>がディスク I/O であるタイプの<span class="bold"><strong>ワークロード</strong></span>。 (<span class="bold"><strong>I/O バウンド</strong></span>とも呼ばれます。) 通常は、ディスクへの頻繁な書き込みや、<span class="bold"><strong>バッファープール</strong></span>に収められるよりも多くのデータのランダム読み取りがかかわります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_bottleneck">ボトルネック</a>, <a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_workload">ワークロード</a>も参照</p></dd><dt><a name="glos_disk_based"></a><span class="glossterm">ディスクベース</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763916384"></a>
        主にディスクストレージ (ハードドライブまたはその同等物) 上のデータを編成するタイプのデータベース。 データは、ディスクとメモリー間でやり取りされて操作されます。 <span class="bold"><strong>インメモリーデータベース</strong></span>の反対です。 <code class="literal">InnoDB</code> はディスクベースですが、<span class="bold"><strong>バッファプール</strong></span>、複数のバッファープールインスタンス、および特定の種類のワークロードが主にメモリーから機能できる<span class="bold"><strong>適応型ハッシュインデックス</strong></span>などの機能も含まれています。 
      </p><p><a class="glossseealso" href="glossary.html#glos_adaptive_hash_index">適応型ハッシュインデックス</a>, <a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_in_memory_database">インメモリーデータベース</a>も参照</p></dd><dt><a name="glos_deadlock"></a><span class="glossterm">デッドロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763697120"></a>
        さまざまな<span class="bold"><strong>トランザクション</strong></span>が進行できない状況 (それぞれが、他方が必要とする<span class="bold"><strong>ロック</strong></span>を保持しているため)。 どちらのトランザクションもリソースが使用可能になるのを待機しているため、どちらも保持しているロックを解放しません。 
      </p><p>
        (<code class="literal">UPDATE</code> や <code class="literal">SELECT ... FOR UPDATE</code> などのステートメントを通じて) トランザクションが複数のテーブル内の行を反対の順にロックすると、デッドロックが発生することがあります。 デッドロックは、このようなステートメントがインデックスレコードと<span class="bold"><strong>ギャップ</strong></span>の範囲をロックし、各トランザクションが一部のロックを取得するけれども、タイミングの問題によりほかを取得しない場合にも発生することがあります。 
      </p><p>
        自動的にデッドロックを検出して処理する方法に関する背景情報については、<a class="xref" href="innodb-storage-engine.html#innodb-deadlock-detection" title="15.7.5.2 デッドロック検出">セクション15.7.5.2「デッドロック検出」</a>を参照してください。 デッドロック状況を回避しリカバリするためのヒントについては、<a class="xref" href="innodb-storage-engine.html#innodb-deadlocks-handling" title="15.7.5.3 デッドロックを最小化および処理する方法">セクション15.7.5.3「デッドロックを最小化および処理する方法」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_gap">ギャップ</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_victim"></a><span class="glossterm">デッドロック対象</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763677344"></a>
        <span class="bold"><strong>デッドロック</strong></span>が検出されたときに<span class="bold"><strong>ロールバック済</strong></span>として自動的に選択される<span class="bold"><strong>トランザクション</strong></span>。 <code class="literal">InnoDB</code> は、更新された行が最も少ないトランザクションをロールバックします。 
      </p><p>
        <span class="bold"><strong>デッドロック検出</strong></span>は、<code class="literal">innodb_deadlock_detect</code> 構成オプションを使用して無効にできます。
      </p><p><a class="glossseealso" href="glossary.html#glos_deadlock">デッドロック</a>, <a class="glossseealso" href="glossary.html#glos_deadlock_detection">デッドロック検出</a>, <a class="glossseealso" href="glossary.html#glos_innodb_lock_wait_timeout">innodb_lock_wait_timeout</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_deadlock_detection"></a><span class="glossterm">デッドロック検出</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763685936"></a>
        <span class="bold"><strong>デッドロック</strong></span>が起きていることを自動的に検出し、関係する<span class="bold"><strong>トランザクション</strong></span>のいずれか (<span class="bold"><strong>デッドロック対象</strong></span>) を自動的に<span class="bold"><strong>ロールバック</strong></span>するメカニズム。 デッドロック検出は、<code class="literal">innodb_deadlock_detect</code> 構成オプションを使用して無効にできます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_deadlock">デッドロック</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_victim">デッドロック対象</a>も参照</p></dd><dt><a name="glos_data_warehouse"></a><span class="glossterm">データウェアハウス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763900288"></a>
        主に大きな<span class="bold"><strong>クエリー</strong></span>を実行するデータベースシステムまたはアプリケーション。 読み取り専用または読み取りが大半のデータは、クエリーの効率を高めるために<span class="bold"><strong>非正規化された</strong></span>形式で編成できます。 MySQL 5.6 以降では、<span class="bold"><strong>読み取り専用トランザクション</strong></span>の最適化からメリットを得ることができます。 <span class="bold"><strong>OLTP</strong></span> と対比してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_denormalized">非正規化</a>, <a class="glossseealso" href="glossary.html#glos_oltp">OLTP</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>, <a class="glossseealso" href="glossary.html#glos_read_only_transaction">読み取り専用トランザクション</a>も参照</p></dd><dt><a name="glos_data_dictionary"></a><span class="glossterm">データディクショナリ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763889712"></a>
        <span class="bold"><strong>テーブル</strong></span>、<span class="bold"><strong>インデックス</strong></span>、テーブル <span class="bold"><strong>columns</strong></span> などのデータベースオブジェクトを追跡するメタデータ。 MySQL 8.0 で導入された MySQL データディクショナリの場合、メタデータは <code class="literal">mysql</code> データベースディレクトリの <code class="literal">InnoDB</code> <span class="bold"><strong>file-per-table</strong></span> テーブルスペースファイルに物理的に配置されます。 <code class="literal">InnoDB</code> データディクショナリの場合、メタデータは <code class="literal">InnoDB</code> <span class="bold"><strong>システムテーブルスペース</strong></span>に物理的に配置されます。 
      </p><p>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品では常に <code class="literal">InnoDB</code> システムテーブルスペースがバックアップされるため、すべてのバックアップに <code class="literal">InnoDB</code> データディクショナリの内容が含まれます。
      </p><p><a class="glossseealso" href="glossary.html#glos_column">カラム</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_frm_file">.frm ファイル</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd><dt><a name="glos_data_directory"></a><span class="glossterm">データディレクトリ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763873584"></a>
        各 MySQL <span class="bold"><strong>instance</strong></span> が <code class="literal">InnoDB</code> 用の<span class="bold"><strong>データファイル</strong></span>および個々のデータベースを表すディレクトリを保持するディレクトリ。 <code class="literal">datadir</code> 構成オプションによって制御されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_instance">インスタンス</a>も参照</p></dd><dt><a name="glos_data_files"></a><span class="glossterm">データファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763866848"></a>
        <span class="bold"><strong>table</strong></span> および <span class="bold"><strong>index</strong></span> データを物理的に格納するファイル。
      </p><p>
        <code class="literal">InnoDB</code> <span class="bold"><strong>データディクショナリ</strong></span>を保持し、複数の <code class="literal">InnoDB</code> テーブルのデータを保持できる <code class="literal">InnoDB</code> <span class="bold"><strong>システムテーブルスペース</strong></span>は、1 つ以上の <code class="filename">.ibdata</code> データファイルで表されます。
      </p><p>
        単一の <code class="literal">InnoDB</code> テーブルのデータを保持する File-per-table テーブルスペースは、<code class="filename">.ibd</code> データファイルで表されます。
      </p><p>
        複数の <code class="literal">InnoDB</code> テーブルのデータを保持できる一般的なテーブルスペース (MySQL 5.7.6 で導入) は、<code class="literal">.ibd</code> データファイルでも表されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_data_dictionary">データディクショナリ</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_general_tablespace">一般テーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_ibdata_file">ibdata ファイル</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd><dt><a name="glos_database"></a><span class="glossterm">データベース</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763849248"></a>
        MySQL <span class="bold"><strong>データディレクトリ</strong></span>内では、各データベースは個別のディレクトリで表されます。 MySQL <span class="bold"><strong>instance</strong></span> 内の複数のデータベースからのテーブルデータを保持できる InnoDB <span class="bold"><strong>システムテーブルスペース</strong></span>は、個々のデータベースディレクトリの外部にある<span class="bold"><strong>データファイル</strong></span>に保持されます。 <span class="bold"><strong>file-per-table</strong></span> モードが有効な場合、<code class="literal">DATA DIRECTORY</code> 句を使用して別の場所に作成されないかぎり、個々の InnoDB テーブルを表す<span class="bold"><strong>.ibd ファイル</strong></span>はデータベースディレクトリ内に格納されます。 MySQL 5.7.6 で導入された一般的なテーブルスペースには、<span class="bold"><strong>.ibd ファイル</strong></span>のテーブルデータも保持されます。 file-per-table <span class="bold"><strong>.ibd ファイル</strong></span>とは異なり、一般的なテーブルスペース<span class="bold"><strong>.ibd ファイル</strong></span>は、MySQL <span class="bold"><strong>instance</strong></span> 内の複数のデータベースからのテーブルデータを保持でき、MySQL データディレクトリに対して相対的または独立したディレクトリに割り当てることができます。 
      </p><p>
        長年 MySQL を使用している人にとって、データベースはなじみ深い概念です。 Oracle Database バックグラウンドからのユーザーは、データベースの MySQL の意味が、Oracle Database が <span class="bold"><strong>schema</strong></span> をコールする内容に近いことがわかります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_instance">インスタンス</a>, <a class="glossseealso" href="glossary.html#glos_schema">スキーマ</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>も参照</p></dd><dt><a name="glos_data_definition_language"></a><span class="glossterm">データ定義言語</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_ddl">DDL</a>も参照</p></dd><dt><a name="glos_data_manipulation_language"></a><span class="glossterm">データ操作言語</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_dml">DML</a>も参照</p></dd><dt><a name="glos_low_water_mark"></a><span class="glossterm">低位境界値</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763934288"></a>
        下限を表す値。通常は、何らかの訂正アクションが始まったり、より積極的になったりするしきい値です。 <span class="bold"><strong>高位境界値</strong></span>と対比してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_high_water_mark">高位境界値</a>も参照</p></dd><dt><a name="glos_slow_shutdown"></a><span class="glossterm">低速シャットダウン</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763908800"></a>
        完了前に追加の <code class="literal">InnoDB</code> フラッシュ操作を実行する <span class="bold"><strong>shutdown</strong></span> のタイプ。 <span class="bold"><strong>クリーンシャットダウン</strong></span>とも呼ばれます。 構成パラメータ <code class="literal">innodb_fast_shutdown=0</code> またはコマンド <code class="literal">SET GLOBAL innodb_fast_shutdown=0;</code> で指定されます。 シャットダウン自体には時間がかかる場合がありますが、その後の起動時にその時間を節約する必要があります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_clean_shutdown">クリーンシャットダウン</a>, <a class="glossseealso" href="glossary.html#glos_fast_shutdown">高速シャットダウン</a>, <a class="glossseealso" href="glossary.html#glos_shutdown">シャットダウン</a>も参照</p></dd><dt><a name="glos_inverted_index"></a><span class="glossterm">転置インデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763667472"></a>
        <code class="literal">InnoDB</code> <span class="bold"><strong>全文検索</strong></span>の実装で使用される、ドキュメント取得システム用に最適化されたデータ構造。 逆インデックスとして実装された <code class="literal">InnoDB</code> <span class="bold"><strong>FULLTEXT インデックス</strong></span>は、テーブルの行の場所ではなく、ドキュメント内の各ワードの位置を記録します。 単一カラム値 (テキスト文字列として格納されたドキュメント) は多くのエントリで転置インデックスで表現されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_full_text_search">全文検索</a>, <a class="glossseealso" href="glossary.html#glos_fulltext_index">FULLTEXT インデックス</a>, <a class="glossseealso" href="glossary.html#glos_ilist">ilist</a>も参照</p></dd><dt><a name="glos_adaptive_hash_index"></a><span class="glossterm">適応型ハッシュインデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763742784"></a>
        メモリー内に<span class="bold"><strong>ハッシュインデックス</strong></span>を構築することで、<code class="literal">=</code> および <code class="literal">IN</code> 演算子を使用して検索を高速化できる <code class="literal">InnoDB</code> テーブルの最適化。 MySQL は、<code class="literal">InnoDB</code> テーブルのインデックス検索を監視し、クエリーがハッシュインデックスのメリットを得られる場合は、頻繁にアクセスされるインデックス <span class="bold"><strong>pages</strong></span> のインデックス検索を自動的に作成します。 ある意味では、適応型ハッシュインデックスは、十分なメインメモリーを利用するように MySQL を実行時に構成するので、メインメモリーデータベースのアーキテクチャーに近づいています。 この機能は、<code class="literal">innodb_adaptive_hash_index</code> 構成オプションで制御されます。 この機能は、一部のワークロードにはメリットがあってもほかのものにはメリットがなく、ハッシュインデックスに使用されるメモリーは<span class="bold"><strong>バッファープール</strong></span>で予約されているので、通常はこの機能を有効にした状態と無効にした状態でベンチマークを行うことをお勧めします。 
      </p><p>
        常に、ハッシュインデックスはテーブル上の既存の <span class="bold"><strong>B ツリー</strong></span>インデックスに基づいて構築されます。 MySQL は、インデックスに対する検索パターンに応じて、B ツリーに定義された任意の長さのキーのプリフィクスに、ハッシュインデックスを構築できます。 ハッシュインデックスは部分的であってもかまいません。B ツリーインデックス全体をバッファープールにキャッシュする必要はありません。 
      </p><p>
        MySQL 5.6 以上では、<code class="literal">InnoDB</code> テーブルで高速単一値参照を利用する別の方法は、<code class="literal">InnoDB</code> <span class="bold"><strong>memcached</strong></span> プラグインを使用することです。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached" title="15.20 InnoDB memcached プラグイン">セクション15.20「InnoDB memcached プラグイン」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_b_tree">B ツリー</a>, <a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_hash_index">ハッシュインデックス</a>, <a class="glossseealso" href="glossary.html#glos_memcached">memcached</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_secondary_index">セカンダリインデックス</a>も参照</p></dd><dt><a name="glos_adaptive_flushing"></a><span class="glossterm">適応型フラッシュ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763723872"></a>
        <span class="bold"><strong>チェックポイント</strong></span>によって生じる I/O オーバーヘッドを軽減する <span class="bold"><strong>InnoDB</strong></span> テーブル用のアルゴリズム。 MySQL は、変更されたすべての<span class="bold"><strong>ページ</strong></span>を<span class="bold"><strong>バッファープール</strong></span>から<span class="bold"><strong>データファイル</strong></span>に一度に<span class="bold"><strong>フラッシュ</strong></span>するのではなく、変更されたページの小さなセットを定期的にフラッシュします。 適応型フラッシュアルゴリズムは、フラッシュの頻度と <span class="bold"><strong>Redo</strong></span> 情報の生成速度に基づいてこれらの定期フラッシュの最適な実行頻度を見積もることによって、このプロセスを拡張します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_checkpoint">チェックポイント</a>, <a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>も参照</p></dd><dt><a name="glos_apply"></a><span class="glossterm">適用</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763708544"></a>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品で生成されたバックアップに、バックアップ進行中に行われた最新の変更が含まれない場合、これらの変更を含むようにバックアップファイルを更新するプロセスは<span class="bold"><strong>適用</strong></span>ステップと呼ばれます。 これは <code class="literal">mysqlbackup</code> コマンドの <code class="literal">apply-log</code> オプションで指定されます。 
      </p><p>
        変更が適用されるまでは、このファイルは <span class="bold"><strong>raw バックアップ</strong></span>と呼ばれます。 変更が適用されたあとは、このファイルは<span class="bold"><strong>準備されたバックアップ</strong></span>と呼ばれます。 変更は、<span class="bold"><strong>ibbackup_logfile</strong></span> ファイルに記録されます。適用ステップが終了すると、このファイルは不要になります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_ibbackup_logfile">ibbackup_logfile</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_prepared_backup">準備されたバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_raw_backup">raw バックアップ</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ト</h3><dl><dt><a name="glos_truststore"></a><span class="glossterm">トラストストア</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763591552"></a></p><p><a class="glossseealso" href="glossary.html#glos_ssl">SSL</a>も参照</p></dd><dt><a name="glos_troubleshooting"></a><span class="glossterm">トラブルシューティング</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763589024"></a>
        問題の原因を特定するプロセス。 MySQL の問題をトラブルシューティングするためのリソースには、次のものがあります: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="xref" href="installing.html#starting-server-troubleshooting" title="2.10.2.1 MySQL Server の起動時の問題のトラブルシューティング">セクション2.10.2.1「MySQL Server の起動時の問題のトラブルシューティング」</a>
          </p></li><li class="listitem"><p>
            <a class="xref" href="security.html#problems-connecting" title="6.2.21 MySQL への接続の問題のトラブルシューティング">セクション6.2.21「MySQL への接続の問題のトラブルシューティング」</a>
          </p></li><li class="listitem"><p>
            <a class="xref" href="error-handling.html#resetting-permissions" title="B.3.3.2 root のパスワードをリセットする方法">セクションB.3.3.2「root のパスワードをリセットする方法」</a>
          </p></li><li class="listitem"><p>
            <a class="xref" href="error-handling.html#common-errors" title="B.3.2 MySQL プログラム使用時の一般的なエラー">セクションB.3.2「MySQL プログラム使用時の一般的なエラー」</a>
          </p></li><li class="listitem"><p>
            <a class="xref" href="innodb-storage-engine.html#innodb-troubleshooting" title="15.21 InnoDB のトラブルシューティング">セクション15.21「InnoDB のトラブルシューティング」</a>。
          </p></li></ul></div></dd><dt><a name="glos_transaction"></a><span class="glossterm">トランザクション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763578800"></a>
        トランザクションは、<span class="bold"><strong>committed</strong></span> または<span class="bold"><strong>ロールバック済</strong></span>の作業の原子単位です。 トランザクションによってデータベースに複数の変更が行われた場合、トランザクションがコミットされるとすべての変更が完了し、トランザクションがロールバックされるとすべての変更が元に戻されます。 
      </p><p>
        <code class="literal">InnoDB</code> によって実装されるデータベーストランザクションには、アトミック性、一貫性、分離性および永続性のために頭字語 <span class="bold"><strong>ACID</strong></span> によってまとめて知られるプロパティがあります。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>も参照</p></dd><dt><a name="glos_transaction_id"></a><span class="glossterm">トランザクション ID</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763569424"></a>
        各 <span class="bold"><strong>row</strong></span> に関連付けられた内部フィールド。 このフィールドは、行をロックした<span class="bold"><strong>トランザクション</strong></span>を記録するために、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code> および <code class="literal">DELETE</code> 操作によって物理的に変更されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_implicit_row_lock">暗黙の行ロック</a>, <a class="glossseealso" href="glossary.html#glos_row">行</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_transportable_tablespace"></a><span class="glossterm">トランスポータブルテーブルスペース</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763560544"></a>
        <span class="bold"><strong>テーブルスペース</strong></span>があるインスタンスから別のインスタンスに移動されることを許可する機能。 従来、すべてのテーブルデータが<span class="bold"><strong>システムテーブルスペース</strong></span>の一部であったため、これは <code class="literal">InnoDB</code> テーブルスペースでは不可能でした。 MySQL 5.6 以上では、<code class="literal">FLUSH TABLES ... FOR EXPORT</code> 構文は <code class="literal">InnoDB</code> テーブルを別のサーバーにコピーする準備をします。他のサーバーで <code class="literal">ALTER TABLE ... DISCARD TABLESPACE</code> および <code class="literal">ALTER TABLE ... IMPORT TABLESPACE</code> を実行すると、コピーされたデータファイルが他のインスタンスに取り込まれます。 <span class="bold"><strong>.ibd ファイル</strong></span>とともにコピーされた個別の<span class="bold"><strong>.cfg ファイル</strong></span>を使用して、テーブルスペースのインポート時にテーブルメタデータ (<span class="bold"><strong>スペース ID</strong></span>など) が更新されます。 使用に関する情報は <a class="xref" href="innodb-storage-engine.html#innodb-table-import" title="15.6.1.3 InnoDB テーブルのインポート">セクション15.6.1.3「InnoDB テーブルのインポート」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_cfg_file">.cfg ファイル</a>, <a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_space_id">スペース ID</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd><dt><a name="glos_document_id"></a><span class="glossterm">ドキュメント ID</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763602784"></a>
        <code class="literal">InnoDB</code> <span class="bold"><strong>全文検索</strong></span>機能において、各 <span class="bold"><strong>ilist</strong></span> 値に関連付けられたドキュメントを一意に識別するための、<span class="bold"><strong>FULLTEXT インデックス</strong></span>を含むテーブルの特別なカラム。 その名前は <code class="literal">FTS_DOC_ID</code> (大文字必須) です。 カラム自体は、<code class="literal">BIGINT UNSIGNED NOT NULL</code> 型で、<code class="literal">FTS_DOC_ID_INDEX</code> という名前の一意インデックス付きである必要があります。 テーブルの作成時にこのカラムを定義することが推奨されます。 <code class="literal">FULLTEXT</code> インデックスの作成時に <code class="literal">InnoDB</code> でテーブルにカラムを追加する必要がある場合、インデックス付け操作のコストはかなり高くなります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_full_text_search">全文検索</a>, <a class="glossseealso" href="glossary.html#glos_fulltext_index">FULLTEXT インデックス</a>, <a class="glossseealso" href="glossary.html#glos_ilist">ilist</a>も参照</p></dd><dt><a name="glos_drop"></a><span class="glossterm">ドロップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763545184"></a>
        <span class="bold"><strong>DDL</strong></span> 操作の一種。<code class="literal">DROP TABLE</code> や <code class="literal">DROP INDEX</code> などのステートメントを通じてスキーマオブジェクトを削除します。 これは内部的に <code class="literal">ALTER TABLE</code> ステートメントにマッピングします。 <code class="literal">InnoDB</code> の観点からは、このような操作のパフォーマンス上の考慮事項には、相互に関連するオブジェクトがすべて更新されるように<span class="bold"><strong>データディクショナリ</strong></span>がロックされている時間、および<span class="bold"><strong>バッファプール</strong></span>などのメモリー構造を更新する時間が含まれます。 <span class="bold"><strong>テーブル</strong></span>の場合、ドロップ操作には、<span class="bold"><strong>切り捨て</strong></span>操作 (<code class="literal">TRUNCATE TABLE</code> ステートメント) と多少異なる特性があります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_data_dictionary">データディクショナリ</a>, <a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>, <a class="glossseealso" href="glossary.html#glos_truncate">切り捨て</a>も参照</p></dd><dt><a name="glos_dynamic_sql"></a><span class="glossterm">動的 SQL</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763628208"></a>
        ステートメントの各部分を文字列変数に連結するナイブテクニックよりも強力でセキュアで効率的な方法を使用して<span class="bold"><strong>プリペアドステートメント</strong></span>を作成および実行できる機能。
      </p><p><a class="glossseealso" href="glossary.html#glos_prepared_statement">プリペアドステートメント</a>も参照</p></dd><dt><a name="glos_dynamic_cursor"></a><span class="glossterm">動的カーソル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763624208"></a>
        <span class="bold"><strong>ODBC</strong></span> でサポートされている <span class="bold"><strong>cursor</strong></span> のタイプで、行が再度読み取られたときに新しい結果および変更された結果を取得できます。 カーソルに変更が表示されるかどうかとその速度は、関連するテーブルのタイプ (トランザクションまたは非トランザクション) およびトランザクションテーブルの分離レベルによって異なります。 動的カーソルのサポートは明示的に有効にする必要があります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_cursor">カーソル</a>, <a class="glossseealso" href="glossary.html#glos_odbc">ODBC</a>も参照</p></dd><dt><a name="glos_dynamic_statement"></a><span class="glossterm">動的ステートメント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763607664"></a>
        <span class="bold"><strong>動的 SQL</strong></span>を介して作成および実行される<span class="bold"><strong>プリペアドステートメント</strong></span>。
      </p><p><a class="glossseealso" href="glossary.html#glos_dynamic_sql">動的 SQL</a>, <a class="glossseealso" href="glossary.html#glos_prepared_statement">プリペアドステートメント</a>も参照</p></dd><dt><a name="glos_dynamic_row_format"></a><span class="glossterm">動的行フォーマット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763618784"></a>
        <code class="literal">InnoDB</code> の行フォーマット。 長い可変長のカラム値は、行データを保持するページの外部に格納されるため、ラージオブジェクトを含む行では非常に効率的です。 ラージフィールドは通常、クエリー条件を評価するためにアクセスされることはないので、頻繁には<span class="bold"><strong>バッファープール</strong></span>に読み込まれません。その結果、I/O 操作は少なくなり、キャッシュメモリーの利用率が改善します。 
      </p><p>
        MySQL 5.7.9 では、デフォルトの行フォーマットは、<code class="literal">DYNAMIC</code> のデフォルト値を持つ <code class="literal">innodb_default_row_format</code> によって定義されます。
      </p><p>
        <code class="literal">InnoDB</code> <code class="literal">DYNAMIC</code> 行フォーマットの追加情報については、<a class="xref" href="innodb-storage-engine.html#innodb-row-format-dynamic" title="DYNAMIC 行フォーマット">DYNAMIC 行フォーマット</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_file_format">ファイル形式</a>, <a class="glossseealso" href="glossary.html#glos_row_format">行フォーマット</a>も参照</p></dd><dt><a name="glos_statistics"></a><span class="glossterm">統計</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763650320"></a>
        各 <code class="literal">InnoDB</code> <span class="bold"><strong>テーブル</strong></span>および<span class="bold"><strong>インデックス</strong></span>に関連する評価値。効率的な<span class="bold"><strong>クエリー実行計画</strong></span>の構築に使用されます。 メイン値は、<span class="bold"><strong>カーディナリティー</strong></span> (個別値の数) と、テーブル行またはインデックスエントリの合計数です。 テーブルの統計は、その<span class="bold"><strong>主キー</strong></span>インデックス内のデータを表します。 <span class="bold"><strong>セカンダリインデックス</strong></span>の統計は、このインデックスで扱われる行を表します。 
      </p><p>
        値は正確なカウントではなく、見積もりです。あらゆる瞬間にさまざまな<span class="bold"><strong>トランザクション</strong></span>が同じテーブルからの行を挿入したり削除したりしている可能性があるためです。 値が頻繁に再計算されないように、<span class="bold"><strong>永続的統計</strong></span>を有効にできます。この場合、値は <code class="literal">InnoDB</code> システムテーブルに格納され、<code class="literal">ANALYZE TABLE</code> ステートメントを発行するときにのみ更新されます。 
      </p><p>
        <code class="literal">innodb_stats_method</code> 構成オプションで統計を計算するときに、<span class="bold"><strong>NULL</strong></span> 値がどのように扱われるかを制御できます。
      </p><p>
        <span class="bold"><strong>INFORMATION_SCHEMA</strong></span> および <span class="bold"><strong>PERFORMANCE_SCHEMA</strong></span> テーブルを通じて、ほかのタイプの統計をデータベースオブジェクトおよびデータベースアクティビティーに利用できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_cardinality">カーディナリティー</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_information_schema">INFORMATION_SCHEMA</a>, <a class="glossseealso" href="glossary.html#glos_null">NULL</a>, <a class="glossseealso" href="glossary.html#glos_performance_schema">パフォーマンススキーマ</a>, <a class="glossseealso" href="glossary.html#glos_persistent_statistics">永続的統計</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>, <a class="glossseealso" href="glossary.html#glos_query_execution_plan">クエリー実行計画</a>, <a class="glossseealso" href="glossary.html#glos_secondary_index">セカンダリインデックス</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_transparent_page_compression"></a><span class="glossterm">透過的ページ圧縮</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763659568"></a>
        <span class="bold"><strong>file-per-table</strong></span> テーブルスペースに存在する <code class="literal">InnoDB</code> テーブルのページレベルの圧縮を可能にする MySQL 5.7.8 で追加された機能。 ページ圧縮を有効にするには、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> で <code class="literal">COMPRESSION</code> 属性を指定します。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-page-compression" title="15.9.2 InnoDB ページ圧縮">セクション15.9.2「InnoDB ページ圧縮」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_hole_punching">ホールパンチング</a>, <a class="glossseealso" href="glossary.html#glos_sparse_file">スパースファイル</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ナ</h3><dl><dt><a name="glos_natural_key"></a><span class="glossterm">ナチュラルキー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763530480"></a>
        インデックス付けされたカラム (通常は<span class="bold"><strong>主キー</strong></span>)。値には実際の意味があります。 通常は、次の理由のため推奨されていません。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            値が万が一変化した場合、<span class="bold"><strong>クラスタ化されたインデックス</strong></span>を再ソートし、それぞれの<span class="bold"><strong>セカンダリインデックス</strong></span>で繰り返される主キー値のコピーを更新するために、多数インデックス保守が必要になる可能性があります。
          </p></li><li class="listitem"><p>
            一見したところ安定した値でも、データベースで正しく表すことが難しい予測不可能な変化をすることがあります。 たとえば、1 つの国が 2 つ以上に分かれ、元の国コードが古くなることがあります。 または、一意値に関するルールに例外が発生する場合があります。 たとえば、納税者 ID が単一の人物に一意であるように意図されている場合でも、データベースでは、ID 窃盗などでそのルールに違反するレコードを処理する必要があることがあります。 また、納税者 ID やその他の機密 ID 番号からは、低品質の主キーが作成されます。それらはセキュリティー保護し、暗号化し、またはほかのカラムと異なる方法で扱う必要がある場合があるためです。 
          </p></li></ul></div><p>
        したがって通常は、<span class="bold"><strong>自動インクリメント</strong></span>カラムを使用するなど、任意の数値を使用して<span class="bold"><strong>合成キー</strong></span>を作成することをお勧めします。
      </p><p><a class="glossseealso" href="glossary.html#glos_auto_increment">自動インクリメント</a>, <a class="glossseealso" href="glossary.html#glos_clustered_index">クラスタ化されたインデックス</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>, <a class="glossseealso" href="glossary.html#glos_secondary_index">セカンダリインデックス</a>, <a class="glossseealso" href="glossary.html#glos_synthetic_key">合成キー</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ニ</h3><dl><dt><a name="glos_doublewrite_buffer"></a><span class="glossterm">二重書き込みバッファー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763516240"></a>
        <code class="literal">InnoDB</code> では、二重書込みと呼ばれるファイルフラッシュ手法を使用します。 <span class="bold"><strong>pages</strong></span> を<span class="bold"><strong>データファイル</strong></span>に書き込む前に、<code class="literal">InnoDB</code> はまず二重書込みバッファと呼ばれる記憶域に書き込みます。 二重書込みバッファへの書込みおよびフラッシュが完了した後にのみ、<code class="literal">InnoDB</code> はデータファイル内の適切な位置にページを書き込みます。 ページ書込みの途中でオペレーティングシステム、ストレージサブシステムまたは <span class="command"><strong>mysqld</strong></span> プロセスがクラッシュした場合、<code class="literal">InnoDB</code> は後で<span class="bold"><strong>クラッシュリカバリ</strong></span>中に二重書込みバッファからページの適切なコピーを見つけることができます。 
      </p><p>
        データは常に 2 度書き込まれますが、二重書き込みバッファーには、2 倍の I/O オーバーヘッドも 2 倍の I/O 操作も不要です。 データは、オペレーティングシステムへの単一 <code class="literal">fsync()</code> 呼び出しで、大きなシーケンシャルチャンクとしてバッファー自体に書き込まれます。 
      </p><p>
        二重書き込みバッファーをオフにするには、オプション <code class="literal">innodb_doublewrite=0</code> を指定します。
      </p><p><a class="glossseealso" href="glossary.html#glos_crash_recovery">クラッシュリカバリ</a>, <a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_purge">パージ</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ネ</h3><dl><dt><a name="glos_native_c_api"></a><span class="glossterm">ネイティブ C API</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763500944"></a>
        <span class="bold"><strong>libmysqlclient</strong></span> と同義です。
      </p><p><a class="glossseealso" href="glossary.html#glos_libmysql">libmysql</a>も参照</p></dd><dt><a name="glos_next_key_lock"></a><span class="glossterm">ネクストキーロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763497376"></a>
        インデックスレコードでの<span class="bold"><strong>レコードロック</strong></span>と、インデックスレコードの前のギャップでの<a class="link" href="glossary.html#glos_gap_lock" title="ギャップロック">ギャップロック</a>の組み合わせ。
      </p><p><a class="glossseealso" href="glossary.html#glos_gap_lock">ギャップロック</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_record_lock">レコードロック</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ハ</h3><dl><dt><a name="glos_hash_index"></a><span class="glossterm">ハッシュインデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763404400"></a>
        大なりや <code class="literal">BETWEEN</code> などの範囲演算子ではなく、等値演算子を使用するクエリーを対象とするタイプの<span class="bold"><strong>インデックス</strong></span>。 これは、<code class="literal">MEMORY</code> テーブルで使用できます。 履歴上の理由から、ハッシュインデックスは <code class="literal">MEMORY</code> テーブルのデフォルトですが、そのストレージエンジンは <span class="bold"><strong>B-tree</strong></span> インデックスもサポートしています。これは、一般的な目的のクエリーに適していることがよくあります。 
      </p><p>
        MySQL には、ランタイム条件に基づいて必要に応じて <code class="literal">InnoDB</code> テーブル用に自動的に作成される、このインデックスタイプのバリアント (<span class="bold"><strong>適応型ハッシュインデックス</strong></span>) が含まれています。
      </p><p><a class="glossseealso" href="glossary.html#glos_adaptive_hash_index">適応型ハッシュインデックス</a>, <a class="glossseealso" href="glossary.html#glos_b_tree">B ツリー</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>も参照</p></dd><dt><a name="glos_heartbeat"></a><span class="glossterm">ハートビート</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763458880"></a>
        システムが適切に機能していることを示すために送信される定期的メッセージ。 <span class="bold"><strong>レプリケーション</strong></span>コンテキストでは、<span class="bold"><strong>source</strong></span> がこのようなメッセージの送信を停止すると、<span class="bold"><strong>レプリカ</strong></span>のいずれかが発生します。 クラスタ環境内のすべてのサーバーが正しく動作していることを確認するために、それらの間で類似の方法を使用できます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_replication">レプリケーション</a>, <a class="glossseealso" href="glossary.html#glos_source">source</a>も参照</p></dd><dt><a name="glos_binary_log"></a><span class="glossterm">バイナリログ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763441408"></a>
        テーブルデータを変更しようとするすべてのステートメントまたは行の変更のレコードを含むファイル。 バイナリログの内容をリプレイして、<span class="bold"><strong>レプリケーション</strong></span>シナリオでレプリカを最新の状態にしたり、バックアップからテーブルデータを復元したあとでデータベースを最新の状態にしたりできます。 バイナリロギング機能は、オンとオフを切り替えられますが、レプリケーションを使用したりバックアップを実行したりする場合は、常に有効にしておくことをお勧めします。 
      </p><p>
        <span class="command"><strong>mysqlbinlog</strong></span> コマンドを使用すると、バイナリログの内容を検査したり、レプリケーションまたは回復中にそれを再生したりできます。 バイナリログの詳細は、<a class="xref" href="server-administration.html#binary-log" title="5.4.4 バイナリログ">セクション5.4.4「バイナリログ」</a>を参照してください。 バイナリログに関連した MySQL 構成オプションについては、<a class="xref" href="replication.html#replication-options-binary-log" title="17.1.6.4 バイナリロギングのオプションと変数">セクション17.1.6.4「バイナリロギングのオプションと変数」</a>を参照してください。 
      </p><p>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品の場合、バイナリログのファイル名とファイル内での現在の位置が重要な詳細です。 レプリケーションコンテキストでバックアップを作成するときにソースのこの情報を記録するには、<code class="literal">--slave-info</code> オプションを指定できます。 
      </p><p>
        MySQL 5.0 より前では、更新ログと呼ばれる同様の機能を利用できました。 MySQL 5.0 以上では、更新ログがバイナリログに置き換わりました。 
      </p><p><a class="glossseealso" href="glossary.html#glos_binlog">binlog</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_replication">レプリケーション</a>も参照</p></dd><dt><a name="glos_bounce"></a><span class="glossterm">バウンス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763429216"></a>
        直後に再起動が行われる<span class="bold"><strong>シャットダウン</strong></span>操作。 パフォーマンスとスループットが迅速に高いレベルに戻るように、<span class="bold"><strong>ウォームアップ</strong></span>期間が比較的短ければ理想的です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_shutdown">シャットダウン</a>も参照</p></dd><dt><a name="glos_backup"></a><span class="glossterm">バックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763418544"></a>
        保護するために、MySQL インスタンスから一部またはすべてのテーブルデータおよびメタデータをコピーするプロセス。 コピーされたファイルのセットを指す場合もあります。 これは DBA のきわめて重要なタスクです。 このプロセスの反対が<span class="bold"><strong>リストア</strong></span>操作です。 
      </p><p>
        MySQL では、<span class="bold"><strong>物理バックアップ</strong></span>は <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品で実行され、<span class="bold"><strong>論理バックアップ</strong></span>は <code class="literal">mysqldump</code> コマンドで実行されます。 これらの方法は、バックアップデータのサイズおよび表現と速度 (特にリストア操作の速度) の点で特性が異なります。 
      </p><p>
        バックアップはさらに、通常のデータベース操作に干渉する程度に応じて、<span class="bold"><strong>ホット</strong></span>、<span class="bold"><strong>ウォーム</strong></span>、<span class="bold"><strong>コールド</strong></span>に分類されます。 (干渉の程度は、ホットバックアップがもっとも少なく、コールドバックアップがもっとも多くなります。) 
      </p><p><a class="glossseealso" href="glossary.html#glos_cold_backup">コールドバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_logical_backup">論理バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_mysqldump">mysqldump</a>, <a class="glossseealso" href="glossary.html#glos_physical_backup">物理バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_warm_backup">ウォームバックアップ</a>も参照</p></dd><dt><a name="glos_buffer"></a><span class="glossterm">バッファー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763392528"></a>
        一時ストレージに使用されるメモリーまたはディスク領域。 多数の小さな I/O 操作ではなく少数の大きなものでディスクに効率的に書き込めるように、データはメモリーにバッファリングされます。 データは、信頼性を高めるためにディスクにバッファリングされるので、考えられる最悪の場合に<span class="bold"><strong>クラッシュ</strong></span>やほかの障害が発生してもリカバリできます。 InnoDB で使用される主なバッファタイプは、<span class="bold"><strong>バッファプール</strong></span>、<span class="bold"><strong>二重書込みバッファ</strong></span>および<span class="bold"><strong>変更バッファ</strong></span>です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_change_buffer">変更バッファー</a>, <a class="glossseealso" href="glossary.html#glos_crash">クラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_doublewrite_buffer">二重書き込みバッファー</a>も参照</p></dd><dt><a name="glos_buffer_pool"></a><span class="glossterm">バッファープール</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763384464"></a>
        テーブルとインデックスの両方のキャッシュされた <code class="literal">InnoDB</code> データを保持するメモリー領域。 大容量読み取り操作の効率を高めるため、バッファープールは複数行を保持できる<span class="bold"><strong>ページ</strong></span>に分割されます。 キャッシュ管理の効率のために、バッファープールはページのリンクリストとして実装されます。まれにしか使用されないデータは、<span class="bold"><strong>LRU</strong></span> アルゴリズムのバリエーションを使用してキャッシュからエージアウトされます。 大容量メモリーを備えたシステムでは、バッファープールを複数の<span class="bold"><strong>バッファープールインスタンス</strong></span>に分割することにより、並列性を改善できます。 
      </p><p>
        いくつかの <code class="literal">InnoDB</code> ステータス変数、<code class="literal">INFORMATION_SCHEMA</code> テーブルおよび <code class="literal">performance_schema</code> テーブルは、バッファプールの内部動作の監視に役立ちます。 MySQL 5.6 以降では、サーバーの停止時にバッファプールの状態を保存し、サーバーの起動時にバッファプールを同じ状態にリストアすることで、サーバーの再起動後、特に大規模なバッファプールを持つインスタンスで長いウォームアップ期間を回避できます。 <a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="15.8.3.6 バッファープールの状態の保存と復元">セクション15.8.3.6「バッファープールの状態の保存と復元」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool_instance">バッファープールインスタンス</a>, <a class="glossseealso" href="glossary.html#glos_lru">LRU</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_warm_up">ウォームアップ</a>も参照</p></dd><dt><a name="glos_buffer_pool_instance"></a><span class="glossterm">バッファープールインスタンス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763371936"></a>
        <span class="bold"><strong>バッファープール</strong></span>は複数の領域に分割できますが、そのいずれか。<code class="literal">innodb_buffer_pool_instances</code> 構成オプションで制御されます。 <code class="literal">innodb_buffer_pool_size</code> で指定された合計メモリーサイズは、すべてのバッファプールインスタンスに分割されます。 通常、複数のバッファープールインスタンスを持つことは、<code class="literal">InnoDB</code> バッファープールに複数の G バイトを割り当てるシステムに適しています。各インスタンスは 1 G バイト以上です。 多数の同時セッションからバッファプール内の大量のデータをロードまたは検索するシステムでは、複数のバッファプールインスタンスを使用すると、バッファプールを管理するデータ構造への排他的アクセスの競合が軽減されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>も参照</p></dd><dt><a name="glos_buddy_allocator"></a><span class="glossterm">バディーアロケータ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763364496"></a>
        InnoDB <span class="bold"><strong>バッファープール</strong></span>でさまざまなサイズの<span class="bold"><strong>ページ</strong></span>を管理するためのメカニズム。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_page_size">page size</a>も参照</p></dd><dt><a name="glos_performance_schema"></a><span class="glossterm">パフォーマンススキーマ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763359120"></a>
        <code class="literal">performance_schema</code> スキーマは (MySQL 5.5 以降)、MySQL Server の多くの内部パーツのパフォーマンス特性に関する詳細情報を取得するために照会できる、テーブルセットを提供します。 <a class="xref" href="performance-schema.html" title="第 27 章 MySQL パフォーマンススキーマ">第27章「<i>MySQL パフォーマンススキーマ</i>」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_information_schema">INFORMATION_SCHEMA</a>, <a class="glossseealso" href="glossary.html#glos_latch">ラッチ</a>, <a class="glossseealso" href="glossary.html#glos_mutex">相互排他ロック</a>, <a class="glossseealso" href="glossary.html#glos_rw_lock">rw ロック (読み書きロック)</a>も参照</p></dd><dt><a name="glos_purge"></a><span class="glossterm">パージ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763491120"></a>
        (<code class="literal">innodb_purge_threads</code> によって制御される) 個別のバックグラウンドスレッドによって実行されるガベージコレクションのタイプで、定期的に実行されます。 パージでは、<span class="bold"><strong>undo ログ</strong></span>ページを<span class="bold"><strong>履歴リスト</strong></span>から解析して処理します。これは、(以前の <code class="literal">DELETE</code> ステートメントによって) 削除対象としてマークされ、<span class="bold"><strong>MVCC</strong></span> または <span class="bold"><strong>rollback</strong></span> では不要になったクラスタインデックスレコードおよびセカンダリインデックスレコードを削除するためです。 パージすると、undo ログページは処理後に履歴リストから解放されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_history_list">履歴リスト</a>, <a class="glossseealso" href="glossary.html#glos_mvcc">MVCC</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_undo_log">Undo ログ</a>も参照</p></dd><dt><a name="glos_purge_thread"></a><span class="glossterm">パージスレッド</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763480864"></a>
        定期的な <span class="bold"><strong>purge</strong></span> 操作の実行専用の <code class="literal">InnoDB</code> プロセス内の<span class="bold"><strong>スレッド</strong></span>。 MySQL 5.6 以降では、複数のパージスレッドが <code class="literal">innodb_purge_threads</code> 構成オプションによって有効になっています。 
      </p><p><a class="glossseealso" href="glossary.html#glos_purge">パージ</a>, <a class="glossseealso" href="glossary.html#glos_thread">スレッド</a>も参照</p></dd><dt><a name="glos_purge_buffering"></a><span class="glossterm">パージバッファリング</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763468144"></a>
        ランダムな I/O を最小限に抑えるために物理書込みを実行できるように、変更を即座に書き込むのではなく、<code class="literal">DELETE</code> 操作によって生成されたセカンダリインデックスページへの変更を<span class="bold"><strong>変更バッファ</strong></span>に格納する方法。 (削除操作は 2 ステッププロセスなので、この操作は、通常は以前に削除とマークされたインデックスレコードをパージする書き込みをバッファリングします。) これは<span class="bold"><strong>変更バッファリング</strong></span>の一種です。ほかには<span class="bold"><strong>挿入バッファリング</strong></span>と<span class="bold"><strong>削除バッファリング</strong></span>があります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_change_buffer">変更バッファー</a>, <a class="glossseealso" href="glossary.html#glos_change_buffering">変更バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_delete_buffering">削除バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_insert_buffer">挿入バッファー</a>, <a class="glossseealso" href="glossary.html#glos_insert_buffering">挿入バッファリング</a>も参照</p></dd><dt><a name="glos_purge_lag"></a><span class="glossterm">パージ遅延</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763474032"></a>
        <code class="literal">InnoDB</code> <span class="bold"><strong>履歴リスト</strong></span>の別の名前。 <code class="literal">innodb_max_purge_lag</code> 構成オプションに関連しています。 
      </p><p><a class="glossseealso" href="glossary.html#glos_history_list">履歴リスト</a>, <a class="glossseealso" href="glossary.html#glos_purge">パージ</a>も参照</p></dd><dt><a name="glos_semi_consistent_read"></a><span class="glossterm">半一貫性読み取り</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763352864"></a>
        <span class="bold"><strong>READ COMMITTED</strong></span> と<span class="bold"><strong>読取り一貫性</strong></span>の組合せである、<code class="literal">UPDATE</code> ステートメントに使用される読取り操作のタイプ。 <code class="literal">UPDATE</code> ステートメントがすでにロックされている行を調べると、<code class="literal">InnoDB</code> は、MySQL に最新のコミット済バージョンを返して、その行が <code class="literal">UPDATE</code> の <code class="literal">WHERE</code> 条件に一致するかどうかを判断できるようにします。 行が一致する場合 (更新する必要がある場合)、MySQL は行を再度読み取り、今回は <code class="literal">InnoDB</code> がロックするか、ロックを待機します。 このタイプの読取り操作は、トランザクションに READ COMMITTED <span class="bold"><strong>分離レベル</strong></span>がある場合にのみ実行できます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_consistent_read">一貫性読み取り</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_read_committed">READ COMMITTED</a>も参照</p></dd><dt><a name="glos_non_repeatable_read"></a><span class="glossterm">反復不可能読み取り</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763341440"></a>
        あるクエリーがデータを取得し、同じ<span class="bold"><strong>トランザクション</strong></span>内のその後のクエリーが同じデータであるはずのものを取得するけれども、それらのクエリーが異なる結果を返す状況 (その間にコミットしている別のトランザクションによって変更された)。
      </p><p>
        この種の操作は、データベース設計の <span class="bold"><strong>ACID</strong></span> 原則に反します。 トランザクション内のデータは、予測可能で安定した関係を持ち、一貫しているべきです。 
      </p><p>
        さまざまな<span class="bold"><strong>分離レベル</strong></span>の中で、反復不可能読み取りは、<span class="bold"><strong>シリアライズ可能読み取り</strong></span>と<span class="bold"><strong>反復可能読み取り</strong></span>レベルによって防止され、<span class="bold"><strong>一貫性読み取り</strong></span>と<span class="bold"><strong>コミットされていない読み取り</strong></span>レベルで許可されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_consistent_read">一貫性読み取り</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_read_uncommitted">READ UNCOMMITTED</a>, <a class="glossseealso" href="glossary.html#glos_repeatable_read">REPEATABLE READ</a>, <a class="glossseealso" href="glossary.html#glos_serializable">SERIALIZABLE</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_exclusive_lock"></a><span class="glossterm">排他ロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763452848"></a>
        ほかの<span class="bold"><strong>トランザクション</strong></span>が同じ行をロックするのを回避するタイプの<span class="bold"><strong>ロック</strong></span>。 この種のロックは、トランザクション<span class="bold"><strong>分離レベル</strong></span>に応じて、ほかのトランザクションが同じ行に書き込むのをブロックしたり、ほかのトランザクションが同じ行を読み取るのをブロックしたりできます。 デフォルトの <code class="literal">InnoDB</code> 分離レベルである <span class="bold"><strong>REPEATABLE READ</strong></span> を使用すると、<span class="bold"><strong>読取り一貫性</strong></span>と呼ばれる手法である排他ロックを持つ行をトランザクションが読み取ることができるため、より高い<span class="bold"><strong>同時実行性</strong></span>が有効になります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_consistent_read">一貫性読み取り</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_repeatable_read">REPEATABLE READ</a>, <a class="glossseealso" href="glossary.html#glos_shared_lock">共有ロック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_torn_page"></a><span class="glossterm">破損ページ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763424784"></a>
        I/O デバイス構成とハードウェア障害の組み合わせが原因で発生する可能性のあるエラー状況。 データが <code class="literal">InnoDB</code> <span class="bold"><strong>ページサイズ</strong></span>より小さいチャンク (デフォルトでは 16KB) で書き出された場合、書込み中にハードウェア障害が発生すると、ページの一部のみがディスクに格納される可能性があります。 <code class="literal">InnoDB</code> <span class="bold"><strong>二重書込みバッファ</strong></span>は、この可能性を防ぎます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_doublewrite_buffer">二重書き込みバッファー</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ヒ</h3><dl><dt><a name="glos_business_rules"></a><span class="glossterm">ビジネスルール</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763327936"></a>
        営利企業を運営するために使用される、ビジネスソフトウェアの基盤を形作るアクションの関係およびシーケンス。 これらのルールは、法律によって規定されたり、企業ポリシーで規定されたります。 慎重に計画することで、データベースでエンコードされ適用される関係と、アプリケーションロジックを通じて実行されるアクションが、企業の実際のポリシーを正確に反映し、現実の状況を扱うことができます。 
      </p><p>
        たとえば、従業員が会社を退職すると、人事部からアクションシーケンスがトリガーされます。 人事データベースには、雇用されたけれどもまだ就業していない人物に関するデータを表すために、柔軟性も必要になることがあります。 オンラインサービスで口座を閉鎖すると、データがデータベースから削除されたり、口座が再度開設されたりした場合にリカバリできるようにデータが移動またはフラグ付けされたります。 企業は、給与が負数でないなどの基本的なサニティーチェックに加えて、給与の最大、最小、および調整に関するポリシーを確立できます。 小売データベースでは、同じシリアル番号の購入を複数回返すことを禁止したり、一定値を超えるクレジットカード購入を禁止したりしますが、詐欺の検出に使用されるデータベースでは、このようなことを許可する場合があります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_relational">リレーショナル</a>も参照</p></dd><dt><a name="glos_non_blocking_io"></a><span class="glossterm">非ブロック化 I/O</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763302832"></a>
        <span class="bold"><strong>非同期 I/O</strong></span>と同じ意味を持つ業界用語。
      </p><p><a class="glossseealso" href="glossary.html#glos_asynchronous_io">非同期 I/O</a>も参照</p></dd><dt><a name="glos_non_locking_read"></a><span class="glossterm">非ロック読み取り</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763299216"></a>
        <code class="literal">SELECT ... FOR UPDATE</code> または <code class="literal">SELECT ... LOCK IN SHARE MODE</code> 句を使用しない<span class="bold"><strong>クエリー</strong></span>。 <span class="bold"><strong>読み取り専用トランザクション</strong></span>でグローバルテーブルに許可される唯一の種類のクエリー。 <span class="bold"><strong>ロック読み取り</strong></span>の反対。 <a class="xref" href="innodb-storage-engine.html#innodb-consistent-read" title="15.7.2.3 一貫性非ロック読み取り">セクション15.7.2.3「一貫性非ロック読み取り」</a>を参照してください。 
      </p><p>
        MySQL 8.0.1 の <code class="literal">SELECT ... LOCK IN SHARE MODE</code> は <code class="literal">SELECT ... FOR SHARE</code> に置き換わりますが、<code class="literal">LOCK IN SHARE MODE</code> は下位互換性のために引き続き使用できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_locking_read">ロック読み取り</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>, <a class="glossseealso" href="glossary.html#glos_read_only_transaction">読み取り専用トランザクション</a>も参照</p></dd><dt><a name="glos_asynchronous_io"></a><span class="glossterm">非同期 I/O</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763314256"></a>
        I/O が完了するまでほかの処理の進行を許可する I/O 操作のタイプ。 <span class="bold"><strong>非ブロック化 I/O</strong></span>とも呼ばれ、<span class="bold"><strong>AIO</strong></span> と省略されます。 <code class="literal">InnoDB</code> では、実際にはリクエストされていないが、すぐに必要になる可能性がある<span class="bold"><strong>バッファプール</strong></span>へのページの読取りなど、データベースの信頼性に影響を与えることなくパラレルで実行できる特定の操作に、このタイプの I/O が使用されます。 
      </p><p>
        従来、<code class="literal">InnoDB</code> は Windows システムでのみ非同期 I/O を使用していました。 InnoDB プラグイン 1.1 および MySQL 5.5 以上では、<code class="literal">InnoDB </code>は Linux システムで非同期 I/O を使用します。 この変更により、<code class="literal">libaio</code> への依存関係がもたらされます。 Linux システムでの非同期 I/O は、<code class="literal">innodb_use_native_aio</code> オプションを使用して構成されます。これはデフォルトで有効になっています。 ほかの Unix 系システムでは、InnoDB は同期 I/O だけを使用します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_non_blocking_io">非ブロック化 I/O</a>も参照</p></dd><dt><a name="glos_denormalized"></a><span class="glossterm">非正規化</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763322288"></a>
        <span class="bold"><strong>外部キー</strong></span>と<span class="bold"><strong>結合</strong></span>クエリーでテーブルをリンクするのではなく、複数のテーブルにわたってデータを複製するデータストレージ戦略。 通常は<span class="bold"><strong>データウェアハウス</strong></span>アプリケーションで使用されます。この場合、データはロード後に更新されません。 このようなアプリケーションでは、更新中にデータの一貫性を維持することを簡略化するよりも、クエリーパフォーマンスが重要になります。 <span class="bold"><strong>正規化</strong></span>と対比してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_data_warehouse">データウェアハウス</a>, <a class="glossseealso" href="glossary.html#glos_foreign_key">外部キー</a>, <a class="glossseealso" href="glossary.html#glos_join">結合</a>, <a class="glossseealso" href="glossary.html#glos_normalized">正規化</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">フ</h3><dl><dt><a name="glos_file_format"></a><span class="glossterm">ファイル形式</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763287440"></a>
        <code class="literal">InnoDB</code> テーブルのファイル形式。
      </p><p><a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_ibdata_file">ibdata ファイル</a>, <a class="glossseealso" href="glossary.html#glos_row_format">行フォーマット</a>も参照</p></dd><dt><a name="glos_fuzzy_checkpointing"></a><span class="glossterm">ファジーチェックポイント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763282224"></a>
        データベース処理を妨害する<span class="bold"><strong>ダーティーページ</strong></span>を一度にすべてフラッシュするのではなく、ダーティーページの小さなバッチを<span class="bold"><strong>バッファープール</strong></span>から<span class="bold"><strong>フラッシュ</strong></span>する方法。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_dirty_page">ダーティーページ</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>も参照</p></dd><dt><a name="glos_phantom"></a><span class="glossterm">ファントム</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763275968"></a>
        あるクエリーの結果セットに出現するけれども、以前のクエリーの結果セットにない行。 たとえば、あるクエリーが<span class="bold"><strong>トランザクション</strong></span>内で 2 度実行されて、その間に別のトランザクションがそのクエリーの <code class="literal">WHERE</code> 句に一致する新しい行を挿入または行を更新したあとにコミットされた場合です。 
      </p><p>
        この現象がファントム読み取りと呼ばれます。 このことから保護することは、<span class="bold"><strong>反復不可能読み取り</strong></span>よりも困難です。最初のクエリー結果セットからのすべての行をロックしても、ファントムが出現する変更は防止されないためです。 
      </p><p>
        さまざまな<span class="bold"><strong>分離レベル</strong></span>の中で、ファントム読み取りは、<span class="bold"><strong>シリアライズ可能読み取り</strong></span>で防止され、<span class="bold"><strong>反復可能読み取り</strong></span>、<span class="bold"><strong>一貫性読み取り</strong></span>、および<span class="bold"><strong>コミットされていない読み取り</strong></span>レベルで許可されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_consistent_read">一貫性読み取り</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_non_repeatable_read">反復不可能読み取り</a>, <a class="glossseealso" href="glossary.html#glos_read_uncommitted">READ UNCOMMITTED</a>, <a class="glossseealso" href="glossary.html#glos_repeatable_read">REPEATABLE READ</a>, <a class="glossseealso" href="glossary.html#glos_serializable">SERIALIZABLE</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_fill_factor"></a><span class="glossterm">フィルファクタ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763262272"></a>
        <code class="literal">InnoDB</code> <span class="bold"><strong>index</strong></span> で、ページが分割される前にインデックスデータによって取得される <span class="bold"><strong>page</strong></span> の割合。 ページ間でインデックスデータが最初に分割されるときの未使用領域によって、負荷のかかるインデックス保守操作を必要とすることなく、より長い文字列値で行を更新できます。 フィルファクタが低すぎた場合、インデックスは必要以上の領域を消費し、インデックスを読み取るときに余分な I/O オーバーヘッドが生じます。 フィルファクタが高すぎると、カラム値の長さが増える更新で、インデックス保守の追加 I/O オーバーヘッドが生じる可能性があります。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-physical-structure" title="15.6.2.2 InnoDB インデックスの物理構造">セクション15.6.2.2「InnoDB インデックスの物理構造」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>も参照</p></dd><dt><a name="glos_flush"></a><span class="glossterm">フラッシュ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763215360"></a>
        メモリー領域または一時ディスクストレージ領域にバッファリングされていた変更をデータベースファイルに書き込むこと。 定期的にフラッシュされる <code class="literal">InnoDB</code> 記憶域構造には、<span class="bold"><strong>redo ログ</strong></span>、<span class="bold"><strong>undo ログ</strong></span>および<span class="bold"><strong>バッファプール</strong></span>が含まれます。 
      </p><p>
        フラッシュは、メモリー領域がいっぱいになってシステムが一部の領域を解放する必要があるため、<span class="bold"><strong>コミット</strong></span>操作が、トランザクションからの変更を完結できることを意味するため、または<span class="bold"><strong>低速シャットダウン</strong></span>操作が、すべての未処理作業を完結するべきであることを意味するため、行われます。 バッファリングされているデータすべてを一度にフラッシュすることが重要でないときは、<code class="literal">InnoDB</code> は、<span class="bold"><strong>ファジーチェックポイント</strong></span>という方法を使用して、ページの小さなバッチをフラッシュし、I/O オーバーヘッドを分散させることができます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_fuzzy_checkpointing">ファジーチェックポイント</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>, <a class="glossseealso" href="glossary.html#glos_slow_shutdown">低速シャットダウン</a>, <a class="glossseealso" href="glossary.html#glos_undo_log">Undo ログ</a>も参照</p></dd><dt><a name="glos_flush_list"></a><span class="glossterm">フラッシュリスト</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763202448"></a>
        <span class="bold"><strong>バッファプール</strong></span>で<span class="bold"><strong>ダーティページ</strong></span>を追跡する内部 <code class="literal">InnoDB</code> データ構造: つまり、変更され、ディスクにライトアウトする必要がある <span class="bold"><strong>pages</strong></span>。 このデータ構造は、<code class="literal">InnoDB</code> 内部 <span class="bold"><strong>mini-transactions</strong></span> によって頻繁に更新されるため、バッファプールへの同時アクセスを可能にするために独自の <span class="bold"><strong>mutex</strong></span> によって保護されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_dirty_page">ダーティーページ</a>, <a class="glossseealso" href="glossary.html#glos_lru">LRU</a>, <a class="glossseealso" href="glossary.html#glos_mini_transaction">ミニトランザクション</a>, <a class="glossseealso" href="glossary.html#glos_mutex">相互排他ロック</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_page_cleaner">ページクリーナー</a>も参照</p></dd><dt><a name="glos_blind_query_expansion"></a><span class="glossterm">ブラインドクエリー拡張</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763220624"></a>
        <code class="literal">WITH QUERY EXPANSION</code> 句で有効になる<span class="bold"><strong>全文検索</strong></span>の特別なモード。 これは検索を 2 度実行し、2 度目の検索には、最初の検索で検出されたドキュメントからのもっとも関連性の強い少数の単語をつなぎ合わせた、独自の検索語句を使用します。 この方法は、主に短い検索語句、おそらく単一単語のみに適用されます。 これは、正確な検索語句がドキュメント内で現れない場合に、関連した一致を見つけることができます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_full_text_search">全文検索</a>も参照</p></dd><dt><a name="glos_prefix"></a><span class="glossterm">プリフィクス</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_index_prefix">インデックスプリフィクス</a>も参照</p></dd><dt><a name="glos_prepared_statement"></a><span class="glossterm">プリペアドステートメント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763189600"></a>
        効率的な実行計画を決定するために事前に分析される SQL ステートメント。 毎回解析および分析のオーバーヘッドなしで、複数回実行できます。 プレースホルダを使用して、毎回 <code class="literal">WHERE</code> 句のリテラルに異なる値を代入できます。 この置換手法により、セキュリティが向上し、なんらかの SQL インジェクション攻撃から保護されます。 戻り値をプログラム変数に変換およびコピーするためのオーバーヘッドを削減することもできます。 
      </p><p>
        プリペアドステートメントは SQL 構文を介して直接使用できますが、様々な<span class="bold"><strong>コネクタ</strong></span>にはプリペアドステートメントを操作するためのプログラミングインタフェースがあり、これらの API は SQL を介して実行するよりも効率的です。
      </p><p><a class="glossseealso" href="glossary.html#glos_client_side_prepared_statement">クライアント側のプリペアドステートメント</a>, <a class="glossseealso" href="glossary.html#glos_connector">コネクタ</a>, <a class="glossseealso" href="glossary.html#glos_server_side_prepared_statement">サーバー側のプリペアドステートメント</a>も参照</p></dd><dt><a name="glos_process"></a><span class="glossterm">プロセス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763182272"></a>
        実行中プログラムのインスタンス。 オペレーティングシステムは、複数の実行中プロセスを切り替えることで、一定程度の<span class="bold"><strong>並列性</strong></span>を実現します。 ほとんどのオペレーティングシステムのプロセスには、リソースを共有する複数の実行<span class="bold"><strong>スレッド</strong></span>を含めることができます。 スレッド間のコンテキスト切り替えは、プロセス間の同等切り替えより高速です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_thread">スレッド</a>も参照</p></dd><dt><a name="glos_isolation_level"></a><span class="glossterm">分離レベル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763176960"></a>
        データベース処理の基礎の 1 つ。 分離は、頭字語 <span class="bold"><strong>ACID</strong></span> の <span class="bold"><strong>I</strong></span> です。分離レベルは、複数の<span class="bold"><strong>トランザクション</strong></span>が同時に変更を行ったりクエリーを実行したりしているときに、パフォーマンスと信頼性のバランス、一貫性、結果の再現性を微調整する設定です。 
      </p><p>
        もっとも高い一貫性および保護からもっとも低いものまで、InnoDB でサポートされる分離レベルは、<span class="bold"><strong>SERIALIZABLE</strong></span>、<span class="bold"><strong>REPEATABLE READ</strong></span>、<span class="bold"><strong>READ COMMITTED</strong></span>、および <span class="bold"><strong>READ UNCOMMITTED</strong></span> です。
      </p><p>
        <code class="literal">InnoDB</code> テーブルでは、多くのユーザーがすべての操作に対してデフォルトの分離レベル (<span class="emphasis"><em>REPEATABLE READ</em></span>) を保持できます。 エキスパートユーザーは、<span class="bold"><strong>OLTP</strong></span> 処理でスケーラビリティの境界をプッシュするとき、またはわずかな不一致が大量のデータの集計結果に影響しないデータウェアハウス操作中に、<span class="bold"><strong>READ COMMITTED</strong></span> レベルを選択できます。 両端のレベル (<span class="bold"><strong>SERIALIZABLE</strong></span> および <span class="bold"><strong>READ UNCOMMITTED</strong></span>) は、処理動作をまれにしか使用されない程度に変更します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_oltp">OLTP</a>, <a class="glossseealso" href="glossary.html#glos_read_committed">READ COMMITTED</a>, <a class="glossseealso" href="glossary.html#glos_read_uncommitted">READ UNCOMMITTED</a>, <a class="glossseealso" href="glossary.html#glos_repeatable_read">REPEATABLE READ</a>, <a class="glossseealso" href="glossary.html#glos_serializable">SERIALIZABLE</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_physical"></a><span class="glossterm">物理</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763251040"></a>
        ディスクブロック、メモリーページ、ファイル、ビット、ディスク読み取りなど、ハードウェア関連側面がかかわるタイプの操作。 物理側面は通常、上級者レベルのパフォーマンスチューニングおよび問題診断中に重要になります。 <span class="bold"><strong>論理</strong></span>と対比してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_logical">論理</a>, <a class="glossseealso" href="glossary.html#glos_physical_backup">物理バックアップ</a>も参照</p></dd><dt><a name="glos_physical_backup"></a><span class="glossterm">物理バックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763246160"></a>
        実際のデータファイルをコピーする<span class="bold"><strong>バックアップ</strong></span>。 たとえば、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品の <span class="bold"><strong><code class="literal">mysqlbackup</code></strong></span> コマンドは物理バックアップを返します。その出力に <code class="literal">mysqld</code> サーバーが直接使用できるデータファイルが含まれているためです (<span class="bold"><strong>リストア</strong></span>操作の速度が向上します)。 <span class="bold"><strong>論理バックアップ</strong></span>と対比してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_backup">バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_logical_backup">論理バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_restore">リストア</a>も参照</p></dd><dt><a name="glos_composite_index"></a><span class="glossterm">複合インデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763254624"></a>
        複数のカラムを含む<span class="bold"><strong>インデックス</strong></span>。
      </p><p><a class="glossseealso" href="glossary.html#glos_index">インデックス</a>も参照</p></dd><dt><a name="glos_partial_index"></a><span class="glossterm">部分インデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763236576"></a>
        カラム値の一部 (通常は、長い <code class="literal">VARCHAR</code> 値の最初の N 文字 (<span class="bold"><strong>プリフィクス</strong></span>) だけを表す) <span class="bold"><strong>インデックス</strong></span>。
      </p><p><a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_index_prefix">インデックスプリフィクス</a>も参照</p></dd><dt><a name="glos_partial_backup"></a><span class="glossterm">部分バックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763226960"></a>
        MySQL データベースの<span class="bold"><strong>テーブル</strong></span>の一部、または MySQL インスタンスのデータベースの一部を含む<span class="bold"><strong>バックアップ</strong></span>。 <span class="bold"><strong>完全バックアップ</strong></span>と対比してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_backup">バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_full_backup">完全バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd><dt><a name="glos_partial_trust"></a><span class="glossterm">部分信頼</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763230912"></a>
        通常、ホスティングプロバイダによって使用される実行環境。アプリケーションにはいくつかの権限がありますが、他の権限はありません。 たとえば、アプリケーションはネットワークを介してデータベースサーバーにアクセスできますが、ローカルファイルの読取りおよび書込みに関しては<span class="quote">「<span class="quote">「サンドボックス」</span>」</span>である場合があります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_connector_net">Connector/NET</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ヘ</h3><dl><dt><a name="glos_pessimistic"></a><span class="glossterm">ペシミスティック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763125808"></a>
        パフォーマンスまたは並列性を犠牲にして、安全性を優先する概念。 リクエストまたは試行が高い割合で失敗する可能性がある場合、または失敗したリクエストの結果が深刻である場合に適しています。 <code class="literal">InnoDB</code> では、ペシミスティック<span class="bold"><strong>ロック</strong></span>戦略と呼ばれるものを使用して、<span class="bold"><strong>デッドロック</strong></span>の可能性を最小限に抑えます。 アプリケーションレベルでは、トランザクションが必要とするすべてのロックを最初に獲得するペシミスティック戦略を使用することによって、デッドロックを回避できる可能性があります。 
      </p><p>
        多くのデータベースに組み込まれているメカニズムでは、反対の<span class="bold"><strong>オプティミスティック</strong></span>概念が使用されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_deadlock">デッドロック</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_optimistic">オプティミスティック</a>も参照</p></dd><dt><a name="glos_page"></a><span class="glossterm">ページ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763152992"></a>
        <code class="literal">InnoDB</code> がディスク (<span class="bold"><strong>データファイル</strong></span>) とメモリー (<span class="bold"><strong>バッファプール</strong></span>) の間で一度に転送するデータ量を表す単位。 ページには 1 つ以上の<span class="bold"><strong>行</strong></span>を含めることができます (各行のデータ量に依存)。 行全体が単一ページに収まらない場合、<code class="literal">InnoDB</code> では、行に関する情報を単一ページに格納できるようにポインタスタイルの追加データ構造が設定されます。 
      </p><p>
        各ページにより多くのデータを収める方法の 1 つは、<span class="bold"><strong>圧縮行フォーマット</strong></span>を使用ことです。 BLOB またはラージテキストフィールドを使用するテーブルの場合、<span class="bold"><strong>コンパクト行フォーマット</strong></span>を使用してこれらのラージカラムを残りの行とは別個に格納することで、これらのカラムを参照しないクエリーの I/O オーバーヘッドとメモリー使用量を減らすことができます。 
      </p><p>
        <code class="literal">InnoDB</code> は、I/O スループットを向上させるために一連のページをバッチとして読み書きするときに、<span class="bold"><strong>extent</strong></span> を一度に読み書きします。
      </p><p>
        MySQL インスタンス内のすべての <code class="literal">InnoDB</code> ディスクデータ構造は、同じ<span class="bold"><strong>ページサイズ</strong></span>を共有します。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_compact_row_format">コンパクト行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_compressed_row_format">圧縮行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_extent">エクステント</a>, <a class="glossseealso" href="glossary.html#glos_page_size">page size</a>, <a class="glossseealso" href="glossary.html#glos_row">行</a>も参照</p></dd><dt><a name="glos_page_cleaner"></a><span class="glossterm">ページクリーナー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763136256"></a>
        <span class="bold"><strong>バッファプール</strong></span>から<span class="bold"><strong>フラッシュ</strong></span> <span class="bold"><strong>ダーティページ</strong></span>が提供する <code class="literal">InnoDB</code> バックグラウンド<span class="bold"><strong>スレッド</strong></span>。 MySQL 5.6 より前では、このアクティビティーは<span class="bold"><strong>マスタースレッド</strong></span>によって実行されていました ページクリーナスレッドの数は、MySQL 5.7.4 で導入された <code class="literal">innodb_page_cleaners</code> 構成オプションによって制御されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_dirty_page">ダーティーページ</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_master_thread">マスタースレッド</a>, <a class="glossseealso" href="glossary.html#glos_thread">スレッド</a>も参照</p></dd><dt><a name="glos_concurrency"></a><span class="glossterm">並列性</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763158832"></a>
        複数の操作 (データベース用語では、<span class="bold"><strong>トランザクション</strong></span>) が互いに干渉することなく同時に実行できること。 並列性はパフォーマンスにも関係しています。理論的には、<span class="bold"><strong>ロック</strong></span>の効率的なメカニズムを使用して、複数の同時トランザクションの保護が最小のパフォーマンスオーバーヘッドで機能するためです。 
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_change_buffering"></a><span class="glossterm">変更バッファリング</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763088192"></a>
        <span class="bold"><strong>変更バッファー</strong></span>を使用する機能の汎用用語で、<span class="bold"><strong>挿入バッファリング</strong></span>、<span class="bold"><strong>削除バッファリング</strong></span>、および<span class="bold"><strong>パージバッファリング</strong></span>から構成されます。 SQL ステートメントから生じるインデックス変更は、通常はランダム I/O 操作を使用し、バックグラウンド<span class="bold"><strong>スレッド</strong></span>によって保持されて定期的に実行されます。 この操作シーケンスは、値が即座にディスクに書き込まれる場合よりも効率的に、一連のインデックス値のディスクブロックを書き込むことができます。 <code class="literal">innodb_change_buffering</code> および <code class="literal">innodb_change_buffer_max_size</code> 構成オプションによって制御されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_change_buffer">変更バッファー</a>, <a class="glossseealso" href="glossary.html#glos_delete_buffering">削除バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_insert_buffering">挿入バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_purge_buffering">パージバッファリング</a>も参照</p></dd><dt><a name="glos_change_buffer"></a><span class="glossterm">変更バッファー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763117232"></a>
        <span class="bold"><strong>セカンダリインデックス</strong></span>内の<span class="bold"><strong>ページ</strong></span>への変更を記録する特殊なデータ構造。 これらの値は、SQL <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、または <code class="literal">DELETE</code> ステートメント (<span class="bold"><strong>DML</strong></span>) の結果として発生する可能性があります。 変更バッファーを使用する一連の機能は、まとめて<span class="bold"><strong>変更バッファリング</strong></span>と呼ばれ、<span class="bold"><strong>挿入バッファリング</strong></span>、<span class="bold"><strong>削除バッファリング</strong></span>、および<span class="bold"><strong>パージバッファリング</strong></span>から構成されています。 
      </p><p>
        セカンダリインデックスからの関連ページが<span class="bold"><strong>バッファープール</strong></span>に存在しない場合、変更は変更バッファーにのみ記録されます。 関連付けられた変更が変更バッファー内にまだあるときに該当するインデックスページがバッファープールに読み取られた場合、そのページに関する変更は、変更バッファーからのデータを使用してバッファープールに適用 (<span class="bold"><strong>マージ</strong></span>) されます。 システムがほとんどアイドル状態になっているとき、または低速シャットダウン中に実行する<span class="bold"><strong>パージ</strong></span>操作は、定期的に新しいインデックスページをディスクに書き込みます。 パージ操作は、それぞれの値を即座にディスクに書き込む場合よりも効率的に、一連のインデックス値のディスクブロックを書き込むことができます。 
      </p><p>
        物理的に変更バッファーは、<span class="bold"><strong>システムテーブルスペース</strong></span>の一部なので、インデックス変更はデータベースの再起動をまたがってバッファーに残ります。 変更は、ほかの読み取り操作によってページがバッファープールに読み取られたときにのみ、適用 (<span class="bold"><strong>マージ</strong></span>) されます。 
      </p><p>
        変更バッファーに格納されたデータの種類と容量は、<code class="literal">innodb_change_buffering</code> および <code class="literal">innodb_change_buffer_max_size</code> 構成オプションで制御されます。 変更バッファー内の現在のデータに関する情報を確認するには、<code class="literal">SHOW ENGINE INNODB STATUS</code> コマンドを発行してください。 
      </p><p>
        以前には<span class="bold"><strong>挿入バッファー</strong></span>と呼ばれていました。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_change_buffering">変更バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_delete_buffering">削除バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_insert_buffer">挿入バッファー</a>, <a class="glossseealso" href="glossary.html#glos_insert_buffering">挿入バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_merge">マージ</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_purge">パージ</a>, <a class="glossseealso" href="glossary.html#glos_purge_buffering">パージバッファリング</a>, <a class="glossseealso" href="glossary.html#glos_secondary_index">セカンダリインデックス</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ベ</h3><dl><dt><a name="glos_base_column"></a><span class="glossterm">ベースカラム</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763076944"></a>
        格納された生成カラムまたは仮想生成カラムの基になる、生成されないテーブルのカラム。 つまり、ベースカラムは、生成されるカラム定義の一部である、生成されないテーブルのカラムです。 
      </p><p><a class="glossseealso" href="glossary.html#glos_generated_column">生成されるカラム</a>, <a class="glossseealso" href="glossary.html#glos_stored_generated_column">ストアド生成カラム</a>, <a class="glossseealso" href="glossary.html#glos_virtual_generated_column">仮想生成カラム</a>も参照</p></dd><dt><a name="glos_beta"></a><span class="glossterm">ベータ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763072736"></a>
        ソフトウェア製品の存続期間の初期段階。評価にのみ利用できる期間で、通常は確定したリリース番号や 1 未満の数がありません。 <code class="literal">InnoDB</code> ではベータ指定は使用されず、<span class="bold"><strong>GA</strong></span> リリースにつながる複数のポイントリリースにわたる<span class="bold"><strong>早期導入者</strong></span>フェーズをお薦めします。 
      </p><p><a class="glossseealso" href="glossary.html#glos_early_adopter">アーリーアダプタ</a>, <a class="glossseealso" href="glossary.html#glos_ga">GA</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ホ</h3><dl><dt><a name="glos_host"></a><span class="glossterm">ホスト</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763050400"></a>
        <span class="bold"><strong>connection</strong></span> の確立に使用されるデータベースサーバーのネットワーク名。 多くの場合、<span class="bold"><strong>port</strong></span> と組み合せて指定されます。 一部のコンテキストでは、IP アドレス <code class="literal">127.0.0.1</code> は、アプリケーションと同じサーバー上のデータベースにアクセスするための特別な名前 <code class="literal">localhost</code> よりも適切に機能します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_connection">接続</a>, <a class="glossseealso" href="glossary.html#glos_localhost">localhost</a>, <a class="glossseealso" href="glossary.html#glos_port">port</a>も参照</p></dd><dt><a name="glos_hot"></a><span class="glossterm">ホット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763043248"></a>
        行、テーブル、または内部データ構造が非常に頻繁にアクセスされ、何らかの形式のロックまたは相互排他が必要になり、結果としてパフォーマンスまたはスケーラビリティーの問題が発生する状況。
      </p><p>
        通常、<span class="quote">「<span class="quote">「ホット」</span>」</span>は望ましくない状態を示しますが、<span class="bold"><strong>ホットバックアップ</strong></span>が推奨されるバックアップのタイプです。
      </p><p><a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>も参照</p></dd><dt><a name="glos_hot_backup"></a><span class="glossterm">ホットバックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763038144"></a>
        データベースの実行中に作成され、アプリケーションがデータベースに対して読取りおよび書込みを行っているバックアップ。 バックアップはデータファイルを単純にコピーするだけではありません。バックアップが進行していた間に挿入または更新されたデータを含める必要があり、バックアップが進行していた間に削除されたデータを排除する必要があり、コミットされなかった変更を無視する必要があります。 
      </p><p>
        特に <code class="literal">MyISAM</code> およびその他のストレージエンジンからのテーブルである <code class="literal">InnoDB</code> テーブルのホットバックアップを実行する Oracle 製品は、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> と呼ばれます。
      </p><p>
        ホットバックアッププロセスは 2 つのステージから構成されます。 データファイルの初期コピーは <span class="bold"><strong>raw バックアップ</strong></span>を生成します。 <span class="bold"><strong>適用</strong></span>ステップにより、バックアップの実行中に行われたデータベースへの変更が組み込まれます。 変更の適用により、<span class="bold"><strong>準備された</strong></span>バックアップが生成されます。これらのファイルは、必要な場合はいつでもリストアできる状態です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_apply">適用</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_prepared_backup">準備されたバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_raw_backup">raw バックアップ</a>も参照</p></dd><dt><a name="glos_hole_punching"></a><span class="glossterm">ホールパンチング</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763056128"></a>
        ページからの空のブロックの解放。 <code class="literal">InnoDB</code> <span class="bold"><strong>透過的ページ圧縮</strong></span>機能は、ホールパンチのサポートに依存しています。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-page-compression" title="15.9.2 InnoDB ページ圧縮">セクション15.9.2「InnoDB ページ圧縮」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_sparse_file">スパースファイル</a>, <a class="glossseealso" href="glossary.html#glos_transparent_page_compression">透過的ページ圧縮</a>も参照</p></dd><dt><a name="glos_bottleneck"></a><span class="glossterm">ボトルネック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763027024"></a>
        システム内で、全体的なスループットを制限する影響を持つ、サイズまたは容量に制約がある部分。 たとえば、メモリー領域が必要な容量に満たないことがありますが、この場合、必要な単一リソースにアクセスするだけで、複数の CPU コアが同時に実行できなくなったり、ディスク I/O が完了するまで待機することで、CPU がフル稼働できなくなったりする可能性があります。 ボトルネックを取り除くと、<span class="bold"><strong>並列性</strong></span>が改善する傾向があります。 たとえば、複数の <code class="literal">InnoDB</code> <span class="bold"><strong>バッファプール</strong></span>インスタンスを持つ機能により、複数のセッションがバッファプールに対して同時に読取りおよび書込みを行う場合の競合が軽減されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>も参照</p></dd><dt><a name="glos_point_in_time_recovery"></a><span class="glossterm">ポイントインタイムリカバリ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763066128"></a>
        特定日時のデータベースの状態を再作成するために<span class="bold"><strong>バックアップ</strong></span>をリストアするプロセス。 一般に <span class="quote">「<span class="quote">PITR</span>」</span> と略記されます。 指定した時間がバックアップの時点に正確に対応する可能性は低いので、この方法は通常、<span class="bold"><strong>物理バックアップ</strong></span>および<span class="bold"><strong>論理バックアップ</strong></span>と組み合わせる必要があります。 たとえば、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品では、指定した特定の時点より前に取得した最後のバックアップをリストアしてから、そのバックアップ時点から PITR 時点までの<span class="bold"><strong>バイナリログ</strong></span>から変更を再現します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_backup">バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_binary_log">バイナリログ</a>, <a class="glossseealso" href="glossary.html#glos_logical_backup">論理バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_physical_backup">物理バックアップ</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">マ</h3><dl><dt><a name="glos_master_server"></a><span class="glossterm">マスター</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_source">source</a>も参照</p></dd><dt><a name="glos_master_thread"></a><span class="glossterm">マスタースレッド</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763011072"></a>
        様々なタスクをバックグラウンドで実行する <code class="literal">InnoDB</code> <span class="bold"><strong>スレッド</strong></span>。 これらのタスクのほとんどは、<span class="bold"><strong>変更バッファ</strong></span>から適切なセカンダリインデックスへの変更の書込みなど、I/O 関連です。 
      </p><p>
        <span class="bold"><strong>並列性</strong></span>を改善するために、アクションがマスタースレッドから個別のバックグラウンドスレッドに移される場合があります。 たとえば、MySQL 5.6 以降では、<span class="bold"><strong>ダーティーページ</strong></span>は、マスタースレッドではなく<span class="bold"><strong>ページクリーナー</strong></span>スレッドで、<span class="bold"><strong>バッファープール</strong></span>から<span class="bold"><strong>フラッシュ</strong></span>されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_change_buffer">変更バッファー</a>, <a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_dirty_page">ダーティーページ</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_page_cleaner">ページクリーナー</a>, <a class="glossseealso" href="glossary.html#glos_thread">スレッド</a>も参照</p></dd><dt><a name="glos_multi_core"></a><span class="glossterm">マルチコア</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762998512"></a>
        マルチスレッドプログラム (MySQL サーバーなど) を利用できるプロセッサのタイプ。
      </p></dd><dt><a name="glos_multiversion_concurrency_control"></a><span class="glossterm">マルチバージョン並列性制御</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_mvcc">MVCC</a>も参照</p></dd><dt><a name="glos_merge"></a><span class="glossterm">マージ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318763020080"></a>
        ページが<span class="bold"><strong>バッファープール</strong></span>に読み込まれたときや、<span class="bold"><strong>変更バッファー</strong></span>に記録された適用可能な変更がバッファープール内のページに組み込まれたときなどに、メモリーにキャッシュされたデータに変更を適用すること。 更新されたデータは最終的に、<span class="bold"><strong>フラッシュ</strong></span>メカニズムによって<span class="bold"><strong>テーブルスペース</strong></span>に書き込まれます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_change_buffer">変更バッファー</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ミ</h3><dl><dt><a name="glos_midpoint_insertion_strategy"></a><span class="glossterm">ミッドポイント挿入戦略</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762994144"></a>
        <span class="bold"><strong>pages</strong></span> を最初に <code class="literal">InnoDB</code> <span class="bold"><strong>バッファプール</strong></span>に取り込む方法。リストの <span class="quote">「<span class="quote">newest</span>」</span> 終端ではなく、中央のどこかに配置します。 このポイントの正確な位置は、<code class="literal">innodb_old_blocks_pct</code> オプションの設定に基づいて変わります。 目的は、<span class="bold"><strong>全テーブルスキャン</strong></span>中など、一度だけ読み取られるページは、厳密な <span class="bold"><strong>LRU</strong></span> アルゴリズムを使用するより早くバッファープールからエージアウトできることです。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool" title="15.5.1 バッファプール">セクション15.5.1「バッファプール」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_full_table_scan">テーブルの完全スキャン</a>, <a class="glossseealso" href="glossary.html#glos_lru">LRU</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>も参照</p></dd><dt><a name="glos_mini_transaction"></a><span class="glossterm">ミニトランザクション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762983424"></a>
        <span class="bold"><strong>DML</strong></span> 操作中に <span class="bold"><strong>physical</strong></span> レベルで内部データ構造を変更する場合の、<code class="literal">InnoDB</code> 処理の内部フェーズ。 ミニトランザクション (mtr) には<span class="bold"><strong>ロールバック</strong></span>の概念はありません。単一<span class="bold"><strong>トランザクション</strong></span>内で複数のミニトランザクションを発生できます。 ミニトランザクションは、<span class="bold"><strong>クラッシュリカバリ</strong></span>中に使用される <span class="bold"><strong>Redo ログ</strong></span>に情報を書き込みます。 ミニトランザクションは、たとえばバックグラウンドスレッドによる<span class="bold"><strong>パージ</strong></span>処理中など、通常のトランザクションのコンテキスト外でも発生できます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_crash_recovery">クラッシュリカバリ</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_physical">物理</a>, <a class="glossseealso" href="glossary.html#glos_purge">パージ</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">メ</h3><dl><dt><a name="glos_metadata_lock"></a><span class="glossterm">メタデータロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762969952"></a>
        別の<span class="bold"><strong>トランザクション</strong></span>によって同時に使用されているテーブルでの <span class="bold"><strong>DDL</strong></span> 操作を防止するタイプの<span class="bold"><strong>ロック</strong></span>。 詳細は、<a class="xref" href="optimization.html#metadata-locking" title="8.11.4 メタデータのロック">セクション8.11.4「メタデータのロック」</a>を参照してください。 
      </p><p>
        <span class="bold"><strong>オンライン</strong></span>操作への拡張機能は (特に MySQL 5.6 以降)、メタデータロックの量を減らすことに注力しています。 その目標は、ほかのトランザクションによってテーブルに照会や更新などが行われている間に、テーブル構造を変更しない DDL 操作 (<code class="literal">InnoDB</code> テーブルに対する <code class="literal">CREATE INDEX</code> や <code class="literal">DROP INDEX</code> など) を進行できるようにすることです。 
      </p><p><a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_online">オンライン</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_metrics_counter"></a><span class="glossterm">メトリックカウンタ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762958000"></a>
        MySQL 5.6 以上の <span class="bold"><strong>INFORMATION_SCHEMA</strong></span> の <code class="literal">INNODB_METRICS</code> テーブルによって実装される機能。 <span class="bold"><strong>counts</strong></span> および合計に対して低レベルの <code class="literal">InnoDB</code> 操作をクエリーして、その結果を<span class="bold"><strong>パフォーマンススキーマ</strong></span>のデータと組み合せてパフォーマンスチューニングに使用できます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_counter">カウンタ</a>, <a class="glossseealso" href="glossary.html#glos_information_schema">INFORMATION_SCHEMA</a>, <a class="glossseealso" href="glossary.html#glos_performance_schema">パフォーマンススキーマ</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">モ</h3><dl><dt><a name="glos_mono"></a><span class="glossterm">モノ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762949216"></a>
        Novell が開発したオープンソースフレームワークで、Linux プラットフォーム上の <span class="bold"><strong>Connector/NET</strong></span> および <span class="bold"><strong>C#</strong></span>アプリケーションで動作します。
      </p><p><a class="glossseealso" href="glossary.html#glos_connector_net">Connector/NET</a>, <a class="glossseealso" href="glossary.html#glos_csharp">C#</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ヨ</h3><dl><dt><a name="glos_read_view"></a><span class="glossterm">読み取りビュー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762934400"></a>
        <code class="literal">InnoDB</code> の <span class="bold"><strong>MVCC</strong></span> メカニズムで使用される内部スナップショット。 ある種の<span class="bold"><strong>トランザクション</strong></span>は、その<span class="bold"><strong>分離レベル</strong></span> に応じて、トランザクション (または、場合によってはステートメント) が開始した時点のデータ値を見ます。 読み取りビューを使用する分離レベルは、<span class="bold"><strong>REPEATABLE READ</strong></span>、<span class="bold"><strong>READ COMMITTED</strong></span>、および <span class="bold"><strong>READ UNCOMMITTED</strong></span> です。 
      </p><p><a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_mvcc">MVCC</a>, <a class="glossseealso" href="glossary.html#glos_read_committed">READ COMMITTED</a>, <a class="glossseealso" href="glossary.html#glos_read_uncommitted">READ UNCOMMITTED</a>, <a class="glossseealso" href="glossary.html#glos_repeatable_read">REPEATABLE READ</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_read_only_transaction"></a><span class="glossterm">読み取り専用トランザクション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762943728"></a>
        <code class="literal">InnoDB</code> テーブル用に最適化できる<span class="bold"><strong>トランザクション</strong></span>のタイプ。トランザクションごとに<span class="bold"><strong>読取りビュー</strong></span>を作成することに関連するブックキーピングの一部を排除します。 <span class="bold"><strong>非ロック読み取り</strong></span>クエリーだけを実行できます。 構文 <code class="literal">START TRANSACTION READ ONLY</code> で明示的に開始したり、特定の条件下で自動的に開始したりできます。 詳細は、<a class="xref" href="optimization.html#innodb-performance-ro-txn" title="8.5.3 InnoDB の読み取り専用トランザクションの最適化">セクション8.5.3「InnoDB の読み取り専用トランザクションの最適化」</a>を参照してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_non_locking_read">非ロック読み取り</a>, <a class="glossseealso" href="glossary.html#glos_read_view">読み取りビュー</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ラ</h3><dl><dt><a name="glos_lifecycle_interceptor"></a><span class="glossterm">ライフサイクルインサータ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762922624"></a>
        <span class="bold"><strong>Connector/J</strong></span> でサポートされている <span class="bold"><strong>interceptor</strong></span> のタイプ。 これには、インタフェース <code class="literal">com.mysql.jdbc.ConnectionLifecycleInterceptor</code> の実装が含まれます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_connector_j">Connector/J</a>, <a class="glossseealso" href="glossary.html#glos_interceptor">interceptor</a>も参照</p></dd><dt><a name="glos_latch"></a><span class="glossterm">ラッチ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762916912"></a>
        <code class="literal">InnoDB</code> が独自の内部メモリー構造の <span class="bold"><strong>lock</strong></span> を実装するために使用する軽量構造で、通常はミリ秒またはマイクロ秒単位で測定された短い時間保持されます。 <span class="bold"><strong>相互排他ロック</strong></span> (排他アクセスの場合) と<span class="bold"><strong>読み書きロック</strong></span> (共有アクセスの場合) の両方を含む一般用語。 特定のラッチは、<code class="literal">InnoDB</code> パフォーマンスチューニングの焦点です。 ラッチの使用と競合に関する統計は、<span class="bold"><strong>パフォーマンススキーマ</strong></span>インタフェースから入手できます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_mutex">相互排他ロック</a>, <a class="glossseealso" href="glossary.html#glos_performance_schema">パフォーマンススキーマ</a>, <a class="glossseealso" href="glossary.html#glos_rw_lock">rw ロック (読み書きロック)</a>も参照</p></dd><dt><a name="glos_random_dive"></a><span class="glossterm">ランダムダイブ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762906944"></a>
        カラム内の様々な値の数を迅速に見積もる手法 (<span class="bold"><strong>カーディナリティ</strong></span>カラム)。 <code class="literal">InnoDB</code> は、インデックスからランダムにページをサンプリングし、そのデータを使用して様々な値の数を見積もります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_cardinality">カーディナリティー</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">リ</h3><dl><dt><a name="glos_list"></a><span class="glossterm">リスト</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762901520"></a>
        <code class="literal">InnoDB</code> <span class="bold"><strong>バッファプール</strong></span>は、メモリー <span class="bold"><strong>pages</strong></span> のリストとして表されます。 リストは、新しいページがアクセスされてバッファープールに読み込まれたとき、バッファープール内のページが再度アクセスされてより新しいと見なされたとき、長時間アクセスされていないページがバッファープールから<span class="bold"><strong>削除</strong></span>されたときに、並べ替えられます。 バッファープールは<span class="bold"><strong>サブリスト</strong></span>に分割され、置換ポリシーは使い慣れた <span class="bold"><strong>LRU</strong></span> テクニックのバリエーションです。 
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_eviction">エビクション</a>, <a class="glossseealso" href="glossary.html#glos_lru">LRU</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_sublist">サブリスト</a>も参照</p></dd><dt><a name="glos_restore"></a><span class="glossterm">リストア</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762891936"></a>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品からのバックアップファイルセットを MySQL で使用できるように準備するプロセス。 この操作を実行すると、破損したデータベースを修正したり、以前のある時点に戻したり、(<span class="bold"><strong>レプリケーション</strong></span>コンテキストで) 新しい<span class="bold"><strong>レプリカ</strong></span>を設定できます。 <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品では、この操作は <code class="literal">mysqlbackup</code> コマンドの <code class="literal">copy-back</code> オプションで実行されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_mysqlbackup_command">mysqlbackup コマンド</a>, <a class="glossseealso" href="glossary.html#glos_prepared_backup">準備されたバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_replica">レプリカ</a>, <a class="glossseealso" href="glossary.html#glos_replication">レプリケーション</a>も参照</p></dd><dt><a name="glos_relational"></a><span class="glossterm">リレーショナル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762881824"></a>
        現代のデータベースシステムの重要な側面。 データベースサーバーは、1 対 1、1 対多、多対 1、一意性などの関係をエンコードし適用します。 たとえば、住所データベースでは、ある人にゼロ個、1 個、または複数個の電話番号が関連付けられていたり、単一電話番号が家族の複数のメンバーに関連付けられていたりします。 金融データベースでは、1 人の人に正確に 1 つの納税者 ID が割り当てられる必要があり、納税者 ID は 1 人の人にのみ関連付けることができます。 
      </p><p>
        データベースサーバーは、これらの関係を使用して、不良データが挿入されるのを防ぎ、情報をルックアップする効率的な方法を見つけることができます。 たとえば、値が一意であると宣言されている場合、サーバーは、最初の一致が見つかるとすぐに検索を停止し、同じ値の 2 番目のコピーを挿入しようとする試みを拒否できます。 
      </p><p>
        データベースレベルではこれらの関係は、テーブル内の<span class="bold"><strong>カラム</strong></span>、一意および <code class="literal">NOT NULL</code> <span class="bold"><strong>制約</strong></span>、<span class="bold"><strong>外部キー</strong></span>、さまざまな種類の結合操作などの SQL 機能を通じて表されます。 複雑な関係には通常、複数のテーブル間で分割されたデータが使用されます。 多くの場合、データは<span class="bold"><strong>正規化</strong></span>されるので、1 対多の関係での重複値は一度だけ格納されます。 
      </p><p>
        数学的なコンテキストでは、データベース内の関係は集合論から派生されます。 たとえば、<code class="literal">WHERE</code> 句の <code class="literal">OR</code> および <code class="literal">AND</code> 演算子は、論理和と論理積の概念を表します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_column">カラム</a>, <a class="glossseealso" href="glossary.html#glos_constraint">制約</a>, <a class="glossseealso" href="glossary.html#glos_foreign_key">外部キー</a>, <a class="glossseealso" href="glossary.html#glos_normalized">正規化</a>も参照</p></dd><dt><a name="glos_history_list"></a><span class="glossterm">履歴リスト</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762867312"></a>
        削除マークが付けられたレコードが <code class="literal">InnoDB</code> <span class="bold"><strong>パージ</strong></span>操作で処理されるようにスケジュールされている<span class="bold"><strong>トランザクション</strong></span>のリスト。 <span class="bold"><strong>Undo ログ</strong></span>に記録されます。 履歴リストの長さはコマンド <code class="literal">SHOW ENGINE INNODB STATUS</code> で報告されます。 履歴リストが <code class="literal">innodb_max_purge_lag</code> 構成オプションの値よりも長くなった場合、パージ操作が削除済みレコードの<span class="bold"><strong>フラッシュ</strong></span>を完了できるように各 <span class="bold"><strong>DML</strong></span> 操作が少し遅くなります。 
      </p><p>
        <span class="bold"><strong>パージラグ</strong></span>とも呼ばれます。
      </p><p><a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_purge">パージ</a>, <a class="glossseealso" href="glossary.html#glos_purge_lag">パージ遅延</a>, <a class="glossseealso" href="glossary.html#glos_rollback_segment">ロールバックセグメント</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_undo_log">Undo ログ</a>も参照</p></dd><dt><a name="glos_neighbor_page"></a><span class="glossterm">隣接ページ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762853696"></a>
        特定のページと同じ<span class="bold"><strong>エクステント</strong></span>内の<span class="bold"><strong>ページ</strong></span>。 ページが<span class="bold"><strong>フラッシュ</strong></span>の対象として選択されると、<span class="bold"><strong>ダーティー</strong></span>である隣接ページがある場合は、通常はそれらも従来ハードディスクの I/O 最適化としてフラッシュされます。 MySQL 5.6 以降では、この動作は構成変数 <code class="literal">innodb_flush_neighbors</code> で制御できます。小さなデータバッチをランダムな場所に書き込むため同じオーバーヘッドは発生しない SSD ドライブでは、この設定をオフにできます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_dirty_page">ダーティーページ</a>, <a class="glossseealso" href="glossary.html#glos_extent">エクステント</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">レ</h3><dl><dt><a name="glos_record_lock"></a><span class="glossterm">レコードロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762829440"></a>
        インデックスレコードでの<a class="link" href="glossary.html#glos_lock" title="ロック">ロック</a>。 たとえば、<code class="literal">SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;</code>では、他のトランザクションが <code class="literal">t.c1</code> の値が 10 の行を挿入、更新または削除できません。 <span class="bold"><strong>ギャップロック</strong></span>および<span class="bold"><strong>ネクストキーロック</strong></span>と対比してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_gap_lock">ギャップロック</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_next_key_lock">ネクストキーロック</a>も参照</p></dd><dt><a name="glos_repertoire"></a><span class="glossterm">レパートリー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762821536"></a>
        レパートリーは、文字セットに適用される用語です。 文字セットレパートリーは、セット内の文字の集合です。 <a class="xref" href="charset.html#charset-repertoire" title="10.2.1 文字セットレパートリー">セクション10.2.1「文字セットレパートリー」</a>を参照してください。 
      </p></dd><dt><a name="glos_replica"></a><span class="glossterm">レプリカ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762818256"></a>
        別のサーバー (<span class="bold"><strong>source</strong></span>) から変更を受け取り、同じ変更を適用する、<span class="bold"><strong>レプリケーション</strong></span>トポロジ内のデータベース <span class="bold"><strong>server</strong></span> マシン。 したがって、ソースと同じ内容が保持されますが、ある程度遅れてしまう可能性があります。 
      </p><p>
        MySQL では、障害時リカバリで、障害が発生したソースのかわりにレプリカが一般的に使用されます。 これらはまた一般に、データベース構成変更がパフォーマンスや信頼性の問題を起こさないことを保証するために、ソフトウェアアップグレードと新しい設定をテストする場合にも使用されます。 
      </p><p>
        レプリカは通常、ソースからリレーされたすべての <span class="bold"><strong>DML</strong></span> (書込み) 操作とユーザークエリーを処理するため、ワークロードが高くなります。 レプリカがソースの変更を十分な速度で適用できるように、多くの場合、高速 I/O デバイスと、同じサーバー上で複数のデータベースインスタンスを実行するのに十分な CPU およびメモリーを備えています。 たとえば、レプリカは <span class="bold"><strong>SSD</strong></span> を使用しますが、ソースはハードドライブストレージを使用します。 
      </p><p><a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_replication">レプリケーション</a>, <a class="glossseealso" href="glossary.html#glos_server">サーバー</a>, <a class="glossseealso" href="glossary.html#glos_source">source</a>, <a class="glossseealso" href="glossary.html#glos_ssd">SSD</a>も参照</p></dd><dt><a name="glos_replication"></a><span class="glossterm">レプリケーション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762806896"></a>
        すべてのデータベースが同じデータを持つように、<span class="bold"><strong>source</strong></span> から 1 つ以上の<span class="bold"><strong>レプリカ</strong></span>に変更を送信する方法。 この方法は、スケーラビリティー向上のためのロードバランシング、ディザスタリカバリ、ソフトウェアアップグレードおよび構成変更のテストなど、幅広く使用されます。 変更は、<span class="bold"><strong>行ベースのレプリケーション</strong></span>および<span class="bold"><strong>ステートメントベースレプリケーション</strong></span>と呼ばれるメソッドによってデータベース間で送信できます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_replica">レプリカ</a>, <a class="glossseealso" href="glossary.html#glos_row_based_replication">行ベースレプリケーション</a>, <a class="glossseealso" href="glossary.html#glos_source">source</a>, <a class="glossseealso" href="glossary.html#glos_statement_based_replication">ステートメントベースレプリケーション</a>も参照</p></dd><dt><a name="glos_exception_interceptor"></a><span class="glossterm">例外インターセプタ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762844080"></a>
        データベースアプリケーションで発生した SQL エラーをトレース、デバッグまたは拡張するための <span class="bold"><strong>interceptor</strong></span> のタイプ。 たとえば、インターセプタコードは、<code class="literal">SHOW WARNINGS</code> ステートメントを発行して追加情報を取得し、説明テキストを追加したり、アプリケーションに返される例外のタイプを変更することもできます。 インターセプタコードは、SQL ステートメントがエラーを返したときにのみ呼び出されるため、通常の (エラーのない) 操作中にアプリケーションのパフォーマンスペナルティは課されません。 
      </p><p>
        <span class="bold"><strong>Connector/J</strong></span> を使用する <span class="bold"><strong>Java</strong></span> アプリケーションでは、このタイプのインターセプタを設定するには、<code class="literal">com.mysql.jdbc.ExceptionInterceptor</code> インタフェースを実装し、<code class="literal">exceptionInterceptors</code> プロパティを<span class="bold"><strong>接続文字列</strong></span>に追加します。
      </p><p>
        <span class="bold"><strong>Connector/NET</strong></span> を使用する <span class="bold"><strong>Visual Studio</strong></span> アプリケーションでは、このタイプのインターセプタを設定するには、<code class="literal">BaseExceptionInterceptor</code> クラスから継承するクラスを定義し、そのクラス名を接続文字列の一部として指定する必要があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_connector_j">Connector/J</a>, <a class="glossseealso" href="glossary.html#glos_connector_net">Connector/NET</a>, <a class="glossseealso" href="glossary.html#glos_interceptor">interceptor</a>, <a class="glossseealso" href="glossary.html#glos_java">Java</a>, <a class="glossseealso" href="glossary.html#glos_visual_studio">Visual Studio</a>も参照</p></dd><dt><a name="glos_concatenated_index"></a><span class="glossterm">連結されたインデックス</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_composite_index">複合インデックス</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ロ</h3><dl><dt><a name="glos_log"></a><span class="glossterm">ログ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762774624"></a>
        <code class="literal">InnoDB</code> コンテキストでは、<span class="quote">「<span class="quote">log</span>」</span> または<span class="quote">「<span class="quote">「ログファイル」</span>」</span>は通常、<span class="bold"><strong>ib_logfile <em class="replaceable"><code>N</code></em></strong></span> ファイルによって表される<span class="bold"><strong>redo ログ</strong></span>を参照します。 別のタイプの <code class="literal">InnoDB</code> ログは、アクティブなトランザクションによって変更されたデータのコピーを保持する記憶域である<span class="bold"><strong>undo ログ</strong></span>です。 
      </p><p>
        MySQL で重要なほかの種類のログには、<span class="bold"><strong>エラーログ</strong></span> (起動および実行時の問題を診断するため), <span class="bold"><strong>バイナリログ</strong></span> (レプリケーションを操作し、特定時点のリストアを実行するため)、<span class="bold"><strong>一般クエリーログ</strong></span> (アプリケーションの問題を診断するため)、および<span class="bold"><strong>スロークエリーログ</strong></span> (パフォーマンスの問題を診断するため) があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_binary_log">バイナリログ</a>, <a class="glossseealso" href="glossary.html#glos_error_log">エラーログ</a>, <a class="glossseealso" href="glossary.html#glos_general_query_log">一般クエリーログ</a>, <a class="glossseealso" href="glossary.html#glos_ib_logfile">ib_logfile</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>, <a class="glossseealso" href="glossary.html#glos_slow_query_log">スロークエリーログ</a>, <a class="glossseealso" href="glossary.html#glos_undo_log">Undo ログ</a>も参照</p></dd><dt><a name="glos_log_group"></a><span class="glossterm">ロググループ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762759600"></a>
        <span class="bold"><strong>Redo ログ</strong></span>を構成するファイルのセット。通常、<code class="literal">ib_logfile0</code> および <code class="literal">ib_logfile1</code> の名前が付けられています。 (この理由のため、<span class="bold"><strong>ib_logfile</strong></span> と総称される場合があります。) 
      </p><p><a class="glossseealso" href="glossary.html#glos_ib_logfile">ib_logfile</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>も参照</p></dd><dt><a name="glos_log_buffer"></a><span class="glossterm">ログバッファー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762753136"></a>
        <span class="bold"><strong>Redo ログ</strong></span>を構成する<span class="bold"><strong>ログファイル</strong></span>に書き込まれるデータを保持するメモリー領域。 これは、<code class="literal">innodb_log_buffer_size</code> 構成オプションで制御されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_log_file">ログファイル</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>も参照</p></dd><dt><a name="glos_log_file"></a><span class="glossterm">ログファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762747200"></a>
        <span class="bold"><strong>Redo ログ</strong></span>を構成する <span class="bold"><strong>ib_logfile<em class="replaceable"><code>N</code></em></strong></span> ファイルの 1 つ。 データは、<span class="bold"><strong>ログバッファー</strong></span>メモリー領域からこれらのファイルに書き込まれます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_ib_logfile">ib_logfile</a>, <a class="glossseealso" href="glossary.html#glos_log_buffer">ログバッファー</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>も参照</p></dd><dt><a name="glos_lock"></a><span class="glossterm">ロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762740864"></a>
        <span class="bold"><strong>ロック</strong></span>戦略の一環として、テーブル、行、内部データ構造などのリソースへのアクセスを制御するオブジェクトの高レベル概念。 パフォーマンスを集中的にチューニングする場合は、<span class="bold"><strong>相互排他ロック</strong></span>や<span class="bold"><strong>ラッチ</strong></span>など、ロックを実装する実際の構造を徹底的に調べることができます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_latch">ラッチ</a>, <a class="glossseealso" href="glossary.html#glos_lock_mode">lock mode</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_mutex">相互排他ロック</a>も参照</p></dd><dt><a name="glos_locking"></a><span class="glossterm">ロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762734080"></a>
        ほかのトランザクションによって照会または変更されているデータを<span class="bold"><strong>トランザクション</strong></span>が見たり変更したりすることを防止するシステム。 <span class="bold"><strong>ロック</strong></span>戦略では、データベース操作の信頼性と一貫性 (<span class="bold"><strong>ACID</strong></span> 哲学の原則) と、良好な<span class="bold"><strong>同時実行性</strong></span>に必要なパフォーマンスのバランスをとる必要があります。 ロック戦略を調整するときは、多くの場合、<span class="bold"><strong>分離レベル</strong></span>を選択し、すべてのデータベース操作がその分離レベルについて安全で信頼性を持つことを保証する必要があります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_lock_escalation"></a><span class="glossterm">ロックエスカレーション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762724848"></a>
        一部のデータベースシステムで使用される操作で、多数の<span class="bold"><strong>行ロック</strong></span>を単一の<span class="bold"><strong>テーブルロック</strong></span>に変換し、メモリー領域を節約しますが、テーブルへの同時アクセスを削減します。 <code class="literal">InnoDB</code> では、行ロックに領域効率の高い表現が使用されるため、<span class="bold"><strong>lock</strong></span> エスカレーションは必要ありません。 
      </p><p><a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_row_lock">行ロック</a>, <a class="glossseealso" href="glossary.html#glos_table_lock">テーブルロック</a>も参照</p></dd><dt><a name="glos_locking_read"></a><span class="glossterm">ロック読み取り</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762717632"></a>
        <code class="literal">InnoDB</code> テーブルでの<span class="bold"><strong>ロック</strong></span>操作も実行する <code class="literal">SELECT</code> ステートメント。 <code class="literal">SELECT ... FOR UPDATE</code> または <code class="literal">SELECT ... LOCK IN SHARE MODE</code> のどちらか。 トランザクションの<span class="bold"><strong>分離レベル</strong></span>に応じて、<span class="bold"><strong>デッドロック</strong></span>を発生させる可能性があります。 <span class="bold"><strong>非ロック読み取り</strong></span>の反対。 <span class="bold"><strong>読み取り専用トランザクション</strong></span>内のグローバルテーブルには許可されません。 
      </p><p>
        MySQL 8.0.1 の <code class="literal">SELECT ... LOCK IN SHARE MODE</code> は <code class="literal">SELECT ... FOR SHARE</code> に置き換わりますが、<code class="literal">LOCK IN SHARE MODE</code> は下位互換性のために引き続き使用できます。
      </p><p>
        <a class="xref" href="innodb-storage-engine.html#innodb-locking-reads" title="15.7.2.4 読取りのロック">セクション15.7.2.4「読取りのロック」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_deadlock">デッドロック</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_non_locking_read">非ロック読み取り</a>, <a class="glossseealso" href="glossary.html#glos_read_only_transaction">読み取り専用トランザクション</a>も参照</p></dd><dt><a name="glos_load_balancing"></a><span class="glossterm">ロードバランシング</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762796960"></a>
        レプリケーションまたはクラスタ構成内の別のスレーブサーバーにクエリーリクエストを送信することによって、読み取り専用接続をスケーリングする方法。 <span class="bold"><strong>Connector/J</strong></span> では、ロードバランシングは <code class="literal">com.mysql.jdbc.ReplicationDriver</code> クラスを介して有効化され、構成プロパティ <code class="literal">loadBalanceStrategy</code> によって制御されます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_connector_j">Connector/J</a>, <a class="glossseealso" href="glossary.html#glos_j2ee">J2EE</a>も参照</p></dd><dt><a name="glos_rollback"></a><span class="glossterm">ロールバック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762790736"></a>
        <span class="bold"><strong>トランザクション</strong></span>が行なった変更を元に戻してトランザクションを終了する <span class="bold"><strong>SQL</strong></span> ステートメント。 これは、トランザクションで行われた変更を永続的にする<span class="bold"><strong>コミット</strong></span>の反対です。 
      </p><p>
        MySQL はデフォルトで、各 SQL ステートメントに続いてコミットを自動的に発行する<span class="bold"><strong>自動コミット</strong></span>設定を使用します。 ロールバック方法を使用する前に、この設定を変更する必要があります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_autocommit">自動コミット</a>, <a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_rollback_segment"></a><span class="glossterm">ロールバックセグメント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762781920"></a>
        <span class="bold"><strong>undo ログ</strong></span>を含む記憶域。 ロールバックセグメントは従来、<span class="bold"><strong>システムテーブルスペース</strong></span>に存在していました。 MySQL 5.6 では、ロールバックセグメントを<span class="bold"><strong>undo テーブルスペース</strong></span>に配置できます。 MySQL 5.7 では、ロールバックセグメントも<span class="emphasis"><em>グローバル一時テーブルスペース</em></span>に割り当てられます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_global_temporary_tablespace">グローバル一時テーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_undo_log">Undo ログ</a>, <a class="glossseealso" href="glossary.html#glos_undo_tablespace">Undo テーブルスペース</a>も参照</p></dd><dt><a name="glos_logical"></a><span class="glossterm">論理</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762701504"></a>
        テーブル、クエリー、インデックス、その他の SQL 概念など、高レベル抽象側面を含むタイプの操作。 論理側面は通常、データベース管理およびアプリケーション開発を便利で使用可能なものにするために重要です。 <span class="bold"><strong>物理</strong></span>と対比してください。 
      </p><p><a class="glossseealso" href="glossary.html#glos_logical_backup">論理バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_physical">物理</a>も参照</p></dd><dt><a name="glos_logical_backup"></a><span class="glossterm">論理バックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762696800"></a>
        実際のデータファイルをコピーせずにテーブル構造とデータを再生成する<span class="bold"><strong>バックアップ</strong></span>。 たとえば、<span class="bold"><strong><code class="literal">mysqldump</code></strong></span> コマンドは論理バックアップを生成します。その出力に、データを再作成できる <code class="literal">CREATE TABLE</code> や <code class="literal">INSERT</code> などのステートメントが含まれるためです。 <span class="bold"><strong>物理バックアップ</strong></span>と対比してください。 論理バックアップは柔軟性 (たとえば、リストア前に、テーブル定義を編集したりステートメントを挿入したりできます) を提供しますが、物理バックアップよりも<span class="bold"><strong>リストア</strong></span>にかなり長い時間がかかる可能性があります。 
      </p><p><a class="glossseealso" href="glossary.html#glos_backup">バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysqldump">mysqldump</a>, <a class="glossseealso" href="glossary.html#glos_physical_backup">物理バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_restore">リストア</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ワ</h3><dl><dt><a name="glos_workload"></a><span class="glossterm">ワークロード</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm46318762685632"></a>
        標準またはピーク使用時にデータベースアプリケーションによって実行される、<span class="bold"><strong>SQL</strong></span> およびほかのデータベース操作の組み合わせおよび量。 <span class="bold"><strong>ボトルネック</strong></span>を識別するパフォーマンステスト中や容量計画中に、データベースに特定のワークロードを課すことができます。 
      </p><p><a class="glossseealso" href="glossary.html#glos_bottleneck">ボトルネック</a>, <a class="glossseealso" href="glossary.html#glos_cpu_bound">CPU バウンド</a>, <a class="glossseealso" href="glossary.html#glos_disk_bound">ディスクバウンド</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>も参照</p></dd></dl></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="indexes.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> </td></tr><tr><td width="40%" align="left" valign="top">付録 C インデックス </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div><div class="copyright-footer"></div></body></html>
