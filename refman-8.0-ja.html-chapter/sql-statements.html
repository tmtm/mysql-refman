<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第 13 章 SQL ステートメント</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="MySQL 8.0 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 8.0 リファレンスマニュアル"><link rel="prev" href="functions.html" title="第 12 章 関数と演算子"><link rel="next" href="data-dictionary.html" title="第 14 章 MySQL データディクショナリ"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 13 章 SQL ステートメント</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="functions.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="data-dictionary.html">次へ</a></td></tr></table><hr></div><div class="status-header"><p class="alert">このページは機械翻訳したものです。</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="sql-statements"></a>第 13 章 SQL ステートメント</h1></div></div></div><div class="toc"><p><b>目次</b></p><dl class="toc"><dt><span class="section"><a href="sql-statements.html#sql-data-definition-statements">13.1 データ定義ステートメント</a></span></dt><dd><dl><dt><span class="section"><a href="sql-statements.html#atomic-ddl">13.1.1 アトミックデータ定義ステートメントのサポート</a></span></dt><dt><span class="section"><a href="sql-statements.html#alter-database">13.1.2 ALTER DATABASE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#alter-event">13.1.3 ALTER EVENT ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#alter-function">13.1.4 ALTER FUNCTION ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#alter-instance">13.1.5 ALTER INSTANCE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#alter-logfile-group">13.1.6 ALTER LOGFILE GROUP ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#alter-procedure">13.1.7 ALTER PROCEDURE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#alter-server">13.1.8 ALTER SERVER ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#alter-table">13.1.9 ALTER TABLE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#alter-tablespace">13.1.10 ALTER TABLESPACE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#alter-view">13.1.11 ALTER VIEW ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-database">13.1.12 CREATE DATABASE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-event">13.1.13 CREATE EVENT ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-function">13.1.14 CREATE FUNCTION ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-index">13.1.15 CREATE INDEX ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-logfile-group">13.1.16 CREATE LOGFILE GROUP ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-procedure">13.1.17 CREATE PROCEDURE ステートメントおよび CREATE FUNCTION ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-server">13.1.18 CREATE SERVER ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-spatial-reference-system">13.1.19 CREATE SPATIAL REFERENCE SYSTEM ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-table">13.1.20 CREATE TABLE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-tablespace">13.1.21 CREATE TABLESPACE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-trigger">13.1.22 CREATE TRIGGER ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-view">13.1.23 CREATE VIEW ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-database">13.1.24 DROP DATABASE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-event">13.1.25 DROP EVENT ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-function">13.1.26 DROP FUNCTION ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-index">13.1.27 DROP INDEX ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-logfile-group">13.1.28 DROP LOGFILE GROUP ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-procedure">13.1.29 DROP PROCEDURE および DROP FUNCTION ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-server">13.1.30 DROP SERVER ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-spatial-reference-system">13.1.31 DROP SPATIAL REFERENCE SYSTEM ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-table">13.1.32 DROP TABLE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-tablespace">13.1.33 DROP TABLESPACE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-trigger">13.1.34 DROP TRIGGER ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-view">13.1.35 DROP VIEW ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#rename-table">13.1.36 RENAME TABLE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#truncate-table">13.1.37 TRUNCATE TABLE ステートメント</a></span></dt></dl></dd><dt><span class="section"><a href="sql-statements.html#sql-data-manipulation-statements">13.2 データ操作ステートメント</a></span></dt><dd><dl><dt><span class="section"><a href="sql-statements.html#call">13.2.1 CALL ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#delete">13.2.2 DELETE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#do">13.2.3 DO ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#handler">13.2.4 HANDLER ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#import-table">13.2.5 IMPORT TABLE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#insert">13.2.6 INSERT ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#load-data">13.2.7 LOAD DATA ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#load-xml">13.2.8 LOAD XML ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#replace">13.2.9 REPLACE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#select">13.2.10 SELECT ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#subqueries">13.2.11 サブクエリー</a></span></dt><dt><span class="section"><a href="sql-statements.html#table">13.2.12 TABLE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#update">13.2.13 UPDATE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#values">13.2.14 VALUES ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#with">13.2.15 WITH (共通テーブル式)</a></span></dt></dl></dd><dt><span class="section"><a href="sql-statements.html#sql-transactional-statements">13.3 トランザクションステートメントおよびロックステートメント</a></span></dt><dd><dl><dt><span class="section"><a href="sql-statements.html#commit">13.3.1 START TRANSACTION、COMMIT および ROLLBACK ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#cannot-roll-back">13.3.2 ロールバックできないステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#implicit-commit">13.3.3 暗黙的なコミットを発生させるステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#savepoint">13.3.4 SAVEPOINT、ROLLBACK TO SAVEPOINT および RELEASE SAVEPOINT ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#lock-instance-for-backup">13.3.5 LOCK INSTANCE FOR BACKUP および UNLOCK INSTANCE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#lock-tables">13.3.6 LOCK TABLES および UNLOCK TABLES ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#set-transaction">13.3.7 SET TRANSACTION ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#xa">13.3.8 XA トランザクション</a></span></dt></dl></dd><dt><span class="section"><a href="sql-statements.html#sql-replication-statements">13.4 レプリケーションステートメント</a></span></dt><dd><dl><dt><span class="section"><a href="sql-statements.html#replication-statements-master">13.4.1 ソースサーバーを制御する SQL ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#replication-statements-replica">13.4.2 レプリケーションサーバーを制御するための SQL ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#replication-statements-group">13.4.3 グループレプリケーションを制御するための SQL ステートメント</a></span></dt></dl></dd><dt><span class="section"><a href="sql-statements.html#sql-prepared-statements">13.5 プリペアドステートメント</a></span></dt><dd><dl><dt><span class="section"><a href="sql-statements.html#prepare">13.5.1 PREPARE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#execute">13.5.2 EXECUTE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#deallocate-prepare">13.5.3 DEALLOCATE PREPARE ステートメント</a></span></dt></dl></dd><dt><span class="section"><a href="sql-statements.html#sql-compound-statements">13.6 複合ステートメントの構文</a></span></dt><dd><dl><dt><span class="section"><a href="sql-statements.html#begin-end">13.6.1 BEGIN ... END 複合ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#statement-labels">13.6.2 ステートメントラベル</a></span></dt><dt><span class="section"><a href="sql-statements.html#declare">13.6.3 DECLARE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#stored-program-variables">13.6.4 ストアドプログラム内の変数</a></span></dt><dt><span class="section"><a href="sql-statements.html#flow-control-statements">13.6.5 フロー制御ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#cursors">13.6.6 カーソル</a></span></dt><dt><span class="section"><a href="sql-statements.html#condition-handling">13.6.7 条件の処理</a></span></dt><dt><span class="section"><a href="sql-statements.html#condition-handling-restrictions">13.6.8 条件処理の制約</a></span></dt></dl></dd><dt><span class="section"><a href="sql-statements.html#sql-server-administration-statements">13.7 データベース管理ステートメント</a></span></dt><dd><dl><dt><span class="section"><a href="sql-statements.html#account-management-statements">13.7.1 アカウント管理ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#resource-group-statements">13.7.2 リソースグループ管理ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#table-maintenance-statements">13.7.3 テーブル保守ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#component-statements">13.7.4 コンポーネント、プラグインおよびユーザー定義関数のステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#clone">13.7.5 CLONE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#set-statement">13.7.6 SET ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show">13.7.7 SHOW ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#other-administrative-statements">13.7.8 その他の管理ステートメント</a></span></dt></dl></dd><dt><span class="section"><a href="sql-statements.html#sql-utility-statements">13.8 ユーティリティステートメント</a></span></dt><dd><dl><dt><span class="section"><a href="sql-statements.html#describe">13.8.1 DESCRIBE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#explain">13.8.2 EXPLAIN ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#help">13.8.3 HELP ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#use">13.8.4 USE ステートメント</a></span></dt></dl></dd></dl></div><p>
    この章では、MySQL によってサポートされる <a class="link" href="glossary.html#glos_sql" title="SQL">SQL</a> ステートメントの構文について説明します。
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sql-data-definition-statements"></a>13.1 データ定義ステートメント</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#atomic-ddl">13.1.1 アトミックデータ定義ステートメントのサポート</a></span></dt><dt><span class="section"><a href="sql-statements.html#alter-database">13.1.2 ALTER DATABASE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#alter-event">13.1.3 ALTER EVENT ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#alter-function">13.1.4 ALTER FUNCTION ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#alter-instance">13.1.5 ALTER INSTANCE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#alter-logfile-group">13.1.6 ALTER LOGFILE GROUP ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#alter-procedure">13.1.7 ALTER PROCEDURE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#alter-server">13.1.8 ALTER SERVER ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#alter-table">13.1.9 ALTER TABLE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#alter-tablespace">13.1.10 ALTER TABLESPACE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#alter-view">13.1.11 ALTER VIEW ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-database">13.1.12 CREATE DATABASE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-event">13.1.13 CREATE EVENT ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-function">13.1.14 CREATE FUNCTION ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-index">13.1.15 CREATE INDEX ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-logfile-group">13.1.16 CREATE LOGFILE GROUP ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-procedure">13.1.17 CREATE PROCEDURE ステートメントおよび CREATE FUNCTION ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-server">13.1.18 CREATE SERVER ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-spatial-reference-system">13.1.19 CREATE SPATIAL REFERENCE SYSTEM ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-table">13.1.20 CREATE TABLE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-tablespace">13.1.21 CREATE TABLESPACE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-trigger">13.1.22 CREATE TRIGGER ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-view">13.1.23 CREATE VIEW ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-database">13.1.24 DROP DATABASE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-event">13.1.25 DROP EVENT ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-function">13.1.26 DROP FUNCTION ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-index">13.1.27 DROP INDEX ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-logfile-group">13.1.28 DROP LOGFILE GROUP ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-procedure">13.1.29 DROP PROCEDURE および DROP FUNCTION ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-server">13.1.30 DROP SERVER ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-spatial-reference-system">13.1.31 DROP SPATIAL REFERENCE SYSTEM ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-table">13.1.32 DROP TABLE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-tablespace">13.1.33 DROP TABLESPACE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-trigger">13.1.34 DROP TRIGGER ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-view">13.1.35 DROP VIEW ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#rename-table">13.1.36 RENAME TABLE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#truncate-table">13.1.37 TRUNCATE TABLE ステートメント</a></span></dt></dl></div><a class="indexterm" name="idm45827008158832"></a><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="atomic-ddl"></a>13.1.1 アトミックデータ定義ステートメントのサポート</h3></div></div></div><a class="indexterm" name="idm45827008156368"></a><a class="indexterm" name="idm45827008155376"></a><p>
      MySQL 8.0 では、アトミックデータ定義言語 (DDL) ステートメントがサポートされます。 この機能は、<span class="emphasis"><em>アトミック DDL</em></span>と呼ばれます。 アトミック DDL ステートメントは、DDL 操作に関連するデータディクショナリ更新、ストレージエンジン操作およびバイナリログ書き込みを単一のアトミックトランザクションとして結び付けます。 操作は、データディクショナリ、ストレージエンジンおよびバイナリログに適用可能な変更を保持してコミットされるか、操作中にサーバーが停止した場合でもロールバックされます。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <span class="emphasis"><em>アトミック DDL</em></span>は<span class="emphasis"><em>トランザクション DDL</em></span>ではありません。 DDL ステートメント、アトミックまたはそれ以外の場合は、ステートメントを実行する前に <code class="literal">COMMIT</code> を実行したかのように、現在のセッションでアクティブなトランザクションを暗黙的に終了します。 つまり、DDL ステートメントは、別のトランザクション内、<code class="literal">START TRANSACTION ... COMMIT</code> などのトランザクション制御ステートメント内、または同じトランザクション内の他のステートメントと組み合せることはできません。 
      </p></div><p>
      アトミック DDL は、MySQL 8.0 で MySQL データディクショナリを導入することで可能になります。 以前の MySQL バージョンでは、メタデータはメタデータファイル、非トランザクションテーブル、および中間コミットを必要とするストレージエンジン固有のディクショナリに格納されていました。 MySQL データディクショナリによって提供される集中化されたトランザクションメタデータ記憶域により、このバリアが削除され、DDL ステートメントの操作をアトミックに再構築できるようになりました。 
    </p><p>
      アトミック DDL 機能については、このセクションの次のトピックで説明します:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#atomic-ddl-supported-statements" title="サポートされている DDL ステートメント">サポートされている DDL ステートメント</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#atomic-ddl-characteristics" title="アトミック DDL の特性">アトミック DDL の特性</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#atomic-ddl-statement-behavior" title="DDL ステートメントの動作の変更">DDL ステートメントの動作の変更</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#atomic-ddl-storage-engine-support" title="ストレージエンジンのサポート">ストレージエンジンのサポート</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#atomic-ddl-view-logs" title="DDL ログの表示">DDL ログの表示</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="atomic-ddl-supported-statements"></a>サポートされている DDL ステートメント</h4></div></div></div><p>
        アトミック DDL 機能では、テーブル DDL ステートメントと非テーブル DDL ステートメントの両方がサポートされています。 テーブル関連の DDL 操作ではストレージエンジンのサポートが必要ですが、テーブル以外の DDL 操作では必要ありません。 現在、<code class="literal">InnoDB</code> ストレージエンジンのみがアトミック DDL をサポートしています。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            サポートされているテーブル DDL ステートメントには、データベース、テーブルスペース、テーブルおよびインデックスに対する <code class="literal">CREATE</code>、<code class="literal">ALTER</code> および <code class="literal">DROP</code> ステートメントと、<code class="literal">TRUNCATE TABLE</code> ステートメントが含まれます。
          </p></li><li class="listitem"><p>
            サポートされているテーブル以外の DDL ステートメントは次のとおりです:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">CREATE</code> ステートメントと <code class="literal">DROP</code> ステートメント、および該当する場合はストアドプログラム、トリガー、ビューおよびユーザー定義関数 (UDF) の <code class="literal">ALTER</code> ステートメント。
              </p></li><li class="listitem"><p>
                アカウント管理ステートメント: <code class="literal">CREATE</code>, <code class="literal">ALTER</code>, <code class="literal">DROP</code>、および該当する場合は、ユーザーおよびロール用の <code class="literal">RENAME</code> ステートメントと、<code class="literal">GRANT</code> および <code class="literal">REVOKE</code> ステートメント。
              </p></li></ul></div></li></ul></div><p>
        次のステートメントは、アトミック DDL 機能ではサポートされていません:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">InnoDB</code> 以外のストレージエンジンを含むテーブル関連の DDL ステートメント。
          </p></li><li class="listitem"><p>
            <code class="literal">INSTALL PLUGIN</code> および <code class="literal">UNINSTALL PLUGIN</code> ステートメント。
          </p></li><li class="listitem"><p>
            <code class="literal">INSTALL COMPONENT</code> および <code class="literal">UNINSTALL COMPONENT</code> ステートメント。
          </p></li><li class="listitem"><p>
            <code class="literal">CREATE SERVER</code>、<code class="literal">ALTER SERVER</code> および <code class="literal">DROP SERVER</code> ステートメント。
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="atomic-ddl-characteristics"></a>アトミック DDL の特性</h4></div></div></div><p>
        アトミック DDL ステートメントの特性は次のとおりです:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            メタデータの更新、バイナリログの書き込み、およびストレージエンジンの操作 (該当する場合) は、単一の原子性操作に結合されます。
          </p></li><li class="listitem"><p>
            DDL 操作中、SQL レイヤーに中間コミットはありません。
          </p></li><li class="listitem"><p>
            該当する場合:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                データディクショナリ、ルーチン、イベントおよび UDF キャッシュの状態は、DDL 操作のステータスと一貫性があります。つまり、DDL 操作が正常に完了したかロールバックされたかを反映するようにキャッシュが更新されます。
              </p></li><li class="listitem"><p>
                DDL 操作に関連するストレージエンジンのメソッドは中間コミットを実行せず、ストレージエンジンはそれ自体を DDL 操作の一部として登録します。
              </p></li><li class="listitem"><p>
                ストレージエンジンは、DDL 操作の <span class="emphasis"><em>Post-DDL</em></span> フェーズで実行される DDL 操作の redo およびロールバックをサポートしています。
              </p></li></ul></div></li><li class="listitem"><p>
            DDL 操作の表示可能な動作はアトミックで、一部の DDL ステートメントの動作が変更されます。 <a class="xref" href="sql-statements.html#atomic-ddl-statement-behavior" title="DDL ステートメントの動作の変更">DDL ステートメントの動作の変更</a>を参照してください。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="atomic-ddl-statement-behavior"></a>DDL ステートメントの動作の変更</h4></div></div></div><p>
        このセクションでは、アトミック DDL サポートの導入による DDL ステートメントの動作の変更について説明します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            すべての名前付きテーブルがアトミック DDL でサポートされているストレージエンジンを使用している場合、<code class="literal">DROP TABLE</code> 操作は完全にアトミックです。 このステートメントは、すべてのテーブルを正常に削除するか、ロールバックします。 
          </p><p>
            指定されたテーブルが存在せず、ストレージエンジンに関係なく変更が行われない場合、<code class="literal">DROP TABLE</code> はエラーで失敗します。 次の例では、指定したテーブルが存在しないために <code class="literal">DROP TABLE</code> ステートメントが失敗する動作の変更を示します: 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT);</code></strong>
mysql&gt; <strong class="userinput"><code>DROP TABLE t1, t2;</code></strong>
ERROR 1051 (42S02): Unknown table 'test.t2'
mysql&gt; <strong class="userinput"><code>SHOW TABLES;</code></strong>
+----------------+
| Tables_in_test |
+----------------+
| t1             |
+----------------+
</pre><p>
            アトミック DDL が導入される前に、<code class="literal">DROP TABLE</code> は、存在しないが、存在する名前付きテーブルに対して成功した名前付きテーブルのエラーを報告します:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT);</code></strong>
mysql&gt; <strong class="userinput"><code>DROP TABLE t1, t2;</code></strong>
ERROR 1051 (42S02): Unknown table 'test.t2'
mysql&gt; <strong class="userinput"><code>SHOW TABLES;</code></strong>
Empty set (0.00 sec)
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              この動作の変更のため、MySQL 8.0 レプリカにレプリケートすると、MySQL 5.7 レプリケーションソースサーバーで部分的に完了した <code class="literal">DROP TABLE</code> ステートメントが失敗します。 この失敗のシナリオを回避するには、<code class="literal">DROP TABLE</code> ステートメントで <code class="literal">IF EXISTS</code> 構文を使用して、存在しないテーブルに対してエラーが発生しないようにします。 
            </p></div></li><li class="listitem"><p>
            すべてのテーブルがアトミック DDL でサポートされているストレージエンジンを使用する場合、<code class="literal">DROP DATABASE</code> はアトミックです。 このステートメントは、すべてのオブジェクトを正常に削除するか、ロールバックします。 ただし、ファイルシステムからのデータベースディレクトリの削除は最後に行われ、アトミック操作の一部ではありません。 ファイルシステムエラーまたはサーバーの停止が原因でデータベースディレクトリの削除に失敗した場合、<code class="literal">DROP DATABASE</code> トランザクションはロールバックされません。 
          </p></li><li class="listitem"><p>
            アトミック DDL でサポートされているストレージエンジンを使用しないテーブルの場合、テーブルの削除はアトミック <code class="literal">DROP TABLE</code> または <code class="literal">DROP DATABASE</code> トランザクションの外部で行われます。 このようなテーブルの削除はバイナリログに個別に書き込まれるため、<code class="literal">DROP TABLE</code> または <code class="literal">DROP DATABASE</code> 操作が中断された場合は、ストレージエンジン、データディクショナリ、およびバイナリログ間の相違が最大で 1 つのテーブルに制限されます。 複数のテーブルを削除する操作の場合、アトミック DDL でサポートされているストレージエンジンを使用しないテーブルは、それを実行するテーブルの前に削除されます。 
          </p></li><li class="listitem"><p>
            アトミック DDL でサポートされているストレージエンジンを使用するテーブルに対する <code class="literal">CREATE TABLE</code>, <code class="literal">ALTER TABLE</code>, <code class="literal">RENAME TABLE</code>, <code class="literal">TRUNCATE TABLE</code>, <code class="literal">CREATE TABLESPACE</code>、および <code class="literal">DROP TABLESPACE</code> 操作は、その操作中にサーバーが停止すると、完全にコミットまたはロールバックされます。 以前の MySQL リリースでは、これらの操作が中断されると、ストレージエンジン、データディクショナリ、およびバイナリログ間の不一致が発生したり、孤立したファイルの背後に残されたりする可能性がありました。 <code class="literal">RENAME TABLE</code> 操作は、すべての名前付きテーブルがアトミック DDL でサポートされているストレージエンジンを使用している場合にのみアトミックです。 
          </p></li><li class="listitem"><p>
            MySQL 8.0.21 の時点では、アトミック DDL をサポートするストレージエンジンでは、行ベースレプリケーションが使用されているときに、<code class="literal">CREATE TABLE ... SELECT</code> ステートメントがバイナリログに 1 つのトランザクションとして記録されます。 以前は、2 つのトランザクションとしてログに記録されていました。1 つはテーブルの作成用、もう 1 つはデータの挿入用です。 2 つのトランザクション間またはデータの挿入中にサーバー障害が発生すると、空のテーブルがレプリケーションされる可能性があります。 アトミック DDL サポートの導入により、<code class="literal">CREATE TABLE ... SELECT</code> ステートメントは行ベースレプリケーションに対して安全であり、GTID ベースレプリケーションでの使用が許可されるようになりました。 
          </p><p>
            アトミック DDL 制約と外部キー制約の両方をサポートするストレージエンジンでは、行ベースレプリケーションが使用されている場合、<code class="literal">CREATE TABLE ... SELECT</code> ステートメントで外部キーの作成は許可されません。 外部キー制約は、後で <code class="literal">ALTER TABLE</code> を使用して追加できます。 
          </p><p>
            <code class="literal">CREATE TABLE ... SELECT</code> がアトミック操作として適用されると、データの挿入中にメタデータロックがテーブルに保持され、操作中にテーブルへの同時アクセスが防止されます。
          </p></li><li class="listitem"><p>
            名前付きビューが存在せず、変更が行われない場合、<code class="literal">DROP VIEW</code> は失敗します。 この例では、名前付きビューが存在しないために <code class="literal">DROP VIEW</code> ステートメントが失敗する動作の変更を示します: 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE VIEW test.viewA AS SELECT * FROM t;</code></strong>
mysql&gt; <strong class="userinput"><code>DROP VIEW test.viewA, test.viewB;</code></strong>
ERROR 1051 (42S02): Unknown table 'test.viewB'
mysql&gt; <strong class="userinput"><code>SHOW FULL TABLES IN test WHERE TABLE_TYPE LIKE 'VIEW';</code></strong>
+----------------+------------+
| Tables_in_test | Table_type |
+----------------+------------+
| viewA          | VIEW       |
+----------------+------------+
</pre><p>
            アトミック DDL が導入される前に、<code class="literal">DROP VIEW</code> は、存在しないが、存在する名前付きビューに対して成功した名前付きビューに対してエラーを返します:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE VIEW test.viewA AS SELECT * FROM t;</code></strong>
mysql&gt; <strong class="userinput"><code>DROP VIEW test.viewA, test.viewB;</code></strong>
ERROR 1051 (42S02): Unknown table 'test.viewB'
mysql&gt; <strong class="userinput"><code>SHOW FULL TABLES IN test WHERE TABLE_TYPE LIKE 'VIEW';</code></strong>
Empty set (0.00 sec)
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              この動作の変更のため、MySQL 8.0 レプリカでレプリケートすると、MySQL 5.7 レプリケーションソースサーバーで部分的に完了した <code class="literal">DROP VIEW</code> 操作が失敗します。 この失敗のシナリオを回避するには、<code class="literal">DROP VIEW</code> ステートメントで <code class="literal">IF EXISTS</code> 構文を使用して、存在しないビューに対してエラーが発生しないようにします。 
            </p></div></li><li class="listitem"><p>
            アカウント管理ステートメントの部分実行は許可されなくなりました。 アカウント管理ステートメントは、指定されたすべてのユーザーに対して成功するか、ロールバックされ、エラーが発生しても効果はありません。 以前の MySQL バージョンでは、複数のユーザーを指定するアカウント管理ステートメントは、一部のユーザーでは成功し、他のユーザーでは失敗する可能性がありました。 
          </p><p>
            この例では、動作の変更が示されています。この例では、2 番目の <code class="literal">CREATE USER</code> ステートメントはエラーを返しますが、すべての名前付きユーザーが成功するわけではないため、失敗します。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE USER userA;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE USER userA, userB;</code></strong>
ERROR 1396 (HY000): Operation CREATE USER failed for 'userA'@'%'
mysql&gt; <strong class="userinput"><code>SELECT User FROM mysql.user WHERE User LIKE 'user%';</code></strong>
+-------+
| User  |
+-------+
| userA |
+-------+
</pre><p>
            アトミック DDL が導入される前に、2 番目の <code class="literal">CREATE USER</code> ステートメントは、存在しないが、存在する名前付きユーザーに対して成功した名前付きユーザーに対してエラーを返します:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE USER userA;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE USER userA, userB;</code></strong>
ERROR 1396 (HY000): Operation CREATE USER failed for 'userA'@'%'
mysql&gt; <strong class="userinput"><code>SELECT User FROM mysql.user WHERE User LIKE 'user%';</code></strong>
+-------+
| User  |
+-------+
| userA |
| userB |
+-------+
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              この動作の変更のため、MySQL 8.0 レプリカでレプリケートすると、MySQL 5.7 レプリケーションソースサーバーで部分的に完了したアカウント管理ステートメントが失敗します。 この失敗のシナリオを回避するには、アカウント管理ステートメントで必要に応じて <code class="literal">IF EXISTS</code> または <code class="literal">IF NOT EXISTS</code> 構文を使用して、名前付きユーザーに関連するエラーを防止します。 
            </p></div></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="atomic-ddl-storage-engine-support"></a>ストレージエンジンのサポート</h4></div></div></div><p>
        現在、<code class="literal">InnoDB</code> ストレージエンジンのみがアトミック DDL をサポートしています。 アトミック DDL をサポートしないストレージエンジンは、DDL アトミック性から除外されます。 除外されたストレージエンジンに関連する DDL 操作は、操作が中断されたとき、または部分的にしか完了しなかったときに発生する可能性のある不整合を引き起こすことができます。 
      </p><p>
        DDL 操作の redo およびロールバックをサポートするために、<code class="literal">InnoDB</code> は、<code class="filename">mysql.ibd</code> データディクショナリテーブルスペースに存在する非表示のデータディクショナリテーブルである <code class="literal">mysql.innodb_ddl_log</code> テーブルに DDL ログを書き込みます。
      </p><p>
        DDL 操作中に <code class="literal">mysql.innodb_ddl_log</code> テーブルに書き込まれる DDL ログを表示するには、<code class="literal">innodb_print_ddl_logs</code> 構成オプションを有効にします。 詳細は、<a class="xref" href="sql-statements.html#atomic-ddl-view-logs" title="DDL ログの表示">DDL ログの表示</a>を参照してください。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">mysql.innodb_ddl_log</code> テーブルに対する変更の redo ログは、<code class="literal">innodb_flush_log_at_trx_commit</code> の設定に関係なく、すぐにディスクにフラッシュされます。 redo ログをすぐにフラッシュすると、DDL 操作によってデータファイルが変更される状況を回避できますが、これらの操作によって生成された <code class="literal">mysql.innodb_ddl_log</code> テーブルに対する変更の redo ログはディスクに永続化されません。 このような状況では、ロールバックまたはリカバリ中にエラーが発生する可能性があります。 
        </p></div><p>
        <code class="literal">InnoDB</code> ストレージエンジンは、DDL 操作をフェーズで実行します。 <code class="literal">ALTER TABLE</code> などの DDL 操作では、<span class="emphasis"><em>Commit</em></span> フェーズの前に<span class="emphasis"><em>準備</em></span>および <span class="emphasis"><em>Perform</em></span> フェーズを複数回実行できます。 
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <span class="emphasis"><em>準備</em></span>: 必要なオブジェクトを作成し、DDL ログを <code class="literal">mysql.innodb_ddl_log</code> テーブルに書き込みます。 DDL ログは、DDL 操作をロールフォワードおよびロールバックする方法を定義します。 
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>Perform</em></span>: DDL 操作を実行します。 たとえば、<code class="literal">CREATE TABLE</code> 操作の作成ルーチンを実行します。 
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>Commit</em></span>: データディクショナリを更新し、データディクショナリのトランザクションをコミットします。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>Post-DDL</em></span>: DDL ログをリプレイし、<code class="literal">mysql.innodb_ddl_log</code> テーブルから削除します。 不整合を引き起こさずにロールバックを安全に実行できるように、データファイルの名前変更や削除などのファイル操作はこの最終フェーズで実行されます。 このフェーズでは、<code class="literal">DROP TABLE</code>、<code class="literal">TRUNCATE TABLE</code> およびテーブルを再構築するその他の DDL 操作のために、<code class="literal">mysql.innodb_dynamic_metadata</code> データディクショナリテーブルから動的メタデータも削除します。 
          </p></li></ol></div><p>
        DDL 操作がコミットされているかロールバックされているかに関係なく、<span class="emphasis"><em>Post-DDL</em></span> フェーズ中に DDL ログがリプレイされ、<code class="literal">mysql.innodb_ddl_log</code> テーブルから削除されます。 DDL ログは、DDL 操作中にサーバーが停止した場合にのみ <code class="literal">mysql.innodb_ddl_log</code> テーブルに残す必要があります。 この場合、DDL ログはリカバリ後にリプレイおよび削除されます。 
      </p><p>
        リカバリ状況では、サーバーの再起動時に DDL 操作をコミットまたはロールバックできます。 DDL 操作の <span class="emphasis"><em>Commit</em></span> フェーズで実行されたデータディクショナリトランザクションが redo ログおよびバイナリログに存在する場合、操作は成功したとみなされ、ロールフォワードされます。 それ以外の場合、<code class="literal">InnoDB</code> がデータディクショナリ redo ログをリプレイし、DDL 操作がロールバックされると、不完全なデータディクショナリトランザクションがロールバックされます。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="atomic-ddl-view-logs"></a>DDL ログの表示</h4></div></div></div><p>
        <code class="literal">InnoDB</code> ストレージエンジンに関連するアトミック DDL 操作中に <code class="literal">mysql.innodb_ddl_log</code> データディクショナリテーブルに書き込まれる DDL ログを表示するには、<code class="literal">innodb_print_ddl_logs</code> で MySQL に <code class="literal">stderr</code> への DDL ログの書込みを許可します。 ホストのオペレーティングシステムおよび MySQL の構成によっては、<code class="literal">stderr</code> がエラーログ、端末またはコンソールウィンドウである場合があります。 <a class="xref" href="server-administration.html#error-log-destination-configuration" title="5.4.2.2 デフォルトのエラーログ保存先の構成">セクション5.4.2.2「デフォルトのエラーログ保存先の構成」</a>を参照してください。 
      </p><p>
        <code class="literal">InnoDB</code> は、DDL 操作の redo およびロールバックをサポートするために、DDL ログを <code class="literal">mysql.innodb_ddl_log</code> テーブルに書き込みます。 <code class="literal">mysql.innodb_ddl_log</code> テーブルは、<code class="filename">mysql.ibd</code> データディクショナリテーブルスペースに存在する非表示のデータディクショナリテーブルです。 他の非表示のデータディクショナリテーブルと同様に、MySQL の非デバッグバージョンでは <code class="literal">mysql.innodb_ddl_log</code> テーブルに直接アクセスできません。 (<a class="xref" href="data-dictionary.html#data-dictionary-schema" title="14.1 データディクショナリスキーマ">セクション14.1「データディクショナリスキーマ」</a>を参照してください。) <code class="literal">mysql.innodb_ddl_log</code> テーブルの構造は、次の定義に対応します: 
      </p><pre class="programlisting">CREATE TABLE mysql.innodb_ddl_log (
  id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  thread_id BIGINT UNSIGNED NOT NULL,
  type INT UNSIGNED NOT NULL,
  space_id INT UNSIGNED,
  page_no INT UNSIGNED,
  index_id BIGINT UNSIGNED,
  table_id BIGINT UNSIGNED,
  old_file_path VARCHAR(512) COLLATE UTF8_BIN,
  new_file_path VARCHAR(512) COLLATE UTF8_BIN,
  KEY(thread_id)
);
</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">id</code>: DDL ログレコードの一意の識別子。
          </p></li><li class="listitem"><p>
            <code class="literal">thread_id</code>: 各 DDL ログレコードには、特定の DDL 操作に属する DDL ログのリプレイおよび削除に使用される <code class="literal">thread_id</code> が割り当てられます。 複数のデータファイル操作を含む DDL 操作では、複数の DDL ログレコードが生成されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">type</code>: DDL 操作タイプ。 タイプには、<code class="literal">FREE</code> (インデックスツリーの削除)、<code class="literal">DELETE</code> (ファイルの削除)、<code class="literal">RENAME</code> (ファイルの名前変更) または <code class="literal">DROP</code> (<code class="literal">mysql.innodb_dynamic_metadata</code> データディクショナリテーブルからのメタデータの削除) があります。 
          </p></li><li class="listitem"><p>
            <code class="literal">space_id</code>: テーブルスペース ID。
          </p></li><li class="listitem"><p>
            <code class="literal">page_no</code>: 割当て情報を含むページ。たとえば、インデックスツリーのルートページです。
          </p></li><li class="listitem"><p>
            <code class="literal">index_id</code>: インデックス ID。
          </p></li><li class="listitem"><p>
            <code class="literal">table_id</code>: テーブル ID。
          </p></li><li class="listitem"><p>
            <code class="literal">old_file_path</code>: 古いテーブルスペースのファイルパス。 テーブルスペースファイルを作成または削除する DDL 操作で使用されます。テーブルスペースの名前を変更する DDL 操作でも使用されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">new_file_path</code>: 新しいテーブルスペースファイルのパス。 テーブルスペースファイルの名前を変更する DDL 操作で使用されます。 
          </p></li></ul></div><p>
        この例では、<code class="literal">CREATE TABLE</code> 操作のために <code class="literal">strderr</code> に書き込まれた DDL ログを <code class="literal">innodb_print_ddl_logs</code> で表示できるようにする方法を示します。
      </p><pre class="programlisting">mysql&gt; SET GLOBAL innodb_print_ddl_logs=1;
mysql&gt; CREATE TABLE t1 (c1 INT) ENGINE = InnoDB;
</pre><pre class="programlisting">[Note] [000000] InnoDB: DDL log insert : [DDL record: DELETE SPACE, id=18, thread_id=7,
space_id=5, old_file_path=./test/t1.ibd]
[Note] [000000] InnoDB: DDL log delete : by id 18
[Note] [000000] InnoDB: DDL log insert : [DDL record: REMOVE CACHE, id=19, thread_id=7,
table_id=1058, new_file_path=test/t1]
[Note] [000000] InnoDB: DDL log delete : by id 19
[Note] [000000] InnoDB: DDL log insert : [DDL record: FREE, id=20, thread_id=7,
space_id=5, index_id=132, page_no=4]
[Note] [000000] InnoDB: DDL log delete : by id 20
[Note] [000000] InnoDB: DDL log post ddl : begin for thread id : 7
[Note] [000000] InnoDB: DDL log post ddl : end for thread id : 7
</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-database"></a>13.1.2 ALTER DATABASE ステートメント</h3></div></div></div><a class="indexterm" name="idm45827007939616"></a><a class="indexterm" name="idm45827007938304"></a><a class="indexterm" name="idm45827007936960"></a><a class="indexterm" name="idm45827007934816"></a><a class="indexterm" name="idm45827007932784"></a><a class="indexterm" name="idm45827007930752"></a><pre class="programlisting">ALTER {DATABASE | SCHEMA} [<em class="replaceable"><code>db_name</code></em>]
    <em class="replaceable"><code>alter_option</code></em> ...

<em class="replaceable"><code>alter_option</code></em>: {
    [DEFAULT] CHARACTER SET [=] <em class="replaceable"><code>charset_name</code></em>
  | [DEFAULT] COLLATE [=] <em class="replaceable"><code>collation_name</code></em>
  | [DEFAULT] ENCRYPTION [=] {'Y' | 'N'}
  | READ ONLY [=] {DEFAULT | 0 | 1}
}
</pre><p>
      <code class="literal">ALTER DATABASE</code> を使用すると、データベースの全体的な特性を変更できます。 これらの特性はデータディクショナリに格納されます。 このステートメントには、データベースに対する <code class="literal">ALTER</code> 権限が必要です。 <code class="literal">ALTER SCHEMA</code> は <code class="literal">ALTER DATABASE</code> のシノニムです。 
    </p><p>
      データベース名を省略すると、ステートメントはデフォルトのデータベースに適用されます。 その場合、デフォルトのデータベースがないとエラーが発生します。 
    </p><p>
      ステートメントから省略された <em class="replaceable"><code>alter_option</code></em> の場合、データベースでは現在のオプション値が保持されますが、文字セットを変更すると照合順序が変更される場合とその逆があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#alter-database-charset" title="文字セットと照合順序のオプション">文字セットと照合順序のオプション</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#alter-database-encryption" title="暗号化オプション">暗号化オプション</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#alter-database-read-only" title="読取り専用オプション">読取り専用オプション</a></p></li></ul></div><h4><a name="alter-database-charset"></a>文字セットと照合順序のオプション</h4><p>
      <code class="literal">CHARACTER SET</code> オプションは、デフォルトのデータベース文字セットを変更します。 <code class="literal">COLLATE</code> オプションは、デフォルトのデータベース照合順序を変更します。 文字セットおよび照合順序名の詳細は、<a class="xref" href="charset.html" title="第 10 章 文字セット、照合順序、Unicode">第10章「<i>文字セット、照合順序、Unicode</i>」</a> を参照してください。 
    </p><p>
      使用可能な文字セットおよび照合順序を確認するには、それぞれ <code class="literal">SHOW CHARACTER SET</code> ステートメントおよび <code class="literal">SHOW COLLATION</code> ステートメントを使用します。 <a class="xref" href="sql-statements.html#show-character-set" title="13.7.7.3 SHOW CHARACTER SET ステートメント">セクション13.7.7.3「SHOW CHARACTER SET ステートメント」</a>および<a class="xref" href="sql-statements.html#show-collation" title="13.7.7.4 SHOW COLLATION ステートメント">セクション13.7.7.4「SHOW COLLATION ステートメント」</a>を参照してください。 
    </p><p>
      ルーチンの作成時にデータベースのデフォルトを使用するストアドルーチンには、それらのデフォルトがその定義の一部として含まれます。 (ストアドルーチンでは、文字セットまたは照合順序が明示的に指定されていない場合、文字データ型を伴う変数は、データベースのデフォルトを使用します。 <a class="xref" href="sql-statements.html#create-procedure" title="13.1.17 CREATE PROCEDURE ステートメントおよび CREATE FUNCTION ステートメント">セクション13.1.17「CREATE PROCEDURE ステートメントおよび CREATE FUNCTION ステートメント」</a>を参照してください。) データベースのデフォルトの文字セットまたは照合順序を変更する場合は、新しいデフォルトを使用するストアドルーチンを削除して再作成する必要があります。 
    </p><h4><a name="alter-database-encryption"></a>暗号化オプション</h4><p>
      MySQL 8.0.16 で導入された <code class="literal">ENCRYPTION</code> オプションは、データベースで作成されたテーブルによって継承されるデフォルトのデータベース暗号化を定義します。 許可される値は、<code class="literal">'Y'</code> (暗号化有効) および<code class="literal">'N'</code> (暗号化無効) です。 新しく作成されたテーブルのみがデフォルトのデータベース暗号化を継承します。 データベースに関連付けられている既存のテーブルの場合、暗号化は変更されません。 <code class="literal">table_encryption_privilege_check</code> システム変数が有効になっている場合、<code class="literal">default_table_encryption</code> システム変数の値とは異なるデフォルトの暗号化設定を指定するには、<code class="literal">TABLE_ENCRYPTION_ADMIN</code> 権限が必要です。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-schema-tablespace-encryption-default" title="スキーマおよび一般テーブルスペースの暗号化デフォルトの定義">スキーマおよび一般テーブルスペースの暗号化デフォルトの定義</a>を参照してください。 
    </p><h4><a name="alter-database-read-only"></a>読取り専用オプション</h4><a class="indexterm" name="idm45827007890784"></a><p>
      MySQL 8.0.22 で導入された <code class="literal">READ ONLY</code> オプションは、データベースおよびデータベース内のオブジェクトの変更を許可するかどうかを制御します。 許可される値は、<code class="literal">DEFAULT</code> または <code class="literal">0</code> (読取り専用ではない) および <code class="literal">1</code> (読取り専用) です。 <code class="literal">READ ONLY</code> が有効になっているデータベースは、操作中にデータベースが変更される可能性があることに関係なく、別の MySQL インスタンスに移行できるため、このオプションはデータベースの移行に役立ちます。 
    </p><p>
      NDB Cluster では、ある <span class="command"><strong>mysqld</strong></span> サーバー上のデータベースを読み取り専用にすると、同じクラスタ内のほかの <span class="command"><strong>mysqld</strong></span> サーバーと同期されるため、データベースはすべての <span class="command"><strong>mysqld</strong></span> サーバー上で読み取り専用になります。
    </p><p>
      <code class="literal">READ ONLY</code> オプションが有効になっている場合は、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">SCHEMATA_EXTENSIONS</code> テーブルに表示されます。 <a class="xref" href="information-schema.html#information-schema-schemata-extensions-table" title="26.32 INFORMATION_SCHEMA SCHEMATA_EXTENSIONS テーブル">セクション26.32「INFORMATION_SCHEMA SCHEMATA_EXTENSIONS テーブル」</a>を参照してください。 
    </p><a class="indexterm" name="idm45827007877104"></a><p>
      これらのシステムスキーマでは、<code class="literal">READ ONLY</code> オプションを有効にできません: <code class="literal">mysql</code>, <code class="literal">information_schema</code>, <code class="literal">performance_schema</code>。
    </p><p>
      <code class="literal">ALTER DATABASE</code> ステートメントでは、<code class="literal">READ ONLY</code> オプションは、次のようにそれ自体の他のインスタンスおよび他のオプションと相互作用します:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">READ ONLY</code> の複数のインスタンス (<code class="literal">READ ONLY = 1 READ ONLY = 0</code> など) が競合する場合は、エラーが発生します。
        </p></li><li class="listitem"><p>
          読取り専用データベースの場合でも、<code class="literal">READ ONLY</code> オプションのみ (競合しない) を含む <code class="literal">ALTER DATABASE</code> ステートメントは許可されます。
        </p></li><li class="listitem"><p>
          ステートメントの前後のデータベースの読取り専用状態で変更が許可されている場合は、<code class="literal">READ ONLY</code> オプションと他のオプションを混在させることができます。 読取り専用状態が変更前と変更後の両方で禁止されている場合、エラーが発生します。 
        </p><p>
          このステートメントは、データベースが読取り専用かどうかにかかわらず成功します:
        </p><pre class="programlisting">ALTER DATABASE mydb READ ONLY = 0 DEFAULT COLLATE utf8mb4_bin;
</pre><p>
          このステートメントは、データベースが読取り専用でない場合は成功しますが、すでに読取り専用の場合は失敗します:
        </p><pre class="programlisting">ALTER DATABASE mydb READ ONLY = 1 DEFAULT COLLATE utf8mb4_bin;
</pre></li></ul></div><p>
      <code class="literal">READ ONLY</code> を有効にすると、データベースのすべてのユーザーに影響しますが、読取り専用チェックの対象ではない次の例外があります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          サーバーの初期化、再起動、アップグレード、またはレプリケーションの一環としてサーバーによって実行されるステートメント。
        </p></li><li class="listitem"><p>
          サーバー起動時に <code class="literal">init_file</code> システム変数によって指定されたファイル内のステートメント。
        </p></li><li class="listitem"><p>
          <code class="literal">TEMPORARY</code> テーブル。読取り専用データベースで <code class="literal">TEMPORARY</code> テーブルを作成、変更、削除および書込みできます。
        </p></li><li class="listitem"><p>
          NDB Cluster の SQL 以外の挿入および更新。
        </p></li></ul></div><p>
      前述の例外操作を除き、<code class="literal">READ ONLY</code> を有効にすると、データベースおよびそのオブジェクト (定義、データ、メタデータなど) への書込み操作が禁止されます。 次のリストに、影響を受ける SQL ステートメントおよび操作の詳細を示します: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          データベース自体:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">CREATE DATABASE</code>
            </p></li><li class="listitem"><p>
              <code class="literal">ALTER DATABASE</code> (<code class="literal">READ ONLY</code> オプションの変更を除く)
            </p></li><li class="listitem"><p>
              <code class="literal">DROP DATABASE</code>
            </p></li></ul></div></li><li class="listitem"><p>
          ビュー:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">CREATE VIEW</code>
            </p></li><li class="listitem"><p>
              <code class="literal">ALTER VIEW</code>
            </p></li><li class="listitem"><p>
              <code class="literal">DROP VIEW</code>
            </p></li><li class="listitem"><p>
              副作用のある関数を起動するビューから選択します。
            </p></li><li class="listitem"><p>
              更新可能なビューの更新。
            </p></li><li class="listitem"><p>
              書込み可能データベース内のオブジェクトを作成または削除するステートメントは、読取り専用データベース内のビューのメタデータに影響を与える場合 (たとえば、ビューを有効または無効にする場合)、拒否されます。
            </p></li></ul></div></li><li class="listitem"><p>
          ストアドルーチン:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">CREATE PROCEDURE</code>
            </p></li><li class="listitem"><p>
              <code class="literal">DROP PROCEDURE</code>
            </p></li><li class="listitem"><p>
              <code class="literal">CALL</code> (副作用のあるプロシージャ)
            </p></li><li class="listitem"><p>
              <code class="literal">CREATE FUNCTION</code>
            </p></li><li class="listitem"><p>
              <code class="literal">DROP FUNCTION</code>
            </p></li><li class="listitem"><p>
              <code class="literal">SELECT</code> (副作用を持つ関数)
            </p></li><li class="listitem"><p>
              プロシージャおよび関数の場合、読取り専用チェックは事前ロックの動作に従います。 <code class="literal">CALL</code> ステートメントの場合、読取り専用チェックはステートメントごとに実行されるため、読取り専用データベースへの書込みを条件付きで実行したステートメントが実際には実行されない場合でも、コールは成功します。 一方、<code class="literal">SELECT</code> 内でコールされる関数の場合、関数本体の実行は事前ロックモードで行われます。 関数内の一部のステートメントが読取り専用データベースに書き込むかぎり、そのステートメントが実際に実行されるかどうかに関係なく、関数の実行はエラーで失敗します。 
            </p></li></ul></div></li><li class="listitem"><p>
          トリガー:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">CREATE TRIGGER</code>
            </p></li><li class="listitem"><p>
              <code class="literal">DROP TRIGGER</code>
            </p></li><li class="listitem"><p>
              トリガーの起動。
            </p></li></ul></div></li><li class="listitem"><p>
          イベント:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">CREATE EVENT</code>
            </p></li><li class="listitem"><p>
              <code class="literal">ALTER EVENT</code>
            </p></li><li class="listitem"><p>
              <code class="literal">DROP EVENT</code>
            </p></li><li class="listitem"><p>
              イベント実行:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                  データディクショナリに格納されているイベントメタデータである最終実行タイムスタンプが変更されるため、データベースでのイベントの実行は失敗します。 イベントの実行に失敗すると、イベントスケジューラが停止する影響もあります。 
                </p></li><li class="listitem"><p>
                  イベントが読取り専用データベースのオブジェクトに書き込まれた場合、イベントの実行はエラーで失敗しますが、イベントスケジューラは停止しません。
                </p></li></ul></div></li></ul></div></li><li class="listitem"><p>
          テーブル:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">CREATE TABLE</code>
            </p></li><li class="listitem"><p>
              <code class="literal">ALTER TABLE</code>
            </p></li><li class="listitem"><p>
              <code class="literal">CREATE INDEX</code>
            </p></li><li class="listitem"><p>
              <code class="literal">DROP INDEX</code>
            </p></li><li class="listitem"><p>
              <code class="literal">RENAME TABLE</code>
            </p></li><li class="listitem"><p>
              <code class="literal">TRUNCATE TABLE</code>
            </p></li><li class="listitem"><p>
              <code class="literal">DROP TABLE</code>
            </p></li><li class="listitem"><p>
              <code class="literal">DELETE</code>
            </p></li><li class="listitem"><p>
              <code class="literal">INSERT</code>
            </p></li><li class="listitem"><p>
              <code class="literal">IMPORT TABLE</code>
            </p></li><li class="listitem"><p>
              <code class="literal">LOAD DATA</code>
            </p></li><li class="listitem"><p>
              <code class="literal">LOAD XML</code>
            </p></li><li class="listitem"><p>
              <code class="literal">REPLACE</code>
            </p></li><li class="listitem"><p>
              <code class="literal">UPDATE</code>
            </p></li><li class="listitem"><p>
              子テーブルが読取り専用データベースにあるカスケード外部キーの場合、子テーブルが直接影響を受けない場合でも、親での更新および削除は拒否されます。
            </p></li><li class="listitem"><p>
              <code class="literal">CREATE TABLE s1.t(i int) ENGINE MERGE UNION (s2.t, s3.t), INSERT_METHOD=...</code> などの <code class="literal">MERGE</code> テーブルの場合、次の動作が適用されます:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                  挿入方法に関係なく、少なくともいずれかの <code class="literal">s1</code>, <code class="literal">s2</code>, <code class="literal">s3</code> が読取り専用の場合、<code class="literal">MERGE</code> テーブル (<code class="literal">INSERT into s1.t</code>) への挿入は失敗します。 挿入は、実際に書込み可能なテーブルで終了する場合でも拒否されます。 
                </p></li><li class="listitem"><p>
                  <code class="literal">s1</code> が読取り専用でないかぎり、<code class="literal">MERGE</code> テーブル (<code class="literal">DROP TABLE s1.t</code>) の削除は成功します。 読取り専用データベースを参照する <code class="literal">MERGE</code> テーブルを削除できます。 
                </p></li></ul></div></li></ul></div></li></ul></div><p>
      <code class="literal">ALTER DATABASE</code> ステートメントは、変更中のデータベース内のオブジェクトにすでにアクセスしているすべての同時トランザクションがコミットされるまでブロックされます。 逆に、同時 <code class="literal">ALTER DATABASE</code> で変更されるデータベース内のオブジェクトにアクセスする書込みトランザクションは、<code class="literal">ALTER DATABASE</code> がコミットされるまでブロックされます。 
    </p><p>
      クローンプラグインを使用してローカルまたはリモートのデータディレクトリをクローニングする場合、クローン内のデータベースは、ソースデータディレクトリにあった読取り専用状態を保持します。 読取り専用状態は、クローニングプロセス自体には影響しません。 クローンで同じデータベース読取り専用状態にすることが望ましくない場合は、クローンで <code class="literal">ALTER DATABASE</code> 操作を使用して、クローニングプロセスの終了後にクローンのオプションを明示的に変更する必要があります。 
    </p><p>
      ドナーから受信者にクローニングする場合、受信者に読取り専用のユーザーデータベースがあると、クローニングは失敗し、エラーメッセージが表示されます。 クローニングは、データベースを書込み可能にした後に再試行できます。 
    </p><p>
      <code class="literal">READ ONLY</code> は、<code class="literal">ALTER DATABASE</code> では許可されますが、<code class="literal">CREATE DATABASE</code> では許可されません。 ただし、読取り専用データベースの場合、<code class="literal">SHOW CREATE DATABASE</code> によって生成されるステートメントには、読取り専用ステータスを示す <code class="literal">READ ONLY=1</code> がコメント内に含まれます: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER DATABASE mydb READ ONLY = 1;</code></strong>
mysql&gt; <strong class="userinput"><code>SHOW CREATE DATABASE mydb\G</code></strong>
*************************** 1. row ***************************
       Database: mydb
Create Database: CREATE DATABASE `mydb`
                 /*!40100 DEFAULT CHARACTER SET utf8mb4
                          COLLATE utf8mb4_0900_ai_ci */
                 /*!80016 DEFAULT ENCRYPTION='N' */
                 /* READ ONLY = 1 */
</pre><p>
      サーバーがこのようなコメントを含む <code class="literal">CREATE DATABASE</code> ステートメントを実行すると、サーバーはそのコメントを無視し、<code class="literal">READ ONLY</code> オプションは処理されません。 これは、<code class="literal">SHOW CREATE DATABASE</code> を使用してダンプ出力に <code class="literal">CREATE DATABASE</code> ステートメントを生成する <span class="command"><strong>mysqldump</strong></span> および <span class="command"><strong>mysqlpump</strong></span> に影響します: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ダンプファイルでは、読取り専用データベースの <code class="literal">CREATE DATABASE</code> ステートメントにコメント付きの <code class="literal">READ ONLY</code> オプションが含まれています。
        </p></li><li class="listitem"><p>
          ダンプファイルは通常どおりリストアできますが、サーバーはコメント化された <code class="literal">READ ONLY</code> オプションを無視するため、リストアされたデータベースは読取り専用ではありません。 リストア後にデータベースを読取り専用にする場合は、<code class="literal">ALTER DATABASE</code> を手動で実行して読取り専用にする必要があります。 
        </p></li></ul></div><p>
      <code class="literal">mydb</code> が読取り専用で、次のようにダンプするとします:
    </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqldump --databases mydb &gt; mydb.sql</code></strong>
</pre><p>
      <code class="literal">mydb</code> を読取り専用にする必要がある場合は、後でリストア操作の後に <code class="literal">ALTER DATABASE</code> を実行する必要があります:
    </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysql</code></strong>
mysql&gt; <strong class="userinput"><code>SOURCE mydb.sql;</code></strong>
mysql&gt; <strong class="userinput"><code>ALTER DATABASE mydb READ ONLY = 1;</code></strong>
</pre><p>
      MySQL Enterprise Backup にはこの問題はありません。 読取り専用データベースは、他のデータベースと同様にバックアップおよびリストアされますが、バックアップ時に <code class="literal">READ ONLY</code> オプションが有効になっていた場合は、リストア時に有効になります。 
    </p><p>
      <code class="literal">ALTER DATABASE</code> はバイナリログに書き込まれるため、レプリケーションソースサーバーで <code class="literal">READ ONLY</code> オプションを変更すると、複製にも影響します。 これが発生しないようにするには、<code class="literal">ALTER DATABASE</code> ステートメントを実行する前にバイナリロギングを無効にする必要があります。 たとえば、レプリカに影響を与えずにデータベースの移行を準備するには、次の操作を実行します: 
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          単一のセッション内で、バイナリロギングを無効にし、データベースに対して <code class="literal">READ ONLY</code> を有効にします:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET sql_log_bin = OFF;</code></strong>
mysql&gt; <strong class="userinput"><code>ALTER DATABASE mydb READ ONLY = 1;</code></strong>
</pre></li><li class="listitem"><p>
          たとえば、<span class="command"><strong>mysqldump</strong></span> または <span class="command"><strong>mysqlpump</strong></span> を使用してデータベースをダンプします:
        </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqldump --databases mydb &gt; mydb.sql</code></strong>
</pre></li><li class="listitem"><p>
          単一セッション内で、バイナリロギングを無効にし、データベースの <code class="literal">READ ONLY</code> を無効にします:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET sql_log_bin = OFF;</code></strong>
mysql&gt; <strong class="userinput"><code>ALTER DATABASE mydb READ ONLY = 0;</code></strong>
</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-event"></a>13.1.3 ALTER EVENT ステートメント</h3></div></div></div><a class="indexterm" name="idm45827007703376"></a><a class="indexterm" name="idm45827007701216"></a><a class="indexterm" name="idm45827007699184"></a><pre class="programlisting">ALTER
    [DEFINER = <em class="replaceable"><code>user</code></em>]
    EVENT <em class="replaceable"><code>event_name</code></em>
    [ON SCHEDULE <em class="replaceable"><code>schedule</code></em>]
    [ON COMPLETION [NOT] PRESERVE]
    [RENAME TO <em class="replaceable"><code>new_event_name</code></em>]
    [ENABLE | DISABLE | DISABLE ON SLAVE]
    [COMMENT '<em class="replaceable"><code>string</code></em>']
    [DO <em class="replaceable"><code>event_body</code></em>]
</pre><p>
      <code class="literal">ALTER EVENT</code> ステートメントは、既存のイベントの 1 つ以上の特性を、そのイベントを削除して再作成することなく変更します。 <code class="literal">DEFINER</code>、<code class="literal">ON SCHEDULE</code>、<code class="literal">ON COMPLETION</code>、<code class="literal">COMMENT</code>、<code class="literal">ENABLE</code>/<code class="literal">DISABLE</code>、<code class="literal">DO</code> の各句の構文は、<code class="literal">CREATE EVENT</code> で使用される場合とまったく同じです。 (<a class="xref" href="sql-statements.html#create-event" title="13.1.13 CREATE EVENT ステートメント">セクション13.1.13「CREATE EVENT ステートメント」</a>を参照してください。) 
    </p><p>
      どのユーザーも、そのユーザーが <code class="literal">EVENT</code> 権限を持っているデータベースで定義されたイベントを変更できます。 ユーザーが正常な <code class="literal">ALTER EVENT</code> ステートメントを実行すると、そのユーザーは、影響を受けるイベントの定義者になります。 
    </p><p>
      <code class="literal">ALTER EVENT</code> は、既存のイベントでのみ機能します。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER EVENT no_such_event </code></strong>
     &gt;     <strong class="userinput"><code>ON SCHEDULE </code></strong>
     &gt;       <strong class="userinput"><code>EVERY '2:3' DAY_HOUR;</code></strong>
<span class="errortext">ERROR 1517 (HY000): Unknown event 'no_such_event'</span>
</pre><p>
      次の各例では、<code class="literal">myevent</code> という名前のイベントが次に示すように定義されていることを前提にしています。
    </p><pre class="programlisting">CREATE EVENT myevent
    ON SCHEDULE
      EVERY 6 HOUR
    COMMENT 'A sample comment.'
    DO
      UPDATE myschema.mytable SET mycol = mycol + 1;
</pre><p>
      次のステートメントは、<code class="literal">myevent</code> のスケジュールを、ただちに開始して 6 時間ごとに 1 回から、ステートメントが実行された 4 時間後から開始して 12 時間ごとに 1 回に変更します。
    </p><pre class="programlisting">ALTER EVENT myevent
    ON SCHEDULE
      EVERY 12 HOUR
    STARTS CURRENT_TIMESTAMP + INTERVAL 4 HOUR;
</pre><p>
      イベントの複数の特性を 1 つのステートメントで変更できます。 この例では、<code class="literal">myevent</code> によって実行される SQL ステートメントを、<code class="literal">mytable</code> のすべてのレコードを削除する SQL ステートメントに変更します。また、イベントのスケジュールも、この <code class="literal">ALTER EVENT</code> ステートメントが実行された 1 日あとに 1 回実行されるように変更します。 
    </p><pre class="programlisting">ALTER EVENT myevent
    ON SCHEDULE
      AT CURRENT_TIMESTAMP + INTERVAL 1 DAY
    DO
      TRUNCATE TABLE myschema.mytable;
</pre><p>
      <code class="literal">ALTER EVENT</code> ステートメントでは、変更したい特性のオプションのみを指定します。省略されたオプションでは、その既存の値が保持されます。 これには、<code class="literal">ENABLE</code> などの、<code class="literal">CREATE EVENT</code> のデフォルト値もすべて含まれます。 
    </p><p>
      <code class="literal">myevent</code> を無効にするには、この <code class="literal">ALTER EVENT</code> ステートメントを使用します。
    </p><pre class="programlisting">ALTER EVENT myevent
    DISABLE;
</pre><p>
      <code class="literal">ON SCHEDULE</code> 句では、組み込みの MySQL 関数やユーザー変数を含む式を使用して、そこに含まれているすべての <em class="replaceable"><code>timestamp</code></em> または <em class="replaceable"><code>interval</code></em> 値を取得できます。 このような式でストアドルーチンやユーザー定義関数を使用したり、テーブル参照を使用したりすることはできません。ただし、<code class="literal">SELECT FROM DUAL</code> は使用できます。 これは、<code class="literal">ALTER EVENT</code> ステートメントと <code class="literal">CREATE EVENT</code> ステートメントの両方に当てはまります。 このような場合のストアドルーチン、ユーザー定義関数、およびテーブルへの参照は明確に禁止されており、エラーで失敗します (Bug #22830 を参照してください)。 
    </p><p>
      <code class="literal">DO</code> 句に別の <code class="literal">ALTER EVENT</code> ステートメントを含む <code class="literal">ALTER EVENT</code> ステートメントは成功したように見えますが、結果として得られるスケジュールされたイベントをサーバーが実行しようとすると、その実行はエラーで失敗します。
    </p><p>
      イベントの名前を変更するには、<code class="literal">ALTER EVENT</code> ステートメントの <code class="literal">RENAME TO</code> 句を使用します。 このステートメントは、イベント <code class="literal">myevent</code> の名前を <code class="literal">yourevent</code> に変更します。 
    </p><pre class="programlisting">ALTER EVENT myevent
    RENAME TO yourevent;
</pre><p>
      次に示すように、<code class="literal">ALTER EVENT ... RENAME TO ...</code> と <code class="literal"><em class="replaceable"><code>db_name.event_name</code></em></code> 表記を使用して、イベントを別のデータベースに移動することもできます。
    </p><pre class="programlisting">ALTER EVENT olddb.myevent
    RENAME TO newdb.myevent;
</pre><p>
      前のステートメントを実行するには、それを実行するユーザーが、<code class="literal">olddb</code> および <code class="literal">newdb</code> データベースの両方に対する <code class="literal">EVENT</code> 権限を持っている必要があります。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">RENAME EVENT</code> ステートメントはありません。
      </p></div><p>
      値 <code class="literal">DISABLE ON SLAVE</code> は、<code class="literal">ENABLE</code> または <code class="literal">DISABLE</code> のかわりにレプリカで使用され、レプリケーションソースサーバーで作成されレプリカにレプリケートされたがレプリカでは実行されなかったイベントを示します。 通常、<code class="literal">DISABLE ON SLAVE</code> は必要に応じて自動的に設定されます。ただし、手動で変更することが必要になる場合もあります。 詳細は、<a class="xref" href="replication.html#replication-features-invoked" title="17.5.1.16 呼び出される機能のレプリケーション">セクション17.5.1.16「呼び出される機能のレプリケーション」</a>を参照してください。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-function"></a>13.1.4 ALTER FUNCTION ステートメント</h3></div></div></div><a class="indexterm" name="idm45827007628768"></a><pre class="programlisting">ALTER FUNCTION <em class="replaceable"><code>func_name</code></em> [<em class="replaceable"><code>characteristic</code></em> ...]

<em class="replaceable"><code>characteristic</code></em>: {
    COMMENT '<em class="replaceable"><code>string</code></em>'
  | LANGUAGE SQL
  | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
  | SQL SECURITY { DEFINER | INVOKER }
}
</pre><p>
      このステートメントを使用すると、ストアドファンクションの特性を変更できます。 <code class="literal">ALTER FUNCTION</code> ステートメントでは、複数の変更を指定できます。 ただし、このステートメントを使用して、ストアドファンクションのパラメータまたは本体を変更することはできません。このような変更を行うには、<code class="literal">DROP FUNCTION</code> と <code class="literal">CREATE FUNCTION</code> を使用して、この関数を削除および再作成する必要があります。 
    </p><p>
      この関数に対する <code class="literal">ALTER ROUTINE</code> 権限が必要です。 (その権限は、関数作成者に自動的に付与されます。) バイナリロギングが有効になっている場合は、<a class="xref" href="stored-objects.html#stored-programs-logging" title="25.7 ストアドプログラムバイナリロギング">セクション25.7「ストアドプログラムバイナリロギング」</a>で説明されているように、<code class="literal">ALTER FUNCTION</code> ステートメントに <code class="literal">SUPER</code> 権限も必要になる可能性があります。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-instance"></a>13.1.5 ALTER INSTANCE ステートメント</h3></div></div></div><a class="indexterm" name="idm45827007609904"></a><pre class="programlisting">ALTER INSTANCE <em class="replaceable"><code>instance_action</code></em>

<em class="replaceable"><code>instance_action</code></em>: {
  | {ENABLE|DISABLE} INNODB REDO_LOG
  | ROTATE INNODB MASTER KEY
  | ROTATE BINLOG MASTER KEY
  | RELOAD TLS
      [FOR CHANNEL {mysql_main | mysql_admin}]
      [NO ROLLBACK ON ERROR]
}
</pre><p>
      <code class="literal">ALTER INSTANCE</code> は、MySQL サーバーインスタンスに適用可能なアクションを定義します。 このステートメントでは、次のアクションがサポートされています: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="alter-instance-enable-disable-innodb-redo-log"></a>
          <code class="literal">ALTER INSTANCE {ENABLE | DISABLE} INNODB REDO_LOG</code>
        </p><p>
          このアクションは、<code class="literal">InnoDB</code> redo ロギングを有効または無効にします。 redo ロギングはデフォルトで有効になっています。 この機能は、新しい MySQL インスタンスへのデータのロードのみを目的としています。 ステートメントはバイナリログに書き込まれません。 MySQL 8.0.21 で導入されました。 
        </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
            <span class="emphasis"><em>本番システムで redo ロギングを無効にしないでください。</em></span> redo ロギングが無効になっているときにサーバーを停止して再起動することは許可されていますが、redo ロギングが無効になっているときに予期しないサーバー停止ページが発生すると、データが失われ、インスタンスが破損する可能性があります。 
          </p></div><p>
          <code class="literal">ALTER INSTANCE [ENABLE|DISABLE] INNODB REDO_LOG</code> 操作には排他的バックアップロックが必要で、これにより他の <code class="literal">ALTER INSTANCE</code> 操作が同時に実行されなくなります。 その他の <code class="literal">ALTER INSTANCE</code> 操作は、ロックが解放されるまで待機してから実行する必要があります。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-disable-redo-logging" title="redo ロギングの無効化">redo ロギングの無効化</a>を参照してください。
        </p></li><li class="listitem"><p><a name="alter-instance-rotate-innodb-master-key"></a>
          <code class="literal">ALTER INSTANCE ROTATE INNODB MASTER KEY</code>
        </p><p>
          このアクションにより、<code class="literal">InnoDB</code> テーブルスペースの暗号化に使用されるマスター暗号化キーがローテーションされます。 キーローテーションには、<code class="literal">ENCRYPTION_KEY_ADMIN</code> または <code class="literal">SUPER</code> 権限が必要です。 このアクションを実行するには、キーリングプラグインをインストールして構成する必要があります。 その手順は、<a class="xref" href="security.html#keyring" title="6.4.4 MySQL キーリング">セクション6.4.4「MySQL キーリング」</a>を参照してください。 
        </p><p>
          <code class="literal">ALTER INSTANCE ROTATE INNODB MASTER KEY</code> では、同時 DML がサポートされます。 ただし、<code class="literal">CREATE TABLE ... ENCRYPTION</code> または <code class="literal">ALTER TABLE ... ENCRYPTION</code> 操作と同時に実行することはできず、これらのステートメントの同時実行によって発生する可能性のある競合を防ぐためにロックが取得されます。 競合するステートメントのいずれかが実行されている場合、別のステートメントを続行する前に完了する必要があります。 
        </p><p>
          <code class="literal">ALTER INSTANCE ROTATE INNODB MASTER KEY</code> ステートメントは、レプリケートされたサーバーで実行できるようにバイナリログに書き込まれます。
        </p><p>
          <code class="literal">ALTER INSTANCE ROTATE INNODB MASTER KEY</code> の使用方法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-data-encryption" title="15.13 InnoDB 保存データ暗号化">セクション15.13「InnoDB 保存データ暗号化」</a> を参照してください。
        </p></li><li class="listitem"><p><a name="alter-instance-rotate-binlog-master-key"></a>
          <code class="literal">ALTER INSTANCE ROTATE BINLOG MASTER KEY</code>
        </p><p>
          このアクションは、バイナリログの暗号化に使用されるバイナリログマスターキーをローテーションします。 バイナリログマスターキーの鍵ローテーションには、<code class="literal">BINLOG_ENCRYPTION_ADMIN</code> または <code class="literal">SUPER</code> 権限が必要です。 <code class="literal">binlog_encryption</code> システム変数が <code class="literal">OFF</code> に設定されている場合、このステートメントは使用できません。 このアクションを実行するには、キーリングプラグインをインストールして構成する必要があります。 その手順は、<a class="xref" href="security.html#keyring" title="6.4.4 MySQL キーリング">セクション6.4.4「MySQL キーリング」</a>を参照してください。 
        </p><p>
          <code class="literal">ALTER INSTANCE ROTATE BINLOG MASTER KEY</code> アクションはバイナリログに書き込まれず、レプリカでは実行されません。 したがって、バイナリログマスターキーローテーションは、MySQL バージョンの混在を含むレプリケーション環境で実行できます。 適用可能なすべてのソースサーバーおよびレプリカサーバーでバイナリログマスターキーの定期ローテーションをスケジュールするには、各サーバーで MySQL イベントスケジューラを有効にし、<code class="literal">CREATE EVENT</code> ステートメントを使用して <code class="literal">ALTER INSTANCE ROTATE BINLOG MASTER KEY</code> ステートメントを発行します。 現在または以前のバイナリログマスターキーのいずれかが危険にさらされている可能性があるためにバイナリログマスターキーをローテーションした場合は、該当するすべてのソースおよびレプリカサーバーでステートメントを発行して、即時のコンプライアンスを検証できます。 
        </p><p>
          プロセスが正しく完了しない場合や、予期しないサーバー停止によって中断された場合の対処方法など、<code class="literal">ALTER INSTANCE ROTATE BINLOG MASTER KEY</code> の追加の使用方法については、<a class="xref" href="replication.html#replication-binlog-encryption" title="17.3.2 バイナリログファイルとリレーログファイルの暗号化">セクション17.3.2「バイナリログファイルとリレーログファイルの暗号化」</a> を参照してください。
        </p></li><li class="listitem"><p><a name="alter-instance-reload-tls"></a>
          <code class="literal">ALTER INSTANCE RELOAD TLS</code>
        </p><p>
          このアクションは、コンテキストを定義するシステム変数の現在の値から TLS コンテキストを再構成します。 また、アクティブなコンテキスト値を反映するステータス変数も更新されます。 このアクションには、<code class="literal">CONNECTION_ADMIN</code> 権限が必要です。 TLS コンテキストの再構成の詳細 (コンテキスト関連のシステム変数やステータス変数など) は、<a class="xref" href="security.html#using-encrypted-connections-server-side-runtime-configuration" title="サーバー側のランタイム構成および暗号化された接続の監視">サーバー側のランタイム構成および暗号化された接続の監視</a> を参照してください。 
        </p><p>
          デフォルトでは、ステートメントはメイン接続インタフェースの TLS コンテキストをリロードします。 (MySQL 8.0.21 で使用可能な) <code class="literal">FOR CHANNEL</code> 句が指定されている場合、ステートメントは指定されたチャネルの TLS コンテキストをリロード: メイン接続インタフェースの場合は <code class="literal">mysql_main</code>、管理接続インタフェースの場合は <code class="literal">mysql_admin</code>。 様々なインタフェースの詳細は、<a class="xref" href="server-administration.html#connection-interfaces" title="5.1.12.1 接続インタフェース">セクション5.1.12.1「接続インタフェース」</a> を参照してください。 更新された TLS コンテキストプロパティーは、パフォーマンススキーマ <code class="literal">tls_channel_status</code> テーブルで公開されます。 <a class="xref" href="performance-schema.html#performance-schema-tls-channel-status-table" title="27.12.19.11 tls_channel_status テーブル">セクション27.12.19.11「tls_channel_status テーブル」</a>を参照してください。 
        </p><p>
          メインインタフェースの TLS コンテキストを更新すると、そのインタフェースにデフォルト以外の TLS 値が構成されていないかぎり、メインインタフェースと同じ TLS コンテキストが使用されるため、管理インタフェースにも影響する可能性があります。
        </p><p>
          デフォルトでは、<code class="literal">RELOAD TLS</code> アクションはエラーでロールバックされ、構成値で新しい TLS コンテキストの作成が許可されていない場合は影響しません。 以前のコンテキスト値は、引き続き新しい接続に使用されます。 オプションの <code class="literal">NO ROLLBACK ON ERROR</code> 句が指定され、新しいコンテキストを作成できない場合、ロールバックは発生しません。 代わりに、警告が生成され、ステートメントが適用されるインタフェース上の新しい接続の暗号化が無効になります。 
        </p><p>
          <code class="literal">ALTER INSTANCE RELOAD TLS</code> ステートメントはバイナリログに書き込まれません (したがってレプリケートされません)。 TLS 構成はローカルであり、関係するすべてのサーバーに必ずしも存在するわけではありません。 
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-logfile-group"></a>13.1.6 ALTER LOGFILE GROUP ステートメント</h3></div></div></div><a class="indexterm" name="idm45827007544064"></a><pre class="programlisting">ALTER LOGFILE GROUP <em class="replaceable"><code>logfile_group</code></em>
    ADD UNDOFILE '<em class="replaceable"><code>file_name</code></em>'
    [INITIAL_SIZE [=] <em class="replaceable"><code>size</code></em>]
    [WAIT]
    ENGINE [=] <em class="replaceable"><code>engine_name</code></em>
</pre><p>
      このステートメントは、'<em class="replaceable"><code>file_name</code></em>' という名前の <code class="literal">UNDO</code> ファイルを既存のログファイルグループ <em class="replaceable"><code>logfile_group</code></em> に追加します。 <code class="literal">ALTER LOGFILE GROUP</code> ステートメントには、<code class="literal">ADD UNDOFILE</code> 句が 1 つだけ存在します。 <code class="literal">DROP UNDOFILE</code> 句は、現在サポートされていません。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        NDB Cluster ディスクデータオブジェクトはすべて同じ名前空間を共有します。 つまり、<span class="emphasis"><em>各ディスクデータオブジェクト</em></span>は (単に、特定の型の各ディスクデータオブジェクトというだけでなく)、一意の名前が付けられている必要があります。 たとえば、テーブルスペースと Undo ログファイルを同じ名前にしたり、Undo ログファイルとデータファイルを同じ名前にしたりすることはできません。 
      </p></div><p>
      オプションの <code class="literal">INITIAL_SIZE</code> パラメータは、<code class="literal">UNDO</code> ファイルの初期サイズをバイト単位で設定します。指定されていない場合、初期サイズはデフォルトで 134217728 (128M バイト) になります。 オプションで、<code class="filename">my.cnf</code> で使用されているものと同様に、<em class="replaceable"><code>size</code></em> の後に一文字の略称を付けることもできます。 一般に、これは <code class="literal">M</code> (M バイト) または <code class="literal">G</code> (G バイト) のどちらかの文字です。 (Bug #13116514、Bug #16104705、Bug #62858) 
    </p><p>
      32 ビットシステム上では、<code class="literal">INITIAL_SIZE</code> のサポートされる最大値は 4294967296 (4G バイト) です。 (Bug #29186) 
    </p><p>
      <code class="literal">INITIAL_SIZE</code> の許可される最小値は 1048576 (1M バイト) です。 (Bug #29574) 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">WAIT</code> は解析されますが、それ以外は無視されます。 このキーワードは現在何の効果もなく、将来の拡張のために用意されています。 
      </p></div><p>
      <code class="literal">ENGINE</code> パラメータ (必須) は、このログファイルグループによって使用されるストレージエンジンを決定します。ここで、<em class="replaceable"><code>engine_name</code></em> はそのストレージエンジンの名前です。 現在、<em class="replaceable"><code>engine_name</code></em> として受け入れられる値は<span class="quote">「<span class="quote"><code class="literal">NDBCLUSTER</code></span>」</span>と<span class="quote">「<span class="quote"><code class="literal">NDB</code></span>」</span>だけです。 この 2 つの値は同等です。 
    </p><p>
      次の例では、ログファイルグループ <code class="literal">lg_3</code> がすでに <code class="literal">CREATE LOGFILE GROUP</code> を使用して作成されていることを前提にしています (<a class="xref" href="sql-statements.html#create-logfile-group" title="13.1.16 CREATE LOGFILE GROUP ステートメント">セクション13.1.16「CREATE LOGFILE GROUP ステートメント」</a>を参照してください)。
    </p><pre class="programlisting">ALTER LOGFILE GROUP lg_3
    ADD UNDOFILE 'undo_10.dat'
    INITIAL_SIZE=32M
    ENGINE=NDBCLUSTER;
</pre><p>
      <code class="literal">ALTER LOGFILE GROUP</code> を <code class="literal">ENGINE = NDBCLUSTER</code> (または <code class="literal">ENGINE = NDB</code>) とともに使用すると、NDB Cluster データノードごとに <code class="literal">UNDO</code> ログファイルが作成されます。 <code class="literal">INFORMATION_SCHEMA.FILES</code> テーブルをクエリーすることによって、<code class="literal">UNDO</code> ファイルが作成されたことを確認したり、それらに関する情報を取得したりできます。 例: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT FILE_NAME, LOGFILE_GROUP_NUMBER, EXTRA</code></strong>
    -&gt; <strong class="userinput"><code>FROM INFORMATION_SCHEMA.FILES</code></strong>
    -&gt; <strong class="userinput"><code>WHERE LOGFILE_GROUP_NAME = 'lg_3';</code></strong>
+-------------+----------------------+----------------+
| FILE_NAME   | LOGFILE_GROUP_NUMBER | EXTRA          |
+-------------+----------------------+----------------+
| newdata.dat |                    0 | CLUSTER_NODE=3 |
| newdata.dat |                    0 | CLUSTER_NODE=4 |
| undo_10.dat |                   11 | CLUSTER_NODE=3 |
| undo_10.dat |                   11 | CLUSTER_NODE=4 |
+-------------+----------------------+----------------+
4 rows in set (0.01 sec)
</pre><p>
      (<a class="xref" href="information-schema.html#information-schema-files-table" title="26.15 INFORMATION_SCHEMA FILES テーブル">セクション26.15「INFORMATION_SCHEMA FILES テーブル」</a>を参照してください。)
    </p><p>
      <code class="literal">UNDO_BUFFER_SIZE</code> に使用されるメモリーは、サイズが <code class="literal">SharedGlobalMemory</code> データノード構成パラメータの値によって決定されるグローバルプールから取得されます。 これには、<code class="literal">InitialLogFileGroup</code> データノード構成パラメータの設定により、このオプションに暗黙的に指定されるデフォルト値もすべて含まれます。 
    </p><p>
      <code class="literal">ALTER LOGFILE GROUP</code> は NDB Cluster のディスクデータストレージでのみ役立ちます。 詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data" title="23.5.10 NDB Cluster ディスクデータテーブル">セクション23.5.10「NDB Cluster ディスクデータテーブル」</a>を参照してください。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-procedure"></a>13.1.7 ALTER PROCEDURE ステートメント</h3></div></div></div><a class="indexterm" name="idm45827007492848"></a><pre class="programlisting">ALTER PROCEDURE <em class="replaceable"><code>proc_name</code></em> [<em class="replaceable"><code>characteristic</code></em> ...]

<em class="replaceable"><code>characteristic</code></em>: {
    COMMENT '<em class="replaceable"><code>string</code></em>'
  | LANGUAGE SQL
  | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
  | SQL SECURITY { DEFINER | INVOKER }
}
</pre><p>
      このステートメントを使用すると、ストアドプロシージャーの特性を変更できます。 <code class="literal">ALTER PROCEDURE</code> ステートメントでは、複数の変更を指定できます。 ただし、このステートメントを使用して、ストアドプロシージャーのパラメータまたは本体を変更することはできません。このような変更を行うには、<code class="literal">DROP PROCEDURE</code> と <code class="literal">CREATE PROCEDURE</code> を使用して、このプロシージャーを削除および再作成する必要があります。 
    </p><p>
      このプロシージャーに対する <code class="literal">ALTER ROUTINE</code> 権限が必要です。 デフォルトでは、その権限は、プロシージャー作成者に自動的に付与されます。 この動作は、<code class="literal">automatic_sp_privileges</code> システム変数を無効にすることによって変更できます。 <a class="xref" href="stored-objects.html#stored-routines-privileges" title="25.2.2 ストアドルーチンと MySQL 権限">セクション25.2.2「ストアドルーチンと MySQL 権限」</a>を参照してください。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-server"></a>13.1.8 ALTER SERVER ステートメント</h3></div></div></div><a class="indexterm" name="idm45827007475600"></a><pre class="programlisting">ALTER SERVER  <em class="replaceable"><code>server_name</code></em>
    OPTIONS (<em class="replaceable"><code>option</code></em> [, <em class="replaceable"><code>option</code></em>] ...)
</pre><p>
      <code class="literal"><em class="replaceable"><code>server_name</code></em></code> のサーバー情報を変更して、<code class="literal">CREATE SERVER</code> ステートメント内で許可されているオプションのいずれかを調整します。 それに応じて、<code class="literal">mysql.servers</code> テーブル内の対応するフィールドが更新されます。 このステートメントには、<code class="literal">SUPER</code> 権限が必要です。 
    </p><p>
      たとえば、<code class="literal">USER</code> オプションを更新するには、次のようにします。
    </p><pre class="programlisting">ALTER SERVER s OPTIONS (USER 'sally');</pre><p>
      <code class="literal">ALTER SERVER</code> によって暗黙的なコミットが発生します。 <a class="xref" href="sql-statements.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。 
    </p><p>
      使用されているロギング形式に関係なく、<code class="literal">ALTER SERVER</code> はバイナリログに書き込まれません。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-table"></a>13.1.9 ALTER TABLE ステートメント</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#alter-table-partition-operations">13.1.9.1 ALTER TABLE パーティション操作</a></span></dt><dt><span class="section"><a href="sql-statements.html#alter-table-generated-columns">13.1.9.2 ALTER TABLE および生成されるカラム</a></span></dt><dt><span class="section"><a href="sql-statements.html#alter-table-examples">13.1.9.3 ALTER TABLE の例</a></span></dt></dl></div><a class="indexterm" name="idm45827007456416"></a><a class="indexterm" name="idm45827007455104"></a><a class="indexterm" name="idm45827007452960"></a><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em>
    [<em class="replaceable"><code>alter_option</code></em> [, <em class="replaceable"><code>alter_option</code></em>] ...]
    [<em class="replaceable"><code>partition_options</code></em>]

<em class="replaceable"><code>alter_option</code></em>: {
    <em class="replaceable"><code>table_options</code></em>
  | ADD [COLUMN] <em class="replaceable"><code>col_name</code></em> <em class="replaceable"><code>column_definition</code></em>
        [FIRST | AFTER <em class="replaceable"><code>col_name</code></em>]
  | ADD [COLUMN] (<em class="replaceable"><code>col_name</code></em> <em class="replaceable"><code>column_definition</code></em>,...)
  | ADD {INDEX | KEY} [<em class="replaceable"><code>index_name</code></em>]
        [<em class="replaceable"><code>index_type</code></em>] (<em class="replaceable"><code>key_part</code></em>,...) [<em class="replaceable"><code>index_option</code></em>] ...
  | ADD {FULLTEXT | SPATIAL} [INDEX | KEY] [<em class="replaceable"><code>index_name</code></em>]
        (<em class="replaceable"><code>key_part</code></em>,...) [<em class="replaceable"><code>index_option</code></em>] ...
  | ADD [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] PRIMARY KEY
        [<em class="replaceable"><code>index_type</code></em>] (<em class="replaceable"><code>key_part</code></em>,...)
        [<em class="replaceable"><code>index_option</code></em>] ...
  | ADD [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] UNIQUE [INDEX | KEY]
        [<em class="replaceable"><code>index_name</code></em>] [<em class="replaceable"><code>index_type</code></em>] (<em class="replaceable"><code>key_part</code></em>,...)
        [<em class="replaceable"><code>index_option</code></em>] ...
  | ADD [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] FOREIGN KEY
        [<em class="replaceable"><code>index_name</code></em>] (<em class="replaceable"><code>col_name</code></em>,...)
        <em class="replaceable"><code>reference_definition</code></em>
  | ADD [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] CHECK (<em class="replaceable"><code>expr</code></em>) [[NOT] ENFORCED]
  | DROP {CHECK | CONSTRAINT} <em class="replaceable"><code>symbol</code></em>
  | ALTER {CHECK | CONSTRAINT} <em class="replaceable"><code>symbol</code></em> [NOT] ENFORCED
  | ALGORITHM [=] {DEFAULT | INSTANT | INPLACE | COPY}
  | ALTER [COLUMN] <em class="replaceable"><code>col_name</code></em> {
        SET DEFAULT {<em class="replaceable"><code>literal</code></em> | (<em class="replaceable"><code>expr</code></em>)}
      | SET {VISIBLE | INVISIBLE}
      | DROP DEFAULT
    }
  | ALTER INDEX <em class="replaceable"><code>index_name</code></em> {VISIBLE | INVISIBLE}
  | CHANGE [COLUMN] <em class="replaceable"><code>old_col_name</code></em> <em class="replaceable"><code>new_col_name</code></em> <em class="replaceable"><code>column_definition</code></em>
        [FIRST | AFTER <em class="replaceable"><code>col_name</code></em>]
  | [DEFAULT] CHARACTER SET [=] <em class="replaceable"><code>charset_name</code></em> [COLLATE [=] <em class="replaceable"><code>collation_name</code></em>]
  | CONVERT TO CHARACTER SET <em class="replaceable"><code>charset_name</code></em> [COLLATE <em class="replaceable"><code>collation_name</code></em>]
  | {DISABLE | ENABLE} KEYS
  | {DISCARD | IMPORT} TABLESPACE
  | DROP [COLUMN] <em class="replaceable"><code>col_name</code></em>
  | DROP {INDEX | KEY} <em class="replaceable"><code>index_name</code></em>
  | DROP PRIMARY KEY
  | DROP FOREIGN KEY <em class="replaceable"><code>fk_symbol</code></em>
  | FORCE
  | LOCK [=] {DEFAULT | NONE | SHARED | EXCLUSIVE}
  | MODIFY [COLUMN] <em class="replaceable"><code>col_name</code></em> <em class="replaceable"><code>column_definition</code></em>
        [FIRST | AFTER <em class="replaceable"><code>col_name</code></em>]
  | ORDER BY <em class="replaceable"><code>col_name</code></em> [, <em class="replaceable"><code>col_name</code></em>] ...
  | RENAME COLUMN <em class="replaceable"><code>old_col_name</code></em> TO <em class="replaceable"><code>new_col_name</code></em>
  | RENAME {INDEX | KEY} <em class="replaceable"><code>old_index_name</code></em> TO <em class="replaceable"><code>new_index_name</code></em>
  | RENAME [TO | AS] <em class="replaceable"><code>new_tbl_name</code></em>
  | {WITHOUT | WITH} VALIDATION
}

<em class="replaceable"><code>partition_options</code></em>:
    <em class="replaceable"><code>partition_option</code></em> [<em class="replaceable"><code>partition_option</code></em>] ...

<em class="replaceable"><code>partition_option</code></em>: {
    ADD PARTITION (<em class="replaceable"><code>partition_definition</code></em>)
  | DROP PARTITION <em class="replaceable"><code>partition_names</code></em>
  | DISCARD PARTITION {<em class="replaceable"><code>partition_names</code></em> | ALL} TABLESPACE
  | IMPORT PARTITION {<em class="replaceable"><code>partition_names</code></em> | ALL} TABLESPACE
  | TRUNCATE PARTITION {<em class="replaceable"><code>partition_names</code></em> | ALL}
  | COALESCE PARTITION <em class="replaceable"><code>number</code></em>
  | REORGANIZE PARTITION <em class="replaceable"><code>partition_names</code></em> INTO (<em class="replaceable"><code>partition_definitions</code></em>)
  | EXCHANGE PARTITION <em class="replaceable"><code>partition_name</code></em> WITH TABLE <em class="replaceable"><code>tbl_name</code></em> [{WITH | WITHOUT} VALIDATION]
  | ANALYZE PARTITION {<em class="replaceable"><code>partition_names</code></em> | ALL}
  | CHECK PARTITION {<em class="replaceable"><code>partition_names</code></em> | ALL}
  | OPTIMIZE PARTITION {<em class="replaceable"><code>partition_names</code></em> | ALL}
  | REBUILD PARTITION {<em class="replaceable"><code>partition_names</code></em> | ALL}
  | REPAIR PARTITION {<em class="replaceable"><code>partition_names</code></em> | ALL}
  | REMOVE PARTITIONING
}

<em class="replaceable"><code>key_part</code></em>: {<em class="replaceable"><code>col_name</code></em> [(<em class="replaceable"><code>length</code></em>)] | (<em class="replaceable"><code>expr</code></em>)} [ASC | DESC]

<em class="replaceable"><code>index_type</code></em>:
    USING {BTREE | HASH}

<em class="replaceable"><code>index_option</code></em>: {
    KEY_BLOCK_SIZE [=] <em class="replaceable"><code>value</code></em>
  | <em class="replaceable"><code>index_type</code></em>
  | WITH PARSER <em class="replaceable"><code>parser_name</code></em>
  | COMMENT '<em class="replaceable"><code>string</code></em>'
  | {VISIBLE | INVISIBLE}
}

<em class="replaceable"><code>table_options</code></em>:
    <em class="replaceable"><code>table_option</code></em> [[,] <em class="replaceable"><code>table_option</code></em>] ...

<em class="replaceable"><code>table_option</code></em>: {
    AUTOEXTEND_SIZE [=] <em class="replaceable"><code>value</code></em>
  | AUTO_INCREMENT [=] <em class="replaceable"><code>value</code></em>
  | AVG_ROW_LENGTH [=] <em class="replaceable"><code>value</code></em>
  | [DEFAULT] CHARACTER SET [=] <em class="replaceable"><code>charset_name</code></em>
  | CHECKSUM [=] {0 | 1}
  | [DEFAULT] COLLATE [=] <em class="replaceable"><code>collation_name</code></em>
  | COMMENT [=] '<em class="replaceable"><code>string</code></em>'
  | COMPRESSION [=] {'ZLIB' | 'LZ4' | 'NONE'}
  | CONNECTION [=] '<em class="replaceable"><code>connect_string</code></em>'
  | {DATA | INDEX} DIRECTORY [=] '<em class="replaceable"><code>absolute path to directory</code></em>'
  | DELAY_KEY_WRITE [=] {0 | 1}
  | ENCRYPTION [=] {'Y' | 'N'}
  | ENGINE [=] <em class="replaceable"><code>engine_name</code></em>
  | ENGINE_ATTRIBUTE [=] '<em class="replaceable"><code>string</code></em>'
  | INSERT_METHOD [=] { NO | FIRST | LAST }
  | KEY_BLOCK_SIZE [=] <em class="replaceable"><code>value</code></em>
  | MAX_ROWS [=] <em class="replaceable"><code>value</code></em>
  | MIN_ROWS [=] <em class="replaceable"><code>value</code></em>
  | PACK_KEYS [=] {0 | 1 | DEFAULT}
  | PASSWORD [=] '<em class="replaceable"><code>string</code></em>'
  | ROW_FORMAT [=] {DEFAULT | DYNAMIC | FIXED | COMPRESSED | REDUNDANT | COMPACT}
  | SECONDARY_ENGINE_ATTRIBUTE [=] '<em class="replaceable"><code>string</code></em>'
  | STATS_AUTO_RECALC [=] {DEFAULT | 0 | 1}
  | STATS_PERSISTENT [=] {DEFAULT | 0 | 1}
  | STATS_SAMPLE_PAGES [=] <em class="replaceable"><code>value</code></em>
  | TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> [STORAGE {DISK | MEMORY}]
  | UNION [=] (<em class="replaceable"><code>tbl_name</code></em>[,<em class="replaceable"><code>tbl_name</code></em>]...)
}

<em class="replaceable"><code>partition_options</code></em>:
    (see <code class="literal">CREATE TABLE</code> options)
</pre><p>
      <code class="literal">ALTER TABLE</code> は、テーブルの構造を変更します。 たとえば、カラムを追加または削除したり、インデックスを作成または破棄したり、既存のカラムの型を変更したり、カラムまたはテーブル自体の名前を変更したりできます。 また、テーブルに使用されているストレージエンジンやテーブルのコメントなどの特性を変更することもできます。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">ALTER TABLE</code> を使用するには、このテーブルに対する <code class="literal">ALTER</code>、<code class="literal">CREATE</code>、および <code class="literal">INSERT</code> 権限が必要です。 テーブルを名前変更するには、古いテーブル側で <code class="literal">ALTER</code> および <code class="literal">DROP</code> と、新しいテーブル側で <code class="literal">ALTER</code>、<code class="literal">CREATE</code>、および <code class="literal">INSERT</code> 権限が必要です。 
        </p></li><li class="listitem"><p>
          テーブル名のあとに、行う変更を指定します。 何も指定されていない場合、<code class="literal">ALTER TABLE</code> は何もしません。 
        </p></li><li class="listitem"><p>
          許容される変更の多くの構文は、<code class="literal">CREATE TABLE</code> ステートメントの句と似ています。<em class="replaceable"><code>column_definition</code></em> 句では、<code class="literal">ADD</code> および <code class="literal">CHANGE</code> に <code class="literal">CREATE TABLE</code> と同じ構文を使用します。 詳細は、<a class="xref" href="sql-statements.html#create-table" title="13.1.20 CREATE TABLE ステートメント">セクション13.1.20「CREATE TABLE ステートメント」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">COLUMN</code> という語はオプションであり、<code class="literal">RENAME COLUMN</code> を除いて省略できます (<code class="literal">RENAME</code> テーブルのネーミング操作とカラムのネーミング操作を区別するため)。
        </p></li><li class="listitem"><p>
          複数の <code class="literal">ADD</code>, <code class="literal">ALTER</code>, <code class="literal">DROP</code> 句および <code class="literal">CHANGE</code> 句をカンマで区切って単一の <code class="literal">ALTER TABLE</code> ステートメントで使用できます。 これは、<code class="literal">ALTER TABLE</code> ステートメントごとに各句が 1 つしか許可されない標準 SQL への MySQL 拡張です。 たとえば、1 つのステートメントで複数のカラムを削除するには、次のようにします。 
        </p><pre class="programlisting">ALTER TABLE t2 DROP COLUMN c, DROP COLUMN d;
</pre></li><li class="listitem"><p>
          ストレージエンジンが試行された <code class="literal">ALTER TABLE</code> 操作をサポートしていない場合は、警告が表示されることがあります。 このような警告は、<code class="literal">SHOW WARNINGS</code> で表示できます。 <a class="xref" href="sql-statements.html#show-warnings" title="13.7.7.42 SHOW WARNINGS ステートメント">セクション13.7.7.42「SHOW WARNINGS ステートメント」</a>を参照してください。 <code class="literal">ALTER TABLE</code> のトラブルシューティングについては、<a class="xref" href="error-handling.html#alter-table-problems" title="B.3.6.1 ALTER TABLE での問題">セクションB.3.6.1「ALTER TABLE での問題」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          生成されるカラムの詳細は、<a class="xref" href="sql-statements.html#alter-table-generated-columns" title="13.1.9.2 ALTER TABLE および生成されるカラム">セクション13.1.9.2「ALTER TABLE および生成されるカラム」</a> を参照してください。
        </p></li><li class="listitem"><p>
          使用例については、<a class="xref" href="sql-statements.html#alter-table-examples" title="13.1.9.3 ALTER TABLE の例">セクション13.1.9.3「ALTER TABLE の例」</a> を参照してください。
        </p></li><li class="listitem"><p>
          MySQL 8.0.17 以降の <code class="literal">InnoDB</code> では、<em class="replaceable"><code>key_part</code></em> 仕様を使用した JSON カラムへの複数値インデックスの追加を <code class="literal">(CAST <em class="replaceable"><code>json_path</code></em> AS <em class="replaceable"><code>type</code></em> ARRAY)</code> の形式でサポートしています。 複数値インデックスの作成と使用方法、および複数値インデックスの制限および制限の詳細は、<a class="xref" href="sql-statements.html#create-index-multi-valued" title="複数値インデックス">複数値インデックス</a> を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">mysql_info()</code> C API 関数を使用すると、<code class="literal">ALTER TABLE</code> によってコピーされた行数を確認できます。 <a class="ulink" href="https://dev.mysql.com/doc/c-api/8.0/en/mysql-info.html" target="_top">mysql_info()</a>を参照してください。 
        </p><a class="indexterm" name="idm45827007346624"></a></li></ul></div><p>
      このセクションの次のトピックで説明するように、<code class="literal">ALTER TABLE</code> ステートメントにはさらにいくつかの側面があります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#alter-table-options" title="テーブルオプション">テーブルオプション</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#alter-table-performance" title="パフォーマンスおよび領域要件">パフォーマンスおよび領域要件</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#alter-table-concurrency" title="同時実行性制御">同時実行性制御</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#alter-table-add-drop-column" title="カラムの追加および削除">カラムの追加および削除</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#alter-table-redefine-column" title="カラムの名前変更、再定義および並替え">カラムの名前変更、再定義および並替え</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#alter-table-index" title="主キーとインデックス">主キーとインデックス</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#alter-table-foreign-key" title="外部キーおよびその他の制約">外部キーおよびその他の制約</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#alter-table-character-set" title="文字セットの変更">文字セットの変更</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#alter-table-import" title="InnoDB テーブルのインポート">InnoDB テーブルのインポート</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#alter-table-row-order" title="MyISAM テーブルの行順序">MyISAM テーブルの行順序</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#alter-table-partition-options" title="パーティショニングオプション">パーティショニングオプション</a></p></li></ul></div><h4><a name="alter-table-options"></a>テーブルオプション</h4><p>
      <em class="replaceable"><code>table_options</code></em> は、<code class="literal">ENGINE</code>, <code class="literal">AUTO_INCREMENT</code>, <code class="literal">AVG_ROW_LENGTH</code>, <code class="literal">MAX_ROWS</code>, <code class="literal">ROW_FORMAT</code> や <code class="literal">TABLESPACE</code> などの <code class="literal">CREATE TABLE</code> ステートメントで使用できる種類のテーブルオプションを示します。
    </p><p>
      すべてのテーブルオプションの詳細は、<a class="xref" href="sql-statements.html#create-table" title="13.1.20 CREATE TABLE ステートメント">セクション13.1.20「CREATE TABLE ステートメント」</a> を参照してください。 ただし、テーブルオプションとして指定されている場合、<code class="literal">ALTER TABLE</code> は <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> を無視します。 <code class="literal">ALTER TABLE</code> では、パーティション化オプションとしてのみ使用でき、<code class="literal">FILE</code> 権限が必要です。 
    </p><p>
      <code class="literal">ALTER TABLE</code> でテーブルオプションを使用すると、単一のテーブル特性を簡単に変更できます。 例: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">t1</code> が現在 <code class="literal">InnoDB</code> テーブルでない場合、次のステートメントはストレージエンジンを <code class="literal">InnoDB</code> に変更します:
        </p><pre class="programlisting">ALTER TABLE t1 ENGINE = InnoDB;
</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              テーブルを <code class="literal">InnoDB</code> ストレージエンジンに切り替えるときの考慮事項については、<a class="xref" href="innodb-storage-engine.html#converting-tables-to-innodb" title="15.6.1.5 MyISAM から InnoDB へのテーブルの変換">セクション15.6.1.5「MyISAM から InnoDB へのテーブルの変換」</a>を参照してください。
            </p></li><li class="listitem"><p>
              <code class="literal">ENGINE</code> 句を指定すると、<code class="literal">ALTER TABLE</code> はテーブルを再構築します。 これは、そのテーブルに指定されたストレージエンジンがすでに存在する場合にも当てはまります。 
            </p></li><li class="listitem"><p>
              既存の <code class="literal">InnoDB</code> テーブルに対して <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ENGINE=INNODB</code> を実行すると、<span class="quote">「<span class="quote">null</span>」</span> <code class="literal">ALTER TABLE</code> 操作が実行されます。これは、<a class="xref" href="innodb-storage-engine.html#innodb-file-defragmenting" title="15.11.4 テーブルのデフラグ">セクション15.11.4「テーブルのデフラグ」</a>で説明されているように、<code class="literal">InnoDB</code> テーブルのデフラグに使用できます。 <code class="literal">InnoDB</code> テーブルに対して <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> FORCE</code> を実行しても、同じ機能が実行されます。 
            </p></li><li class="listitem"><p>
              <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ENGINE=INNODB</code> および <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> FORCE</code> では、<a class="link" href="innodb-storage-engine.html#innodb-online-ddl" title="15.12 InnoDB とオンライン DDL">online DDL</a> を使用します。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl" title="15.12 InnoDB とオンライン DDL">セクション15.12「InnoDB とオンライン DDL」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              テーブルのストレージエンジンを変更しようとした結果は、<a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a> で説明されているように、目的のストレージエンジンが使用可能かどうか、および <code class="literal">NO_ENGINE_SUBSTITUTION</code> SQL モードの設定の影響を受けます。
            </p></li><li class="listitem"><p>
              データが誤って失われることのないように、<code class="literal">ALTER TABLE</code> を使用して、テーブルのストレージエンジンを <code class="literal">MERGE</code> または <code class="literal">BLACKHOLE</code> に変更することはできません。
            </p></li></ul></div></li><li class="listitem"><p>
          圧縮された行ストレージ形式を使用するように <code class="literal">InnoDB</code> テーブルを変更するには:
        </p><pre class="programlisting">ALTER TABLE t1 ROW_FORMAT = COMPRESSED;
</pre></li><li class="listitem"><p>
          <code class="literal">ENCRYPTION</code> 句は、<code class="literal">InnoDB</code> テーブルのページレベルのデータ暗号化を有効または無効にします。 暗号化を有効にするには、キーリングプラグインをインストールして構成する必要があります。 
        </p><p>
          <code class="literal">table_encryption_privilege_check</code> 変数が有効になっている場合、デフォルトのスキーマ暗号化設定とは異なる設定で <code class="literal">ENCRYPTION</code> 句を使用するには、<code class="literal">TABLE_ENCRYPTION_ADMIN</code> 権限が必要です。
        </p><p>
          MySQL 8.0.16 より前では、<code class="literal">ENCRYPTION</code> 句は file-per-table テーブルスペースに存在するテーブルを変更する場合にのみサポートされていました。 MySQL 8.0.16 では、<code class="literal">ENCRYPTION</code> 句は一般的なテーブルスペースに存在するテーブルに対してもサポートされています。 
        </p><p>
          一般的なテーブルスペースに存在するテーブルの場合、テーブルとテーブルスペースの暗号化は一致する必要があります。
        </p><p>
          テーブルを別のテーブルスペースに移動したり、ストレージエンジンを変更したりしてテーブルの暗号化を変更したりするには、<code class="literal">ENCRYPTION</code> 句を明示的に指定する必要があります。
        </p><p>
          MySQL 8.0.16 の時点では、暗号化をサポートしていないストレージエンジンがテーブルで使用されている場合、<code class="literal">'N'</code>または<code class="literal">''</code>以外の値で <code class="literal">ENCRYPTION</code> 句を指定することはできません。 以前は、条項は受け入れられました。 暗号化をサポートしていないストレージエンジンを使用して、暗号化対応スキーマで <code class="literal">ENCRYPTION</code> 句なしでテーブルを作成しようとすることも許可されていません。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-data-encryption" title="15.13 InnoDB 保存データ暗号化">セクション15.13「InnoDB 保存データ暗号化」</a>を参照してください。
        </p></li><li class="listitem"><p>
          現在の自動インクリメント値をリセットするには:
        </p><pre class="programlisting">ALTER TABLE t1 AUTO_INCREMENT = 13;
</pre><p>
          このカウンタを、現在使用されている値以下の値にリセットすることはできません。 <code class="literal">InnoDB</code> と <code class="literal">MyISAM</code> のどちらの場合も、この値が現在 <code class="literal">AUTO_INCREMENT</code> カラム内にある最大値以下である場合、この値は現在の <code class="literal">AUTO_INCREMENT</code> カラムの最大値に 1 を加えた値にリセットされます。 
        </p></li><li class="listitem"><p>
          デフォルトのテーブルの文字セットを変更するには:
        </p><pre class="programlisting">ALTER TABLE t1 CHARACTER SET = utf8;
</pre><p>
          <a class="xref" href="sql-statements.html#alter-table-character-set" title="文字セットの変更">文字セットの変更</a>も参照してください。
        </p></li><li class="listitem"><p>
          テーブルコメントを追加 (または変更) するには:
        </p><pre class="programlisting">ALTER TABLE t1 COMMENT = 'New table comment';
</pre></li><li class="listitem"><p>
          既存の <a class="link" href="glossary.html#glos_general_tablespace" title="一般テーブルスペース">general tablespaces</a>、<a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースおよび <a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">system tablespace</a> 間で <code class="literal">InnoDB</code> テーブルを移動するには、<code class="literal">TABLESPACE</code> オプションを指定して <code class="literal">ALTER TABLE</code> を使用します。 <a class="xref" href="innodb-storage-engine.html#general-tablespaces-moving-non-partitioned-tables" title="ALTER TABLE を使用したテーブルスペース間のテーブルの移動">ALTER TABLE を使用したテーブルスペース間のテーブルの移動</a>を参照してください。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">ALTER TABLE ... TABLESPACE</code> 操作では、<code class="literal">TABLESPACE</code> 属性が以前の値から変更されていない場合でも、常に全テーブルが再構築されます。
            </p></li><li class="listitem"><p>
              <code class="literal">ALTER TABLE ... TABLESPACE</code> 構文では、一時テーブルスペースから永続テーブルスペースへのテーブルの移動はサポートされていません。
            </p></li><li class="listitem"><p>
              <code class="literal">CREATE TABLE ... TABLESPACE</code> でサポートされている <code class="literal">DATA DIRECTORY</code> 句は、<code class="literal">ALTER TABLE ... TABLESPACE</code> ではサポートされず、指定されている場合は無視されます。
            </p></li><li class="listitem"><p>
              <code class="literal">TABLESPACE</code> オプションの機能および制限の詳細は、<code class="literal">CREATE TABLE</code> を参照してください。
            </p></li></ul></div></li><li class="listitem"><p>
          MySQL NDB Cluster 8.0 は、次の例に示すように、<code class="literal">ALTER TABLE</code> ステートメントのテーブルコメントの一部として、テーブルパーティションバランス (フラグメントカウントタイプ)、read-from-any-replica 機能、フルレプリケーション、またはこれらの任意の組み合わせを <code class="literal">CREATE TABLE</code> と同じ方法で制御するための <code class="literal">NDB_TABLE</code> オプションの設定をサポートしています:
        </p><pre class="programlisting">ALTER TABLE t1 COMMENT = "NDB_TABLE=READ_BACKUP=0,PARTITION_BALANCE=FOR_RA_BY_NODE";
</pre><p>
          <code class="literal">ALTER TABLE ... COMMENT ...</code> では、テーブルの既存のコメントはすべて破棄されることに注意してください。 追加情報および例については、<a class="xref" href="sql-statements.html#create-table-comment-ndb-table-options" title="「NDB_TABLE の設定」オプション">「NDB_TABLE の設定」オプション</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">ENGINE_ATTRIBUTE</code> および <code class="literal">SECONDARY_ENGINE_ATTRIBUTE</code> オプション (MySQL 8.0.21 の時点で使用可能) は、プライマリおよびセカンダリストレージエンジンのテーブル、カラム、およびインデックス属性を指定するために使用されます。 オプションは、将来の使用のために予約されています。 インデックス属性は変更できません。 インデックスを削除し、必要な変更を加えて再度追加する必要があります。これは、単一の <code class="literal">ALTER TABLE</code> ステートメントで実行できます。 
        </p></li></ul></div><p>
      テーブルオプションが意図したとおりに変更されたことを確認するには、<code class="literal">SHOW CREATE TABLE</code> を使用するか、<code class="literal">INFORMATION_SCHEMA.TABLES</code> テーブルをクエリーします。
    </p><h4><a name="alter-table-performance"></a>パフォーマンスおよび領域要件</h4><p>
      <code class="literal">ALTER TABLE</code> 操作は、次のいずれかのアルゴリズムを使用して処理されます:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">COPY</code>: 操作は元のテーブルのコピーに対して実行され、テーブルデータは元のテーブルから新しいテーブルの行ごとにコピーされます。 同時 DML は許可されません。 
        </p></li><li class="listitem"><p>
          <code class="literal">INPLACE</code>: 操作ではテーブルデータのコピーは回避されますが、テーブルが適切に再構築される可能性があります。 操作の準備フェーズおよび実行フェーズでは、テーブルに対する排他的メタデータロックが短時間で取得される場合があります。 通常、同時 DML はサポートされています。 
        </p></li><li class="listitem"><p>
          <code class="literal">INSTANT</code>: 操作では、データディクショナリ内のメタデータのみが変更されます。 準備および実行中にテーブルに対する排他的メタデータロックは行われず、テーブルデータは影響を受けず、操作が即時に行われます。 同時 DML が許可されます。 (MySQL 8.0.12 で導入) 
        </p></li></ul></div><p>
      <code class="literal">ALGORITHM</code> 句はオプションです。 <code class="literal">ALGORITHM</code> 句を省略すると、MySQL では、ストレージエンジンおよびそれをサポートする <code class="literal">ALTER TABLE</code> 句に <code class="literal">ALGORITHM=INSTANT</code> が使用されます。 それ以外の場合は、<code class="literal">ALGORITHM=INPLACE</code> が使用されます。 <code class="literal">ALGORITHM=INPLACE</code> がサポートされていない場合、<code class="literal">ALGORITHM=COPY</code> が使用されます。 
    </p><p>
      <code class="literal">ALGORITHM</code> 句を指定するには、それをサポートする句およびストレージエンジンに指定されたアルゴリズムを使用する操作が必要です。そうしないと、エラーで失敗します。 <code class="literal">ALGORITHM=DEFAULT</code> を指定することは、<code class="literal">ALGORITHM</code> 句を省略することと同じです。 
    </p><p>
      <code class="literal">COPY</code> アルゴリズムを使用する <code class="literal">ALTER TABLE</code> 操作は、テーブルを変更している他の操作が完了するまで待機します。 変更がテーブルコピーに適用されると、データがコピーされ、元のテーブルが削除され、テーブルコピーの名前が元のテーブルの名前に変更されます。 <code class="literal">ALTER TABLE</code> 操作の実行中、元のテーブルは他のセッションで読取り可能です (ただし、すぐに記載されている例外があります)。 <code class="literal">ALTER TABLE</code> 操作の開始後に開始されたテーブルの更新および書込みは、新しいテーブルの準備ができるまで停止され、新しいテーブルに自動的にリダイレクトされます。 テーブルの一時コピーは、別のディレクトリに存在するデータベースにテーブルを移動する <code class="literal">RENAME TO</code> 操作でないかぎり、元のテーブルのデータベースディレクトリに作成されます。 
    </p><p>
      前述の例外は、古いテーブル構造をテーブルおよびテーブル定義キャッシュからクリアする準備が整った時点で、<code class="literal">ALTER TABLE</code> が読取り (書込みのみではなく) をブロックすることです。 この時点で、このステートメントは排他的ロックを取得する必要があります。 これを行うには、現在のリーダーが終了するまで待機し、新しい読取りおよび書込みをブロックします。 
    </p><p>
      <code class="literal">COPY</code> アルゴリズムを使用する <code class="literal">ALTER TABLE</code> 操作により、同時 DML 操作が防止されます。 並列クエリーは、引き続き許可されます。 つまり、テーブルコピー操作には常に、少なくとも <code class="literal">LOCK=SHARED</code> (クエリーを許可するが、DML は許可しない) の並列性の制限が含まれます。 DML およびクエリーを防止する <code class="literal">LOCK=EXCLUSIVE</code> を指定することで、<code class="literal">LOCK</code> 句をサポートする操作の同時実行性をさらに制限できます。 詳細は、<a class="xref" href="sql-statements.html#alter-table-concurrency" title="同時実行性制御">同時実行性制御</a>を参照してください。 
    </p><p>
      それ以外の場合は使用しない <code class="literal">ALTER TABLE</code> 操作に <code class="literal">COPY</code> アルゴリズムを強制的に使用するには、<code class="literal">ALGORITHM=COPY</code> を指定するか、<code class="literal">old_alter_table</code> システム変数を有効にします。 <code class="literal">old_alter_table</code> 設定と、<code class="literal">DEFAULT</code> 以外の値を持つ <code class="literal">ALGORITHM</code> 句の間に矛盾がある場合は、<code class="literal">ALGORITHM</code> 句が優先されます。 
    </p><p>
      <code class="literal">InnoDB</code> テーブルの場合、<a class="link" href="glossary.html#glos_shared_tablespace" title="共有テーブルスペース">shared tablespace</a> に存在するテーブルで <code class="literal">COPY</code> アルゴリズムを使用する <code class="literal">ALTER TABLE</code> 操作によって、テーブルスペースで使用される領域の量が増加する可能性があります。 このような操作には、テーブルのデータとインデックスと同じ追加領域が必要です。 共有テーブルスペースに存在するテーブルの場合、操作中に使用された追加領域は、<a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースに存在するテーブル用であるため、オペレーティングシステムに解放されません。 
    </p><p>
      オンライン DDL 操作の領域要件の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-space-requirements" title="15.12.3 オンライン DDL 領域の要件">セクション15.12.3「オンライン DDL 領域の要件」</a> を参照してください。
    </p><p>
      <code class="literal">INPLACE</code> アルゴリズムをサポートする <code class="literal">ALTER TABLE</code> 操作には、次のものがあります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_online_ddl" title="オンライン DDL">online DDL</a> 機能でサポートされている <code class="literal">ALTER TABLE</code> 操作。 <a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-operations" title="15.12.1 オンライン DDL 操作">セクション15.12.1「オンライン DDL 操作」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          テーブルの名前の変更。 MySQL は、コピーを作成せずに、テーブル <em class="replaceable"><code>tbl_name</code></em> に対応するファイルの名前を変更します。 (<code class="literal">RENAME TABLE</code> ステートメントを使用してテーブルの名前を変更することもできます。 <a class="xref" href="sql-statements.html#rename-table" title="13.1.36 RENAME TABLE ステートメント">セクション13.1.36「RENAME TABLE ステートメント」</a>を参照してください。) 名前を変更したテーブル専用に付与された権限は、新しい名前に移行されません。 それらは、手動で変更する必要があります。 
        </p></li><li class="listitem"><p>
          テーブルメタデータのみを変更する操作。 サーバーがテーブルの内容に触れないため、これらの操作はすぐに行われます。 メタデータのみの操作には次のものがあります: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              カラム名の変更。 NDB Cluster 8.0.18 以降では、この操作をオンラインで実行することもできます。 
            </p></li><li class="listitem"><p>
              カラムのデフォルト値の変更 (<code class="literal">NDB</code> テーブルを除く)。
            </p></li><li class="listitem"><p>
              データ型の記憶域サイズが変更されないかぎり、新しい列挙を追加するか、有効なメンバー値のリストの <span class="emphasis"><em>end</em></span> にメンバーを設定して、<code class="literal">ENUM</code> または <code class="literal">SET</code> カラムの定義を変更します。 たとえば、8 つのメンバーを持つ <code class="literal">SET</code> カラムにメンバーを追加すると、値ごとに必要な記憶域が 1 バイトから 2 バイトに変更されます。これにはテーブルのコピーが必要です。 リストの途中にメンバーを追加すると、既存のメンバーの番号が変更されます。これには、テーブルコピーが必要になります。 
            </p></li><li class="listitem"><p>
              空間カラムの定義を変更して、<code class="literal">SRID</code> 属性を削除します。 (<code class="literal">SRID</code> 属性を追加または変更するには再構築が必要であり、サーバーはすべての値に指定された SRID 値があることを確認する必要があるため、再構築を実行できません。) 
            </p></li><li class="listitem"><p>
              MySQL 8.0.14 では、次の条件が適用される場合にカラムの文字セットを変更します:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                  カラムのデータ型は、<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、<code class="literal">TEXT</code> 型または <code class="literal">ENUM</code> です。
                </p></li><li class="listitem"><p>
                  文字セットの変更は、<code class="literal">utf8mb3</code> から <code class="literal">utf8mb4</code> へ、または任意の文字セットから <code class="literal">binary</code> へです。
                </p></li><li class="listitem"><p>
                  カラムにインデックスがありません。
                </p></li></ul></div></li><li class="listitem"><p>
              MySQL 8.0.14 では、次の条件が適用される場合、生成されたカラムを変更します:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                  <code class="literal">InnoDB</code> テーブルの場合、生成されたストアドカラムを変更するが、その型、式または NULL 値可能性は変更しないステートメント。
                </p></li><li class="listitem"><p>
                  <code class="literal">InnoDB</code> 以外のテーブルの場合、生成されたストアドカラムまたは仮想カラムを変更するが、型、式または NULL 値可能性は変更しないステートメント。
                </p></li></ul></div><p>
              このような変更の例として、カラムコメントの変更があります。
            </p></li></ul></div></li><li class="listitem"><p>
          インデックスの名前変更。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> および <code class="literal">NDB</code> テーブルのセカンダリインデックスの追加または削除。 <a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-operations" title="15.12.1 オンライン DDL 操作">セクション15.12.1「オンライン DDL 操作」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">NDB</code> テーブルの場合、可変幅のカラムに対してインデックスを追加および削除する操作。 これらの操作は、テーブルのコピーなし、および同時 DML アクションをブロックせずに、ほとんどの期間オンラインで実行されます。 <a class="xref" href="mysql-cluster.html#mysql-cluster-online-operations" title="23.5.11 NDB Cluster での ALTER TABLE を使用したオンライン操作">セクション23.5.11「NDB Cluster での ALTER TABLE を使用したオンライン操作」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">ALTER INDEX</code> 操作によるインデックスの可視性の変更。
        </p></li><li class="listitem"><p>
          変更されたカラムが生成されたカラム式に含まれていない場合に、<code class="literal">DEFAULT</code> 値を持つカラムに依存する生成されたカラムを含むテーブルのカラムの変更。 たとえば、テーブルを再構築せずに、別のカラムの <code class="literal">NULL</code> プロパティを変更できます。 
        </p></li></ul></div><p>
      <code class="literal">INSTANT</code> アルゴリズムをサポートする <code class="literal">ALTER TABLE</code> 操作には、次のものがあります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          カラムの追加。 この機能は、<span class="quote">「<span class="quote">「インスタント <code class="literal">ADD COLUMN</code>」</span>」</span>と呼ばれます。 制限が適用されます。 <a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-operations" title="15.12.1 オンライン DDL 操作">セクション15.12.1「オンライン DDL 操作」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          仮想カラムの追加または削除。
        </p></li><li class="listitem"><p>
          カラムのデフォルト値の追加または削除。
        </p></li><li class="listitem"><p>
          <code class="literal">ENUM</code> または <code class="literal">SET</code> カラムの定義の変更。 前述の <code class="literal">ALGORITHM=INSTANT</code> の場合と同じ制限が適用されます。 
        </p></li><li class="listitem"><p>
          インデックスタイプの変更。
        </p></li><li class="listitem"><p>
          テーブルの名前の変更。 前述の <code class="literal">ALGORITHM=INSTANT</code> の場合と同じ制限が適用されます。 
        </p></li></ul></div><p>
      <code class="literal">ALGORITHM=INSTANT</code> をサポートする操作の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-operations" title="15.12.1 オンライン DDL 操作">セクション15.12.1「オンライン DDL 操作」</a> を参照してください。
    </p><p>
      <code class="literal">ALTER TABLE</code> は、<code class="literal">ADD COLUMN</code>, <code class="literal">CHANGE COLUMN</code>, <code class="literal">MODIFY COLUMN</code>, <code class="literal">ADD INDEX</code> および <code class="literal">FORCE</code> 操作のために、MySQL 5.5 一時カラムを 5.6 形式にアップグレードします。 テーブルを再構築しなければならないため、この変換は <code class="literal">INPLACE</code> アルゴリズムを使用して実行することはできません。そのため、これらの場合に <code class="literal">ALGORITHM=INPLACE</code> を指定するとエラーになります。 必要であれば、<code class="literal">ALGORITHM=COPY</code> を指定します。 
    </p><p>
      <code class="literal">KEY</code> によってテーブルをパーティション化するために使用される複数カラムインデックスに対する <code class="literal">ALTER TABLE</code> 操作によってカラムの順序が変更される場合は、<code class="literal">ALGORITHM=COPY</code> を使用してのみ実行できます。
    </p><p>
      <code class="literal">WITHOUT VALIDATION</code> 句および <code class="literal">WITH VALIDATION</code> 句は、<code class="literal">ALTER TABLE</code> が <a class="link" href="glossary.html#glos_virtual_generated_column" title="仮想生成カラム">virtual generated column</a> の変更に対してインプレース操作を実行するかどうかに影響します。 <a class="xref" href="sql-statements.html#alter-table-generated-columns" title="13.1.9.2 ALTER TABLE および生成されるカラム">セクション13.1.9.2「ALTER TABLE および生成されるカラム」</a>を参照してください。 
    </p><p>
      NDB Cluster 8.0 は、標準 MySQL Server で使用されるものと同じ <code class="literal">ALGORITHM=INPLACE</code> 構文を使用したオンライン操作をサポートします。 <code class="literal">NDB</code> はオンラインでのテーブルスペースの変更をサポートしていません。NDB 8.0.21 以降では許可されません。 詳しくは<a class="xref" href="mysql-cluster.html#mysql-cluster-online-operations" title="23.5.11 NDB Cluster での ALTER TABLE を使用したオンライン操作">セクション23.5.11「NDB Cluster での ALTER TABLE を使用したオンライン操作」</a>,をご覧ください。 
    </p><p>
      <code class="literal">DISCARD ... PARTITION ... TABLESPACE</code> または <code class="literal">IMPORT ... PARTITION ... TABLESPACE</code> を使用した <code class="literal">ALTER TABLE</code> では、一時テーブルまたは一時パーティションファイルは作成されません。
    </p><p>
      <code class="literal">ALTER TABLE</code> with <code class="literal">ADD PARTITION</code>, <code class="literal">DROP PARTITION</code>, <code class="literal">COALESCE PARTITION</code>, <code class="literal">REBUILD PARTITION</code> または <code class="literal">REORGANIZE PARTITION</code> では、一時テーブルは作成されません (<code class="literal">NDB</code> テーブルとともに使用する場合を除く)。ただし、これらの操作では一時パーティションファイルを作成でき、作成できます。
    </p><p>
      <code class="literal">RANGE</code> または <code class="literal">LIST</code> パーティションに対する <code class="literal">ADD</code> または <code class="literal">DROP</code> 操作は即座の操作か、ほぼ即座の操作です。 <code class="literal">HASH</code> または <code class="literal">KEY</code> パーティションに対する <code class="literal">ADD</code> または <code class="literal">COALESCE</code> 操作では、<code class="literal">LINEAR HASH</code> または <code class="literal">LINEAR KEY</code> が使用されていないかぎり、すべてのパーティション間でデータがコピーされます。<code class="literal">ADD</code> または <code class="literal">COALESCE</code> 操作はパーティションごとに実行されますが、これは実質的に、新しいテーブルの作成と同じです。 <code class="literal">REORGANIZE</code> 操作では変更されたパーティションのみがコピーされ、変更されていないものはそのままです。 
    </p><p>
      <code class="literal">MyISAM</code> テーブルの場合は、<code class="literal">myisam_sort_buffer_size</code> システム変数を大きな値に設定することによって、インデックスの再作成 (変更プロセスのもっとも遅い部分) を高速化できます。
    </p><h4><a name="alter-table-concurrency"></a>同時実行性制御</h4><p>
      これをサポートする <code class="literal">ALTER TABLE</code> 操作の場合は、<code class="literal">LOCK</code> 句を使用して、テーブルの変更中の同時読取りおよび書込みのレベルを制御できます。 この句にデフォルト以外の値を指定すると、変更操作中に特定の量の同時アクセスまたは排他性を必要とし、リクエストされたロックの程度が使用できない場合は操作を停止できます。 
    </p><p>
      <code class="literal">ALGORITHM=INSTANT</code> を使用する操作には、<code class="literal">LOCK = DEFAULT</code> のみが許可されます。 その他の <code class="literal">LOCK</code> 句パラメータは適用できません。 
    </p><p>
      <code class="literal">LOCK</code> 句のパラメータは次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
</p><pre class="programlisting">LOCK = DEFAULT
</pre><p>

          指定された <code class="literal">ALGORITHM</code> 句 (存在する場合) および <code class="literal">ALTER TABLE</code> 操作に対する最大レベルの並列性: サポートされている場合は、並列読み取りおよび書き込みを許可します。 そうでない場合、サポートされている場合は、並列読み取りを許可します。 そうでない場合は、排他的アクセスを適用します。 
        </p></li><li class="listitem"><p>
</p><pre class="programlisting">LOCK = NONE
</pre><p>

          サポートされている場合は、並列読み取りおよび書き込みを許可します。 それ以外の場合は、エラーが発生します。 
        </p></li><li class="listitem"><p>
</p><pre class="programlisting">LOCK = SHARED
</pre><p>

          サポートされている場合は、並列読み取りを許可しますが、書き込みはブロックします。 ストレージエンジンが指定された <code class="literal">ALGORITHM</code> 句 (存在する場合) および <code class="literal">ALTER TABLE</code> 操作に対して同時書き込みをサポートしている場合でも、書き込みはブロックされます。 同時読取りがサポートされていない場合は、エラーが発生します。 
        </p></li><li class="listitem"><p>
</p><pre class="programlisting">LOCK = EXCLUSIVE
</pre><p>

          排他的アクセスを適用します。 これは、指定された <code class="literal">ALGORITHM</code> 句 (存在する場合) および <code class="literal">ALTER TABLE</code> 操作について、ストレージエンジンによって同時読み取り/書き込みがサポートされている場合でも実行されます。 
        </p></li></ul></div><h4><a name="alter-table-add-drop-column"></a>カラムの追加および削除</h4><p>
      <code class="literal">ADD</code> を使用してテーブルに新しいカラムを追加し、<code class="literal">DROP</code> を使用して既存のカラムを削除します。 <code class="literal">DROP <em class="replaceable"><code>col_name</code></em></code> は、標準 SQL に対する MySQL の拡張機能です。 
    </p><p>
      テーブル行内の特定の位置にカラムを追加するには、<code class="literal">FIRST</code> または <code class="literal">AFTER <em class="replaceable"><code>col_name</code></em></code> を使用します。 デフォルトでは、そのカラムを最後に追加します。 
    </p><p>
      テーブルに 1 つのカラムしか含まれていない場合は、そのカラムを削除できません。 テーブルを削除する場合は、かわりに <code class="literal">DROP TABLE</code> ステートメントを使用します。 
    </p><p>
      テーブルからカラムが削除された場合、そのカラムは、それが含まれているすべてのインデックスからも削除されます。 インデックスを構成するすべてのカラムが削除された場合は、そのインデックスも削除されます。 <code class="literal">CHANGE</code> または <code class="literal">MODIFY</code> を使用して、インデックスが存在するカラムを短くしたときに、結果として得られるカラムの長さがインデックスの長さより短くなった場合、MySQL は自動的にそのインデックスを短くします。 
    </p><p>
      <code class="literal">ALTER TABLE ... ADD</code> では、カラムに非決定的関数を使用する式のデフォルト値がある場合、ステートメントによって警告またはエラーが生成されることがあります。 詳細は、<a class="xref" href="data-types.html#data-type-defaults" title="11.6 データ型デフォルト値">セクション11.6「データ型デフォルト値」</a> および <a class="xref" href="replication.html#replication-gtids-restrictions" title="17.1.3.7 GTID ベースレプリケーションの制約">セクション17.1.3.7「GTID ベースレプリケーションの制約」</a> を参照してください。 
    </p><h4><a name="alter-table-redefine-column"></a>カラムの名前変更、再定義および並替え</h4><a class="indexterm" name="idm45827007030544"></a><a class="indexterm" name="idm45827007028512"></a><a class="indexterm" name="idm45827007026480"></a><a class="indexterm" name="idm45827007024448"></a><p>
      <code class="literal">CHANGE</code>, <code class="literal">MODIFY</code>, <code class="literal">RENAME COLUMN</code> 句および <code class="literal">ALTER</code> 句を使用すると、既存のカラムの名前および定義を変更できます。 これらには次のような比較特性があります: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">CHANGE</code>:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              カラムの名前を変更し、その定義を変更するか、その両方を行うことができます。
            </p></li><li class="listitem"><p>
              <code class="literal">MODIFY</code> または <code class="literal">RENAME COLUMN</code> よりも多くの機能を備えていますが、一部の操作には便宜上役立ちます。 <code class="literal">CHANGE</code> では、名前を変更しない場合はカラムの名前を 2 回指定する必要があり、名前の変更のみの場合はカラム定義を再指定する必要があります。 
            </p></li><li class="listitem"><p>
              <code class="literal">FIRST</code> または <code class="literal">AFTER</code> では、カラムを並べ替えることができます。
            </p></li></ul></div></li><li class="listitem"><p>
          <code class="literal">MODIFY</code>:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              カラム定義は変更できますが、名前は変更できません。
            </p></li><li class="listitem"><p>
              <code class="literal">CHANGE</code> よりも、名前を変更せずにカラム定義を変更する方が便利です。
            </p></li><li class="listitem"><p>
              <code class="literal">FIRST</code> または <code class="literal">AFTER</code> では、カラムを並べ替えることができます。
            </p></li></ul></div></li><li class="listitem"><p>
          <code class="literal">RENAME COLUMN</code>:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              カラム名は変更できますが、その定義は変更できません。
            </p></li><li class="listitem"><p>
              <code class="literal">CHANGE</code> よりも、定義を変更せずにカラムの名前を変更する方が便利です。
            </p></li></ul></div></li><li class="listitem"><p>
          <code class="literal">ALTER</code>: カラムのデフォルト値を変更するためにのみ使用されます。
        </p></li></ul></div><a class="indexterm" name="idm45827006996752"></a><a class="indexterm" name="idm45827006995312"></a><p>
      <code class="literal">CHANGE</code> は、標準 SQL に対する MySQL の拡張機能です。 <code class="literal">MODIFY</code> および <code class="literal">RENAME COLUMN</code> は、Oracle との互換性のための MySQL の拡張機能です。 
    </p><p>
      カラムを変更してその名前と定義の両方を変更するには、古い名前と新しい名前、および新しい定義を指定して <code class="literal">CHANGE</code> を使用します。 たとえば、<code class="literal">INT NOT NULL</code> カラムの名前を <code class="literal">a</code> から <code class="literal">b</code> に変更し、<code class="literal">NOT NULL</code> 属性を保持したまま <code class="literal">BIGINT</code> データ型を使用するようにその定義を変更するには、次のようにします: 
    </p><pre class="programlisting">ALTER TABLE t1 CHANGE a b BIGINT NOT NULL;
</pre><p>
      名前ではなくカラム定義を変更するには、<code class="literal">CHANGE</code> または <code class="literal">MODIFY</code> を使用します。 <code class="literal">CHANGE</code> では、構文に 2 つのカラム名が必要であるため、名前を変更せずに同じ名前を 2 回指定する必要があります。 たとえば、カラム <code class="literal">b</code> の定義を変更するには、次のようにします: 
    </p><pre class="programlisting">ALTER TABLE t1 CHANGE b b INT NOT NULL;
</pre><p>
      <code class="literal">MODIFY</code> では、カラム名が必要になるのは一度のみであるため、名前を変更せずに定義を変更する方が便利です:
    </p><pre class="programlisting">ALTER TABLE t1 MODIFY b INT NOT NULL;
</pre><p>
      カラム名を変更するが、その定義は変更しない場合は、<code class="literal">CHANGE</code> または <code class="literal">RENAME COLUMN</code> を使用します。 <code class="literal">CHANGE</code> では、構文にカラム定義が必要であるため、定義を変更しないでおくには、カラムに現在設定されている定義を再指定する必要があります。 たとえば、<code class="literal">INT NOT NULL</code> カラムの名前を <code class="literal">b</code> から <code class="literal">a</code> に変更するには、次のようにします: 
    </p><pre class="programlisting">ALTER TABLE t1 CHANGE b a INT NOT NULL;
</pre><p>
      <code class="literal">RENAME COLUMN</code> では、古い名前と新しい名前のみが必要なため、定義を変更せずに名前を変更する方が便利です:
    </p><pre class="programlisting">ALTER TABLE t1 RENAME COLUMN b TO a;
</pre><p>
      一般に、カラムの名前をテーブルにすでに存在する名前に変更することはできません。 ただし、名前を入れ替えたりサイクル内で移動したりする場合などには、これは当てはまらないことがあります。 テーブルに <code class="literal">a</code>、<code class="literal">b</code> および <code class="literal">c</code> という名前のカラムがある場合、これらは有効な操作です: 
    </p><pre class="programlisting">-- swap a and b
ALTER TABLE t1 RENAME COLUMN a TO b,
               RENAME COLUMN b TO a;
-- "rotate" a, b, c through a cycle
ALTER TABLE t1 RENAME COLUMN a TO b,
               RENAME COLUMN b TO c,
               RENAME COLUMN c TO a;
</pre><p>
      <code class="literal">CHANGE</code> または <code class="literal">MODIFY</code> を使用してカラム定義を変更する場合、<code class="literal">PRIMARY KEY</code> や <code class="literal">UNIQUE</code> などのインデックス属性以外の、新しいカラムに適用するデータ型およびすべての属性を定義に含める必要があります。 元の定義には存在するが、新しい定義として指定されていない属性は引き継がれません。 カラム <code class="literal">col1</code> が <code class="literal">INT UNSIGNED DEFAULT 1 COMMENT 'my column'</code>として定義されており、カラムを次のように変更して、<code class="literal">INT</code> のみを <code class="literal">BIGINT</code> に変更するとします: 
    </p><pre class="programlisting">ALTER TABLE t1 MODIFY col1 BIGINT;
</pre><p>
      このステートメントは、データ型を <code class="literal">INT</code> から <code class="literal">BIGINT</code> に変更しますが、<code class="literal">UNSIGNED</code>、<code class="literal">DEFAULT</code> および <code class="literal">COMMENT</code> 属性も削除します。 これらを保持するには、ステートメントに明示的に含める必要があります: 
    </p><pre class="programlisting">ALTER TABLE t1 MODIFY col1 BIGINT UNSIGNED DEFAULT 1 COMMENT 'my column';
</pre><p>
      <code class="literal">CHANGE</code> または <code class="literal">MODIFY</code> を使用してデータ型を変更する場合、MySQL は既存のカラム値を可能なかぎり新しい型に変換しようとします。
    </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
        この変換によって、データが変更される可能性があります。 たとえば、文字列カラムを短くすると、値が切り捨てられる可能性があります。 新しいデータ型への変換によってデータが失われる場合は操作が成功しないようにするには、<code class="literal">ALTER TABLE</code> を使用する前に厳密な SQL モードを有効にします (<a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a>を参照してください)。 
      </p></div><p>
      <code class="literal">CHANGE</code> または <code class="literal">MODIFY</code> を使用して、インデックスが存在するカラムを短くしたときに、結果として得られるカラムの長さがインデックスの長さより短くなった場合、MySQL は自動的にそのインデックスを短くします。
    </p><p>
      <code class="literal">CHANGE</code> または <code class="literal">RENAME COLUMN</code> によって名前が変更されたカラムの場合、MySQL は、これらの参照の名前を名前が変更されたカラムに自動的に変更します:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          非表示インデックスや無効化された <code class="literal">MyISAM</code> インデックスなど、古いカラムを参照するインデックス。
        </p></li><li class="listitem"><p>
          古いカラムを参照する外部キー。
        </p></li></ul></div><p>
      <code class="literal">CHANGE</code> または <code class="literal">RENAME COLUMN</code> によって名前が変更されたカラムの場合、MySQL は、名前が変更されたカラムへの次の参照の名前を自動的に変更しません:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          名前が変更されたカラムを参照する生成されたカラムおよびパーティション式。 <code class="literal">CHANGE</code> を使用して、カラムの名前を変更するものと同じ <code class="literal">ALTER TABLE</code> ステートメントでこのような式を再定義する必要があります。 
        </p></li><li class="listitem"><p>
          名前が変更されたカラムを参照するビューおよびストアドプログラム。 これらのオブジェクトの定義は、新しいカラム名を参照するように手動で変更する必要があります。 
        </p></li></ul></div><p>
      テーブル内のカラムを並べ替えるには、<code class="literal">CHANGE</code> または <code class="literal">MODIFY</code> 操作で <code class="literal">FIRST</code> および <code class="literal">AFTER</code> を使用します。
    </p><a class="indexterm" name="idm45827006927712"></a><p>
      <code class="literal">ALTER ... SET DEFAULT</code> または <code class="literal">ALTER ... DROP DEFAULT</code> は、それぞれカラムに新しいデフォルト値を指定するか、古いデフォルト値を削除します。 古いデフォルトが削除され、かつカラムを <code class="literal">NULL</code> にできる場合、新しいデフォルトは <code class="literal">NULL</code> です。 カラムを <code class="literal">NULL</code> にできない場合、MySQL は、<a class="xref" href="data-types.html#data-type-defaults" title="11.6 データ型デフォルト値">セクション11.6「データ型デフォルト値」</a>で説明されているようにデフォルト値を割り当てます。 
    </p><p>
      MySQL 8.0.23 では、<code class="literal">ALTER ... SET VISIBLE</code> および <code class="literal">ALTER ... SET INVISIBLE</code> を使用してカラムの可視性を変更できます。 <a class="xref" href="sql-statements.html#invisible-columns" title="13.1.20.10 非表示カラム">セクション13.1.20.10「非表示カラム」</a>を参照してください。 
    </p><h4><a name="alter-table-index"></a>主キーとインデックス</h4><a class="indexterm" name="idm45827006917184"></a><a class="indexterm" name="idm45827006916240"></a><a class="indexterm" name="idm45827006914096"></a><p>
      <code class="literal">DROP PRIMARY KEY</code> により、<a class="link" href="glossary.html#glos_primary_key" title="主キー">primary key</a> が削除されます。 主キーが存在しない場合は、エラーが発生します。 主キーのパフォーマンス特性 (特に <code class="literal">InnoDB</code> テーブルの場合) については、<a class="xref" href="optimization.html#primary-key-optimization" title="8.3.2 主キーの最適化">セクション8.3.2「主キーの最適化」</a>を参照してください。 
    </p><p>
      <code class="literal">sql_require_primary_key</code> システム変数が有効になっている場合、主キーを削除しようとするとエラーが発生します。
    </p><a class="indexterm" name="idm45827006906704"></a><a class="indexterm" name="idm45827006905360"></a><p>
      テーブルに <code class="literal">UNIQUE INDEX</code> または <code class="literal">PRIMARY KEY</code> を追加すると、重複キーをできるだけ早く検出できるようにするために、MySQL はそれを一意でないどのインデックスよりも前に格納します。
    </p><a class="indexterm" name="idm45827006901760"></a><a class="indexterm" name="idm45827006900416"></a><a class="indexterm" name="idm45827006898272"></a><p>
      <code class="literal">DROP INDEX</code> はインデックスを削除します。 これは、標準 SQL への MySQL 拡張です。 <a class="xref" href="sql-statements.html#drop-index" title="13.1.27 DROP INDEX ステートメント">セクション13.1.27「DROP INDEX ステートメント」</a>を参照してください。 インデックス名を確認するには、<code class="literal">SHOW INDEX FROM <em class="replaceable"><code>tbl_name</code></em></code> を使用します。 
    </p><p>
      一部のストレージエンジンでは、インデックスの作成時にインデックスタイプを指定できます。 <em class="replaceable"><code>index_type</code></em> 指定子の構文は、<code class="literal">USING <em class="replaceable"><code>type_name</code></em></code> です。 <code class="literal">USING</code> の詳細は、<a class="xref" href="sql-statements.html#create-index" title="13.1.15 CREATE INDEX ステートメント">セクション13.1.15「CREATE INDEX ステートメント」</a>を参照してください。 推奨される位置は、カラムリストのあとです。 将来の MySQL リリースでは、カラムリストの前にオプションの使用がサポートされることが期待されます。 
    </p><p>
      <em class="replaceable"><code>index_option</code></em> 値は、インデックスの追加オプションを指定します。 <code class="literal">USING</code> はそのようなオプションの 1 つです。 許可される <em class="replaceable"><code>index_option</code></em> 値の詳細は、<a class="xref" href="sql-statements.html#create-index" title="13.1.15 CREATE INDEX ステートメント">セクション13.1.15「CREATE INDEX ステートメント」</a>を参照してください。 
    </p><p>
      <code class="literal">RENAME INDEX <em class="replaceable"><code>old_index_name</code></em> TO <em class="replaceable"><code>new_index_name</code></em></code> は、インデックスの名前を変更します。 これは、標準 SQL への MySQL 拡張です。 テーブルの内容は変更されません。<em class="replaceable"><code>old_index_name</code></em> は、同じ <code class="literal">ALTER TABLE</code> ステートメントで削除されないテーブル内の既存のインデックスの名前である必要があります。<em class="replaceable"><code>new_index_name</code></em> は新しいインデックス名で、変更が適用された後に結果テーブルのインデックスの名前を複製することはできません。 どちらのインデックス名も <code class="literal">PRIMARY</code> にできません。 
    </p><a class="indexterm" name="idm45827006880640"></a><a class="indexterm" name="idm45827006879296"></a><a class="indexterm" name="idm45827006877152"></a><p>
      <code class="literal">MyISAM</code> テーブルで <code class="literal">ALTER TABLE</code> を使用する場合は、(<code class="literal">REPAIR TABLE</code> の場合と同様に) 一意でないすべてのインデックスが個別のバッチで作成されます。 多くのインデックスがあるときは、この方法で <code class="literal">ALTER TABLE</code> がはるかに早くなります。 
    </p><p>
      <code class="literal">MyISAM</code> テーブルの場合は、キーの更新を明示的に制御できます。 <code class="literal">ALTER TABLE ... DISABLE KEYS</code> を使用して、一意でないインデックスの更新を停止するよう MySQL に指示します。 次に、<code class="literal">ALTER TABLE ... ENABLE KEYS</code> を使用して、不足しているインデックスを再作成します。 <code class="literal">MyISAM</code> はこれを、キーを 1 つずつ挿入するのに比べてはるかに高速な特殊なアルゴリズムで実行するため、一括挿入操作を実行する前にキーを無効にすると大幅な高速化が得られます。 <code class="literal">ALTER TABLE ... DISABLE KEYS</code> を使用するには、先に説明した権限に加えて <code class="literal">INDEX</code> 権限が必要です。 
    </p><p>
      一意でないインデックスは、無効になっている間、有効なときにはこのインデックスを使用する <code class="literal">SELECT</code> や <code class="literal">EXPLAIN</code> などのステートメントで無視されます。
    </p><p>
      <code class="literal">ALTER TABLE</code> ステートメントのあとに、インデックスカーディナリティー情報を更新するために <code class="literal">ANALYZE TABLE</code> の実行が必要になることがあります。 <a class="xref" href="sql-statements.html#show-index" title="13.7.7.22 SHOW INDEX ステートメント">セクション13.7.7.22「SHOW INDEX ステートメント」</a>を参照してください。 
    </p><a class="indexterm" name="idm45827006858368"></a><p>
      <code class="literal">ALTER INDEX</code> 操作では、インデックスを可視または不可視にできます。 不可視インデックスはオプティマイザでは使用されません。 インデックスの可視性の変更は、主キー以外のインデックス (明示的または暗黙的) に適用されます。 この機能はストレージエンジンに依存しません (すべてのエンジンでサポートされています)。 詳細は、<a class="xref" href="optimization.html#invisible-indexes" title="8.3.12 不可視のインデックス">セクション8.3.12「不可視のインデックス」</a>を参照してください。 
    </p><h4><a name="alter-table-foreign-key"></a>外部キーおよびその他の制約</h4><a class="indexterm" name="idm45827006853600"></a><a class="indexterm" name="idm45827006852288"></a><p>
      <code class="literal">FOREIGN KEY</code> および <code class="literal">REFERENCES</code> 句は、<code class="literal">ADD [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] FOREIGN KEY [<em class="replaceable"><code>index_name</code></em>] (...) REFERENCES ... (...)</code> を実装する <code class="literal">InnoDB</code> および <code class="literal">NDB</code> ストレージエンジンによってサポートされます。 <a class="xref" href="sql-statements.html#create-table-foreign-keys" title="13.1.20.5 FOREIGN KEY の制約">セクション13.1.20.5「FOREIGN KEY の制約」</a>を参照してください。 その他のストレージエンジンでは、これらの句は解析されますが、無視されます。 
    </p><p>
      <code class="literal">ALTER TABLE</code> では、<code class="literal">CREATE TABLE</code> とは異なり、<code class="literal">ADD FOREIGN KEY</code> は <em class="replaceable"><code>index_name</code></em> (指定されている場合) を無視し、自動的に生成された外部キー名を使用します。 回避方法として、外部キー名を指定する <code class="literal">CONSTRAINT</code> 句を含めます。 
    </p><pre class="programlisting">ADD CONSTRAINT <em class="replaceable"><code>name</code></em> FOREIGN KEY (....) ...
</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        MySQL では、参照がカラム指定の一部として定義されているインライン <code class="literal">REFERENCES</code> 指定は暗黙的に無視されます。 MySQL は、個別の <code class="literal">FOREIGN KEY</code> 仕様の一部として定義された <code class="literal">REFERENCES</code> 句のみを受け入れます。 
      </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        パーティション化された <code class="literal">InnoDB</code> テーブルは、外部キーをサポートしていません。 この制限は、<code class="literal">NDB</code> テーブル (<code class="literal">[LINEAR] KEY</code> によって明示的にパーティション化されたテーブルを含む) には適用されません。 詳細は、<a class="xref" href="partitioning.html#partitioning-limitations-storage-engines" title="24.6.2 ストレージエンジンに関連するパーティショニング制限">セクション24.6.2「ストレージエンジンに関連するパーティショニング制限」</a>を参照してください。 
      </p></div><a class="indexterm" name="idm45827006831824"></a><a class="indexterm" name="idm45827006830480"></a><a class="indexterm" name="idm45827006828336"></a><p>
      MySQL Server と NDB Cluster はどちらも、<code class="literal">ALTER TABLE</code> を使用した外部キーの削除をサポートしています:
    </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DROP FOREIGN KEY <em class="replaceable"><code>fk_symbol</code></em>;
</pre><p>
      同じ <code class="literal">ALTER TABLE</code> ステートメントでの外部キーの追加および削除は、<code class="literal">ALTER TABLE ... ALGORITHM=INPLACE</code> ではサポートされていますが、<code class="literal">ALTER TABLE ... ALGORITHM=COPY</code> ではサポートされていません。
    </p><p>
      サーバーは、参照整合性が失われる可能性がある外部キーカラムの変更を禁止します。 回避方法として、カラム定義を変更する前に <code class="literal">ALTER TABLE ... DROP FOREIGN KEY</code> を使用し、あとで <code class="literal">ALTER TABLE ... ADD FOREIGN KEY</code> を使用します。 禁止されている変更の例を次に示します: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          安全でない可能性がある外部キーカラムのデータ型に対する変更。 たとえば、<code class="literal">VARCHAR(20)</code> の <code class="literal">VARCHAR(30)</code> への変更は許可されますが、それを <code class="literal">VARCHAR(1024)</code> に変更することは、それによって個々の値を格納するために必要なバイト長の数が変更されるため許可されません。 
        </p></li><li class="listitem"><p>
          非制限モードで <code class="literal">NULL</code> カラムを <code class="literal">NOT NULL</code> に変更することは、参照テーブルに対応する値がないデフォルトの <code class="literal">NULL</code> 以外の値への <code class="literal">NULL</code> 値の変換を防ぐために禁止されています。 この操作は厳密モードでは許可されますが、このような変換が必要な場合はエラーが返されます。 
        </p></li></ul></div><p>
      <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> RENAME <em class="replaceable"><code>new_tbl_name</code></em></code> は、内部的に生成された外部キー制約名および文字列 <span class="quote">「<span class="quote"><em class="replaceable"><code>tbl_name</code></em> _ibfk_</span>」</span>で始まるユーザー定義の外部キー制約名を、新しいテーブル名を反映するように変更します。 <code class="literal">InnoDB</code> は、文字列 <span class="quote">「<span class="quote"><em class="replaceable"><code>tbl_name</code></em> _ibfk_</span>」</span>で始まる外部キー制約名を内部的に生成された名前と解釈します。 
    </p><a class="indexterm" name="idm45827006801728"></a><p>
      MySQL 8.0.16 より前の <code class="literal">ALTER TABLE</code> では、次の限定バージョンの <code class="literal">CHECK</code> 制約追加構文のみが許可されていました。この構文は解析され、無視されます:
    </p><pre class="programlisting">ADD CHECK (<em class="replaceable"><code>expr</code></em>)
</pre><p>
      MySQL 8.0.16 の時点で、<code class="literal">ALTER TABLE</code> では、既存のテーブルの <code class="literal">CHECK</code> 制約を追加、削除または変更できます:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          新しい <code class="literal">CHECK</code> 制約を追加します:
        </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em>
    ADD CONSTRAINT [<em class="replaceable"><code>symbol</code></em>] CHECK (<em class="replaceable"><code>expr</code></em>) [[NOT] ENFORCED];
</pre><p>
          制約構文要素の意味は、<code class="literal">CREATE TABLE</code> の場合と同じです。 <a class="xref" href="sql-statements.html#create-table-check-constraints" title="13.1.20.6 CHECK 制約">セクション13.1.20.6「CHECK 制約」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <em class="replaceable"><code>symbol</code></em> という名前の既存の <code class="literal">CHECK</code> 制約を削除します:
        </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em>
    DROP CHECK <em class="replaceable"><code>symbol</code></em>;
</pre></li><li class="listitem"><p>
          <em class="replaceable"><code>symbol</code></em> という名前の既存の <code class="literal">CHECK</code> 制約が施行されるかどうかを変更します:
        </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em>
    ALTER CHECK <em class="replaceable"><code>symbol</code></em> [NOT] ENFORCED;
</pre></li></ul></div><p>
      <code class="literal">DROP CHECK</code> 句および <code class="literal">ALTER CHECK</code> 句は、標準 SQL に対する MySQL の拡張機能です。
    </p><p>
      MySQL 8.0.19 の時点で、<code class="literal">ALTER TABLE</code> では、制約タイプが制約名から決定される任意のタイプの既存の制約を削除および変更するために、より一般的な (および SQL 標準の) 構文を使用できます:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <em class="replaceable"><code>symbol</code></em> という名前の既存の制約を削除します:
        </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em>
    DROP CONSTRAINT <em class="replaceable"><code>symbol</code></em>;
</pre><p>
          <code class="literal">sql_require_primary_key</code> システム変数が有効になっている場合、主キーを削除しようとするとエラーが発生します。
        </p></li><li class="listitem"><p>
          <em class="replaceable"><code>symbol</code></em> という名前の既存の制約を施行するかどうかを変更します:
        </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em>
    ALTER CONSTRAINT <em class="replaceable"><code>symbol</code></em> [NOT] ENFORCED;
</pre><p>
          <code class="literal">CHECK</code> 制約のみ変更して強制終了できます。 他のすべての制約タイプは常に適用されます。 
        </p></li></ul></div><p>
      SQL 標準では、すべてのタイプの制約 (主キー、一意インデックス、外部キー、チェック) が同じネームスペースに属することが指定されています。 MySQL では、各制約タイプにスキーマごとに独自のネームスペースがあります。 したがって、各タイプの制約の名前はスキーマごとに一意である必要がありますが、異なるタイプの制約には同じ名前を付けることができます。 複数の制約の名前が同じ場合、<code class="literal">DROP CONSTRAINT</code> と <code class="literal">ADD CONSTRAINT</code> はあいまいであり、エラーが発生します。 このような場合は、制約固有の構文を使用して制約を変更する必要があります。 たとえば、主キーまたは外部キーを削除するには、<code class="literal">DROP PRIMARY KEY</code> または DROP FOREIGN KEY を使用します。 
    </p><p>
      テーブルの変更によって <code class="literal">CHECK</code> 制約の施行違反が発生した場合、エラーが発生し、テーブルは変更されません。 エラーが発生した操作の例: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">CHECK</code> 制約で使用されるカラムに <code class="literal">AUTO_INCREMENT</code> 属性を追加しようとします。
        </p></li><li class="listitem"><p>
          施行された <code class="literal">CHECK</code> 制約を追加しようとするか、既存の行が制約条件に違反している非施行 <code class="literal">CHECK</code> 制約を施行しようとします。
        </p></li><li class="listitem"><p>
          <code class="literal">CHECK</code> 制約で使用されているカラムを変更、名前変更または削除しようとします。ただし、その制約が同じステートメントでも削除されている場合を除きます。 例外: <code class="literal">CHECK</code> 制約が単一のカラムのみを参照する場合、そのカラムを削除すると制約が自動的に削除されます。 
        </p></li></ul></div><p>
      <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> RENAME <em class="replaceable"><code>new_tbl_name</code></em></code> は、新しいテーブル名を反映するために、文字列 <span class="quote">「<span class="quote"><em class="replaceable"><code>tbl_name</code></em> _chk_</span>」</span>で始まる内部生成およびユーザー定義の <code class="literal">CHECK</code> 制約名を変更します。 MySQL は、文字列 <span class="quote">「<span class="quote"><em class="replaceable"><code>tbl_name</code></em> _chk_</span>」</span>で始まる <code class="literal">CHECK</code> 制約名を内部的に生成された名前と解釈します。 
    </p><h4><a name="alter-table-character-set"></a>文字セットの変更</h4><p>
      <a class="indexterm" name="idm45827006746016"></a> テーブルのデフォルトの文字セットおよびすべての文字カラム (<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、<code class="literal">TEXT</code>) を新しい文字セットに変更するには、次のようなステートメントを使用します。
    </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> CONVERT TO CHARACTER SET <em class="replaceable"><code>charset_name</code></em>;
</pre><p>
      このステートメントでは、すべての文字カラムの照合順序も変更されます。 使用する照合順序を示す <code class="literal">COLLATE</code> 句を指定しない場合、このステートメントは、その文字セットのデフォルトの照合順序を使用します。 この照合順序が目的とするテーブル使用に適していない (たとえば、大文字と小文字が区別される照合順序から大文字と小文字が区別されない照合順序に変更されてしまう) 場合は、照合順序を明示的に指定します。 
    </p><p>
      <code class="literal">VARCHAR</code> のデータ型または <code class="literal">TEXT</code> 型のいずれかを持つカラムの場合、<code class="literal">CONVERT TO CHARACTER SET</code> は必要に応じてデータ型を変更し、新しいカラムが元のカラムと同じ数の文字を格納できる長さになるようにします。 たとえば、<code class="literal">TEXT</code> カラムには、そのカラム内の値のバイト長 (最大 65,535) を格納するための 2 バイト長があります。 <code class="literal">latin1</code> <code class="literal">TEXT</code> カラムの場合は、各文字に 1 バイトが必要なため、このカラムには最大 65,535 文字を格納できます。 このカラムが <code class="literal">utf8</code> に変換された場合は、各文字に最大 3 バイトが必要になる可能性があるため、可能性のある最大の長さは 3 × 65,535 = 196,605 バイトになります。 この長さは <code class="literal">TEXT</code> カラムの長さバイトに収まらないため、MySQL はデータ型を <code class="literal">MEDIUMTEXT</code> に変換します。これは、長さバイトが 196,605 の値を記録できる最小の文字列型です。 同様に、<code class="literal">VARCHAR</code> カラムは <code class="literal">MEDIUMTEXT</code> に変換される可能性があります。 
    </p><p>
      今説明した型のデータ型の変更を回避するには、<code class="literal">CONVERT TO CHARACTER SET</code> を使用しないでください。 代わりに、<code class="literal">MODIFY</code> を使用して個々のカラムを変更します。 例: 
    </p><pre class="programlisting">ALTER TABLE t MODIFY latin1_text_col TEXT CHARACTER SET utf8;
ALTER TABLE t MODIFY latin1_varchar_col VARCHAR(<em class="replaceable"><code>M</code></em>) CHARACTER SET utf8;
</pre><p>
      <code class="literal">CONVERT TO CHARACTER SET binary</code> を指定した場合、<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、および <code class="literal">TEXT</code> カラムは、それぞれ対応するバイナリ文字列型 (<code class="literal">BINARY</code>、<code class="literal">VARBINARY</code>、<code class="literal">BLOB</code>) に変換されます。 つまり、カラムには文字セットがなくなり、後続の <code class="literal">CONVERT TO</code> 操作は適用されません。 
    </p><p>
      <code class="literal">CONVERT TO CHARACTER SET</code> 操作で <em class="replaceable"><code>charset_name</code></em> が <code class="literal">DEFAULT</code> の場合は、<code class="literal">character_set_database</code> システム変数で指定された文字セットが使用されます。
    </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
        <code class="literal">CONVERT TO</code> 操作は、元の文字セットと名前付き文字セットの間でカラム値を変換します。 これは、ある文字セット (<code class="literal">latin1</code> など) のカラムがあるが、格納された値が実際には、ほかの何らかの互換性のない文字セット (<code class="literal">utf8</code> など) を使用している場合に必要なもの<span class="emphasis"><em>ではありません</em></span>。 この場合は、このようなカラムごとに、次を実行する必要があります。 
      </p><pre class="programlisting">ALTER TABLE t1 CHANGE c1 c1 BLOB;
ALTER TABLE t1 CHANGE c1 c1 TEXT CHARACTER SET utf8;
</pre><p>
        これが機能する理由は、<code class="literal">BLOB</code> カラムとの間で変換する場合は変換が発生しないためです。
      </p></div><p>
      テーブルの<span class="emphasis"><em>デフォルトの</em></span>文字セットのみを変更するには、次のステートメントを使用します。
    </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DEFAULT CHARACTER SET <em class="replaceable"><code>charset_name</code></em>;
</pre><p>
      ワード <code class="literal">DEFAULT</code> はオプションです。 デフォルトの文字セットは、あとで (たとえば、<code class="literal">ALTER TABLE ... ADD column</code> で) テーブルに追加するカラムの文字セットを指定しない場合に使用される文字セットです。 
    </p><p>
      <code class="literal">foreign_key_checks</code> システム変数 (デフォルト設定) が有効な場合、外部キー制約で使用される文字列カラムを含むテーブルでは文字セット変換は許可されません。 回避策は、文字セット変換を実行する前に <code class="literal">foreign_key_checks</code> を無効にすることです。 <code class="literal">foreign_key_checks</code> を再度有効にする前に、外部キー制約に関係する両方のテーブルで変換を実行する必要があります。 いずれかのテーブルのみを変換した後に <code class="literal">foreign_key_checks</code> を再度有効にすると、これらの操作中に暗黙的に変換されるために、<code class="literal">ON DELETE CASCADE</code> または <code class="literal">ON UPDATE CASCADE</code> 操作によって参照テーブルのデータが破損する可能性があります (Bug #45290、Bug #74816)。 
    </p><h4><a name="alter-table-import"></a>InnoDB テーブルのインポート</h4><a class="indexterm" name="idm45827006689616"></a><a class="indexterm" name="idm45827006688416"></a><p>
      独自の <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースで作成された <code class="literal">InnoDB</code> テーブルは、<code class="literal">DISCARD TABLEPACE</code> 句および <code class="literal">IMPORT TABLESPACE</code> 句を使用して、バックアップまたは別の MySQL サーバーインスタンスからインポートできます。 <a class="xref" href="innodb-storage-engine.html#innodb-table-import" title="15.6.1.3 InnoDB テーブルのインポート">セクション15.6.1.3「InnoDB テーブルのインポート」</a>を参照してください。 
    </p><h4><a name="alter-table-row-order"></a>MyISAM テーブルの行順序</h4><a class="indexterm" name="idm45827006681104"></a><p>
      <code class="literal">ORDER BY</code> では、特定の順序で行を含む新しいテーブルを作成できます。 このオプションは、ほとんどの場合、特定の順序で行をクエリーすることがわかっている場合に主に役立ちます。 このオプションをテーブルの大幅な変更のあとに使用すると、パフォーマンスの向上が得られる可能性があります。 場合によっては、テーブルが、あとでその並べ替えに使用するカラムごとの順番になっていれば、MySQL でのソートが簡単になることがあります。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        挿入や削除を行うと、このテーブルは指定された順序のままではなくなります。
      </p></div><p>
      <code class="literal">ORDER BY</code> 構文では、ソートのためのカラム名を 1 つ以上指定できます。その各カラム名に続けて、オプションで、それぞれ昇順または降順のソート順序を示す <code class="literal">ASC</code> または <code class="literal">DESC</code> を指定できます。 デフォルトは昇順です。 ソート条件として許可されるのはカラム名だけです。任意の式は許可されていません。 この句は、ほかのどの句よりもあとの最後に指定するようにしてください。 
    </p><p>
      <code class="literal">InnoDB</code> は常に、<a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">クラスタ化されたインデックス</a>に従ってテーブル行を並べ替えるため、<code class="literal">ORDER BY</code> は <code class="literal">InnoDB</code> テーブルでは意味がありません。
    </p><p>
      パーティション化されたテーブルに対して使用されている場合、<code class="literal">ALTER TABLE ... ORDER BY</code> は、各パーティション内でのみ行を並べ替えます。
    </p><h4><a name="alter-table-partition-options"></a>パーティショニングオプション</h4><p>
      <em class="replaceable"><code>partition_options</code></em> は、パーティションの再パーティション化、パーティションの追加、削除、破棄、インポート、マージおよび分割、およびパーティション化メンテナンスの実行のためにパーティションテーブルで使用できるオプションを示します。
    </p><p>
      <code class="literal">ALTER TABLE</code> ステートメントには、ほかの変更指定に加えて、<code class="literal">PARTITION BY</code> または <code class="literal">REMOVE PARTITIONING</code> 句を含めることができますが、<code class="literal">PARTITION BY</code> または <code class="literal">REMOVE PARTITIONING</code> 句は、ほかのどの指定よりもあとの最後に指定する必要があります。 リストされているオプションは個々のパーティションに作用するため、<code class="literal">ADD PARTITION</code>, <code class="literal">DROP PARTITION</code>, <code class="literal">DISCARD PARTITION</code>, <code class="literal">IMPORT PARTITION</code>, <code class="literal">COALESCE PARTITION</code>, <code class="literal">REORGANIZE PARTITION</code>, <code class="literal">EXCHANGE PARTITION</code>, <code class="literal">ANALYZE PARTITION</code>, <code class="literal">CHECK PARTITION</code> および <code class="literal">REPAIR PARTITION</code> オプションを単一の <code class="literal">ALTER TABLE</code> 内の他の変更指定と組み合せることはできません。 
    </p><p>
      パーティションのオプションの詳細は、<a class="xref" href="sql-statements.html#create-table" title="13.1.20 CREATE TABLE ステートメント">セクション13.1.20「CREATE TABLE ステートメント」</a>および<a class="xref" href="sql-statements.html#alter-table-partition-operations" title="13.1.9.1 ALTER TABLE パーティション操作">セクション13.1.9.1「ALTER TABLE パーティション操作」</a>を参照してください。 <code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> ステートメントの詳細および例については、<a class="xref" href="partitioning.html#partitioning-management-exchange" title="24.3.3 パーティションとサブパーティションをテーブルと交換する">セクション24.3.3「パーティションとサブパーティションをテーブルと交換する」</a>を参照してください。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="alter-table-partition-operations"></a>13.1.9.1 ALTER TABLE パーティション操作</h4></div></div></div><p>
        <code class="literal">ALTER TABLE</code> のパーティション関連の句をパーティションテーブルとともに使用して、パーティションの再パーティション化、パーティションの追加、削除、破棄、インポート、マージおよび分割、パーティション化メンテナンスの実行を行うことができます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            単に、パーティション化されたテーブルに対して <code class="literal">ALTER TABLE</code> で <em class="replaceable"><code>partition_options</code></em> 句を使用するだけで、<em class="replaceable"><code>partition_options</code></em> で定義されたパーティション化スキームに従って、そのテーブルが再パーティション化されます。 この句は常に <code class="literal">PARTITION BY</code> で始まり、<code class="literal">CREATE TABLE</code> の <em class="replaceable"><code>partition_options</code></em> 句に適用されるものと同じ構文およびその他のルールに従い (詳細は、<a class="xref" href="sql-statements.html#create-table" title="13.1.20 CREATE TABLE ステートメント">セクション13.1.20「CREATE TABLE ステートメント」</a> を参照)、まだパーティション化されていない既存のテーブルのパーティション化にも使用できます。 たとえば、次に示すように定義された (パーティション化されていない) テーブルを考えてみます。 
          </p><pre class="programlisting">CREATE TABLE t1 (
    id INT,
    year_col INT
);
</pre><p>
            このテーブルは、次のステートメントを使用し、<code class="literal">id</code> カラムをパーティション化キーとして使用して <code class="literal">HASH</code> によって 8 つのパーティションにパーティション化できます。
          </p><pre class="programlisting">ALTER TABLE t1
    PARTITION BY HASH(id)
    PARTITIONS 8;
</pre><p>
            MySQL は、<code class="literal">[SUB]PARTITION BY [LINEAR] KEY</code> で <code class="literal">ALGORITHM</code> オプションをサポートしています。 <code class="literal">ALGORITHM=1</code> を指定すると、サーバーは、パーティション内の行の配置を計算するときに MySQL 5.1 と同じキーハッシュ関数を使用します。<code class="literal">ALGORITHM=2</code> は、サーバーが、MySQL 5.5 以降で実装され、<code class="literal">KEY</code> によってパーティション化された新しいテーブルに対してデフォルトで使用されるキーハッシュ関数を使用することを示します。 (MySQL 5.5 以降で採用されたキーハッシュ関数によって作成されたパーティション化されたテーブルを MySQL 5.1 サーバーで使用することはできません。) このオプションを指定しない場合は、<code class="literal">ALGORITHM=2</code> を使用するのと同じ効果があります。 このオプションは、主に <code class="literal">[LINEAR] KEY</code> によってパーティション化されたテーブルを MySQL 5.1 以降の MySQL バージョン間でアップグレードまたはダウングレードするときに使用するか、または MySQL 5.5 以降のサーバー上で、MySQL 5.1 サーバー上で使用できる <code class="literal">KEY</code> または <code class="literal">LINEAR KEY</code> によってパーティション化されたテーブルを作成することを目的にしています。 
          </p><p>
            <code class="literal">ALTER TABLE ... PARTITION BY</code> ステートメントを使用して作成されたテーブルは、<code class="literal">CREATE TABLE ... PARTITION BY</code> を使用して作成されたテーブルと同じルールに従う必要があります。 これには、そのテーブルに含まれている可能性のあるすべての一意のキー (すべての主キーを含む) と、パーティショニング式で使用されている 1 つまたは複数のカラムの間の関係を管理するルールが含まれます。これについては、<a class="xref" href="partitioning.html#partitioning-limitations-partitioning-keys-unique-keys" title="24.6.1 パーティショニングキー、主キー、および一意キー">セクション24.6.1「パーティショニングキー、主キー、および一意キー」</a>で説明されています。 また、パーティションの数を指定するための <code class="literal">CREATE TABLE ... PARTITION BY</code> のルールも <code class="literal">ALTER TABLE ... PARTITION BY</code> に適用されます。 
          </p><p>
            <code class="literal">ALTER TABLE ADD PARTITION</code> の <em class="replaceable"><code>partition_definition</code></em> 句は、<code class="literal">CREATE TABLE</code> ステートメントの同じ名前の句と同じオプションをサポートしています。 (構文と説明については、<a class="xref" href="sql-statements.html#create-table" title="13.1.20 CREATE TABLE ステートメント">セクション13.1.20「CREATE TABLE ステートメント」</a>を参照してください。) 次に示すように作成されたパーティション化されたテーブルがあるとします。 
          </p><pre class="programlisting">CREATE TABLE t1 (
    id INT,
    year_col INT
)
PARTITION BY RANGE (year_col) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1995),
    PARTITION p2 VALUES LESS THAN (1999)
);
</pre><p>
            このテーブルに、<code class="literal">2002</code> より小さい値を格納するための新しいパーティション <code class="literal">p3</code> を次のように追加できます。
          </p><pre class="programlisting">ALTER TABLE t1 ADD PARTITION (PARTITION p3 VALUES LESS THAN (2002));
</pre><p>
            <code class="literal">DROP PARTITION</code> を使用すると、1 つ以上の <code class="literal">RANGE</code> または <code class="literal">LIST</code> パーティションを削除できます。 このステートメントは、<code class="literal">HASH</code> または <code class="literal">KEY</code> パーティションでは使用できません。かわりに、<code class="literal">COALESCE PARTITION</code> を使用してください (このセクションの後半を参照)。 <em class="replaceable"><code>partition_names</code></em> リストで名前が指定されている削除されたパーティションに格納されていたデータはすべて破棄されます。 たとえば、前に定義されたテーブル <code class="literal">t1</code> の場合は、<code class="literal">p0</code> および <code class="literal">p1</code> という名前のパーティションを次に示すように削除できます。 
          </p><pre class="programlisting">ALTER TABLE t1 DROP PARTITION p0, p1;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">DROP PARTITION</code> は、<code class="literal">NDB</code> ストレージエンジンを使用するテーブルでは機能しません。 <a class="xref" href="partitioning.html#partitioning-management-range-list" title="24.3.1 RANGE および LIST パーティションの管理">セクション24.3.1「RANGE および LIST パーティションの管理」</a>および<a class="xref" href="mysql-cluster.html#mysql-cluster-limitations" title="23.1.7 NDB Cluster の既知の制限事項">セクション23.1.7「NDB Cluster の既知の制限事項」</a>を参照してください。 
            </p></div><p>
            <code class="literal">ADD PARTITION</code> と <code class="literal">DROP PARTITION</code> は現在、<code class="literal">IF [NOT] EXISTS</code> をサポートしていません。
          </p><p>
            <code class="literal">DISCARD PARTITION ... TABLESPACE</code> および <code class="literal">IMPORT PARTITION ... TABLESPACE</code> オプションは、<a class="link" href="glossary.html#glos_transportable_tablespace" title="トランスポータブルテーブルスペース">Transportable Tablespace</a> 機能を個々の <code class="literal">InnoDB</code> テーブルパーティションに拡張します。 各 <code class="literal">InnoDB</code> テーブルパーティションには、独自のテーブルスペースファイル (<code class="filename">.ibd</code> ファイル) があります。 <a class="link" href="glossary.html#glos_transportable_tablespace" title="トランスポータブルテーブルスペース">Transportable Tablespace</a> 機能を使用すると、実行中の MySQL サーバーインスタンスから別の実行中のインスタンスにテーブルスペースを簡単にコピーしたり、同じインスタンスでリストアを実行できます。 どちらのオプションも、1 つ以上のパーティション名のカンマ区切りリストを取ります。 例: 
          </p><pre class="programlisting">ALTER TABLE t1 DISCARD PARTITION p2, p3 TABLESPACE;
</pre><pre class="programlisting">ALTER TABLE t1 IMPORT PARTITION p2, p3 TABLESPACE;
</pre><p>
            サブパーティションテーブルで <code class="literal">DISCARD PARTITION ... TABLESPACE</code> および <code class="literal">IMPORT PARTITION ... TABLESPACE</code> を実行する場合、パーティション名とサブパーティション名の両方が許可されます。 パーティション名を指定すると、そのパーティションのサブパーティションが含まれます。 
          </p><p>
            <a class="link" href="glossary.html#glos_transportable_tablespace" title="トランスポータブルテーブルスペース">Transportable Tablespace</a> 機能では、パーティション <code class="literal">InnoDB</code> テーブルのコピーまたはリストアもサポートされています。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-table-import" title="15.6.1.3 InnoDB テーブルのインポート">セクション15.6.1.3「InnoDB テーブルのインポート」</a>を参照してください。 
          </p><p>
            パーティションテーブルの名前変更はサポートされています。 <code class="literal">ALTER TABLE ... REORGANIZE PARTITION</code> を使用して個々のパーティションの名前を間接的に変更できますが、この操作ではパーティションデータがコピーされます。 
          </p><p>
            選択したパーティションから行を削除するには、<code class="literal">TRUNCATE PARTITION</code> オプションを使用します。 このオプションは、1 つ以上のカンマ区切りのパーティション名のリストを取ります。 次のステートメントによって作成されたテーブル <code class="literal">t1</code> について考えてみます: 
          </p><pre class="programlisting">CREATE TABLE t1 (
    id INT,
    year_col INT
)
PARTITION BY RANGE (year_col) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1995),
    PARTITION p2 VALUES LESS THAN (1999),
    PARTITION p3 VALUES LESS THAN (2003),
    PARTITION p4 VALUES LESS THAN (2007)
);
</pre><p>
            パーティション <code class="literal">p0</code> からすべての行を削除するには、次のステートメントを使用します:
          </p><pre class="programlisting">ALTER TABLE t1 TRUNCATE PARTITION p0;
</pre><p>
            今示したステートメントには、次の <code class="literal">DELETE</code> ステートメントと同じ効果があります。
          </p><pre class="programlisting">DELETE FROM t1 WHERE year_col &lt; 1991;
</pre><p>
            複数のパーティションを切り詰める場合、パーティションが連続している必要はありません。これにより、通常、<code class="literal">DELETE</code> ステートメントで実行された場合は非常に複雑な <code class="literal">WHERE</code> 条件が必要になる、パーティション化されたテーブルでの削除操作が大幅に簡素化される可能性があります。 たとえば、次のステートメントは、パーティション <code class="literal">p1</code> と <code class="literal">p3</code> のすべての行を削除します。 
          </p><pre class="programlisting">ALTER TABLE t1 TRUNCATE PARTITION p1, p3;
</pre><p>
            同等の <code class="literal">DELETE</code> ステートメントを次に示します。
          </p><pre class="programlisting">DELETE FROM t1 WHERE
    (year_col &gt;= 1991 AND year_col &lt; 1995)
    OR
    (year_col &gt;= 2003 AND year_col &lt; 2007);
</pre><p>
            パーティション名のリストのかわりに <code class="literal">ALL</code> キーワードを使用すると、ステートメントはすべてのテーブルパーティションに対して機能します。
          </p><p>
            <code class="literal">TRUNCATE PARTITION</code> は行を削除するだけです。そのテーブル自体や、どのパーティションの定義も変更されません。
          </p><p>
            行が削除されたことを確認するには、次のようなクエリーを使用して <code class="literal">INFORMATION_SCHEMA.PARTITIONS</code> テーブルを確認します:
          </p><pre class="programlisting">SELECT PARTITION_NAME, TABLE_ROWS
    FROM INFORMATION_SCHEMA.PARTITIONS
    WHERE TABLE_NAME = 't1';
</pre><p>
            <code class="literal">HASH</code> または <code class="literal">KEY</code> によってパーティション化されたテーブルで <code class="literal">COALESCE PARTITION</code> を使用すると、そのパーティションの数を <em class="replaceable"><code>number</code></em> だけ減らすことができます。 次のようにテーブル <code class="literal">t2</code> を作成したとします: 
          </p><pre class="programlisting">CREATE TABLE t2 (
    name VARCHAR (30),
    started DATE
)
PARTITION BY HASH( YEAR(started) )
PARTITIONS 6;
</pre><p>
            <code class="literal">t2</code> で使用されるパーティションの数を 6 から 4 に減らすには、次のステートメントを使用します:
          </p><pre class="programlisting">ALTER TABLE t2 COALESCE PARTITION 2;
</pre><p>
            最後の <em class="replaceable"><code>number</code></em> パーティションに含まれるデータは、残りのパーティションにマージされます。 この場合、パーティション 4 および 5 は最初の 4 つのパーティション (0、1、2 および 3 の番号が付けられたパーティション) にマージされます。 
          </p><p>
            パーティション化されたテーブルで使用される (すべてではなく) 一部のパーティションを変更するには、<code class="literal">REORGANIZE PARTITION</code> を使用できます。 このステートメントは、次のいくつかの方法で使用できます。 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                一連のパーティションを単一パーティションにマージします。 これを行うには、<em class="replaceable"><code>partition_names</code></em> リスト内の複数のパーティションに名前を付け、<em class="replaceable"><code>partition_definition</code></em> の単一の定義を指定します。 
              </p></li><li class="listitem"><p>
                既存のパーティションをいくつかのパーティションに分割します。 これを実現するには、<em class="replaceable"><code>partition_names</code></em> の単一のパーティションに名前を付け、複数の <em class="replaceable"><code>partition_definitions</code></em> を指定します。 
              </p></li><li class="listitem"><p>
                <code class="literal">VALUES LESS THAN</code> を使用して、定義されたパーティションのサブセットの範囲を変更するか、または <code class="literal">VALUES IN</code> を使用して、定義されたパーティションのサブセットの値リストを変更します。
              </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              明示的に名前が付けられていないパーティションに対して、MySQL は自動的に <code class="literal">p0</code>、<code class="literal">p1</code>、<code class="literal">p2</code> などのデフォルト名を付けます。 同じことがサブパーティションにも当てはまります。 
            </p></div><p>
            <code class="literal">ALTER TABLE ... REORGANIZE PARTITION</code> ステートメントの詳細および例については、<a class="xref" href="partitioning.html#partitioning-management-range-list" title="24.3.1 RANGE および LIST パーティションの管理">セクション24.3.1「RANGE および LIST パーティションの管理」</a>を参照してください。
          </p></li><li class="listitem"><p>
            テーブルのパーティションまたはサブパーティションをテーブルと交換するには、<code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> ステートメントを使用します。つまり、パーティションまたはサブパーティション内の既存の行を非パーティションテーブルに移動し、非パーティションテーブル内の既存の行をテーブルのパーティションまたはサブパーティションに移動します。
          </p><p>
            使用方法および例については、<a class="xref" href="partitioning.html#partitioning-management-exchange" title="24.3.3 パーティションとサブパーティションをテーブルと交換する">セクション24.3.3「パーティションとサブパーティションをテーブルと交換する」</a>を参照してください。
          </p></li><li class="listitem"><p>
            いくつかのオプションでは、<code class="literal">CHECK TABLE</code> や <code class="literal">REPAIR TABLE</code> などのステートメントによって非パーティションテーブルに実装されるものと同様のパーティションメンテナンスおよび修復機能が提供されます (パーティションテーブルでもサポートされます。詳細は、<a class="xref" href="sql-statements.html#table-maintenance-statements" title="13.7.3 テーブル保守ステートメント">セクション13.7.3「テーブル保守ステートメント」</a> を参照してください)。 これには、<code class="literal">ANALYZE PARTITION</code>、<code class="literal">CHECK PARTITION</code>、<code class="literal">OPTIMIZE PARTITION</code>、<code class="literal">REBUILD PARTITION</code>、および <code class="literal">REPAIR PARTITION</code> が含まれます。 これらの各オプションは、1 つ以上のパーティション名から成るカンマで区切られた <em class="replaceable"><code>partition_names</code></em> 句を受け取ります。 パーティションはターゲットテーブルにすでに存在している必要があります。 <em class="replaceable"><code>partition_names</code></em> のかわりに <code class="literal">ALL</code> キーワードを使用することもできます。この場合、ステートメントはすべてのテーブルパーティションで動作します。 詳細および例については、<a class="xref" href="partitioning.html#partitioning-maintenance" title="24.3.4 パーティションの保守">セクション24.3.4「パーティションの保守」</a>を参照してください。 
          </p><p>
            <code class="literal">InnoDB</code> は現在、パーティションごとの最適化をサポートしていません。<code class="literal">ALTER TABLE ... OPTIMIZE PARTITION</code> では、テーブル全体が再構築および分析され、適切な警告が発行されます。 (Bug #11751825、Bug #42822) この問題を回避するには、かわりに <code class="literal">ALTER TABLE ... REBUILD PARTITION</code> および <code class="literal">ALTER TABLE ... ANALYZE PARTITION</code> を使用します。 
          </p><p>
            <code class="literal">ANALYZE PARTITION</code>, <code class="literal">CHECK PARTITION</code>, <code class="literal">OPTIMIZE PARTITION</code> および <code class="literal">REPAIR PARTITION</code> オプションは、パーティション化されていないテーブルではサポートされていません。
          </p></li><li class="listitem"><p>
            <code class="literal">REMOVE PARTITIONING</code> を使用すると、テーブルまたはそのデータに影響を与えることなく、テーブルのパーティション化を削除できます。 このオプションは、カラムやインデックスの追加、削除、名前変更などのために使用されるその他の <code class="literal">ALTER TABLE</code> オプションと組み合わせることができます。 
          </p></li><li class="listitem"><p>
            <code class="literal">ALTER TABLE</code> で <code class="literal">ENGINE</code> オプションを使用すると、パーティション化に影響を与えることなく、テーブルで使用されるストレージエンジンが変更されます。 ターゲットストレージエンジンは、独自のパーティショニングハンドラを提供する必要があります。 ネイティブのパーティショニングハンドラを持つのは、<code class="literal">InnoDB</code> および <code class="literal">NDB</code> ストレージエンジンだけです。現在、<code class="literal">NDB</code> は MySQL 8.0 ではサポートされていません。 
          </p></li></ul></div><p>
        <code class="literal">ALTER TABLE</code> ステートメントには、ほかの変更指定に加えて、<code class="literal">PARTITION BY</code> または <code class="literal">REMOVE PARTITIONING</code> 句を含めることができますが、<code class="literal">PARTITION BY</code> または <code class="literal">REMOVE PARTITIONING</code> 句は、ほかのどの指定よりもあとの最後に指定する必要があります。
      </p><p>
        <code class="literal">ADD PARTITION</code>、<code class="literal">DROP PARTITION</code>、<code class="literal">COALESCE PARTITION</code>、<code class="literal">REORGANIZE PARTITION</code>、<code class="literal">ANALYZE PARTITION</code>、<code class="literal">CHECK PARTITION</code>、および <code class="literal">REPAIR PARTITION</code> オプションは、個々のパーティションに対して機能するため、1 つの <code class="literal">ALTER TABLE</code> 内でほかの変更指定と組み合わせることはできません。 詳細は、<a class="xref" href="sql-statements.html#alter-table-partition-operations" title="13.1.9.1 ALTER TABLE パーティション操作">セクション13.1.9.1「ALTER TABLE パーティション操作」</a>を参照してください。 
      </p><p>
        特定の <code class="literal">ALTER TABLE</code> ステートメントでは、次のいずれか 1 つのオプションの単一インスタンスのみを使用できます。<code class="literal">PARTITION BY</code>、<code class="literal">ADD PARTITION</code>、<code class="literal">DROP PARTITION</code>、<code class="literal">TRUNCATE PARTITION</code>、<code class="literal">EXCHANGE PARTITION</code>、<code class="literal">REORGANIZE PARTITION</code>、または <code class="literal">COALESCE PARTITION</code>、<code class="literal">ANALYZE PARTITION</code>、<code class="literal">CHECK PARTITION</code>、<code class="literal">OPTIMIZE PARTITION</code>、<code class="literal">REBUILD PARTITION</code>、<code class="literal">REMOVE PARTITIONING</code>。
      </p><p>
        たとえば、次の 2 つのステートメントは無効です。
      </p><pre class="programlisting">ALTER TABLE t1 ANALYZE PARTITION p1, ANALYZE PARTITION p2;

ALTER TABLE t1 ANALYZE PARTITION p1, CHECK PARTITION p2;
</pre><p>
        最初のケースでは、次のように、分析される両方のパーティションを一覧表示した 1 つの <code class="literal">ANALYZE PARTITION</code> オプションを含む 1 つのステートメントを使用して、テーブル <code class="literal">t1</code> のパーティション <code class="literal">p1</code> と <code class="literal">p2</code> を同時に分析できます。
      </p><pre class="programlisting">ALTER TABLE t1 ANALYZE PARTITION p1, p2;
</pre><p>
        2 番目のケースでは、同じテーブルの別のパーティションに対する <code class="literal">ANALYZE</code> 操作と <code class="literal">CHECK</code> 操作を同時に実行することはできません。 代わりに、次のように、2 つの個別のステートメントを発行する必要があります。 
      </p><pre class="programlisting">ALTER TABLE t1 ANALYZE PARTITION p1;
ALTER TABLE t1 CHECK PARTITION p2;
</pre><p>
        サブパーティションに対する <code class="literal">REBUILD</code> 操作は現在サポートされていません。 <code class="literal">REBUILD</code> キーワードはサブパーティションでは明示的に禁止されており、使用すると <code class="literal">ALTER TABLE</code> はエラーで失敗します。 
      </p><p>
        チェックまたは修復するパーティションに重複キーエラーが含まれている場合、<code class="literal">CHECK PARTITION </code>および<code class="literal"> REPAIR PARTITION</code> の操作は失敗します。
      </p><p>
        これらのステートメントの詳細は、<a class="xref" href="partitioning.html#partitioning-maintenance" title="24.3.4 パーティションの保守">セクション24.3.4「パーティションの保守」</a> を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="alter-table-generated-columns"></a>13.1.9.2 ALTER TABLE および生成されるカラム</h4></div></div></div><a class="indexterm" name="idm45827006462080"></a><p>
        生成されるカラムに対して許可される <code class="literal">ALTER TABLE</code> 操作は、<code class="literal">ADD</code>、<code class="literal">MODIFY</code> および <code class="literal">CHANGE</code> です。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            生成されたカラムを追加できます。
          </p><pre class="programlisting">CREATE TABLE t1 (c1 INT);
ALTER TABLE t1 ADD COLUMN c2 INT GENERATED ALWAYS AS (c1 + 1) STORED;
</pre></li><li class="listitem"><p>
            生成されたカラムのデータ型および式は変更できます。
          </p><pre class="programlisting">CREATE TABLE t1 (c1 INT, c2 INT GENERATED ALWAYS AS (c1 + 1) STORED);
ALTER TABLE t1 MODIFY COLUMN c2 TINYINT GENERATED ALWAYS AS (c1 + 5) STORED;
</pre></li><li class="listitem"><p>
            他のカラムが参照していない場合は、生成されたカラムの名前を変更または削除できます。
          </p><pre class="programlisting">CREATE TABLE t1 (c1 INT, c2 INT GENERATED ALWAYS AS (c1 + 1) STORED);
ALTER TABLE t1 CHANGE c2 c3 INT GENERATED ALWAYS AS (c1 + 1) STORED;
ALTER TABLE t1 DROP COLUMN c3;
</pre></li><li class="listitem"><p>
            仮想生成カラムは、格納された生成カラムに変更できません。その逆も同様です。 これを回避するには、カラムを削除してから、新しい定義で追加します。 
          </p><pre class="programlisting">CREATE TABLE t1 (c1 INT, c2 INT GENERATED ALWAYS AS (c1 + 1) VIRTUAL);
ALTER TABLE t1 DROP COLUMN c2;
ALTER TABLE t1 ADD COLUMN c2 INT GENERATED ALWAYS AS (c1 + 1) STORED;
</pre></li><li class="listitem"><p>
            非生成カラムは、格納済に変更できますが、仮想生成カラムには変更できません。
          </p><pre class="programlisting">CREATE TABLE t1 (c1 INT, c2 INT);
ALTER TABLE t1 MODIFY COLUMN c2 INT GENERATED ALWAYS AS (c1 + 1) STORED;
</pre></li><li class="listitem"><p>
            格納されているが、仮想生成カラムは生成されていないカラムに変更できます。 格納された生成値は、生成されないカラムの値になります。 
          </p><pre class="programlisting">CREATE TABLE t1 (c1 INT, c2 INT GENERATED ALWAYS AS (c1 + 1) STORED);
ALTER TABLE t1 MODIFY COLUMN c2 INT;
</pre></li><li class="listitem"><p>
            式はサーバーによって評価される必要があるため、<code class="literal">ADD COLUMN</code> はストアドカラムのインプレース操作ではありません (一時テーブルを使用せずに実行されます)。 ストアドカラムの場合、インデックス付けの変更はインプレースで行われ、式の変更はインプレースでは行われません。 カラムコメントへの変更はインプレースで行われます。 
          </p></li><li class="listitem"><p>
            パーティション化されていないテーブルの場合、<code class="literal">ADD COLUMN</code> および <code class="literal">DROP COLUMN</code> は仮想カラムのインプレース操作です。 ただし、仮想カラムの追加または削除は、他の <code class="literal">ALTER TABLE</code> 操作と組み合せて実行することはできません。 
          </p><p>
            パーティションテーブルの場合、<code class="literal">ADD COLUMN</code> および <code class="literal">DROP COLUMN</code> は仮想カラムのインプレース操作ではありません。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> では、仮想生成カラムのセカンダリインデックスがサポートされます。 仮想生成カラムに対するセカンダリインデックスの追加または削除はインプレース操作です。 詳細は、<a class="xref" href="sql-statements.html#create-table-secondary-indexes" title="13.1.20.9 セカンダリインデックスと生成されたカラム">セクション13.1.20.9「セカンダリインデックスと生成されたカラム」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">VIRTUAL</code> で生成されたカラムがテーブルに追加または変更された場合、生成されたカラム式によって計算されるデータがカラムの範囲外であることは保証されません。 これにより、一貫性のないデータが返され、予期せず失敗したステートメントが発生する可能性があります。 このようなカラムに対して検証が行われるかどうかを制御できるように、<code class="literal">ALTER TABLE</code> では <code class="literal">WITHOUT VALIDATION</code> 句および <code class="literal">WITH VALIDATION</code> 句がサポートされています: 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">WITHOUT VALIDATION</code> (どちらの句も指定されていない場合のデフォルト) では、インプレース操作が実行され (可能な場合)、データ整合性はチェックされず、ステートメントはより迅速に終了します。 ただし、後で値が範囲外の場合は、テーブルからの読取りでカラムの警告またはエラーが報告される可能性があります。 
              </p></li><li class="listitem"><p>
                <code class="literal">WITH VALIDATION</code> では、<code class="literal">ALTER TABLE</code> によってテーブルがコピーされます。 範囲外のエラーまたはその他のエラーが発生した場合、ステートメントは失敗します。 テーブルのコピーが実行されるため、ステートメントに時間がかかります。 
              </p></li></ul></div><p>
            <code class="literal">WITHOUT VALIDATION</code> および <code class="literal">WITH VALIDATION</code> は、<code class="literal">ADD COLUMN</code>、<code class="literal">CHANGE COLUMN</code> および <code class="literal">MODIFY COLUMN</code> 操作でのみ許可されます。 それ以外の場合は、<code class="literal">ER_WRONG_USAGE</code> エラーが発生します。 
          </p></li><li class="listitem"><p>
            式の評価によって切捨てが発生した場合、または関数への入力が正しくない場合、<code class="literal">ALTER TABLE</code> ステートメントはエラーで終了し、DDL 操作は拒否されます。
          </p></li><li class="listitem"><p>
            カラムのデフォルト値を変更する <code class="literal">ALTER TABLE</code> ステートメントでは、<em class="replaceable"><code>col_name</code></em> を使用してカラムを参照する生成されたカラム式の値を変更することもできます。これにより、<code class="literal">DEFAULT(<em class="replaceable"><code>col_name</code></em>)</code> を使用してカラムを参照する生成されたカラム式の値を変更できます。 このため、生成されたカラム式で <code class="literal">DEFAULT()</code> が使用されている場合、カラムの定義を変更する <code class="literal">ALTER TABLE</code> 操作によってテーブルが再構築されます。 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="alter-table-examples"></a>13.1.9.3 ALTER TABLE の例</h4></div></div></div><p>
        次に示すように作成されたテーブル <code class="literal">t1</code> から開始します:
      </p><pre class="programlisting">CREATE TABLE t1 (a INTEGER, b CHAR(10));
</pre><p>
        テーブルの名前を <code class="literal">t1</code> から <code class="literal">t2</code> に変更するには、次のようにします。
      </p><pre class="programlisting">ALTER TABLE t1 RENAME t2;
</pre><p>
        カラム <code class="literal">a</code> を <code class="literal">INTEGER</code> から <code class="literal">TINYINT NOT NULL</code> に変更し (名前は同じままにします)、またカラム <code class="literal">b</code> を <code class="literal">CHAR(10)</code> から <code class="literal">CHAR(20)</code> に変更し、さらにその名前を <code class="literal">b</code> から <code class="literal">c</code> に変更するには、次のようにします。
      </p><pre class="programlisting">ALTER TABLE t2 MODIFY a TINYINT NOT NULL, CHANGE b c CHAR(20);
</pre><p>
        <code class="literal">d</code> という名前の新しい <code class="literal">TIMESTAMP</code> カラムを追加するには、次のようにします。
      </p><pre class="programlisting">ALTER TABLE t2 ADD d TIMESTAMP;
</pre><p>
        カラム <code class="literal">d</code> にインデックスを、またカラム <code class="literal">a</code> に <code class="literal">UNIQUE</code> インデックスを追加するには、次のようにします。
      </p><pre class="programlisting">ALTER TABLE t2 ADD INDEX (d), ADD UNIQUE (a);
</pre><p>
        カラム <code class="literal">c</code> を削除するには、次のようにします。
      </p><pre class="programlisting">ALTER TABLE t2 DROP COLUMN c;
</pre><p>
        <code class="literal">c</code> という名前の新しい <code class="literal">AUTO_INCREMENT</code> 整数カラムを追加するには、次のようにします。
      </p><pre class="programlisting">ALTER TABLE t2 ADD c INT UNSIGNED NOT NULL AUTO_INCREMENT,
  ADD PRIMARY KEY (c);
</pre><p>
        <code class="literal">AUTO_INCREMENT</code> カラムにはインデックスを設定する必要があるため <code class="literal">c</code> に (<code class="literal">PRIMARY KEY</code> として) インデックスを設定し、また主キーカラムは <code class="literal">NULL</code> にできないため <code class="literal">c</code> を <code class="literal">NOT NULL</code> として宣言します。
      </p><p>
        <code class="literal">NDB</code> テーブルの場合は、テーブルまたはカラムに使用されるストレージ型を変更することもできます。 たとえば、次に示すように作成された <code class="literal">NDB</code> テーブルを考えてみます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT) TABLESPACE ts_1 ENGINE NDB;</code></strong>
Query OK, 0 rows affected (1.27 sec)
</pre><p>
        このテーブルをディスクベースのストレージに変換するには、次の <code class="literal">ALTER TABLE</code> ステートメントを使用できます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 TABLESPACE ts_1 STORAGE DISK;</code></strong>
Query OK, 0 rows affected (2.99 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t1\G</code></strong>
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `c1` int(11) DEFAULT NULL
) /*!50100 TABLESPACE ts_1 STORAGE DISK */
ENGINE=ndbcluster DEFAULT CHARSET=latin1
1 row in set (0.01 sec)
</pre><p>
        テーブルが最初に作成されたときにテーブルスペースが参照されている必要はありませんが、テーブルスペースは <code class="literal">ALTER TABLE</code> によって参照される必要があります。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (c1 INT) ts_1 ENGINE NDB;</code></strong>
Query OK, 0 rows affected (1.00 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE t2 STORAGE DISK;</code></strong>
<span class="errortext">ERROR 1005 (HY000): Can't create table 'c.#sql-1750_3' (errno: 140)</span>
mysql&gt; <strong class="userinput"><code>ALTER TABLE t2 TABLESPACE ts_1 STORAGE DISK;</code></strong>
Query OK, 0 rows affected (3.42 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t2\G</code></strong>
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t2` (
  `c1` int(11) DEFAULT NULL
) /*!50100 TABLESPACE ts_1 STORAGE DISK */
ENGINE=ndbcluster DEFAULT CHARSET=latin1
1 row in set (0.01 sec)
</pre><p>
        個々のカラムのストレージ型を変更するには、<code class="literal">ALTER TABLE ... MODIFY [COLUMN]</code> を使用できます。 たとえば、次の <code class="literal">CREATE TABLE</code> ステートメントを使用して、2 つのカラムを含む「NDB Cluster ディスクデータ」テーブルを作成するとします: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t3 (c1 INT, c2 INT)</code></strong>
    -&gt;     <strong class="userinput"><code>TABLESPACE ts_1 STORAGE DISK ENGINE NDB;</code></strong>
Query OK, 0 rows affected (1.34 sec)
</pre><p>
        カラム <code class="literal">c2</code> をディスクベースのストレージからインメモリーストレージに変更するには、次に示すように、ALTER TABLE ステートメントで使用されるカラム定義に STORAGE MEMORY 句を含めます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE t3 MODIFY c2 INT STORAGE MEMORY;</code></strong>
Query OK, 0 rows affected (3.14 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
        同様の方法で <code class="literal">STORAGE DISK</code> を使用して、インメモリーカラムをディスクベースのカラムにすることができます。
      </p><p>
        カラム <code class="literal">c1</code> は、ディスクベースのストレージを使用します。これが (<code class="literal">CREATE TABLE</code> ステートメント内のテーブルレベルの <code class="literal">STORAGE DISK</code> 句によって決定される) テーブルのデフォルトであるためです。 ただし、次の SHOW <code class="literal">CREATE TABLE</code> の出力に示すように、カラム <code class="literal">c2</code> はインメモリーストレージを使用します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t3\G</code></strong>
*************************** 1. row ***************************
       Table: t3
Create Table: CREATE TABLE `t3` (
  `c1` int(11) DEFAULT NULL,
  `c2` int(11) /*!50120 STORAGE MEMORY */ DEFAULT NULL
) /*!50100 TABLESPACE ts_1 STORAGE DISK */ ENGINE=ndbcluster DEFAULT CHARSET=latin1
1 row in set (0.02 sec)
</pre><p>
        <code class="literal">AUTO_INCREMENT</code> カラムを追加すると、カラム値には、自動的にシーケンス番号が入力されます。 <code class="literal">MyISAM</code> テーブルの場合は、<code class="literal">ALTER TABLE</code> の前に <code class="literal">SET INSERT_ID=<em class="replaceable"><code>value</code></em></code> を実行するか、または <code class="literal">AUTO_INCREMENT=<em class="replaceable"><code>value</code></em></code> テーブルオプションを使用することによって、最初のシーケンス番号を設定できます。 
      </p><p>
        <code class="literal">MyISAM</code> テーブルでは、<code class="literal">AUTO_INCREMENT</code> カラムを変更しない場合、シーケンス番号は影響を受けません。 <code class="literal">AUTO_INCREMENT</code> カラムを削除してから、別の <code class="literal">AUTO_INCREMENT</code> カラムを追加した場合、シーケンス番号は 1 から付け直されます。 
      </p><p>
        レプリケーションを使用する場合、テーブルに <code class="literal">AUTO_INCREMENT</code> カラムを追加しても、レプリカとソースで同じ順序で行が生成されないことがあります。 これが発生するのは、行が番号付けされる順序が、テーブルに使用される固有のストレージエンジンおよび行が挿入された順序に依存するためです。 ソースとレプリカで順序が同じであることが重要な場合は、<code class="literal">AUTO_INCREMENT</code> 番号を割り当てる前に行を順序付けする必要があります。 テーブル <code class="literal">t1</code> に <code class="literal">AUTO_INCREMENT</code> カラムを追加すると仮定した場合、次のステートメントは、<code class="literal">t1</code> と同一であるが、<code class="literal">AUTO_INCREMENT</code> カラムを含む新しいテーブル <code class="literal">t2</code> を生成します。 
      </p><pre class="programlisting">CREATE TABLE t2 (id INT AUTO_INCREMENT PRIMARY KEY)
SELECT * FROM t1 ORDER BY col1, col2;
</pre><p>
        ここでは、テーブル <code class="literal">t1</code> にカラム <code class="literal">col1</code> と <code class="literal">col2</code> が存在することを前提にしています。
      </p><p>
        この一連のステートメントでは、<code class="literal">AUTO_INCREMENT</code> カラムが追加された、<code class="literal">t1</code> と同一の新しいテーブル <code class="literal">t2</code> も生成されます:
      </p><pre class="programlisting">CREATE TABLE t2 LIKE t1;
ALTER TABLE t2 ADD id INT AUTO_INCREMENT PRIMARY KEY;
INSERT INTO t2 SELECT * FROM t1 ORDER BY col1, col2;
</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          ソースとレプリカの両方で同じ順序を保証するには、<code class="literal">ORDER BY</code> 句で <code class="literal">t1</code> の <span class="emphasis"><em>all</em></span> カラムを参照する必要があります。
        </p></div><p>
        <code class="literal">AUTO_INCREMENT</code> カラムを持つコピーを作成および移入するために使用する方法にかかわらず、最終手順は元のテーブルを削除してコピーの名前を変更することです。
      </p><pre class="programlisting">DROP TABLE t1;
ALTER TABLE t2 RENAME t1;
</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-tablespace"></a>13.1.10 ALTER TABLESPACE ステートメント</h3></div></div></div><a class="indexterm" name="idm45827006316032"></a><a class="indexterm" name="idm45827006313856"></a><a class="indexterm" name="idm45827006311792"></a><pre class="programlisting">ALTER [UNDO] TABLESPACE <em class="replaceable"><code>tablespace_name</code></em>
  <span class="emphasis"><em>NDB only:</em></span>
    {ADD | DROP} DATAFILE '<em class="replaceable"><code>file_name</code></em>'
    [INITIAL_SIZE [=] size]
    [WAIT]
  <span class="emphasis"><em>InnoDB and NDB:</em></span>
    [RENAME TO <em class="replaceable"><code>tablespace_name</code></em>]
  <span class="emphasis"><em>InnoDB only:</em></span>
    [AUTOEXTEND_SIZE [=] '<em class="replaceable"><code>value</code></em>']
    [SET {ACTIVE | INACTIVE}]
    [ENCRYPTION [=] {'Y' | 'N'}]
  <span class="emphasis"><em>InnoDB and NDB:</em></span>
    [ENGINE [=] <em class="replaceable"><code>engine_name</code></em>]
  <span class="emphasis"><em>Reserved for future use:</em></span>
    [ENGINE_ATTRIBUTE [=] '<em class="replaceable"><code>string</code></em>']
</pre><p>
      このステートメントは、<code class="literal">NDB</code> および <code class="literal">InnoDB</code> テーブルスペースで使用されます。 これを使用して、新しいデータファイルを <code class="literal">NDB</code> テーブルスペースに追加したり、<code class="literal">NDB</code> テーブルスペースからデータファイルを削除できます。 また、「NDB Cluster ディスクデータ」テーブルスペースの名前変更、<code class="literal">InnoDB</code> 一般テーブルスペースの名前変更、<code class="literal">InnoDB</code> 一般テーブルスペースの暗号化、または <code class="literal">InnoDB</code> undo テーブルスペースをアクティブまたは非アクティブとしてマークするためにも使用できます。 
    </p><p>
      MySQL 8.0.14 で導入された <code class="literal">UNDO</code> キーワードは、<code class="literal">InnoDB</code> undo テーブルスペースをアクティブまたは非アクティブとしてマークするために <code class="literal">SET {ACTIVE | INACTIVE}</code> 句とともに使用されます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-undo-tablespaces" title="15.6.3.4 undo テーブルスペース">セクション15.6.3.4「undo テーブルスペース」</a>を参照してください。 
    </p><p>
      <code class="literal">ADD DATAFILE</code> バリアントを使用すると、<code class="literal">INITIAL_SIZE</code> 句を使用して <code class="literal">NDB</code>「ディスクデータ」テーブルスペースの初期サイズを指定できます。<em class="replaceable"><code>size</code></em> はバイト単位で測定され、デフォルト値は 134217728 (128 MB) です。 オプションで、<code class="filename">my.cnf</code> で使用されているものと同様に、<em class="replaceable"><code>size</code></em> の後に一文字の略称を付けることもできます。 一般に、これは <code class="literal">M</code> (M バイト) または <code class="literal">G</code> (G バイト) のどちらかの文字です。 
    </p><p>
      32 ビットシステム上では、<code class="literal">INITIAL_SIZE</code> のサポートされる最大値は 4294967296 (4G バイト) です。 (Bug #29186) 
    </p><p>
      <code class="literal">INITIAL_SIZE</code> は、<code class="literal">CREATE TABLESPACE</code> と同様に明示的に丸められます。
    </p><p>
      データファイルが作成されると、そのサイズは変更できませんが、追加の <code class="literal">ALTER TABLESPACE ... ADD DATAFILE</code> ステートメントを使用して NDB テーブルスペースにデータファイルを追加できます。
    </p><p>
      <code class="literal">ALTER TABLESPACE ... ADD DATAFILE</code> を <code class="literal">ENGINE = NDB</code> とともに使用すると、各クラスタデータノードにデータファイルが作成されますが、<code class="literal">INFORMATION_SCHEMA.FILES</code> テーブルには 1 つの行のみが生成されます。 詳細は、このテーブルおよび <a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data-objects" title="23.5.10.1 NDB Cluster ディスクデータオブジェクト">セクション23.5.10.1「NDB Cluster ディスクデータオブジェクト」</a> の説明を参照してください。 <code class="literal">ADD DATAFILE</code> は、<code class="literal">InnoDB</code> テーブルスペースではサポートされていません。 
    </p><p>
      <code class="literal">ALTER TABLESPACE</code> で <code class="literal">DROP DATAFILE</code> を使用すると、NDB テーブルスペースからデータファイル'<em class="replaceable"><code>file_name</code></em>'が削除されます。 いずれかのテーブルが使用しているテーブルスペースからはデータファイルを削除できません。つまり、そのデータファイルが空である (エクステントが使用されていない) ことが必要です。 <a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data-objects" title="23.5.10.1 NDB Cluster ディスクデータオブジェクト">セクション23.5.10.1「NDB Cluster ディスクデータオブジェクト」</a>を参照してください。 さらに、削除されるデータファイルはすべて、<code class="literal">CREATE TABLESPACE</code> または <code class="literal">ALTER TABLESPACE</code> で以前にそのテーブルスペースに追加されている必要があります。 <code class="literal">DROP DATAFILE</code> は、<code class="literal">InnoDB</code> テーブルスペースではサポートされていません。 
    </p><p>
      <code class="literal">WAIT</code> は解析されますが、それ以外は無視されます。 これは将来の拡張のために用意されています。 
    </p><p>
      テーブルスペースで使用されるストレージエンジンを指定する <code class="literal">ENGINE</code> 句は非推奨になりました。将来のリリースで削除される予定です。 テーブルスペース記憶域エンジンはデータディクショナリによって認識されるため、<code class="literal">ENGINE</code> 句は廃止されています。 ストレージエンジンが指定されている場合は、データディクショナリに定義されているテーブルスペースストレージエンジンと一致する必要があります。 <code class="literal">NDB</code> テーブルスペースと互換性のある <em class="replaceable"><code>engine_name</code></em> の値は、<code class="literal">NDB</code> および <code class="literal">NDBCLUSTER</code> のみです。 
    </p><p>
      <code class="literal">RENAME TO</code> 操作は、<code class="literal">autocommit</code> の設定に関係なく、<code class="literal">autocommit</code> モードで暗黙的に実行されます。
    </p><p>
      テーブルスペースに存在するテーブルに対して <code class="literal">LOCK TABLES</code> または <code class="literal">FLUSH TABLES WITH READ LOCK</code> が有効になっている間は、<code class="literal">RENAME TO</code> 操作を実行できません。
    </p><p>
      排他的 <a class="link" href="glossary.html#glos_metadata_lock" title="メタデータロック">metadata locks</a> は、テーブルスペースの名前の変更中に一般的なテーブルスペースに存在するテーブルに対して取得されるため、同時 DDL が回避されます。 同時 DML がサポートされています。 
    </p><p>
      <code class="literal">InnoDB</code> 一般テーブルスペースの名前を変更するには、<code class="literal">CREATE TABLESPACE</code> 権限が必要です。
    </p><p>
      <code class="literal">AUTOEXTEND_SIZE</code> オプションは、一杯になったときに <code class="literal">InnoDB</code> がテーブルスペースのサイズを拡張する量を定義します。 MySQL 8.0.23 で導入されました。 設定は 4MB の倍数である必要があります。 デフォルト設定は 0 で、暗黙的なデフォルト動作に従ってテーブルスペースが拡張されます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-tablespace-autoextend-size" title="15.6.3.9 テーブルスペースの AUTOEXTEND_SIZE 構成">セクション15.6.3.9「テーブルスペースの AUTOEXTEND_SIZE 構成」</a>を参照してください。 
    </p><p>
      <code class="literal">ENCRYPTION</code> 句は、<code class="literal">InnoDB</code> 一般テーブルスペースまたは <code class="literal">mysql</code> システムテーブルスペースのページレベルのデータ暗号化を有効または無効にします。 一般テーブルスペースの暗号化サポートは、MySQL 8.0.13 で導入されました。 <code class="literal">mysql</code> システムテーブルスペースの暗号化サポートは、MySQL 8.0.16 で導入されました。 
    </p><p>
      暗号化を有効にする前に、キーリングプラグインをインストールして構成する必要があります。
    </p><p>
      MySQL 8.0.16 では、<code class="literal">table_encryption_privilege_check</code> 変数が有効になっている場合、<code class="literal">default_table_encryption</code> の設定とは異なる <code class="literal">ENCRYPTION</code> 句の設定を使用して一般的なテーブルスペースを変更するには、<code class="literal">TABLE_ENCRYPTION_ADMIN</code> 権限が必要です。
    </p><p>
      テーブルスペース内のいずれかのテーブルが <code class="literal">DEFAULT ENCRYPTION='N'</code>で定義されたスキーマに属している場合、一般テーブルスペースの暗号化の有効化は失敗します。 同様に、一般テーブルスペースのいずれかのテーブルが <code class="literal">DEFAULT ENCRYPTION='Y'</code>で定義されたスキーマに属している場合、暗号化の無効化は失敗します。 <code class="literal">DEFAULT ENCRYPTION</code> スキーマオプションは、MySQL 8.0.16 で導入されました。 
    </p><p>
      一般的なテーブルスペースで実行される <code class="literal">ALTER TABLESPACE</code> ステートメントに <code class="literal">ENCRYPTION</code> 句が含まれていない場合、<code class="literal">default_table_encryption</code> の設定に関係なく、テーブルスペースは現在の暗号化ステータスを保持します。
    </p><p>
      一般テーブルスペースまたは <code class="literal">mysql</code> システムテーブルスペースが暗号化されると、テーブルスペースに存在するすべてのテーブルが暗号化されます。 同様に、暗号化されたテーブルスペースに作成されたテーブルも暗号化されます。 
    </p><p>
      <code class="literal">INPLACE</code> アルゴリズムは、一般テーブルスペースまたは <code class="literal">mysql</code> システムテーブルスペースの <code class="literal">ENCRYPTION</code> 属性を変更するときに使用されます。 <code class="literal">INPLACE</code> アルゴリズムでは、テーブルスペースに存在するテーブルに対する同時 DML が許可されます。 同時 DDL はブロックされます。 
    </p><p>
      詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-data-encryption" title="15.13 InnoDB 保存データ暗号化">セクション15.13「InnoDB 保存データ暗号化」</a>を参照してください。
    </p><p>
      <code class="literal">ENGINE_ATTRIBUTE</code> オプション (MySQL 8.0.21 の時点で使用可能) を使用して、プライマリストレージエンジンのテーブルスペース属性を指定します。 このオプションは、将来の使用のために予約されています。 
    </p><p>
      許可される値は、有効な <code class="literal">JSON</code> ドキュメントまたは空の文字列 ('') を含む文字列リテラルです。 無効な <code class="literal">JSON</code> が拒否されました。 
    </p><pre class="programlisting">ALTER TABLESPACE ts1 ENGINE_ATTRIBUTE='{"<em class="replaceable"><code>key</code></em>":"<em class="replaceable"><code>value</code></em>"}';
</pre><p>
      <code class="literal">ENGINE_ATTRIBUTE</code> の値は、エラーなしで繰り返すことができます。 この場合、最後に指定した値が使用されます。 
    </p><p>
      <code class="literal">ENGINE_ATTRIBUTE</code> 値はサーバーによってチェックされず、テーブルストレージエンジンが変更されたときにもクリアされません。
    </p><p>
      JSON 属性値の個々の要素を変更することはできません。 追加または置換できるのは属性のみです。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-view"></a>13.1.11 ALTER VIEW ステートメント</h3></div></div></div><a class="indexterm" name="idm45827006209920"></a><pre class="programlisting">ALTER
    [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
    [DEFINER = <em class="replaceable"><code>user</code></em>]
    [SQL SECURITY { DEFINER | INVOKER }]
    VIEW <em class="replaceable"><code>view_name</code></em> [(<em class="replaceable"><code>column_list</code></em>)]
    AS <em class="replaceable"><code>select_statement</code></em>
    [WITH [CASCADED | LOCAL] CHECK OPTION]
</pre><p>
      このステートメントは、ビューの定義を変更します。このビューは存在する必要があります。 構文は、<code class="literal">CREATE VIEW</code> の場合と似ています (<a class="xref" href="sql-statements.html#create-view" title="13.1.23 CREATE VIEW ステートメント">セクション13.1.23「CREATE VIEW ステートメント」</a> を参照)。 このステートメントには、このビューに対する <code class="literal">CREATE VIEW</code> および <code class="literal">DROP</code> 権限と、<code class="literal">SELECT</code> ステートメントで参照される各カラムに対する何らかの権限が必要です。 <code class="literal">ALTER VIEW</code> は、定義者または <code class="literal">SET_USER_ID</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) を持つユーザーにのみ許可されます。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-database"></a>13.1.12 CREATE DATABASE ステートメント</h3></div></div></div><a class="indexterm" name="idm45827006192400"></a><a class="indexterm" name="idm45827006190288"></a><a class="indexterm" name="idm45827006189056"></a><a class="indexterm" name="idm45827006187712"></a><a class="indexterm" name="idm45827006185568"></a><a class="indexterm" name="idm45827006183536"></a><a class="indexterm" name="idm45827006181504"></a><pre class="programlisting">CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] <em class="replaceable"><code>db_name</code></em>
    [<em class="replaceable"><code>create_option</code></em>] ...

<em class="replaceable"><code>create_option</code></em>: [DEFAULT] {
    CHARACTER SET [=] <em class="replaceable"><code>charset_name</code></em>
  | COLLATE [=] <em class="replaceable"><code>collation_name</code></em>
  | ENCRYPTION [=] {'Y' | 'N'}
}
</pre><p>
      <code class="literal">CREATE DATABASE</code> は、指定された名前を持つデータベースを作成します。 このステートメントを使用するには、このデータベースに対する <code class="literal">CREATE</code> 権限が必要です。 <code class="literal">CREATE SCHEMA</code> は <code class="literal">CREATE DATABASE</code> のシノニムです。 
    </p><p>
      そのデータベースが存在するときに <code class="literal">IF NOT EXISTS</code> を指定しなかった場合は、エラーが発生します。
    </p><p>
      <code class="literal">CREATE DATABASE</code> は、アクティブな <code class="literal">LOCK TABLES</code> ステートメントを持つセッション内では許可されません。
    </p><p>
      各 <em class="replaceable"><code>create_option</code></em> は、データベース特性を指定します。 データベース特性はデータディクショナリに格納されます。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">CHARACTER SET</code> オプションは、デフォルトのデータベース文字セットを指定します。 <code class="literal">COLLATE</code> オプションは、デフォルトのデータベース照合順序を指定します。 文字セットおよび照合順序名の詳細は、<a class="xref" href="charset.html" title="第 10 章 文字セット、照合順序、Unicode">第10章「<i>文字セット、照合順序、Unicode</i>」</a> を参照してください。 
        </p><p>
          使用可能な文字セットと照合順序を確認するには、それぞれ <code class="literal">SHOW CHARACTER SET</code> ステートメントと <code class="literal">SHOW COLLATION</code> ステートメントを使用します。 <a class="xref" href="sql-statements.html#show-character-set" title="13.7.7.3 SHOW CHARACTER SET ステートメント">セクション13.7.7.3「SHOW CHARACTER SET ステートメント」</a>および<a class="xref" href="sql-statements.html#show-collation" title="13.7.7.4 SHOW COLLATION ステートメント">セクション13.7.7.4「SHOW COLLATION ステートメント」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          MySQL 8.0.16 で導入された <code class="literal">ENCRYPTION</code> オプションは、データベースで作成されたテーブルによって継承されるデフォルトのデータベース暗号化を定義します。 許可される値は、<code class="literal">'Y'</code> (暗号化有効) および<code class="literal">'N'</code> (暗号化無効) です。 <code class="literal">ENCRYPTION</code> オプションが指定されていない場合、<code class="literal">default_table_encryption</code> システム変数の値によってデフォルトのデータベース暗号化が定義されます。 <code class="literal">table_encryption_privilege_check</code> システム変数が有効になっている場合、<code class="literal">default_table_encryption</code> 設定とは異なるデフォルトの暗号化設定を指定するには、<code class="literal">TABLE_ENCRYPTION_ADMIN</code> 権限が必要です。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-schema-tablespace-encryption-default" title="スキーマおよび一般テーブルスペースの暗号化デフォルトの定義">スキーマおよび一般テーブルスペースの暗号化デフォルトの定義</a>を参照してください。 
        </p></li></ul></div><p>
      MySQL でのデータベースは、そのデータベース内のテーブルに対応するファイルを含むディレクトリとして実装されます。 最初の作成時にはデータベースにテーブルがないため、<code class="literal">CREATE DATABASE</code> ステートメントでは MySQL データディレクトリの下にディレクトリのみが作成されます。 許可されるデータベース名のルールは、<a class="xref" href="language-structure.html#identifiers" title="9.2 スキーマオブジェクト名">セクション9.2「スキーマオブジェクト名」</a>に示されています。 データベース名に特殊文字が含まれている場合は、<a class="xref" href="language-structure.html#identifier-mapping" title="9.2.4 識別子とファイル名のマッピング">セクション9.2.4「識別子とファイル名のマッピング」</a>で説明されているように、その文字のエンコードされたバージョンがデータベースディレクトリの名前に含まれます。 
    </p><p>
      データディレクトリの下にディレクトリを手動で作成することによるデータベースディレクトリの作成 (<span class="command"><strong>mkdir</strong></span> などを使用) は、MySQL 8.0 ではサポートされていません。
    </p><p>
      データベースを作成する場合は、サーバーでディレクトリとその中のファイルを管理します。 データベースディレクトリおよびファイルを直接操作すると、不整合や予期しない結果が発生する可能性があります。 
    </p><a class="indexterm" name="idm45827006137824"></a><a class="indexterm" name="idm45827006135648"></a><p>
      MySQL にはデータベース数の制限はありません。 ベースとなるファイルシステムによっては、ディレクトリ数に制限がある場合があります。 
    </p><a class="indexterm" name="idm45827006132784"></a><p>
      <span class="command"><strong>mysqladmin</strong></span> プログラムを使用してデータベースを作成することもできます。 <a class="xref" href="programs.html#mysqladmin" title="4.5.2 mysqladmin — A MySQL Server 管理プログラム">セクション4.5.2「mysqladmin — A MySQL Server 管理プログラム」</a>を参照してください。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-event"></a>13.1.13 CREATE EVENT ステートメント</h3></div></div></div><a class="indexterm" name="idm45827006128288"></a><a class="indexterm" name="idm45827006126128"></a><a class="indexterm" name="idm45827006124096"></a><pre class="programlisting">CREATE
    [DEFINER = <em class="replaceable"><code>user</code></em>]
    EVENT
    [IF NOT EXISTS]
    <em class="replaceable"><code>event_name</code></em>
    ON SCHEDULE <em class="replaceable"><code>schedule</code></em>
    [ON COMPLETION [NOT] PRESERVE]
    [ENABLE | DISABLE | DISABLE ON SLAVE]
    [COMMENT '<em class="replaceable"><code>string</code></em>']
    DO <em class="replaceable"><code>event_body</code></em>;

<em class="replaceable"><code>schedule</code></em>: {
    AT <em class="replaceable"><code>timestamp</code></em> [+ INTERVAL <em class="replaceable"><code>interval</code></em>] ...
  | EVERY <em class="replaceable"><code>interval</code></em>
    [STARTS <em class="replaceable"><code>timestamp</code></em> [+ INTERVAL <em class="replaceable"><code>interval</code></em>] ...]
    [ENDS <em class="replaceable"><code>timestamp</code></em> [+ INTERVAL <em class="replaceable"><code>interval</code></em>] ...]
}

<em class="replaceable"><code>interval</code></em>:
    <em class="replaceable"><code>quantity</code></em> {YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE |
              WEEK | SECOND | YEAR_MONTH | DAY_HOUR | DAY_MINUTE |
              DAY_SECOND | HOUR_MINUTE | HOUR_SECOND | MINUTE_SECOND}
</pre><p>
      このステートメントは、新しいイベントを作成してスケジュールします。 イベントスケジューラが有効になっていないかぎり、イベントは実行されません。 イベントスケジューラのステータスをチェックし、必要に応じてそれを有効にする方法については、<a class="xref" href="stored-objects.html#events-configuration" title="25.4.2 イベントスケジューラの構成">セクション25.4.2「イベントスケジューラの構成」</a>を参照してください。 
    </p><p>
      <code class="literal">CREATE EVENT</code> には、イベントが作成されるスキーマに対する <code class="literal">EVENT</code> 権限が必要です。 <code class="literal">DEFINER</code> 句が存在する場合、<a class="xref" href="stored-objects.html#stored-objects-security" title="25.6 ストアドオブジェクトのアクセス制御">セクション25.6「ストアドオブジェクトのアクセス制御」</a> で説明されているように、必要な権限は <em class="replaceable"><code>user</code></em> の値によって異なります。 
    </p><p>
      有効な <code class="literal">CREATE EVENT</code> ステートメントの最小要件は次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          キーワード <code class="literal">CREATE EVENT</code> に加えて、データベーススキーマ内のイベントを一意に識別するイベント名。
        </p></li><li class="listitem"><p>
          イベントが実行される時期と頻度を決定する <code class="literal">ON SCHEDULE</code> 句。
        </p></li><li class="listitem"><p>
          イベントによって実行される SQL ステートメントを含む <code class="literal">DO</code> 句。
        </p></li></ul></div><p>
      最小限の <code class="literal">CREATE EVENT</code> ステートメントの例を次に示します。
    </p><pre class="programlisting">CREATE EVENT myevent
    ON SCHEDULE AT CURRENT_TIMESTAMP + INTERVAL 1 HOUR
    DO
      UPDATE myschema.mytable SET mycol = mycol + 1;
</pre><p>
      前のステートメントは、<code class="literal">myevent</code> という名前のイベントを作成します。 このイベントは、<code class="literal">myschema.mytable</code> テーブルの <code class="literal">mycol</code> カラムの値を 1 増分する SQL ステートメントを実行することによって (その作成の 1 時間後に) 1 回実行されます。 
    </p><p>
      <em class="replaceable"><code>event_name</code></em> は、最大長が 64 文字の有効な MySQL 識別子である必要があります。 イベント名では大/小文字が区別されないため、<code class="literal">myevent</code> と <code class="literal">MyEvent</code> という名前のイベントを同じスキーマに含めることはできません。 一般に、イベント名を管理するルールは、ストアドルーチンの名前の場合と同じです。 <a class="xref" href="language-structure.html#identifiers" title="9.2 スキーマオブジェクト名">セクション9.2「スキーマオブジェクト名」</a>を参照してください。 
    </p><p>
      イベントはスキーマに関連付けられています。 <em class="replaceable"><code>event_name</code></em> の一部としてスキーマが示されていない場合は、デフォルトの (現在の) スキーマと見なされます。 イベントを特定のスキーマ内に作成するには、<code class="literal"><em class="replaceable"><code>schema_name</code></em>.<em class="replaceable"><code>event_name</code></em></code> 構文を使用して、そのイベント名をスキーマで修飾します。 
    </p><p>
      <code class="literal">DEFINER</code> 句は、イベントの実行時にアクセス権限を確認するときに使用される MySQL アカウントを指定します。 <code class="literal">DEFINER</code> 句が存在する場合、<em class="replaceable"><code>user</code></em> 値は<code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'<em class="replaceable"><code>host_name</code></em>'</code>、<code class="literal">CURRENT_USER</code> または <code class="literal">CURRENT_USER()</code> として指定された MySQL アカウントである必要があります。 許可される <em class="replaceable"><code>user</code></em> 値は、<a class="xref" href="stored-objects.html#stored-objects-security" title="25.6 ストアドオブジェクトのアクセス制御">セクション25.6「ストアドオブジェクトのアクセス制御」</a> で説明されているように、保持する権限によって異なります。 イベントセキュリティの詳細は、そのセクションも参照してください。 
    </p><p>
      <code class="literal">DEFINER</code> 句を省略すると、デフォルトの定義者は <code class="literal">CREATE EVENT</code> ステートメントを実行するユーザーになります。 これは、明示的に <code class="literal">DEFINER = CURRENT_USER</code> を指定するのと同じです。 
    </p><p>
      イベント本体内では、<code class="literal">CURRENT_USER</code> 関数は、<code class="literal">DEFINER</code> ユーザーであるイベント実行時の権限のチェックに使用されるアカウントを返します。 イベント内のユーザー監査については、<a class="xref" href="security.html#account-activity-auditing" title="6.2.22 SQL ベースのアカウントアクティビティ監査">セクション6.2.22「SQL ベースのアカウントアクティビティ監査」</a>を参照してください。 
    </p><p>
      <code class="literal">CREATE EVENT</code> での <code class="literal">IF NOT EXISTS</code> には、<code class="literal">CREATE TABLE</code> での場合と同じ意味があります。<em class="replaceable"><code>event_name</code></em> という名前のイベントが同じスキーマ内にすでに存在する場合、アクションは実行されず、エラーも発生しません。 (ただし、このような場合は警告が生成されます。) 
    </p><p>
      <code class="literal">ON SCHEDULE</code> 句は、そのイベントに対して定義された <em class="replaceable"><code>event_body</code></em> を繰り返す時期、頻度、および期間を決定します。 この句は、次の 2 つの形式のいずれかを取ります。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          1 回限りのイベントには、<code class="literal">AT <em class="replaceable"><code>timestamp</code></em></code> が使用されます。 これは、そのイベントが <em class="replaceable"><code>timestamp</code></em> で指定された日付と時間に 1 回だけ実行されることを指定します。この値は、日付と時間の両方を含んでいるか、または datetime 値に解決される式である必要があります。 この目的には、<code class="literal">DATETIME</code> または <code class="literal">TIMESTAMP</code> 型のどちらかの値を使用できます。 日付が過去の日付である場合は、次に示すように、警告が発生します。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT NOW();</code></strong>
+---------------------+
| NOW()               |
+---------------------+
| 2006-02-10 23:59:01 |
+---------------------+
1 row in set (0.04 sec)

mysql&gt; <strong class="userinput"><code>CREATE EVENT e_totals</code></strong>
    -&gt;     <strong class="userinput"><code>ON SCHEDULE AT '2006-02-10 23:59:00'</code></strong>
    -&gt;     <strong class="userinput"><code>DO INSERT INTO test.totals VALUES (NOW());</code></strong>
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Note
   Code: 1588
Message: Event execution time is in the past and ON COMPLETION NOT
         PRESERVE is set. The event was dropped immediately after
         creation.
</pre><p>
          どのような理由であれ、それ自体が無効な <code class="literal">CREATE EVENT</code> ステートメントはエラーで失敗します。
        </p><p>
          現在の日付と時間を指定するには、<code class="literal">CURRENT_TIMESTAMP</code> を使用できます。 このような場合、イベントは、作成されるとすぐに機能します。 
        </p><p>
          現在の日付と時間を基準にした将来のある時点 (<span class="quote">「<span class="quote">今から 3 週間後</span>」</span>というフレーズで表される時点など) に発生するイベントを作成するには、オプションの句 <code class="literal">+ INTERVAL <em class="replaceable"><code>interval</code></em></code> を使用できます。 <em class="replaceable"><code>interval</code></em> 部分は数量と時間単位で構成され、<a class="xref" href="language-structure.html#temporal-intervals" title="時間間隔">時間間隔</a> で説明されている構文ルールに従いますが、イベントの定義時にマイクロ秒を含む単位キーワードは使用できません。 一部の間隔型では、複合の時間単位を使用できます。 たとえば、<span class="quote">「<span class="quote">2 分と 10 秒</span>」</span>は、<code class="literal">+ INTERVAL '2:10' MINUTE_SECOND</code> として表すことができます。 
        </p><p>
          また、間隔を組み合わせることもできます。 たとえば、<code class="literal">AT CURRENT_TIMESTAMP + INTERVAL 3 WEEK + INTERVAL 2 DAY</code> は、<span class="quote">「<span class="quote">今から 3 週間と 2 日後</span>」</span>と同等です。 このような句の各部分は、<code class="literal">+ INTERVAL</code> で始まる必要があります。 
        </p></li><li class="listitem"><p>
          アクションを定期的に繰り返すには、<code class="literal">EVERY</code> 句を使用します。 <code class="literal">EVERY</code> キーワードのあとに、前の <code class="literal">AT</code> キーワードの説明に示されている <em class="replaceable"><code>interval</code></em> を指定します。(<code class="literal">EVERY</code> では <code class="literal">+ INTERVAL</code> は使用され<span class="emphasis"><em>ません</em></span>。) たとえば、<code class="literal">EVERY 6 WEEK</code> は<span class="quote">「<span class="quote">6 週間ごと</span>」</span>を示します。 
        </p><p>
          <code class="literal">EVERY</code> 句では <code class="literal">+ INTERVAL</code> 句は許可されていませんが、<code class="literal">+ INTERVAL</code> 内で許可されているのと同じ複合の時間単位を使用できます。
        </p><p>
          <code class="literal">EVERY</code> 句には、オプションの <code class="literal">STARTS</code> 句を含めることができます。 <code class="literal">STARTS</code> のあとに、このアクションがいつ繰り返しを開始するかを示す <em class="replaceable"><code>timestamp</code></em> 値を指定します。また、<code class="literal">+ INTERVAL <em class="replaceable"><code>interval</code></em></code> を使用して、<span class="quote">「<span class="quote">今からの</span>」</span>時間を指定することもできます。 たとえば、<code class="literal">EVERY 3 MONTH STARTS CURRENT_TIMESTAMP + INTERVAL 1 WEEK</code> は、<span class="quote">「<span class="quote">今から 1 週間後に開始して 3 か月ごと</span>」</span>を示します。 同様に、<span class="quote">「<span class="quote">今から 6 時間と 15 分後から開始して 2 週ごと</span>」</span>を、<code class="literal">EVERY 2 WEEK STARTS CURRENT_TIMESTAMP + INTERVAL '6:15' HOUR_MINUTE</code> として表すことができます。 <code class="literal">STARTS</code> を指定しないことは、<code class="literal">STARTS CURRENT_TIMESTAMP</code> を使用することと同じです。つまり、イベントに対して指定されたアクションは、そのイベントが作成されるとただちに繰り返しを開始します。 
        </p><p>
          <code class="literal">EVERY</code> 句には、オプションの <code class="literal">ENDS</code> 句を含めることができます。 <code class="literal">ENDS</code> キーワードのあとに、このイベントがいつ繰り返しを停止するかを MySQL に指示する <em class="replaceable"><code>timestamp</code></em> 値を指定します。 また、<code class="literal">ENDS</code> とともに <code class="literal">+ INTERVAL <em class="replaceable"><code>interval</code></em></code> を使用することもできます。たとえば、<code class="literal">EVERY 12 HOUR STARTS CURRENT_TIMESTAMP + INTERVAL 30 MINUTE ENDS CURRENT_TIMESTAMP + INTERVAL 4 WEEK</code> は、<span class="quote">「<span class="quote">今から 30 分後に開始し、今から 4 週間後に終了するまで 12 時間ごと</span>」</span>と同等です。 <code class="literal">ENDS</code> を使用しないことは、このイベントがいつまでも実行を続行することを示します。 
        </p><p>
          <code class="literal">ENDS</code> は、複合の時間単位に対して <code class="literal">STARTS</code> と同じ構文をサポートします。
        </p><p>
          <code class="literal">EVERY</code> 句では、<code class="literal">STARTS</code> または <code class="literal">ENDS</code>、あるいはその両方を使用できます。また、どちらも使用しないことも可能です。
        </p><p>
          繰り返しイベントがスケジュール間隔内に終了しない場合は、イベントの複数のインスタンスが同時に実行される可能性があります。 これが好ましくない場合は、同時インスタンスを回避するためのメカニズムを設けてください。 たとえば、<code class="literal">GET_LOCK()</code> 関数や、行またはテーブルのロックを使用できます。 
        </p></li></ul></div><p>
      <code class="literal">ON SCHEDULE</code> 句では、組み込みの MySQL 関数やユーザー変数を含む式を使用して、そこに含まれているすべての <em class="replaceable"><code>timestamp</code></em> または <em class="replaceable"><code>interval</code></em> 値を取得できます。 このような式でストアドファンクションやユーザー定義関数を使用したり、テーブル参照を使用したりすることはできません。ただし、<code class="literal">SELECT FROM DUAL</code> は使用できます。 これは、<code class="literal">CREATE EVENT</code> ステートメントと <code class="literal">ALTER EVENT</code> ステートメントの両方に当てはまります。 このような場合のストアドファンクション、ユーザー定義関数、およびテーブルへの参照は明確に禁止されており、エラーで失敗します (Bug #22830 を参照してください)。 
    </p><p>
      <code class="literal">ON SCHEDULE</code> 句の時間は、現在のセッションの <code class="literal">time_zone</code> 値を使用して解釈されます。 これがイベントのタイムゾーン、つまり、イベントのスケジューリングに使用され、イベントが実行されるとそのイベント内で有効になるタイムゾーンになります。 これらの時間は UTC に変換され、イベントタイムゾーンとともに内部的に格納されます。 これにより、サーバータイムゾーンまたはサマータイムの影響に対し生じた変更とは無関係に、定義されたとおりにイベントの実行を処理できます。 イベントの時間の表現の詳細は、<a class="xref" href="stored-objects.html#events-metadata" title="25.4.4 イベントメタデータ">セクション25.4.4「イベントメタデータ」</a>を参照してください。 <a class="xref" href="sql-statements.html#show-events" title="13.7.7.18 SHOW EVENTS ステートメント">セクション13.7.7.18「SHOW EVENTS ステートメント」</a>および<a class="xref" href="information-schema.html#information-schema-events-table" title="26.14 INFORMATION_SCHEMA EVENTS テーブル">セクション26.14「INFORMATION_SCHEMA EVENTS テーブル」</a>も参照してください。 
    </p><p>
      通常は、イベントの期限が切れると、そのイベントはただちに削除されます。 この動作は、<code class="literal">ON COMPLETION PRESERVE</code> を指定することによってオーバーライドできます。 <code class="literal">ON COMPLETION NOT PRESERVE</code> を使用すると、単にデフォルトの非持続性の動作が明示的になるだけです。 
    </p><p>
      <code class="literal">DISABLE</code> キーワードを使用すると、イベントは作成するが、それがアクティブにならないようにすることができます。 あるいは、<code class="literal">ENABLE</code> を使用して、デフォルトステータス (アクティブ) を明示的にすることもできます。 これは、<code class="literal">ALTER EVENT</code> と組み合わせるともっとも有効です (<a class="xref" href="sql-statements.html#alter-event" title="13.1.3 ALTER EVENT ステートメント">セクション13.1.3「ALTER EVENT ステートメント」</a>を参照してください)。 
    </p><p>
      3 番目の値は、<code class="literal">ENABLE</code> または <code class="literal">DISABLE</code> のかわりに表示されることもあります。<code class="literal">DISABLE ON SLAVE</code> は、イベントがレプリケーションソースサーバー上で作成され、レプリカにレプリケートされたが、レプリカ上では実行されなかったことを示すために、レプリカ上のイベントのステータスに設定されます。 <a class="xref" href="replication.html#replication-features-invoked" title="17.5.1.16 呼び出される機能のレプリケーション">セクション17.5.1.16「呼び出される機能のレプリケーション」</a>を参照してください。 
    </p><p>
      <code class="literal">COMMENT</code> 句を使用して、イベントに対するコメントを指定できます。<em class="replaceable"><code>comment</code></em> には、イベントの説明に使用する、最大 64 文字の任意の文字列を指定できます。 コメントテキストは文字列リテラルであるため、引用符で囲む必要があります。 
    </p><p>
      <code class="literal">DO</code> 句は、イベントによって実行されるアクションを指定するものであり、SQL ステートメントで構成されます。 ストアドルーチンで使用できる有効な MySQL ステートメントのほぼすべてを、スケジュールされたイベントのアクションステートメントとしても使用できます。 (<a class="xref" href="stored-objects.html#stored-program-restrictions" title="25.8 ストアドプログラムの制約">セクション25.8「ストアドプログラムの制約」</a>を参照してください。) たとえば、次のイベント <code class="literal">e_hourly</code> は、<code class="literal">sessions</code> テーブルのすべての行を 1 時間に 1 回削除します。ここで、このテーブルは <code class="literal">site_activity</code> スキーマの一部です。 
    </p><pre class="programlisting">CREATE EVENT e_hourly
    ON SCHEDULE
      EVERY 1 HOUR
    COMMENT 'Clears out sessions table each hour.'
    DO
      DELETE FROM site_activity.sessions;
</pre><p>
      MySQL は、イベントが作成または変更されたときの有効な <code class="literal">sql_mode</code> システム変数の設定を格納し、<span class="emphasis"><em>イベントが実行を開始したときの現在のサーバー SQL モードには関係なく</em></span>、常にそのイベントを強制的にこの設定で実行します。
    </p><p>
      <code class="literal">DO</code> 句に <code class="literal">ALTER EVENT</code> ステートメントを含む <code class="literal">CREATE EVENT</code> ステートメントは成功したように見えます。ただし、結果として得られるスケジュールされたイベントをサーバーが実行しようとすると、その実行はエラーで失敗します。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        単に結果セットを返す <code class="literal">SELECT</code> や <code class="literal">SHOW</code> などのステートメントは、イベントで使用されても何の効果もありません。これらのステートメントからの出力は MySQL モニターに送信されず、またどこにも格納されません。 ただし、結果を格納する <code class="literal">SELECT ... INTO</code> や <code class="literal">INSERT INTO ... SELECT</code> などのステートメントは使用できます。 (後者の例については、このセクションにある次の例を参照してください。) 
      </p></div><p>
      イベントが属するスキーマは、<code class="literal">DO</code> 句でのテーブル参照のためのデフォルトスキーマです。 ほかのスキーマでのテーブルへの参照はすべて、正しいスキーマ名で修飾する必要があります。 
    </p><p>
      次に示すように、ストアドルーチンと同様に、<code class="literal">BEGIN</code> および <code class="literal">END</code> キーワードを使用して <code class="literal">DO</code> 句で複合ステートメントの構文を使用できます。
    </p><pre class="programlisting">delimiter |

CREATE EVENT e_daily
    ON SCHEDULE
      EVERY 1 DAY
    COMMENT 'Saves total number of sessions then clears the table each day'
    DO
      BEGIN
        INSERT INTO site_activity.totals (time, total)
          SELECT CURRENT_TIMESTAMP, COUNT(*)
            FROM site_activity.sessions;
        DELETE FROM site_activity.sessions;
      END |

delimiter ;
</pre><p>
      この例では、<code class="literal">delimiter</code> コマンドを使用して、ステートメント区切り文字を変更します。 <a class="xref" href="stored-objects.html#stored-programs-defining" title="25.1 ストアドプログラムの定義">セクション25.1「ストアドプログラムの定義」</a>を参照してください。 
    </p><p>
      イベントでは、ストアドルーチンで使用されているような、より複雑な複合ステートメントを使用できます。 この例では、ローカル変数、エラーハンドラ、およびフロー制御構造構文を使用しています。 
    </p><pre class="programlisting">delimiter |

CREATE EVENT e
    ON SCHEDULE
      EVERY 5 SECOND
    DO
      BEGIN
        DECLARE v INTEGER;
        DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN END;

        SET v = 0;

        WHILE v &lt; 5 DO
          INSERT INTO t1 VALUES (0);
          UPDATE t2 SET s1 = s1 + 1;
          SET v = v + 1;
        END WHILE;
    END |

delimiter ;
</pre><p>
      イベントに、またはイベントから直接パラメータを渡す方法はありませんが、パラメータを持つストアドルーチンをイベント内で呼び出すことは可能です。
    </p><pre class="programlisting">CREATE EVENT e_call_myproc
    ON SCHEDULE
      AT CURRENT_TIMESTAMP + INTERVAL 1 DAY
    DO CALL myproc(5, 27);
</pre><p>
      イベント定義者がグローバルシステム変数を設定するのに十分な権限を持っている場合 (<a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a> を参照)、イベントはグローバル変数の読取りおよび書込みを実行できます。 このような権限を付与するには不正利用の可能性があるため、十分に注意する必要があります。 
    </p><p>
      一般に、ストアドルーチンで有効なすべてのステートメントを、イベントによって実行されるアクションステートメントに使用できます。 ストアドルーチン内で許可されるステートメントの詳細は、<a class="xref" href="stored-objects.html#stored-routines-syntax" title="25.2.1 ストアドルーチンの構文">セクション25.2.1「ストアドルーチンの構文」</a> を参照してください。 ストアドルーチンの一部としてイベントを作成できますが、イベントを別のイベントで作成することはできません。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-function"></a>13.1.14 CREATE FUNCTION ステートメント</h3></div></div></div><p>
      <code class="literal">CREATE FUNCTION</code> ステートメントは、ストアドファンクションやユーザー定義関数 (UDF) を作成するために使用されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ストアドファンクションの作成については、<a class="xref" href="sql-statements.html#create-procedure" title="13.1.17 CREATE PROCEDURE ステートメントおよび CREATE FUNCTION ステートメント">セクション13.1.17「CREATE PROCEDURE ステートメントおよび CREATE FUNCTION ステートメント」</a>を参照してください。
        </p></li><li class="listitem"><p>
          ユーザー定義関数の作成については、<a class="xref" href="sql-statements.html#create-function-loadable" title="13.7.4.1 ユーザー定義関数用の CREATE FUNCTION ステートメント">セクション13.7.4.1「ユーザー定義関数用の CREATE FUNCTION ステートメント」</a>を参照してください。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-index"></a>13.1.15 CREATE INDEX ステートメント</h3></div></div></div><a class="indexterm" name="idm45827005941600"></a><a class="indexterm" name="idm45827005940288"></a><a class="indexterm" name="idm45827005938832"></a><a class="indexterm" name="idm45827005936800"></a><pre class="programlisting">CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX <em class="replaceable"><code>index_name</code></em>
    [<em class="replaceable"><code>index_type</code></em>]
    ON <em class="replaceable"><code>tbl_name</code></em> (<em class="replaceable"><code>key_part</code></em>,...)
    [<em class="replaceable"><code>index_option</code></em>]
    [<em class="replaceable"><code>algorithm_option</code></em> | <em class="replaceable"><code>lock_option</code></em>] ...

<em class="replaceable"><code>key_part</code></em>: {<em class="replaceable"><code>col_name</code></em> [(<em class="replaceable"><code>length</code></em>)] | (<em class="replaceable"><code>expr</code></em>)} [ASC | DESC]

<em class="replaceable"><code>index_option</code></em>: {
    KEY_BLOCK_SIZE [=] <em class="replaceable"><code>value</code></em>
  | <em class="replaceable"><code>index_type</code></em>
  | WITH PARSER <em class="replaceable"><code>parser_name</code></em>
  | COMMENT '<em class="replaceable"><code>string</code></em>'
  | {VISIBLE | INVISIBLE}
  | ENGINE_ATTRIBUTE [=] '<em class="replaceable"><code>string</code></em>'
  | SECONDARY_ENGINE_ATTRIBUTE [=] '<em class="replaceable"><code>string</code></em>'
}

<em class="replaceable"><code>index_type</code></em>:
    USING {BTREE | HASH}

<em class="replaceable"><code>algorithm_option</code></em>:
    ALGORITHM [=] {DEFAULT | INPLACE | COPY}

<em class="replaceable"><code>lock_option</code></em>:
    LOCK [=] {DEFAULT | NONE | SHARED | EXCLUSIVE}
</pre><p>
      通常、テーブル上のすべてのインデックスは、そのテーブル自体が <code class="literal">CREATE TABLE</code> で作成された時点で作成します。 <a class="xref" href="sql-statements.html#create-table" title="13.1.20 CREATE TABLE ステートメント">セクション13.1.20「CREATE TABLE ステートメント」</a>を参照してください。 このガイドラインは、主キーによってデータファイル内の行の物理配列が決定される <code class="literal">InnoDB</code> テーブルの場合に特に重要です。 <code class="literal">CREATE INDEX</code> では、既存のテーブルにインデックスを追加できます。 
    </p><p>
      <code class="literal">CREATE INDEX</code> は、インデックスを作成するために <code class="literal">ALTER TABLE</code> ステートメントにマップされます。 <a class="xref" href="sql-statements.html#alter-table" title="13.1.9 ALTER TABLE ステートメント">セクション13.1.9「ALTER TABLE ステートメント」</a>を参照してください。 <code class="literal">CREATE INDEX</code> を使用して <code class="literal">PRIMARY KEY</code> を作成することはできません。代わりに <code class="literal">ALTER TABLE</code> を使用します。 インデックスの詳細は、<a class="xref" href="optimization.html#mysql-indexes" title="8.3.1 MySQL のインデックスの使用の仕組み">セクション8.3.1「MySQL のインデックスの使用の仕組み」</a>を参照してください。 
    </p><p>
      <code class="literal">InnoDB</code> は、仮想カラムのセカンダリインデックスをサポートしています。 詳細は、<a class="xref" href="sql-statements.html#create-table-secondary-indexes" title="13.1.20.9 セカンダリインデックスと生成されたカラム">セクション13.1.20.9「セカンダリインデックスと生成されたカラム」</a>を参照してください。 
    </p><p>
      <code class="literal">innodb_stats_persistent</code> 設定が有効になっている場合は、<code class="literal">InnoDB</code> テーブル上でインデックスを作成したあと、そのテーブルに対して <code class="literal">ANALYZE TABLE</code> ステートメントを実行します。
    </p><p>
      MySQL 8.0.17 以降、<em class="replaceable"><code>key_part</code></em> 仕様の <em class="replaceable"><code>expr</code></em> では、<code class="literal">(CAST <em class="replaceable"><code>json_expression</code></em> AS <em class="replaceable"><code>type</code></em> ARRAY)</code> の形式を使用して <code class="literal">JSON</code> カラムに複数値インデックスを作成できます。 <a class="xref" href="sql-statements.html#create-index-multi-valued" title="複数値インデックス">複数値インデックス</a>を参照してください。 
    </p><p>
      <code class="literal">(<em class="replaceable"><code>key_part1</code></em>, <em class="replaceable"><code>key_part2</code></em>, ...)</code> 形式のインデックス指定では、複数のキー部分を持つインデックスが作成されます。 インデックスキー値は、指定されたキー部分の値を連結することによって形成されます。 たとえば、<code class="literal">(col1, col2, col3)</code> では、<code class="literal">col1</code>、<code class="literal">col2</code> および <code class="literal">col3</code> の値で構成されるインデックスキーを持つ複数カラムインデックスを指定します。 
    </p><p>
      <em class="replaceable"><code>key_part</code></em> 仕様の末尾には、<code class="literal">ASC</code> または <code class="literal">DESC</code> を使用して、インデックス値を昇順または降順のどちらで格納するかを指定できます。 順序指定子が指定されていない場合、デフォルトは昇順です。 <code class="literal">ASC</code> および <code class="literal">DESC</code> は、<code class="literal">HASH</code> インデックスには使用できません。 <code class="literal">ASC</code> および <code class="literal">DESC</code> は、複数値インデックスでもサポートされていません。 MySQL 8.0.12 では、<code class="literal">SPATIAL</code> インデックスに対して <code class="literal">ASC</code> および <code class="literal">DESC</code> は許可されていません。 
    </p><p>
      次の各セクションでは、<code class="literal">CREATE INDEX</code> ステートメントの様々な側面について説明します:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#create-index-column-prefixes" title="カラム接頭辞のキー部分">カラム接頭辞のキー部分</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-index-functional-key-parts" title="機能キー部品">機能キー部品</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-index-unique" title="一意インデックス">一意インデックス</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-index-fulltext" title="全文インデックス">全文インデックス</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-index-multi-valued" title="複数値インデックス">複数値インデックス</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-index-spatial" title="空間インデックス">空間インデックス</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-index-options" title="インデックスオプション">インデックスオプション</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-index-copying" title="テーブルのコピーおよびロックのオプション">テーブルのコピーおよびロックのオプション</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="create-index-column-prefixes"></a>カラム接頭辞のキー部分</h4></div></div></div><p>
        文字列カラムの場合、<code class="literal"><em class="replaceable"><code>col_name</code></em>(<em class="replaceable"><code>length</code></em>)</code> 構文を使用してインデックス接頭辞の長さを指定し、カラム値の先頭部分のみを使用するインデックスを作成できます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            接頭辞は、<code class="literal">CHAR</code>, <code class="literal">VARCHAR</code>, <code class="literal">BINARY</code> および <code class="literal">VARBINARY</code> のキー部分に指定できます。
          </p></li><li class="listitem"><p>
            接頭辞は、<code class="literal">BLOB</code> および <code class="literal">TEXT</code> のキー部分に指定する必要があります。 また、<code class="literal">BLOB</code> カラムおよび <code class="literal">TEXT</code> カラムは、<code class="literal">InnoDB</code>、<code class="literal">MyISAM</code> および <code class="literal">BLACKHOLE</code> テーブルに対してのみインデックス付けできます。 
          </p><a class="indexterm" name="idm45827005859744"></a><a class="indexterm" name="idm45827005857584"></a><a class="indexterm" name="idm45827005855536"></a><a class="indexterm" name="idm45827005853488"></a></li><li class="listitem"><p>
            接頭辞 <span class="emphasis"><em>limits</em></span> はバイト単位で測定されます。 ただし、<code class="literal">CREATE TABLE</code>、<code class="literal">ALTER TABLE</code> および <code class="literal">CREATE INDEX</code> ステートメントのインデックス指定の接頭辞 <span class="emphasis"><em>lengths</em></span> は、非バイナリ文字列型 (<code class="literal">CHAR</code>, <code class="literal">VARCHAR</code>, <code class="literal">TEXT</code>) の場合は文字数として解釈され、バイナリ文字列型 (<code class="literal">BINARY</code>, <code class="literal">VARBINARY</code>, <code class="literal">BLOB</code>) の場合はバイト数として解釈されます。 マルチバイト文字セットを使用する非バイナリ文字列カラムに接頭辞の長さを指定する場合は、これを考慮してください。 
          </p><p>
            プリフィクスのサポートやプリフィクスの長さ (サポートされている場合) は、ストレージエンジンに依存します。 たとえば、<code class="literal"><a class="link" href="glossary.html#glos_redundant_row_format" title="冗長行フォーマット">REDUNDANT</a></code> または <code class="literal"><a class="link" href="glossary.html#glos_compact_row_format" title="コンパクト行フォーマット">COMPACT</a></code> の行形式を使用する <code class="literal">InnoDB</code> テーブルでは、接頭辞の長さは最大 767 バイトです。 <code class="literal"><a class="link" href="glossary.html#glos_dynamic_row_format" title="動的行フォーマット">DYNAMIC</a></code> または <code class="literal"><a class="link" href="glossary.html#glos_compressed_row_format" title="圧縮行フォーマット">COMPRESSED</a></code> の行形式を使用する <code class="literal">InnoDB</code> テーブルでは、接頭辞の長さの制限は 3072 バイトです。 <code class="literal">MyISAM</code> テーブルの場合、接頭辞の長さの制限は 1000 バイトです。 <code class="literal">NDB</code> ストレージエンジンは接頭辞をサポートしていません (<a class="xref" href="mysql-cluster.html#mysql-cluster-limitations-unsupported" title="23.1.7.6 NDB Cluster でサポートされない機能または欠落している機能">セクション23.1.7.6「NDB Cluster でサポートされない機能または欠落している機能」</a> を参照)。 
          </p></li></ul></div><p>
        指定したインデックス接頭辞がカラムの最大データ型サイズを超える場合、<code class="literal">CREATE INDEX</code> は次のようにインデックスを処理します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            一意でないインデックスの場合は、エラーが発生するか (厳密な SQL モードが有効な場合)、インデックスの長さが最大カラムデータ型サイズ内になるように縮小され、警告が生成されます (厳密な SQL モードが有効でない場合)。
          </p></li><li class="listitem"><p>
            一意インデックスの場合、インデックスの長さを短くすると、指定した一意性要件を満たさない一意でないエントリの挿入が可能になるため、SQL モードに関係なくエラーが発生します。
          </p></li></ul></div><p>
        次のステートメントは、<code class="literal">name</code> カラムの最初の 10 文字を使用してインデックスを作成します (<code class="literal">name</code> にバイナリ以外の文字列型があると想定しています):
      </p><pre class="programlisting">CREATE INDEX part_of_name ON customer (name(10));
</pre><p>
        通常、カラムの名前が最初の 10 文字と異なる場合、このインデックスを使用して実行されるルックアップは、<code class="literal">name</code> カラム全体から作成されたインデックスを使用する場合よりも遅くなることはありません。 また、インデックスにカラムプリフィクスを使用するとインデックスファイルをはるかに小さくできるため、多くのディスク領域が節約されるだけでなく、<code class="literal">INSERT</code> 操作も高速化される可能性があります。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="create-index-functional-key-parts"></a>機能キー部品</h4></div></div></div><p>
        <span class="quote">「<span class="quote">normal</span>」</span> インデックスは、カラム値またはカラム値の接頭辞をインデックス付けします。 たとえば、次のテーブルでは、特定の <code class="literal">t1</code> 行のインデックスエントリに、最初の 10 文字で構成される完全な <code class="literal">col1</code> 値と <code class="literal">col2</code> 値の接頭辞が含まれています: 
      </p><pre class="programlisting">CREATE TABLE t1 (
  col1 VARCHAR(10),
  col2 VARCHAR(20),
  INDEX (col1, col2(10))
);
</pre><p>
        MySQL 8.0.13 以上では、カラムまたはカラムの接頭辞値ではなく式の値をインデックス付けする関数キー部分がサポートされています。 関数キーパーツを使用すると、テーブルに直接格納されない値のインデックス付けが可能になります。 例: 
      </p><pre class="programlisting">CREATE TABLE t1 (col1 INT, col2 INT, INDEX func_index ((ABS(col1))));
CREATE INDEX idx1 ON t1 ((col1 + col2));
CREATE INDEX idx2 ON t1 ((col1 + col2), (col1 - col2), col1);
ALTER TABLE t1 ADD INDEX ((col1 * 40) DESC);
</pre><p>
        複数のキーパートを持つインデックスでは、非機能キーパートと機能キーパートを混在させることができます。
      </p><p>
        <code class="literal">ASC</code> および <code class="literal">DESC</code> は、機能キー部分でサポートされています。
      </p><p>
        機能キー部分は、次のルールに従う必要があります。 キーパート定義に許可されていない構成が含まれている場合は、エラーが発生します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            インデックス定義では、式をカッコで囲み、カラムまたはカラムの接頭辞と区別します。 たとえば、これは許可されており、式はカッコで囲まれています: 
          </p><pre class="programlisting">INDEX ((col1 + col2), (col3 - col4))
</pre><p>
            これによりエラーが発生します。式はカッコで囲まれません:
          </p><pre class="programlisting">INDEX (col1 + col2, col3 - col4)
</pre></li><li class="listitem"><p>
            関数キー部分は、カラム名のみで構成できません。 たとえば、これは許可されていません: 
          </p><pre class="programlisting">INDEX ((col1), (col2))
</pre><p>
            かわりに、キー部分を機能しないキー部分としてカッコなしで記述します:
          </p><pre class="programlisting">INDEX (col1, col2)
</pre></li><li class="listitem"><p>
            関数キー部分式はカラム接頭辞を参照できません。 回避策については、このセクションで後述する <code class="literal">SUBSTRING()</code> および <code class="literal">CAST()</code> の説明を参照してください。 
          </p></li><li class="listitem"><p>
            外部キー仕様では、機能キー部分は許可されません。
          </p></li></ul></div><p>
        <code class="literal">CREATE TABLE ... LIKE</code> の場合、宛先テーブルは元のテーブルの機能キー部分を保持します。
      </p><p>
        関数インデックスは非表示の仮想生成カラムとして実装され、次のような影響があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            各関数キー部分は、テーブルのカラムの合計数に対する制限に対してカウントされます。<a class="xref" href="optimization.html#column-count-limit" title="8.4.7 テーブルカラム数と行サイズの制限">セクション8.4.7「テーブルカラム数と行サイズの制限」</a> を参照してください。
          </p></li><li class="listitem"><p>
            機能キー部分は、生成されたカラムに適用されるすべての制限を継承します。 例: 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                関数キー部分には、生成されたカラムに許可された関数のみが許可されます。
              </p></li><li class="listitem"><p>
                サブクエリー、パラメータ、変数、ストアドファンクションおよびユーザー定義関数は使用できません。
              </p></li></ul></div><p>
            適用可能な制限の詳細は、<a class="xref" href="sql-statements.html#create-table-generated-columns" title="13.1.20.8 CREATE TABLE および生成されるカラム">セクション13.1.20.8「CREATE TABLE および生成されるカラム」</a> および <a class="xref" href="sql-statements.html#alter-table-generated-columns" title="13.1.9.2 ALTER TABLE および生成されるカラム">セクション13.1.9.2「ALTER TABLE および生成されるカラム」</a> を参照してください。
          </p></li><li class="listitem"><p>
            仮想生成カラム自体に記憶域は必要ありません。 インデックス自体は、他のインデックスと同様に記憶領域を占有します。 
          </p></li></ul></div><p>
        <code class="literal">UNIQUE</code> は、関数キー部分を含むインデックスに対してサポートされています。 ただし、主キーに機能キー部分を含めることはできません。 主キーでは、生成されたカラムを格納する必要がありますが、機能キー部分は、格納された生成カラムではなく、仮想生成カラムとして実装されます。 
      </p><p>
        <code class="literal">SPATIAL</code> および <code class="literal">FULLTEXT</code> インデックスには、関数キー部分を含めることはできません。
      </p><p>
        テーブルに主キーが含まれていない場合、<code class="literal">InnoDB</code> は最初の <code class="literal">UNIQUE NOT NULL</code> インデックスを主キーに自動的に昇格します。 これは、関数キー部分を持つ <code class="literal">UNIQUE NOT NULL</code> インデックスではサポートされません。 
      </p><p>
        インデックスが重複している場合は、非関数インデックスで警告が発生します。 関数キー部分を含むインデックスには、この機能はありません。 
      </p><p>
        関数キー部分によって参照されるカラムを削除するには、最初にインデックスを削除する必要があります。 それ以外の場合は、エラーが発生します。 
      </p><p>
        非機能キー部分は接頭辞の長さの指定をサポートしていますが、これは機能キー部分では不可能です。 解決策は、<code class="literal">SUBSTRING()</code>(または、このセクションの後半で説明する <code class="literal">CAST()</code>) を使用することです。 クエリーで使用される <code class="literal">SUBSTRING()</code> 関数を含む関数キー部分の場合、<code class="literal">WHERE</code> 句には同じ引数を持つ <code class="literal">SUBSTRING()</code> が含まれている必要があります。 次の例では、<code class="literal">SUBSTRING()</code> への引数がインデックス指定と一致する唯一のクエリーであるため、インデックスを使用できるのは 2 つ目の <code class="literal">SELECT</code> のみです: 
      </p><pre class="programlisting">CREATE TABLE tbl (
  col1 LONGTEXT,
  INDEX idx1 ((SUBSTRING(col1, 1, 10)))
);
SELECT * FROM tbl WHERE SUBSTRING(col1, 1, 9) = '123456789';
SELECT * FROM tbl WHERE SUBSTRING(col1, 1, 10) = '1234567890';
</pre><p>
        関数キーパーツを使用すると、<code class="literal">JSON</code> 値など、インデックス化できない値のインデックス化が可能です。 ただし、目的の効果を得るには、これを正しく行う必要があります。 たとえば、次の構文は機能しません: 
      </p><pre class="programlisting">CREATE TABLE employees (
  data JSON,
  INDEX ((data-&gt;&gt;'$.name'))
);
</pre><p>
        構文は、次の理由で失敗します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">-&gt;&gt;</code> 演算子は <code class="literal">JSON_UNQUOTE(JSON_EXTRACT(...))</code> に変換されます。
          </p></li><li class="listitem"><p>
            <code class="literal">JSON_UNQUOTE()</code> は、データ型が <code class="literal">LONGTEXT</code> の値を戻し、非表示の生成されたカラムには同じデータ型が割り当てられます。
          </p></li><li class="listitem"><p>
            MySQL では、キー部分に接頭辞の長さを指定せずに <code class="literal">LONGTEXT</code> カラムをインデックス付けすることはできず、機能キー部分では接頭辞の長さを使用できません。
          </p></li></ul></div><p>
        <code class="literal">JSON</code> カラムをインデックス付けするには、次のように <code class="literal">CAST()</code> 関数を使用します:
      </p><pre class="programlisting">CREATE TABLE employees (
  data JSON,
  INDEX ((CAST(data-&gt;&gt;'$.name' AS CHAR(30))))
);
</pre><p>
        非表示の生成されたカラムには、インデックス付け可能な <code class="literal">VARCHAR(30)</code> データ型が割り当てられます。 ただし、この方法では、インデックスを使用しようとすると新しい問題が発生します: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CAST()</code> は、照合 <code class="literal">utf8mb4_0900_ai_ci</code> (サーバーのデフォルトの照合) を含む文字列を返します。
          </p></li><li class="listitem"><p>
            <code class="literal">JSON_UNQUOTE()</code> は、照合順序が <code class="literal">utf8mb4_bin</code> (ハードコード) の文字列を返します。
          </p></li></ul></div><p>
        その結果、前述のテーブル定義のインデックス付き式と次のクエリーの <code class="literal">WHERE</code> 句式の間に照合の不一致があります:
      </p><pre class="programlisting">SELECT * FROM employees WHERE data-&gt;&gt;'$.name' = 'James';
</pre><p>
        クエリーとインデックスの式が異なるため、インデックスは使用されません。 関数キー部分でこのようなシナリオをサポートするために、オプティマイザは使用するインデックスを検索するときに <code class="literal">CAST()</code> を自動的に削除しますが、インデックス付き式の照合がクエリー式の照合と一致する場合は<span class="emphasis"><em>のみ</em></span>を削除します。 関数キー部分が使用されるインデックスの場合、次の 2 つのソリューションのいずれかが機能します (ただし、ある程度異なります): 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            解決策 1。 インデックス付き式に <code class="literal">JSON_UNQUOTE()</code> と同じ照合を割り当てます: 
          </p><pre class="programlisting">CREATE TABLE employees (
  data JSON,
  INDEX idx ((CAST(data-&gt;&gt;"$.name" AS CHAR(30)) COLLATE utf8mb4_bin))
);
INSERT INTO employees VALUES
  ('{ "name": "james", "salary": 9000 }'),
  ('{ "name": "James", "salary": 10000 }'),
  ('{ "name": "Mary", "salary": 12000 }'),
  ('{ "name": "Peter", "salary": 8000 }');
SELECT * FROM employees WHERE data-&gt;&gt;'$.name' = 'James';
</pre><p>
            <code class="literal">-&gt;&gt;</code>演算子は <code class="literal">JSON_UNQUOTE(JSON_EXTRACT(...))</code> と同じで、<code class="literal">JSON_UNQUOTE()</code> は照合順序 <code class="literal">utf8mb4_bin</code> を持つ文字列を返します。 したがって、比較では大文字と小文字が区別され、一致する行は 1 つのみです: 
          </p><pre class="programlisting">+------------------------------------+
| data                               |
+------------------------------------+
| {"name": "James", "salary": 10000} |
+------------------------------------+
</pre></li><li class="listitem"><p>
            ソリューション 2. クエリーに完全な式を指定します: 
          </p><pre class="programlisting">CREATE TABLE employees (
  data JSON,
  INDEX idx ((CAST(data-&gt;&gt;"$.name" AS CHAR(30))))
);
INSERT INTO employees VALUES
  ('{ "name": "james", "salary": 9000 }'),
  ('{ "name": "James", "salary": 10000 }'),
  ('{ "name": "Mary", "salary": 12000 }'),
  ('{ "name": "Peter", "salary": 8000 }');
SELECT * FROM employees WHERE CAST(data-&gt;&gt;'$.name' AS CHAR(30)) = 'James';
</pre><p>
            <code class="literal">CAST()</code> は照合 <code class="literal">utf8mb4_0900_ai_ci</code> を含む文字列を返すため、比較では大文字と小文字が区別されず、次の 2 つの行が一致します:
          </p><pre class="programlisting">+------------------------------------+
| data                               |
+------------------------------------+
| {"name": "james", "salary": 9000}  |
| {"name": "James", "salary": 10000} |
+------------------------------------+
</pre></li></ul></div><p>
        オプティマイザではインデックス付けされた生成カラムを含む <code class="literal">CAST()</code> の自動削除がサポートされていますが、次の方法ではインデックスの有無にかかわらず異なる結果が生成されるため、機能しないことに注意してください (Bug#27337092):
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE employees (</code></strong>
         <strong class="userinput"><code>data JSON,</code></strong>
         <strong class="userinput"><code>generated_col VARCHAR(30) AS (CAST(data-&gt;&gt;'$.name' AS CHAR(30)))</code></strong>
       <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected, 1 warning (0.03 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO employees (data)</code></strong>
       <strong class="userinput"><code>VALUES ('{"name": "james"}'), ('{"name": "James"}');</code></strong>
Query OK, 2 rows affected, 1 warning (0.01 sec)
Records: 2  Duplicates: 0  Warnings: 1

mysql&gt; <strong class="userinput"><code>SELECT * FROM employees WHERE data-&gt;&gt;'$.name' = 'James';</code></strong>
+-------------------+---------------+
| data              | generated_col |
+-------------------+---------------+
| {"name": "James"} | James         |
+-------------------+---------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE employees ADD INDEX idx (generated_col);</code></strong>
Query OK, 0 rows affected, 1 warning (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 1

mysql&gt; <strong class="userinput"><code>SELECT * FROM employees WHERE data-&gt;&gt;'$.name' = 'James';</code></strong>
+-------------------+---------------+
| data              | generated_col |
+-------------------+---------------+
| {"name": "james"} | james         |
| {"name": "James"} | James         |
+-------------------+---------------+
2 rows in set (0.01 sec)
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="create-index-unique"></a>一意インデックス</h4></div></div></div><p>
        <code class="literal">UNIQUE</code> インデックスは、そのインデックス内のすべての値が異なっている必要があるという制約を作成します。 既存の行に一致するキー値を持つ新しい行を追加しようとすると、エラーが発生します。 <code class="literal">UNIQUE</code> インデックスのカラムに接頭辞値を指定する場合、カラム値は接頭辞の長さ内で一意である必要があります。 <code class="literal">UNIQUE</code> インデックスでは、<code class="literal">NULL</code> を含むことができるカラムに対して複数の <code class="literal">NULL</code> 値が許可されます。 
      </p><a class="indexterm" name="idm45827005705440"></a><p>
        テーブルに整数型の単一カラムで構成される <code class="literal">PRIMARY KEY</code> または <code class="literal">UNIQUE NOT NULL</code> インデックスがある場合は、次のように<code class="literal">_rowid</code> を使用して <code class="literal">SELECT</code> ステートメントのインデックス付けされたカラムを参照できます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            単一の整数カラムで構成される <code class="literal">PRIMARY KEY</code> がある場合、<code class="literal">_rowid</code> は <code class="literal">PRIMARY KEY</code> カラムを参照します。 <code class="literal">PRIMARY KEY</code> はあるが、単一の整数カラムで構成されていない場合、<code class="literal">_rowid</code> は使用できません。 
          </p></li><li class="listitem"><p>
            それ以外の場合、<code class="literal">_rowid</code> は最初の <code class="literal">UNIQUE NOT NULL</code> インデックスのカラムを参照します (そのインデックスが単一の整数カラムで構成されている場合)。 最初の <code class="literal">UNIQUE NOT NULL</code> インデックスが単一の整数カラムで構成されていない場合、<code class="literal">_rowid</code> は使用できません。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="create-index-fulltext"></a>全文インデックス</h4></div></div></div><p>
        <code class="literal">FULLTEXT</code> インデックスは <code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> テーブルでのみサポートされ、<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、および <code class="literal">TEXT</code> カラムのみを含めることができます。 インデックス設定は常に、カラム全体に対して実行されます。カラムプリフィクスのインデックス設定はサポートされていないため、プリフィクス長が指定されてもすべて無視されます。 操作の詳細は、<a class="xref" href="functions.html#fulltext-search" title="12.10 全文検索関数">セクション12.10「全文検索関数」</a>を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="create-index-multi-valued"></a>複数値インデックス</h4></div></div></div><a class="indexterm" name="idm45827005680352"></a><p>
        MySQL 8.0.17 では、<code class="literal">InnoDB</code> は複数値インデックスをサポートしています。 複数値インデックスは、値の配カラムを格納するカラムに定義されたセカンダリインデックスです。 <span class="quote">「<span class="quote">normal</span>」</span> インデックスには、データレコードごとに 1 つのインデックスレコードがあります (1:1)。 複数値インデックスは、単一のデータレコードに対して複数のインデックスレコードを持つことができます (N:1)。 複数値インデックスは <code class="literal">JSON</code> 配列のインデックス付けを目的としています。 たとえば、次の JSON ドキュメントの郵便番号の配列に定義された複数値インデックスでは、各インデックスレコードが同じデータレコードを参照するように、郵便番号ごとにインデックスレコードが作成されます。 
      </p><pre class="programlisting">{
    "user":"Bob",
    "user_id":31,
    "zipcode":[94477,94536]
}
</pre><h5><a name="idm45827005674224"></a>複数値インデックスの作成</h5><p>
        <code class="literal">CREATE TABLE</code>、<code class="literal">ALTER TABLE</code> または <code class="literal">CREATE INDEX</code> ステートメントで複数値インデックスを作成できます。 これには、<code class="literal">JSON</code> 配列内の同じ型のスカラー値を SQL データ型配列にキャストするインデックス定義で <code class="literal">CAST(... AS ... ARRAY)</code> を使用する必要があります。 仮想カラムは、SQL データ型配列の値を使用して透過的に生成されます。最後に、仮想カラムに関数インデックス (仮想インデックスとも呼ばれます) が作成されます。 これは、複数値インデックスを形成する SQL データ型配カラムの値の仮想カラムに定義された関数インデックスです。 
      </p><p>
        次のリストの例は、<code class="literal">customers</code> という名前のテーブルの <code class="literal">JSON</code> カラム <code class="literal">custinfo</code> の配カラム <code class="literal">$.zipcode</code> に複数値インデックス <code class="literal">zips</code> を作成する方法を示しています。 いずれの場合も、JSON 配列は <code class="literal">UNSIGNED</code> 整数値の SQL データ型配列にキャストされます。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CREATE TABLE</code> のみ:
          </p><pre class="programlisting">CREATE TABLE customers (
    id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    modified DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    custinfo JSON,
    INDEX zips( (CAST(custinfo-&gt;'$.zip' AS UNSIGNED ARRAY)) )
    );
</pre></li><li class="listitem"><p>
            <code class="literal">CREATE TABLE</code> と <code class="literal">ALTER TABLE</code>:
          </p><p>
</p><pre class="programlisting">CREATE TABLE customers (
    id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    modified DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    custinfo JSON
    );

ALTER TABLE customers ADD INDEX zips( (CAST(custinfo-&gt;'$.zip' AS UNSIGNED ARRAY)) );
</pre><p>
          </p></li><li class="listitem"><p>
            <code class="literal">CREATE TABLE</code> と <code class="literal">CREATE INDEX</code>:
          </p><p>
</p><pre class="programlisting">CREATE TABLE customers (
    id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    modified DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    custinfo JSON
    );

CREATE INDEX zips ON customers ( (CAST(custinfo-&gt;'$.zip' AS UNSIGNED ARRAY)) );
</pre><p>
          </p></li></ul></div><p>
        複数値インデックスはコンポジットインデックスの一部として定義することもできます。 次の例は、(<code class="literal">id</code> および <code class="literal">modified</code> カラムの) 2 つの単一値部分と (<code class="literal">custinfo</code> カラムの) 1 つの複数値部分を含むコンポジットインデックスを示しています: 
      </p><pre class="programlisting">CREATE TABLE customers (
    id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    modified DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    custinfo JSON
    );

ALTER TABLE customers ADD INDEX comp(id, modified,
    (CAST(custinfo-&gt;'$.zipcode' AS UNSIGNED ARRAY)) );
</pre><p>
        コンポジットインデックスで使用できる複数値キー部分は 1 つのみです。 複数値キー部分は、キーの他の部分に対して任意の順序で使用できます。 つまり、示されている <code class="literal">ALTER TABLE</code> ステートメントは、<code class="literal">comp(id, (CAST(custinfo-&gt;'$.zipcode' AS UNSIGNED ARRAY), modified))</code> (またはその他の順序付け) を使用している可能性があり、引き続き有効です。 
      </p><h5><a name="idm45827005643856"></a>複数値インデックスの使用</h5><p>
        <code class="literal">WHERE</code> 句で次の関数が指定されている場合、オプティマイザは複数値インデックスを使用してレコードをフェッチします:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">MEMBER OF()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">JSON_CONTAINS()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">JSON_OVERLAPS()</code>
          </p></li></ul></div><p>
        これを示すために、次の <code class="literal">CREATE TABLE</code> および <code class="literal">INSERT</code> ステートメントを使用して <code class="literal">customers</code> テーブルを作成および移入します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE customers (</code></strong>
    -&gt;     <strong class="userinput"><code>id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,</code></strong>
    -&gt;     <strong class="userinput"><code>modified DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</code></strong>
    -&gt;     <strong class="userinput"><code>custinfo JSON</code></strong>
    -&gt;     <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.51 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO customers VALUES</code></strong>
    -&gt;     <strong class="userinput"><code>(NULL, NOW(), '{"user":"Jack","user_id":37,"zipcode":[94582,94536]}'),</code></strong>
    -&gt;     <strong class="userinput"><code>(NULL, NOW(), '{"user":"Jill","user_id":22,"zipcode":[94568,94507,94582]}'),</code></strong>
    -&gt;     <strong class="userinput"><code>(NULL, NOW(), '{"user":"Bob","user_id":31,"zipcode":[94477,94507]}'),</code></strong>
    -&gt;     <strong class="userinput"><code>(NULL, NOW(), '{"user":"Mary","user_id":72,"zipcode":[94536]}'),</code></strong>
    -&gt;     <strong class="userinput"><code>(NULL, NOW(), '{"user":"Ted","user_id":56,"zipcode":[94507,94582]}');</code></strong>
Query OK, 5 rows affected (0.07 sec)
Records: 5  Duplicates: 0  Warnings: 0
</pre><p>
        まず、<code class="literal">customers</code> テーブルに対して 3 つのクエリーを実行します。それぞれが <code class="literal">MEMBER OF()</code>、<code class="literal">JSON_CONTAINS()</code> および <code class="literal">JSON_OVERLAPS()</code> を使用し、次に示す各クエリーの結果が表示されます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM customers</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE 94507 MEMBER OF(custinfo-&gt;'$.zipcode');</code></strong>
+----+---------------------+-------------------------------------------------------------------+
| id | modified            | custinfo                                                          |
+----+---------------------+-------------------------------------------------------------------+
|  2 | 2019-06-29 22:23:12 | {"user": "Jill", "user_id": 22, "zipcode": [94568, 94507, 94582]} |
|  3 | 2019-06-29 22:23:12 | {"user": "Bob", "user_id": 31, "zipcode": [94477, 94507]}         |
|  5 | 2019-06-29 22:23:12 | {"user": "Ted", "user_id": 56, "zipcode": [94507, 94582]}         |
+----+---------------------+-------------------------------------------------------------------+
3 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM customers</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE JSON_CONTAINS(custinfo-&gt;'$.zipcode', CAST('[94507,94582]' AS JSON));</code></strong>
+----+---------------------+-------------------------------------------------------------------+
| id | modified            | custinfo                                                          |
+----+---------------------+-------------------------------------------------------------------+
|  2 | 2019-06-29 22:23:12 | {"user": "Jill", "user_id": 22, "zipcode": [94568, 94507, 94582]} |
|  5 | 2019-06-29 22:23:12 | {"user": "Ted", "user_id": 56, "zipcode": [94507, 94582]}         |
+----+---------------------+-------------------------------------------------------------------+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM customers</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE JSON_OVERLAPS(custinfo-&gt;'$.zipcode', CAST('[94507,94582]' AS JSON));</code></strong>
+----+---------------------+-------------------------------------------------------------------+
| id | modified            | custinfo                                                          |
+----+---------------------+-------------------------------------------------------------------+
|  1 | 2019-06-29 22:23:12 | {"user": "Jack", "user_id": 37, "zipcode": [94582, 94536]}        |
|  2 | 2019-06-29 22:23:12 | {"user": "Jill", "user_id": 22, "zipcode": [94568, 94507, 94582]} |
|  3 | 2019-06-29 22:23:12 | {"user": "Bob", "user_id": 31, "zipcode": [94477, 94507]}         |
|  5 | 2019-06-29 22:23:12 | {"user": "Ted", "user_id": 56, "zipcode": [94507, 94582]}         |
+----+---------------------+-------------------------------------------------------------------+
4 rows in set (0.00 sec)
</pre><p>
        次に、前述の 3 つのクエリーごとに <code class="literal">EXPLAIN</code> を実行します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM customers</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE 94507 MEMBER OF(custinfo-&gt;'$.zipcode');</code></strong>
+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | customers | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    5 |   100.00 | Using where |
+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM customers</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE JSON_CONTAINS(custinfo-&gt;'$.zipcode', CAST('[94507,94582]' AS JSON));</code></strong>
+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | customers | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    5 |   100.00 | Using where |
+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM customers</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE JSON_OVERLAPS(custinfo-&gt;'$.zipcode', CAST('[94507,94582]' AS JSON));</code></strong>
+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | customers | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    5 |   100.00 | Using where |
+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.01 sec)
</pre><p>
        上記の 3 つのクエリーでは、どのキーも使用できません。 この問題を解決するには、次のように、<code class="literal">zipcode</code> 配カラムの <code class="literal">JSON</code> カラム (<code class="literal">custinfo</code>) に複数値インデックスを追加します: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE customers</code></strong>
    -&gt;     <strong class="userinput"><code>ADD INDEX zips( (CAST(custinfo-&gt;'$.zipcode' AS UNSIGNED ARRAY)) );</code></strong>
Query OK, 0 rows affected (0.47 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
        前の <code class="literal">EXPLAIN</code> ステートメントを再度実行すると、作成したばかりのインデックス <code class="literal">zips</code> をクエリーで使用できる (および使用できる) ことがわかります:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM customers</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE 94507 MEMBER OF(custinfo-&gt;'$.zipcode');</code></strong>
+----+-------------+-----------+------------+------+---------------+------+---------+-------+------+----------+-------------+
| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref   | rows | filtered | Extra       |
+----+-------------+-----------+------------+------+---------------+------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | customers | NULL       | ref  | zips          | zips | 9       | const |    1 |   100.00 | Using where |
+----+-------------+-----------+------------+------+---------------+------+---------+-------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM customers</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE JSON_CONTAINS(custinfo-&gt;'$.zipcode', CAST('[94507,94582]' AS JSON));</code></strong>
+----+-------------+-----------+------------+-------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table     | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-----------+------------+-------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | customers | NULL       | range | zips          | zips | 9       | NULL |    6 |   100.00 | Using where |
+----+-------------+-----------+------------+-------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM customers</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE JSON_OVERLAPS(custinfo-&gt;'$.zipcode', CAST('[94507,94582]' AS JSON));</code></strong>
+----+-------------+-----------+------------+-------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table     | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-----------+------------+-------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | customers | NULL       | range | zips          | zips | 9       | NULL |    6 |   100.00 | Using where |
+----+-------------+-----------+------------+-------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.01 sec)
</pre><p>
        複数値インデックスは一意キーとして定義できます。 一意キーとして定義されている場合、複数値インデックスにすでに存在する値を挿入しようとすると、重複キーエラーが返されます。 重複する値がすでに存在する場合、次に示すように、一意の複数値インデックスを追加しようとすると失敗します: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE customers DROP INDEX zips;</code></strong>
Query OK, 0 rows affected (0.55 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>ALTER TABLE customers</code></strong>
    -&gt;     <strong class="userinput"><code>ADD UNIQUE INDEX zips((CAST(custinfo-&gt;'$.zipcode' AS UNSIGNED ARRAY)));</code></strong>
<span class="errortext">ERROR 1062 (23000): Duplicate entry '[94507, ' for key 'customers.zips'</span>
mysql&gt; <strong class="userinput"><code>ALTER TABLE customers</code></strong>
    -&gt;     <strong class="userinput"><code>ADD INDEX zips((CAST(custinfo-&gt;'$.zipcode' AS UNSIGNED ARRAY)));</code></strong>
Query OK, 0 rows affected (0.36 sec)
Records: 0  Duplicates: 0  Warnings: 0

</pre><h5><a name="idm45827005578944"></a>複数値インデックスの特性</h5><p>
        複数値インデックスには、次に示す追加の特性があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            複数値インデックスに影響する DML 操作は、通常のインデックスに影響する DML 操作と同じ方法で処理されますが、唯一の違いは、単一のクラスタインデックスレコードに対して複数の挿入または更新が存在する可能性があることです。
          </p></li><li class="listitem"><p>
            NULL 値可能性および複数値インデックス:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                複数値キー部分に空の配列がある場合、インデックスにエントリは追加されず、データレコードにはインデックススキャンでアクセスできません。
              </p></li><li class="listitem"><p>
                複数値キー部分の生成で <code class="literal">NULL</code> 値が返された場合、<code class="literal">NULL</code> を含む単一のエントリが複数値インデックスに追加されます。 キー部分が <code class="literal">NOT NULL</code> として定義されている場合は、エラーが報告されます。 
              </p></li><li class="listitem"><p>
                型付き配列カラムが <code class="literal">NULL</code> に設定されている場合、ストレージエンジンは、データレコードを指す <code class="literal">NULL</code> を含む単一のレコードを格納します。
              </p></li><li class="listitem"><p>
                インデックス付き配列では、<code class="literal">JSON</code> の NULL 値は許可されません。 戻り値が <code class="literal">NULL</code> の場合、JSON null として扱われ、<span class="errortext">「JSON 値が無効です」</span>エラーが報告されます。 
              </p></li></ul></div></li><li class="listitem"><p>
            複数値インデックスは仮想カラムの仮想インデックスであるため、仮想生成カラムのセカンダリインデックスと同じルールに従う必要があります。
          </p></li><li class="listitem"><p>
            空の配列のインデックスレコードは追加されません。
          </p></li></ul></div><h5><a name="idm45827005561120"></a>複数値インデックスの制限事項</h5><p>
        複数値インデックスには、次の制限事項があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            複数値インデックスごとに許可される複数値キー部分は 1 つのみです。 ただし、次に示すように、<code class="literal">CAST(... AS ... ARRAY)</code> 式は <code class="literal">JSON</code> 文書内の複数の配列を参照できます: 
          </p><pre class="programlisting">CAST(data-&gt;'$.arr[*][*]' AS UNSIGNED ARRAY)
</pre><p>
            この場合、JSON 式に一致するすべての値が単一のフラット配列としてインデックスに格納されます。
          </p></li><li class="listitem"><p>
            複数値キー部分を持つインデックスは順序付けをサポートしていないため、主キーとして使用できません。 同じ理由で、<code class="literal">ASC</code> または <code class="literal">DESC</code> キーワードを使用して複数値インデックスを定義することはできません。 
          </p></li><li class="listitem"><p>
            複数値インデックスをカバーインデックスにすることはできません。
          </p></li><li class="listitem"><p>
            複数値インデックスのレコード当たりの最大値は、単一の undo ログページに格納できるデータ量によって決まります。つまり、65221 バイト (オーバーヘッドの場合は 64K から 315 バイトを引いた値) で、キー値の最大合計長も 65221 バイトです。 キーの最大数は様々な要因に依存するため、特定の制限を定義できません。 たとえば、テストでは、レコードごとに 1604 個までの整数キーを許可する複数値インデックスが示されています。 制限に達すると、次のようなエラーが報告されます: <span class="errortext">ERROR 3905 (HY000): 複数値インデックス'idx'のレコード当たりの値の最大数を 1 値超えました</span>。 
          </p></li><li class="listitem"><p>
            複数値キー部分で許可されている式のタイプは、<code class="literal">JSON</code> 式のみです。 式は、インデックス付けされたカラムに挿入された JSON ドキュメント内の既存の要素を参照する必要はありませんが、構文的に有効である必要があります。 
          </p></li><li class="listitem"><p>
            同じクラスタインデックスレコードのインデックスレコードは複数値インデックス全体に分散されるため、複数値インデックスではレンジスキャンまたはインデックスのみのスキャンはサポートされません。
          </p></li><li class="listitem"><p>
            複数値インデックスは、外部キー指定では使用できません。
          </p></li><li class="listitem"><p>
            複数値インデックスにはインデックス接頭辞を定義できません。
          </p></li><li class="listitem"><p>
            複数値インデックスは、データキャストで <code class="literal">BINARY</code> として定義できません (<code class="literal">CAST()</code> 関数の説明を参照)。
          </p></li><li class="listitem"><p>
            複数値インデックスのオンライン作成はサポートされていません。つまり、操作で <code class="literal">ALGORITHM=COPY</code> が使用されます。 <a class="xref" href="sql-statements.html#alter-table-performance" title="パフォーマンスおよび領域要件">パフォーマンスおよび領域要件</a>を参照してください。 
          </p></li><li class="listitem"><p>
            次の 2 つの文字セットと照合順序の組合せ以外の文字セットと照合順序は、複数値インデックスではサポートされていません:
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                デフォルトの <code class="literal">binary</code> 照合順序を持つ <code class="literal">binary</code> 文字セット
              </p></li><li class="listitem"><p>
                デフォルトの <code class="literal">utf8mb4_0900_as_cs</code> 照合順序を持つ <code class="literal">utf8mb4</code> 文字セット。
              </p></li></ol></div></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> テーブルのカラムに対する他のインデックスと同様に、<code class="literal">USING HASH</code> では複数値インデックスを作成できません。作成しようとすると警告が表示されます: <span class="errortext">このストレージエンジンは HASH インデックスアルゴリズムをサポートしていません。代わりにストレージエンジンのデフォルトが使用されました</span>。 (<code class="literal">USING BTREE</code> は通常どおりにサポートされます。) 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="create-index-spatial"></a>空間インデックス</h4></div></div></div><p>
        <code class="literal">MyISAM</code>, <code class="literal">InnoDB</code>, <code class="literal">NDB</code> および <code class="literal">ARCHIVE</code> ストレージエンジンは、<code class="literal">POINT</code>、<code class="literal">GEOMETRY</code> などの空間カラムをサポートしています。(<a class="xref" href="data-types.html#spatial-types" title="11.4 空間データ型">セクション11.4「空間データ型」</a> では、空間データ型について説明します。) ただし、空間カラムのインデックス設定に対するサポートはエンジンによって異なります。 空間カラムの空間インデックスおよび非空間インデックスは、次のルールに従って使用できます。 
      </p><p>
        空間カラムの空間インデックスには、次の特性があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> テーブルでのみ使用できます。 その他のストレージエンジンに対して <code class="literal">SPATIAL INDEX</code> を指定すると、エラーが発生します。 
          </p></li><li class="listitem"><p>
            MySQL 8.0.12 では、空間カラムのインデックスは <code class="literal">SPATIAL</code> インデックスである必要があります。 したがって、<code class="literal">SPATIAL</code> キーワードはオプションですが、空間カラムにインデックスを作成する場合は暗黙的です。 
          </p></li><li class="listitem"><p>
            単一の空間カラムにのみ使用できます。 空間インデックスは、複数の空間カラムに対して作成できません。 
          </p></li><li class="listitem"><p>
            インデックス付きカラムは <code class="literal">NOT NULL</code> である必要があります。
          </p></li><li class="listitem"><p>
            カラム接頭辞の長さは禁止されています。 各カラムの幅全体にインデックスが設定されます。 
          </p></li><li class="listitem"><p>
            主キーまたは一意インデックスには使用できません。
          </p></li></ul></div><p>
        (<code class="literal">INDEX</code>、<code class="literal">UNIQUE</code> または <code class="literal">PRIMARY KEY</code> で作成された) 空間カラムの非空間インデックスには、次の特性があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">ARCHIVE</code> を除く空間カラムをサポートするすべてのストレージエンジンに対して許可されます。
          </p></li><li class="listitem"><p>
            インデックスが主キーでないかぎり、カラムを <code class="literal">NULL</code> にすることができます。
          </p></li><li class="listitem"><p>
            非 <code class="literal">SPATIAL</code> インデックスのインデックスタイプは、ストレージエンジンによって異なります。 現在は、B ツリーが使用されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code>、<code class="literal">MyISAM</code> および <code class="literal">MEMORY</code> テーブルに対してのみ <code class="literal">NULL</code> 値を持つことができるカラムに対して許可されます。
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="create-index-options"></a>インデックスオプション</h4></div></div></div><p>
        キーパートリストの後に、インデックスオプションを指定できます。 <em class="replaceable"><code>index_option</code></em> 値には、次のいずれかを指定できます。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">KEY_BLOCK_SIZE [=] <em class="replaceable"><code>value</code></em></code>
          </p><p>
            <code class="literal">MyISAM</code> テーブルの場合、<code class="literal">KEY_BLOCK_SIZE</code> はオプションで、インデックスキーブロックに使用するサイズをバイト単位で指定します。 この値はヒントとして扱われます。必要に応じて、異なるサイズが使用される可能性があります。 個々のインデックス定義に指定された <code class="literal">KEY_BLOCK_SIZE</code> 値は、テーブルレベルの <code class="literal">KEY_BLOCK_SIZE</code> 値をオーバーライドします。 
          </p><p>
            <code class="literal">KEY_BLOCK_SIZE</code> は、<code class="literal">InnoDB</code> テーブルのインデックスレベルではサポートされていません。 <a class="xref" href="sql-statements.html#create-table" title="13.1.20 CREATE TABLE ステートメント">セクション13.1.20「CREATE TABLE ステートメント」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <em class="replaceable"><code>index_type</code></em>
          </p><p>
            一部のストレージエンジンでは、インデックスの作成時にインデックスタイプを指定できます。 例: 
          </p><pre class="programlisting">CREATE TABLE lookup (id INT) ENGINE = MEMORY;
CREATE INDEX id_index ON lookup (id) USING BTREE;
</pre><p>
            <a class="xref" href="sql-statements.html#create-index-storage-engine-index-types" title="表 13.1 ストレージエンジンあたりのインデックスタイプ">表13.1「ストレージエンジンあたりのインデックスタイプ」</a> には、様々なストレージエンジンでサポートされている許容インデックスタイプ値が表示されます。 複数のインデックスタイプが示されている場合は、最初のものが、インデックスタイプ指示子が指定されないときのデフォルトになります。 テーブルに示されていないストレージエンジンは、インデックス定義で <em class="replaceable"><code>index_type</code></em> 句をサポートしていません。 
          </p><div class="table"><a name="create-index-storage-engine-index-types"></a><p class="title"><b>表 13.1 ストレージエンジンあたりのインデックスタイプ</b></p><div class="table-contents"><table summary="Permissible index types by storage engine."><col style="width: 20%"><col style="width: 50%"><thead><tr>
                <th>ストレージエンジン</th>
                <th>許可されるインデックスタイプ</th>
              </tr></thead><tbody><tr>
                <td><code class="literal">InnoDB</code></td>
                <td><code class="literal">BTREE</code></td>
              </tr><tr>
                <td><code class="literal">MyISAM</code></td>
                <td><code class="literal">BTREE</code></td>
              </tr><tr>
                <td><code class="literal">MEMORY</code>/<code class="literal">HEAP</code></td>
                <td><code class="literal">HASH</code>、<code class="literal">BTREE</code></td>
              </tr><tr>
                <td><code class="literal">NDB</code></td>
                <td><code class="literal">HASH</code>、<code class="literal">BTREE</code> (テキストの注を参照してください)</td>
              </tr></tbody></table></div></div><br class="table-break"><p>
            <em class="replaceable"><code>index_type</code></em> 句は、<code class="literal">FULLTEXT INDEX</code> または (MySQL 8.0.12 より前の) <code class="literal">SPATIAL INDEX</code> 仕様には使用できません。 フルテキストインデックスの実装は、ストレージエンジンに依存します。 空間インデックスは R ツリーインデックスとして実装されます。 
          </p><p>
            特定のストレージエンジンに対して無効なインデックスタイプを指定しても、エンジンがクエリー結果に影響を与えずに使用できる別のインデックスタイプが使用可能な場合、エンジンは使用可能なタイプを使用します。 パーサーは、<code class="literal">RTREE</code> を型名として認識します。 MySQL 8.0.12 では、これは <code class="literal">SPATIAL</code> インデックスに対してのみ許可されます。 8.0.12 より前では、どのストレージエンジンにも <code class="literal">RTREE</code> を指定できません。 
          </p><p>
            <code class="literal">BTREE</code> インデックスは、<code class="literal">NDB</code> ストレージエンジンによって T ツリーインデックスとして実装されます。
          </p><a class="indexterm" name="idm45827005443680"></a><a class="indexterm" name="idm45827005441904"></a><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">NDB</code> テーブルカラム上のインデックスの場合、<code class="literal">USING</code> オプションは、一意のインデックスまたは主キーに対してのみ指定できます。 <code class="literal">USING HASH</code> では、順序付けされたインデックスは作成されません。それ以外の場合、<code class="literal">NDB</code> テーブルに一意インデックスまたは主キーを作成すると、順序付けられたインデックスとハッシュインデックスの両方が自動的に作成され、それぞれが同じカラムセットをインデックス付けします。 
            </p><p>
              <code class="literal">NDB</code> テーブルの 1 つ以上の <code class="literal">NULL</code> カラムを含む一意インデックスの場合、ハッシュインデックスはリテラル値の検索にのみ使用できます。つまり、<code class="literal">IS [NOT] NULL</code> 条件ではテーブルの全体スキャンが必要です。 回避策として、このようなテーブルの <code class="literal">NULL</code> カラムを使用している一意のインデックスが、順序付けられたインデックスを含む方法で常に作成されるようにすることがあります。つまり、インデックスの作成時に <code class="literal">USING HASH</code> を使用しないようにします。 
            </p></div><p>
            特定のストレージエンジンに対して無効なインデックスタイプを指定しても、エンジンがクエリー結果に影響を与えずに使用できる別のインデックスタイプが使用可能な場合、エンジンは使用可能なタイプを使用します。 パーサーは <code class="literal">RTREE</code> をタイプ名として認識しますが、現在、これはどのストレージエンジンに対しても指定できません。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">ON <em class="replaceable"><code>tbl_name</code></em></code> 句の前の <em class="replaceable"><code>index_type</code></em> オプションの使用は非推奨になりました。この位置でのオプションの使用のサポートは、将来の MySQL リリースで削除される予定です。 <em class="replaceable"><code>index_type</code></em> オプションが前とあとの両方の位置で指定された場合は、最後のオプションが適用されます。 
            </p></div><p>
            <code class="literal">TYPE <em class="replaceable"><code>type_name</code></em></code> は、<code class="literal">USING <em class="replaceable"><code>type_name</code></em></code> のシノニムとして認識されます。 ただし、推奨される形式は <code class="literal">USING</code> です。 
          </p><p>
            次のテーブルに、<em class="replaceable"><code>index_type</code></em> オプションをサポートするストレージエンジンのインデックス特性を示します。
          </p><div class="table"><a name="innodb-storage-engine-index-characteristics"></a><p class="title"><b>表 13.2 InnoDB ストレージエンジンのインデックス特性</b></p><div class="table-contents"><table summary="Index characteristics of the InnoDB storage engine."><col style="width: 15%"><col style="width: 10%"><col style="width: 15%"><col style="width: 20%"><col style="width: 20%"><col style="width: 20%"><thead><tr>
                <th scope="col">インデックスクラス</th>
                <th scope="col">インデックスタイプ</th>
                <th scope="col">NULL VALUES を格納</th>
                <th scope="col">複数の NULL 値を許可</th>
                <th scope="col">IS NULL スキャンタイプ</th>
                <th scope="col">IS NOT NULL スキャンタイプ</th>
              </tr></thead><tbody><tr>
                <th scope="row">主キー</th>
                <td><code class="literal">BTREE</code></td>
                <td>いいえ</td>
                <td>いいえ</td>
                <td>N/A</td>
                <td>N/A</td>
              </tr><tr>
                <th scope="row">Unique</th>
                <td><code class="literal">BTREE</code></td>
                <td>はい</td>
                <td>はい</td>
                <td>インデックス</td>
                <td>インデックス</td>
              </tr><tr>
                <th scope="row">鍵</th>
                <td><code class="literal">BTREE</code></td>
                <td>はい</td>
                <td>はい</td>
                <td>インデックス</td>
                <td>インデックス</td>
              </tr><tr>
                <th scope="row"><code class="literal">FULLTEXT</code></th>
                <td>N/A</td>
                <td>はい</td>
                <td>はい</td>
                <td>Table</td>
                <td>Table</td>
              </tr><tr>
                <th scope="row"><code class="literal">SPATIAL</code></th>
                <td>N/A</td>
                <td>いいえ</td>
                <td>いいえ</td>
                <td>N/A</td>
                <td>N/A</td>
              </tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="myisam-storage-engine-index-characteristics"></a><p class="title"><b>表 13.3 MyISAM ストレージエンジンのインデックス特性</b></p><div class="table-contents"><table summary="Index characteristics of the MyISAM storage engine."><col style="width: 15%"><col style="width: 10%"><col style="width: 15%"><col style="width: 20%"><col style="width: 20%"><col style="width: 20%"><thead><tr>
                <th scope="col">インデックスクラス</th>
                <th scope="col">インデックスタイプ</th>
                <th scope="col">NULL VALUES を格納</th>
                <th scope="col">複数の NULL 値を許可</th>
                <th scope="col">IS NULL スキャンタイプ</th>
                <th scope="col">IS NOT NULL スキャンタイプ</th>
              </tr></thead><tbody><tr>
                <th scope="row">主キー</th>
                <td><code class="literal">BTREE</code></td>
                <td>いいえ</td>
                <td>いいえ</td>
                <td>N/A</td>
                <td>N/A</td>
              </tr><tr>
                <th scope="row">Unique</th>
                <td><code class="literal">BTREE</code></td>
                <td>はい</td>
                <td>はい</td>
                <td>インデックス</td>
                <td>インデックス</td>
              </tr><tr>
                <th scope="row">鍵</th>
                <td><code class="literal">BTREE</code></td>
                <td>はい</td>
                <td>はい</td>
                <td>インデックス</td>
                <td>インデックス</td>
              </tr><tr>
                <th scope="row"><code class="literal">FULLTEXT</code></th>
                <td>N/A</td>
                <td>はい</td>
                <td>はい</td>
                <td>Table</td>
                <td>Table</td>
              </tr><tr>
                <th scope="row"><code class="literal">SPATIAL</code></th>
                <td>N/A</td>
                <td>いいえ</td>
                <td>いいえ</td>
                <td>N/A</td>
                <td>N/A</td>
              </tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="memory-storage-engine-index-characteristics"></a><p class="title"><b>表 13.4 MEMORY ストレージエンジンのインデックス特性</b></p><div class="table-contents"><table summary="Index characteristics of the Memory storage engine."><col style="width: 15%"><col style="width: 10%"><col style="width: 15%"><col style="width: 20%"><col style="width: 20%"><col style="width: 20%"><thead><tr>
                <th scope="col">インデックスクラス</th>
                <th scope="col">インデックスタイプ</th>
                <th scope="col">NULL VALUES を格納</th>
                <th scope="col">複数の NULL 値を許可</th>
                <th scope="col">IS NULL スキャンタイプ</th>
                <th scope="col">IS NOT NULL スキャンタイプ</th>
              </tr></thead><tbody><tr>
                <th scope="row">主キー</th>
                <td><code class="literal">BTREE</code></td>
                <td>いいえ</td>
                <td>いいえ</td>
                <td>N/A</td>
                <td>N/A</td>
              </tr><tr>
                <th scope="row">Unique</th>
                <td><code class="literal">BTREE</code></td>
                <td>はい</td>
                <td>はい</td>
                <td>インデックス</td>
                <td>インデックス</td>
              </tr><tr>
                <th scope="row">鍵</th>
                <td><code class="literal">BTREE</code></td>
                <td>はい</td>
                <td>はい</td>
                <td>インデックス</td>
                <td>インデックス</td>
              </tr><tr>
                <th scope="row">主キー</th>
                <td><code class="literal">HASH</code></td>
                <td>いいえ</td>
                <td>いいえ</td>
                <td>N/A</td>
                <td>N/A</td>
              </tr><tr>
                <th scope="row">Unique</th>
                <td><code class="literal">HASH</code></td>
                <td>はい</td>
                <td>はい</td>
                <td>インデックス</td>
                <td>インデックス</td>
              </tr><tr>
                <th scope="row">鍵</th>
                <td><code class="literal">HASH</code></td>
                <td>はい</td>
                <td>はい</td>
                <td>インデックス</td>
                <td>インデックス</td>
              </tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="ndb-storage-engine-index-characteristics"></a><p class="title"><b>表 13.5 NDB ストレージエンジンのインデックス特性</b></p><div class="table-contents"><table summary="Index characteristics of the NDB storage engine."><col style="width: 15%"><col style="width: 10%"><col style="width: 15%"><col style="width: 20%"><col style="width: 20%"><col style="width: 20%"><thead><tr>
                <th scope="col">インデックスクラス</th>
                <th scope="col">インデックスタイプ</th>
                <th scope="col">NULL VALUES を格納</th>
                <th scope="col">複数の NULL 値を許可</th>
                <th scope="col">IS NULL スキャンタイプ</th>
                <th scope="col">IS NOT NULL スキャンタイプ</th>
              </tr></thead><tbody><tr>
                <th scope="row">主キー</th>
                <td><code class="literal">BTREE</code></td>
                <td>いいえ</td>
                <td>いいえ</td>
                <td>インデックス</td>
                <td>インデックス</td>
              </tr><tr>
                <th scope="row">Unique</th>
                <td><code class="literal">BTREE</code></td>
                <td>はい</td>
                <td>はい</td>
                <td>インデックス</td>
                <td>インデックス</td>
              </tr><tr>
                <th scope="row">鍵</th>
                <td><code class="literal">BTREE</code></td>
                <td>はい</td>
                <td>はい</td>
                <td>インデックス</td>
                <td>インデックス</td>
              </tr><tr>
                <th scope="row">主キー</th>
                <td><code class="literal">HASH</code></td>
                <td>いいえ</td>
                <td>いいえ</td>
                <td>テーブル (ノート 1 を参照)</td>
                <td>テーブル (ノート 1 を参照)</td>
              </tr><tr>
                <th scope="row">Unique</th>
                <td><code class="literal">HASH</code></td>
                <td>はい</td>
                <td>はい</td>
                <td>テーブル (ノート 1 を参照)</td>
                <td>テーブル (ノート 1 を参照)</td>
              </tr><tr>
                <th scope="row">鍵</th>
                <td><code class="literal">HASH</code></td>
                <td>はい</td>
                <td>はい</td>
                <td>テーブル (ノート 1 を参照)</td>
                <td>テーブル (ノート 1 を参照)</td>
              </tr></tbody></table></div></div><br class="table-break"><p>
            テーブルノート:
          </p><p>
            1. <code class="literal">USING HASH</code> では、暗黙的な順序付きインデックスは作成されません。
          </p></li><li class="listitem"><p>
            <code class="literal">WITH PARSER <em class="replaceable"><code>parser_name</code></em></code>
          </p><p>
            このオプションは、<code class="literal">FULLTEXT</code> インデックスとともにのみ使用できます。 これは、全文インデックス設定および検索操作に特殊な処理が必要な場合に、パーサープラグインをインデックスに関連付けます。 <code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> は、フルテキストパーサープラグインをサポートしています。 フルテキストパーサープラグインが関連付けられた <code class="literal">MyISAM</code> テーブルがある場合は、<code class="literal">ALTER TABLE</code> を使用してテーブルを <code class="literal">InnoDB</code> に変換できます。 詳細は、<a class="ulink" href="https://dev.mysql.com/doc/extending-mysql/8.0/en/plugin-types.html#full-text-plugin-type" target="_top">Full-Text Parser Plugins</a> および <a class="ulink" href="https://dev.mysql.com/doc/extending-mysql/8.0/en/writing-full-text-plugins.html" target="_top">Writing Full-Text Parser Plugins</a> を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">COMMENT '<em class="replaceable"><code>string</code></em>'</code>
          </p><p>
            インデックス定義には、最大 1024 文字のオプションのコメントを含めることができます。
          </p><p>
            インデックスページ用の <a class="link" href="innodb-storage-engine.html#index-page-merge-threshold" title="15.8.11 インデックスページのマージしきい値の構成"><code class="literal">MERGE_THRESHOLD</code></a> は、<code class="literal">CREATE INDEX</code> ステートメントの <em class="replaceable"><code>index_option</code></em> <code class="literal">COMMENT</code> 句を使用して個々のインデックスに対して構成できます。 例: 
          </p><pre class="programlisting">CREATE TABLE t1 (id INT);
CREATE INDEX id_index ON t1 (id) COMMENT 'MERGE_THRESHOLD=40';
</pre><p>
            行が削除されたとき、または更新操作によって行が短縮されたときに、インデックスページのページフル率が <code class="literal">MERGE_THRESHOLD</code> 値を下回った場合、<code class="literal">InnoDB</code> はインデックスページを隣接するインデックスページとマージしようとします。 デフォルトの <code class="literal">MERGE_THRESHOLD</code> 値は 50 で、これは以前にハードコードされた値です。 
          </p><p>
            <code class="literal">MERGE_THRESHOLD</code> は、<code class="literal">CREATE TABLE</code> および <code class="literal">ALTER TABLE</code> ステートメントを使用して、インデックスレベルおよびテーブルレベルで定義することもできます。 詳細は、<a class="xref" href="innodb-storage-engine.html#index-page-merge-threshold" title="15.8.11 インデックスページのマージしきい値の構成">セクション15.8.11「インデックスページのマージしきい値の構成」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">VISIBLE</code>, <code class="literal">INVISIBLE</code>
          </p><p>
            インデックスの可視性を指定します。 インデックスはデフォルトで可視化されます。 不可視インデックスはオプティマイザでは使用されません。 インデックスの可視性の指定は、主キー以外のインデックス (明示的または暗黙的) に適用されます。 詳細は、<a class="xref" href="optimization.html#invisible-indexes" title="8.3.12 不可視のインデックス">セクション8.3.12「不可視のインデックス」</a>を参照してください。 
          </p><a class="indexterm" name="idm45827005189280"></a></li><li class="listitem"><p>
            <code class="literal">ENGINE_ATTRIBUTE</code> および <code class="literal">SECONDARY_ENGINE_ATTRIBUTE</code> オプション (MySQL 8.0.21 の時点で使用可能) は、プライマリストレージエンジンおよびセカンダリストレージエンジンのインデックス属性を指定するために使用されます。 オプションは、将来の使用のために予約されています。 
          </p><p>
            許可される値は、有効な <code class="literal">JSON</code> ドキュメントまたは空の文字列 ('') を含む文字列リテラルです。 無効な <code class="literal">JSON</code> が拒否されました。 
          </p><pre class="programlisting">CREATE INDEX i1 ON t1 (c1) ENGINE_ATTRIBUTE='{"<em class="replaceable"><code>key</code></em>":"<em class="replaceable"><code>value</code></em>"}';</pre><p>
            <code class="literal">ENGINE_ATTRIBUTE</code> および <code class="literal">SECONDARY_ENGINE_ATTRIBUTE</code> の値は、エラーなしで繰り返すことができます。 この場合、最後に指定した値が使用されます。 
          </p><p>
            <code class="literal">ENGINE_ATTRIBUTE</code> および <code class="literal">SECONDARY_ENGINE_ATTRIBUTE</code> の値は、サーバーによってチェックされず、テーブルストレージエンジンが変更されたときにもクリアされません。
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="create-index-copying"></a>テーブルのコピーおよびロックのオプション</h4></div></div></div><p>
        <code class="literal">ALGORITHM</code> 句および <code class="literal">LOCK</code> 句を指定して、インデックスの変更中にテーブルの読取りおよび書込みを行うためのテーブルのコピー方法および同時実行性のレベルに影響を与えることができます。 これらには、<code class="literal">ALTER TABLE</code> ステートメントの場合と同じ意味があります。 詳細は、<a class="xref" href="sql-statements.html#alter-table" title="13.1.9 ALTER TABLE ステートメント">セクション13.1.9「ALTER TABLE ステートメント」</a>を参照してください。 
      </p><p>
        NDB Cluster は、標準の MySQL Server で使用されるものと同じ <code class="literal">ALGORITHM=INPLACE</code> 構文を使用したオンライン操作をサポートします。 詳しくは<a class="xref" href="mysql-cluster.html#mysql-cluster-online-operations" title="23.5.11 NDB Cluster での ALTER TABLE を使用したオンライン操作">セクション23.5.11「NDB Cluster での ALTER TABLE を使用したオンライン操作」</a>,をご覧ください。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-logfile-group"></a>13.1.16 CREATE LOGFILE GROUP ステートメント</h3></div></div></div><a class="indexterm" name="idm45827005167824"></a><pre class="programlisting">CREATE LOGFILE GROUP <em class="replaceable"><code>logfile_group</code></em>
    ADD UNDOFILE '<em class="replaceable"><code>undo_file</code></em>'
    [INITIAL_SIZE [=] <em class="replaceable"><code>initial_size</code></em>]
    [UNDO_BUFFER_SIZE [=] <em class="replaceable"><code>undo_buffer_size</code></em>]
    [REDO_BUFFER_SIZE [=] <em class="replaceable"><code>redo_buffer_size</code></em>]
    [NODEGROUP [=] <em class="replaceable"><code>nodegroup_id</code></em>]
    [WAIT]
    [COMMENT [=] '<em class="replaceable"><code>string</code></em>']
    ENGINE [=] <em class="replaceable"><code>engine_name</code></em>
</pre><p>
      このステートメントは、'<em class="replaceable"><code>undo_file</code></em>' という名前の 1 つの <code class="literal">UNDO</code> ファイルを持つ <em class="replaceable"><code>logfile_group</code></em> という名前の新しいログファイルグループを作成します。 <code class="literal">CREATE LOGFILE GROUP</code> ステートメントには、<code class="literal">ADD UNDOFILE</code> 句が 1 つだけ存在します。 ログファイルグループの命名を管理するルールについては、<a class="xref" href="language-structure.html#identifiers" title="9.2 スキーマオブジェクト名">セクション9.2「スキーマオブジェクト名」</a>を参照してください。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        NDB Cluster ディスクデータオブジェクトはすべて同じ名前空間を共有します。 つまり、<span class="emphasis"><em>各ディスクデータオブジェクト</em></span>は (単に、特定の型の各ディスクデータオブジェクトというだけでなく)、一意の名前が付けられている必要があります。 たとえば、テーブルスペースとログファイルグループを同じ名前にしたり、テーブルスペースとデータファイルを同じ名前にしたりすることはできません。 
      </p></div><p>
      NDB Cluster インスタンスごとに一度に 1 つのログファイルグループしか存在できません。
    </p><p>
      オプションの <code class="literal">INITIAL_SIZE</code> パラメータは、<code class="literal">UNDO</code> ファイルの初期サイズを設定します。指定されていない場合は、デフォルトで <code class="literal">128M</code> (128M バイト) になります。 オプションの <code class="literal">UNDO_BUFFER_SIZE</code> パラメータは、ログファイルグループの <code class="literal">UNDO</code> バッファーで使用されるサイズを設定します。<code class="literal">UNDO_BUFFER_SIZE</code> のデフォルト値は <code class="literal">8M</code> (8M バイト) です。この値が、使用可能なシステムメモリーの量を超えることはできません。 これらのパラメータは、どちらもバイト単位で指定されます。 オプションで、これらのいずれかまたは両方の後に、<code class="filename">my.cnf</code> で使用されるものと同様に、大きさの順に 1 文字の略称を付けることができます。 一般に、これは <code class="literal">M</code> (M バイト) または <code class="literal">G</code> (G バイト) のどちらかの文字です。 
    </p><p>
      <code class="literal">UNDO_BUFFER_SIZE</code> に使用されるメモリーは、サイズが <code class="literal">SharedGlobalMemory</code> データノード構成パラメータの値によって決定されるグローバルプールから取得されます。 これには、<code class="literal">InitialLogFileGroup</code> データノード構成パラメータの設定により、このオプションに暗黙的に指定されるデフォルト値もすべて含まれます。 
    </p><p>
      <code class="literal">UNDO_BUFFER_SIZE</code> に許可される最大値は 629145600 (600M バイト) です。
    </p><p>
      32 ビットシステム上では、<code class="literal">INITIAL_SIZE</code> のサポートされる最大値は 4294967296 (4G バイト) です。 (Bug #29186) 
    </p><p>
      <code class="literal">INITIAL_SIZE</code> の許可される最小値は 1048576 (1M バイト) です。
    </p><p>
      <code class="literal">ENGINE</code> オプションは、このログファイルグループによって使用されるストレージエンジンを決定します。ここで、<em class="replaceable"><code>engine_name</code></em> はそのストレージエンジンの名前です。 MySQL 8.0 では、これは <code class="literal">NDB</code> (または <code class="literal">NDBCLUSTER</code>) である必要があります。 <code class="literal">ENGINE</code> が設定されていない場合、MySQL は、<code class="literal">default_storage_engine</code> サーバーシステム変数 (以前の <code class="literal">storage_engine</code>) で指定されたエンジンを使用しようとします。 いずれにしても、エンジンが <code class="literal">NDB</code> または <code class="literal">NDBCLUSTER</code> として指定されていない場合、<code class="literal">CREATE LOGFILE GROUP</code> ステートメントは成功したように見えますが、次に示すように、実際にはログファイルグループの作成に失敗します。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE LOGFILE GROUP lg1</code></strong>
    -&gt;     <strong class="userinput"><code>ADD UNDOFILE 'undo.dat' INITIAL_SIZE = 10M;</code></strong>
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+-------+------+------------------------------------------------------------------------------------------------+
| Level | Code | Message                                                                                        |
+-------+------+------------------------------------------------------------------------------------------------+
| Error | 1478 | <span class="errortext">Table storage engine 'InnoDB' does not support the create option 'TABLESPACE or LOGFILE GROUP'</span> |
+-------+------+------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>DROP LOGFILE GROUP lg1 ENGINE = NDB;</code></strong>
<span class="errortext">ERROR 1529 (HY000): Failed to drop LOGFILE GROUP</span>

mysql&gt; <strong class="userinput"><code>CREATE LOGFILE GROUP lg1</code></strong>
    -&gt;     <strong class="userinput"><code>ADD UNDOFILE 'undo.dat' INITIAL_SIZE = 10M</code></strong>
    -&gt;     <strong class="userinput"><code>ENGINE = NDB;</code></strong>
Query OK, 0 rows affected (2.97 sec)
</pre><p>
      <code class="literal">NDB</code> 以外のストレージエンジンに名前が付けられているが、成功したように見える場合、<code class="literal">CREATE LOGFILE GROUP</code> ステートメントは実際にはエラーを返しません。これは NDB Cluster の将来のリリースで対処することを希望している既知の問題です。
    </p><p>
      <em class="replaceable"><code>REDO_BUFFER_SIZE</code></em>、<code class="literal">NODEGROUP</code>、<code class="literal">WAIT</code>、および <code class="literal">COMMENT</code> は解析されますが、無視されるため、MySQL 8.0 では何の効果もありません。 これらのオプションは、将来の拡張のために用意されています。 
    </p><p>
      <code class="literal">ENGINE [=] NDB</code> とともに使用された場合は、ログファイルグループとそれに関連付けられた <code class="literal">UNDO</code> ログファイルが各クラスタデータノード上に作成されます。 <code class="literal">INFORMATION_SCHEMA.FILES</code> テーブルをクエリーすることによって、<code class="literal">UNDO</code> ファイルが作成されたことを確認したり、それらに関する情報を取得したりできます。 例: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT LOGFILE_GROUP_NAME, LOGFILE_GROUP_NUMBER, EXTRA</code></strong>
    -&gt; <strong class="userinput"><code>FROM INFORMATION_SCHEMA.FILES</code></strong>
    -&gt; <strong class="userinput"><code>WHERE FILE_NAME = 'undo_10.dat';</code></strong>
+--------------------+----------------------+----------------+
| LOGFILE_GROUP_NAME | LOGFILE_GROUP_NUMBER | EXTRA          |
+--------------------+----------------------+----------------+
| lg_3               |                   11 | CLUSTER_NODE=3 |
| lg_3               |                   11 | CLUSTER_NODE=4 |
+--------------------+----------------------+----------------+
2 rows in set (0.06 sec)
</pre><p>
      <code class="literal">CREATE LOGFILE GROUP</code> は NDB Cluster のディスクデータストレージでのみ役立ちます。 <a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data" title="23.5.10 NDB Cluster ディスクデータテーブル">セクション23.5.10「NDB Cluster ディスクデータテーブル」</a>を参照してください。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-procedure"></a>13.1.17 CREATE PROCEDURE ステートメントおよび CREATE FUNCTION ステートメント</h3></div></div></div><a class="indexterm" name="idm45827005099248"></a><a class="indexterm" name="idm45827005097936"></a><pre class="programlisting">CREATE
    [DEFINER = <em class="replaceable"><code>user</code></em>]
    PROCEDURE <em class="replaceable"><code>sp_name</code></em> ([<em class="replaceable"><code>proc_parameter</code></em>[,...]])
    [<em class="replaceable"><code>characteristic</code></em> ...] <em class="replaceable"><code>routine_body</code></em>

CREATE
    [DEFINER = <em class="replaceable"><code>user</code></em>]
    FUNCTION <em class="replaceable"><code>sp_name</code></em> ([<em class="replaceable"><code>func_parameter</code></em>[,...]])
    RETURNS <em class="replaceable"><code>type</code></em>
    [<em class="replaceable"><code>characteristic</code></em> ...] <em class="replaceable"><code>routine_body</code></em>

<em class="replaceable"><code>proc_parameter</code></em>:
    [ IN | OUT | INOUT ] <em class="replaceable"><code>param_name</code></em> <em class="replaceable"><code>type</code></em>

<em class="replaceable"><code>func_parameter</code></em>:
    <em class="replaceable"><code>param_name</code></em> <em class="replaceable"><code>type</code></em>

<em class="replaceable"><code>type</code></em>:
    <em class="replaceable"><code>Any valid MySQL data type</code></em>

<em class="replaceable"><code>characteristic</code></em>: {
    COMMENT '<em class="replaceable"><code>string</code></em>'
  | LANGUAGE SQL
  | [NOT] DETERMINISTIC
  | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
  | SQL SECURITY { DEFINER | INVOKER }
}

<em class="replaceable"><code>routine_body</code></em>:
    <em class="replaceable"><code>Valid SQL routine statement</code></em>
</pre><p>
      これらのステートメントは、ストアドルーチン (ストアドプロシージャーまたはストアドファンクション) の作成に使用されます。 つまり、指定されたルーチンがサーバーに認識されます。 デフォルトでは、ストアドルーチンはデフォルトのデータベースに関連付けられます。 ルーチンを明示的に特定のデータベースに関連付けるには、そのルーチンの作成時に、その名前を <em class="replaceable"><code>db_name.sp_name</code></em> として指定します。 
    </p><p>
      <code class="literal">CREATE FUNCTION</code> ステートメントはまた、UDF (ユーザー定義関数) をサポートするために MySQL でも使用されます。 <a class="xref" href="sql-statements.html#create-function-loadable" title="13.7.4.1 ユーザー定義関数用の CREATE FUNCTION ステートメント">セクション13.7.4.1「ユーザー定義関数用の CREATE FUNCTION ステートメント」</a>を参照してください。 UDF は、外部のストアドファンクションと見なすことができます。 ストアドファンクションは、その名前空間を UDF と共有します。 各種の関数への参照をサーバーが解釈する方法を記述したルールについては、<a class="xref" href="language-structure.html#function-resolution" title="9.2.5 関数名の構文解析と解決">セクション9.2.5「関数名の構文解析と解決」</a>を参照してください。 
    </p><p>
      ストアドプロシージャーを呼び出すには、<code class="literal">CALL</code> ステートメントを使用します (<a class="xref" href="sql-statements.html#call" title="13.2.1 CALL ステートメント">セクション13.2.1「CALL ステートメント」</a>を参照してください)。 ストアドファンクションを呼び出すには、式でその関数を参照します。 その関数は、式の評価中に値を返します。 
    </p><p>
      <code class="literal">CREATE PROCEDURE</code> および <code class="literal">CREATE FUNCTION</code> には、<code class="literal">CREATE ROUTINE</code> 権限が必要です。 <code class="literal">DEFINER</code> 句が存在する場合、<a class="xref" href="stored-objects.html#stored-objects-security" title="25.6 ストアドオブジェクトのアクセス制御">セクション25.6「ストアドオブジェクトのアクセス制御」</a> で説明されているように、必要な権限は <em class="replaceable"><code>user</code></em> の値によって異なります。 バイナリロギングが有効になっている場合は、<a class="xref" href="stored-objects.html#stored-programs-logging" title="25.7 ストアドプログラムバイナリロギング">セクション25.7「ストアドプログラムバイナリロギング」</a> で説明されているように、<code class="literal">CREATE FUNCTION</code> に <code class="literal">SUPER</code> 権限が必要になることがあります。 
    </p><p>
      デフォルトでは、MySQL は、ルーチン作成者に <code class="literal">ALTER ROUTINE</code> および <code class="literal">EXECUTE</code> 権限を自動的に付与します。 この動作は、<code class="literal">automatic_sp_privileges</code> システム変数を無効にすることによって変更できます。 <a class="xref" href="stored-objects.html#stored-routines-privileges" title="25.2.2 ストアドルーチンと MySQL 権限">セクション25.2.2「ストアドルーチンと MySQL 権限」</a>を参照してください。 
    </p><p>
      <code class="literal">DEFINER</code> および <code class="literal">SQL SECURITY</code> 句は、このセクションのあとの方で説明されているように、ルーチンの実行時にアクセス権限を確認するときに使用されるセキュリティーコンテキストを指定します。
    </p><p>
      ルーチン名が組み込みの SQL 関数の名前と同じである場合は、そのルーチンを定義するか、またはあとで呼び出すときに名前とそれに続く括弧の間にスペースを使用しないかぎり、構文エラーが発生します。 このため、ユーザー独自のストアドルーチンに既存の SQL 関数の名前を使用することは避けてください。 
    </p><p>
      <code class="literal">IGNORE_SPACE</code> SQL モードは、ストアドルーチンではなく、組み込み関数に適用されます。 ストアドルーチン名のあとのスペースは、<code class="literal">IGNORE_SPACE</code> が有効になっているかどうかには関係なく、常に許可されます。 
    </p><p>
      括弧で囲まれたパラメータリストは、常に存在する必要があります。 パラメータが存在しない場合は、<code class="literal">()</code> の空のパラメータリストを使用するようにしてください。 パラメータ名では大文字と小文字は区別されません。 
    </p><p>
      各パラメータは、デフォルトでは <code class="literal">IN</code> パラメータです。 それ以外のパラメータを指定するには、パラメータ名の前にキーワード <code class="literal">OUT</code> または <code class="literal">INOUT</code> を使用します。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">IN</code>、<code class="literal">OUT</code>、または <code class="literal">INOUT</code> としてのパラメータの指定は、<code class="literal">PROCEDURE</code> に対してのみ有効です。 <code class="literal">FUNCTION</code> の場合、パラメータは常に <code class="literal">IN</code> パラメータと見なされます。 
      </p></div><p>
      <code class="literal">IN</code> パラメータは、プロシージャーへの値を渡します。 プロシージャーはその値を変更する可能性がありますが、そのプロシージャーから戻ったとき、その変更は呼び出し元に表示されません。 <code class="literal">OUT</code> パラメータは、プロシージャーから呼び出し元に値を渡します。 その初期値はプロシージャー内では <code class="literal">NULL</code> であり、そのプロシージャーから戻ったとき、その値は呼び出し元に表示されます。 <code class="literal">INOUT</code> パラメータは呼び出し元によって初期化され、プロシージャーで変更できます。そのプロシージャーから戻ったとき、プロシージャーによって行われた変更はすべて呼び出し元に表示されます。 
    </p><p>
      <code class="literal">OUT</code> または <code class="literal">INOUT</code> パラメータごとに、プロシージャーを呼び出す <code class="literal">CALL</code> ステートメントでユーザー定義変数を渡して、プロシージャーから戻ったときにその値を取得できるようにします。 別のストアドプロシージャまたはストアドファンクション内からプロシージャをコールする場合は、ルーチンパラメータまたはローカルルーチン変数を <code class="literal">OUT</code> または <code class="literal">INOUT</code> パラメータとして渡すこともできます。 トリガー内からプロシージャをコールする場合は、<code class="literal">NEW.<em class="replaceable"><code>col_name</code></em></code> を <code class="literal">OUT</code> または <code class="literal">INOUT</code> パラメータとして渡すこともできます。 
    </p><p>
      プロシージャパラメータに対する未処理条件の影響の詳細は、<a class="xref" href="sql-statements.html#conditions-and-parameters" title="13.6.7.8 条件の処理と OUT または INOUT パラメータ">セクション13.6.7.8「条件の処理と OUT または INOUT パラメータ」</a> を参照してください。
    </p><p>
      ルーチン内に準備されたステートメントでルーチンパラメータを参照することはできません。<a class="xref" href="stored-objects.html#stored-program-restrictions" title="25.8 ストアドプログラムの制約">セクション25.8「ストアドプログラムの制約」</a>を参照してください。
    </p><p>
      次の例は、国コードを指定して、<code class="literal">world</code> データベースの <code class="literal">city</code> テーブルに表示されるその国の都市の数をカウントする単純なストアドプロシージャを示しています。 国コードは <code class="literal">IN</code> パラメータを使用して渡され、市区町村数は <code class="literal">OUT</code> パラメータを使用して返されます: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>delimiter //</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE PROCEDURE citycount (IN country CHAR(3), OUT cities INT)</code></strong>
       <strong class="userinput"><code>BEGIN</code></strong>
         <strong class="userinput"><code>SELECT COUNT(*) INTO cities FROM world.city</code></strong>
         <strong class="userinput"><code>WHERE CountryCode = country;</code></strong>
       <strong class="userinput"><code>END//</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>delimiter ;</code></strong>

mysql&gt; <strong class="userinput"><code>CALL citycount('JPN', @cities); -- cities in Japan</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @cities;</code></strong>
+---------+
| @cities |
+---------+
|     248 |
+---------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>CALL citycount('FRA', @cities); -- cities in France</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @cities;</code></strong>
+---------+
| @cities |
+---------+
|      40 |
+---------+
1 row in set (0.00 sec)
</pre><p>
      この例では、プロシージャーの定義中に <span class="command"><strong>mysql</strong></span> クライアントの <code class="literal">delimiter</code> コマンドを使用して、ステートメント区切り文字を <code class="literal">;</code> から <code class="literal">//</code> に変更しています。 これにより、プロシージャー本体で使用される <code class="literal">;</code> 区切り文字を、<span class="command"><strong>mysql</strong></span> 自体が解釈するのではなく、サーバーに渡すようにすることができます。 <a class="xref" href="stored-objects.html#stored-programs-defining" title="25.1 ストアドプログラムの定義">セクション25.1「ストアドプログラムの定義」</a>を参照してください。 
    </p><p>
      <code class="literal">RETURNS</code> 句は、<code class="literal">FUNCTION</code> (これには必須です) に対してのみ指定できます。 これは関数の戻り型を示すものであり、関数本体には <code class="literal">RETURN <em class="replaceable"><code>value</code></em></code> ステートメントが含まれている必要があります。 <code class="literal">RETURN</code> ステートメントが異なる型の値を返した場合、その値は正しい型に強制的に変更されます。 たとえば、ある関数が <code class="literal">RETURNS</code> 句で <code class="literal">ENUM</code> または <code class="literal">SET</code> 値を指定しているが、<code class="literal">RETURN</code> ステートメントが整数を返した場合、その関数から返される値は <code class="literal">SET</code> メンバーのセットの対応する <code class="literal">ENUM</code> メンバーを示す文字列になります。 
    </p><p>
      次の関数例はパラメータを受け取り、SQL 関数を使用して操作を実行したあと、結果を返します。 この場合は、関数定義に内部の <code class="literal">;</code> ステートメント区切り文字が含まれていないため、<code class="literal">delimiter</code> を使用する必要はありません。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE FUNCTION hello (s CHAR(20))</code></strong>
mysql&gt; <strong class="userinput"><code>RETURNS CHAR(50) DETERMINISTIC</code></strong>
       <strong class="userinput"><code>RETURN CONCAT('Hello, ',s,'!');</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT hello('world');</code></strong>
+----------------+
| hello('world') |
+----------------+
| Hello, world!  |
+----------------+
1 row in set (0.00 sec)
</pre><p>
      パラメータ型と関数の戻り型は、任意の有効なデータ型を使用するように宣言できます。 <code class="literal">COLLATE</code> 属性は、<code class="literal">CHARACTER SET</code> 指定の前にある場合に使用できます。 
    </p><p>
      <em class="replaceable"><code>routine_body</code></em> は、有効な SQL ルーチンステートメントで構成されます。 これは <code class="literal">SELECT</code> や <code class="literal">INSERT</code> などの単純なステートメントでも、<code class="literal">BEGIN</code> と <code class="literal">END</code> を使用して記述された複合ステートメントでもかまいません。 複合ステートメントには、宣言、ループ、およびその他の制御構造ステートメントを含めることができます。 これらのステートメントの構文については、<a class="xref" href="sql-statements.html#sql-compound-statements" title="13.6 複合ステートメントの構文">セクション13.6「複合ステートメントの構文」</a>で説明されています。 実際には、本体が単一の <code class="literal">RETURN</code> ステートメントで構成されていないかぎり、ストアドファンクションは複合ステートメントを使用する傾向があります。 
    </p><p>
      MySQL では、ルーチンに <code class="literal">CREATE</code> や <code class="literal">DROP</code> などの DDL ステートメントを含めることが許可されます。 MySQL ではまた、ストアドプロシージャーに <code class="literal">COMMIT</code> などの SQL トランザクションステートメントを含めることも許可されます (ただし、ストアドファンクションには許可されません)。 ストアドファンクションには、明示的または暗黙的なコミットまたはロールバックを実行するステートメントを含めることはできません。 これらのステートメントのサポートは、SQL 標準では必要ありません。SQL 標準では、各 DBMS ベンダーがこれらのステートメントを許可するかどうかを決められると定めています。 
    </p><p>
      結果セットを返すステートメントはストアドプロシージャー内で使用できますが、ストアドファンクション内では使用できません。 この禁止には、<code class="literal">INTO <em class="replaceable"><code>var_list</code></em></code> 句を含まない <code class="literal">SELECT</code> ステートメントや、<code class="literal">SHOW</code>、<code class="literal">EXPLAIN</code>、<code class="literal">CHECK TABLE</code> などのその他のステートメントが含まれます。 結果セットを返すことを関数の定義時に判定できるステートメントの場合は、<code class="literal">Not allowed to return a result set from a function</code> エラーが発生します (<code class="literal">ER_SP_NO_RETSET</code>)。 結果セットを返すことを実行時にしか判定できないステートメントの場合は、<code class="literal">PROCEDURE %s can't return a result set in the given context</code> エラーが発生します (<code class="literal">ER_SP_BADSELECT</code>)。 
    </p><p>
      ストアドルーチン内での <code class="literal">USE</code> ステートメントは許可されていません。 ルーチンが呼び出されると、暗黙的な <code class="literal">USE <em class="replaceable"><code>db_name</code></em></code> が実行されます (また、そのルーチンが終了すると元に戻されます)。 これにより、そのルーチンには実行中、特定のデフォルトデータベースが割り当てられます。 ルーチンのデフォルトデータベース以外のデータベース内のオブジェクトへの参照は、適切なデータベース名で修飾するようにしてください。 
    </p><p>
      ストアドルーチン内では許可されないステートメントの詳細は、<a class="xref" href="stored-objects.html#stored-program-restrictions" title="25.8 ストアドプログラムの制約">セクション25.8「ストアドプログラムの制約」</a>を参照してください。
    </p><p>
      MySQL インタフェースを備える言語で記述されたプログラム内からのストアドプロシージャーの呼び出しについては、<a class="xref" href="sql-statements.html#call" title="13.2.1 CALL ステートメント">セクション13.2.1「CALL ステートメント」</a>を参照してください。
    </p><p>
      MySQL は、ルーチンが作成または変更されたときの有効な <code class="literal">sql_mode</code> システム変数の設定を格納し、<span class="emphasis"><em>ルーチンが実行を開始したときの現在のサーバー SQL モードには関係なく</em></span>、常にそのルーチンを強制的にこの設定で実行します。
    </p><p>
      呼び出し元の SQL モードからそのルーチンの SQL モードへの切り替えは、引数を評価し、結果として得られる値をルーチンパラメータに割り当てたあとに実行されます。 あるルーチンを厳密な SQL モードで定義したが、その呼び出しを非厳密モードで行なった場合は、引数のルーチンパラメータへの割り当てが厳密モードで実行されません。 ルーチンに渡される式を厳密な SQL モードで割り当てる必要がある場合は、そのルーチンを厳密モードが有効な状態で呼び出すようにしてください。 
    </p><p>
      <code class="literal">COMMENT</code> 特性は MySQL 拡張であり、そのストアドルーチンの説明のために使用できます。 この情報は、<code class="literal">SHOW CREATE PROCEDURE</code> および <code class="literal">SHOW CREATE FUNCTION</code> ステートメントによって表示されます。 
    </p><p>
      <code class="literal">LANGUAGE</code> 特性は、そのルーチンが記述されている言語を示します。 サーバーはこの特性を無視します。SQL ルーチンのみがサポートされています。 
    </p><p>
      ルーチンは、同じ入力パラメータに対して常に同じ結果を生成する場合は<span class="quote">「<span class="quote">決定的</span>」</span>と見なされ、それ以外の場合は<span class="quote">「<span class="quote">非決定的</span>」</span>と見なされます。 ルーチン定義で <code class="literal">DETERMINISTIC</code> と <code class="literal">NOT DETERMINISTIC</code> のどちらも指定されていない場合、デフォルトは <code class="literal">NOT DETERMINISTIC</code> になります。 関数が決定的であることを宣言するには、明示的に <code class="literal">DETERMINISTIC</code> を指定する必要があります。 
    </p><p>
      ルーチンの性質の評価は、作成者の<span class="quote">「<span class="quote">誠実さ</span>」</span>に基づいています。MySQL は、<code class="literal">DETERMINISTIC</code> と宣言されたルーチンに非決定的な結果を生成するステートメントが含まれていないかどうかをチェックしません。 ただし、ルーチンの誤った宣言は、その結果やパフォーマンスに影響を与える可能性があります。 非決定的なルーチンを <code class="literal">DETERMINISTIC</code> として宣言すると、オプティマイザが正しくない実行計画を選択するために、予期しない結果を招くことがあります。 決定的なルーチンを <code class="literal">NONDETERMINISTIC</code> として宣言すると、使用可能な最適化が使用されなくなるために、パフォーマンスが低下することがあります。 
    </p><p>
      バイナリロギングが有効になっている場合、<code class="literal">DETERMINISTIC</code> 特性は、MySQL がどのルーチン定義を受け入れるかに影響を与えます。 <a class="xref" href="stored-objects.html#stored-programs-logging" title="25.7 ストアドプログラムバイナリロギング">セクション25.7「ストアドプログラムバイナリロギング」</a>を参照してください。 
    </p><p>
      <code class="literal">NOW()</code> 関数 (または、そのシノニム) あるいは <code class="literal">RAND()</code> を含むルーチンは非決定的ですが、引き続きレプリケーションに対して安全である可能性があります。 <code class="literal">NOW()</code> の場合、バイナリログにはタイムスタンプが含まれ、正しくレプリケートされます。 <code class="literal">RAND()</code> もまた、ルーチンの実行中に 1 回だけ呼び出されるかぎり、正しくレプリケートされます。 (ルーチン実行タイムスタンプおよび乱数シードは、ソースとレプリカで同一の暗黙的な入力とみなすことができます。) 
    </p><p>
      いくつかの特性によって、ルーチンによるデータ使用の性質に関する情報が提供されます。 MySQL では、これらの特性はアドバイザリにすぎません。 サーバーはこれらを使用して、ルーチンの実行を許可するステートメントの種類を制約しません。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">CONTAINS SQL</code> は、そのルーチンに、データの読み取りや書き込みを行うステートメントが含まれていないことを示します。 これは、これらのどの特性も明示的に指定されていない場合のデフォルトです。 このようなステートメントの例として、実行されてもデータの読み取りや書き込みを行わない <code class="literal">SET @x = 1</code> または <code class="literal">DO RELEASE_LOCK('abc')</code> があります。 
        </p></li><li class="listitem"><p>
          <code class="literal">NO SQL</code> は、そのルーチンに SQL ステートメントが含まれていないことを示します。
        </p></li><li class="listitem"><p>
          <code class="literal">READS SQL DATA</code> は、そのルーチンに、データを読み取るステートメント (<code class="literal">SELECT</code> など) が含まれているが、データを書き込むステートメントは含まれていないことを示します。
        </p></li><li class="listitem"><p>
          <code class="literal">MODIFIES SQL DATA</code> は、そのルーチンに、データを書き込む可能性のあるステートメント (<code class="literal">INSERT</code> や <code class="literal">DELETE</code> など) が含まれていることを示します。
        </p></li></ul></div><p>
      <code class="literal">SQL SECURITY</code> 特性は、セキュリティーコンテキストを指定する <code class="literal">DEFINER</code> または <code class="literal">INVOKER</code> のどちらかです。これは、そのルーチンがルーチンの <code class="literal">DEFINER</code> 句で指定されたアカウント、またはそのルーチンを呼び出すユーザーのどちらの権限を使用して実行されるかを示します。 このアカウントには、そのルーチンが関連付けられているデータベースにアクセスするためのアクセス権が必要です。 デフォルト値は <code class="literal">DEFINER</code> です。 そのルーチンを呼び出すユーザーには、それに対する <code class="literal">EXECUTE</code> 権限が必要です。また、そのルーチンが定義者のセキュリティーコンテキストで実行される場合は、<code class="literal">DEFINER</code> アカウントにもその権限が必要です。 
    </p><p>
      <code class="literal">DEFINER</code> 句は、<code class="literal">SQL SECURITY DEFINER</code> 特性を持つルーチンのルーチン実行時にアクセス権限を確認するときに使用される MySQL アカウントを指定します。
    </p><p>
      <code class="literal">DEFINER</code> 句が存在する場合、<em class="replaceable"><code>user</code></em> 値は<code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'<em class="replaceable"><code>host_name</code></em>'</code>、<code class="literal">CURRENT_USER</code> または <code class="literal">CURRENT_USER()</code> として指定された MySQL アカウントである必要があります。 許可される <em class="replaceable"><code>user</code></em> 値は、<a class="xref" href="stored-objects.html#stored-objects-security" title="25.6 ストアドオブジェクトのアクセス制御">セクション25.6「ストアドオブジェクトのアクセス制御」</a> で説明されているように、保持する権限によって異なります。 ストアドルーチンのセキュリティーに関する追加情報については、そのセクションも参照してください。 
    </p><p>
      <code class="literal">DEFINER</code> 句を省略すると、デフォルトの定義者は <code class="literal">CREATE PROCEDURE</code> または <code class="literal">CREATE FUNCTION</code> ステートメントを実行するユーザーになります。 これは、明示的に <code class="literal">DEFINER = CURRENT_USER</code> を指定するのと同じです。 
    </p><p>
      <code class="literal">SQL SECURITY DEFINER</code> 特性で定義されたストアドルーチンの本体内で、<code class="literal">CURRENT_USER</code> 関数はルーチン <code class="literal">DEFINER</code> 値を返します。 ストアドルーチン内のユーザー監査については、<a class="xref" href="security.html#account-activity-auditing" title="6.2.22 SQL ベースのアカウントアクティビティ監査">セクション6.2.22「SQL ベースのアカウントアクティビティ監査」</a>を参照してください。 
    </p><p>
      <code class="literal">mysql.user</code> システムテーブルにリストされている MySQL アカウントの数を表示する次の手順について考えてみます:
    </p><pre class="programlisting">CREATE DEFINER = 'admin'@'localhost' PROCEDURE account_count()
BEGIN
  SELECT 'Number of accounts:', COUNT(*) FROM mysql.user;
END;
</pre><p>
      このプロシージャーには、それがどのユーザーによって定義されている場合でも、<code class="literal">'admin'@'localhost'</code> の <code class="literal">DEFINER</code> アカウントが割り当てられます。 また、それがどのユーザーから呼び出された場合でも、そのアカウントの権限で実行されます (デフォルトのセキュリティー特性は <code class="literal">DEFINER</code> であるため)。 このプロシージャーは、呼び出し元にそれに対する <code class="literal">EXECUTE</code> 権限があり、かつ <code class="literal">'admin'@'localhost'</code> に <code class="literal">mysql.user</code> テーブルに対する <code class="literal">SELECT</code> 権限があるかどうかに応じて成功または失敗します。 
    </p><p>
      ここで、このプロシージャーが <code class="literal">SQL SECURITY INVOKER</code> 特性を使用して定義されているとします。
    </p><pre class="programlisting">CREATE DEFINER = 'admin'@'localhost' PROCEDURE account_count()
SQL SECURITY INVOKER
BEGIN
  SELECT 'Number of accounts:', COUNT(*) FROM mysql.user;
END;
</pre><p>
      このプロシージャーは、依然として <code class="literal">'admin'@'localhost'</code> の <code class="literal">DEFINER</code> を持っていますが、この場合は呼び出し元ユーザーの権限で実行されます。 そのため、このプロシージャーは、呼び出し元にそれに対する <code class="literal">EXECUTE</code> 権限と、<code class="literal">mysql.user</code> テーブルに対する <code class="literal">SELECT</code> 権限があるかどうかに応じて成功または失敗します。 
    </p><p>
      サーバーは、ルーチンパラメータ、<code class="literal">DECLARE</code> を使用して作成されたローカルルーチン変数、または関数の戻り値のデータ型を次のように処理します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          データ型の不一致やオーバーフローがないかどうか割り当てがチェックされます。 変換やオーバーフローの問題によって警告が発生するか、または厳密な SQL モードではエラーが発生します。 
        </p></li><li class="listitem"><p>
          スカラー値のみを割り当てることができます。 たとえば、<code class="literal">SET x = (SELECT 1, 2)</code> などのステートメントは無効です。 
        </p></li><li class="listitem"><p>
          文字データ型では、<code class="literal">CHARACTER SET</code> が宣言に含まれている場合、指定された文字セットとそのデフォルトの照合順序が使用されます。 <code class="literal">COLLATE</code> 属性も存在する場合は、デフォルトの照合順序ではなく、その照合順序が使用されます。 
        </p><p>
          <code class="literal">CHARACTER SET</code> および <code class="literal">COLLATE</code> が存在しない場合は、ルーチンの作成時に有効なデータベース文字セットおよび照合順序が使用されます。 サーバーでデータベース文字セットおよび照合順序を使用しないようにするには、文字データパラメータに明示的な <code class="literal">CHARACTER SET</code> および <code class="literal">COLLATE</code> 属性を指定します。 
        </p><p>
          データベースのデフォルトの文字セットまたは照合順序を変更する場合は、新しいデータベースのデフォルトを使用するストアドルーチンを削除して再作成する必要があります。
        </p><p>
          データベース文字セットおよび照合順序は、<code class="literal">character_set_database</code> および <code class="literal">collation_database</code> システム変数の値で指定されます。 詳細は、<a class="xref" href="charset.html#charset-database" title="10.3.3 データベース文字セットおよび照合順序">セクション10.3.3「データベース文字セットおよび照合順序」</a>を参照してください。 
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-server"></a>13.1.18 CREATE SERVER ステートメント</h3></div></div></div><a class="indexterm" name="idm45827004864912"></a><pre class="programlisting">CREATE SERVER <em class="replaceable"><code>server_name</code></em>
    FOREIGN DATA WRAPPER <em class="replaceable"><code>wrapper_name</code></em>
    OPTIONS (<em class="replaceable"><code>option</code></em> [, <em class="replaceable"><code>option</code></em>] ...)

<em class="replaceable"><code>option</code></em>: {
    HOST <em class="replaceable"><code>character-literal</code></em>
  | DATABASE <em class="replaceable"><code>character-literal</code></em>
  | USER <em class="replaceable"><code>character-literal</code></em>
  | PASSWORD <em class="replaceable"><code>character-literal</code></em>
  | SOCKET <em class="replaceable"><code>character-literal</code></em>
  | OWNER <em class="replaceable"><code>character-literal</code></em>
  | PORT <em class="replaceable"><code>numeric-literal</code></em>
}
</pre><p>
      このステートメントは、<code class="literal">FEDERATED</code> ストレージエンジンで使用するためのサーバーの定義を作成します。 <code class="literal">CREATE SERVER</code> ステートメントは、<code class="literal">mysql</code> データベース内の <code class="literal">servers</code> テーブルに新しい行を作成します。 このステートメントには、<code class="literal">SUPER</code> 権限が必要です。 
    </p><p>
      <code class="literal"><em class="replaceable"><code>server_name</code></em></code> は、そのサーバーへの一意の参照にしてください。 サーバー定義はサーバーのスコープ内でグローバルであり、サーバー定義を特定のデータベースに対して修飾することはできません。<code class="literal"><em class="replaceable"><code>server_name</code></em></code> の最大長は 64 文字 (64 文字を超える名前は暗黙的に切り捨てられます) で、大/小文字は区別されません。 この名前は、引用符で囲まれた文字列として指定できます。 
    </p><p>
      <code class="literal"><em class="replaceable"><code>wrapper_name</code></em></code> は識別子であり、一重引用符で囲むことができます。
    </p><p>
      各 <code class="literal"><em class="replaceable"><code>option</code></em></code> について、文字リテラルまたは数値リテラルのどちらかを指定する必要があります。 文字リテラルは UTF-8 であり、64 文字の最大長をサポートし、デフォルトではブランク (空) の文字列になります。 文字列リテラルは、暗黙のうちに 64 文字に切り捨てられます。 数値リテラルは 0 から 9999 までの数字である必要があり、デフォルト値は 0 です。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">OWNER</code> オプションは現在、適用されず、作成されるサーバー接続の所有権または操作には影響を与えません。
      </p></div><p>
      <code class="literal">CREATE SERVER</code> ステートメントは、<code class="literal">mysql.servers</code> テーブル内にエントリを作成します。これは、あとで <code class="literal">FEDERATED</code> テーブルを作成するときに <code class="literal">CREATE TABLE</code> ステートメントで使用できます。 指定したオプションは、<code class="literal">mysql.servers</code> テーブルのカラムの移入に使用されます。 テーブルカラムは、<code class="literal">Server_name</code>、<code class="literal">Host</code>、<code class="literal">Db</code>、<code class="literal">Username</code>、<code class="literal">Password</code>、<code class="literal">Port</code>、および <code class="literal">Socket</code> です。 
    </p><p>
      例:
    </p><pre class="programlisting">CREATE SERVER s
FOREIGN DATA WRAPPER mysql
OPTIONS (USER 'Remote', HOST '198.51.100.106', DATABASE 'test');
</pre><p>
      サーバーへの接続を確立するために必要なすべてのオプションを指定する必要があります。 ユーザー名、ホスト名、およびデータベース名は必須です。 パスワードなどの、その他のオプションも必要になる可能性があります。 
    </p><p>
      このテーブルに格納されたデータは、<code class="literal">FEDERATED</code> テーブルへの接続を作成するときに使用できます。
    </p><pre class="programlisting">CREATE TABLE t (s1 INT) ENGINE=FEDERATED CONNECTION='s';</pre><p>
      詳細は、<a class="xref" href="storage-engines.html#federated-storage-engine" title="16.8 FEDERATED ストレージエンジン">セクション16.8「FEDERATED ストレージエンジン」</a>を参照してください。
    </p><p>
      <code class="literal">CREATE SERVER</code> によって暗黙的なコミットが発生します。 <a class="xref" href="sql-statements.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。 
    </p><p>
      使用されているロギング形式に関係なく、<code class="literal">CREATE SERVER</code> はバイナリログに書き込まれません。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-spatial-reference-system"></a>13.1.19 CREATE SPATIAL REFERENCE SYSTEM ステートメント</h3></div></div></div><a class="indexterm" name="idm45827004819696"></a><pre class="programlisting">CREATE OR REPLACE SPATIAL REFERENCE SYSTEM
    <em class="replaceable"><code>srid</code></em> <em class="replaceable"><code>srs_attribute</code></em> ...

CREATE SPATIAL REFERENCE SYSTEM
    [IF NOT EXISTS]
    <em class="replaceable"><code>srid</code></em> <em class="replaceable"><code>srs_attribute</code></em> ...

<em class="replaceable"><code>srs_attribute</code></em>: {
    NAME '<em class="replaceable"><code>srs_name</code></em>'
  | DEFINITION '<em class="replaceable"><code>definition</code></em>'
  | ORGANIZATION '<em class="replaceable"><code>org_name</code></em>' IDENTIFIED BY <em class="replaceable"><code>org_id</code></em>
  | DESCRIPTION '<em class="replaceable"><code>description</code></em>'
}

<em class="replaceable"><code>srid</code></em>, <em class="replaceable"><code>org_id</code></em>: <em class="replaceable"><code>32-bit unsigned integer</code></em>
</pre><p>
      このステートメントは、<a class="link" href="data-types.html#spatial-reference-systems" title="11.4.5 空間参照システムのサポート">spatial reference system</a> (SRS) 定義を作成し、データディクショナリに格納します。 <code class="literal">SUPER</code> 権限が必要です。 結果のデータディクショナリエントリは、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">ST_SPATIAL_REFERENCE_SYSTEMS</code> テーブルを使用して検査できます。 
    </p><p>
      SRID 値は一意である必要があるため、<code class="literal">OR REPLACE</code> も <code class="literal">IF NOT EXISTS</code> も指定されていない場合、指定された <em class="replaceable"><code>srid</code></em> 値を持つ SRS 定義がすでに存在するとエラーが発生します。
    </p><p>
      <code class="literal">CREATE OR REPLACE</code> 構文では、SRID 値が既存のテーブルのカラムで使用されていないかぎり、同じ SRID 値を持つ既存の SRS 定義が置換されます。 その場合、エラーが発生します。 例: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE OR REPLACE SPATIAL REFERENCE SYSTEM 4326 ...;</code></strong>
ERROR 3716 (SR005): Can't modify SRID 4326. There is at
least one column depending on it.
</pre><p>
      SRID を使用するカラムを識別するには、次のクエリーを使用し、4326 を作成しようとしている定義の SRID に置き換えます:
    </p><pre class="programlisting">SELECT * FROM INFORMATION_SCHEMA.ST_GEOMETRY_COLUMNS WHERE SRS_ID=4326;
</pre><p>
      <code class="literal">CREATE ... IF NOT EXISTS</code> 構文では、SRID 値が同じ既存の SRS 定義は無視され、警告が発生します。
    </p><p>
      SRID 値は 32 ビットの符号なし整数の範囲内である必要がありますが、次の制限があります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          SRID 0 は有効な SRID ですが、<code class="literal">CREATE SPATIAL REFERENCE SYSTEM</code> では使用できません。
        </p></li><li class="listitem"><p>
          値が予約された SRID 範囲内にある場合は、警告が発生します。 予約済の範囲は、[0, 32767] (EPSG で予約済)、[60,000,000、69,999,999] (EPSG で予約済) および[2,000,000,000、2,147,483,647] (MySQL で予約済) です。 EPSG は<a class="ulink" href="http://epsg.org" target="_top">「欧州石油調査グループ」</a>を表します。 
        </p></li><li class="listitem"><p>
          ユーザーは、予約された範囲内に SRID を持つ SRS を作成しないでください。 これにより、MySQL に配布された将来の SRS 定義と競合する SRID のリスクが実行され、その結果、新しいシステム提供の SRS が MySQL のアップグレード用にインストールされないか、ユーザー定義の SRS が上書きされます。 
        </p></li></ul></div><p>
      ステートメントの属性は、次の条件を満たす必要があります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          属性は任意の順序で指定できますが、複数回指定することはできません。
        </p></li><li class="listitem"><p>
          <code class="literal">NAME</code> および <code class="literal">DEFINITION</code> 属性は必須です。
        </p></li><li class="listitem"><p>
          <code class="literal">NAME</code> <em class="replaceable"><code>srs_name</code></em> 属性値は一意である必要があります。 <code class="literal">ORGANIZATION</code> <em class="replaceable"><code>org_name</code></em> と <em class="replaceable"><code>org_id</code></em> の属性値の組合せは一意である必要があります。 
        </p></li><li class="listitem"><p>
          <code class="literal">NAME</code> <em class="replaceable"><code>srs_name</code></em> 属性値および <code class="literal">ORGANIZATION</code> <em class="replaceable"><code>org_name</code></em> 属性値を空にしたり、先頭または末尾を空白にすることはできません。
        </p></li><li class="listitem"><p>
          属性指定の文字列値に、改行を含む制御文字を含めることはできません。
        </p></li><li class="listitem"><p>
          次のテーブルに、文字列属性値の最大長を示します。
        </p><div class="table"><a name="spatial-reference-system-attribute-length"></a><p class="title"><b>表 13.6 CREATE SPATIAL REFERENCE SYSTEM 属性長</b></p><div class="table-contents"><table summary="Maximum string attribute lengths for CREATE SPATIAL REFERENCE SYSTEM"><col style="width: 25%"><col style="width: 50%"><thead><tr>
              <th>属性</th>
              <th>最大の長さ (文字)</th>
            </tr></thead><tbody><tr>
              <td><code class="literal">NAME</code></td>
              <td>80</td>
            </tr><tr>
              <td><code class="literal">DEFINITION</code></td>
              <td>4096</td>
            </tr><tr>
              <td><code class="literal">ORGANIZATION</code></td>
              <td>256</td>
            </tr><tr>
              <td><code class="literal">DESCRIPTION</code></td>
              <td>2048</td>
            </tr></tbody></table></div></div><br class="table-break"></li></ul></div><p>
      <code class="literal">CREATE SPATIAL REFERENCE SYSTEM</code> ステートメントの例を次に示します。 読みやすくするために、<code class="literal">DEFINITION</code> 値は複数の行にわたって再フォーマットされます。 (ステートメントを有効にするには、実際に値を単一行に指定する必要があります。) 
    </p><pre class="programlisting">CREATE SPATIAL REFERENCE SYSTEM 4120
NAME 'Greek'
ORGANIZATION 'EPSG' IDENTIFIED BY 4120
DEFINITION
  'GEOGCS["Greek",DATUM["Greek",SPHEROID["Bessel 1841",
  6377397.155,299.1528128,AUTHORITY["EPSG","7004"]],
  AUTHORITY["EPSG","6120"]],PRIMEM["Greenwich",0,
  AUTHORITY["EPSG","8901"]],UNIT["degree",0.017453292519943278,
  AUTHORITY["EPSG","9122"]],AXIS["Lat",NORTH],AXIS["Lon",EAST],
  AUTHORITY["EPSG","4120"]]';
</pre><p>
      SRS 定義の文法は、<em class="citetitle">「OpenGIS 実装仕様: 座標変換サービス」</em>、Revision 1.00、OGC 01-009、2001 年 1 月 12 日、7.2 セクションで定義されている文法に基づきます。 この仕様は、<a class="ulink" href="http://www.opengeospatial.org/standards/ct" target="_top">http://www.opengeospatial.org/standards/ct</a> で入手できます。 
    </p><p>
      MySQL では、次の変更が仕様に組み込まれています:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">&lt;horz cs&gt;</code> の本番ルール (つまり、地理的および予測される SRS) のみが実装されます。
        </p></li><li class="listitem"><p>
          <code class="literal">&lt;parameter&gt;</code> には、オプションの非標準の <code class="literal">&lt;authority&gt;</code> 句があります。 これにより、投影パラメータを名前ではなく権限で認識できます。 
        </p></li><li class="listitem"><p>
          この指定によって、<code class="literal">GEOGCS</code> 空間参照システム定義で <code class="literal">AXIS</code> 句が必須になることはありません。 ただし、<code class="literal">AXIS</code> 句がない場合、MySQL では、定義に緯度 - 経度順または経度 - 緯度順の軸があるかどうかを判断できません。 MySQL では、各 <code class="literal">GEOGCS</code> 定義に 2 つの <code class="literal">AXIS</code> 句を含める必要があるという非標準要件が適用されます。 一方は <code class="literal">NORTH</code> または <code class="literal">SOUTH</code>、もう一方は <code class="literal">EAST</code> または <code class="literal">WEST</code> である必要があります。 <code class="literal">AXIS</code> 句の順序によって、定義に緯度 - 経度順と経度 - 緯度順のどちらの軸があるかが決まります。 
        </p></li><li class="listitem"><p>
          SRS 定義に改行を含めることはできません。
        </p></li></ul></div><p>
      SRS 定義で投影の権限コードが指定されている場合 (推奨)、定義に必須パラメータがないとエラーが発生します。 この場合、エラーメッセージに問題の内容が示されます。 MySQL でサポートされる投影方法および必須パラメータは、<a class="xref" href="sql-statements.html#supported-srs-projections-table" title="表 13.7 サポートされている空間参照システム投影方法">表13.7「サポートされている空間参照システム投影方法」</a> および <a class="xref" href="sql-statements.html#srs-projection-parameters-table" title="表 13.8 空間参照システム予測パラメータ">表13.8「空間参照システム予測パラメータ」</a> に示されています。 
    </p><p>
      MySQL の SRS 定義の記述の詳細は、<a class="ulink" href="https://mysqlserverteam.com/geographic-spatial-reference-systems-in-mysql-8-0/" target="_top">「MySQL 8.0 での地理空間参照システム」</a>および<a class="ulink" href="https://mysqlserverteam.com/projected-spatial-reference-systems-in-mysql-8-0/" target="_top">「MySQL 8.0 での空間参照システムの予測」</a>を参照してください
    </p><p>
      次のテーブルに、MySQL でサポートされる投影方法を示します。 MySQL では不明な投影方法が許可されますが、必須パラメータの定義をチェックすることはできず、空間データを不明な投影との間で変換することもできません。 式を含む各予測の動作の詳細は、<a class="ulink" href="http://www.epsg.org/Portals/0/373-07-2.pdf" target="_top">「EPSG ガイダンスノート 7-2」</a>を参照してください。 
    </p><div class="table"><a name="supported-srs-projections-table"></a><p class="title"><b>表 13.7 サポートされている空間参照システム投影方法</b></p><div class="table-contents"><table summary="Supported spatial reference system projection codes, names, and mandatory EPSG parameters."><col style="width: 10%"><col style="width: 45%"><col style="width: 35%"><thead><tr>
          <th scope="col">EPSG コード</th>
          <th scope="col">見積名</th>
          <th scope="col">必須パラメータ (EPSG コード)</th>
        </tr></thead><tbody><tr>
          <th scope="row">1024</th>
          <td>人気のある視覚化擬似 Mercator</td>
          <td>8801, 8802, 8806, 8807</td>
        </tr><tr>
          <th scope="row">1027</th>
          <td>ランバートアジムタル等地区 (球面)</td>
          <td>8801, 8802, 8806, 8807</td>
        </tr><tr>
          <th scope="row">1028</th>
          <td>均一円柱状</td>
          <td>8823, 8802, 8806, 8807</td>
        </tr><tr>
          <th scope="row">1029</th>
          <th>均一円筒 (球状)</th>
          <th>8823, 8802, 8806, 8807</th>
        </tr><tr>
          <th scope="row">1041</th>
          <th>クロヴァク語 (北方向)</th>
          <th>8811, 8833, 1036, 8818, 8819, 8806, 8807</th>
        </tr><tr>
          <th scope="row">1042</th>
          <th>Krovak 変更済</th>
          <th>8811, 8833, 1036, 8818, 8819, 8806, 8807, 8617, 8618, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035</th>
        </tr><tr>
          <th scope="row">1043</th>
          <th>Krovak Modified (北向き)</th>
          <th>8811, 8833, 1036, 8818, 8819, 8806, 8807, 8617, 8618, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035</th>
        </tr><tr>
          <th scope="row">1051</th>
          <th>Lambert Conic Conformal (2SP ミシガン)</th>
          <th>8821, 8822, 8823, 8824, 8826, 8827, 1038</th>
        </tr><tr>
          <th scope="row">1052</th>
          <th>コロンビア都市</th>
          <th>8801, 8802, 8806, 8807, 1039</th>
        </tr><tr>
          <th scope="row">9801</th>
          <th>Lambert Conic Conformal (1SP)</th>
          <th>8801, 8802, 8805, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9802</th>
          <th>Lambert Conic Conformal (2SP)</th>
          <th>8821, 8822, 8823, 8824, 8826, 8827</th>
        </tr><tr>
          <th scope="row">9803</th>
          <th>Lambert Conic Conformal (2SP ベルギー)</th>
          <th>8821, 8822, 8823, 8824, 8826, 8827</th>
        </tr><tr>
          <th scope="row">9804</th>
          <th>Mercator (バリアント A)</th>
          <th>8801, 8802, 8805, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9805</th>
          <th>Mercator (バリアント B)</th>
          <th>8823, 8802, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9806</th>
          <th>Cassini-Soldner</th>
          <th>8801, 8802, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9807</th>
          <th>Transverse Mercator</th>
          <th>8801, 8802, 8805, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9808</th>
          <th>Transverse Mercator (南向き)</th>
          <th>8801, 8802, 8805, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9809</th>
          <th>液体ステレオグラフィー</th>
          <th>8801, 8802, 8805, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9810</th>
          <th>極立体視 (バリアント A)</th>
          <th>8801, 8802, 8805, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9811</th>
          <th>ニュージーランド地図グリッド</th>
          <th>8801, 8802, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9812</th>
          <th>Hotine Oblique Mercator (バリアント A)</th>
          <th>8811, 8812, 8813, 8814, 8815, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9813</th>
          <th>Laborde Oblique Mercator</th>
          <th>8811, 8812, 8813, 8815, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9815</th>
          <th>Hotine Oblique Mercator (バリアント B)</th>
          <th>8811, 8812, 8813, 8814, 8815, 8816, 8817</th>
        </tr><tr>
          <th scope="row">9816</th>
          <th>チュニジアマイニンググリッド</th>
          <th>8821, 8822, 8826, 8827</th>
        </tr><tr>
          <th scope="row">9817</th>
          <th>Lambert Conic Near-Conformal</th>
          <th>8801, 8802, 8805, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9818</th>
          <th>アメリカ領ポリコン</th>
          <th>8801, 8802, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9819</th>
          <th>Krovak</th>
          <th>8811, 8833, 1036, 8818, 8819, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9820</th>
          <th>ランバートアジムタル等圏</th>
          <th>8801, 8802, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9822</th>
          <th>Albers Equal Area</th>
          <th>8821, 8822, 8823, 8824, 8826, 8827</th>
        </tr><tr>
          <th scope="row">9824</th>
          <th>Transverse Mercator ゾーングリッドシステム</th>
          <th>8801, 8830, 8831, 8805, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9826</th>
          <th>ランバートコニック連合 (西方向)</th>
          <th>8801, 8802, 8805, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9828</th>
          <th>ボンヌ (南指向)</th>
          <th>8801, 8802, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9829</th>
          <th>極立体視 (バリアント B)</th>
          <th>8832, 8833, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9830</th>
          <th>極立体視 (バリアント C)</th>
          <th>8832, 8833, 8826, 8827</th>
        </tr><tr>
          <th scope="row">9831</th>
          <th>グアム投影</th>
          <th>8801, 8802, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9832</th>
          <th>修正済方程式</th>
          <th>8801, 8802, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9833</th>
          <th>双曲線カシーニ＝ソルドナー</th>
          <th>8801, 8802, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9834</th>
          <th>ランバートシリンダル等面 (球面)</th>
          <th>8823, 8802, 8806, 8807</th>
        </tr><tr>
          <th scope="row">9835</th>
          <td>ランバートシリンダル等面</td>
          <td>8823, 8802, 8806, 8807</td>
        </tr></tbody></table></div></div><br class="table-break"><p>
      次のテーブルに、MySQL で認識される投影パラメータを示します。 認識は主に権限コードによって行われます。 認証局コードがない場合、MySQL は、パラメータ名に一致する大/小文字を区別しない文字列にフォールバックします。 各パラメータの詳細は、<a class="ulink" href="https://www.epsg-registry.org" target="_top">「EPSG オンラインレジストリ」</a>のコードを参照してください。 
    </p><div class="table"><a name="srs-projection-parameters-table"></a><p class="title"><b>表 13.8 空間参照システム予測パラメータ</b></p><div class="table-contents"><table summary="Spatial reference system projection codes, fallback names, and EPSG names."><col style="width: 10%"><col style="width: 45%"><col style="width: 35%"><thead><tr>
          <th scope="col">EPSG コード</th>
          <th scope="col">フォールバック名 (MySQL で認識)</th>
          <th scope="col">EPSG 名</th>
        </tr></thead><tbody><tr>
          <th scope="row">1026</th>
          <th>c1</th>
          <th>C1</th>
        </tr><tr>
          <th scope="row">1027</th>
          <th>c2</th>
          <th>C2</th>
        </tr><tr>
          <th scope="row">1028</th>
          <th>c3</th>
          <th>C3</th>
        </tr><tr>
          <th scope="row">1029</th>
          <th>c4</th>
          <th>C4</th>
        </tr><tr>
          <th scope="row">1030</th>
          <th>c5</th>
          <th>C5</th>
        </tr><tr>
          <th scope="row">1031</th>
          <th>c6</th>
          <th>C6</th>
        </tr><tr>
          <th scope="row">1032</th>
          <th>c7</th>
          <th>C7</th>
        </tr><tr>
          <th scope="row">1033</th>
          <th>c8</th>
          <th>C8</th>
        </tr><tr>
          <th scope="row">1034</th>
          <th>c9</th>
          <th>C9</th>
        </tr><tr>
          <th scope="row">1035</th>
          <th>c10</th>
          <th>C10</th>
        </tr><tr>
          <th scope="row">1036</th>
          <th>方位角</th>
          <th>円錐軸の同一レベル</th>
        </tr><tr>
          <th scope="row">1038</th>
          <th>ellipsoid_scale_factor</th>
          <th>楕円体スケーリング係数</th>
        </tr><tr>
          <th scope="row">1039</th>
          <th>projection_plane_height_at_origin</th>
          <th>投影平面原点の高さ</th>
        </tr><tr>
          <th scope="row">8617</th>
          <th>evaluation_point_ordinate_1</th>
          <th>評価ポイントの序数 1</th>
        </tr><tr>
          <th scope="row">8618</th>
          <th>evaluation_point_ordinate_2</th>
          <th>評価ポイントの序数 2</th>
        </tr><tr>
          <th scope="row">8801</th>
          <th>latitude_of_origin</th>
          <th>自然起点の緯度</th>
        </tr><tr>
          <th scope="row">8802</th>
          <th>central_meridian</th>
          <th>自然原点の経度</th>
        </tr><tr>
          <th scope="row">8805</th>
          <th>scale_factor</th>
          <th>自然原点のスケール係数</th>
        </tr><tr>
          <th scope="row">8806</th>
          <th>false_easting</th>
          <th>偽東座標</th>
        </tr><tr>
          <th scope="row">8807</th>
          <th>false_northing</th>
          <th>偽北座標</th>
        </tr><tr>
          <th scope="row">8811</th>
          <th>latitude_of_center</th>
          <th>投影センターの緯度</th>
        </tr><tr>
          <th scope="row">8812</th>
          <th>longitude_of_center</th>
          <th>投影中心の経度</th>
        </tr><tr>
          <th scope="row">8813</th>
          <th>方位角</th>
          <th>最初の行の方位角</th>
        </tr><tr>
          <th scope="row">8814</th>
          <th>rectified_grid_angle</th>
          <th>ジオメトリ補正からスキューグリッドまでの角度</th>
        </tr><tr>
          <th scope="row">8815</th>
          <th>scale_factor</th>
          <th>初期線の尺度係数</th>
        </tr><tr>
          <th scope="row">8816</th>
          <th>false_easting</th>
          <th>投影中心の東座標</th>
        </tr><tr>
          <th scope="row">8817</th>
          <th>false_northing</th>
          <th>投影中心の北座標</th>
        </tr><tr>
          <th scope="row">8818</th>
          <th>pseudo_standard_parallel_1</th>
          <th>擬似標準並列度</th>
        </tr><tr>
          <th scope="row">8819</th>
          <th>scale_factor</th>
          <th>疑似標準パラレルのスケール係数</th>
        </tr><tr>
          <th scope="row">8821</th>
          <th>latitude_of_origin</th>
          <th>偽起点の緯度</th>
        </tr><tr>
          <th scope="row">8822</th>
          <th>central_meridian</th>
          <th>偽原点の経度</th>
        </tr><tr>
          <th scope="row">8823</th>
          <th>standard_parallel_1, standard_parallel1</th>
          <th>第 1 標準平行度</th>
        </tr><tr>
          <th scope="row">8824</th>
          <th>standard_parallel_2, standard_parallel2</th>
          <th>第 2 標準並列度</th>
        </tr><tr>
          <th scope="row">8826</th>
          <th>false_easting</th>
          <th>偽原点の東座標</th>
        </tr><tr>
          <th scope="row">8827</th>
          <th>false_northing</th>
          <th>偽原点での北座標</th>
        </tr><tr>
          <th scope="row">8830</th>
          <th>initial_longitude</th>
          <th>初期経度</th>
        </tr><tr>
          <th scope="row">8831</th>
          <th>zone_width</th>
          <th>ゾーンの幅</th>
        </tr><tr>
          <th scope="row">8832</th>
          <th>standard_parallel</th>
          <th>標準並列度</th>
        </tr><tr>
          <th scope="row">8833</th>
          <td>longitude_of_center</td>
          <td>原点の経度</td>
        </tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-table"></a>13.1.20 CREATE TABLE ステートメント</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#create-table-files">13.1.20.1 CREATE TABLE によって作成されるファイル</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-temporary-table">13.1.20.2 CREATE TEMPORARY TABLE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-table-like">13.1.20.3 CREATE TABLE ... LIKE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-table-select">13.1.20.4 CREATE TABLE ... SELECT ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-table-foreign-keys">13.1.20.5 FOREIGN KEY の制約</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-table-check-constraints">13.1.20.6 CHECK 制約</a></span></dt><dt><span class="section"><a href="sql-statements.html#silent-column-changes">13.1.20.7 暗黙のカラム指定の変更</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-table-generated-columns">13.1.20.8 CREATE TABLE および生成されるカラム</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-table-secondary-indexes">13.1.20.9 セカンダリインデックスと生成されたカラム</a></span></dt><dt><span class="section"><a href="sql-statements.html#invisible-columns">13.1.20.10 非表示カラム</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-table-ndb-table-comment-options">13.1.20.11 NDB_TABLE オプションの設定</a></span></dt></dl></div><a class="indexterm" name="idm45827004448944"></a><pre class="programlisting">CREATE [TEMPORARY] TABLE [IF NOT EXISTS] <em class="replaceable"><code>tbl_name</code></em>
    (<em class="replaceable"><code>create_definition</code></em>,...)
    [<em class="replaceable"><code>table_options</code></em>]
    [<em class="replaceable"><code>partition_options</code></em>]

CREATE [TEMPORARY] TABLE [IF NOT EXISTS] <em class="replaceable"><code>tbl_name</code></em>
    [(<em class="replaceable"><code>create_definition</code></em>,...)]
    [<em class="replaceable"><code>table_options</code></em>]
    [<em class="replaceable"><code>partition_options</code></em>]
    [IGNORE | REPLACE]
    [AS] <em class="replaceable"><code>query_expression</code></em>

CREATE [TEMPORARY] TABLE [IF NOT EXISTS] <em class="replaceable"><code>tbl_name</code></em>
    { LIKE <em class="replaceable"><code>old_tbl_name</code></em> | (LIKE <em class="replaceable"><code>old_tbl_name</code></em>) }

<em class="replaceable"><code>create_definition</code></em>: {
    <em class="replaceable"><code>col_name</code></em> <em class="replaceable"><code>column_definition</code></em>
  | {INDEX | KEY} [<em class="replaceable"><code>index_name</code></em>] [<em class="replaceable"><code>index_type</code></em>] (<em class="replaceable"><code>key_part</code></em>,...)
      [<em class="replaceable"><code>index_option</code></em>] ...
  | {FULLTEXT | SPATIAL} [INDEX | KEY] [<em class="replaceable"><code>index_name</code></em>] (<em class="replaceable"><code>key_part</code></em>,...)
      [<em class="replaceable"><code>index_option</code></em>] ...
  | [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] PRIMARY KEY
      [<em class="replaceable"><code>index_type</code></em>] (<em class="replaceable"><code>key_part</code></em>,...)
      [<em class="replaceable"><code>index_option</code></em>] ...
  | [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] UNIQUE [INDEX | KEY]
      [<em class="replaceable"><code>index_name</code></em>] [<em class="replaceable"><code>index_type</code></em>] (<em class="replaceable"><code>key_part</code></em>,...)
      [<em class="replaceable"><code>index_option</code></em>] ...
  | [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] FOREIGN KEY
      [<em class="replaceable"><code>index_name</code></em>] (<em class="replaceable"><code>col_name</code></em>,...)
      <em class="replaceable"><code>reference_definition</code></em>
  | <em class="replaceable"><code>check_constraint_definition</code></em>
}

<em class="replaceable"><code>column_definition</code></em>: {
    <em class="replaceable"><code>data_type</code></em> [NOT NULL | NULL] [DEFAULT {<em class="replaceable"><code>literal</code></em> | (<em class="replaceable"><code>expr</code></em>)} ]
      [VISIBLE | INVISIBLE]
      [AUTO_INCREMENT] [UNIQUE [KEY]] [[PRIMARY] KEY]
      [COMMENT '<em class="replaceable"><code>string</code></em>']
      [COLLATE <em class="replaceable"><code>collation_name</code></em>]
      [COLUMN_FORMAT {FIXED | DYNAMIC | DEFAULT}]
      [ENGINE_ATTRIBUTE [=] '<em class="replaceable"><code>string</code></em>']
      [SECONDARY_ENGINE_ATTRIBUTE [=] '<em class="replaceable"><code>string</code></em>']
      [STORAGE {DISK | MEMORY}]
      [<em class="replaceable"><code>reference_definition</code></em>]
      [<em class="replaceable"><code>check_constraint_definition</code></em>]
  | <em class="replaceable"><code>data_type</code></em>
      [COLLATE <em class="replaceable"><code>collation_name</code></em>]
      [GENERATED ALWAYS] AS (<em class="replaceable"><code>expr</code></em>)
      [VIRTUAL | STORED] [NOT NULL | NULL]
      [VISIBLE | INVISIBLE]
      [UNIQUE [KEY]] [[PRIMARY] KEY]
      [COMMENT '<em class="replaceable"><code>string</code></em>']
      [<em class="replaceable"><code>reference_definition</code></em>]
      [<em class="replaceable"><code>check_constraint_definition</code></em>]
}

<em class="replaceable"><code>data_type</code></em>:
    (see <a class="xref" href="data-types.html" title="第 11 章 データ型">第11章「<i>データ型</i>」</a>)

<em class="replaceable"><code>key_part</code></em>: {<em class="replaceable"><code>col_name</code></em> [(<em class="replaceable"><code>length</code></em>)] | (<em class="replaceable"><code>expr</code></em>)} [ASC | DESC]

<em class="replaceable"><code>index_type</code></em>:
    USING {BTREE | HASH}

<em class="replaceable"><code>index_option</code></em>: {
    KEY_BLOCK_SIZE [=] <em class="replaceable"><code>value</code></em>
  | <em class="replaceable"><code>index_type</code></em>
  | WITH PARSER <em class="replaceable"><code>parser_name</code></em>
  | COMMENT '<em class="replaceable"><code>string</code></em>'
  | {VISIBLE | INVISIBLE}
  |<code class="literal">ENGINE_ATTRIBUTE</code> [=] '<em class="replaceable"><code>string</code></em>'
  |<code class="literal">SECONDARY_ENGINE_ATTRIBUTE</code> [=] '<em class="replaceable"><code>string</code></em>'
}

<em class="replaceable"><code>check_constraint_definition</code></em>:
    [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] CHECK (<em class="replaceable"><code>expr</code></em>) [[NOT] ENFORCED]

<em class="replaceable"><code>reference_definition</code></em>:
    REFERENCES <em class="replaceable"><code>tbl_name</code></em> (<em class="replaceable"><code>key_part</code></em>,...)
      [MATCH FULL | MATCH PARTIAL | MATCH SIMPLE]
      [ON DELETE <em class="replaceable"><code>reference_option</code></em>]
      [ON UPDATE <em class="replaceable"><code>reference_option</code></em>]

<em class="replaceable"><code>reference_option</code></em>:
    RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT

<em class="replaceable"><code>table_options</code></em>:
    <em class="replaceable"><code>table_option</code></em> [[,] <em class="replaceable"><code>table_option</code></em>] ...

<em class="replaceable"><code>table_option</code></em>: {
    AUTOEXTEND_SIZE [=] <em class="replaceable"><code>value</code></em>
  | AUTO_INCREMENT [=] <em class="replaceable"><code>value</code></em>
  | AVG_ROW_LENGTH [=] <em class="replaceable"><code>value</code></em>
  | [DEFAULT] CHARACTER SET [=] <em class="replaceable"><code>charset_name</code></em>
  | CHECKSUM [=] {0 | 1}
  | [DEFAULT] COLLATE [=] <em class="replaceable"><code>collation_name</code></em>
  | COMMENT [=] '<em class="replaceable"><code>string</code></em>'
  | COMPRESSION [=] {'ZLIB' | 'LZ4' | 'NONE'}
  | CONNECTION [=] '<em class="replaceable"><code>connect_string</code></em>'
  | {DATA | INDEX} DIRECTORY [=] '<em class="replaceable"><code>absolute path to directory</code></em>'
  | DELAY_KEY_WRITE [=] {0 | 1}
  | ENCRYPTION [=] {'Y' | 'N'}
  | ENGINE [=] <em class="replaceable"><code>engine_name</code></em>
  | ENGINE_ATTRIBUTE [=] '<em class="replaceable"><code>string</code></em>'
  | INSERT_METHOD [=] { NO | FIRST | LAST }
  | KEY_BLOCK_SIZE [=] <em class="replaceable"><code>value</code></em>
  | MAX_ROWS [=] <em class="replaceable"><code>value</code></em>
  | MIN_ROWS [=] <em class="replaceable"><code>value</code></em>
  | PACK_KEYS [=] {0 | 1 | DEFAULT}
  | PASSWORD [=] '<em class="replaceable"><code>string</code></em>'
  | ROW_FORMAT [=] {DEFAULT | DYNAMIC | FIXED | COMPRESSED | REDUNDANT | COMPACT}
  | SECONDARY_ENGINE_ATTRIBUTE [=] '<em class="replaceable"><code>string</code></em>'
  | STATS_AUTO_RECALC [=] {DEFAULT | 0 | 1}
  | STATS_PERSISTENT [=] {DEFAULT | 0 | 1}
  | STATS_SAMPLE_PAGES [=] <em class="replaceable"><code>value</code></em>
  | TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> [STORAGE {DISK | MEMORY}]
  | UNION [=] (<em class="replaceable"><code>tbl_name</code></em>[,<em class="replaceable"><code>tbl_name</code></em>]...)
}

<em class="replaceable"><code>partition_options</code></em>:
    PARTITION BY
        { [LINEAR] HASH(<em class="replaceable"><code>expr</code></em>)
        | [LINEAR] KEY [ALGORITHM={1 | 2}] (<em class="replaceable"><code>column_list</code></em>)
        | RANGE{(<em class="replaceable"><code>expr</code></em>) | COLUMNS(<em class="replaceable"><code>column_list</code></em>)}
        | LIST{(<em class="replaceable"><code>expr</code></em>) | COLUMNS(<em class="replaceable"><code>column_list</code></em>)} }
    [PARTITIONS <em class="replaceable"><code>num</code></em>]
    [SUBPARTITION BY
        { [LINEAR] HASH(<em class="replaceable"><code>expr</code></em>)
        | [LINEAR] KEY [ALGORITHM={1 | 2}] (<em class="replaceable"><code>column_list</code></em>) }
      [SUBPARTITIONS <em class="replaceable"><code>num</code></em>]
    ]
    [(<em class="replaceable"><code>partition_definition</code></em> [, <em class="replaceable"><code>partition_definition</code></em>] ...)]

<em class="replaceable"><code>partition_definition</code></em>:
    PARTITION <em class="replaceable"><code>partition_name</code></em>
        [VALUES
            {LESS THAN {(<em class="replaceable"><code>expr</code></em> | <em class="replaceable"><code>value_list</code></em>) | MAXVALUE}
            |
            IN (<em class="replaceable"><code>value_list</code></em>)}]
        [[STORAGE] ENGINE [=] <em class="replaceable"><code>engine_name</code></em>]
        [COMMENT [=] '<em class="replaceable"><code>string</code></em>' ]
        [DATA DIRECTORY [=] '<code class="filename"><em class="replaceable"><code>data_dir</code></em></code>']
        [INDEX DIRECTORY [=] '<code class="filename"><em class="replaceable"><code>index_dir</code></em></code>']
        [MAX_ROWS [=] <em class="replaceable"><code>max_number_of_rows</code></em>]
        [MIN_ROWS [=] <em class="replaceable"><code>min_number_of_rows</code></em>]
        [TABLESPACE [=] tablespace_name]
        [(<em class="replaceable"><code>subpartition_definition</code></em> [, <em class="replaceable"><code>subpartition_definition</code></em>] ...)]

<em class="replaceable"><code>subpartition_definition</code></em>:
    SUBPARTITION <em class="replaceable"><code>logical_name</code></em>
        [[STORAGE] ENGINE [=] <em class="replaceable"><code>engine_name</code></em>]
        [COMMENT [=] '<em class="replaceable"><code>string</code></em>' ]
        [DATA DIRECTORY [=] '<code class="filename"><em class="replaceable"><code>data_dir</code></em></code>']
        [INDEX DIRECTORY [=] '<code class="filename"><em class="replaceable"><code>index_dir</code></em></code>']
        [MAX_ROWS [=] <em class="replaceable"><code>max_number_of_rows</code></em>]
        [MIN_ROWS [=] <em class="replaceable"><code>min_number_of_rows</code></em>]
        [TABLESPACE [=] tablespace_name]

<em class="replaceable"><code>query_expression:</code></em>
    SELECT ...   (<em class="replaceable"><code>Some valid select or union statement</code></em>)
</pre><p>
      <code class="literal">CREATE TABLE</code> は、指定された名前を持つテーブルを作成します。 このテーブルに対する <code class="literal">CREATE</code> 権限が必要です。 
    </p><p>
      デフォルトでは、テーブルは <code class="literal">InnoDB</code> ストレージエンジンを使用してデフォルトデータベースに作成されます。 テーブルがすでに存在する場合、デフォルトデータベースが存在しない場合、またはデータベースが存在しない場合はエラーが発生します。 
    </p><a class="indexterm" name="idm45827004373904"></a><a class="indexterm" name="idm45827004371728"></a><p>
      MySQL にはテーブル数の制限はありません。 ベースとなるファイルシステムによっては、テーブルを表すファイル数に制限がある場合があります。 個々のストレージエンジンには、エンジン固有の制約が課される場合があります。 <code class="literal">InnoDB</code> では、最大 40 億個のテーブルを使用できます。 
    </p><p>
      テーブルの物理表現の詳細は、<a class="xref" href="sql-statements.html#create-table-files" title="13.1.20.1 CREATE TABLE によって作成されるファイル">セクション13.1.20.1「CREATE TABLE によって作成されるファイル」</a> を参照してください。
    </p><p>
      このセクションの次のトピックで説明するように、<code class="literal">CREATE TABLE</code> ステートメントにはいくつかの側面があります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#create-table-name" title="テーブル名">テーブル名</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-table-temporary-tables" title="一時テーブル">一時テーブル</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-table-clone-copy" title="テーブルのクローニングおよびコピー">テーブルのクローニングおよびコピー</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-table-types-attributes" title="カラムのデータ型および属性">カラムのデータ型および属性</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-table-indexes-keys" title="インデックス、外部キーおよび CHECK 制約">インデックス、外部キーおよび CHECK 制約</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-table-options" title="テーブルオプション">テーブルオプション</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-table-partitioning" title="テーブルのパーティション化">テーブルのパーティション化</a></p></li></ul></div><h4><a name="create-table-name"></a>テーブル名</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal"><em class="replaceable"><code>tbl_name</code></em></code>
        </p><p>
          特定のデータベース内にテーブルを作成するには、テーブル名を <em class="replaceable"><code>db_name.tbl_name</code></em> として指定できます。 そのデータベースが存在すると仮定すると、これは、デフォルトデータベースが存在するかどうかには関係なく機能します。 引用符で囲まれた識別子を使用する場合は、データベース名とテーブル名を個別に引用符で囲みます。 たとえば、<code class="literal">`mydb.mytbl`</code> ではなく、<code class="literal">`mydb`.`mytbl`</code> と記述します。 
        </p><p>
          許可されるテーブル名のルールは、<a class="xref" href="language-structure.html#identifiers" title="9.2 スキーマオブジェクト名">セクション9.2「スキーマオブジェクト名」</a>に示されています。
        </p></li><li class="listitem"><p>
          <code class="literal">IF NOT EXISTS</code>
        </p><p>
          テーブルが存在する場合にエラーが発生しないようにします。 ただし、既存のテーブルの構造が <code class="literal">CREATE TABLE</code> ステートメントによって示されている構造と同一であることの検証は行われません。 
        </p></li></ul></div><h4><a name="create-table-temporary-tables"></a>一時テーブル</h4><p>
      テーブルの作成時に <code class="literal">TEMPORARY</code> キーワードを使用できます。 <code class="literal">TEMPORARY</code> テーブルは現在のセッション内でのみ表示され、セッションがクローズされると自動的に削除されます。 詳細は、<a class="xref" href="sql-statements.html#create-temporary-table" title="13.1.20.2 CREATE TEMPORARY TABLE ステートメント">セクション13.1.20.2「CREATE TEMPORARY TABLE ステートメント」</a>を参照してください。 
    </p><h4><a name="create-table-clone-copy"></a>テーブルのクローニングおよびコピー</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">LIKE</code>
        </p><p>
          <code class="literal">CREATE TABLE ... LIKE</code> を使用して、元のテーブルに定義されているカラム属性やインデックスなど、別のテーブルの定義に基づいて空のテーブルを作成します:
        </p><pre class="programlisting">CREATE TABLE <em class="replaceable"><code>new_tbl</code></em> LIKE <em class="replaceable"><code>orig_tbl</code></em>;
</pre><p>
          詳細は、<a class="xref" href="sql-statements.html#create-table-like" title="13.1.20.3 CREATE TABLE ... LIKE ステートメント">セクション13.1.20.3「CREATE TABLE ... LIKE ステートメント」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">[AS] <em class="replaceable"><code>query_expression</code></em></code>
        </p><p>
          別のテーブルからテーブルを作成するには、<code class="literal">CREATE TABLE</code> ステートメントの最後に <code class="literal">SELECT</code> ステートメントを追加します:
        </p><pre class="programlisting">CREATE TABLE <em class="replaceable"><code>new_tbl</code></em> AS SELECT * FROM <em class="replaceable"><code>orig_tbl</code></em>;
</pre><p>
          詳細は、<a class="xref" href="sql-statements.html#create-table-select" title="13.1.20.4 CREATE TABLE ... SELECT ステートメント">セクション13.1.20.4「CREATE TABLE ... SELECT ステートメント」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">IGNORE | REPLACE</code>
        </p><p>
          <code class="literal">IGNORE</code> および <code class="literal">REPLACE</code> オプションは、<code class="literal">SELECT</code> ステートメントを使用してテーブルをコピーするときに一意キー値を複製する行の処理方法を示します。
        </p><p>
          詳細は、<a class="xref" href="sql-statements.html#create-table-select" title="13.1.20.4 CREATE TABLE ... SELECT ステートメント">セクション13.1.20.4「CREATE TABLE ... SELECT ステートメント」</a>を参照してください。
        </p></li></ul></div><h4><a name="create-table-types-attributes"></a>カラムのデータ型および属性</h4><p>
      テーブルあたり 4096 カラムという強い制限値がありますが、特定のテーブルでは、実際の最大数がこれより少なくなる可能性があります。実際の最大数は、<a class="xref" href="optimization.html#column-count-limit" title="8.4.7 テーブルカラム数と行サイズの制限">セクション8.4.7「テーブルカラム数と行サイズの制限」</a>で説明されている要因によって異なります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal"><em class="replaceable"><code>data_type</code></em></code>
        </p><p>
          <em class="replaceable"><code>data_type</code></em> は、カラム定義のデータ型を表します。 カラムのデータ型の指定に使用できる構文の詳細、および各型のプロパティの詳細は、<a class="xref" href="data-types.html" title="第 11 章 データ型">第11章「<i>データ型</i>」</a> を参照してください。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              属性の中には、すべてのデータ型には適用されないものがあります。 <code class="literal">AUTO_INCREMENT</code> は、整数型と浮動小数点型にのみ適用されます。 MySQL 8.0.13 より前は、<code class="literal">DEFAULT</code> は <code class="literal">BLOB</code>, <code class="literal">TEXT</code>, <code class="literal">GEOMETRY</code> および <code class="literal">JSON</code> タイプには適用されません。 
            </p></li><li class="listitem"><p>
              文字データ型 (<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、<code class="literal">TEXT</code> 型、<code class="literal">ENUM</code>、<code class="literal">SET</code> およびシノニム) には、<code class="literal">CHARACTER SET</code> を含めてカラムの文字セットを指定できます。 <code class="literal">CHARSET</code> は <code class="literal">CHARACTER SET</code> のシノニムです。 文字セットの照合順序は、他の属性とともに <code class="literal">COLLATE</code> 属性とともに指定できます。 詳細は、<a class="xref" href="charset.html" title="第 10 章 文字セット、照合順序、Unicode">第10章「<i>文字セット、照合順序、Unicode</i>」</a>を参照してください。 例: 
            </p><pre class="programlisting">CREATE TABLE t (c CHAR(20) CHARACTER SET utf8 COLLATE utf8_bin);
</pre><p>
              MySQL 8.0 は、文字カラム定義内の長さの指定を文字数で解釈します。 <code class="literal">BINARY</code> と <code class="literal">VARBINARY</code> の長さはバイト単位です。 
            </p></li><li class="listitem"><p>
              <code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、<code class="literal">BINARY</code>、および <code class="literal">VARBINARY</code> カラムの場合は、<code class="literal"><em class="replaceable"><code>col_name</code></em>(<em class="replaceable"><code>length</code></em>)</code> 構文を使用してインデックスプリフィクス長を指定することにより、カラム値の先頭の部分のみを使用するインデックスを作成できます。 <code class="literal">BLOB</code> および <code class="literal">TEXT</code> カラムにもインデックスを設定できますが、プリフィクス長を指定する<span class="emphasis"><em>必要があります</em></span>。 プリフィクス長は、バイナリ以外の文字列型の場合は文字数で、バイナリ文字列型の場合はバイト単位で指定されます。 つまり、インデックスエントリは、<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、および <code class="literal">TEXT</code> カラムの場合は各カラム値の最初の <em class="replaceable"><code>length</code></em> 文字、<code class="literal">BINARY</code>、<code class="literal">VARBINARY</code>、および <code class="literal">BLOB</code> カラムの場合は各カラム値の最初の <em class="replaceable"><code>length</code></em> バイトで構成されます。 このようにカラム値のプリフィクスのみにインデックスを設定すると、インデックスファイルをはるかに小さくできます。 インデックス接頭辞の詳細は、<a class="xref" href="sql-statements.html#create-index" title="13.1.15 CREATE INDEX ステートメント">セクション13.1.15「CREATE INDEX ステートメント」</a> を参照してください。 
            </p><a class="indexterm" name="idm45827004277120"></a><a class="indexterm" name="idm45827004274960"></a><a class="indexterm" name="idm45827004272896"></a><a class="indexterm" name="idm45827004270816"></a><p>
              <code class="literal">BLOB</code> および <code class="literal">TEXT</code> カラム上のインデックス設定をサポートするのは、<code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> ストレージエンジンだけです。 例: 
            </p><pre class="programlisting">CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));
</pre><p>
              指定したインデックス接頭辞がカラムの最大データ型サイズを超える場合、<code class="literal">CREATE TABLE</code> は次のようにインデックスを処理します:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                  一意でないインデックスの場合は、エラーが発生するか (厳密な SQL モードが有効な場合)、インデックスの長さが最大カラムデータ型サイズ内になるように縮小され、警告が生成されます (厳密な SQL モードが有効でない場合)。
                </p></li><li class="listitem"><p>
                  一意インデックスの場合、インデックスの長さを短くすると、指定した一意性要件を満たさない一意でないエントリの挿入が可能になるため、SQL モードに関係なくエラーが発生します。
                </p></li></ul></div></li><li class="listitem"><p>
              <code class="literal">JSON</code> カラムはインデックス付けできません。 この制限を回避するには、生成されたカラムに <code class="literal">JSON</code> カラムからスカラー値を抽出するインデックスを作成します。 詳細な例は、<a class="xref" href="sql-statements.html#json-column-indirect-index" title="JSON カラムインデックスを提供するための生成されたカラムのインデックス付け">JSON カラムインデックスを提供するための生成されたカラムのインデックス付け</a> を参照してください。 
            </p></li></ul></div></li><li class="listitem"><p>
          <code class="literal">NOT NULL | NULL</code>
        </p><a class="indexterm" name="idm45827004253472"></a><a class="indexterm" name="idm45827004251328"></a><p>
          <code class="literal">NULL</code> と <code class="literal">NOT NULL</code> のどちらも指定されていない場合、そのカラムは <code class="literal">NULL</code> が指定されたかのように処理されます。
        </p><p>
          MySQL 8.0 では、<code class="literal">InnoDB</code>、<code class="literal">MyISAM</code> および <code class="literal">MEMORY</code> ストレージエンジンのみが <code class="literal">NULL</code> 値を持つことができるカラムのインデックスをサポートしています。 それ以外の場合は、インデックス付きカラムを <code class="literal">NOT NULL</code> として宣言する必要があります。そうしないと、エラー結果が発生します。 
        </p></li><li class="listitem"><p>
          <code class="literal">DEFAULT</code>
        </p><a class="indexterm" name="idm45827004240528"></a><a class="indexterm" name="idm45827004239072"></a><p>
          カラムのデフォルト値を指定します。 カラム定義に明示的な <code class="literal">DEFAULT</code> 値が含まれていない場合など、デフォルト値の処理の詳細は、<a class="xref" href="data-types.html#data-type-defaults" title="11.6 データ型デフォルト値">セクション11.6「データ型デフォルト値」</a> を参照してください。 
        </p><p>
          <code class="literal">NO_ZERO_DATE</code> または <code class="literal">NO_ZERO_IN_DATE</code> SQL モードが有効になっているときに、日付の値のデフォルトがそのモードに従って正しくない場合、<code class="literal">CREATE TABLE</code> では厳密な SQL モードが有効になっていない場合は警告を、厳密モードが有効になっている場合はエラーを生成します。 たとえば、<code class="literal">NO_ZERO_IN_DATE</code> が有効になっている場合は、<code class="literal">c1 DATE DEFAULT '2010-00-00'</code> によって警告が生成されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">VISIBLE</code>, <code class="literal">INVISIBLE</code>
        </p><p>
          カラムの可視性を指定します。 どちらのキーワードも存在しない場合、デフォルトは <code class="literal">VISIBLE</code> です。 テーブルには、少なくとも 1 つの表示可能なカラムが必要です。 すべてのカラムを非表示にしようとすると、エラーが発生します。 詳細は、<a class="xref" href="sql-statements.html#invisible-columns" title="13.1.20.10 非表示カラム">セクション13.1.20.10「非表示カラム」</a>を参照してください。 
        </p><a class="indexterm" name="idm45827004225184"></a><p>
          <code class="literal">VISIBLE</code> および <code class="literal">INVISIBLE</code> キーワードは、MySQL 8.0.23 の時点で使用できます。 MySQL 8.0.23 より前は、すべてのカラムが表示されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">AUTO_INCREMENT</code>
        </p><p>
          整数または浮動小数点のカラムには、追加の属性 <code class="literal">AUTO_INCREMENT</code> を指定できます。 インデックスが設定された <code class="literal">AUTO_INCREMENT</code> カラムに <code class="literal">NULL</code> (推奨) または <code class="literal">0</code> の値を挿入すると、カラムは次のシーケンス値に設定されます。 通常、これは <code class="literal"><em class="replaceable"><code>value</code></em>+1</code> です。ここで <em class="replaceable"><code>value</code></em> は現在テーブルにあるカラムの最大値です。 <code class="literal">AUTO_INCREMENT</code> シーケンスは <code class="literal">1</code> で始まります。 
        </p><p>
          行を挿入したあとに <code class="literal">AUTO_INCREMENT</code> 値を取得するには、<code class="literal">LAST_INSERT_ID()</code> SQL 関数または <code class="literal">mysql_insert_id()</code> C API 関数を使用します。 <a class="xref" href="functions.html#information-functions" title="12.16 情報関数">セクション12.16「情報関数」</a>および<a class="ulink" href="https://dev.mysql.com/doc/c-api/8.0/en/mysql-insert-id.html" target="_top">mysql_insert_id()</a>を参照してください。 
        </p><p>
          <code class="literal">NO_AUTO_VALUE_ON_ZERO</code> SQL モードが有効になっている場合は、新しいシーケンス値を生成することなく、<code class="literal">0</code> を <code class="literal">AUTO_INCREMENT</code> カラム内に <code class="literal">0</code> として格納できます。 <a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a>を参照してください。 
        </p><p>
          テーブルごとに存在できる <code class="literal">AUTO_INCREMENT</code> カラムは 1 つだけです。このカラムはインデックス付きである必要があり、<code class="literal">DEFAULT</code> 値を割り当てることはできません。 <code class="literal">AUTO_INCREMENT</code> カラムは、正の値だけが含まれている場合にのみ正しく機能します。 負の数を挿入すると、非常に大きな正の数を挿入したと見なされます。 これは、数字が正から負に<span class="quote">「<span class="quote">ラップする</span>」</span>ときの精度の問題を回避すると同時に、<code class="literal">0</code> を含む <code class="literal">AUTO_INCREMENT</code> カラムを誤って取得してしまわないようにするために行われます。 
        </p><p>
          <code class="literal">MyISAM</code> テーブルの場合は、マルチカラムキー内の <code class="literal">AUTO_INCREMENT</code> セカンダリカラムを指定できます。 <a class="xref" href="tutorial.html#example-auto-increment" title="3.6.9 AUTO_INCREMENT の使用">セクション3.6.9「AUTO_INCREMENT の使用」</a>を参照してください。 
        </p><a class="indexterm" name="idm45827004196176"></a><a class="indexterm" name="idm45827004194736"></a><p>
          MySQL を一部の ODBC アプリケーションと互換性があるようにするために、次のクエリーを使用して、最後に挿入された行の <code class="literal">AUTO_INCREMENT</code> 値を見つけることができます。
        </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>auto_col</code></em> IS NULL
</pre><p>
          このメソッドでは、<code class="literal">sql_auto_is_null</code> 変数が 0 に設定されていない必要があります。 <a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>を参照してください。 
        </p><p>
          <code class="literal">InnoDB</code> と <code class="literal">AUTO_INCREMENT</code> については、<a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-handling" title="15.6.1.6 InnoDB での AUTO_INCREMENT 処理">セクション15.6.1.6「InnoDB での AUTO_INCREMENT 処理」</a>を参照してください。 <code class="literal">AUTO_INCREMENT</code> と MySQL レプリケーションについては、<a class="xref" href="replication.html#replication-features-auto-increment" title="17.5.1.1 レプリケーションと AUTO_INCREMENT">セクション17.5.1.1「レプリケーションと AUTO_INCREMENT」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">COMMENT</code>
        </p><a class="indexterm" name="idm45827004181520"></a><p>
          カラムのコメントは、<code class="literal">COMMENT</code> オプションで 1024 文字以内で指定できます。 このコメントは、<code class="literal">SHOW CREATE TABLE</code> および <code class="literal">SHOW FULL COLUMNS</code> ステートメントによって表示されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">COLUMN_FORMAT</code>
        </p><a class="indexterm" name="idm45827004175248"></a><p>
          NDB Cluster では、<code class="literal">COLUMN_FORMAT</code> を使用して <code class="literal">NDB</code> テーブルの個々のカラムのデータストレージ形式を指定することもできます。 許可されるカラムフォーマットは、<code class="literal">FIXED</code>、<code class="literal">DYNAMIC</code>、および <code class="literal">DEFAULT</code> です。 <code class="literal">FIXED</code> は固定幅記憶域の指定に使用され、<code class="literal">DYNAMIC</code> はカラムを可変幅にすることを許可し、<code class="literal">DEFAULT</code> はカラムのデータ型によって決定される固定幅記憶域または可変幅記憶域 (<code class="literal">ROW_FORMAT</code> 指定子によってオーバーライドされる可能性がある) を使用します。 
        </p><p>
          <code class="literal">NDB</code> テーブルの場合、<code class="literal">COLUMN_FORMAT</code> のデフォルト値は <code class="literal">FIXED</code> です。
        </p><p>
          NDB Cluster では、<code class="literal">COLUMN_FORMAT=FIXED</code> で定義されたカラムの可能な最大オフセットは 8188 バイトです。 詳細および考えられる回避策については、<a class="xref" href="mysql-cluster.html#mysql-cluster-limitations-database-objects" title="23.1.7.5 NDB Cluster 内のデータベースオブジェクトに関連付けられる制限">セクション23.1.7.5「NDB Cluster 内のデータベースオブジェクトに関連付けられる制限」</a> を参照してください。 
        </p><p>
          <code class="literal">COLUMN_FORMAT</code> は現在、<code class="literal">NDB</code> 以外のストレージエンジンを使用しているテーブルのカラムには影響を与えません。 MySQL 8.0 は、<code class="literal">COLUMN_FORMAT</code> を暗黙的に無視します。 
        </p></li><li class="listitem"><p>
          <code class="literal">ENGINE_ATTRIBUTE</code> および <code class="literal">SECONDARY_ENGINE_ATTRIBUTE</code> オプション (MySQL 8.0.21 の時点で使用可能) を使用して、プライマリおよびセカンダリストレージエンジンのカラム属性を指定します。 オプションは、将来の使用のために予約されています。 
        </p><p>
          許可される値は、有効な <code class="literal">JSON</code> ドキュメントまたは空の文字列 ('') を含む文字列リテラルです。 無効な <code class="literal">JSON</code> が拒否されました。 
        </p><pre class="programlisting">CREATE TABLE t1 (c1 INT ENGINE_ATTRIBUTE='{"<em class="replaceable"><code>key</code></em>":"<em class="replaceable"><code>value</code></em>"}');</pre><p>
          <code class="literal">ENGINE_ATTRIBUTE</code> および <code class="literal">SECONDARY_ENGINE_ATTRIBUTE</code> の値は、エラーなしで繰り返すことができます。 この場合、最後に指定した値が使用されます。 
        </p><p>
          <code class="literal">ENGINE_ATTRIBUTE</code> および <code class="literal">SECONDARY_ENGINE_ATTRIBUTE</code> の値は、サーバーによってチェックされず、テーブルストレージエンジンが変更されたときにもクリアされません。
        </p></li><li class="listitem"><p>
          <code class="literal">STORAGE</code>
        </p><a class="indexterm" name="idm45827004145392"></a><p>
          <code class="literal">NDB</code> テーブルの場合、<code class="literal">STORAGE</code> 句を使用して、カラムをディスクに格納するかメモリーに格納するかを指定できます。 <code class="literal">STORAGE DISK</code> を指定するとカラムはディスク上に格納され、<code class="literal">STORAGE MEMORY</code> を指定するとインメモリーストレージが使用されます。 使用される <code class="literal">CREATE TABLE</code> ステートメントには、引き続き <code class="literal">TABLESPACE</code> 句が含まれている必要があります。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
    -&gt;     <strong class="userinput"><code>c1 INT STORAGE DISK,</code></strong>
    -&gt;     <strong class="userinput"><code>c2 INT STORAGE MEMORY</code></strong>
    -&gt; <strong class="userinput"><code>) ENGINE NDB;</code></strong>
<span class="errortext">ERROR 1005 (HY000): Can't create table 'c.t1' (errno: 140)</span>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
    -&gt;     <strong class="userinput"><code>c1 INT STORAGE DISK,</code></strong>
    -&gt;     <strong class="userinput"><code>c2 INT STORAGE MEMORY</code></strong>
    -&gt; <strong class="userinput"><code>) TABLESPACE ts_1 ENGINE NDB;</code></strong>
Query OK, 0 rows affected (1.06 sec)
</pre><p>
          <code class="literal">NDB</code> テーブルの場合、<code class="literal">STORAGE DEFAULT</code> は <code class="literal">STORAGE MEMORY</code> と同等です。
        </p><p>
          <code class="literal">STORAGE</code> 句は、<code class="literal">NDB</code> 以外のストレージエンジンを使用しているテーブルには影響を与えません。 <code class="literal">STORAGE</code> キーワードは NDB Cluster で提供される <span class="command"><strong>mysqld</strong></span> の構築でのみサポートされます。ほかのバージョンの MySQL では認識されず、<code class="literal">STORAGE</code> キーワードを使用しようとすると構文エラーが発生します。 
        </p></li><li class="listitem"><p>
          <code class="literal">GENERATED ALWAYS</code>
        </p><p>
          生成されたカラム式を指定するために使用します。 <a class="link" href="glossary.html#glos_generated_column" title="生成されるカラム">generated columns</a> の詳細は、<a class="xref" href="sql-statements.html#create-table-generated-columns" title="13.1.20.8 CREATE TABLE および生成されるカラム">セクション13.1.20.8「CREATE TABLE および生成されるカラム」</a> を参照してください。 
        </p><p>
          <a class="link" href="glossary.html#glos_stored_generated_column" title="ストアド生成カラム">Stored generated columns</a> はインデックス付けできます。 <code class="literal">InnoDB</code> は、<a class="link" href="glossary.html#glos_virtual_generated_column" title="仮想生成カラム">virtual generated columns</a> でセカンダリインデックスをサポートしています。 <a class="xref" href="sql-statements.html#create-table-secondary-indexes" title="13.1.20.9 セカンダリインデックスと生成されたカラム">セクション13.1.20.9「セカンダリインデックスと生成されたカラム」</a>を参照してください。 
        </p></li></ul></div><h4><a name="create-table-indexes-keys"></a>インデックス、外部キーおよび CHECK 制約</h4><p>
      インデックス、外部キーおよび <code class="literal">CHECK</code> 制約の作成には、いくつかのキーワードが適用されます。 次の説明に加えて、一般的な背景は、<a class="xref" href="sql-statements.html#create-index" title="13.1.15 CREATE INDEX ステートメント">セクション13.1.15「CREATE INDEX ステートメント」</a>、<a class="xref" href="sql-statements.html#create-table-foreign-keys" title="13.1.20.5 FOREIGN KEY の制約">セクション13.1.20.5「FOREIGN KEY の制約」</a> および <a class="xref" href="sql-statements.html#create-table-check-constraints" title="13.1.20.6 CHECK 制約">セクション13.1.20.6「CHECK 制約」</a> を参照してください。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">CONSTRAINT <em class="replaceable"><code>symbol</code></em></code>
        </p><p>
          <code class="literal">CONSTRAINT <em class="replaceable"><code>symbol</code></em></code> 句を指定して制約に名前を付けることができます。 句が指定されていない場合、または <code class="literal">CONSTRAINT</code> キーワードの後に <em class="replaceable"><code>symbol</code></em> が含まれていない場合、MySQL では制約名が自動的に生成されますが、次に示す例外があります。 <em class="replaceable"><code>symbol</code></em> 値 (使用する場合) は、制約タイプごとにスキーマ (データベース) ごとに一意である必要があります。 <em class="replaceable"><code>symbol</code></em> が重複すると、エラーになります。 <a class="xref" href="language-structure.html#identifier-length" title="9.2.1 識別子の長さ制限">セクション9.2.1「識別子の長さ制限」</a> で生成される制約識別子の長さ制限に関する説明も参照してください。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            外部キー定義に <code class="literal">CONSTRAINT <em class="replaceable"><code>symbol</code></em></code> 句が指定されていない場合、または <code class="literal">CONSTRAINT</code> キーワードの後に <em class="replaceable"><code>symbol</code></em> が含まれていない場合、MySQL は MySQL 8.0.15 までの外部キーインデックス名を使用し、その後に制約名を自動的に生成します。
          </p></div><p>
          SQL 標準では、すべてのタイプの制約 (主キー、一意インデックス、外部キー、チェック) が同じネームスペースに属することが指定されています。 MySQL では、各制約タイプにスキーマごとに独自のネームスペースがあります。 したがって、各タイプの制約の名前はスキーマごとに一意である必要がありますが、異なるタイプの制約には同じ名前を付けることができます。 
        </p></li><li class="listitem"><p>
          <code class="literal">PRIMARY KEY</code>
        </p><a class="indexterm" name="idm45827004097696"></a><p>
          すべてのキーカラムを <code class="literal">NOT NULL</code> として定義する必要がある一意のインデックス。 それらが <code class="literal">NOT NULL</code> として明示的に宣言されていない場合、MySQL は、それらを暗黙的に (かつ警告なしで) そのように宣言します。 テーブルに存在できる <code class="literal">PRIMARY KEY</code> は 1 つだけです。 <code class="literal">PRIMARY KEY</code> の名前は、常に <code class="literal">PRIMARY</code> です。そのため、これをその他のどの種類のインデックスの名前としても使用できません。 
        </p><p>
          <code class="literal">PRIMARY KEY</code> が存在しないときに、アプリケーションがテーブル内の <code class="literal">PRIMARY KEY</code> を要求した場合、MySQL は、<code class="literal">NULL</code> カラムのない最初の <code class="literal">UNIQUE</code> インデックスを <code class="literal">PRIMARY KEY</code> として返します。
        </p><p>
          <code class="literal">InnoDB</code> テーブルでは、セカンダリインデックスのためのストレージのオーバーヘッドを最小限に抑えるために、<code class="literal">PRIMARY KEY</code> を短い値に維持してください。 各セカンダリインデックスエントリには、対応する行の主キーカラムのコピーが含まれています。 (<a class="xref" href="innodb-storage-engine.html#innodb-index-types" title="15.6.2.1 クラスタインデックスとセカンダリインデックス">セクション15.6.2.1「クラスタインデックスとセカンダリインデックス」</a>を参照してください。) 
        </p><p>
          作成されたテーブルでは、<code class="literal">PRIMARY KEY</code> が最初に配置され、そのあとにすべての <code class="literal">UNIQUE</code> インデックス、さらに一意でないインデックスが続きます。 これは、MySQL オプティマイザが、使用するインデックスに優先順位を付けたり、重複した <code class="literal">UNIQUE</code> キーをよりすばやく検出したりするのに役立ちます。 
        </p><p>
          <code class="literal">PRIMARY KEY</code> をマルチカラムインデックスにすることができます。 ただし、カラム指定で <code class="literal">PRIMARY KEY</code> キー属性を使用してマルチカラムインデックスを作成することはできません。 それを行なっても、その単一カラムがプライマリとしてマークされるだけです。 別の <code class="literal">PRIMARY KEY(<em class="replaceable"><code>key_part</code></em>, ...)</code> 句を使用する必要があります。 
        </p><a class="indexterm" name="idm45827004076992"></a><p>
          テーブルに整数型の単一カラムで構成される <code class="literal">PRIMARY KEY</code> または <code class="literal">UNIQUE NOT NULL</code> インデックスがある場合、<a class="xref" href="sql-statements.html#create-index-unique" title="一意インデックス">一意インデックス</a> で説明されているように、<code class="literal">_rowid</code> を使用して <code class="literal">SELECT</code> ステートメントのインデックス付きカラムを参照できます。
        </p><p>
          MySQL では、<code class="literal">PRIMARY KEY</code> の名前は <code class="literal">PRIMARY</code> です。 その他のインデックスでは、名前を割り当てなかった場合、そのインデックスには最初のインデックス付きカラムと同じ名前が割り当てられ、それを一意にするためにオプションのサフィクス (<code class="literal">_2</code>、<code class="literal">_3</code>、<code class="literal">...</code>) が付けられます。 テーブルのインデックス名は、<code class="literal">SHOW INDEX FROM <em class="replaceable"><code>tbl_name</code></em></code> を使用して確認できます。 <a class="xref" href="sql-statements.html#show-index" title="13.7.7.22 SHOW INDEX ステートメント">セクション13.7.7.22「SHOW INDEX ステートメント」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">KEY | INDEX</code>
        </p><p>
          <code class="literal">KEY</code> は通常、<code class="literal">INDEX</code> のシノニムです。 キー属性 <code class="literal">PRIMARY KEY</code> もまた、カラム定義内で指定する場合は、単に <code class="literal">KEY</code> として指定できます。 これは、ほかのデータベースシステムとの互換性のために実装されました。 
        </p></li><li class="listitem"><p>
          <code class="literal">UNIQUE</code>
        </p><p>
          <code class="literal">UNIQUE</code> インデックスは、そのインデックス内のすべての値が異なっている必要があるという制約を作成します。 既存の行に一致するキー値を持つ新しい行を追加しようとすると、エラーが発生します。 すべてのエンジンについて、<code class="literal">UNIQUE</code> インデックスは、<code class="literal">NULL</code> を含むことができるカラムでの複数の <code class="literal">NULL</code> 値を許可します。 <code class="literal">UNIQUE</code> インデックスのカラムに接頭辞値を指定する場合、カラム値は接頭辞の長さ内で一意である必要があります。 
        </p><a class="indexterm" name="idm45827004052368"></a><p>
          テーブルに整数型の単一カラムで構成される <code class="literal">PRIMARY KEY</code> または <code class="literal">UNIQUE NOT NULL</code> インデックスがある場合、<a class="xref" href="sql-statements.html#create-index-unique" title="一意インデックス">一意インデックス</a> で説明されているように、<code class="literal">_rowid</code> を使用して <code class="literal">SELECT</code> ステートメントのインデックス付きカラムを参照できます。
        </p></li><li class="listitem"><p>
          <code class="literal">FULLTEXT</code>
        </p><p>
          <code class="literal">FULLTEXT</code> インデックスは、全文検索に使用される特別なタイプのインデックスです。 <code class="literal">FULLTEXT</code> インデックスをサポートするのは、<code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> だけです。 これらは、<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、および <code class="literal">TEXT</code> カラムからのみ作成できます。 インデックス設定は常に、カラム全体に対して実行されます。カラムプリフィクスのインデックス設定はサポートされていないため、プリフィクス長が指定されてもすべて無視されます。 操作の詳細は、<a class="xref" href="functions.html#fulltext-search" title="12.10 全文検索関数">セクション12.10「全文検索関数」</a>を参照してください。 <code class="literal">WITH PARSER</code> 句は、全文インデックス設定および検索操作に特殊な処理が必要な場合にパーサープラグインをインデックスに関連付けるために、<em class="replaceable"><code>index_option</code></em> 値として指定できます。 この句は、<code class="literal">FULLTEXT</code> インデックスに対してのみ有効です。 <code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> は、フルテキストパーサープラグインをサポートしています。 詳細は、<a class="ulink" href="https://dev.mysql.com/doc/extending-mysql/8.0/en/plugin-types.html#full-text-plugin-type" target="_top">Full-Text Parser Plugins</a> および <a class="ulink" href="https://dev.mysql.com/doc/extending-mysql/8.0/en/writing-full-text-plugins.html" target="_top">Writing Full-Text Parser Plugins</a> を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">SPATIAL</code>
        </p><p>
          空間データ型に <code class="literal">SPATIAL</code> インデックスを作成できます。 空間型は <code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> テーブルでのみサポートされており、インデックス付けされたカラムは <code class="literal">NOT NULL</code> として宣言する必要があります。 <a class="xref" href="data-types.html#spatial-types" title="11.4 空間データ型">セクション11.4「空間データ型」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">FOREIGN KEY</code>
        </p><p>
          MySQL は、関連データのテーブルにまたがる相互参照を可能にする外部キーと、この分散したデータの整合性を維持するために役立つ外部キー制約をサポートします。 定義およびオプションの情報は、<a class="link" href="sql-statements.html#create-table-reference-definition"><em class="replaceable"><code>reference_definition</code></em></a> および <a class="link" href="sql-statements.html#create-table-reference-option"><em class="replaceable"><code>reference_option</code></em></a> を参照してください。 
        </p><p>
          <code class="literal">InnoDB</code> ストレージエンジンを使用するパーティション化されたテーブルは、外部キーをサポートしていません。 詳細については、<a class="xref" href="partitioning.html#partitioning-limitations" title="24.6 パーティショニングの制約と制限">セクション24.6「パーティショニングの制約と制限」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">CHECK</code>
        </p><p>
          <code class="literal">CHECK</code> 句を使用すると、テーブルの行のデータ値について制約を作成できます。 <a class="xref" href="sql-statements.html#create-table-check-constraints" title="13.1.20.6 CHECK 制約">セクション13.1.20.6「CHECK 制約」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal"><em class="replaceable"><code>key_part</code></em></code>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <em class="replaceable"><code>key_part</code></em> 仕様の末尾には、<code class="literal">ASC</code> または <code class="literal">DESC</code> を使用して、インデックス値を昇順または降順のどちらで格納するかを指定できます。 順序指定子が指定されていない場合、デフォルトは昇順です。 
            </p></li><li class="listitem"><p>
              <em class="replaceable"><code>length</code></em> 属性で定義される接頭辞の長さは、<code class="literal"><a class="link" href="glossary.html#glos_redundant_row_format" title="冗長行フォーマット">REDUNDANT</a></code> または <code class="literal"><a class="link" href="glossary.html#glos_compact_row_format" title="コンパクト行フォーマット">COMPACT</a></code> の行形式を使用する <code class="literal">InnoDB</code> テーブルでは最大 767 バイトです。 <code class="literal"><a class="link" href="glossary.html#glos_dynamic_row_format" title="動的行フォーマット">DYNAMIC</a></code> または <code class="literal"><a class="link" href="glossary.html#glos_compressed_row_format" title="圧縮行フォーマット">COMPRESSED</a></code> の行形式を使用する <code class="literal">InnoDB</code> テーブルでは、接頭辞の長さの制限は 3072 バイトです。 <code class="literal">MyISAM</code> テーブルの場合、接頭辞の長さの制限は 1000 バイトです。 
            </p><p>
              接頭辞 <span class="emphasis"><em>limits</em></span> はバイト単位で測定されます。 ただし、<code class="literal">CREATE TABLE</code>、<code class="literal">ALTER TABLE</code> および <code class="literal">CREATE INDEX</code> ステートメントのインデックス指定の接頭辞 <span class="emphasis"><em>lengths</em></span> は、非バイナリ文字列型 (<code class="literal">CHAR</code>, <code class="literal">VARCHAR</code>, <code class="literal">TEXT</code>) の場合は文字数として解釈され、バイナリ文字列型 (<code class="literal">BINARY</code>, <code class="literal">VARBINARY</code>, <code class="literal">BLOB</code>) の場合はバイト数として解釈されます。 マルチバイト文字セットを使用する非バイナリ文字列カラムに接頭辞の長さを指定する場合は、これを考慮してください。 
            </p></li><li class="listitem"><p>
              MySQL 8.0.17 以降、<em class="replaceable"><code>key_part</code></em> 仕様の <em class="replaceable"><code>expr</code></em> では、<code class="literal">(CAST <em class="replaceable"><code>json_path</code></em> AS <em class="replaceable"><code>type</code></em> ARRAY)</code> の形式を使用して <code class="literal">JSON</code> カラムに複数値インデックスを作成できます。<a class="xref" href="sql-statements.html#create-index-multi-valued" title="複数値インデックス">複数値インデックス</a> では、複数値インデックスの作成、使用方法、制限および制限に関する詳細情報を提供します。
            </p></li></ul></div></li><li class="listitem"><p>
          <code class="literal"><em class="replaceable"><code>index_type</code></em></code>
        </p><p>
          一部のストレージエンジンでは、インデックスの作成時にインデックスタイプを指定できます。 <em class="replaceable"><code>index_type</code></em> 指定子の構文は、<code class="literal">USING <em class="replaceable"><code>type_name</code></em></code> です。 
        </p><p>
          例:
        </p><pre class="programlisting">CREATE TABLE lookup
  (id INT, INDEX USING BTREE (id))
  ENGINE = MEMORY;
</pre><p>
          <code class="literal">USING</code> の推奨される位置は、インデックスカラムリストのあとです。 カラムリストの前に指定できますが、その位置でのオプションの使用のサポートは非推奨であるため、将来の MySQL リリースで削除される予定です。 
        </p></li><li class="listitem"><p>
          <code class="literal"><em class="replaceable"><code>index_option</code></em></code>
        </p><p>
          <em class="replaceable"><code>index_option</code></em> 値は、インデックスの追加オプションを指定します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">KEY_BLOCK_SIZE</code>
            </p><p>
              <code class="literal">MyISAM</code> テーブルの場合、<code class="literal">KEY_BLOCK_SIZE</code> はオプションで、インデックスキーブロックに使用するサイズをバイト単位で指定します。 この値はヒントとして扱われます。必要に応じて、異なるサイズが使用される可能性があります。 個々のインデックス定義に指定された <code class="literal">KEY_BLOCK_SIZE</code> 値は、テーブルレベルの <code class="literal">KEY_BLOCK_SIZE</code> 値をオーバーライドします。 
            </p><p>
              テーブルレベルの <code class="literal">KEY_BLOCK_SIZE</code> 属性の詳細は、<a class="xref" href="sql-statements.html#create-table-options" title="テーブルオプション">テーブルオプション</a> を参照してください。
            </p></li><li class="listitem"><p>
              <code class="literal">WITH PARSER</code>
            </p><p>
              <code class="literal">WITH PARSER</code> オプションは、<code class="literal">FULLTEXT</code> インデックスでのみ使用できます。 これは、全文インデックス設定および検索操作に特殊な処理が必要な場合に、パーサープラグインをインデックスに関連付けます。 <code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> は、フルテキストパーサープラグインをサポートしています。 フルテキストパーサープラグインが関連付けられた <code class="literal">MyISAM</code> テーブルがある場合は、<code class="literal">ALTER TABLE</code> を使用してテーブルを <code class="literal">InnoDB</code> に変換できます。 
            </p></li><li class="listitem"><p>
              <code class="literal">COMMENT</code>
            </p><p>
              インデックス定義には、最大 1024 文字のオプションのコメントを含めることができます。
            </p><p>
              <code class="literal"><em class="replaceable"><code>index_option</code></em></code> <code class="literal">COMMENT</code> 句を使用して、個々のインデックスに <code class="literal">InnoDB</code> <code class="literal">MERGE_THRESHOLD</code> 値を設定できます。 <a class="xref" href="innodb-storage-engine.html#index-page-merge-threshold" title="15.8.11 インデックスページのマージしきい値の構成">セクション15.8.11「インデックスページのマージしきい値の構成」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              <code class="literal">VISIBLE</code>, <code class="literal">INVISIBLE</code>
            </p><p>
              インデックスの可視性を指定します。 インデックスはデフォルトで可視化されます。 不可視インデックスはオプティマイザでは使用されません。 インデックスの可視性の指定は、主キー以外のインデックス (明示的または暗黙的) に適用されます。 詳細は、<a class="xref" href="optimization.html#invisible-indexes" title="8.3.12 不可視のインデックス">セクション8.3.12「不可視のインデックス」</a>を参照してください。 
            </p><a class="indexterm" name="idm45827003946720"></a></li><li class="listitem"><p>
              <code class="literal">ENGINE_ATTRIBUTE</code> および <code class="literal">SECONDARY_ENGINE_ATTRIBUTE</code> オプション (MySQL 8.0.21 の時点で使用可能) は、プライマリストレージエンジンおよびセカンダリストレージエンジンのインデックス属性を指定するために使用されます。 オプションは、将来の使用のために予約されています。 
            </p></li></ul></div><p>
          許容される <em class="replaceable"><code>index_option</code></em> 値の詳細は、<a class="xref" href="sql-statements.html#create-index" title="13.1.15 CREATE INDEX ステートメント">セクション13.1.15「CREATE INDEX ステートメント」</a> を参照してください。 インデックスの詳細は、<a class="xref" href="optimization.html#mysql-indexes" title="8.3.1 MySQL のインデックスの使用の仕組み">セクション8.3.1「MySQL のインデックスの使用の仕組み」</a>を参照してください。 
        </p></li><li class="listitem"><p><a name="create-table-reference-definition"></a>
          <code class="literal"><em class="replaceable"><code>reference_definition</code></em></code>
        </p><p>
          <em class="replaceable"><code>reference_definition</code></em> 構文の詳細および例は、<a class="xref" href="sql-statements.html#create-table-foreign-keys" title="13.1.20.5 FOREIGN KEY の制約">セクション13.1.20.5「FOREIGN KEY の制約」</a> を参照してください。
        </p><p>
          <code class="literal">InnoDB</code> および <code class="literal">NDB</code> テーブルは、外部キー制約のチェックをサポートしています。 参照されるテーブルのカラムには、常に明示的に名前を付ける必要があります。 外部キーに対しては <code class="literal">ON DELETE</code> と <code class="literal">ON UPDATE</code> の両方のアクションがサポートされています。 詳細および例については、<a class="xref" href="sql-statements.html#create-table-foreign-keys" title="13.1.20.5 FOREIGN KEY の制約">セクション13.1.20.5「FOREIGN KEY の制約」</a>を参照してください。 
        </p><p>
          その他のストレージエンジンの場合、MySQL Server は、<code class="literal">CREATE TABLE</code> ステートメント内の <code class="literal">FOREIGN KEY</code> および <code class="literal">REFERENCES</code> 構文を解析して無視します。 <a class="xref" href="introduction.html#ansi-diff-foreign-keys" title="1.7.2.3 FOREIGN KEY 制約の違い">セクション1.7.2.3「FOREIGN KEY 制約の違い」</a>を参照してください。 
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
            ANSI/ISO SQL 標準に精通しているユーザーの場合は、参照整合性の制約定義で使用される <code class="literal">MATCH</code> 句を認識または適用するストレージエンジンは (<code class="literal">InnoDB</code> を含め) 存在しません。 明示的な <code class="literal">MATCH</code> 句を使用しても効果はなく、<code class="literal">ON DELETE</code> 句および <code class="literal">ON UPDATE</code> 句も無視されます。 これらの理由により、<code class="literal">MATCH</code> の指定は避けるようにしてください。 
          </p><p>
            SQL 標準での <code class="literal">MATCH</code> 句は、複合 (マルチカラム) 外部キー内の <code class="literal">NULL</code> 値が、主キーとの比較時にどのように処理されるかを制御します。 <code class="literal">InnoDB</code> は基本的に、外部キーをすべてまたは部分的に <code class="literal">NULL</code> にすることが許可される、<code class="literal">MATCH SIMPLE</code> で定義されるセマンティクスを実装しています。 その場合は、このような外部キーを含む (子テーブルの) 行の挿入が許可され、その行は参照される (親) テーブル内のどの行にも一致しません。 トリガーを使用して、ほかのセマンティクスを実装できます。 
          </p><p>
            さらに、MySQL ではパフォーマンスのために、参照されるカラムにインデックスを設定する必要があります。 ただし、<code class="literal">InnoDB</code> では、参照カラムを <code class="literal">UNIQUE</code> または <code class="literal">NOT NULL</code> として宣言する必要はありません。 一意でないキーまたは <code class="literal">NULL</code> 値を含むキーへの外部キー参照の処理は、<code class="literal">UPDATE</code> や <code class="literal">DELETE CASCADE</code> などの操作に対して適切に定義されていません。 <code class="literal">UNIQUE</code> (または <code class="literal">PRIMARY</code>) と <code class="literal">NOT NULL</code> の両方であるキーのみを参照する外部キーを使用することをお勧めします。 
          </p><p>
            MySQL は、参照がカラム指定の一部として定義されている<span class="quote">「<span class="quote">「インライン <code class="literal">REFERENCES</code> 仕様」</span>」</span> (SQL 標準で定義されているもの) を解析しますが、無視します。 MySQL は、個別の <code class="literal">FOREIGN KEY</code> 指定の一部として指定されている場合にのみ <code class="literal">REFERENCES</code> 句を受け入れます。 
          </p></div></li><li class="listitem"><p><a name="create-table-reference-option"></a>
          <code class="literal"><em class="replaceable"><code>reference_option</code></em></code>
        </p><p>
          <code class="literal">RESTRICT</code>, <code class="literal">CASCADE</code>, <code class="literal">SET NULL</code>, <code class="literal">NO ACTION</code> および <code class="literal">SET DEFAULT</code> オプションの詳細は、<a class="xref" href="sql-statements.html#create-table-foreign-keys" title="13.1.20.5 FOREIGN KEY の制約">セクション13.1.20.5「FOREIGN KEY の制約」</a> を参照してください。
        </p></li></ul></div><h4><a name="create-table-options"></a>テーブルオプション</h4><p>
      テーブルオプションは、テーブルの動作を最適化するために使用します。 ほとんどの場合は、それらのうちのどれも指定する必要はありません。 特に示されていないかぎり、これらのオプションはすべてのストレージエンジンに適用されます。 特定のストレージエンジンに適用されないオプションは、テーブル定義の一部として受け入れられ、記憶される可能性があります。 それにより、あとで <code class="literal">ALTER TABLE</code> を使用して、別のストレージエンジンを使用するようにテーブルを変換した場合に、このようなオプションが適用されます。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">ENGINE</code>
        </p><p>
          次のテーブルに示すいずれかの名前を使用して、テーブルのストレージエンジンを指定します。 エンジン名は、引用符で囲んでも囲まなくてもかまいません。 引用符で囲まれた名前 <code class="literal">'DEFAULT'</code> は認識されますが、無視されます。 
        </p><div class="informaltable"><table summary="Storage engine names permitted for the ENGINE table option and a description of each engine."><col style="width: 25%"><col style="width: 70%"><thead><tr>
              <th>ストレージエンジン</th>
              <th>説明</th>
            </tr></thead><tbody><tr>
              <td><code class="literal">InnoDB</code></td>
              <td>行ロックと外部キーを備えたトランザクションセーフテーブル。 新しいテーブルのためのデフォルトのストレージエンジン。 MySQL は経験しているが、<code class="literal">InnoDB</code> がはじめてである場合は、<a class="xref" href="innodb-storage-engine.html" title="第 15 章 InnoDB ストレージエンジン">第15章「<i>InnoDB ストレージエンジン</i>」</a>、そのなかでも特に<a class="xref" href="innodb-storage-engine.html#innodb-introduction" title="15.1 InnoDB 入門">セクション15.1「InnoDB 入門」</a>を参照してください。 </td>
            </tr><tr>
              <td><code class="literal">MyISAM</code></td>
              <td>主に読み取り専用または読み取りが大半のワークロードに使用される、バイナリの移植可能なストレージエンジン。 <a class="xref" href="storage-engines.html#myisam-storage-engine" title="16.2 MyISAM ストレージエンジン">セクション16.2「MyISAM ストレージエンジン」</a>を参照してください。 </td>
            </tr><tr>
              <td><code class="literal">MEMORY</code></td>
              <td>このストレージエンジンのデータは、メモリー内にのみ格納されます。 <a class="xref" href="storage-engines.html#memory-storage-engine" title="16.3 MEMORY ストレージエンジン">セクション16.3「MEMORY ストレージエンジン」</a>を参照してください。 </td>
            </tr><tr>
              <td><code class="literal">CSV</code></td>
              <td>カンマ区切り値形式で行を格納するテーブル。 <a class="xref" href="storage-engines.html#csv-storage-engine" title="16.4 CSV ストレージエンジン">セクション16.4「CSV ストレージエンジン」</a>を参照してください。 </td>
            </tr><tr>
              <td><code class="literal">ARCHIVE</code></td>
              <td>アーカイブストレージエンジン。 <a class="xref" href="storage-engines.html#archive-storage-engine" title="16.5 ARCHIVE ストレージエンジン">セクション16.5「ARCHIVE ストレージエンジン」</a>を参照してください。 </td>
            </tr><tr>
              <td><code class="literal">EXAMPLE</code></td>
              <td>サンプルのエンジン。 <a class="xref" href="storage-engines.html#example-storage-engine" title="16.9 EXAMPLE ストレージエンジン">セクション16.9「EXAMPLE ストレージエンジン」</a>を参照してください。 </td>
            </tr><tr>
              <td><code class="literal">FEDERATED</code></td>
              <td>リモートテーブルにアクセスするストレージエンジン。 <a class="xref" href="storage-engines.html#federated-storage-engine" title="16.8 FEDERATED ストレージエンジン">セクション16.8「FEDERATED ストレージエンジン」</a>を参照してください。 </td>
            </tr><tr>
              <td><code class="literal">HEAP</code></td>
              <td>これは <code class="literal">MEMORY</code> のシノニムです。</td>
            </tr><tr>
              <td><code class="literal">MERGE</code></td>
              <td>1 つのテーブルとして使用される <code class="literal">MyISAM</code> テーブルのコレクション。 <code class="literal">MRG_MyISAM</code> とも呼ばれます。 <a class="xref" href="storage-engines.html#merge-storage-engine" title="16.7 MERGE ストレージエンジン">セクション16.7「MERGE ストレージエンジン」</a>を参照してください。 </td>
            </tr><tr>
              <td><code class="literal">NDB</code></td>
              <td>トランザクションと外部キーをサポートする、クラスタ化された、耐障害の、メモリーベースのテーブル。 <code class="literal">NDBCLUSTER</code> とも呼ばれます。 <a class="xref" href="mysql-cluster.html" title="第 23 章 MySQL NDB Cluster 8.0">第23章「<i>MySQL NDB Cluster 8.0</i>」</a>を参照してください。 </td>
            </tr></tbody></table></div><p>
          デフォルトでは、使用できないストレージエンジンが指定されている場合、ステートメントはエラーで失敗します。 この動作をオーバーライドするには、サーバーの SQL モードから <code class="literal">NO_ENGINE_SUBSTITUTION</code> を削除します (<a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a> を参照)。これにより、MySQL では、指定されたエンジンをデフォルトのストレージエンジンに置き換えることができます。 通常、このような場合、これは <code class="literal">default_storage_engine</code> システム変数のデフォルト値である <code class="literal">InnoDB</code> です。 <code class="literal">NO_ENGINE_SUBSTITUTION</code> が無効になっている場合、ストレージエンジンの指定が受け入れられないと警告が発生します。 
        </p></li><li class="listitem"><p>
          <code class="literal">AUTOEXTEND_SIZE</code>
        </p><p>
          テーブルスペースが一杯になったときに <code class="literal">InnoDB</code> がテーブルスペースのサイズを拡張する量を定義します。 MySQL 8.0.23 で導入されました。 設定は 4MB の倍数である必要があります。 デフォルト設定は 0 で、暗黙的なデフォルト動作に従ってテーブルスペースが拡張されます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-tablespace-autoextend-size" title="15.6.3.9 テーブルスペースの AUTOEXTEND_SIZE 構成">セクション15.6.3.9「テーブルスペースの AUTOEXTEND_SIZE 構成」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">AUTO_INCREMENT</code>
        </p><p>
          テーブルの初期の <code class="literal">AUTO_INCREMENT</code> 値。 MySQL 8.0 では、これは <code class="literal">MyISAM</code>、<code class="literal">MEMORY</code>、<code class="literal">InnoDB</code>、および <code class="literal">ARCHIVE</code> テーブルに対して機能します。 <code class="literal">AUTO_INCREMENT</code> テーブルオプションをサポートしていないエンジンの最初の自動インクリメント値を設定するには、テーブルを作成したあとに目的の値より 1 小さい値を持つ<span class="quote">「<span class="quote">ダミーの</span>」</span>行を挿入してから、そのダミーの行を削除します。 
        </p><p>
          <code class="literal">CREATE TABLE</code> ステートメント内の <code class="literal">AUTO_INCREMENT</code> テーブルオプションをサポートするエンジンの場合は、<code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> AUTO_INCREMENT = <em class="replaceable"><code>N</code></em></code> を使用して <code class="literal">AUTO_INCREMENT</code> 値をリセットすることもできます。 この値を、現在カラム内にある最大値より小さく設定することはできません。 
        </p></li><li class="listitem"><p>
          <code class="literal">AVG_ROW_LENGTH</code>
        </p><p>
          テーブルの平均の行の長さの近似値。 これを設定する必要があるのは、可変サイズの行を持つ大きなテーブルの場合だけです。 
        </p><p>
          <code class="literal">MyISAM</code> テーブルを作成すると、MySQL は <code class="literal">MAX_ROWS</code> および <code class="literal">AVG_ROW_LENGTH</code> オプションの積を使用して、結果として得られるテーブルがどれくらいの大きさになるかを判定します。 どちらのオプションも指定しない場合、<code class="literal">MyISAM</code> データおよびインデックスファイルの最大サイズは、デフォルトで 256T バイトになります。 (オペレーティングシステムでその大きさのファイルがサポートされていない場合、テーブルサイズはファイルサイズ制限によって制約されます。) インデックスをより小さく、かつ高速にするためにポインタサイズを小さく維持したいと考えており、実際に大きなファイルが必要でない場合は、<code class="literal">myisam_data_pointer_size</code> システム変数を設定することによってデフォルトのポインタサイズを小さくすることができます。 (<a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>を参照してください。) すべてのテーブルをデフォルトの制限を超えて拡張できるようにしたいと考えており、テーブルが必要以上に少し遅く、かつ大きくなってもかまわない場合は、この変数を設定することによってデフォルトのポインタサイズを大きくすることができます。 この値を 7 に設定すると、最大 65,536T バイトのテーブルサイズが許可されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">[DEFAULT] CHARACTER SET</code>
        </p><p>
          テーブルのデフォルトの文字セットを指定します。 <code class="literal">CHARSET</code> は <code class="literal">CHARACTER SET</code> のシノニムです。 文字セット名が <code class="literal">DEFAULT</code> である場合は、データベース文字セットが使用されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">CHECKSUM</code>
        </p><p>
          MySQL ですべての行のライブチェックサム (つまり、テーブルが変更されると MySQL が自動的に更新するチェックサム) が保持されるようにする場合は、これを 1 に設定します。 これにより、テーブルの更新が少し遅くなりますが、破損したテーブルを見つけることが容易になります。 <code class="literal">CHECKSUM TABLE</code> ステートメントは、このチェックサムをレポートします。 (<code class="literal">MyISAM</code> のみ。) 
        </p></li><li class="listitem"><p>
          <code class="literal">[DEFAULT] COLLATE</code>
        </p><p>
          テーブルのデフォルトの照合を指定します。
        </p></li><li class="listitem"><p>
          <code class="literal">COMMENT</code>
        </p><p>
          テーブルのコメントであり、長さは最大 2048 文字です。
        </p><p>
          <code class="literal"><em class="replaceable"><code>table_option</code></em></code> <code class="literal">COMMENT</code> 句を使用して、テーブルの <code class="literal">InnoDB</code> <code class="literal">MERGE_THRESHOLD</code> 値を設定できます。 <a class="xref" href="innodb-storage-engine.html#index-page-merge-threshold" title="15.8.11 インデックスページのマージしきい値の構成">セクション15.8.11「インデックスページのマージしきい値の構成」</a>を参照してください。 
        </p><p><a name="create-table-comment-ndb-table-options"></a><b>「NDB_TABLE の設定」オプション. </b>
            <a class="indexterm" name="idm45827003797920"></a> <code class="literal">NDB</code> テーブルを作成する <code class="literal">CREATE TABLE</code> のまたは変更する <code class="literal">ALTER TABLE</code> ステートメントのテーブルコメントは、<code class="literal">NDB_TABLE</code> オプション <code class="literal">NOLOGGING</code>, <code class="literal">READ_BACKUP</code>, <code class="literal">PARTITION_BALANCE</code>、または <code class="literal">FULLY_REPLICATED</code> の 1 つから 4 つを指定するのに使用でき、カンマ区切り (必要ならば) の名前 - 値ペアのセットとして、引用符付きテキストで始まる文字列 <code class="literal">NDB_TABLE=</code> の直後に続きます。 この構文を使用したステートメントの例を次に示します (強調されたテキスト): 
          </p><pre class="programlisting">CREATE TABLE t1 (
    c1 INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    c2 VARCHAR(100),
    c3 VARCHAR(100) )
ENGINE=NDB
<span class="emphasis"><em>COMMENT="NDB_TABLE=READ_BACKUP=0,PARTITION_BALANCE=FOR_RP_BY_NODE"</em></span>;
</pre><p>
          引用符で囲まれた文字列内ではスペースを使用できません。 文字列では大文字と小文字は区別されません。 
        </p><p>
          コメントは、<code class="literal">SHOW CREATE TABLE</code> の出力の一部として表示されます。 コメントのテキストは、MySQL Information Schema <code class="literal">TABLES</code> テーブルの TABLE_COMMENT カラムとしても使用できます。 
        </p><p>
          このコメント構文は、<code class="literal">NDB</code> テーブルの <code class="literal">ALTER TABLE</code> ステートメントでもサポートされています。 <code class="literal">ALTER TABLE</code> で使用されるテーブルコメントは、テーブルにある可能性のある既存のコメントを置き換えることに注意してください。 
        </p><p>
          テーブルコメントでの <code class="literal">MERGE_THRESHOLD</code> オプションの設定は、<code class="literal">NDB</code> テーブルではサポートされていません (無視されます)。
        </p><p>
          完全な構文情報および例は、<a class="xref" href="sql-statements.html#create-table-ndb-table-comment-options" title="13.1.20.11 NDB_TABLE オプションの設定">セクション13.1.20.11「NDB_TABLE オプションの設定」</a> を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">COMPRESSION</code>
        </p><p>
          <code class="literal">InnoDB</code> テーブルのページレベル圧縮に使用される圧縮アルゴリズム。 サポートされている値は、<code class="literal">Zlib</code>、<code class="literal">LZ4</code> および <code class="literal">None</code> です。 <code class="literal">COMPRESSION</code> 属性は、透過的ページ圧縮機能とともに導入されました。 ページ圧縮は、<a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースに存在する <code class="literal">InnoDB</code> テーブルでのみサポートされており、スパースファイルおよびホールパンチをサポートする Linux および Windows プラットフォームでのみ使用できます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-page-compression" title="15.9.2 InnoDB ページ圧縮">セクション15.9.2「InnoDB ページ圧縮」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">CONNECTION</code>
        </p><p>
          <code class="literal">FEDERATED</code> テーブルの接続文字列。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            古いバージョンの MySQL は、接続文字列に <code class="literal">COMMENT</code> オプションを使用していました。
          </p></div></li><li class="listitem"><p>
          <code class="literal">DATA DIRECTORY</code>、<code class="literal">INDEX DIRECTORY</code>
        </p><p>
          <code class="literal">InnoDB</code> の場合、<code class="literal">DATA DIRECTORY='<em class="replaceable"><code>directory</code></em>'</code>句を使用すると、データディレクトリ外にテーブルを作成できます。 <code class="literal">DATA DIRECTORY</code> 句を使用するには、<code class="literal">innodb_file_per_table</code> 変数を有効にする必要があります。 完全なディレクトリパスを指定する必要があります。 MySQL 8.0.21 では、指定されたディレクトリは <code class="literal">InnoDB</code> で認識されている必要があります。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-create-table-external" title="15.6.1.2 外部でのテーブルの作成">セクション15.6.1.2「外部でのテーブルの作成」</a>を参照してください。 
        </p><p>
          <code class="literal">MyISAM</code> テーブルを作成する場合は、<code class="literal">DATA DIRECTORY='<em class="replaceable"><code>directory</code></em>'</code> 句、<code class="literal">INDEX DIRECTORY='<em class="replaceable"><code>directory</code></em>'</code> 句、またはその両方を使用できます。 これらは、それぞれ <code class="literal">MyISAM</code> テーブルのデータファイルとインデックスファイルを配置する場所を指定します。 <code class="literal">InnoDB</code> テーブルとは異なり、<code class="literal">DATA DIRECTORY</code> または <code class="literal">INDEX DIRECTORY</code> オプションで <code class="literal">MyISAM</code> テーブルを作成する場合、MySQL はデータベース名に対応するサブディレクトリを作成しません。 各ファイルは、指定されたディレクトリ内に作成されます。 
        </p><p>
          <code class="literal">DATA DIRECTORY</code> または <code class="literal">INDEX DIRECTORY</code> テーブルオプションを使用するには、<code class="literal">FILE</code> 権限が必要です。
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
            テーブルレベルの <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> オプションは、パーティション化されたテーブルでは無視されます。 (Bug #32091) 
          </p></div><p>
          これらのオプションは、<code class="option">--skip-symbolic-links</code> オプションを使用していない場合にのみ機能します。 また、オペレーティングシステムにも、機能するスレッドに対して安全な <code class="literal">realpath()</code> 呼び出しが存在する必要があります。 詳細は、<a class="xref" href="optimization.html#symbolic-links-to-tables" title="8.12.2.2 Unix 上の MyISAM へのシンボリックリンクの使用">セクション8.12.2.2「Unix 上の MyISAM へのシンボリックリンクの使用」</a>を参照してください。 
        </p><p>
          <code class="literal">MyISAM</code> テーブルが <code class="literal">DATA DIRECTORY</code> オプションなしで作成される場合、<code class="filename">.MYD</code> ファイルがデータベースディレクトリ内に作成されます。 デフォルトでは、<code class="literal">MyISAM</code> が既存の <code class="filename">.MYD</code> ファイルを検出した場合、そのファイルを上書きします。 <code class="literal">INDEX DIRECTORY</code> オプションを指定せずに作成されたテーブルについて、<code class="filename">.MYI</code> ファイルに同じことが当てはまります。 この動作を抑制するには、<code class="option">--keep_files_on_create</code> オプションを使用してサーバーを起動します。この場合、<code class="literal">MyISAM</code> は既存のファイルを上書きせず、かわりにエラーを返します。 
        </p><p>
          <code class="literal">DATA DIRECTORY</code> または <code class="literal">INDEX DIRECTORY</code> オプションを使用して <code class="literal">MyISAM</code> テーブルが作成され、既存の <code class="filename">.MYD</code> または <code class="filename">.MYI</code> ファイルが見つかった場合、<code class="literal">MyISAM</code> は常にエラーを返し、指定されたディレクトリ内のファイルを上書きしません。
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
            <code class="literal">DATA DIRECTORY</code> または <code class="literal">INDEX DIRECTORY</code> では、MySQL データディレクトリを含むパス名を使用できません。 これには、パーティション化されたテーブルや個々のテーブルパーティションが含まれます。 (Bug #32167 を参照してください。) 
          </p></div></li><li class="listitem"><p>
          <code class="literal">DELAY_KEY_WRITE</code>
        </p><p>
          テーブルのキー更新をテーブルが閉じられるまで遅らせる場合は、これを 1 に設定します。 <a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>にある <code class="literal">delay_key_write</code> システム変数の説明を参照してください。 (<code class="literal">MyISAM</code> のみ。) 
        </p></li><li class="listitem"><p>
          <code class="literal">ENCRYPTION</code>
        </p><p>
          <code class="literal">ENCRYPTION</code> 句は、<code class="literal">InnoDB</code> テーブルのページレベルのデータ暗号化を有効または無効にします。 暗号化を有効にする前に、キーリングプラグインをインストールして構成する必要があります。 MySQL 8.0.16 より前では、<code class="literal">ENCRYPTION</code> 句は file-per-table テーブルスペースにテーブルを作成する場合にのみ指定できます。 MySQL 8.0.16 では、一般的なテーブルスペースにテーブルを作成するときに <code class="literal">ENCRYPTION</code> 句を指定することもできます。 
        </p><p>
          MySQL 8.0.16 では、<code class="literal">ENCRYPTION</code> 句が指定されていない場合、テーブルはデフォルトのスキーマ暗号化を継承します。 <code class="literal">table_encryption_privilege_check</code> 変数が有効になっている場合、デフォルトのスキーマ暗号化とは異なる <code class="literal">ENCRYPTION</code> 句設定を使用してテーブルを作成するには、<code class="literal">TABLE_ENCRYPTION_ADMIN</code> 権限が必要です。 一般的なテーブルスペースにテーブルを作成する場合、テーブルとテーブルスペースの暗号化は一致する必要があります。 
        </p><p>
          MySQL 8.0.16 の時点では、暗号化をサポートしていないストレージエンジンを使用する場合、<code class="literal">'N'</code>または<code class="literal">''</code>以外の値で <code class="literal">ENCRYPTION</code> 句を指定することはできません。 以前は、条項は受け入れられました。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-data-encryption" title="15.13 InnoDB 保存データ暗号化">セクション15.13「InnoDB 保存データ暗号化」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">ENGINE_ATTRIBUTE</code> および <code class="literal">SECONDARY_ENGINE_ATTRIBUTE</code> オプション (MySQL 8.0.21 の時点で使用可能) を使用して、プライマリおよびセカンダリストレージエンジンのテーブル属性を指定します。 オプションは、将来の使用のために予約されています。 
        </p><p>
          許可される値は、有効な <code class="literal">JSON</code> ドキュメントまたは空の文字列 ('') を含む文字列リテラルです。 無効な <code class="literal">JSON</code> が拒否されました。 
        </p><pre class="programlisting">CREATE TABLE t1 (c1 INT) ENGINE_ATTRIBUTE='{"<em class="replaceable"><code>key</code></em>":"<em class="replaceable"><code>value</code></em>"}';</pre><p>
          <code class="literal">ENGINE_ATTRIBUTE</code> および <code class="literal">SECONDARY_ENGINE_ATTRIBUTE</code> の値は、エラーなしで繰り返すことができます。 この場合、最後に指定した値が使用されます。 
        </p><p>
          <code class="literal">ENGINE_ATTRIBUTE</code> および <code class="literal">SECONDARY_ENGINE_ATTRIBUTE</code> の値は、サーバーによってチェックされず、テーブルストレージエンジンが変更されたときにもクリアされません。
        </p></li><li class="listitem"><p>
          <code class="literal">INSERT_METHOD</code>
        </p><p>
          <code class="literal">MERGE</code> テーブルにデータを挿入する場合は、<code class="literal">INSERT_METHOD</code> を使用して、行を挿入するテーブルを指定する必要があります。 <code class="literal">INSERT_METHOD</code> は、<code class="literal">MERGE</code> テーブルにのみ役立つオプションです。 最初または最後のテーブルに挿入するには <code class="literal">FIRST</code> または <code class="literal">LAST</code> の値を、挿入されないようにするには <code class="literal">NO</code> の値を使用します。 <a class="xref" href="storage-engines.html#merge-storage-engine" title="16.7 MERGE ストレージエンジン">セクション16.7「MERGE ストレージエンジン」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">KEY_BLOCK_SIZE</code>
        </p><p>
          <code class="literal">MyISAM</code> テーブルの場合、<code class="literal">KEY_BLOCK_SIZE</code> はオプションで、インデックスキーブロックに使用するサイズをバイト単位で指定します。 この値はヒントとして扱われます。必要に応じて、異なるサイズが使用される可能性があります。 個々のインデックス定義に指定された <code class="literal">KEY_BLOCK_SIZE</code> 値は、テーブルレベルの <code class="literal">KEY_BLOCK_SIZE</code> 値をオーバーライドします。 
        </p><p>
          <code class="literal">InnoDB</code> テーブルの場合、<code class="literal">KEY_BLOCK_SIZE</code> は <a class="link" href="glossary.html#glos_compression" title="圧縮">compressed</a> <code class="literal">InnoDB</code> テーブルに使用する <a class="link" href="glossary.html#glos_page" title="ページ">page</a> サイズを KB 単位で指定します。 <code class="literal">KEY_BLOCK_SIZE</code> 値は、ヒントとして処理されます。<code class="literal">InnoDB</code> では、必要に応じて異なるサイズが使用される可能性があります。 <code class="literal">KEY_BLOCK_SIZE</code> は、<code class="literal">innodb_page_size</code> 値以下にのみできます。 値 0 は、<code class="literal">innodb_page_size</code> 値の半分であるデフォルトの圧縮済みページサイズを表します。 <code class="literal">innodb_page_size</code> に応じて、可能な <code class="literal">KEY_BLOCK_SIZE</code> 値には 0、1、2、4、8 および 16 が含まれます。 詳しくは<a class="xref" href="innodb-storage-engine.html#innodb-table-compression" title="15.9.1 InnoDB テーブルの圧縮">セクション15.9.1「InnoDB テーブルの圧縮」</a>をご覧ください。 
        </p><p>
          <code class="literal">InnoDB</code> テーブルに <code class="literal">KEY_BLOCK_SIZE</code> を指定する場合、Oracle では <code class="literal">innodb_strict_mode</code> を有効にすることをお薦めします。 <code class="literal">innodb_strict_mode</code> が有効な場合、無効な <code class="literal">KEY_BLOCK_SIZE</code> 値を指定するとエラーが返されます。 <code class="literal">innodb_strict_mode</code> が無効な場合、無効な <code class="literal">KEY_BLOCK_SIZE</code> 値は警告になり、<code class="literal">KEY_BLOCK_SIZE</code> オプションは無視されます。 
        </p><p>
          <code class="literal">SHOW TABLE STATUS</code> に対するレスポンスの <code class="literal">Create_options</code> カラムには、<code class="literal">SHOW CREATE TABLE</code> と同様に、テーブルで使用される実際の <code class="literal">KEY_BLOCK_SIZE</code> がレポートされます。
        </p><p>
          <code class="literal">InnoDB</code> では、テーブルレベルでの <code class="literal">KEY_BLOCK_SIZE</code> のみがサポートされます。
        </p><p>
          <code class="literal">KEY_BLOCK_SIZE</code> は、32KB および 64KB の <code class="literal">innodb_page_size</code> 値ではサポートされていません。 <code class="literal">InnoDB</code> テーブル圧縮では、これらのページサイズはサポートされていません。 
        </p><p>
          <code class="literal">InnoDB</code> では、一時テーブルの作成時に <code class="literal">KEY_BLOCK_SIZE</code> オプションをサポートしていません。
        </p></li><li class="listitem"><p>
          <code class="literal">MAX_ROWS</code>
        </p><p>
          テーブル内に格納することを予定している行の最大数。 これは強い制限値ではなく、どちらかと言うと、テーブルが少なくともこの行数を格納できる必要があるという、ストレージエンジンへのヒントです。 
        </p><a class="indexterm" name="idm45827003646112"></a><a class="indexterm" name="idm45827003644336"></a><a class="indexterm" name="idm45827003642560"></a><a class="indexterm" name="idm45827003640512"></a><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
            <code class="literal">NDB</code> テーブルで <code class="literal">MAX_ROWS</code> を使用してテーブルパーティションの数を制御することは非推奨です。 下位互換性のために新しいバージョンでも引き続きサポートされますが、将来のリリースでは削除される予定です。 かわりに PARTITION_BALANCE を使用してください。<a class="xref" href="sql-statements.html#create-table-comment-ndb-table-options" title="「NDB_TABLE の設定」オプション">「NDB_TABLE の設定」オプション</a> を参照してください。 
          </p></div><p>
          <code class="literal">NDB</code> ストレージエンジンは、この値を最大値として扱います。 非常に大きな「NDB Cluster」テーブル (数百万行を含む) を作成する場合は、このオプションを使用して、<code class="literal">MAX_ROWS = 2 * <em class="replaceable"><code>rows</code></em></code> を設定することで、<code class="literal">NDB</code> がテーブルの主キーのハッシュの格納に使用するハッシュテーブルに十分な数の索引スロットを割り当てるようにする必要があります (<em class="replaceable"><code>rows</code></em> は、テーブルに挿入する予定の行数です)。 
        </p><p>
          <code class="literal">MAX_ROWS</code> の最大値は 4294967295 です。これを超える値は、この制限に切り捨てられます。
        </p></li><li class="listitem"><p>
          <code class="literal">MIN_ROWS</code>
        </p><p>
          テーブル内に格納することを予定している行の最小数。 <code class="literal">MEMORY</code> ストレージエンジンは、このオプションをメモリー使用に関するヒントとして使用します。 
        </p></li><li class="listitem"><p>
          <code class="literal">PACK_KEYS</code>
        </p><p>
          <code class="literal">MyISAM</code> テーブルでのみ有効です。 インデックスを小さくする場合は、このオプションを 1 に設定します。 通常は、これによって更新は遅く、読み取りは高速になります。 このオプションを 0 に設定すると、キーのすべてのパッキングが無効になります。 これを <code class="literal">DEFAULT</code> に設定すると、長い <code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、<code class="literal">BINARY</code>、または <code class="literal">VARBINARY</code> カラムのみをパックするようストレージエンジンに指示します。 
        </p><p>
          <code class="literal">PACK_KEYS</code> を使用しない場合、デフォルトでは文字列をパックしますが、数値はパックしません。 <code class="literal">PACK_KEYS=1</code> を使用した場合は、数値もパックされます。 
        </p><p>
          2 進数のキーをパックする場合、MySQL は次のプリフィクス圧縮を使用します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              前のキーの何バイトが次のキーと同じであるかを示すために、すべてのキーに 1 バイトが余分に必要になります。
            </p></li><li class="listitem"><p>
              行へのポインタは、圧縮率を向上させるために、キーの直後に高位バイトが先に来る順序で格納されます。
            </p></li></ul></div><p>
          つまり、2 つの連続した行に等しいキーが多数存在する場合は、次の<span class="quote">「<span class="quote">同じ</span>」</span>キーはすべて、通常 (行へのポインタを含め) 2 バイトしか占有しません。 これを、次のキーが <code class="literal">storage_size_for_key + pointer_size</code> (ここで、ポインタサイズは通常 4) を占有する通常のケースと比較してください。 逆に言うと、プリフィクス圧縮から大きな利点が得られるのは、同じ数値が多数存在する場合だけです。 すべてのキーが完全に異なっている場合は、そのキーが <code class="literal">NULL</code> 値を持つことができるキーでないかぎり、キーあたり 1 バイト多く使用されます。 (この場合、パックされたキーの長さは、キーが <code class="literal">NULL</code> であるかどうかをマークするために使用されるのと同じバイトに格納されます。) 
        </p></li><li class="listitem"><p>
          <code class="literal">PASSWORD</code>
        </p><p>
          このオプションは使用されません。
        </p></li><li class="listitem"><p>
          <code class="literal">ROW_FORMAT</code>
        </p><p>
          行が格納される物理フォーマットを定義します。
        </p><p>
          <a class="link" href="glossary.html#glos_strict_mode" title="厳密モード">strict mode</a> を無効にしてテーブルを作成する場合、指定した行フォーマットがサポートされていないと、ストレージエンジンのデフォルトの行フォーマットが使用されます。 テーブルの実際の行形式は、<code class="literal">SHOW TABLE STATUS</code> に応じて <code class="literal">Row_format</code> カラムにレポートされます。 <code class="literal">Create_options</code> カラムには、<code class="literal">SHOW CREATE TABLE</code> と同様に、<code class="literal">CREATE TABLE</code> ステートメントで指定された行形式が表示されます。 
        </p><p>
          行形式の選択は、テーブルに使用されるストレージエンジンによって異なります。
        </p><p>
          <code class="literal">InnoDB</code> テーブルの場合:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              デフォルトの行フォーマットは、<code class="literal">DYNAMIC</code> のデフォルト設定を持つ <code class="literal">innodb_default_row_format</code> によって定義されます。 デフォルトの行フォーマットは、<code class="literal">ROW_FORMAT</code> オプションが定義されていない場合、または <code class="literal">ROW_FORMAT=DEFAULT</code> が使用されている場合に使用されます。 
            </p><p>
              <code class="literal">ROW_FORMAT</code> オプションが定義されていない場合、または <code class="literal">ROW_FORMAT=DEFAULT</code> が使用されている場合は、テーブルを再構築する操作によって、テーブルの行形式も <code class="literal">innodb_default_row_format</code> で定義されているデフォルトに暗黙的に変更されます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-row-format-defining" title="テーブルの行形式の定義">テーブルの行形式の定義</a>を参照してください。 
            </p></li><li class="listitem"><p>
              データ型 (特に <code class="literal">BLOB</code> 型) の <code class="literal">InnoDB</code> 記憶域をより効率的にするには、<code class="literal">DYNAMIC</code> を使用します。 <code class="literal">DYNAMIC</code> の行形式に関連する要件については、<a class="xref" href="innodb-storage-engine.html#innodb-row-format-dynamic" title="DYNAMIC 行フォーマット">DYNAMIC 行フォーマット</a> を参照してください。 
            </p></li><li class="listitem"><p>
              <code class="literal">InnoDB</code> テーブルの圧縮を有効にするには、<code class="literal">ROW_FORMAT=COMPRESSED</code> を指定します。 一時テーブルを作成する場合、<code class="literal">ROW_FORMAT=COMPRESSED</code> オプションはサポートされません。 <code class="literal">COMPRESSED</code> の行形式に関連する要件については、<a class="xref" href="innodb-storage-engine.html#innodb-compression" title="15.9 InnoDB のテーブルおよびページの圧縮">セクション15.9「InnoDB のテーブルおよびページの圧縮」</a> を参照してください。 
            </p></li><li class="listitem"><p>
              以前のバージョンの MySQL で使用されていた行形式は、<code class="literal">REDUNDANT</code> の行形式を指定することで引き続きリクエストできます。
            </p></li><li class="listitem"><p>
              デフォルト以外の <code class="literal">ROW_FORMAT</code> 句を指定する場合は、<code class="literal">innodb_strict_mode</code> 構成オプションも有効にすることを考慮してください。
            </p></li><li class="listitem"><p>
              <code class="literal">ROW_FORMAT=FIXED</code> はサポートされていません。 <code class="literal">innodb_strict_mode</code> が無効になっているときに <code class="literal">ROW_FORMAT=FIXED</code> が指定された場合、<code class="literal">InnoDB</code> は警告を発行し、<code class="literal">ROW_FORMAT=DYNAMIC</code> とみなします。 <code class="literal">innodb_strict_mode</code> が有効になっている間に <code class="literal">ROW_FORMAT=FIXED</code> が指定されている場合 (デフォルト)、<code class="literal">InnoDB</code> はエラーを返します。 
            </p></li><li class="listitem"><p>
              <code class="literal">InnoDB</code> 行フォーマットの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="15.10 InnoDB の行フォーマット">セクション15.10「InnoDB の行フォーマット」</a>を参照してください。
            </p></li></ul></div><p>
          <code class="literal">MyISAM</code> テーブルの場合は、このオプション値を、静的行フォーマットまたは可変長行フォーマットを示す <code class="literal">FIXED</code> または <code class="literal">DYNAMIC</code> に設定できます。<span class="command"><strong>myisampack</strong></span> は、この型を <code class="literal">COMPRESSED</code> に設定します。 <a class="xref" href="storage-engines.html#myisam-table-formats" title="16.2.3 MyISAM テーブルのストレージフォーマット">セクション16.2.3「MyISAM テーブルのストレージフォーマット」</a>を参照してください。 
        </p><p>
          <code class="literal">NDB</code> テーブルの場合、デフォルトの <code class="literal">ROW_FORMAT</code> は <code class="literal">DYNAMIC</code> です。
        </p></li><li class="listitem"><p>
          <code class="literal">STATS_AUTO_RECALC</code>
        </p><p>
          <code class="literal">InnoDB</code> テーブルの<a class="link" href="glossary.html#glos_persistent_statistics" title="永続的統計">永続的統計</a>を自動的に再計算するかどうかを指定します。 値 <code class="literal">DEFAULT</code> を指定すると、テーブルの永続的統計設定は <code class="literal">innodb_stats_auto_recalc</code> 構成オプションによって決定されます。 値 <code class="literal">1</code> を指定すると、統計は、テーブル内のデータの 10% が変更されたときに再計算されます。 値 <code class="literal">0</code> は、このテーブルの自動再計算が行われないようにします。この設定の場合、テーブルへの大幅な変更を行なったあとに統計を再計算するには、<code class="literal">ANALYZE TABLE</code> ステートメントを発行します。 永続的統計機能の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="15.8.10.1 永続的オプティマイザ統計のパラメータの構成">セクション15.8.10.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">STATS_PERSISTENT</code>
        </p><p>
          <code class="literal">InnoDB</code> テーブルの<a class="link" href="glossary.html#glos_persistent_statistics" title="永続的統計">永続的統計</a>を有効にするかどうかを指定します。 値 <code class="literal">DEFAULT</code> を指定すると、テーブルの永続的統計設定は <code class="literal">innodb_stats_persistent</code> 構成オプションによって決定されます。 値 <code class="literal">1</code> がテーブルの永続的統計を有効にするのに対して、値 <code class="literal">0</code> はこの機能を無効にします。 <code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントを使用して永続的統計を有効にしたあと、代表的なデータのテーブルへのロード後に統計を計算するには、<code class="literal">ANALYZE TABLE</code> ステートメントを発行します。 永続的統計機能の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="15.8.10.1 永続的オプティマイザ統計のパラメータの構成">セクション15.8.10.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">STATS_SAMPLE_PAGES</code>
        </p><p>
          インデックス付きカラムのカーディナリティーやその他の統計 (<code class="literal">ANALYZE TABLE</code> によって計算される統計など) を推定するときにサンプリングするインデックスページの数。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="15.8.10.1 永続的オプティマイザ統計のパラメータの構成">セクション15.8.10.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">TABLESPACE</code>
        </p><p>
          <code class="literal">TABLESPACE</code> 句を使用すると、既存の一般テーブルスペース、file-per-table テーブルスペースまたはシステムテーブルスペースにテーブルを作成できます。
        </p><pre class="programlisting">CREATE TABLE <em class="replaceable"><code>tbl_name</code></em> ... TABLESPACE [=] <em class="replaceable"><code>tablespace_name</code></em></pre><p>
          <code class="literal">TABLESPACE</code> 句を使用する前に、指定する一般テーブルスペースが存在している必要があります。 一般テーブルスペースの詳細は、<a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="15.6.3.3 一般テーブルスペース">セクション15.6.3.3「一般テーブルスペース」</a> を参照してください。 
        </p><p>
          <code class="literal"><em class="replaceable"><code>tablespace_name</code></em></code> は、大/小文字を区別する識別子です。 引用符で囲むことも、引用符で囲まないこともできます。 スラッシュ文字 (<span class="quote">「<span class="quote">/</span>」</span>) は使用できません。 <span class="quote">「<span class="quote">innodb_</span>」</span>で始まる名前は、特別な用途のために予約されています。 
        </p><p>
          システムテーブルスペースにテーブルを作成するには、テーブルスペース名として <code class="literal">innodb_system</code> を指定します。
        </p><pre class="programlisting">CREATE TABLE <em class="replaceable"><code>tbl_name</code></em> ... TABLESPACE [=] innodb_system</pre><p>
          <code class="literal">TABLESPACE [=] innodb_system</code> を使用すると、<code class="literal">innodb_file_per_table</code> の設定に関係なく、圧縮されていない行形式のテーブルをシステムテーブルスペースに配置できます。 たとえば、<code class="literal">TABLESPACE [=] innodb_system</code> を使用して、<code class="literal">ROW_FORMAT=DYNAMIC</code> を含むテーブルをシステムテーブルスペースに追加できます。 
        </p><p>
          file-per-table テーブルスペースにテーブルを作成するには、テーブルスペース名として <code class="literal">innodb_file_per_table</code> を指定します。
        </p><pre class="programlisting">CREATE TABLE <em class="replaceable"><code>tbl_name</code></em> ... TABLESPACE [=] innodb_file_per_table</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">innodb_file_per_table</code> が有効な場合、<code class="literal">InnoDB</code> file-per-table テーブルスペースを作成するために <code class="literal">TABLESPACE=innodb_file_per_table</code> を指定する必要はありません。 <code class="literal">InnoDB</code> テーブルは、<code class="literal">innodb_file_per_table</code> が有効な場合、デフォルトで file-per-table テーブルスペースに作成されます。 
          </p></div><p>
          <code class="literal">DATA DIRECTORY</code> 句は <code class="literal">CREATE TABLE ... TABLESPACE=innodb_file_per_table</code> では許可されますが、それ以外の場合は <code class="literal">TABLESPACE</code> 句との組合せでの使用はサポートされていません。 MySQL 8.0.21 では、<code class="literal">DATA DIRECTORY</code> 句で指定されたディレクトリは <code class="literal">InnoDB</code> で認識されている必要があります。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-create-table-external-data-directory" title="DATA DIRECTORY 句の使用">DATA DIRECTORY 句の使用</a>を参照してください。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">CREATE TEMPORARY TABLE</code> での <code class="literal">TABLESPACE = innodb_file_per_table</code> 句および <code class="literal">TABLESPACE = innodb_temporary</code> 句のサポートは、MySQL 8.0.13 で非推奨になりました。MySQL の将来のバージョンで削除される予定です。
          </p></div><p>
          <code class="literal">STORAGE</code> テーブルオプションは、<code class="literal">NDB</code> テーブルでのみ使用されます。 <code class="literal">STORAGE</code> は、使用される記憶域のタイプ (ディスクまたはメモリー) を決定し、<code class="literal">DISK</code> または <code class="literal">MEMORY</code> のいずれかになります。 
        </p><p>
          <code class="literal">TABLESPACE ... STORAGE DISK</code> は、「NDB Cluster ディスクデータ」テーブルスペースにテーブルを割り当てます。 テーブルスペースは、<code class="literal">CREATE TABLESPACE</code> を使用してすでに作成されている必要があります。 詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data" title="23.5.10 NDB Cluster ディスクデータテーブル">セクション23.5.10「NDB Cluster ディスクデータテーブル」</a>を参照してください。 
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
            <code class="literal">STORAGE</code> 句を、<code class="literal">TABLESPACE</code> 句のない <code class="literal">CREATE TABLE</code> ステートメントで使用することはできません。
          </p></div></li><li class="listitem"><p>
          <code class="literal">UNION</code>
        </p><p>
          同一の <code class="literal">MyISAM</code> テーブルのコレクションにアクセスするために使用します。 これは、<code class="literal">MERGE</code> テーブルでのみ機能します。 <a class="xref" href="storage-engines.html#merge-storage-engine" title="16.7 MERGE ストレージエンジン">セクション16.7「MERGE ストレージエンジン」</a>を参照してください。 
        </p><p>
          <code class="literal">MERGE</code> テーブルにマップするテーブルに対する <code class="literal">SELECT</code>、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> 権限が必要です。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            以前は、使用されるすべてのテーブルが <code class="literal">MERGE</code> テーブル自体と同じデータベース内に存在する必要がありました。 この制限は適用されなくなりました。 
          </p></div></li></ul></div><h4><a name="create-table-partitioning"></a>テーブルのパーティション化</h4><p>
      <em class="replaceable"><code>partition_options</code></em> を使用すると、<code class="literal">CREATE TABLE</code> で作成されたテーブルのパーティション化を制御できます。
    </p><p>
      このセクションの最初にある <em class="replaceable"><code>partition_options</code></em> の構文に示されているすべてのオプションが、すべてのパーティショニングタイプに使用できるわけではありません。 各タイプに固有の情報については、次の個々のタイプのリストを参照してください。また、MySQL でのパーティション化の動作や使用に関するより詳細な情報、および MySQL のパーティション化に関連したテーブル作成やその他のステートメントの追加の例については、<a class="xref" href="partitioning.html" title="第 24 章 パーティション化">第24章「<i>パーティション化</i>」</a>を参照してください。 
    </p><p>
      パーティションに対しては変更、マージ、テーブルへの追加、およびテーブルからの削除が可能です。 これらのタスクを実行するための MySQL ステートメントに関する基本情報については、<a class="xref" href="sql-statements.html#alter-table" title="13.1.9 ALTER TABLE ステートメント">セクション13.1.9「ALTER TABLE ステートメント」</a>を参照してください。 より詳細な説明および例については、<a class="xref" href="partitioning.html#partitioning-management" title="24.3 パーティション管理">セクション24.3「パーティション管理」</a>を参照してください。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">PARTITION BY</code>
        </p><p>
          <em class="replaceable"><code>partition_options</code></em> 句が使用される場合、この句は <code class="literal">PARTITION BY</code> で始まります。 この句には、パーティションを決定するために使用される関数が含まれています。この関数は、1 から <em class="replaceable"><code>num</code></em> までの範囲の整数値を返します。ここで、<em class="replaceable"><code>num</code></em> はパーティションの数です。 (テーブルに含めることのできるユーザー定義パーティションの最大数は 1024 です。この最大数には、このセクションのあとの方で説明されているサブパーティションの数が含まれています。) 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">PARTITION BY</code> 句で使用される式 (<em class="replaceable"><code>expr</code></em>) は、作成されているテーブルにはないどのカラムも参照できません。このような参照は明確に禁止されており、そのステートメントがエラーで失敗する原因になります。 (Bug #29444) 
          </p></div></li><li class="listitem"><p>
          <code class="literal">HASH(<em class="replaceable"><code>expr</code></em>)</code>
        </p><p>
          1 つ以上のカラムをハッシュして、行を配置および検索するためのキーを作成します。<em class="replaceable"><code>expr</code></em> は、1 つ以上のテーブルのカラムを使用する式です。 これは、1 つの整数値が得られる任意の有効な MySQL 式 (MySQL 関数を含む) にすることができます。 たとえば、次はどちらも、<code class="literal">PARTITION BY HASH</code> を使用した有効な <code class="literal">CREATE TABLE</code> ステートメントです。 
        </p><pre class="programlisting">CREATE TABLE t1 (col1 INT, col2 CHAR(5))
    PARTITION BY HASH(col1);

CREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATETIME)
    PARTITION BY HASH ( YEAR(col3) );
</pre><p>
          <code class="literal">PARTITION BY HASH</code> では、<code class="literal">VALUES LESS THAN</code> または <code class="literal">VALUES IN</code> のどちらの句も使用できません。
        </p><p>
          <code class="literal">PARTITION BY HASH</code> は、<em class="replaceable"><code>expr</code></em> をパーティションの数で割った余り (つまり、法) を使用します。 例および追加情報については、<a class="xref" href="partitioning.html#partitioning-hash" title="24.2.4 HASH パーティショニング">セクション24.2.4「HASH パーティショニング」</a>を参照してください。 
        </p><p>
          <code class="literal">LINEAR</code> キーワードには、いくぶん異なるアルゴリズムが必要になります。 この場合、行が格納されるパーティションの数は、1 つ以上の論理的な <code class="literal">AND</code> 演算の結果として計算されます。 線形ハッシュの説明および例については、<a class="xref" href="partitioning.html#partitioning-linear-hash" title="24.2.4.1 LINEAR HASH パーティショニング">セクション24.2.4.1「LINEAR HASH パーティショニング」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">KEY(<em class="replaceable"><code>column_list</code></em>)</code>
        </p><p>
          これは <code class="literal">HASH</code> と似ていますが、偶数のデータ分散を保証するために、MySQL がハッシュ関数を提供する点が異なります。 <em class="replaceable"><code>column_list</code></em> 引数は、単純に 1 つ以上のテーブルカラム (最大 16 個) のリストです。 この例は、4 つのパーティションを持つ、キーによってパーティション化された単純なテーブルを示しています。 
        </p><pre class="programlisting">CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE)
    PARTITION BY KEY(col3)
    PARTITIONS 4;
</pre><p>
          キーによってパーティション化されたテーブルの場合は、<code class="literal">LINEAR</code> キーワードを使用して線形パーティション化を採用できます。 これには、<code class="literal">HASH</code> によってパーティション化されたテーブルの場合と同じ効果があります。 つまり、パーティション番号は法ではなく、<code class="literal">&amp;</code> 演算子を使用して見つけられます (詳細は、<a class="xref" href="partitioning.html#partitioning-linear-hash" title="24.2.4.1 LINEAR HASH パーティショニング">セクション24.2.4.1「LINEAR HASH パーティショニング」</a>および<a class="xref" href="partitioning.html#partitioning-key" title="24.2.5 KEY パーティショニング">セクション24.2.5「KEY パーティショニング」</a>を参照してください)。 この例では、キーによる線形パーティション化を使用して 5 つのパーティション間でデータを分散させます。 
        </p><pre class="programlisting">CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE)
    PARTITION BY LINEAR KEY(col3)
    PARTITIONS 5;
</pre><p>
          <code class="literal">ALGORITHM={1 | 2}</code> オプションは、<code class="literal">[SUB]PARTITION BY [LINEAR] KEY</code> でサポートされます。 <code class="literal">ALGORITHM=1</code> を指定すると、サーバーは MySQL 5.1 と同じキーハッシュ関数を使用します。<code class="literal">ALGORITHM=2</code> は、サーバーが、MySQL 5.5 以降で実装され、<code class="literal">KEY</code> によってパーティション化された新しいテーブルに対してデフォルトで使用されるキーハッシュ関数を採用することを示します。 (MySQL 5.5 以降で採用されたキーハッシュ関数によって作成されたパーティション化されたテーブルを MySQL 5.1 サーバーで使用することはできません。) このオプションを指定しない場合は、<code class="literal">ALGORITHM=2</code> を使用するのと同じ効果があります。 このオプションは、主に <code class="literal">[LINEAR] KEY</code> によってパーティション化されたテーブルを MySQL 5.1 以降の MySQL バージョン間でアップグレードまたはダウングレードするときに使用するか、または MySQL 5.5 以降のサーバー上で、MySQL 5.1 サーバー上で使用できる <code class="literal">KEY</code> または <code class="literal">LINEAR KEY</code> によってパーティション化されたテーブルを作成することを目的にしています。 詳細は、<a class="xref" href="sql-statements.html#alter-table-partition-operations" title="13.1.9.1 ALTER TABLE パーティション操作">セクション13.1.9.1「ALTER TABLE パーティション操作」</a>を参照してください。 
        </p><p>
          MySQL 5.7 以降の <span class="command"><strong>mysqldump</strong></span> では、次のようにバージョニングされたコメントにこのオプションが含まれています:
        </p><pre class="programlisting">CREATE TABLE t1 (a INT)
/*!50100 PARTITION BY KEY */ <span class="emphasis"><em>/*!50611 ALGORITHM = 1 */</em></span> /*!50100 ()
      PARTITIONS 3 */
</pre><p>
          これにより、MySQL 5.6.10 以前のサーバーはこのオプションを無視するようになります。これらのバージョンでは、通常であれば構文エラーが発生します。 <code class="literal">KEY</code> によってパーティション化またはサブパーティション化されたテーブルをバージョン 5.6.11 より前の MySQL 5.6 サーバーに使用する MySQL 5.7 サーバーで作成されたダンプをロードする場合は、先に進む前に <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/upgrading-from-previous-series.html" target="_top">Changes in MySQL 5.6</a> に問い合せてください。 (見つかった情報は、MySQL 5.7(事実上 5.6.11 または later-server) から作成された <code class="literal">KEY</code> パーティションテーブルまたはサブパーティションテーブルを含むダンプを MySQL 5.5.30 以前のサーバーにロードする場合にも適用されます。) 
        </p><p>
          また、MySQL 5.6.11 以降では、<code class="literal">ALGORITHM=1</code> が <span class="command"><strong>mysqldump</strong></span> と同じ方法で、バージョン管理されたコメントを使用して <code class="literal">SHOW CREATE TABLE</code> の出力に必要に応じて表示されます。 <code class="literal">ALGORITHM=2</code> は、元のテーブルを作成するときにこのオプションが指定された場合でも、<code class="literal">SHOW CREATE TABLE</code> の出力から常に省略されます。 
        </p><p>
          <code class="literal">PARTITION BY KEY</code> では、<code class="literal">VALUES LESS THAN</code> または <code class="literal">VALUES IN</code> のどちらの句も使用できません。
        </p></li><li class="listitem"><p>
          <code class="literal">RANGE(<em class="replaceable"><code>expr</code></em>)</code>
        </p><p>
          この場合、<em class="replaceable"><code>expr</code></em> では、一連の <code class="literal">VALUES LESS THAN</code> 演算子を使用して値の範囲が表示されます。 範囲のパーティション化を使用する場合は、<code class="literal">VALUES LESS THAN</code> を使用して、少なくとも 1 つのパーティションを定義する必要があります。 範囲のパーティション化では <code class="literal">VALUES IN</code> を使用できません。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">RANGE</code> によってパーティション化されたテーブルでは、<code class="literal">VALUES LESS THAN</code> を整数リテラル値、または 1 つの整数値に評価される式のどちらかとともに使用する必要があります。 MySQL 8.0 では、このセクションのあとの方で説明されている、<code class="literal">PARTITION BY RANGE COLUMNS</code> を使用して定義されたテーブルでこの制限を克服できます。 
          </p></div><p>
          次のスキームに従って、年の値を含むカラムに関してパーティション化するテーブルがあるとします。
        </p><div class="informaltable"><table summary="A table partitioning scheme based on a column containing year values, as described in the preceding text. The table lists partition numbers and corresponding range of years."><col style="width: 40%"><col style="width: 60%"><thead><tr>
              <th>パーティション番号:</th>
              <th>年の範囲:</th>
            </tr></thead><tbody><tr>
              <td>0</td>
              <td>1990 以前</td>
            </tr><tr>
              <td>1</td>
              <td>1991 から 1994 まで</td>
            </tr><tr>
              <td>2</td>
              <td>1995 から 1998 まで</td>
            </tr><tr>
              <td>3</td>
              <td>1999 から 2002 まで</td>
            </tr><tr>
              <td>4</td>
              <td>2003 から 2005 まで</td>
            </tr><tr>
              <td>5</td>
              <td>2006 以降</td>
            </tr></tbody></table></div><p>
          このようなパーティション化スキームを実装するテーブルは、次に示す <code class="literal">CREATE TABLE</code> ステートメントによって実現できます。
        </p><pre class="programlisting">CREATE TABLE t1 (
    year_col  INT,
    some_data INT
)
PARTITION BY RANGE (year_col) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1995),
    PARTITION p2 VALUES LESS THAN (1999),
    PARTITION p3 VALUES LESS THAN (2002),
    PARTITION p4 VALUES LESS THAN (2006),
    PARTITION p5 VALUES LESS THAN MAXVALUE
);
</pre><p>
          <code class="literal">PARTITION ... VALUES LESS THAN ...</code> ステートメントは、連続的に機能します。 <code class="literal">VALUES LESS THAN MAXVALUE</code> は、それ以外で指定されている最大値より大きい<span class="quote">「<span class="quote">残りの</span>」</span>値を指定するように機能します。 
        </p><p>
          <code class="literal">VALUES LESS THAN</code> 句は、<code class="literal">switch ... case</code> ブロックの <code class="literal">case</code> 部分と同様の方法で順次機能します (C、Java、PHP などの多くのプログラミング言語で使用されています)。 つまり、この句は、連続した各 <code class="literal">VALUES LESS THAN</code> で指定されている上限が前の句の上限より大きく、かつ <code class="literal">MAXVALUE</code> を参照している句がリスト内のすべての句の最後に来るような方法で配置されている必要があります。 
        </p></li><li class="listitem"><p>
          <code class="literal">RANGE COLUMNS(<em class="replaceable"><code>column_list</code></em>)</code>
        </p><p>
          <code class="literal">RANGE</code> のこのバリアントにより、複数のカラムで範囲条件を使用する (つまり、<code class="literal">WHERE a = 1 AND b &lt; 10</code> や <code class="literal">WHERE a = 1 AND b = 10 AND c &lt; 10</code> などの条件を持つ) クエリーのパーティションプルーニングが容易になります。 これにより、<code class="literal">COLUMNS</code> 句内のカラムのリストと、各 <code class="literal">PARTITION ... VALUES LESS THAN (<em class="replaceable"><code>value_list</code></em>)</code> パーティション定義句内のカラム値のセットを使用して、複数のカラム内の値の範囲を指定できるようになります。 (もっとも単純なケースでは、このセットは単一カラムで構成されます。) <em class="replaceable"><code>column_list</code></em> および <em class="replaceable"><code>value_list</code></em> で参照できるカラムの最大数は 16 です。 
        </p><p>
          <code class="literal">COLUMNS</code> 句で使用される <em class="replaceable"><code>column_list</code></em> には、カラムの名前のみを含めることができます。リスト内の各カラムは MySQL のデータ型のうち、整数型、文字列型、および時間または日付カラム型のいずれかである必要があります。 <code class="literal">BLOB</code>、<code class="literal">TEXT</code>、<code class="literal">SET</code>、<code class="literal">ENUM</code>、<code class="literal">BIT</code>、または空間データ型を使用したカラムは許可されていません。浮動小数点数型を使用するカラムも許可されていません。 また、<code class="literal">COLUMNS</code> 句では、関数や演算式も使用できません。 
        </p><p>
          パーティション定義で使用される <code class="literal">VALUES LESS THAN</code> 句は、<code class="literal">COLUMNS()</code> 句に現れるカラムごとにリテラル値を指定する必要があります。つまり、各 <code class="literal">VALUES LESS THAN</code> 句で使用される値のリストには、<code class="literal">COLUMNS</code> 句にリストされているカラムの数と同じ数の値が含まれている必要があります。 <code class="literal">VALUES LESS THAN</code> 句で <code class="literal">COLUMNS</code> 句に存在する数より多いか、または少ない値を使用しようとすると、このステートメントは次のエラーで失敗します。<span class="errortext">Inconsistency in usage of column lists for partitioning...</span>. <code class="literal">VALUES LESS THAN</code> に現れるどの値にも <code class="literal">NULL</code> は使用できません。 この例に示すように、最初のカラム以外の特定のカラムで <code class="literal">MAXVALUE</code> を複数回使用できます。 
        </p><pre class="programlisting">CREATE TABLE rc (
    a INT NOT NULL,
    b INT NOT NULL
)
PARTITION BY RANGE COLUMNS(a,b) (
    PARTITION p0 VALUES LESS THAN (10,5),
    PARTITION p1 VALUES LESS THAN (20,10),
    PARTITION p2 VALUES LESS THAN (50,MAXVALUE),
    PARTITION p3 VALUES LESS THAN (65,MAXVALUE),
    PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)
);
</pre><p>
          <code class="literal">VALUES LESS THAN</code> 値リストで使用されている各値が、対応するカラムの型に正確に一致している必要があります。変換は行われません。 たとえば、整数型を使用するカラムに一致する値として文字列 <code class="literal">'1'</code> を使用したり (代わりに、数値 <code class="literal">1</code> を使用する必要があります)、文字列型を使用するカラムに一致する値として数値 <code class="literal">1</code> を使用したりすることはできません (このような場合は、引用符で囲まれた文字列 <code class="literal">'1'</code> を使用する必要があります)。 
        </p><p>
          詳細は、<a class="xref" href="partitioning.html#partitioning-range" title="24.2.1 RANGE パーティショニング">セクション24.2.1「RANGE パーティショニング」</a>および<a class="xref" href="partitioning.html#partitioning-pruning" title="24.4 パーティションプルーニング">セクション24.4「パーティションプルーニング」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">LIST(<em class="replaceable"><code>expr</code></em>)</code>
        </p><p>
          これは、州や国コードなど、使用可能な値の制限されたセットを持つテーブルのカラムに基づいてパーティションを割り当てる場合に役立ちます。 このような場合は、特定の州または国に関連するすべての行を単一パーティションに割り当てたり、特定の州または国のセットのためにパーティションを予約したりできます。 これは <code class="literal">RANGE</code> に似ていますが、各パーティションに許可される値を指定するために <code class="literal">VALUES IN</code> しか使用できない点が異なります。 
        </p><p>
          <code class="literal">VALUES IN</code> は、一致させる値のリストとともに使用されます。 たとえば、次のようなパーティション化スキームを作成できます。 
        </p><pre class="programlisting">CREATE TABLE client_firms (
    id   INT,
    name VARCHAR(35)
)
PARTITION BY LIST (id) (
    PARTITION r0 VALUES IN (1, 5, 9, 13, 17, 21),
    PARTITION r1 VALUES IN (2, 6, 10, 14, 18, 22),
    PARTITION r2 VALUES IN (3, 7, 11, 15, 19, 23),
    PARTITION r3 VALUES IN (4, 8, 12, 16, 20, 24)
);
</pre><p>
          リストのパーティション化を使用する場合は、<code class="literal">VALUES IN</code> を使用して、少なくとも 1 つのパーティションを定義する必要があります。 <code class="literal">PARTITION BY LIST</code> では <code class="literal">VALUES LESS THAN</code> を使用できません。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">LIST</code> によってパーティション化されたテーブルでは、<code class="literal">VALUES IN</code> で使用される値リストを整数値のみで構成する必要があります。 MySQL 8.0 では、このセクションのあとの方で説明されている、<code class="literal">LIST COLUMNS</code> によるパーティション化を使用してこの制限を克服できます。 
          </p></div></li><li class="listitem"><p>
          <code class="literal">LIST COLUMNS(<em class="replaceable"><code>column_list</code></em>)</code>
        </p><p>
          <code class="literal">LIST</code> のこのバリアントにより、複数のカラムで比較条件を使用する (つまり、<code class="literal">WHERE a = 5 AND b = 5</code> や <code class="literal">WHERE a = 1 AND b = 10 AND c = 5</code> などの条件を持つ) クエリーのパーティションプルーニングが容易になります。 これにより、<code class="literal">COLUMNS</code> 句内のカラムのリストと、各 <code class="literal">PARTITION ... VALUES IN (<em class="replaceable"><code>value_list</code></em>)</code> パーティション定義句内のカラム値のセットを使用して、複数のカラム内の値を指定できるようになります。 
        </p><p>
          <code class="literal">LIST COLUMNS(<em class="replaceable"><code>column_list</code></em>)</code> で使用されるカラムリストと <code class="literal">VALUES IN(<em class="replaceable"><code>value_list</code></em>)</code> で使用される値リストに関連したデータ型を管理するルールは、<code class="literal">VALUES IN</code> 句では <code class="literal">MAXVALUE</code> が許可されず、<code class="literal">NULL</code> を使用できる点を除き、それぞれ <code class="literal">RANGE COLUMNS(<em class="replaceable"><code>column_list</code></em>)</code> で使用されるカラムリストと <code class="literal">VALUES LESS THAN(<em class="replaceable"><code>value_list</code></em>)</code> で使用される値リストの場合のルールと同じです。
        </p><p>
          <code class="literal">PARTITION BY LIST COLUMNS</code> で <code class="literal">VALUES IN</code> に使用される値のリストには、<code class="literal">PARTITION BY LIST</code> で使用された場合と比較して重要な違いが 1 つあります。 <code class="literal">PARTITION BY LIST COLUMNS</code> で使用された場合、<code class="literal">VALUES IN</code> 句内の各要素は、カラム値の<span class="emphasis"><em>セット</em></span>である必要があります。各セット内の値の数は <code class="literal">COLUMNS</code> 句で使用されているカラム数と同じである必要があり、これらの値のデータ型はそれらのカラムのデータ型に一致している (しかも、同じ順序で現れる) 必要があります。 もっとも単純なケースでは、このセットは単一カラムで構成されます。 <em class="replaceable"><code>column_list</code></em> および <em class="replaceable"><code>value_list</code></em> を構成する各要素で使用できるカラムの最大数は 16 です。 
        </p><p>
          次の <code class="literal">CREATE TABLE</code> ステートメントで定義されるテーブルは、<code class="literal">LIST COLUMNS</code> パーティション化を使用したテーブルの例を示しています。
        </p><pre class="programlisting">CREATE TABLE lc (
    a INT NULL,
    b INT NULL
)
PARTITION BY LIST COLUMNS(a,b) (
    PARTITION p0 VALUES IN( (0,0), (NULL,NULL) ),
    PARTITION p1 VALUES IN( (0,1), (0,2), (0,3), (1,1), (1,2) ),
    PARTITION p2 VALUES IN( (1,0), (2,0), (2,1), (3,0), (3,1) ),
    PARTITION p3 VALUES IN( (1,3), (2,2), (2,3), (3,2), (3,3) )
);
</pre></li><li class="listitem"><p>
          <code class="literal">PARTITIONS <em class="replaceable"><code>num</code></em></code>
        </p><p>
          オプションで、<code class="literal">PARTITIONS <em class="replaceable"><code>num</code></em></code> 句を使用してパーティションの数を指定できます。ここで、<em class="replaceable"><code>num</code></em> はパーティションの数です。 この句<span class="emphasis"><em>と</em></span>ほかのいずれかの <code class="literal">PARTITION</code> 句の両方が使用されている場合、<em class="replaceable"><code>num</code></em> は、<code class="literal">PARTITION</code> 句を使用して宣言されているすべてのパーティションの総数と同じである必要があります。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">RANGE</code> または <code class="literal">LIST</code> によってパーティション化されたテーブルの作成で <code class="literal">PARTITIONS</code> 句を使用するかどうかにかかわらず、テーブル定義には引き続き、少なくとも 1 つの <code class="literal">PARTITION VALUES</code> 句を含める必要があります (下を参照してください)。
          </p></div></li><li class="listitem"><p>
          <code class="literal">SUBPARTITION BY</code>
        </p><p>
          オプションで、パーティションを複数のサブパーティションに分割できます。 これは、オプションの <code class="literal">SUBPARTITION BY</code> 句を使用して示すことができます。 サブパーティション化は、<code class="literal">HASH</code> または <code class="literal">KEY</code> によって実行できます。 これらのどちらも <code class="literal">LINEAR</code> にすることができます。 これらは、同等のパーティショニングタイプについて前に説明したのと同じように機能します。 (<code class="literal">LIST</code> または <code class="literal">RANGE</code> によってサブパーティション化することはできません。) 
        </p><p>
          サブパーティションの数は、<code class="literal">SUBPARTITIONS</code> キーワードと、そのあとの整数値を使用して示すことができます。
        </p></li><li class="listitem"><p>
          <code class="literal">PARTITIONS</code> または <code class="literal">SUBPARTITIONS</code> 句で使用されている値の厳密なチェックが適用され、この値は次のルールに従っている必要があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              この値は 0 以外の正の整数である必要があります。
            </p></li><li class="listitem"><p>
              先頭の 0 は許可されません。
            </p></li><li class="listitem"><p>
              この値は整数リテラルである必要があり、式にすることはできません。 たとえば、<code class="literal">0.2E+01</code> が <code class="literal">2</code> に評価されたとしても、<code class="literal">PARTITIONS 0.2E+01</code> は許可されません。 (Bug #15890) 
            </p></li></ul></div></li><li class="listitem"><p>
          <code class="literal"><em class="replaceable"><code>partition_definition</code></em></code>
        </p><p>
          各パーティションは、<em class="replaceable"><code>partition_definition</code></em> 句を使用して個別に定義できます。 この句を構成する個別の部分は次のとおりです。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">PARTITION <em class="replaceable"><code>partition_name</code></em></code>
            </p><p>
              パーティションの論理名を指定します。
            </p></li><li class="listitem"><p>
              <code class="literal">VALUES</code>
            </p><p>
              レンジパーティション化では、各パーティションに <code class="literal">VALUES LESS THAN</code> 句が含まれている必要があります。リストパーティション化では、パーティションごとに <code class="literal">VALUES IN</code> 句を指定する必要があります。 これは、このパーティションにどの行を格納するかを決定するために使用されます。 構文の例については、<a class="xref" href="partitioning.html" title="第 24 章 パーティション化">第24章「<i>パーティション化</i>」</a>にあるパーティショニングタイプの説明を参照してください。 
            </p></li><li class="listitem"><p>
              <code class="literal">[STORAGE] ENGINE</code>
            </p><p>
              MySQL は、<code class="literal">PARTITION</code> と <code class="literal">SUBPARTITION</code> の両方に対して<code class="literal">[STORAGE] ENGINE</code> オプションを受け入れます。 現在、このオプションを使用できる唯一の方法は、すべてのパーティションまたはすべてのサブパーティションを同じストレージエンジンに設定し、同じテーブル内のパーティションまたはサブパーティションに異なるストレージエンジンを設定しようとすると、<span class="errortext">「ERROR 1469 (HY000): パーティション内のハンドラの混在は、このバージョンの MySQL では許可されていません」</span>エラーが発生することです。 
            </p></li><li class="listitem"><p>
              <code class="literal">COMMENT</code>
            </p><p>
              オプションの <code class="literal">COMMENT</code> 句を使用すると、このパーティションを説明する文字列を指定できます。 例: 
            </p><pre class="programlisting">COMMENT = 'Data for the years previous to 1999'
</pre><p>
              パーティションコメントの最大長は 1024 文字です。
            </p></li><li class="listitem"><p>
              <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code>
            </p><p>
              <code class="literal">DATA DIRECTORY</code> と <code class="literal">INDEX DIRECTORY</code> は、それぞれ、このパーティションのデータとインデックスが格納されるディレクトリを示すために使用できます。 <code class="filename"><em class="replaceable"><code>data_dir</code></em></code> と <code class="filename"><em class="replaceable"><code>index_dir</code></em></code> はどちらも、絶対システムパス名である必要があります。 
            </p><p>
              MySQL 8.0.21 では、<code class="literal">DATA DIRECTORY</code> 句で指定されたディレクトリは <code class="literal">InnoDB</code> で認識されている必要があります。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-create-table-external-data-directory" title="DATA DIRECTORY 句の使用">DATA DIRECTORY 句の使用</a>を参照してください。 
            </p><p>
              <code class="literal">DATA DIRECTORY</code> または <code class="literal">INDEX DIRECTORY</code> パーティションオプションを使用するには、<code class="literal">FILE</code> 権限が必要です。
            </p><p>
              例:
            </p><pre class="programlisting">CREATE TABLE th (id INT, name VARCHAR(30), adate DATE)
PARTITION BY LIST(YEAR(adate))
(
  PARTITION p1999 VALUES IN (1995, 1999, 2003)
    DATA DIRECTORY = '<code class="filename">/var/appdata/95/data</code>'
    INDEX DIRECTORY = '<code class="filename">/var/appdata/95/idx</code>',
  PARTITION p2000 VALUES IN (1996, 2000, 2004)
    DATA DIRECTORY = '<code class="filename">/var/appdata/96/data</code>'
    INDEX DIRECTORY = '<code class="filename">/var/appdata/96/idx</code>',
  PARTITION p2001 VALUES IN (1997, 2001, 2005)
    DATA DIRECTORY = '<code class="filename">/var/appdata/97/data</code>'
    INDEX DIRECTORY = '<code class="filename">/var/appdata/97/idx</code>',
  PARTITION p2002 VALUES IN (1998, 2002, 2006)
    DATA DIRECTORY = '<code class="filename">/var/appdata/98/data</code>'
    INDEX DIRECTORY = '<code class="filename">/var/appdata/98/idx</code>'
);
</pre><p>
              <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> は、<code class="literal">MyISAM</code> テーブルで使用される <code class="literal">CREATE TABLE</code> ステートメントの <em class="replaceable"><code>table_option</code></em> 句と同じように動作します。
            </p><p>
              パーティションごとに 1 つのデータディレクトリと 1 つのインデックスディレクトリを指定できます。 指定されないままになっている場合、データとインデックスは、デフォルトではそのテーブルのデータベースディレクトリ内に格納されます。 
            </p><p>
              <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> オプションは、<code class="literal">NO_DIR_IN_CREATE</code> が有効になっている場合、パーティション化されたテーブルの作成では無視されます。
            </p></li><li class="listitem"><p>
              <code class="literal">MAX_ROWS</code> および <code class="literal">MIN_ROWS</code>
            </p><p>
              パーティションに格納する行の最大数と最小数をそれぞれ指定するために使用できます。 <em class="replaceable"><code>max_number_of_rows</code></em> と <em class="replaceable"><code>min_number_of_rows</code></em> の値は正の整数である必要があります。 同じ名前を持つテーブルレベルのオプションと同様に、これらはサーバーへの<span class="quote">「<span class="quote">提案</span>」</span>としてのみ機能し、強い制限値ではありません。 
            </p></li><li class="listitem"><p>
              <code class="literal">TABLESPACE</code>
            </p><p>
              <code class="literal">TABLESPACE `innodb_file_per_table`</code>を指定して、パーティションの <code class="literal">InnoDB</code> file-per-table テーブルスペースを指定するために使用できます。 すべてのパーティションは同じストレージエンジンに属している必要があります。 
            </p><p>
              <code class="literal">InnoDB</code> テーブルパーティションの共有 <code class="literal">InnoDB</code> テーブルスペースへの配置はサポートされていません。 共有テーブルスペースには、<code class="literal">InnoDB</code> システムテーブルスペースおよび一般テーブルスペースが含まれます。 
            </p></li></ul></div></li><li class="listitem"><p>
          <code class="literal"><em class="replaceable"><code>subpartition_definition</code></em></code>
        </p><p>
          オプションで、パーティション定義に 1 つ以上の <em class="replaceable"><code>subpartition_definition</code></em> 句を含めることができます。 これらの各句は、少なくとも <code class="literal">SUBPARTITION <em class="replaceable"><code>name</code></em></code> で構成されます。ここで、<em class="replaceable"><code>name</code></em> はそのサブパーティションの識別子です。 <code class="literal">PARTITION</code> キーワードが <code class="literal">SUBPARTITION</code> に置き換えられる点を除き、サブパーティション定義の構文はパーティション定義の構文と同じです。 
        </p><p>
          サブパーティション化は <code class="literal">HASH</code> または <code class="literal">KEY</code> によって実行する必要があり、<code class="literal">RANGE</code> または <code class="literal">LIST</code> パーティションに対してのみ実行できます。 <a class="xref" href="partitioning.html#partitioning-subpartitions" title="24.2.6 サブパーティショニング">セクション24.2.6「サブパーティショニング」</a>を参照してください。 
        </p></li></ul></div><p>
      <span class="bold"><strong>生成されたカラムによるパーティション化</strong></span>
    </p><p>
      生成されたカラムによるパーティション化が許可されます。 例: 
    </p><pre class="programlisting">CREATE TABLE t1 (
  s1 INT,
  s2 INT AS (EXP(s1)) STORED
)
PARTITION BY LIST (s2) (
  PARTITION p1 VALUES IN (1)
);
</pre><p>
      パーティション化では、生成されたカラムは通常のカラムとして認識されます。これにより、パーティション化が許可されていない関数の制限の回避策が有効になります (<a class="xref" href="partitioning.html#partitioning-limitations-functions" title="24.6.3 関数に関連するパーティショニング制限">セクション24.6.3「関数に関連するパーティショニング制限」</a> を参照)。 前述の例は、この方法を示しています: <code class="literal">EXP()</code> は <code class="literal">PARTITION BY</code> 句で直接使用できませんが、<code class="literal">EXP()</code> を使用して定義された生成されたカラムは許可されます。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="create-table-files"></a>13.1.20.1 CREATE TABLE によって作成されるファイル</h4></div></div></div><a class="indexterm" name="idm45827003191968"></a><a class="indexterm" name="idm45827003189840"></a><a class="indexterm" name="idm45827003188480"></a><a class="indexterm" name="idm45827003187120"></a><a class="indexterm" name="idm45827003185760"></a><p>
        file-per-table テーブルスペースまたは一般テーブルスペースに作成された <code class="literal">InnoDB</code> テーブルの場合、テーブルデータおよび関連するインデックスは、データベースディレクトリの <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibd file</a> に格納されます。 <code class="literal">InnoDB</code> テーブルがシステムテーブルスペースに作成されると、システムテーブルスペースを表す <a class="link" href="glossary.html#glos_ibdata_file" title="ibdata ファイル">ibdata* files</a> にテーブルデータおよびインデックスが格納されます。 <code class="literal">innodb_file_per_table</code> オプションは、デフォルトで file-per-table テーブルスペースと system テーブルスペースのどちらにテーブルを作成するかを制御します。 <code class="literal">TABLESPACE</code> オプションを使用すると、<code class="literal">innodb_file_per_table</code> の設定に関係なく、file-per-table テーブルスペース、一般テーブルスペースまたはシステムテーブルスペースにテーブルを配置できます。 
      </p><p>
        <code class="literal">MyISAM</code> テーブルの場合は、ストレージエンジンがデータおよびインデックスファイルを作成します。 したがって、<code class="literal">MyISAM</code> テーブル <em class="replaceable"><code>tbl_name</code></em> ごとに 2 つのディスクファイルがあります。 
      </p><div class="informaltable"><table summary="The purpose of MyISAM table tbl_name disk files."><col style="width: 30%"><col style="width: 70%"><thead><tr>
            <th>ファイル</th>
            <th>目的</th>
          </tr></thead><tbody><tr>
            <td><code class="filename"><em class="replaceable"><code>tbl_name</code></em>.MYD</code></td>
            <td>データファイル</td>
          </tr><tr>
            <td><code class="filename"><em class="replaceable"><code>tbl_name</code></em>.MYI</code></td>
            <td>インデックスファイル</td>
          </tr></tbody></table></div><p>
        <a class="xref" href="storage-engines.html" title="第 16 章 代替ストレージエンジン">第16章「<i>代替ストレージエンジン</i>」</a>では、テーブルを表すために各ストレージエンジンがどのようなファイルを作成するかについて説明しています。 テーブル名に特殊文字が含まれている場合は、<a class="xref" href="language-structure.html#identifier-mapping" title="9.2.4 識別子とファイル名のマッピング">セクション9.2.4「識別子とファイル名のマッピング」</a>で説明されているように、その文字のエンコードされたバージョンがテーブルファイルの名前に含まれます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="create-temporary-table"></a>13.1.20.2 CREATE TEMPORARY TABLE ステートメント</h4></div></div></div><a class="indexterm" name="idm45827003159344"></a><a class="indexterm" name="idm45827003157888"></a><p>
        テーブルの作成時に <code class="literal">TEMPORARY</code> キーワードを使用できます。 <code class="literal">TEMPORARY</code> テーブルは現在のセッション内でのみ表示され、セッションがクローズされると自動的に削除されます。 つまり、2 つの異なるセッションが同じ一時テーブル名を使用することができ、互いに、または同じ名前の既存の <code class="literal">TEMPORARY</code> 以外のテーブルと競合することはありません。 (既存のテーブルは、一時テーブルが削除されるまで非表示になります。) 
      </p><p>
        <code class="literal">InnoDB</code> では、圧縮一時テーブルはサポートされていません。 <code class="literal">innodb_strict_mode</code> が有効な場合 (デフォルト)、<code class="literal">ROW_FORMAT=COMPRESSED</code> または <code class="literal">KEY_BLOCK_SIZE</code> が指定されていると、<code class="literal">CREATE TEMPORARY TABLE</code> はエラーを返します。 <code class="literal">innodb_strict_mode</code> が無効な場合は、警告が発行され、圧縮されていない行形式を使用して一時テーブルが作成されます。 <code class="literal">innodb_file_per-table</code> オプションは、<code class="literal">InnoDB</code> 一時テーブルの作成には影響しません。 
      </p><p>
        <code class="literal">CREATE TABLE</code> では、<code class="literal">TEMPORARY</code> キーワードとともに使用する場合を除き、暗黙的なコミットが発生します。 <a class="xref" href="sql-statements.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。 
      </p><p>
        <code class="literal">TEMPORARY</code> テーブルは、データベース (スキーマ) と非常に疎な関係を持っています。 データベースを削除しても、そのデータベース内で作成されたどの <code class="literal">TEMPORARY</code> テーブルも自動的には削除されません。 
      </p><a class="indexterm" name="idm45827003138880"></a><a class="indexterm" name="idm45827003136704"></a><p>
        一時テーブルを作成するには、<code class="literal">CREATE TEMPORARY TABLES</code> 権限が必要です。 セッションが一時テーブルを作成したあと、サーバーはそのテーブルに対するそれ以上の権限チェックを実行しません。 セッションの作成によって、<code class="literal">DROP TABLE</code>、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、<code class="literal">SELECT</code> などのあらゆる操作をテーブル上で実行できます。 
      </p><p>
        この動作の 1 つの影響として、現在のユーザーが一時テーブルを作成する権限を持たなくても、セッションが一時テーブルを操作できるということがあります。 現在のユーザーには <code class="literal">CREATE TEMPORARY TABLES</code> 権限はありませんが、<code class="literal">CREATE TEMPORARY TABLES</code> を持ち、一時テーブルを作成するユーザーの権限で実行される定義者コンテキストのストアドプロシージャを実行できるとします。 プロシージャーの実行中、セッションは定義側ユーザーの権限を使用します。 プロシージャーが復帰したあと、有効な権限は現在のユーザーの権限に戻り、これによって引き続き一時テーブルを表示し、一時テーブルに対してあらゆる操作を実行できることになります。 
      </p><p>
        <code class="literal">CREATE TEMPORY TABLE ... LIKE</code> を使用して、<code class="literal">mysql</code> テーブルスペース、<code class="literal">InnoDB</code> システムテーブルスペース (<code class="literal">innodb_system</code>) または一般テーブルスペースに存在するテーブルの定義に基づいて空のテーブルを作成することはできません。 このようなテーブルのテーブルスペース定義には、テーブルが存在するテーブルスペースを定義する <code class="literal">TABLESPACE</code> 属性が含まれており、前述のテーブルスペースは一時テーブルをサポートしていません。 このようなテーブルの定義に基づいて一時テーブルを作成するには、かわりに次の構文を使用します: 
      </p><pre class="programlisting">CREATE TEMPORARY TABLE <em class="replaceable"><code>new_tbl</code></em> SELECT * FROM <em class="replaceable"><code>orig_tbl</code></em> LIMIT 0;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">CREATE TEMPORARY TABLE</code> での <code class="literal">TABLESPACE = innodb_file_per_table</code> 句および <code class="literal">TABLESPACE = innodb_temporary</code> 句のサポートは、MySQL 8.0.13 で非推奨になりました。MySQL の将来のバージョンで削除される予定です。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="create-table-like"></a>13.1.20.3 CREATE TABLE ... LIKE ステートメント</h4></div></div></div><a class="indexterm" name="idm45827003112944"></a><a class="indexterm" name="idm45827003111488"></a><p>
        <code class="literal">CREATE TABLE ... LIKE</code> を使用して、元のテーブルに定義されているカラム属性やインデックスなど、別のテーブルの定義に基づいて空のテーブルを作成します:
      </p><pre class="programlisting">CREATE TABLE <em class="replaceable"><code>new_tbl</code></em> LIKE <em class="replaceable"><code>orig_tbl</code></em>;
</pre><p>
        このコピーは、元のテーブルと同じバージョンのテーブルストレージフォーマットを使用して作成されます。 元のテーブルに対する <code class="literal">SELECT</code> 権限が必要です。 
      </p><p>
        <code class="literal">LIKE</code> は、ビューに対してではなく、ベーステーブルに対してのみ機能します。
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          <code class="literal">LOCK TABLES</code> ステートメントが有効な間は、<code class="literal">CREATE TABLE</code> または <code class="literal">CREATE TABLE ... LIKE</code> を実行できません。
        </p><p>
          <code class="literal">CREATE TABLE ... LIKE</code> は、<code class="literal">CREATE TABLE</code> と同じチェックを行います。 つまり、現在の SQL モードが元のテーブルの作成時に有効なモードと異なる場合、テーブル定義は新しいモードでは無効とみなされ、ステートメントが失敗する可能性があります。 
        </p></div><p>
        <code class="literal">CREATE TABLE ... LIKE</code> の場合、宛先テーブルには元のテーブルから生成されたカラム情報が保持されます。
      </p><p>
        <code class="literal">CREATE TABLE ... LIKE</code> の場合、宛先テーブルには元のテーブルの式のデフォルト値が保持されます。
      </p><p>
        <code class="literal">CREATE TABLE ... LIKE</code> の場合、宛先テーブルでは、すべての制約名が生成されることを除き、元のテーブルの <code class="literal">CHECK</code> 制約が保持されます。
      </p><p>
        <code class="literal">CREATE TABLE ... LIKE</code> は、元のテーブルや、すべての外部キー定義に対して指定されたどの <code class="literal">DATA DIRECTORY</code> または <code class="literal">INDEX DIRECTORY</code> テーブルオプションも保持しません。
      </p><p>
        元のテーブルが <code class="literal">TEMPORARY</code> テーブルである場合、<code class="literal">CREATE TABLE ... LIKE</code> は <code class="literal">TEMPORARY</code> を保持しません。 <code class="literal">TEMPORARY</code> 宛先テーブルを作成するには、<code class="literal">CREATE TEMPORARY TABLE ... LIKE</code> を使用します。 
      </p><p>
        <code class="literal">mysql</code> テーブルスペース、<code class="literal">InnoDB</code> システムテーブルスペース (<code class="literal">innodb_system</code>) または一般テーブルスペースで作成されたテーブルには、テーブルが存在するテーブルスペースを定義する <code class="literal">TABLESPACE</code> 属性がテーブル定義に含まれます。 一時的な回帰のため、<code class="literal">CREATE TABLE ... LIKE</code> は <code class="literal">TABLESPACE</code> 属性を保持し、<code class="literal">innodb_file_per_table</code> の設定に関係なく、定義されたテーブルスペースにテーブルを作成します。 このようなテーブルの定義に基づいて空のテーブルを作成するときに <code class="literal">TABLESPACE</code> 属性を回避するには、かわりに次の構文を使用します: 
      </p><pre class="programlisting">CREATE TABLE <em class="replaceable"><code>new_tbl</code></em> SELECT * FROM <em class="replaceable"><code>orig_tbl</code></em> LIMIT 0;
</pre><p>
        <code class="literal">CREATE TABLE ... LIKE</code> 操作では、すべての <code class="literal">ENGINE_ATTRIBUTE</code> および <code class="literal">SECONDARY_ENGINE_ATTRIBUTE</code> の値が新しいテーブルに適用されます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="create-table-select"></a>13.1.20.4 CREATE TABLE ... SELECT ステートメント</h4></div></div></div><a class="indexterm" name="idm45827003070096"></a><a class="indexterm" name="idm45827003068640"></a><p>
        <code class="literal">CREATE TABLE</code> ステートメントの最後に <code class="literal">SELECT</code> ステートメントを追加することによって、あるテーブルを別のテーブルから作成できます。
      </p><pre class="programlisting">CREATE TABLE <em class="replaceable"><code>new_tbl</code></em> [AS] SELECT * FROM <em class="replaceable"><code>orig_tbl</code></em>;
</pre><p>
        MySQL は、<code class="literal">SELECT</code> 内のすべての要素に対して新しいカラムを作成します。 例: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE test (a INT NOT NULL AUTO_INCREMENT,</code></strong>
    -&gt;        <strong class="userinput"><code>PRIMARY KEY (a), KEY(b))</code></strong>
    -&gt;        <strong class="userinput"><code>ENGINE=MyISAM SELECT b,c FROM test2;</code></strong>
</pre><p>
        これにより、<code class="literal">a</code>、<code class="literal">b</code>、<code class="literal">c</code> の 3 つのカラムを含む <code class="literal">MyISAM</code> テーブルが作成されます。 <code class="literal">ENGINE</code> オプションは <code class="literal">CREATE TABLE</code> ステートメントの一部であるため、<code class="literal">SELECT</code> のあとに使用してはいけません。これにより、構文エラーが発生します。 <code class="literal">CHARSET</code> などのその他の <code class="literal">CREATE TABLE</code> オプションにも同じことが当てはまります。 
      </p><p>
        <code class="literal">SELECT</code> ステートメントからのカラムは、テーブルにオーバーラップされるのではなく、テーブルの右側に付加されます。 次の例を考えてみます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM foo;</code></strong>
+---+
| n |
+---+
| 1 |
+---+

mysql&gt; <strong class="userinput"><code>CREATE TABLE bar (m INT) SELECT n FROM foo;</code></strong>
Query OK, 1 row affected (0.02 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM bar;</code></strong>
+------+---+
| m    | n |
+------+---+
| NULL | 1 |
+------+---+
1 row in set (0.00 sec)
</pre><p>
        テーブル <code class="literal">foo</code> 内の行ごとに、<code class="literal">foo</code> からの値と新しいカラムのデフォルト値を持つ行が <code class="literal">bar</code> 内に挿入されます。
      </p><p>
        <code class="literal">CREATE TABLE ... SELECT</code> の結果として得られるテーブルでは、<code class="literal">CREATE TABLE</code> 部分でのみ指定されているカラムが最初に来ます。 両方の部分で指定されているカラム、または <code class="literal">SELECT</code> 部分でのみ指定されているカラムがそのあとに来ます。 <code class="literal">SELECT</code> カラムのデータ型は、<code class="literal">CREATE TABLE</code> 部分にあるカラムも指定することによってオーバーライドできます。 
      </p><p>
        テーブルへのデータのコピー中にエラーが発生した場合、テーブルは自動的に削除され、作成されません。 ただし、MySQL 8.0.21 より前では、行ベースレプリケーションが使用されている場合、<code class="literal">CREATE TABLE ... SELECT</code> ステートメントは、テーブルを作成するトランザクションとデータを挿入するトランザクションの 2 つとしてバイナリログに記録されます。 ステートメントがバイナリログから適用された場合、2 つのトランザクション間またはデータのコピー中に障害が発生すると、空のテーブルが複製される可能性があります。 この制限は、MySQL 8.0.21 では削除されます。 アトミック DDL をサポートするストレージエンジンでは、行ベースレプリケーションが使用されているときに、<code class="literal">CREATE TABLE ... SELECT</code> が 1 つのトランザクションとして記録および適用されるようになりました。 詳細は、<a class="xref" href="sql-statements.html#atomic-ddl" title="13.1.1 アトミックデータ定義ステートメントのサポート">セクション13.1.1「アトミックデータ定義ステートメントのサポート」</a>を参照してください。 
      </p><p>
        MySQL 8.0.21 の時点では、アトミック DDL 制約と外部キー制約の両方をサポートするストレージエンジンでは、行ベースレプリケーションが使用されている場合、<code class="literal">CREATE TABLE ... SELECT</code> ステートメントで外部キーの作成は許可されません。 外部キー制約は、後で <code class="literal">ALTER TABLE</code> を使用して追加できます。 
      </p><p>
        一意のキー値を複製する行を処理する方法を示すために、<code class="literal">SELECT</code> の前に <code class="literal">IGNORE</code> または <code class="literal">REPLACE</code> を指定できます。 <code class="literal">IGNORE</code> を指定すると、一意のキー値に関して既存の行を複製する行は破棄されます。 <code class="literal">REPLACE</code> を指定すると、新しい行によって同じ一意のキー値を持つ行が置き換えられます。 <code class="literal">IGNORE</code> と <code class="literal">REPLACE</code> のどちらも指定されていない場合は、重複した一意のキー値によってエラーが発生します。 詳細は、<a class="xref" href="server-administration.html#ignore-effect-on-execution" title="IGNORE がステートメントの実行に与える影響">IGNORE がステートメントの実行に与える影響</a>を参照してください。 
      </p><p>
        MySQL 8.0.19 以降では、<code class="literal">CREATE TABLE ... SELECT</code> の <code class="literal">SELECT</code> 部分で <code class="literal">VALUES</code> ステートメントを使用することもできます。ステートメントの <code class="literal">VALUES</code> 部分には、<code class="literal">AS</code> 句を使用してテーブルのエイリアスを含める必要があります。 <code class="literal">VALUES</code> からのカラムに名前を付けるには、テーブルのエイリアスを使用してカラムのエイリアスを指定します。それ以外の場合は、デフォルトのカラム名の <code class="literal">column_0</code>, <code class="literal">column_1</code>, <code class="literal">column_2</code>... が使用されます。 
      </p><p>
        それ以外の場合、作成されるテーブルのカラムのネーミングは、このセクションで前述したものと同じルールに従います。 例: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE tv1</code></strong>
     &gt;     <strong class="userinput"><code>SELECT * FROM (VALUES ROW(1,3,5), ROW(2,4,6)) AS v;</code></strong>
mysql&gt; <strong class="userinput"><code>TABLE tv1;</code></strong>
+----------+----------+----------+
| column_0 | column_1 | column_2 |
+----------+----------+----------+
|        1 |        3 |        5 |
|        2 |        4 |        6 |
+----------+----------+----------+

mysql&gt; CREATE TABLE tv2
     &gt;     SELECT * FROM (VALUES ROW(1,3,5), ROW(2,4,6)) AS v(x,y,z);
mysql&gt; <strong class="userinput"><code>TABLE tv2;</code></strong>
+---+---+---+
| x | y | z |
+---+---+---+
| 1 | 3 | 5 |
| 2 | 4 | 6 |
+---+---+---+

mysql&gt; <strong class="userinput"><code>CREATE TABLE tv3 (a INT, b INT, c INT)</code></strong>
     &gt;     <strong class="userinput"><code>SELECT * FROM (VALUES ROW(1,3,5), ROW(2,4,6)) AS v(x,y,z);</code></strong>
mysql&gt; TABLE tv3;
+------+------+------+----------+----------+----------+
| a    | b    | c    | column_0 | column_1 | column_2 |
+------+------+------+----------+----------+----------+
| NULL | NULL | NULL |        1 |        3 |        5 |
| NULL | NULL | NULL |        2 |        4 |        6 |
+------+------+------+----------+----------+----------+

mysql&gt; <strong class="userinput"><code>CREATE TABLE tv4 (a INT, b INT, c INT)</code></strong>
     &gt;     <strong class="userinput"><code>SELECT * FROM (VALUES ROW(1,3,5), ROW(2,4,6)) AS v(x,y,z);</code></strong>
mysql&gt; <strong class="userinput"><code>TABLE tv4;</code></strong>
+------+------+------+---+---+---+
| a    | b    | c    | x | y | z |
+------+------+------+---+---+---+
| NULL | NULL | NULL | 1 | 3 | 5 |
| NULL | NULL | NULL | 2 | 4 | 6 |
+------+------+------+---+---+---+

mysql&gt; <strong class="userinput"><code>CREATE TABLE tv5 (a INT, b INT, c INT)</code></strong>
     &gt;     <strong class="userinput"><code>SELECT * FROM (VALUES ROW(1,3,5), ROW(2,4,6)) AS v(a,b,c);</code></strong>
mysql&gt; <strong class="userinput"><code>TABLE tv5;</code></strong>
+------+------+------+
| a    | b    | c    |
+------+------+------+
|    1 |    3 |    5 |
|    2 |    4 |    6 |
+------+------+------+
</pre><p>
        すべてのカラムを選択し、デフォルトのカラム名を使用する場合、<code class="literal">SELECT *</code> を省略できるため、テーブル <code class="literal">tv1</code> の作成に使用したステートメントも次のように記述できます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE tv1 VALUES ROW(1,3,5), ROW(2,4,6);</code></strong>
mysql&gt; <strong class="userinput"><code>TABLE tv1;</code></strong>
+----------+----------+----------+
| column_0 | column_1 | column_2 |
+----------+----------+----------+
|        1 |        3 |        5 |
|        2 |        4 |        6 |
+----------+----------+----------+
</pre><p>
        <code class="literal">VALUES</code> を <code class="literal">SELECT</code> のソースとして使用する場合、すべてのカラムが常に新しいテーブルに選択され、名前付きのテーブルから選択する場合と同じように個々のカラムを選択することはできません。次の各ステートメントではエラー (<code class="literal">ER_OPERAND_COLUMNS</code>) が生成されます:
      </p><pre class="programlisting">CREATE TABLE tvx
    SELECT (x,z) FROM (VALUES ROW(1,3,5), ROW(2,4,6)) AS v(x,y,z);

CREATE TABLE tvx (a INT, c INT)
    SELECT (x,z) FROM (VALUES ROW(1,3,5), ROW(2,4,6)) AS v(x,y,z);
</pre><p>
        同様に、<code class="literal">SELECT</code> のかわりに <code class="literal">TABLE</code> ステートメントを使用できます。 これは、<code class="literal">VALUES</code> の場合と同じルールに従います。ソーステーブルのすべてのカラムとその名前は、常に新しいテーブルに挿入されます。 例: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>TABLE t1;</code></strong>
+----+----+
| a  | b  |
+----+----+
|  1 |  2 |
|  6 |  7 |
| 10 | -4 |
| 14 |  6 |
+----+----+

mysql&gt; <strong class="userinput"><code>CREATE TABLE tt1 TABLE t1;</code></strong>
mysql&gt; <strong class="userinput"><code>TABLE tt1;</code></strong>
+----+----+
| a  | b  |
+----+----+
|  1 |  2 |
|  6 |  7 |
| 10 | -4 |
| 14 |  6 |
+----+----+

mysql&gt; <strong class="userinput"><code>CREATE TABLE tt2 (x INT) TABLE t1;</code></strong>
mysql&gt; <strong class="userinput"><code>TABLE tt2;</code></strong>
+------+----+----+
| x    | a  | b  |
+------+----+----+
| NULL |  1 |  2 |
| NULL |  6 |  7 |
| NULL | 10 | -4 |
| NULL | 14 |  6 |
+------+----+----+
</pre><p>
        基礎となる <code class="literal">SELECT</code> ステートメントの行の順序を常に決定できるわけではないため、<code class="literal">CREATE TABLE ... IGNORE SELECT</code> および <code class="literal">CREATE TABLE ... REPLACE SELECT</code> ステートメントには、ステートメントベースのレプリケーションに対して安全でないフラグが付けられます。 このようなステートメントは、ステートメントベースのモードの使用時にエラーログに警告を生成し、<code class="literal">MIXED</code> モードの使用時に行ベースの形式を使用してバイナリログに書き込まれます。 <a class="xref" href="replication.html#replication-sbr-rbr" title="17.2.1.1 ステートメントベースおよび行ベースレプリケーションのメリットとデメリット">セクション17.2.1.1「ステートメントベースおよび行ベースレプリケーションのメリットとデメリット」</a>も参照してください。 
      </p><p>
        <code class="literal">CREATE TABLE ... SELECT</code> は、どのインデックスも自動的には作成しません。 これは、ステートメントをできるだけ柔軟にするために意図的に行われます。 作成されたテーブル内にインデックスを設定する場合は、これらを <code class="literal">SELECT</code> ステートメントの前に指定するようにしてください。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE bar (UNIQUE (n)) SELECT n FROM foo;</code></strong>
</pre><p>
        <code class="literal">CREATE TABLE ... SELECT</code> の場合、宛先テーブルでは、選択元テーブルのカラムが生成されたカラムであるかどうかに関する情報は保持されません。 ステートメントの <code class="literal">SELECT</code> 部分では、宛先テーブルの生成されたカラムに値を割り当てることはできません。 
      </p><p>
        <code class="literal">CREATE TABLE ... SELECT</code> の場合、宛先テーブルは元のテーブルの式のデフォルト値を保持します。
      </p><p>
        何らかのデータ型の変換が実行される可能性があります。 たとえば、<code class="literal">AUTO_INCREMENT</code> 属性が保持されないため、<code class="literal">VARCHAR</code> カラムは <code class="literal">CHAR</code> カラムになることができます。 リトレインされる属性は <code class="literal">NULL</code> (または <code class="literal">NOT NULL</code>) と、それらを含むカラムの場合は、<code class="literal">CHARACTER SET</code>、<code class="literal">COLLATION</code>、<code class="literal">COMMENT</code>、および <code class="literal">DEFAULT</code> 句です。 
      </p><p>
        <code class="literal">CREATE TABLE ... SELECT</code> を使用してテーブルを作成する場合は、クエリー内のすべての関数呼び出しまたは式にエイリアスを付けるようにしてください。 そうしないと、<code class="literal">CREATE</code> ステートメントが失敗するか、または好ましくないカラム名が生成される可能性があります。 
      </p><pre class="programlisting">CREATE TABLE artists_and_works
  SELECT artist.name, COUNT(work.artist_id) AS number_of_works
  FROM artist LEFT JOIN work ON artist.id = work.artist_id
  GROUP BY artist.id;
</pre><p>
        作成したテーブルのカラムのデータ型を明示的に指定することもできます:
      </p><pre class="programlisting">CREATE TABLE foo (a TINYINT NOT NULL) SELECT b+1 AS a FROM bar;
</pre><p>
        <code class="literal">CREATE TABLE ... SELECT</code> では、<code class="literal">IF NOT EXISTS</code> が指定され、ターゲットテーブルが存在する場合、宛先テーブルには何も挿入されず、ステートメントはログに記録されません。
      </p><p>
        バイナリログを使用して元のテーブルを確実に再作成できるようにするために、MySQL では、<code class="literal">CREATE TABLE ... SELECT</code> 中の並列挿入が許可されません。 ただし、MySQL 8.0.21 より前では、行ベースレプリケーションが使用されているときにバイナリログから <code class="literal">CREATE TABLE ... SELECT</code> 操作が適用されると、データのコピー中にレプリケートされたテーブルでの同時挿入が許可されます。 この制限は、アトミック DDL をサポートするストレージエンジン上の MySQL 8.0.21 では削除されます。 詳細は、<a class="xref" href="sql-statements.html#atomic-ddl" title="13.1.1 アトミックデータ定義ステートメントのサポート">セクション13.1.1「アトミックデータ定義ステートメントのサポート」</a>を参照してください。 
      </p><p>
        <code class="literal">CREATE TABLE <em class="replaceable"><code>new_table</code></em> SELECT ... FROM <em class="replaceable"><code>old_table</code></em> ...</code> などのステートメントで <code class="literal">SELECT</code> の一部として <code class="literal">FOR UPDATE</code> を使用することはできません。 それを行おうとすると、このステートメントは失敗します。 
      </p><p>
        <code class="literal">CREATE TABLE ... SELECT</code> 操作では、<code class="literal">ENGINE_ATTRIBUTE</code> および <code class="literal">SECONDARY_ENGINE_ATTRIBUTE</code> の値はカラムにのみ適用されます。 明示的に指定しないかぎり、テーブルおよびインデックスの <code class="literal">ENGINE_ATTRIBUTE</code> および <code class="literal">SECONDARY_ENGINE_ATTRIBUTE</code> の値は新しいテーブルに適用されません。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="create-table-foreign-keys"></a>13.1.20.5 FOREIGN KEY の制約</h4></div></div></div><a class="indexterm" name="idm45827002931232"></a><a class="indexterm" name="idm45827002929808"></a><p>
        MySQL では、テーブル間の相互参照関連データを許可する外部キー、および関連データの一貫性を保つための外部キー制約がサポートされています。
      </p><p>
        外部キー関係には、初期カラム値を保持する親テーブルと、親カラム値を参照するカラム値を持つ子テーブルが含まれます。 子テーブルに外部キー制約が定義されています。 
      </p><p>
        <code class="literal">CREATE TABLE</code> ステートメントまたは <code class="literal">ALTER TABLE</code> ステートメントで外部キー制約を定義するために不可欠な構文は次のとおりです:
      </p><pre class="programlisting">[CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] FOREIGN KEY
    [<em class="replaceable"><code>index_name</code></em>] (<em class="replaceable"><code>col_name</code></em>, ...)
    REFERENCES <em class="replaceable"><code>tbl_name</code></em> (<em class="replaceable"><code>col_name</code></em>,...)
    [ON DELETE <em class="replaceable"><code>reference_option</code></em>]
    [ON UPDATE <em class="replaceable"><code>reference_option</code></em>]

<em class="replaceable"><code>reference_option</code></em>:
    RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT
</pre><p>
        外部キー制約の使用方法については、このセクションの次のトピックで説明します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#foreign-key-identifiers" title="識別子">識別子</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#foreign-key-restrictions" title="条件と制限">条件と制限</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#foreign-key-referential-actions" title="参照アクション">参照アクション</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#foreign-key-examples" title="外部キー制約の例">外部キー制約の例</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#foreign-key-adding" title="外部キー制約の追加">外部キー制約の追加</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#foreign-key-dropping" title="外部キー制約の削除">外部キー制約の削除</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#foreign-key-checks" title="外部キーチェック">外部キーチェック</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#foreign-key-locking" title="ロック中">ロック中</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#foreign-key-metadata" title="外部キー定義およびメタデータ">外部キー定義およびメタデータ</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#foreign-key-errors" title="外部キーエラー">外部キーエラー</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="foreign-key-identifiers"></a>識別子</h5></div></div></div><p>
          外部キー制約のネーミングは、次のルールによって制御されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">CONSTRAINT</code> <em class="replaceable"><code>symbol</code></em> 値が使用されます (定義されている場合)。
            </p></li><li class="listitem"><p>
              <code class="literal">CONSTRAINT</code> <em class="replaceable"><code>symbol</code></em> 句が定義されていない場合、または <code class="literal">CONSTRAINT</code> キーワードの後に記号が含まれていない場合は、制約名が自動的に生成されます。
            </p><p>
              MySQL 8.0.16 より前では、<code class="literal">CONSTRAINT</code> <em class="replaceable"><code>symbol</code></em> 句が定義されていなかった場合、または <code class="literal">CONSTRAINT</code> キーワードのあとにシンボルが含まれていなかった場合、<code class="literal">InnoDB</code> と <code class="literal">NDB</code> の両方のストレージエンジンは <code class="literal">FOREIGN_KEY <em class="replaceable"><code>index_name</code></em></code> を使用します (定義されている場合)。 MySQL 8.0.16 以上では、<code class="literal">FOREIGN_KEY <em class="replaceable"><code>index_name</code></em></code> は無視されます。 
            </p></li><li class="listitem"><p>
              定義されている場合、<code class="literal">CONSTRAINT <em class="replaceable"><code>symbol</code></em></code> 値はデータベース内で一意である必要があります。 <em class="replaceable"><code>symbol</code></em> が重複すると、次のようなエラーが発生: <span class="errortext">ERROR 1005 (HY000): テーブル'test.fk1'を作成できません (errno: 121)</span>。 
            </p></li><li class="listitem"><p>
              NDB Cluster は、外部名を作成時と同じ大文字/小文字を使用して格納します。 8.0.20 より前のバージョンでは、<code class="literal">SELECT</code> およびその他の SQL ステートメントを処理する際に、<code class="literal">NDB</code> は、<code class="literal">lower_case_table_names</code> が 0 に等しい場合に、そのようなステートメントの外部キーの名前を大/小文字を区別して格納された名前と比較していました。 NDB 8.0.20 以降では、この値はこのような比較の方法に影響を与えなくなり、大文字と小文字に関係なく常に実行されます。 (Bug #30512043) 
            </p></li></ul></div><p>
          <code class="literal">FOREIGN KEY ... REFERENCES</code> 句内のテーブルとカラムの識別子は、逆引用符 (<code class="literal">`</code>) で囲むことができます。 あるいは、<code class="literal">ANSI_QUOTES</code> SQL モードが有効になっている場合は、二重引用符 (<code class="literal">"</code>) を使用できます。 <code class="literal">lower_case_table_names</code> システム変数の設定も考慮されます。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="foreign-key-restrictions"></a>条件と制限</h5></div></div></div><p>
          外部キー制約には、次の条件および制限事項があります:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              親テーブルと子テーブルは同じストレージエンジンを使用する必要があり、一時テーブルとして定義することはできません。
            </p></li><li class="listitem"><p>
              外部キー制約を作成するには、親テーブルに対する <code class="literal">REFERENCES</code> 権限が必要です。
            </p></li><li class="listitem"><p>
              外部キー内の対応するカラムと、参照されるキーは同様のデータ型を持っている必要があります。 <span class="emphasis"><em>「<code class="literal">INTEGER</code> や <code class="literal">DECIMAL</code> などの固定精度タイプのサイズと符号は同じである必要があります」</em></span>。 文字列型の長さが同じである必要はありません。 バイナリ以外の (文字の) 文字列カラムの場合、文字セットと照合順序が同じである必要があります。 
            </p></li><li class="listitem"><p>
              MySQL は、1 つのテーブル内のあるカラムと別のカラムの間の外部キー参照をサポートしています。 (あるカラムが、それ自体への外部キー参照を持つことはできません。) このような場合、<span class="quote">「<span class="quote">「子テーブルレコード」</span>」</span>は同じテーブル内の依存レコードを参照します。 
            </p></li><li class="listitem"><p>
              MySQL では、外部キーチェックを高速に実行でき、かつテーブルスキャンが必要なくなるように、外部キーおよび参照されるキーに関するインデックスが必要です。 参照しているテーブルには、外部キーカラムが同じ順序で<span class="emphasis"><em>最初の</em></span>カラムとしてリストされているインデックスが存在する必要があります。 このようなインデックスが存在しない場合は、参照しているテーブル上に自動的に作成されます。 外部キー制約の施行に使用できる別のインデックスを作成した場合、このインデックスは後で暗黙的に削除される可能性があります。<em class="replaceable"><code>index_name</code></em> が指定されている場合は、前述のように使用されます。 
            </p></li><li class="listitem"><p>
              <code class="literal">InnoDB</code> では、外部キーが任意のインデックスカラムまたはカラムのグループを参照することが許可されます。 ただし、参照テーブルには、参照カラムが同じ順序の <span class="emphasis"><em>first</em></span> カラムであるインデックスが必要です。 <code class="literal">InnoDB</code> がインデックスに追加する非表示カラムも考慮されます (<a class="xref" href="innodb-storage-engine.html#innodb-index-types" title="15.6.2.1 クラスタインデックスとセカンダリインデックス">セクション15.6.2.1「クラスタインデックスとセカンダリインデックス」</a> を参照)。 
            </p><p>
              <code class="literal">NDB</code> には、外部キーとして参照されるいずれかのカラム上の明示的な一意のキー (または主キー) が必要です。 <code class="literal">InnoDB</code> では、標準 SQL の拡張ではありません。 
            </p></li><li class="listitem"><p>
              外部キーカラム上のインデックスプリフィクスはサポートされていません。 したがって、<code class="literal">BLOB</code> カラムおよび <code class="literal">TEXT</code> カラムは、常に接頭辞の長さを含む必要があるため、外部キーに含めることはできません。 
            </p></li><li class="listitem"><p>
              現在、<code class="literal">InnoDB</code> ではユーザー定義のパーティションを持つテーブルの外部キーがサポートされていません。 これには、親テーブルと子テーブルの両方が含まれます。 
            </p><p>
              この制限は、<code class="literal">KEY</code> または <code class="literal">LINEAR KEY</code> によってパーティション化された <code class="literal">NDB</code> テーブル (<code class="literal">NDB</code> ストレージエンジンによってサポートされる唯一のユーザーパーティショニングタイプ) には適用されません。これらは外部キー参照を含むか、またはこのような参照のターゲットになることができます。
            </p></li><li class="listitem"><p>
              外部キー関係のテーブルは、別のストレージエンジンを使用するように変更できません。 ストレージエンジンを変更するには、まず外部キー制約をすべて削除する必要があります。 
            </p></li><li class="listitem"><p>
              外部キー制約は、仮想生成カラムを参照できません。
            </p></li></ul></div><p>
          外部キー制約の MySQL 実装と SQL 標準の違いの詳細は、<a class="xref" href="introduction.html#ansi-diff-foreign-keys" title="1.7.2.3 FOREIGN KEY 制約の違い">セクション1.7.2.3「FOREIGN KEY 制約の違い」</a> を参照してください。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="foreign-key-referential-actions"></a>参照アクション</h5></div></div></div><p>
          <code class="literal">UPDATE</code> または <code class="literal">DELETE</code> 操作が、子テーブルで一致する行を持つ親テーブルのキー値に影響する場合、結果は <code class="literal">FOREIGN KEY</code> 句の <code class="literal">ON UPDATE</code> および <code class="literal">ON DELETE</code> 副次句で指定された<span class="emphasis"><em>参照アクション</em></span>によって異なります。 参照アクションには次のものがあります: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">CASCADE</code>: 親テーブルから行を削除または更新し、子テーブル内の一致する行を自動的に削除または更新します。 <code class="literal">ON DELETE CASCADE</code> と <code class="literal">ON UPDATE CASCADE</code> の両方がサポートされています。 2 つのテーブル間で、親テーブルまたは子テーブル内の同じカラムに対して機能する複数の <code class="literal">ON UPDATE CASCADE</code> 句を定義しないでください。 
            </p><p>
              外部キーリレーションシップの両方のテーブルに <code class="literal">FOREIGN KEY</code> 句が定義されている場合、カスケード操作を成功させるには、一方の <code class="literal">FOREIGN KEY</code> 句に定義されている <code class="literal">ON UPDATE CASCADE</code> または <code class="literal">ON DELETE CASCADE</code> 副次句をもう一方の <code class="literal">FOREIGN KEY</code> 句に定義する必要があります。 <code class="literal">ON UPDATE CASCADE</code> または <code class="literal">ON DELETE CASCADE</code> 副次句が <code class="literal">FOREIGN KEY</code> 句に対してのみ定義されている場合、カスケード操作はエラーで失敗します。 
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                カスケードされた外部キーアクションはトリガーをアクティブ化しません。
              </p></div></li><li class="listitem"><p>
              <code class="literal">SET NULL</code>: 親テーブルから行を削除または更新し、子テーブルの外部キーカラムを <code class="literal">NULL</code> に設定します。 <code class="literal">ON DELETE SET NULL</code> 句と <code class="literal">ON UPDATE SET NULL</code> 句の両方がサポートされています。 
            </p><p>
              <code class="literal">SET NULL</code> アクションを指定する場合は、<span class="emphasis"><em>子テーブル内のカラムを <code class="literal">NOT NULL</code> として宣言していないことを確認してください</em></span>。
            </p></li><li class="listitem"><p>
              <code class="literal">RESTRICT</code>: 親テーブルに対する削除または更新操作を拒否します。 <code class="literal">RESTRICT</code> (または <code class="literal">NO ACTION</code>) を指定することは、<code class="literal">ON DELETE</code> または <code class="literal">ON UPDATE</code> 句を省略することと同じです。 
            </p></li><li class="listitem"><p>
              <code class="literal">NO ACTION</code>: 標準 SQL のキーワード。 MySQL では、<code class="literal">RESTRICT</code> と同等です。 MySQL Server は、参照されるテーブル内に関連する外部キー値が存在する場合、親テーブルに対する削除または更新操作を拒否します。 一部のデータベースシステムは遅延チェックを備えており、その場合、<code class="literal">NO ACTION</code> は遅延チェックです。 MySQL では、外部キー制約はただちにチェックされるため、<code class="literal">NO ACTION</code> は <code class="literal">RESTRICT</code> と同じです。 
            </p></li><li class="listitem"><p>
              <code class="literal">SET DEFAULT</code>: このアクションは MySQL パーサーによって認識されますが、<code class="literal">InnoDB</code> と <code class="literal">NDB</code> はどちらも、<code class="literal">ON DELETE SET DEFAULT</code> または <code class="literal">ON UPDATE SET DEFAULT</code> 句を含むテーブル定義を拒否します。
            </p></li></ul></div><p>
          外部キーをサポートするストレージエンジンでは、親テーブルに一致する候補キー値がない場合、MySQL は子テーブルに外部キー値を作成しようとする <code class="literal">INSERT</code> または <code class="literal">UPDATE</code> 操作を拒否します。
        </p><p>
          指定されていない <code class="literal">ON DELETE</code> または <code class="literal">ON UPDATE</code> の場合、デフォルトのアクションは常に <code class="literal">NO ACTION</code> です。
        </p><p>
          デフォルトでは、明示的に指定された <code class="literal">ON DELETE NO ACTION</code> または <code class="literal">ON UPDATE NO ACTION</code> 句は、<code class="literal">SHOW CREATE TABLE</code> 出力または <span class="command"><strong>mysqldump</strong></span> でダンプされたテーブルには表示されません。 同等のデフォルト以外のキーワードである <code class="literal">RESTRICT</code> は、<code class="literal">SHOW CREATE TABLE</code> 出力および <span class="command"><strong>mysqldump</strong></span> でダンプされたテーブルに表示されます。 
        </p><p>
          <code class="literal">NDB</code> テーブルでは、参照先が親テーブルの主キーである場合、<code class="literal">ON UPDATE CASCADE</code> はサポートされません。
        </p><p>
          NDB 8.0.16 の時点: <code class="literal">NDB</code> テーブルの場合、子テーブルに <code class="literal">TEXT</code> 型または <code class="literal">BLOB</code> 型のいずれかのカラムが含まれる <code class="literal">ON DELETE CASCADE</code> はサポートされません。 (Bug #89511、Bug #27484882) 
        </p><p>
          <code class="literal">InnoDB</code> は、外部キー制約に対応するインデックスのレコードに対して、深さ優先検索アルゴリズムを使用してカスケード操作を実行します。
        </p><p>
          格納された生成カラムに対する外部キー制約では、<code class="literal">CASCADE</code>、<code class="literal">SET NULL</code> または <code class="literal">SET DEFAULT</code> を <code class="literal">ON UPDATE</code> 参照アクションとして使用することも、<code class="literal">SET NULL</code> または <code class="literal">SET DEFAULT</code> を <code class="literal">ON DELETE</code> 参照アクションとして使用することもできません。
        </p><p>
          格納された生成カラムのベースカラムに対する外部キー制約では、<code class="literal">CASCADE</code>、<code class="literal">SET NULL</code> または <code class="literal">SET DEFAULT</code> を <code class="literal">ON UPDATE</code> または <code class="literal">ON DELETE</code> の参照アクションとして使用できません。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="foreign-key-examples"></a>外部キー制約の例</h5></div></div></div><p>
          次の簡単な例では、単一カラムの外部キーを使用して <code class="literal">parent</code> テーブルと <code class="literal">child</code> テーブルを関連付けます:
        </p><pre class="programlisting">CREATE TABLE parent (
    id INT NOT NULL,
    PRIMARY KEY (id)
) ENGINE=INNODB;

CREATE TABLE child (
    id INT,
    parent_id INT,
    INDEX par_ind (parent_id),
    FOREIGN KEY (parent_id)
        REFERENCES parent(id)
        ON DELETE CASCADE
) ENGINE=INNODB;
</pre><p>
          これは、<code class="literal">product_order</code> テーブルに他の 2 つのテーブルの外部キーがある、より複雑な例です。 1 つの外部キーが、<code class="literal">product</code> テーブル内の 2 カラムのインデックスを参照しています。 もう一方の外部キーは、<code class="literal">customer</code> テーブル内の単一カラムインデックスを参照しています。 
        </p><pre class="programlisting">CREATE TABLE product (
    category INT NOT NULL, id INT NOT NULL,
    price DECIMAL,
    PRIMARY KEY(category, id)
)   ENGINE=INNODB;

CREATE TABLE customer (
    id INT NOT NULL,
    PRIMARY KEY (id)
)   ENGINE=INNODB;

CREATE TABLE product_order (
    no INT NOT NULL AUTO_INCREMENT,
    product_category INT NOT NULL,
    product_id INT NOT NULL,
    customer_id INT NOT NULL,

    PRIMARY KEY(no),
    INDEX (product_category, product_id),
    INDEX (customer_id),

    FOREIGN KEY (product_category, product_id)
      REFERENCES product(category, id)
      ON UPDATE CASCADE ON DELETE RESTRICT,

    FOREIGN KEY (customer_id)
      REFERENCES customer(id)
)   ENGINE=INNODB;
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="foreign-key-adding"></a>外部キー制約の追加</h5></div></div></div><p>
          次の <code class="literal">ALTER TABLE</code> 構文を使用して、既存のテーブルに外部キー制約を追加できます:
        </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em>
    ADD [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] FOREIGN KEY
    [<em class="replaceable"><code>index_name</code></em>] (<em class="replaceable"><code>col_name</code></em>, ...)
    REFERENCES <em class="replaceable"><code>tbl_name</code></em> (<em class="replaceable"><code>col_name</code></em>,...)
    [ON DELETE <em class="replaceable"><code>reference_option</code></em>]
    [ON UPDATE <em class="replaceable"><code>reference_option</code></em>]
</pre><p>
          外部キーは、自己参照型にする (同じテーブルを参照する) ことができます。 <code class="literal">ALTER TABLE</code>、<span class="emphasis"><em>最初に、外部キーによって参照されるカラムにインデックスを作成してください</em></span>を使用してテーブルに外部キー制約を追加する場合。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="foreign-key-dropping"></a>外部キー制約の削除</h5></div></div></div><a class="indexterm" name="idm45827002750768"></a><a class="indexterm" name="idm45827002749456"></a><a class="indexterm" name="idm45827002747312"></a><p>
          次の <code class="literal">ALTER TABLE</code> 構文を使用して、外部キー制約を削除できます:
        </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DROP FOREIGN KEY <em class="replaceable"><code>fk_symbol</code></em>;
</pre><p>
          制約の作成時に <code class="literal">FOREIGN KEY</code> 句で <code class="literal">CONSTRAINT</code> 名が定義されていた場合は、その名前を参照して外部キー制約を削除できます。 それ以外の場合は、制約名が内部的に生成されているため、その値を使用する必要があります。 外部キー制約名を確認するには、<code class="literal">SHOW CREATE TABLE</code> を使用します: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE child\G</code></strong>
*************************** 1. row ***************************
       Table: child
Create Table: CREATE TABLE `child` (
  `id` int DEFAULT NULL,
  `parent_id` int DEFAULT NULL,
  KEY `par_ind` (`parent_id`),
  CONSTRAINT `child_ibfk_1` FOREIGN KEY (`parent_id`)
  REFERENCES `parent` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci

mysql&gt; <strong class="userinput"><code>ALTER TABLE child DROP FOREIGN KEY `child_ibfk_1`;</code></strong>
</pre><p>
          <code class="literal">ALTER TABLE ... ALGORITHM=INPLACE</code> では、同じ <code class="literal">ALTER TABLE</code> ステートメントでの外部キーの追加および削除がサポートされています。 <code class="literal">ALTER TABLE ... ALGORITHM=COPY</code> ではサポートされていません。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="foreign-key-checks"></a>外部キーチェック</h5></div></div></div><p>
          外部キーチェックは、デフォルトで有効になっている <code class="literal">foreign_key_checks</code> 変数によって制御されます。 通常、この変数は通常の操作中は有効のままにして、参照整合性を強制します。 <code class="literal">foreign_key_checks</code> 変数は、<code class="literal">InnoDB</code> テーブルの場合と同じ効果を <code class="literal">NDB</code> テーブルに与えます。 
        </p><p>
          <code class="literal">foreign_key_checks</code> 変数は動的であり、グローバルスコープとセッションスコープの両方をサポートします。 システム変数の使用の詳細は、<a class="xref" href="server-administration.html#using-system-variables" title="5.1.9 システム変数の使用">セクション5.1.9「システム変数の使用」</a> を参照してください。 
        </p><p>
          外部キーチェックの無効化は、次の場合に役立ちます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              外部キー制約によって参照されるテーブルの削除。 参照テーブルは、<code class="literal">foreign_key_checks</code> が無効化された後にのみ削除できます。 テーブルを削除すると、テーブルに定義されている制約も削除されます。 
            </p></li><li class="listitem"><p>
              外部キー関係に必要な順序とは異なる順序でテーブルをリロードします。 たとえば、<span class="command"><strong>mysqldump</strong></span> では、子テーブルの外部キー制約など、ダンプファイル内のテーブルの正しい定義が生成されます。 外部キー関係を持つテーブルのダンプファイルを簡単にリロードできるように、<span class="command"><strong>mysqldump</strong></span> では、<code class="literal">foreign_key_checks</code> を無効にするステートメントがダンプ出力に自動的に含まれます。 これにより、ダンプファイルに外部キーに対して正しく順序付けされていないテーブルが含まれている場合に、任意の順序でテーブルをインポートできます。 <code class="literal">foreign_key_checks</code> を無効にすると、外部キーチェックが回避され、インポート操作も高速化されます。 
            </p></li><li class="listitem"><p>
              外部キーチェックを回避するための <code class="literal">LOAD DATA</code> 操作の実行。
            </p></li><li class="listitem"><p>
              外部キー関係を持つテーブルに対する <code class="literal">ALTER TABLE</code> 操作の実行。
            </p></li></ul></div><p>
          <code class="literal">foreign_key_checks</code> が無効な場合、外部キー制約は無視されますが、次の例外があります:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              テーブル定義がテーブルを参照する外部キー制約に準拠していない場合、以前に削除されたテーブルを再作成するとエラーが返されます。 テーブルには正しいカラム名およびタイプが必要です。 参照キーに対するインデックスも必要です。 これらの要件が満たされない場合、MySQL は errno を参照するエラー 1005 を返します: 150:外部キー制約が正しく形成されなかったことを意味します。 
            </p></li><li class="listitem"><p>
              テーブルを変更すると、エラーが返されます (errno: 150) 変更されたテーブルに対して外部キー定義が正しく構成されていない場合。
            </p></li><li class="listitem"><p>
              外部キー制約に必要なインデックスの削除。 インデックスを削除する前に、外部キー制約を削除する必要があります。 
            </p></li><li class="listitem"><p>
              カラムが一致しないカラムタイプを参照する外部キー制約の作成。
            </p></li></ul></div><p>
          <code class="literal">foreign_key_checks</code> を無効にすると、次の追加の影響があります:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              データベースの外部のテーブルによって参照される外部キーを持つテーブルを含むデータベースを削除できます。
            </p></li><li class="listitem"><p>
              外部キーが他のテーブルによって参照されているテーブルを削除できます。
            </p></li><li class="listitem"><p>
              <code class="literal">foreign_key_checks</code> を有効にしてもテーブルデータのスキャンはトリガーされません。つまり、<code class="literal">foreign_key_checks</code> が無効になっている間にテーブルに追加された行は、<code class="literal">foreign_key_checks</code> が再度有効になったときに一貫性がチェックされません。
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="foreign-key-locking"></a>ロック中</h5></div></div></div><p>
          MySQL は、必要に応じて、外部キー制約によって関連付けられたテーブルにメタデータロックを拡張します。 メタデータロックを拡張すると、競合する DML 操作および DDL 操作が関連するテーブルで同時に実行されなくなります。 この機能を使用すると、親テーブルが変更されたときに外部キーメタデータを更新することもできます。 以前の MySQL リリースでは、子テーブルが所有する外部キーメタデータは安全に更新できませんでした。 
        </p><p>
          テーブルが <code class="literal">LOCK TABLES</code> で明示的にロックされている場合、外部キー制約に関連するテーブルはすべて暗黙的にオープンおよびロックされます。 外部キーチェックでは、関連するテーブルに対して共有読取り専用ロック (<code class="literal">LOCK TABLES READ</code>) が取得されます。 カスケード更新では、操作に関連する関連テーブルに対してシェアードナッシング書込みロック (<code class="literal">LOCK TABLES WRITE</code>) が取得されます。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="foreign-key-metadata"></a>外部キー定義およびメタデータ</h5></div></div></div><p>
          外部キー定義を表示するには、<code class="literal">SHOW CREATE TABLE</code> を使用します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE child\G</code></strong>
*************************** 1. row ***************************
       Table: child
Create Table: CREATE TABLE `child` (
  `id` int DEFAULT NULL,
  `parent_id` int DEFAULT NULL,
  KEY `par_ind` (`parent_id`),
  CONSTRAINT `child_ibfk_1` FOREIGN KEY (`parent_id`)
  REFERENCES `parent` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
</pre><p>
          <code class="literal">INFORMATION_SCHEMA.KEY_COLUMN_USAGE</code> テーブルから、外部キーに関する情報を取得できます。 このテーブルに対するクエリーの例を次に示します。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME, CONSTRAINT_NAME</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE</code></strong>
       <strong class="userinput"><code>WHERE REFERENCED_TABLE_SCHEMA IS NOT NULL;</code></strong>
+--------------+------------+-------------+-----------------+
| TABLE_SCHEMA | TABLE_NAME | COLUMN_NAME | CONSTRAINT_NAME |
+--------------+------------+-------------+-----------------+
| test         | child      | parent_id   | child_ibfk_1    |
+--------------+------------+-------------+-----------------+
</pre><p>
          <code class="literal">InnoDB</code> 外部キーに固有の情報は、<code class="literal">INNODB_FOREIGN</code> テーブルおよび <code class="literal">INNODB_FOREIGN_COLS</code> テーブルから取得できます。 クエリーの例を次に示します: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_FOREIGN \G</code></strong>
*************************** 1. row ***************************
      ID: test/child_ibfk_1
FOR_NAME: test/child
REF_NAME: test/parent
  N_COLS: 1
    TYPE: 1

mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_FOREIGN_COLS \G</code></strong>
*************************** 1. row ***************************
          ID: test/child_ibfk_1
FOR_COL_NAME: parent_id
REF_COL_NAME: id
         POS: 0
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="foreign-key-errors"></a>外部キーエラー</h5></div></div></div><p>
          <code class="literal">InnoDB</code> テーブルに関連する外部キーエラー (通常は MySQL Server のエラー 150) が発生した場合、<code class="literal">SHOW ENGINE INNODB STATUS</code> 出力をチェックすることで、最新の外部キーエラーに関する情報を取得できます。
        </p><pre class="programlisting">mysql&gt; SHOW ENGINE INNODB STATUS\G
...
------------------------
LATEST FOREIGN KEY ERROR
------------------------
2018-04-12 14:57:24 0x7f97a9c91700 Transaction:
TRANSACTION 7717, ACTIVE 0 sec inserting
mysql tables in use 1, locked 1
4 lock struct(s), heap size 1136, 3 row lock(s), undo log entries 3
MySQL thread id 8, OS thread handle 140289365317376, query id 14 localhost root update
INSERT INTO child VALUES (NULL, 1), (NULL, 2), (NULL, 3), (NULL, 4), (NULL, 5), (NULL, 6)
Foreign key constraint fails for table `test`.`child`:
,
  CONSTRAINT `child_ibfk_1` FOREIGN KEY (`parent_id`) REFERENCES `parent` (`id`) ON DELETE
  CASCADE ON UPDATE CASCADE
Trying to add in child table, in index par_ind tuple:
DATA TUPLE: 2 fields;
 0: len 4; hex 80000003; asc     ;;
 1: len 4; hex 80000003; asc     ;;

But in parent table `test`.`parent`, in index PRIMARY,
the closest match we can find is record:
PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000004; asc     ;;
 1: len 6; hex 000000001e19; asc       ;;
 2: len 7; hex 81000001110137; asc       7;;
...
</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
            ユーザーがすべての親テーブルに対するテーブルレベルの権限を持っている場合、外部キー操作に関する <code class="literal">ER_NO_REFERENCED_ROW_2</code> および <code class="literal">ER_ROW_IS_REFERENCED_2</code> のエラーメッセージでは、親テーブルに関する情報が公開されます。 ユーザーがすべての親テーブルに対するテーブルレベルの権限を持っていない場合は、かわりにより一般的なエラーメッセージ (<code class="literal">ER_NO_REFERENCED_ROW</code> および <code class="literal">ER_ROW_IS_REFERENCED</code>) が表示されます。 
          </p><p>
            例外として、<code class="literal">DEFINER</code> 権限で実行するように定義されたストアドプログラムの場合、権限が評価されるユーザーは、起動するユーザーではなく、プログラムの <code class="literal">DEFINER</code> 句のユーザーです。 そのユーザーがテーブルレベルの親テーブル権限を持っている場合でも、親テーブルの情報は表示されます。 この場合、ストアドプログラムの作成者は、適切な条件ハンドラを含めて情報を非表示にする必要があります。 
          </p></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="create-table-check-constraints"></a>13.1.20.6 CHECK 制約</h4></div></div></div><a class="indexterm" name="idm45827002653568"></a><p>
        MySQL 8.0.16 より前の <code class="literal">CREATE TABLE</code> では、次の限定バージョンのテーブル <code class="literal">CHECK</code> 制約構文のみが許可されていました。この構文は解析され、無視されます:
      </p><pre class="programlisting">CHECK (<em class="replaceable"><code>expr</code></em>)
</pre><p>
        MySQL 8.0.16 の時点で、<code class="literal">CREATE TABLE</code> は、すべてのストレージエンジンに対して、テーブルおよびカラムの <code class="literal">CHECK</code> 制約のコア機能を許可します。 <code class="literal">CREATE TABLE</code> では、テーブル制約とカラム制約の両方に対して、次の <code class="literal">CHECK</code> 制約構文を使用できます: 
      </p><pre class="programlisting">[CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] CHECK (<em class="replaceable"><code>expr</code></em>) [[NOT] ENFORCED]
</pre><p>
        オプションの <em class="replaceable"><code>symbol</code></em> では、制約の名前を指定します。 省略すると、MySQL はテーブル名、リテラル<code class="literal">_chk_</code>および序数 (1、2、3 など) から名前を生成します。 制約名の最大長は 64 文字です。 大/小文字は区別されますが、アクセントは区別されません。 
      </p><p>
        <em class="replaceable"><code>expr</code></em> では、制約条件をブール式として指定します。この式は、テーブルの各行に対して <code class="literal">TRUE</code> または <code class="literal">UNKNOWN</code> (<code class="literal">NULL</code> 値の場合) に評価される必要があります。 条件が <code class="literal">FALSE</code> に評価されると、失敗し、制約違反が発生します。 違反の影響は、このセクションの後半で説明するように、実行されるステートメントによって異なります。 
      </p><p>
        オプションの施行句は、制約が施行されるかどうかを示します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            省略するか、<code class="literal">ENFORCED</code> として指定すると、制約が作成されて適用されます。
          </p></li><li class="listitem"><p>
            <code class="literal">NOT ENFORCED</code> として指定した場合、制約は作成されますが、施行されません。
          </p></li></ul></div><p>
        <code class="literal">CHECK</code> 制約は、テーブル制約またはカラム制約のいずれかとして指定されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブル制約はカラム定義内には表示されず、任意のテーブルのカラムを参照できます。 前方参照は、後でテーブル定義に表示されるカラムに対して許可されます。 
          </p></li><li class="listitem"><p>
            カラム制約はカラム定義内に表示され、そのカラムのみを参照できます。
          </p></li></ul></div><p>
        このテーブル定義について考えます。
      </p><pre class="programlisting">CREATE TABLE t1
(
  CHECK (c1 &lt;&gt; c2),
  c1 INT CHECK (c1 &gt; 10),
  c2 INT CONSTRAINT c2_positive CHECK (c2 &gt; 0),
  c3 INT CHECK (c3 &lt; 100),
  CONSTRAINT c1_nonzero CHECK (c1 &lt;&gt; 0),
  CHECK (c1 &gt; c3)
);
</pre><p>
        定義には、名前付き形式および名前なし形式のテーブル制約およびカラム制約が含まれます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            最初の制約はテーブル制約です: カラム定義の外部で発生するため、複数のテーブルのカラムを参照できます (参照することもできます)。 この制約には、まだ定義されていないカラムへのフォワード参照が含まれています。 制約名が指定されていないため、MySQL は名前を生成します。 
          </p></li><li class="listitem"><p>
            次の 3 つの制約はカラム制約です: それぞれがカラム定義内で発生するため、参照できるのは定義されているカラムのみです。 いずれかの制約に明示的に名前が付けられます。 MySQL では、それぞれの名前が生成されます。 
          </p></li><li class="listitem"><p>
            最後の 2 つの制約はテーブル制約です。 これらのいずれかに明示的に名前が付けられます。 MySQL により、他方の名前が生成されます。 
          </p></li></ul></div><p>
        前述のように、MySQL は、指定されていない <code class="literal">CHECK</code> 制約の名前を生成します。 前述のテーブル定義に対して生成された名前を確認するには、<code class="literal">SHOW CREATE TABLE</code> を使用します: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t1\G</code></strong>
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `c1` int(11) DEFAULT NULL,
  `c2` int(11) DEFAULT NULL,
  `c3` int(11) DEFAULT NULL,
  CONSTRAINT `c1_nonzero` CHECK ((`c1` &lt;&gt; 0)),
  CONSTRAINT `c2_positive` CHECK ((`c2` &gt; 0)),
  CONSTRAINT `t1_chk_1` CHECK ((`c1` &lt;&gt; `c2`)),
  CONSTRAINT `t1_chk_2` CHECK ((`c1` &gt; 10)),
  CONSTRAINT `t1_chk_3` CHECK ((`c3` &lt; 100)),
  CONSTRAINT `t1_chk_4` CHECK ((`c1` &gt; `c3`))
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
</pre><p>
        SQL 標準では、すべてのタイプの制約 (主キー、一意インデックス、外部キー、チェック) が同じネームスペースに属することが指定されています。 MySQL では、各制約タイプにスキーマ (データベース) ごとに独自のネームスペースがあります。 したがって、<code class="literal">CHECK</code> 制約名はスキーマごとに一意である必要があります。同じスキーマ内の複数のテーブルで <code class="literal">CHECK</code> 制約名を共有することはできません。 (例外: <code class="literal">TEMPORARY</code> テーブルは、同じ名前の <code class="literal">TEMPORARY</code> 以外のテーブルを非表示にするため、同じ <code class="literal">CHECK</code> 制約名を持つこともできます。) 
      </p><p>
        生成された制約名をテーブル名で開始すると、テーブル名もスキーマ内で一意である必要があるため、スキーマの一意性が保証されます。
      </p><p>
        <code class="literal">CHECK</code> の条件式は、次のルールに従う必要があります。 許可されていない構造が式に含まれている場合は、エラーが発生します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">AUTO_INCREMENT</code> 属性を持つカラムおよび他のテーブルのカラムを除き、生成されていないカラムおよび生成されたカラムは許可されます。
          </p></li><li class="listitem"><p>
            リテラル、決定的組込み関数および演算子を使用できます。 関数は、テーブル内の同じデータが指定された場合、接続ユーザーとは関係なく、複数の起動で同じ結果が生成される場合は決定論的です。 非決定的で、この定義に失敗する関数の例: <code class="literal">CONNECTION_ID()</code>, <code class="literal">CURRENT_USER()</code>, <code class="literal">NOW()</code>。 
          </p></li><li class="listitem"><p>
            ストアドファンクションおよびユーザー定義関数は使用できません。
          </p></li><li class="listitem"><p>
            ストアドプロシージャおよびストアドファンクションのパラメータは使用できません。
          </p></li><li class="listitem"><p>
            変数 (システム変数、ユーザー定義変数およびストアドプログラムローカル変数) は使用できません。
          </p></li><li class="listitem"><p>
            サブクエリーは許可されません。
          </p></li></ul></div><p>
        外部キー参照アクション (<code class="literal">ON UPDATE</code>、<code class="literal">ON DELETE</code>) は、<code class="literal">CHECK</code> 制約で使用されるカラムでは禁止されています。 同様に、<code class="literal">CHECK</code> 制約は、外部キー参照アクションで使用されるカラムでは禁止されています。 
      </p><p>
        <code class="literal">CHECK</code> 制約は、<code class="literal">INSERT</code>, <code class="literal">UPDATE</code>, <code class="literal">REPLACE</code>, <code class="literal">LOAD DATA</code> および <code class="literal">LOAD XML</code> ステートメントに対して評価され、制約が <code class="literal">FALSE</code> と評価されるとエラーが発生します。 エラーが発生した場合、すでに適用されている変更の処理は、<a class="xref" href="server-administration.html#sql-mode-strict" title="厳密な SQL モード">厳密な SQL モード</a> で説明されているように、トランザクションストレージエンジンと非トランザクションストレージエンジンで異なり、厳密な SQL モードが有効になっているかどうかによっても異なります。 
      </p><p>
        <code class="literal">CHECK</code> 制約は、<code class="literal">INSERT IGNORE</code>, <code class="literal">UPDATE IGNORE</code>, <code class="literal">LOAD DATA ... IGNORE</code> および <code class="literal">LOAD XML ... IGNORE</code> ステートメントに対して評価され、制約が <code class="literal">FALSE</code> と評価されると警告が発生します。 問題のある行の挿入または更新はスキップされます。 
      </p><p>
        制約式が宣言されたカラム型とは異なるデータ型に評価された場合、宣言された型への暗黙的な強制は、通常の MySQL 型変換ルールに従って行われます。 <a class="xref" href="functions.html#type-conversion" title="12.3 式評価での型変換">セクション12.3「式評価での型変換」</a>を参照してください。 型変換が失敗した場合、または精度が失われた場合は、エラーが発生します。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          制約式の評価では、評価時に有効な SQL モードが使用されます。 式のいずれかのコンポーネントが SQL モードに依存している場合、すべての使用中に SQL モードが同じでないかぎり、テーブルの使用方法によって結果が異なることがあります。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="silent-column-changes"></a>13.1.20.7 暗黙のカラム指定の変更</h4></div></div></div><a class="indexterm" name="idm45827002573680"></a><p>
        MySQL は場合によって、カラム指定を <code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントで指定されたものから暗黙のうちに変更することがあります。 これらの変更は、データ型、データ型に関連付けられた属性、またはインデックス指定に対して行われる可能性があります。 
      </p><p>
        すべての変更は 65,535 バイトの内部の行サイズ制限に従うため、データ型を変更しようとする一部の試みが失敗する可能性があります。 <a class="xref" href="optimization.html#column-count-limit" title="8.4.7 テーブルカラム数と行サイズの制限">セクション8.4.7「テーブルカラム数と行サイズの制限」</a>を参照してください。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">PRIMARY KEY</code> の一部であるカラムは、そのように宣言されていない場合でも、<code class="literal">NOT NULL</code> にされます。
          </p></li><li class="listitem"><p>
            テーブルが作成されたとき、<code class="literal">ENUM</code> および <code class="literal">SET</code> メンバー値から末尾のスペースが自動的に削除されます。
          </p></li><li class="listitem"><p>
            MySQL は、ほかの SQL データベースベンダーによって使用されている特定のデータ型を MySQL 型にマップします。 <a class="xref" href="data-types.html#other-vendor-data-types" title="11.9 その他のデータベースエンジンのデータ型の使用">セクション11.9「その他のデータベースエンジンのデータ型の使用」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            特定のストレージエンジンには許可されないインデックスタイプを指定するために <code class="literal">USING</code> 句を含めたが、そのエンジンがクエリー結果に影響を与えることなく使用できる使用可能な別のインデックスタイプが存在する場合、エンジンはその使用可能なタイプを使用します。
          </p></li><li class="listitem"><p>
            厳密な SQL モードが有効になっていない場合、長さ指定が 65535 より大きい <code class="literal">VARCHAR</code> カラムは <code class="literal">TEXT</code> に変換され、長さ指定が 65535 より大きい <code class="literal">VARBINARY</code> カラムは <code class="literal">BLOB</code> に変換されます。 そうでない場合は、これらのいずれの場合にもエラーが発生します。 
          </p></li><li class="listitem"><p>
            文字データ型に <code class="literal">CHARACTER SET binary</code> 属性を指定すると、カラムは対応するバイナリデータ型として作成されます。つまり、<code class="literal">CHAR</code> は <code class="literal">BINARY</code> になり、<code class="literal">VARCHAR</code> は <code class="literal">VARBINARY</code> になり、<code class="literal">TEXT</code> は <code class="literal">BLOB</code> になります。 <code class="literal">ENUM</code> および <code class="literal">SET</code> データ型では、これは行われず、宣言されたとおりに作成されます。 この定義を使用して、テーブルを指定したとします。 
          </p><pre class="programlisting">CREATE TABLE t
(
  c1 VARCHAR(10) CHARACTER SET binary,
  c2 TEXT CHARACTER SET binary,
  c3 ENUM('a','b','c') CHARACTER SET binary
);
</pre><p>
            結果のテーブルには、この定義が含まれています。
          </p><pre class="programlisting">CREATE TABLE t
(
  c1 VARBINARY(10),
  c2 BLOB,
  c3 ENUM('a','b','c') CHARACTER SET binary
);
</pre></li></ul></div><p>
        MySQL が、指定したもの以外のデータ型を使用したかどうかを確認するには、テーブルを作成または変更したあとに、<code class="literal">DESCRIBE</code> または <code class="literal">SHOW CREATE TABLE</code> ステートメントを発行します。
      </p><a class="indexterm" name="idm45827002536944"></a><p>
        <span class="command"><strong>myisampack</strong></span> を使用してテーブルを圧縮する場合は、その他の特定のデータ型の変更が発生する場合があります。 <a class="xref" href="storage-engines.html#compressed-format" title="16.2.3.3 圧縮テーブルの特徴">セクション16.2.3.3「圧縮テーブルの特徴」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="create-table-generated-columns"></a>13.1.20.8 CREATE TABLE および生成されるカラム</h4></div></div></div><a class="indexterm" name="idm45827002532128"></a><p>
        <code class="literal">CREATE TABLE</code> では、生成されるカラムの指定がサポートされています。 生成されたカラムの値は、カラム定義に含まれる式から計算されます。 
      </p><p>
        生成されたカラムは、<code class="literal">NDB</code> ストレージエンジンでもサポートされます。
      </p><p>
        次の単純な例は、<code class="literal">sidea</code> カラムおよび <code class="literal">sideb</code> カラムに右側の三角形の長さを格納し、<code class="literal">sidec</code> のハイフンの長さを計算するテーブルを示しています (もう一方の辺の二乗の合計の平方根):
      </p><pre class="programlisting">CREATE TABLE triangle (
  sidea DOUBLE,
  sideb DOUBLE,
  sidec DOUBLE AS (SQRT(sidea * sidea + sideb * sideb))
);
INSERT INTO triangle (sidea, sideb) VALUES(1,1),(3,4),(6,8);
</pre><p>
        テーブルから選択すると、次の結果になります:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM triangle;</code></strong>
+-------+-------+--------------------+
| sidea | sideb | sidec              |
+-------+-------+--------------------+
|     1 |     1 | 1.4142135623730951 |
|     3 |     4 |                  5 |
|     6 |     8 |                 10 |
+-------+-------+--------------------+
</pre><p>
        <code class="literal">triangle</code> テーブルを使用するアプリケーションは、それらを計算する式を指定しなくても、ハイフン値にアクセスできます。
      </p><p>
        生成されるカラム定義の構文は次のとおりです:
      </p><pre class="programlisting"><em class="replaceable"><code>col_name</code></em> <em class="replaceable"><code>data_type</code></em> [GENERATED ALWAYS] AS (<em class="replaceable"><code>expr</code></em>)
  [VIRTUAL | STORED] [NOT NULL | NULL]
  [UNIQUE [KEY]] [[PRIMARY] KEY]
  [COMMENT '<em class="replaceable"><code>string</code></em>']
</pre><p>
        <code class="literal">AS (<em class="replaceable"><code>expr</code></em>)</code> は、カラムが生成されることを示し、カラム値の計算に使用される式を定義します。 カラムの生成された性質をより明確にするために、<code class="literal">AS</code> の前に <code class="literal">GENERATED ALWAYS</code> を付けることができます。 式で許可または禁止されている構造体については、あとで説明します。 
      </p><p>
        <code class="literal">VIRTUAL</code> または <code class="literal">STORED</code> キーワードは、カラム値の格納方法を示します。これは、カラムの使用に影響します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">VIRTUAL</code>: カラム値は格納されませんが、<code class="literal">BEFORE</code> トリガーの直後に行が読み取られたときに評価されます。 仮想カラムは記憶域を取りません。 
          </p><p>
            <code class="literal">InnoDB</code> は、仮想カラムのセカンダリインデックスをサポートしています。 <a class="xref" href="sql-statements.html#create-table-secondary-indexes" title="13.1.20.9 セカンダリインデックスと生成されたカラム">セクション13.1.20.9「セカンダリインデックスと生成されたカラム」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">STORED</code>: カラム値は、行の挿入または更新時に評価および格納されます。 ストアドカラムには記憶領域が必要であり、インデックス付けできます。 
          </p></li></ul></div><p>
        どちらのキーワードも指定されていない場合、デフォルトは <code class="literal">VIRTUAL</code> です。
      </p><p>
        テーブル内で <code class="literal">VIRTUAL</code> カラムと <code class="literal">STORED</code> カラムを混在させることができます。
      </p><p>
        カラムがインデックス付けされているか、<code class="literal">NULL</code> であるか、またはコメントを提供できるかを示す他の属性を指定できます。
      </p><p>
        生成されるカラム式は、次のルールに従う必要があります。 許可されていない構造が式に含まれている場合は、エラーが発生します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            リテラル、決定的組込み関数および演算子を使用できます。 関数は、テーブル内の同じデータが指定された場合、接続ユーザーとは関係なく、複数の起動で同じ結果が生成される場合は決定論的です。 非決定的で、この定義に失敗する関数の例: <code class="literal">CONNECTION_ID()</code>, <code class="literal">CURRENT_USER()</code>, <code class="literal">NOW()</code>。 
          </p></li><li class="listitem"><p>
            ストアドファンクションおよびユーザー定義関数は使用できません。
          </p></li><li class="listitem"><p>
            ストアドプロシージャおよびストアドファンクションのパラメータは使用できません。
          </p></li><li class="listitem"><p>
            変数 (システム変数、ユーザー定義変数およびストアドプログラムローカル変数) は使用できません。
          </p></li><li class="listitem"><p>
            サブクエリーは許可されません。
          </p></li><li class="listitem"><p>
            生成されたカラム定義は、生成された他のカラムを参照できますが、テーブル定義で以前に発生したカラムのみを参照できます。 生成されたカラム定義は、その定義が以前に発生したか後で発生したかに関係なく、テーブル内の任意のベース (生成されていない) カラムを参照できます。 
          </p></li><li class="listitem"><p>
            <code class="literal">AUTO_INCREMENT</code> 属性は、生成されたカラム定義では使用できません。
          </p></li><li class="listitem"><p>
            生成されたカラム定義で <code class="literal">AUTO_INCREMENT</code> カラムをベースカラムとして使用することはできません。
          </p></li><li class="listitem"><p>
            式の評価によって切捨てが発生した場合、または関数への入力が正しくない場合、<code class="literal">CREATE TABLE</code> ステートメントはエラーで終了し、DDL 操作は拒否されます。
          </p></li></ul></div><p>
        式が宣言されたカラム型とは異なるデータ型に評価された場合、宣言された型への暗黙的な強制は、通常の MySQL 型変換ルールに従って行われます。 <a class="xref" href="functions.html#type-conversion" title="12.3 式評価での型変換">セクション12.3「式評価での型変換」</a>を参照してください。 
      </p><p>
        生成されたカラムが <code class="literal">TIMESTAMP</code> データ型を使用している場合、<code class="literal">explicit_defaults_for_timestamp</code> の設定は無視されます。 このような場合、この変数を無効にすると、<code class="literal">NULL</code> は <code class="literal">CURRENT_TIMESTAMP</code> に変換されません。 MySQL 8.0.22 以降では、カラムが <code class="literal">NOT NULL</code> としても宣言されている場合、<code class="literal">NULL</code> を挿入しようとすると <span class="errorname">ER_BAD_NULL_ERROR</span> で明示的に拒否されます。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          式の評価では、評価時に有効な SQL モードが使用されます。 式のいずれかのコンポーネントが SQL モードに依存している場合、すべての使用中に SQL モードが同じでないかぎり、テーブルの使用方法によって結果が異なることがあります。 
        </p></div><p>
        <code class="literal">CREATE TABLE ... LIKE</code> の場合、宛先テーブルには元のテーブルから生成されたカラム情報が保持されます。
      </p><p>
        <code class="literal">CREATE TABLE ... SELECT</code> の場合、宛先テーブルでは、選択元テーブルのカラムが生成されたカラムであるかどうかに関する情報は保持されません。 ステートメントの <code class="literal">SELECT</code> 部分では、宛先テーブルの生成されたカラムに値を割り当てることはできません。 
      </p><p>
        生成されたカラムによるパーティション化が許可されます。 <a class="xref" href="sql-statements.html#create-table-partitioning" title="テーブルのパーティション化">テーブルのパーティション化</a>を参照してください。 
      </p><p>
        格納された生成カラムに対する外部キー制約では、<code class="literal">CASCADE</code>、<code class="literal">SET NULL</code> または <code class="literal">SET DEFAULT</code> を <code class="literal">ON UPDATE</code> 参照アクションとして使用することも、<code class="literal">SET NULL</code> または <code class="literal">SET DEFAULT</code> を <code class="literal">ON DELETE</code> 参照アクションとして使用することもできません。
      </p><p>
        格納された生成カラムのベースカラムに対する外部キー制約では、<code class="literal">CASCADE</code>、<code class="literal">SET NULL</code> または <code class="literal">SET DEFAULT</code> を <code class="literal">ON UPDATE</code> または <code class="literal">ON DELETE</code> の参照アクションとして使用できません。
      </p><p>
        外部キー制約は、仮想生成カラムを参照できません。
      </p><p>
        トリガーは、<code class="literal">NEW.<em class="replaceable"><code>col_name</code></em></code> または <code class="literal">OLD.<em class="replaceable"><code>col_name</code></em></code> を使用して生成されたカラムを参照することはできません。
      </p><p>
        <code class="literal">INSERT</code>、<code class="literal">REPLACE</code> および <code class="literal">UPDATE</code> では、生成されたカラムが明示的に挿入、置換または更新される場合、許可される値は <code class="literal">DEFAULT</code> のみです。
      </p><p>
        ビュー内の生成されたカラムは、割り当て可能であるため、更新可能とみなされます。 ただし、このようなカラムが明示的に更新される場合、許可される値は <code class="literal">DEFAULT</code> のみです。 
      </p><p>
        生成されるカラムには、次のようないくつかのユースケースがあります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            仮想生成カラムは、クエリーを簡略化および統合する方法として使用できます。 複雑な条件を生成されたカラムとして定義し、テーブルに対する複数のクエリーから参照して、すべてのクエリーが完全に同じ条件を使用するようにできます。 
          </p></li><li class="listitem"><p>
            格納された生成カラムは、即時計算にコストがかかる複雑な条件の実体化キャッシュとして使用できます。
          </p></li><li class="listitem"><p>
            生成されたカラムは関数インデックスをシミュレートできます: 生成されたカラムを使用して関数式を定義し、インデックス付けします。 これは、<code class="literal">JSON</code> カラムなど、直接インデックス付けできない型のカラムを操作する場合に役立ちます。詳細な例は、<a class="xref" href="sql-statements.html#json-column-indirect-index" title="JSON カラムインデックスを提供するための生成されたカラムのインデックス付け">JSON カラムインデックスを提供するための生成されたカラムのインデックス付け</a> を参照してください。 
          </p><p>
            格納された生成カラムの場合、このアプローチのデメリットは、値が生成されたカラムの値として 2 回格納され、インデックスに 1 回格納されることです。
          </p></li><li class="listitem"><p>
            生成されたカラムがインデックス付けされている場合、オプティマイザはカラム定義に一致するクエリー式を認識し、クエリーがそのカラムを名前で直接参照しない場合でも、クエリーの実行中にカラムのインデックスを適宜使用します。 詳細は、<a class="xref" href="optimization.html#generated-column-index-optimizations" title="8.3.11 生成されたカラムインデックスのオプティマイザによる使用">セクション8.3.11「生成されたカラムインデックスのオプティマイザによる使用」</a>を参照してください。 
          </p></li></ul></div><p>
        例:
      </p><p>
        テーブル <code class="literal">t1</code> に <code class="literal">first_name</code> カラムと <code class="literal">last_name</code> カラムが含まれており、アプリケーションが次のような式を使用してフルネームを頻繁に構成するとします:
      </p><pre class="programlisting">SELECT CONCAT(first_name,' ',last_name) AS full_name FROM t1;
</pre><p>
        式を書き出さないようにするには、<code class="literal">t1</code> でビュー <code class="literal">v1</code> を作成します。これにより、式を使用せずに <code class="literal">full_name</code> を直接選択できるため、アプリケーションが簡略化されます:
      </p><pre class="programlisting">CREATE VIEW v1 AS
SELECT *, CONCAT(first_name,' ',last_name) AS full_name FROM t1;

SELECT full_name FROM v1;
</pre><p>
        生成されたカラムを使用すると、ビューを定義せずに、アプリケーションで <code class="literal">full_name</code> を直接選択することもできます:
      </p><pre class="programlisting">CREATE TABLE t1 (
  first_name VARCHAR(10),
  last_name VARCHAR(10),
  full_name VARCHAR(255) AS (CONCAT(first_name,' ',last_name))
);

SELECT full_name FROM t1;
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="create-table-secondary-indexes"></a>13.1.20.9 セカンダリインデックスと生成されたカラム</h4></div></div></div><a class="indexterm" name="idm45827002425024"></a><p>
        <code class="literal">InnoDB</code> では、仮想生成カラムのセカンダリインデックスがサポートされます。 その他のインデックスタイプはサポートされていません。 仮想カラムに定義されたセカンダリインデックスは、<span class="quote">「<span class="quote">「仮想インデックス」</span>」</span>と呼ばれることもあります。 
      </p><p>
        セカンダリインデックスは、1 つ以上の仮想カラム、または仮想カラムと通常のカラムまたは格納された生成カラムの組合せに対して作成できます。 仮想カラムを含むセカンダリインデックスは、<code class="literal">UNIQUE</code> として定義できます。 
      </p><p>
        セカンダリインデックスが仮想生成カラムに作成されると、生成されたカラム値はインデックスのレコードで実体化されます。 インデックスが <a class="link" href="glossary.html#glos_covering_index" title="カバリングインデックス">covering index</a>(クエリーによって取得されたすべてのカラムを含む) の場合、生成されたカラム値は、計算された<span class="quote">「<span class="quote">「その場で」</span>」</span>ではなく、インデックス構造の実体化された値から取得されます。 
      </p><p>
        <code class="literal">INSERT</code> および <code class="literal">UPDATE</code> の操作中にセカンダリインデックスレコードの仮想カラム値を実体化するときに計算が実行されるため、仮想カラムでセカンダリインデックスを使用する際に考慮する追加の書込みコストがあります。 追加の書込みコストがあっても、生成される <span class="emphasis"><em>stored</em></span> カラム (クラスタインデックスで実体化される) よりも仮想カラムのセカンダリインデックスの方が望ましい場合があり、その結果、より多くのディスク領域およびメモリーが必要なテーブルが大きくなります。 セカンダリインデックスが仮想カラムに定義されていない場合、カラムの行が調査されるたびに仮想カラムの値を計算する必要があるため、読取りに追加のコストがかかります。 
      </p><p>
        インデックス付けされた仮想カラムの値は MVCC ログに記録され、ロールバック中またはパージ操作中に生成されたカラム値の不要な再計算を回避します。 ログに記録される値のデータ長は、<code class="literal">COMPACT</code> および <code class="literal">REDUNDANT</code> の行形式では 767 バイト、<code class="literal">DYNAMIC</code> および <code class="literal">COMPRESSED</code> の行形式では 3072 バイトのインデックスキー制限によって制限されます。 
      </p><p>
        仮想カラムに対するセカンダリインデックスの追加または削除はインプレース操作です。
      </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="json-column-indirect-index"></a>JSON カラムインデックスを提供するための生成されたカラムのインデックス付け</h5></div></div></div><p>
          他の場所で説明したように、<code class="literal">JSON</code> カラムは直接インデックス付けできません。 このようなカラムを間接的に参照するインデックスを作成するには、次の例に示すように、インデックス付けする必要がある情報を抽出する生成カラムを定義し、生成されたカラムにインデックスを作成します: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE jemp (</code></strong>
    -&gt;     <strong class="userinput"><code>c JSON,</code></strong>
    -&gt;     <strong class="userinput"><code>g INT GENERATED ALWAYS AS (c-&gt;"$.id"),</code></strong>
    -&gt;     <strong class="userinput"><code>INDEX i (g)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.28 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO jemp (c) VALUES</code></strong>
     &gt;   <strong class="userinput"><code>('{"id": "1", "name": "Fred"}'), ('{"id": "2", "name": "Wilma"}'),</code></strong>
     &gt;   <strong class="userinput"><code>('{"id": "3", "name": "Barney"}'), ('{"id": "4", "name": "Betty"}');</code></strong>
Query OK, 4 rows affected (0.04 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT c-&gt;&gt;"$.name" AS name</code></strong>
     &gt;     <strong class="userinput"><code>FROM jemp WHERE g &gt; 2;</code></strong>
+--------+
| name   |
+--------+
| Barney |
| Betty  |
+--------+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT c-&gt;&gt;"$.name" AS name</code></strong>
     &gt;    <strong class="userinput"><code>FROM jemp WHERE g &gt; 2\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: jemp
   partitions: NULL
         type: range
possible_keys: i
          key: i
      key_len: 5
          ref: NULL
         rows: 2
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select json_unquote(json_extract(`test`.`jemp`.`c`,'$.name'))
AS `name` from `test`.`jemp` where (`test`.`jemp`.`g` &gt; 2)
1 row in set (0.00 sec)
</pre><p>
          (この例では、表示領域に合うように最後のステートメントの出力をラップしています。)
        </p><p>
          <code class="literal">EXPLAIN</code> を <code class="literal">SELECT</code> または <code class="literal">-&gt;</code> または <code class="literal">-&gt;&gt;</code> 演算子を使用する 1 つ以上の式を含む他の SQL ステートメントで <code class="literal">EXPLAIN</code> を使用する場合、<code class="literal">JSON_EXTRACT()</code> および (必要に応じて) <code class="literal">JSON_UNQUOTE()</code> を使用して、この <code class="literal">EXPLAIN</code> ステートメントに続いてすぐに <code class="literal">SHOW WARNINGS</code> から出力の通り、これらの式はそれらの相当に変換されます:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT c-&gt;&gt;"$.name"</code></strong>
     &gt; <strong class="userinput"><code>FROM jemp WHERE g &gt; 2 ORDER BY c-&gt;"$.name"\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: jemp
   partitions: NULL
         type: range
possible_keys: i
          key: i
      key_len: 5
          ref: NULL
         rows: 2
     filtered: 100.00
        Extra: Using where; Using filesort
1 row in set, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select json_unquote(json_extract(`test`.`jemp`.`c`,'$.name')) AS
`c-&gt;&gt;"$.name"` from `test`.`jemp` where (`test`.`jemp`.`g` &gt; 2) order by
json_extract(`test`.`jemp`.`c`,'$.name')
1 row in set (0.00 sec)
</pre><p>
          追加情報および例については、<code class="literal">-&gt;</code> および <code class="literal">-&gt;&gt;</code> の演算子と、<code class="literal">JSON_EXTRACT()</code> および <code class="literal">JSON_UNQUOTE()</code> の関数の説明を参照してください。
        </p><p>
          この手法を使用して、<code class="literal">GEOMETRY</code> カラムなど、直接インデックス付けできない他のタイプのカラムを間接的に参照するインデックスを提供することもできます。
        </p><p>
          MySQL 8.0.21 以降では、式を使用するクエリーの最適化に使用できる式を指定した <code class="literal">JSON_VALUE()</code> 関数を使用して、<code class="literal">JSON</code> カラムにインデックスを作成することもできます。 詳細および例については、その関数の説明を参照してください。 
        </p><h6><a name="json-column-indirect-index-mysql-cluster"></a>NDB Cluster での JSON カラムと間接インデックス</h6><p>
          <a class="indexterm" name="idm45827002368016"></a> <a class="indexterm" name="idm45827002366352"></a> <a class="indexterm" name="idm45827002364576"></a> <a class="indexterm" name="idm45827002362400"></a> MySQL NDB Cluster では、次の条件に従って JSON カラムの間接インデックスを使用することもできます:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              <code class="literal">NDB</code> は、<code class="literal">JSON</code> カラムの値を <code class="literal">BLOB</code> として内部的に処理します。 つまり、JSON カラムが 1 つ以上ある <code class="literal">NDB</code> テーブルには主キーが必要であり、それ以外の場合はバイナリログに記録できません。 
            </p></li><li class="listitem"><p>
              <code class="literal">NDB</code> ストレージエンジンは、仮想カラムのインデックス作成をサポートしていません。 生成されるカラムのデフォルトは <code class="literal">VIRTUAL</code> であるため、間接インデックスを <code class="literal">STORED</code> として適用する生成されるカラムを明示的に指定する必要があります。 
            </p></li></ol></div><p>
          次に示す <code class="literal">jempn</code> テーブルの作成に使用される <strong class="userinput"><code>CREATE TABLE</code></strong> ステートメントは、<code class="literal">NDB</code> と互換性があるように変更された、前述の <code class="literal">jemp</code> テーブルのバージョンです:
        </p><pre class="programlisting">CREATE TABLE jempn (
  a BIGINT(20) NOT NULL AUTO_INCREMENT PRIMARY KEY,
  c JSON DEFAULT NULL,
  g INT GENERATED ALWAYS AS (c-&gt;"$.name") STORED,
  INDEX i (g)
) ENGINE=NDB;
</pre><p>
          次の <code class="literal">INSERT</code> ステートメントを使用して、このテーブルに移入できます:
        </p><pre class="programlisting">INSERT INTO jempn (a, c) VALUES
  (NULL, '{"id": "1", "name": "Fred"}'),
  (NULL, '{"id": "2", "name": "Wilma"}'),
  (NULL, '{"id": "3", "name": "Barney"}'),
  (NULL, '{"id": "4", "name": "Betty"}');
</pre><p>
          次に示すように、<code class="literal">NDB</code> でインデックス <code class="literal">i</code> を使用できるようになりました:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT c-&gt;&gt;"$.name" AS name
          FROM jempn WHERE g &gt; 2\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: jempn
   partitions: p0,p1
         type: range
possible_keys: i
          key: i
      key_len: 5
          ref: NULL
         rows: 3
     filtered: 100.00
        Extra: Using where with pushed condition (`test`.`jempn`.`g` &gt; 2)
1 row in set, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select
json_unquote(json_extract(`test`.`jempn`.`c`,'$.name')) AS `name` from
`test`.`jempn` where (`test`.`jempn`.`g` &gt; 2)
1 row in set (0.00 sec)
</pre><p>
          格納された生成カラムは <code class="literal">DataMemory</code> を使用し、このようなカラムのインデックスは <code class="literal">IndexMemory</code> を使用することに注意してください。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="invisible-columns"></a>13.1.20.10 非表示カラム</h4></div></div></div><a class="indexterm" name="idm45827002333200"></a><p>
        MySQL では、MySQL 8.0.23 の時点で非表示カラムがサポートされています。 非表示のカラムは通常、クエリーでは非表示ですが、明示的に参照されている場合はアクセスできます。 MySQL 8.0.23 より前は、すべてのカラムが表示されます。 
      </p><p>
        不可視のカラムが役立つ場合の図として、アプリケーションが <code class="literal">SELECT *</code> クエリーを使用してテーブルにアクセスし、アプリケーションが予期しない新しいカラムを追加するようにテーブルを変更した場合でも、変更せずに作業を続行する必要があるとします。 <code class="literal">SELECT *</code> クエリーでは、<code class="literal">*</code> は非表示のカラムを除くすべてのテーブルのカラムに評価されるため、解決策は新しいカラムを非表示のカラムとして追加することです。 カラムは <code class="literal">SELECT *</code> クエリーから<span class="quote">「<span class="quote">「非表示」</span>」</span>のままであり、アプリケーションは引き続き以前と同様に動作します。 アプリケーションの新しいバージョンは、明示的に参照することで、必要に応じて不可視のカラムを参照できます。 
      </p><p>
        次の各セクションでは、MySQL で非表示カラムを処理する方法について説明します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#invisible-column-ddl-statements" title="DDL ステートメントと非表示カラム">DDL ステートメントと非表示カラム</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#invisible-column-dml-statements" title="DML ステートメントと非表示カラム">DML ステートメントと非表示カラム</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#invisible-column-metadata" title="非表示カラムのメタデータ">非表示カラムのメタデータ</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#invisible-column-binary-logging" title="バイナリログと不可視のカラム">バイナリログと不可視のカラム</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="invisible-column-ddl-statements"></a>DDL ステートメントと非表示カラム</h5></div></div></div><p>
          カラムはデフォルトで可視化されます。 新しいカラムの可視性を明示的に指定するには、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> のカラム定義の一部として <code class="literal">VISIBLE</code> または <code class="literal">INVISIBLE</code> キーワードを使用します: 
        </p><pre class="programlisting">CREATE TABLE t1 (
  i INT,
  j DATE INVISIBLE
) ENGINE = InnoDB;
ALTER TABLE t1 ADD COLUMN k INT INVISIBLE;
</pre><p>
          既存のカラムの可視性を変更するには、<code class="literal">VISIBLE</code> または <code class="literal">INVISIBLE</code> キーワードをいずれかの <code class="literal">ALTER TABLE</code> カラム変更句とともに使用します:
        </p><pre class="programlisting">ALTER TABLE t1 CHANGE COLUMN j j DATE VISIBLE;
ALTER TABLE t1 MODIFY COLUMN j DATE INVISIBLE;
ALTER TABLE t1 ALTER COLUMN j SET VISIBLE;
</pre><p>
          テーブルには、少なくとも 1 つの表示可能なカラムが必要です。 すべてのカラムを非表示にしようとすると、エラーが発生します。 
        </p><p>
          非表示カラムでは、通常のカラム属性がサポートされます: <code class="literal">NULL</code>, <code class="literal">NOT NULL</code>, <code class="literal">AUTO_INCREMENT</code> など。
        </p><p>
          生成されたカラムは非表示にできます。
        </p><p>
          インデックス定義では、<code class="literal">PRIMARY KEY</code> インデックスや <code class="literal">UNIQUE</code> インデックスの定義など、不可視のカラムに名前を付けることができます。 テーブルには 1 つ以上の可視カラムが必要ですが、インデックス定義には可視カラムは必要ありません。 
        </p><p>
          テーブルから削除された不可視のカラムは、通常の方法で、カラムに名前を付けるインデックス定義から削除されます。
        </p><p>
          外部キー制約は非表示カラムに定義でき、外部キー制約は非表示カラムを参照できます。
        </p><p>
          <code class="literal">CHECK</code> の制約は、不可視のカラムに対して定義できます。 新規または変更された行の場合、非表示カラムに対する <code class="literal">CHECK</code> 制約に違反するとエラーが発生します。 
        </p><p>
          <code class="literal">CREATE TABLE ... LIKE</code> には不可視のカラムが含まれており、新しいテーブルでは不可視です。
        </p><p>
          <code class="literal">CREATE TABLE ... SELECT</code> には、<code class="literal">SELECT</code> 部分で明示的に参照されないかぎり、不可視のカラムは含まれません。 ただし、明示的に参照されている場合でも、既存のテーブルに表示されないカラムは新しいテーブルに表示されます: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (col1 INT, col2 INT INVISIBLE);</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 AS SELECT col1, col2 FROM t1;</code></strong>
mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t2\G</code></strong>
*************************** 1. row ***************************
       Table: t2
Create Table: CREATE TABLE `t2` (
  `col1` int DEFAULT NULL,
  `col2` int DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
</pre><p>
          非表示を保持する必要がある場合は、<code class="literal">CREATE TABLE ... SELECT</code> ステートメントの <code class="literal">CREATE TABLE</code> 部分で非表示カラムの定義を指定します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (col1 INT, col2 INT INVISIBLE);</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (col2 INT INVISIBLE) AS SELECT col1, col2 FROM t1;</code></strong>
mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t2\G</code></strong>
*************************** 1. row ***************************
       Table: t2
Create Table: CREATE TABLE `t2` (
  `col1` int DEFAULT NULL,
  `col2` int DEFAULT NULL /*!80023 INVISIBLE */
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
</pre><p>
          ビューは、ビューを定義する <code class="literal">SELECT</code> ステートメントで非表示カラムを明示的に参照することで、非表示カラムを参照できます。 カラムを参照するビューを定義した後にカラムの可視性を変更しても、ビューの動作は変わりません。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="invisible-column-dml-statements"></a>DML ステートメントと非表示カラム</h5></div></div></div><p>
          <code class="literal">SELECT</code> ステートメントでは、選択リストで明示的に参照されないかぎり、非表示カラムは結果セットの一部になりません。 選択リストでは、<code class="literal">*</code> および <code class="literal"><em class="replaceable"><code>tbl_name</code></em>.*</code> の短縮形に非表示カラムは含まれません。 自然結合には、非表示のカラムは含まれません。 
        </p><p>
          次のステートメントの順序を考えてみます:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (col1 INT, col2 INT INVISIBLE);</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t1 (col1, col2) VALUES(1, 2), (3, 4);</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT * FROM t1;</code></strong>
+------+
| col1 |
+------+
|    1 |
|    3 |
+------+

mysql&gt; <strong class="userinput"><code>SELECT col1, col2 FROM t1;</code></strong>
+------+------+
| col1 | col2 |
+------+------+
|    1 |    2 |
|    3 |    4 |
+------+------+
</pre><p>
          最初の <code class="literal">SELECT</code> は、選択リストの非表示カラム <code class="literal">col2</code> を参照しません (<code class="literal">*</code> には非表示カラムが含まれていないため)。したがって、<code class="literal">col2</code> はステートメントの結果に表示されません。 もう一方の <code class="literal">SELECT</code> は <code class="literal">col2</code> を参照するため、結果に表示されます。 
        </p><p>
          新しい行を作成するステートメントの場合、明示的に参照されて値が割り当てられないかぎり、非表示カラムには暗黙的なデフォルト値が割り当てられます。 暗黙的なデフォルトの詳細は、<a class="xref" href="data-types.html#data-type-defaults-implicit" title="暗黙的なデフォルト処理">暗黙的なデフォルト処理</a> を参照してください。 
        </p><p>
          <code class="literal">INSERT</code> (および <code class="literal">REPLACE</code> の場合、非置換行の場合) では、カラムリストが欠落しているか、空のカラムリスト、または非表示のカラムを含まない空でないカラムリストを使用して、暗黙的なデフォルトの割当てが行われます:
        </p><pre class="programlisting">CREATE TABLE t1 (col1 INT, col2 INT INVISIBLE);
INSERT INTO t1 VALUES(...);
INSERT INTO t1 () VALUES(...);
INSERT INTO t1 (col1) VALUES(...);
</pre><p>
          最初の 2 つの <code class="literal">INSERT</code> ステートメントでは、<code class="literal">VALUES()</code> リストは表示カラムごとに値を指定する必要があり、非表示カラムは指定できません。 3 つ目の <code class="literal">INSERT</code> ステートメントでは、<code class="literal">VALUES()</code> リストに名前付きカラムの数と同じ数の値を指定する必要があります。 
        </p><p>
          <code class="literal">LOAD DATA</code> および <code class="literal">LOAD XML</code> の場合、暗黙的なデフォルト割当ては、欠落しているカラムリストまたは非表示のカラムを含まない空でないカラムリストで発生します。 入力行に非表示カラムの値を含めないでください。 
        </p><p>
          前述のステートメントに暗黙的なデフォルト以外の値を割り当てるには、カラムリストで非表示カラムに明示的に名前を付け、その値を指定します。
        </p><p>
          <code class="literal">*</code> には非表示カラムが含まれていないため、<code class="literal">INSERT INTO ... SELECT *</code> および <code class="literal">REPLACE INTO ... SELECT *</code> には非表示カラムは含まれていません。 暗黙的なデフォルトの割当ては、前述のとおりに行われます。 
        </p><p>
          新しい行を挿入または無視するステートメント、あるいは <code class="literal">PRIMARY KEY</code> インデックスまたは <code class="literal">UNIQUE</code> インデックスの値に基づいて既存の行を置換または変更するステートメントの場合、MySQL は非表示カラムを表示カラムと同じように処理: 非表示カラムはキー値の比較に関与します。 具体的には、新しい行が一意キー値の既存の行と同じ値を持つ場合、インデックスカラムが可視か不可視かにかかわらず、次の動作が発生します: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">IGNORE</code> 修飾子を使用すると、<code class="literal">INSERT</code>、<code class="literal">LOAD DATA</code> および <code class="literal">LOAD XML</code> は新しい行を無視します。
            </p></li><li class="listitem"><p>
              <code class="literal">REPLACE</code> は、既存の行を新しい行に置き換えます。 <code class="literal">REPLACE</code> 修飾子を使用すると、<code class="literal">LOAD DATA</code> と <code class="literal">LOAD XML</code> は同じことを行います。 
            </p></li><li class="listitem"><p>
              <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> によって既存の行が更新されます。
            </p></li></ul></div><p>
          <code class="literal">UPDATE</code> ステートメントの非表示カラムを更新するには、表示カラムの場合と同様に、非表示カラムに名前を付けて値を割り当てます。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="invisible-column-metadata"></a>非表示カラムのメタデータ</h5></div></div></div><a class="indexterm" name="idm45827002232960"></a><a class="indexterm" name="idm45827002230816"></a><p>
          カラムが表示可能か非表示かに関する情報は、<code class="literal">INFORMATION_SCHEMA.COLUMNS</code> テーブルまたは <code class="literal">SHOW COLUMNS</code> 出力の <code class="literal">EXTRA</code> カラムから入手できます。 例: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, COLUMN_NAME, EXTRA</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.COLUMNS</code></strong>
       <strong class="userinput"><code>WHERE TABLE_SCHEMA = 'test' AND TABLE_NAME = 't1';</code></strong>
+------------+-------------+-----------+
| TABLE_NAME | COLUMN_NAME | EXTRA     |
+------------+-------------+-----------+
| t1         | i           |           |
| t1         | j           |           |
| t1         | k           | INVISIBLE |
+------------+-------------+-----------+
</pre><p>
          カラムはデフォルトで表示されるため、<code class="literal">EXTRA</code> では表示情報は表示されません。 非表示カラムの場合、<code class="literal">EXTRA</code> には <code class="literal">INVISIBLE</code> が表示されます。 
        </p><p>
          <code class="literal">SHOW CREATE TABLE</code> では、テーブル定義に非表示のカラムが表示され、バージョン固有のコメントには <code class="literal">INVISIBLE</code> キーワードが含まれます:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t1\G</code></strong>
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `i` int DEFAULT NULL,
  `j` int DEFAULT NULL,
  `k` int DEFAULT NULL /*!80023 INVISIBLE */
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
</pre><p>
          <span class="command"><strong>mysqldump</strong></span> および <code class="literal">mysqlpump</code> では <code class="literal">SHOW CREATE TABLE</code> が使用されるため、ダンプされたテーブル定義に非表示のカラムが含まれます。 また、ダンプされたデータには非表示のカラム値も含まれます。 
        </p><p>
          不可視のカラムをサポートしていない古いバージョンの MySQL にダンプファイルをリロードすると、バージョン固有のコメントが無視され、不可視のカラムが可視として作成されます。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="invisible-column-binary-logging"></a>バイナリログと不可視のカラム</h5></div></div></div><a class="indexterm" name="idm45827002210064"></a><a class="indexterm" name="idm45827002207920"></a><p>
          MySQL では、非表示カラムはバイナリログ内のイベントに関して次のように処理されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              テーブル作成イベントには、非表示カラムの <code class="literal">INVISIBLE</code> 属性が含まれます。
            </p></li><li class="listitem"><p>
              不可視のカラムは、行イベントで可視のカラムと同様に扱われます。 これらは、必要に応じて <code class="literal">binlog_row_image</code> システム変数の設定に従って含まれます。 
            </p></li><li class="listitem"><p>
              行イベントが適用されると、不可視のカラムは行イベントの可視カラムと同様に扱われます。 特に、使用するアルゴリズムおよびインデックスは、<code class="literal">slave_rows_search_algorithms</code> システム変数の設定に従って選択されます。 
            </p></li><li class="listitem"><p>
              非表示カラムは、書込みセットの計算時に可視カラムと同様に扱われます。 特に、書込みセットには不可視のカラムに定義されたインデックスが含まれます。 
            </p></li><li class="listitem"><p>
              <span class="command"><strong>mysqlbinlog</strong></span> コマンドには、カラムメタデータの可視性が含まれます。
            </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="create-table-ndb-table-comment-options"></a>13.1.20.11 NDB_TABLE オプションの設定</h4></div></div></div><p>
        <a class="indexterm" name="idm45827002194048"></a> <a class="indexterm" name="idm45827002192960"></a> <a class="indexterm" name="idm45827002190816"></a> <a class="indexterm" name="idm45827002189840"></a> <a class="indexterm" name="idm45827002188752"></a> NDB Cluster では、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントのテーブルコメントを使用して <code class="literal">NDB_TABLE</code> オプションを指定することもできます。<code class="literal">NDB_TABLE</code> オプションは、文字列 <code class="literal">NDB_TABLE=</code> に続いて、必要に応じてカンマで区切り、1 つ以上の名前 - 値ペアで構成されます。 名前と値の構文の完全な構文を次に示します: 
      </p><pre class="programlisting">COMMENT="NDB_TABLE=<em class="replaceable"><code>ndb_table_option</code></em>[,<em class="replaceable"><code>ndb_table_option</code></em>[,...]]"

<em class="replaceable"><code>ndb_table_option</code></em>: {
    NOLOGGING={1 | 0}
  | READ_BACKUP={1 | 0}
  | PARTITION_BALANCE={FOR_RP_BY_NODE | FOR_RA_BY_NODE | FOR_RP_BY_LDM
                      | FOR_RA_BY_LDM | FOR_RA_BY_LDM_X_2
                      | FOR_RA_BY_LDM_X_3 | FOR_RA_BY_LDM_X_4}
  | FULLY_REPLICATED={1 | 0}
}
</pre><p>
        引用符で囲まれた文字列内ではスペースを使用できません。 文字列では大文字と小文字は区別されません。 
      </p><p>
        この方法でコメントの一部として設定できる 4 つの <code class="literal">NDB</code> テーブルオプションについては、次のいくつかの段落で詳しく説明します。
      </p><p>
        <a class="indexterm" name="idm45827002178064"></a> <a class="indexterm" name="idm45827002176288"></a> <code class="literal">NOLOGGING</code>: 1 を使用することは、<code class="literal">ndb_table_no_logging</code> を有効にすることに対応していますが、実際の影響はありません。 プレースホルダとして提供され、主に <code class="literal">ALTER TABLE</code> ステートメントの完全性のために使用されます。 
      </p><p>
        <a class="indexterm" name="idm45827002170976"></a> <a class="indexterm" name="idm45827002169200"></a> <a class="indexterm" name="idm45827002167424"></a> <code class="literal">READ_BACKUP</code>: このオプションを 1 に設定すると、<code class="literal">ndb_read_backup</code> が有効になっている場合と同じ効果があり、レプリカからの読取りが可能になります。 これにより、テーブルからの読取りのパフォーマンスが大幅に向上しますが、書込みパフォーマンスに対するコストは比較的低くなります。 NDB 8.0.19 以降、1 が <code class="literal">READ_BACKUP</code> のデフォルトであり、<code class="literal">ndb_read_backup</code> のデフォルトは <code class="literal">ON</code> です (以前は、すべてのレプリカからの読み取りがデフォルトで無効になっていました)。 
      </p><p>
        次に示すような <code class="literal">ALTER TABLE</code> ステートメントを使用して、既存のテーブルに対して <code class="literal">READ_BACKUP</code> をオンラインで設定できます:
      </p><pre class="programlisting">ALTER TABLE ... ALGORITHM=INPLACE, COMMENT="NDB_TABLE=READ_BACKUP=1";

ALTER TABLE ... ALGORITHM=INPLACE, COMMENT="NDB_TABLE=READ_BACKUP=0";
</pre><p>
        <code class="literal">ALTER TABLE</code> の <code class="literal">ALGORITHM</code> オプションの詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-online-operations" title="23.5.11 NDB Cluster での ALTER TABLE を使用したオンライン操作">セクション23.5.11「NDB Cluster での ALTER TABLE を使用したオンライン操作」</a> を参照してください。
      </p><p>
        <a class="indexterm" name="idm45827002154304"></a> <a class="indexterm" name="idm45827002152544"></a> <a class="indexterm" name="idm45827002150736"></a> <code class="literal">PARTITION_BALANCE</code>: パーティションの割当ておよび配置をさらに制御します。 次の 4 つのスキームがサポートされています: 
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <code class="literal">FOR_RP_BY_NODE</code>: ノードごとに 1 つのパーティション。
          </p><p>
            プライマリパーティションを格納する LDM はノードごとに 1 つのみです。 各パーティションは、すべてのノードの同じ LDM (同じ ID) に格納されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">FOR_RA_BY_NODE</code>: ノードグループごとに 1 つのパーティション。
          </p><p>
            各ノードには、単一のパーティション (プライマリレプリカまたはバックアップレプリカのいずれか) が格納されます。 各パーティションは、すべてのノードの同じ LDM に格納されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">FOR_RP_BY_LDM</code>: 各ノードの LDM ごとに 1 つのパーティション (デフォルト)。
          </p><p>
            これは、<code class="literal">READ_BACKUP</code> が 1 に設定されている場合に使用する設定です。
          </p></li><li class="listitem"><p>
            <code class="literal">FOR_RA_BY_LDM</code>: 各ノードグループの LDM ごとに 1 つのパーティション。
          </p><p>
            これらのパーティションには、プライマリパーティションまたはバックアップパーティションを指定できます。
          </p></li><li class="listitem"><p>
            <code class="literal">FOR_RA_BY_LDM_X_2</code>: 各ノードグループの LDM ごとに 2 つのパーティション。
          </p><p>
            これらのパーティションには、プライマリパーティションまたはバックアップパーティションを指定できます。
          </p></li><li class="listitem"><p>
            <code class="literal">FOR_RA_BY_LDM_X_3</code>: 各ノードグループの LDM ごとに 3 つのパーティション。
          </p><p>
            これらのパーティションには、プライマリパーティションまたはバックアップパーティションを指定できます。
          </p></li><li class="listitem"><p>
            <code class="literal">FOR_RA_BY_LDM_X_4</code>: 各ノードグループの LDM ごとに 4 つのパーティション。
          </p><p>
            これらのパーティションには、プライマリパーティションまたはバックアップパーティションを指定できます。
          </p></li></ol></div><p>
        <code class="literal">PARTITION_BALANCE</code> は、テーブル当たりのパーティション数を設定するための推奨インタフェースです。 <code class="literal">MAX_ROWS</code> を使用したパーティションの数の強制は非推奨ですが、下位互換性のために引き続きサポートされます。MySQL NDB Cluster の将来のリリースでは削除される予定です。 (Bug #81759、Bug #23544301) 
      </p><p>
        <a class="indexterm" name="idm45827002126432"></a> <a class="indexterm" name="idm45827002124624"></a> <code class="literal">FULLY_REPLICATED</code> は、テーブルが完全にレプリケートされるかどうか、つまり各データノードにテーブルの完全なコピーがあるかどうかを制御します。 テーブルの完全レプリケーションを有効にするには、<code class="literal">FULLY_REPLICATED=1</code> を使用します。 
      </p><p>
        この設定は、<code class="literal">ndb_fully_replicated</code> システム変数を使用して制御することもできます。 これを <code class="literal">ON</code> に設定すると、すべての新しい <code class="literal">NDB</code> テーブルに対してデフォルトでオプションが有効になります。デフォルトは <code class="literal">OFF</code> です。 <code class="literal">ndb_data_node_neighbour</code> システム変数は完全にレプリケートされたテーブルにも使用され、完全にレプリケートされたテーブルにアクセスしたときに、この MySQL Server に対してローカルなデータノードにアクセスするようにします。 
      </p><p>
        <code class="literal">NDB</code> テーブルの作成時にこのようなコメントを使用する <code class="literal">CREATE TABLE</code> ステートメントの例を次に示します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
     &gt;     <strong class="userinput"><code>c1 INT NOT NULL AUTO_INCREMENT PRIMARY KEY,</code></strong>
     &gt;     <strong class="userinput"><code>c2 VARCHAR(100),</code></strong>
     &gt;     <strong class="userinput"><code>c3 VARCHAR(100) )</code></strong>
     &gt; <strong class="userinput"><code>ENGINE=NDB</code></strong>
     &gt;
<strong class="userinput"><code>COMMENT="NDB_TABLE=READ_BACKUP=0,PARTITION_BALANCE=FOR_RP_BY_NODE";</code></strong>
</pre><p>
        コメントは、<code class="literal">SHOW CREATE TABLE</code> の出力の一部として表示されます。 コメントのテキストは、次の例に示すように、MySQL Information Schema <code class="literal">TABLES</code> テーブルのクエリーからも使用できます: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, TABLE_SCHEMA, TABLE_COMMENT</code></strong>
     &gt; <strong class="userinput"><code>FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME="t1"\G</code></strong>
*************************** 1. row ***************************
   TABLE_NAME: t1
 TABLE_SCHEMA: test
TABLE_COMMENT: NDB_TABLE=READ_BACKUP=0,PARTITION_BALANCE=FOR_RP_BY_NODE
1 row in set (0.01 sec)
</pre><p>
        このコメント構文は、次に示すように、<code class="literal">NDB</code> テーブルの <code class="literal">ALTER TABLE</code> ステートメントでもサポートされます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 COMMENT="NDB_TABLE=PARTITION_BALANCE=FOR_RA_BY_NODE";</code></strong>
Query OK, 0 rows affected (0.40 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
        NDB 8.0.21 以降、<code class="literal">TABLE_COMMENT</code> カラムには、次のように <code class="literal">ALTER TABLE</code> ステートメントのあとにテーブルを再作成するために必要なコメントが表示されます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, TABLE_SCHEMA, TABLE_COMMENT</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME="t1"\G</code></strong>
*************************** 1. row ***************************
   TABLE_NAME: t1
 TABLE_SCHEMA: test
TABLE_COMMENT: NDB_TABLE=READ_BACKUP=0,PARTITION_BALANCE=FOR_RP_BY_NODE
1 row in set (0.01 sec)
</pre><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, TABLE_SCHEMA, TABLE_COMMENT</code></strong>
     &gt; <strong class="userinput"><code>FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME="t1";</code></strong>
+------------+--------------+--------------------------------------------------+
| TABLE_NAME | TABLE_SCHEMA | TABLE_COMMENT                                    |
+------------+--------------+--------------------------------------------------+
| t1         | c            | NDB_TABLE=PARTITION_BALANCE=FOR_RA_BY_NODE       |
| t1         | d            |                                                  |
+------------+--------------+--------------------------------------------------+
2 rows in set (0.01 sec)
</pre><p>
        <code class="literal">ALTER TABLE</code> で使用されるテーブルコメントは、テーブルに存在する可能性のある既存のコメントを置き換えることに注意してください。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 COMMENT="NDB_TABLE=PARTITION_BALANCE=FOR_RA_BY_NODE";</code></strong>
Query OK, 0 rows affected (0.40 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, TABLE_SCHEMA, TABLE_COMMENT</code></strong>
     &gt; <strong class="userinput"><code>FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME="t1";</code></strong>
+------------+--------------+--------------------------------------------------+
| TABLE_NAME | TABLE_SCHEMA | TABLE_COMMENT                                    |
+------------+--------------+--------------------------------------------------+
| t1         | c            | NDB_TABLE=PARTITION_BALANCE=FOR_RA_BY_NODE       |
| t1         | d            |                                                  |
+------------+--------------+--------------------------------------------------+
2 rows in set (0.01 sec)
</pre><p>
        NDB 8.0.21 より前は、<code class="literal">ALTER TABLE</code> で使用されていたテーブルコメントによって、テーブルに存在する可能性のある既存のコメントが置き換えられていました。 これは、たとえば、<code class="literal">READ_BACKUP</code> 値が <code class="literal">ALTER TABLE</code> ステートメントによって設定された新しいコメントに引き継がれず、未指定の値がデフォルトに戻されたことを意味します。 (BUG#30428829) そのため、SQL を使用して以前にコメントに設定された値を取得する方法がなくなりました。 コメント値がデフォルトに戻らないようにするには、既存のコメント文字列からそのような値を保持し、<code class="literal">ALTER TABLE</code> に渡されるコメントに含める必要がありました。 
      </p><p>
        <code class="literal">PARTITION_BALANCE</code> オプションの値は、<span class="command"><strong>ndb_desc</strong></span> の出力にも表示されます。<span class="command"><strong>ndb_desc</strong></span> には、<code class="literal">READ_BACKUP</code> および <code class="literal">FULLY_REPLICATED</code> オプションがテーブルに設定されているかどうかも表示されます。 詳細は、このプログラムの説明を参照してください。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-tablespace"></a>13.1.21 CREATE TABLESPACE ステートメント</h3></div></div></div><a class="indexterm" name="idm45827002074592"></a><a class="indexterm" name="idm45827002073536"></a><a class="indexterm" name="idm45827002071360"></a><pre class="programlisting">CREATE [UNDO] TABLESPACE <em class="replaceable"><code>tablespace_name</code></em>

  <span class="emphasis"><em>InnoDB and NDB:</em></span>
    [ADD DATAFILE '<em class="replaceable"><code>file_name</code></em>']
    [AUTOEXTEND_SIZE [=] <em class="replaceable"><code>value</code></em>]

  <span class="emphasis"><em>InnoDB only:</em></span>
    [FILE_BLOCK_SIZE = value]
    [ENCRYPTION [=] {'Y' | 'N'}]

  <span class="emphasis"><em>NDB only:</em></span>
    USE LOGFILE GROUP <em class="replaceable"><code>logfile_group</code></em>
    [EXTENT_SIZE [=] <em class="replaceable"><code>extent_size</code></em>]
    [INITIAL_SIZE [=] <em class="replaceable"><code>initial_size</code></em>]
    [MAX_SIZE [=] <em class="replaceable"><code>max_size</code></em>]
    [NODEGROUP [=] <em class="replaceable"><code>nodegroup_id</code></em>]
    [WAIT]
    [COMMENT [=] '<em class="replaceable"><code>string</code></em>']

  <span class="emphasis"><em>InnoDB and NDB:</em></span>
    [ENGINE [=] <em class="replaceable"><code>engine_name</code></em>]

  <span class="emphasis"><em>Reserved for future use:</em></span>
    [ENGINE_ATTRIBUTE [=] '<em class="replaceable"><code>string</code></em>']
 </pre><p>
      このステートメントは、テーブルスペースの作成に使用されます。 正確な構文とセマンティクスは、使用されるストレージエンジンによって異なります。 標準の MySQL リリースでは、これは常に <code class="literal">InnoDB</code> テーブルスペースです。 MySQL NDB Cluster は、<code class="literal">NDB</code> ストレージエンジンを使用したテーブルスペースもサポートしています。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#create-tablespace-innodb" title="InnoDB に関する考慮事項">InnoDB に関する考慮事項</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-tablespace-ndb" title="NDB Cluster に関する考慮事項">NDB Cluster に関する考慮事項</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-tablespace-options" title="オプション">オプション</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-tablespace-notes" title="メモ">メモ</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-tablespace-innodb-examples" title="InnoDB の例">InnoDB の例</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-tablespace-ndb-examples" title="NDB の例">NDB の例</a></p></li></ul></div><h4><a name="create-tablespace-innodb"></a>InnoDB に関する考慮事項</h4><p>
      <code class="literal">CREATE TABLESPACE</code> 構文は、一般的なテーブルスペースまたは undo テーブルスペースの作成に使用されます。 undo テーブルスペースを作成するには、MySQL 8.0.14 で導入された <code class="literal">UNDO</code> キーワードを指定する必要があります。 
    </p><p>
      一般的なテーブルスペースは共有テーブルスペースです。 複数のテーブルを保持でき、すべてのテーブルの行フォーマットをサポートします。 一般テーブルスペースは、データディレクトリに対して相対的または独立した場所に作成できます。 
    </p><p>
      <code class="literal">InnoDB</code> の一般テーブルスペースを作成した後、<code class="literal">CREATE TABLE <em class="replaceable"><code>tbl_name</code></em> ... TABLESPACE [=] <em class="replaceable"><code>tablespace_name</code></em></code> または <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> TABLESPACE [=] <em class="replaceable"><code>tablespace_name</code></em></code> を使用してテーブルスペースにテーブルを追加します。 詳細は、<a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="15.6.3.3 一般テーブルスペース">セクション15.6.3.3「一般テーブルスペース」</a>を参照してください。 
    </p><p>
      undo テーブルスペースには undo ログが含まれます。 undo テーブルスペースは、完全修飾データファイルパスを指定することで、選択した場所に作成できます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-undo-tablespaces" title="15.6.3.4 undo テーブルスペース">セクション15.6.3.4「undo テーブルスペース」</a>を参照してください。 
    </p><h4><a name="create-tablespace-ndb"></a>NDB Cluster に関する考慮事項</h4><p>
      このステートメントは、テーブルスペースを作成するために使用します。このテーブルスペースには、「NDB Cluster ディスクデータ」テーブルの記憶領域を提供するデータファイルを 1 つ以上含めることができます (<a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data" title="23.5.10 NDB Cluster ディスクデータテーブル">セクション23.5.10「NDB Cluster ディスクデータテーブル」</a> を参照)。 このステートメントを使用して 1 つのデータファイルが作成され、テーブルスペースに追加されます。 <code class="literal">ALTER TABLESPACE</code> ステートメントを使用して、テーブルスペースにデータファイルを追加できます (<a class="xref" href="sql-statements.html#alter-tablespace" title="13.1.10 ALTER TABLESPACE ステートメント">セクション13.1.10「ALTER TABLESPACE ステートメント」</a>を参照してください)。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        NDB Cluster ディスクデータオブジェクトはすべて同じ名前空間を共有します。 つまり、<span class="emphasis"><em>各ディスクデータオブジェクト</em></span>は (単に、特定の型の各ディスクデータオブジェクトというだけでなく)、一意の名前が付けられている必要があります。 たとえば、テーブルスペースとログファイルグループを同じ名前にしたり、テーブルスペースとデータファイルを同じ名前にしたりすることはできません。 
      </p></div><p>
      作成されるテーブルスペースには、<code class="literal">USE LOGFILE GROUP</code> 句を使用して、1 つ以上の <code class="literal">UNDO</code> ログファイルのログファイルグループを割り当てる必要があります。<em class="replaceable"><code>logfile_group</code></em> は、<code class="literal">CREATE LOGFILE GROUP</code> で作成された既存のログファイルグループである必要があります (<a class="xref" href="sql-statements.html#create-logfile-group" title="13.1.16 CREATE LOGFILE GROUP ステートメント">セクション13.1.16「CREATE LOGFILE GROUP ステートメント」</a>を参照してください)。 複数のテーブルスペースが <code class="literal">UNDO</code> ロギングのために同じログファイルグループを使用できます。 
    </p><p>
      <code class="literal">EXTENT_SIZE</code> または <code class="literal">INITIAL_SIZE</code> を設定する場合は、<code class="filename">my.cnf</code> で使用されているものと同様に、数値の後に一文字の略称を付けることもできます。 一般に、これは <code class="literal">M</code> (M バイト) または <code class="literal">G</code> (G バイト) のどちらかの文字です。 
    </p><p>
      <code class="literal">INITIAL_SIZE</code> および <code class="literal">EXTENT_SIZE</code> は、次のように丸められます:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">EXTENT_SIZE</code> は、最も近い 32K の倍数に切り上げられます。
        </p></li><li class="listitem"><p>
          <code class="literal">INITIAL_SIZE</code> は、<span class="emphasis"><em>down</em></span> を 32K の最も近い整数の倍数に丸めます。この結果は、<code class="literal">EXTENT_SIZE</code> の最も近い整数の倍数に切り上げられます (丸め後)。
        </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">NDB</code> は、データノードの再起動操作のためにテーブルスペースの 4% を予約します。 この予約済領域は、データ記憶域には使用できません。 
      </p></div><p>
      今説明した丸めは明示的に実行され、このような丸めのいずれかが実行された場合は MySQL Server によって警告が発行されます。 丸められた値はまた、<code class="literal">INFORMATION_SCHEMA.FILES</code> カラム値の計算やその他の目的のために、NDB カーネルでも使用されます。 ただし、予期しない結果が発生しないようにするために、これらのオプションの指定では常に 32K の整数倍を使用することをお勧めします。 
    </p><p>
      <code class="literal">CREATE TABLESPACE</code> を <code class="literal">ENGINE [=] NDB</code> とともに使用すると、各クラスタデータノードにテーブルスペースおよび関連するデータファイルが作成されます。 <code class="literal">INFORMATION_SCHEMA.FILES</code> テーブルをクエリーすることによって、データファイルが作成されたことを確認したり、それらに関する情報を取得したりできます。 (このセクションの後半の例を参照してください。) 
    </p><p>
      (<a class="xref" href="information-schema.html#information-schema-files-table" title="26.15 INFORMATION_SCHEMA FILES テーブル">セクション26.15「INFORMATION_SCHEMA FILES テーブル」</a>を参照してください。)
    </p><h4><a name="create-tablespace-options"></a>オプション</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">ADD DATAFILE</code>: テーブルスペースデータファイルの名前を定義します。 このオプションは、<code class="literal">NDB</code> テーブルスペースを作成する場合は常に必要です。MySQL 8.0.14 以降の <code class="literal">InnoDB</code> の場合は、undo テーブルスペースを作成する場合にのみ必要です。 指定したパスを含む <code class="literal"><em class="replaceable"><code>file_name</code></em></code> は、一重引用符または二重引用符で囲む必要があります。 ファイル名 (ファイル拡張子をカウントしない) およびディレクトリ名は、少なくとも 1 バイトの長さにする必要があります。 長さゼロのファイル名およびディレクトリ名はサポートされていません。 
        </p><p>
          <code class="literal">InnoDB</code> と <code class="literal">NDB</code> によるデータファイルの処理方法にはかなりの違いがあるため、次の説明では 2 つのストレージエンジンについて個別に説明します。
        </p><p><b>InnoDB データファイル. </b>
            <code class="literal">InnoDB</code> テーブルスペースでは単一のデータファイルのみがサポートされ、その名前には <code class="literal">.ibd</code> 拡張子が含まれている必要があります。
          </p><p>
          <code class="literal">InnoDB</code> 一般テーブルスペースデータファイルをデータディレクトリ外の場所に配置するには、データディレクトリに対する完全修飾パスまたは相対パスを含めます。 undo テーブルスペースには、完全修飾パスのみが許可されます。 パスを指定しない場合、データディレクトリに一般テーブルスペースが作成されます。 パスを指定せずに作成された undo テーブルスペースは、<code class="literal">innodb_undo_directory</code> 変数で定義されたディレクトリに作成されます。 <code class="literal">innodb_undo_directory</code> 変数が定義されていない場合、undo テーブルスペースはデータディレクトリに作成されます。 
        </p><p>
          暗黙的に作成された file-per-table テーブルスペースとの競合を回避するために、データディレクトリの下のサブディレクトリに <code class="literal">InnoDB</code> 一般テーブルスペースを作成することはサポートされていません。 データディレクトリ外に一般的なテーブルスペースまたは undo テーブルスペースを作成する場合、そのディレクトリが存在し、テーブルスペースを作成する前に <code class="literal">InnoDB</code> で認識されている必要があります。 ディレクトリを <code class="literal">InnoDB</code> で認識できるようにするには、<code class="literal">innodb_directories</code> 値または <code class="literal">innodb_directories</code> 値に値が追加される変数のいずれかにディレクトリを追加します。<code class="literal">innodb_directories</code> は読取り専用変数です。 構成するには、サーバーを再起動する必要があります。 
        </p><p>
          <code class="literal">InnoDB</code> テーブルスペースの作成時に <code class="literal">ADD DATAFILE</code> 句が指定されていない場合、一意のファイル名を持つテーブルスペースデータファイルが暗黙的に作成されます。 一意のファイル名は、ダッシュ (<em class="replaceable"><code>aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee</code></em>) で区切られた 16 進数の 5 つのグループにフォーマットされた 128 ビット UUID です。 ストレージエンジンで必要な場合は、ファイル拡張子が追加されます。 <code class="filename">.ibd</code> ファイル拡張子が <code class="literal">InnoDB</code> 一般テーブルスペースデータファイルに追加されます。 レプリケーション環境では、レプリケーションソースサーバーに作成されたデータファイル名は、レプリカに作成されたデータファイル名と同じではありません。 
        </p><p>
          MySQL 8.0.17 では、<code class="literal">InnoDB</code> テーブルスペースの作成時に <code class="literal">ADD DATAFILE</code> 句で循環ディレクトリ参照は許可されません。 たとえば、次のステートメントの循環ディレクトリ参照 (<code class="literal">/../</code>) は使用できません: 
        </p><pre class="programlisting">CREATE TABLESPACE ts1 ADD DATAFILE ts1.ibd '<em class="replaceable"><code>any_directory</code></em>/../ts1.ibd';
</pre><p>
          この制限の例外は Linux に存在し、前述のディレクトリがシンボリックリンクの場合は循環ディレクトリ参照が許可されます。 たとえば、<em class="replaceable"><code>any_directory</code></em> がシンボリックリンクの場合、前述の例のデータファイルパスは許可されます。 (データファイルパスを'<code class="literal">../</code>'で始めることはできます。) 
        </p><p><b>NDB データファイル. </b>
            <code class="literal">NDB</code> テーブルスペースでは、任意の有効なファイル名を持つことができる複数のデータファイルがサポートされています。<code class="literal">ALTER TABLESPACE</code> ステートメントを使用して、作成後に「NDB Cluster」テーブルスペースにデータファイルを追加できます。
          </p><p>
          <code class="literal">NDB</code> テーブルスペースデータファイルは、デフォルトでデータノードファイルシステムディレクトリ、つまりデータノードデータディレクトリ (<code class="literal">DataDir</code>) の下の <code class="filename">ndb_<em class="replaceable"><code>nodeid</code></em>_fs/TS</code> という名前のディレクトリに作成されます。<em class="replaceable"><code>nodeid</code></em> はデータノード <code class="literal">NodeId</code> です。 データファイルをデフォルト以外の場所に配置するには、絶対ディレクトリパスまたはデフォルトの場所に対する相対パスを含めます。 指定されたディレクトリが存在しない場合、<code class="literal">NDB</code> はそれを作成しようとします。そのためには、データノードプロセスが実行されているシステムユーザーアカウントに適切なアクセス権が必要です。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            データファイルに使用されるパスを決定する際、<code class="literal">NDB</code> は <code class="literal">~</code> (チルダ) 文字を拡張しません。
          </p></div><p>
          複数のデータノードが同じ物理ホスト上で実行されている場合は、次の考慮事項が適用されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              データファイルの作成時に絶対パスを指定することはできません。
            </p></li><li class="listitem"><p>
              各データノードに個別のデータディレクトリがないかぎり、データノードファイルシステムのディレクトリ外にテーブルスペースデータファイルを作成することはできません。
            </p></li><li class="listitem"><p>
              各データノードに独自のデータディレクトリがある場合は、このディレクトリ内の任意の場所にデータファイルを作成できます。
            </p></li><li class="listitem"><p>
              各データノードに独自のデータディレクトリがある場合は、そのホスト上で実行されている各データノードのホストファイルシステム上の一意の場所に解決されるかぎり、相対パスを使用してノードデータディレクトリ外にデータファイルを作成することもできます。
            </p></li></ul></div></li><li class="listitem"><p>
          <code class="literal">FILE_BLOCK_SIZE</code>: このオプションは <code class="literal">InnoDB</code> の一般的なテーブルスペースに固有で、<code class="literal">NDB</code> によって無視され、テーブルスペースデータファイルのブロックサイズが定義されます。 値はバイト単位または KB 単位で指定できます。 たとえば、8K バイトのファイルブロックサイズは 8192 または 8K と指定できます。 このオプションを指定しない場合、<code class="literal">FILE_BLOCK_SIZE</code> はデフォルトで <code class="literal">innodb_page_size</code> 値に設定されます。 <code class="literal">FILE_BLOCK_SIZE</code> は、圧縮された <code class="literal">InnoDB</code> テーブル (<code class="literal">ROW_FORMAT=COMPRESSED</code>) の格納にテーブルスペースを使用する場合に必要です。 この場合、テーブルスペースの作成時にテーブルスペース <code class="literal">FILE_BLOCK_SIZE</code> を定義する必要があります。 
        </p><p>
          <code class="literal">FILE_BLOCK_SIZE</code> が <code class="literal">innodb_page_size</code> 値と等しい場合、テーブルスペースには、圧縮されていない行形式 (<code class="literal">COMPACT</code>、<code class="literal">REDUNDANT</code> および <code class="literal">DYNAMIC</code>) を持つテーブルのみを含めることができます。 <code class="literal">COMPRESSED</code> 行形式のテーブルの物理ページサイズは、圧縮されていないテーブルとは異なります。 したがって、圧縮されたテーブルは、圧縮されていないテーブルと同じテーブルスペースに共存できません。 
        </p><p>
          一般的なテーブルスペースに圧縮テーブルを含めるには、<code class="literal">FILE_BLOCK_SIZE</code> を指定する必要があり、<code class="literal">FILE_BLOCK_SIZE</code> 値は <code class="literal">innodb_page_size</code> 値との関連で有効な圧縮ページサイズである必要があります。 また、圧縮テーブル (<code class="literal">KEY_BLOCK_SIZE</code>) の物理ページサイズは <code class="literal">FILE_BLOCK_SIZE/1024</code> と同じである必要があります。 たとえば、<code class="literal">innodb_page_size=16K</code> および <code class="literal">FILE_BLOCK_SIZE=8K</code> の場合、テーブルの <code class="literal">KEY_BLOCK_SIZE</code> は 8 である必要があります。 詳細は、<a class="xref" href="innodb-storage-engine.html#general-tablespaces" title="15.6.3.3 一般テーブルスペース">セクション15.6.3.3「一般テーブルスペース」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">USE LOGFILE GROUP</code>: <code class="literal">NDB</code> に必要です。これは、<code class="literal">CREATE LOGFILE GROUP</code> を使用して以前に作成されたログファイルグループの名前です。 <code class="literal">InnoDB</code> ではサポートされていません。エラーで失敗します。 
        </p></li><li class="listitem"><p>
          <code class="literal">EXTENT_SIZE</code>: このオプションは NDB に固有であり、エラーで失敗する InnoDB ではサポートされていません。 <code class="literal">EXTENT_SIZE</code> では、テーブルスペースに属するすべてのファイルで使用されるエクステントのサイズがバイト単位で設定されます。 デフォルト値は 1M です。 最小サイズは 32K であり、理論的な最大サイズは 2G です。ただし、実際的な最大サイズはいくつかの要因によって異なります。 ほとんどの場合は、エクステントサイズを変更してもパフォーマンスに測定可能な影響を与えることはないため、特別な状況を除き、常にデフォルト値を使用することをお勧めします。 
        </p><p>
          <span class="firstterm">エクステント</span>は、ディスク領域の割り当ての単位です。 1 つのエクステントが、そのエクステントに収容できる量のデータでいっぱいになってから、別のエクステントが使用されます。 理論上は、データファイルあたり最大 65,535 (64K) 個のエクステントを使用できます。ただし、推奨される最大数は 32,768 (32K) です。 1 つのデータファイルの推奨される最大サイズは 32G (つまり、32K 個のエクステント × エクステントあたり 1M バイト) です。 さらに、エクステントを特定のパーティションに割り当てたあと、そのエクステントを使用して別のパーティションのデータを格納することはできません。エクステントには、複数のパーティションのデータを格納できません。 これは、たとえば、<code class="literal">INITIAL_SIZE</code>(次の項目を参照) が 256 MB で、<code class="literal">EXTENT_SIZE</code> が 128M の単一のデータファイルを持つテーブルスペースにはエクステントが 2 つしかないため、最大 2 つの異なるディスクデータテーブルパーティションのデータを格納するために使用できることを意味します。 
        </p><p>
          <code class="literal">INFORMATION_SCHEMA.FILES</code> テーブルをクエリーすることによって、特定のデータファイルに未使用のまま残っているエクステントの数を確認できるため、ファイル内の空き容量の概算値を導き出すことができます。 それ以上の説明および例については、<a class="xref" href="information-schema.html#information-schema-files-table" title="26.15 INFORMATION_SCHEMA FILES テーブル">セクション26.15「INFORMATION_SCHEMA FILES テーブル」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">INITIAL_SIZE</code>: このオプションは <code class="literal">NDB</code> に固有であり、<code class="literal">InnoDB</code> ではサポートされていません。エラーが発生して失敗します。
        </p><p>
          <code class="literal">INITIAL_SIZE</code> パラメータは、<code class="literal">ADD DATATFILE</code> を使用して特定されたデータファイルの合計サイズをバイト単位で設定します。 このファイルが作成されると、そのサイズは変更できませんが、<code class="literal">ALTER TABLESPACE ... ADD DATAFILE</code> を使用してテーブルスペースにデータファイルを追加できます。 
        </p><p>
          <code class="literal">INITIAL_SIZE</code> はオプションです。そのデフォルト値は 134217728 (128M バイト) です。
        </p><p>
          32 ビットシステム上では、<code class="literal">INITIAL_SIZE</code> のサポートされる最大値は 4294967296 (4G バイト) です。
        </p></li><li class="listitem"><p>
          <code class="literal">AUTOEXTEND_SIZE</code>: MySQL 8.0.23 より前の MySQL では無視されます。MySQL 8.0.23 から、テーブルスペースが一杯になったときに <code class="literal">InnoDB</code> がテーブルスペースのサイズを拡張する量を定義します。 設定は 4MB の倍数である必要があります。 デフォルト設定は 0 で、暗黙的なデフォルト動作に従ってテーブルスペースが拡張されます。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-tablespace-autoextend-size" title="15.6.3.9 テーブルスペースの AUTOEXTEND_SIZE 構成">セクション15.6.3.9「テーブルスペースの AUTOEXTEND_SIZE 構成」</a>を参照してください。 
        </p><p>
          使用しているストレージエンジンに関係なく、MySQL NDB Cluster 8.0 のどのリリースにも影響はありません。
        </p></li><li class="listitem"><p>
          <code class="literal">MAX_SIZE</code>: 現在、MySQL では無視されます。将来の使用のために予約されています。 使用されているストレージエンジンに関係なく、MySQL 8.0 または MySQL NDB Cluster 8.0 のどのリリースにも影響しません。 
        </p></li><li class="listitem"><p>
          <code class="literal">NODEGROUP</code>: 現在、MySQL では無視されます。将来の使用のために予約されています。 使用されているストレージエンジンに関係なく、MySQL 8.0 または MySQL NDB Cluster 8.0 のどのリリースにも影響しません。 
        </p></li><li class="listitem"><p>
          <code class="literal">WAIT</code>: 現在、MySQL では無視されます。将来の使用のために予約されています。 使用されているストレージエンジンに関係なく、MySQL 8.0 または MySQL NDB Cluster 8.0 のどのリリースにも影響しません。 
        </p></li><li class="listitem"><p>
          <code class="literal">COMMENT</code>: 現在、MySQL では無視されます。将来の使用のために予約されています。 使用されているストレージエンジンに関係なく、MySQL 8.0 または MySQL NDB Cluster 8.0 のどのリリースにも影響しません。 
        </p></li><li class="listitem"><p>
          <code class="literal">ENCRYPTION</code> 句は、<code class="literal">InnoDB</code> 一般テーブルスペースのページレベルのデータ暗号化を有効または無効にします。 一般テーブルスペースの暗号化サポートは、MySQL 8.0.13 で導入されました。 
        </p><p>
          MySQL 8.0.16 では、<code class="literal">ENCRYPTION</code> 句が指定されていない場合、<code class="literal">default_table_encryption</code> 設定によって暗号化を有効にするかどうかが制御されます。 <code class="literal">ENCRYPTION</code> 句は、<code class="literal">default_table_encryption</code> 設定をオーバーライドします。 ただし、<code class="literal">table_encryption_privilege_check</code> 変数が有効になっている場合、<code class="literal">default_table_encryption</code> 設定とは異なる <code class="literal">ENCRYPTION</code> 句設定を使用するには、<code class="literal">TABLE_ENCRYPTION_ADMIN</code> 権限が必要です。 
        </p><p>
          暗号化対応のテーブルスペースを作成する前に、キープラグインをインストールして構成する必要があります。
        </p><p>
          一般的なテーブルスペースが暗号化されると、テーブルスペースに存在するすべてのテーブルが暗号化されます。 同様に、暗号化されたテーブルスペースに作成されたテーブルも暗号化されます。 
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-data-encryption" title="15.13 InnoDB 保存データ暗号化">セクション15.13「InnoDB 保存データ暗号化」</a>を参照してください
        </p></li><li class="listitem"><p>
          <code class="literal">ENGINE</code>: テーブルスペースを使用するストレージエンジンを定義します。ここで、<em class="replaceable"><code>engine_name</code></em> はストレージエンジンの名前です。 現在、標準の MySQL 8.0 リリースでは、<code class="literal">InnoDB</code> ストレージエンジンのみがサポートされています。 MySQL NDB Cluster は、<code class="literal">NDB</code> と <code class="literal">InnoDB</code> の両方のテーブルスペースをサポートしています。 このオプションが指定されていない場合、<code class="literal">default_storage_engine</code> システム変数の値が <code class="literal">ENGINE</code> に使用されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">ENGINE_ATTRIBUTE</code> オプション (MySQL 8.0.21 の時点で使用可能) を使用して、プライマリストレージエンジンのテーブルスペース属性を指定します。 このオプションは、将来の使用のために予約されています。 
        </p><p>
          許可される値は、有効な <code class="literal">JSON</code> ドキュメントまたは空の文字列 ('') を含む文字列リテラルです。 無効な <code class="literal">JSON</code> が拒否されました。 
        </p><pre class="programlisting">CREATE TABLESPACE ts1 ENGINE_ATTRIBUTE='{"<em class="replaceable"><code>key</code></em>":"<em class="replaceable"><code>value</code></em>"}';
</pre><p>
          <code class="literal">ENGINE_ATTRIBUTE</code> の値は、エラーなしで繰り返すことができます。 この場合、最後に指定した値が使用されます。 
        </p><p>
          <code class="literal">ENGINE_ATTRIBUTE</code> 値はサーバーによってチェックされず、テーブルストレージエンジンが変更されたときにもクリアされません。
        </p></li></ul></div><h4><a name="create-tablespace-notes"></a>メモ</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          MySQL テーブルスペースのネーミングに関するルールは、<a class="xref" href="language-structure.html#identifiers" title="9.2 スキーマオブジェクト名">セクション9.2「スキーマオブジェクト名」</a> を参照してください。 この接頭辞はシステムで使用するために予約されているため、これらのルールに加えて、スラッシュ文字 (<span class="quote">「<span class="quote">/</span>」</span>) も使用できず、<code class="literal">innodb_</code>で始まる名前も使用できません。 
        </p></li><li class="listitem"><p>
          一時一般テーブルスペースの作成はサポートされていません。
        </p></li><li class="listitem"><p>
          一般テーブルスペースでは、一時テーブルはサポートされていません。
        </p></li><li class="listitem"><p>
          <code class="literal">TABLESPACE</code> オプションを <code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> とともに使用して、<code class="literal">InnoDB</code> テーブルパーティションまたはサブパーティションを file-per-table テーブルスペースに割り当てることができます。 すべてのパーティションは同じストレージエンジンに属している必要があります。 共有 <code class="literal">InnoDB</code> テーブルスペースへのテーブルパーティションの割当てはサポートされていません。 共有テーブルスペースには、<code class="literal">InnoDB</code> システムテーブルスペースおよび一般テーブルスペースが含まれます。 
        </p></li><li class="listitem"><p>
          一般テーブルスペースでは、<code class="literal">CREATE TABLE ... TABLESPACE</code> を使用した行形式のテーブルの追加がサポートされています。<code class="literal">innodb_file_per_table</code> を有効にする必要はありません。
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_strict_mode</code> は、一般的なテーブルスペースには適用できません。 テーブルスペース管理ルールは、<code class="literal">innodb_strict_mode</code> とは無関係に厳密に適用されます。 <code class="literal">CREATE TABLESPACE</code> パラメータが正しくないか、互換性がない場合、<code class="literal">innodb_strict_mode</code> の設定に関係なく操作は失敗します。 <code class="literal">CREATE TABLE ... TABLESPACE</code> または <code class="literal">ALTER TABLE ... TABLESPACE</code> を使用してテーブルを一般テーブルスペースに追加すると、<code class="literal">innodb_strict_mode</code> は無視されますが、このステートメントは <code class="literal">innodb_strict_mode</code> が有効になっているかのように評価されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">DROP TABLESPACE</code> を使用して、テーブルスペースを削除します。 テーブルスペースを削除する前に、<code class="literal">DROP TABLE</code> を使用してテーブルスペースからすべてのテーブルを削除する必要があります。 「NDB Cluster」テーブルスペースを削除する前に、1 つ以上の <code class="literal">ALTER TABLESPACE ... DROP DATATFILE</code> ステートメントを使用してすべてのデータファイルを削除する必要もあります。 <a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data-objects" title="23.5.10.1 NDB Cluster ディスクデータオブジェクト">セクション23.5.10.1「NDB Cluster ディスクデータオブジェクト」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> 一般テーブルスペースに追加された <code class="literal">InnoDB</code> テーブルのすべての部分は、インデックスや <code class="literal">BLOB</code> ページなどの一般テーブルスペースに存在します。
        </p><p>
          テーブルスペースに割り当てられた <code class="literal">NDB</code> テーブルの場合、インデックス付けされていないカラムのみがディスクに格納され、実際にはテーブルスペースデータファイルが使用されます。 すべての <code class="literal">NDB</code> テーブルのインデックスおよびインデックス付けされたカラムは、常にメモリーに保持されます。 
        </p></li><li class="listitem"><p>
          システムテーブルスペースと同様に、一般テーブルスペースに格納されているテーブルの切捨てまたは削除によって、新しい <code class="literal">InnoDB</code> データにのみ使用できる空き領域が一般テーブルスペース <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibd data file</a> に内部的に作成されます。 file-per-table テーブルスペース用であるため、領域はオペレーティングシステムに解放されません。 
        </p></li><li class="listitem"><p>
          一般テーブルスペースは、どのデータベースまたはスキーマにも関連付けられていません。
        </p></li><li class="listitem"><p>
          <code class="literal">ALTER TABLE ... DISCARD TABLESPACE</code> および <code class="literal">ALTER TABLE ...IMPORT TABLESPACE</code> は、一般テーブルスペースに属するテーブルではサポートされていません。
        </p></li><li class="listitem"><p>
          サーバーは、一般的なテーブルスペースを参照する DDL に対してテーブルスペースレベルのメタデータロックを使用します。 比較すると、サーバーは file-per-table テーブルスペースを参照する DDL に対してテーブルレベルのメタデータロックを使用します。 
        </p></li><li class="listitem"><p>
          生成されたテーブルスペースまたは既存のテーブルスペースを一般テーブルスペースに変更することはできません。
        </p></li><li class="listitem"><p>
          一般的なテーブルスペース名と file-per-table テーブルスペース名の間に競合はありません。 file-per-table テーブルスペース名に存在する<span class="quote">「<span class="quote">/</span>」</span>文字は、一般的なテーブルスペース名では使用できません。 
        </p></li><li class="listitem"><p>
          <span class="command"><strong>mysqldump</strong></span> および <span class="command"><strong>mysqlpump</strong></span> は、<code class="literal">InnoDB</code> <code class="literal">CREATE TABLESPACE</code> ステートメントをダンプしません。
        </p></li></ul></div><h4><a name="create-tablespace-innodb-examples"></a>InnoDB の例</h4><p>
      この例では、一般的なテーブルスペースを作成し、異なる行形式の 3 つの非圧縮テーブルを追加する方法を示します。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts1` ADD DATAFILE 'ts1.ibd' ENGINE=INNODB;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts1 ROW_FORMAT=REDUNDANT;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (c1 INT PRIMARY KEY) TABLESPACE ts1 ROW_FORMAT=COMPACT;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t3 (c1 INT PRIMARY KEY) TABLESPACE ts1 ROW_FORMAT=DYNAMIC;</code></strong>
</pre><p>
      この例では、一般的なテーブルスペースを作成し、圧縮テーブルを追加する方法を示します。 この例では、デフォルトの <code class="literal">innodb_page_size</code> 値が 16K であると想定しています。 8192 の <code class="literal">FILE_BLOCK_SIZE</code> では、圧縮テーブルの <code class="literal">KEY_BLOCK_SIZE</code> が 8 である必要があります。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts2` ADD DATAFILE 'ts2.ibd' FILE_BLOCK_SIZE = 8192 Engine=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t4 (c1 INT PRIMARY KEY) TABLESPACE ts2 ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=8;</code></strong>
</pre><p>
      この例では、MySQL 8.0.14 の時点でオプションの <code class="literal">ADD DATAFILE</code> 句を指定せずに一般的なテーブルスペースを作成する方法を示します。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts3` ENGINE=INNODB;</code></strong>
</pre><p>
      この例では、undo テーブルスペースの作成方法を示します。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE UNDO TABLESPACE <em class="replaceable"><code>undo_003</code></em> ADD DATAFILE '<em class="replaceable"><code>undo_003</code></em>.ibu';</code></strong>
</pre><h4><a name="create-tablespace-ndb-examples"></a>NDB の例</h4><p>
      <code class="filename">mydata-1.dat</code> という名前のデータファイルを使用して、<code class="literal">myts</code> という名前の「NDB Cluster ディスクデータ」テーブルスペースを作成するとします。 <code class="filename">NDB</code> テーブルスペースでは、常に 1 つ以上の undo ログファイルで構成されるログファイルグループを使用する必要があります。 この例では、まず、次に示す <code class="literal">CREATE LOGFILE GROUP</code> ステートメントを使用して、<code class="filename">myundo-1.dat</code> という名前の undo ログファイルを含む <code class="literal">mylg</code> という名前のログファイルグループを作成します: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE LOGFILE GROUP myg1</code></strong>
    -&gt;     <strong class="userinput"><code>ADD UNDOFILE 'myundo-1.dat'</code></strong>
    -&gt;     <strong class="userinput"><code>ENGINE=NDB;</code></strong>
Query OK, 0 rows affected (3.29 sec)
</pre><p>
      これで、次のステートメントを使用して、前述のテーブルスペースを作成できます:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE myts</code></strong>
    -&gt;     <strong class="userinput"><code>ADD DATAFILE 'mydata-1.dat'</code></strong>
    -&gt;     <strong class="userinput"><code>USE LOGFILE GROUP mylg</code></strong>
    -&gt;     <strong class="userinput"><code>ENGINE=NDB;</code></strong>
Query OK, 0 rows affected (2.98 sec)
</pre><p>
      次に示すように、<code class="literal">TABLESPACE</code> および <code class="literal">STORAGE DISK</code> オプションを指定した <code class="literal">CREATE TABLE</code> ステートメントを使用して、「ディスクデータ」テーブルを作成できるようになりました:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE mytable (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,</code></strong>
    -&gt;     <strong class="userinput"><code>lname VARCHAR(50) NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>fname VARCHAR(50) NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>dob DATE NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>joined DATE NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>INDEX(last_name, first_name)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt;     <strong class="userinput"><code>TABLESPACE myts STORAGE DISK</code></strong>
    -&gt;     <strong class="userinput"><code>ENGINE=NDB;</code></strong>
Query OK, 0 rows affected (1.41 sec)
</pre><p>
      <code class="literal">id</code>、<code class="literal">lname</code> および <code class="literal">fname</code> カラムはすべてインデックス付けされているため、実際には <code class="literal">mytable</code> の <code class="literal">dob</code> および <code class="literal">joined</code> カラムのみがディスクに格納されることに注意してください。
    </p><p>
      前述のように、<code class="literal">CREATE TABLESPACE</code> を <code class="literal">ENGINE [=] NDB</code> とともに使用すると、テーブルスペースおよび関連するデータファイルが NDB Cluster データノードごとに作成されます。 次に示すように、<code class="literal">INFORMATION_SCHEMA.FILES</code> テーブルをクエリーして、データファイルが作成されたことを確認し、その情報を取得できます: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT FILE_NAME, FILE_TYPE, LOGFILE_GROUP_NAME, STATUS, EXTRA</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.FILES</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLESPACE_NAME = 'myts';</code></strong>

+--------------+------------+--------------------+--------+----------------+
| file_name    | file_type  | logfile_group_name | status | extra          |
+--------------+------------+--------------------+--------+----------------+
| mydata-1.dat | DATAFILE   | mylg               | NORMAL | CLUSTER_NODE=5 |
| mydata-1.dat | DATAFILE   | mylg               | NORMAL | CLUSTER_NODE=6 |
| NULL         | TABLESPACE | mylg               | NORMAL | NULL           |
+--------------+------------+--------------------+--------+----------------+
3 rows in set (0.01 sec)
</pre><p>
      追加情報および例については、<a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data-objects" title="23.5.10.1 NDB Cluster ディスクデータオブジェクト">セクション23.5.10.1「NDB Cluster ディスクデータオブジェクト」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-trigger"></a>13.1.22 CREATE TRIGGER ステートメント</h3></div></div></div><a class="indexterm" name="idm45827001746896"></a><a class="indexterm" name="idm45827001745584"></a><pre class="programlisting">CREATE
    [DEFINER = <em class="replaceable"><code>user</code></em>]
    TRIGGER <em class="replaceable"><code>trigger_name</code></em>
    <em class="replaceable"><code>trigger_time</code></em> <em class="replaceable"><code>trigger_event</code></em>
    ON <em class="replaceable"><code>tbl_name</code></em> FOR EACH ROW
    [<em class="replaceable"><code>trigger_order</code></em>]
    <em class="replaceable"><code>trigger_body</code></em>

<em class="replaceable"><code>trigger_time</code></em>: { BEFORE | AFTER }

<em class="replaceable"><code>trigger_event</code></em>: { INSERT | UPDATE | DELETE }

<em class="replaceable"><code>trigger_order</code></em>: { FOLLOWS | PRECEDES } <em class="replaceable"><code>other_trigger_name</code></em>
</pre><p>
      このステートメントは、新しいトリガーを作成します。 トリガーとは、テーブルに関連付けられ、そのテーブルに対して特定のイベントが発生するとアクティブ化される名前付きデータベースオブジェクトのことです。 トリガーは、<em class="replaceable"><code>tbl_name</code></em> という名前のテーブルに関連付けられます。これは、永続的なテーブルを指す必要があります。 トリガーを <code class="literal">TEMPORARY</code> テーブルまたはビューに関連付けることはできません。 
    </p><p>
      トリガー名はスキーマの名前空間内に存在します。つまり、すべてのトリガーがスキーマ内で一意の名前を持つ必要があります。 異なるスキーマ内のトリガーは同じ名前を持つことができます。 
    </p><p>
      このセクションでは、<code class="literal">CREATE TRIGGER</code> 構文について説明します。 詳細は、<a class="xref" href="stored-objects.html#trigger-syntax" title="25.3.1 トリガーの構文と例">セクション25.3.1「トリガーの構文と例」</a>を参照してください。 
    </p><p>
      <code class="literal">CREATE TRIGGER</code> には、このトリガーに関連付けられたテーブルに対する <code class="literal">TRIGGER</code> 権限が必要です。 <code class="literal">DEFINER</code> 句が存在する場合、<a class="xref" href="stored-objects.html#stored-objects-security" title="25.6 ストアドオブジェクトのアクセス制御">セクション25.6「ストアドオブジェクトのアクセス制御」</a> で説明されているように、必要な権限は <em class="replaceable"><code>user</code></em> の値によって異なります。 バイナリロギングが有効になっている場合は、<a class="xref" href="stored-objects.html#stored-programs-logging" title="25.7 ストアドプログラムバイナリロギング">セクション25.7「ストアドプログラムバイナリロギング」</a> で説明されているように、<code class="literal">CREATE TRIGGER</code> に <code class="literal">SUPER</code> 権限が必要になることがあります。 
    </p><p>
      <code class="literal">DEFINER</code> 句は、このセクションのあとの方で説明されているように、トリガーのアクティブ化時にアクセス権限を確認するときに使用されるセキュリティーコンテキストを決定します。
    </p><p>
      <em class="replaceable"><code>trigger_time</code></em> は、このトリガーのアクション時間です。 これは、トリガーが各行の変更の前またはあとにアクティブ化されることを示す <code class="literal">BEFORE</code> または <code class="literal">AFTER</code> にすることができます。 
    </p><p>
      基本的なカラム値チェックはトリガーのアクティブ化の前に行われるため、<code class="literal">BEFORE</code> トリガーを使用して、カラムタイプに不適切な値を有効な値に変換することはできません。
    </p><p>
      <em class="replaceable"><code>trigger_event</code></em> は、このトリガーをアクティブ化する操作の種類を示します。 次の <em class="replaceable"><code>trigger_event</code></em> 値が許可されます。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">INSERT</code>: トリガーは、新しい行がテーブルに挿入されるたびにアクティブ化されます (たとえば、<code class="literal">INSERT</code>、<code class="literal">LOAD DATA</code> および <code class="literal">REPLACE</code> ステートメントを使用)。
        </p></li><li class="listitem"><p>
          <code class="literal">UPDATE</code>: トリガーは、(<code class="literal">UPDATE</code> ステートメントなどを使用して) 行が変更されるたびにアクティブ化されます。
        </p></li><li class="listitem"><p>
          <code class="literal">DELETE</code>: トリガーは、(<code class="literal">DELETE</code> ステートメントや <code class="literal">REPLACE</code> ステートメントなどを使用して) 行がテーブルから削除されるたびにアクティブになります。 テーブルに対する <code class="literal">DROP TABLE</code> および <code class="literal">TRUNCATE TABLE</code> ステートメントは、<code class="literal">DELETE</code> を使用しないため、このトリガーをアクティブ化<span class="emphasis"><em>しません</em></span>。 また、パーティションを削除しても <code class="literal">DELETE</code> トリガーはアクティブ化されません。 
        </p></li></ul></div><p>
      <em class="replaceable"><code>trigger_event</code></em> は、トリガーをアクティブ化する SQL ステートメントのリテラル型を表しているのではなく、テーブル操作の種類を表しています。 たとえば、<code class="literal">INSERT</code> トリガーは、<code class="literal">INSERT</code> ステートメントだけでなく、<code class="literal">LOAD DATA</code> ステートメントでもアクティブ化されます。それは、どちらのステートメントもテーブルに行を挿入するためです。 
    </p><p>
      この混乱を招く可能性がある例として、<code class="literal">INSERT INTO ... ON DUPLICATE KEY UPDATE ...</code> 構文があります。すべての行で <code class="literal">BEFORE INSERT</code> トリガーがアクティブ化されたあと、その行に重複キーが存在したかどうかに応じて、<code class="literal">AFTER INSERT</code> トリガーだけか、または <code class="literal">BEFORE UPDATE</code> トリガーと <code class="literal">AFTER UPDATE</code> トリガーの両方がアクティブ化されます。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        カスケードされた外部キーアクションはトリガーをアクティブ化しません。
      </p></div><p>
      同じトリガーイベントおよびアクション時間を持つ特定のテーブルに対して複数のトリガーを定義できます。 たとえば、1 つのテーブルに対して 2 つの <code class="literal">BEFORE UPDATE</code> トリガーを定義できます。 デフォルトでは、同じトリガーイベントおよびアクション時間を持つトリガーは、作成された順序で実行されます。 トリガー順序に影響を与えるには、<code class="literal">FOLLOWS</code> または <code class="literal">PRECEDES</code> を示す <em class="replaceable"><code>trigger_order</code></em> 句と、同じトリガーイベントおよびアクション時間を持つ既存のトリガーの名前を指定します。 <code class="literal">FOLLOWS</code> を指定すると、新しいトリガーは既存のトリガーのあとに実行されます。 <code class="literal">PRECEDES</code> を指定すると、新しいトリガーは既存のトリガーの前に実行されます。 
    </p><p>
      <em class="replaceable"><code>trigger_body</code></em> は、トリガーがアクティブ化されるときに実行されるステートメントです。 複数のステートメントを実行するには、<code class="literal">BEGIN ... END</code> 複合ステートメント構造構文を使用します。 これにより、ストアドルーチン内で許可されているものと同じステートメントを使用することもできます。 <a class="xref" href="sql-statements.html#begin-end" title="13.6.1 BEGIN ... END 複合ステートメント">セクション13.6.1「BEGIN ... END 複合ステートメント」</a>を参照してください。 一部のステートメントは、トリガー内では許可されません。<a class="xref" href="stored-objects.html#stored-program-restrictions" title="25.8 ストアドプログラムの制約">セクション25.8「ストアドプログラムの制約」</a>を参照してください。 
    </p><p>
      トリガー本体内では、エイリアス <code class="literal">OLD</code> と <code class="literal">NEW</code> を使用して、対象テーブル (そのトリガーに関連付けられたテーブル) 内のカラムを参照できます。 <code class="literal">OLD.<em class="replaceable"><code>col_name</code></em></code> は、更新または削除される前の既存の行のカラムを示します。 <code class="literal">NEW.<em class="replaceable"><code>col_name</code></em></code> は、挿入された新しい行、または更新されたあとの既存の行のカラムを示します。 
    </p><a class="indexterm" name="idm45827001671344"></a><p>
      トリガーは、<code class="literal">NEW.<em class="replaceable"><code>col_name</code></em></code> または <code class="literal">OLD.<em class="replaceable"><code>col_name</code></em></code> を使用して生成されたカラムを参照することはできません。 生成されるカラムの詳細は、<a class="xref" href="sql-statements.html#create-table-generated-columns" title="13.1.20.8 CREATE TABLE および生成されるカラム">セクション13.1.20.8「CREATE TABLE および生成されるカラム」</a> を参照してください。 
    </p><p>
      MySQL は、トリガーが作成されたときの有効な <code class="literal">sql_mode</code> システム変数の設定を格納し、<span class="emphasis"><em>トリガーが実行を開始したときの現在のサーバー SQL モードには関係なく</em></span>、常にそのトリガー本体を強制的にこの設定で実行します。
    </p><p>
      <code class="literal">DEFINER</code> 句は、トリガーのアクティブ化時にアクセス権限を確認するときに使用される MySQL アカウントを指定します。 <code class="literal">DEFINER</code> 句が存在する場合、<em class="replaceable"><code>user</code></em> 値は<code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'<em class="replaceable"><code>host_name</code></em>'</code>、<code class="literal">CURRENT_USER</code> または <code class="literal">CURRENT_USER()</code> として指定された MySQL アカウントである必要があります。 許可される <em class="replaceable"><code>user</code></em> 値は、<a class="xref" href="stored-objects.html#stored-objects-security" title="25.6 ストアドオブジェクトのアクセス制御">セクション25.6「ストアドオブジェクトのアクセス制御」</a> で説明されているように、保持する権限によって異なります。 トリガーセキュリティの詳細は、そのセクションも参照してください。 
    </p><p>
      <code class="literal">DEFINER</code> 句を省略すると、デフォルトの定義者は <code class="literal">CREATE TRIGGER</code> ステートメントを実行するユーザーになります。 これは、明示的に <code class="literal">DEFINER = CURRENT_USER</code> を指定するのと同じです。 
    </p><p>
      MySQL は、トリガー権限を確認するときに、<code class="literal">DEFINER</code> ユーザーを次のように考慮します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">CREATE TRIGGER</code> の時点で、このステートメントを発行するユーザーには <code class="literal">TRIGGER</code> 権限が必要です。
        </p></li><li class="listitem"><p>
          トリガーのアクティブ化時、権限は <code class="literal">DEFINER</code> ユーザーに対して確認されます。 このユーザーには、次の権限が必要です。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              対象テーブルに対する <code class="literal">TRIGGER</code> 権限。
            </p></li><li class="listitem"><p>
              テーブルカラムへの参照がトリガー本体内の <code class="literal">OLD.<em class="replaceable"><code>col_name</code></em></code> または <code class="literal">NEW.<em class="replaceable"><code>col_name</code></em></code> を使用して発生した場合は、対象テーブルに対する <code class="literal">SELECT</code> 権限。
            </p></li><li class="listitem"><p>
              テーブルカラムがトリガー本体内の <code class="literal">SET NEW.<em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>value</code></em></code> 割り当てのターゲットである場合は、対象テーブルに対する <code class="literal">UPDATE</code> 権限。
            </p></li><li class="listitem"><p>
              その他のどのような権限も、通常、そのトリガーによって実行されるステートメントに必要です。
            </p></li></ul></div></li></ul></div><p>
      トリガー本体内で、<code class="literal">CURRENT_USER</code> 関数は、トリガーのアクティブ化時に権限を確認するために使用されるアカウントを返します。 これは、そのトリガーがアクティブ化される原因となるアクションを実行したユーザーではなく、<code class="literal">DEFINER</code> ユーザーです。 トリガー内のユーザー監査については、<a class="xref" href="security.html#account-activity-auditing" title="6.2.22 SQL ベースのアカウントアクティビティ監査">セクション6.2.22「SQL ベースのアカウントアクティビティ監査」</a>を参照してください。 
    </p><p>
      <code class="literal">LOCK TABLES</code> を使用してトリガーを含むテーブルをロックした場合は、<a class="xref" href="sql-statements.html#lock-tables-and-triggers" title="LOCK TABLES とトリガー">LOCK TABLES とトリガー</a>で説明されているように、そのトリガー内で使用されているテーブルもロックされます。
    </p><p>
      トリガーの使用の詳細は、<a class="xref" href="stored-objects.html#trigger-syntax" title="25.3.1 トリガーの構文と例">セクション25.3.1「トリガーの構文と例」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-view"></a>13.1.23 CREATE VIEW ステートメント</h3></div></div></div><a class="indexterm" name="idm45827001626896"></a><a class="indexterm" name="idm45827001625472"></a><a class="indexterm" name="idm45827001623440"></a><pre class="programlisting">CREATE
    [OR REPLACE]
    [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
    [DEFINER = <em class="replaceable"><code>user</code></em>]
    [SQL SECURITY { DEFINER | INVOKER }]
    VIEW <em class="replaceable"><code>view_name</code></em> [(<em class="replaceable"><code>column_list</code></em>)]
    AS <em class="replaceable"><code>select_statement</code></em>
    [WITH [CASCADED | LOCAL] CHECK OPTION]
</pre><p>
      <code class="literal">CREATE VIEW</code> ステートメントは、新しいビューを作成するか、<code class="literal">OR REPLACE</code> 句が指定されている場合は既存のビューを置き換えます。 そのビューが存在しない場合、<code class="literal">CREATE OR REPLACE VIEW</code> は <code class="literal">CREATE VIEW</code> と同じです。 ビューが存在する場合は、<code class="literal">CREATE OR REPLACE VIEW</code> によって置換されます。 
    </p><p>
      ビューの使用に関する制限の詳細は、<a class="xref" href="stored-objects.html#view-restrictions" title="25.9 ビューの制約">セクション25.9「ビューの制約」</a> を参照してください。
    </p><p>
      <em class="replaceable"><code>select_statement</code></em> は、そのビューの定義を提供する <code class="literal">SELECT</code> ステートメントです。 (ビューから選択すると、実質的には <code class="literal">SELECT</code> ステートメントを使用して選択されます。) <em class="replaceable"><code>select_statement</code></em> では、実テーブルや他のビューから選択できます。 MySQL 8.0.19 以降、<code class="literal">SELECT</code> ステートメントは <code class="literal">VALUES</code> ステートメントをソースとして使用することも、<code class="literal">CREATE TABLE ... SELECT</code> と同様に <code class="literal">TABLE</code> ステートメントに置き換えることもできます。 
    </p><p>
      ビュー定義は作成時の<span class="quote">「<span class="quote">「冷凍」</span>」</span>であり、基礎となるテーブルの定義に対する後続の変更の影響を受けません。 たとえば、ビューがテーブルで <code class="literal">SELECT *</code> として定義されている場合、後でテーブルに追加された新しいカラムはビューの一部にならず、テーブルから削除されたカラムはビューからの選択時にエラーになります。 
    </p><p>
      <code class="literal">ALGORITHM</code> 句は、MySQL によるビューの処理方法に影響を与えます。 <code class="literal">DEFINER</code> および <code class="literal">SQL SECURITY</code> 句は、ビューの呼び出し時にアクセス権限を確認するときに使用されるセキュリティーコンテキストを指定します。 <code class="literal">WITH CHECK OPTION</code> 句を指定すると、ビューによって参照されているテーブル内の行への挿入または更新を制約できます。 これらの句については、このセクションのあとの方で説明されています。 
    </p><p>
      <code class="literal">CREATE VIEW</code> ステートメントには、このビューに対する <code class="literal">CREATE VIEW</code> 権限と、<code class="literal">SELECT</code> ステートメントによって選択される各カラムに対する何らかの権限が必要です。 <code class="literal">SELECT</code> ステートメントの他の場所で使用されるカラムの場合は、<code class="literal">SELECT</code> 権限が必要です。 <code class="literal">OR REPLACE</code> 句が存在する場合は、このビューに対する <code class="literal">DROP</code> 権限も必要です。 <code class="literal">DEFINER</code> 句が存在する場合、<a class="xref" href="stored-objects.html#stored-objects-security" title="25.6 ストアドオブジェクトのアクセス制御">セクション25.6「ストアドオブジェクトのアクセス制御」</a> で説明されているように、必要な権限は <em class="replaceable"><code>user</code></em> の値によって異なります。 
    </p><p>
      ビューが参照されると、このセクションのあとの方で説明されている権限確認が発生します。
    </p><p>
      ビューはデータベースに属します。 デフォルトでは、新しいビューはデフォルトデータベース内に作成されます。 特定のデータベースでビューを明示的に作成するには、<em class="replaceable"><code>db_name.view_name</code></em> 構文を使用して、ビュー名をデータベース名で修飾します: 
    </p><pre class="programlisting">CREATE VIEW test.v AS SELECT * FROM t;
</pre><p>
      <code class="literal">SELECT</code> ステートメントの修飾されていないテーブルまたはビューの名前も、デフォルトのデータベースに関して解釈されます。 ビューは、テーブル名またはビュー名を適切なデータベース名で修飾することで、他のデータベース内のテーブルまたはビューを参照できます。 
    </p><p>
      データベース内で、ベーステーブルとビューは同じ名前空間を共有するため、ベーステーブルとビューが同じ名前を持つことはできません。
    </p><p>
      <code class="literal">SELECT</code> ステートメントによって取得されるカラムは、テーブルのカラムへの単純な参照、または関数、定数値、演算子などを使用する式です。
    </p><p>
      ビューには、実テーブルと同様に、重複のない一意のカラム名が必要です。 デフォルトでは、<code class="literal">SELECT</code> ステートメントによって取得されるカラムの名前はビューカラム名に使用されます。 ビューカラムの明示的な名前を定義するには、カンマ区切りの識別子のリストとしてオプションの <em class="replaceable"><code>column_list</code></em> 句を指定します。 <em class="replaceable"><code>column_list</code></em> 内の名前の数は、<code class="literal">SELECT</code> ステートメントによって取得されるカラムの数と同じである必要があります。 
    </p><p>
      ビューは、多くの種類の <code class="literal">SELECT</code> ステートメントから作成できできます。 ベーステーブルまたはほかのビューを参照できます。 結合、<code class="literal">UNION</code>、およびサブクエリーを使用できます。 <code class="literal">SELECT</code> では、テーブルを参照する必要もありません: 
    </p><pre class="programlisting">CREATE VIEW v_today (today) AS SELECT CURRENT_DATE;
</pre><p>
      次の例では、別のテーブルから 2 つのカラムを選択するビューと、それらのカラムから計算された式を定義します:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t (qty INT, price INT);</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t VALUES(3, 50);</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE VIEW v AS SELECT qty, price, qty*price AS value FROM t;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM v;</code></strong>
+------+-------+-------+
| qty  | price | value |
+------+-------+-------+
|    3 |    50 |   150 |
+------+-------+-------+
</pre><p>
      ビュー定義は、次の制限に従います。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SELECT</code> ステートメントは、システム変数またはユーザー定義変数を参照できません。
        </p></li><li class="listitem"><p>
          ストアドプログラム内では、<code class="literal">SELECT</code> ステートメントはプログラムパラメータまたはローカル変数を参照できません。
        </p></li><li class="listitem"><p>
          <code class="literal">SELECT</code> ステートメントは、準備済みステートメントのパラメータを参照できません。
        </p></li><li class="listitem"><p>
          この定義で参照されているテーブルまたはビューは、すべて存在する必要があります。 ビューの作成後に、定義が参照するテーブルまたはビューを削除すると、ビューを使用するとエラーになります。 この種類の問題に関してビュー定義を確認するには、<code class="literal">CHECK TABLE</code> ステートメントを使用します。 
        </p></li><li class="listitem"><p>
          この定義は <code class="literal">TEMPORARY</code> テーブルを参照できないため、<code class="literal">TEMPORARY</code> ビューは作成できません。
        </p></li><li class="listitem"><p>
          トリガーをビューに関連付けることはできません。
        </p></li><li class="listitem"><p>
          <code class="literal">SELECT</code> ステートメント内のカラム名のエイリアスは (256 文字の別名の最大の長さではなく) 64 文字のカラムの最大の長さに対してチェックされます。
        </p></li></ul></div><p>
      <code class="literal">ORDER BY</code> はビュー定義内で許可されていますが、独自の <code class="literal">ORDER BY</code> を含むステートメントを使用しているビューから選択した場合は無視されます。
    </p><p>
      この定義内のその他のオプションまたは句の場合は、そのビューを参照しているステートメントのオプションまたは句に追加されますが、その効果は定義されていません。 たとえば、ビュー定義に <code class="literal">LIMIT</code> 句が含まれているときに、独自の <code class="literal">LIMIT</code> 句を含むステートメントを使用しているビューから選択した場合、どの制限が適用されるかは未定義です。 これと同じ原則が、<code class="literal">SELECT</code> キーワードの後に続くオプション (<code class="literal">ALL</code>、<code class="literal">DISTINCT</code>、<code class="literal">SQL_SMALL_RESULT</code> など)、および <code class="literal">INTO</code>, <code class="literal">FOR UPDATE</code>, <code class="literal">FOR SHARE</code>, <code class="literal">LOCK IN SHARE MODE</code>、<code class="literal">PROCEDURE</code> などの句にも適用されます。 
    </p><p>
      システム変数を変更してクエリー処理環境を変更すると、ビューから取得した結果が影響を受ける可能性があります:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE VIEW v (mycol) AS SELECT 'abc';</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>SET sql_mode = '';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT "mycol" FROM v;</code></strong>
+-------+
| mycol |
+-------+
| mycol |
+-------+
1 row in set (0.01 sec)

mysql&gt; <strong class="userinput"><code>SET sql_mode = 'ANSI_QUOTES';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT "mycol" FROM v;</code></strong>
+-------+
| mycol |
+-------+
| abc   |
+-------+
1 row in set (0.00 sec)
</pre><p>
      <code class="literal">DEFINER</code> および <code class="literal">SQL SECURITY</code> 句は、そのビューを参照しているステートメントの実行時に、そのビューに対するアクセス権限を確認するときにどの MySQL アカウントを使用するかを決定します。 有効な <code class="literal">SQL SECURITY</code> 特性値は、<code class="literal">DEFINER</code> (デフォルト) および <code class="literal">INVOKER</code> です。 これらは、それぞれ、そのビューを定義したユーザーまたは呼び出したユーザーが必要な権限を持っている必要があることを示します。 
    </p><p>
      <code class="literal">DEFINER</code> 句が存在する場合、<em class="replaceable"><code>user</code></em> 値は<code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'<em class="replaceable"><code>host_name</code></em>'</code>、<code class="literal">CURRENT_USER</code> または <code class="literal">CURRENT_USER()</code> として指定された MySQL アカウントである必要があります。 許可される <em class="replaceable"><code>user</code></em> 値は、<a class="xref" href="stored-objects.html#stored-objects-security" title="25.6 ストアドオブジェクトのアクセス制御">セクション25.6「ストアドオブジェクトのアクセス制御」</a> で説明されているように、保持する権限によって異なります。 表示セキュリティの詳細は、そのセクションも参照してください。 
    </p><p>
      <code class="literal">DEFINER</code> 句を省略すると、デフォルトの定義者は <code class="literal">CREATE VIEW</code> ステートメントを実行するユーザーになります。 これは、明示的に <code class="literal">DEFINER = CURRENT_USER</code> を指定するのと同じです。 
    </p><p>
      ビュー定義内では、<code class="literal">CURRENT_USER</code> 関数はデフォルトでビューの <code class="literal">DEFINER</code> 値を返します。 <code class="literal">SQL SECURITY INVOKER</code> 特性を使用して定義されたビューの場合、<code class="literal">CURRENT_USER</code> は、そのビューの呼び出し元のアカウントを返します。 ビュー内のユーザー監査については、<a class="xref" href="security.html#account-activity-auditing" title="6.2.22 SQL ベースのアカウントアクティビティ監査">セクション6.2.22「SQL ベースのアカウントアクティビティ監査」</a>を参照してください。 
    </p><p>
      <code class="literal">SQL SECURITY DEFINER</code> 特性を使用して定義されたストアドルーチン内で、<code class="literal">CURRENT_USER</code> は、そのルーチンの <code class="literal">DEFINER</code> 値を返します。 ビュー定義に <code class="literal">CURRENT_USER</code> の <code class="literal">DEFINER</code> 値が含まれている場合は、これにより、このようなルーチン内で定義されたビューも影響を受けます。 
    </p><p>
      MySQL では、次のような表示権限がチェックされます:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ビューの定義時に、ビュー作成者は、そのビューによってアクセスされるトップレベルのオブジェクトを使用するために必要な権限を持っている必要があります。 たとえば、ビュー定義がテーブルカラムを参照している場合、作成者は、その定義の選択リスト内の各カラムに対する何らかの権限と、その定義内の別の場所で使用されている各カラムに対する <code class="literal">SELECT</code> 権限を持っている必要があります。 この定義がストアドファンクションを参照している場合は、その関数を呼び出すために必要な権限のみを確認できます。 関数呼び出し時に必要な権限は、その関数が実行されるときにしか確認できません。別の呼び出しでは、その関数内の別の実行パスが選択される可能性があります。 
        </p></li><li class="listitem"><p>
          ビューを参照するユーザーは、そのビューにアクセスするための適切な権限 (そのビューから選択するための <code class="literal">SELECT</code> や、そのビューに挿入するための <code class="literal">INSERT</code> など) を持っている必要があります。
        </p></li><li class="listitem"><p>
          ビューが参照されると、そのビューによってアクセスされるオブジェクトに対する権限が、<code class="literal">SQL SECURITY</code> 特性が <code class="literal">DEFINER</code> または <code class="literal">INVOKER</code> のどちらであるかに応じて、それぞれ、そのビューの <code class="literal">DEFINER</code> アカウントによって保持されている権限または呼び出し元に対して確認されます。
        </p></li><li class="listitem"><p>
          ビューへの参照によってストアドファンクションが実行される場合、その関数内で実行されるステートメントの権限確認は、その関数の <code class="literal">SQL SECURITY</code> 特性が <code class="literal">DEFINER</code> または <code class="literal">INVOKER</code> のどちらであるかによって異なります。 セキュリティー特性が <code class="literal">DEFINER</code> である場合、その関数は <code class="literal">DEFINER</code> アカウントの権限で実行されます。 この特性が <code class="literal">INVOKER</code> である場合、その関数は、そのビューの <code class="literal">SQL SECURITY</code> 特性によって決定される権限で実行されます。 
        </p></li></ul></div><p>
      例: あるビューがストアドファンクションに依存する可能性があり、さらにその関数がほかのストアドルーチンを呼び出す可能性があります。 たとえば、次のビューはストアドファンクション <code class="literal">f()</code> を呼び出します。 
    </p><pre class="programlisting">CREATE VIEW v AS SELECT * FROM t WHERE t.id = f(t.name);
</pre><p>
      <code class="literal">f()</code> に次のようなステートメントが含まれているとします。
    </p><pre class="programlisting">IF name IS NULL then
  CALL p1();
ELSE
  CALL p2();
END IF;
</pre><p>
      <code class="literal">f()</code> が実行されるとき、<code class="literal">f()</code> 内のステートメントを実行するために必要な権限を確認する必要があります。 これは、<code class="literal">f()</code> 内の実行パスに応じて、<code class="literal">p1()</code> または <code class="literal">p2()</code> に対する権限が必要であることを示します。 これらの権限は実行時に確認する必要があり、それらの権限を持っている必要のあるユーザーは、ビュー <code class="literal">v</code> と関数 <code class="literal">f()</code> の <code class="literal">SQL SECURITY</code> 値によって決定されます。 
    </p><p>
      ビューの <code class="literal">DEFINER</code> および <code class="literal">SQL SECURITY</code> 句は、標準 SQL への拡張です。 標準 SQL では、ビューは <code class="literal">SQL SECURITY DEFINER</code> のルールを使用して処理されます。 標準には、ビューの定義者 (これは、ビューのスキーマの所有者と同じです) はそのビューに対する該当する権限 (<code class="literal">SELECT</code> など) を取得し、またそれらを付与することができると記載されています。 MySQL にはスキーマの<span class="quote">「<span class="quote">所有者</span>」</span>という概念がないため、MySQL では定義者を識別するための句が追加されています。 <code class="literal">DEFINER</code> 句は、標準が備えている機能、つまり、だれがそのビューを定義したかについての永続的なレコードを備えることを目的とした拡張です。 <code class="literal">DEFINER</code> のデフォルト値がビュー作成者のアカウントになっているのはそのためです。 
    </p><p>
      オプションの <code class="literal">ALGORITHM</code> 句は、標準 SQL への MySQL 拡張です。 これは、MySQL によるビューの処理方法に影響を与えます。 <code class="literal">ALGORITHM</code> は、<code class="literal">MERGE</code>、<code class="literal">TEMPTABLE</code>、または <code class="literal">UNDEFINED</code> の 3 つの値を受け取ります。 詳細は、<a class="xref" href="stored-objects.html#view-algorithms" title="25.5.2 ビュー処理アルゴリズム">セクション25.5.2「ビュー処理アルゴリズム」</a> および <a class="xref" href="optimization.html#derived-table-optimization" title="8.2.2.4 マージまたは実体化を使用した導出テーブル、ビュー参照および共通テーブル式の最適化">セクション8.2.2.4「マージまたは実体化を使用した導出テーブル、ビュー参照および共通テーブル式の最適化」</a> を参照してください。 
    </p><p>
      いくつかのビューは更新可能です。 つまり、これらのビューを <code class="literal">UPDATE</code>、<code class="literal">DELETE</code>、<code class="literal">INSERT</code> などのステートメントで使用して、ベースとなるテーブルの内容を更新できます。 ビューが更新可能であるためには、そのビュー内の行とベースとなるテーブル内の行の間に 1 対 1 の関係が存在する必要があります。 また、ビューを更新不可能にするその他の特定の構造構文も存在します。 
    </p><a class="indexterm" name="idm45827001459152"></a><p>
      ビュー内の生成されたカラムは、割り当て可能であるため、更新可能とみなされます。 ただし、このようなカラムが明示的に更新される場合、許可される値は <code class="literal">DEFAULT</code> のみです。 生成されるカラムの詳細は、<a class="xref" href="sql-statements.html#create-table-generated-columns" title="13.1.20.8 CREATE TABLE および生成されるカラム">セクション13.1.20.8「CREATE TABLE および生成されるカラム」</a> を参照してください。 
    </p><p>
      更新可能なビューに対して <code class="literal">WITH CHECK OPTION</code> 句を指定すると、<em class="replaceable"><code>select_statement</code></em> 内の <code class="literal">WHERE</code> 句が true である行を除く行への挿入または更新を回避できます。
    </p><p>
      更新可能なビューに対する <code class="literal">WITH CHECK OPTION</code> 句では、そのビューが別のビューとの関連で定義されている場合、<code class="literal">LOCAL</code> および <code class="literal">CASCADED</code> キーワードによってチェックテストのスコープが決定されます。 <code class="literal">LOCAL</code> キーワードは、<code class="literal">CHECK OPTION</code> を、定義されているビューのみに制限します。 <code class="literal">CASCADED</code> を指定すると、ベースとなるビューに対するチェックも評価されます。 どちらのキーワードも指定されていない場合、デフォルトは <code class="literal">CASCADED</code> になります。 
    </p><p>
      更新可能なビューおよび <code class="literal">WITH CHECK OPTION</code> 句の詳細は、<a class="xref" href="stored-objects.html#view-updatability" title="25.5.3 更新可能および挿入可能なビュー">セクション25.5.3「更新可能および挿入可能なビュー」</a>, and <a class="xref" href="stored-objects.html#view-check-option" title="25.5.4 WITH CHECK OPTION 句の表示">セクション25.5.4「WITH CHECK OPTION 句の表示」</a> を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-database"></a>13.1.24 DROP DATABASE ステートメント</h3></div></div></div><a class="indexterm" name="idm45827001441168"></a><a class="indexterm" name="idm45827001439856"></a><a class="indexterm" name="idm45827001438512"></a><a class="indexterm" name="idm45827001436368"></a><a class="indexterm" name="idm45827001434336"></a><a class="indexterm" name="idm45827001432304"></a><pre class="programlisting">DROP {DATABASE | SCHEMA} [IF EXISTS] <em class="replaceable"><code>db_name</code></em>
</pre><p>
      <code class="literal">DROP DATABASE</code> は、データベース内のすべてのテーブルを削除したあと、そのデータベースを削除します。 このステートメントには<span class="emphasis"><em>十分に</em></span>注意してください。 <code class="literal">DROP DATABASE</code> を使用するには、そのデータベースに対する <code class="literal">DROP</code> 権限が必要です。 <code class="literal">DROP SCHEMA</code> は <code class="literal">DROP DATABASE</code> のシノニムです。 
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        データベースを削除しても、データベース専用に付与された権限は自動的に削除されません。 手動で削除する必要があります。 <a class="xref" href="sql-statements.html#grant" title="13.7.1.6 GRANT ステートメント">セクション13.7.1.6「GRANT ステートメント」</a>を参照してください。 
      </p></div><p>
      <code class="literal">IF EXISTS</code> は、データベースが存在しない場合にエラーが発生しないようにするために使用されます。
    </p><p>
      デフォルトデータベースが削除されると、そのデフォルトデータベースは設定解除されます (<code class="literal">DATABASE()</code> 関数が <code class="literal">NULL</code> を返します)。
    </p><p>
      シンボリックリンクされたデータベースに対して <code class="literal">DROP DATABASE</code> を使用した場合は、そのリンクと元のデータベースの両方が削除されます。
    </p><p>
      <code class="literal">DROP DATABASE</code> は、削除されたテーブルの数を返します。
    </p><p>
      <code class="literal">DROP DATABASE</code> ステートメントは、通常の操作中に MySQL 自体が作成する可能性のあるファイルおよびディレクトリを、指定されたデータベースディレクトリから削除します。 これには、次のリストに示す拡張子を持つすべてのファイルが含まれます: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="filename">.BAK</code>
        </p></li><li class="listitem"><p>
          <code class="filename">.DAT</code>
        </p></li><li class="listitem"><p>
          <code class="filename">.HSH</code>
        </p></li><li class="listitem"><p>
          <code class="filename">.MRG</code>
        </p></li><li class="listitem"><p>
          <code class="filename">.MYD</code>
        </p></li><li class="listitem"><p>
          <code class="filename">.MYI</code>
        </p></li><li class="listitem"><p>
          <code class="filename">.cfg</code>
        </p></li><li class="listitem"><p>
          <code class="filename">.db</code>
        </p></li><li class="listitem"><p>
          <code class="filename">.ibd</code>
        </p></li><li class="listitem"><p>
          <code class="filename">.ndb</code>
        </p></li></ul></div><p>
      今一覧表示されたファイルを MySQL が削除したあとに、このデータベースディレクトリ内にほかのファイルやディレクトリが残っている場合は、そのデータベースディレクトリを削除できません。 この場合は、残っているすべてのファイルまたはディレクトリを手動で削除してから、再度 <code class="literal">DROP DATABASE</code> ステートメントを発行する必要があります。 
    </p><p>
      データベースを削除しても、そのデータベース内に作成されたどの <code class="literal">TEMPORARY</code> テーブルも削除されません。 <code class="literal">TEMPORARY</code> テーブルは、それらを作成したセッションが終了すると自動的に削除されます。 <a class="xref" href="sql-statements.html#create-temporary-table" title="13.1.20.2 CREATE TEMPORARY TABLE ステートメント">セクション13.1.20.2「CREATE TEMPORARY TABLE ステートメント」</a>を参照してください。 
    </p><a class="indexterm" name="idm45827001387648"></a><p>
      データベースは <span class="command"><strong>mysqladmin</strong></span> でも削除できます。 <a class="xref" href="programs.html#mysqladmin" title="4.5.2 mysqladmin — A MySQL Server 管理プログラム">セクション4.5.2「mysqladmin — A MySQL Server 管理プログラム」</a>を参照してください。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-event"></a>13.1.25 DROP EVENT ステートメント</h3></div></div></div><a class="indexterm" name="idm45827001383056"></a><a class="indexterm" name="idm45827001381744"></a><a class="indexterm" name="idm45827001379552"></a><pre class="programlisting">DROP EVENT [IF EXISTS] <em class="replaceable"><code>event_name</code></em>
</pre><p>
      このステートメントは、<em class="replaceable"><code>event_name</code></em> という名前のイベントを削除します。 このイベントはただちにアクティブな状態を停止し、サーバーから完全に削除されます。 
    </p><p>
      このイベントが存在しない場合は、エラー <span class="errortext">ERROR 1517 (HY000): Unknown event '<em class="replaceable"><code>event_name</code></em>'</span> が発生します。 これをオーバーライドし、代わりに <code class="literal">IF EXISTS</code> を使用して、このステートメントで存在しないイベントに対する警告が生成されるようにできます。 
    </p><p>
      このステートメントには、削除されるイベントが属するスキーマに対する <code class="literal">EVENT</code> 権限が必要です。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-function"></a>13.1.26 DROP FUNCTION ステートメント</h3></div></div></div><p>
      <code class="literal">DROP FUNCTION</code> ステートメントは、ストアドファンクションやユーザー定義関数 (UDF) を削除するために使用されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ストアドファンクションの削除については、<a class="xref" href="sql-statements.html#drop-procedure" title="13.1.29 DROP PROCEDURE および DROP FUNCTION ステートメント">セクション13.1.29「DROP PROCEDURE および DROP FUNCTION ステートメント」</a>を参照してください。
        </p></li><li class="listitem"><p>
          ユーザー定義関数の削除については、<a class="xref" href="sql-statements.html#drop-function-loadable" title="13.7.4.2 ユーザー定義関数に対する DROP FUNCTION ステートメント">セクション13.7.4.2「ユーザー定義関数に対する DROP FUNCTION ステートメント」</a>を参照してください。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-index"></a>13.1.27 DROP INDEX ステートメント</h3></div></div></div><a class="indexterm" name="idm45827001358816"></a><a class="indexterm" name="idm45827001357504"></a><a class="indexterm" name="idm45827001355360"></a><pre class="programlisting">DROP INDEX <em class="replaceable"><code>index_name</code></em> ON <em class="replaceable"><code>tbl_name</code></em>
    [<em class="replaceable"><code>algorithm_option</code></em> | <em class="replaceable"><code>lock_option</code></em>] ...

<em class="replaceable"><code>algorithm_option</code></em>:
    ALGORITHM [=] {DEFAULT | INPLACE | COPY}

<em class="replaceable"><code>lock_option</code></em>:
    LOCK [=] {DEFAULT | NONE | SHARED | EXCLUSIVE}
</pre><p>
      <code class="literal">DROP INDEX</code> は、テーブル <em class="replaceable"><code>tbl_name</code></em> から <em class="replaceable"><code>index_name</code></em> という名前のインデックスを削除します。 このステートメントは、このインデックスを削除するために <code class="literal">ALTER TABLE</code> ステートメントにマップされます。 <a class="xref" href="sql-statements.html#alter-table" title="13.1.9 ALTER TABLE ステートメント">セクション13.1.9「ALTER TABLE ステートメント」</a>を参照してください。 
    </p><p>
      主キーを削除するには、インデックス名は常に <code class="literal">PRIMARY</code> です。これは、<code class="literal">PRIMARY</code> が予約語であるため、引用符で囲まれた識別子として指定する必要があります。
    </p><pre class="programlisting">DROP INDEX `PRIMARY` ON t;
</pre><p>
      <code class="literal">NDB</code> テーブルの可変幅カラム上のインデックスはオンラインで、つまり、テーブルコピーを行うことなく削除されます。 テーブルは、ほかの NDB Cluster API ノードからのアクセスに対してロックされませんが、操作中は <span class="emphasis"><em>same</em></span> API ノード上のほかの操作に対してロックされます。 これは、サーバーが実行できると判断した場合は常に、そのサーバーによって自動的に実行されます。これを実行するために、特殊な SQL 構文やサーバーオプションを使用する必要はありません。 
    </p><p>
      <code class="literal">ALGORITHM</code> 句および <code class="literal">LOCK</code> 句を指定して、インデックスの変更中にテーブルの読取りおよび書込みを行うためのテーブルのコピー方法および同時実行性のレベルに影響を与えることができます。 これらには、<code class="literal">ALTER TABLE</code> ステートメントの場合と同じ意味があります。 詳細は、<a class="xref" href="sql-statements.html#alter-table" title="13.1.9 ALTER TABLE ステートメント">セクション13.1.9「ALTER TABLE ステートメント」</a>を参照してください。 
    </p><p>
      MySQL NDB Cluster は、標準 MySQL Server でサポートされているものと同じ <code class="literal">ALGORITHM=INPLACE</code> 構文を使用したオンライン操作をサポートします。 詳しくは<a class="xref" href="mysql-cluster.html#mysql-cluster-online-operations" title="23.5.11 NDB Cluster での ALTER TABLE を使用したオンライン操作">セクション23.5.11「NDB Cluster での ALTER TABLE を使用したオンライン操作」</a>,をご覧ください。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-logfile-group"></a>13.1.28 DROP LOGFILE GROUP ステートメント</h3></div></div></div><a class="indexterm" name="idm45827001328576"></a><pre class="programlisting">DROP LOGFILE GROUP <em class="replaceable"><code>logfile_group</code></em>
    ENGINE [=] <em class="replaceable"><code>engine_name</code></em>
</pre><p>
      このステートメントは、<em class="replaceable"><code>logfile_group</code></em> という名前のログファイルグループを削除します。 このログファイルグループがすでに存在する必要があります。そうしないと、エラー結果が発生します。 (ログファイルグループの作成については、<a class="xref" href="sql-statements.html#create-logfile-group" title="13.1.16 CREATE LOGFILE GROUP ステートメント">セクション13.1.16「CREATE LOGFILE GROUP ステートメント」</a>を参照してください。) 
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        ログファイルグループを削除する前に、そのログファイルグループを <code class="literal">UNDO</code> ロギングのために使用しているすべてのテーブルスペースを削除する必要があります。
      </p></div><p>
      必須の <code class="literal">ENGINE</code> 句は、削除されるログファイルグループによって使用されるストレージエンジンの名前を指定します。 現在、<em class="replaceable"><code>engine_name</code></em> に許可される値は <code class="literal">NDB</code> と <code class="literal">NDBCLUSTER</code> だけです。 
    </p><p>
      <code class="literal">DROP LOGFILE GROUP</code> は NDB Cluster のディスクデータストレージでのみ役立ちます。 <a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data" title="23.5.10 NDB Cluster ディスクデータテーブル">セクション23.5.10「NDB Cluster ディスクデータテーブル」</a>を参照してください。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-procedure"></a>13.1.29 DROP PROCEDURE および DROP FUNCTION ステートメント</h3></div></div></div><a class="indexterm" name="idm45827001313728"></a><a class="indexterm" name="idm45827001312416"></a><pre class="programlisting">DROP {PROCEDURE | FUNCTION} [IF EXISTS] <em class="replaceable"><code>sp_name</code></em>
</pre><p>
      これらのステートメントは、ストアドルーチン (ストアドプロシージャーまたはストアドファンクション) を削除するために使用されます。 つまり、指定されたルーチンがサーバーから削除されます。 (<code class="literal">DROP FUNCTION</code> は、ユーザー定義関数の削除にも使用されます。<a class="xref" href="sql-statements.html#drop-function-loadable" title="13.7.4.2 ユーザー定義関数に対する DROP FUNCTION ステートメント">セクション13.7.4.2「ユーザー定義関数に対する DROP FUNCTION ステートメント」</a> を参照してください。) 
    </p><p>
      ストアドルーチンを削除するには、そのストアドルーチンに対する <code class="literal">ALTER ROUTINE</code> 権限が必要です。 (<code class="literal">automatic_sp_privileges</code> システム変数が有効になっている場合は、その権限と <code class="literal">EXECUTE</code> が自動的に、そのルーチンが作成されるときはルーチン作成者に付与され、そのルーチンが削除されるときは作成者から削除されます。 <a class="xref" href="stored-objects.html#stored-routines-privileges" title="25.2.2 ストアドルーチンと MySQL 権限">セクション25.2.2「ストアドルーチンと MySQL 権限」</a>を参照してください。) 
    </p><p>
      <code class="literal">IF EXISTS</code> 句は MySQL 拡張です。 これは、プロシージャーまたは関数が存在しない場合にエラーが発生しないようにします。 <code class="literal">SHOW WARNINGS</code> で表示できる警告が生成されます。 
    </p><p>
      <code class="literal">DROP FUNCTION</code> はまた、ユーザー定義関数を削除するためにも使用されます (<a class="xref" href="sql-statements.html#drop-function-loadable" title="13.7.4.2 ユーザー定義関数に対する DROP FUNCTION ステートメント">セクション13.7.4.2「ユーザー定義関数に対する DROP FUNCTION ステートメント」</a>を参照してください)。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-server"></a>13.1.30 DROP SERVER ステートメント</h3></div></div></div><a class="indexterm" name="idm45827001292688"></a><pre class="programlisting">DROP SERVER [ IF EXISTS ] <em class="replaceable"><code>server_name</code></em>
</pre><p>
      <code class="literal"><em class="replaceable"><code>server_name</code></em></code> という名前のサーバーのサーバー定義を削除します。 <code class="literal">mysql.servers</code> テーブル内の対応する行が削除されます。 このステートメントには、<code class="literal">SUPER</code> 権限が必要です。 
    </p><p>
      テーブルのサーバーを削除しても、作成されるときにこの接続情報を使用したどの <code class="literal">FEDERATED</code> テーブルにも影響を与えません。 <a class="xref" href="sql-statements.html#create-server" title="13.1.18 CREATE SERVER ステートメント">セクション13.1.18「CREATE SERVER ステートメント」</a>を参照してください。 
    </p><p>
      <code class="literal">DROP SERVER</code> によって暗黙的なコミットが発生します。 <a class="xref" href="sql-statements.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。 
    </p><p>
      使用されているロギング形式に関係なく、<code class="literal">DROP SERVER</code> はバイナリログに書き込まれません。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-spatial-reference-system"></a>13.1.31 DROP SPATIAL REFERENCE SYSTEM ステートメント</h3></div></div></div><a class="indexterm" name="idm45827001276016"></a><pre class="programlisting">DROP SPATIAL REFERENCE SYSTEM
    [IF EXISTS]
    <em class="replaceable"><code>srid</code></em>

<em class="replaceable"><code>srid</code></em>: <em class="replaceable"><code>32-bit unsigned integer</code></em>
</pre><p>
      このステートメントは、データディクショナリから <a class="link" href="data-types.html#spatial-reference-systems" title="11.4.5 空間参照システムのサポート">spatial reference system</a> (SRS) 定義を削除します。 <code class="literal">SUPER</code> 権限が必要です。 
    </p><p>
      例:
    </p><pre class="programlisting">DROP SPATIAL REFERENCE SYSTEM 4120;
</pre><p>
      SRID 値を持つ SRS 定義が存在しない場合は、<code class="literal">IF EXISTS</code> が指定されていないかぎりエラーが発生します。 その場合、エラーではなく警告が発生します。 
    </p><p>
      SRID 値が既存のテーブルのカラムで使用されている場合は、エラーが発生します。 例: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>DROP SPATIAL REFERENCE SYSTEM 4326;</code></strong>
ERROR 3716 (SR005): Can't modify SRID 4326. There is at
least one column depending on it.
</pre><p>
      SRID を使用するカラムを識別するには、次のクエリーを使用します:
    </p><pre class="programlisting">SELECT * FROM INFORMATION_SCHEMA.ST_GEOMETRY_COLUMNS WHERE SRS_ID=4326;
</pre><p>
      SRID 値は 32 ビットの符号なし整数の範囲内である必要がありますが、次の制限があります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          SRID 0 は有効な SRID ですが、<code class="literal">DROP SPATIAL REFERENCE SYSTEM</code> では使用できません。
        </p></li><li class="listitem"><p>
          値が予約された SRID 範囲内にある場合は、警告が発生します。 予約済の範囲は、[0, 32767] (EPSG で予約済)、[60,000,000、69,999,999] (EPSG で予約済) および[2,000,000,000、2,147,483,647] (MySQL で予約済) です。 EPSG は<a class="ulink" href="http://epsg.org" target="_top">「欧州石油調査グループ」</a>を表します。 
        </p></li><li class="listitem"><p>
          ユーザーは、予約された範囲内の SRID を持つ SRS を削除しないでください。 システムにインストールされた SRS が削除された場合、SRS 定義を MySQL のアップグレード用に再作成できます。 
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-table"></a>13.1.32 DROP TABLE ステートメント</h3></div></div></div><a class="indexterm" name="idm45827001251408"></a><a class="indexterm" name="idm45827001250096"></a><a class="indexterm" name="idm45827001247952"></a><pre class="programlisting">DROP [TEMPORARY] TABLE [IF EXISTS]
    <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ...
    [RESTRICT | CASCADE]
</pre><p>
      <code class="literal">DROP TABLE</code> は、1 つ以上のテーブルを削除します。 各テーブルに対する <code class="literal">DROP</code> 権限が必要です。 
    </p><p>
      このステートメントを使用した<span class="emphasis"><em>注意してください</em></span>。 テーブルごとに、テーブル定義およびすべてのテーブルデータが削除されます。 テーブルがパーティション化されている場合、ステートメントはテーブル定義、そのすべてのパーティション、それらのパーティションに格納されているすべてのデータ、および削除されたテーブルに関連付けられているすべてのパーティション定義を削除します。 
    </p><p>
      テーブルを削除すると、そのテーブルのトリガーも削除されます。
    </p><p>
      <code class="literal">DROP TABLE</code> では、<code class="literal">TEMPORARY</code> キーワードとともに使用する場合を除き、暗黙的なコミットが発生します。 <a class="xref" href="sql-statements.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。 
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        テーブルを削除しても、そのテーブル専用に付与された権限は自動的には削除されません。 手動で削除する必要があります。 <a class="xref" href="sql-statements.html#grant" title="13.7.1.6 GRANT ステートメント">セクション13.7.1.6「GRANT ステートメント」</a>を参照してください。 
      </p></div><p>
      引数リストに指定されたテーブルが存在しない場合、<code class="literal">DROP TABLE</code> の動作は <code class="literal">IF EXISTS</code> 句が指定されているかどうかによって異なります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">IF EXISTS</code> がない場合、ステートメントは失敗し、削除できなかった存在しないテーブルを示すエラーが表示され、変更は行われません。
        </p></li><li class="listitem"><p>
          <code class="literal">IF EXISTS</code> では、存在しないテーブルに対してエラーは発生しません。 このステートメントは、存在するすべての名前付きテーブルを削除し、存在しないテーブルごとに <code class="literal">NOTE</code> 診断を生成します。 これらのノートは、<code class="literal">SHOW WARNINGS</code> で表示できます。 <a class="xref" href="sql-statements.html#show-warnings" title="13.7.7.42 SHOW WARNINGS ステートメント">セクション13.7.7.42「SHOW WARNINGS ステートメント」</a>を参照してください。 
        </p></li></ul></div><p>
      <code class="literal">IF EXISTS</code> は、データディクショナリにエントリがあり、記憶域エンジンによって管理されるテーブルがない異常な状況でテーブルを削除する場合にも役立ちます。 (たとえば、ストレージエンジンからテーブルを削除したあと、データディクショナリエントリを削除する前に異常なサーバーイグジットが発生した場合。) 
    </p><p>
      <code class="literal">TEMPORARY</code> キーワードには、次の効果があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          このステートメントは、<code class="literal">TEMPORARY</code> テーブルのみを削除します。
        </p></li><li class="listitem"><p>
          このステートメントは暗黙的なコミットを引き起こしません。
        </p></li><li class="listitem"><p>
          アクセス権は確認されません。 <code class="literal">TEMPORARY</code> テーブルは、それを作成したセッションでのみ表示されるため、チェックは必要ありません。 
        </p></li></ul></div><p>
      <code class="literal">TEMPORARY</code> 以外のテーブルを誤って削除しないようにするには、<code class="literal">TEMPORARY</code> キーワードを含めることをお薦めします。
    </p><p>
      <code class="literal">RESTRICT</code> および <code class="literal">CASCADE</code> キーワードは何も行いません。 他のデータベースシステムからの移植を容易にすることができます。 
    </p><p>
      <code class="literal">DROP TABLE</code> はすべての <code class="literal">innodb_force_recovery</code> 設定でサポートされているわけではありません。 <a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="15.21.2 InnoDB のリカバリの強制的な実行">セクション15.21.2「InnoDB のリカバリの強制的な実行」</a>を参照してください。 
    </p><a class="indexterm" name="idm45827001207408"></a></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-tablespace"></a>13.1.33 DROP TABLESPACE ステートメント</h3></div></div></div><a class="indexterm" name="idm45827001203408"></a><a class="indexterm" name="idm45827001201232"></a><a class="indexterm" name="idm45827001199168"></a><pre class="programlisting">DROP [UNDO] TABLESPACE <em class="replaceable"><code>tablespace_name</code></em>
    [ENGINE [=] <em class="replaceable"><code>engine_name</code></em>]
</pre><p>
      このステートメントは、<code class="literal">CREATE TABLESPACE</code> を使用して以前に作成されたテーブルスペースを削除します。 <code class="literal">NDB</code> および <code class="literal">InnoDB</code> ストレージエンジンでサポートされています。 
    </p><p>
      undo テーブルスペースを削除するには、MySQL 8.0.14 で導入された <code class="literal">UNDO</code> キーワードを指定する必要があります。 <code class="literal">CREATE UNDO TABLESPACE</code> 構文を使用して作成された undo テーブルスペースのみを削除できます。 undo テーブルスペースは、削除する前に <code class="literal">empty</code> 状態である必要があります。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-undo-tablespaces" title="15.6.3.4 undo テーブルスペース">セクション15.6.3.4「undo テーブルスペース」</a>を参照してください。 
    </p><p>
      <code class="literal">ENGINE</code> は、テーブルスペースを使用するストレージエンジンを設定します。ここで、<em class="replaceable"><code>engine_name</code></em> はストレージエンジンの名前です。 現在、<code class="literal">InnoDB</code> および <code class="literal">NDB</code> の値がサポートされています。 設定しない場合、<code class="literal">default_storage_engine</code> の値が使用されます。 テーブルスペースの作成に使用されたストレージエンジンと同じでない場合、<code class="literal">DROP TABLESPACE</code> ステートメントは失敗します。 
    </p><p>
      <code class="literal"><em class="replaceable"><code>tablespace_name</code></em></code> は、MySQL では大/小文字が区別される識別子です。
    </p><p>
      <code class="literal">InnoDB</code> 一般テーブルスペースの場合、<code class="literal">DROP TABLESPACE</code> 操作の前にすべてのテーブルをテーブルスペースから削除する必要があります。 テーブルスペースが空でない場合、<code class="literal">DROP TABLESPACE</code> はエラーを返します。 
    </p><p>
      削除する <code class="literal">NDB</code> テーブルスペースにデータファイルを含めることはできません。つまり、<code class="literal">NDB</code> テーブルスペースを削除する前に、まず <code class="literal">ALTER TABLESPACE ... DROP DATAFILE</code> を使用して各データファイルを削除する必要があります。
    </p><h4><a name="idm45827001172032"></a>メモ</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          一般的な <code class="literal">InnoDB</code> テーブルスペースは、テーブルスペースの最後のテーブルが削除されても自動的には削除されません。 テーブルスペースは、<code class="literal">DROP TABLESPACE <em class="replaceable"><code>tablespace_name</code></em></code> を使用して明示的に削除する必要があります。 
        </p></li><li class="listitem"><p>
          <code class="literal">DROP DATABASE</code> 操作では、一般的なテーブルスペースに属するテーブルを削除できますが、そのテーブルスペースに属するすべてのテーブルを削除しても、テーブルスペースは削除できません。 テーブルスペースは、<code class="literal">DROP TABLESPACE <em class="replaceable"><code>tablespace_name</code></em></code> を使用して明示的に削除する必要があります。 
        </p></li><li class="listitem"><p>
          システムテーブルスペースと同様に、一般テーブルスペースに格納されているテーブルの切捨てまたは削除によって、新しい <code class="literal">InnoDB</code> データにのみ使用できる空き領域が一般テーブルスペース <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibd data file</a> に内部的に作成されます。 file-per-table テーブルスペース用であるため、領域はオペレーティングシステムに解放されません。 
        </p></li></ul></div><h4><a name="idm45827001161328"></a>InnoDB の例</h4><p>
      この例では、<code class="literal">InnoDB</code> の一般テーブルスペースを削除する方法を示します。 一般的なテーブルスペース <code class="literal">ts1</code> は、単一のテーブルで作成されます。 テーブルスペースを削除する前に、テーブルを削除する必要があります。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE `ts1` ADD DATAFILE 'ts1.ibd' Engine=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts1 Engine=InnoDB;</code></strong>

mysql&gt; <strong class="userinput"><code>DROP TABLE t1;</code></strong>

mysql&gt; <strong class="userinput"><code>DROP TABLESPACE ts1;</code></strong>
</pre><p>
      この例では、undo テーブルスペースの削除を示します。 undo テーブルスペースは、削除する前に <code class="literal">empty</code> 状態である必要があります。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-undo-tablespaces" title="15.6.3.4 undo テーブルスペース">セクション15.6.3.4「undo テーブルスペース」</a>を参照してください。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>DROP UNDO TABLESPACE <em class="replaceable"><code>undo_003</code></em>;</code></strong>
</pre><h4><a name="idm45827001150176"></a>NDB の例</h4><p>
      この例では、最初にテーブルスペースを作成した後に <code class="filename">mydata-1.dat</code> という名前のデータファイルを持つ <code class="literal">NDB</code> テーブルスペース <code class="literal">myts</code> を削除する方法を示し、<code class="literal">mylg</code> という名前のログファイルグループが存在することを前提としています (<a class="xref" href="sql-statements.html#create-logfile-group" title="13.1.16 CREATE LOGFILE GROUP ステートメント">セクション13.1.16「CREATE LOGFILE GROUP ステートメント」</a> を参照)。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLESPACE myts</code></strong>
    -&gt;     <strong class="userinput"><code>ADD DATAFILE 'mydata-1.dat'</code></strong>
    -&gt;     <strong class="userinput"><code>USE LOGFILE GROUP mylg</code></strong>
    -&gt;     <strong class="userinput"><code>ENGINE=NDB;</code></strong>
</pre><p>
      削除する前に、次に示すように、<code class="literal">ALTER TABLESPACE</code> を使用してテーブルスペースからすべてのデータファイルを削除する必要があります:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLESPACE myts</code></strong>
    -&gt;     <strong class="userinput"><code>DROP DATAFILE 'mydata-1.dat'</code></strong>
    -&gt;     <strong class="userinput"><code>ENGINE=NDB;</code></strong>

mysql&gt; <strong class="userinput"><code>DROP TABLESPACE myts;</code></strong>
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-trigger"></a>13.1.34 DROP TRIGGER ステートメント</h3></div></div></div><a class="indexterm" name="idm45827001133968"></a><a class="indexterm" name="idm45827001132656"></a><pre class="programlisting">DROP TRIGGER [IF EXISTS] [<em class="replaceable"><code>schema_name</code></em>.]<em class="replaceable"><code>trigger_name</code></em>
</pre><p>
      このステートメントは、トリガーを削除します。 スキーマ (データベース) 名はオプションです。 スキーマが省略されている場合、このトリガーはデフォルトスキーマから削除されます。 <code class="literal">DROP TRIGGER</code> には、このトリガーに関連付けられたテーブルに対する <code class="literal">TRIGGER</code> 権限が必要です。 
    </p><p>
      存在しないトリガーに対してエラーが発生しないようにするには、<code class="literal">IF EXISTS</code> を使用します。 <code class="literal">IF EXISTS</code> を使用している場合は、存在しないトリガーに対して <code class="literal">NOTE</code> が生成されます。 <a class="xref" href="sql-statements.html#show-warnings" title="13.7.7.42 SHOW WARNINGS ステートメント">セクション13.7.7.42「SHOW WARNINGS ステートメント」</a>を参照してください。 
    </p><p>
      テーブルを削除すると、そのテーブルのトリガーも削除されます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-view"></a>13.1.35 DROP VIEW ステートメント</h3></div></div></div><a class="indexterm" name="idm45827001117712"></a><pre class="programlisting">DROP VIEW [IF EXISTS]
    <em class="replaceable"><code>view_name</code></em> [, <em class="replaceable"><code>view_name</code></em>] ...
    [RESTRICT | CASCADE]
</pre><p>
      <code class="literal">DROP VIEW</code> は、1 つ以上のビューを削除します。 各ビューに対する <code class="literal">DROP</code> 権限が必要です。 
    </p><p>
      引数リストに指定されたビューが存在しない場合、ステートメントは、削除できなかったビューを名前で示すエラーで失敗し、変更は行われません。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        MySQL 5.7 以前では、引数リストに指定されたビューが存在しない場合、<code class="literal">DROP VIEW</code> はエラーを返しますが、存在するリスト内のすべてのビューも削除します。 MySQL 8.0 の動作が変更されたため、MySQL 8.0 レプリカでレプリケートすると、MySQL 5.7 レプリケーションソースサーバーで部分的に完了した <code class="literal">DROP VIEW</code> 操作が失敗します。 この失敗のシナリオを回避するには、<code class="literal">DROP VIEW</code> ステートメントで <code class="literal">IF EXISTS</code> 構文を使用して、存在しないビューに対してエラーが発生しないようにします。 詳細は、<a class="xref" href="sql-statements.html#atomic-ddl" title="13.1.1 アトミックデータ定義ステートメントのサポート">セクション13.1.1「アトミックデータ定義ステートメントのサポート」</a>を参照してください。 
      </p></div><p>
      <code class="literal">IF EXISTS</code> 句は、存在しないビューに対してエラーが発生しないようにします。 この句が指定されている場合は、存在しないビューごとに <code class="literal">NOTE</code> が生成されます。 <a class="xref" href="sql-statements.html#show-warnings" title="13.7.7.42 SHOW WARNINGS ステートメント">セクション13.7.7.42「SHOW WARNINGS ステートメント」</a>を参照してください。 
    </p><p>
      <code class="literal">RESTRICT</code> と <code class="literal">CASCADE</code> (指定されている場合) は解析されますが、無視されます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="rename-table"></a>13.1.36 RENAME TABLE ステートメント</h3></div></div></div><a class="indexterm" name="idm45827001094832"></a><pre class="programlisting">RENAME TABLE
    <em class="replaceable"><code>tbl_name</code></em> TO <em class="replaceable"><code>new_tbl_name</code></em>
    [, <em class="replaceable"><code>tbl_name2</code></em> TO <em class="replaceable"><code>new_tbl_name2</code></em>] ...
</pre><p>
      <code class="literal">RENAME TABLE</code> は、1 つ以上のテーブルの名前を変更します。 元のテーブルに対する <code class="literal">ALTER</code> 権限と <code class="literal">DROP</code> 権限、および新しいテーブルに対する <code class="literal">CREATE</code> 権限と <code class="literal">INSERT</code> 権限が必要です。 
    </p><p>
      たとえば、<code class="literal">old_table</code> というテーブルの名前を <code class="literal">new_table</code> に変更するには、次のステートメントを使用します:
    </p><pre class="programlisting">RENAME TABLE old_table TO new_table;
</pre><p>
      このステートメントは、次の <code class="literal">ALTER TABLE</code> ステートメントと同等です:
    </p><pre class="programlisting">ALTER TABLE old_table RENAME new_table;
</pre><p>
      <code class="literal">RENAME TABLE</code> は、<code class="literal">ALTER TABLE</code> とは異なり、単一のステートメント内で複数のテーブルの名前を変更できます:
    </p><pre class="programlisting">RENAME TABLE old_table1 TO new_table1,
             old_table2 TO new_table2,
             old_table3 TO new_table3;
</pre><p>
      名前変更操作は左から右に実行されます。 したがって、2 つのテーブル名を入れ替えるには、次の手順を実行します (仲介者名が <code class="literal">tmp_table</code> のテーブルがまだ存在しないことを前提としています): 
    </p><pre class="programlisting">RENAME TABLE old_table TO tmp_table,
             new_table TO old_table,
             tmp_table TO new_table;
</pre><p>
      テーブルのメタデータロックは名前順に取得され、場合によっては、複数のトランザクションが同時に実行されるときに操作結果に違いが生じることがあります。 <a class="xref" href="optimization.html#metadata-locking" title="8.11.4 メタデータのロック">セクション8.11.4「メタデータのロック」</a>を参照してください。 
    </p><p>
      MySQL 8.0.13 では、<code class="literal">WRITE</code> ロックでロックされているテーブル、または複数テーブルの名前変更操作の前のステップでロックされた <code class="literal">WRITE</code> テーブルの名前を変更する積である場合、<code class="literal">LOCK TABLES</code> ステートメントでロックされたテーブルの名前を変更できます。 たとえば、次のように指定できます: 
    </p><pre class="programlisting">LOCK TABLE old_table1 WRITE;
RENAME TABLE old_table1 TO new_table1,
             new_table1 TO new_table2;
</pre><p>
      次の場合は許可されません。
    </p><pre class="programlisting">LOCK TABLE old_table1 READ;
RENAME TABLE old_table1 TO new_table1,
             new_table1 TO new_table2;
</pre><p>
      MySQL 8.0.13 より前は、<code class="literal">RENAME TABLE</code> を実行するには、<code class="literal">LOCK TABLES</code> でロックされたテーブルがないようにする必要があります。
    </p><p>
      トランザクションテーブルのロック条件が満たされると、名前変更操作はアトミックに実行されます。名前変更の進行中は、他のセッションはどのテーブルにもアクセスできません。
    </p><p>
      <code class="literal">RENAME TABLE</code> 中にエラーが発生した場合、ステートメントは失敗し、変更は行われません。
    </p><p>
      <code class="literal">RENAME TABLE</code> を使用して、データベース間でテーブルを移動できます:
    </p><pre class="programlisting">RENAME TABLE <em class="replaceable"><code>current_db.tbl_name</code></em> TO <em class="replaceable"><code>other_db.tbl_name;</code></em>
</pre><a class="indexterm" name="idm45827001056096"></a><a class="indexterm" name="idm45827001053952"></a><p>
      この方法を使用して、あるデータベースから別のデータベースにすべてのテーブルを移動すると、実際には、元のデータベースが引き続き存在し、テーブルなしでアルバイトされることを除き、データベースの名前が変更されます (MySQL に単一のステートメントがない操作)。
    </p><p>
      <code class="literal">RENAME TABLE</code> と同様に、<code class="literal">ALTER TABLE ... RENAME</code> を使用してテーブルを別のデータベースに移動することもできます。 使用するステートメントに関係なく、名前変更操作によってテーブルが別のファイルシステムにあるデータベースに移動される場合、結果の成功はプラットフォーム固有であり、テーブルファイルの移動に使用される基礎となるオペレーティングシステムコールによって異なります。 
    </p><p>
      テーブルにトリガーがある場合、テーブルの名前を別のデータベースに変更しようとすると、<span class="errortext">「トリガーが間違ったスキーマにあります」</span> (<code class="literal">ER_TRG_IN_WRONG_SCHEMA</code>) エラーで失敗します。
    </p><p>
      暗号化されていないテーブルは暗号化対応データベースに移動でき、その逆も可能です。 ただし、<code class="literal">table_encryption_privilege_check</code> 変数が有効になっている場合、テーブルの暗号化設定がデフォルトのデータベース暗号化と異なると、<code class="literal">TABLE_ENCRYPTION_ADMIN</code> 権限が必要です。 
    </p><a class="indexterm" name="idm45827001044352"></a><p>
      <code class="literal">TEMPORARY</code> テーブルの名前を変更する場合、<code class="literal">RENAME TABLE</code> は機能しません。 かわりに <code class="literal">ALTER TABLE</code> を使用してください。 
    </p><p>
      <code class="literal">RENAME TABLE</code> はビューに対して機能しますが、ビューの名前を別のデータベースに変更することはできません。
    </p><p>
      名前を変更したテーブルまたはビュー専用に付与された権限は、新しい名前に移行されません。 それらは、手動で変更する必要があります。 
    </p><p>
      <code class="literal">RENAME TABLE <em class="replaceable"><code>tbl_name</code></em> TO <em class="replaceable"><code>new_tbl_name</code></em></code> は、内部的に生成された外部キー制約名および文字列 <span class="quote">「<span class="quote"><em class="replaceable"><code>tbl_name</code></em> _ibfk_</span>」</span>で始まるユーザー定義の外部キー制約名を、新しいテーブル名を反映するように変更します。 <code class="literal">InnoDB</code> は、文字列 <span class="quote">「<span class="quote"><em class="replaceable"><code>tbl_name</code></em> _ibfk_</span>」</span>で始まる外部キー制約名を内部的に生成された名前と解釈します。 
    </p><p>
      名前が変更されたテーブルを指す外部キー制約名は、競合がないかぎり自動的に更新されます。競合がある場合、ステートメントはエラーで失敗します。 名前を変更した制約名がすでに存在する場合は、競合が発生します。 このような場合は、外部キーを削除して再作成し、正しく機能させる必要があります。 
    </p><a class="indexterm" name="idm45827001031968"></a><p>
      <code class="literal">RENAME TABLE <em class="replaceable"><code>tbl_name</code></em> TO <em class="replaceable"><code>new_tbl_name</code></em></code> は、新しいテーブル名を反映するために、文字列 <span class="quote">「<span class="quote"><em class="replaceable"><code>tbl_name</code></em> _chk_</span>」</span>で始まる内部生成およびユーザー定義の <code class="literal">CHECK</code> 制約名を変更します。 MySQL は、文字列 <span class="quote">「<span class="quote"><em class="replaceable"><code>tbl_name</code></em> _chk_</span>」</span>で始まる <code class="literal">CHECK</code> 制約名を内部的に生成された名前と解釈します。 例: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t1\G</code></strong>
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `i1` int(11) DEFAULT NULL,
  `i2` int(11) DEFAULT NULL,
  CONSTRAINT `t1_chk_1` CHECK ((`i1` &gt; 0)),
  CONSTRAINT `t1_chk_2` CHECK ((`i2` &lt; 0))
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
1 row in set (0.02 sec)

mysql&gt; <strong class="userinput"><code>RENAME TABLE t1 TO t3;</code></strong>
Query OK, 0 rows affected (0.03 sec)

mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t3\G</code></strong>
*************************** 1. row ***************************
       Table: t3
Create Table: CREATE TABLE `t3` (
  `i1` int(11) DEFAULT NULL,
  `i2` int(11) DEFAULT NULL,
  CONSTRAINT `t3_chk_1` CHECK ((`i1` &gt; 0)),
  CONSTRAINT `t3_chk_2` CHECK ((`i2` &lt; 0))
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
1 row in set (0.01 sec)
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="truncate-table"></a>13.1.37 TRUNCATE TABLE ステートメント</h3></div></div></div><a class="indexterm" name="idm45827001019200"></a><pre class="programlisting">TRUNCATE [TABLE] <em class="replaceable"><code>tbl_name</code></em>
</pre><p>
      <code class="literal">TRUNCATE TABLE</code> は、テーブルを完全に空にします。 これには <code class="literal">DROP</code> 権限が必要です。 <code class="literal">TRUNCATE TABLE</code> は論理的に、すべての行を削除する <code class="literal">DELETE</code> ステートメントや、<code class="literal">DROP TABLE</code> および <code class="literal">CREATE TABLE</code> ステートメントのシーケンスに似ています。 
    </p><p>
      高パフォーマンスを実現するために、<code class="literal">TRUNCATE TABLE</code> はデータを削除する DML メソッドをバイパスします。 したがって、<code class="literal">ON DELETE</code> トリガーは起動せず、親子外部キー関係を持つ <code class="literal">InnoDB</code> テーブルに対しては実行できず、DML 操作のようにロールバックできません。 ただし、アトミック DDL でサポートされているストレージエンジンを使用するテーブルでの <code class="literal">TRUNCATE TABLE</code> 操作は、その操作中にサーバーが停止すると、完全にコミットまたはロールバックされます。 詳細は、<a class="xref" href="sql-statements.html#atomic-ddl" title="13.1.1 アトミックデータ定義ステートメントのサポート">セクション13.1.1「アトミックデータ定義ステートメントのサポート」</a>を参照してください。 
    </p><p>
      <code class="literal">TRUNCATE TABLE</code> は <code class="literal">DELETE</code> に似ているにもかかわらず、DML ステートメントではなく DDL ステートメントとして分類されます。 これは、次の点で <code class="literal">DELETE</code> と異なります: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          切り捨て操作はテーブルを削除して再作成するため、特に大きなテーブルの場合は、行を 1 つずつ削除するよりはるかに高速です。
        </p></li><li class="listitem"><p>
          切り捨て操作は暗黙的なコミットを発生させるため、ロールバックできません。 <a class="xref" href="sql-statements.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          セッションがアクティブなテーブルロックを保持している場合は、切り詰め操作を実行できません。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> テーブルまたは <code class="literal">NDB</code> テーブルを参照する他のテーブルからの <code class="literal">FOREIGN KEY</code> 制約がある場合、そのテーブルに対する <code class="literal">TRUNCATE TABLE</code> は失敗します。 同じテーブルのカラム間の外部キー制約が許可されます。 
        </p></li><li class="listitem"><p>
          切り詰め操作は、削除された行数に対して、意味のある値を返しません。 通常の結果は<span class="quote">「<span class="quote">0 rows affected</span>」</span>ですが、これは<span class="quote">「<span class="quote">情報がない</span>」</span>ものとして解釈してください。 
        </p></li><li class="listitem"><p>
          テーブル定義が有効であるかぎり、データファイルまたはインデックスファイルが破損した場合でも、<code class="literal">TRUNCATE TABLE</code> を使用してテーブルを空のテーブルとして再作成できます。
        </p></li><li class="listitem"><p>
          <code class="literal">AUTO_INCREMENT</code> 値はすべて、その開始値にリセットされます。 これは、通常はシーケンス値を再利用しない <code class="literal">MyISAM</code> や <code class="literal">InnoDB</code> にも当てはまります。 
        </p></li><li class="listitem"><p>
          パーティションテーブルで使用した場合、<code class="literal">TRUNCATE TABLE</code> はパーティション化を保持します。つまり、データファイルおよびインデックスファイルは削除されて再作成されますが、パーティション定義には影響しません。
        </p></li><li class="listitem"><p>
          <code class="literal">TRUNCATE TABLE</code> ステートメントは、<code class="literal">ON DELETE</code> トリガーを起動しません。
        </p></li><li class="listitem"><p>
          破損した <code class="literal">InnoDB</code> テーブルの切捨てがサポートされています。
        </p></li></ul></div><p>
      テーブルに対する <code class="literal">TRUNCATE TABLE</code> は、<code class="literal">HANDLER OPEN</code> で開かれたそのテーブルのすべてのハンドラを閉じます。
    </p><p>
      <code class="literal">TRUNCATE TABLE</code> は、バイナリロギングおよびレプリケーション目的のときは、<code class="literal">DROP TABLE</code> とそれに続く <code class="literal">CREATE TABLE</code> として、つまり、DML ではなく DDL として扱われます。 これは、<code class="literal">InnoDB</code> またはほかのトランザクションストレージエンジン (そのトランザクション分離レベルがステートメントベースロギングを許可しない (<code class="literal">READ COMMITTED</code> または <code class="literal">READ UNCOMMITTED</code>)) を使用するときは、<code class="literal">STATEMENT</code> または <code class="literal">MIXED</code> ロギングモード使用時にステートメントがログに記録されず複製されなかった事実によります。 (Bug #36763) ただし、前述の方法で <code class="literal">InnoDB</code> を使用してレプリカに適用されます。 
    </p><p>
      MySQL 5.7 以前では、ラージバッファプールおよび <code class="literal">innodb_adaptive_hash_index</code> が有効になっているシステムで <code class="literal">TRUNCATE TABLE</code> 操作を実行すると、テーブル適応ハッシュインデックスエントリの削除時に LRU スキャンが発生したため、システムパフォーマンスが一時的に低下する可能性がありました (Bug #68184)。 MySQL 8.0 で <code class="literal">TRUNCATE TABLE</code> を <code class="literal">DROP TABLE</code> および <code class="literal">CREATE TABLE</code> に再マッピングすると、LRU スキャンの問題が回避されます。 
    </p><p>
      <code class="literal">TRUNCATE TABLE</code> はパフォーマンススキーマのサマリーテーブルで使用できますが、その効果は行の削除ではなく、サマリーカラムを 0 または <code class="literal">NULL</code> にリセットすることです。 <a class="xref" href="performance-schema.html#performance-schema-summary-tables" title="27.12.18 パフォーマンススキーマサマリーテーブル">セクション27.12.18「パフォーマンススキーマサマリーテーブル」</a>を参照してください。 
    </p><p>
      file-per-table テーブルスペースに存在する <code class="literal">InnoDB</code> テーブルを切り捨てると、既存のテーブルスペースが削除され、新しいテーブルスペースが作成されます。 MySQL 8.0.21 では、テーブルスペースが以前のバージョンで作成され、不明なディレクトリに存在する場合、<code class="literal">InnoDB</code> は新しいテーブルスペースをデフォルトの場所に作成し、次の警告をエラーログに書き込みます: <span class="errortext">The DATA DIRECTORY の場所は既知のディレクトリにある必要があります。 DATA DIRECTORY の場所は無視され、ファイルはデフォルトの datadir location</span> に格納されます。 既知のディレクトリは、<code class="literal">datadir</code>、<code class="literal">innodb_data_home_dir</code> および <code class="literal">innodb_directories</code> 変数で定義されているディレクトリです。 <code class="literal">TRUNCATE TABLE</code> で現在の場所にテーブルスペースを作成するには、<code class="literal">TRUNCATE TABLE</code> を実行する前に <code class="literal">innodb_directories</code> 設定にディレクトリを追加します。 
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sql-data-manipulation-statements"></a>13.2 データ操作ステートメント</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#call">13.2.1 CALL ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#delete">13.2.2 DELETE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#do">13.2.3 DO ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#handler">13.2.4 HANDLER ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#import-table">13.2.5 IMPORT TABLE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#insert">13.2.6 INSERT ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#load-data">13.2.7 LOAD DATA ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#load-xml">13.2.8 LOAD XML ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#replace">13.2.9 REPLACE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#select">13.2.10 SELECT ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#subqueries">13.2.11 サブクエリー</a></span></dt><dt><span class="section"><a href="sql-statements.html#table">13.2.12 TABLE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#update">13.2.13 UPDATE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#values">13.2.14 VALUES ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#with">13.2.15 WITH (共通テーブル式)</a></span></dt></dl></div><a class="indexterm" name="idm45827000940288"></a><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="call"></a>13.2.1 CALL ステートメント</h3></div></div></div><a class="indexterm" name="idm45827000937792"></a><pre class="programlisting">CALL <em class="replaceable"><code>sp_name</code></em>([<em class="replaceable"><code>parameter</code></em>[,...]])
CALL <em class="replaceable"><code>sp_name</code></em>[()]
</pre><p>
      <code class="literal">CALL</code> ステートメントは、以前に <code class="literal">CREATE PROCEDURE</code> を使用して定義されたストアドプロシージャーを呼び出します。
    </p><p>
      引数を取らないストアドプロシージャーは、括弧なしで呼び出すことができます。 つまり、<code class="literal">CALL p()</code> と <code class="literal">CALL p</code> は同等です。 
    </p><p>
      <code class="literal">CALL</code> は、<code class="literal">OUT</code> または <code class="literal">INOUT</code> パラメータとして宣言されたパラメータを使用して、その呼び出し元に値を返すことができます。 そのプロシージャーから戻るとき、クライアントプログラムは、ルーチン内で実行された最後のステートメントで影響を受けた行数を取得することもできます。SQL レベルでは、<code class="literal">ROW_COUNT()</code> 関数を呼び出します。C API からは、<code class="literal">mysql_affected_rows()</code> 関数を呼び出します。 
    </p><p>
      プロシージャパラメータに対する未処理条件の影響の詳細は、<a class="xref" href="sql-statements.html#conditions-and-parameters" title="13.6.7.8 条件の処理と OUT または INOUT パラメータ">セクション13.6.7.8「条件の処理と OUT または INOUT パラメータ」</a> を参照してください。
    </p><p>
      <code class="literal">OUT</code> または <code class="literal">INOUT</code> パラメータを使用してプロシージャーから値を取得するには、ユーザー変数を使用してこのパラメータを渡し、そのプロシージャーから戻ったあとに変数の値をチェックします。 (そのプロシージャーを別のストアドプロシージャーまたはストアドファンクション内から呼び出している場合は、<code class="literal">IN</code> または <code class="literal">INOUT</code> パラメータとしてルーチンパラメータまたはローカルルーチン変数を渡すこともできます。) <code class="literal">INOUT</code> パラメータの場合は、プロシージャーに渡す前にその値を初期化してください。 次のプロシージャーには、このプロシージャーが現在のサーバーバージョンに設定する <code class="literal">OUT</code> パラメータと、このプロシージャーがその現在の値から 1 増分する <code class="literal">INOUT</code> 値が含まれています。 
    </p><pre class="programlisting">CREATE PROCEDURE p (OUT ver_param VARCHAR(25), INOUT incr_param INT)
BEGIN
  # Set value of OUT parameter
  SELECT VERSION() INTO ver_param;
  # Increment value of INOUT parameter
  SET incr_param = incr_param + 1;
END;
</pre><p>
      このプロシージャーを呼び出す前に、<code class="literal">INOUT</code> パラメータとして渡される変数を初期化します。 プロシージャをコールすると、2 つの変数の値が設定または変更されていることがわかります: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET @increment = 10;</code></strong>
mysql&gt; <strong class="userinput"><code>CALL p(@version, @increment);</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT @version, @increment;</code></strong>
+--------------------+------------+
| @version           | @increment |
+--------------------+------------+
| 8.0.3-rc-debug-log |         11 |
+--------------------+------------+
</pre><p>
      <code class="literal">PREPARE</code> および <code class="literal">EXECUTE</code> で使用される準備済 <code class="literal">CALL</code> ステートメントでは、<code class="literal">IN</code> パラメータ、<code class="literal">OUT</code> および <code class="literal">INOUT</code> パラメータにプレースホルダを使用できます。 これらの種類のパラメータは、次のように使用できます。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET @increment = 10;</code></strong>
mysql&gt; <strong class="userinput"><code>PREPARE s FROM 'CALL p(?, ?)';</code></strong>
mysql&gt; <strong class="userinput"><code>EXECUTE s USING @version, @increment;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT @version, @increment;</code></strong>
+--------------------+------------+
| @version           | @increment |
+--------------------+------------+
| 8.0.3-rc-debug-log |         11 |
+--------------------+------------+
</pre><p>
      <code class="literal">CALL</code> SQL ステートメントを使用して、結果セットを生成するストアドプロシージャーを実行する C プログラムを記述するには、<code class="literal">CLIENT_MULTI_RESULTS</code> フラグが有効になっている必要があります。 これは、各 <code class="literal">CALL</code> によって、プロシージャー内で実行されるステートメントによって返される可能性のある結果セットに加えて、呼び出しステータスを示すための結果が返されるためです。 <code class="literal">CLIENT_MULTI_RESULTS</code> は、<code class="literal">CALL</code> が、準備済みステートメントを含むストアドプロシージャーを実行するために使用される場合にも有効になっている必要があります。 これらのステートメントが結果セットを生成するかどうかは、このようなプロシージャがロードされたときに判断できないため、結果セットを生成すると想定する必要があります。 
    </p><p>
      <code class="literal">CLIENT_MULTI_RESULTS</code> は、<code class="literal">mysql_real_connect()</code> を呼び出すときに、<code class="literal">CLIENT_MULTI_RESULTS</code> フラグ自体を渡すことによって明示的に、または <code class="literal">CLIENT_MULTI_STATEMENTS</code> を渡すことによって暗黙的に有効にする (これによって <code class="literal">CLIENT_MULTI_RESULTS</code> も有効になります) ことができます。 <code class="literal">CLIENT_MULTI_RESULTS</code> はデフォルトで有効になっています。 
    </p><p>
      <code class="literal">mysql_query()</code> または <code class="literal">mysql_real_query()</code> を使用して実行された <code class="literal">CALL</code> ステートメントの結果を処理するには、それ以上結果が存在するかどうかを判定するために <code class="literal">mysql_next_result()</code> を呼び出すループを使用してください。 例については、<a class="ulink" href="https://dev.mysql.com/doc/c-api/8.0/en/c-api-multiple-queries.html" target="_top">Multiple Statement Execution Support</a>を参照してください。 
    </p><p>
      C プログラムでは、プリペアドステートメントインタフェースを使用して <code class="literal">CALL</code> ステートメントを実行し、<code class="literal">OUT</code> および <code class="literal">INOUT</code> パラメータにアクセスできます。 これは、それ以上結果が存在するかどうかを判定するために <code class="literal">mysql_stmt_next_result()</code> を呼び出すループを使用して <code class="literal">CALL</code> ステートメントの結果を処理することにより行われます。 例については、<a class="ulink" href="https://dev.mysql.com/doc/c-api/8.0/en/c-api-prepared-call-statements.html" target="_top">Prepared CALL Statement Support</a>を参照してください。 MySQL インタフェースを備える言語は、準備済み <code class="literal">CALL</code> ステートメントを使用して、<code class="literal">OUT</code> および <code class="literal">INOUT</code> プロシージャーパラメータを直接取得できます。 
    </p><p>
      ストアドプログラムによって参照されるオブジェクトに対するメタデータの変更が検出され、プログラムが次に実行されるときに、影響を受けるステートメントが自動的に再解析されます。 詳細については、<a class="xref" href="optimization.html#statement-caching" title="8.10.3 プリペアドステートメントおよびストアドプログラムのキャッシュ">セクション8.10.3「プリペアドステートメントおよびストアドプログラムのキャッシュ」</a>を参照してください。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="delete"></a>13.2.2 DELETE ステートメント</h3></div></div></div><a class="indexterm" name="idm45827000867376"></a><a class="indexterm" name="idm45827000866064"></a><p>
      <code class="literal">DELETE</code> は、テーブルの行を削除する DML ステートメントです。
    </p><p>
      <code class="literal">DELETE</code> ステートメントは、<code class="literal">WITH</code> 句で始まり、<code class="literal">DELETE</code> 内でアクセス可能な共通テーブル式を定義できます。 <a class="xref" href="sql-statements.html#with" title="13.2.15 WITH (共通テーブル式)">セクション13.2.15「WITH (共通テーブル式)」</a>を参照してください。 
    </p><h4><a name="idm45827000856064"></a>単一テーブル構文</h4><pre class="programlisting">DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM <em class="replaceable"><code>tbl_name</code></em> [[AS] <em class="replaceable"><code>tbl_alias</code></em>]
    [PARTITION (<em class="replaceable"><code>partition_name</code></em> [, <em class="replaceable"><code>partition_name</code></em>] ...)]
    [WHERE <em class="replaceable"><code>where_condition</code></em>]
    [ORDER BY ...]
    [LIMIT <em class="replaceable"><code>row_count</code></em>]
</pre><p>
      <code class="literal">DELETE</code> ステートメントは、<em class="replaceable"><code>tbl_name</code></em> の行を削除し、削除された行数を返します。 削除された行数をチェックするには、<a class="xref" href="functions.html#information-functions" title="12.16 情報関数">セクション12.16「情報関数」</a>で説明されている<code class="literal">ROW_COUNT()</code> 関数を呼び出します。 
    </p><h4><a name="idm45827000848192"></a>メインの句</h4><p>
      オプションの <code class="literal">WHERE</code> 句内の条件は、どの行を削除するかを識別します。 <code class="literal">WHERE</code> 句がない場合は、すべての行が削除されます。 
    </p><p>
      <em class="replaceable"><code>where_condition</code></em> は、削除される各行に対して true に評価される式です。 これは、<a class="xref" href="sql-statements.html#select" title="13.2.10 SELECT ステートメント">セクション13.2.10「SELECT ステートメント」</a>で説明されているように指定されます。 
    </p><p>
      <code class="literal">ORDER BY</code> 句が指定されている場合は、指定されている順序で行が削除されます。 <code class="literal">LIMIT</code> 句は、削除できる行数に制限を設定します。 これらの句は単一テーブルの削除に適用されますが、複数テーブルの削除には適用されません。 
    </p><h4><a name="idm45827000841264"></a>複数テーブル構文</h4><pre class="programlisting">DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
    <em class="replaceable"><code>tbl_name</code></em>[.*] [, <em class="replaceable"><code>tbl_name</code></em>[.*]] ...
    FROM <em class="replaceable"><code>table_references</code></em>
    [WHERE <em class="replaceable"><code>where_condition</code></em>]

DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
    FROM <em class="replaceable"><code>tbl_name</code></em>[.*] [, <em class="replaceable"><code>tbl_name</code></em>[.*]] ...
    USING <em class="replaceable"><code>table_references</code></em>
    [WHERE <em class="replaceable"><code>where_condition</code></em>]
</pre><h4><a name="idm45827000834944"></a>権限</h4><p>
      テーブルから行を削除するには、そのテーブルに対する <code class="literal">DELETE</code> 権限が必要です。 <code class="literal">WHERE</code> 句で指定されているカラムなどの、読み取られるだけのカラムに対しては、<code class="literal">SELECT</code> 権限のみが必要です。 
    </p><h4><a name="idm45827000830704"></a>パフォーマンス</h4><p>
      削除された行数を知る必要がない場合、テーブルを空にするには、<code class="literal">WHERE</code> 句のない <code class="literal">DELETE</code> ステートメントより <code class="literal">TRUNCATE TABLE</code> ステートメントの方が高速です。 <code class="literal">DELETE</code> とは異なり、<code class="literal">TRUNCATE TABLE</code> はトランザクション内で、またはそのテーブルがロックされている場合は使用できません。 <a class="xref" href="sql-statements.html#truncate-table" title="13.1.37 TRUNCATE TABLE ステートメント">セクション13.1.37「TRUNCATE TABLE ステートメント」</a>および<a class="xref" href="sql-statements.html#lock-tables" title="13.3.6 LOCK TABLES および UNLOCK TABLES ステートメント">セクション13.3.6「LOCK TABLES および UNLOCK TABLES ステートメント」</a>を参照してください。 
    </p><p>
      削除操作の速度はまた、<a class="xref" href="optimization.html#delete-optimization" title="8.2.5.3 DELETE ステートメントの最適化">セクション8.2.5.3「DELETE ステートメントの最適化」</a>で説明されている要因によって影響を受ける可能性もあります。
    </p><p>
      特定の <code class="literal">DELETE</code> ステートメントに時間がかかりすぎないようにするために、<code class="literal">DELETE</code> の MySQL 固有の <code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em></code> 句は、削除される行の最大数を指定します。 削除する行数がこの制限を超えている場合は、影響を受ける行数が <code class="literal">LIMIT</code> 値を下回るまで <code class="literal">DELETE</code> ステートメントを繰り返します。 
    </p><h4><a name="idm45827000816160"></a>サブクエリー</h4><p>
      テーブルから削除して、サブクエリーの同じテーブルから選択することはできません。
    </p><h4><a name="idm45827000814816"></a>パーティションテーブルのサポート</h4><p>
      <code class="literal">DELETE</code> では、<code class="literal">PARTITION</code> オプションを使用した明示的なパーティション選択がサポートされています。このオプションは、削除する行を選択するパーティションまたはサブパーティション (あるいはその両方) のカンマ区切り名のリストを取得します。 このリストに含まれていないパーティションは無視されます。 <code class="literal">p0</code> という名前のパーティションを含むパーティション化されたテーブル <code class="literal">t</code> がある場合、ステートメント <code class="literal">DELETE FROM t PARTITION (p0)</code> の実行には、このテーブルに対して <code class="literal">ALTER TABLE t TRUNCATE PARTITION (p0)</code> を実行するのと同じ効果があります。どちらの場合も、パーティション <code class="literal">p0</code> 内のすべての行が削除されます。 
    </p><p>
      <code class="literal">PARTITION</code> は、<code class="literal">WHERE</code> 条件とともに使用できます。その場合、この条件は、リストされているパーティション内の行に対してのみテストされます。 たとえば、<code class="literal">DELETE FROM t PARTITION (p0) WHERE c &lt; 5</code> は、条件 <code class="literal">c &lt; 5</code> が true であるパーティション <code class="literal">p0</code> の行のみを削除します。ほかのパーティション内の行はチェックされないため、<code class="literal">DELETE</code> によって影響を受けません。 
    </p><p>
      <code class="literal">PARTITION</code> オプションはまた、複数テーブルの <code class="literal">DELETE</code> ステートメントでも使用できます。 このようなオプションを、<code class="literal">FROM</code> オプションで指定されているテーブルごとに最大 1 つ使用できます。 
    </p><p>
      詳細および例については、<a class="xref" href="partitioning.html#partitioning-selection" title="24.5 パーティション選択">セクション24.5「パーティション選択」</a>を参照してください。
    </p><h4><a name="idm45827000796672"></a>自動インクリメントカラム</h4><p>
      <code class="literal">AUTO_INCREMENT</code> カラムに最大値を含む行を削除した場合、その値は、<code class="literal">MyISAM</code> または <code class="literal">InnoDB</code> テーブルには再利用されません。 <code class="literal">autocommit</code> モードで <code class="literal">DELETE FROM <em class="replaceable"><code>tbl_name</code></em></code> (<code class="literal">WHERE</code> 句はなし) を使用してテーブル内のすべての行を削除した場合、そのシーケンスは、<code class="literal">InnoDB</code> と <code class="literal">MyISAM</code> を除くすべてのストレージエンジンに対して開始されます。 <a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-handling" title="15.6.1.6 InnoDB での AUTO_INCREMENT 処理">セクション15.6.1.6「InnoDB での AUTO_INCREMENT 処理」</a>で説明されているように、<code class="literal">InnoDB</code> テーブルに対しては、この動作の例外がいくつかあります。 
    </p><p>
      <code class="literal">MyISAM</code> テーブルの場合は、マルチカラムキー内の <code class="literal">AUTO_INCREMENT</code> セカンダリカラムを指定できます。 この場合は、シーケンスの先頭から削除された値の再利用が <code class="literal">MyISAM</code> テーブルに対しても実行されます。 <a class="xref" href="tutorial.html#example-auto-increment" title="3.6.9 AUTO_INCREMENT の使用">セクション3.6.9「AUTO_INCREMENT の使用」</a>を参照してください。 
    </p><h4><a name="idm45827000783408"></a>修飾子</h4><p>
      <code class="literal">DELETE</code> ステートメントは、次の修飾子をサポートします。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">LOW_PRIORITY</code> 修飾子を指定すると、他のクライアントがテーブルから読み取ることがなくなるまで、サーバーは <code class="literal">DELETE</code> の実行を遅延します。 これは、テーブルレベルロックのみを使用するストレージエンジン (<code class="literal">MyISAM</code>、<code class="literal">MEMORY</code>、および <code class="literal">MERGE</code>) にのみ影響を与えます。 
        </p><a class="indexterm" name="idm45827000776016"></a></li><li class="listitem"><p>
          <code class="literal">MyISAM</code> テーブルの場合、<code class="literal">QUICK</code> 修飾子を使用すると、ストレージエンジンは削除中にインデックスリーフをマージしないため、一部の種類の削除操作が高速になる可能性があります。
        </p><a class="indexterm" name="idm45827000771552"></a></li><li class="listitem"><p>
          <code class="literal">IGNORE</code> 修飾子を使用すると、MySQL は行の削除処理中に無視できるエラーを無視します。 (解析の段階で検出されたエラーは、通常の方法で処理されます。) <code class="literal">IGNORE</code> の使用のために無視されたエラーは、警告として返されます。 詳細は、<a class="xref" href="server-administration.html#ignore-effect-on-execution" title="IGNORE がステートメントの実行に与える影響">IGNORE がステートメントの実行に与える影響</a>を参照してください。 
        </p><a class="indexterm" name="idm45827000766192"></a></li></ul></div><h4><a name="idm45827000764064"></a>削除の順序</h4><p>
      <code class="literal">DELETE</code> ステートメントに <code class="literal">ORDER BY</code> 句が含まれている場合は、この句で指定されている順序で行が削除されます。 これは、主に <code class="literal">LIMIT</code> と組み合わせて使用した場合に有効です。 たとえば、次のステートメントは <code class="literal">WHERE</code> 句に一致する行を見つけ、それらを <code class="literal">timestamp_column</code> でソートしたあと、最初の (もっとも古い) 行を削除します。 
    </p><pre class="programlisting">DELETE FROM somelog WHERE user = 'jcole'
ORDER BY timestamp_column LIMIT 1;
</pre><p>
      <code class="literal">ORDER BY</code> はまた、参照整合性の違反を回避するために必要な順序で行を削除する場合も役立ちます。
    </p><h4><a name="idm45827000756080"></a>InnoDB テーブル</h4><p>
      大きなテーブルから多数の行を削除する場合は、<code class="literal">InnoDB</code> テーブルに対するロックテーブルのサイズを超える可能性があります。 この問題を回避するために、または単にテーブルがロックされたままになる時間を最小限に抑えるために、<code class="literal">DELETE</code> をまったく使用しない次の方法が有効な場合があります。 
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          削除<span class="emphasis"><em>されない</em></span>行を選択して、元のテーブルと同じ構造を持つ空のテーブルに格納します。
        </p><pre class="programlisting">INSERT INTO t_copy SELECT * FROM t WHERE ... ;
</pre></li><li class="listitem"><p>
          <code class="literal">RENAME TABLE</code> を使用して元のテーブルを原子的に移動したあと、コピーの名前を元の名前に変更します。
        </p><pre class="programlisting">RENAME TABLE t TO t_old, t_copy TO t;
</pre></li><li class="listitem"><p>
          元のテーブルを削除します。
        </p><pre class="programlisting">DROP TABLE t_old;
</pre></li></ol></div><p>
      <code class="literal">RENAME TABLE</code> が実行されている間、関連するテーブルにはほかのどのセッションからもアクセスできないため、名前変更の操作は並列性の問題に制約されません。 <a class="xref" href="sql-statements.html#rename-table" title="13.1.36 RENAME TABLE ステートメント">セクション13.1.36「RENAME TABLE ステートメント」</a>を参照してください。 
    </p><h4><a name="idm45827000741936"></a>MyISAM テーブル</h4><p>
      <code class="literal">MyISAM</code> テーブルでは、削除された行はリンクリスト内に保持され、以降の <code class="literal">INSERT</code> 操作は古い行の位置を再利用します。 未使用領域を再利用し、ファイルサイズを減らすには、<code class="literal">OPTIMIZE TABLE</code> ステートメントまたは <span class="command"><strong>myisamchk</strong></span> ユーティリティーを使用してテーブルを再編成します。 <code class="literal">OPTIMIZE TABLE</code> の方が使い方は簡単ですが、<span class="command"><strong>myisamchk</strong></span> の方が高速です。 <a class="xref" href="sql-statements.html#optimize-table" title="13.7.3.4 OPTIMIZE TABLE ステートメント">セクション13.7.3.4「OPTIMIZE TABLE ステートメント」</a>および<a class="xref" href="programs.html#myisamchk" title="4.6.4 myisamchk — MyISAM テーブルメンテナンスユーティリティー">セクション4.6.4「myisamchk — MyISAM テーブルメンテナンスユーティリティー」</a>を参照してください。 
    </p><p>
      <code class="literal">QUICK</code> 修飾子は、削除操作でインデックスリーフがマージされるかどうかに影響を与えます。 <code class="literal">DELETE QUICK</code> は、削除された行のインデックス値が、あとで挿入された行の同様のインデックス値に置き換えられるアプリケーションで、特に役立ちます。 この場合、削除された値によって残された穴は再利用されます。 
    </p><p>
      <code class="literal">DELETE QUICK</code> は、削除された値によって、新しい挿入が再度発生するインデックス値の範囲全体にわたって空きのあるインデックスブロックが残される場合には役立ちません。 この場合は、<code class="literal">QUICK</code> を使用すると、再利用されないままのインデックスで領域が浪費される可能性があります。 このようなシナリオの例を次に示します。 
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          インデックス付き <code class="literal">AUTO_INCREMENT</code> カラムを含むテーブルを作成します。
        </p></li><li class="listitem"><p>
          このテーブルに多数の行を挿入します。 各挿入によって、インデックスの先頭に追加されるインデックス値が生成されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">DELETE QUICK</code> を使用して、カラムの範囲の最後にある行のブロックを削除します。
        </p></li></ol></div><p>
      このシナリオでは、削除されたインデックス値に関連付けられたインデックスブロックに空きができますが、<code class="literal">QUICK</code> が使用されているため、ほかのインデックスブロックにはマージされません。 新しい挿入が発生したとき、新しい行には削除された範囲内のインデックス値が含まれていないため、これらのインデックスブロックは空きがあるままになります。 さらに、削除された一部のインデックス値が偶然に空きのあるブロック内か、またはその隣のインデックスブロックに含まれていないかぎり、あとで <code class="literal">QUICK</code> なしで <code class="literal">DELETE</code> を使用した場合でも空きがあるままになります。 これらの状況で未使用のインデックス領域を再利用するには、<code class="literal">OPTIMIZE TABLE</code> を使用します。 
    </p><p>
      テーブルから多数の行を削除しようとしている場合は、<code class="literal">DELETE QUICK</code> に続けて <code class="literal">OPTIMIZE TABLE</code> を使用した方が高速になることがあります。 これにより、インデックスブロックの多数のマージ操作が実行されるのではなく、インデックスが再構築されます。 
    </p><h4><a name="idm45827000715168"></a>複数テーブルの削除</h4><p>
      <code class="literal">WHERE</code> 句内の条件に応じて 1 つ以上のテーブルから行を削除するには、<code class="literal">DELETE</code> ステートメントで複数のテーブルを指定できます。 複数テーブルの <code class="literal">DELETE</code> では、<code class="literal">ORDER BY</code> または <code class="literal">LIMIT</code> を使用できません。 <a class="xref" href="sql-statements.html#join" title="13.2.10.2 JOIN 句">セクション13.2.10.2「JOIN 句」</a>で説明されているように、<em class="replaceable"><code>table_references</code></em> 句は、結合に含まれるテーブルをリストします。 
    </p><p>
      最初の複数テーブル構文では、<code class="literal">FROM</code> 句の前にリストされているテーブルの一致する行のみが削除されます。 2 番目の複数テーブル構文では、<code class="literal">USING</code> 句の前にある <code class="literal">FROM</code> 句にリストされているテーブルの一致する行のみが削除されます。 その効果は、多数のテーブルの行を同時に削除し、さらに検索にのみ使用される追加のテーブルを指定できることです。 
    </p><pre class="programlisting">DELETE t1, t2 FROM t1 INNER JOIN t2 INNER JOIN t3
WHERE t1.id=t2.id AND t2.id=t3.id;
</pre><p>
      または:
    </p><pre class="programlisting">DELETE FROM t1, t2 USING t1 INNER JOIN t2 INNER JOIN t3
WHERE t1.id=t2.id AND t2.id=t3.id;
</pre><p>
      これらのステートメントは、削除する行を検索するときに 3 つのすべてのテーブルを使用しますが、テーブル <code class="literal">t1</code> と <code class="literal">t2</code> の一致する行のみを削除します。
    </p><p>
      前の例では <code class="literal">INNER JOIN</code> を使用していますが、複数テーブルの <code class="literal">DELETE</code> ステートメントは、<code class="literal">SELECT</code> ステートメント内で許可されているほかの型の結合 (<code class="literal">LEFT JOIN</code> など) を使用できます。 たとえば、<code class="literal">t1</code> 内に存在する行で <code class="literal">t2</code> 内に一致するものがない行を削除するには、<code class="literal">LEFT JOIN</code> を使用します。 
    </p><pre class="programlisting">DELETE t1 FROM t1 LEFT JOIN t2 ON t1.id=t2.id WHERE t2.id IS NULL;
</pre><p>
      この構文では、<span class="command"><strong>Access</strong></span> との互換性のために、各 <em class="replaceable"><code>tbl_name</code></em> のあとに <code class="literal">.*</code> が許可されます。
    </p><p>
      外部キー制約が存在する <code class="literal">InnoDB</code> テーブルを含む、複数テーブルの <code class="literal">DELETE</code> ステートメントを使用した場合は、MySQL オプティマイザが、それらの親子関係の順序とは異なる順序でテーブルを処理する可能性があります。 この場合、このステートメントは失敗し、ロールバックされます。 代わりに、1 つのテーブルから削除したあと、<code class="literal">InnoDB</code> が提供する <code class="literal">ON DELETE</code> 機能を使用して、ほかのテーブルがそれに応じて変更されるようにしてください。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        テーブルのエイリアスを宣言した場合は、テーブルを参照するときにそのエイリアスを使用する必要があります。
      </p><pre class="programlisting">DELETE t1 FROM test AS t1, test2 WHERE ...
</pre></div><p>
      複数テーブルの <code class="literal">DELETE</code> 内のテーブルエイリアスは、そのステートメントの <em class="replaceable"><code>table_references</code></em> 部分でのみ宣言するようにしてください。 それ以外の場所では、エイリアス参照が許可されますが、エイリアス宣言は許可されません。 
    </p><p>
      正しい:
    </p><pre class="programlisting">DELETE a1, a2 FROM t1 AS a1 INNER JOIN t2 AS a2
WHERE a1.id=a2.id;

DELETE FROM a1, a2 USING t1 AS a1 INNER JOIN t2 AS a2
WHERE a1.id=a2.id;
</pre><p>
      正しくない:
    </p><pre class="programlisting">DELETE t1 AS a1, t2 AS a2 FROM t1 INNER JOIN t2
WHERE a1.id=a2.id;

DELETE FROM t1 AS a1, t2 AS a2 USING t1 INNER JOIN t2
WHERE a1.id=a2.id;
</pre><p>
      テーブルのエイリアスは、MySQL 8.0.16 以降の単一テーブルの <code class="literal">DELETE</code> ステートメントでもサポートされています。 (Bug #89410、Bug #27455809) 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="do"></a>13.2.3 DO ステートメント</h3></div></div></div><a class="indexterm" name="idm45827000675872"></a><pre class="programlisting">DO <em class="replaceable"><code>expr</code></em> [, <em class="replaceable"><code>expr</code></em>] ...
</pre><p>
      <code class="literal">DO</code> は式を実行しますが、結果は何も返しません。 ほとんどの点で、<code class="literal">DO</code> は <code class="literal">SELECT <em class="replaceable"><code>expr</code></em>, ...</code> の短縮形ですが、その結果に関心がない場合は少し高速であるという利点があります。 
    </p><p>
      <code class="literal">DO</code> は主に、副作用がある関数 (<code class="literal">RELEASE_LOCK()</code> など) で役立ちます。
    </p><p>
      例: この <code class="literal">SELECT</code> ステートメントは一時停止しますが、結果セットの生成も行います。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT SLEEP(5);</code></strong>
+----------+
| SLEEP(5) |
+----------+
|        0 |
+----------+
1 row in set (5.02 sec)
</pre><p>
      それに対して、<code class="literal">DO</code> は、結果セットを生成することなく一時停止します。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>DO SLEEP(5);</code></strong>
Query OK, 0 rows affected (4.99 sec)
</pre><p>
      これは、たとえば、結果セットを生成するステートメントを禁止しているストアドファンクションまたはトリガーで役立つ場合があります。
    </p><p>
      <code class="literal">DO</code> は式を実行するだけです。 <code class="literal">SELECT</code> を使用できるすべての場合に使用できるわけではありません。 たとえば、<code class="literal">DO id FROM t1</code> は、テーブルを参照するため無効です。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="handler"></a>13.2.4 HANDLER ステートメント</h3></div></div></div><a class="indexterm" name="idm45827000651600"></a><pre class="programlisting">HANDLER <em class="replaceable"><code>tbl_name</code></em> OPEN [ [AS] <em class="replaceable"><code>alias</code></em>]

HANDLER <em class="replaceable"><code>tbl_name</code></em> READ <em class="replaceable"><code>index_name</code></em> { = | &lt;= | &gt;= | &lt; | &gt; } (<em class="replaceable"><code>value1</code></em>,<em class="replaceable"><code>value2</code></em>,...)
    [ WHERE <em class="replaceable"><code>where_condition</code></em> ] [LIMIT ... ]
HANDLER <em class="replaceable"><code>tbl_name</code></em> READ <em class="replaceable"><code>index_name</code></em> { FIRST | NEXT | PREV | LAST }
    [ WHERE <em class="replaceable"><code>where_condition</code></em> ] [LIMIT ... ]
HANDLER <em class="replaceable"><code>tbl_name</code></em> READ { FIRST | NEXT }
    [ WHERE <em class="replaceable"><code>where_condition</code></em> ] [LIMIT ... ]

HANDLER <em class="replaceable"><code>tbl_name</code></em> CLOSE
</pre><p>
      <code class="literal">HANDLER</code> ステートメントは、テーブルストレージエンジンインタフェースへの直接アクセスを提供します。 これは、<code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> テーブルに使用できます。 
    </p><p>
      <code class="literal">HANDLER ... OPEN</code> ステートメントはテーブルを開き、それを以降の <code class="literal">HANDLER ... READ</code> ステートメントを使用してアクセス可能にします。 このテーブルオブジェクトはほかのセッションによって共有されておらず、このセッションが <code class="literal">HANDLER ... CLOSE</code> を呼び出すか、またはこのセッションが終了するまでクローズされません。 
    </p><p>
      エイリアスを使用してテーブルを開いた場合は、その開かれたテーブルへのほかの <code class="literal">HANDLER</code> ステートメントによるそれ以降の参照は、テーブル名ではなくエイリアスを使用する必要があります。 エイリアスを使用せずに、データベース名で修飾されたテーブル名を使用してテーブルを開く場合、以降の参照では修飾されていないテーブル名を使用する必要があります。 たとえば、<code class="literal">mydb.mytable</code> を使用して開いたテーブルの場合、さらに参照するには <code class="literal">mytable</code> を使用する必要があります。 
    </p><p>
      最初の <code class="literal">HANDLER ... READ</code> 構文は、指定されたインデックスが特定の値を満たし、かつ <code class="literal">WHERE</code> 条件が満たされている行をフェッチします。 マルチカラムインデックスがある場合は、インデックスカラム値をカンマ区切りリストとして指定します。 インデックス内のすべてのカラムの値を指定するか、またはインデックスカラムの左端のプリフィクスの値を指定します。 インデックス <code class="literal">my_idx</code> に、<code class="literal">col_a</code>、<code class="literal">col_b</code>、および <code class="literal">col_c</code> という名前の 3 つのカラムがその順序で含まれているとします。 <code class="literal">HANDLER</code> ステートメントは、そのインデックス内の 3 つのすべてのカラム、または左端のプリフィクス内のカラムの値を指定できます。 例: 
    </p><pre class="programlisting">HANDLER ... READ my_idx = (col_a_val,col_b_val,col_c_val) ...
HANDLER ... READ my_idx = (col_a_val,col_b_val) ...
HANDLER ... READ my_idx = (col_a_val) ...
</pre><p>
      <code class="literal">HANDLER</code> インタフェースを使用してテーブルの <code class="literal">PRIMARY KEY</code> を参照するには、引用符で囲まれた識別子 <code class="literal">`PRIMARY`</code> を使用します。
    </p><pre class="programlisting">HANDLER <em class="replaceable"><code>tbl_name</code></em> READ `PRIMARY` ...
</pre><p>
      2 番目の <code class="literal">HANDLER ... READ</code> 構文は、<code class="literal">WHERE</code> 条件に一致するインデックス順序でテーブルの行をフェッチします。
    </p><p>
      3 番目の <code class="literal">HANDLER ... READ</code> 構文は、<code class="literal">WHERE</code> 条件に一致する自然な行順序でテーブルの行をフェッチします。 これは、フルテーブルスキャンが望ましい場合は、<code class="literal">HANDLER <em class="replaceable"><code>tbl_name</code></em> READ <em class="replaceable"><code>index_name</code></em></code> より高速です。 自然な行順序とは、行が <code class="literal">MyISAM</code> テーブルデータファイル内に格納されている順序のことです。 このステートメントは <code class="literal">InnoDB</code> テーブルに対しても機能しますが、個別のデータファイルが存在しないため、このような概念はありません。 
    </p><p>
      <code class="literal">LIMIT</code> 句を使用しない場合は、すべての形式の <code class="literal">HANDLER ... READ</code> が単一行 (使用可能な場合) をフェッチします。 特定の行数を返すには、<code class="literal">LIMIT</code> 句を含めます。 その構文は、<code class="literal">SELECT</code> ステートメントの場合と同じです。 <a class="xref" href="sql-statements.html#select" title="13.2.10 SELECT ステートメント">セクション13.2.10「SELECT ステートメント」</a>を参照してください。 
    </p><p>
      <code class="literal">HANDLER ... CLOSE</code> は、<code class="literal">HANDLER ... OPEN</code> でオープンされたテーブルをクローズします。
    </p><p>
      通常の <code class="literal">SELECT</code> ステートメントの代わりに <code class="literal">HANDLER</code> インタフェースを使用する理由として、次のいくつかがあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">HANDLER</code> は <code class="literal">SELECT</code> より高速です。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">HANDLER ... OPEN</code> に対して、指定されたストレージエンジンハンドラオブジェクトが割り当てられます。 このオブジェクトは、そのテーブルに対する以降の <code class="literal">HANDLER</code> ステートメントに再利用されます。ステートメントごとに再初期化する必要はありません。 
            </p></li><li class="listitem"><p>
              関連する解析が少なくなります。
            </p></li><li class="listitem"><p>
              オプティマイザまたはクエリーチェックのオーバーヘッドがありません。
            </p></li><li class="listitem"><p>
              ハンドラインタフェースは (たとえば、<a class="link" href="glossary.html#glos_dirty_read" title="ダーティー読み取り">ダーティー読み取り</a>が許可されるような) データの整合性のある外観を提供する必要がないため、ストレージエンジンは、<code class="literal">SELECT</code> が通常は許可しない最適化を使用できます。
            </p></li></ul></div></li><li class="listitem"><p>
          <code class="literal">HANDLER</code> によって、<code class="literal">ISAM</code> に似た低レベルのインタフェースを使用する MySQL アプリケーションへの移植が容易になります。 (キー値格納パラダイムを使用するアプリケーションを適応させるための代替手段については、<a class="xref" href="innodb-storage-engine.html#innodb-memcached" title="15.20 InnoDB memcached プラグイン">セクション15.20「InnoDB memcached プラグイン」</a>を参照してください。) 
        </p></li><li class="listitem"><p>
          <code class="literal">HANDLER</code> を使用すると、<code class="literal">SELECT</code> では実現が困難な (または、不可能でさえある) 方法でデータベースをたどることができます。 <code class="literal">HANDLER</code> インタフェースは、データベースに対話型ユーザーインタフェースを提供するアプリケーションの操作時にデータを調べるためのより自然な方法です。 
        </p></li></ul></div><p>
      <code class="literal">HANDLER</code> は、やや低レベルのステートメントです。 たとえば、一貫性が提供されません。 つまり、<code class="literal">HANDLER ... OPEN</code> はテーブルのスナップショットを作成<span class="emphasis"><em>せず</em></span>、テーブルのロックも行い<span class="emphasis"><em>ません</em></span>。 これは、<code class="literal">HANDLER ... OPEN</code> ステートメントが発行されたあと、テーブルデータを (現在のセッションまたはその他のセッションで) 変更することができ、これらの変更が <code class="literal">HANDLER ... NEXT</code> または <code class="literal">HANDLER ... PREV</code> スキャンに部分的にしか表示されない可能性があることを示します。 
    </p><p>
      開かれたハンドラを閉じ、再度開くようにマークすることができます。その場合、このハンドラはテーブル内の位置を失います。 これは、次の両方の状況が当てはまる場合に発生します。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          このハンドラのテーブルに対して、いずれかのセッションが <code class="literal">FLUSH TABLES</code> または DDL ステートメントを実行している。
        </p></li><li class="listitem"><p>
          このハンドラを開いているセッションが、テーブルを使用する <code class="literal">HANDLER</code> 以外のステートメントを実行している。
        </p></li></ul></div><p>
      テーブルに対する <code class="literal">TRUNCATE TABLE</code> は、<code class="literal">HANDLER OPEN</code> で開かれたそのテーブルのすべてのハンドラを閉じます。
    </p><p>
      <code class="literal">FLUSH TABLES <em class="replaceable"><code>tbl_name</code></em> WITH READ LOCK</code> でフラッシュされたテーブルが <code class="literal">HANDLER</code> で開かれた場合、そのハンドラは暗黙的にフラッシュされ、その位置を失います。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="import-table"></a>13.2.5 IMPORT TABLE ステートメント</h3></div></div></div><a class="indexterm" name="idm45827000564800"></a><a class="indexterm" name="idm45827000563744"></a><a class="indexterm" name="idm45827000562720"></a><pre class="programlisting">IMPORT TABLE FROM <em class="replaceable"><code>sdi_file</code></em> [, <em class="replaceable"><code>sdi_file</code></em>] ...
</pre><p>
      <code class="literal">IMPORT TABLE</code> ステートメントは、<code class="filename">.sdi</code> (シリアライズディクショナリ情報) メタデータファイルに含まれる情報に基づいて <code class="literal">MyISAM</code> テーブルをインポートします。 <code class="literal">IMPORT TABLE</code> には、<code class="filename">.sdi</code> およびテーブルコンテンツファイルを読み取るための <code class="literal">FILE</code> 権限と、作成するテーブルに対する <code class="literal">CREATE</code> 権限が必要です。 
    </p><p>
      <span class="command"><strong>mysqldump</strong></span> を使用してあるサーバーからテーブルをエクスポートし、SQL ステートメントのファイルを書き込み、<span class="command"><strong>mysql</strong></span> を使用して別のサーバーにインポートしてダンプファイルを処理できます。 <code class="literal">IMPORT TABLE</code> は、<span class="quote">「<span class="quote">raw</span>」</span> テーブルファイルを使用して、より高速な代替方法を提供します。 
    </p><p>
      インポートする前に、テーブルの内容を提供するファイルをインポートサーバーの適切なスキーマディレクトリに配置し、<code class="filename">.sdi</code> ファイルをサーバーからアクセス可能なディレクトリに配置する必要があります。 たとえば、<code class="filename">.sdi</code> ファイルは、<code class="literal">secure_file_priv</code> システム変数で指定されたディレクトリ、または (<code class="literal">secure_file_priv</code> が空の場合は) サーバーデータディレクトリの下のディレクトリに配置できます。 
    </p><p>
      次の例では、<code class="literal">employees</code> および <code class="literal">managers</code> という名前の <code class="literal">MyISAM</code> テーブルをあるサーバーの <code class="literal">hr</code> スキーマからエクスポートし、別のサーバーの <code class="literal">hr</code> スキーマにインポートする方法について説明します。 この例では、次の前提を使用しています (独自のシステムで同様の操作を実行するには、必要に応じてパス名を変更します): 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          エクスポートサーバーの場合、<em class="replaceable"><code>export_basedir</code></em> はベースディレクトリを表し、そのデータディレクトリは<code class="filename"> <em class="replaceable"><code>export_basedir</code></em>/data</code> です。
        </p></li><li class="listitem"><p>
          インポートサーバーの場合、<em class="replaceable"><code>import_basedir</code></em> はベースディレクトリを表し、そのデータディレクトリは<code class="filename"> <em class="replaceable"><code>import_basedir</code></em>/data</code> です。
        </p></li><li class="listitem"><p>
          テーブルファイルはエクスポートサーバーから<code class="filename">/tmp/export</code> ディレクトリにエクスポートされ、このディレクトリはセキュアです (他のユーザーはアクセスできません)。
        </p></li><li class="listitem"><p>
          インポートサーバーは、<code class="literal">secure_file_priv</code> システム変数で指定されたディレクトリとして<code class="filename">/tmp/mysql-files</code> を使用します。
        </p></li></ul></div><p>
      エクスポートサーバーからテーブルをエクスポートするには、この手順を使用します:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          エクスポート中に変更できないように、次のステートメントを実行してテーブルをロックし、一貫性のあるスナップショットを確認します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>FLUSH TABLES hr.employees, hr.managers WITH READ LOCK;</code></strong>
</pre><p>
          ロックが有効な間は、テーブルは引き続き使用できますが、読取りアクセスにのみ使用できます。
        </p></li><li class="listitem"><p>
          ファイルシステムレベルで、<code class="filename">.sdi</code> およびテーブルコンテンツファイルを <code class="literal">hr</code> スキーマディレクトリからセキュアエクスポートディレクトリにコピーします:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">.sdi</code> ファイルは <code class="literal">hr</code> スキーマディレクトリにありますが、テーブル名とまったく同じベース名を持っていない可能性があります。 たとえば、<code class="literal">employees</code> テーブルおよび <code class="literal">managers</code> テーブルの <code class="filename">.sdi</code> ファイルには、<code class="filename">employees_125.sdi</code> および <code class="filename">managers_238.sdi</code> という名前が付けられます。 
            </p></li><li class="listitem"><p>
              <code class="literal">MyISAM</code> テーブルの場合、コンテンツファイルはその <code class="filename">.MYD</code> データファイルおよび <code class="filename">.MYI</code> インデックスファイルです。
            </p></li></ul></div><p>
          これらのファイル名を指定すると、コピーコマンドは次のようになります:
        </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>cd <em class="replaceable"><code>export_basedir</code></em>/data/hr</code></strong>
shell&gt; <strong class="userinput"><code>cp employees_125.sdi /tmp/export</code></strong>
shell&gt; <strong class="userinput"><code>cp managers_238.sdi /tmp/export</code></strong>
shell&gt; <strong class="userinput"><code>cp employees.{MYD,MYI} /tmp/export</code></strong>
shell&gt; <strong class="userinput"><code>cp managers.{MYD,MYI} /tmp/export</code></strong>
</pre></li><li class="listitem"><p>
          テーブルのロックを解除します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UNLOCK TABLES;</code></strong>
</pre></li></ol></div><p>
      インポートサーバーにテーブルをインポートするには、次の手順を使用します:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          インポートスキーマが存在する必要があります。 必要に応じて、次のステートメントを実行して作成します: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE SCHEMA hr;</code></strong>
</pre></li><li class="listitem"><p>
          ファイルシステムレベルで、<code class="filename">.sdi</code> ファイルをインポートサーバーの <code class="literal">secure_file_priv</code> ディレクトリ<code class="filename">/tmp/mysql-files</code> にコピーします。 また、テーブルコンテンツファイルを <code class="literal">hr</code> スキーマディレクトリにコピーします: 
        </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>cd /tmp/export</code></strong>
shell&gt; <strong class="userinput"><code>cp employees_125.sdi /tmp/mysql-files</code></strong>
shell&gt; <strong class="userinput"><code>cp managers_238.sdi /tmp/mysql-files</code></strong>
shell&gt; <strong class="userinput"><code>cp employees.{MYD,MYI} <em class="replaceable"><code>import_basedir</code></em>/data/hr</code></strong>
shell&gt; <strong class="userinput"><code>cp managers.{MYD,MYI} <em class="replaceable"><code>import_basedir</code></em>/data/hr</code></strong>
</pre></li><li class="listitem"><p>
          <code class="filename">.sdi</code> ファイルを指定する <code class="literal">IMPORT TABLE</code> ステートメントを実行して、テーブルをインポートします:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>IMPORT TABLE FROM</code></strong>
       <strong class="userinput"><code>'/tmp/mysql-files/employees.sdi',</code></strong>
       <strong class="userinput"><code>'/tmp/mysql-files/managers.sdi';</code></strong>
</pre></li></ol></div><p>
      <code class="filename">.sdi</code> ファイルは、その変数が空の場合、<code class="literal">secure_file_priv</code> システム変数で指定されたインポートサーバーディレクトリに配置する必要はありません。インポートされたテーブルのスキーマディレクトリを含め、サーバーからアクセス可能な任意のディレクトリに配置できます。 ただし、<code class="filename">.sdi</code> ファイルがそのディレクトリに配置されている場合は、リライトされる可能性があります。インポート操作では、テーブルに対して新しい <code class="filename">.sdi</code> ファイルが作成され、操作で新しいファイルに同じファイル名が使用されている場合は古い <code class="filename">.sdi</code> ファイルが上書きされます。 
    </p><p>
      各 <em class="replaceable"><code>sdi_file</code></em> 値は、テーブルの <code class="filename">.sdi</code> ファイルを指定する文字列リテラルであるか、<code class="filename">.sdi</code> ファイルと一致するパターンである必要があります。 文字列がパターンの場合は、先頭のディレクトリパスおよび <code class="filename">.sdi</code> ファイル名の接尾辞を文字どおりに指定する必要があります。 パターン文字は、ファイル名のベース名部分でのみ使用できます: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">?</code> は任意の 1 文字に一致します
        </p></li><li class="listitem"><p>
          <code class="literal">*</code> は、文字を含まない任意の文字シーケンスに一致
        </p></li></ul></div><p>
      パターンを使用すると、前の <code class="literal">IMPORT TABLE</code> ステートメントが次のように記述されている可能性があります (<code class="filename">/tmp/mysql-files</code> ディレクトリにパターンに一致する他の <code class="filename">.sdi</code> ファイルが含まれていないことを前提としています):
    </p><pre class="programlisting">IMPORT TABLE FROM '/tmp/mysql-files/*.sdi';
</pre><p>
      <code class="filename">.sdi</code> ファイルパス名の場所を解釈するために、サーバーは <code class="literal">LOAD DATA</code> のサーバー側ルールと同じルール (<code class="literal">LOCAL</code> 以外のルール) を <code class="literal">IMPORT TABLE</code> に使用します。 <a class="xref" href="sql-statements.html#load-data" title="13.2.7 LOAD DATA ステートメント">セクション13.2.7「LOAD DATA ステートメント」</a> を参照してください。相対パス名の解釈に使用されるルールに特に注意してください。 
    </p><p>
      <code class="literal">.sdi</code> またはテーブルファイルが見つからない場合、<code class="literal">IMPORT TABLE</code> は失敗します。 テーブルをインポートすると、サーバーはテーブルを開こうとし、検出された問題を警告として報告します。 修復を試行して報告された問題を修正するには、<code class="literal">REPAIR TABLE</code> を使用します。 
    </p><p>
      <code class="literal">IMPORT TABLE</code> はバイナリログに書き込まれません。
    </p><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="import-table-restrictions"></a>制約と制限</h4></div></div></div><p>
        <code class="literal">IMPORT TABLE</code> は、<code class="literal">TEMPORARY</code> 以外の <code class="literal">MyISAM</code> テーブルにのみ適用されます。 トランザクションストレージエンジンで作成されたテーブル、<code class="literal">CREATE TEMPORARY TABLE</code> で作成されたテーブルまたはビューには適用されません。 
      </p><p>
        インポート操作で使用される <code class="filename">.sdi</code> ファイルは、インポートサーバーと同じデータディクショナリバージョンおよび sdi バージョンのサーバーで生成する必要があります。 生成元サーバーのバージョン情報は、<code class="filename">.sdi</code> ファイルにあります: 
      </p><pre class="programlisting">{
   "mysqld_version_id":80019,
   "dd_version":80017,
   "sdi_version":80016,
   ...
}
</pre><p>
        インポートサーバーのデータディクショナリおよび sdi バージョンを確認するには、インポートサーバーで最近作成されたテーブルの <code class="filename">.sdi</code> ファイルを確認します。
      </p><p>
        テーブルデータおよびインデックスファイルは、エクスポートサーバーで定義されているテーブルで <code class="literal">DATA DIRECTORY</code> または <code class="literal">INDEX DIRECTORY</code> テーブルオプションが使用されていないかぎり、インポート操作の前にインポートサーバーのスキーマディレクトリに配置する必要があります。 その場合は、<code class="literal">IMPORT TABLE</code> ステートメントを実行する前に、次のいずれかの代替方法を使用してインポートプロシージャを変更します: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            データファイルとインデックスファイルをエクスポートサーバーホストと同じディレクトリに配置し、インポートサーバースキーマディレクトリにそれらのファイルへのシンボリックリンクを作成します。
          </p></li><li class="listitem"><p>
            データファイルおよびインデックスファイルをエクスポートサーバーホスト上のものとは異なるインポートサーバーホストディレクトリに配置し、それらのファイルへのシンボリックリンクをインポートサーバースキーマディレクトリに作成します。 また、異なるファイルの場所を反映するように <code class="filename">.sdi</code> ファイルを変更します。 
          </p></li><li class="listitem"><p>
            データおよびインデックスファイルをインポートサーバーホストのスキーマディレクトリに配置し、<code class="filename">.sdi</code> ファイルを変更してデータおよびインデックスディレクトリのテーブルオプションを削除します。
          </p></li></ul></div><p>
        <code class="filename">.sdi</code> ファイルに格納されている照合 ID は、エクスポートサーバーとインポートサーバーで同じ照合を参照する必要があります。
      </p><p>
        テーブルのトリガー情報はテーブル <code class="filename">.sdi</code> ファイルにシリアライズされないため、インポート操作によってトリガーはリストアされません。
      </p><p>
        <code class="filename">.sdi</code> ファイルの一部の編集は <code class="literal">IMPORT TABLE</code> ステートメントの実行前に許可されますが、その他の編集は問題があるか、インポート操作が失敗する可能性があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            データディレクトリおよびインデックスディレクトリテーブルオプションの変更は、データファイルとインデックスファイルの場所がエクスポートサーバーとインポートサーバーで異なる場合に必要です。
          </p></li><li class="listitem"><p>
            エクスポートサーバーとは異なるインポートサーバーのスキーマにテーブルをインポートするには、スキーマ名を変更する必要があります。
          </p></li><li class="listitem"><p>
            エクスポートサーバーとインポートサーバーでのファイルシステムの大/小文字の区別セマンティクスの違いや、<code class="literal">lower_case_table_names</code> 設定の違いに対応するために、スキーマ名とテーブル名の変更が必要になる場合があります。 <code class="filename">.sdi</code> ファイルのテーブル名を変更する場合は、テーブルファイルの名前も変更する必要があります。 
          </p></li><li class="listitem"><p>
            場合によっては、カラム定義の変更が許可されます。 データ型を変更すると、問題が発生する可能性があります。 
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="insert"></a>13.2.6 INSERT ステートメント</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#insert-select">13.2.6.1 INSERT ... SELECT ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#insert-on-duplicate">13.2.6.2 INSERT ... ON DUPLICATE KEY UPDATE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#insert-delayed">13.2.6.3 INSERT DELAYED ステートメント</a></span></dt></dl></div><a class="indexterm" name="idm45827000415344"></a><a class="indexterm" name="idm45827000414032"></a><a class="indexterm" name="idm45827000412688"></a><pre class="programlisting">INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
    [INTO] <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em> [, <em class="replaceable"><code>partition_name</code></em>] ...)]
    [(<em class="replaceable"><code>col_name</code></em> [, <em class="replaceable"><code>col_name</code></em>] ...)]
    { {VALUES | VALUE} (<em class="replaceable"><code>value_list</code></em>) [, (<em class="replaceable"><code>value_list</code></em>)] ...
      |
      VALUES <em class="replaceable"><code>row_constructor_list</code></em>
    }
    [AS <em class="replaceable"><code>row_alias</code></em>[(<em class="replaceable"><code>col_alias</code></em> [, <em class="replaceable"><code>col_alias</code></em>] ...)]]
    [ON DUPLICATE KEY UPDATE <em class="replaceable"><code>assignment_list</code></em>]

INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
    [INTO] <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em> [, <em class="replaceable"><code>partition_name</code></em>] ...)]
    [AS <em class="replaceable"><code>row_alias</code></em>[(<em class="replaceable"><code>col_alias</code></em> [, <em class="replaceable"><code>col_alias</code></em>] ...)]]
    SET <em class="replaceable"><code>assignment_list</code></em>
    [ON DUPLICATE KEY UPDATE <em class="replaceable"><code>assignment_list</code></em>]

INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]
    [INTO] <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em> [, <em class="replaceable"><code>partition_name</code></em>] ...)]
    [(<em class="replaceable"><code>col_name</code></em> [, <em class="replaceable"><code>col_name</code></em>] ...)]
    [AS <em class="replaceable"><code>row_alias</code></em>[(<em class="replaceable"><code>col_alias</code></em> [, <em class="replaceable"><code>col_alias</code></em>] ...)]]
    {SELECT ... | TABLE <em class="replaceable"><code>table_name</code></em>}
    [ON DUPLICATE KEY UPDATE <em class="replaceable"><code>assignment_list</code></em>]

<em class="replaceable"><code>value</code></em>:
    {<em class="replaceable"><code>expr</code></em> | DEFAULT}

<em class="replaceable"><code>value_list</code></em>:
    <em class="replaceable"><code>value</code></em> [, <em class="replaceable"><code>value</code></em>] ...

<em class="replaceable"><code>row_constructor_list</code></em>:
    ROW(<em class="replaceable"><code>value_list</code></em>)[, ROW(<em class="replaceable"><code>value_list</code></em>)][, ...]

<em class="replaceable"><code>assignment</code></em>:
    <em class="replaceable"><code>col_name</code></em> = [<em class="replaceable"><code>row_alias</code></em>.]<em class="replaceable"><code>value</code></em>

<em class="replaceable"><code>assignment_list</code></em>:
    <em class="replaceable"><code>assignment</code></em> [, <em class="replaceable"><code>assignment</code></em>] ...
</pre><p>
      <code class="literal">INSERT</code> は、既存のテーブルに新しい行を挿入します。 <code class="literal">INSERT ... VALUES</code>、<code class="literal">INSERT ... VALUES ROW()</code> および <code class="literal">INSERT ... SET</code> 形式のステートメントは、明示的に指定された値に基づいて行を挿入します。 <code class="literal">INSERT ... SELECT</code> 形式は、別の 1 つまたは複数のテーブルから選択された行を挿入します。 MySQL 8.0.19 以降で <code class="literal">INSERT ... TABLE</code> を使用して、単一のテーブルから行を挿入することもできます。 <code class="literal">INSERT</code> で <code class="literal">ON DUPLICATE KEY UPDATE</code> 句を使用すると、行が挿入されて <code class="literal">UNIQUE</code> インデックスまたは <code class="literal">PRIMARY KEY</code> で値が重複する場合に、既存の行を更新できます。 MySQL 8.0.19 以降では、1 つ以上のオプションのカラムアライスを持つ行エイリアスを <code class="literal">ON DUPLICATE KEY UPDATE</code> で使用して、挿入する行を参照できます。 
    </p><p>
      <code class="literal">INSERT ... SELECT</code> および <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> の詳細は、<a class="xref" href="sql-statements.html#insert-select" title="13.2.6.1 INSERT ... SELECT ステートメント">セクション13.2.6.1「INSERT ... SELECT ステートメント」</a> および <a class="xref" href="sql-statements.html#insert-on-duplicate" title="13.2.6.2 INSERT ... ON DUPLICATE KEY UPDATE ステートメント">セクション13.2.6.2「INSERT ... ON DUPLICATE KEY UPDATE ステートメント」</a> を参照してください。
    </p><p>
      MySQL 8.0 では、<code class="literal">DELAYED</code> キーワードは受け入れられますが、サーバーでは無視されます。 この理由については、<a class="xref" href="sql-statements.html#insert-delayed" title="13.2.6.3 INSERT DELAYED ステートメント">セクション13.2.6.3「INSERT DELAYED ステートメント」</a> を参照してください。 
    </p><p>
      テーブルに挿入するには、そのテーブルに対する <code class="literal">INSERT</code> 権限が必要です。 <code class="literal">ON DUPLICATE KEY UPDATE</code> 句が使用されていて、重複キーのために代わりに <code class="literal">UPDATE</code> が実行される場合、このステートメントには、更新されるカラムに対する <code class="literal">UPDATE</code> 権限が必要です。 読み取られるが、変更されないカラムの場合は、<code class="literal">SELECT</code> 権限のみが必要です (<code class="literal">ON DUPLICATE KEY UPDATE</code> 句にある <em class="replaceable"><code>col_name</code></em>=<em class="replaceable"><code>expr</code></em> 割り当ての右側でのみ参照されるカラムの場合など)。 
    </p><p>
      パーティションテーブルに挿入する場合、新しい行を受け入れるパーティションおよびサブパーティションを制御できます。 <code class="literal">PARTITION</code> オプションは、テーブルのパーティションまたはサブパーティション (あるいはその両方) のカンマ区切りの名前のリストを取ります。 特定の <code class="literal">INSERT</code> ステートメントによって挿入される行がリストされているいずれかのパーティションに一致しない場合、<code class="literal">INSERT</code> ステートメントは<span class="errortext">Found a row not matching the given partition set</span>エラーで失敗します。 詳細および例については、<a class="xref" href="partitioning.html#partitioning-selection" title="24.5 パーティション選択">セクション24.5「パーティション選択」</a>を参照してください。 
    </p><p>
      <em class="replaceable"><code>tbl_name</code></em> は、行が挿入されるテーブルです。 ステートメントが値を提供するカラムを次のように指定します: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          テーブル名の後にカンマ区切りのカラム名のカッコ付きリストを指定します。 この場合、各名前付きカラムの値は、<code class="literal">VALUES</code> リスト、<code class="literal">VALUES ROW()</code> リストまたは <code class="literal">SELECT</code> ステートメントで指定する必要があります。 <code class="literal">INSERT TABLE</code> フォームの場合、ソーステーブルのカラム数は挿入されるカラム数と一致する必要があります。 
        </p></li><li class="listitem"><p>
          <code class="literal">INSERT ... VALUES</code> または <code class="literal">INSERT ... SELECT</code> のカラム名のリストを指定しない場合は、テーブル内のすべてのカラムの値を <code class="literal">VALUES</code> リスト、<code class="literal">SELECT</code> ステートメントまたは <code class="literal">TABLE</code> ステートメントで指定する必要があります。 テーブル内のカラムの順序がわからない場合は、<code class="literal">DESCRIBE <em class="replaceable"><code>tbl_name</code></em></code> を使用して見つけます。 
        </p></li><li class="listitem"><p>
          <code class="literal">SET</code> 句は、各カラムに割り当てる値とともに、カラムを名前で明示的に指定します。
        </p></li></ul></div><p>
      カラム値は、次のいくつかの方法で指定できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          厳密な SQL モードが有効になっていない場合、値が明示的に指定されていないカラムはデフォルト (明示的または暗黙的) 値に設定されます。 たとえば、テーブル内のすべてのカラムを指定していないカラムリストを指定した場合、指定されていないカラムはそのデフォルト値に設定されます。 デフォルト値の割り当てについては、<a class="xref" href="data-types.html#data-type-defaults" title="11.6 データ型デフォルト値">セクション11.6「データ型デフォルト値」</a>で説明されています。 <a class="xref" href="introduction.html#constraint-invalid-data" title="1.7.3.3 無効なデータに対する制約の施行">セクション1.7.3.3「無効なデータに対する制約の施行」</a>も参照してください。 
        </p><a class="indexterm" name="idm45827000333792"></a><p>
          厳密な SQL モードが有効になっている場合、デフォルト値を持たないすべてのカラムに明示的な値が指定されていないと、<code class="literal">INSERT</code> ステートメントはエラーを生成します。 <a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          カラムリストと <code class="literal">VALUES</code> リストの両方が空である場合、<code class="literal">INSERT</code> は、各カラムがそのデフォルト値に設定された行を作成します。
        </p><pre class="programlisting">INSERT INTO <em class="replaceable"><code>tbl_name</code></em> () VALUES();
</pre><p>
          厳密モードが有効になっていない場合、MySQL では、デフォルトが明示的に定義されていないカラムに暗黙的なデフォルト値が使用されます。 厳密モードが有効な場合、いずれかのカラムにデフォルト値がないとエラーが発生します。 
        </p></li><li class="listitem"><p>
          カラムを明示的にそのデフォルト値に設定するには、キーワード <code class="literal">DEFAULT</code> を使用します。 これにより、テーブル内の各カラムの値が含まれていない不完全な <code class="literal">VALUES</code> リストを書かなくても済むため、いくつかのカラムを除くすべてのカラムに値を割り当てる <code class="literal">INSERT</code> ステートメントの記述が容易になります。 それ以外の場合は、<code class="literal">VALUES</code> リストの各値に対応するカラム名のリストを指定する必要があります。 
        </p></li><li class="listitem"><p>
          生成されたカラムが明示的ににに挿入される場合、許可される値は <code class="literal">DEFAULT</code> のみです。 生成されるカラムの詳細は、<a class="xref" href="sql-statements.html#create-table-generated-columns" title="13.1.20.8 CREATE TABLE および生成されるカラム">セクション13.1.20.8「CREATE TABLE および生成されるカラム」</a> を参照してください。 
        </p><a class="indexterm" name="idm45827000317440"></a></li><li class="listitem"><p>
          式では、<code class="literal">DEFAULT(<em class="replaceable"><code>col_name</code></em>)</code> を使用してカラム <em class="replaceable"><code>col_name</code></em> のデフォルト値を生成できます。
        </p></li><li class="listitem"><p>
          カラム値を提供する式 <em class="replaceable"><code>expr</code></em> の型変換は、式のデータ型がカラムのデータ型と一致しない場合に発生することがあります。 特定の値を変換すると、カラムタイプに応じて異なる値が挿入される可能性があります。 たとえば、文字列<code class="literal">'1999.0e-2'</code>を <code class="literal">INT</code>, <code class="literal">FLOAT</code>, <code class="literal">DECIMAL(10,6)</code> に挿入したり、<code class="literal">YEAR</code> カラムを挿入すると、値 <code class="literal">1999</code>, <code class="literal">19.9921</code>, <code class="literal">19.992100</code> または <code class="literal">1999</code> がそれぞれ挿入されます。 文字列から数値への変換では、文字列の初期部分のみが有効な整数または年とみなされる可能性があるため、<code class="literal">INT</code> および <code class="literal">YEAR</code> カラムに格納される値は <code class="literal">1999</code> です。 <code class="literal">FLOAT</code> および <code class="literal">DECIMAL</code> カラムの場合、文字列から数値への変換では、文字列全体が有効な数値とみなされます。 
        </p></li><li class="listitem"><p>
          式 <em class="replaceable"><code>expr</code></em> は、以前に値リスト内に設定された任意のカラムを参照できます。 たとえば、次のステートメントは、<code class="literal">col2</code> の値が、前に割り当てられている <code class="literal">col1</code> を参照しているため実行可能です。 
        </p><pre class="programlisting">INSERT INTO <em class="replaceable"><code>tbl_name</code></em> (col1,col2) VALUES(15,col1*2);
</pre><p>
          ただし、次のステートメントは、<code class="literal">col1</code> の値が、<code class="literal">col1</code> のあとに割り当てられている <code class="literal">col2</code> を参照しているため正当ではありません。
        </p><pre class="programlisting">INSERT INTO <em class="replaceable"><code>tbl_name</code></em> (col1,col2) VALUES(col2*2,15);
</pre><p>
          <code class="literal">AUTO_INCREMENT</code> 値を含むカラムに対して例外が発生します。 <code class="literal">AUTO_INCREMENT</code> 値は他の値の割当て後に生成されるため、割当て内の <code class="literal">AUTO_INCREMENT</code> カラムへの参照はすべて <code class="literal">0</code> を返します。 
        </p></li></ul></div><p>
      <code class="literal">VALUES</code> 構文を使用する <code class="literal">INSERT</code> ステートメントは複数の行を挿入できます。 これを行うには、カンマで区切られたカラム値の複数のリストをカッコで囲み、カンマで区切って含めます。 例: 
    </p><pre class="programlisting">INSERT INTO <em class="replaceable"><code>tbl_name</code></em> (a,b,c)
    VALUES(1,2,3), (4,5,6), (7,8,9);
</pre><p>
      各値リストには、行ごとに挿入されるのと同じ数の値が含まれている必要があります。 次のステートメントは、それぞれ 3 つの値のリストではなく、9 つの値のリストが 1 つ含まれているため、無効です: 
    </p><pre class="programlisting">INSERT INTO <em class="replaceable"><code>tbl_name</code></em> (a,b,c) VALUES(1,2,3,4,5,6,7,8,9);
</pre><p>
      このコンテキストでは、<code class="literal">VALUE</code> は <code class="literal">VALUES</code> のシノニムです。 値リストの数やリスト当たりの値の数については何も意味しません。 リストごとの値の数に関係なく、単一の値リストまたは複数のリストのいずれかを使用できます。 
    </p><p>
      <code class="literal">VALUES ROW()</code> 構文を使用する <code class="literal">INSERT</code> ステートメントでは、複数の行を挿入することもできます。 この場合、各値リストは、次のように <code class="literal">ROW()</code> (行コンストラクタ) 内に含まれている必要があります: 
    </p><pre class="programlisting">INSERT INTO <em class="replaceable"><code>tbl_name</code></em> (a,b,c)
    VALUES ROW(1,2,3), ROW(4,5,6), ROW(7,8,9);
</pre><p>
      <code class="literal">INSERT</code> の影響を受ける行の値は、<code class="literal">ROW_COUNT()</code> SQL 関数または <code class="literal">mysql_affected_rows()</code> C API 関数を使用して取得できます。 <a class="xref" href="functions.html#information-functions" title="12.16 情報関数">セクション12.16「情報関数」</a>および<a class="ulink" href="https://dev.mysql.com/doc/c-api/8.0/en/mysql-affected-rows.html" target="_top">mysql_affected_rows()</a>を参照してください。 
    </p><p>
      複数の値リスト、<code class="literal">INSERT ... SELECT</code> または <code class="literal">INSERT ... TABLE</code> で <code class="literal">INSERT ... VALUES</code> または <code class="literal">INSERT ... VALUES ROW()</code> を使用する場合、このステートメントは次の形式で情報文字列を返します:
    </p><pre class="programlisting">Records: <em class="replaceable"><code>N1</code></em> Duplicates: <em class="replaceable"><code>N2</code></em> Warnings: <em class="replaceable"><code>N3</code></em>
</pre><a class="indexterm" name="idm45827000259856"></a><p>
      C API を使用している場合は、<code class="literal">mysql_info()</code> 関数を呼び出すことによって情報文字列を取得できます。 <a class="ulink" href="https://dev.mysql.com/doc/c-api/8.0/en/mysql-info.html" target="_top">mysql_info()</a>を参照してください。 
    </p><p>
      <code class="literal">Records</code> は、このステートメントによって処理された行数を示します。 (これは、<code class="literal">Duplicates</code> が 0 以外であることがあるため、必ずしも実際に挿入された行数ではありません。) <code class="literal">Duplicates</code> は、何らかの既存の一意のインデックス値を複製しているために挿入できなかった行数を示します。 <code class="literal">Warnings</code> は、何らかの点で問題があったカラム値を挿入するための試行回数を示します。 警告は、次のいずれかの条件で発生する場合があります。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">NOT NULL</code> として宣言されているカラムへの <code class="literal">NULL</code> の挿入。 複数行の <code class="literal">INSERT</code> ステートメントまたは <code class="literal">INSERT INTO ... SELECT</code> ステートメントの場合、このカラムは、そのカラムデータ型の暗黙のデフォルト値に設定されます。 これは、数値型では <code class="literal">0</code>、文字列型では空の文字列 (<code class="literal">''</code>)、および日付と時間型では<span class="quote">「<span class="quote">0</span>」</span>の値です。 サーバーは <code class="literal">SELECT</code> からの結果セットを検査して、それが単一行を返すかどうかを確認しないため、<code class="literal">INSERT INTO ... SELECT</code> ステートメントは複数行の挿入と同じ方法で処理されます。 (単一行の <code class="literal">INSERT</code> の場合は、<code class="literal">NULL</code> が <code class="literal">NOT NULL</code> カラムに挿入されても警告は発生しません。 代わりに、このステートメントがエラーで失敗します。) 
        </p></li><li class="listitem"><p>
          数値カラムの、そのカラムの範囲外にある値への設定。 この値は、その範囲のもっとも近い端点にクリップされます。 
        </p></li><li class="listitem"><p>
          数値カラムへの <code class="literal">'10.34 a'</code> などの値の割り当て。 後続の非数値のテキストは取り除かれ、残りの数値部分が挿入されます。 文字列値に先頭の数値部分が含まれていない場合、このカラムは <code class="literal">0</code> に設定されます。 
        </p></li><li class="listitem"><p>
          文字列カラム (<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、<code class="literal">TEXT</code>、または <code class="literal">BLOB</code>) への、そのカラムの最大長を超える文字列の挿入。 この値は、そのカラムの最大長に切り捨てられます。 
        </p></li><li class="listitem"><p>
          日付または時間カラムへの、そのデータ型として不正な値の挿入。 このカラムは、その型の適切な 0 の値に設定されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">AUTO_INCREMENT</code> のカラム値を含む <code class="literal">INSERT</code> の例は、<a class="xref" href="tutorial.html#example-auto-increment" title="3.6.9 AUTO_INCREMENT の使用">セクション3.6.9「AUTO_INCREMENT の使用」</a> を参照してください。
        </p><a class="indexterm" name="idm45827000226064"></a><a class="indexterm" name="idm45827000224752"></a><p>
          <code class="literal">INSERT</code> が <code class="literal">AUTO_INCREMENT</code> カラムを含むテーブルに行を挿入する場合は、<code class="literal">LAST_INSERT_ID()</code> SQL 関数または <code class="literal">mysql_insert_id()</code> C API 関数を使用して、そのカラムに使用される値を検索できます。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            これらの 2 つの関数が、必ずしも同じ動作を行うとは限りません。 <code class="literal">AUTO_INCREMENT</code> カラムに関連した <code class="literal">INSERT</code> ステートメントの動作については、<a class="xref" href="functions.html#information-functions" title="12.16 情報関数">セクション12.16「情報関数」</a>および<a class="ulink" href="https://dev.mysql.com/doc/c-api/8.0/en/mysql-insert-id.html" target="_top">mysql_insert_id()</a>でさらに詳細に説明されています。 
          </p></div></li></ul></div><p>
      <code class="literal">INSERT</code> ステートメントは、次の修飾子をサポートします。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">LOW_PRIORITY</code> 修飾子を使用すると、ほかのクライアントがテーブルから読み取ることがなくなるまで、<code class="literal">INSERT</code> の実行が遅延されます。 これには、既存のクライアントが読み取っている間や、<code class="literal">INSERT LOW_PRIORITY</code> ステートメントが待機している間に読み取りを開始したほかのクライアントが含まれます。 したがって、<code class="literal">INSERT LOW_PRIORITY</code> ステートメントを発行するクライアントが非常に長い時間待機する可能性があります。 
        </p><a class="indexterm" name="idm45827000207936"></a><p>
          <code class="literal">LOW_PRIORITY</code> は、テーブルレベルロック (<code class="literal">MyISAM</code>、<code class="literal">MEMORY</code>、<code class="literal">MERGE</code> など) のみを使用するストレージエンジンにのみ影響します。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            同時挿入が無効になるため、<code class="literal">LOW_PRIORITY</code> は通常、<code class="literal">MyISAM</code> テーブルでは使用しないでください。 <a class="xref" href="optimization.html#concurrent-inserts" title="8.11.3 同時挿入">セクション8.11.3「同時挿入」</a>を参照してください。 
          </p></div></li><li class="listitem"><p>
          <code class="literal">HIGH_PRIORITY</code> を指定すると、サーバーが <code class="option">--low-priority-updates</code> オプションで起動されている場合に、その効果がオーバーライドされます。 また、同時挿入も使用されなくなります。 <a class="xref" href="optimization.html#concurrent-inserts" title="8.11.3 同時挿入">セクション8.11.3「同時挿入」</a>を参照してください。 
        </p><a class="indexterm" name="idm45827000196160"></a><p>
          <code class="literal">HIGH_PRIORITY</code> は、テーブルレベルロック (<code class="literal">MyISAM</code>、<code class="literal">MEMORY</code>、<code class="literal">MERGE</code> など) のみを使用するストレージエンジンにのみ影響します。
        </p></li><li class="listitem"><p>
          <code class="literal">IGNORE</code> 修飾子を使用すると、<code class="literal">INSERT</code> ステートメントの実行中に発生する無視可能なエラーは無視されます。 たとえば、<code class="literal">IGNORE</code> を使用しない場合は、テーブル内の既存の <code class="literal">UNIQUE</code> インデックスまたは <code class="literal">PRIMARY KEY</code> 値を複製する行によって重複キーエラーが発生し、このステートメントは中止されます。 <code class="literal">IGNORE</code> を指定すると、その行が破棄され、エラーは発生しません。 無視されたエラーでは、かわりに警告が生成されます。 
        </p><a class="indexterm" name="idm45827000184576"></a><p>
          <a class="indexterm" name="idm45827000182400"></a> <code class="literal">IGNORE</code> には、特定の値に一致するパーティションが見つからないパーティション化されたテーブルへの挿入でも同様の効果があります。 <code class="literal">IGNORE</code> がない場合、このような <code class="literal">INSERT</code> ステートメントはエラーで中断されます。 <code class="literal">INSERT IGNORE</code> を使用すると、一致しない値を含む行に対しては挿入操作が暗黙的に失敗しますが、一致する行は挿入されます。 例については、<a class="xref" href="partitioning.html#partitioning-list" title="24.2.2 LIST パーティショニング">セクション24.2.2「LIST パーティショニング」</a>を参照してください。 
        </p><p>
          <code class="literal">IGNORE</code> が指定されていない場合は、エラーをトリガーするデータ変換によってステートメントが中止されます。 <code class="literal">IGNORE</code> を指定すると、無効な値はもっとも近い値に調整されて挿入されます。警告は生成されますが、ステートメントは中止されません。 <code class="literal">mysql_info()</code> C API 関数を使用すると、テーブルに実際に挿入された行数を確認できます。 
        </p><p>
          詳細は、<a class="xref" href="server-administration.html#ignore-effect-on-execution" title="IGNORE がステートメントの実行に与える影響">IGNORE がステートメントの実行に与える影響</a>を参照してください。
        </p><p>
          古い行を上書きするには、<code class="literal">INSERT</code> の代わりに <code class="literal">REPLACE</code> を使用できます。 <code class="literal">REPLACE</code> は、古い行を複製する一意のキー値を含む新しい行の処理における <code class="literal">INSERT IGNORE</code> の対応する機能です: 新しい行は、破棄されるのではなく、古い行を置き換えます。 <a class="xref" href="sql-statements.html#replace" title="13.2.9 REPLACE ステートメント">セクション13.2.9「REPLACE ステートメント」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">ON DUPLICATE KEY UPDATE</code> を指定し、<code class="literal">UNIQUE</code> インデックスまたは <code class="literal">PRIMARY KEY</code> で値が重複する原因となる行を挿入すると、古い行の <code class="literal">UPDATE</code> が発生します。 行ごとの影響を受けた行の値は、その行が新しい行として挿入された場合は 1、既存の行が更新された場合は 2、既存の行がその現在の値に設定された場合は 0 です。 <span class="command"><strong>mysqld</strong></span> への接続時に <code class="literal">mysql_real_connect()</code> C API 関数に <code class="literal">CLIENT_FOUND_ROWS</code> フラグを指定すると、既存の行が現在の値に設定されている場合、影響を受ける行の値は 1 (0 ではなく) になります。 <a class="xref" href="sql-statements.html#insert-on-duplicate" title="13.2.6.2 INSERT ... ON DUPLICATE KEY UPDATE ステートメント">セクション13.2.6.2「INSERT ... ON DUPLICATE KEY UPDATE ステートメント」</a>を参照してください。 
        </p><a class="indexterm" name="idm45827000156112"></a></li><li class="listitem"><p>
          <code class="literal">INSERT DELAYED</code> は MySQL 5.6 で非推奨となり、最終的な削除がスケジュールされています。 MySQL 8.0 では、<code class="literal">DELAYED</code> 修飾子は受け入れられますが無視されます。 代わりに <code class="literal">INSERT</code> (<code class="literal">DELAYED</code> を付けない) を使用してください。 <a class="xref" href="sql-statements.html#insert-delayed" title="13.2.6.3 INSERT DELAYED ステートメント">セクション13.2.6.3「INSERT DELAYED ステートメント」</a>を参照してください。 
        </p><a class="indexterm" name="idm45827000149280"></a></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="insert-select"></a>13.2.6.1 INSERT ... SELECT ステートメント</h4></div></div></div><a class="indexterm" name="idm45827000146048"></a><a class="indexterm" name="idm45827000144736"></a><pre class="programlisting">INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]
    [INTO] <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em> [, <em class="replaceable"><code>partition_name</code></em>] ...)]
    [(<em class="replaceable"><code>col_name</code></em> [, <em class="replaceable"><code>col_name</code></em>] ...)]
    {SELECT ... | TABLE <em class="replaceable"><code>table_name</code></em>}
    [ON DUPLICATE KEY UPDATE <em class="replaceable"><code>assignment_list</code></em>]

<em class="replaceable"><code>value</code></em>:
    {<em class="replaceable"><code>expr</code></em> | DEFAULT}

<em class="replaceable"><code>assignment</code></em>:
    <em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>value</code></em>

<em class="replaceable"><code>assignment_list</code></em>:
    <em class="replaceable"><code>assignment</code></em> [, <em class="replaceable"><code>assignment</code></em>] ...
</pre><p>
        <code class="literal">INSERT ... SELECT</code> を使用すると、複数のテーブルから選択できる <code class="literal">SELECT</code> ステートメントの結果から、テーブルに多数の行をすばやく挿入できます。 例: 
      </p><pre class="programlisting">INSERT INTO tbl_temp2 (fld_id)
  SELECT tbl_temp1.fld_order_id
  FROM tbl_temp1 WHERE tbl_temp1.fld_order_id &gt; 100;
</pre><p>
        MySQL 8.0.19 以降、次に示すように、<code class="literal">SELECT</code> のかわりに <code class="literal">TABLE</code> ステートメントを使用できます:
      </p><pre class="programlisting">INSERT INTO ta TABLE tb;
</pre><p>
        <code class="literal">TABLE tb</code> は、<code class="literal">SELECT * FROM tb</code> と同等です。 これは、ソーステーブルのすべてのカラムをターゲットテーブルに挿入し、WHERE によるフィルタリングが不要な場合に便利です。 また、<code class="literal">TABLE</code> の行は <code class="literal">ORDER BY</code> を使用して 1 つ以上のカラムで順序付けでき、挿入される行数は <code class="literal">LIMIT</code> 句を使用して制限できます。 詳細は、<a class="xref" href="sql-statements.html#table" title="13.2.12 TABLE ステートメント">セクション13.2.12「TABLE ステートメント」</a>を参照してください。 
      </p><p>
        次の条件は、<code class="literal">INSERT ... SELECT</code> ステートメント、および特に明記されている場合を除き、<code class="literal">INSERT ... TABLE</code> にも適用されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            重複キー違反の原因になる行を無視するには、<code class="literal">IGNORE</code> を指定します。
          </p></li><li class="listitem"><p>
            <code class="literal">INSERT</code> ステートメントのターゲットテーブルは、クエリーの <code class="literal">SELECT</code> 部分の <code class="literal">FROM</code> 句に、または <code class="literal">TABLE</code> によって指定されたテーブルとして指定できます。 ただし、テーブルに挿入し、さらにサブクエリーで同じテーブルから選択することはできません。 
          </p><p>
            同じテーブルから選択して同じテーブルに挿入する場合、MySQL は、<code class="literal">SELECT</code> の行を保持する内部一時テーブルを作成し、それらの行をターゲットテーブルに挿入します。 ただし、同じステートメントで <code class="literal">TEMPORARY</code> テーブルを 2 回参照することはできないため、<code class="literal">t</code> が <code class="literal">TEMPORARY</code> テーブルの場合は <code class="literal">INSERT INTO t ... SELECT ... FROM t</code> を使用できません。 同じ理由で、<code class="literal">t</code> が一時テーブルの場合は <code class="literal">INSERT INTO t ... TABLE t</code> を使用できません。 <a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4 MySQL での内部一時テーブルの使用">セクション8.4.4「MySQL での内部一時テーブルの使用」</a>および<a class="xref" href="error-handling.html#temporary-table-problems" title="B.3.6.2 TEMPORARY テーブルに関する問題">セクションB.3.6.2「TEMPORARY テーブルに関する問題」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">AUTO_INCREMENT</code> カラムは、通常どおりに機能します。
          </p></li><li class="listitem"><p>
            バイナリログを使用して元のテーブルを再作成できるようにするために、MySQL では <code class="literal">INSERT ... SELECT</code> または <code class="literal">INSERT ... TABLE</code> ステートメントの同時挿入が許可されていません (<a class="xref" href="optimization.html#concurrent-inserts" title="8.11.3 同時挿入">セクション8.11.3「同時挿入」</a> を参照)。
          </p></li><li class="listitem"><p>
            <code class="literal">SELECT</code> と <code class="literal">INSERT</code> が同じテーブルを参照している場合のあいまいなカラム参照の問題を回避するには、<code class="literal">SELECT</code> 部分で使用されている各テーブルの一意のエイリアスを指定し、その部分にあるカラム名を適切なエイリアスで修飾します。
          </p><p>
            <code class="literal">TABLE</code> ステートメントはエイリアスをサポートしていません。
          </p></li></ul></div><p>
        ソーステーブルまたはターゲットテーブル (あるいはその両方) のどのパーティションまたはサブパーティション (あるいはその両方) を、テーブルの名前に続く <code class="literal">PARTITION</code> オプションとともに使用するかを明示的に選択できます。 <code class="literal">PARTITION</code> がこのステートメントの <code class="literal">SELECT</code> 部分にあるソーステーブルの名前とともに使用されている場合は、そのパーティションリストで指定されているパーティションまたはサブパーティションの行のみが選択されます。 <code class="literal">PARTITION</code> をステートメントの <code class="literal">INSERT</code> 部分のターゲットテーブルの名前とともに使用する場合、選択したすべての行を、オプションの後のパーティションリストで指定されたパーティションまたはサブパーティションに挿入できる必要があります。 それ以外の場合、<code class="literal">INSERT ... SELECT</code> ステートメントは失敗します。 詳細および例については、<a class="xref" href="partitioning.html#partitioning-selection" title="24.5 パーティション選択">セクション24.5「パーティション選択」</a>を参照してください。 
      </p><p>
        <code class="literal">TABLE</code> は、<code class="literal">PARTITION</code> オプションをサポートしていません。
      </p><p>
        <code class="literal">INSERT ... SELECT</code> ステートメントの場合、<code class="literal">ON DUPLICATE KEY UPDATE</code> 句で <code class="literal">SELECT</code> カラムを参照できる条件については、<a class="xref" href="sql-statements.html#insert-on-duplicate" title="13.2.6.2 INSERT ... ON DUPLICATE KEY UPDATE ステートメント">セクション13.2.6.2「INSERT ... ON DUPLICATE KEY UPDATE ステートメント」</a> を参照してください。 これは、<code class="literal">INSERT ... TABLE</code> でも機能します。 
      </p><p>
        <code class="literal">ORDER BY</code> 句のない <code class="literal">SELECT</code> ステートメントまたは <code class="literal">TABLE</code> ステートメントが行を戻す順序は、非決定的です。 つまり、レプリケーションを使用している場合、このような <code class="literal">SELECT</code> がソースとスレーブで同じ順序で行を返すことは保証されないため、それらの間に不整合が生じる可能性があります。 これが発生しないようにするには、ソースとレプリカで同じ行順序を生成する <code class="literal">ORDER BY</code> 句を使用して、レプリケートされる <code class="literal">INSERT ... SELECT</code> ステートメントまたは <code class="literal">INSERT ... TABLE</code> ステートメントを常に記述します。 <a class="xref" href="replication.html#replication-features-limit" title="17.5.1.18 レプリケーションと LIMIT">セクション17.5.1.18「レプリケーションと LIMIT」</a>も参照してください。 
      </p><p>
        この問題のため、<code class="literal">INSERT ... SELECT ON DUPLICATE KEY UPDATE</code> および <code class="literal">INSERT IGNORE ... SELECT</code> ステートメントには、ステートメントベースレプリケーションに対して安全でないというフラグが付けられます。 このようなステートメントは、ステートメントベースのモードの使用時にエラーログに警告を生成し、<code class="literal">MIXED</code> モードの使用時に行ベースの形式を使用してバイナリログに書き込まれます。 (Bug #11758262、Bug #50439) 
      </p><p>
        <a class="xref" href="replication.html#replication-sbr-rbr" title="17.2.1.1 ステートメントベースおよび行ベースレプリケーションのメリットとデメリット">セクション17.2.1.1「ステートメントベースおよび行ベースレプリケーションのメリットとデメリット」</a>も参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="insert-on-duplicate"></a>13.2.6.2 INSERT ... ON DUPLICATE KEY UPDATE ステートメント</h4></div></div></div><p>
        <code class="literal">ON DUPLICATE KEY UPDATE</code> 句を指定し、行を挿入すると、<code class="literal">UNIQUE</code> インデックスまたは <code class="literal">PRIMARY KEY</code> で値が重複する場合、古い行の <code class="literal">UPDATE</code> が発生します。 たとえば、カラム <code class="literal">a</code> が <code class="literal">UNIQUE</code> として宣言され、値 <code class="literal">1</code> を含んでいる場合、次の 2 つのステートメントには同様の効果があります。 
      </p><pre class="programlisting">INSERT INTO t1 (a,b,c) VALUES (1,2,3)
  ON DUPLICATE KEY UPDATE c=c+1;

UPDATE t1 SET c=c+1 WHERE a=1;
</pre><p>
        効果はまったく同じではありません: <code class="literal">a</code> が自動インクリメントカラムである <code class="literal">InnoDB</code> テーブルの場合、<code class="literal">INSERT</code> ステートメントは自動インクリメント値を増やしますが、<code class="literal">UPDATE</code> は増やしません。
      </p><p>
        カラム <code class="literal">b</code> も一意である場合、<code class="literal">INSERT</code> は、代わりに次の <code class="literal">UPDATE</code> ステートメントと同等です。
      </p><pre class="programlisting">UPDATE t1 SET c=c+1 WHERE a=1 OR b=2 LIMIT 1;
</pre><p>
        <code class="literal">a=1 OR b=2</code> が複数の行に一致する場合は、<span class="emphasis"><em>1 つ</em></span>の行だけが更新されます。 一般に、一意のインデックスが複数含まれているテーブルに対して <code class="literal">ON DUPLICATE KEY UPDATE</code> 句を使用することは避けるようにしてください。 
      </p><p>
        <code class="literal">ON DUPLICATE KEY UPDATE</code> を使用した場合、行ごとの影響を受けた行の値は、その行が新しい行として挿入された場合は 1、既存の行が更新された場合は 2、既存の行がその現在の値に設定された場合は 0 です。 <span class="command"><strong>mysqld</strong></span> への接続時に <code class="literal">mysql_real_connect()</code> C API 関数に <code class="literal">CLIENT_FOUND_ROWS</code> フラグを指定すると、既存の行が現在の値に設定されている場合、影響を受ける行の値は 1 (0 ではなく) になります。 
      </p><p>
        テーブルに <code class="literal">AUTO_INCREMENT</code> カラムが含まれているときに、<code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> で行を挿入または更新した場合、<code class="literal">LAST_INSERT_ID()</code> 関数は <code class="literal">AUTO_INCREMENT</code> 値を返します。
      </p><p>
        <code class="literal">ON DUPLICATE KEY UPDATE</code> 句には、カンマで区切られた、複数のカラム割り当てを含めることができます。
      </p><p>
        <code class="literal">ON DUPLICATE KEY UPDATE</code> 句の代入値式では、<code class="literal">VALUES(<em class="replaceable"><code>col_name</code></em>)</code> 関数を使用して <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> ステートメントの <code class="literal">INSERT</code> 部分からカラム値を参照できます。 つまり、<code class="literal">ON DUPLICATE KEY UPDATE</code> 句にある <code class="literal">VALUES(<em class="replaceable"><code>col_name</code></em>)</code> は、重複キーの競合が発生していない場合に挿入される <em class="replaceable"><code>col_name</code></em> の値を参照します。 この関数は、複数の行を挿入する際に特に役立ちます。 <code class="literal">VALUES()</code> 関数は、<code class="literal">ON DUPLICATE KEY UPDATE</code> 句または <code class="literal">INSERT</code> ステートメントでのみ意味があり、それ以外の場合は <code class="literal">NULL</code> を戻します。 例: 
      </p><pre class="programlisting">INSERT INTO t1 (a,b,c) VALUES (1,2,3),(4,5,6)
  ON DUPLICATE KEY UPDATE c=VALUES(a)+VALUES(b);
</pre><p>
        そのステートメントは、次の 2 つのステートメントと同一です。
      </p><pre class="programlisting">INSERT INTO t1 (a,b,c) VALUES (1,2,3)
  ON DUPLICATE KEY UPDATE c=3;
INSERT INTO t1 (a,b,c) VALUES (4,5,6)
  ON DUPLICATE KEY UPDATE c=9;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          新しい行とカラムを参照するための <code class="literal">VALUES()</code> の使用は、MySQL 8.0.20 以降非推奨になり、将来のバージョンの MySQL で削除される予定です。 かわりに、このセクションの次のいくつかの段落で説明するように、行およびカラムのエイリアスを使用します。 
        </p></div><p>
        MySQL 8.0.19 以降では、<code class="literal">VALUES</code> または <code class="literal">SET</code> 句の後に <code class="literal">AS</code> キーワードを付けて、挿入する行のエイリアス (オプションでそのカラムの 1 つ以上) を使用できます。 行エイリアス <code class="literal">new</code> を使用すると、以前に <code class="literal">VALUES()</code> を使用して新しいカラム値にアクセスしていたステートメントを、次に示す形式で記述できます: 
      </p><pre class="programlisting">INSERT INTO t1 (a,b,c) VALUES (1,2,3),(4,5,6) AS new
  ON DUPLICATE KEY UPDATE c = new.a+new.b;
</pre><p>
        また、カラムエイリアス <code class="literal">m</code>、<code class="literal">n</code> および <code class="literal">p</code> を使用する場合は、代入句で行エイリアスを省略して、次のような同じステートメントを記述できます:
      </p><pre class="programlisting">INSERT INTO t1 (a,b,c) VALUES (1,2,3),(4,5,6) AS new(m,n,p)
  ON DUPLICATE KEY UPDATE c = m+n;
</pre><p>
        この方法でカラムエイリアスを使用する場合、代入句で直接使用しない場合でも、<code class="literal">VALUES</code> 句の後に行エイリアスを使用する必要があります。
      </p><p>
        前述のように、<code class="literal">SET</code> 句で行およびカラムのエイリアスを使用することもできます。 前述の 2 つの <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> ステートメントで、<code class="literal">VALUES</code> のかわりに <code class="literal">SET</code> を使用すると、次のように実行できます: 
      </p><pre class="programlisting">INSERT INTO t1 SET a=1,b=2,c=3 AS new
  ON DUPLICATE KEY UPDATE c = new.a+new.b;

INSERT INTO t1 SET a=1,b=2,c=3 AS new(m,n,p)
  ON DUPLICATE KEY UPDATE c = m+n;
</pre><p>
        行のエイリアスは、テーブルの名前と同じにできません。 カラムエイリアスが使用されていない場合、またはカラム名と同じ場合は、<code class="literal">ON DUPLICATE KEY UPDATE</code> 句の行エイリアスを使用して区別する必要があります。 カラムのエイリアスは、適用される行のエイリアスに関して一意である必要があります (つまり、同じ行のカラムを参照するカラムのエイリアスは同じにできません)。 
      </p><p>
        <code class="literal">INSERT ... SELECT</code> ステートメントの場合、<code class="literal">ON DUPLICATE KEY UPDATE</code> 句で参照できる <code class="literal">SELECT</code> クエリー式の許容形式に関して、次のルールが適用されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            単一のテーブルに対するクエリーからのカラムへの参照 (導出テーブルの場合もあります)。
          </p></li><li class="listitem"><p>
            複数のテーブルに対する結合のクエリーからのカラムへのリファレンス。
          </p></li><li class="listitem"><p>
            <code class="literal">DISTINCT</code> クエリーからのカラムへのリファレンス。
          </p></li><li class="listitem"><p>
            <code class="literal">SELECT</code> が <code class="literal">GROUP BY</code> を使用しないかぎり、他のテーブルのカラムへのリファレンス。 副作用の 1 つは、一意でないカラム名への参照を修飾する必要があることです。 
          </p></li></ul></div><p>
        <code class="literal">UNION</code> からのカラムの参照はサポートされていません。 この制限を回避するには、<code class="literal">UNION</code> を導出テーブルとして書き換え、その行を単一テーブルの結果セットとして処理できるようにします。 たとえば、次のステートメントはエラーを生成します: 
      </p><pre class="programlisting">INSERT INTO t1 (a, b)
  SELECT c, d FROM t2
  UNION
  SELECT e, f FROM t3
ON DUPLICATE KEY UPDATE b = b + c;
</pre><p>
        かわりに、<code class="literal">UNION</code> を導出テーブルとしてリライトする同等のステートメントを使用します:
      </p><pre class="programlisting">INSERT INTO t1 (a, b)
SELECT * FROM
  (SELECT c, d FROM t2
   UNION
   SELECT e, f FROM t3) AS dt
ON DUPLICATE KEY UPDATE b = b + c;
</pre><p>
        クエリーを導出テーブルとしてリライトする方法では、<code class="literal">GROUP BY</code> クエリーからカラムを参照することもできます。
      </p><p>
        <code class="literal">INSERT ... SELECT</code> ステートメントの結果は <code class="literal">SELECT</code> からの行の順序に依存するため、この順序は常に保証されるわけではないため、ソースとスレーブの <code class="literal">INSERT ... SELECT ON DUPLICATE KEY UPDATE</code> ステートメントの相違を記録するときに可能です。 したがって、ステートメントベースのレプリケーションでは、<code class="literal">INSERT ... SELECT ON DUPLICATE KEY UPDATE</code> ステートメントに安全でないというフラグが付けられます。 このようなステートメントは、ステートメントベースのモードの使用時にエラーログに警告を生成し、<code class="literal">MIXED</code> モードの使用時に行ベースの形式を使用してバイナリログに書き込まれます。 複数の一意キーまたは主キーを持つテーブルに対する <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> ステートメントも安全でないとマークされます。 (Bug #11765650、Bug #58637) 
      </p><p>
        <a class="xref" href="replication.html#replication-sbr-rbr" title="17.2.1.1 ステートメントベースおよび行ベースレプリケーションのメリットとデメリット">セクション17.2.1.1「ステートメントベースおよび行ベースレプリケーションのメリットとデメリット」</a>も参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="insert-delayed"></a>13.2.6.3 INSERT DELAYED ステートメント</h4></div></div></div><a class="indexterm" name="idm45826999968160"></a><a class="indexterm" name="idm45826999966848"></a><a class="indexterm" name="idm45826999965504"></a><pre class="programlisting">INSERT DELAYED ...
</pre><p>
        <code class="literal">INSERT</code> ステートメントの <code class="literal">DELAYED</code> オプションは、標準 SQL に対する MySQL の拡張機能です。 以前のバージョンの MySQL では、特定の種類のテーブル (<code class="literal">MyISAM</code> など) に使用できるため、クライアントが <code class="literal">INSERT DELAYED</code> を使用すると、サーバーから OK が一度に取得され、テーブルが他のスレッドで使用されていない場合に挿入されるように行がキューに入れられます。 
      </p><p>
        <code class="literal">DELAYED</code> の挿入および置換は、MySQL 5.6 で非推奨になりました。 MySQL 8.0 では、<code class="literal">DELAYED</code> はサポートされません。 サーバーは <code class="literal">DELAYED</code> キーワードを認識しますが、無視し、挿入を遅延なしの挿入として処理し、<code class="literal">ER_WARN_LEGACY_SYNTAX_CONVERTED</code> 警告を生成: <span class="errortext">INSERT DELAYED はサポートされなくなりました。 ステートメントは INSERT</span> に変換されました。 <code class="literal">DELAYED</code> キーワードは、将来のリリースで削除される予定です。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="load-data"></a>13.2.7 LOAD DATA ステートメント</h3></div></div></div><a class="indexterm" name="idm45826999948800"></a><a class="indexterm" name="idm45826999947744"></a><pre class="programlisting">LOAD DATA
    [LOW_PRIORITY | CONCURRENT] [LOCAL]
    INFILE '<em class="replaceable"><code>file_name</code></em>'
    [REPLACE | IGNORE]
    INTO TABLE <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em> [, <em class="replaceable"><code>partition_name</code></em>] ...)]
    [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>]
    [{FIELDS | COLUMNS}
        [TERMINATED BY '<em class="replaceable"><code>string</code></em>']
        [[OPTIONALLY] ENCLOSED BY '<em class="replaceable"><code>char</code></em>']
        [ESCAPED BY '<em class="replaceable"><code>char</code></em>']
    ]
    [LINES
        [STARTING BY '<em class="replaceable"><code>string</code></em>']
        [TERMINATED BY '<em class="replaceable"><code>string</code></em>']
    ]
    [IGNORE <em class="replaceable"><code>number</code></em> {LINES | ROWS}]
    [(<em class="replaceable"><code>col_name_or_user_var</code></em>
        [, <em class="replaceable"><code>col_name_or_user_var</code></em>] ...)]
    [SET <em class="replaceable"><code>col_name</code></em>={<em class="replaceable"><code>expr</code></em> | DEFAULT}
        [, <em class="replaceable"><code>col_name</code></em>={<em class="replaceable"><code>expr</code></em> | DEFAULT}] ...]
</pre><p>
      <code class="literal">LOAD DATA</code> ステートメントは、テキストファイルからテーブルに非常に高速に行を読み取ります。 <code class="literal">LOAD DATA</code> は、<code class="literal">SELECT ... INTO OUTFILE</code> を補完したものです。 (<a class="xref" href="sql-statements.html#select-into" title="13.2.10.1 SELECT ... INTO ステートメント">セクション13.2.10.1「SELECT ... INTO ステートメント」</a>を参照してください。) テーブルからファイルにデータを書き込むには、<code class="literal">SELECT ... INTO OUTFILE</code> を使用します。 ファイルをテーブルに読み取るには、<code class="literal">LOAD DATA</code> を使用します。 <code class="literal">FIELDS</code> および <code class="literal">LINES</code> 句の構文は、両方のステートメントで同じです。 
    </p><a class="indexterm" name="idm45826999925856"></a><p>
      <span class="command"><strong>mysqlimport</strong></span> ユーティリティを使用してデータファイルをロードすることもできます。<a class="xref" href="programs.html#mysqlimport" title="4.5.5 mysqlimport — データインポートプログラム">セクション4.5.5「mysqlimport — データインポートプログラム」</a> を参照してください。<span class="command"><strong>mysqlimport</strong></span> は、<code class="literal">LOAD DATA</code> ステートメントをサーバーに送信することによって動作します。
    </p><p>
      <code class="literal">INSERT</code> と <code class="literal">LOAD DATA</code> の効率および <code class="literal">LOAD DATA</code> の高速化の詳細は、<a class="xref" href="optimization.html#insert-optimization" title="8.2.5.1 INSERT ステートメントの最適化">セクション8.2.5.1「INSERT ステートメントの最適化」</a> を参照してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#load-data-partitioning-support" title="パーティションテーブルのサポート">パーティションテーブルのサポート</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#load-data-input-file" title="入力ファイルの名前、場所およびコンテンツの解釈">入力ファイルの名前、場所およびコンテンツの解釈</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#load-data-replication" title="レプリケーションに関する考慮事項">レプリケーションに関する考慮事項</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#load-data-concurrency" title="並列性に関する考慮事項">並列性に関する考慮事項</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#load-data-duplicate-key-handling" title="重複キーの処理">重複キーの処理</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#load-data-index-handling" title="インデックス処理">インデックス処理</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#load-data-field-line-handling" title="フィールドおよび明細の処理">フィールドおよび明細の処理</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#load-data-column-list" title="カラムリストの指定">カラムリストの指定</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#load-data-input-preprocessing" title="入力前処理">入力前処理</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#load-data-statement-result-information" title="ステートメントの結果情報">ステートメントの結果情報</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#load-data-miscellaneous" title="その他のトピック">その他のトピック</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="load-data-partitioning-support"></a>パーティションテーブルのサポート</h4></div></div></div><p>
        <code class="literal">LOAD DATA</code> では、パーティションまたはサブパーティション (あるいはその両方) のカンマ区切り名のリストを含む <code class="literal">PARTITION</code> オプションを使用した明示的なパーティション選択がサポートされています。 このオプションが使用されているとき、リストで指定されているいずれかのパーティションまたはサブパーティションにファイルからの行を挿入できない場合、このステートメントは <span class="errortext">Found a row not matching the given partition set</span> エラーで失敗します。 詳細および例については、<a class="xref" href="partitioning.html#partitioning-selection" title="24.5 パーティション選択">セクション24.5「パーティション選択」</a>を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="load-data-input-file"></a>入力ファイルの名前、場所およびコンテンツの解釈</h4></div></div></div><p>
        ファイル名は、リテラル文字列として指定する必要があります。 Windows では、パス名内のバックスラッシュをスラッシュまたは二重のバックスラッシュとして指定します。 <code class="literal">character_set_filesystem</code> システム変数は、ファイル名文字セットの解釈を制御します。 
      </p><p>
        サーバーは、<code class="literal">character_set_database</code> システム変数によって示されている文字セットを使用してファイル内の情報を解釈します。 <code class="literal">SET NAMES</code> や、<code class="literal">character_set_client</code> の設定は入力の解釈に影響を与えません。 入力ファイルの内容にデフォルトとは異なる文字セットが使用されている場合は、通常、<code class="literal">CHARACTER SET</code> 句を使用してそのファイルの文字セットを指定することをお勧めします。 <code class="literal">binary</code> の文字セットは、<span class="quote">「<span class="quote">変換なし</span>」</span>を指定します。 
      </p><p>
        <code class="literal">LOAD DATA</code> では、フィールド値がロードされるカラムのデータ型に関係なく、ファイル内のすべてのフィールドが同じ文字セットを持つと解釈されます。 ファイルの内容が正しく解釈されるように、そのファイルが正しい文字セットで書き込まれていることを確認する必要があります。 たとえば、<span class="command"><strong>mysqldump -T</strong></span> を使用して、または <span class="command"><strong>mysql</strong></span> で <code class="literal">SELECT ... INTO OUTFILE</code> ステートメントを発行してデータファイルを書き込む場合は、<code class="literal">LOAD DATA</code> でファイルをロードするときに使用される文字セットで出力が書き込まれるように、<code class="option">--default-character-set</code> オプションを使用してください。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">ucs2</code>、<code class="literal">utf16</code>、<code class="literal">utf16le</code>、または <code class="literal">utf32</code> 文字セットを使用するデータファイルはロードできません。
        </p></div><p>
        <code class="literal">LOCAL</code> 修飾子は、後で説明するように、ファイルの予期される場所およびエラー処理に影響します。 <code class="literal">LOCAL</code> は、サーバーとクライアントの両方がそれを許可するように構成されている場合にのみ機能します。 たとえば、<code class="literal">local_infile</code> システム変数を無効にして <span class="command"><strong>mysqld</strong></span> を起動した場合、<code class="literal">LOCAL</code> は機能しません。 <a class="xref" href="security.html#load-data-local-security" title="6.1.6 LOAD DATA LOCAL のセキュリティー上の考慮事項">セクション6.1.6「LOAD DATA LOCAL のセキュリティー上の考慮事項」</a>を参照してください。 
      </p><p>
        <code class="literal">LOCAL</code> 修飾子は、ファイルが見つかる場所に影響します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">LOCAL</code> が指定されている場合、ファイルはクライアントホスト上のクライアントプログラムによって読み取られ、サーバーに送信されます。 このファイルは、その正確な場所を指定するためにフルパス名として指定できます。 相対パス名として指定されている場合、その名前は、クライアントプログラムが起動されたディレクトリを基準にして解釈されます。 
          </p><p>
            <code class="literal">LOCAL</code> を <code class="literal">LOAD DATA</code> とともに使用すると、MySQL サーバーが一時ファイルを格納するディレクトリにファイルのコピーが作成されます。 <a class="xref" href="error-handling.html#temporary-files" title="B.3.3.5 MySQL が一時ファイルを格納する場所">セクションB.3.3.5「MySQL が一時ファイルを格納する場所」</a>を参照してください。 このディレクトリ内にコピーのための十分な領域がないと、<code class="literal">LOAD DATA LOCAL</code> ステートメントが失敗する場合があります。 
          </p></li><li class="listitem"><p>
            <code class="literal">LOCAL</code> が指定されていない場合、ファイルはサーバーホスト上にある必要があり、直接サーバーによって読み取られます。 サーバーは、次のルールを使用してファイルを見つけます。 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                ファイル名が絶対パス名である場合、サーバーはそれを指定されたとおりに使用します。
              </p></li><li class="listitem"><p>
                ファイル名が 1 つ以上の先行コンポーネントを含む相対パス名である場合、サーバーは、サーバーのデータディレクトリを基準にしてファイルを検索します。
              </p></li><li class="listitem"><p>
                先行コンポーネントを含まないファイル名が指定されている場合、サーバーは、デフォルトデータベースのデータベースディレクトリ内でそのファイルを探します。
              </p></li></ul></div></li></ul></div><p>
        <code class="literal">LOCAL</code> 以外のケースでは、これらのルールは、<code class="filename">./myfile.txt</code> という名前のファイルがサーバーのデータディレクトリから読み取られるのに対して、<code class="filename">myfile.txt</code> として指定されたファイルはデフォルトデータベースのデータベースディレクトリから読み取られることを示します。 たとえば、<code class="literal">db1</code> がデフォルトデータベースである場合、次の <code class="literal">LOAD DATA</code> ステートメントは、このステートメントが明示的に <code class="literal">db2</code> データベース内のテーブルにファイルをロードしているにもかかわらず、<code class="literal">db1</code> のデータベースディレクトリからファイル <code class="filename">data.txt</code> を読み取ります。 
      </p><pre class="programlisting">LOAD DATA INFILE 'data.txt' INTO TABLE db2.my_table;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          また、サーバーは <code class="literal">LOCAL</code> 以外のルールを使用して、<code class="literal">IMPORT TABLE</code> ステートメントの <code class="filename">.sdi</code> ファイルを検索します。
        </p></div><p>
        <code class="literal">LOCAL</code> 以外のロード操作は、サーバーにあるテキストファイルを読み取ります。 セキュリティ上の理由から、このような操作には <code class="literal">FILE</code> 権限が必要です。 <a class="xref" href="security.html#privileges-provided" title="6.2.2 MySQL で提供される権限">セクション6.2.2「MySQL で提供される権限」</a>を参照してください。 また、<code class="literal">LOCAL</code> 以外のロード操作は、<code class="literal">secure_file_priv</code> システム変数設定の影響を受けます。 変数値が空でないディレクトリ名の場合、ロードするファイルはそのディレクトリに配置する必要があります。 変数値が空 (セキュアでない) の場合、ファイルはサーバーからのみ読取り可能である必要があります。 
      </p><p>
        <code class="literal">LOCAL</code> を使用すると、クライアントからサーバーへの接続を介してファイルコンテンツを送信する必要があるため、サーバーがファイルに直接アクセスするより少し時間がかかります。 その一方で、ローカルファイルをロードするために <code class="literal">FILE</code> 権限は必要ありません。 
      </p><p>
        <code class="literal">LOCAL</code> はまた、エラー処理にも影響を与えます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">LOAD DATA</code> では、データ解釈エラーおよび重複キーエラーによって操作が終了します。
          </p></li><li class="listitem"><p>
            <code class="literal">LOAD DATA LOCAL</code> では、データ解釈および重複キーのエラーは警告になり、操作の途中でファイルの転送を停止する方法がサーバーにないため、操作は続行されます。 重複キーエラーについては、これは <code class="literal">IGNORE</code> が指定されている場合と同じです。 <code class="literal">IGNORE</code> については、このセクションのあとの方でさらに詳細に説明されています。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="load-data-replication"></a>レプリケーションに関する考慮事項</h4></div></div></div><p>
        <code class="literal">LOAD DATA</code> は、ステートメントベースレプリケーションでは安全でないとみなされます。 <code class="literal">binlog_format=STATEMENT</code> が設定されているときに <code class="literal">LOAD DATA</code> を使用すると、データを含む一時ファイルが、変更が適用されるレプリケーションスレーブ上に作成されます。 バイナリログの暗号化がサーバー上でアクティブな場合、この一時ファイルは暗号化されないことに注意してください。 暗号化が必要な場合は、一時ファイルを作成しない行ベースまたは混合バイナリロギング形式を使用してください。 <code class="literal">LOAD DATA</code> とレプリケーションの相互作用の詳細は、<a class="xref" href="replication.html#replication-features-load-data" title="17.5.1.19 レプリケーションと LOAD DATA">セクション17.5.1.19「レプリケーションと LOAD DATA」</a> を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="load-data-concurrency"></a>並列性に関する考慮事項</h4></div></div></div><p>
        <code class="literal">LOW_PRIORITY</code> 修飾子を使用すると、ほかのクライアントがテーブルから読み取ることがなくなるまで、<code class="literal">LOAD DATA</code> ステートメントの実行が遅延されます。 これは、テーブルレベルロックのみを使用するストレージエンジン (<code class="literal">MyISAM</code>、<code class="literal">MEMORY</code>、および <code class="literal">MERGE</code>) にのみ影響を与えます。 
      </p><p>
        同時挿入の条件を満たす (つまり、中央に空きブロックが含まれていない) <code class="literal">MyISAM</code> テーブルで <code class="literal">CONCURRENT</code> 修飾子を指定すると、<code class="literal">LOAD DATA</code> の実行中に他のスレッドがテーブルからデータを取得できます。 この修飾子は、ほかのスレッドがそのテーブルを同時に使用していない場合でも、<code class="literal">LOAD DATA</code> のパフォーマンスに少し影響します。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="load-data-duplicate-key-handling"></a>重複キーの処理</h4></div></div></div><p>
        <code class="literal">REPLACE</code> および <code class="literal">IGNORE</code> 修飾子は、一意のキー値で既存の行を複製する新しい (入力) 行の処理を制御します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">REPLACE</code> を指定すると、新しい行で既存の行が置き換えられます。 つまり、既存の行と同じ主キーまたは一意インデックスの値を持つ行が既存の行を置換します。 <a class="xref" href="sql-statements.html#replace" title="13.2.9 REPLACE ステートメント">セクション13.2.9「REPLACE ステートメント」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">IGNORE</code> を指定すると、一意のキー値で既存の行を複製する新しい行は破棄されます。 詳細は、<a class="xref" href="server-administration.html#ignore-effect-on-execution" title="IGNORE がステートメントの実行に与える影響">IGNORE がステートメントの実行に与える影響</a>を参照してください。 
          </p><a class="indexterm" name="idm45826999803920"></a></li><li class="listitem"><p>
            いずれの修飾子も指定しない場合、動作は <code class="literal">LOCAL</code> 修飾子が指定されているかどうかによって異なります。 <code class="literal">LOCAL</code> が指定されていない場合は、重複キー値が見つかるとエラーが発生し、テキストファイルの残りは無視されます。 <code class="literal">LOCAL</code> が指定されている場合、デフォルトの動作は <code class="literal">IGNORE</code> が指定されている場合と同じです。これは、操作の最中にファイルの転送を停止する方法がサーバーにはないためです。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="load-data-index-handling"></a>インデックス処理</h4></div></div></div><p>
        ロード操作中に外部キー制約を無視するには、<code class="literal">LOAD DATA</code> を実行する前に <code class="literal">SET foreign_key_checks = 0</code> ステートメントを実行します。
      </p><p>
        空の <code class="literal">MyISAM</code> テーブルで <code class="literal">LOAD DATA</code> を使用する場合、一意でないすべてのインデックスが個別のバッチで作成されます (<code class="literal">REPAIR TABLE</code> の場合など)。 通常、これにより、多数のインデックスがある場合に <code class="literal">LOAD DATA</code> がはるかに高速になります。 一部の極端なケースでは、ファイルをテーブルにロードする前に <code class="literal">ALTER TABLE ... DISABLE KEYS</code> でインデックスを無効にし、ファイルをロードしたあとに <code class="literal">ALTER TABLE ... ENABLE KEYS</code> を使用してインデックスを再作成することによって、インデックスをさらに高速に作成できます。 <a class="xref" href="optimization.html#insert-optimization" title="8.2.5.1 INSERT ステートメントの最適化">セクション8.2.5.1「INSERT ステートメントの最適化」</a>を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="load-data-field-line-handling"></a>フィールドおよび明細の処理</h4></div></div></div><p>
        <code class="literal">LOAD DATA</code> ステートメントと <code class="literal">SELECT ... INTO OUTFILE</code> ステートメントの両方で、<code class="literal">FIELDS</code> 句と <code class="literal">LINES</code> 句の構文は同じです。 どちらの句もオプションですが、両方が指定される場合は、<code class="literal">FIELDS</code> を <code class="literal">LINES</code> の前に指定する必要があります。 
      </p><p>
        <code class="literal">FIELDS</code> 句を指定する場合は、その各サブ句 (<code class="literal">TERMINATED BY</code>、<code class="literal">[OPTIONALLY] ENCLOSED BY</code>、および <code class="literal">ESCAPED BY</code>) もオプションです。ただし、そのうちの少なくとも 1 つを指定する必要があります。 これらの句の引数には ASCII 文字のみを含めることができます。 
      </p><p>
        <code class="literal">FIELDS</code> または <code class="literal">LINES</code> 句を指定しない場合、そのデフォルトは、次を記述した場合と同じです。
      </p><pre class="programlisting">FIELDS TERMINATED BY '\t' ENCLOSED BY '' ESCAPED BY '\\'
LINES TERMINATED BY '\n' STARTING BY ''
</pre><p>
        バックスラッシュは、SQL ステートメントの文字列内の MySQL エスケープ文字です。 したがって、リテラルのバックスラッシュを指定するには、値が単一のバックスラッシュとして解釈されるように 2 つのバックスラッシュを指定する必要があります。 エスケープシーケンス<code class="literal">'\t'</code>および<code class="literal">'\n'</code>では、それぞれタブ文字と改行文字が指定されます。 
      </p><p>
        つまり、デフォルトでは、<code class="literal">LOAD DATA</code> は入力の読取り時に次のように動作します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            改行の位置にある行の境界を探します。
          </p></li><li class="listitem"><p>
            行の接頭辞はスキップしないでください。
          </p></li><li class="listitem"><p>
            タブの位置で行をフィールドに分割します。
          </p></li><li class="listitem"><p>
            フィールドが引用文字で囲まれていることを期待しません。
          </p></li><li class="listitem"><p>
            前にエスケープ文字<code class="literal">\</code>がある文字をエスケープシーケンスとして解釈します。 たとえば、<code class="literal">\t</code>、<code class="literal">\n</code> および<code class="literal">\\</code>は、それぞれタブ、改行およびバックスラッシュを示します。 エスケープシーケンスの完全なリストについては、あとの <code class="literal">FIELDS ESCAPED BY</code> の説明を参照してください。 
          </p></li></ul></div><p>
        逆に、デフォルトでは、出力を書き込むとき <code class="literal">SELECT ... INTO OUTFILE</code> は次のように機能します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            フィールド間にタブを書き込みます。
          </p></li><li class="listitem"><p>
            フィールドを引用文字で囲みません。
          </p></li><li class="listitem"><p>
            <code class="literal">\</code>を使用して、フィールド値内で発生するタブ、改行または<code class="literal">\</code>のインスタンスをエスケープします。
          </p></li><li class="listitem"><p>
            行の最後に改行を書き込みます。
          </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          Windows システムで生成されたテキストファイルの場合、Windows プログラムでは通常、行終了記号として 2 文字を使用するため、適切なファイル読取りに <code class="literal">LINES TERMINATED BY '\r\n'</code>が必要になることがあります。 <span class="command"><strong>WordPad</strong></span> などの一部のプログラムは、ファイルを書き込むときに行ターミネータとして <code class="literal">\r</code> を使用する可能性があります。 このようなファイルを読み取るには、<code class="literal">LINES TERMINATED BY '\r'</code> を使用します。 
        </p></div><p>
        すべての入力行に無視する共通の接頭辞がある場合は、<code class="literal">LINES STARTING BY '<em class="replaceable"><code>prefix_string</code></em>'</code>を使用して接頭辞<span class="emphasis"><em>およびそれより前のもの</em></span>をスキップできます。 行にプリフィクスが含まれていない場合は、行全体がスキップされます。 たとえば、次のステートメントを発行するとします。 
      </p><pre class="programlisting">LOAD DATA INFILE '/tmp/test.txt' INTO TABLE test
  FIELDS TERMINATED BY ','  LINES STARTING BY 'xxx';
</pre><p>
        データファイルは次のようになっています。
      </p><pre class="programlisting">xxx"abc",1
something xxx"def",2
"ghi",3
</pre><p>
        結果の行は、<code class="literal">("abc",1)</code> および <code class="literal">("def",2)</code> です。 ファイル内の 3 行目は、プリフィクスが含まれていないためスキップされます。 
      </p><p>
        <code class="literal">IGNORE <em class="replaceable"><code>number</code></em> LINES</code> オプションを使用すると、ファイルの先頭にある行を無視できます。 たとえば、<code class="literal">IGNORE 1 LINES</code> を使用して、カラム名を含む最初のヘッダー行をスキップできます: 
      </p><pre class="programlisting">LOAD DATA INFILE '/tmp/test.txt' INTO TABLE test IGNORE 1 LINES;
</pre><p>
        <code class="literal">SELECT ... INTO OUTFILE</code> を <code class="literal">LOAD DATA</code> とともに使用してデータベースからファイルにデータを書き込み、後でそのファイルをデータベースに読み取る場合、両方のステートメントのフィールド処理オプションと行処理オプションが一致する必要があります。 そうしないと、<code class="literal">LOAD DATA</code> はファイルの内容を正しく解釈しません。 <code class="literal">SELECT ... INTO OUTFILE</code> を使用して、カンマで区切られたフィールドを含むファイルを書き込むとします。 
      </p><pre class="programlisting">SELECT * INTO OUTFILE 'data.txt'
  FIELDS TERMINATED BY ','
  FROM table2;
</pre><p>
        カンマ区切りファイルを読み取るには、正しいステートメントは次のようになります:
      </p><pre class="programlisting">LOAD DATA INFILE 'data.txt' INTO TABLE table2
  FIELDS TERMINATED BY ',';
</pre><p>
        かわりに、次に示すステートメントを使用してファイルを読み取ろうとすると、フィールド間のタブを検索するように <code class="literal">LOAD DATA</code> に指示するため、機能しません:
      </p><pre class="programlisting">LOAD DATA INFILE 'data.txt' INTO TABLE table2
  FIELDS TERMINATED BY '\t';
</pre><p>
        その結果、各入力行が 1 つのフィールドとして解釈される可能性があります。
      </p><a class="indexterm" name="idm45826999723680"></a><a class="indexterm" name="idm45826999722160"></a><p>
        <code class="literal">LOAD DATA</code> を使用して、外部ソースから取得したファイルを読み取ることができます。 たとえば、多くのプログラムは、各行にカンマで区切られ、二重引用符で囲まれた複数のフィールドが含まれており、かつ開始行がカラム名になっているようなカンマ区切り値 (CSV) 形式でデータをエクスポートできます。 このようなファイル内の行が復帰改行と改行のペアで終了している場合、次に示すステートメントは、このファイルをロードするために使用するフィールド処理と行処理のオプションを示しています。 
      </p><pre class="programlisting">LOAD DATA INFILE 'data.txt' INTO TABLE <em class="replaceable"><code>tbl_name</code></em>
  FIELDS TERMINATED BY ',' ENCLOSED BY '"'
  LINES TERMINATED BY '\r\n'
  IGNORE 1 LINES;
</pre><p>
        入力値が必ずしも引用符で囲まれていない場合は、<code class="literal">ENCLOSED BY</code> オプションの前に <code class="literal">OPTIONALLY</code> を使用します。
      </p><p>
        フィールド処理または行処理のどのオプションにも、空の文字列 (<code class="literal">''</code>) を指定できます。 空でない場合、<code class="literal">FIELDS [OPTIONALLY] ENCLOSED BY</code> および <code class="literal">FIELDS ESCAPED BY</code> 値は単一の文字である必要があります。 <code class="literal">FIELDS TERMINATED BY</code>、<code class="literal">LINES STARTING BY</code>、および <code class="literal">LINES TERMINATED BY</code> 値は、複数の文字にすることができます。 たとえば、復帰改行と改行のペアで終了する行を書き込むか、またはこのような行を含むファイルを読み取るには、<code class="literal">LINES TERMINATED BY '\r\n'</code> 句を指定します。 
      </p><p>
        <code class="literal">%%</code> から成る行で区切られたジョークを含むファイルを読み取るには、次のようにできます。
      </p><pre class="programlisting">CREATE TABLE jokes
  (a INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
  joke TEXT NOT NULL);
LOAD DATA INFILE '/tmp/jokes.txt' INTO TABLE jokes
  FIELDS TERMINATED BY ''
  LINES TERMINATED BY '\n%%\n' (joke);
</pre><p>
        <code class="literal">FIELDS [OPTIONALLY] ENCLOSED BY</code> は、フィールドの引用符を制御します。 出力 (<code class="literal">SELECT ... INTO OUTFILE</code>) でワード <code class="literal">OPTIONALLY</code> を省略した場合は、すべてのフィールドが <code class="literal">ENCLOSED BY</code> 文字で囲まれます。 フィールド区切り文字としてカンマを使用したこのような出力の例を次に示します。 
      </p><pre class="programlisting">"1","a string","100.20"
"2","a string containing a , comma","102.20"
"3","a string containing a \" quote","102.20"
"4","a string containing a \", quote and comma","102.20"
</pre><p>
        <code class="literal">OPTIONALLY</code> を指定した場合、<code class="literal">ENCLOSED BY</code> 文字は、文字列データ型 (<code class="literal">CHAR</code>、<code class="literal">BINARY</code>、<code class="literal">TEXT</code>、<code class="literal">ENUM</code> など) を持つカラムの値を囲むためにのみ使用されます。
      </p><pre class="programlisting">1,"a string",100.20
2,"a string containing a , comma",102.20
3,"a string containing a \" quote",102.20
4,"a string containing a \", quote and comma",102.20
</pre><p>
        フィールド値内の <code class="literal">ENCLOSED BY</code> 文字の出現は、先頭に <code class="literal">ESCAPED BY</code> 文字を付けてエスケープされます。 また、空の <code class="literal">ESCAPED BY</code> 値を指定すると、<code class="literal">LOAD DATA</code> で正しく読み取れない出力が誤って生成される可能性があります。 たとえば、エスケープ文字が空である場合、今示した前の出力は次のようになります。 4 行目の 2 番目のフィールドに含まれる引用符のあとにカンマが続いていることに注目してください。これにより、このフィールドが (誤って) 終了するように見えます。 
      </p><pre class="programlisting">1,"a string",100.20
2,"a string containing a , comma",102.20
3,"a string containing a " quote",102.20
4,"a string containing a ", quote and comma",102.20
</pre><p>
        入力では、<code class="literal">ENCLOSED BY</code> 文字 (存在する場合) はフィールド値の最後から取り除かれます。 (これは、<code class="literal">OPTIONALLY</code> が指定されているかどうかには関係しません。<code class="literal">OPTIONALLY</code> は、入力の解釈には影響を与えません。) <code class="literal">ENCLOSED BY</code> 文字が <code class="literal">ESCAPED BY</code> 文字のあとに現れた場合は、現在のフィールド値の一部として解釈されます。 
      </p><p>
        フィールドが <code class="literal">ENCLOSED BY</code> 文字で始まったとき、その文字のインスタンスがフィールド値の終了として認識されるのは、そのあとにフィールドまたは行の <code class="literal">TERMINATED BY</code> シーケンスが続いている場合だけです。 あいまいさを避けるために、フィールド値の中に <code class="literal">ENCLOSED BY</code> 文字が現れるときはそれを 2 文字にすることができ、それがその文字の単一インスタンスとして解釈されます。 たとえば、<code class="literal">ENCLOSED BY '"'</code> が指定されている場合、引用符は次に示すように処理されます。 
      </p><pre class="programlisting">"The ""BIG"" boss"  -&gt; The "BIG" boss
The "BIG" boss      -&gt; The "BIG" boss
The ""BIG"" boss    -&gt; The ""BIG"" boss
</pre><p>
        <code class="literal">FIELDS ESCAPED BY</code> は、特殊文字の読み取りまたは書き込みの方法を制御します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            入力では、<code class="literal">FIELDS ESCAPED BY</code> 文字が空でない場合、その文字が現れると取り除かれ、それに続く文字がフィールド値の一部として文字どおりに解釈されます。 最初の文字がエスケープ文字である一部の 2 文字シーケンスは例外です。 これらのシーケンスを (エスケープ文字に<code class="literal">\</code>を使用して) 次の表に示します。 <code class="literal">NULL</code> 処理のルールについては、このセクションのあとの方で説明されています。 
          </p><div class="informaltable"><table summary="Two-character sequences for which the first character (a \) is the escape character."><col style="width: 15%"><col style="width: 85%"><thead><tr>
                <th>文字</th>
                <th>エスケープシーケンス</th>
              </tr></thead><tbody><tr>
                <td><code class="literal">\0</code><a class="indexterm" name="idm45826999666048"></a><a class="indexterm" name="idm45826999664832"></a></td>
                <td>ASCII NUL (<code class="literal">X'00'</code>) 文字</td>
              </tr><tr>
                <td><code class="literal">\b</code> <a class="indexterm" name="idm45826999660288"></a> <a class="indexterm" name="idm45826999659200"></a></td>
                <td>バックスペース文字</td>
              </tr><tr>
                <td><code class="literal">\n</code><a class="indexterm" name="idm45826999655392"></a><a class="indexterm" name="idm45826999654176"></a><a class="indexterm" name="idm45826999652960"></a><a class="indexterm" name="idm45826999651744"></a></td>
                <td>改行 (ラインフィード) 文字</td>
              </tr><tr>
                <td><code class="literal">\r</code> <a class="indexterm" name="idm45826999647840"></a> <a class="indexterm" name="idm45826999646320"></a> <a class="indexterm" name="idm45826999645344"></a></td>
                <td>復帰改行文字</td>
              </tr><tr>
                <td><code class="literal">\t</code><a class="indexterm" name="idm45826999641552"></a><a class="indexterm" name="idm45826999640336"></a></td>
                <td>タブ文字。</td>
              </tr><tr>
                <td><code class="literal">\Z</code><a class="indexterm" name="idm45826999636576"></a><a class="indexterm" name="idm45826999635360"></a></td>
                <td>ASCII 26 (Ctrl+Z)</td>
              </tr><tr>
                <td><code class="literal">\N</code><a class="indexterm" name="idm45826999631600"></a></td>
                <td>NULL</td>
              </tr></tbody></table></div><p>
            <code class="literal">\</code>でのエスケープ構文の詳細は、<a class="xref" href="language-structure.html#string-literals" title="9.1.1 文字列リテラル">セクション9.1.1「文字列リテラル」</a>を参照してください。
          </p><p>
            <code class="literal">FIELDS ESCAPED BY</code> 文字が空である場合、エスケープシーケンスの解釈は実行されません。
          </p></li><li class="listitem"><p>
            出力では、<code class="literal">FIELDS ESCAPED BY</code> 文字が空でない場合、その文字は、出力上で次の文字の前に付けるために使用されます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">FIELDS ESCAPED BY</code> 文字
              </p></li><li class="listitem"><p>
                <code class="literal">FIELDS [OPTIONALLY] ENCLOSED BY</code> 文字
              </p></li><li class="listitem"><p>
                <code class="literal">ENCLOSED BY</code> 文字が空または指定されていない場合の、<code class="literal">FIELDS TERMINATED BY</code> および <code class="literal">LINES TERMINATED BY</code> 値の最初の文字。
              </p></li><li class="listitem"><p>
                ASCII <code class="literal">0</code> (エスケープ文字のあとに実際に書き込まれる文字は 0 の値のバイトではなく、ASCII の<code class="literal">0</code>です)
              </p></li></ul></div><p>
            <code class="literal">FIELDS ESCAPED BY</code> 文字が空である場合は、どの文字もエスケープされず、<code class="literal">NULL</code> は <code class="literal">\N</code> ではなく、<code class="literal">NULL</code> として出力されます。 特に、データ内のフィールド値に今指定したリスト内のいずれかの文字が含まれている場合、空のエスケープ文字を指定することはおそらく適切な方法ではありません。 
          </p></li></ul></div><p>
        特定のケースでは、フィールド処理と行処理のオプションは相互に作用します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">LINES TERMINATED BY</code> が空の文字列であり、かつ <code class="literal">FIELDS TERMINATED BY</code> が空以外である場合、行は <code class="literal">FIELDS TERMINATED BY</code> でも終了します。
          </p></li><li class="listitem"><p>
            <code class="literal">FIELDS TERMINATED BY</code> と <code class="literal">FIELDS ENCLOSED BY</code> の値がどちらも空 (<code class="literal">''</code>) である場合は、固定行 (区切られていない) フォーマットが使用されます。 固定行フォーマットでは、フィールド間に区切り文字は使用されません (ただし、行ターミネータは引き続き存在できます)。 代わりに、カラム値は、そのフィールド内のすべての値を保持するために十分に広いフィールド幅を使用して読み取りと書き込みが行われます。 <code class="literal">TINYINT</code>、<code class="literal">SMALLINT</code>、<code class="literal">MEDIUMINT</code>、<code class="literal">INT</code>、および <code class="literal">BIGINT</code> では、宣言されている表示幅にかかわらず、フィールド幅はそれぞれ 4、6、8、11、および 20 です。 
          </p><p>
            <code class="literal">LINES TERMINATED BY</code> は引き続き、行を区切るために使用されます。 ある行にすべてのフィールドが含まれていない場合、カラムの残りの部分はそのデフォルト値に設定されます。 行ターミネータが存在しない場合は、これを <code class="literal">''</code> に設定してください。 この場合は、テキストファイルの各行にすべてのフィールドが含まれている必要があります。 
          </p><p>
            固定行フォーマットはまた、あとで説明されているように、<code class="literal">NULL</code> 値の処理にも影響を与えます。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              マルチバイト文字セットを使用している場合、固定サイズフォーマットは機能しません。
            </p></div></li></ul></div><p>
        <code class="literal">NULL</code> 値の処理は、使用されている <code class="literal">FIELDS</code> および <code class="literal">LINES</code> オプションによって異なります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            デフォルトの <code class="literal">FIELDS</code> および <code class="literal">LINES</code> 値では、<code class="literal">NULL</code> は出力として <code class="literal">\N</code> のフィールド値として書き込まれ、<code class="literal">\N</code> のフィールド値は入力として <code class="literal">NULL</code> として読み取られます (<code class="literal">ESCAPED BY</code> 文字は<code class="literal">\</code>であると仮定します)。
          </p></li><li class="listitem"><p>
            <code class="literal">FIELDS ENCLOSED BY</code> が空でない場合、リテラルワード <code class="literal">NULL</code> をその値として含むフィールドは <code class="literal">NULL</code> 値として読み取られます。 これは、文字列 <code class="literal">'NULL'</code> として読み取られる、<code class="literal">FIELDS ENCLOSED BY</code> 文字で囲まれたワード <code class="literal">NULL</code> とは異なります。 
          </p></li><li class="listitem"><p>
            <code class="literal">FIELDS ESCAPED BY</code> が空である場合、<code class="literal">NULL</code> はワード <code class="literal">NULL</code> として書き込まれます。
          </p></li><li class="listitem"><p>
            固定行フォーマット (これは、<code class="literal">FIELDS TERMINATED BY</code> と <code class="literal">FIELDS ENCLOSED BY</code> がどちらも空であるときに使用されます) では、<code class="literal">NULL</code> は空の文字列として書き込まれます。 これにより、<code class="literal">NULL</code> 値とテーブル内の空の文字列の両方が空の文字列として書き込まれるため、両方をファイルに書き込むときに区別できなくなります。 ファイルを読み戻したときにこの 2 つを区別できることが必要な場合は、固定行フォーマットを使用すべきではありません。 
          </p></li></ul></div><p>
        <code class="literal">NULL</code> を <code class="literal">NOT NULL</code> カラムにロードしようとすると、そのカラムのデータ型の暗黙のデフォルト値の割り当てが行われて警告が発生するか、または厳密な SQL モードではエラーが発生します。 暗黙のデフォルト値については、<a class="xref" href="data-types.html#data-type-defaults" title="11.6 データ型デフォルト値">セクション11.6「データ型デフォルト値」</a>で説明されています。 
      </p><p>
        一部のケースは、<code class="literal">LOAD DATA</code> でサポートされていません:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            固定サイズ行 (<code class="literal">FIELDS TERMINATED BY</code> と <code class="literal">FIELDS ENCLOSED BY</code> がどちらも空) および <code class="literal">BLOB</code> または <code class="literal">TEXT</code> カラム。
          </p></li><li class="listitem"><p>
            別のセパレータと同じセパレータまたは別のセパレータの接頭辞を指定すると、<code class="literal">LOAD DATA</code> は入力を正しく解釈できません。 たとえば、次の <code class="literal">FIELDS</code> 句では問題が発生します。 
          </p><pre class="programlisting">FIELDS TERMINATED BY '"' ENCLOSED BY '"'
</pre></li><li class="listitem"><p>
            <code class="literal">FIELDS ESCAPED BY</code> が空の場合、<code class="literal">FIELDS ENCLOSED BY</code> または <code class="literal">LINES TERMINATED BY</code> の出現箇所と <code class="literal">FIELDS TERMINATED BY</code> 値が含まれるフィールド値によって、<code class="literal">LOAD DATA</code> はフィールドまたは行の読取りを早すぎる状態で停止します。 これは、フィールドまたは行の値がどこで終了するかを <code class="literal">LOAD DATA</code> が適切に判断できないために発生します。 
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="load-data-column-list"></a>カラムリストの指定</h4></div></div></div><p>
        次の例では、<code class="literal">persondata</code> テーブルのすべてのカラムをロードします。
      </p><pre class="programlisting">LOAD DATA INFILE 'persondata.txt' INTO TABLE persondata;
</pre><p>
        デフォルトでは、<code class="literal">LOAD DATA</code> ステートメントの最後にカラムリストが指定されていない場合、入力行には各テーブルのカラムのフィールドが含まれている必要があります。 テーブルのカラムの一部のみをロードする場合は、カラムリストを指定します。 
      </p><pre class="programlisting">LOAD DATA INFILE 'persondata.txt' INTO TABLE persondata
(<em class="replaceable"><code>col_name_or_user_var</code></em> [, <em class="replaceable"><code>col_name_or_user_var</code></em>] ...);
</pre><p>
        カラムリストはまた、入力ファイル内のフィールドの順序がテーブル内のカラムの順序と異なる場合にも指定する必要があります。 そうしないと、MySQL は、入力フィールドとテーブルカラムを一致させる方法がわかりません。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="load-data-input-preprocessing"></a>入力前処理</h4></div></div></div><p>
        各 <em class="replaceable"><code>col_name_or_user_var</code></em> 値は、カラム名またはユーザー変数のいずれかです。 ユーザー変数を使用すると、結果をカラムに割り当てる前に、<code class="literal">SET</code> 句を使用して値に対して前処理変換を実行できます。 
      </p><p>
        <code class="literal">SET</code> 句内のユーザー変数は、いくつかの方法で使用できます。 次の例では、最初の入力カラムを直接 <code class="literal">t1.column1</code> の値に使用し、2 番目の入力カラムを、<code class="literal">t1.column2</code> の値に使用される前に除算演算の対象になるユーザー変数に割り当てます。 
      </p><pre class="programlisting">LOAD DATA INFILE 'file.txt'
  INTO TABLE t1
  (column1, @var1)
  SET column2 = @var1/100;
</pre><p>
        <code class="literal">SET</code> 句を使用すると、入力ファイルからは取得されない値を指定できます。 次のステートメントは、<code class="literal">column3</code> を現在の日付と時間に設定します。 
      </p><pre class="programlisting">LOAD DATA INFILE 'file.txt'
  INTO TABLE t1
  (column1, column2)
  SET column3 = CURRENT_TIMESTAMP;
</pre><p>
        入力値をユーザー変数に割り当て、その変数をテーブルカラムには代入しないようにして、その値を破棄することもできます。
      </p><pre class="programlisting">LOAD DATA INFILE 'file.txt'
  INTO TABLE t1
  (column1, @dummy, column2, @dummy, column3);
</pre><p>
        カラム/変数リストと <code class="literal">SET</code> 句の使用は、次の制限に従います。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">SET</code> 句の代入では、割り当て演算子の左側にカラム名のみを置くようにしてください。
          </p></li><li class="listitem"><p>
            <code class="literal">SET</code> の代入の右側では、サブクエリーを使用できます。 カラムに代入される値を返すサブクエリーとして使用できるのは、スカラーサブクエリーだけです。 また、サブクエリーを使用して、ロードされているテーブルから選択することはできません。 
          </p></li><li class="listitem"><p>
            <code class="literal">IGNORE</code> 句によって無視された行は、カラム/変数リストや <code class="literal">SET</code> 句では処理されません。
          </p></li><li class="listitem"><p>
            ユーザー変数には表示幅がないため、固定行フォーマットのデータをロードする場合はユーザー変数を使用できません。
          </p></li></ul></div><p>
        入力行を処理する場合、<code class="literal">LOAD DATA</code> はそれをフィールドに分割し、カラム/変数リストと <code class="literal">SET</code> 句に応じた値 (存在する場合) を使用します。 そのあと、結果として得られる行がテーブルに挿入されます。 そのテーブルに <code class="literal">BEFORE INSERT</code> または <code class="literal">AFTER INSERT</code> トリガーが存在する場合、これらのトリガーはそれぞれ、行挿入の前またはあとにアクティブ化されます。 
      </p><p>
        入力行に含まれるフィールドが多すぎる場合は、余分なフィールドが無視され、警告数が 1 増えます。
      </p><p>
        入力行に含まれるフィールドが少なすぎる場合、入力フィールドがないテーブルカラムはそのデフォルト値に設定されます。 デフォルト値の割り当てについては、<a class="xref" href="data-types.html#data-type-defaults" title="11.6 データ型デフォルト値">セクション11.6「データ型デフォルト値」</a>で説明されています。 
      </p><p>
        空のフィールド値はフィールドがないとは見なされず、次のように解釈されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            文字列型の場合、このカラムは空の文字列に設定されます。
          </p></li><li class="listitem"><p>
            数値型の場合、このカラムは <code class="literal">0</code> に設定されます。
          </p></li><li class="listitem"><p>
            日付と時間型の場合、このカラムはその型の適切な<span class="quote">「<span class="quote">0</span>」</span>の値に設定されます。 <a class="xref" href="data-types.html#date-and-time-types" title="11.2 日時データ型">セクション11.2「日時データ型」</a>を参照してください。 
          </p></li></ul></div><p>
        これらは、<code class="literal">INSERT</code> または <code class="literal">UPDATE</code> ステートメントで空の文字列を文字列、数値、日付または時間の各型に明示的に割り当てた場合の結果と同じ値です。
      </p><p>
        空のフィールド値や正しくないフィールド値の処理は、SQL モードが制限的な値に設定されていると、今説明した処理とは異なってきます。 たとえば、<code class="literal">sql_mode</code> が <code class="literal">TRADITIONAL</code> に設定されている場合、空の値または数値カラムの<code class="literal">'x'</code>などの値を変換すると、0 に変換されるのではなくエラーになります。 (<code class="literal">LOCAL</code> または <code class="literal">IGNORE</code> では、制限付き <code class="literal">sql_mode</code> 値であっても、エラーではなく警告が発生し、非制限 SQL モードで使用されるのと同じ最も近い値の動作を使用して行が挿入されます。 これは、操作中にサーバーがファイルの転送を停止する方法がないために発生します。) 
      </p><p>
        <code class="literal">TIMESTAMP</code> カラムが現在の日付と時間に設定されるのは、そのカラムに <code class="literal">NULL</code> 値 (つまり、<code class="literal">\N</code>) が存在し、かつそのカラムが <code class="literal">NULL</code> 値を許可するように宣言されていない場合、または <code class="literal">TIMESTAMP</code> カラムのデフォルト値が現在のタイムスタンプであり、かつフィールドリストが指定されたときにこのカラムがフィールドリストから省略されている場合だけです。
      </p><p>
        <code class="literal">LOAD DATA</code> はすべての入力を文字列とみなすため、<code class="literal">INSERT</code> ステートメントと同様に <code class="literal">ENUM</code> または <code class="literal">SET</code> カラムに数値を使用することはできません。 <code class="literal">ENUM</code> および <code class="literal">SET</code> 値はすべて、文字列として指定する必要があります。 
      </p><p>
        バイナリ表記法 (<code class="literal">b'011010'</code>など) を使用して <code class="literal">BIT</code> 値を直接ロードすることはできません。 これを回避するには、<code class="literal">SET</code> 句を使用して先頭の <code class="literal">b'</code>および末尾の<code class="literal">'</code>を削除し、base-2 から base-10 への変換を実行して MySQL が値を <code class="literal">BIT</code> カラムに適切にロードするようにします: 
      </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>cat /tmp/bit_test.txt</code></strong>
b'10'
b'1111111'
shell&gt; <strong class="userinput"><code>mysql test</code></strong>
mysql&gt; <strong class="userinput"><code>LOAD DATA INFILE '/tmp/bit_test.txt'</code></strong>
       <strong class="userinput"><code>INTO TABLE bit_test (@var1)</code></strong>
       <strong class="userinput"><code>SET b = CAST(CONV(MID(@var1, 3, LENGTH(@var1)-3), 2, 10) AS UNSIGNED);</code></strong>
Query OK, 2 rows affected (0.00 sec)
Records: 2  Deleted: 0  Skipped: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT BIN(b+0) FROM bit_test;</code></strong>
+----------+
| BIN(b+0) |
+----------+
| 10       |
| 1111111  |
+----------+
2 rows in set (0.00 sec)
</pre><p>
        <code class="literal">0b</code> バイナリ表記法 (<code class="literal">0b011010</code> など) の <code class="literal">BIT</code> 値の場合は、かわりに次の <code class="literal">SET</code> 句を使用して、先頭の <code class="literal">0b</code> を削除します:
      </p><pre class="programlisting">SET b = CAST(CONV(MID(@var1, 3, LENGTH(@var1)-2), 2, 10) AS UNSIGNED)
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="load-data-statement-result-information"></a>ステートメントの結果情報</h4></div></div></div><p>
        <code class="literal">LOAD DATA</code> ステートメントが終了すると、次の形式の情報文字列が返されます:
      </p><pre class="programlisting">Records: 1  Deleted: 0  Skipped: 0  Warnings: 0
</pre><p>
        警告は、<code class="literal">INSERT</code> ステートメント (<a class="xref" href="sql-statements.html#insert" title="13.2.6 INSERT ステートメント">セクション13.2.6「INSERT ステートメント」</a> を参照) を使用して値を挿入する場合と同じ状況で発生しますが、入力行のフィールドが少なすぎるか多すぎる場合にも <code class="literal">LOAD DATA</code> によって警告が生成される点が異なります。
      </p><p>
        <code class="literal">SHOW WARNINGS</code> を使用すると、発生した問題に関する情報として最初の <code class="literal">max_error_count</code> 警告のリストを取得できます。 <a class="xref" href="sql-statements.html#show-warnings" title="13.7.7.42 SHOW WARNINGS ステートメント">セクション13.7.7.42「SHOW WARNINGS ステートメント」</a>を参照してください。 
      </p><a class="indexterm" name="idm45826999459680"></a><p>
        C API を使用している場合は、<code class="literal">mysql_info()</code> 関数を呼び出すことによって、そのステートメントに関する情報を取得できます。 <a class="ulink" href="https://dev.mysql.com/doc/c-api/8.0/en/mysql-info.html" target="_top">mysql_info()</a>を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="load-data-miscellaneous"></a>その他のトピック</h4></div></div></div><p>
        Unix では、<code class="literal">LOAD DATA</code> でパイプから読み取る必要がある場合は次の手法を使用できます (この例では、<code class="filename">/</code> ディレクトリのリストをテーブル <code class="literal">db1.t1</code> にロードします)。
      </p><pre class="programlisting">mkfifo /mysql/data/db1/ls.dat
chmod 666 /mysql/data/db1/ls.dat
find / -ls &gt; /mysql/data/db1/ls.dat &amp;
mysql -e "LOAD DATA INFILE 'ls.dat' INTO TABLE t1" db1
</pre><p>
        ここでは、ロードするデータを生成するコマンドと <span class="command"><strong>mysql</strong></span> コマンドを別々の端末で実行するか、バックグラウンドでデータ生成プロセスを実行する必要があります (前述の例を参照)。 これを行わない場合、パイプは <span class="command"><strong>mysql</strong></span> プロセスによってデータが読み取られるまでブロックされます。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="load-xml"></a>13.2.8 LOAD XML ステートメント</h3></div></div></div><a class="indexterm" name="idm45826999446096"></a><pre class="programlisting">LOAD XML
    [LOW_PRIORITY | CONCURRENT] [LOCAL]
    INFILE '<em class="replaceable"><code>file_name</code></em>'
    [REPLACE | IGNORE]
    INTO TABLE [<em class="replaceable"><code>db_name</code></em>.]<em class="replaceable"><code>tbl_name</code></em>
    [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>]
    [ROWS IDENTIFIED BY '&lt;<em class="replaceable"><code>tagname</code></em>&gt;']
    [IGNORE <em class="replaceable"><code>number</code></em> {LINES | ROWS}]
    [(<em class="replaceable"><code>field_name_or_user_var</code></em>
        [, <em class="replaceable"><code>field_name_or_user_var</code></em>] ...)]
    [SET <em class="replaceable"><code>col_name</code></em>={<em class="replaceable"><code>expr</code></em> | DEFAULT}
        [, <em class="replaceable"><code>col_name</code></em>={<em class="replaceable"><code>expr</code></em> | DEFAULT}] ...]
</pre><p>
      <code class="literal">LOAD XML</code> ステートメントは、XML ファイルからテーブルにデータを読み取ります。 <em class="replaceable"><code>file_name</code></em> は、リテラル文字列として指定する必要があります。 オプションの <code class="literal">ROWS IDENTIFIED BY</code> 句内の <em class="replaceable"><code>tagname</code></em> もリテラル文字列として指定し、山括弧 (<code class="literal">&lt;</code> および <code class="literal">&gt;</code>) で囲む必要があります。 
    </p><p>
      <code class="literal">LOAD XML</code> は、XML 出力モードでの <span class="command"><strong>mysql</strong></span> クライアントの実行 (つまり、<code class="option">--xml</code> オプションを使用したクライアントの起動) を補完するものとして機能します。 テーブルから XML ファイルにデータを書き込むには、次に示すように、システムシェルから <code class="option">--xml</code> および <code class="option">-e</code> オプションを指定して <span class="command"><strong>mysql</strong></span> クライアントを呼び出すことができます: 
    </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysql --xml -e 'SELECT * FROM mydb.mytable' &gt; file.xml</code></strong>
</pre><p>
      ファイルをテーブルに読み取るには、<code class="literal">LOAD XML</code> を使用します。 デフォルトでは、<code class="literal">&lt;row&gt;</code> 要素は、データベーステーブル行と同等であると見なされます。これは、<code class="literal">ROWS IDENTIFIED BY</code> 句を使用して変更できます。 
    </p><p>
      このステートメントは、次の 3 つの異なる XML 形式をサポートします。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          属性としてのカラム名と、属性値としてのカラム値:
        </p><pre class="programlisting">&lt;<em class="replaceable"><code>row</code></em> <em class="replaceable"><code>column1</code></em>="<em class="replaceable"><code>value1</code></em>" <em class="replaceable"><code>column2</code></em>="<em class="replaceable"><code>value2</code></em>" .../&gt;
</pre></li><li class="listitem"><p>
          タグとしてのカラム名と、これらのタグの内容としてのカラム値:
        </p><pre class="programlisting">&lt;<em class="replaceable"><code>row</code></em>&gt;
  &lt;<em class="replaceable"><code>column1</code></em>&gt;<em class="replaceable"><code>value1</code></em>&lt;/<em class="replaceable"><code>column1</code></em>&gt;
  &lt;<em class="replaceable"><code>column2</code></em>&gt;<em class="replaceable"><code>value2</code></em>&lt;/<em class="replaceable"><code>column2</code></em>&gt;
&lt;/<em class="replaceable"><code>row</code></em>&gt;
</pre></li><li class="listitem"><p>
          カラム名は <code class="literal">&lt;field&gt;</code> タグの <code class="literal">name</code> 属性で、値はこれらのタグの内容:
        </p><pre class="programlisting">&lt;row&gt;
  &lt;field name='<em class="replaceable"><code>column1</code></em>'&gt;<em class="replaceable"><code>value1</code></em>&lt;/field&gt;
  &lt;field name='<em class="replaceable"><code>column2</code></em>'&gt;<em class="replaceable"><code>value2</code></em>&lt;/field&gt;
&lt;/row&gt;
</pre><p>
          これは、<span class="command"><strong>mysqldump</strong></span> などのほかの MySQL ツールによって使用される形式です。
        </p></li></ul></div><p>
      同じ XML ファイルで 3 つのすべての形式を使用できます。インポートルーチンは各行の形式を自動的に検出し、それを正しく解釈します。 タグは、タグまたは属性名とカラム名に基づいて照合されます。 
    </p><p>
      MySQL 8.0.21 より前は、<code class="literal">LOAD XML</code> はソース XML の <code class="literal">CDATA</code> セクションをサポートしていませんでした。 (Bug #30753708、Bug #98199) 
    </p><p>
      次の句は、基本的に <code class="literal">LOAD XML</code> に対して <code class="literal">LOAD DATA</code> に対する場合と同じように機能します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">LOW_PRIORITY</code> または <code class="literal">CONCURRENT</code>
        </p></li><li class="listitem"><p>
          <code class="literal">LOCAL</code>
        </p></li><li class="listitem"><p>
          <code class="literal">REPLACE</code> または <code class="literal">IGNORE</code>
        </p></li><li class="listitem"><p>
          <code class="literal">CHARACTER SET</code>
        </p></li><li class="listitem"><p>
          <code class="literal">SET</code>
        </p></li></ul></div><p>
      これらの句の詳細は、<a class="xref" href="sql-statements.html#load-data" title="13.2.7 LOAD DATA ステートメント">セクション13.2.7「LOAD DATA ステートメント」</a>を参照してください。
    </p><p>
      <code class="literal">(<em class="replaceable"><code>field_name_or_user_var</code></em>, ...)</code> は、カンマ区切りの XML フィールドまたはユーザー変数のリストです。 この目的で使用されるユーザー変数の名前は、接頭辞<code class="literal">@</code>が付いた XML ファイルのフィールドの名前と一致する必要があります。 フィールド名を使用して、目的のフィールドのみを選択できます。 ユーザー変数を使用して、後続の再利用のために対応するフィールド値を格納できます。 
    </p><p>
      <code class="literal">IGNORE <em class="replaceable"><code>number</code></em> LINES</code> または <code class="literal">IGNORE <em class="replaceable"><code>number</code></em> ROWS</code> 句を指定すると、XML ファイル内の最初の <em class="replaceable"><code>number</code></em> 行がスキップされます。 これは、<code class="literal">LOAD DATA</code> ステートメントの <code class="literal">IGNORE ... LINES</code> 句に類似しています。 
    </p><p>
      次に示すように作成された <code class="literal">person</code> という名前のテーブルがあるとします:
    </p><pre class="programlisting">USE test;

CREATE TABLE person (
    person_id INT NOT NULL PRIMARY KEY,
    fname VARCHAR(40) NULL,
    lname VARCHAR(40) NULL,
    created TIMESTAMP
);
</pre><p>
      さらに、このテーブルが最初は空であるとします。
    </p><p>
      ここで、次に示すような内容を持つ単純な XML ファイル <code class="filename">person.xml</code> があるとします。
    </p><pre class="programlisting">&lt;list&gt;
  &lt;person person_id="1" fname="Kapek" lname="Sainnouine"/&gt;
  &lt;person person_id="2" fname="Sajon" lname="Rondela"/&gt;
  &lt;person person_id="3"&gt;&lt;fname&gt;Likame&lt;/fname&gt;&lt;lname&gt;Örrtmons&lt;/lname&gt;&lt;/person&gt;
  &lt;person person_id="4"&gt;&lt;fname&gt;Slar&lt;/fname&gt;&lt;lname&gt;Manlanth&lt;/lname&gt;&lt;/person&gt;
  &lt;person&gt;&lt;field name="person_id"&gt;5&lt;/field&gt;&lt;field name="fname"&gt;Stoma&lt;/field&gt;
    &lt;field name="lname"&gt;Milu&lt;/field&gt;&lt;/person&gt;
  &lt;person&gt;&lt;field name="person_id"&gt;6&lt;/field&gt;&lt;field name="fname"&gt;Nirtam&lt;/field&gt;
    &lt;field name="lname"&gt;Sklöd&lt;/field&gt;&lt;/person&gt;
  &lt;person person_id="7"&gt;&lt;fname&gt;Sungam&lt;/fname&gt;&lt;lname&gt;Dulbåd&lt;/lname&gt;&lt;/person&gt;
  &lt;person person_id="8" fname="Sraref" lname="Encmelt"/&gt;
&lt;/list&gt;
</pre><p>
      例として示したこのファイルには、前に説明した許可される各 XML 形式が表されています。
    </p><p>
      <code class="filename">person.xml</code> 内のデータを <code class="literal">person</code> テーブルにインポートするには、次のステートメントを使用できます。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>LOAD XML LOCAL INFILE 'person.xml'</code></strong>
    -&gt;   <strong class="userinput"><code>INTO TABLE person</code></strong>
    -&gt;   <strong class="userinput"><code>ROWS IDENTIFIED BY '&lt;person&gt;';</code></strong>

Query OK, 8 rows affected (0.00 sec)
Records: 8  Deleted: 0  Skipped: 0  Warnings: 0
</pre><p>
      ここでは、<code class="filename">person.xml</code> が MySQL データディレクトリ内に存在することを前提にしています。 このファイルが見つからない場合は、次のエラーが発生します。 
    </p><pre class="programlisting"><span class="errortext">ERROR 2 (HY000): File '/person.xml' not found (Errcode: 2)</span>
</pre><p>
      <code class="literal">ROWS IDENTIFIED BY '&lt;person&gt;'</code> 句は、XML ファイル内の各 <code class="literal">&lt;person&gt;</code> 要素が、このデータがインポートされるテーブル内の各行と同等であると見なされることを示します。 この場合、これは <code class="literal">test</code> データベース内の <code class="literal">person</code> テーブルです。 
    </p><p>
      サーバーからの応答でわかるように、<code class="literal">test.person</code> テーブルには 8 行がインポートされました。 これは、単純な <code class="literal">SELECT</code> ステートメントで確認できます。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM person;</code></strong>
+-----------+--------+------------+---------------------+
| person_id | fname  | lname      | created             |
+-----------+--------+------------+---------------------+
|         1 | Kapek  | Sainnouine | 2007-07-13 16:18:47 |
|         2 | Sajon  | Rondela    | 2007-07-13 16:18:47 |
|         3 | Likame | Örrtmons   | 2007-07-13 16:18:47 |
|         4 | Slar   | Manlanth   | 2007-07-13 16:18:47 |
|         5 | Stoma  | Nilu       | 2007-07-13 16:18:47 |
|         6 | Nirtam | Sklöd      | 2007-07-13 16:18:47 |
|         7 | Sungam | Dulbåd     | 2007-07-13 16:18:47 |
|         8 | Sreraf | Encmelt    | 2007-07-13 16:18:47 |
+-----------+--------+------------+---------------------+
8 rows in set (0.00 sec)
</pre><p>
      これは、このセクションで前述したように、許可された 3 つの XML 形式のいずれかまたはすべてが単一のファイルに表示され、<code class="literal">LOAD XML</code> を使用して読み取ることができることを示しています。
    </p><p>
      インポート操作の逆を示します。つまり、次に示すように、MySQL テーブルデータを XML ファイルにダンプするには、<span class="command"><strong>mysql</strong></span> クライアントをシステムシェルから使用します:
    </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysql --xml -e "SELECT * FROM test.person" &gt; person-dump.xml</code></strong>
shell&gt; <strong class="userinput"><code>cat person-dump.xml</code></strong>
&lt;?xml version="1.0"?&gt;

&lt;resultset statement="SELECT * FROM test.person" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;row&gt;
	&lt;field name="person_id"&gt;1&lt;/field&gt;
	&lt;field name="fname"&gt;Kapek&lt;/field&gt;
	&lt;field name="lname"&gt;Sainnouine&lt;/field&gt;
  &lt;/row&gt;

  &lt;row&gt;
	&lt;field name="person_id"&gt;2&lt;/field&gt;
	&lt;field name="fname"&gt;Sajon&lt;/field&gt;
	&lt;field name="lname"&gt;Rondela&lt;/field&gt;
  &lt;/row&gt;

  &lt;row&gt;
	&lt;field name="person_id"&gt;3&lt;/field&gt;
	&lt;field name="fname"&gt;Likema&lt;/field&gt;
	&lt;field name="lname"&gt;Örrtmons&lt;/field&gt;
  &lt;/row&gt;

  &lt;row&gt;
	&lt;field name="person_id"&gt;4&lt;/field&gt;
	&lt;field name="fname"&gt;Slar&lt;/field&gt;
	&lt;field name="lname"&gt;Manlanth&lt;/field&gt;
  &lt;/row&gt;

  &lt;row&gt;
	&lt;field name="person_id"&gt;5&lt;/field&gt;
	&lt;field name="fname"&gt;Stoma&lt;/field&gt;
	&lt;field name="lname"&gt;Nilu&lt;/field&gt;
  &lt;/row&gt;

  &lt;row&gt;
	&lt;field name="person_id"&gt;6&lt;/field&gt;
	&lt;field name="fname"&gt;Nirtam&lt;/field&gt;
	&lt;field name="lname"&gt;Sklöd&lt;/field&gt;
  &lt;/row&gt;

  &lt;row&gt;
	&lt;field name="person_id"&gt;7&lt;/field&gt;
	&lt;field name="fname"&gt;Sungam&lt;/field&gt;
	&lt;field name="lname"&gt;Dulbåd&lt;/field&gt;
  &lt;/row&gt;

  &lt;row&gt;
	&lt;field name="person_id"&gt;8&lt;/field&gt;
	&lt;field name="fname"&gt;Sreraf&lt;/field&gt;
	&lt;field name="lname"&gt;Encmelt&lt;/field&gt;
  &lt;/row&gt;
&lt;/resultset&gt;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="option">--xml</code> オプションを指定すると、<span class="command"><strong>mysql</strong></span> クライアントは、その出力として XML 形式を使用します。<code class="option">-e</code> オプションを指定すると、クライアントはそのオプションの直後にある SQL ステートメントを実行します。 <a class="xref" href="programs.html#mysql" title="4.5.1 mysql — MySQL コマンドラインクライアント">セクション4.5.1「mysql — MySQL コマンドラインクライアント」</a>を参照してください。 
      </p></div><p>
      ダンプが有効であることを確認するには、次のように、<code class="literal">person</code> テーブルのコピーを作成し、ダンプファイルを新しいテーブルにインポートします:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE person2 LIKE person;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>LOAD XML LOCAL INFILE 'person-dump.xml'</code></strong>
    -&gt;   <strong class="userinput"><code>INTO TABLE person2;</code></strong>
Query OK, 8 rows affected (0.01 sec)
Records: 8  Deleted: 0  Skipped: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM person2;</code></strong>
+-----------+--------+------------+---------------------+
| person_id | fname  | lname      | created             |
+-----------+--------+------------+---------------------+
|         1 | Kapek  | Sainnouine | 2007-07-13 16:18:47 |
|         2 | Sajon  | Rondela    | 2007-07-13 16:18:47 |
|         3 | Likema | Örrtmons   | 2007-07-13 16:18:47 |
|         4 | Slar   | Manlanth   | 2007-07-13 16:18:47 |
|         5 | Stoma  | Nilu       | 2007-07-13 16:18:47 |
|         6 | Nirtam | Sklöd      | 2007-07-13 16:18:47 |
|         7 | Sungam | Dulbåd     | 2007-07-13 16:18:47 |
|         8 | Sreraf | Encmelt    | 2007-07-13 16:18:47 |
+-----------+--------+------------+---------------------+
8 rows in set (0.00 sec)
</pre><p>
      XML ファイルのすべてのフィールドが、対応するテーブルのカラムと一致する必要はありません。 対応するカラムがないフィールドはスキップされます。 これを確認するには、まず <code class="literal">person2</code> テーブルを空にして <code class="literal">created</code> カラムを削除してから、前に使用したのと同じ <code class="literal">LOAD XML</code> ステートメントを次のように使用します: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>TRUNCATE person2;</code></strong>
Query OK, 8 rows affected (0.26 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE person2 DROP COLUMN created;</code></strong>
Query OK, 0 rows affected (0.52 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE person2\G</code></strong>
*************************** 1. row ***************************
       Table: person2
Create Table: CREATE TABLE `person2` (
  `person_id` int(11) NOT NULL,
  `fname` varchar(40) DEFAULT NULL,
  `lname` varchar(40) DEFAULT NULL,
  PRIMARY KEY (`person_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>LOAD XML LOCAL INFILE 'person-dump.xml'</code></strong>
    -&gt;   <strong class="userinput"><code>INTO TABLE person2;</code></strong>
Query OK, 8 rows affected (0.01 sec)
Records: 8  Deleted: 0  Skipped: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM person2;</code></strong>
+-----------+--------+------------+
| person_id | fname  | lname      |
+-----------+--------+------------+
|         1 | Kapek  | Sainnouine |
|         2 | Sajon  | Rondela    |
|         3 | Likema | Örrtmons   |
|         4 | Slar   | Manlanth   |
|         5 | Stoma  | Nilu       |
|         6 | Nirtam | Sklöd      |
|         7 | Sungam | Dulbåd     |
|         8 | Sreraf | Encmelt    |
+-----------+--------+------------+
8 rows in set (0.00 sec)
</pre><p>
      XML ファイルの各行でフィールドが指定される順序は、<code class="literal">LOAD XML</code> の操作には影響しません。フィールドの順序は行によって異なる場合があり、テーブル内の対応するカラムと同じ順序である必要はありません。
    </p><p>
      前述のように、XML の 1 つ以上のフィールド (目的のフィールドのみを選択する場合) またはユーザー変数 (後で使用するために対応するフィールド値を格納する場合) の <code class="literal">(<em class="replaceable"><code>field_name_or_user_var</code></em>, ...)</code> リストを使用できます。 ユーザー変数は、XML ファイルの名前が XML フィールドの名前と一致しないテーブルのカラムにデータを挿入する場合に特に役立ちます。 これがどのように機能するかを確認するには、まず、<code class="literal">person</code> テーブルの構造と一致するが、カラムの名前が異なる <code class="literal">individual</code> という名前のテーブルを作成します: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE individual (</code></strong>
    -&gt;     <strong class="userinput"><code>individual_id INT NOT NULL PRIMARY KEY,</code></strong>
    -&gt;     <strong class="userinput"><code>name1 VARCHAR(40) NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>name2 VARCHAR(40) NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>made TIMESTAMP</code></strong>
    -&gt; );
Query OK, 0 rows affected (0.42 sec)
</pre><p>
      この場合、フィールド名とカラム名が一致しないため、XML ファイルをテーブルに直接ロードすることはできません:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>LOAD XML INFILE '../bin/person-dump.xml' INTO TABLE test.individual;</code></strong>
ERROR 1263 (22004): Column set to default value; NULL supplied to NOT NULL column 'individual_id' at row 1
</pre><p>
      これは、MySQL サーバーがターゲットテーブルのカラム名と一致するフィールド名を検索するために発生します。 この問題を回避するには、フィールド値をユーザー変数に選択し、<code class="literal">SET</code> を使用してターゲットテーブルのカラムをそれらの変数の値と同じに設定します。 次に示すように、これらの操作は両方とも単一のステートメントで実行できます: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>LOAD XML INFILE '../bin/person-dump.xml'</code></strong>
    -&gt;     <strong class="userinput"><code>INTO TABLE test.individual (@person_id, @fname, @lname, @created)</code></strong>
    -&gt;     <strong class="userinput"><code>SET individual_id=@person_id, name1=@fname, name2=@lname, made=@created;</code></strong>
Query OK, 8 rows affected (0.05 sec)
Records: 8  Deleted: 0  Skipped: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM individual;</code></strong>
+---------------+--------+------------+---------------------+
| individual_id | name1  | name2      | made                |
+---------------+--------+------------+---------------------+
|             1 | Kapek  | Sainnouine | 2007-07-13 16:18:47 |
|             2 | Sajon  | Rondela    | 2007-07-13 16:18:47 |
|             3 | Likema | Örrtmons   | 2007-07-13 16:18:47 |
|             4 | Slar   | Manlanth   | 2007-07-13 16:18:47 |
|             5 | Stoma  | Nilu       | 2007-07-13 16:18:47 |
|             6 | Nirtam | Sklöd      | 2007-07-13 16:18:47 |
|             7 | Sungam | Dulbåd     | 2007-07-13 16:18:47 |
|             8 | Srraf  | Encmelt    | 2007-07-13 16:18:47 |
+---------------+--------+------------+---------------------+
8 rows in set (0.00 sec)
</pre><p>
      ユーザー変数の名前は、XML ファイルの対応するフィールドの名前と一致し、変数であることを示す必須の<code class="literal">@</code>接頭辞が追加されている必要があります。 ユーザー変数は、対応するフィールドと同じ順序でリストまたは割り当てる必要はありません。 
    </p><p>
      <code class="literal">ROWS IDENTIFIED BY '&lt;<em class="replaceable"><code>tagname</code></em>&gt;'</code> 句を使用すると、同じ XML ファイルのデータを定義の異なるデータベーステーブルにインポートできます。 この例では、次の XML を含む <code class="filename">address.xml</code> という名前のファイルがあるとします。 
    </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;

&lt;list&gt;
  &lt;person person_id="1"&gt;
    &lt;fname&gt;Robert&lt;/fname&gt;
    &lt;lname&gt;Jones&lt;/lname&gt;
    &lt;address address_id="1" street="Mill Creek Road" zip="45365" city="Sidney"/&gt;
    &lt;address address_id="2" street="Main Street" zip="28681" city="Taylorsville"/&gt;
  &lt;/person&gt;

  &lt;person person_id="2"&gt;
    &lt;fname&gt;Mary&lt;/fname&gt;
    &lt;lname&gt;Smith&lt;/lname&gt;
    &lt;address address_id="3" street="River Road" zip="80239" city="Denver"/&gt;
    &lt;!-- &lt;address address_id="4" street="North Street" zip="37920" city="Knoxville"/&gt; --&gt;
  &lt;/person&gt;

&lt;/list&gt;
</pre><p>
      ここでも、このセクションで前に定義された <code class="literal">test.person</code> テーブルを使用できます。テーブルの既存のすべてのレコードをクリアしたあと、次に示すようにその構造を表示します。
    </p><pre class="programlisting">mysql&lt; <strong class="userinput"><code>TRUNCATE person;</code></strong>
Query OK, 0 rows affected (0.04 sec)

mysql&lt; <strong class="userinput"><code>SHOW CREATE TABLE person\G</code></strong>
*************************** 1. row ***************************
       Table: person
Create Table: CREATE TABLE `person` (
  `person_id` int(11) NOT NULL,
  `fname` varchar(40) DEFAULT NULL,
  `lname` varchar(40) DEFAULT NULL,
  `created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`person_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4
1 row in set (0.00 sec)
</pre><p>
      次に、次の <code class="literal">CREATE TABLE</code> ステートメントを使用して、<code class="literal">test</code> データベース内に <code class="literal">address</code> テーブルを作成します。
    </p><pre class="programlisting">CREATE TABLE address (
    address_id INT NOT NULL PRIMARY KEY,
    person_id INT NULL,
    street VARCHAR(40) NULL,
    zip INT NULL,
    city VARCHAR(40) NULL,
    created TIMESTAMP
);
</pre><p>
      XML ファイルのデータを <code class="literal">person</code> テーブルにインポートするには、次に示すように、行が <code class="literal">&lt;person&gt;</code> 要素で指定されるように指定する次の <code class="literal">LOAD XML</code> ステートメントを実行します。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>LOAD XML LOCAL INFILE 'address.xml'</code></strong>
    -&gt;   <strong class="userinput"><code>INTO TABLE person</code></strong>
    -&gt;   <strong class="userinput"><code>ROWS IDENTIFIED BY '&lt;person&gt;';</code></strong>
Query OK, 2 rows affected (0.00 sec)
Records: 2  Deleted: 0  Skipped: 0  Warnings: 0
</pre><p>
      <code class="literal">SELECT</code> ステートメントを使用して、レコードがインポートされたことを確認できます。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM person;</code></strong>
+-----------+--------+-------+---------------------+
| person_id | fname  | lname | created             |
+-----------+--------+-------+---------------------+
|         1 | Robert | Jones | 2007-07-24 17:37:06 |
|         2 | Mary   | Smith | 2007-07-24 17:37:06 |
+-----------+--------+-------+---------------------+
2 rows in set (0.00 sec)
</pre><p>
      XML ファイル内の <code class="literal">&lt;address&gt;</code> 要素は、<code class="literal">person</code> テーブル内に対応するカラムがないためスキップされます。
    </p><p>
      <code class="literal">&lt;address&gt;</code> 要素のデータを <code class="literal">address</code> テーブルにインポートするには、次に示す <code class="literal">LOAD XML</code> ステートメントを使用します。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>LOAD XML LOCAL INFILE 'address.xml'</code></strong>
    -&gt;   <strong class="userinput"><code>INTO TABLE address</code></strong>
    -&gt;   <strong class="userinput"><code>ROWS IDENTIFIED BY '&lt;address&gt;';</code></strong>
Query OK, 3 rows affected (0.00 sec)
Records: 3  Deleted: 0  Skipped: 0  Warnings: 0
</pre><p>
      次のような <code class="literal">SELECT</code> ステートメントを使用して、データがインポートされたこと確認できます。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM address;</code></strong>
+------------+-----------+-----------------+-------+--------------+---------------------+
| address_id | person_id | street          | zip   | city         | created             |
+------------+-----------+-----------------+-------+--------------+---------------------+
|          1 |         1 | Mill Creek Road | 45365 | Sidney       | 2007-07-24 17:37:37 |
|          2 |         1 | Main Street     | 28681 | Taylorsville | 2007-07-24 17:37:37 |
|          3 |         2 | River Road      | 80239 | Denver       | 2007-07-24 17:37:37 |
+------------+-----------+-----------------+-------+--------------+---------------------+
3 rows in set (0.00 sec)
</pre><p>
      <code class="literal">&lt;address&gt;</code> 要素のデータのうち、XML コメントで囲まれているものはインポートされません。 ただし、<code class="literal">address</code> テーブルには <code class="literal">person_id</code> カラムがあるため、各 <code class="literal">&lt;address&gt;</code> に対する親の <code class="literal">&lt;person&gt;</code> 要素の <code class="literal">person_id</code> 属性の値は <code class="literal">address</code> テーブルにインポートされ<span class="emphasis"><em>ます</em></span>。 
    </p><p><b>セキュリティー上の考慮事項. </b>
        <code class="literal">LOAD DATA</code> ステートメントと同様に、クライアントホストからサーバーホストへの XML ファイルの転送は MySQL サーバーによって開始されます。 理論上は、<code class="literal">LOAD XML</code> ステートメント内でクライアントによって指定されたファイルではなく、サーバーが選択したファイルを転送するようにクライアントプログラムに指示する、パッチが適用されたサーバーを構築できます。 そのようなサーバーは、クライアントユーザーが読み取りアクセス権を持つクライアントホスト上のすべてのファイルにアクセスできます。 
      </p><p>
      Web 環境では、クライアントは通常、Web サーバーから MySQL に接続します。 MySQL サーバーに対して任意のコマンドを実行できるユーザーは、<code class="literal">LOAD XML LOCAL</code> を使用して、Web サーバープロセスが読み取りアクセス権を持つどのファイルでも読み取ることができます。 この環境では、そのクライアントは MySQL サーバーに対して、Web サーバーに接続するユーザーによって実行されているリモートプログラムではなく、実際に Web サーバーです。 
    </p><p>
      <code class="literal">--local-infile=0</code> または <code class="literal">--local-infile=OFF</code> を使用してサーバーを起動することによって、クライアントからの XML ファイルのロードを無効にすることができます。 このオプションはまた、クライアントセッションの期間中は <code class="literal">LOAD XML</code> を無効にするように <span class="command"><strong>mysql</strong></span> クライアントを起動する場合にも使用できます。 
    </p><p>
      クライアントがサーバーから XML ファイルをロードしないようにするために、対応する MySQL ユーザーアカウントには <code class="literal">FILE</code> 権限を付与しないようにするか、またはクライアントユーザーアカウントがすでにこの権限を持っている場合は取り消してください。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        <code class="literal">FILE</code> 権限を取り消す (または最初に付与しない) と、ユーザーは <code class="literal">LOAD XML</code> ステートメント (および <code class="literal">LOAD_FILE()</code> 関数) の実行のみを保持し、<code class="literal">LOAD XML LOCAL</code> の実行を妨げることはありません。 このステートメントを禁止するには、サーバーまたはクライアントを <code class="option">--local-infile=OFF</code> で起動する必要があります。 
      </p><p>
        つまり、<code class="literal">FILE</code> 権限は、そのクライアントがサーバー上のファイルを読み取れるかどうかにのみ影響を与えます。そのクライアントがローカルファイルシステム上のファイルを読み取れるかどうかには関係しません。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replace"></a>13.2.9 REPLACE ステートメント</h3></div></div></div><a class="indexterm" name="idm45826999236368"></a><pre class="programlisting">REPLACE [LOW_PRIORITY | DELAYED]
    [INTO] <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em> [, <em class="replaceable"><code>partition_name</code></em>] ...)]
    [(<em class="replaceable"><code>col_name</code></em> [, <em class="replaceable"><code>col_name</code></em>] ...)]
    { {VALUES | VALUE} (<em class="replaceable"><code>value_list</code></em>) [, (<em class="replaceable"><code>value_list</code></em>)] ...
      |
      VALUES <em class="replaceable"><code>row_constructor_list</code></em>
    }

REPLACE [LOW_PRIORITY | DELAYED]
    [INTO] <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em> [, <em class="replaceable"><code>partition_name</code></em>] ...)]
    SET <em class="replaceable"><code>assignment_list</code></em>

REPLACE [LOW_PRIORITY | DELAYED]
    [INTO] <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em> [, <em class="replaceable"><code>partition_name</code></em>] ...)]
    [(<em class="replaceable"><code>col_name</code></em> [, <em class="replaceable"><code>col_name</code></em>] ...)]
    {SELECT ... | TABLE <em class="replaceable"><code>table_name</code></em>}

<em class="replaceable"><code>value</code></em>:
    {<em class="replaceable"><code>expr</code></em> | DEFAULT}

<em class="replaceable"><code>value_list</code></em>:
    <em class="replaceable"><code>value</code></em> [, <em class="replaceable"><code>value</code></em>] ...

<em class="replaceable"><code>row_constructor_list</code></em>:
    ROW(<em class="replaceable"><code>value_list</code></em>)[, ROW(<em class="replaceable"><code>value_list</code></em>)][, ...]

<em class="replaceable"><code>assignment</code></em>:
    <em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>value</code></em>

<em class="replaceable"><code>assignment_list</code></em>:
    <em class="replaceable"><code>assignment</code></em> [, <em class="replaceable"><code>assignment</code></em>] ...
</pre><p>
      <code class="literal">REPLACE</code> は、<code class="literal">INSERT</code> とまったく同じように機能します。ただし、テーブル内の古い行に、<code class="literal">PRIMARY KEY</code> または <code class="literal">UNIQUE</code> インデックスに関して新しい行と同じ値が含まれている場合、その古い行は新しい行が挿入される前に削除されます。 <a class="xref" href="sql-statements.html#insert" title="13.2.6 INSERT ステートメント">セクション13.2.6「INSERT ステートメント」</a>を参照してください。 
    </p><p>
      <code class="literal">REPLACE</code> は、SQL 標準への MySQL 拡張です。 これは挿入を行うか、または<span class="emphasis"><em>削除</em></span>と挿入を行います。 標準 SQL への別の MySQL 拡張 (挿入または<span class="emphasis"><em>更新</em></span>を行います) については、<a class="xref" href="sql-statements.html#insert-on-duplicate" title="13.2.6.2 INSERT ... ON DUPLICATE KEY UPDATE ステートメント">セクション13.2.6.2「INSERT ... ON DUPLICATE KEY UPDATE ステートメント」</a>を参照してください。 
    </p><p>
      <code class="literal">DELAYED</code> の挿入および置換は、MySQL 5.6 で非推奨になりました。 MySQL 8.0 では、<code class="literal">DELAYED</code> はサポートされません。 サーバーは <code class="literal">DELAYED</code> キーワードを認識しますが、無視し、置換を遅延なし置換として処理し、<code class="literal">ER_WARN_LEGACY_SYNTAX_CONVERTED</code> 警告を生成: <span class="errortext">REPLACE DELAYED はサポートされなくなりました。 ステートメントは REPLACE</span> に変換されました。 <code class="literal">DELAYED</code> キーワードは、将来のリリースで削除される予定です。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">REPLACE</code> は、テーブルに <code class="literal">PRIMARY KEY</code> または <code class="literal">UNIQUE</code> インデックスがある場合にのみ意味を持ちます。 それ以外の場合は、新しい行が別の行と重複するかどうかを判断するために使用されるインデックスがないため、<code class="literal">INSERT</code> と同等になります。 
      </p></div><p>
      すべてのカラムの値が <code class="literal">REPLACE</code> ステートメントで指定されている値から取得されます。 カラムがない場合は、<code class="literal">INSERT</code> での処理と同様に、そのカラムはそのデフォルト値に設定されます。 現在の行の値を参照し、それを新しい行で使用することはできません。 <code class="literal">SET <em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>col_name</code></em> + 1</code> などの代入を使用した場合、右側にあるカラム名への参照は <code class="literal">DEFAULT(<em class="replaceable"><code>col_name</code></em>)</code> として処理されるため、この代入は <code class="literal">SET <em class="replaceable"><code>col_name</code></em> = DEFAULT(<em class="replaceable"><code>col_name</code></em>) + 1</code> と同等です。 
    </p><p>
      MySQL 8.0.19 以降では、<code class="literal">REPLACE</code> が <code class="literal">VALUES ROW()</code> を使用して挿入を試みるカラム値を指定できます。
    </p><p>
      <code class="literal">REPLACE</code> を使用するには、このテーブルに対する <code class="literal">INSERT</code> 権限と <code class="literal">DELETE</code> 権限の両方が必要です。
    </p><a class="indexterm" name="idm45826999184448"></a><p>
      生成されたカラムが明示的に置換される場合、許可される値は <code class="literal">DEFAULT</code> のみです。 生成されるカラムの詳細は、<a class="xref" href="sql-statements.html#create-table-generated-columns" title="13.1.20.8 CREATE TABLE および生成されるカラム">セクション13.1.20.8「CREATE TABLE および生成されるカラム」</a> を参照してください。 
    </p><p>
      <code class="literal">REPLACE</code> では、パーティションまたはサブパーティション (あるいはその両方) のカンマ区切り名のリストを含む <code class="literal">PARTITION</code> キーワードを使用した明示的なパーティション選択がサポートされています。 <code class="literal">INSERT</code> と同様に、これらのいずれかのパーティションまたはサブパーティションに新しい行を挿入できない場合、<code class="literal">REPLACE</code> ステートメントは<span class="errortext">Found a row not matching the given partition set</span>.エラーで失敗します。 詳細および例については、<a class="xref" href="partitioning.html#partitioning-selection" title="24.5 パーティション選択">セクション24.5「パーティション選択」</a>を参照してください。 
    </p><p>
      <code class="literal">REPLACE</code> は、影響を受けた行数を示す数を返します。 これは、削除された行と挿入された行の合計です。 この数が単一行の <code class="literal">REPLACE</code> に対して 1 である場合は、行が挿入され、削除された行はありませんでした。 この数が 1 より大きい場合は、新しい行が挿入される前に 1 つ以上の古い行が削除されました。 テーブルに複数の一意のインデックスが存在するときに、新しい行が異なる一意のインデックス内の別の古い行の値を複製した場合は、単一行が複数の古い行を置き換えることがあります。 
    </p><p>
      影響を受けた行数により、<code class="literal">REPLACE</code> が行を追加しただけか、または行の置き換えも行なったかを判定することが容易になります。その数が 1 (追加した) か、またはそれより大きい (置き換えた) かをチェックします。
    </p><p>
      C API を使用している場合は、<code class="literal">mysql_affected_rows()</code> 関数を使用して、影響を受けた行数を取得できます。
    </p><p>
      テーブルに置換して、サブクエリーの同じテーブルから選択することはできません。
    </p><p>
      MySQL は、<code class="literal">REPLACE</code> (および <code class="literal">LOAD DATA ... REPLACE</code>) に次のアルゴリズムを使用します。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          テーブルへの新しい行の挿入を試みます
        </p></li><li class="listitem"><p>
          主キーまたは一意のインデックスに関する重複キーエラーが発生したために挿入が失敗している間、次のことを行います。
        </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>
              重複キー値を含む競合している行をテーブルから削除します
            </p></li><li class="listitem"><p>
              テーブルへの新しい行の挿入を再試行します
            </p></li></ol></div></li></ol></div><p>
      重複キーエラーが発生した場合、ストレージエンジンが削除と挿入ではなく、更新として <code class="literal">REPLACE</code> を実行する可能性がありますが、そのセマンティクスは同じです。 ストレージエンジンが <code class="literal">Handler_<em class="replaceable"><code>xxx</code></em></code> ステータス変数を増分する方法が異なる可能性がある以外、ユーザーに見える影響はありません。 
    </p><p>
      <code class="literal">REPLACE ... SELECT</code> ステートメントの結果は <code class="literal">SELECT</code> からの行の順序に依存し、この順序は常に保証されるわけではないため、ソースとスレーブが相違するようにこれらのステートメントをロギングするときに可能です。 このため、<code class="literal">REPLACE ... SELECT</code> ステートメントにはステートメントベースレプリケーションに対して安全でないフラグが付けられます。このようなステートメントは、ステートメントベースモードの使用時にエラーログに警告を生成し、<code class="literal">MIXED</code> モードの使用時に行ベースの形式を使用してバイナリログに書き込まれます。 <a class="xref" href="replication.html#replication-sbr-rbr" title="17.2.1.1 ステートメントベースおよび行ベースレプリケーションのメリットとデメリット">セクション17.2.1.1「ステートメントベースおよび行ベースレプリケーションのメリットとデメリット」</a>も参照してください。 
    </p><p>
      MySQL 8.0.19 以降では、<code class="literal">INSERT</code> と同様に、<code class="literal">TABLE</code> および <code class="literal">SELECT</code> with <code class="literal">REPLACE</code> がサポートされます。 詳細および例については、<a class="xref" href="sql-statements.html#insert-select" title="13.2.6.1 INSERT ... SELECT ステートメント">セクション13.2.6.1「INSERT ... SELECT ステートメント」</a>を参照してください。 
    </p><p>
      パーティション化されていない既存のテーブルをパーティション化に対応するように変更しているときや、すでにパーティション化されたテーブルのパーティション化を変更しているときに、そのテーブルの主キーの変更を検討する可能性があります (<a class="xref" href="partitioning.html#partitioning-limitations-partitioning-keys-unique-keys" title="24.6.1 パーティショニングキー、主キー、および一意キー">セクション24.6.1「パーティショニングキー、主キー、および一意キー」</a>を参照してください)。 これを行うと、パーティション化されていないテーブルの主キーを変更した場合と同様に、<code class="literal">REPLACE</code> ステートメントの結果が影響を受ける可能性があります。 次の <code class="literal">CREATE TABLE</code> ステートメントによって作成されたテーブルを考えてみます。 
    </p><pre class="programlisting">CREATE TABLE test (
  id INT UNSIGNED NOT NULL AUTO_INCREMENT,
  data VARCHAR(64) DEFAULT NULL,
  ts TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (id)
);
</pre><p>
      このテーブルを作成し、mysql クライアントに示されているステートメントを実行すると、結果は次のようになります。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>REPLACE INTO test VALUES (1, 'Old', '2014-08-20 18:47:00');</code></strong>
Query OK, 1 row affected (0.04 sec)

mysql&gt; <strong class="userinput"><code>REPLACE INTO test VALUES (1, 'New', '2014-08-20 18:47:42');</code></strong>
Query OK, 2 rows affected (0.04 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM test;</code></strong>
+----+------+---------------------+
| id | data | ts                  |
+----+------+---------------------+
|  1 | New  | 2014-08-20 18:47:42 |
+----+------+---------------------+
1 row in set (0.00 sec)
</pre><p>
      ここで、次に示すように (強調表示されたテキスト) 主キーが 2 つのカラムになっている点を除き、最初のテーブルとほぼ同一の 2 番目のテーブルを作成します。
    </p><pre class="programlisting">CREATE TABLE test2 (
  id INT UNSIGNED NOT NULL AUTO_INCREMENT,
  data VARCHAR(64) DEFAULT NULL,
  ts TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  <span class="emphasis"><em>PRIMARY KEY (id, ts)</em></span>
);
</pre><p>
      元の <code class="literal">test</code> テーブルに対して実行したのと同じ 2 つの <code class="literal">REPLACE</code> ステートメントを <code class="literal">test2</code> に対して実行すると、異なる結果が得られます。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>REPLACE INTO test2 VALUES (1, 'Old', '2014-08-20 18:47:00');</code></strong>
Query OK, 1 row affected (0.05 sec)

mysql&gt; <strong class="userinput"><code>REPLACE INTO test2 VALUES (1, 'New', '2014-08-20 18:47:42');</code></strong>
Query OK, 1 row affected (0.06 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM test2;</code></strong>
+----+------+---------------------+
| id | data | ts                  |
+----+------+---------------------+
|  1 | Old  | 2014-08-20 18:47:00 |
|  1 | New  | 2014-08-20 18:47:42 |
+----+------+---------------------+
2 rows in set (0.00 sec)
</pre><p>
      これは、<code class="literal">test2</code> に対して実行した場合は <code class="literal">id</code> カラムと <code class="literal">ts</code> カラムの両方の値が、置き換えられる行に対する既存の行の値に一致している必要があり、そうでないと行が挿入されるためです。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="select"></a>13.2.10 SELECT ステートメント</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#select-into">13.2.10.1 SELECT ... INTO ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#join">13.2.10.2 JOIN 句</a></span></dt><dt><span class="section"><a href="sql-statements.html#union">13.2.10.3 UNION 句</a></span></dt><dt><span class="section"><a href="sql-statements.html#parenthesized-query-expressions">13.2.10.4 カッコで囲まれたクエリー式</a></span></dt></dl></div><a class="indexterm" name="idm45826999122464"></a><pre class="programlisting">SELECT
    [ALL | DISTINCT | DISTINCTROW ]
    [HIGH_PRIORITY]
    [STRAIGHT_JOIN]
    [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
    [SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]
    <em class="replaceable"><code>select_expr</code></em> [, <em class="replaceable"><code>select_expr</code></em>] ...
    [<em class="replaceable"><code>into_option</code></em>]
    [FROM <em class="replaceable"><code>table_references</code></em>
      [PARTITION <em class="replaceable"><code>partition_list</code></em>]]
    [WHERE <em class="replaceable"><code>where_condition</code></em>]
    [GROUP BY {<em class="replaceable"><code>col_name</code></em> | <em class="replaceable"><code>expr</code></em> | <em class="replaceable"><code>position</code></em>}, ... [WITH ROLLUP]]
    [HAVING <em class="replaceable"><code>where_condition</code></em>]
    [WINDOW <em class="replaceable"><code>window_name</code></em> AS (<em class="replaceable"><code>window_spec</code></em>)
        [, <em class="replaceable"><code>window_name</code></em> AS (<em class="replaceable"><code>window_spec</code></em>)] ...]
    [ORDER BY {<em class="replaceable"><code>col_name</code></em> | <em class="replaceable"><code>expr</code></em> | <em class="replaceable"><code>position</code></em>}
      [ASC | DESC], ... [WITH ROLLUP]]
    [LIMIT {[<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em> | <em class="replaceable"><code>row_count</code></em> OFFSET <em class="replaceable"><code>offset</code></em>}]
    [<em class="replaceable"><code>into_option</code></em>]
    [FOR {UPDATE | SHARE}
        [OF <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ...]
        [NOWAIT | SKIP LOCKED]
      | LOCK IN SHARE MODE]
    [<em class="replaceable"><code>into_option</code></em>]

<em class="replaceable"><code>into_option</code></em>: {
    INTO OUTFILE '<em class="replaceable"><code>file_name</code></em>'
        [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>]
        <em class="replaceable"><code>export_options</code></em>
  | INTO DUMPFILE '<em class="replaceable"><code>file_name</code></em>'
  | INTO <em class="replaceable"><code>var_name</code></em> [, <em class="replaceable"><code>var_name</code></em>] ...
}
</pre><p>
      <code class="literal">SELECT</code> は、1 つ以上のテーブルから選択された行を取得するために使用され、<code class="literal">UNION</code> ステートメントとサブクエリーを含めることができます。 <a class="xref" href="sql-statements.html#union" title="13.2.10.3 UNION 句">セクション13.2.10.3「UNION 句」</a>および<a class="xref" href="sql-statements.html#subqueries" title="13.2.11 サブクエリー">セクション13.2.11「サブクエリー」</a>を参照してください。 <code class="literal">SELECT</code> ステートメントは、<code class="literal">WITH</code> 句で始まり、<code class="literal">SELECT</code> 内でアクセス可能な共通テーブル式を定義できます。 <a class="xref" href="sql-statements.html#with" title="13.2.15 WITH (共通テーブル式)">セクション13.2.15「WITH (共通テーブル式)」</a>を参照してください。 
    </p><p>
      <code class="literal">SELECT</code> ステートメントのもっとも一般的に使用される句は次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          各 <em class="replaceable"><code>select_expr</code></em> は、取得するカラムを示します。 少なくとも 1 つの <em class="replaceable"><code>select_expr</code></em> が存在する必要があります。 
        </p></li><li class="listitem"><p>
          <em class="replaceable"><code>table_references</code></em> は、行を取得する 1 つまたは複数のテーブルを示します。 その構文については、<a class="xref" href="sql-statements.html#join" title="13.2.10.2 JOIN 句">セクション13.2.10.2「JOIN 句」</a>で説明されています。 
        </p></li><li class="listitem"><p>
          <code class="literal">SELECT</code> では、<em class="replaceable"><code>table_reference</code></em> のテーブル名の後にパーティションまたはサブパーティション (あるいはその両方) のリストを含む <code class="literal">PARTITION</code> を使用した明示的なパーティション選択がサポートされています (<a class="xref" href="sql-statements.html#join" title="13.2.10.2 JOIN 句">セクション13.2.10.2「JOIN 句」</a> を参照)。 この場合、行はリストされているパーティションからのみ選択され、テーブルのほかのパーティションはすべて無視されます。 詳細および例については、<a class="xref" href="partitioning.html#partitioning-selection" title="24.5 パーティション選択">セクション24.5「パーティション選択」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">WHERE</code> 句 (指定されている場合) は、選択されるために行が満たす必要のある 1 つまたは複数の条件を示します。<em class="replaceable"><code>where_condition</code></em> は、選択される各行に対して true に評価される式です。 <code class="literal">WHERE</code> 句がない場合、このステートメントはすべての行を選択します。 
        </p><p>
          <code class="literal">WHERE</code> 式では、集計 (グループ) 関数を除き、MySQL でサポートされている任意の関数および演算子を使用できます。 <a class="xref" href="language-structure.html#expressions" title="9.5 式">セクション9.5「式」</a>および<a class="xref" href="functions.html" title="第 12 章 関数と演算子">第12章「<i>関数と演算子</i>」</a>を参照してください。 
        </p></li></ul></div><p>
      <code class="literal">SELECT</code> を使用して、どのテーブルも参照せずに計算された行を取得することもできます。
    </p><p>
      例:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT 1 + 1;</code></strong>
        -&gt; 2
</pre><p>
      <a class="indexterm" name="idm45826999070736"></a> テーブルが参照されない状況では、ダミーのテーブル名として <code class="literal">DUAL</code> を指定することが許可されます。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT 1 + 1 FROM DUAL;</code></strong>
        -&gt; 2
</pre><p>
      <code class="literal">DUAL</code> は純粋に、すべての <code class="literal">SELECT</code> ステートメントに <code class="literal">FROM</code> や、場合によってはその他の句が存在することを要求するユーザーの便宜のために用意されています。 MySQL は、これらの句を無視する可能性があります。 MySQL では、テーブルが参照されない場合でも <code class="literal">FROM DUAL</code> は必要ありません。 
    </p><p>
      一般に、使用される句は、正確に構文の説明で示されている順序で指定する必要があります。 たとえば、<code class="literal">HAVING</code> 句は、すべての <code class="literal">GROUP BY</code> 句のあとで、かつすべての <code class="literal">ORDER BY</code> 句の前にある必要があります。 <code class="literal">INTO</code> 句は、構文の説明で示されている任意の位置に指定できますが、特定のステートメント内に指定できるのは一度のみで、複数の位置には指定できません。 <code class="literal">INTO</code> の詳細は、<a class="xref" href="sql-statements.html#select-into" title="13.2.10.1 SELECT ... INTO ステートメント">セクション13.2.10.1「SELECT ... INTO ステートメント」</a>を参照してください。 
    </p><p>
      <em class="replaceable"><code>select_expr</code></em> 項のリストは、どのカラムを取得するかを示す選択リストで構成されています。 これらの項はカラムや式を指定するか、または <code class="literal">*</code> の短縮形を使用できます。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          1 つの修飾されていない <code class="literal">*</code> のみから成る選択リストは、すべてのテーブルのすべてのカラムを選択するための短縮形として使用できます。
        </p><pre class="programlisting">SELECT * FROM t1 INNER JOIN t2 ...
</pre></li><li class="listitem"><p>
          <code class="literal"><em class="replaceable"><code>tbl_name</code></em>.*</code> は、指定されたテーブルのすべてのカラムを選択するための修飾された短縮形として使用できます。
        </p><pre class="programlisting">SELECT t1.*, t2.* FROM t1 INNER JOIN t2 ...
</pre></li><li class="listitem"><p>
          テーブルに非表示カラムがある場合、<code class="literal">*</code> および <code class="literal"><em class="replaceable"><code>tbl_name</code></em>.*</code> には非表示カラムは含まれません。 非表示カラムを含めるには、明示的に参照する必要があります。 
        </p></li><li class="listitem"><p>
          修飾されていない <code class="literal">*</code> を選択リスト内のほかの項目とともに使用すると、解析エラーが生成される可能性があります。 この問題を回避するには、修飾された <code class="literal"><em class="replaceable"><code>tbl_name</code></em>.*</code> 参照を使用します。: 
        </p><pre class="programlisting">SELECT AVG(score), t1.* FROM t1 ...
</pre></li></ul></div><p>
      次のリストは、その他の <code class="literal">SELECT</code> 句に関する追加情報を示しています。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="indexterm" name="idm45826999039424"></a> <a class="indexterm" name="idm45826999037280"></a> <code class="literal">AS <em class="replaceable"><code>alias_name</code></em></code> を使用して、<em class="replaceable"><code>select_expr</code></em> にエイリアスを指定できます。 エイリアスは式のカラム名として使用され、<code class="literal">GROUP BY</code>、<code class="literal">ORDER BY</code>、または <code class="literal">HAVING</code> 句で使用できます。 例: 
        </p><pre class="programlisting">SELECT CONCAT(last_name,', ',first_name) AS full_name
  FROM mytable ORDER BY full_name;
</pre><p>
          <em class="replaceable"><code>select_expr</code></em> にエイリアスとして識別子を指定する場合、<code class="literal">AS</code> キーワードはオプションです。 前の例は、次のように記述することもできました。 
        </p><pre class="programlisting">SELECT CONCAT(last_name,', ',first_name) full_name
  FROM mytable ORDER BY full_name;
</pre><p>
          ただし、<code class="literal">AS</code> はオプションであるため、2 つの <em class="replaceable"><code>select_expr</code></em> 式の間のカンマを忘れると、軽微な問題が発生する可能性があります。MySQL は、2 番目の式をエイリアスとして解釈します。 たとえば、次のステートメントでは、<code class="literal">columnb</code> はエイリアスとして処理されます。 
        </p><pre class="programlisting">SELECT columna columnb FROM mytable;
</pre><p>
          このため、カラムのエイリアスを指定するときは <code class="literal">AS</code> を明示的に使用するようにすることをお勧めします。
        </p><p>
          <code class="literal">WHERE</code> 句が実行されるときはまだカラム値が決定されていない可能性があるため、<code class="literal">WHERE</code> 句内でカラムのエイリアスを参照することは許可されません。 <a class="xref" href="error-handling.html#problems-with-alias" title="B.3.4.4 カラムエイリアスに関する問題">セクションB.3.4.4「カラムエイリアスに関する問題」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm45826999019216"></a> <a class="indexterm" name="idm45826999017904"></a> <code class="literal">FROM <em class="replaceable"><code>table_references</code></em></code> 句は、行を取得する 1 つまたは複数のテーブルを示します。 複数のテーブルを指定すると、結合が実行されます。 結合構文については、<a class="xref" href="sql-statements.html#join" title="13.2.10.2 JOIN 句">セクション13.2.10.2「JOIN 句」</a>を参照してください。 指定されたテーブルごとに、オプションでエイリアスを指定できます。 
        </p><pre class="programlisting"><em class="replaceable"><code>tbl_name</code></em> [[AS] <em class="replaceable"><code>alias</code></em>] [<em class="replaceable"><code>index_hint</code></em>]
</pre><a class="indexterm" name="idm45826999012288"></a><a class="indexterm" name="idm45826999010800"></a><p>
          インデックスヒントを使用すると、クエリー処理中にインデックスを選択する方法に関する情報がオプティマイザに提供されます。 これらのヒントを指定するための構文については、<a class="xref" href="optimization.html#index-hints" title="8.9.4 インデックスヒント">セクション8.9.4「インデックスヒント」</a>を参照してください。 
        </p><p>
          代わりの方法として <code class="literal">SET max_seeks_for_key=<em class="replaceable"><code>value</code></em></code> を使用して、MySQL にテーブルスキャンの代わりにキースキャンを強制的に実行させることができます。 <a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          データベースを明示的に指定するために、デフォルトデータベース内でテーブルを <em class="replaceable"><code>tbl_name</code></em> または <em class="replaceable"><code>db_name</code></em>.<em class="replaceable"><code>tbl_name</code></em> として参照できます。 カラムを <em class="replaceable"><code>col_name</code></em>、<em class="replaceable"><code>tbl_name</code></em>.<em class="replaceable"><code>col_name</code></em> または <em class="replaceable"><code>db_name</code></em>.<em class="replaceable"><code>tbl_name</code></em>.<em class="replaceable"><code>col_name</code></em> として参照できます。 参照があいまいにならないかぎり、カラム参照のために <em class="replaceable"><code>tbl_name</code></em> または <em class="replaceable"><code>db_name</code></em>.<em class="replaceable"><code>tbl_name</code></em> プリフィクスを指定する必要はありません。 より明示的なカラム参照形式を必要とするあいまいさの例については、<a class="xref" href="language-structure.html#identifier-qualifiers" title="9.2.2 識別子の修飾子">セクション9.2.2「識別子の修飾子」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm45826998996464"></a> <a class="indexterm" name="idm45826998994352"></a>テーブル参照は、<code class="literal"><em class="replaceable"><code>tbl_name</code></em> AS <em class="replaceable"><code>alias_name</code></em></code> または <em class="replaceable"><code>tbl_name alias_name</code></em> を使用してエイリアス設定できます。 次のステートメントは同等です。 
        </p><pre class="programlisting">SELECT t1.name, t2.salary FROM employee AS t1, info AS t2
  WHERE t1.name = t2.name;

SELECT t1.name, t2.salary FROM employee t1, info t2
  WHERE t1.name = t2.name;
</pre></li><li class="listitem"><p>
          <a class="indexterm" name="idm45826998989248"></a> カラム名、カラムのエイリアス、またはカラム位置を使用して、出力のために選択されたカラムを <code class="literal">ORDER BY</code> および <code class="literal">GROUP BY</code> 句で参照できます。 カラム位置は整数であり、1 から始まります。 
        </p><pre class="programlisting">SELECT college, region, seed FROM tournament
  ORDER BY region, seed;

SELECT college, region AS r, seed AS s FROM tournament
  ORDER BY r, s;

SELECT college, region, seed FROM tournament
  ORDER BY 2, 3;
</pre><p>
          逆の順序でソートするには、ソートに使用する <code class="literal">ORDER BY</code> 句内のカラムの名前に <code class="literal">DESC</code> (降順) キーワードを追加します。 デフォルトは昇順です。これは、<code class="literal">ASC</code> キーワードを使用して明示的に指定できます。 
        </p><p>
          <code class="literal">ORDER BY</code> がカッコで囲まれたクエリー式内で発生し、外部クエリーにも適用される場合、結果は未定義であり、将来のバージョンの MySQL で変更される可能性があります。
        </p><p>
          カラム位置の使用は、この構文が SQL 標準から削除されたため非推奨です。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm45826998978896"></a> MySQL 8.0.13 より前では、MySQL は <code class="literal">GROUP BY</code> カラムの明示的な <code class="literal">ASC</code> または <code class="literal">DESC</code> 指定子を許可する非標準の構文拡張をサポートしていました。 MySQL 8.0.12 以降では、グループ化関数を使用した <code class="literal">ORDER BY</code> がサポートされているため、この拡張機能を使用する必要はなくなりました。 (Bug #86312、Bug #26073525) これは、<code class="literal">GROUP BY</code> の使用時に次のように任意のカラムでソートできることも意味します: 
        </p><pre class="programlisting">SELECT a, b, COUNT(c) AS t FROM test_table GROUP BY a,b ORDER BY a,t DESC;
</pre><p>
          MySQL 8.0.13 では、<code class="literal">GROUP BY</code> 拡張機能はサポートされなくなりました: <code class="literal">GROUP BY</code> カラムの <code class="literal">ASC</code> または <code class="literal">DESC</code> 指定子は許可されていません。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm45826998967072"></a> <a class="indexterm" name="idm45826998964912"></a> <code class="literal">ORDER BY</code> または <code class="literal">GROUP BY</code> を使用して <code class="literal">SELECT</code> のカラムをソートする場合、<code class="literal">max_sort_length</code> システム変数で指定された初期バイト数のみを使用して値がソートされます。
        </p></li><li class="listitem"><p>
          MySQL では、<code class="literal">GROUP BY</code> の使用が、<code class="literal">GROUP BY</code> 句で指定されていないフィールドの選択を許可するように拡張されています。 クエリーから期待する結果が得られない場合は、<a class="xref" href="functions.html#aggregate-functions-and-modifiers" title="12.20 集計関数">セクション12.20「集計関数」</a>にある <code class="literal">GROUP BY</code> の説明を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">GROUP BY</code> では、<code class="literal">WITH ROLLUP</code> 修飾子が許可されます。 <a class="xref" href="functions.html#group-by-modifiers" title="12.20.2 GROUP BY 修飾子">セクション12.20.2「GROUP BY 修飾子」</a>を参照してください。 
        </p><p>
          <a class="indexterm" name="idm45826998951760"></a> 以前は、<code class="literal">WITH ROLLUP</code> 修飾子を持つクエリーで <code class="literal">ORDER BY</code> を使用することはできませんでした。 この制限は、MySQL 8.0.12 の時点でなくなりました。 <a class="xref" href="functions.html#group-by-modifiers" title="12.20.2 GROUP BY 修飾子">セクション12.20.2「GROUP BY 修飾子」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm45826998946752"></a> <code class="literal">HAVING</code> 句は、ほぼ最後 (項目がクライアントに送信される直前) に最適化なしで適用されます。 (<code class="literal">LIMIT</code> は <code class="literal">HAVING</code> のあとに適用されます。) 
        </p><p>
          SQL 標準では、<code class="literal">HAVING</code> は <code class="literal">GROUP BY</code> 句内のカラムか、または集約関数で使用されるカラムしか参照できません。 ただし、MySQL ではこの動作への拡張がサポートされており、<code class="literal">HAVING</code> が <code class="literal">SELECT</code> リスト内のカラムや外側サブクエリー内のカラムを参照することも許可されます。 
        </p><p>
          <code class="literal">HAVING</code> 句があいまいなカラムを参照している場合は、警告が発生します。 次のステートメントにある <code class="literal">col2</code> は、エイリアスとカラム名の両方として使用されているため、あいまいです。 
        </p><pre class="programlisting">SELECT COUNT(col1) AS col2 FROM t GROUP BY col2 HAVING col2 = 2;
</pre><p>
          標準 SQL の動作の方が優先されるため、<code class="literal">HAVING</code> のカラム名が <code class="literal">GROUP BY</code> で使用されると同時に、出力カラムリスト内のエイリアスが指定されたカラムとしても使用されている場合は、<code class="literal">GROUP BY</code> カラム内のカラムが優先されます。
        </p></li><li class="listitem"><p>
          <code class="literal">WHERE</code> 句に含めるべき項目には <code class="literal">HAVING</code> を使用しないでください。 たとえば、次のように記述しないでください。 
        </p><pre class="programlisting">SELECT <em class="replaceable"><code>col_name</code></em> FROM <em class="replaceable"><code>tbl_name</code></em> HAVING <em class="replaceable"><code>col_name</code></em> &gt; 0;
</pre><p>
          代わりに、次のように記述してください。
        </p><pre class="programlisting">SELECT <em class="replaceable"><code>col_name</code></em> FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>col_name</code></em> &gt; 0;
</pre></li><li class="listitem"><p>
          <code class="literal">HAVING</code> 句は、<code class="literal">WHERE</code> 句が参照できない集約関数を参照できます。
        </p><pre class="programlisting">SELECT user, MAX(salary) FROM users
  GROUP BY user HAVING MAX(salary) &gt; 10;
</pre><p>
          (これは、一部の古いバージョンの MySQL では機能しませんでした。)
        </p></li><li class="listitem"><p>
          MySQL では、重複したカラム名が許可されます。 つまり、同じ名前を持つ複数の <em class="replaceable"><code>select_expr</code></em> が存在できます。 これは、標準 SQL の拡張です。 MySQL では <code class="literal">GROUP BY</code> や <code class="literal">HAVING</code> が <em class="replaceable"><code>select_expr</code></em> 値を参照することも許可されるため、これにより、あいまいさが発生する場合があります。 
        </p><pre class="programlisting">SELECT 12 AS a, a FROM t GROUP BY a;
</pre><p>
          このステートメントでは、どちらのカラムの名前も <code class="literal">a</code> です。 グループ化のために正しいカラムが使用されるようにするために、<em class="replaceable"><code>select_expr</code></em> ごとに異なる名前を使用してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">WINDOW</code> 句が存在する場合は、ウィンドウ関数で参照できる名前付きウィンドウを定義します。 詳細は、<a class="xref" href="functions.html#window-functions-named-windows" title="12.21.4 名前付きウィンドウ">セクション12.21.4「名前付きウィンドウ」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          MySQL は、<code class="literal">ORDER BY</code> 句内の修飾されていないカラムまたはエイリアス参照を、まず <em class="replaceable"><code>select_expr</code></em> 値、次に <code class="literal">FROM</code> 句内のテーブルのカラム内を検索することによって解決します。 <code class="literal">GROUP BY</code> または <code class="literal">HAVING</code> 句の場合は、<em class="replaceable"><code>select_expr</code></em> 値内を検索する前に <code class="literal">FROM</code> 句を検索します。 (<code class="literal">GROUP BY</code> と <code class="literal">HAVING</code> について、これは、<code class="literal">ORDER BY</code>) の場合と同じルールを使用していた MySQL 5.0 より前の動作とは異なります。 
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm45826998902672"></a> <code class="literal">LIMIT</code> 句を使用すると、<code class="literal">SELECT</code> ステートメントによって返される行数を制約できます。 <code class="literal">LIMIT</code> は 1 つまたは 2 つの数値引数を受け取ります。これは、どちらも負ではない整定数である必要があります。ただし、次の例外があります。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              準備済みステートメント内では、<code class="literal">?</code> プレースホルダマーカーを使用して <code class="literal">LIMIT</code> パラメータを指定できます。
            </p></li><li class="listitem"><p>
              ストアドプログラム内では、整数値のルーチンパラメータまたはローカル変数を使用して <code class="literal">LIMIT</code> パラメータを指定できます。
            </p></li></ul></div><p>
          引数が 2 つの場合、最初の引数は返す先頭行のオフセットを指定し、2 番目の引数は返す行の最大数を指定します。 最初の行のオフセットは (1 ではなく) 0 です。 
        </p><pre class="programlisting">SELECT * FROM tbl LIMIT 5,10;  # Retrieve rows 6-15
</pre><p>
          特定のオフセットから結果セットの最後までのすべての行を取得するために、2 番目のパラメータにある程度大きい数字を使用できます。 次のステートメントは、96 行目から最後の行までのすべての行を取得します。 
        </p><pre class="programlisting">SELECT * FROM tbl LIMIT 95,18446744073709551615;
</pre><p>
          引数が 1 つの場合、この値は、結果セットの先頭から返す行数を指定します。
        </p><pre class="programlisting">SELECT * FROM tbl LIMIT 5;     # Retrieve first 5 rows
</pre><p>
          つまり、<code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em></code> は <code class="literal">LIMIT 0, <em class="replaceable"><code>row_count</code></em></code> と同等です。
        </p><p>
          準備済みステートメントでは、プレースホルダを使用できます。 次のステートメントは、<code class="literal">tbl</code> テーブルから行を戻します: 
        </p><pre class="programlisting">SET @a=1;
PREPARE STMT FROM 'SELECT * FROM tbl LIMIT ?';
EXECUTE STMT USING @a;
</pre><p>
          次のステートメントは、<code class="literal">tbl</code> テーブルから秒から 6 行目を戻します:
        </p><pre class="programlisting">SET @skip=1; SET @numrows=5;
PREPARE STMT FROM 'SELECT * FROM tbl LIMIT ?, ?';
EXECUTE STMT USING @skip, @numrows;
</pre><p>
          PostgreSQL との互換性のために、MySQL は <code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em> OFFSET <em class="replaceable"><code>offset</code></em></code> 構文もサポートしています。
        </p><p>
          <code class="literal">LIMIT</code> がカッコで囲まれたクエリー式内で発生し、外部クエリーにも適用される場合、結果は未定義であり、将来のバージョンの MySQL で変更される可能性があります。
        </p></li><li class="listitem"><p>
          <code class="literal">SELECT</code> の <code class="literal">SELECT ... INTO</code> 形式を使用すると、クエリー結果をファイルに書き込んだり、変数に格納したりできます。 詳細は、<a class="xref" href="sql-statements.html#select-into" title="13.2.10.1 SELECT ... INTO ステートメント">セクション13.2.10.1「SELECT ... INTO ステートメント」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm45826998872496"></a> <a class="indexterm" name="idm45826998871440"></a> <a class="indexterm" name="idm45826998870352"></a> <a class="indexterm" name="idm45826998869264"></a> <a class="indexterm" name="idm45826998868176"></a> <code class="literal">FOR UPDATE</code> をページロックまたは行ロックを使用するストレージエンジンとともに使用する場合、クエリーによって検査される行は、現在のトランザクションが終了するまで書き込みロックされます。
        </p><p>
          <code class="literal">CREATE TABLE <em class="replaceable"><code>new_table</code></em> SELECT ... FROM <em class="replaceable"><code>old_table</code></em> ...</code> などのステートメントで <code class="literal">SELECT</code> の一部として <code class="literal">FOR UPDATE</code> を使用することはできません。 (それを行おうとすると、このステートメントはエラー <span class="errortext">Can't update table '<em class="replaceable"><code>old_table</code></em>' while '<em class="replaceable"><code>new_table</code></em>' is being created</span>で拒否されます。) 
        </p><p>
          <code class="literal">FOR SHARE</code> および <code class="literal">LOCK IN SHARE MODE</code> では、他のトランザクションが調査された行を読み取ることはできるが、更新または削除することはできない共有ロックが設定されます。 <code class="literal">FOR SHARE</code> と <code class="literal">LOCK IN SHARE MODE</code> は同等です。 ただし、<code class="literal">FOR UPDATE</code> と同様に、<code class="literal">FOR SHARE</code> は <code class="literal">NOWAIT</code>、<code class="literal">SKIP LOCKED</code> および <code class="literal">OF <em class="replaceable"><code>tbl_name</code></em></code> オプションをサポートしています。 <code class="literal">FOR SHARE</code> は <code class="literal">LOCK IN SHARE MODE</code> の代替機能ですが、<code class="literal">LOCK IN SHARE MODE</code> は下位互換性のために引き続き使用できます。 
        </p><p>
          <code class="literal">NOWAIT</code> では、<code class="literal">FOR UPDATE</code> または <code class="literal">FOR SHARE</code> クエリーがすぐに実行され、別のトランザクションによってロックが保持されているために行ロックを取得できない場合はエラーが返されます。
        </p><p>
          <code class="literal">SKIP LOCKED</code> では、別のトランザクションによってロックされている結果セットから行を除外して、<code class="literal">FOR UPDATE</code> または <code class="literal">FOR SHARE</code> クエリーがただちに実行されます。
        </p><p>
          <code class="literal">NOWAIT</code> および <code class="literal">SKIP LOCKED</code> オプションは、ステートメントベースレプリケーションでは安全ではありません。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            ロックされた行をスキップするクエリーは、データの一貫性のないビューを返します。 したがって、<code class="literal">SKIP LOCKED</code> は一般的なトランザクション作業には適していません。 ただし、複数のセッションが同じキューに類似したテーブルにアクセスする場合、ロックの競合を回避するために使用できます。 
          </p></div><p>
          <code class="literal">OF <em class="replaceable"><code>tbl_name</code></em></code> は、<code class="literal">FOR UPDATE</code> および <code class="literal">FOR SHARE</code> クエリーを名前付きテーブルに適用します。 例: 
        </p><pre class="programlisting">SELECT * FROM t1, t2 FOR SHARE OF t1 FOR UPDATE OF t2;
</pre><p>
          <code class="literal">OF <em class="replaceable"><code>tbl_name</code></em></code> を省略すると、クエリーブロックによって参照されるすべてのテーブルがロックされます。 したがって、別のロック句と組み合せて <code class="literal">OF <em class="replaceable"><code>tbl_name</code></em></code> なしでロック句を使用すると、エラーが返されます。 複数のロック句で同じテーブルを指定すると、エラーが返されます。 エイリアスが <code class="literal">SELECT</code> ステートメントでテーブル名として指定されている場合、ロック句ではエイリアスのみを使用できます。 <code class="literal">SELECT</code> ステートメントでエイリアスが明示的に指定されていない場合、ロック句では実際のテーブル名のみを指定できます。 
        </p><p>
          <code class="literal">FOR UPDATE</code> および <code class="literal">FOR SHARE</code> の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-locking-reads" title="15.7.2.4 読取りのロック">セクション15.7.2.4「読取りのロック」</a> を参照してください。 <code class="literal">NOWAIT</code> および <code class="literal">SKIP LOCKED</code> オプションの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-locking-reads-nowait-skip-locked" title="NOWAIT および SKIP LOCKED による読取り同時実行性のロック">NOWAIT および SKIP LOCKED による読取り同時実行性のロック</a> を参照してください。 
        </p></li></ul></div><p>
      <code class="literal">SELECT</code> キーワードの後に、ステートメントの操作に影響を与える多数の修飾子を使用できます。 <code class="literal">HIGH_PRIORITY</code>、<code class="literal">STRAIGHT_JOIN</code> および <code class="literal">SQL_</code>以降の修飾子は、標準 SQL に対する MySQL の拡張機能です。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">ALL</code> 修飾子および <code class="literal">DISTINCT</code> 修飾子は、重複する行を戻すかどうかを指定します。 <code class="literal">ALL</code> (デフォルト) は、重複を含め、一致するすべての行を返すように指定します。 <code class="literal">DISTINCT</code> は、重複した行の結果セットからの削除を指定します。 両方の修飾子を指定するとエラーになります。 <code class="literal">DISTINCTROW</code> は <code class="literal">DISTINCT</code> のシノニムです。 
        </p><p>
          MySQL 8.0.12 以降では、<code class="literal">WITH ROLLUP</code> も使用するクエリーで <code class="literal">DISTINCT</code> を使用できます。 (Bug #87450、Bug #26640100) 
        </p><a class="indexterm" name="idm45826998813664"></a><a class="indexterm" name="idm45826998811600"></a><a class="indexterm" name="idm45826998809536"></a></li><li class="listitem"><p>
          <code class="literal">HIGH_PRIORITY</code> では、テーブルを更新するステートメントよりも <code class="literal">SELECT</code> の優先度が高くなります。 これは、非常に高速であり、かつただちに実行する必要のあるクエリーにのみ使用するようにしてください。 テーブルが読み取りに対してロックされている間に発行された <code class="literal">SELECT HIGH_PRIORITY</code> クエリーは、そのテーブルが未使用になるのを待機している更新ステートメントが存在する場合でも実行されます。 これは、テーブルレベルロックのみを使用するストレージエンジン (<code class="literal">MyISAM</code>、<code class="literal">MEMORY</code>、および <code class="literal">MERGE</code>) にのみ影響を与えます。 
        </p><a class="indexterm" name="idm45826998801008"></a><p>
          <code class="literal">HIGH_PRIORITY</code> を、<code class="literal">UNION</code> の一部である <code class="literal">SELECT</code> ステートメントで使用することはできません。
        </p></li><li class="listitem"><p>
          <code class="literal">STRAIGHT_JOIN</code> では、オプティマイザによって、<code class="literal">FROM</code> 句にリストされている順序でテーブルが結合されます。 オプティマイザがテーブルを最適でない順序で結合する場合は、これを使用してクエリーを高速化できます。 <code class="literal">STRAIGHT_JOIN</code> はまた、<em class="replaceable"><code>table_references</code></em> リストでも使用できます。 <a class="xref" href="sql-statements.html#join" title="13.2.10.2 JOIN 句">セクション13.2.10.2「JOIN 句」</a>を参照してください。 
        </p><a class="indexterm" name="idm45826998791248"></a><a class="indexterm" name="idm45826998789104"></a><a class="indexterm" name="idm45826998787072"></a><p>
          <code class="literal">STRAIGHT_JOIN</code> は、オプティマイザが <code class="literal">const</code> または <code class="literal">system</code> テーブルとして扱うテーブルには適用されません。 このようなテーブルは単一行を生成し、クエリー実行の最適化フェーズ中に読み取られます。また、そのカラムへの参照は、クエリー実行が続行される前に適切なカラム値で置き換えられます。 これらのテーブルは、<code class="literal">EXPLAIN</code> によって表示されるクエリー計画の最初に表示されます。 「<a class="xref" href="optimization.html#using-explain" title="8.8.1 EXPLAIN によるクエリーの最適化">セクション8.8.1「EXPLAIN によるクエリーの最適化」</a>」を参照してください。 この例外は、外部結合の <code class="literal">NULL</code> で補完された側で使用されている <code class="literal">const</code> テーブルまたは <code class="literal">system</code> テーブル (つまり、<code class="literal">LEFT JOIN</code> の右側のテーブルまたは <code class="literal">RIGHT JOIN</code> の左側のテーブル) には適用されない可能性があります。 
        </p></li><li class="listitem"><p>
          <code class="literal">SQL_BIG_RESULT</code> または <code class="literal">SQL_SMALL_RESULT</code> を <code class="literal">GROUP BY</code> または <code class="literal">DISTINCT</code> とともに使用して、結果セットに多数の行があるか、それぞれ小さいことをオプティマイザに伝えることができます。 <code class="literal">SQL_BIG_RESULT</code> の場合、MySQL ではディスクベースの一時テーブルが直接使用され (作成されている場合)、<code class="literal">GROUP BY</code> 要素のキーを使用した一時テーブルよりソートが優先されます。 <code class="literal">SQL_SMALL_RESULT</code> の場合、MySQL では、ソートを使用するかわりにインメモリー一時テーブルを使用して結果テーブルを格納します。 これは、通常は必要ないはずです。 
        </p><a class="indexterm" name="idm45826998768128"></a><a class="indexterm" name="idm45826998765952"></a></li><li class="listitem"><p>
          <code class="literal">SQL_BUFFER_RESULT</code> では、結果が強制的に一時テーブルに格納されます。 これは、MySQL がテーブルロックを早期に解放する場合や、結果セットをクライアントに送信するのに長い時間がかかる場合に役立ちます。 この修飾子は、トップレベルの <code class="literal">SELECT</code> ステートメントにのみ使用でき、サブクエリーや <code class="literal">UNION</code> の後には使用できません。 
        </p><a class="indexterm" name="idm45826998759728"></a></li><li class="listitem"><p>
          <code class="literal">SQL_CALC_FOUND_ROWS</code> は、<code class="literal">LIMIT</code> 句に関係なく、結果セットに存在する行数を計算するように MySQL に指示します。 そのあと、行数は <code class="literal">SELECT FOUND_ROWS()</code> を使用して取得できます。 <a class="xref" href="functions.html#information-functions" title="12.16 情報関数">セクション12.16「情報関数」</a>を参照してください。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">SQL_CALC_FOUND_ROWS</code> クエリー修飾子および付随する <code class="literal">FOUND_ROWS()</code> 関数は、MySQL 8.0.17 で非推奨になりました。これらは、MySQL の将来のバージョンで削除される予定です。 代替戦略の詳細は、<code class="literal">FOUND_ROWS()</code> の説明を参照してください。 
          </p></div><a class="indexterm" name="idm45826998750000"></a></li><li class="listitem"><p>
          <code class="literal">SQL_CACHE</code> および <code class="literal">SQL_NO_CACHE</code> 修飾子は、MySQL 8.0 より前のクエリーキャッシュで使用されていました。 クエリーキャッシュは MySQL 8.0 で削除されました。 <code class="literal">SQL_CACHE</code> 修飾子も削除されました。 <code class="literal">SQL_NO_CACHE</code> は非推奨であり、効果はありません。将来の MySQL リリースで削除される予定です。 
        </p><a class="indexterm" name="idm45826998743936"></a><a class="indexterm" name="idm45826998741760"></a></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="select-into"></a>13.2.10.1 SELECT ... INTO ステートメント</h4></div></div></div><a class="indexterm" name="idm45826998738352"></a><a class="indexterm" name="idm45826998736352"></a><p>
        <code class="literal">SELECT</code> の <code class="literal">SELECT ... INTO</code> 形式を使用すると、クエリー結果を変数に格納したり、ファイルに書き込んだりできます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">SELECT ... INTO <em class="replaceable"><code>var_list</code></em></code> はカラム値を選択し、それらを変数に格納します。
          </p></li><li class="listitem"><p>
            <code class="literal">SELECT ... INTO OUTFILE</code> は、選択された行をファイルに書き込みます。 カラムおよび行ターミネータを指定すると、特定の出力形式を生成できます。 
          </p></li><li class="listitem"><p>
            <code class="literal">SELECT ... INTO DUMPFILE</code> は、単一行をファイルに形式設定なしで書き込みます。
          </p></li></ul></div><p>
        特定の <code class="literal">SELECT</code> ステートメントには最大で 1 つの <code class="literal">INTO</code> 句を含めることができますが、<code class="literal">SELECT</code> 構文の説明 (<a class="xref" href="sql-statements.html#select" title="13.2.10 SELECT ステートメント">セクション13.2.10「SELECT ステートメント」</a> を参照) に示されているように、<code class="literal">INTO</code> は異なる位置に配置できます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">FROM</code> より前。 例: 
          </p><pre class="programlisting">SELECT * INTO @myvar FROM t1;
</pre></li><li class="listitem"><p>
            後続のロック句の前。 例: 
          </p><pre class="programlisting">SELECT * FROM t1 INTO @myvar FOR UPDATE;
</pre></li><li class="listitem"><p>
            <code class="literal">SELECT</code> の最後。 例: 
          </p><pre class="programlisting">SELECT * FROM t1 FOR UPDATE INTO @myvar;
</pre></li></ul></div><p>
        ステートメントの最後の <code class="literal">INTO</code> 位置は、MySQL 8.0.20 でサポートされており、推奨位置です。 ロック句の前の位置は、MySQL 8.0.20 では非推奨です。将来のバージョンの MySQL ではサポートされなくなる予定です。 つまり、<code class="literal">FROM</code> の後には <code class="literal">INTO</code> が生成されますが、<code class="literal">SELECT</code> の最後には生成されません。 
      </p><p>
        ネストされた <code class="literal">SELECT</code> はその結果を外側のコンテキストに返す必要があるため、このような <code class="literal">SELECT</code> では <code class="literal">INTO</code> 句を使用してはいけません。 <code class="literal">UNION</code> ステートメント内での <code class="literal">INTO</code> の使用には制約もあります。<a class="xref" href="sql-statements.html#union" title="13.2.10.3 UNION 句">セクション13.2.10.3「UNION 句」</a> を参照してください。 
      </p><p>
        <code class="literal">INTO <em class="replaceable"><code>var_list</code></em></code> バリアントの場合:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <em class="replaceable"><code>var_list</code></em> では、1 つ以上の変数のリストに名前を付けます。各変数には、ユーザー定義変数、ストアドプロシージャまたはストアドファンクションパラメータ、ストアドプログラムのローカル変数を指定できます。 (準備された <code class="literal">SELECT ... INTO <em class="replaceable"><code>var_list</code></em></code> ステートメント内では、ユーザー定義の変数のみが許可されます。<a class="xref" href="sql-statements.html#local-variable-scope" title="13.6.4.2 ローカル変数のスコープと解決">セクション13.6.4.2「ローカル変数のスコープと解決」</a> を参照してください。) 
          </p></li><li class="listitem"><p>
            選択された値は変数に割り当てられます。 変数の数がカラム数に一致している必要があります。 クエリーは、単一行を返すようにしてください。 クエリーが行を返さない場合は、エラーコード 1329 で警告が発生し (<code class="literal">No data</code>)、変数値は変更されないままになります。 クエリーが複数の行を返す場合は、エラー 1172 が発生します (<code class="literal">結果が 2 行以上です</code>)。 このステートメントが複数の行を取得する可能性がある場合は、<code class="literal">LIMIT 1</code> を使用して結果セットを単一行に制限できます。 
          </p><pre class="programlisting">SELECT id, data INTO @x, @y FROM test.t1 LIMIT 1;
</pre></li></ul></div><a class="indexterm" name="idm45826998692336"></a><a class="indexterm" name="idm45826998690144"></a><p>
        <code class="literal">INTO <em class="replaceable"><code>var_list</code></em></code> は、<code class="literal">TABLE</code> ステートメントとともに使用することもできますが、次の制限があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            変数の数は、テーブルのカラムの数と一致する必要があります。
          </p></li><li class="listitem"><p>
            テーブルに複数の行が含まれる場合は、<code class="literal">LIMIT 1</code> を使用して結果セットを単一行に制限する必要があります。 <code class="literal">LIMIT 1</code> は、<code class="literal">INTO</code> キーワードの前に指定する必要があります。 
          </p></li></ul></div><p>
        このようなステートメントの例を次に示します:
      </p><pre class="programlisting">TABLE employees ORDER BY lname DESC LIMIT 1
    INTO @id, @fname, @lname, @hired, @separated, @job_code, @store_id;
</pre><a class="indexterm" name="idm45826998679248"></a><a class="indexterm" name="idm45826998677040"></a><p>
        単一行を一連のユーザー変数に生成する <code class="literal">VALUES</code> ステートメントから値を選択することもできます。 この場合、テーブルのエイリアスを使用し、値リストの各値を変数に割り当てる必要があります。 ここに示す 2 つのステートメントはそれぞれ、<code class="literal">SET @x=2, @y=4, @z=8</code> と同等です: 
      </p><pre class="programlisting">SELECT * FROM (VALUES ROW(2,4,8)) AS t INTO @x,@y,@z;

SELECT * FROM (VALUES ROW(2,4,8)) AS t(a,b,c) INTO @x,@y,@z;
</pre><p>
        ユーザー変数名では大/小文字は区別されません。 <a class="xref" href="language-structure.html#user-variables" title="9.4 ユーザー定義変数">セクション9.4「ユーザー定義変数」</a>を参照してください。 
      </p><a class="indexterm" name="idm45826998669408"></a><a class="indexterm" name="idm45826998668096"></a><p>
        <code class="literal">SELECT</code> の <code class="literal">SELECT ... INTO OUTFILE '<em class="replaceable"><code>file_name</code></em>'</code> 形式は、選択された行をファイルに書き込みます。 ファイルはサーバーホストに作成されるため、この構文を使用するには <code class="literal">FILE</code> 権限が必要です。<em class="replaceable"><code>file_name</code></em> は既存のファイルにすることはできません。特に、<code class="filename">/etc/passwd</code> やデータベーステーブルなどのファイルが変更されるのを防ぎます。 <code class="literal">character_set_filesystem</code> システム変数は、ファイル名の解釈を制御します。 
      </p><p>
        <code class="literal">SELECT ... INTO OUTFILE</code> ステートメントは、サーバーホスト上のテキストファイルへのテーブルのダンプを有効にすることを目的としています。 結果のファイルを他のホストに作成する場合、サーバーホストファイルシステム上のネットワークマップパスを使用してリモートホスト上のファイルの場所にアクセスできないかぎり、サーバーホストファイルシステムを基準にした相対パスをファイルに書き込む方法がないため、<code class="literal">SELECT ... INTO OUTFILE</code> は通常は適していません。 
      </p><p>
        または、MySQL クライアントソフトウェアがリモートホストにインストールされている場合は、<code class="literal">mysql -e "SELECT ..." &gt; <em class="replaceable"><code>file_name</code></em></code> などのクライアントコマンドを使用して、そのホストにファイルを生成できます。
      </p><p>
        <code class="literal">SELECT ... INTO OUTFILE</code> は、<code class="literal">LOAD DATA</code> を補完したものです。 カラム値は、<code class="literal">CHARACTER SET</code> 句で指定されている文字セットに変換されて書き込まれます。 このような句が存在しない場合、値は <code class="literal">binary</code> 文字セットを使用してダンプされます。 事実上、文字セットの変換は実行されません。 結果セットに複数の文字セットのカラムが含まれている場合は、出力データファイルであるため、ファイルを正しくリロードできない可能性があります。 
      </p><p>
        ステートメントの <em class="replaceable"><code>export_options</code></em> 部分の構文は、<code class="literal">LOAD DATA</code> ステートメントで使用されるものと同じ <code class="literal">FIELDS</code> 句および <code class="literal">LINES</code> 句で構成されます。 デフォルト値や許容値など、<code class="literal">FIELDS</code> 句および <code class="literal">LINES</code> 句の詳細は、<a class="xref" href="sql-statements.html#load-data" title="13.2.7 LOAD DATA ステートメント">セクション13.2.7「LOAD DATA ステートメント」</a> を参照してください。 
      </p><p>
        <code class="literal">FIELDS ESCAPED BY</code> は、特殊文字を書き込む方法を制御します。 <code class="literal">FIELDS ESCAPED BY</code> 文字が空でない場合、その文字は、出力上で次の文字の前に付けられるプリフィクスとして、あいまいさを避けるために必要な場合に使用されます。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">FIELDS ESCAPED BY</code> 文字
          </p></li><li class="listitem"><p>
            <code class="literal">FIELDS [OPTIONALLY] ENCLOSED BY</code> 文字
          </p></li><li class="listitem"><p>
            <code class="literal">FIELDS TERMINATED BY</code> および <code class="literal">LINES TERMINATED BY</code> 値の最初の文字
          </p></li><li class="listitem"><p>
            ASCII <code class="literal">NUL</code> (0 の値のバイト。エスケープ文字のあとに実際に書き込まれる文字は 0 の値のバイトではなく、ASCII の<code class="literal">0</code>です)
          </p></li></ul></div><p>
        <code class="literal">FIELDS TERMINATED BY</code>、<code class="literal">ENCLOSED BY</code>、<code class="literal">ESCAPED BY</code>、または <code class="literal">LINES TERMINATED BY</code> 文字は、そのファイルを確実に読み戻すことができるように、エスケープする<span class="emphasis"><em>必要があります</em></span>。 ASCII <code class="literal">NUL</code> は、一部のページャーで見やすくなるようにエスケープされます。 
      </p><p>
        結果のファイルは SQL 構文に準拠する必要がないため、他にエスケープする必要はありません。
      </p><p>
        <code class="literal">FIELDS ESCAPED BY</code> 文字が空である場合は、どの文字もエスケープされず、<code class="literal">NULL</code> は <code class="literal">\N</code> ではなく、<code class="literal">NULL</code> として出力されます。 特に、データ内のフィールド値に今指定したリスト内のいずれかの文字が含まれている場合、空のエスケープ文字を指定することはおそらく適切な方法ではありません。 
      </p><a class="indexterm" name="idm45826998623552"></a><p>
        テーブルのすべてのカラムをテキストファイルにダンプする場合は、<code class="literal">INTO OUTFILE</code> を <code class="literal">TABLE</code> ステートメントとともに使用することもできます。 この場合、<code class="literal">ORDER BY</code> および <code class="literal">LIMIT</code> を使用して順序付けと行数を制御できます。これらの句は、<code class="literal">INTO OUTFILE</code> の前に指定する必要があります。 <code class="literal">TABLE ... INTO OUTFILE</code> では、<code class="literal">SELECT ... INTO OUTFILE</code> と同じ <em class="replaceable"><code>export_options</code></em> がサポートされており、ファイルシステムへの書込みには同じ制限があります。 このようなステートメントの例を次に示します: 
      </p><pre class="programlisting">TABLE employees ORDER BY lname LIMIT 1000
    INTO OUTFILE '/tmp/employee_data_1.txt'
    FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"', ESCAPED BY '\'
    LINES TERMINATED BY '\n';
</pre><p>
        <code class="literal">SELECT ... INTO OUTFILE</code> を <code class="literal">VALUES</code> ステートメントとともに使用して、値をファイルに直接書き込むこともできます。 次に例を示します: 
      </p><pre class="programlisting">SELECT * FROM (VALUES ROW(1,2,3),ROW(4,5,6),ROW(7,8,9)) AS t
    INTO OUTFILE '/tmp/select-values.txt';
</pre><p>
        テーブルのエイリアスを使用する必要があります。カラムのエイリアスもサポートされており、オプションで目的のカラムからのみ値を書き込むために使用できます。 <code class="literal">SELECT ... INTO OUTFILE</code> でサポートされているエクスポートオプションのいずれかまたはすべてを使用して、出力をファイルにフォーマットすることもできます。 
      </p><a class="indexterm" name="idm45826998608176"></a><a class="indexterm" name="idm45826998606656"></a><p>
        多くのプログラムで使用されているカンマ区切り値 (CSV) 形式のファイルを生成する例を次に示します。
      </p><pre class="programlisting">SELECT a,b,a+b INTO OUTFILE '/tmp/result.txt'
  FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
  LINES TERMINATED BY '\n'
  FROM test_table;
</pre><a class="indexterm" name="idm45826998603600"></a><p>
        <code class="literal">INTO OUTFILE</code> の代わりに <code class="literal">INTO DUMPFILE</code> を使用した場合、MySQL はエスケープ処理を実行することなく、カラムや行の終了のない 1 行のみをファイルに書き込みます。 これは、<code class="literal">BLOB</code> 値を選択してファイルに格納する場合に便利です。 
      </p><p>
        <code class="literal">TABLE</code> は、<code class="literal">INTO DUMPFILE</code> もサポートしています。 テーブルに複数の行が含まれている場合は、<code class="literal">LIMIT 1</code> を使用して出力を単一行に制限する必要もあります。 <code class="literal">INTO DUMPFILE</code> は、<code class="literal">SELECT * FROM (VALUES ROW()[, ...]) AS <em class="replaceable"><code>table_alias</code></em> [LIMIT 1]</code>とともに使用することもできます。 <a class="xref" href="sql-statements.html#values" title="13.2.14 VALUES ステートメント">セクション13.2.14「VALUES ステートメント」</a>を参照してください。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">INTO OUTFILE</code> または <code class="literal">INTO DUMPFILE</code> によって作成されたファイルは、アカウント <span class="command"><strong>mysqld</strong></span> が実行されているオペレーティングシステムユーザーによって所有されます。 (これらの理由のために、<span class="command"><strong>mysqld</strong></span> を <code class="literal">root</code> としては<span class="emphasis"><em>決して実行しないでください</em></span>。)  MySQL 8.0.17 では、ファイル作成の umask は 0640 です。ファイルの内容を操作するには、十分なアクセス権限が必要です。 MySQL 8.0.17 より前では、umask は 0666 で、ファイルはサーバーホスト上のすべてのユーザーによって書き込み可能です。 
        </p><p>
          <code class="literal">secure_file_priv</code> システム変数が空以外のディレクトリ名に設定されている場合、書き込まれるファイルはそのディレクトリ内に存在する必要があります。
        </p></div><p>
        イベントスケジューラによって実行されるイベントの一部として実行された <code class="literal">SELECT ... INTO</code> ステートメントのコンテキストでは、診断メッセージ (エラーだけでなく、警告も含みます) がエラーログに (Windows ではアプリケーションイベントログにも) 書き込まれます。 詳細は、<a class="xref" href="stored-objects.html#events-status-info" title="25.4.5 イベントスケジューラのステータス">セクション25.4.5「イベントスケジューラのステータス」</a>を参照してください。 
      </p><p>
        MySQL 8.0.22 の時点では、<code class="literal">SELECT INTO OUTFILE</code> および <code class="literal">SELECT INTO DUMPFILE</code> によって書き込まれた出力ファイルの定期的な同期がサポートされており、そのバージョンで導入された <code class="literal">select_into_disk_sync</code> サーバーシステム変数を設定することで有効になります。 出力バッファサイズおよびオプションの遅延は、それぞれ <code class="literal">select_into_buffer_size</code> および <code class="literal">select_into_disk_sync_delay</code> を使用して設定できます。 詳細は、これらのシステム変数の説明を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="join"></a>13.2.10.2 JOIN 句</h4></div></div></div><a class="indexterm" name="idm45826998575520"></a><a class="indexterm" name="idm45826998574176"></a><a class="indexterm" name="idm45826998572832"></a><a class="indexterm" name="idm45826998571488"></a><a class="indexterm" name="idm45826998570144"></a><a class="indexterm" name="idm45826998568800"></a><a class="indexterm" name="idm45826998567456"></a><a class="indexterm" name="idm45826998566112"></a><a class="indexterm" name="idm45826998564768"></a><a class="indexterm" name="idm45826998563424"></a><a class="indexterm" name="idm45826998562080"></a><a class="indexterm" name="idm45826998560736"></a><a class="indexterm" name="idm45826998559392"></a><a class="indexterm" name="idm45826998558016"></a><a class="indexterm" name="idm45826998556672"></a><p>
        MySQL では、<code class="literal">SELECT</code> ステートメントおよび複数テーブルの <code class="literal">DELETE</code> ステートメントと <code class="literal">UPDATE</code> ステートメントの <em class="replaceable"><code>table_references</code></em> 部分について、次の <code class="literal">JOIN</code> 構文がサポートされています:
      </p><pre class="programlisting"><em class="replaceable"><code>table_references:</code></em>
    <em class="replaceable"><code>escaped_table_reference</code></em> [, <em class="replaceable"><code>escaped_table_reference</code></em>] ...

<em class="replaceable"><code>escaped_table_reference</code></em>: {
    <em class="replaceable"><code>table_reference</code></em>
  | { OJ <em class="replaceable"><code>table_reference</code></em> }
}

<em class="replaceable"><code>table_reference</code></em>: {
    <em class="replaceable"><code>table_factor</code></em>
  | <em class="replaceable"><code>joined_table</code></em>
}

<em class="replaceable"><code>table_factor</code></em>: {
    <em class="replaceable"><code>tbl_name</code></em> [PARTITION (<em class="replaceable"><code>partition_names</code></em>)]
        [[AS] <em class="replaceable"><code>alias</code></em>] [<em class="replaceable"><code>index_hint_list</code></em>]
  | [LATERAL] <em class="replaceable"><code>table_subquery</code></em> [AS] <em class="replaceable"><code>alias</code></em> [(<em class="replaceable"><code>col_list</code></em>)]
  | ( <em class="replaceable"><code>table_references</code></em> )
}

<em class="replaceable"><code>joined_table</code></em>: {
    <em class="replaceable"><code>table_reference</code></em> {[INNER | CROSS] JOIN | STRAIGHT_JOIN} <em class="replaceable"><code>table_factor</code></em> [<em class="replaceable"><code>join_specification</code></em>]
  | <em class="replaceable"><code>table_reference</code></em> {LEFT|RIGHT} [OUTER] JOIN <em class="replaceable"><code>table_reference</code></em> <em class="replaceable"><code>join_specification</code></em>
  | <em class="replaceable"><code>table_reference</code></em> NATURAL [INNER | {LEFT|RIGHT} [OUTER]] JOIN <em class="replaceable"><code>table_factor</code></em>
}

<em class="replaceable"><code>join_specification</code></em>: {
    ON <em class="replaceable"><code>search_condition</code></em>
  | USING (<em class="replaceable"><code>join_column_list</code></em>)
}

<em class="replaceable"><code>join_column_list</code></em>:
    <em class="replaceable"><code>column_name</code></em> [, <em class="replaceable"><code>column_name</code></em>] ...

<em class="replaceable"><code>index_hint_list</code></em>:
    <em class="replaceable"><code>index_hint</code></em> [, <em class="replaceable"><code>index_hint</code></em>] ...

<em class="replaceable"><code>index_hint</code></em>: {
    USE {INDEX|KEY}
      [FOR {JOIN|ORDER BY|GROUP BY}] ([<em class="replaceable"><code>index_list</code></em>])
  | {IGNORE|FORCE} {INDEX|KEY}
      [FOR {JOIN|ORDER BY|GROUP BY}] (<em class="replaceable"><code>index_list</code></em>)
}

<em class="replaceable"><code>index_list</code></em>:
    <em class="replaceable"><code>index_name</code></em> [, <em class="replaceable"><code>index_name</code></em>] ...
</pre><p>
        テーブル参照は、結合式とも呼ばれます。
      </p><p>
        テーブル参照 (パーティションテーブルを参照する場合) には、カンマ区切りのパーティションまたはサブパーティション (あるいはその両方) のリストを含む <code class="literal">PARTITION</code> オプションを含めることができます。 このオプションはテーブルの名前のあとで、かつエイリアス宣言 (存在する場合) の前に指定されます。 このオプションの効果は、リストされたパーティションまたはサブパーティションからのみ行が選択されることです。 リストに指定されていないパーティションまたはサブパーティションは無視されます。 詳細および例については、<a class="xref" href="partitioning.html#partitioning-selection" title="24.5 パーティション選択">セクション24.5「パーティション選択」</a>を参照してください。 
      </p><p>
        <em class="replaceable"><code>table_factor</code></em> の構文は、標準 SQL と比較して MySQL で拡張されています。 標準では、<em class="replaceable"><code>table_reference</code></em> のみを受け入れ、カッコのペア内のリストは受け入れません。 
      </p><p>
        <em class="replaceable"><code>table_reference</code></em> アイテムのリスト内の各カンマが内部結合と同等とみなされる場合、これは保守的な拡張機能です。 例: 
      </p><pre class="programlisting">SELECT * FROM t1 LEFT JOIN (t2, t3, t4)
                 ON (t2.a = t1.a AND t3.b = t1.b AND t4.c = t1.c)
</pre><p>
        次と同等です。
      </p><pre class="programlisting">SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4)
                 ON (t2.a = t1.a AND t3.b = t1.b AND t4.c = t1.c)
</pre><p>
        MySQL では、<code class="literal">JOIN</code>、<code class="literal">CROSS JOIN</code>、および <code class="literal">INNER JOIN</code> は構文上同等です (互いに置き換えることができます)。 標準 SQL では、それらは同等ではありません。 <code class="literal">INNER JOIN</code> は <code class="literal">ON</code> 句とともに使用され、<code class="literal">CROSS JOIN</code> はそれ以外のときに使用されます。 
      </p><p>
        一般に、内部結合操作のみを含む結合式内のかっこは無視できます。 MySQL では、ネストした結合もサポートされています。 <a class="xref" href="optimization.html#nested-join-optimization" title="8.2.1.8 ネストした結合の最適化">セクション8.2.1.8「ネストした結合の最適化」</a>を参照してください。 
      </p><p>
        インデックスヒントを指定すると、MySQL オプティマイザによるインデックスの使用方法に影響を与えることができます。 詳細は、<a class="xref" href="optimization.html#index-hints" title="8.9.4 インデックスヒント">セクション8.9.4「インデックスヒント」</a>を参照してください。 オプティマイザヒントおよび <code class="literal">optimizer_switch</code> システム変数は、オプティマイザによるインデックスの使用に影響を与える他の方法です。 <a class="xref" href="optimization.html#optimizer-hints" title="8.9.3 オプティマイザヒント">セクション8.9.3「オプティマイザヒント」</a>および<a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2 切り替え可能な最適化">セクション8.9.2「切り替え可能な最適化」</a>を参照してください。 
      </p><p>
        次のリストでは、結合の書込み時に考慮する一般的な要因について説明します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブル参照には、<code class="literal"><em class="replaceable"><code>tbl_name</code></em> AS <em class="replaceable"><code>alias_name</code></em></code> または <em class="replaceable"><code>tbl_name alias_name</code></em> を使用してエイリアスを指定できます。
          </p><pre class="programlisting">SELECT t1.name, t2.salary
  FROM employee AS t1 INNER JOIN info AS t2 ON t1.name = t2.name;

SELECT t1.name, t2.salary
  FROM employee t1 INNER JOIN info t2 ON t1.name = t2.name;
</pre></li><li class="listitem"><p>
            <em class="replaceable"><code>table_subquery</code></em> は、<code class="literal">FROM</code> 句では導出テーブルまたはサブクエリーとも呼ばれます。 <a class="xref" href="sql-statements.html#derived-tables" title="13.2.11.8 導出テーブル">セクション13.2.11.8「導出テーブル」</a>を参照してください。 このようなサブクエリーには、サブクエリーの結果にテーブル名を指定するエイリアスを含める必要があります。また、オプションで、カッコ内にテーブルのカラム名のリストを含めることもできます。 簡単な例を次に示します: 
          </p><pre class="programlisting">SELECT * FROM (SELECT 1, 2, 3) AS t1;
</pre></li><li class="listitem"><p>
            1 つの結合で参照できるテーブルの最大数は 61 です。 これには、<code class="literal">FROM</code> 句の導出テーブルおよびビューを外部クエリーブロックにマージすることで処理される結合が含まれます (<a class="xref" href="optimization.html#derived-table-optimization" title="8.2.2.4 マージまたは実体化を使用した導出テーブル、ビュー参照および共通テーブル式の最適化">セクション8.2.2.4「マージまたは実体化を使用した導出テーブル、ビュー参照および共通テーブル式の最適化」</a> を参照)。 
          </p><a class="indexterm" name="idm45826998497264"></a><a class="indexterm" name="idm45826998495120"></a></li><li class="listitem"><p>
            結合条件が存在しない場合、<code class="literal">INNER JOIN</code> と <code class="literal">,</code> (カンマ) は意味的に同等です。どちらも、指定されたテーブル間のデカルト積を生成します (つまり、最初のテーブル内のすべての各行が 2 番目のテーブル内のすべての各行に結合されます)。
          </p><p>
            ただし、カンマ演算子の優先順位は <code class="literal">INNER JOIN</code>, <code class="literal">CROSS JOIN</code>, <code class="literal">LEFT JOIN</code> の優先順位よりも低くなります。 結合条件が存在するときにカンマ結合をほかの結合型と混在させた場合は、<code class="literal">「カラム '<em class="replaceable"><code>col_name</code></em>' は 'on clause' にはありません」</code>という形式のエラーが発生する可能性があります。 この問題への対処に関する情報は、このセクションのあとの方で提供します。 
          </p></li><li class="listitem"><p>
            <code class="literal">ON</code> で使用される <em class="replaceable"><code>search_condition</code></em> は、<code class="literal">WHERE</code> 句で使用できるフォームの条件式です。 通常、<code class="literal">ON</code> 句はテーブルの結合方法を指定する条件に使用され、<code class="literal">WHERE</code> 句は結果セットに含める行を制限します。 
          </p></li><li class="listitem"><p>
            <code class="literal">LEFT JOIN</code> 内の <code class="literal">ON</code> または <code class="literal">USING</code> 部分にある右側のテーブルに一致する行が存在しない場合は、すべてのカラムが <code class="literal">NULL</code> に設定された行が右側のテーブルに使用されます。 このことを使用して、別のテーブルに対応する行が存在しないテーブル内の行を検索できます。 
          </p><pre class="programlisting">SELECT left_tbl.*
  FROM left_tbl LEFT JOIN right_tbl ON left_tbl.id = right_tbl.id
  WHERE right_tbl.id IS NULL;
</pre><p>
            この例では、<code class="literal">right_tbl</code> に存在しない <code class="literal">id</code> 値を持つ <code class="literal">left_tbl</code> 内のすべての行 (つまり、<code class="literal">right_tbl</code> 内に対応する行のない <code class="literal">left_tbl</code> 内のすべての行) を検索します。 <a class="xref" href="optimization.html#outer-join-optimization" title="8.2.1.9 外部結合の最適化">セクション8.2.1.9「外部結合の最適化」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">USING(<em class="replaceable"><code>join_column_list</code></em>)</code> 句は、両方のテーブルに存在する必要があるカラムのリストを指定します。 テーブル <code class="literal">a</code> と <code class="literal">b</code> の両方にカラム <code class="literal">c1</code>、<code class="literal">c2</code>、および <code class="literal">c3</code> が含まれている場合、次の結合は、この 2 つのテーブルの対応するカラムを比較します。 
          </p><pre class="programlisting">a LEFT JOIN b USING (c1, c2, c3)
</pre></li><li class="listitem"><p>
            2 つのテーブルの <code class="literal">NATURAL [LEFT] JOIN</code> は、両方のテーブル内に存在するすべてのカラムを指定する <code class="literal">USING</code> 句を含む <code class="literal">INNER JOIN</code> または <code class="literal">LEFT JOIN</code> と意味的に同等であるとして定義されます。
          </p></li><li class="listitem"><p>
            <code class="literal">RIGHT JOIN</code> は、<code class="literal">LEFT JOIN</code> と同じように機能します。 コードをデータベース間で移植可能な状態に維持するため、<code class="literal">RIGHT JOIN</code> の代わりに <code class="literal">LEFT JOIN</code> を使用することをお勧めします。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45826998455344"></a> <a class="indexterm" name="idm45826998453872"></a> 結合構文の説明に示されている <code class="literal">{ OJ ... }</code> 構文は、ODBC との互換性のためにのみ存在します。 構文内のカールした中括弧は文字どおりに書き込まれる必要があります。それらは構文説明の別の部分で利用されているようなメタ構文ではありません。 
          </p><pre class="programlisting">SELECT left_tbl.*
    FROM { OJ left_tbl LEFT OUTER JOIN right_tbl
           ON left_tbl.id = right_tbl.id }
    WHERE right_tbl.id IS NULL;
</pre><p>
            <code class="literal">{ OJ ... }</code> 内では、<code class="literal">INNER JOIN</code> や <code class="literal">RIGHT OUTER JOIN</code> などのほかの型の結合を使用できます。 これは、一部のサードパーティー製アプリケーションとの互換性に役立ちますが、正式な ODBC 構文ではありません。 
          </p></li><li class="listitem"><p>
            <code class="literal">STRAIGHT_JOIN</code> は、左側のテーブルが常に右側のテーブルの前に読み取られる点を除き、<code class="literal">JOIN</code> と同じです。 これは、結合オプティマイザが最適でない順序でテーブルを処理する (少数の) 場合に使用できます。 
          </p></li></ul></div><p>
        結合のいくつかの例:
      </p><pre class="programlisting">SELECT * FROM table1, table2;

SELECT * FROM table1 INNER JOIN table2 ON table1.id = table2.id;

SELECT * FROM table1 LEFT JOIN table2 ON table1.id = table2.id;

SELECT * FROM table1 LEFT JOIN table2 USING (id);

SELECT * FROM table1 LEFT JOIN table2 ON table1.id = table2.id
  LEFT JOIN table3 ON table2.id = table3.id;
</pre><p>
        外部結合バリアントを含む <code class="literal">USING</code> との自然結合および結合は、SQL:2003 標準に従って処理されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">NATURAL</code> 結合の冗長カラムは表示されません。 次の一連のステートメントを考えてみます。 
          </p><pre class="programlisting">CREATE TABLE t1 (i INT, j INT);
CREATE TABLE t2 (k INT, j INT);
INSERT INTO t1 VALUES(1, 1);
INSERT INTO t2 VALUES(1, 1);
SELECT * FROM t1 NATURAL JOIN t2;
SELECT * FROM t1 JOIN t2 USING (j);
</pre><p>
            最初の <code class="literal">SELECT</code> ステートメントでは、カラム <code class="literal">j</code> は両方のテーブルに現れるため、結合カラムになります。そのため、標準 SQL に従って、出力には 2 回ではなく 1 回だけ表示されるべきです。 同様に、2 番目の SELECT ステートメントでは、カラム <code class="literal">j</code> は <code class="literal">USING</code> 句で指定されているため、出力には 2 回ではなく 1 回だけ表示されるべきです。 
          </p><p>
            したがって、このステートメントは次の出力を生成します:
          </p><pre class="programlisting">+------+------+------+
| j    | i    | k    |
+------+------+------+
|    1 |    1 |    1 |
+------+------+------+
+------+------+------+
| j    | i    | k    |
+------+------+------+
|    1 |    1 |    1 |
+------+------+------+
</pre><p>
            冗長なカラムの削除およびカラムの順序付けは、標準 SQL に従って行われ、次の表示順序が生成されます:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                最初に、結合された 2 つのテーブルの合体した共通カラムが、最初のテーブルに現れた順序で
              </p></li><li class="listitem"><p>
                2 番目に、最初のテーブルに一意のカラムが、そのテーブルに現れた順序で
              </p></li><li class="listitem"><p>
                3 番目に、2 番目のテーブルに一意のカラムが、そのテーブルに現れた順序で
              </p></li></ul></div><p>
            2 つの共通カラムを置き換える 1 つの結果カラムは、合体操作を使用して定義されます。 つまり、<code class="literal">t1.a</code> と <code class="literal">t2.a</code> の 2 つに対して、結果として得られる 1 つの結合カラム <code class="literal">a</code> は <code class="literal">a = COALESCE(t1.a, t2.a)</code> として定義されます。ここでは: 
          </p><pre class="programlisting">COALESCE(x, y) = (CASE WHEN x IS NOT NULL THEN x ELSE y END)
</pre><p>
            結合操作が他の結合の場合、結合の結果カラムは結合されたテーブルのすべてのカラムの連結で構成されます。
          </p><p>
            合体したカラムの定義の結果として、外部結合では、2 つのカラムのいずれかが常に <code class="literal">NULL</code> である場合、合体したカラムには <code class="literal">NULL</code> 以外のカラムの値が含まれます。 どちらのカラムも <code class="literal">NULL</code> でないか、または両方のカラムがこの値である場合、両方の共通カラムに同じ値が含まれているため、合体したカラムの値としてどちらが選択されるかは問題にはなりません。 これを解釈するための簡単な方法として、外部結合の合体したカラムが <code class="literal">JOIN</code> の内部テーブルの共通カラムによって表されると考えてみます。 テーブル <code class="literal">t1(a, b)</code> と <code class="literal">t2(a, c)</code> に次の内容が含まれているとします。 
          </p><pre class="programlisting">t1    t2
----  ----
1 x   2 z
2 y   3 w
</pre><p>
            この結合では、カラム <code class="literal">a</code> に <code class="literal">t1.a</code> の値が含まれます:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM t1 NATURAL LEFT JOIN t2;</code></strong>
+------+------+------+
| a    | b    | c    |
+------+------+------+
|    1 | x    | NULL |
|    2 | y    | z    |
+------+------+------+
</pre><p>
            対照的に、この結合では、カラム <code class="literal">a</code> に <code class="literal">t2.a</code> の値が含まれます。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM t1 NATURAL RIGHT JOIN t2;</code></strong>
+------+------+------+
| a    | c    | b    |
+------+------+------+
|    2 | z    | y    |
|    3 | w    | NULL |
+------+------+------+
</pre><p>
            <code class="literal">JOIN ... ON</code> を使用して、これらの結果をそれ以外の同等のクエリーと比較します:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM t1 LEFT JOIN t2 ON (t1.a = t2.a);</code></strong>
+------+------+------+------+
| a    | b    | a    | c    |
+------+------+------+------+
|    1 | x    | NULL | NULL |
|    2 | y    |    2 | z    |
+------+------+------+------+
</pre><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM t1 RIGHT JOIN t2 ON (t1.a = t2.a);</code></strong>
+------+------+------+------+
| a    | b    | a    | c    |
+------+------+------+------+
|    2 | y    |    2 | z    |
| NULL | NULL |    3 | w    |
+------+------+------+------+
</pre></li><li class="listitem"><p>
            <code class="literal">USING</code> 句は、対応するカラムを比較する <code class="literal">ON</code> 句としてリライトできます。 ただし、<code class="literal">USING</code> と <code class="literal">ON</code> は似ていますが、まったく同じではありません。 次の 2 つのクエリーについて考えてみます: 
          </p><a class="indexterm" name="idm45826998397760"></a><a class="indexterm" name="idm45826998395600"></a><a class="indexterm" name="idm45826998393552"></a><pre class="programlisting">a LEFT JOIN b USING (c1, c2, c3)
a LEFT JOIN b ON a.c1 = b.c1 AND a.c2 = b.c2 AND a.c3 = b.c3
</pre><p>
            結合条件を満たす行の判別に関して、両方の結合は意味的に同一です。
          </p><p>
            <code class="literal">SELECT *</code> の展開に対してどのカラムを表示するかの判定に関しては、この 2 つの結合は意味的に同一ではありません。 <code class="literal">USING</code> 結合が対応するカラムの合体した値を選択するのに対して、<code class="literal">ON</code> 結合は、すべてのテーブルのすべてのカラムを選択します。 <code class="literal">USING</code> 結合の場合、<code class="literal">SELECT *</code> は次の値を選択します: 
          </p><pre class="programlisting">COALESCE(a.c1, b.c1), COALESCE(a.c2, b.c2), COALESCE(a.c3, b.c3)
</pre><p>
            <code class="literal">ON</code> 結合の場合、<code class="literal">SELECT *</code> は次の値を選択します。
          </p><pre class="programlisting">a.c1, a.c2, a.c3, b.c1, b.c2, b.c3
</pre><p>
            内部結合では、両方のカラムの値が同じであるため、<code class="literal">COALESCE(a.c1, b.c1)</code> は <code class="literal">a.c1</code> または <code class="literal">b.c1</code> と同じです。 外部結合 (<code class="literal">LEFT JOIN</code> など) では、2 つのカラムのどちらかが <code class="literal">NULL</code> になる場合があります。 そのカラムは結果から省略されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">ON</code> 句は、そのオペランドのみを参照できます。
          </p><p>
            例:
          </p><pre class="programlisting">CREATE TABLE t1 (i1 INT);
CREATE TABLE t2 (i2 INT);
CREATE TABLE t3 (i3 INT);
SELECT * FROM t1 JOIN t2 ON (i1 = i3) JOIN t3;
</pre><p>
            <code class="literal">i3</code> は <code class="literal">ON</code> 句のオペランドではない <code class="literal">t3</code> のカラムであるため、このステートメントは <code class="literal">Unknown column 'i3' in 'on clause'</code>エラーで失敗します。 結合を処理できるようにするには、次のようにステートメントをリライトします: 
          </p><a class="indexterm" name="idm45826998370112"></a><pre class="programlisting">SELECT * FROM t1 JOIN t2 JOIN t3 ON (i1 = i3);
</pre></li><li class="listitem"><p>
            <code class="literal">JOIN</code> の優先順位はカンマ演算子 (<code class="literal">,</code>) より高いため、結合式 <code class="literal">t1, t2 JOIN t3</code> は <code class="literal">((t1, t2) JOIN t3)</code> としてではなく <code class="literal">(t1, (t2 JOIN t3))</code> として解釈されます。 これは、<code class="literal">ON</code> 句を使用するステートメントに影響します。この句は結合のオペランド内のカラムのみを参照でき、優先順位はそれらのオペランドの解釈に影響します。 
          </p><p>
            例:
          </p><pre class="programlisting">CREATE TABLE t1 (i1 INT, j1 INT);
CREATE TABLE t2 (i2 INT, j2 INT);
CREATE TABLE t3 (i3 INT, j3 INT);
INSERT INTO t1 VALUES(1, 1);
INSERT INTO t2 VALUES(1, 1);
INSERT INTO t3 VALUES(1, 1);
SELECT * FROM t1, t2 JOIN t3 ON (t1.i1 = t3.i3);
</pre><p>
            <code class="literal">JOIN</code> はカンマ演算子よりも優先されるため、<code class="literal">ON</code> 句のオペランドは <code class="literal">t2</code> および <code class="literal">t3</code> です。 <code class="literal">t1.i1</code> はどのオペランドのカラムでもないため、その結果は<code class="literal">「カラム 't1.i1' は 'on clause' にはありません」</code>というエラーになります。 
          </p><a class="indexterm" name="idm45826998355728"></a><p>
            結合を処理できるようにするには、次のいずれかの方法を使用します:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">ON</code> 句のオペランドが <code class="literal">(t1, t2)</code> および <code class="literal">t3</code> になるように、最初の 2 つのテーブルをカッコで明示的にグループ化します:
              </p><pre class="programlisting">SELECT * FROM (t1, t2) JOIN t3 ON (t1.i1 = t3.i3);
</pre></li><li class="listitem"><p>
                カンマ演算子を使用せずに、かわりに <code class="literal">JOIN</code> を使用します:
              </p><pre class="programlisting">SELECT * FROM t1 JOIN t2 JOIN t3 ON (t1.i1 = t3.i3);
</pre></li></ul></div><p>
            同じ優先順位解釈が、カンマ演算子と <code class="literal">INNER JOIN</code>, <code class="literal">CROSS JOIN</code>, <code class="literal">LEFT JOIN</code> および <code class="literal">RIGHT JOIN</code> を混在させるステートメントにも適用されます。これらはすべてカンマ演算子よりも優先順位が高くなります。
          </p></li><li class="listitem"><p>
            SQL:2003 標準と比較した MySQL 拡張機能では、MySQL では <code class="literal">NATURAL</code> または <code class="literal">USING</code> 結合の共通 (結合) カラムを修飾できますが、標準では修飾できません。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="union"></a>13.2.10.3 UNION 句</h4></div></div></div><a class="indexterm" name="idm45826998339040"></a><pre class="programlisting">SELECT ...
UNION [ALL | DISTINCT] SELECT ...
[UNION [ALL | DISTINCT] SELECT ...]
</pre><p>
        <code class="literal">UNION</code> は、複数の <code class="literal">SELECT</code> ステートメントの結果を単一の結果セットに結合します。 例: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT 1, 2;</code></strong>
+---+---+
| 1 | 2 |
+---+---+
| 1 | 2 |
+---+---+
mysql&gt; <strong class="userinput"><code>SELECT 'a', 'b';</code></strong>
+---+---+
| a | b |
+---+---+
| a | b |
+---+---+
mysql&gt; <strong class="userinput"><code>SELECT 1, 2 UNION SELECT 'a', 'b';</code></strong>
+---+---+
| 1 | 2 |
+---+---+
| 1 | 2 |
| a | b |
+---+---+
</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#union-result-set" title="結果セットのカラム名およびデータ型">結果セットのカラム名およびデータ型</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#union-table" title="共用体の TABLE">共用体の TABLE</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#union-distinct-all" title="UNION DISTINCT および UNION ALL">UNION DISTINCT および UNION ALL</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#union-order-by-limit" title="UNION での ORDER BY および LIMIT">UNION での ORDER BY および LIMIT</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#union-restrictions" title="UNION の制限">UNION の制限</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#union-8-0-versus-5-7" title="MySQL 5.7 と比較した MySQL 8.0 での UNION の処理">MySQL 5.7 と比較した MySQL 8.0 での UNION の処理</a></p></li></ul></div><h5><a name="union-result-set"></a>結果セットのカラム名およびデータ型</h5><p>
        <code class="literal">UNION</code> 結果セットのカラム名は、最初の <code class="literal">SELECT</code> ステートメントのカラム名から取得されます。
      </p><p>
        各 <code class="literal">SELECT</code> ステートメントの対応する位置にリストされている選択されるカラムは、データ型が同じになるようにしてください。 たとえば、最初のステートメントで選択された最初のカラムは、他のステートメントで選択された最初のカラムと同じタイプである必要があります。 対応する <code class="literal">SELECT</code> カラムのデータ型が一致しない場合、<code class="literal">UNION</code> 結果のカラムの型と長さでは、すべての <code class="literal">SELECT</code> ステートメントによって取得された値が考慮されます。 たとえば、カラムの長さが最初の <code class="literal">SELECT</code> の値の長さに制約されていない次の例を考えてみます: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT REPEAT('a',1) UNION SELECT REPEAT('b',20);</code></strong>
+----------------------+
| REPEAT('a',1)        |
+----------------------+
| a                    |
| bbbbbbbbbbbbbbbbbbbb |
+----------------------+
</pre><h5><a name="union-table"></a>共用体の TABLE</h5><p>
        MySQL 8.0.19 以降では、同等の <code class="literal">SELECT</code> ステートメントを使用できる場所であれば、<code class="literal">UNION</code> で <code class="literal">TABLE</code> ステートメントまたは <code class="literal">VALUES</code> ステートメントを使用することもできます。 次に示すように、テーブル <code class="literal">t1</code> および <code class="literal">t2</code> が作成され、移入されているとします: 
      </p><pre class="programlisting">CREATE TABLE t1 (x INT, y INT);
INSERT INTO t1 VALUES ROW(4,-2),ROW(5,9);

CREATE TABLE t2 (a INT, b INT);
INSERT INTO t2 VALUES ROW(1,2),ROW(3,4);
</pre><p>
        前述の例では、<code class="literal">VALUES</code> 以降のクエリーの出力のカラム名は無視され、次の <code class="literal">UNION</code> クエリーはすべて同じ結果になります:
      </p><pre class="programlisting">SELECT * FROM t1 UNION SELECT * FROM t2;
TABLE t1 UNION SELECT * FROM t2;
VALUES ROW(4,-2), ROW(5,9) UNION SELECT * FROM t2;
SELECT * FROM t1 UNION TABLE t2;
TABLE t1 UNION TABLE t2;
VALUES ROW(4,-2), ROW(5,9) UNION TABLE t2;
SELECT * FROM t1 UNION VALUES ROW(4,-2),ROW(5,9);
TABLE t1 UNION VALUES ROW(4,-2),ROW(5,9);
VALUES ROW(4,-2), ROW(5,9) UNION VALUES ROW(4,-2),ROW(5,9);
</pre><p>
        カラム名を強制的に同じにするには、<code class="literal">VALUES</code> を <code class="literal">SELECT</code> の左側にラップし、次のようにエイリアスを使用します:
      </p><pre class="programlisting">SELECT * FROM (VALUES ROW(4,-2), ROW(5,9)) AS t(x,y)
  UNION TABLE t2;
SELECT * FROM (VALUES ROW(4,-2), ROW(5,9)) AS t(x,y)
  UNION VALUES ROW(4,-2),ROW(5,9);
</pre><h5><a name="union-distinct-all"></a>UNION DISTINCT および UNION ALL</h5><p>
        デフォルトでは、重複行は <code class="literal">UNION</code> の結果から削除されます。 オプションの <code class="literal">DISTINCT</code> キーワードも同じ効果がありますが、明示的になります。 オプションの <code class="literal">ALL</code> キーワードを指定すると、重複した行の削除は実行されず、その結果には、すべての <code class="literal">SELECT</code> ステートメントからの一致するすべての行が含まれます。 
      </p><p>
        <code class="literal">UNION ALL</code> と <code class="literal">UNION DISTINCT</code> を同じクエリー内で混在させることができます。 混在した <code class="literal">UNION</code> 型は、<code class="literal">DISTINCT</code> 和集合がその左側にある <code class="literal">ALL</code> 和集合をすべてオーバーライドするように処理されます。 <code class="literal">DISTINCT</code> 和集合は、<code class="literal">UNION DISTINCT</code> を使用して明示的に、あるいはそのあとに <code class="literal">DISTINCT</code> または <code class="literal">ALL</code> キーワードのない <code class="literal">UNION</code> を使用して暗黙的に生成できます。 
      </p><p>
        MySQL 8.0.19 以降では、<code class="literal">UNION ALL</code> および <code class="literal">UNION DISTINCT</code> は、1 つ以上の <code class="literal">TABLE</code> ステートメントが共用体で使用されている場合と同じように動作します。
      </p><h5><a name="union-order-by-limit"></a>UNION での ORDER BY および LIMIT</h5><p>
        <code class="literal">ORDER BY</code> または <code class="literal">LIMIT</code> 句を個々の <code class="literal">SELECT</code> に適用するには、<code class="literal">SELECT</code> をカッコで囲み、カッコ内に句を配置します:
      </p><pre class="programlisting">(SELECT a FROM t1 WHERE a=10 AND B=1 ORDER BY a LIMIT 10)
UNION
(SELECT a FROM t2 WHERE a=11 AND B=2 ORDER BY a LIMIT 10);
</pre><p>
        個々の <code class="literal">SELECT</code> ステートメントに <code class="literal">ORDER BY</code> を使用すると、<code class="literal">UNION</code> では順序付けられていない行のセットがデフォルトで生成されるため、最終結果に行が表示される順序については何も意味しません。 したがって、このコンテキストの <code class="literal">ORDER BY</code> は通常、<code class="literal">SELECT</code> 用に取得する選択済の行のサブセットを決定するために <code class="literal">LIMIT</code> とともに使用されますが、最終的な <code class="literal">UNION</code> 結果の行の順序には必ずしも影響しません。 <code class="literal">SELECT</code> に <code class="literal">LIMIT</code> がない状態で <code class="literal">ORDER BY</code> が表示された場合は、どのような場合にも効果がないため最適化されます。 
      </p><p>
        <code class="literal">ORDER BY</code> または <code class="literal">LIMIT</code> 句を使用して <code class="literal">UNION</code> 結果全体をソートまたは制限するには、個々の <code class="literal">SELECT</code> ステートメントをカッコで囲み、最後のステートメントの後に <code class="literal">ORDER BY</code> または <code class="literal">LIMIT</code> を配置します:
      </p><pre class="programlisting">(SELECT a FROM t1 WHERE a=10 AND B=1)
UNION
(SELECT a FROM t2 WHERE a=11 AND B=2)
ORDER BY a LIMIT 10;
</pre><p>
        括弧のないステートメントは、今示した括弧で囲まれたステートメントと同等です。
      </p><p>
        MySQL 8.0.19 以降、<code class="literal">TABLE</code> は <code class="literal">WHERE</code> 句をサポートしていないことに注意して、前述の方法と同じ方法で <code class="literal">TABLE</code> とともに <code class="literal">ORDER BY</code> および <code class="literal">LIMIT</code> を使用できます。
      </p><p>
        この種の <code class="literal">ORDER BY</code> は、テーブル名 (つまり、<em class="replaceable"><code>tbl_name</code></em>.<em class="replaceable"><code>col_name</code></em> という形式の名前) を含むカラム参照を使用できません。 代わりに、最初の <code class="literal">SELECT</code> ステートメント内にカラムのエイリアスを指定し、そのエイリアスを <code class="literal">ORDER BY</code> 内で参照します。 (あるいは、<code class="literal">ORDER BY</code> 内でカラムを、そのカラム位置を使用して参照します。 ただし、カラム位置の使用は非推奨です。)  
      </p><p>
        また、ソートされるカラムにエイリアスが指定されている場合、<code class="literal">ORDER BY</code> 句はそのカラム名ではなく、エイリアスを参照する<span class="emphasis"><em>必要があります</em></span>。 次のステートメントのうち最初のステートメントは許可されていますが、次のステートメントは <code class="literal">Unknown column 'a' in 'order clause'</code>エラーで失敗します: 
      </p><pre class="programlisting">(SELECT a AS b FROM t) UNION (SELECT ...) ORDER BY b;
(SELECT a AS b FROM t) UNION (SELECT ...) ORDER BY a;
</pre><p>
        <code class="literal">UNION</code> 結果の行が各 <code class="literal">SELECT</code> によって取得された行のセットで構成されるようにするには、ソートカラムとして使用する各 <code class="literal">SELECT</code> の追加のカラムを選択し、最後の <code class="literal">SELECT</code> に続くそのカラムでソートする <code class="literal">ORDER BY</code> を追加します:
      </p><pre class="programlisting">(SELECT 1 AS sort_col, col1a, col1b, ... FROM t1)
UNION
(SELECT 2, col2a, col2b, ... FROM t2) ORDER BY sort_col;
</pre><p>
        さらに個々の <code class="literal">SELECT</code> の結果内のソート順序を維持するには、<code class="literal">ORDER BY</code> 句にセカンダリカラムを追加します。
      </p><pre class="programlisting">(SELECT 1 AS sort_col, col1a, col1b, ... FROM t1)
UNION
(SELECT 2, col2a, col2b, ... FROM t2) ORDER BY sort_col, col1a;
</pre><p>
        また、追加のカラムを使用すると、各行がどの <code class="literal">SELECT</code> から取得されるかを決定することもできます。 追加のカラムでは、テーブル名を示す文字列などのほかの識別情報も指定できます。 
      </p><h5><a name="union-restrictions"></a>UNION の制限</h5><p>
        <code class="literal">UNION</code> では、<code class="literal">SELECT</code> ステートメントは通常の SELECT ステートメントですが、次の制限があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            最初の <code class="literal">SELECT</code> の <code class="literal">HIGH_PRIORITY</code> は効果がありません。 後続の <code class="literal">SELECT</code> の <code class="literal">HIGH_PRIORITY</code> では、構文エラーが発生します。 
          </p></li><li class="listitem"><p>
            最後の <code class="literal">SELECT</code> ステートメントのみが <code class="literal">INTO</code> 句を使用できます。 ただし、<code class="literal">UNION</code> の結果全体が <code class="literal">INTO</code> 出力先に書き込まれます。 
          </p></li></ul></div><p>
        MySQL 8.0.20 では、<code class="literal">INTO</code> を含む次の 2 つの <code class="literal">UNION</code> バリアントは非推奨であり、将来のバージョンの MySQL でサポートが削除される予定です:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            クエリー式の後続のクエリーブロックでは、<code class="literal">FROM</code> の前に <code class="literal">INTO</code> を使用すると警告が生成されます。 例: 
          </p><pre class="programlisting">... UNION SELECT * INTO OUTFILE '<em class="replaceable"><code>file_name</code></em>' FROM <em class="replaceable"><code>table_name</code></em>;
</pre></li><li class="listitem"><p>
            クエリー式のカッコで囲まれた後続ブロックでは、<code class="literal">INTO</code> を (<code class="literal">FROM</code> に対する相対位置に関係なく) 使用すると警告が生成されます。 例: 
          </p><pre class="programlisting">... UNION (SELECT * INTO OUTFILE '<em class="replaceable"><code>file_name</code></em>' FROM <em class="replaceable"><code>table_name</code></em>);
</pre><p>
            これらのバリアントは、クエリー式 (<code class="literal">UNION</code>) 全体ではなく名前付きテーブルから情報を収集するかのように、混乱しているため非推奨です。
          </p></li></ul></div><p>
        <code class="literal">ORDER BY</code> 句に集計関数を含む <code class="literal">UNION</code> クエリーは、<code class="literal">ER_AGGREGATE_ORDER_FOR_UNION</code> エラーで拒否されます。 例: 
      </p><pre class="programlisting">SELECT 1 AS foo UNION SELECT 2 ORDER BY MAX(1);
</pre><h5><a name="union-8-0-versus-5-7"></a>MySQL 5.7 と比較した MySQL 8.0 での UNION の処理</h5><p>
        MySQL 8.0 では、<code class="literal">SELECT</code> および <code class="literal">UNION</code> のパーサールールがリファクタリングされ、より一貫性が保たれ (このような各コンテキストで同じ <code class="literal">SELECT</code> 構文が均一に適用される)、重複が削減されました。 MySQL 5.7 と比較すると、この作業の結果、次のようないくつかのユーザーに見える影響があり、特定のステートメントのリライトが必要になる場合があります: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">NATURAL JOIN</code> では、標準 SQL に準拠したオプションの <code class="literal">INNER</code> キーワード (<code class="literal">NATURAL INNER JOIN</code>) を使用できます。
          </p></li><li class="listitem"><p>
            標準 SQL に準拠すると、カッコなしの右重複結合 (<code class="literal">... JOIN ... JOIN ... ON ... ON</code> など) が許可されます。
          </p></li><li class="listitem"><p>
            <code class="literal">STRAIGHT_JOIN</code> では、他の内部結合と同様に <code class="literal">USING</code> 句が許可されるようになりました。
          </p></li><li class="listitem"><p>
            パーサーは、クエリー式を囲むカッコを受け入れます。 たとえば、<code class="literal">(SELECT ... UNION SELECT ...)</code> は許可されています。 <a class="xref" href="sql-statements.html#parenthesized-query-expressions" title="13.2.10.4 カッコで囲まれたクエリー式">セクション13.2.10.4「カッコで囲まれたクエリー式」</a>も参照してください。 
          </p></li><li class="listitem"><p>
            パーサーは、<code class="literal">SQL_CACHE</code> および <code class="literal">SQL_NO_CACHE</code> クエリー修飾子の許可された配置に準拠しています。
          </p></li><li class="listitem"><p>
            以前はサブクエリーでのみ許可されていた共用体の左端のネストが、トップレベルのステートメントで許可されるようになりました。 たとえば、次のステートメントは有効として受け入れられます: 
          </p><pre class="programlisting">(SELECT 1 UNION SELECT 1) UNION SELECT 1;
</pre></li><li class="listitem"><p>
            ロック句 (<code class="literal">FOR UPDATE</code>、<code class="literal">LOCK IN SHARE MODE</code>) は、<code class="literal">UNION</code> 以外のクエリーでのみ使用できます。 つまり、ロック句を含む <code class="literal">SELECT</code> ステートメントにはカッコを使用する必要があります。 このステートメントは有効ではなくなりました: 
          </p><pre class="programlisting">SELECT 1 FOR UPDATE UNION SELECT 1 FOR UPDATE;
</pre><p>
            かわりに、次のようなステートメントを記述します:
          </p><pre class="programlisting">(SELECT 1 FOR UPDATE) UNION (SELECT 1 FOR UPDATE);
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="parenthesized-query-expressions"></a>13.2.10.4 カッコで囲まれたクエリー式</h4></div></div></div><a class="indexterm" name="idm45826998165712"></a><a class="indexterm" name="idm45826998164208"></a><a class="indexterm" name="idm45826998162128"></a><a class="indexterm" name="idm45826998160048"></a><a class="indexterm" name="idm45826998157968"></a><pre class="programlisting"><em class="replaceable"><code>parenthesized_query_expression</code></em>:
    ( <em class="replaceable"><code>query_expression</code></em> [<em class="replaceable"><code>order_by_clause</code></em>] [<em class="replaceable"><code>limit_clause</code></em>] )
      [<em class="replaceable"><code>order_by_clause</code></em>]
      [<em class="replaceable"><code>limit_clause</code></em>]
      [<em class="replaceable"><code>into_clause</code></em>]

<em class="replaceable"><code>query_expression</code></em>:
    <em class="replaceable"><code>query_block</code></em> [UNION <em class="replaceable"><code>query_block</code></em> [UNION <em class="replaceable"><code>query_block</code></em> ...]]
      [<em class="replaceable"><code>order_by_clause</code></em>]
      [<em class="replaceable"><code>limit_clause</code></em>]
      [<em class="replaceable"><code>into_clause</code></em>]

<em class="replaceable"><code>query_block</code></em>:
    SELECT ...             (see <a class="xref" href="sql-statements.html#select" title="13.2.10 SELECT ステートメント">セクション13.2.10「SELECT ステートメント」</a>)

<em class="replaceable"><code>order_by_clause</code></em>:
    ORDER BY as for SELECT (see <a class="xref" href="sql-statements.html#select" title="13.2.10 SELECT ステートメント">セクション13.2.10「SELECT ステートメント」</a>)

<em class="replaceable"><code>limit_clause</code></em>:
    LIMIT as for SELECT    (see <a class="xref" href="sql-statements.html#select" title="13.2.10 SELECT ステートメント">セクション13.2.10「SELECT ステートメント」</a>)

<em class="replaceable"><code>into_clause</code></em>:
    INTO as for SELECT     (see <a class="xref" href="sql-statements.html#select" title="13.2.10 SELECT ステートメント">セクション13.2.10「SELECT ステートメント」</a>)
</pre><p>
        MySQL 8.0.22 以上では、前述の構文に従ってカッコで囲まれたクエリー式がサポートされます。 最も単純なのは、カッコで囲まれたクエリー式に単一の <code class="literal">SELECT</code> が含まれ、次のオプション句は含まれないことです: 
      </p><pre class="programlisting">(SELECT 1);
(SELECT * FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = 'mysql');
</pre><p>
        カッコで囲まれたクエリー式には、複数の <code class="literal">SELECT</code> ステートメントで構成される <code class="literal">UNION</code> を含めることもでき、オプションの句の一部またはすべてで終わることができます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>(SELECT 1 AS result UNION SELECT 2);</code></strong>
+--------+
| result |
+--------+
|      1 |
|      2 |
+--------+
mysql&gt; <strong class="userinput"><code>(SELECT 1 AS result UNION SELECT 2) LIMIT 1;</code></strong>
+--------+
| result |
+--------+
|      1 |
+--------+
mysql&gt; <strong class="userinput"><code>(SELECT 1 AS result UNION SELECT 2) LIMIT 1 OFFSET 1;</code></strong>
+--------+
| result |
+--------+
|      2 |
+--------+
mysql&gt; <strong class="userinput"><code>(SELECT 1 AS result UNION SELECT 2)</code></strong>
       <strong class="userinput"><code>ORDER BY result DESC LIMIT 1;</code></strong>
+--------+
| result |
+--------+
|      2 |
+--------+
mysql&gt; <strong class="userinput"><code>(SELECT 1 AS result UNION SELECT 2)</code></strong>
       <strong class="userinput"><code>ORDER BY result DESC LIMIT 1 OFFSET 1;</code></strong>
+--------+
| result |
+--------+
|      1 |
+--------+
mysql&gt; <strong class="userinput"><code>(SELECT 1 AS result UNION SELECT 3 UNION SELECT 2)</code></strong>
       <strong class="userinput"><code>ORDER BY result LIMIT 1 OFFSET 1 INTO @var;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT @var;</code></strong>
+------+
| @var |
+------+
|    2 |
+------+
</pre><p>
        カッコで囲まれたクエリー式はクエリー式としても使用されるため、クエリー式は通常、クエリーブロックで構成され、カッコで囲まれたクエリー式で構成されることもあります:
      </p><pre class="programlisting">(SELECT * FROM t1 ORDER BY a) UNION (SELECT * FROM t2 ORDER BY b) ORDER BY z;
</pre><p>
        クエリーブロックには、外部の <code class="literal">UNION</code> および <code class="literal">ORDER BY</code> と <code class="literal">LIMIT</code> の前に適用される後続の <code class="literal">ORDER BY</code> 句および <code class="literal">LIMIT</code> 句がある場合があります。
      </p><p>
        末尾に <code class="literal">ORDER BY</code> または <code class="literal">LIMIT</code> を含むクエリーブロックをカッコで囲まずに含めることはできませんが、カッコは様々な方法で強制に使用できます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            各クエリーブロックに <code class="literal">LIMIT</code> を適用するには:
          </p><pre class="programlisting">(SELECT 1 LIMIT 1) UNION (SELECT 2 LIMIT 1);
</pre></li><li class="listitem"><p>
            クエリーブロックとクエリー式全体の両方に <code class="literal">LIMIT</code> を適用するには:
          </p><pre class="programlisting">(SELECT 1 LIMIT 1) UNION (SELECT 2 LIMIT 1) LIMIT 1;
</pre></li><li class="listitem"><p>
            クエリー式全体に <code class="literal">LIMIT</code> を適用するには (カッコなし):
          </p><pre class="programlisting">SELECT 1 UNION SELECT 2 LIMIT 1;
</pre></li><li class="listitem"><p>
            ハイブリッド強制: 最初のクエリーブロックおよびクエリー式全体に対する <code class="literal">LIMIT</code>:
          </p><pre class="programlisting">(SELECT 1 LIMIT 1) UNION SELECT 2 LIMIT 1;
</pre></li></ul></div><p>
        このセクションで説明する構文には、特定の制限事項があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">ORDER BY</code> がカッコで囲まれたクエリー式内で発生し、外部クエリーにも適用される場合、結果は未定義であり、将来のバージョンの MySQL で変更される可能性があります。 <code class="literal">LIMIT</code> がカッコで囲まれたクエリー式内に出現し、外部クエリーにも適用される場合も同様です。 
          </p></li><li class="listitem"><p>
            クエリー式の末尾の <code class="literal">INTO</code> 句は、カッコ内に別の <code class="literal">INTO</code> 句がある場合は使用できません。
          </p></li><li class="listitem"><p>
            カッコで囲まれたクエリー式では、複数レベルの <code class="literal">ORDER BY</code> または <code class="literal">LIMIT</code> 操作は許可されません。 例: 
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>(SELECT 'a' UNION SELECT 'b' LIMIT 1) LIMIT 2;</code></strong>
ERROR 1235 (42000): This version of MySQL doesn't yet support 'parenthesized
query expression with more than one external level of ORDER/LIMIT operations'
</pre></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="subqueries"></a>13.2.11 サブクエリー</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#scalar-subqueries">13.2.11.1 スカラーオペランドとしてのサブクエリー</a></span></dt><dt><span class="section"><a href="sql-statements.html#comparisons-using-subqueries">13.2.11.2 サブクエリーを使用した比較</a></span></dt><dt><span class="section"><a href="sql-statements.html#any-in-some-subqueries">13.2.11.3 ANY、IN、または SOME を使用したサブクエリー</a></span></dt><dt><span class="section"><a href="sql-statements.html#all-subqueries">13.2.11.4 ALL を使用したサブクエリー</a></span></dt><dt><span class="section"><a href="sql-statements.html#row-subqueries">13.2.11.5 行サブクエリー</a></span></dt><dt><span class="section"><a href="sql-statements.html#exists-and-not-exists-subqueries">13.2.11.6 EXISTS または NOT EXISTS を使用したサブクエリー</a></span></dt><dt><span class="section"><a href="sql-statements.html#correlated-subqueries">13.2.11.7 相関サブクエリー</a></span></dt><dt><span class="section"><a href="sql-statements.html#derived-tables">13.2.11.8 導出テーブル</a></span></dt><dt><span class="section"><a href="sql-statements.html#lateral-derived-tables">13.2.11.9 ラテラル導出テーブル</a></span></dt><dt><span class="section"><a href="sql-statements.html#subquery-errors">13.2.11.10 サブクエリーのエラー</a></span></dt><dt><span class="section"><a href="sql-statements.html#optimizing-subqueries">13.2.11.11 サブクエリーの最適化</a></span></dt><dt><span class="section"><a href="sql-statements.html#subquery-restrictions">13.2.11.12 サブクエリーの制約</a></span></dt></dl></div><a class="indexterm" name="idm45826998095936"></a><a class="indexterm" name="idm45826998094480"></a><a class="indexterm" name="idm45826998093136"></a><a class="indexterm" name="idm45826998091376"></a><p>
      サブクエリーは、別のステートメント内の <code class="literal">SELECT</code> ステートメントです。
    </p><p>
      SQL 標準で必要とされるすべてのサブクエリーフォームと操作、および MySQL 固有のいくつかの機能がサポートされています。
    </p><p>
      サブクエリーの例を次に示します。
    </p><pre class="programlisting">SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);
</pre><p>
      この例では、<code class="literal">SELECT * FROM t1 ...</code> が<span class="emphasis"><em>外部クエリー</em></span> (または <span class="emphasis"><em>外部ステートメント</em></span>) であり、<code class="literal">(SELECT column1 FROM t2)</code> が<span class="emphasis"><em>サブクエリー</em></span>です。 これを、このサブクエリーは外部クエリー内で<span class="emphasis"><em>ネストされている</em></span>と表現し、また実際、サブクエリーをほかのサブクエリー内で (かなりの深さまで) ネストできます。 サブクエリーは常に、括弧内に指定する必要があります。 
    </p><p>
      サブクエリーの主な利点は次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ステートメントの各部分を分離できるように、<span class="emphasis"><em>構造化された</em></span>クエリーを可能にします。
        </p></li><li class="listitem"><p>
          通常であれば複雑な結合や和集合を必要とする操作を実行するための代替手段を提供します。
        </p></li><li class="listitem"><p>
          多くの人びとが、サブクエリーを複雑な結合や和集合より読みやすいと感じています。 実際、早期の SQL である<span class="quote">「<span class="quote">構造化クエリー言語</span>」</span>を呼び出すという元の考え方を人びとに提供したのは、サブクエリーの技術革新でした。 
        </p></li></ul></div><p>
      SQL 標準で指定され、MySQL でサポートされているサブクエリー構文に関する主なポイントを示すステートメントの例を次に示します。
    </p><pre class="programlisting">DELETE FROM t1
WHERE s11 &gt; ANY
 (SELECT COUNT(*) /* no hint */ FROM t2
  WHERE NOT EXISTS
   (SELECT * FROM t3
    WHERE ROW(5*t2.s1,77)=
     (SELECT 50,11*s1 FROM t4 UNION SELECT 50,77 FROM
      (SELECT * FROM t5) AS t5)));
</pre><p>
      サブクエリーは、スカラー (単一値)、単一行、単一カラム、またはテーブル (1 つ以上のカラムの 1 つ以上の行) を返すことができます。 これらは、スカラー、カラム、行、およびテーブルサブクエリーと呼ばれます。 特定の種類の結果を返すサブクエリーは多くの場合、次の各セクションで説明されているように、特定のコンテキストでのみ使用できます。 
    </p><p>
      サブクエリーを使用できるステートメントのタイプに関する制限はほとんどありません。 サブクエリーには、<code class="literal">DISTINCT</code>、<code class="literal">GROUP BY</code>、<code class="literal">ORDER BY</code>、<code class="literal">LIMIT</code>、結合、インデックスヒント、<code class="literal">UNION</code> 構造構文、コメント、関数などの、通常の <code class="literal">SELECT</code> に含めることのできる多くのキーワードや句を含めることができます。 
    </p><p>
      MySQL 8.0.19 以降、<code class="literal">TABLE</code> および <code class="literal">VALUES</code> ステートメントをサブクエリーで使用できます。 通常、<code class="literal">VALUES</code> を使用するサブクエリーは、set 表記法を使用するか、<code class="literal">SELECT</code> または <code class="literal">TABLE</code> 構文を使用してよりコンパクトにリライトできる、より詳細なバージョンのサブクエリーです。<code class="literal">CREATE TABLE ts VALUES ROW(2), ROW(4), ROW(6)</code> ステートメントを使用して <code class="literal">ts</code> テーブルを作成する場合、ここに示すステートメントはすべて同等です: 
    </p><pre class="programlisting">SELECT * FROM tt
    WHERE b &gt; ANY (VALUES ROW(2), ROW(4), ROW(6));

SELECT * FROM tt
    WHERE b &gt; ANY (2, 4, 6);

SELECT * FROM tt
    WHERE b &gt; ANY (SELECT * FROM ts);

SELECT * FROM tt
    WHERE b &gt; ANY (TABLE ts);
</pre><p>
      次の各セクションでは、<code class="literal">TABLE</code> サブクエリーの例を示します。
    </p><p>
      サブクエリーの外部ステートメントは、<code class="literal">SELECT</code>、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、<code class="literal">DELETE</code>、<code class="literal">SET</code>、<code class="literal">DO</code> のいずれでもかまいません。
    </p><p>
      オプティマイザによるサブクエリーの処理方法については、<a class="xref" href="optimization.html#subquery-optimization" title="8.2.2 サブクエリー、導出テーブル、ビュー参照および共通テーブル式の最適化">セクション8.2.2「サブクエリー、導出テーブル、ビュー参照および共通テーブル式の最適化」</a>を参照してください。 サブクエリーの使用に関する制限の説明 (特定の形式のサブクエリー構文でのパフォーマンスの問題を含む) については、<a class="xref" href="sql-statements.html#subquery-restrictions" title="13.2.11.12 サブクエリーの制約">セクション13.2.11.12「サブクエリーの制約」</a>を参照してください。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="scalar-subqueries"></a>13.2.11.1 スカラーオペランドとしてのサブクエリー</h4></div></div></div><p>
        もっとも単純な形式のサブクエリーは、単一値を返すスカラーサブクエリーです。 スカラーサブクエリーは単純なオペランドであるため、単一カラム値またはリテラルが正当である場所であればほぼどこでも使用できるほか、データ型、長さ、<code class="literal">NULL</code> にできることの表示などの、すべてのオペランドが持っている特性を持つことを期待できます。 例: 
      </p><pre class="programlisting">CREATE TABLE t1 (s1 INT, s2 CHAR(5) NOT NULL);
INSERT INTO t1 VALUES(100, 'abcde');
SELECT (SELECT s2 FROM t1);
</pre><p>
        この <code class="literal">SELECT</code> 内のサブクエリーは、<code class="literal">CHAR</code> のデータ型、5 の長さ、<code class="literal">CREATE TABLE</code> の時点で有効なデフォルトに等しい文字セットと照合順序、およびこのカラム内の値を <code class="literal">NULL</code> にできることの表示を持つ単一値 (<code class="literal">'abcde'</code>) を返します。 サブクエリー結果が空であればその結果は <code class="literal">NULL</code> になるため、スカラーサブクエリーによって選択された値の NULL 可能性はコピーされません。 今示したサブクエリーで <code class="literal">t1</code> が空であった場合は、<code class="literal">s2</code> が <code class="literal">NOT NULL</code> であるにもかかわらず、その結果は <code class="literal">NULL</code> になります。 
      </p><p>
        スカラーサブクエリーを使用できないコンテキストがいくつか存在します。 ステートメントでリテラル値のみが許可されている場合は、サブクエリーを使用できません。 たとえば、<code class="literal">LIMIT</code> にはリテラル整数引数が必要で、<code class="literal">LOAD DATA</code> にはリテラル文字列ファイル名が必要です。 サブクエリーを使用してこれらの値を指定することはできません。 
      </p><p>
        次の各セクションにある、やや簡素な構造構文 <code class="literal">(SELECT column1 FROM t1)</code> が含まれた例を参照するときは、はるかに多様で、かつ複雑な構造構文を含む独自のコードがあるものと考えてください。
      </p><p>
        次の 2 つのテーブルを作成するとします。
      </p><pre class="programlisting">CREATE TABLE t1 (s1 INT);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2 (s1 INT);
INSERT INTO t2 VALUES (2);
</pre><p>
        次に、<code class="literal">SELECT</code> を実行します。
      </p><pre class="programlisting">SELECT (SELECT s1 FROM t2) FROM t1;
</pre><p>
        <code class="literal">t2</code> には、<code class="literal">2</code> の値を持つカラム <code class="literal">s1</code> が含まれている行が存在するため、その結果は <code class="literal">2</code> になります。
      </p><p>
        MySQL 8.0.19 以降では、<code class="literal">TABLE</code> を使用して前述のクエリーを次のように記述することもできます:
      </p><pre class="programlisting">SELECT (TABLE t2) FROM t1;
</pre><p>
        スカラーサブクエリーを式の一部にすることはできますが、そのサブクエリーが関数への引数を提供するオペランドである場合でも、括弧を忘れないでください。 例: 
      </p><pre class="programlisting">SELECT UPPER((SELECT s1 FROM t1)) FROM t2;
</pre><p>
        同じ結果は、MySQL 8.0.19 以降で <code class="literal">SELECT UPPER((TABLE t1)) FROM t2</code> を使用して取得できます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="comparisons-using-subqueries"></a>13.2.11.2 サブクエリーを使用した比較</h4></div></div></div><p>
        サブクエリーのもっとも一般的な使用の形式は次のとおりです。
      </p><pre class="programlisting"><em class="replaceable"><code>non_subquery_operand</code></em> <em class="replaceable"><code>comparison_operator</code></em> (<em class="replaceable"><code>subquery</code></em>)
</pre><p>
        ここで、<em class="replaceable"><code>comparison_operator</code></em> は次の演算子のいずれかです。
      </p><pre class="programlisting">=  &gt;  &lt;  &gt;=  &lt;=  &lt;&gt;  !=  &lt;=&gt;
</pre><p>
        例:
      </p><pre class="programlisting">... WHERE 'a' = (SELECT column1 FROM t1)
</pre><p>
        MySQL では、次の構造構文も許可されます。
      </p><pre class="programlisting"><em class="replaceable"><code>non_subquery_operand</code></em> LIKE (<em class="replaceable"><code>subquery</code></em>)
</pre><p>
        以前は、サブクエリーの唯一の正当な場所は比較の右側であり、この方法にこだわったいくつかの古い DBMS がまだ見つかることもあります。
      </p><p>
        結合では実行できない一般的な形式のサブクエリー比較の例を次に示します。 これは、<code class="literal">column1</code> 値がテーブル <code class="literal">t2</code> 内の最大値に等しいテーブル <code class="literal">t1</code> 内のすべての行を検索します。 
      </p><pre class="programlisting">SELECT * FROM t1
  WHERE column1 = (SELECT MAX(column2) FROM t2);
</pre><p>
        次に別の例を示します。これもまた、いずれかのテーブルに対する集約が含まれているため、結合では実行できません。 これは、特定のカラムに 2 回現れる値を含むテーブル <code class="literal">t1</code> 内のすべての行を検索します。 
      </p><pre class="programlisting">SELECT * FROM t1 AS t
  WHERE 2 = (SELECT COUNT(*) FROM t1 WHERE t1.id = t.id);
</pre><p>
        スカラーに対するサブクエリーの比較の場合、サブクエリーはスカラーを返す必要があります。 行コンストラクタに対するサブクエリーの比較の場合、サブクエリーは、その行コンストラクタと同じ数の値を含む行を返す行サブクエリーである必要があります。 <a class="xref" href="sql-statements.html#row-subqueries" title="13.2.11.5 行サブクエリー">セクション13.2.11.5「行サブクエリー」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="any-in-some-subqueries"></a>13.2.11.3 ANY、IN、または SOME を使用したサブクエリー</h4></div></div></div><a class="indexterm" name="idm45826997996912"></a><a class="indexterm" name="idm45826997994736"></a><a class="indexterm" name="idm45826997993568"></a><a class="indexterm" name="idm45826997992288"></a><p>
        構文:
      </p><pre class="programlisting"><em class="replaceable"><code>operand</code></em> <em class="replaceable"><code>comparison_operator</code></em> ANY (<em class="replaceable"><code>subquery</code></em>)
<em class="replaceable"><code>operand</code></em> IN (<em class="replaceable"><code>subquery</code></em>)
<em class="replaceable"><code>operand</code></em> <em class="replaceable"><code>comparison_operator</code></em> SOME (<em class="replaceable"><code>subquery</code></em>)
</pre><p>
        ここで、<em class="replaceable"><code>comparison_operator</code></em> は次の演算子のいずれかです。
      </p><pre class="programlisting">=  &gt;  &lt;  &gt;=  &lt;=  &lt;&gt;  !=
</pre><p>
        <code class="literal">ANY</code> キーワード (これは比較演算子のあとに指定する必要があります) は、<span class="quote">「<span class="quote">このサブクエリーが返すカラム内の値の <code class="literal">ANY</code> (いずれか) に対して比較が <code class="literal">TRUE</code> である場合は <code class="literal">TRUE</code> を返す</span>」</span>ことを示します。 例: 
      </p><pre class="programlisting">SELECT s1 FROM t1 WHERE s1 &gt; ANY (SELECT s1 FROM t2);
</pre><p>
        テーブル <code class="literal">t1</code> 内に <code class="literal">(10)</code> を含む行が存在するとします。 テーブル <code class="literal">t2</code> に <code class="literal">(21,14,7)</code> が含まれている場合、<code class="literal">t2</code> には <code class="literal">10</code> より小さい値 <code class="literal">7</code> が存在するため、この式は <code class="literal">TRUE</code> です。 テーブル <code class="literal">t2</code> に <code class="literal">(20,10)</code> が含まれている場合、またはテーブル <code class="literal">t2</code> が空である場合、この式は <code class="literal">FALSE</code> です。 テーブル <code class="literal">t2</code> に <code class="literal">(NULL,NULL,NULL)</code> が含まれている場合、この式は<span class="emphasis"><em>不明</em></span> (つまり、<code class="literal">NULL</code>) です。 
      </p><p>
        サブクエリーで使用されている場合、ワード <code class="literal">IN</code> は <code class="literal">= ANY</code> のエイリアスです。 そのため、次の 2 つのステートメントは同じです。 
      </p><pre class="programlisting">SELECT s1 FROM t1 WHERE s1 = ANY (SELECT s1 FROM t2);
SELECT s1 FROM t1 WHERE s1 IN    (SELECT s1 FROM t2);
</pre><p>
        式リストで使用されている場合、<code class="literal">IN</code> と <code class="literal">= ANY</code> はシノニムではありません。 <code class="literal">IN</code> は式リストを取得できますが、<code class="literal">= ANY</code> はできません。 <a class="xref" href="functions.html#comparison-operators" title="12.4.2 比較関数と演算子">セクション12.4.2「比較関数と演算子」</a>を参照してください。 
      </p><p>
        <code class="literal">NOT IN</code> は <code class="literal">&lt;&gt; ANY</code> ではなく、<code class="literal">&lt;&gt; ALL</code> のエイリアスです。 <a class="xref" href="sql-statements.html#all-subqueries" title="13.2.11.4 ALL を使用したサブクエリー">セクション13.2.11.4「ALL を使用したサブクエリー」</a>を参照してください。 
      </p><p>
        ワード <code class="literal">SOME</code> は <code class="literal">ANY</code> のエイリアスです。 そのため、次の 2 つのステートメントは同じです。 
      </p><pre class="programlisting">SELECT s1 FROM t1 WHERE s1 &lt;&gt; ANY  (SELECT s1 FROM t2);
SELECT s1 FROM t1 WHERE s1 &lt;&gt; SOME (SELECT s1 FROM t2);
</pre><p>
        ワード <code class="literal">SOME</code> はほとんど使用されませんが、この例は、これがなぜ役立つ可能性があるかを示しています。 ほとんどの人びとにとって、<span class="quote">「<span class="quote">a is not equal to any b</span>」</span>(a はどの b にも等しくない) という英語のフレーズは<span class="quote">「<span class="quote">there is no b which is equal to a</span>」</span>(a に等しい b は存在しない) を示しますが、それはこの SQL 構文が示す内容とは異なります。 この構文は、<span class="quote">「<span class="quote">there is some b to which a is not equal</span>」</span>(a に等しくない b がいくつか存在する) を示します。 代わりに <code class="literal">&lt;&gt; SOME</code> を使用すると、このクエリーの本当の意味がすべての人に理解されるようにするのに役立ちます。 
      </p><p>
        MySQL 8.0.19 以降、テーブルに単一のカラムのみが含まれている場合は、スカラー <code class="literal">IN</code>、<code class="literal">ANY</code> または <code class="literal">SOME</code> サブクエリーで <code class="literal">TABLE</code> を使用できます。 <code class="literal">t2</code> にカラムが 1 つしかない場合は、このセクションで前述したステートメントを次に示すように記述できます。各場合は、<code class="literal">SELECT s1 FROM t2</code> を <code class="literal">TABLE t2</code> に置き換えます: 
      </p><pre class="programlisting">SELECT s1 FROM t1 WHERE s1 &gt; ANY (TABLE t2);

SELECT s1 FROM t1 WHERE s1 = ANY (TABLE t2);

SELECT s1 FROM t1 WHERE s1 IN (TABLE t2);

SELECT s1 FROM t1 WHERE s1 &lt;&gt; ANY  (TABLE t2);

SELECT s1 FROM t1 WHERE s1 &lt;&gt; SOME (TABLE t2);
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="all-subqueries"></a>13.2.11.4 ALL を使用したサブクエリー</h4></div></div></div><a class="indexterm" name="idm45826997940016"></a><a class="indexterm" name="idm45826997937888"></a><p>
        構文:
      </p><pre class="programlisting"><em class="replaceable"><code>operand</code></em> <em class="replaceable"><code>comparison_operator</code></em> ALL (<em class="replaceable"><code>subquery</code></em>)
</pre><p>
        ワード <code class="literal">ALL</code> (これは比較演算子のあとに指定する必要があります) は、<span class="quote">「<span class="quote">このサブクエリーが返すカラム内の値の <code class="literal">ALL</code> (すべて) に対して比較が <code class="literal">TRUE</code> である場合は <code class="literal">TRUE</code> を返す</span>」</span>ことを示します。 例: 
      </p><pre class="programlisting">SELECT s1 FROM t1 WHERE s1 &gt; ALL (SELECT s1 FROM t2);
</pre><p>
        テーブル <code class="literal">t1</code> 内に <code class="literal">(10)</code> を含む行が存在するとします。 テーブル <code class="literal">t2</code> に <code class="literal">(-5,0,+5)</code> が含まれている場合、<code class="literal">10</code> が <code class="literal">t2</code> 内の 3 つのすべての値より大きいため、この式は <code class="literal">TRUE</code> です。 テーブル <code class="literal">t2</code> に <code class="literal">(12,6,NULL,-100)</code> が含まれている場合、テーブル <code class="literal">t2</code> には <code class="literal">10</code> より大きい単一値 <code class="literal">12</code> が存在するため、この式は <code class="literal">FALSE</code> です。 テーブル <code class="literal">t2</code> に <code class="literal">(0,NULL,1)</code> が含まれている場合、この式は<span class="emphasis"><em>不明</em></span> (つまり、<code class="literal">NULL</code>) です。 
      </p><p>
        最後に、テーブル <code class="literal">t2</code> が空である場合、この式は <code class="literal">TRUE</code> です。 そのため、テーブル <code class="literal">t2</code> が空であるとき、次の式は <code class="literal">TRUE</code> です。 
      </p><pre class="programlisting">SELECT * FROM t1 WHERE 1 &gt; ALL (SELECT s1 FROM t2);
</pre><p>
        ただし、テーブル <code class="literal">t2</code> が空であるとき、次の式は <code class="literal">NULL</code> です。
      </p><pre class="programlisting">SELECT * FROM t1 WHERE 1 &gt; (SELECT s1 FROM t2);
</pre><p>
        さらに、テーブル <code class="literal">t2</code> が空であるとき、次の式は <code class="literal">NULL</code> です。
      </p><pre class="programlisting">SELECT * FROM t1 WHERE 1 &gt; ALL (SELECT MAX(s1) FROM t2);
</pre><p>
        一般に、<span class="emphasis"><em><code class="literal">NULL</code> 値を含むテーブル</em></span>と<span class="emphasis"><em>空のテーブル</em></span>は<span class="quote">「<span class="quote">エッジケース</span>」</span>です。 サブクエリーを記述するときは、常に、これらの 2 つの可能性を考慮に入れたかどうかを考慮してください。 
      </p><p>
        <code class="literal">NOT IN</code> は <code class="literal">&lt;&gt; ALL</code> のエイリアスです。 そのため、次の 2 つのステートメントは同じです。 
      </p><pre class="programlisting">SELECT s1 FROM t1 WHERE s1 &lt;&gt; ALL (SELECT s1 FROM t2);
SELECT s1 FROM t1 WHERE s1 NOT IN (SELECT s1 FROM t2);
</pre><p>
        MySQL 8.0.19 では、<code class="literal">TABLE</code> ステートメントがサポートされます。 <code class="literal">IN</code>、<code class="literal">ANY</code> および <code class="literal">SOME</code> と同様に、次の 2 つの条件が満たされている場合は <code class="literal">TABLE</code> を <code class="literal">ALL</code> および <code class="literal">NOT IN</code> とともに使用できます: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            サブクエリーのテーブルに含まれるカラムは 1 つのみです
          </p></li><li class="listitem"><p>
            サブクエリーはカラム式に依存していません
          </p></li></ul></div><p>
        たとえば、テーブル <code class="literal">t2</code> が単一のカラムで構成されていると仮定すると、前述の最後の 2 つのステートメントは、次のように <code class="literal">TABLE t2</code> を使用して記述できます:
      </p><pre class="programlisting">SELECT s1 FROM t1 WHERE s1 &lt;&gt; ALL (TABLE t2);
SELECT s1 FROM t1 WHERE s1 NOT IN (TABLE t2);
</pre><p>
        サブクエリーはカラム式に依存するため、<code class="literal">SELECT * FROM t1 WHERE 1 &gt; ALL (SELECT MAX(s1) FROM t2);</code>などのクエリーは <code class="literal">TABLE t2</code> を使用して記述できません。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="row-subqueries"></a>13.2.11.5 行サブクエリー</h4></div></div></div><a class="indexterm" name="idm45826997885312"></a><a class="indexterm" name="idm45826997883840"></a><a class="indexterm" name="idm45826997882928"></a><a class="indexterm" name="idm45826997881440"></a><p>
        スカラーサブクエリーまたはカラムサブクエリーは、単一の値または値のカラムを返します。 <span class="emphasis"><em>行サブクエリー</em></span>は、単一行を返し、そのために複数のカラム値を返すことができるサブクエリーバリアントです。 行サブクエリーの比較のための正当な演算子は次のとおりです。 
      </p><pre class="programlisting">=  &gt;  &lt;  &gt;=  &lt;=  &lt;&gt;  !=  &lt;=&gt;
</pre><p>
        次に、2 つの例を示します。
      </p><pre class="programlisting">SELECT * FROM t1
  WHERE (col1,col2) = (SELECT col3, col4 FROM t2 WHERE id = 10);
SELECT * FROM t1
  WHERE ROW(col1,col2) = (SELECT col3, col4 FROM t2 WHERE id = 10);
</pre><p>
        どちらのクエリーでも、テーブル <code class="literal">t2</code> に <code class="literal">id = 10</code> を持つ単一行が含まれている場合、このサブクエリーは単一行を返します。 この行に <code class="literal">t1</code> 内のいずれかの行の <code class="literal">col1</code> および <code class="literal">col2</code> 値に等しい <code class="literal">col3</code> および <code class="literal">col4</code> 値が含まれている場合、<code class="literal">WHERE</code> 式は <code class="literal">TRUE</code> であり、各クエリーはこれらの <code class="literal">t1</code> 行を返します。 <code class="literal">t2</code> 行の <code class="literal">col3</code> および <code class="literal">col4</code> 値が、いずれの <code class="literal">t1</code> 行の <code class="literal">col1</code> および <code class="literal">col2</code> 値にも等しくない場合、この式は <code class="literal">FALSE</code> であり、このクエリーは空の結果セットを返します。 サブクエリーによって行が生成されない場合、この式は<span class="emphasis"><em>不明</em></span> (つまり、<code class="literal">NULL</code>) です。 サブクエリーによって複数の行が生成される場合は、行サブクエリーが最大で 1 行しか返すことができないため、エラーが発生します。 
      </p><p>
        行の比較における各演算子の動作の詳細は、<a class="xref" href="functions.html#comparison-operators" title="12.4.2 比較関数と演算子">セクション12.4.2「比較関数と演算子」</a> を参照してください。
      </p><p>
        式 <code class="literal">(1,2)</code> や <code class="literal">ROW(1,2)</code> は、<span class="firstterm">行コンストラクタ</span>とも呼ばれます。 この 2 つは同等です。 行コンストラクタと、サブクエリーによって返される行には、同じ数の値が含まれている必要があります。 
      </p><p>
        行コンストラクタは、2 つ以上のカラムを返すサブクエリーとの比較に使用されます。 サブクエリーが単一カラムを返すと、これは行ではなく、スカラー値として見なされるため、少なくとも 2 つのカラムを返さないサブクエリーで行コンストラクタを使用することはできません。 そのため、次のクエリーは構文エラーで失敗します。 
      </p><pre class="programlisting">SELECT * FROM t1 WHERE ROW(1) = (SELECT column1 FROM t2)
</pre><p>
        行コンストラクタは、ほかのコンテキストでも正当です。 たとえば、次の 2 つのステートメントは意味的に同等です (また、オプティマイザによって同じように処理されます)。 
      </p><pre class="programlisting">SELECT * FROM t1 WHERE (column1,column2) = (1,1);
SELECT * FROM t1 WHERE column1 = 1 AND column2 = 1;
</pre><p>
        次のクエリーは、<span class="quote">「<span class="quote">テーブル <code class="literal">t2</code> 内にも存在するテーブル <code class="literal">t1</code> 内のすべての行を検索する</span>」</span>という要求にこたえます。
      </p><pre class="programlisting">SELECT column1,column2,column3
  FROM t1
  WHERE (column1,column2,column3) IN
         (SELECT column1,column2,column3 FROM t2);
</pre><p>
        オプティマイザおよび行コンストラクタの詳細は、<a class="xref" href="optimization.html#row-constructor-optimization" title="8.2.1.22 行コンストラクタ式の最適化">セクション8.2.1.22「行コンストラクタ式の最適化」</a> を参照してください
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="exists-and-not-exists-subqueries"></a>13.2.11.6 EXISTS または NOT EXISTS を使用したサブクエリー</h4></div></div></div><a class="indexterm" name="idm45826997846352"></a><a class="indexterm" name="idm45826997844224"></a><a class="indexterm" name="idm45826997842144"></a><a class="indexterm" name="idm45826997840080"></a><p>
        サブクエリーが少なくとも 1 行を返す場合、<code class="literal">EXISTS <em class="replaceable"><code>subquery</code></em></code> は <code class="literal">TRUE</code> であり、<code class="literal">NOT EXISTS <em class="replaceable"><code>subquery</code></em></code> は <code class="literal">FALSE</code> です。 例: 
      </p><pre class="programlisting">SELECT column1 FROM t1 WHERE EXISTS (SELECT * FROM t2);
</pre><p>
        従来より、<code class="literal">EXISTS</code> サブクエリーは <code class="literal">SELECT *</code> で始まりますが、<code class="literal">SELECT 5</code> や <code class="literal">SELECT column1</code>、あるいはほかの何で始まってもかまいません。 MySQL はこのようなサブクエリー内の <code class="literal">SELECT</code> リストを無視するため、何も違いは生まれません。 
      </p><p>
        前の例では、<code class="literal">t2</code> に何らかの行が含まれている場合 (<code class="literal">NULL</code> 値以外は何も含まれていない行でも)、<code class="literal">EXISTS</code> 条件は <code class="literal">TRUE</code> です。 <code class="literal">[NOT] EXISTS</code> サブクエリーには、ほぼ常に相互関係が含まれるため、これは実際にはありそうにもない例です。 次に、より現実的な例をいくつか示します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            1 つ以上の市に存在するのはどのような種類のお店ですか?
          </p><pre class="programlisting">SELECT DISTINCT store_type FROM stores
  WHERE EXISTS (SELECT * FROM cities_stores
                WHERE cities_stores.store_type = stores.store_type);
</pre></li><li class="listitem"><p>
            どの市にも存在しないのはどのような種類のお店ですか?
          </p><pre class="programlisting">SELECT DISTINCT store_type FROM stores
  WHERE NOT EXISTS (SELECT * FROM cities_stores
                    WHERE cities_stores.store_type = stores.store_type);
</pre></li><li class="listitem"><p>
            すべての市に存在するのはどのような種類のお店ですか?
          </p><pre class="programlisting">SELECT DISTINCT store_type FROM stores s1
  WHERE NOT EXISTS (
    SELECT * FROM cities WHERE NOT EXISTS (
      SELECT * FROM cities_stores
       WHERE cities_stores.city = cities.city
       AND cities_stores.store_type = stores.store_type));
</pre></li></ul></div><p>
        最後の例は、二重にネストされた <code class="literal">NOT EXISTS</code> クエリーです。 つまり、<code class="literal">NOT EXISTS</code> 句の中に <code class="literal">NOT EXISTS</code> 句が存在します。 これは正式には、<span class="quote">「<span class="quote"><code class="literal">Stores</code> にないお店が含まれている市は存在しますか</span>」</span>? という質問に答えます。 ただし、ネストされた <code class="literal">NOT EXISTS</code> が、<span class="quote">「<span class="quote"><em class="replaceable"><code>x</code></em> はすべての <em class="replaceable"><code>y</code></em> に対して <code class="literal">TRUE</code> ですか?</span>」</span>という質問に答えるという方が簡単です。 
      </p><p>
        MySQL 8.0.19 以降では、次のように、<code class="literal">NOT EXISTS</code> または <code class="literal">NOT EXISTS</code> を <code class="literal">TABLE</code> とともにサブクエリーで使用することもできます:
      </p><pre class="programlisting">SELECT column1 FROM t1 WHERE EXISTS (TABLE t2);
</pre><p>
        結果は、サブクエリーで <code class="literal">WHERE</code> 句を指定せずに <code class="literal">SELECT *</code> を使用した場合と同じです。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="correlated-subqueries"></a>13.2.11.7 相関サブクエリー</h4></div></div></div><a class="indexterm" name="idm45826997803200"></a><a class="indexterm" name="idm45826997801744"></a><p>
        <span class="emphasis"><em>相関サブクエリー</em></span>は、外部クエリーにも現れるテーブルへの参照を含むサブクエリーです。 例: 
      </p><pre class="programlisting">SELECT * FROM t1
  WHERE column1 = ANY (SELECT column1 FROM t2
                       WHERE t2.column2 = t1.column2);
</pre><p>
        このサブクエリーには、サブクエリーの <code class="literal">FROM</code> 句でテーブル <code class="literal">t1</code> が指定されていない場合でも、<code class="literal">t1</code> のカラムへの参照が含まれます。 そのため、MySQL はこのサブクエリーの外部を探し、外部クエリー内の <code class="literal">t1</code> を見つけます。 
      </p><p>
        テーブル <code class="literal">t1</code> に <code class="literal">column1 = 5</code> かつ <code class="literal">column2 = 6</code> である行が含まれている一方、テーブル <code class="literal">t2</code> に <code class="literal">column1 = 5</code> かつ <code class="literal">column2 = 7</code> である行が含まれているとします。 単純な式 <code class="literal">... WHERE column1 = ANY (SELECT column1 FROM t2)</code> は <code class="literal">TRUE</code> になりますが、この例では、サブクエリー内の <code class="literal">WHERE</code> 句は (<code class="literal">(5,6)</code> が <code class="literal">(5,7)</code> に等しくないため) <code class="literal">FALSE</code> です。そのため、全体としての式は <code class="literal">FALSE</code> です。 
      </p><p>
        <span class="bold"><strong>スコープルール:</strong></span> MySQL は、内部から外部に評価します。 例: 
      </p><pre class="programlisting">SELECT column1 FROM t1 AS x
  WHERE x.column1 = (SELECT column1 FROM t2 AS x
    WHERE x.column1 = (SELECT column1 FROM t3
      WHERE x.column2 = t3.column1));
</pre><p>
        このステートメントでは、<code class="literal">SELECT column1 FROM t2 AS x ...</code> が <code class="literal">t2</code> の名前を変更するため、<code class="literal">x.column2</code> はテーブル <code class="literal">t2</code> 内のカラムである必要があります。 <code class="literal">SELECT column1 FROM t1 ...</code> が<span class="emphasis"><em>さらに外部にある</em></span>外部クエリーであるため、これはテーブル <code class="literal">t1</code> 内のカラムではありません。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="derived-tables"></a>13.2.11.8 導出テーブル</h4></div></div></div><a class="indexterm" name="idm45826997774896"></a><a class="indexterm" name="idm45826997773424"></a><a class="indexterm" name="idm45826997770976"></a><p>
        このセクションでは、導出テーブルの一般的な特性について説明します。 <code class="literal">LATERAL</code> キーワードで始まるラテラル導出テーブルの詳細は、<a class="xref" href="sql-statements.html#lateral-derived-tables" title="13.2.11.9 ラテラル導出テーブル">セクション13.2.11.9「ラテラル導出テーブル」</a> を参照してください。 
      </p><p>
        導出テーブルは、クエリーの <code class="literal">FROM</code> 句の有効範囲内にテーブルを生成する式です。 たとえば、<code class="literal">SELECT</code> ステートメントの <code class="literal">FROM</code> 句のサブクエリーは導出テーブルです: 
      </p><pre class="programlisting">SELECT ... FROM (<em class="replaceable"><code>subquery</code></em>) [AS] <em class="replaceable"><code>tbl_name</code></em> ...
</pre><p>
        <code class="literal">JSON_TABLE()</code> 関数は、テーブルを生成し、導出テーブルを作成する別の方法を提供します:
      </p><pre class="programlisting">SELECT * FROM JSON_TABLE(<em class="replaceable"><code>arg_list</code></em>) [AS] <em class="replaceable"><code>tbl_name</code></em> ...
</pre><p>
        <code class="literal">FROM</code> 句のすべてのテーブルに名前が必要なため、<code class="literal">[AS] <em class="replaceable"><code>tbl_name</code></em></code> 句は必須です。 導出テーブルのカラムには一意の名前を付ける必要があります。 または、<em class="replaceable"><code>tbl_name</code></em> の後に、導出テーブルのカラムの名前をカッコで囲んだリストを続けることもできます: 
      </p><pre class="programlisting">SELECT ... FROM (<em class="replaceable"><code>subquery</code></em>) [AS] <em class="replaceable"><code>tbl_name</code></em> (<em class="replaceable"><code>col_list</code></em>) ...
</pre><p>
        カラム名の数は、テーブルのカラムの数と同じである必要があります。
      </p><p>
        説明のために、次のテーブルがあるとします。
      </p><pre class="programlisting">CREATE TABLE t1 (s1 INT, s2 CHAR(5), s3 FLOAT);
</pre><p>
        このテーブルの例を使用して、<code class="literal">FROM</code> 句内のサブクエリーを使用する方法を次に示します。
      </p><pre class="programlisting">INSERT INTO t1 VALUES (1,'1',1.0);
INSERT INTO t1 VALUES (2,'2',2.0);
SELECT sb1,sb2,sb3
  FROM (SELECT s1 AS sb1, s2 AS sb2, s3*2 AS sb3 FROM t1) AS sb
  WHERE sb1 &gt; 1;
</pre><p>
        結果:
      </p><pre class="programlisting">+------+------+------+
| sb1  | sb2  | sb3  |
+------+------+------+
|    2 | 2    |    4 |
+------+------+------+
</pre><p>
        次に別の例を示します。グループ化されたテーブルに関する一連の合計の平均を知りたいとします。 次のクエリーは機能しません。 
      </p><pre class="programlisting">SELECT AVG(SUM(column1)) FROM t1 GROUP BY column1;
</pre><p>
        ただし、次のクエリーは目的の情報を提供します。
      </p><pre class="programlisting">SELECT AVG(sum_column1)
  FROM (SELECT SUM(column1) AS sum_column1
        FROM t1 GROUP BY column1) AS t1;
</pre><p>
        サブクエリー内で使用されているカラム名 (<code class="literal">sum_column1</code>) は外部クエリーで認識されます。
      </p><p>
        導出テーブルのカラム名は、その選択リストから取得されます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM (SELECT 1, 2, 3, 4) AS dt;</code></strong>
+---+---+---+---+
| 1 | 2 | 3 | 4 |
+---+---+---+---+
| 1 | 2 | 3 | 4 |
+---+---+---+---+
</pre><p>
        カラム名を明示的に指定するには、導出テーブル名の後にカラム名のカッコ付きリストを付けます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM (SELECT 1, 2, 3, 4) AS dt (a, b, c, d);</code></strong>
+---+---+---+---+
| a | b | c | d |
+---+---+---+---+
| 1 | 2 | 3 | 4 |
+---+---+---+---+
</pre><p>
        導出テーブルは、スカラー、カラム、行またはテーブルを戻すことができます。
      </p><p>
        導出テーブルには、次の制限事項があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            導出テーブルには、同じ <code class="literal">SELECT</code> の他のテーブルへの参照を含めることはできません (そのためには <code class="literal">LATERAL</code> 導出テーブルを使用します。<a class="xref" href="sql-statements.html#lateral-derived-tables" title="13.2.11.9 ラテラル導出テーブル">セクション13.2.11.9「ラテラル導出テーブル」</a> を参照)。
          </p></li><li class="listitem"><p>
            MySQL 8.0.14 より前は、導出テーブルに外部参照を含めることはできません。 これは、SQL 標準の制限ではなく、MySQL 8.0.14 で削除された MySQL 制限です。 たとえば、次のクエリーの導出テーブル <code class="literal">dt</code> には、外部クエリーのテーブル <code class="literal">t1</code> への参照 <code class="literal">t1.b</code> が含まれています: 
          </p><pre class="programlisting">SELECT * FROM t1
WHERE t1.d &gt; (SELECT AVG(dt.a)
                FROM (SELECT SUM(t2.a) AS a
                      FROM t2
                      WHERE t2.b = t1.b GROUP BY t2.c) dt
              WHERE dt.a &gt; 10);
</pre><p>
            クエリーは、MySQL 8.0.14 以上で有効です。 8.0.14 より前は、エラーが生成されます: <code class="literal">Unknown column 't1.b' in 'where clause'</code> 
          </p></li></ul></div><p>
        オプティマイザは、導出テーブルに関する情報を、<code class="literal">EXPLAIN</code> が導出テーブルを実体化する必要がないように決定します。 <a class="xref" href="optimization.html#derived-table-optimization" title="8.2.2.4 マージまたは実体化を使用した導出テーブル、ビュー参照および共通テーブル式の最適化">セクション8.2.2.4「マージまたは実体化を使用した導出テーブル、ビュー参照および共通テーブル式の最適化」</a>を参照してください。 
      </p><p>
        特定の状況下では、<code class="literal">EXPLAIN SELECT</code> を使用してテーブルデータを変更できます。 これは、外部クエリーがいずれかのテーブルにアクセスし、内部クエリーが、テーブルの 1 つ以上の行を変更するストアドファンクションを呼び出す場合に発生する可能性があります。 データベース <code class="literal">d1</code> に 2 つのテーブル <code class="literal">t1</code> および <code class="literal">t2</code> があり、次に示すように <code class="literal">t2</code> を変更するストアドファンクション <code class="literal">f1</code> が作成されているとします: 
      </p><pre class="programlisting">CREATE DATABASE d1;
USE d1;
CREATE TABLE t1 (c1 INT);
CREATE TABLE t2 (c1 INT);
CREATE FUNCTION f1(p1 INT) RETURNS INT
  BEGIN
    INSERT INTO t2 VALUES (p1);
    RETURN p1;
  END;
</pre><p>
        次に示すように、<code class="literal">EXPLAIN SELECT</code> で関数を直接参照しても、<code class="literal">t2</code> には影響しません:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM t2;</code></strong>
Empty set (0.02 sec)

mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT f1(5)\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: NULL
   partitions: NULL
         type: NULL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
     filtered: NULL
        Extra: No tables used
1 row in set (0.01 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t2;</code></strong>
Empty set (0.01 sec)
</pre><p>
        これは、出力の <code class="literal">table</code> および <code class="literal">Extra</code> カラムでわかるように、<code class="literal">SELECT</code> ステートメントがどのテーブルも参照しなかったためです。 これはまた、次のネストされた <code class="literal">SELECT</code> にも当てはまります。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT NOW() AS a1, (SELECT f1(5)) AS a2\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: NULL
         type: NULL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
     filtered: NULL
        Extra: No tables used
1 row in set, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+-------+------+------------------------------------------+
| Level | Code | Message                                  |
+-------+------+------------------------------------------+
| Note  | 1249 | Select 2 was reduced during optimization |
+-------+------+------------------------------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t2;</code></strong>
Empty set (0.00 sec)
</pre><p>
        ただし、外部 <code class="literal">SELECT</code> がいずれかのテーブルを参照する場合、オプティマイザはサブクエリーのステートメントも実行し、<code class="literal">t2</code> が変更されます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM t1 AS a1, (SELECT f1(5)) AS a2\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: &lt;derived2&gt;
   partitions: NULL
         type: system
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: PRIMARY
        table: a1
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: NULL
*************************** 3. row ***************************
           id: 2
  select_type: DERIVED
        table: NULL
   partitions: NULL
         type: NULL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
     filtered: NULL
        Extra: No tables used
3 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t2;</code></strong>
+------+
| c1   |
+------+
|    5 |
+------+
1 row in set (0.00 sec)
</pre><p>
        これはまた、次に示すような <code class="literal">EXPLAIN SELECT</code> ステートメントは、<code class="literal">t1</code> 内の行ごとに 1 回 <code class="literal">BENCHMARK()</code> 関数が実行されるため、実行に長い時間がかかる可能性があることも示しています。
      </p><pre class="programlisting">EXPLAIN SELECT * FROM t1 AS a1, (SELECT BENCHMARK(1000000, MD5(NOW())));
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="lateral-derived-tables"></a>13.2.11.9 ラテラル導出テーブル</h4></div></div></div><a class="indexterm" name="idm45826997688848"></a><a class="indexterm" name="idm45826997686720"></a><p>
        導出テーブルは、通常、同じ <code class="literal">FROM</code> 句内の前述のテーブルのカラムを参照 (依存) することはできません。 MySQL 8.0.14 では、導出テーブルを横導出テーブルとして定義して、このような参照が許可されるように指定できます。 
      </p><p>
        非ラテラル導出テーブルは、<a class="xref" href="sql-statements.html#derived-tables" title="13.2.11.8 導出テーブル">セクション13.2.11.8「導出テーブル」</a> で説明されている構文を使用して指定します。 ラテラル導出テーブルの構文は、導出テーブルの指定の前にキーワード <code class="literal">LATERAL</code> が指定されている点を除き、非ラテラル導出テーブルの構文と同じです。 <code class="literal">LATERAL</code> キーワードは、ラテラル導出テーブルとして使用される各テーブルの前に指定する必要があります。 
      </p><p>
        ラテラル導出テーブルには、次の制限事項があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ラテラル導出テーブルは、カンマで区切られたテーブルのリストまたは結合指定 (<code class="literal">JOIN</code>, <code class="literal">INNER JOIN</code>, <code class="literal">CROSS JOIN</code>, <code class="literal">LEFT [OUTER] JOIN</code> または <code class="literal">RIGHT [OUTER] JOIN</code>) のいずれかで、<code class="literal">FROM</code> 句でのみ使用できます。
          </p></li><li class="listitem"><p>
            ラテラル導出テーブルが結合句の右オペランドにあり、左オペランドへの参照が含まれている場合、結合操作は <code class="literal">INNER JOIN</code>、<code class="literal">CROSS JOIN</code> または <code class="literal">LEFT [OUTER] JOIN</code> である必要があります。
          </p><p>
            テーブルが左オペランドにあり、右オペランドへの参照が含まれている場合、結合操作は <code class="literal">INNER JOIN</code>、<code class="literal">CROSS JOIN</code> または <code class="literal">RIGHT [OUTER] JOIN</code> である必要があります。
          </p></li><li class="listitem"><p>
            ラテラル導出テーブルが集計関数を参照する場合、関数集計クエリーを、ラテラル導出テーブルが発生する <code class="literal">FROM</code> 句を所有するクエリーにすることはできません。
          </p></li><li class="listitem"><p>
            SQL 標準に従って、テーブル関数には暗黙的な <code class="literal">LATERAL</code> があるため、8.0.14 より前の MySQL 8.0 バージョンと同様に動作します。 ただし、標準に従って、<code class="literal">LATERAL</code> ワードは暗黙的であっても <code class="literal">JSON_TABLE()</code> の前には許可されません。 
          </p></li></ul></div><p>
        次の説明では、潜在的導出テーブルによって、非潜在的導出テーブルで実行できない特定の SQL 操作や、より効率的な回避策を必要とする特定の SQL 操作がどのように行われるかを示します。
      </p><p>
        この問題を解決するとします: 営業部隊内の個人のテーブル (各行に販売部隊のメンバーが記述されている) と、すべての売上のテーブル (各行に販売が記述されている) があるとします: 営業担当、顧客、金額、日付) は、各営業担当の最大販売の規模と顧客を決定します。 この問題には 2 つの方法があります。 
      </p><p>
        問題を解決する最初のアプローチ: 各営業担当について、最大販売サイズを計算し、この最大値を指定した顧客も検索します。 MySQL では、次のように実行できます: 
      </p><pre class="programlisting">SELECT
  salesperson.name,
  -- find maximum sale size for this salesperson
  (SELECT MAX(amount) AS amount
    FROM all_sales
    WHERE all_sales.salesperson_id = salesperson.id)
  AS amount,
  -- find customer for this maximum size
  (SELECT customer_name
    FROM all_sales
    WHERE all_sales.salesperson_id = salesperson.id
    AND all_sales.amount =
         -- find maximum size, again
         (SELECT MAX(amount) AS amount
           FROM all_sales
           WHERE all_sales.salesperson_id = salesperson.id))
  AS customer_name
FROM
  salesperson;
</pre><p>
        このクエリーでは、営業担当ごとに最大サイズが 2 回 (最初のサブクエリーで 1 回、2 回目で) 計算されるため、非効率的です。
      </p><p>
        次の変更されたクエリーに示すように、営業担当ごとに最大数を計算し、それを導出テーブルで<span class="quote">「<span class="quote">「キャッシュ」</span>」</span>することで、効率性向上を試みることができます:
      </p><pre class="programlisting">SELECT
  salesperson.name,
  max_sale.amount,
  max_sale_customer.customer_name
FROM
  salesperson,
  -- calculate maximum size, cache it in transient derived table max_sale
  (SELECT MAX(amount) AS amount
    FROM all_sales
    WHERE all_sales.salesperson_id = salesperson.id)
  AS max_sale,
  -- find customer, reusing cached maximum size
  (SELECT customer_name
    FROM all_sales
    WHERE all_sales.salesperson_id = salesperson.id
    AND all_sales.amount =
        -- the cached maximum size
        max_sale.amount)
  AS max_sale_customer;
</pre><p>
        ただし、導出テーブルは同じ <code class="literal">FROM</code> 句の他のテーブルに依存できないため、SQL-92 ではクエリーは無効です。 導出テーブルは、クエリー期間中は一定である必要があり、他の <code class="literal">FROM</code> 句テーブルのカラムへの参照は含まれません。 前述のとおり、クエリーでは次のエラーが生成されます: 
      </p><pre class="programlisting">ERROR 1054 (42S22): Unknown column 'salesperson.id' in 'where clause'
</pre><p>
        SQL:1999 では、導出テーブルの前に <code class="literal">LATERAL</code> キーワード (<span class="quote">「<span class="quote">「この導出テーブルは左側の前のテーブルに依存しています」</span>」</span>を意味する) がある場合、クエリーは有効になります:
      </p><pre class="programlisting">SELECT
  salesperson.name,
  max_sale.amount,
  max_sale_customer.customer_name
FROM
  salesperson,
  -- calculate maximum size, cache it in transient derived table max_sale
  LATERAL
  (SELECT MAX(amount) AS amount
    FROM all_sales
    WHERE all_sales.salesperson_id = salesperson.id)
  AS max_sale,
  -- find customer, reusing cached maximum size
  LATERAL
  (SELECT customer_name
    FROM all_sales
    WHERE all_sales.salesperson_id = salesperson.id
    AND all_sales.amount =
        -- the cached maximum size
        max_sale.amount)
  AS max_sale_customer;
</pre><p>
        ラテラル導出テーブルは定数である必要はなく、それが依存する前のテーブルの新しい行が最上位のクエリーによって処理されるたびに最新になります。
      </p><p>
        問題を解決するための第 2 のアプローチ: <code class="literal">SELECT</code> リストのサブクエリーが複数のカラムを返す可能性がある場合は、別の解決策を使用できます:
      </p><pre class="programlisting">SELECT
  salesperson.name,
  -- find maximum size and customer at same time
  (SELECT amount, customer_name
    FROM all_sales
    WHERE all_sales.salesperson_id = salesperson.id
    ORDER BY amount DESC LIMIT 1)
FROM
  salesperson;
</pre><p>
        これは効率的ですが、不正です。 このようなサブクエリーは単一のカラムのみを返すことができるため、機能しません: 
      </p><pre class="programlisting">ERROR 1241 (21000): Operand should contain 1 column(s)
</pre><p>
        クエリーをリライトするには、導出テーブルから複数のカラムを選択します:
      </p><pre class="programlisting">SELECT
  salesperson.name,
  max_sale.amount,
  max_sale.customer_name
FROM
  salesperson,
  -- find maximum size and customer at same time
  (SELECT amount, customer_name
    FROM all_sales
    WHERE all_sales.salesperson_id = salesperson.id
    ORDER BY amount DESC LIMIT 1)
  AS max_sale;
</pre><p>
        ただし、これも機能しません。 導出テーブルは <code class="literal">salesperson</code> テーブルに依存しているため、<code class="literal">LATERAL</code> なしで失敗します: 
      </p><pre class="programlisting">ERROR 1054 (42S22): Unknown column 'salesperson.id' in 'where clause'
</pre><p>
        <code class="literal">LATERAL</code> キーワードを追加すると、クエリーは有効になります:
      </p><pre class="programlisting">SELECT
  salesperson.name,
  max_sale.amount,
  max_sale.customer_name
FROM
  salesperson,
  -- find maximum size and customer at same time
  LATERAL
  (SELECT amount, customer_name
    FROM all_sales
    WHERE all_sales.salesperson_id = salesperson.id
    ORDER BY amount DESC LIMIT 1)
  AS max_sale;
</pre><p>
        つまり、<code class="literal">LATERAL</code> は、前述の 2 つのアプローチにおけるすべての欠点に対する効率的なソリューションです。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="subquery-errors"></a>13.2.11.10 サブクエリーのエラー</h4></div></div></div><a class="indexterm" name="idm45826997631776"></a><a class="indexterm" name="idm45826997629664"></a><p>
        サブクエリーにのみ適用されるエラーがいくつか存在します。 このセクションでは、これらについて説明します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            サポートされていないサブクエリー構文:
          </p><pre class="programlisting">ERROR 1235 (ER_NOT_SUPPORTED_YET)
SQLSTATE = 42000
Message = "This version of MySQL doesn't yet support
'LIMIT &amp; IN/ALL/ANY/SOME subquery'"
</pre><p>
            つまり、MySQL は次のようなステートメントをサポートしていません:
          </p><pre class="programlisting">SELECT * FROM t1 WHERE s1 IN (SELECT s2 FROM t2 ORDER BY s1 LIMIT 1)
</pre></li><li class="listitem"><p>
            サブクエリーからの正しくないカラム数:
          </p><pre class="programlisting">ERROR 1241 (ER_OPERAND_COL)
SQLSTATE = 21000
Message = "Operand should contain 1 column(s)"
</pre><p>
            このエラーは、次のような場合に発生します。
          </p><pre class="programlisting">SELECT (SELECT column1, column2 FROM t2) FROM t1;
</pre><p>
            目的が行の比較である場合は、複数のカラムを返すサブクエリーを使用できます。 ほかのコンテキストでは、サブクエリーはスカラーオペランドである必要があります。 <a class="xref" href="sql-statements.html#row-subqueries" title="13.2.11.5 行サブクエリー">セクション13.2.11.5「行サブクエリー」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            サブクエリーからの正しくない行数:
          </p><pre class="programlisting">ERROR 1242 (ER_SUBSELECT_NO_1_ROW)
SQLSTATE = 21000
Message = "Subquery returns more than 1 row"
</pre><p>
            このエラーは、サブクエリーが最大で 1 行しか返す必要がないにもかかわらず、複数の行を返すステートメントで発生します。 次の例を考えてみます。 
          </p><pre class="programlisting">SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);
</pre><p>
            <code class="literal">SELECT column1 FROM t2</code> が単一行のみを返す場合、前のクエリーは機能します。 サブクエリーが複数の行を返す場合、エラー 1242 が発生します。 その場合は、このクエリーを次のように書き換えてください。 
          </p><pre class="programlisting">SELECT * FROM t1 WHERE column1 = ANY (SELECT column1 FROM t2);
</pre></li><li class="listitem"><p>
            サブクエリー内の誤って使用されているテーブル:
          </p><pre class="programlisting">Error 1093 (ER_UPDATE_TABLE_USED)
SQLSTATE = HY000
Message = "You can't specify target table 'x'
for update in FROM clause"
</pre><p>
            このエラーは、テーブルを変更し、さらにサブクエリーで同じテーブルから選択しようとする次のような場合に発生します。
          </p><pre class="programlisting">UPDATE t1 SET column2 = (SELECT MAX(column1) FROM t1);
</pre><p>
            これを回避するには、共通テーブル式または導出テーブルを使用できます。 <a class="xref" href="sql-statements.html#subquery-restrictions" title="13.2.11.12 サブクエリーの制約">セクション13.2.11.12「サブクエリーの制約」</a>を参照してください。 
          </p></li></ul></div><p>
        MySQL 8.0.19 以降では、このセクションで説明するすべてのエラーは、サブクエリーで <code class="literal">TABLE</code> を使用する場合にも適用されます。
      </p><p>
        トランザクションストレージエンジンの場合は、サブクエリーが失敗するとステートメント全体が失敗します。 非トランザクションストレージエンジンの場合は、エラーが検出される前に行われたデータ変更が保持されます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="optimizing-subqueries"></a>13.2.11.11 サブクエリーの最適化</h4></div></div></div><p>
        開発が進行中であるため、長期にわたって信頼できる最適化のヒントはありません。 次のリストに、再生に役立つ興味深いトリックをいくつか示します。 <a class="xref" href="optimization.html#subquery-optimization" title="8.2.2 サブクエリー、導出テーブル、ビュー参照および共通テーブル式の最適化">セクション8.2.2「サブクエリー、導出テーブル、ビュー参照および共通テーブル式の最適化」</a>も参照してください。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            句をサブクエリーの外部から内部に移動します。 たとえば、次のクエリーを使用してください: 
          </p><pre class="programlisting">SELECT * FROM t1
  WHERE s1 IN (SELECT s1 FROM t1 UNION ALL SELECT s1 FROM t2);
</pre><p>
            次のクエリーの代替として:
          </p><pre class="programlisting">SELECT * FROM t1
  WHERE s1 IN (SELECT s1 FROM t1) OR s1 IN (SELECT s1 FROM t2);
</pre><p>
            別の例として、このクエリーを使用してください:
          </p><pre class="programlisting">SELECT (SELECT column1 + 5 FROM t1) FROM t2;
</pre><p>
            次のクエリーの代替として:
          </p><pre class="programlisting">SELECT (SELECT column1 FROM t1) + 5 FROM t2;
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="subquery-restrictions"></a>13.2.11.12 サブクエリーの制約</h4></div></div></div><a class="indexterm" name="idm45826997592416"></a><a class="indexterm" name="idm45826997590304"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            一般に、テーブルを変更することも、サブクエリーの同じテーブルから選択することもできません。 たとえば、この制限は次の形式のステートメントに適用されます。 
          </p><pre class="programlisting">DELETE FROM t WHERE ... (SELECT ... FROM t ...);
UPDATE t ... WHERE col = (SELECT ... FROM t ...);
{INSERT|REPLACE} INTO t (SELECT ... FROM t ...);
</pre><p>
            例外: 前述の禁止は、導出テーブルを使用している変更されたテーブルで、その導出テーブルが外部クエリーにマージされるのではなく実体化されている場合には適用されません。 (<a class="xref" href="optimization.html#derived-table-optimization" title="8.2.2.4 マージまたは実体化を使用した導出テーブル、ビュー参照および共通テーブル式の最適化">セクション8.2.2.4「マージまたは実体化を使用した導出テーブル、ビュー参照および共通テーブル式の最適化」</a>を参照してください。) 例: 
          </p><pre class="programlisting">UPDATE t ... WHERE col = (SELECT * FROM (SELECT ... FROM t...) AS dt ...);
</pre><p>
            導出テーブルからの結果は一時テーブルとして実体化されるため、<code class="literal">t</code> への更新が行われるまでに、<code class="literal">t</code> 内の関連する行がすでに選択されています。
          </p><p>
            一般に、<code class="literal">NO_MERGE</code> オプティマイザヒントを追加することで、導出テーブルを実体化するオプティマイザに影響を与えることができます。 <a class="xref" href="optimization.html#optimizer-hints" title="8.9.3 オプティマイザヒント">セクション8.9.3「オプティマイザヒント」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            行比較演算は一部のみサポートされています。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal"><em class="replaceable"><code>expr</code></em> [NOT] IN <em class="replaceable"><code>subquery</code></em></code> の場合、<em class="replaceable"><code>expr</code></em> は <em class="replaceable"><code>n</code></em> タプル (行コンストラクタ構文を使用して指定します) にでき、サブクエリーは <em class="replaceable"><code>n</code></em> タプルの行を返すことができます。 したがって、許可されている構文は、具体的には <code class="literal"><em class="replaceable"><code>row_constructor</code></em> [NOT] IN <em class="replaceable"><code>table_subquery</code></em></code> と表されます 
              </p></li><li class="listitem"><p>
                <code class="literal"><em class="replaceable"><code>expr</code></em> <em class="replaceable"><code>op</code></em> {ALL|ANY|SOME} <em class="replaceable"><code>subquery</code></em></code> の場合、<em class="replaceable"><code>expr</code></em> はスカラー値にする必要があり、サブクエリーはカラムサブクエリーにする必要があります。複合カラム行を返すことはできません。
              </p></li></ul></div><p>
            つまり、<em class="replaceable"><code>n</code></em> タプルの行を返すサブクエリーの場合、次のものはサポートされています。
          </p><pre class="programlisting">(<em class="replaceable"><code>expr_1</code></em>, ..., <em class="replaceable"><code>expr_n</code></em>) [NOT] IN <em class="replaceable"><code>table_subquery</code></em>
</pre><p>
            ただし、次のものはサポートされていません。
          </p><pre class="programlisting">(<em class="replaceable"><code>expr_1</code></em>, ..., <em class="replaceable"><code>expr_n</code></em>) <em class="replaceable"><code>op</code></em> {ALL|ANY|SOME} <em class="replaceable"><code>subquery</code></em>
</pre><p>
            <code class="literal">IN</code> の行比較がサポートされているのに、他はサポートされていない理由は、<code class="literal">IN</code> が、<code class="literal">=</code> 比較および <code class="literal">AND</code> 演算のシーケンスに、これを書き換えることによって実装されているためです。 この方法は、<code class="literal">ALL</code> 、<code class="literal">ANY</code>、<code class="literal">SOME</code> には使用できません。 
          </p></li><li class="listitem"><p>
            MySQL 8.0.14 より前は、<code class="literal">FROM</code> 句のサブクエリーを相関サブクエリーにすることはできません。 これらは、クエリー実行中にすべて実体化 (結果セットを生成するように評価) されるので、外部クエリーの行ごとに評価できません。 オプティマイザは、結果が必要になるまで実体化を遅延します。これにより、実体化を回避できます。 <a class="xref" href="optimization.html#derived-table-optimization" title="8.2.2.4 マージまたは実体化を使用した導出テーブル、ビュー参照および共通テーブル式の最適化">セクション8.2.2.4「マージまたは実体化を使用した導出テーブル、ビュー参照および共通テーブル式の最適化」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            MySQL は特定のサブクエリー演算子にサブクエリーの <code class="literal">LIMIT</code> をサポートしていません。
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM t1</code></strong>
       <strong class="userinput"><code>WHERE s1 IN (SELECT s2 FROM t2 ORDER BY s1 LIMIT 1);</code></strong>
ERROR 1235 (42000): This version of MySQL doesn't yet support
 'LIMIT &amp; IN/ALL/ANY/SOME subquery'
</pre><p>
            <a class="xref" href="sql-statements.html#subquery-errors" title="13.2.11.10 サブクエリーのエラー">セクション13.2.11.10「サブクエリーのエラー」</a>を参照してください。
          </p></li><li class="listitem"><p>
            MySQL では、サブクエリーで行をテーブルに挿入するなどのデータ変更の副作用があるストアドファンクションを参照できます。 たとえば、<code class="literal">f()</code> が行を挿入する場合、次のクエリーはデータを変更できます。 
          </p><pre class="programlisting">SELECT ... WHERE x IN (SELECT f() ...);
</pre><p>
            この動作は、SQL 標準に対する拡張です。 MySQL では、オプティマイザによる処理の選択方法に応じて、特定のクエリーの実行ごとに <code class="literal">f()</code> が異なる回数実行される可能性があるため、非決定的な結果が生成される可能性があります。 
          </p><p>
            ステートメントベースレプリケーションまたは混合形式レプリケーションの場合、このような不確定の影響の 1 つは、このようなクエリーがソースとそのスレーブで異なる結果を生成できることです。
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="table"></a>13.2.12 TABLE ステートメント</h3></div></div></div><a class="indexterm" name="idm45826997540112"></a><a class="indexterm" name="idm45826997539056"></a><a class="indexterm" name="idm45826997536928"></a><p>
      <code class="literal">TABLE</code> は、MySQL 8.0.19 で導入された DML ステートメントで、指定されたテーブルの行とカラムを返します。
    </p><pre class="programlisting">TABLE <em class="replaceable"><code>table_name</code></em> [ORDER BY <em class="replaceable"><code>column_name</code></em>] [LIMIT <em class="replaceable"><code>number</code></em> [OFFSET <em class="replaceable"><code>number</code></em>]]
</pre><p>
      <code class="literal">TABLE</code> ステートメントは、いくつかの方法で <code class="literal">SELECT</code> のように動作します。 <code class="literal">t</code> という名前のテーブルが存在する場合、次の 2 つのステートメントによって同一の出力が生成されます: 
    </p><pre class="programlisting">TABLE t;

SELECT * FROM t;
</pre><p>
      <code class="literal">ORDER BY</code> 句および <code class="literal">LIMIT</code> 句をそれぞれ使用して、<code class="literal">TABLE</code> によって生成される行数を順序付けおよび制限できます。 これらの関数は、次に示すように、<code class="literal">SELECT</code> で使用する場合と同じ句 (<code class="literal">LIMIT</code> でのオプションの <code class="literal">OFFSET</code> 句を含む) と同じように機能します: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>TABLE t;</code></strong>
+----+----+
| a  | b  |
+----+----+
|  1 |  2 |
|  6 |  7 |
|  9 |  5 |
| 10 | -4 |
| 11 | -1 |
| 13 |  3 |
| 14 |  6 |
+----+----+
7 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>TABLE t ORDER BY b;</code></strong>
+----+----+
| a  | b  |
+----+----+
| 10 | -4 |
| 11 | -1 |
|  1 |  2 |
| 13 |  3 |
|  9 |  5 |
| 14 |  6 |
|  6 |  7 |
+----+----+
7 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>TABLE t LIMIT 3;</code></strong>
+---+---+
| a | b |
+---+---+
| 1 | 2 |
| 6 | 7 |
| 9 | 5 |
+---+---+
3 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>TABLE t ORDER BY b LIMIT 3;</code></strong>
+----+----+
| a  | b  |
+----+----+
| 10 | -4 |
| 11 | -1 |
|  1 |  2 |
+----+----+
3 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>TABLE t ORDER BY b LIMIT 3 OFFSET 2;</code></strong>
+----+----+
| a  | b  |
+----+----+
|  1 |  2 |
| 13 |  3 |
|  9 |  5 |
+----+----+
3 rows in set (0.00 sec)
</pre><p>
      <code class="literal">TABLE</code> は、主に次の点で <code class="literal">SELECT</code> と異なります:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">TABLE</code> では、常にテーブルのすべてのカラムが表示されます。
        </p></li><li class="listitem"><p>
          <code class="literal">TABLE</code> では、行の任意のフィルタリングは許可されません。つまり、<code class="literal">TABLE</code> では <code class="literal">WHERE</code> 句はサポートされません。
        </p></li></ul></div><p>
      返されるテーブルのカラムを制限するには、<code class="literal">ORDER BY</code> および <code class="literal">LIMIT</code>(あるいはその両方) を使用して達成できる以上の行をフィルタリングし、<code class="literal">SELECT</code> を使用します。
    </p><p>
      <code class="literal">TABLE</code> は、一時テーブルとともに使用できます。
    </p><p>
      <code class="literal">TABLE</code> は、<code class="literal">SELECT</code> のかわりに、ここにリストされているものを含め、他の多くの構成要素で使用することもできます:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          次に示すように、<code class="literal">UNION</code> を使用します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>TABLE t1;</code></strong>
+---+----+
| a | b  |
+---+----+
| 2 | 10 |
| 5 |  3 |
| 7 |  8 |
+---+----+
3 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>TABLE t2;</code></strong>
+---+---+
| a | b |
+---+---+
| 1 | 2 |
| 3 | 4 |
| 6 | 7 |
+---+---+
3 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>TABLE t1 UNION TABLE t2;</code></strong>
+---+----+
| a | b  |
+---+----+
| 2 | 10 |
| 5 |  3 |
| 7 |  8 |
| 1 |  2 |
| 3 |  4 |
| 6 |  7 |
+---+----+
6 rows in set (0.00 sec)
</pre><p>
          ここで示した <code class="literal">UNION</code> は、次のステートメントと同等です:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM t1 UNION SELECT * FROM t2;</code></strong>
+---+----+
| a | b  |
+---+----+
| 2 | 10 |
| 5 |  3 |
| 7 |  8 |
| 1 |  2 |
| 3 |  4 |
| 6 |  7 |
+---+----+
6 rows in set (0.00 sec)
</pre><p>
          <code class="literal">TABLE</code> は、<code class="literal">SELECT</code> ステートメントまたは <code class="literal">VALUES</code> ステートメント (あるいはその両方) と組み合せて使用することもできます。 <a class="xref" href="sql-statements.html#union" title="13.2.10.3 UNION 句">セクション13.2.10.3「UNION 句」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">INTO</code> を使用してユーザー変数を移入し、<code class="literal">INTO OUTFILE</code> または <code class="literal">INTO DUMPFILE</code> を使用してテーブルデータをファイルに書き込みます。 詳細および例は、<a class="xref" href="sql-statements.html#select-into" title="13.2.10.1 SELECT ... INTO ステートメント">セクション13.2.10.1「SELECT ... INTO ステートメント」</a> を参照してください。 
        </p></li><li class="listitem"><p>
          多くの場合、サブクエリーを使用できます。 <code class="literal">a</code> という名前のカラムを持つ任意のテーブル <code class="literal">t1</code> と、単一のカラムを持つ別のテーブル <code class="literal">t2</code> がある場合、次のようなステートメントが可能です: 
        </p><pre class="programlisting">SELECT * FROM t1 WHERE a IN (TABLE t2);
</pre><p>
          テーブル <code class="literal">ts</code> の単一カラムの名前が <code class="literal">x</code> であると仮定すると、前述のステートメントは次に示す各ステートメントと同等です (いずれの場合もまったく同じ結果が生成されます):
        </p><pre class="programlisting">SELECT * FROM t1 WHERE a IN (SELECT x FROM t2);

SELECT * FROM t1 WHERE a IN (SELECT * FROM t2);
</pre><p>
          詳しくは<a class="xref" href="sql-statements.html#subqueries" title="13.2.11 サブクエリー">セクション13.2.11「サブクエリー」</a>,をご覧ください。
        </p></li><li class="listitem"><p>
          <code class="literal">INSERT</code> および <code class="literal">REPLACE</code> ステートメントを使用します。それ以外の場合は、<code class="literal">SELECT *</code> を使用します。 詳細および例については、<a class="xref" href="sql-statements.html#insert-select" title="13.2.6.1 INSERT ... SELECT ステートメント">セクション13.2.6.1「INSERT ... SELECT ステートメント」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">TABLE</code> は、多くの場合、<code class="literal">CREATE TABLE ... SELECT</code> または <code class="literal">CREATE VIEW ... SELECT</code> の <code class="literal">SELECT</code> のかわりに使用することもできます。 詳細および例については、これらのステートメントの説明を参照してください。 
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="update"></a>13.2.13 UPDATE ステートメント</h3></div></div></div><a class="indexterm" name="idm45826997458384"></a><a class="indexterm" name="idm45826997457072"></a><p>
      <code class="literal">UPDATE</code> は、テーブルの行を変更する DML ステートメントです。
    </p><p>
      <code class="literal">UPDATE</code> ステートメントは、<code class="literal">WITH</code> 句で始まり、<code class="literal">UPDATE</code> 内でアクセス可能な共通テーブル式を定義できます。 <a class="xref" href="sql-statements.html#with" title="13.2.15 WITH (共通テーブル式)">セクション13.2.15「WITH (共通テーブル式)」</a>を参照してください。 
    </p><p>
      単一テーブル構文:
    </p><pre class="programlisting">UPDATE [LOW_PRIORITY] [IGNORE] <em class="replaceable"><code>table_reference</code></em>
    SET <em class="replaceable"><code>assignment_list</code></em>
    [WHERE <em class="replaceable"><code>where_condition</code></em>]
    [ORDER BY ...]
    [LIMIT <em class="replaceable"><code>row_count</code></em>]

<em class="replaceable"><code>value</code></em>:
    {<em class="replaceable"><code>expr</code></em> | DEFAULT}

<em class="replaceable"><code>assignment</code></em>:
    <em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>value</code></em>

<em class="replaceable"><code>assignment_list</code></em>:
    <em class="replaceable"><code>assignment</code></em> [, <em class="replaceable"><code>assignment</code></em>] ...
</pre><p>
      複数テーブル構文:
    </p><pre class="programlisting">UPDATE [LOW_PRIORITY] [IGNORE] <em class="replaceable"><code>table_references</code></em>
    SET <em class="replaceable"><code>assignment_list</code></em>
    [WHERE <em class="replaceable"><code>where_condition</code></em>]
</pre><p>
      単一テーブル構文の場合、<code class="literal">UPDATE</code> ステートメントは、指定されたテーブル内の既存の行のカラムを新しい値に更新します。 <code class="literal">SET</code> 句は、変更するカラムと、それらのカラムに指定される値を示します。 各値は式か、またはカラムを明示的にそのデフォルト値に設定するキーワード <code class="literal">DEFAULT</code> として指定できます。 <code class="literal">WHERE</code> 句 (指定されている場合) は、どの行を更新するかを識別する条件を指定します。 <code class="literal">WHERE</code> 句がない場合は、すべての行が更新されます。 <code class="literal">ORDER BY</code> 句が指定されている場合は、指定されている順序で行が更新されます。 <code class="literal">LIMIT</code> 句は、更新できる行数に制限を設定します。 
    </p><p>
      複数テーブル構文の場合、<code class="literal">UPDATE</code> は、条件を満たす <em class="replaceable"><code>table_references</code></em> で指定されている各テーブル内の行を更新します。 一致した各行は、条件に複数回一致した場合でも、1 回更新されます。 複数テーブル構文の場合は、<code class="literal">ORDER BY</code> および <code class="literal">LIMIT</code> を使用できません。 
    </p><p>
      パーティション化されたテーブルの場合は、このステートメントの単一テーブルと複数テーブルの両方の形式で、テーブル参照の一部としての <code class="literal">PARTITION</code> オプションの使用がサポートされます。 このオプションは、1 つ以上のパーティションまたはサブパーティション (またはその両方) のリストを受け取ります。 リストされているパーティション (またはサブパーティション) だけが一致をチェックされ、これらのパーティションまたはサブパーティションのいずれにも存在しない行は、<em class="replaceable"><code>where_condition</code></em> を満たすかどうかにかかわらず更新されません。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">INSERT</code> または <code class="literal">REPLACE</code> ステートメントで <code class="literal">PARTITION</code> を使用している場合とは異なり、それ以外は有効な <code class="literal">UPDATE ... PARTITION</code> ステートメントは、リストされているパーティション (またはサブパーティション) 内のどの行も <em class="replaceable"><code>where_condition</code></em> に一致しない場合でも成功したと見なされます。
      </p></div><p>
      詳細および例については、<a class="xref" href="partitioning.html#partitioning-selection" title="24.5 パーティション選択">セクション24.5「パーティション選択」</a>を参照してください。
    </p><p>
      <em class="replaceable"><code>where_condition</code></em> は、更新される各行に対して true に評価される式です。 式の構文については、<a class="xref" href="language-structure.html#expressions" title="9.5 式">セクション9.5「式」</a>を参照してください。 
    </p><p>
      <em class="replaceable"><code>table_references</code></em> と <em class="replaceable"><code>where_condition</code></em> は、<a class="xref" href="sql-statements.html#select" title="13.2.10 SELECT ステートメント">セクション13.2.10「SELECT ステートメント」</a>で説明されているように指定されます。
    </p><p>
      実際に更新された、<code class="literal">UPDATE</code> 内で参照されているカラムに対してのみ <code class="literal">UPDATE</code> 権限が必要です。 読み取られるが、変更されないカラムに対しては、<code class="literal">SELECT</code> 権限のみが必要です。 
    </p><p>
      <code class="literal">UPDATE</code> ステートメントは、次の修飾子をサポートします。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">LOW_PRIORITY</code> 修飾子を使用すると、ほかのクライアントがテーブルから読み取ることがなくなるまで、<code class="literal">UPDATE</code> の実行が遅延されます。 これは、テーブルレベルロックのみを使用するストレージエンジン (<code class="literal">MyISAM</code>、<code class="literal">MEMORY</code>、および <code class="literal">MERGE</code>) にのみ影響を与えます。 
        </p><a class="indexterm" name="idm45826997402496"></a></li><li class="listitem"><p>
          <code class="literal">IGNORE</code> 修飾子を使用すると、更新中にエラーが発生しても更新ステートメントは中断されません。 一意のキー値に関して重複キーの競合が発生した行は更新されません。 データ変換エラーの原因になる値に更新された行は、代わりに、もっとも近い有効な値に更新されます。 詳細は、<a class="xref" href="server-administration.html#ignore-effect-on-execution" title="IGNORE がステートメントの実行に与える影響">IGNORE がステートメントの実行に与える影響</a>を参照してください。 
        </p><a class="indexterm" name="idm45826997397824"></a></li></ul></div><p>
      <code class="literal">ORDER BY</code> 句を持つステートメントを含む <code class="literal">UPDATE IGNORE</code> ステートメントには、ステートメントベースのレプリケーションに対して安全でないというフラグが付けられます。 (これは、どの行が無視されるかが、行が更新される順序によって決定されるためです。) このようなステートメントは、ステートメントベースのモードの使用時にエラーログに警告を生成し、<code class="literal">MIXED</code> モードの使用時に行ベースの形式を使用してバイナリログに書き込まれます。 (Bug #11758262、Bug #50439) 詳細は、<a class="xref" href="replication.html#replication-rbr-safe-unsafe" title="17.2.1.3 バイナリロギングでの安全および安全でないステートメントの判断">セクション17.2.1.3「バイナリロギングでの安全および安全でないステートメントの判断」</a>を参照してください。 
    </p><p>
      式で更新されるテーブルのカラムにアクセスする場合、<code class="literal">UPDATE</code> はそのカラムの現在の値を使用します。 たとえば、次のステートメントは、<code class="literal">col1</code> をその現在の値より 1 大きい値に設定します。 
    </p><pre class="programlisting">UPDATE t1 SET col1 = col1 + 1;
</pre><p>
      次のステートメントの 2 番目の割り当ては、<code class="literal">col2</code> を元の <code class="literal">col1</code> 値ではなく、現在の (更新された) <code class="literal">col1</code> 値に設定します。 この結果、<code class="literal">col1</code> と <code class="literal">col2</code> の値が同じになります。 この動作は標準 SQL とは異なります。 
    </p><pre class="programlisting">UPDATE t1 SET col1 = col1 + 1, col2 = col1;
</pre><p>
      単一テーブルの <code class="literal">UPDATE</code> の割り当ては一般に、左から右に評価されます。 複数テーブルの更新では、割り当てが特定の順序で実行される保証はありません。 
    </p><p>
      カラムをその現在の値に設定した場合は、MySQL がこれに気付き、その更新を行いません。
    </p><p>
      <code class="literal">NOT NULL</code> として宣言されているカラムを <code class="literal">NULL</code> に設定することによって更新すると、厳密な SQL モードが有効になっている場合は、エラーが発生します。そうでない場合、カラムはそのカラムデータ型の暗黙のデフォルト値に設定され、警告数が 1 増やされます。 暗黙のデフォルト値は、数値型では <code class="literal">0</code>、文字列型では空の文字列 (<code class="literal">''</code>)、および日付と時間型では<span class="quote">「<span class="quote">0</span>」</span>の値です。 <a class="xref" href="data-types.html#data-type-defaults" title="11.6 データ型デフォルト値">セクション11.6「データ型デフォルト値」</a>を参照してください。 
    </p><a class="indexterm" name="idm45826997373840"></a><p>
      生成されたカラムが明示的に更新される場合、許可される値は <code class="literal">DEFAULT</code> のみです。 生成されるカラムの詳細は、<a class="xref" href="sql-statements.html#create-table-generated-columns" title="13.1.20.8 CREATE TABLE および生成されるカラム">セクション13.1.20.8「CREATE TABLE および生成されるカラム」</a> を参照してください。 
    </p><a class="indexterm" name="idm45826997369840"></a><p>
      <code class="literal">UPDATE</code> は、実際に変更された行数を返します。 <code class="literal">mysql_info()</code> C API 関数は、一致して更新された行数と、<code class="literal">UPDATE</code> 中に発生した警告の数を返します。 
    </p><p>
      <code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em></code> を使用すると、<code class="literal">UPDATE</code> のスコープを制限できます。 <code class="literal">LIMIT</code> 句は、一致した行の制限です。 このステートメントは、実際に変更されたかどうかにかかわらず、<code class="literal">WHERE</code> 句を満たす <em class="replaceable"><code>row_count</code></em> 行を見つけるとすぐに停止します。 
    </p><p>
      <code class="literal">UPDATE</code> ステートメントに <code class="literal">ORDER BY</code> 句が含まれている場合は、この句で指定されている順序で行が更新されます。 これは、通常であればエラーが発生する可能性のある特定の状況で役立つ場合があります。 テーブル <code class="literal">t</code> に、一意のインデックスを持つカラム <code class="literal">id</code> が含まれているとします。 次のステートメントは、行が更新される順序によっては、重複キーエラーで失敗する可能性があります。 
    </p><pre class="programlisting">UPDATE t SET id = id + 1;
</pre><p>
      たとえば、このテーブルの <code class="literal">id</code> カラムに 1 と 2 が含まれており、2 が 3 に更新される前に 1 が 2 に更新された場合は、エラーが発生します。 この問題を回避するには、大きな <code class="literal">id</code> 値を持つ行が小さな値を持つ行の前に更新されるように、<code class="literal">ORDER BY</code> 句を追加します。 
    </p><pre class="programlisting">UPDATE t SET id = id + 1 ORDER BY id DESC;
</pre><p>
      また、複数のテーブルを範囲に含む <code class="literal">UPDATE</code> 操作を実行することもできます。 ただし、複数テーブルの <code class="literal">UPDATE</code> では <code class="literal">ORDER BY</code> または <code class="literal">LIMIT</code> を使用できません。 <em class="replaceable"><code>table_references</code></em> 句は、結合に含まれるテーブルをリストします。 その構文については、<a class="xref" href="sql-statements.html#join" title="13.2.10.2 JOIN 句">セクション13.2.10.2「JOIN 句」</a>で説明されています。 次に例を示します。 
    </p><pre class="programlisting">UPDATE items,month SET items.price=month.price
WHERE items.id=month.id;
</pre><p>
      前の例は、カンマ演算子を使用する内部結合を示していますが、複数テーブルの <code class="literal">UPDATE</code> ステートメントは、<code class="literal">SELECT</code> ステートメント内で許可されている任意の型の結合 (<code class="literal">LEFT JOIN</code> など) を使用できます。
    </p><p>
      外部キー制約が存在する <code class="literal">InnoDB</code> テーブルを含む、複数テーブルの <code class="literal">UPDATE</code> ステートメントを使用した場合は、MySQL オプティマイザが、それらの親子関係の順序とは異なる順序でテーブルを処理する可能性があります。 この場合、このステートメントは失敗し、ロールバックされます。 代わりに、1 つのテーブルを更新したあと、<code class="literal">InnoDB</code> が提供する <code class="literal">ON UPDATE</code> 機能を使用して、ほかのテーブルがそれに応じて変更されるようにします。 <a class="xref" href="sql-statements.html#create-table-foreign-keys" title="13.1.20.5 FOREIGN KEY の制約">セクション13.1.20.5「FOREIGN KEY の制約」</a>を参照してください。 
    </p><p>
      テーブルを更新してサブクエリーの同じテーブルから直接選択することはできません。 これを回避するには、複数テーブルの更新を使用します。この更新では、いずれかのテーブルが実際に更新するテーブルから導出され、エイリアスを使用して導出テーブルを参照します。 次に示すステートメントを使用して定義された <code class="literal">items</code> という名前のテーブルを更新するとします: 
    </p><pre class="programlisting">CREATE TABLE items (
    id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    wholesale DECIMAL(6,2) NOT NULL DEFAULT 0.00,
    retail DECIMAL(6,2) NOT NULL DEFAULT 0.00,
    quantity BIGINT NOT NULL DEFAULT 0
);
</pre><p>
      値入れが 30% 以上で在庫が 100 未満のアイテムの小売価格を下げるには、<code class="literal">WHERE</code> 句でサブクエリーを使用する次のような <code class="literal">UPDATE</code> ステートメントを使用します。 次に示すように、このステートメントは機能しません: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE items</code></strong>
     &gt; <strong class="userinput"><code>SET retail = retail * 0.9</code></strong>
     &gt; <strong class="userinput"><code>WHERE id IN</code></strong>
     &gt;     <strong class="userinput"><code>(SELECT id FROM items</code></strong>
     &gt;         <strong class="userinput"><code>WHERE retail / wholesale &gt;= 1.3 AND quantity &gt; 100);</code></strong>
<span class="errortext">ERROR 1093 (HY000): You can't specify target table 'items' for update in FROM clause</span>
</pre><p>
      かわりに、次のように、最も外側の <code class="literal">WHERE</code> 句でエイリアスを使用して参照し、サブクエリーを更新対象のテーブルのリストに移動する複数テーブル更新を使用できます:
    </p><pre class="programlisting">UPDATE items,
       (SELECT id FROM items
        WHERE id IN
            (SELECT id FROM items
             WHERE retail / wholesale &gt;= 1.3 AND quantity &lt; 100))
        AS discounted
SET items.retail = items.retail * 0.9
WHERE items.id = discounted.id;
</pre><p>
      オプティマイザはデフォルトで導出テーブル <code class="literal">discounted</code> を最も外側のクエリーブロックにマージしようとするため、導出テーブルを強制的に実体化する場合にのみ機能します。 これを行うには、更新を実行する前に <code class="literal">optimizer_switch</code> システム変数の <code class="literal">derived_merge</code> フラグを <code class="literal">off</code> に設定するか、次のように <code class="literal">NO_MERGE</code> オプティマイザヒントを使用します: 
    </p><pre class="programlisting">UPDATE /*+ NO_MERGE(discounted) */ items,
       (SELECT id FROM items
        WHERE retail / wholesale &gt;= 1.3 AND quantity &lt; 100)
        AS discounted
    SET items.retail = items.retail * 0.9
    WHERE items.id = discounted.id;
</pre><p>
      このような場合にオプティマイザヒントを使用する利点は、オプティマイザヒントが使用されるクエリーブロック内でのみ適用されるため、<code class="literal">UPDATE</code> の実行後に <code class="literal">optimizer_switch</code> の値を再度変更する必要がないことです。
    </p><p>
      次のように、<code class="literal">IN</code> または <code class="literal">EXISTS</code> を使用しないようにサブクエリーをリライトすることもできます:
    </p><pre class="programlisting">UPDATE items,
       (SELECT id, retail / wholesale AS markup, quantity FROM items)
       AS discounted
    SET items.retail = items.retail * 0.9
    WHERE discounted.markup &gt;= 1.3
    AND discounted.quantity &lt; 100
    AND items.id = discounted.id;
</pre><p>
      この場合、サブクエリーはマージではなくデフォルトで実体化されるため、導出テーブルのマージを無効にする必要はありません。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="values"></a>13.2.14 VALUES ステートメント</h3></div></div></div><a class="indexterm" name="idm45826997307376"></a><a class="indexterm" name="idm45826997305888"></a><a class="indexterm" name="idm45826997303856"></a><p>
      <code class="literal">VALUES</code> は、MySQL 8.0.19 で導入された DML ステートメントで、1 つ以上の行のセットをテーブルとして返します。 つまり、スタンドアロン SQL ステートメントとしても機能するテーブル値コンストラクタです。 
    </p><pre class="programlisting">VALUES <em class="replaceable"><code>row_constructor_list</code></em> [ORDER BY <em class="replaceable"><code>column_designator</code></em>] [LIMIT BY <em class="replaceable"><code>number</code></em>]

<em class="replaceable"><code>row_constructor_list</code></em>:
    ROW(<em class="replaceable"><code>value_list</code></em>)[, ROW(<em class="replaceable"><code>value_list</code></em>)][, ...]

<em class="replaceable"><code>value_list</code></em>:
    <em class="replaceable"><code>value</code></em>[, <em class="replaceable"><code>value</code></em>][, ...]

<em class="replaceable"><code>column_designator</code></em>:
    column_<em class="replaceable"><code>index</code></em>
</pre><p>
      <code class="literal">VALUES</code> ステートメントは、<code class="literal">VALUES</code> キーワードと、カンマで区切られた 1 つ以上の行コンストラクタのリストで構成されます。 行コンストラクタは、カッコで囲まれた 1 つ以上のスカラー値の値リストを持つ <code class="literal">ROW()</code> 行コンストラクタ句で構成されます。 値には、任意の MySQL データ型のリテラルまたはスカラー値に解決される式を使用できます。 
    </p><p>
      <code class="literal">ROW()</code> は空にできません (ただし、指定された各スカラー値を <code class="literal">NULL</code> にすることはできます)。 同じ <code class="literal">VALUES</code> ステートメントの各 <code class="literal">ROW()</code> の値リストには、同じ数の値が含まれている必要があります。 
    </p><p>
      <code class="literal">DEFAULT</code> キーワードは <code class="literal">VALUES</code> でサポートされていないため、<code class="literal">INSERT</code> ステートメントで値を指定するために使用される場合を除き、構文エラーが発生します。
    </p><p>
      <code class="literal">VALUES</code> の出力はテーブルです:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>VALUES ROW(1,-2,3), ROW(5,7,9), ROW(4,6,8);</code></strong>
+----------+----------+----------+
| column_0 | column_1 | column_2 |
+----------+----------+----------+
|        1 |       -2 |        3 |
|        5 |        7 |        9 |
|        4 |        6 |        8 |
+----------+----------+----------+
3 rows in set (0.00 sec)
</pre><p>
      <code class="literal">VALUES</code> からのテーブル出力のカラムには暗黙的に名前が付けられたカラム <code class="literal">column_0</code>, <code class="literal">column_1</code>, <code class="literal">column_2</code> などがあり、常に <code class="literal">0</code> で始まります。 このファクトを使用すると、次に示すように、<code class="literal">SELECT</code> ステートメントと同じ方法で、オプションの <code class="literal">ORDER BY</code> 句を使用してカラムごとに行を並べ替えることができます: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>VALUES ROW(1,-2,3), ROW(5,7,9), ROW(4,6,8) ORDER BY column_1;</code></strong>
+----------+----------+----------+
| column_0 | column_1 | column_2 |
+----------+----------+----------+
|        1 |       -2 |        3 |
|        4 |        6 |        8 |
|        5 |        7 |        9 |
+----------+----------+----------+
3 rows in set (0.00 sec)
</pre><p>
      <code class="literal">VALUES</code> ステートメントでは、出力の行数を制限するための <code class="literal">LIMIT</code> 句もサポートされています。
    </p><p>
      <code class="literal">VALUES</code> ステートメントは、カラム値のデータ型に関して許可されます。次に示すように、同じカラム内で型を混在させることができます:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>VALUES ROW("q", 42, '2019-12-18'),</code></strong>
    -&gt;     <strong class="userinput"><code>ROW(23, "abc", 98.6),</code></strong>
    -&gt;     <strong class="userinput"><code>ROW(27.0002, "Mary Smith", '{"a": 10, "b": 25}');</code></strong>
+----------+------------+--------------------+
| column_0 | column_1   | column_2           |
+----------+------------+--------------------+
| q        | 42         | 2019-12-18         |
| 23       | abc        | 98.6               |
| 27.0002  | Mary Smith | {"a": 10, "b": 25} |
+----------+------------+--------------------+
3 rows in set (0.00 sec)
</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        <code class="literal">ROW()</code> の 1 つ以上のインスタンスを持つ <code class="literal">VALUES</code> は、テーブル値コンストラクタとして機能します。<code class="literal">INSERT</code> ステートメントまたは <code class="literal">REPLACE</code> ステートメントで値を指定するために使用できますが、この目的でも使用される <code class="literal">VALUES</code> キーワードと混同しないでください。 また、<code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> のカラム値を参照する <code class="literal">VALUES()</code> 関数と混同しないでください。 
      </p><p>
        <code class="literal">ROW()</code> は行値コンストラクタであることにも注意する必要があります (<a class="xref" href="sql-statements.html#row-subqueries" title="13.2.11.5 行サブクエリー">セクション13.2.11.5「行サブクエリー」</a> を参照してくださいが、<code class="literal">VALUES ROW()</code> はテーブル値コンストラクタであり、両者を同じ意味で使用することはできません)。
      </p></div><p>
      <code class="literal">VALUES</code> は、ここにリストされているものを含め、<code class="literal">SELECT</code> を使用できる多くの場合に使用できます:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          次に示すように、<code class="literal">UNION</code> を使用します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT 1,2 UNION SELECT 10,15;</code></strong>
+----+----+
| 1  | 2  |
+----+----+
|  1 |  2 |
| 10 | 15 |
+----+----+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>VALUES ROW(1,2) UNION VALUES ROW(10,15);</code></strong>
+----------+----------+
| column_0 | column_1 |
+----------+----------+
|        1 |        2 |
|       10 |       15 |
+----------+----------+
2 rows in set (0.00 sec)
</pre><p>
          この方法では、次のように、複数の行を持つ構築されたテーブルを結合することもできます:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>VALUES ROW(1,2), ROW(3,4), ROW(5,6)</code></strong>
     &gt;     <strong class="userinput"><code>UNION VALUES ROW(10,15),ROW(20,25);</code></strong>
+----------+----------+
| column_0 | column_1 |
+----------+----------+
|        1 |        2 |
|        3 |        4 |
|        5 |        6 |
|       10 |       15 |
|       20 |       25 |
+----------+----------+
5 rows in set (0.00 sec)
</pre><p>
          このような場合は、<code class="literal">UNION</code> を完全に省略して、次のような単一の <strong class="userinput"><code>VALUES</code></strong> ステートメントを使用することもできます (通常はこれをお薦めします):
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>VALUES ROW(1,2), ROW(3,4), ROW(5,6), ROW(10,15), ROW(20,25);</code></strong>
+----------+----------+
| column_0 | column_1 |
+----------+----------+
|        1 |        2 |
|        3 |        4 |
|        5 |        6 |
|       10 |       15 |
|       20 |       25 |
+----------+----------+
</pre><p>
          <code class="literal">VALUES</code> は、<code class="literal">SELECT</code> ステートメントまたは <code class="literal">TABLE</code> ステートメント (あるいはその両方) と組み合せて使用することもできます。
        </p><p>
          <code class="literal">UNION</code> の構成されたテーブルには、<code class="literal">SELECT</code> を使用している場合と同様に、同じ数のカラムが含まれている必要があります。 その他の例については、<a class="xref" href="sql-statements.html#union" title="13.2.10.3 UNION 句">セクション13.2.10.3「UNION 句」</a> を参照してください。 
        </p></li><li class="listitem"><p>
          結合内。 詳細および例については、<a class="xref" href="sql-statements.html#join" title="13.2.10.2 JOIN 句">セクション13.2.10.2「JOIN 句」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">INSERT</code> ステートメントまたは <code class="literal">REPLACE</code> ステートメントでの <code class="literal">VALUES()</code> のかわりに、そのセマンティクスはここで説明するものと多少異なります。 詳細は、<a class="xref" href="sql-statements.html#insert" title="13.2.6 INSERT ステートメント">セクション13.2.6「INSERT ステートメント」</a>,を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">CREATE TABLE ... SELECT</code> および <code class="literal">CREATE VIEW ... SELECT</code> のソーステーブルのかわり。 詳細および例については、これらのステートメントの説明を参照してください。 
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="with"></a>13.2.15 WITH (共通テーブル式)</h3></div></div></div><a class="indexterm" name="idm45826997214864"></a><p>
      共通テーブル式 (CTE) は、単一ステートメントのスコープ内に存在し、あとでそのステートメント内で複数回参照できる名前付き一時結果セットです。 次の説明では、CTE を使用するステートメントを記述する方法について説明します。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#common-table-expressions" title="共通テーブル式">共通テーブル式</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#common-table-expressions-recursive" title="再帰的な共通テーブル式">再帰的な共通テーブル式</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#common-table-expressions-recursion-limits" title="共通テーブル式の再帰の制限">共通テーブル式の再帰の制限</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#common-table-expressions-recursive-examples" title="再帰的な共通テーブル式の例">再帰的な共通テーブル式の例</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#common-table-expressions-similar-constructs" title="類似の構成と比較した共通テーブル式">類似の構成と比較した共通テーブル式</a></p></li></ul></div><p>
      CTE 最適化の詳細は、<a class="xref" href="optimization.html#derived-table-optimization" title="8.2.2.4 マージまたは実体化を使用した導出テーブル、ビュー参照および共通テーブル式の最適化">セクション8.2.2.4「マージまたは実体化を使用した導出テーブル、ビュー参照および共通テーブル式の最適化」</a> を参照してください。
    </p><h4><a name="idm45826997205856"></a>追加のリソース</h4><p>
      次の記事には、多くの例を含む、MySQL での CTE の使用に関する追加情報が含まれています:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="ulink" href="http://mysqlserverteam.com/mysql-8-0-labs-recursive-common-table-expressions-in-mysql-ctes/" target="_top">MySQL 8.0 ラボ: [再帰的] MySQL (CTE) の共通テーブル式</a>
        </p></li><li class="listitem"><p>
          <a class="ulink" href="http://mysqlserverteam.com/mysql-8-0-labs-recursive-common-table-expressions-in-mysql-ctes-part-two-how-to-generate-series/" target="_top">MySQL 8.0 ラボ: [再帰的] MySQL (CTE) の共通テーブル式、パート 2 - シリーズの生成方法</a>
        </p></li><li class="listitem"><p>
          <a class="ulink" href="http://mysqlserverteam.com/mysql-8-0-labs-recursive-common-table-expressions-in-mysql-ctes-part-three-hierarchies/" target="_top">MySQL 8.0 ラボ: [再帰的] MySQL (CTE) の共通テーブル式 (第 3 部) - 階層</a>
        </p></li><li class="listitem"><p>
          <a class="ulink" href="http://mysqlserverteam.com/mysql-8-0-1-recursive-common-table-expressions-in-mysql-ctes-part-four-depth-first-or-breadth-first-traversal-transitive-closure-cycle-avoidance/" target="_top">MySQL 8.0.1 : [再帰的] MySQL (CTE) の共通テーブル式、パート 4 - 深さ優先または幅優先トラバース、推移閉鎖、サイクル回避</a>
        </p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="common-table-expressions"></a>共通テーブル式</h4></div></div></div><p>
        共通テーブル式を指定するには、カンマ区切りの副次句を持つ <code class="literal">WITH</code> 句を使用します。 各副次句は、結果セットを生成し、名前をサブクエリーに関連付けるサブクエリーを提供します。 次の例では、<code class="literal">WITH</code> 句で <code class="literal">cte1</code> および <code class="literal">cte2</code> という CTE を定義し、<code class="literal">WITH</code> 句に続く最上位 <code class="literal">SELECT</code> で CTE を参照します: 
      </p><pre class="programlisting">WITH
  cte1 AS (SELECT a, b FROM table1),
  cte2 AS (SELECT c, d FROM table2)
SELECT b, d FROM cte1 JOIN cte2
WHERE cte1.a = cte2.c;
</pre><p>
        <code class="literal">WITH</code> 句を含むステートメントでは、各 CTE 名を参照して、対応する CTE 結果セットにアクセスできます。
      </p><p>
        CTE 名は他の CTE で参照できるため、CTE を他の CTE に基づいて定義できます。
      </p><p>
        CTE は、それ自体を参照して再帰 CTE を定義できます。 再帰 CTE の一般的なアプリケーションには、階層データまたはツリー構造化データのシリーズ生成およびトラバースが含まれます。 
      </p><p>
        共通テーブル式は、DML ステートメントの構文のオプション部分です。 これらは、<code class="literal">WITH</code> 句を使用して定義されます: 
      </p><pre class="programlisting"><em class="replaceable"><code>with_clause</code></em>:
    WITH [RECURSIVE]
        <em class="replaceable"><code>cte_name</code></em> [(<em class="replaceable"><code>col_name</code></em> [, <em class="replaceable"><code>col_name</code></em>] ...)] AS (<em class="replaceable"><code>subquery</code></em>)
        [, <em class="replaceable"><code>cte_name</code></em> [(<em class="replaceable"><code>col_name</code></em> [, <em class="replaceable"><code>col_name</code></em>] ...)] AS (<em class="replaceable"><code>subquery</code></em>)] ...
</pre><p>
        <em class="replaceable"><code>cte_name</code></em> は、単一の共通テーブル式に名前を付け、<code class="literal">WITH</code> 句を含むステートメントでテーブル参照として使用できます。
      </p><p>
        <code class="literal">AS (<em class="replaceable"><code>subquery</code></em>)</code> の <em class="replaceable"><code>subquery</code></em> 部分は<span class="quote">「<span class="quote">「CTE のサブクエリー」</span>」</span>と呼ばれ、CTE 結果セットを生成します。 <code class="literal">AS</code> の後にカッコが必要です。 
      </p><p>
        サブクエリーが独自の名前を参照する場合、共通テーブル式は再帰的です。 <code class="literal">WITH</code> 句の CTE が再帰的な場合は、<code class="literal">RECURSIVE</code> キーワードを含める必要があります。 詳細は、<a class="xref" href="sql-statements.html#common-table-expressions-recursive" title="再帰的な共通テーブル式">再帰的な共通テーブル式</a>を参照してください。 
      </p><p>
        特定の CTE のカラム名の決定は、次のように行われます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            CTE 名の後にカッコで囲まれた名前のリストがある場合、それらの名前はカラム名になります:
          </p><pre class="programlisting">WITH cte (col1, col2) AS
(
  SELECT 1, 2
  UNION ALL
  SELECT 3, 4
)
SELECT col1, col2 FROM cte;
</pre><p>
            リスト内の名前の数は、結果セット内のカラムの数と同じである必要があります。
          </p></li><li class="listitem"><p>
            それ以外の場合、カラム名は <code class="literal">AS (<em class="replaceable"><code>subquery</code></em>)</code> 部分内の最初の <code class="literal">SELECT</code> の選択リストから取得されます:
          </p><pre class="programlisting">WITH cte AS
(
  SELECT 1 AS col1, 2 AS col2
  UNION ALL
  SELECT 3, 4
)
SELECT col1, col2 FROM cte;
</pre></li></ul></div><p>
        <code class="literal">WITH</code> 句は、次のコンテキストで使用できます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">SELECT</code>、<code class="literal">UPDATE</code> および <code class="literal">DELETE</code> ステートメントの先頭。
          </p><pre class="programlisting">WITH ... SELECT ...
WITH ... UPDATE ...
WITH ... DELETE ...
</pre></li><li class="listitem"><p>
            サブクエリーの開始時 (導出テーブルサブクエリーを含む):
          </p><pre class="programlisting">SELECT ... WHERE id IN (WITH ... SELECT ...) ...
SELECT * FROM (WITH ... SELECT ...) AS dt ...
</pre></li><li class="listitem"><p>
            <code class="literal">SELECT</code> ステートメントを含むステートメントについては、<code class="literal">SELECT</code> の直前を参照してください:
          </p><pre class="programlisting">INSERT ... WITH ... SELECT ...
REPLACE ... WITH ... SELECT ...
CREATE TABLE ... WITH ... SELECT ...
CREATE VIEW ... WITH ... SELECT ...
DECLARE CURSOR ... WITH ... SELECT ...
EXPLAIN ... WITH ... SELECT ...
</pre></li></ul></div><p>
        同じレベルで許可される <code class="literal">WITH</code> 句は 1 つのみです。 <code class="literal">WITH</code> の後に同じレベルの <code class="literal">WITH</code> が続くことは許可されていないため、これは不正です: 
      </p><pre class="programlisting">WITH cte1 AS (...) WITH cte2 AS (...) SELECT ...
</pre><p>
        ステートメントを有効にするには、副次句をカンマで区切る単一の <code class="literal">WITH</code> 句を使用します:
      </p><pre class="programlisting">WITH cte1 AS (...), cte2 AS (...) SELECT ...
</pre><p>
        ただし、異なるレベルで発生する場合は、ステートメントに複数の <code class="literal">WITH</code> 句を含めることができます:
      </p><pre class="programlisting">WITH cte1 AS (SELECT 1)
SELECT * FROM (WITH cte2 AS (SELECT 2) SELECT * FROM cte2 JOIN cte1) AS dt;
</pre><p>
        <code class="literal">WITH</code> 句では、複数の共通テーブル式を定義できますが、各 CTE 名は句に対して一意である必要があります。 これは不正です: 
      </p><pre class="programlisting">WITH cte1 AS (...), cte1 AS (...) SELECT ...
</pre><p>
        ステートメントを有効にするには、CTE を一意の名前で定義します:
      </p><pre class="programlisting">WITH cte1 AS (...), cte2 AS (...) SELECT ...
</pre><p>
        CTE は、自身または他の CTE を参照できます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            自己参照 CTE は再帰的です。
          </p></li><li class="listitem"><p>
            CTE は、同じ <code class="literal">WITH</code> 句で以前に定義された CTE を参照できますが、後で定義された CTE は参照できません。
          </p><p>
            この制約は、<code class="literal">cte1</code> が <code class="literal">cte2</code> を参照し、<code class="literal">cte2</code> が <code class="literal">cte1</code> を参照する相互再帰 CTE を除外します。 これらの参照のいずれかは、後で定義する CTE への参照である必要がありますが、これは許可されていません。 
          </p></li><li class="listitem"><p>
            特定のクエリーブロック内の CTE は、より外側のレベルのクエリーブロックで定義された CTE を参照できますが、より内側のレベルのクエリーブロックで定義された CTE は参照できません。
          </p></li></ul></div><p>
        同じ名前のオブジェクトへの参照を解決するには、導出テーブルで CTE を非表示にし、CTE で実テーブル、<code class="literal">TEMPORARY</code> テーブルおよびビューを非表示にします。 名前解決は、同じクエリーブロック内のオブジェクトを検索し、その名前のオブジェクトが見つからないときに外部ブロックに順に進むことで行われます。 
      </p><p>
        導出テーブルと同様に、CTE には MySQL 8.0.14 より前の外部参照を含めることはできません。 これは、SQL 標準の制限ではなく、MySQL 8.0.14 で削除された MySQL 制限です。 再帰 CTE に固有の構文上のその他の考慮事項については、<a class="xref" href="sql-statements.html#common-table-expressions-recursive" title="再帰的な共通テーブル式">再帰的な共通テーブル式</a> を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="common-table-expressions-recursive"></a>再帰的な共通テーブル式</h4></div></div></div><p>
        再帰的共通テーブル式は、独自の名前を参照するサブクエリーを持つ式です。 例: 
      </p><pre class="programlisting">WITH RECURSIVE cte (n) AS
(
  SELECT 1
  UNION ALL
  SELECT n + 1 FROM cte WHERE n &lt; 5
)
SELECT * FROM cte;
</pre><p>
        このステートメントを実行すると、単純な線形順序を含む単一のカラムである次の結果が生成されます:
      </p><pre class="programlisting">+------+
| n    |
+------+
|    1 |
|    2 |
|    3 |
|    4 |
|    5 |
+------+
</pre><p>
        再帰 CTE の構造は次のとおりです:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">WITH</code> 句内の CTE がそれ自体を参照する場合、<code class="literal">WITH</code> 句は <code class="literal">WITH RECURSIVE</code> で始まる必要があります。 (CTE がそれ自体を参照していない場合、<code class="literal">RECURSIVE</code> は許可されますが必須ではありません。) 
          </p><p>
            再帰 CTE の <code class="literal">RECURSIVE</code> を忘れた場合、次のエラーが発生する可能性があります:
          </p><pre class="programlisting">ERROR 1146 (42S02): Table '<em class="replaceable"><code>cte_name</code></em>' doesn't exist
</pre></li><li class="listitem"><p>
            再帰 CTE サブクエリーには、<code class="literal">UNION [ALL]</code>または <code class="literal">UNION DISTINCT</code> で区切られた次の 2 つの部分があります:
          </p><pre class="programlisting">SELECT ...      -- return initial row set
UNION ALL
SELECT ...      -- return additional row sets
</pre><p>
            最初の <code class="literal">SELECT</code> は CTE の最初の行を生成し、CTE 名を参照しません。 2 番目の <code class="literal">SELECT</code> では、<code class="literal">FROM</code> 句で CTE 名を参照することで追加の行が生成され、繰り返されます。 再帰は、この部分で新しい行が生成されない場合に終了します。 したがって、再帰 CTE は非再帰的 <code class="literal">SELECT</code> 部分とそれに続く再帰的 <code class="literal">SELECT</code> 部分で構成されます。 
          </p><p>
            各 <code class="literal">SELECT</code> 部分自体を複数の <code class="literal">SELECT</code> ステートメントの和集合にすることができます。
          </p></li><li class="listitem"><p>
            CTE 結果カラムの型は、非再帰的 <code class="literal">SELECT</code> 部分のカラム型からのみ推測され、カラムはすべて NULL 値可能です。 型の決定では、再帰的 <code class="literal">SELECT</code> 部分は無視されます。 
          </p></li><li class="listitem"><p>
            非再帰的部分と再帰的部分が <code class="literal">UNION DISTINCT</code> によって分離されている場合、重複する行は削除されます。 これは、無限ループを回避するために推移的な閉鎖を実行するクエリーに役立ちます。 
          </p></li><li class="listitem"><p>
            再帰部分の各反復は、前の反復によって生成された行に対してのみ動作します。 再帰部分に複数のクエリーブロックがある場合、各クエリーブロックの反復は未指定の順序でスケジュールされ、各クエリーブロックは、前の反復または前の反復終了以降に他のクエリーブロックによって生成された行に対して動作します。 
          </p></li></ul></div><p>
        前述の再帰 CTE サブクエリーには、最初の行セットを生成するために単一行を取得する次の非再帰部分があります:
      </p><pre class="programlisting">SELECT 1
</pre><p>
        CTE サブクエリーには、次の再帰的部分もあります:
      </p><pre class="programlisting">SELECT n + 1 FROM cte WHERE n &lt; 5
</pre><p>
        反復のたびに、その <code class="literal">SELECT</code> は、前の行セットの <code class="literal">n</code> の値より大きい新しい値を持つ行を生成します。 最初の反復は初期行セット (<code class="literal">1</code>) で動作し、<code class="literal">1+1=2</code> を生成します。2 番目の反復は最初の反復行セット (<code class="literal">2</code>) で動作し、<code class="literal">2+1=3</code> などを生成します。 これは、<code class="literal">n</code> が 5 未満になったときに発生する再帰が終了するまで続きます。 
      </p><p>
        CTE の再帰的部分で非再帰的部分よりもカラムの値が広い場合は、データの切捨てを回避するために、非再帰的部分のカラムを拡張する必要がある場合があります。 次のステートメントがあるとします。 
      </p><pre class="programlisting">WITH RECURSIVE cte AS
(
  SELECT 1 AS n, 'abc' AS str
  UNION ALL
  SELECT n + 1, CONCAT(str, str) FROM cte WHERE n &lt; 3
)
SELECT * FROM cte;
</pre><p>
        非厳密 SQL モードでは、このステートメントは次の出力を生成します:
      </p><pre class="programlisting">+------+------+
| n    | str  |
+------+------+
|    1 | abc  |
|    2 | abc  |
|    3 | abc  |
+------+------+
</pre><p>
        非再帰的 <code class="literal">SELECT</code> によってカラム幅が決定されるため、<code class="literal">str</code> のカラム値はすべて<code class="literal">'abc'</code>です。 したがって、再帰的 <code class="literal">SELECT</code> によって生成されるより広い <code class="literal">str</code> 値は切り捨てられます。 
      </p><p>
        厳密な SQL モードでは、このステートメントはエラーを生成します:
      </p><pre class="programlisting">ERROR 1406 (22001): Data too long for column 'str' at row 1
</pre><p>
        この問題に対処して、ステートメントで切捨てやエラーが発生しないようにするには、非再帰的 <code class="literal">SELECT</code> で <code class="literal">CAST()</code> を使用して <code class="literal">str</code> カラムの幅を広げます:
      </p><pre class="programlisting">WITH RECURSIVE cte AS
(
  SELECT 1 AS n, CAST('abc' AS CHAR(20)) AS str
  UNION ALL
  SELECT n + 1, CONCAT(str, str) FROM cte WHERE n &lt; 3
)
SELECT * FROM cte;
</pre><p>
        これで、ステートメントは切捨てなしで次の結果を生成します:
      </p><pre class="programlisting">+------+--------------+
| n    | str          |
+------+--------------+
|    1 | abc          |
|    2 | abcabc       |
|    3 | abcabcabcabc |
+------+--------------+
</pre><p>
        カラムには、位置ではなく名前でアクセスします。つまり、次の CTE に示すように、再帰部分のカラムは、別の位置を持つ非再帰部分のカラムにアクセスできます:
      </p><pre class="programlisting">WITH RECURSIVE cte AS
(
  SELECT 1 AS n, 1 AS p, -1 AS q
  UNION ALL
  SELECT n + 1, q * 2, p * 2 FROM cte WHERE n &lt; 5
)
SELECT * FROM cte;
</pre><p>
        一方の行の <code class="literal">p</code> は前の行の <code class="literal">q</code> から導出されるため、正の値と負の値は出力の後続の各行の位置を入れ替えます:
      </p><pre class="programlisting">+------+------+------+
| n    | p    | q    |
+------+------+------+
|    1 |    1 |   -1 |
|    2 |   -2 |    2 |
|    3 |    4 |   -4 |
|    4 |   -8 |    8 |
|    5 |   16 |  -16 |
+------+------+------+
</pre><p>
        再帰的 CTE サブクエリー内では、いくつかの構文制約が適用されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            再帰的 <code class="literal">SELECT</code> 部分には、次の構成を含めることはできません:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">SUM()</code> などの集計関数
              </p></li><li class="listitem"><p>
                ウィンドウ関数
              </p></li><li class="listitem"><p>
                <code class="literal">GROUP BY</code>
              </p></li><li class="listitem"><p>
                <code class="literal">ORDER BY</code>
              </p></li><li class="listitem"><p>
                <code class="literal">DISTINCT</code>
              </p></li></ul></div><p>
            MySQL 8.0.19 より前は、再帰 CTE の再帰的 <code class="literal">SELECT</code> 部分で <code class="literal">LIMIT</code> 句を使用することもできませんでした。 この制限は MySQL 8.0.19 で解除され、このような場合、オプションの <code class="literal">OFFSET</code> 句とともに <code class="literal">LIMIT</code> がサポートされるようになりました。 結果セットへの影響は、最も外側の <code class="literal">SELECT</code> で <code class="literal">LIMIT</code> を使用する場合と同じですが、再帰的 <code class="literal">SELECT</code> とともに使用すると、要求された数の行が生成されるとすぐに行の生成が停止するため、より効率的です。 
          </p><p>
            これらの制約は、再帰 CTE の非再帰的 <code class="literal">SELECT</code> 部分には適用されません。 <code class="literal">DISTINCT</code> での禁止は、<code class="literal">UNION</code> メンバーにのみ適用されます。<code class="literal">UNION DISTINCT</code> は許可されます。 
          </p></li><li class="listitem"><p>
            再帰的 <code class="literal">SELECT</code> 部分は CTE を参照する必要があるのは、サブクエリーではなく、その <code class="literal">FROM</code> 句でのみです。 CTE 以外のテーブルを参照して CTE と結合できます。 このような結合で CTE を使用する場合、CTE を <code class="literal">LEFT JOIN</code> の右側に配置しないでください。 
          </p></li></ul></div><p>
        これらの制約は、MySQL 固有除外である <code class="literal">ORDER BY</code>、<code class="literal">LIMIT</code> (MySQL 8.0.18 以前) および <code class="literal">DISTINCT</code> 以外は、SQL 標準から取得されます。
      </p><p>
        再帰 CTE の場合、再帰的 <code class="literal">SELECT</code> 部品の <code class="literal">EXPLAIN</code> 出力行の <code class="literal">Extra</code> カラムに <code class="literal">Recursive</code> が表示されます。
      </p><p>
        <code class="literal">EXPLAIN</code> によって表示される原価見積は反復当たりの原価を表しますが、これは合計原価と大きく異なる場合があります。 オプティマイザは、<code class="literal">WHERE</code> 句が false になる時点では予測できないため、反復数を予測できません。 
      </p><p>
        CTE の実際のコストは、結果セットのサイズの影響を受ける場合もあります。 多くの行を生成する CTE では、メモリー内からディスク上の形式に変換するために十分な大きさの内部一時テーブルが必要になる場合があり、パフォーマンスが低下する可能性があります。 その場合、許可されるインメモリー一時テーブルサイズを増やすと、パフォーマンスが向上する可能性があります。<a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4 MySQL での内部一時テーブルの使用">セクション8.4.4「MySQL での内部一時テーブルの使用」</a> を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="common-table-expressions-recursion-limits"></a>共通テーブル式の再帰の制限</h4></div></div></div><p>
        再帰的 CTE では、再帰的 <code class="literal">SELECT</code> 部分に再帰を終了する条件が含まれていることが重要です。 ランナウェイ再帰 CTE から保護する開発手法として、実行時間に制限を設定することで強制的に終了できます: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">cte_max_recursion_depth</code> システム変数は、CTE の再帰レベル数に制限を強制します。 サーバーは、この変数の値よりも多くのレベルを繰り返す CTE の実行を終了します。 
          </p></li><li class="listitem"><p>
            <code class="literal">max_execution_time</code> システム変数は、現在のセッション内で実行される <code class="literal">SELECT</code> ステートメントの実行タイムアウトを強制します。
          </p></li><li class="listitem"><p>
            <code class="literal">MAX_EXECUTION_TIME</code> オプティマイザヒントは、表示されている <code class="literal">SELECT</code> ステートメントに対してクエリーごとの実行タイムアウトを強制します。
          </p></li></ul></div><p>
        再帰 CTE が誤って書き込まれ、再帰実行の終了条件がないとします:
      </p><pre class="programlisting">WITH RECURSIVE cte (n) AS
(
  SELECT 1
  UNION ALL
  SELECT n + 1 FROM cte
)
SELECT * FROM cte;
</pre><p>
        デフォルトでは、<code class="literal">cte_max_recursion_depth</code> の値は 1000 で、CTE は 1000 レベルを超えて繰り返されたときに終了します。 アプリケーションでは、セッション値を変更して要件に合せて調整できます: 
      </p><pre class="programlisting">SET SESSION cte_max_recursion_depth = 10;      -- permit only shallow recursion
SET SESSION cte_max_recursion_depth = 1000000; -- permit deeper recursion
</pre><p>
        グローバル <code class="literal">cte_max_recursion_depth</code> 値を設定して、後で開始するすべてのセッションに影響を与えることもできます。
      </p><p>
        実行が遅く再帰するクエリー、または <code class="literal">cte_max_recursion_depth</code> 値を非常に高く設定する理由があるコンテキストでは、深い再帰から保護する別の方法は、セッションタイムアウトを設定することです。 これを行うには、CTE ステートメントを実行する前に、次のようなステートメントを実行します: 
      </p><pre class="programlisting">SET max_execution_time = 1000; -- impose one second timeout
</pre><p>
        または、CTE ステートメント自体にオプティマイザヒントを含めます:
      </p><pre class="programlisting">WITH RECURSIVE cte (n) AS
(
  SELECT 1
  UNION ALL
  SELECT n + 1 FROM cte
)
SELECT /*+ SET_VAR(cte_max_recursion_depth = 1M) */ * FROM cte;

WITH RECURSIVE cte (n) AS
(
  SELECT 1
  UNION ALL
  SELECT n + 1 FROM cte
)
SELECT /*+ MAX_EXECUTION_TIME(1000) */ * FROM cte;
</pre><p>
        MySQL 8.0.19 以降では、再帰的クエリー内で <code class="literal">LIMIT</code> を使用して、最も外側の <code class="literal">SELECT</code> に返される行の最大数を設定することもできます。次に例を示します:
      </p><pre class="programlisting">WITH RECURSIVE cte (n) AS
(
  SELECT 1
  UNION ALL
  SELECT n + 1 FROM cte LIMIT 10000
)
SELECT * FROM cte;
</pre><p>
        これは、時間制限に加えて、または時間制限を設定するかわりに行うことができます。 したがって、次の CTE は、10 千行を返した後、または 1 千秒先に実行された後に終了します: 
      </p><pre class="programlisting">WITH RECURSIVE cte (n) AS
(
  SELECT 1
  UNION ALL
  SELECT n + 1 FROM cte LIMIT 10000
)
SELECT /*+ MAX_EXECUTION_TIME(1000) */ * FROM cte;
</pre><a class="indexterm" name="idm45826996994160"></a><a class="indexterm" name="idm45826996992032"></a><p>
        実行時間制限のない再帰的クエリーが無限ループに入った場合は、<code class="literal">KILL QUERY</code> を使用して別のセッションから再帰的クエリーを終了できます。 セッション自体では、クエリーの実行に使用されるクライアントプログラムによってクエリーを強制終了する方法が提供される場合があります。 たとえば、<span class="command"><strong>mysql</strong></span> では、<span class="keycap"><strong>Control+C</strong></span> と入力すると現在のステートメントが中断されます。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="common-table-expressions-recursive-examples"></a>再帰的な共通テーブル式の例</h4></div></div></div><p>
        前述のように、再帰的共通テーブル式 (CTE) は、系列の生成および階層データまたはツリー構造化データのトラバースに頻繁に使用されます。 このセクションでは、これらの手法の簡単な例をいくつか示します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#common-table-expressions-recursive-fibonacci-series" title="フィボナッチシリーズ世代">フィボナッチシリーズ世代</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#common-table-expressions-recursive-date-series" title="日付シリーズ生成">日付シリーズ生成</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#common-table-expressions-recursive-hierarchy-traversal" title="階層データトラバース">階層データトラバース</a></p></li></ul></div><h5><a name="common-table-expressions-recursive-fibonacci-series"></a>フィボナッチシリーズ世代</h5><p>
        Fibonacci シリーズは、2 つの数値 0 と 1 (または 1 と 1) で始まり、その後の各数値は前の 2 つの数値の合計です。 再帰的共通テーブル式では、再帰的 <code class="literal">SELECT</code> によって生成された各行がシリーズの前の 2 つの数値にアクセスできる場合、Fibonacci シリーズを生成できます。 次の CTE は、最初の 2 つの番号として 0 と 1 を使用して 10-number シリーズを生成します: 
      </p><pre class="programlisting">WITH RECURSIVE fibonacci (n, fib_n, next_fib_n) AS
(
  SELECT 1, 0, 1
  UNION ALL
  SELECT n + 1, next_fib_n, fib_n + next_fib_n
    FROM fibonacci WHERE n &lt; 10
)
SELECT * FROM fibonacci;
</pre><p>
        CTE は次の結果を生成します:
      </p><pre class="programlisting">+------+-------+------------+
| n    | fib_n | next_fib_n |
+------+-------+------------+
|    1 |     0 |          1 |
|    2 |     1 |          1 |
|    3 |     1 |          2 |
|    4 |     2 |          3 |
|    5 |     3 |          5 |
|    6 |     5 |          8 |
|    7 |     8 |         13 |
|    8 |    13 |         21 |
|    9 |    21 |         34 |
|   10 |    34 |         55 |
+------+-------+------------+
</pre><p>
        CTE の機能:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">n</code> は、行に <code class="literal">n</code> 番目の Fibonacci 番号が含まれていることを示す表示カラムです。 たとえば、8 番目の Fibonacci 番号は 13 です。 
          </p></li><li class="listitem"><p>
            <code class="literal">fib_n</code> カラムには、Fibonacci 番号 <code class="literal">n</code> が表示されます。
          </p></li><li class="listitem"><p>
            <code class="literal">next_fib_n</code> カラムには、数値 <code class="literal">n</code> の後の次の Fibonacci 番号が表示されます。 このカラムは次の行に次の系カラム値を提供するため、行の <code class="literal">fib_n</code> カラムに前の 2 つの系カラム値の合計を生成できます。 
          </p></li><li class="listitem"><p>
            再帰は、<code class="literal">n</code> が 10 に達すると終了します。 これは任意の選択肢で、出力を小さな行セットに制限します。 
          </p></li></ul></div><p>
        前述の出力は CTE の結果全体を示しています。 その一部のみを選択するには、トップレベルの <code class="literal">SELECT</code> に適切な <code class="literal">WHERE</code> 句を追加します。 たとえば、8 番目のフィボナッチ番号を選択するには、次のようにします: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>WITH RECURSIVE fibonacci ...</code></strong>
       ...
       <strong class="userinput"><code>SELECT fib_n FROM fibonacci WHERE n = 8;</code></strong>
+-------+
| fib_n |
+-------+
|    13 |
+-------+
</pre><h5><a name="common-table-expressions-recursive-date-series"></a>日付シリーズ生成</h5><p>
        共通テーブル式では、一連の連続した日付を生成できます。これは、サマリーデータにテーブルされていない日付を含む、シリーズ内のすべての日付の行を含むサマリーを生成する場合に役立ちます。
      </p><p>
        売上番号のテーブルに次の行が含まれているとします:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM sales ORDER BY date, price;</code></strong>
+------------+--------+
| date       | price  |
+------------+--------+
| 2017-01-03 | 100.00 |
| 2017-01-03 | 200.00 |
| 2017-01-06 |  50.00 |
| 2017-01-08 |  10.00 |
| 2017-01-08 |  20.00 |
| 2017-01-08 | 150.00 |
| 2017-01-10 |   5.00 |
+------------+--------+
</pre><p>
        このクエリーでは、日当たりの売上が集計されます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT date, SUM(price) AS sum_price</code></strong>
       <strong class="userinput"><code>FROM sales</code></strong>
       <strong class="userinput"><code>GROUP BY date</code></strong>
       <strong class="userinput"><code>ORDER BY date;</code></strong>
+------------+-----------+
| date       | sum_price |
+------------+-----------+
| 2017-01-03 |    300.00 |
| 2017-01-06 |     50.00 |
| 2017-01-08 |    180.00 |
| 2017-01-10 |      5.00 |
+------------+-----------+
</pre><p>
        ただし、その結果には、テーブルに含まれる日付の範囲でテーブルされない日付の<span class="quote">「<span class="quote">「穴」</span>」</span>が含まれます。 範囲内のすべての日付を表す結果を再帰 CTE を使用して生成し、その日付セットを生成して、<code class="literal">LEFT JOIN</code> と販売データを結合できます。 
      </p><p>
        日付範囲シリーズを生成する CTE は次のとおりです:
      </p><pre class="programlisting">WITH RECURSIVE dates (date) AS
(
  SELECT MIN(date) FROM sales
  UNION ALL
  SELECT date + INTERVAL 1 DAY FROM dates
  WHERE date + INTERVAL 1 DAY &lt;= (SELECT MAX(date) FROM sales)
)
SELECT * FROM dates;
</pre><p>
        CTE は次の結果を生成します:
      </p><pre class="programlisting">+------------+
| date       |
+------------+
| 2017-01-03 |
| 2017-01-04 |
| 2017-01-05 |
| 2017-01-06 |
| 2017-01-07 |
| 2017-01-08 |
| 2017-01-09 |
| 2017-01-10 |
+------------+
</pre><p>
        CTE の機能:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            非再帰的 <code class="literal">SELECT</code> では、<code class="literal">sales</code> テーブルにまたがる日付範囲内で最も低い日付が生成されます。
          </p></li><li class="listitem"><p>
            再帰的 <code class="literal">SELECT</code> によって生成された各行では、前の行によって生成された日付に 1 日が追加されます。
          </p></li><li class="listitem"><p>
            再帰は、日付が <code class="literal">sales</code> テーブルの範囲内の最も高い日付に達した後に終了します。
          </p></li></ul></div><p>
        CTE を <code class="literal">sales</code> テーブルに対して <code class="literal">LEFT JOIN</code> と結合すると、範囲内の各日付の行を含む売上サマリーが生成されます:
      </p><pre class="programlisting">WITH RECURSIVE dates (date) AS
(
  SELECT MIN(date) FROM sales
  UNION ALL
  SELECT date + INTERVAL 1 DAY FROM dates
  WHERE date + INTERVAL 1 DAY &lt;= (SELECT MAX(date) FROM sales)
)
SELECT dates.date, COALESCE(SUM(price), 0) AS sum_price
FROM dates LEFT JOIN sales ON dates.date = sales.date
GROUP BY dates.date
ORDER BY dates.date;
</pre><p>
        出力は次のようになります:
      </p><pre class="programlisting">+------------+-----------+
| date       | sum_price |
+------------+-----------+
| 2017-01-03 |    300.00 |
| 2017-01-04 |      0.00 |
| 2017-01-05 |      0.00 |
| 2017-01-06 |     50.00 |
| 2017-01-07 |      0.00 |
| 2017-01-08 |    180.00 |
| 2017-01-09 |      0.00 |
| 2017-01-10 |      5.00 |
+------------+-----------+
</pre><p>
        次の点に注意してください:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            クエリーは非効率的ですか。特に、再帰的 <code class="literal">SELECT</code> の各行に対して <code class="literal">MAX()</code> サブクエリーが実行されているクエリーですか。 <code class="literal">EXPLAIN</code> では、<code class="literal">MAX()</code> を含むサブクエリーが一度のみ評価され、結果がキャッシュされることが示されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">COALESCE()</code> を使用すると、<code class="literal">sales</code> テーブルに売上データが発生しない日に、<code class="literal">sum_price</code> カラムに <code class="literal">NULL</code> が表示されなくなります。
          </p></li></ul></div><h5><a name="common-table-expressions-recursive-hierarchy-traversal"></a>階層データトラバース</h5><p>
        再帰的な共通テーブル式は、階層を形成するデータを横断する場合に役立ちます。 会社の各従業員について、従業員名、ID 番号および従業員マネージャの ID を表示する小さなデータセットを作成する次のステートメントについて考えてみます。 最上位レベルの従業員 (CEO) のマネージャ ID は <code class="literal">NULL</code> (マネージャなし) です。 
      </p><pre class="programlisting">CREATE TABLE employees (
  id         INT PRIMARY KEY NOT NULL,
  name       VARCHAR(100) NOT NULL,
  manager_id INT NULL,
  INDEX (manager_id),
FOREIGN KEY (manager_id) REFERENCES employees (id)
);
INSERT INTO employees VALUES
(333, "Yasmina", NULL),  # Yasmina is the CEO (manager_id is NULL)
(198, "John", 333),      # John has ID 198 and reports to 333 (Yasmina)
(692, "Tarek", 333),
(29, "Pedro", 198),
(4610, "Sarah", 29),
(72, "Pierre", 29),
(123, "Adil", 692);
</pre><p>
        結果のデータセットは次のようになります:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM employees ORDER BY id;</code></strong>
+------+---------+------------+
| id   | name    | manager_id |
+------+---------+------------+
|   29 | Pedro   |        198 |
|   72 | Pierre  |         29 |
|  123 | Adil    |        692 |
|  198 | John    |        333 |
|  333 | Yasmina |       NULL |
|  692 | Tarek   |        333 |
| 4610 | Sarah   |         29 |
+------+---------+------------+
</pre><p>
        各従業員の管理チェーン (つまり、CEO から従業員へのパス) を含む組織図を作成するには、再帰 CTE を使用します:
      </p><pre class="programlisting">WITH RECURSIVE employee_paths (id, name, path) AS
(
  SELECT id, name, CAST(id AS CHAR(200))
    FROM employees
    WHERE manager_id IS NULL
  UNION ALL
  SELECT e.id, e.name, CONCAT(ep.path, ',', e.id)
    FROM employee_paths AS ep JOIN employees AS e
      ON ep.id = e.manager_id
)
SELECT * FROM employee_paths ORDER BY path;
</pre><p>
        CTE は次の出力を生成します:
      </p><pre class="programlisting">+------+---------+-----------------+
| id   | name    | path            |
+------+---------+-----------------+
|  333 | Yasmina | 333             |
|  198 | John    | 333,198         |
|   29 | Pedro   | 333,198,29      |
| 4610 | Sarah   | 333,198,29,4610 |
|   72 | Pierre  | 333,198,29,72   |
|  692 | Tarek   | 333,692         |
|  123 | Adil    | 333,692,123     |
+------+---------+-----------------+
</pre><p>
        CTE の機能:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            非再帰的 <code class="literal">SELECT</code> は、CEO (<code class="literal">NULL</code> マネージャ ID を持つ行) の行を生成します。
          </p><p>
            <code class="literal">path</code> カラムは、再帰的 <code class="literal">SELECT</code> によって生成されるより長い <code class="literal">path</code> 値のための領域が確保されるように、<code class="literal">CHAR(200)</code> に広がります。
          </p></li><li class="listitem"><p>
            再帰的 <code class="literal">SELECT</code> によって生成された各行では、前の行によって生成された従業員に直接レポートするすべての従業員が検索されます。 このような従業員ごとに、行には従業員 ID と従業員名、および従業員管理チェーンが含まれます。 チェーンは、従業員 ID が最後に追加されたマネージャチェーンです。 
          </p></li><li class="listitem"><p>
            再帰は、従業員に他の部下がいない場合に終了します。
          </p></li></ul></div><p>
        特定の従業員のパスを検索するには、最上位の <code class="literal">SELECT</code> に <code class="literal">WHERE</code> 句を追加します。 たとえば、Tarek および Sarah の結果を表示するには、次のように <code class="literal">SELECT</code> を変更します: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>WITH RECURSIVE ...</code></strong>
       ...
       <strong class="userinput"><code>SELECT * FROM employees_extended</code></strong>
       <strong class="userinput"><code>WHERE id IN (692, 4610)</code></strong>
       <strong class="userinput"><code>ORDER BY path;</code></strong>
+------+-------+-----------------+
| id   | name  | path            |
+------+-------+-----------------+
| 4610 | Sarah | 333,198,29,4610 |
|  692 | Tarek | 333,692         |
+------+-------+-----------------+
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="common-table-expressions-similar-constructs"></a>類似の構成と比較した共通テーブル式</h4></div></div></div><p>
        共通テーブル式 (CTE) は、いくつかの点で派生テーブルに似ています:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            両方の構成メンバーに名前が付けられます。
          </p></li><li class="listitem"><p>
            両方の構成は、単一のステートメントの有効範囲に存在します。
          </p></li></ul></div><p>
        これらの類似性のため、CTE と導出テーブルは同じ意味で使用できます。 簡単な例として、次のステートメントは同等です: 
      </p><pre class="programlisting">WITH cte AS (SELECT 1) SELECT * FROM cte;
SELECT * FROM (SELECT 1) AS dt;
</pre><p>
        ただし、CTE には導出テーブルと比較していくつかの利点があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            導出テーブルは、クエリー内で一度のみ参照できます。 CTE は複数回参照できます。 導出テーブルの結果の複数のインスタンスを使用するには、結果を複数回導出する必要があります。 
          </p></li><li class="listitem"><p>
            CTE は自己参照 (再帰的) にすることができます。
          </p></li><li class="listitem"><p>
            CTE は別の CTE を参照できます。
          </p></li><li class="listitem"><p>
            CTE 内に埋め込まれるのではなく、CTE の定義がステートメントの先頭に表示されると、CTE が読みやすくなる場合があります。
          </p></li></ul></div><p>
        CTE は、<code class="literal">CREATE [TEMPORARY] TABLE</code> で作成されるテーブルに似ていますが、明示的に定義または削除する必要はありません。 CTE の場合、テーブルを作成する権限は必要ありません。 
      </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sql-transactional-statements"></a>13.3 トランザクションステートメントおよびロックステートメント</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#commit">13.3.1 START TRANSACTION、COMMIT および ROLLBACK ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#cannot-roll-back">13.3.2 ロールバックできないステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#implicit-commit">13.3.3 暗黙的なコミットを発生させるステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#savepoint">13.3.4 SAVEPOINT、ROLLBACK TO SAVEPOINT および RELEASE SAVEPOINT ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#lock-instance-for-backup">13.3.5 LOCK INSTANCE FOR BACKUP および UNLOCK INSTANCE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#lock-tables">13.3.6 LOCK TABLES および UNLOCK TABLES ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#set-transaction">13.3.7 SET TRANSACTION ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#xa">13.3.8 XA トランザクション</a></span></dt></dl></div><p>
    MySQL は、<code class="literal">SET autocommit</code>、<code class="literal">START TRANSACTION</code>、<code class="literal">COMMIT</code>、<code class="literal">ROLLBACK</code> などのステートメントを介して (特定のクライアントセッション内の) ローカルトランザクションをサポートしています。 <a class="xref" href="sql-statements.html#commit" title="13.3.1 START TRANSACTION、COMMIT および ROLLBACK ステートメント">セクション13.3.1「START TRANSACTION、COMMIT および ROLLBACK ステートメント」</a>を参照してください。 XA トランザクションサポートにより、MySQL は分散トランザクションにも参加できます。 <a class="xref" href="sql-statements.html#xa" title="13.3.8 XA トランザクション">セクション13.3.8「XA トランザクション」</a>を参照してください。 
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="commit"></a>13.3.1 START TRANSACTION、COMMIT および ROLLBACK ステートメント</h3></div></div></div><a class="indexterm" name="idm45826996866336"></a><a class="indexterm" name="idm45826996865024"></a><a class="indexterm" name="idm45826996863680"></a><a class="indexterm" name="idm45826996862336"></a><pre class="programlisting">START TRANSACTION
    [<em class="replaceable"><code>transaction_characteristic</code></em> [, <em class="replaceable"><code>transaction_characteristic</code></em>] ...]

<em class="replaceable"><code>transaction_characteristic</code></em>: {
    WITH CONSISTENT SNAPSHOT
  | READ WRITE
  | READ ONLY
}

BEGIN [WORK]
COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE]
ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]
SET autocommit = {0 | 1}
</pre><p>
      次のステートメントにより、<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>の使用を制御できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">START TRANSACTION</code> または <code class="literal">BEGIN</code> は、新しいトランザクションを開始します。
        </p></li><li class="listitem"><p>
          <code class="literal">COMMIT</code> は、現在のトランザクションをコミットして、その変更を永続的なものにします。
        </p></li><li class="listitem"><p>
          <code class="literal">ROLLBACK</code> は、現在のトランザクションをロールバックして、その変更を取り消します。
        </p></li><li class="listitem"><p>
          <code class="literal">SET autocommit</code> は、現在のセッションのデフォルトの自動コミットモードを無効または有効にします。
        </p></li></ul></div><p>
      デフォルトでは、MySQL は<a class="link" href="glossary.html#glos_autocommit" title="自動コミット">自動コミット</a>モードが有効になった状態で動作します。 つまり、特にトランザクション内にない場合、各ステートメントは <code class="literal">START TRANSACTION</code> および <code class="literal">COMMIT</code> で囲まれているかのようにアトミックです。 <code class="literal">ROLLBACK</code> を使用して効果を元に戻すことはできませんが、ステートメントの実行中にエラーが発生した場合、ステートメントはロールバックされます。 
    </p><p>
      一連のステートメントに対して自動コミットモードを暗黙的に無効にするには、<code class="literal">START TRANSACTION</code> ステートメントを使用します。
    </p><pre class="programlisting">START TRANSACTION;
SELECT @A:=SUM(salary) FROM table1 WHERE type=1;
UPDATE table2 SET summary=@A WHERE type=1;
COMMIT;
</pre><p>
      <code class="literal">START TRANSACTION</code> を使用すると、そのトランザクションを <code class="literal">COMMIT</code> または <code class="literal">ROLLBACK</code> で終了するまで、自動コミットは無効のままになります。 そのあと、自動コミットモードはその以前の状態に戻ります。 
    </p><p>
      <code class="literal">START TRANSACTION</code> では、トランザクションの特性を制御するいくつかの修飾子が許可されます。 複数の修飾子を指定するには、それらをカンマで区切ります。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">WITH CONSISTENT SNAPSHOT</code> 修飾子は、この機能に対応しているストレージエンジンでの<a class="link" href="glossary.html#glos_consistent_read" title="一貫性読み取り">一貫性読み取り</a>を開始します。 これは、<code class="literal">InnoDB</code> にのみ適用されます。 その効果は、任意の <code class="literal">InnoDB</code> テーブルから <code class="literal">START TRANSACTION</code> に続けて <code class="literal">SELECT</code> を発行することと同じです。 <a class="xref" href="innodb-storage-engine.html#innodb-consistent-read" title="15.7.2.3 一貫性非ロック読み取り">セクション15.7.2.3「一貫性非ロック読み取り」</a>を参照してください。 <code class="literal">WITH CONSISTENT SNAPSHOT</code> 修飾子は、現在のトランザクション<a class="link" href="glossary.html#glos_isolation_level" title="分離レベル">分離レベル</a>を変更しないため、現在の分離レベルが一貫性読み取りを許可するものである場合にのみ、整合性のあるスナップショットを提供します。 一貫性読み取りを許可する分離レベルは、<code class="literal">REPEATABLE READ</code> だけです。 その他のすべての分離レベルの場合、<code class="literal">WITH CONSISTENT SNAPSHOT</code> 句は無視されます。 <code class="literal">WITH CONSISTENT SNAPSHOT</code> 句が無視されると、警告が生成されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">READ WRITE</code> および <code class="literal">READ ONLY</code> 修飾子は、トランザクションアクセスモードを設定します。 これらは、そのトランザクションで使用されるテーブルへの変更を許可または禁止します。 <code class="literal">READ ONLY</code> の制限は、そのトランザクションが、ほかのトランザクションに表示されるトランザクションテーブルと非トランザクションテーブルの両方を変更またはロックしないようにします。このトランザクションは引き続き、一時テーブルを変更またはロックできます。 
        </p><p>
          MySQL では、トランザクションが読み取り専用であることがわかっている場合、<code class="literal">InnoDB</code> テーブルに対するクエリーの追加の最適化が可能です。 <code class="literal">READ ONLY</code> を指定すると、読み取り専用ステータスを自動的に特定できない場合に、これらの最適化が適用されることが保証されます。 詳細は、<a class="xref" href="optimization.html#innodb-performance-ro-txn" title="8.5.3 InnoDB の読み取り専用トランザクションの最適化">セクション8.5.3「InnoDB の読み取り専用トランザクションの最適化」</a>を参照してください。 
        </p><p>
          アクセスモードが指定されていない場合は、デフォルトモードが適用されます。 デフォルトが変更されていないかぎり、それは読み取り/書き込みです。 同じステートメント内で <code class="literal">READ WRITE</code> と <code class="literal">READ ONLY</code> の両方を指定することは許可されません。 
        </p><p>
          読み取り専用モードでは、DML ステートメントを使用して <code class="literal">TEMPORARY</code> キーワードで作成されたテーブルは引き続き変更できます。 永続的なテーブルと同様に、DDL ステートメントによって行われる変更は許可されません。 
        </p><p>
          トランザクションアクセスモードの詳細 (デフォルトモードを変更する方法を含む) は、<a class="xref" href="sql-statements.html#set-transaction" title="13.3.7 SET TRANSACTION ステートメント">セクション13.3.7「SET TRANSACTION ステートメント」</a>を参照してください。
        </p><p>
          <code class="literal">read_only</code> システム変数が有効になっている場合、<code class="literal">START TRANSACTION READ WRITE</code> でトランザクションを明示的に開始するには、<code class="literal">CONNECTION_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。
        </p></li></ul></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        MySQL クライアントアプリケーションを記述するために使用される多くの API (JDBC など) は、クライアントから <code class="literal">START TRANSACTION</code> ステートメントを送信する代わりに使用できる (また、場合によっては使用すべき)、トランザクションを開始するための独自のメソッドを提供しています。 詳細は、<a class="xref" href="connectors-apis.html" title="第 29 章 Connector および API">第29章「<i>Connector および API</i>」</a>または API のドキュメントを参照してください。 
      </p></div><p>
      自動コミットモードを明示的に無効にするには、次のステートメントを使用します。
    </p><pre class="programlisting">SET autocommit=0;
</pre><p>
      <code class="literal">autocommit</code> 変数を 0 に設定することによって自動コミットモードを無効にしたあと、トランザクションセーフテーブル (<code class="literal">InnoDB</code> または <code class="literal">NDB</code> のテーブルなど) への変更がただちに永続的になることはありません。 <code class="literal">COMMIT</code> を使用して変更をディスクに格納するか、または <code class="literal">ROLLBACK</code> を使用して変更を無視する必要があります。 
    </p><p>
      <code class="literal">autocommit</code> はセッション変数であるため、セッションごとに設定する必要があります。 新しい接続ごとに自動コミットモードを無効にするには、<a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>にある <code class="literal">autocommit</code> システム変数の説明を参照してください。 
    </p><p>
      <code class="literal">BEGIN</code> と <code class="literal">BEGIN WORK</code> は、トランザクションを開始するための <code class="literal">START TRANSACTION</code> のエイリアスとしてサポートされています。 標準の SQL 構文である <code class="literal">START TRANSACTION</code> は、アドホックトランザクションを開始するための推奨される方法であり、<code class="literal">BEGIN</code> では許可されない修飾子が許可されます。 
    </p><p>
      <code class="literal">BEGIN</code> ステートメントは、<code class="literal">BEGIN ... END</code> 複合ステートメントを開始する <code class="literal">BEGIN</code> キーワードの使用とは異なります。 後者はトランザクションを開始しません。 <a class="xref" href="sql-statements.html#begin-end" title="13.6.1 BEGIN ... END 複合ステートメント">セクション13.6.1「BEGIN ... END 複合ステートメント」</a>を参照してください。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        すべてのストアドプログラム (ストアドプロシージャーとストアドファンクション、トリガー、およびイベント) 内で、パーサーは、<code class="literal">BEGIN [WORK]</code> を <code class="literal">BEGIN ... END</code> ブロックの開始として扱います。 このコンテキストでは、代わりに <code class="literal">START TRANSACTION</code> を使用してトランザクションを開始します。 
      </p></div><p>
      オプションの <code class="literal">WORK</code> キーワードは、<code class="literal">CHAIN</code> および <code class="literal">RELEASE</code> 句と同様に、<code class="literal">COMMIT</code> と <code class="literal">ROLLBACK</code> に対してサポートされています。 <code class="literal">CHAIN</code> と <code class="literal">RELEASE</code> は、トランザクションの完了に対する追加の制御に使用できます。 <code class="literal">completion_type</code> システム変数の値によって、デフォルトの完了動作が決定されます。 <a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>を参照してください。 
    </p><p>
      <code class="literal">AND CHAIN</code> 句を指定すると、現在のトランザクションが終了するとすぐに新しいトランザクションが開始され、新しいトランザクションの分離レベルは終了したばかりのトランザクションと同じになります。 新しいトランザクションでは、終了理由トランザクションと同じアクセスモード (<code class="literal">READ WRITE</code> または <code class="literal">READ ONLY</code>) も使用されます。 <code class="literal">RELEASE</code> 句を指定すると、サーバーは、現在のトランザクションを終了したあと現在のクライアントセッションを切り離します。 <code class="literal">NO</code> キーワードを含めると、<code class="literal">CHAIN</code> または <code class="literal">RELEASE</code> の完了が抑制されます。これは、<code class="literal">completion_type</code> システム変数がデフォルトで、チェーンまたはリリースの完了が実行されるように設定されている場合に役立つことがあります。 
    </p><p>
      トランザクションを開始すると、保留中のトランザクションはすべてコミットされます。 詳細は、<a class="xref" href="sql-statements.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。 
    </p><p>
      また、トランザクションを開始すると、ユーザーが <code class="literal">UNLOCK TABLES</code> を実行したかのように、<code class="literal">LOCK TABLES</code> によって取得されたテーブルロックも解放されます。 トランザクションを開始しても、<code class="literal">FLUSH TABLES WITH READ LOCK</code> によって取得されたグローバルな読み取りロックは解放されません。 
    </p><p>
      最適な結果を得るために、トランザクションは、1 つのトランザクションセーフストレージエンジンによって管理されているテーブルのみを使用して実行するようにしてください。 そうしないと、次の問題が発生する場合があります。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          複数のトランザクションセーフストレージエンジン (<code class="literal">InnoDB</code> など) のテーブルを使用し、トランザクション分離レベルが <code class="literal">SERIALIZABLE</code> でない場合、あるトランザクションがコミットされると、同じテーブルを使用する別の進行中のトランザクションには、最初のトランザクションによって行われた変更の一部のみが表示される可能性があります。 つまり、混在したエンジンではトランザクションのアトミック性が保証されないため、不整合が発生する場合があります。 (混在したエンジンでのトランザクションの頻度が低い場合は、<code class="literal">SET TRANSACTION ISOLATION LEVEL</code> を使用して、必要に応じてトランザクションごとに分離レベルを <code class="literal">SERIALIZABLE</code> に設定できます。)  
        </p></li><li class="listitem"><p>
          トランザクション内でトランザクションセーフでないテーブルを使用する場合は、自動コミットモードのステータスには関係なく、それらのテーブルへの変更が一度に格納されます。
        </p></li><li class="listitem"><p>
          トランザクション内で非トランザクションテーブルを更新したあとに <code class="literal">ROLLBACK</code> ステートメントを発行すると、<code class="literal">ER_WARNING_NOT_COMPLETE_ROLLBACK</code> 警告が発生します。 トランザクションセーフテーブルへの変更はロールバックされますが、非トランザクションセーフテーブルへの変更はロールバックされません。 
        </p></li></ul></div><p>
      各トランザクションは、<code class="literal">COMMIT</code> 時に、1 つのまとまりでバイナリログに格納されます。 ロールバックされたトランザクションはログに記録されません。 (<span class="bold"><strong>例外</strong></span>: 非トランザクションテーブルへの変更はロールバックできません。 ロールバックされるトランザクションに非トランザクションテーブルへの変更が含まれている場合は、非トランザクションテーブルへの変更が確実にレプリケートされるようにするために、最後に <code class="literal">ROLLBACK</code> ステートメントを使用してトランザクション全体がログに記録されます。)  <a class="xref" href="server-administration.html#binary-log" title="5.4.4 バイナリログ">セクション5.4.4「バイナリログ」</a>を参照してください。 
    </p><p>
      トランザクションの分離レベルまたはアクセスモードは、<code class="literal">SET TRANSACTION</code> ステートメントを使用して変更できます。 <a class="xref" href="sql-statements.html#set-transaction" title="13.3.7 SET TRANSACTION ステートメント">セクション13.3.7「SET TRANSACTION ステートメント」</a>を参照してください。 
    </p><p>
      ロールバックは、ユーザーが明示的に求めることなく (たとえば、エラーの発生時に) 暗黙的に発生する可能性のある低速な操作になる場合があります。 このため、<code class="literal">ROLLBACK</code> ステートメントを使用して実行された明示的なロールバックに対してだけでなく、暗黙のロールバックに対しても、<code class="literal">SHOW PROCESSLIST</code> はセッションの <code class="literal">State</code> カラムに <code class="literal">Rolling back</code> を表示します。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        MySQL 8.0 では、<code class="literal">BEGIN</code>、<code class="literal">COMMIT</code>、および <code class="literal">ROLLBACK</code> は <code class="option">--replicate-do-db</code> または <code class="option">--replicate-ignore-db</code> ルールによって影響を受けません。
      </p></div><p>
      <code class="literal">InnoDB</code> でトランザクションの完全なロールバックが実行されると、トランザクションで設定されたすべてのロックが解放されます。 重複キーエラーなどのエラーの結果としてトランザクション内の単一の SQL ステートメントがロールバックされた場合、そのステートメントによって設定されたロックは、トランザクションがアクティブなまま保持されます。 これが発生する原因は、<code class="literal">InnoDB</code> では、どの行がどのステートメントで設定されたのかをあとで確認できないような形式で、行ロックが格納されるためです。 
    </p><p>
      トランザクション内の <code class="literal">SELECT</code> ステートメントがストアドファンクションをコールし、ストアドファンクション内のステートメントが失敗した場合、そのステートメントはロールバックされます。 その後、<code class="literal">ROLLBACK</code> がトランザクションに対して実行されると、トランザクション全体がロールバックされます。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="cannot-roll-back"></a>13.3.2 ロールバックできないステートメント</h3></div></div></div><p>
      いくつかのステートメントはロールバックできません。 これには一般に、データベースを作成または削除したり、テーブルやストアドルーチンを作成、削除、または変更したりするデータ定義言語 (DDL) ステートメントが含まれます。 
    </p><p>
      このようなステートメントを含まないようにトランザクションを設計してください。 ロールバックできないステートメントをトランザクション内で早期に発行し、そのあと別のステートメントが失敗したとすると、このような場合に <code class="literal">ROLLBACK</code> ステートメントを発行してもそのトランザクションのすべての効果をロールバックすることはできません。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="implicit-commit"></a>13.3.3 暗黙的なコミットを発生させるステートメント</h3></div></div></div><p>
      このセクションに示されているステートメント (およびそのすべてのシノニム) は、ユーザーがこのステートメントを実行する前に <code class="literal">COMMIT</code> を実行したかのように、現在のセッション内でアクティブなすべてのトランザクションを暗黙的に終了します。
    </p><p>
      これらのステートメントのほとんどは、実行後に暗黙的なコミットを引き起こします。 その目的は、そのような各ステートメントを独自の特別なトランザクションで処理することです。 トランザクション制御ステートメントおよびロックステートメントは例外です: 実行前に暗黙的なコミットが発生した場合、後に別のコミットは発生しません。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <span class="bold"><strong>データベースオブジェクトを定義または変更するデータ定義言語 (DDL) ステートメント。</strong></span> <code class="literal">ALTER EVENT</code>, <code class="literal">ALTER FUNCTION</code>, <code class="literal">ALTER PROCEDURE</code>, <code class="literal">ALTER SERVER</code>, <code class="literal">ALTER TABLE</code>, <code class="literal">ALTER VIEW</code>, <code class="literal">CREATE DATABASE</code>, <code class="literal">CREATE EVENT</code>, <code class="literal">CREATE FUNCTION</code>, <code class="literal">CREATE INDEX</code>, <code class="literal">CREATE PROCEDURE</code>, <code class="literal">CREATE ROLE</code>, <code class="literal">CREATE SERVER</code>, <code class="literal">CREATE SPATIAL REFERENCE SYSTEM</code>, <code class="literal">CREATE TABLE</code>, <code class="literal">CREATE TRIGGER</code>, <code class="literal">CREATE VIEW</code>, <code class="literal">DROP DATABASE</code>, <code class="literal">DROP EVENT</code>, <code class="literal">DROP FUNCTION</code>, <code class="literal">DROP INDEX</code>, <code class="literal">DROP PROCEDURE</code>, <code class="literal">DROP ROLE</code>, <code class="literal">DROP SERVER</code>, <code class="literal">DROP SPATIAL REFERENCE SYSTEM</code>, <code class="literal">DROP TABLE</code>, <code class="literal">DROP TRIGGER</code>, <code class="literal">DROP VIEW</code>, <code class="literal">INSTALL PLUGIN</code>, <code class="literal">RENAME TABLE</code>, <code class="literal">TRUNCATE TABLE</code>, <code class="literal">UNINSTALL PLUGIN</code>。 
        </p><p>
          <code class="literal">CREATE TABLE</code> および <code class="literal">DROP TABLE</code> ステートメントは、<code class="literal">TEMPORARY</code> キーワードが使用されている場合はトランザクションをコミットしません。 (これは、コミットを発生させる <code class="literal">ALTER TABLE</code> や <code class="literal">CREATE INDEX</code> などの、一時テーブルに対するその他の操作には適用されません。)  ただし、暗黙的なコミットは発生しませんが、ステートメントのロールバックもできません。つまり、このようなステートメントを使用すると、トランザクションのアトミック性が侵害されます。 たとえば、<code class="literal">CREATE TEMPORARY TABLE</code> を使用したあとにトランザクションをロールバックしても、そのテーブルは存在し続けます。 
        </p><p>
          <code class="literal">InnoDB</code> での <code class="literal">CREATE TABLE</code> ステートメントは、1 つのトランザクションとして処理されます。 つまり、ユーザーが <code class="literal">ROLLBACK</code> を発行しても、ユーザーがそのトランザクション中に実行した <code class="literal">CREATE TABLE</code> ステートメントは元に戻されません。 
        </p><p>
          <code class="literal">CREATE TABLE ... SELECT</code> は、一時テーブル以外のテーブルを作成している場合、そのステートメントが実行される前後に暗黙的なコミットを発生させます。 (<code class="literal">CREATE TEMPORARY TABLE ... SELECT</code> に対してコミットは発生しません。) 
        </p></li><li class="listitem"><p>
          <span class="bold"><strong><code class="literal">mysql</code> データベース内のテーブルを暗黙的に使用または変更するステートメント。</strong></span> <code class="literal">ALTER USER</code>, <code class="literal">CREATE USER</code>, <code class="literal">DROP USER</code>, <code class="literal">GRANT</code>, <code class="literal">RENAME USER</code>, <code class="literal">REVOKE</code>, <code class="literal">SET PASSWORD</code>。 
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>トランザクション制御およびロックステートメント。</strong></span> <code class="literal">BEGIN</code>、<code class="literal">LOCK TABLES</code>、<code class="literal">SET autocommit = 1</code> (この値がまだ 1 でない場合)、<code class="literal">START TRANSACTION</code>、<code class="literal">UNLOCK TABLES</code>。 
        </p><p>
          <code class="literal">UNLOCK TABLES</code> は、非トランザクションテーブルロックを取得するために現在 <code class="literal">LOCK TABLES</code> でロックされているテーブルがある場合にのみ、トランザクションをコミットします。 <code class="literal">FLUSH TABLES WITH READ LOCK</code> はテーブルレベルのロックを取得しないため、このステートメントに続く <code class="literal">UNLOCK TABLES</code> に対してコミットは発生しません。 
        </p><p>
          トランザクションをネストすることはできません。 これは、<code class="literal">START TRANSACTION</code> ステートメントまたはそのシノニムのいずれかを発行するときに、現在のすべてのトランザクションに対して実行される暗黙的なコミットの結果です。 
        </p><p>
          XA トランザクションが <code class="literal">ACTIVE</code> 状態にある間に、暗黙的なコミットを発生させるステートメントをそのトランザクションで使用することはできません。
        </p><p>
          <code class="literal">BEGIN</code> ステートメントは、<code class="literal">BEGIN ... END</code> 複合ステートメントを開始する <code class="literal">BEGIN</code> キーワードの使用とは異なります。 後者は暗黙的なコミットを発生させません。 <a class="xref" href="sql-statements.html#begin-end" title="13.6.1 BEGIN ... END 複合ステートメント">セクション13.6.1「BEGIN ... END 複合ステートメント」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>データロードステートメント。</strong></span> <code class="literal">LOAD DATA</code>。 <code class="literal">LOAD DATA</code> では、<code class="literal">NDB</code> ストレージエンジンを使用するテーブルに対してのみ暗黙的なコミットが発生します。 
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>管理ステートメント。</strong></span> <code class="literal">ANALYZE TABLE</code>, <code class="literal">CACHE INDEX</code>, <code class="literal">CHECK TABLE</code>, <code class="literal">FLUSH</code>, <code class="literal">LOAD INDEX INTO CACHE</code>, <code class="literal">OPTIMIZE TABLE</code>, <code class="literal">REPAIR TABLE</code>, <code class="literal">RESET</code> (ただし、<code class="literal">RESET PERSIST</code>)。 
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>レプリケーション制御ステートメント</strong></span>。 <code class="literal">START REPLICA | SLAVE</code>, <code class="literal">STOP REPLICA | SLAVE</code>, <code class="literal">RESET REPLICA | SLAVE</code>, <code class="literal">CHANGE REPLICATION SOURCE TO</code>, <code class="literal">CHANGE MASTER TO</code>。 
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="savepoint"></a>13.3.4 SAVEPOINT、ROLLBACK TO SAVEPOINT および RELEASE SAVEPOINT ステートメント</h3></div></div></div><a class="indexterm" name="idm45826996608368"></a><a class="indexterm" name="idm45826996607056"></a><a class="indexterm" name="idm45826996605712"></a><pre class="programlisting">SAVEPOINT <em class="replaceable"><code>identifier</code></em>
ROLLBACK [WORK] TO [SAVEPOINT] <em class="replaceable"><code>identifier</code></em>
RELEASE SAVEPOINT <em class="replaceable"><code>identifier</code></em>
</pre><p>
      <code class="literal">InnoDB</code> は、SQL ステートメント <code class="literal">SAVEPOINT</code>、<code class="literal">ROLLBACK TO SAVEPOINT</code>、<code class="literal">RELEASE SAVEPOINT</code> のほか、<code class="literal">ROLLBACK</code> のオプションの <code class="literal">WORK</code> キーワードをサポートしています。
    </p><p>
      <code class="literal">SAVEPOINT</code> ステートメントは、<em class="replaceable"><code>identifier</code></em> の名前を持つ名前付きのトランザクションセーブポイントを設定します。 現在のトランザクションに同じ名前を持つセーブポイントが含まれている場合、古いセーブポイントは削除され、新しいセーブポイントが設定されます。 
    </p><p>
      <code class="literal">ROLLBACK TO SAVEPOINT</code> ステートメントは、トランザクションを終了することなく、そのトランザクションを指定されたセーブポイントにロールバックします。 セーブポイントが設定されたあとに現在のトランザクションが行に対して行なった変更はロールバックで元に戻されますが、<code class="literal">InnoDB</code> は、セーブポイントのあとにメモリーに格納された行ロックを解放<span class="emphasis"><em>しません</em></span>。 (新しく挿入された行の場合、ロック情報は、その行に格納されているトランザクション ID によって伝達されます。ロックが個別にメモリーに格納されるわけではありません。 この場合、行ロックは Undo で解放されます。) 指定されたセーブポイントよりあとで設定されたセーブポイントは削除されます。 
    </p><p>
      <code class="literal">ROLLBACK TO SAVEPOINT</code> ステートメントが次のエラーを返した場合は、指定された名前を持つセーブポイントが存在しないことを示しています。
    </p><pre class="programlisting">ERROR 1305 (42000): SAVEPOINT <em class="replaceable"><code>identifier</code></em> does not exist
</pre><p>
      <code class="literal">RELEASE SAVEPOINT</code> ステートメントは、指定されたセーブポイントを現在のトランザクションの一連のセーブポイントから削除します。 コミットまたはロールバックは発生しません。 そのセーブポイントが存在しない場合はエラーになります。 
    </p><p>
      <code class="literal">COMMIT</code>、またはセーブポイントを指定しない <code class="literal">ROLLBACK</code> を実行した場合は、現在のトランザクションのすべてのセーブポイントが削除されます。
    </p><p>
      ストアドファンクションが呼び出されるか、またはトリガーがアクティブ化されると、新しいセーブポイントレベルが作成されます。 以前のレベルにあるセーブポイントは使用できなくなるため、新しいレベルのセーブポイントとは競合しません。 関数またはトリガーが終了すると、その関数またはトリガーによって作成されたセーブポイントはすべて解放され、以前のセーブポイントレベルがリストアされます。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="lock-instance-for-backup"></a>13.3.5 LOCK INSTANCE FOR BACKUP および UNLOCK INSTANCE ステートメント</h3></div></div></div><a class="indexterm" name="idm45826996571920"></a><a class="indexterm" name="idm45826996570624"></a><pre class="programlisting">LOCK INSTANCE FOR BACKUP

UNLOCK INSTANCE
</pre><p>
      <code class="literal">LOCK INSTANCE FOR BACKUP</code> は、オンラインバックアップ中に DML を許可するインスタンスレベルの<span class="emphasis"><em>バックアップロック</em></span>を取得し、一貫性のないスナップショットを生成する可能性のある操作を防止します。
    </p><p>
      <code class="literal">LOCK INSTANCE FOR BACKUP</code> ステートメントを実行するには、<code class="literal">BACKUP_ADMIN</code> 権限が必要です。 以前のバージョンから MySQL 8.0 へのインプレースアップグレードを実行すると、<code class="literal">RELOAD</code> 権限を持つユーザーに <code class="literal">BACKUP_ADMIN</code> 権限が自動的に付与されます。 
    </p><p>
      複数のセッションで同時にバックアップロックを保持できます。
    </p><p>
      <code class="literal">UNLOCK INSTANCE</code> は、現在のセッションで保持されているバックアップロックを解放します。 セッションが終了すると、セッションによって保持されているバックアップロックも解放されます。 
    </p><p>
      <code class="literal">LOCK INSTANCE FOR BACKUP</code> では、ファイルの作成、名前変更または削除はできません。 <code class="literal">REPAIR TABLE</code> <code class="literal">TRUNCATE TABLE</code>、<code class="literal">OPTIMIZE TABLE</code> およびアカウント管理ステートメントはブロックされます。 <a class="xref" href="sql-statements.html#account-management-statements" title="13.7.1 アカウント管理ステートメント">セクション13.7.1「アカウント管理ステートメント」</a>を参照してください。 <code class="literal">InnoDB</code> redo ログに記録されていない <code class="literal">InnoDB</code> ファイルを変更する操作もブロックされます。 
    </p><p>
      <code class="literal">LOCK INSTANCE FOR BACKUP</code> では、ユーザーが作成した一時テーブルにのみ影響する DDL 操作が許可されます。 実際には、バックアップロックが保持されている間に、ユーザーが作成した一時テーブルに属するファイルを作成、名前変更または削除できます。 バイナリログファイルの作成も許可されます。 
    </p><p>
      <code class="literal">LOCK INSTANCE FOR BACKUP</code> によって取得されるバックアップロックは、<code class="literal">FLUSH TABLES <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ... WITH READ LOCK</code> によって取得されるトランザクションロックおよびロックとは無関係であり、次の一連のステートメントが許可されます:
    </p><pre class="programlisting">LOCK INSTANCE FOR BACKUP;
FLUSH TABLES <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ... WITH READ LOCK;
UNLOCK TABLES;
UNLOCK INSTANCE;
</pre><pre class="programlisting">FLUSH TABLES <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ... WITH READ LOCK;
LOCK INSTANCE FOR BACKUP;
UNLOCK INSTANCE;
UNLOCK TABLES;
</pre><p>
      <code class="literal">lock_wait_timeout</code> 設定では、<code class="literal">LOCK INSTANCE FOR BACKUP</code> ステートメントがロックの取得を待機してから放棄する時間を定義します。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="lock-tables"></a>13.3.6 LOCK TABLES および UNLOCK TABLES ステートメント</h3></div></div></div><a class="indexterm" name="idm45826996537008"></a><a class="indexterm" name="idm45826996535696"></a><pre class="programlisting">LOCK TABLES
    <em class="replaceable"><code>tbl_name</code></em> [[AS] <em class="replaceable"><code>alias</code></em>] <em class="replaceable"><code>lock_type</code></em>
    [, <em class="replaceable"><code>tbl_name</code></em> [[AS] <em class="replaceable"><code>alias</code></em>] <em class="replaceable"><code>lock_type</code></em>] ...

<em class="replaceable"><code>lock_type</code></em>: {
    READ [LOCAL]
  | [LOW_PRIORITY] WRITE
}

UNLOCK TABLES
</pre><p>
      MySQL では、クライアントセッションは、ほかのセッションと連携してテーブルにアクセスするために、またはそのセッションにテーブルへの排他的アクセスが必要な期間中はほかのセッションによってそのテーブルが変更されないようにするために、明示的にテーブルロックを取得できます。 セッションがロックを取得または解放できるのは、それ自体のためだけです。 あるセッションが別のセッションのためにロックを取得したり、別のセッションによって保持されているロックを解放したりすることはできません。 
    </p><p>
      ロックを使用すると、トランザクションをエミュレートするか、またはテーブル更新時の速度を向上させることができます。 詳細は、<a class="xref" href="sql-statements.html#lock-tables-restrictions" title="テーブルロックの制限と条件">テーブルロックの制限と条件</a> を参照してください。 
    </p><p>
      <code class="literal">LOCK TABLES</code> は、現在のクライアントセッションのテーブルロックを明示的に取得します。 テーブルロックは、ベーステーブルまたはビューに対して取得できます。 ロックされる各オブジェクトに対する <code class="literal">LOCK TABLES</code> 権限と <code class="literal">SELECT</code> 権限が必要です。 
    </p><p>
      ビューのロックの場合、<code class="literal">LOCK TABLES</code> は、そのビューで使用されているすべてのベーステーブルをロックされるテーブルのセットに追加し、それらのテーブルを自動的にロックします。 ロックされるビューの基礎となるテーブルの場合、<code class="literal">LOCK TABLES</code> は、ビュー定義者 (<code class="literal">SQL SECURITY DEFINER</code> ビューの場合) または実行者 (すべてのビューの場合) がテーブルに対する適切な権限を持っていることを確認します。 
    </p><p>
      <a class="xref" href="sql-statements.html#lock-tables-and-triggers" title="LOCK TABLES とトリガー">LOCK TABLES とトリガー</a>で説明されているように、<code class="literal">LOCK TABLES</code> によって明示的にテーブルをロックした場合は、トリガーで使用されているテーブルもすべて暗黙的にロックされます。
    </p><p>
      <code class="literal">LOCK TABLES</code> を使用してテーブルを明示的にロックすると、外部キー制約に関連するテーブルが暗黙的にオープンおよびロックされます。 外部キーチェックでは、関連するテーブルに対して共有読取り専用ロック (<code class="literal">LOCK TABLES READ</code>) が取得されます。 カスケード更新では、操作に関連する関連テーブルに対してシェアードナッシング書込みロック (<code class="literal">LOCK TABLES WRITE</code>) が取得されます。 
    </p><p>
      <code class="literal">UNLOCK TABLES</code> は、現在のセッションによって保持されているテーブルロックをすべて明示的に解放します。 <code class="literal">LOCK TABLES</code> は、新しいロックを取得する前に、現在のセッションによって保持されているテーブルロックをすべて暗黙的に解放します。 
    </p><p>
      <code class="literal">UNLOCK TABLES</code> の別の使用法として、すべてのデータベース内のすべてのテーブルをロックできる <code class="literal">FLUSH TABLES WITH READ LOCK</code> ステートメントによって取得されたグローバルな読み取りロックの解放があります。 <a class="xref" href="sql-statements.html#flush" title="13.7.8.3 FLUSH ステートメント">セクション13.7.8.3「FLUSH ステートメント」</a>を参照してください。 (これは、特定時点のスナップショットを取得できる、Veritas などのファイルシステムがある場合にバックアップを取得するための非常に便利な方法です。) 
    </p><p>
      テーブルロックは、ほかのセッションによる不適切な読み取りまたは書き込みからのみ保護します。 <code class="literal">WRITE</code> ロックを保持しているセッションは、<code class="literal">DROP TABLE</code> や <code class="literal">TRUNCATE TABLE</code> などのテーブルレベルの操作を実行できます。 <code class="literal">READ</code> ロックを保持しているセッションの場合、<code class="literal">DROP TABLE</code> および <code class="literal">TRUNCATE TABLE</code> 操作は許可されません。 
    </p><p>
      次の説明は、<code class="literal">TEMPORARY</code> 以外のテーブルにのみ適用されます。 <code class="literal">LOCK TABLES</code> は <code class="literal">TEMPORARY</code> テーブルに対して許可されます (ただし、無視されます)。 テーブルは、ほかのどのようなロックが有効になっているかには関係なく、そのテーブルが作成されたセッションから自由にアクセスできます。 ほかのどのセッションもそのテーブルを参照できないため、ロックは必要ありません。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#table-lock-acquisition" title="テーブルロック取得">テーブルロック取得</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#table-lock-release" title="テーブルロック解除">テーブルロック解除</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#lock-tables-and-transactions" title="テーブルロックとトランザクションの通信">テーブルロックとトランザクションの通信</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#lock-tables-and-triggers" title="LOCK TABLES とトリガー">LOCK TABLES とトリガー</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#lock-tables-restrictions" title="テーブルロックの制限と条件">テーブルロックの制限と条件</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="table-lock-acquisition"></a>テーブルロック取得</h4></div></div></div><p>
        現在のセッション内でテーブルロックを取得するには、メタデータロックを取得する <code class="literal">LOCK TABLES</code> ステートメントを使用します (<a class="xref" href="optimization.html#metadata-locking" title="8.11.4 メタデータのロック">セクション8.11.4「メタデータのロック」</a> を参照)。
      </p><p>
        次のロックタイプを使用できます。
      </p><p>
        <code class="literal">READ [LOCAL]</code> ロック:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            このロックを保持しているセッションは、テーブルを読み取ることができます (ただし、書き込みはできません)。
          </p></li><li class="listitem"><p>
            複数のセッションが同時にテーブルに対する <code class="literal">READ</code> ロックを取得できます。
          </p></li><li class="listitem"><p>
            ほかのセッションは、<code class="literal">READ</code> ロックを明示的に取得することなく、テーブルを読み取ることができます。
          </p></li><li class="listitem"><p>
            <code class="literal">LOCAL</code> 修飾子を使用すると、ロックが保持されている間、ほかのセッションによる競合しない <code class="literal">INSERT</code> ステートメント (並列挿入) を実行できます。 (<a class="xref" href="optimization.html#concurrent-inserts" title="8.11.3 同時挿入">セクション8.11.3「同時挿入」</a>を参照してください。) ただし、ロックを保持している間、サーバーの外部にあるプロセスを使用してデータベースを操作しようとしている場合は、<code class="literal">READ LOCAL</code> を使用できません。 <code class="literal">InnoDB</code> テーブルの場合、<code class="literal">READ LOCAL</code> は <code class="literal">READ</code> と同じです。 
          </p></li></ul></div><p>
        <code class="literal">[LOW_PRIORITY] WRITE</code> ロック:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            このロックを保持しているセッションは、テーブルの読み取りおよび書き込みが可能です。
          </p></li><li class="listitem"><p>
            このロックを保持しているセッションだけがテーブルにアクセスできます。 ロックが解放されるまで、ほかのどのセッションもアクセスできません。 
          </p></li><li class="listitem"><p>
            <code class="literal">WRITE</code> ロックが保持されている間、テーブルに対するほかのセッションからのロック要求はブロックされます。
          </p></li><li class="listitem"><p>
            <code class="literal">LOW_PRIORITY</code> 修飾子は何の効果もありません。 以前のバージョンの MySQL では、ロックの動作に影響を与えましたが、これは当てはまらなくなっています。 これは非推奨になり、使用すると警告が生成されます。 代わりに、<code class="literal">LOW_PRIORITY</code> のない <code class="literal">WRITE</code> を使用してください。 
          </p></li></ul></div><p>
        <code class="literal">WRITE</code> ロックは通常、更新ができるだけ早く処理されるように、<code class="literal">READ</code> ロックより高い優先度を持っています。 つまり、あるセッションが <code class="literal">READ</code> ロックを取得したあと、別のセッションが <code class="literal">WRITE</code> ロックを要求した場合は、<code class="literal">WRITE</code> ロックを要求したセッションがロックを取得して解放するまで、以降の <code class="literal">READ</code> ロック要求が待たされます。 (このポリシーの例外は、<code class="literal">max_write_lock_count</code> システム変数の小さい値に対して発生する可能性があります。<a class="xref" href="optimization.html#metadata-locking" title="8.11.4 メタデータのロック">セクション8.11.4「メタデータのロック」</a> を参照してください。) 
      </p><p>
        <code class="literal">LOCK TABLES</code> ステートメントが、いずれかのテーブルに対するほかのセッションによって保持されているロックのために待機する必要がある場合、このステートメントはすべてのロックを取得できるまでブロックされます。
      </p><p>
        ロックが必要なセッションは、必要なすべてのロックを 1 つの <code class="literal">LOCK TABLES</code> ステートメントで取得する必要があります。 このように取得されたロックが保持されている間、このセッションは、ロックされたテーブルにのみアクセスできます。 たとえば、次のステートメントシーケンスでは、<code class="literal">t2</code> が <code class="literal">LOCK TABLES</code> ステートメントでロックされていないため、このテーブルにアクセスしようとするとエラーが発生します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>LOCK TABLES t1 READ;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT COUNT(*) FROM t1;</code></strong>
+----------+
| COUNT(*) |
+----------+
|        3 |
+----------+
mysql&gt; <strong class="userinput"><code>SELECT COUNT(*) FROM t2;</code></strong>
ERROR 1100 (HY000): Table 't2' was not locked with LOCK TABLES
</pre><p>
        <code class="literal">INFORMATION_SCHEMA</code> データベース内のテーブルは例外です。 これらのテーブルは、セッションが <code class="literal">LOCK TABLES</code> によって取得されたテーブルロックを保持している間であっても、明示的にロックされることなくアクセスできます。 
      </p><p>
        ロックされたテーブルを、同じ名前を使用して 1 つのクエリーで複数回参照することはできません。 代わりにエイリアスを使用し、そのテーブルと各エイリアスのための個別のロックを取得します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>LOCK TABLE t WRITE, t AS t1 READ;</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t SELECT * FROM t;</code></strong>
ERROR 1100: Table 't' was not locked with LOCK TABLES
mysql&gt; <strong class="userinput"><code>INSERT INTO t SELECT * FROM t AS t1;</code></strong>
</pre><p>
        最初の <code class="literal">INSERT</code> では、ロックされたテーブルに対する同じ名前への参照が 2 つ存在するため、エラーが発生します。 2 番目の <code class="literal">INSERT</code> は、テーブルへの参照で異なる名前が使用されるため、成功します。 
      </p><p>
        ステートメントがエイリアスを使用してテーブルを参照する場合は、その同じエイリアスを使用してテーブルをロックする必要があります。 エイリアスを指定しないでテーブルをロックすることはできません。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>LOCK TABLE t READ;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM t AS myalias;</code></strong>
ERROR 1100: Table 'myalias' was not locked with LOCK TABLES
</pre><p>
        逆に、エイリアスを使用してテーブルをロックする場合は、ステートメント内でそのエイリアスを使用してテーブルを参照する必要があります。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>LOCK TABLE t AS myalias READ;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM t;</code></strong>
ERROR 1100: Table 't' was not locked with LOCK TABLES
mysql&gt; <strong class="userinput"><code>SELECT * FROM t AS myalias;</code></strong>
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="table-lock-release"></a>テーブルロック解除</h4></div></div></div><p>
        セッションによって保持されているテーブルロックが解放される場合は、すべてのテーブルロックが一度に解放されます。 セッションは明示的にロックを解放できます。また、特定の状況で、ロックが暗黙的に解放される場合もあります。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            セッションは、<code class="literal">UNLOCK TABLES</code> によって明示的にロックを解放できます。
          </p></li><li class="listitem"><p>
            セッションがすでにロックを保持している間にロックを取得するために <code class="literal">LOCK TABLES</code> ステートメントを発行した場合は、新しいロックが付与される前に、その既存のロックが暗黙的に解放されます。
          </p></li><li class="listitem"><p>
            セッションが (たとえば、<code class="literal">START TRANSACTION</code> で) トランザクションを開始した場合は、暗黙的な <code class="literal">UNLOCK TABLES</code> が実行され、既存のロックが解放されます。 (テーブルロックとトランザクションの間の通信の詳細は、<a class="xref" href="sql-statements.html#lock-tables-and-transactions" title="テーブルロックとトランザクションの通信">テーブルロックとトランザクションの通信</a>を参照してください。)  
          </p></li></ul></div><p>
        クライアントセッションの接続が (正常または異常にかかわらず) 終了した場合、サーバーは、そのセッションによって保持されているすべてのテーブルロック (トランザクションおよび非トランザクション) を暗黙的に解放します。 クライアントが再接続すると、ロックは無効になります。 さらに、クライアントにアクティブなトランザクションがある場合、サーバーは切断時にそのトランザクションをロールバックし、再接続が発生した場合は、自動コミットが有効になった状態で新しいセッションが開始されます。 このため、クライアントは自動再接続を無効にすることが必要になる場合があります。 自動再接続が有効な場合、再接続が発生してもテーブルロックまたは現在のトランザクションが失われても、クライアントには通知されません。 自動再接続が無効になっている場合は、接続が削除されると、発行された次のステートメントに対してエラーが発生します。 クライアントはそのエラーを検出し、ロックの再取得やトランザクションの再実行などの適切なアクションを実行できます。 <a class="ulink" href="https://dev.mysql.com/doc/c-api/8.0/en/c-api-auto-reconnect.html" target="_top">Automatic Reconnection Control</a>を参照してください。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          ロックされたテーブル上で <code class="literal">ALTER TABLE</code> を使用すると、そのテーブルがロック解除される場合があります。 たとえば、2 番目の <code class="literal">ALTER TABLE</code> 操作を試みると、エラー<code class="literal">「テーブル '<em class="replaceable"><code>tbl_name</code></em>' は LOCK TABLES でロックされていません」</code>が発生する場合があります。 これに対処するには、2 番目の変更の前にテーブルを再度ロックします。 <a class="xref" href="error-handling.html#alter-table-problems" title="B.3.6.1 ALTER TABLE での問題">セクションB.3.6.1「ALTER TABLE での問題」</a>も参照してください。 
        </p></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="lock-tables-and-transactions"></a>テーブルロックとトランザクションの通信</h4></div></div></div><a class="indexterm" name="idm45826996403872"></a><p>
        <code class="literal">LOCK TABLES</code> および <code class="literal">UNLOCK TABLES</code> は、トランザクションの使用との間で次のように通信します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">LOCK TABLES</code> はトランザクションセーフではないため、テーブルをロックしようとする前に、アクティブなトランザクションをすべて暗黙的にコミットします。
          </p></li><li class="listitem"><p>
            <code class="literal">UNLOCK TABLES</code> は、アクティブなトランザクションをすべて暗黙的にコミットしますが、これが行われるのは、テーブルロックを取得するために <code class="literal">LOCK TABLES</code> が使用された場合のみです。 たとえば、次の一連のステートメントでは、<code class="literal">UNLOCK TABLES</code> がグローバルな読み取りロックを解放しますが、有効なテーブルロックがないためにトランザクションはコミットされません。 
          </p><pre class="programlisting">FLUSH TABLES WITH READ LOCK;
START TRANSACTION;
SELECT ... ;
UNLOCK TABLES;
</pre></li><li class="listitem"><p>
            トランザクションを (たとえば、<code class="literal">START TRANSACTION</code> で) 開始すると、現在のトランザクションはすべて暗黙的にコミットされ、既存のテーブルロックが解放されます。
          </p></li><li class="listitem"><p>
            <code class="literal">FLUSH TABLES WITH READ LOCK</code> は、グローバルな読み取りロックを取得しますが、テーブルロックは取得しないため、テーブルロックと暗黙的なコミットに関して <code class="literal">LOCK TABLES</code> および <code class="literal">UNLOCK TABLES</code> と同じ動作には従いません。 たとえば、<code class="literal">START TRANSACTION</code> は、グローバルな読み取りロックを解放しません。 <a class="xref" href="sql-statements.html#flush" title="13.7.8.3 FLUSH ステートメント">セクション13.7.8.3「FLUSH ステートメント」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            暗黙的にトランザクションのコミットを発生させるその他のステートメントは、既存のテーブルロックを解放しません。 このようなステートメントのリストについては、<a class="xref" href="sql-statements.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            トランザクションテーブル (<code class="literal">InnoDB</code> テーブルなど) で <code class="literal">LOCK TABLES</code> および <code class="literal">UNLOCK TABLES</code> を使用するための正しい方法は、<code class="literal">SET autocommit = 0</code> (<code class="literal">START TRANSACTION</code> ではなく) に続けて <code class="literal">LOCK TABLES</code> を指定することによってトランザクションを開始し、そのトランザクションを明示的にコミットするまで <code class="literal">UNLOCK TABLES</code> を呼び出さないことです。 たとえば、テーブル <code class="literal">t1</code> に書き込み、テーブル <code class="literal">t2</code> から読み取る必要がある場合は、次のように実行できます。 
          </p><pre class="programlisting">SET autocommit=0;
LOCK TABLES t1 WRITE, t2 READ, ...;
<em class="replaceable"><code>... do something with tables t1 and t2 here ...</code></em>
COMMIT;
UNLOCK TABLES;
</pre><p>
            <code class="literal">LOCK TABLES</code> を呼び出すと、<code class="literal">InnoDB</code> は内部的に独自のテーブルロックを取得し、MySQL は独自のテーブルロックを取得します。 <code class="literal">InnoDB</code> は次のコミット時に内部のテーブルロックを解放しますが、MySQL でテーブルロックが解放されるようにするには、<code class="literal">UNLOCK TABLES</code> を呼び出す必要があります。 <code class="literal">autocommit = 1</code> を指定すると、<code class="literal">LOCK TABLES</code> の呼び出しの直後に <code class="literal">InnoDB</code> によって内部のテーブルロックが解放され、デッドロックが非常に発生しやすくなる場合があるため、この指定は行わないようにしてください。 <code class="literal">autocommit = 1</code> が指定された場合、古いアプリケーションが不必要なデッドロックを回避するのに役立つように、<code class="literal">InnoDB</code> は内部のテーブルロックをまったく取得しません。 
          </p></li><li class="listitem"><p>
            <code class="literal">ROLLBACK</code> は、テーブルロックを解放しません。
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="lock-tables-and-triggers"></a>LOCK TABLES とトリガー</h4></div></div></div><p>
        <code class="literal">LOCK TABLES</code> によって明示的にテーブルをロックした場合は、トリガーで使用されているテーブルもすべて暗黙的にロックされます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            これらのロックは、<code class="literal">LOCK TABLES</code> ステートメントによって明示的に取得されるロックと同時に取得されます。
          </p></li><li class="listitem"><p>
            トリガーで使用されているテーブルに対するロックは、そのテーブルが読み取りのみに使用されているかどうかによって異なります。 読み取りのみに使用されている場合は、読み取りロックで十分です。 そうでない場合は、書き込みロックが使用されます。 
          </p></li><li class="listitem"><p>
            テーブルが <code class="literal">LOCK TABLES</code> によって読み取りに対して明示的にロックされているが、トリガー内で変更される可能性があるために書き込みに対してロックする必要がある場合は、読み取りロックではなく書き込みロックが取得されます。 (つまり、トリガー内でのテーブルの表示のために必要な暗黙の書き込みロックによって、テーブルに対する明示的な読み取りロック要求が書き込みロック要求に変換されます。)  
          </p></li></ul></div><p>
        次のステートメントを使用して、2 つのテーブル <code class="literal">t1</code> と <code class="literal">t2</code> をロックするとします。
      </p><pre class="programlisting">LOCK TABLES t1 WRITE, t2 READ;
</pre><p>
        <code class="literal">t1</code> または <code class="literal">t2</code> にトリガーがある場合、トリガー内で使用されるテーブルもロックされます。 <code class="literal">t1</code> に、次のように定義されたトリガーが含まれているとします。 
      </p><pre class="programlisting">CREATE TRIGGER t1_a_ins AFTER INSERT ON t1 FOR EACH ROW
BEGIN
  UPDATE t4 SET count = count+1
      WHERE id = NEW.id AND EXISTS (SELECT a FROM t3);
  INSERT INTO t2 VALUES(1, 2);
END;
</pre><p>
        <code class="literal">LOCK TABLES</code> ステートメントの結果として、<code class="literal">t1</code> と <code class="literal">t2</code> は、このステートメントに現れるためにロックされます。また、<code class="literal">t3</code> と <code class="literal">t4</code> は、トリガー内で使用されているためにロックされます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">t1</code> は、<code class="literal">WRITE</code> ロック要求ごとに、書き込みに対してロックされます。
          </p></li><li class="listitem"><p>
            <code class="literal">t2</code> は、要求が <code class="literal">READ</code> ロックに対するものであったとしても、書き込みに対してロックされます。 これは、トリガー内で <code class="literal">t2</code> に挿入されるために発生します。したがって、<code class="literal">READ</code> 要求は <code class="literal">WRITE</code> 要求に変換されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">t3</code> は、トリガー内から読み取られるだけであるため、読み取りに対してロックされます。
          </p></li><li class="listitem"><p>
            <code class="literal">t4</code> は、トリガー内で更新される可能性があるため、書き込みに対してロックされます。
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="lock-tables-restrictions"></a>テーブルロックの制限と条件</h4></div></div></div><p>
        テーブルロックを待機しているセッションを終了するために、<code class="literal">KILL</code> を安全に使用できます。 <a class="xref" href="sql-statements.html#kill" title="13.7.8.4 KILL ステートメント">セクション13.7.8.4「KILL ステートメント」</a>を参照してください。 
      </p><p>
        <code class="literal">LOCK TABLES</code> および <code class="literal">UNLOCK TABLES</code> は、ストアドプログラム内では使用できません。
      </p><p>
        <code class="literal">performance_schema</code> データベース内のテーブルは、<code class="literal">setup_<em class="replaceable"><code>xxx</code></em></code> テーブルを除き、<code class="literal">LOCK TABLES</code> ではロックできません。
      </p><p>
        <code class="literal">LOCK TABLES</code> ステートメントが有効になっている間、次のステートメントは禁止されます。<code class="literal">CREATE TABLE</code>、<code class="literal">CREATE TABLE ... LIKE</code>、<code class="literal">CREATE VIEW</code>、<code class="literal">DROP VIEW</code>、およびストアドファンクション、ストアドプロシージャー、イベントでの DDL ステートメント。
      </p><p>
        一部の操作では、<code class="literal">mysql</code> データベース内のシステムテーブルにアクセスする必要があります。 たとえば、<code class="literal">HELP</code> ステートメントにはサーバー側のヘルプテーブルの内容が必要であり、また <code class="literal">CONVERT_TZ()</code> はタイムゾーンテーブルの読み取りが必要になる可能性があります。 サーバーは、ユーザーが明示的にロックしなくても済むように、必要に応じてシステムテーブルを読み取りに対して暗黙的にロックします。 次のテーブルは、今説明したように処理されます。 
      </p><pre class="programlisting">mysql.help_category
mysql.help_keyword
mysql.help_relation
mysql.help_topic
mysql.time_zone
mysql.time_zone_leap_second
mysql.time_zone_name
mysql.time_zone_transition
mysql.time_zone_transition_type
</pre><p>
        これらのテーブルのいずれかに対する <code class="literal">WRITE</code> ロックを <code class="literal">LOCK TABLES</code> ステートメントで明示的に設定する場合は、そのテーブルがロックされる唯一のテーブルである必要があります。ほかのどのテーブルも、同じステートメントではロックできません。
      </p><p>
        1 つの <code class="literal">UPDATE</code> ステートメントはすべてアトミックであるため、通常、テーブルをロックする必要はありません。現在実行中の SQL ステートメントを、ほかのどのセッションも妨げることはできません。 ただし、テーブルのロックによって利点が得られる可能性のある場合がいくつかあります。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            一連の <code class="literal">MyISAM</code> テーブルに対して多くの操作を実行しようとしている場合は、使用しようとしているテーブルをロックする方がはるかに高速です。 <code class="literal">MyISAM</code> テーブルをロックすると、MySQL はロックされたテーブルのキーキャッシュを <code class="literal">UNLOCK TABLES</code> が呼び出されるまでフラッシュしないため、そのテーブルに対する挿入、更新、または削除が高速化されます。 通常、キーキャッシュは各 SQL ステートメントのあとでフラッシュされます。 
          </p><p>
            テーブルロックのマイナス面は、<code class="literal">READ</code> によってロックされたテーブルをどのセッションも更新できず (ロックを保持しているセッションを含む)、ロックを保持しているセッションを除き、<code class="literal">WRITE</code> によってロックされたテーブルにどのセッションもアクセスできない点です。
          </p></li><li class="listitem"><p>
            非トランザクションストレージエンジンに対してテーブルを使用している場合、<code class="literal">SELECT</code> と <code class="literal">UPDATE</code> の間にテーブルがほかのセッションによって変更されないようにするには、<code class="literal">LOCK TABLES</code> を使用する必要があります。 次に示す例では、安全に実行するために <code class="literal">LOCK TABLES</code> が必要です。 
          </p><pre class="programlisting">LOCK TABLES trans READ, customer WRITE;
SELECT SUM(value) FROM trans WHERE customer_id=<em class="replaceable"><code>some_id</code></em>;
UPDATE customer
  SET total_value=<em class="replaceable"><code>sum_from_previous_statement</code></em>
  WHERE customer_id=<em class="replaceable"><code>some_id</code></em>;
UNLOCK TABLES;
</pre><p>
            <code class="literal">LOCK TABLES</code> を使用しない場合は、<code class="literal">SELECT</code> ステートメントと <code class="literal">UPDATE</code> ステートメントの実行の間に、別のセッションによって <code class="literal">trans</code> テーブルに新しい行が挿入される可能性があります。
          </p></li></ul></div><p>
        多くの場合は、相対的な更新 (<code class="literal">UPDATE customer SET <em class="replaceable"><code>value</code></em>=<em class="replaceable"><code>value</code></em>+<em class="replaceable"><code>new_value</code></em></code>) または <code class="literal">LAST_INSERT_ID()</code> 関数を使用することによって <code class="literal">LOCK TABLES</code> の使用を回避できます。
      </p><p>
        場合によっては、ユーザーレベルのアドバイザリロック関数 <code class="literal">GET_LOCK()</code> および <code class="literal">RELEASE_LOCK()</code> を使用してテーブルのロックを回避することもできます。 高速化のために、これらのロックはサーバーのハッシュテーブル内に保存され、<code class="literal">pthread_mutex_lock()</code> と <code class="literal">pthread_mutex_unlock()</code> で実装されます。 <a class="xref" href="functions.html#locking-functions" title="12.15 ロック関数">セクション12.15「ロック関数」</a>を参照してください。 
      </p><p>
        ロックポリシーの詳細は、<a class="xref" href="optimization.html#internal-locking" title="8.11.1 内部ロック方法">セクション8.11.1「内部ロック方法」</a>を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="set-transaction"></a>13.3.7 SET TRANSACTION ステートメント</h3></div></div></div><a class="indexterm" name="idm45826996267280"></a><a class="indexterm" name="idm45826996265808"></a><a class="indexterm" name="idm45826996264400"></a><a class="indexterm" name="idm45826996263168"></a><pre class="programlisting">SET [GLOBAL | SESSION] TRANSACTION
    <em class="replaceable"><code>transaction_characteristic</code></em> [, <em class="replaceable"><code>transaction_characteristic</code></em>] ...

<em class="replaceable"><code>transaction_characteristic</code></em>: {
    ISOLATION LEVEL <em class="replaceable"><code>level</code></em>
  | <em class="replaceable"><code>access_mode</code></em>
}

<em class="replaceable"><code>level</code></em>: {
     REPEATABLE READ
   | READ COMMITTED
   | READ UNCOMMITTED
   | SERIALIZABLE
}

<em class="replaceable"><code>access_mode</code></em>: {
     READ WRITE
   | READ ONLY
}
</pre><p>
      このステートメントは、<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>の特性を指定します。 これは、カンマで区切られた 1 つ以上の特性値のリストを受け取ります。 各特性値によって、トランザクション <a class="link" href="glossary.html#glos_isolation_level" title="分離レベル">isolation level</a> またはアクセスモードが設定されます。 分離レベルは、<code class="literal">InnoDB</code> テーブルに対する操作に使用されます。 アクセスモードでは、トランザクションが読取り/書込みモードと読取り専用モードのどちらで動作するかを指定します。 
    </p><p>
      さらに、<code class="literal">SET TRANSACTION</code> には、ステートメントのスコープを示すオプションの <code class="literal">GLOBAL</code> または <code class="literal">SESSION</code> キーワードを含めることができます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#set-transaction-isolation-level" title="トランザクション分離レベル">トランザクション分離レベル</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#set-transaction-access-mode" title="トランザクションアクセスモード">トランザクションアクセスモード</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#set-transaction-scope" title="トランザクション特性スコープ">トランザクション特性スコープ</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="set-transaction-isolation-level"></a>トランザクション分離レベル</h4></div></div></div><p>
        トランザクション分離レベルを設定するには、<code class="literal">ISOLATION LEVEL <em class="replaceable"><code>level</code></em></code> 句を使用します。 同じ <code class="literal">SET TRANSACTION</code> ステートメントで複数の <code class="literal">ISOLATION LEVEL</code> 句を指定することはできません。 
      </p><p>
        デフォルトの分離レベルは <code class="literal">REPEATABLE READ</code> です。 許可されるその他の値は、<code class="literal">READ COMMITTED</code>、<code class="literal">READ UNCOMMITTED</code> および <code class="literal">SERIALIZABLE</code> です。 これらの分離レベルの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-transaction-isolation-levels" title="15.7.2.1 トランザクション分離レベル">セクション15.7.2.1「トランザクション分離レベル」</a> を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="set-transaction-access-mode"></a>トランザクションアクセスモード</h4></div></div></div><p>
        トランザクションアクセスモードを設定するには、<code class="literal">READ WRITE</code> または <code class="literal">READ ONLY</code> 句を使用します。 同じ <code class="literal">SET TRANSACTION</code> ステートメントで複数のアクセスモード句を指定することはできません。 
      </p><p>
        デフォルトでは、トランザクションは読み取り/書き込みモードで実行され、そのトランザクションで使用されるテーブルに対して読み取りと書き込みの両方が許可されます。 このモードは、<code class="literal">READ WRITE</code> のアクセスモードで <code class="literal">SET TRANSACTION</code> を使用して明示的に指定できます。 
      </p><p>
        トランザクションアクセスモードが <code class="literal">READ ONLY</code> に設定されている場合は、テーブルへの変更が禁止されます。 これにより、書き込みが許可されていない場合に可能になる、ストレージエンジンのパフォーマンス向上が実現される可能性があります。 
      </p><p>
        読み取り専用モードでは、DML ステートメントを使用して <code class="literal">TEMPORARY</code> キーワードで作成されたテーブルは引き続き変更できます。 永続的なテーブルと同様に、DDL ステートメントによって行われる変更は許可されません。 
      </p><p>
        <code class="literal">READ WRITE</code> および <code class="literal">READ ONLY</code> アクセスモードは、<code class="literal">START TRANSACTION</code> ステートメントを使用して個々のトランザクションに対しても指定できます。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="set-transaction-scope"></a>トランザクション特性スコープ</h4></div></div></div><p>
        トランザクション特性は、グローバルに設定することも、現在のセッションに対して設定することも、次のトランザクションに対してのみ設定することもできます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">GLOBAL</code> キーワードを使用する場合:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                ステートメントは、後続のすべてのセッションにグローバルに適用されます。
              </p></li><li class="listitem"><p>
                既存のセッションは影響を受けません。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">SESSION</code> キーワードを使用する場合:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                このステートメントは、現行のセッション内で実行される後続のすべてのトランザクションに適用されます。
              </p></li><li class="listitem"><p>
                ステートメントはトランザクション内では許可されますが、現在進行中のトランザクションには影響しません。
              </p></li><li class="listitem"><p>
                トランザクション間で実行された場合、このステートメントは、指定された特性の次のトランザクション値を設定する前述のステートメントをオーバーライドします。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">SESSION</code> または <code class="literal">GLOBAL</code> キーワードを使用しない場合:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                このステートメントは、セッション内で次に実行される単一のトランザクションにのみ適用されます。
              </p></li><li class="listitem"><p>
                後続のトランザクションは、指定された特性のセッション値を使用するように戻ります。
              </p></li><li class="listitem"><p>
                ステートメントはトランザクション内では許可されません:
              </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>START TRANSACTION;</code></strong>
Query OK, 0 rows affected (0.02 sec)

mysql&gt; <strong class="userinput"><code>SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;</code></strong>
ERROR 1568 (25001): Transaction characteristics can't be changed
while a transaction is in progress
</pre></li></ul></div></li></ul></div><p>
        グローバルトランザクション特性を変更するには、<code class="literal">CONNECTION_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。 任意のセッションで、セッション特性 (トランザクションの途中であっても) または次のトランザクションの特性 (そのトランザクションの開始前) を自由に変更できます。 
      </p><p>
        サーバーの起動時にグローバル分離レベルを設定するには、コマンド行またはオプションファイルで <code class="option">--transaction-isolation=<em class="replaceable"><code>level</code></em></code> オプションを使用します。 このオプションの <em class="replaceable"><code>level</code></em> の値では、スペースではなくダッシュが使用されるため、許可される値は <code class="literal">READ-UNCOMMITTED</code>、<code class="literal">READ-COMMITTED</code>、<code class="literal">REPEATABLE-READ</code>、または <code class="literal">SERIALIZABLE</code> です。 
      </p><p>
        同様に、サーバーの起動時にグローバルトランザクションアクセスモードを設定するには、<code class="option">--transaction-read-only</code> オプションを使用します。 デフォルトは <code class="literal">OFF</code> (読取り/書込みモード) ですが、読取り専用モードの場合は値を <code class="literal">ON</code> に設定できます。 
      </p><p>
        たとえば、分離レベルを <code class="literal">REPEATABLE READ</code> に、アクセスモードを <code class="literal">READ WRITE</code> に設定するには、オプションファイルの<code class="literal">[mysqld]</code>セクションで次の行を使用します:
      </p><pre class="programlisting">[mysqld]
transaction-isolation = REPEATABLE-READ
transaction-read-only = OFF
</pre><p>
        実行時に、前述のように、グローバル、セッションおよび次のトランザクションスコープレベルの特性を <code class="literal">SET TRANSACTION</code> ステートメントを使用して間接的に設定できます。 また、<code class="literal">SET</code> ステートメントを使用して直接設定し、<code class="literal">transaction_isolation</code> および <code class="literal">transaction_read_only</code> システム変数に値を割り当てることもできます: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">SET TRANSACTION</code> では、様々なスコープレベルでトランザクション特性を設定するために、オプションの <code class="literal">GLOBAL</code> および <code class="literal">SESSION</code> キーワードを使用できます。
          </p></li><li class="listitem"><p>
            <code class="literal">transaction_isolation</code> および <code class="literal">transaction_read_only</code> システム変数に値を割り当てるための <code class="literal">SET</code> ステートメントには、これらの変数を様々なスコープレベルで設定するための構文があります。
          </p></li></ul></div><p>
        次のテーブルに、各 <code class="literal">SET TRANSACTION</code> で設定される特性スコープレベルと変数割当て構文を示します。
      </p><div class="table"><a name="set-transaction-characteristic-syntax"></a><p class="title"><b>表 13.9 トランザクション特性の SET TRANSACTION 構文</b></p><div class="table-contents"><table summary="Syntax for setting transaction characteristics using SET TRANSACTION and affected scope."><col style="width: 60%"><col style="width: 40%"><thead><tr>
            <th>構文</th>
            <th>影響を受ける特性スコープ</th>
          </tr></thead><tbody><tr>
            <td><code class="literal">SET GLOBAL TRANSACTION <em class="replaceable"><code>transaction_characteristic</code></em></code></td>
            <td>グローバル</td>
          </tr><tr>
            <td><code class="literal">SET SESSION TRANSACTION <em class="replaceable"><code>transaction_characteristic</code></em></code></td>
            <td>セッション</td>
          </tr><tr>
            <td><code class="literal">SET TRANSACTION <em class="replaceable"><code>transaction_characteristic</code></em></code></td>
            <td>次のトランザクションのみ</td>
          </tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="set-variable-characteristic-syntax"></a><p class="title"><b>表 13.10 トランザクション特性の SET 構文</b></p><div class="table-contents"><table summary="Syntax for setting transaction characteristics using SET and affected scope."><col style="width: 60%"><col style="width: 40%"><thead><tr>
            <th>構文</th>
            <th>影響を受ける特性スコープ</th>
          </tr></thead><tbody><tr>
            <td><code class="literal">SET GLOBAL <em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>value</code></em></code></td>
            <td>グローバル</td>
          </tr><tr>
            <td><code class="literal">SET @@GLOBAL.<em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>value</code></em></code></td>
            <td>グローバル</td>
          </tr><tr>
            <td><code class="literal">SET PERSIST <em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>value</code></em></code></td>
            <td>グローバル</td>
          </tr><tr>
            <td><code class="literal">SET @@PERSIST.<em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>value</code></em></code></td>
            <td>グローバル</td>
          </tr><tr>
            <td><code class="literal">SET PERSIST_ONLY <em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>value</code></em></code></td>
            <td>ランタイムへの影響なし</td>
          </tr><tr>
            <td><code class="literal">SET @@PERSIST_ONLY.<em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>value</code></em></code></td>
            <td>ランタイムへの影響なし</td>
          </tr><tr>
            <td><code class="literal">SET SESSION <em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>value</code></em></code></td>
            <td>セッション</td>
          </tr><tr>
            <td><code class="literal">SET @@SESSION.<em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>value</code></em></code></td>
            <td>セッション</td>
          </tr><tr>
            <td><code class="literal">SET <em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>value</code></em></code></td>
            <td>セッション</td>
          </tr><tr>
            <td><code class="literal">SET @@<em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>value</code></em></code></td>
            <td>次のトランザクションのみ</td>
          </tr></tbody></table></div></div><br class="table-break"><p>
        実行時にトランザクション特性のグローバル値およびセッション値を確認できます:
      </p><pre class="programlisting">SELECT @@GLOBAL.transaction_isolation, @@GLOBAL.transaction_read_only;
SELECT @@SESSION.transaction_isolation, @@SESSION.transaction_read_only;
</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="xa"></a>13.3.8 XA トランザクション</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#xa-statements">13.3.8.1 XA トランザクション SQL ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#xa-states">13.3.8.2 XA トランザクションの状態</a></span></dt><dt><span class="section"><a href="sql-statements.html#xa-restrictions">13.3.8.3 XA トランザクションの制約</a></span></dt></dl></div><a class="indexterm" name="idm45826996110400"></a><p>
      <a class="link" href="glossary.html#glos_xa" title="XA">XA</a> トランザクションのサポートは、<code class="literal">InnoDB</code> ストレージエンジンに対して使用できます。 MySQL XA 実装は、X/Open CAE ドキュメント<em class="citetitle">分散トランザクション処理: XA 仕様</em>に基づいています。 このドキュメントは The Open Group によって発行されており、<a class="ulink" href="http://www.opengroup.org/public/pubs/catalog/c193.htm" target="_top">http://www.opengroup.org/public/pubs/catalog/c193.htm</a> で入手できます。 現在の XA 実装の制限については、<a class="xref" href="sql-statements.html#xa-restrictions" title="13.3.8.3 XA トランザクションの制約">セクション13.3.8.3「XA トランザクションの制約」</a>で説明されています。 
    </p><p>
      クライアント側には、特殊な要件は何もありません。 MySQL サーバーへの XA インタフェースは、<code class="literal">XA</code> キーワードで始まる SQL ステートメントで構成されています。 MySQL クライアントプログラムは、SQL ステートメントを送信したり、XA ステートメントインタフェースのセマンティクスを理解したりできる必要があります。 これらが、最新のクライアントライブラリに対してリンクされている必要はありません。 古いクライアントライブラリも機能します。 
    </p><p>
      MySQL Connector/J 5.0.0 以上では、XA SQL ステートメントインタフェースを処理するクラスインタフェースを使用して XA が直接サポートされます。
    </p><p>
      XA は分散トランザクション、つまり、複数の個別のトランザクションリソースがグローバルトランザクションに参加することを許可する機能をサポートしています。 トランザクションリソースは多くの場合 RDBMS ですが、ほかの種類のリソースであってもかまいません。 
    </p><p>
      グローバルトランザクションには、それ自体でトランザクションである複数のアクションが含まれますが、そのすべてがグループとして正常に完了するか、またはすべてがグループとしてロールバックされるかのどちらかである必要があります。 基本的に、これは ACID プロパティーを<span class="quote">「<span class="quote">1 レベル上に</span>」</span>拡張することにより、複数の ACID トランザクションを、同じく ACID プロパティーを持つグローバル操作のコンポーネントとして連携して実行できるようにします。 (非分散トランザクションと同様に、アプリケーションが読取り現象に敏感な場合は、<code class="literal">SERIALIZABLE</code> をお薦めします。 <code class="literal">REPEATABLE READ</code> では、分散トランザクションには不十分な場合があります。) 
    </p><p>
      分散トランザクションのいくつかの例:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          あるアプリケーションが、メッセージングサービスを RDBMS と組み合わせる統合ツールとして機能する場合があります。 このアプリケーションは、同じくトランザクションデータベースを含む、メッセージの送信、取得、および処理を行うトランザクションがすべて、確実にグローバルトランザクション内で実行されるようにします。 これは、<span class="quote">「<span class="quote">トランザクション電子メール</span>」</span>と考えることができます。 
        </p></li><li class="listitem"><p>
          アプリケーションが、MySQL サーバーや Oracle サーバー (または複数の MySQL サーバー) などの異なるデータベースサーバーに関連するアクションを実行します。ここで、複数のサーバーに関連するアクションは、各サーバーに対してローカルな個別のトランザクションとしてではなく、グローバルトランザクションの一部として実行する必要があります。
        </p></li><li class="listitem"><p>
          銀行が口座情報を RDBMS 内に保持し、現金自動預け払い機 (ATM) を通して現金を出し入れしています。 ATM のアクションが口座に正しく反映されるように保証することが必要ですが、これは RDBMS だけでは実行できません。 グローバルなトランザクションマネージャーが ATM とデータベースリソースを統合して、財務トランザクションの全体的な一貫性を確保します。 
        </p></li></ul></div><p>
      グローバルトランザクションを使用するアプリケーションには、1 つまたは複数のリソースマネージャーと 1 つのトランザクションマネージャーが含まれています。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          リソースマネージャー (RM) は、トランザクションリソースへのアクセスを提供します。 データベースサーバーは、1 つの種類のリソースマネージャーです。 これは、RM によって管理されているトランザクションをコミットまたはロールバックできる必要があります。 
        </p></li><li class="listitem"><p>
          トランザクションマネージャー (TM) は、グローバルトランザクションの一部であるトランザクションを調整します。 これは、これらの各トランザクションを処理する RM と通信します。 グローバルトランザクション内の個々のトランザクションは、グローバルトランザクションの<span class="quote">「<span class="quote">ブランチ</span>」</span>です。 グローバルトランザクションとそのブランチは、あとで説明されている名付けスキームによって識別されます。 
        </p></li></ul></div><p>
      XA の MySQL 実装により、MySQL サーバーはグローバルトランザクション内の XA トランザクションを処理するリソースマネージャとして機能できます。 MySQL サーバーに接続するクライアントプログラムは、トランザクションマネージャーとして機能します。 
    </p><p>
      グローバルトランザクションを実行するには、どのコンポーネントが関連しているかを知り、各コンポーネントをそのコミットまたはロールバックが可能なポイントに持っていくことが必要です。 各コンポーネントが自身の成功する能力に関してレポートする内容に応じて、それらのすべてが、アトミックグループとしてコミットまたはロールバックする必要があります。 つまり、すべてのコンポーネントがコミットするか、またはすべてのコンポーネントがロールバックする必要があります。 グローバルトランザクションを管理するには、いずれかのコンポーネントまたは接続しているネットワークが失敗する可能性があることを考慮に入れる必要があります。 
    </p><p>
      グローバルトランザクションを実行するためのプロセスでは、2 フェーズコミット (2PC) が使用されます。 これは、グローバルトランザクションのブランチによって実行されるアクションが実行されたあとに行われます。 
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          最初のフェーズでは、すべてのブランチが準備されます。 つまり、これらは TM からコミットの準備を行うよう指示されます。 これは通常、ブランチを管理する各 RM が、そのブランチのアクションを安定したストレージ内に記録することを示します。 これらのブランチはこれを実行できるかどうかを示し、これらの結果が 2 番目のフェーズに使用されます。 
        </p></li><li class="listitem"><p>
          2 番目のフェーズでは、TM が RM にコミットまたはロールバックのどちらを行うかを指示します。 すべてのブランチが準備されたときにコミット可能であることを示した場合、すべてのブランチにコミットするように指示されます。 コミットできなかったことを準備したときにブランチが示された場合は、すべてのブランチにロールバックするように指示されます。 
        </p></li></ol></div><p>
      場合によっては、グローバルトランザクションで 1 フェーズコミット (1PC) が使用されることがあります。 たとえば、グローバルトランザクションが 1 つのトランザクションリソース (つまり、1 つのブランチ) だけで構成されていることがトランザクションマネージャーによって検出された場合は、そのリソースに準備とコミットを一度に行うよう指示できます。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="xa-statements"></a>13.3.8.1 XA トランザクション SQL ステートメント</h4></div></div></div><a class="indexterm" name="idm45826996075168"></a><a class="indexterm" name="idm45826996073856"></a><a class="indexterm" name="idm45826996071664"></a><a class="indexterm" name="idm45826996070432"></a><a class="indexterm" name="idm45826996068240"></a><a class="indexterm" name="idm45826996067008"></a><a class="indexterm" name="idm45826996064816"></a><a class="indexterm" name="idm45826996063584"></a><a class="indexterm" name="idm45826996061392"></a><a class="indexterm" name="idm45826996060160"></a><a class="indexterm" name="idm45826996057968"></a><a class="indexterm" name="idm45826996056736"></a><a class="indexterm" name="idm45826996054544"></a><a class="indexterm" name="idm45826996052480"></a><p>
        MySQL で XA トランザクションを実行するには、次のステートメントを使用します。
      </p><pre class="programlisting">XA {START|BEGIN} <em class="replaceable"><code>xid</code></em> [JOIN|RESUME]

XA END <em class="replaceable"><code>xid</code></em> [SUSPEND [FOR MIGRATE]]

XA PREPARE <em class="replaceable"><code>xid</code></em>

XA COMMIT <em class="replaceable"><code>xid</code></em> [ONE PHASE]

XA ROLLBACK <em class="replaceable"><code>xid</code></em>

XA RECOVER [CONVERT XID]
</pre><p>
        <code class="literal">XA START</code> の場合、<code class="literal">JOIN</code> 句および <code class="literal">RESUME</code> 句は認識されますが、効果はありません。
      </p><p>
        <code class="literal">XA END</code> の場合、<code class="literal">SUSPEND [FOR MIGRATE]</code>句は認識されますが、効果はありません。
      </p><p>
        各 XA ステートメントは <code class="literal">XA</code> キーワードで始まり、そのほとんどに <em class="replaceable"><code>xid</code></em> 値が必要です。 <em class="replaceable"><code>xid</code></em> は XA トランザクション識別子です。 これは、このステートメントがどのトランザクションに適用されるかを示します。<em class="replaceable"><code>xid</code></em> 値はクライアントによって指定されるか、または MySQL サーバーによって生成されます。 <em class="replaceable"><code>xid</code></em> 値には、1 つから 3 つの部分が含まれています。 
      </p><pre class="programlisting"><em class="replaceable"><code>xid</code></em>: <em class="replaceable"><code>gtrid</code></em> [, <em class="replaceable"><code>bqual</code></em> [, <em class="replaceable"><code>formatID</code></em> ]]
</pre><p>
        <em class="replaceable"><code>gtrid</code></em> はグローバルトランザクション識別子であり、<em class="replaceable"><code>bqual</code></em> はブランチ修飾子であり、<em class="replaceable"><code>formatID</code></em> は、<em class="replaceable"><code>gtrid</code></em> および <em class="replaceable"><code>bqual</code></em> 値で使用される形式を識別する数値です。 構文で示されているように、<em class="replaceable"><code>bqual</code></em> と <em class="replaceable"><code>formatID</code></em> はオプションです。 <em class="replaceable"><code>bqual</code></em> が指定されていない場合、そのデフォルト値は <code class="literal">''</code> です。 <em class="replaceable"><code>formatID</code></em> が指定されていない場合、そのデフォルト値は 1 です。 
      </p><p>
        <em class="replaceable"><code>gtrid</code></em> と <em class="replaceable"><code>bqual</code></em> はそれぞれ、最大 64 バイト長 (64 文字ではありません) の文字列リテラルである必要があります。<em class="replaceable"><code>gtrid</code></em> と <em class="replaceable"><code>bqual</code></em> は、いくつかの方法で指定できます。 引用符付き文字列 (<code class="literal">'ab'</code>)、16 進文字列 (<code class="literal">X'6162'</code>、<code class="literal">0x6162</code>) またはビット値 (<code class="literal">b'<em class="replaceable"><code>nnnn</code></em>'</code>) を使用できます。 
      </p><p>
        <em class="replaceable"><code>formatID</code></em> は符号なし整数です。
      </p><p>
        <em class="replaceable"><code>gtrid</code></em> および <em class="replaceable"><code>bqual</code></em> 値は、MySQL サーバーのベースとなる XA サポートルーチンによってバイト単位で解釈されます。 ただし、XA ステートメントを含む SQL ステートメントが解析されている間、サーバーは何からの特定の文字セットで動作します。 安全のために、<em class="replaceable"><code>gtrid</code></em> と <em class="replaceable"><code>bqual</code></em> は 16 進文字列として記述してください。 
      </p><p>
        <em class="replaceable"><code>xid</code></em> 値は通常、トランザクションマネージャーによって生成されます。 ある TM によって生成される値は、ほかの TM によって生成される値とは異なっている必要があります。 特定の TM は、<code class="literal">XA RECOVER</code> ステートメントによって返された値のリスト内の自身の <em class="replaceable"><code>xid</code></em> 値を認識できる必要があります。 
      </p><p>
        <code class="literal">XA START <em class="replaceable"><code>xid</code></em></code> は、指定された <em class="replaceable"><code>xid</code></em> 値を使用して XA トランザクションを開始します。 各 XA トランザクションが一意の <em class="replaceable"><code>xid</code></em> 値を持っている必要があるため、その値が現在、別の XA トランザクションによって使用されていてはいけません。 一意性は、<em class="replaceable"><code>gtrid</code></em> および <em class="replaceable"><code>bqual</code></em> 値を使用して評価されます。 XA トランザクションに対する以降のすべての XA ステートメントを、<code class="literal">XA START</code> ステートメントで指定されたものと同じ <em class="replaceable"><code>xid</code></em> 値を使用して指定する必要があります。 これらのステートメントのいずれかを使用しているが、既存の XA トランザクションに対応していない <em class="replaceable"><code>xid</code></em> 値を指定した場合は、エラーが発生します。 
      </p><p>
        1 つ以上の XA トランザクションを同じグローバルトランザクションの一部にすることができます。 特定のグローバルトランザクション内のすべての XA トランザクションが <em class="replaceable"><code>xid</code></em> 値内の同じ <em class="replaceable"><code>gtrid</code></em> 値を使用する必要があります。 このため、特定の XA トランザクションがどのグローバルトランザクションの一部であるかについてのあいまいさがないように、<em class="replaceable"><code>gtrid</code></em> 値はグローバルに一意である必要があります。 <em class="replaceable"><code>xid</code></em> 値の <em class="replaceable"><code>bqual</code></em> 部分は、グローバルトランザクション内の XA トランザクションごとに異なっている必要があります。 (<em class="replaceable"><code>bqual</code></em> 値が異なっているという要件は、現在の MySQL XA 実装の制限です。 これは XA 仕様の一部ではありません。)  
      </p><p>
        <code class="literal">XA RECOVER</code> ステートメントは、<code class="literal">PREPARED</code> 状態にある MySQL サーバー上の XA トランザクションに関する情報を返します。 (<a class="xref" href="sql-statements.html#xa-states" title="13.3.8.2 XA トランザクションの状態">セクション13.3.8.2「XA トランザクションの状態」</a>を参照してください。) この出力には、どのクライアントによって開始されたかには関係なく、サーバー上のこのような XA トランザクションごとの行が含まれています。 
      </p><p>
        <code class="literal">XA RECOVER</code> には、<code class="literal">XA_RECOVER_ADMIN</code> 権限が必要です。 この権限要件により、ユーザーは自分以外の未処理の準備済 XA トランザクションの XID 値を検出できなくなります。 XA トランザクションを開始したユーザーが XID を認識しているため、XA トランザクションの通常のコミットまたはロールバックには影響しません。 
      </p><p>
        <code class="literal">XA RECOVER</code> の出力行は次のようになります (<code class="literal">'abc'</code>、<code class="literal">'def'</code>、<code class="literal">7</code> の各部分から成る <em class="replaceable"><code>xid</code></em> 値の例の場合)。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>XA RECOVER;</code></strong>
+----------+--------------+--------------+--------+
| formatID | gtrid_length | bqual_length | data   |
+----------+--------------+--------------+--------+
|        7 |            3 |            3 | abcdef |
+----------+--------------+--------------+--------+
</pre><p>
        出力カラムには次の意味があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">formatID</code> は、トランザクション <em class="replaceable"><code>xid</code></em> の <em class="replaceable"><code>formatID</code></em> 部分です。
          </p></li><li class="listitem"><p>
            <code class="literal">gtrid_length</code> は、<em class="replaceable"><code>xid</code></em> の <em class="replaceable"><code>gtrid</code></em> 部分の長さ (バイト単位) です。
          </p></li><li class="listitem"><p>
            <code class="literal">bqual_length</code> は、<em class="replaceable"><code>xid</code></em> の <em class="replaceable"><code>bqual</code></em> 部分の長さ (バイト単位) です。
          </p></li><li class="listitem"><p>
            <code class="literal">data</code> は、<em class="replaceable"><code>xid</code></em> の <em class="replaceable"><code>gtrid</code></em> および <em class="replaceable"><code>bqual</code></em> 部分の連結です。
          </p></li></ul></div><p>
        XID 値に印刷不可能な文字が含まれる場合があります。 <code class="literal">XA RECOVER</code> では、クライアントが XID 値を 16 進数でリクエストできるように、オプションの <code class="literal">CONVERT XID</code> 句を使用できます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="xa-states"></a>13.3.8.2 XA トランザクションの状態</h4></div></div></div><p>
        XA トランザクションは、次の各状態を経由して処理されます。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <code class="literal">XA START</code> を使用して、XA トランザクションを開始し、それを <code class="literal">ACTIVE</code> 状態にします。
          </p></li><li class="listitem"><p>
            <code class="literal">ACTIVE</code> XA トランザクションに対しては、トランザクションを構成する SQL ステートメントを発行したあと、<code class="literal">XA END</code> ステートメントを発行します。 <code class="literal">XA END</code> は、トランザクションを <code class="literal">IDLE</code> 状態にします。 
          </p></li><li class="listitem"><p>
            <code class="literal">IDLE</code> XA トランザクションに対しては、<code class="literal">XA PREPARE</code> ステートメントまたは <code class="literal">XA COMMIT ... ONE PHASE</code> ステートメントのどちらかを発行できます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">XA PREPARE</code> は、トランザクションを <code class="literal">PREPARED</code> 状態にします。 <code class="literal">XA RECOVER</code> では <code class="literal">PREPARED</code> 状態の XA トランザクションがすべてリストされるため、この時点での <code class="literal">XA RECOVER</code> ステートメントの出力にはトランザクションの <em class="replaceable"><code>xid</code></em> 値が含まれます。 
              </p></li><li class="listitem"><p>
                <code class="literal">XA COMMIT ... ONE PHASE</code> は、トランザクションの準備とコミットを行います。 トランザクションが終了するため、<em class="replaceable"><code>xid</code></em> 値は <code class="literal">XA RECOVER</code> によってリストされません。 
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">PREPARED</code> XA トランザクションに対しては、<code class="literal">XA COMMIT</code> ステートメントを発行してトランザクションをコミットおよび終了するか、または <code class="literal">XA ROLLBACK</code> を発行してトランザクションをロールバックおよび終了することができます。
          </p></li></ol></div><p>
        グローバルトランザクションの一部としてテーブルに行を挿入する単純な XA トランザクションを次に示します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>XA START 'xatest';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO mytable (i) VALUES(10);</code></strong>
Query OK, 1 row affected (0.04 sec)

mysql&gt; <strong class="userinput"><code>XA END 'xatest';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>XA PREPARE 'xatest';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>XA COMMIT 'xatest';</code></strong>
Query OK, 0 rows affected (0.00 sec)
</pre><p>
        特定のクライアント接続のコンテキスト内では、XA トランザクションとローカル (非 XA) トランザクションは相互に排他的です。 たとえば、XA トランザクションを開始するために <code class="literal">XA START</code> が発行された場合は、その XA トランザクションがコミットまたはロールバックされるまでローカルトランザクションを開始できません。 逆に、<code class="literal">START TRANSACTION</code> を使用してローカルトランザクションが開始された場合は、そのトランザクションがコミットまたはロールバックされるまで XA ステートメントを使用できません。 
      </p><p>
        XA トランザクションが <code class="literal">ACTIVE</code> 状態の場合、暗黙的なコミットを引き起こすステートメントは発行できません。 その XA トランザクションをロールバックできないため、それを行うことは XA 規約に違反します。 このようなステートメントを実行しようとすると、次のエラーが発生します: 
      </p><pre class="programlisting">ERROR 1399 (XAE07): XAER_RMFAIL: The command cannot be executed
when global transaction is in the ACTIVE state
</pre><p>
        前の注意事項が適用されるステートメントは、<a class="xref" href="sql-statements.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>に示されています。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="xa-restrictions"></a>13.3.8.3 XA トランザクションの制約</h4></div></div></div><a class="indexterm" name="idm45826995928416"></a><a class="indexterm" name="idm45826995926256"></a><p>
        XA トランザクションのサポートは、<code class="literal">InnoDB</code> ストレージエンジンに限られています。
      </p><p>
        <span class="quote">「<span class="quote">外部 XA</span>」</span> の場合、MySQL Server がリソースマネージャーとして機能し、クライアントプログラムがトランザクションマネージャーとして機能します。 <span class="quote">「<span class="quote">内部 XA</span>」</span> の場合、MySQL サーバー内のストレージエンジンがリソースマネージャーとして機能し、サーバー自体がトランザクションマネージャーとして機能します。 内部 XA サポートは、個々のストレージエンジンの機能によって制限されています。 内部 XA は、複数のストレージエンジンが関与する XA トランザクションを処理するために必要になります。 内部 XA の実装では、ストレージエンジンがテーブルハンドラレベルでの 2 フェーズコミットをサポートしている必要であり、現在これは <code class="literal">InnoDB</code> にのみ当てはまります。 
      </p><p>
        <code class="literal">XA START</code> の場合、<code class="literal">JOIN</code> 句および <code class="literal">RESUME</code> 句は認識されますが、効果はありません。
      </p><p>
        <code class="literal">XA END</code> の場合、<code class="literal">SUSPEND [FOR MIGRATE]</code>句は認識されますが、効果はありません。
      </p><p>
        <em class="replaceable"><code>xid</code></em> 値の <em class="replaceable"><code>bqual</code></em> 部分が、グローバルトランザクション内の XA トランザクションごとに異なる必要があるという要件が、現在の MySQL XA 実装の制限です。 これは XA の仕様によるものではありません。 
      </p><p>
        XA トランザクションは、2 つの部分でバイナリログに書き込まれます。 <code class="literal">XA PREPARE </code>が発行されると、<code class="literal">XA PREPARE</code> までのトランザクションの最初の部分が初期 GTID を使用して書き込まれます。 <code class="literal">XA_prepare_log_event</code> は、バイナリログ内のこのようなトランザクションを識別するために使用されます。 <code class="literal">XA COMMIT</code> または <code class="literal">XA ROLLBACK</code> が発行されると、<code class="literal">XA COMMIT</code> または <code class="literal">XA ROLLBACK</code> ステートメントのみを含むトランザクションの別の部分が、別の GTID を使用して書き込まれます。 <code class="literal">XA_prepare_log_event</code> で識別されるトランザクションの最初の部分の後に、必ずしも <code class="literal">XA COMMIT</code> または <code class="literal">XA ROLLBACK</code> が続くわけではありません。これにより、任意の 2 つの XA トランザクションのインターリーブバイナリロギングが発生する可能性があります。 XA トランザクションの 2 つの部分は、異なるバイナリログファイルでも使用できます。 つまり、<code class="literal">PREPARED</code> 状態の XA トランザクションは、明示的な <code class="literal">XA COMMIT</code> ステートメントまたは <code class="literal">XA ROLLBACK</code> ステートメントが発行されるまで永続的になり、XA トランザクションがレプリケーションと互換性を持つようになります。 
      </p><p>
        レプリカでは、XA トランザクションが準備されるとすぐにレプリケーションアプライヤスレッドからデタッチされ、レプリカ上の任意のスレッドによってコミットまたはロールバックできます。 これは、同じ XA トランザクションが、異なるスレッド上の異なる状態で <code class="literal">events_transactions_current</code> テーブルに表示されることを意味します。 <code class="literal">events_transactions_current</code> テーブルには、スレッド上の最新の監視対象トランザクションイベントの現在のステータスが表示され、スレッドがアイドル状態の場合、このステータスは更新されません。 そのため、XA トランザクションは、別のスレッドによって処理された後も、元のアプライヤスレッドの <code class="literal">PREPARED</code> 状態で表示できます。 <code class="literal">PREPARED</code> 状態のままでリカバリが必要な XA トランザクションを肯定的に識別するには、パフォーマンススキーマトランザクションテーブルではなく、<code class="literal">XA RECOVER</code> ステートメントを使用します。 
      </p><p>
        XA トランザクションの使用には、次の制限があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            XA トランザクションは、バイナリログに関して予期しない停止に対する完全な回復力がありません。 サーバーが <code class="literal">XA PREPARE</code>, <code class="literal">XA COMMIT</code>, <code class="literal">XA ROLLBACK</code> または <code class="literal">XA COMMIT ... ONE PHASE</code> ステートメントの実行中に予期しない停止が発生した場合、サーバーは正しい状態に回復できず、サーバーとバイナリログが一貫性のない状態のままになる可能性があります。 この状況では、バイナリログに適用されていない追加の XA トランザクションが含まれているか、適用されている XA トランザクションが失われている可能性があります。 また、GTID が有効になっている場合は、回復後に、<code class="literal">@@GLOBAL.GTID_EXECUTED</code> が適用されたトランザクションを正しく記述しないことがあります。 <code class="literal">XA PREPARE</code> の前、<code class="literal">XA PREPARE</code> と <code class="literal">XA COMMIT</code> (または <code class="literal">XA ROLLBACK</code>) の間、または <code class="literal">XA COMMIT</code> (または <code class="literal">XA ROLLBACK</code>) の後に予期しない停止が発生した場合、サーバーおよびバイナリログは正しくリカバリされ、一貫性のある状態になります。 
          </p></li><li class="listitem"><p>
            XA トランザクションと組み合せたレプリケーションフィルタまたはバイナリログフィルタの使用はサポートされていません。 テーブルをフィルタリングすると、レプリカで XA トランザクションが空になる可能性があり、空の XA トランザクションはサポートされません。 また、MySQL 8.0 のデフォルトになった <code class="literal">InnoDB</code> テーブルに格納されているレプリカ接続メタデータリポジトリおよびアプライヤメタデータリポジトリでは、フィルタ処理された XA トランザクションの後にデータエンジントランザクションの内部状態が変更され、レプリケーショントランザクションコンテキストの状態と一貫性がなくなる可能性があります。 
          </p><p>
            XA トランザクションがレプリケーションフィルタの影響を受けるたびに、トランザクションが空であったかどうかに関係なく、エラー <code class="literal">ER_XA_REPLICATION_FILTERS</code> がログに記録されます。 トランザクションが空でない場合、レプリカは実行を続行できますが、潜在的な問題を回避するために XA トランザクションでのレプリケーションフィルタの使用を中止するステップを実行する必要があります。 トランザクションが空の場合、レプリカは停止します。 その場合、レプリケーションプロセスの一貫性が損なわれる可能性のある不確定な状態にレプリカがある可能性があります。 特に、レプリカのレプリカ上の <code class="literal">gtid_executed</code> セットは、ソース上のものと一貫性がない可能性があります。 この状況を解決するには、ソースを分離し、すべてのレプリケーションを停止してから、レプリケーショントポロジ全体で GTID の一貫性をチェックします。 エラーメッセージを生成した XA トランザクションを元に戻し、レプリケーションを再開します。 
          </p></li><li class="listitem"><p>
            XA トランザクションは、ステートメントベースレプリケーションでは安全でないとみなされます。 ソースでパラレルにコミットされた 2 つの XA トランザクションがレプリカで逆の順序で準備されている場合、安全に解決できないロック依存性が発生する可能性があり、レプリケーションがレプリカのデッドロックで失敗する可能性があります。 この状況は、シングルスレッドまたはマルチスレッドレプリカで発生する可能性があります。 <code class="literal">binlog_format=STATEMENT</code> が設定されている場合、XA トランザクション内の DML ステートメントに対して警告が発行されます。 <code class="literal">binlog_format=MIXED</code> または <code class="literal">binlog_format=ROW</code> が設定されている場合、XA トランザクション内の DML ステートメントは行ベースのレプリケーションを使用して記録され、潜在的な問題は存在しません。 
          </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL 5.7.7 より前は、XA トランザクションはレプリケーションとまったく互換性がありませんでした。 これは、<code class="literal">PREPARED</code> 状態の XA トランザクションが、サーバーのクリーンシャットダウンまたはクライアントの切断時にロールバックされるためです。 同様に、サーバーが異常停止してから再度起動されたが、トランザクションの内容をバイナリログに書き込めなかった場合、<code class="literal">PREPARED</code> 状態の XA トランザクションは <code class="literal">PREPARED</code> 状態のままになります。 どちらの状況でも、XA トランザクションを正しくレプリケートできませんでした。 
        </p></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sql-replication-statements"></a>13.4 レプリケーションステートメント</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#replication-statements-master">13.4.1 ソースサーバーを制御する SQL ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#replication-statements-replica">13.4.2 レプリケーションサーバーを制御するための SQL ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#replication-statements-group">13.4.3 グループレプリケーションを制御するための SQL ステートメント</a></span></dt></dl></div><p>
    レプリケーションは、このセクションで説明されているステートメントを使用した SQL インタフェースを通して制御できます。 ステートメントは、ソースサーバーを制御するグループ、レプリカサーバーを制御するグループ、および任意のレプリケーションサーバーに適用できるグループに分割されます。 
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-statements-master"></a>13.4.1 ソースサーバーを制御する SQL ステートメント</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#purge-binary-logs">13.4.1.1 PURGE BINARY LOGS ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#reset-master">13.4.1.2 RESET MASTER ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#set-sql-log-bin">13.4.1.3 SET sql_log_bin ステートメント</a></span></dt></dl></div><a class="indexterm" name="idm45826995860640"></a><a class="indexterm" name="idm45826995858464"></a><a class="indexterm" name="idm45826995856400"></a><p>
      このセクションでは、レプリケーションソースサーバーを管理するためのステートメントについて説明します。<a class="xref" href="sql-statements.html#replication-statements-replica" title="13.4.2 レプリケーションサーバーを制御するための SQL ステートメント">セクション13.4.2「レプリケーションサーバーを制御するための SQL ステートメント」</a> では、レプリカサーバーを管理するためのステートメントについて説明します。
    </p><p>
      ここで説明するステートメントに加えて、レプリケーションでは次の <code class="literal">SHOW</code> ステートメントがソースサーバーで使用されます。 これらのステートメントについては、<a class="xref" href="sql-statements.html#show" title="13.7.7 SHOW ステートメント">セクション13.7.7「SHOW ステートメント」</a>を参照してください。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SHOW BINARY LOGS</code>
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW BINLOG EVENTS</code>
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW MASTER STATUS</code>
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW REPLICAS | SHOW SLAVE HOSTS</code>
        </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="purge-binary-logs"></a>13.4.1.1 PURGE BINARY LOGS ステートメント</h4></div></div></div><a class="indexterm" name="idm45826995841344"></a><a class="indexterm" name="idm45826995840032"></a><pre class="programlisting">PURGE { BINARY | MASTER } LOGS {
    TO '<em class="replaceable"><code>log_name</code></em>'
  | BEFORE <em class="replaceable"><code>datetime_expr</code></em>
}
</pre><p>
        バイナリログは、MySQL サーバーによって行われたデータ変更に関する情報を含む一連のファイルです。 このログは一連のバイナリログファイルのほか、インデックスファイルで構成されています (<a class="xref" href="server-administration.html#binary-log" title="5.4.4 バイナリログ">セクション5.4.4「バイナリログ」</a>を参照してください)。 
      </p><p>
        <code class="literal">PURGE BINARY LOGS</code> ステートメントは、指定されたログファイル名または日付の前にあるログインデックスファイルにリストされているすべてのバイナリログファイルを削除します。 <code class="literal">BINARY</code> と <code class="literal">MASTER</code> はシノニムです。 削除されたログファイルはインデックスファイル内に記録されているリストからも削除されるため、特定のログファイルがそのリスト内の先頭になります。 
      </p><p>
        <code class="literal">PURGE BINARY LOGS</code> には、<code class="literal">BINLOG_ADMIN</code> 権限が必要です。 このステートメントは、サーバーがバイナリロギングを有効にする <code class="option">--log-bin</code> オプションで起動されていない場合は何の効果もありません。 
      </p><p>
        例:
      </p><pre class="programlisting">PURGE BINARY LOGS TO 'mysql-bin.010';
PURGE BINARY LOGS BEFORE '2019-04-02 22:46:26';
</pre><p>
        <code class="literal">BEFORE</code> バリアント <em class="replaceable"><code>datetime_expr</code></em> 引数は、<code class="literal">DATETIME</code> 値 (<code class="literal">'<em class="replaceable"><code>YYYY-MM-DD hh:mm:ss</code></em>'</code>形式の値) に評価される必要があります。
      </p><p>
        このステートメントは、レプリカのレプリケート中に安全に実行できます。 それらを停止する必要はありません。 現在削除しようとしているログファイルのいずれかを読み取っているアクティブレプリカがある場合、このステートメントでは、使用中のログファイルまたはそのログファイルより後のログファイルは削除されませんが、以前のログファイルは削除されます。 この状況では、警告メッセージが発行されます。 ただし、レプリカが接続されておらず、まだ読み取られていないログファイルのいずれかをパージする場合、レプリカは再接続後にレプリケートできません。 
      </p><p>
        バイナリログファイルを安全にパージするには、次の手順に従います。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            各レプリカで、<code class="literal">SHOW REPLICA | SLAVE STATUS</code> を使用して読み取るログファイルを確認します。
          </p></li><li class="listitem"><p>
            <code class="literal">SHOW BINARY LOGS</code> を使用して、ソースのバイナリログファイルのリストを取得します。
          </p></li><li class="listitem"><p>
            すべてのレプリカの中で最も古いログファイルを確認します。 これがターゲットファイルです。 すべてのレプリカが最新の場合、これはリストの最後のログファイルです。 
          </p></li><li class="listitem"><p>
            削除しようとしているすべてのログファイルのバックアップを作成します。 (この手順はオプションですが、常に実行することをお勧めします。)  
          </p></li><li class="listitem"><p>
            ターゲットファイルの直前までのすべてのログファイルをパージします。
          </p></li></ol></div><p>
        <code class="literal">PURGE BINARY LOGS TO</code> と <code class="literal">PURGE BINARY LOGS BEFORE</code> はどちらも、<code class="filename">.index</code> ファイルにリストされているバイナリログファイルが、ほかの何らかの手段 (Linux 上での <span class="command"><strong>rm</strong></span> の使用など) によってシステムから削除されている場合はエラーで失敗します。 (Bug #18199、Bug #18453) このようなエラーに対処するには、<code class="filename">.index</code> ファイル (これは単純なテキストファイルです) を手動で編集して、実際に存在するバイナリログファイルのみがリストされていることを確認したあと、失敗した <code class="literal">PURGE BINARY LOGS</code> ステートメントを再度実行します。 
      </p><p>
        バイナリログファイルは、サーバーのバイナリログの有効期限後に自動的に削除されます。 ファイルの削除は、起動時およびバイナリログのフラッシュ時に実行できます。 デフォルトのバイナリログの有効期限は 30 日です。 <code class="literal">binlog_expire_logs_seconds</code> システム変数を使用して、別の有効期限を指定できます。 レプリケーションを使用している場合は、レプリカがソースより遅れる可能性のある最大時間以下の有効期限を指定する必要があります。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="reset-master"></a>13.4.1.2 RESET MASTER ステートメント</h4></div></div></div><a class="indexterm" name="idm45826995797056"></a><pre class="programlisting">RESET MASTER [TO <em class="replaceable"><code>binary_log_file_index_number</code></em>]
</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          このステートメントは、必要なバイナリログファイルデータおよび GTID 実行履歴が失われないように注意して使用してください。
        </p></div><p>
        <code class="literal">RESET MASTER</code> には、<code class="literal">RELOAD</code> 権限が必要です。
      </p><p>
        バイナリロギングが有効になっている (<code class="literal">log_bin</code> が <code class="literal">ON</code>) サーバーの場合、<code class="literal">RESET MASTER</code> は既存のバイナリログファイルをすべて削除し、バイナリログインデックスファイルをリセットして、バイナリロギングが開始される前の状態にサーバーをリセットします。 バイナリロギングを再開できるように、新しい空のバイナリログファイルが作成されます。 
      </p><p>
        GTID が使用されている (<code class="literal">gtid_mode</code> が <code class="literal">ON</code>) サーバーの場合、<code class="literal">RESET MASTER</code> を発行すると GTID 実行履歴がリセットされます。 <code class="literal">gtid_purged</code> システム変数の値は空の文字列 (<code class="literal">''</code>) に設定され、<code class="literal">gtid_executed</code> システム変数のグローバル値 (セッション値ではない) は空の文字列に設定され、<code class="literal">mysql.gtid_executed</code> テーブルはクリアされます (<a class="xref" href="replication.html#replication-gtids-gtid-executed-table" title="mysql.gtid_executed テーブル">mysql.gtid_executed テーブル</a> を参照)。 GTID 対応サーバーでバイナリロギングが有効になっている場合、<code class="literal">RESET MASTER</code> は前述のようにバイナリログもリセットします。 GTID 対応サーバーがバイナリロギングが無効になっているレプリカであっても、<code class="literal">RESET MASTER</code> は GTID 実行履歴をリセットする方法であることに注意してください。<code class="literal">RESET REPLICA | SLAVE</code> は GTID 実行履歴に影響しません。 GTID 実行履歴のリセットの詳細は、<a class="xref" href="replication.html#replication-gtids-execution-history" title="GTID 実行履歴のリセット">GTID 実行履歴のリセット</a> を参照してください。 
      </p><p>
        オプションの <code class="literal">TO</code> 句を指定せずに <code class="literal">RESET MASTER</code> を発行すると、インデックスファイルにリストされているすべてのバイナリログファイルが削除され、バイナリログインデックスファイルが空にリセットされ、<code class="literal">1</code> から始まる新しいバイナリログファイルが作成されます。 リセット後に <code class="literal">1</code> 以外の番号からバイナリログファイルのインデックスを開始するには、オプションの <code class="literal">TO</code> 句を使用します。 
      </p><p>
        <code class="literal">RESET MASTER</code> を <code class="literal">TO</code> 句とともに使用してバイナリログファイルのインデックス番号を指定すると、<code class="literal">FLUSH BINARY LOGS</code> および <code class="literal">PURGE BINARY LOGS TO</code> ステートメントの代わりに単一のステートメントが提供されるため、フェイルオーバーが簡略化されます。 インデックス番号に適切な値を使用していることを確認します。 間違った値を入力した場合は、<code class="literal">TO</code> 句を指定して、または指定せずに別の <code class="literal">RESET MASTER</code> ステートメントを発行することで、これを修正できます。 範囲外の値を修正しないと、サーバーを再起動できません。 
      </p><p>
        次の例では、<code class="literal">TO</code> 句の使用方法を示します:
      </p><pre class="programlisting">RESET MASTER TO 1234;

SHOW BINARY LOGS;
+-------------------+-----------+-----------+
| Log_name          | File_size | Encrypted |
+-------------------+-----------+-----------+
| source-bin.001234 |       154 | No        |
+-------------------+-----------+-----------+
</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          <code class="literal">TO</code> 句を使用しない <code class="literal">RESET MASTER</code> の効果は、<code class="literal">PURGE BINARY LOGS</code> の効果と 2 つの重要な点で異なります:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              <code class="literal">RESET MASTER</code> が、インデックスファイルにリストされている<span class="emphasis"><em>すべての</em></span>バイナリログファイルを削除し、<code class="literal">.000001</code> の数字のサフィクスを持つ 1 つの空のバイナリログファイルだけを残すのに対して、<code class="literal">PURGE BINARY LOGS</code> では番号はリセットされません。
            </p></li><li class="listitem"><p>
              <code class="literal">RESET MASTER</code> は、レプリカの実行中に使用することを意図していません。 レプリカの実行中に <code class="literal">RESET MASTER</code> を使用した場合の動作は定義されていません (したがってサポートされていません)。一方、レプリカの実行中は <code class="literal">PURGE BINARY LOGS</code> を安全に使用できます。 
            </p></li></ol></div><p>
          <a class="xref" href="sql-statements.html#purge-binary-logs" title="13.4.1.1 PURGE BINARY LOGS ステートメント">セクション13.4.1.1「PURGE BINARY LOGS ステートメント」</a>も参照してください。
        </p></div><p>
        <code class="literal">TO</code> 句のない <code class="literal">RESET MASTER</code> は、ソースおよびレプリカを最初に設定するときに役立つことがあるため、次のように設定を検証できます:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            ソースとレプリカを起動し、レプリケーションを開始します (<a class="xref" href="replication.html#replication-howto" title="17.1.2 バイナリログファイルの位置ベースのレプリケーションの設定">セクション17.1.2「バイナリログファイルの位置ベースのレプリケーションの設定」</a> を参照)。
          </p></li><li class="listitem"><p>
            ソースでいくつかのテストクエリーを実行します。
          </p></li><li class="listitem"><p>
            クエリーがレプリカにレプリケートされたことを確認します。
          </p></li><li class="listitem"><p>
            レプリケーションが正しく実行されている場合は、<code class="literal">STOP REPLICA | SLAVE</code> を発行してからレプリカで <code class="literal">RESET REPLICA | SLAVE</code> を発行し、テストクエリーからの不要なデータがレプリカに存在しないことを確認します。
          </p></li><li class="listitem"><p>
            ソースで <code class="literal">RESET MASTER</code> を発行して、テストクエリーをクリーンアップします。
          </p></li></ol></div><p>
        設定の確認、ソースおよびレプリカのリセット、およびテストによって生成された不要なデータまたはバイナリログファイルがソースまたはレプリカに残っていないことの確認後、レプリカを起動してレプリケートを開始できます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="set-sql-log-bin"></a>13.4.1.3 SET sql_log_bin ステートメント</h4></div></div></div><a class="indexterm" name="idm45826995728176"></a><pre class="programlisting">SET sql_log_bin = {OFF|ON}
</pre><p>
        <code class="literal">sql_log_bin</code> 変数は、バイナリログへのロギングを現在のセッションで有効にするかどうかを制御します (バイナリログ自体が有効になっていると仮定します)。 デフォルト値は <code class="literal">ON</code> です。 現在のセッションのバイナリロギングを無効または有効にするには、セッション <code class="literal">sql_log_bin</code> 変数を <code class="literal">OFF</code> または <code class="literal">ON</code> に設定します。 
      </p><p>
        レプリカにレプリケートしないソースに変更を加えている間にバイナリロギングを一時的に無効にするには、セッションに対してこの変数を <code class="literal">OFF</code> に設定します。
      </p><p>
        このシステム変数のセッション値の設定は制限された操作です。 セッションユーザーには、制限付きセッション変数を設定するのに十分な権限が必要です。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 
      </p><p>
        トランザクションまたはサブクエリー内で <code class="literal">sql_log_bin</code> のセッション値を設定することはできません。
      </p><p>
        <span class="emphasis"><em>「この変数を <code class="literal">OFF</code> に設定すると、新しい GTID がバイナリログ内のトランザクションに割り当てられなくなります」</em></span>。 これは、GTID をレプリケーションに使用している場合、バイナリロギングがあとで再度有効になった場合でも、この時点からログに書き込まれる GTID はその意味で発生したトランザクションを考慮しないため、それらのトランザクションは失われることを意味します。 
      </p><p>
        <span class="command"><strong>mysqldump</strong></span> は GTID が使用されているサーバーからダンプファイルに <code class="literal">SET @@SESSION.sql_log_bin=0</code> ステートメントを追加します。これにより、ダンプファイルのリロード中にバイナリロギングが無効になります。 このステートメントは、トランザクションの元の GTID が使用されるように、新しい GTID が生成されてダンプファイル内のトランザクションに割り当てられるのを防ぎます。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-statements-replica"></a>13.4.2 レプリケーションサーバーを制御するための SQL ステートメント</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#change-master-to">13.4.2.1 CHANGE MASTER TO ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#change-replication-filter">13.4.2.2 CHANGE REPLICATION FILTER ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#change-replication-source-to">13.4.2.3 CHANGE REPLICATION SOURCE TO ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#master-pos-wait">13.4.2.4 MASTER_POS_WAIT() ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#reset-replica">13.4.2.5 RESET REPLICA | SLAVE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#reset-slave">13.4.2.6 RESET SLAVE | REPLICA ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#start-replica">13.4.2.7 START REPLICA | SLAVE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#start-slave">13.4.2.8 START SLAVE | REPLICA ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#stop-replica">13.4.2.9 STOP REPLICA | SLAVE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#stop-slave">13.4.2.10 STOP SLAVE | REPLICA ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#replication-functions-source-list">13.4.2.11 ソースリストを構成する関数</a></span></dt></dl></div><a class="indexterm" name="idm45826995706400"></a><a class="indexterm" name="idm45826995704256"></a><a class="indexterm" name="idm45826995702224"></a><p>
      このセクションでは、レプリカサーバーを管理するためのステートメントについて説明します。<a class="xref" href="sql-statements.html#replication-statements-master" title="13.4.1 ソースサーバーを制御する SQL ステートメント">セクション13.4.1「ソースサーバーを制御する SQL ステートメント」</a> では、ソースサーバーを管理するためのステートメントについて説明します。
    </p><p>
      ここで説明するステートメントに加えて、<code class="literal">SHOW REPLICA | SLAVE STATUS</code> および <code class="literal">SHOW RELAYLOG EVENTS</code> もレプリカとともに使用されます。 これらのステートメントについては、<a class="xref" href="sql-statements.html#show-replica-status" title="13.7.7.35 SHOW REPLICA | SLAVE STATUS ステートメント">セクション13.7.7.35「SHOW REPLICA | SLAVE STATUS ステートメント」</a>および<a class="xref" href="sql-statements.html#show-relaylog-events" title="13.7.7.32 SHOW RELAYLOG EVENTS ステートメント">セクション13.7.7.32「SHOW RELAYLOG EVENTS ステートメント」</a>を参照してください。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="change-master-to"></a>13.4.2.1 CHANGE MASTER TO ステートメント</h4></div></div></div><a class="indexterm" name="idm45826995692816"></a><pre class="programlisting">CHANGE MASTER TO <em class="replaceable"><code>option</code></em> [, <em class="replaceable"><code>option</code></em>] ... [ <em class="replaceable"><code>channel_option</code></em> ]

<em class="replaceable"><code>option</code></em>: {
    MASTER_BIND = '<em class="replaceable"><code>interface_name</code></em>'
  | MASTER_HOST = '<em class="replaceable"><code>host_name</code></em>'
  | MASTER_USER = '<em class="replaceable"><code>user_name</code></em>'
  | MASTER_PASSWORD = '<em class="replaceable"><code>password</code></em>'
  | MASTER_PORT = <em class="replaceable"><code>port_num</code></em>
  | PRIVILEGE_CHECKS_USER = {'<em class="replaceable"><code>account</code></em>' | NULL}
  | REQUIRE_ROW_FORMAT = {0|1}
  | REQUIRE_TABLE_PRIMARY_KEY_CHECK = {STREAM | ON | OFF}
  | ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS = {OFF | LOCAL | <em class="replaceable"><code>uuid</code></em>}
  | MASTER_LOG_FILE = '<em class="replaceable"><code>source_log_name</code></em>'
  | MASTER_LOG_POS = <em class="replaceable"><code>source_log_pos</code></em>
  | MASTER_AUTO_POSITION = {0|1}
  | RELAY_LOG_FILE = '<em class="replaceable"><code>relay_log_name</code></em>'
  | RELAY_LOG_POS = <em class="replaceable"><code>relay_log_pos</code></em>
  | MASTER_HEARTBEAT_PERIOD = <em class="replaceable"><code>interval</code></em>
  | MASTER_CONNECT_RETRY = <em class="replaceable"><code>interval</code></em>
  | MASTER_RETRY_COUNT = <em class="replaceable"><code>count</code></em>
  | SOURCE_CONNECTION_AUTO_FAILOVER = {0|1}
  | MASTER_DELAY = <em class="replaceable"><code>interval</code></em>
  | MASTER_COMPRESSION_ALGORITHMS = '<em class="replaceable"><code>value</code></em>'
  | MASTER_ZSTD_COMPRESSION_LEVEL = <em class="replaceable"><code>level</code></em>
  | MASTER_SSL = {0|1}
  | MASTER_SSL_CA = '<em class="replaceable"><code>ca_file_name</code></em>'
  | MASTER_SSL_CAPATH = '<em class="replaceable"><code>ca_directory_name</code></em>'
  | MASTER_SSL_CERT = '<em class="replaceable"><code>cert_file_name</code></em>'
  | MASTER_SSL_CRL = '<em class="replaceable"><code>crl_file_name</code></em>'
  | MASTER_SSL_CRLPATH = '<em class="replaceable"><code>crl_directory_name</code></em>'
  | MASTER_SSL_KEY = '<em class="replaceable"><code>key_file_name</code></em>'
  | MASTER_SSL_CIPHER = '<em class="replaceable"><code>cipher_list</code></em>'
  | MASTER_SSL_VERIFY_SERVER_CERT = {0|1}
  | MASTER_TLS_VERSION = '<em class="replaceable"><code>protocol_list</code></em>'
  | MASTER_TLS_CIPHERSUITES = '<em class="replaceable"><code>ciphersuite_list</code></em>'
  | MASTER_PUBLIC_KEY_PATH = '<em class="replaceable"><code>key_file_name</code></em>'
  | GET_MASTER_PUBLIC_KEY = {0|1}
  | NETWORK_NAMESPACE = '<em class="replaceable"><code>namespace</code></em>'
  | IGNORE_SERVER_IDS = (<em class="replaceable"><code>server_id_list</code></em>)
}

<em class="replaceable"><code>channel_option</code></em>:
    FOR CHANNEL <em class="replaceable"><code>channel</code></em>

<em class="replaceable"><code>server_id_list</code></em>:
    [<em class="replaceable"><code>server_id</code></em> [, <em class="replaceable"><code>server_id</code></em>] ... ]
</pre><p>
        <code class="literal">CHANGE MASTER TO</code> は、レプリカサーバーがソースへの接続およびソースからのデータの読取りに使用するパラメータを変更します。 また、レプリケーションメタデータリポジトリの内容も更新されます (<a class="xref" href="replication.html#replica-logs" title="17.2.4 リレーログおよびレプリケーションメタデータリポジトリ">セクション17.2.4「リレーログおよびレプリケーションメタデータリポジトリ」</a> を参照)。 MySQL 8.0.23 から、<code class="literal">CHANGE MASTER TO</code> のかわりに <code class="literal">CHANGE REPLICATION SOURCE TO</code> を使用します。これは、そのリリースから非推奨になりました。 MySQL 8.0.23 より前のリリースでは、<code class="literal">CHANGE MASTER TO</code> を使用します。 
      </p><p>
        レプリケーション SQL スレッドおよびレプリケーション I/O スレッドの状態に応じて、最初に停止せずに、実行中のレプリカに対して <code class="literal">CHANGE MASTER TO</code> ステートメントを発行できます。 このような使用を制御するルールは、このセクションの後半で説明します。 <code class="literal">CHANGE MASTER TO</code> には、<code class="literal">REPLICATION_SLAVE_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。 
      </p><p>
        マルチスレッドのレプリカを使用する場合 (つまり、<code class="literal">slave_parallel_workers</code> が 0 より大きい場合)、レプリカを停止すると、レプリカが意図的に停止されたかどうかに関係なく、リレーログから実行された一連のトランザクションで<span class="quote">「<span class="quote">「ギャップ」</span>」</span>が発生する可能性があります。 このようなギャップが存在する場合、<code class="literal">CHANGE MASTER TO</code> の発行は失敗します。 この状況の解決策は、ギャップを確実に閉じる <code class="literal">START REPLICA | SLAVE UNTIL SQL_AFTER_MTS_GAPS</code> を発行することです。 
      </p><p>
        オプションの <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を使用すると、ステートメントが適用されるレプリケーションチャネルの名前を指定できます。 <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を指定すると、<code class="literal">CHANGE MASTER TO</code> ステートメントが特定のレプリケーションチャネルに適用され、新しいチャネルの追加または既存のチャネルの変更に使用されます。 たとえば、<code class="literal">channel2</code> という新しいチャネルを追加するには、次のようにします: 
      </p><pre class="programlisting">CHANGE MASTER TO MASTER_HOST=host1, MASTER_PORT=3002 FOR CHANNEL 'channel2'</pre><p>
        句が指定されておらず、追加のチャネルが存在しない場合、ステートメントはデフォルトチャネルに適用されます。
      </p><p>
        複数のレプリケーションチャネルを使用する場合、<code class="literal">CHANGE MASTER TO</code> ステートメントで <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を使用してチャネルを指定しないと、エラーが発生します。 詳しくは<a class="xref" href="replication.html#replication-channels" title="17.2.2 レプリケーションチャネル">セクション17.2.2「レプリケーションチャネル」</a>をご覧ください。 
      </p><p>
        <code class="literal">MASTER_HOST</code> およびその他の <code class="literal">CHANGE MASTER TO</code> オプションに使用される値では、改行 (<code class="literal">\n</code> または <code class="literal">0x0A</code>) 文字がチェックされます。 このような文字がこれらの値に存在すると、<code class="literal">ER_MASTER_INFO</code> でステートメントが失敗します。 
      </p><p>
        <code class="literal">CHANGE MASTER TO</code> を起動すると、<code class="literal">MASTER_HOST</code>, <code class="literal">MASTER_PORT</code>, <code class="literal">MASTER_LOG_FILE</code> および <code class="literal">MASTER_LOG_POS</code> の以前の値が、実行前のレプリカ状態に関するその他の情報とともにエラーログに書き込まれます。
      </p><p>
        <code class="literal">CHANGE MASTER TO</code> では、進行中のトランザクションが暗黙的にコミットされます。 <a class="xref" href="sql-statements.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。 
      </p><p>
        <code class="literal">CHANGE MASTER TO</code> ステートメントの一部のオプションでは、<code class="literal">CHANGE MASTER TO</code> ステートメント (およびその後の <code class="literal">START REPLICA | SLAVE</code> ステートメント) を発行する前に、<code class="literal">STOP REPLICA | SLAVE</code> ステートメントを発行する必要があります。 場合によっては、レプリケーション SQL スレッドまたはレプリケーション I/O スレッドのどちらか一方のみを停止する必要があります: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            SQL スレッドが停止すると、レプリケーション I/O スレッドが実行されている場合でも、<code class="literal">RELAY_LOG_FILE</code>、<code class="literal">RELAY_LOG_POS</code> および <code class="literal">MASTER_DELAY</code> オプションの任意の組合せを使用して <code class="literal">CHANGE MASTER TO</code> を実行できます。 I/O スレッドの実行中は、このステートメントでほかのオプションを使用できません。 
          </p></li><li class="listitem"><p>
            I/O スレッドが停止すると、SQL スレッドが実行されている場合でも、このステートメント (任意の組合せで) <span class="emphasis"><em>except</em></span> <code class="literal">RELAY_LOG_FILE</code>, <code class="literal">RELAY_LOG_POS</code>, <code class="literal">MASTER_DELAY</code> または <code class="literal">MASTER_AUTO_POSITION = 1</code> のオプションを使用して <code class="literal">CHANGE MASTER TO</code> を実行できます。
          </p></li><li class="listitem"><p>
            <code class="literal">MASTER_AUTO_POSITION = 1</code> または <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> を使用する <code class="literal">CHANGE MASTER TO</code> ステートメントを発行する前に、SQL スレッドと I/O スレッドの両方を停止する必要があります。
          </p></li></ul></div><p>
        <code class="literal">SHOW REPLICA | SLAVE STATUS</code> を使用して、レプリケーション SQL スレッドおよびレプリケーション I/O スレッドの現在の状態を確認できます。 Group Replication applier チャネル (<code class="literal">group_replication_applier</code>) には I/O スレッドがなく、SQL スレッドのみがあることに注意してください。 
      </p><p>
        詳細は、<a class="xref" href="replication.html#replication-solutions-switch" title="17.4.8 フェイルオーバー中のソースの切替え">セクション17.4.8「フェイルオーバー中のソースの切替え」</a>を参照してください。
      </p><p>
        ステートメントベースレプリケーションおよび一時テーブルを使用している場合は、<code class="literal">STOP REPLICA | SLAVE</code> ステートメントのあとの <code class="literal">CHANGE MASTER TO</code> ステートメントがレプリカ上の一時テーブルの背後に残る可能性があります。 これが発生するたびに警告 (<code class="literal">ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO</code>) が発行されるようになりました。 このような場合は、このような <code class="literal">CHANGE MASTER TO</code> ステートメントを実行する前に、<code class="literal">Slave_open_temp_tables</code> システムステータス変数の値が 0 であることを確認することで回避できます。 
      </p><p>
        <code class="literal">CHANGE MASTER TO</code> は、ソースのスナップショットがあり、スナップショットの時刻に対応するソースバイナリログ座標を記録している場合にレプリカを設定する際に役立ちます。 スナップショットをレプリカにロードしてソースと同期した後、レプリカで <code class="literal">CHANGE MASTER TO MASTER_LOG_FILE='<em class="replaceable"><code>log_name</code></em>', MASTER_LOG_POS=<em class="replaceable"><code>log_pos</code></em></code> を実行して、レプリカがソースバイナリログの読取りを開始する座標を指定できます。 
      </p><p>
        次の例では、レプリカが使用するソースサーバーを変更し、レプリカが読取りを開始するソースバイナリログ座標を確立します:
      </p><pre class="programlisting">CHANGE MASTER TO
  MASTER_HOST='source2.example.com',
  MASTER_USER='replication',
  MASTER_PASSWORD='<em class="replaceable"><code>password</code></em>',
  MASTER_PORT=3306,
  MASTER_LOG_FILE='source2-bin.001',
  MASTER_LOG_POS=4,
  MASTER_CONNECT_RETRY=10;
</pre><p>
        次の例は、使用される頻度の低い操作を示しています。 これは、なんらかの理由で再実行するリレーログファイルがレプリカに存在する場合に使用されます。 これを行うには、ソースにアクセスできる必要はありません。 <code class="literal">CHANGE MASTER TO</code> のみを使用し、SQL スレッド (<code class="literal">START REPLICA | SLAVE SQL_THREAD</code>) を起動する必要があります: 
      </p><pre class="programlisting">CHANGE MASTER TO
  RELAY_LOG_FILE='replica-relay-bin.006',
  RELAY_LOG_POS=4025;
</pre><p>
        <code class="literal">CHANGE MASTER TO</code> ステートメントで指定しないオプションは、次の説明に示す場合を除き、その値を保持します。 そのため、ほとんどの場合、変更されないオプションを指定する必要はありません。 
      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"> <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> </span></dt><dd><p>
              レプリケーションチャネルが GTID を持たないレプリケートされたトランザクションに GTID を割り当て、GTID ベースのレプリケーションを使用しないソースから使用するレプリカへのレプリケーションを有効にします。 マルチソースレプリカの場合、<code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> を使用するチャネルと使用しないチャネルを混在させることができます。 デフォルトは <code class="literal">OFF</code> で、この機能は使用されません。 
            </p><p>
              <code class="literal">LOCAL</code> は、レプリカ独自の UUID (<code class="literal">server_uuid</code> 設定) を含む GTID を割り当てます。<code class="literal"><em class="replaceable"><code>uuid</code></em></code> は、レプリケーションソースサーバーの <code class="literal">server_uuid</code> 設定など、指定された UUID を含む GTID を割り当てます。 非ローカル UUID を使用すると、レプリカで発生したトランザクションと、ソースで発生したトランザクション、およびマルチソースレプリカの場合は異なるソースで発生したトランザクションを区別できます。 選択した UUID は、レプリカ自体での使用にのみ意味があります。 ソースによって送信されたトランザクションのいずれかに GTID がすでにある場合、その GTID は保持されます。 
            </p><p>
              Group Replication に固有のチャネルでは <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> を使用できませんが、Group Replication グループメンバーであるサーバーインスタンス上の別のソースの非同期レプリケーションチャネルでは使用できます。 その場合、GTID を作成するための UUID として Group Replication グループ名を指定しないでください。 
            </p><p>
              <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> を <code class="literal">LOCAL</code> または <code class="literal"><em class="replaceable"><code>uuid</code></em></code> に設定するには、レプリカに <code class="literal">gtid_mode=ON</code> が設定されている必要があり、後で変更することはできません。 このオプションは、バイナリログファイルの位置ベースのレプリケーションを持つソースで使用されるため、チャネルに <code class="literal">MASTER_AUTO_POSITION=1</code> を設定することはできません。 このオプションを設定する前に、レプリケーション SQL スレッドとレプリケーション I/O スレッドの両方を停止する必要があります。 
            </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
                フェイルオーバーが必要な場合、どのチャネルでも <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> を使用して設定されたレプリカを昇格させてレプリケーションサーバーを置き換えることはできず、レプリカから作成されたバックアップを使用してレプリケーションサーバーをリストアすることはできません。 同じ制限が、任意のチャネルで <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> を使用する他のレプリカの置換またはリストアにも適用されます。 
              </p></div><p>
              その他の制限および詳細は、<a class="xref" href="replication.html#replication-gtids-assign-anon" title="17.1.3.6 GTID のないソースから GTID のあるレプリカへのレプリケーション">セクション17.1.3.6「GTID のないソースから GTID のあるレプリカへのレプリケーション」</a> を参照してください。
            </p></dd><dt><span class="term"> <code class="literal">GET_MASTER_PUBLIC_KEY</code> </span></dt><dd><p>
              ソースから公開キーをリクエストすることで、RSA キーペアベースのパスワード交換を有効にします。 このオプションは、<code class="literal">caching_sha2_password</code> 認証プラグインで認証されるレプリカに適用されます。 このプラグインを使用して認証されるアカウントによる接続の場合、ソースはリクエストされないかぎり公開キーを送信しないため、クライアントでリクエストまたは指定する必要があります。 <code class="literal">MASTER_PUBLIC_KEY_PATH</code> が指定され、有効な公開キーファイルが指定されている場合は、<code class="literal">GET_MASTER_PUBLIC_KEY</code> よりも優先されます。 <code class="literal">caching_sha2_password</code> プラグイン (MySQL 8.0 のデフォルト) で認証されるレプリケーションユーザーアカウントを使用していて、セキュアな接続を使用していない場合は、このオプションまたは <code class="literal">MASTER_PUBLIC_KEY_PATH</code> オプションを指定して、RSA 公開キーをレプリカに提供する必要があります。 
            </p></dd><dt><span class="term"> <code class="literal">IGNORE_SERVER_IDS</code> </span></dt><dd><p>
              レプリカが指定されたサーバーから発生したイベントを無視するようにします。 このオプションは、0 個以上のサーバー ID のコンマ区切りリストを取ります。 サーバーからのログローテーションおよび削除イベントは無視されず、リレーログに記録されます。 
            </p><p>
              循環レプリケーションでは、発信元のサーバーは通常、独自のイベントのターミネータとして機能するため、これらのイベントが複数回適用されることはありません。 そのため、このオプションは、循環内のいずれかのサーバーが削除されたときの循環レプリケーションで役立ちます。 1、2、3、および 4 のサーバー ID を持つ 4 台のサーバーを含む循環レプリケーションセットアップが存在するとき、サーバー 3 に障害が発生したとします。 サーバー 2 からサーバー 4 へのレプリケーションを開始してギャップを埋める場合、サーバー 4 で発行する <code class="literal">CHANGE MASTER TO</code> ステートメントに <code class="literal">IGNORE_SERVER_IDS = (3)</code> を含めて、サーバー 3 の代わりにサーバー 2 をソースとして使用するように指示できます。 それにより、サーバー 4 は、使用されなくなっているサーバーで発信されたすべてのステートメントを無視し、伝播しなくなります。 
            </p><p>
              <code class="literal">IGNORE_SERVER_IDS</code> にサーバーの独自の ID が含まれているときに、<code class="option">--replicate-same-server-id</code> オプションが有効な状態でそのサーバーが起動された場合は、エラーが発生します。
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                レプリケーションにグローバルトランザクション識別子 (GTID) が使用されている場合、すでに適用されているトランザクションは自動的に無視されるため、<code class="literal">IGNORE_SERVER_IDS</code> 関数は必須ではなく、非推奨です。 サーバーに <code class="literal">gtid_mode=ON</code> が設定されている場合、<code class="literal">CHANGE MASTER TO</code> ステートメントに <code class="literal">IGNORE_SERVER_IDS</code> オプションを含めると、非推奨の警告が発行されます。 
              </p></div><p>
              ソースメタデータリポジトリおよび <code class="literal">SHOW REPLICA | SLAVE STATUS</code> の出力では、現在無視されているサーバーのリストが提供されます。 詳細は、<a class="xref" href="replication.html#replica-logs-status" title="17.2.4.2 レプリケーションメタデータリポジトリ">セクション17.2.4.2「レプリケーションメタデータリポジトリ」</a>および<a class="xref" href="sql-statements.html#show-replica-status" title="13.7.7.35 SHOW REPLICA | SLAVE STATUS ステートメント">セクション13.7.7.35「SHOW REPLICA | SLAVE STATUS ステートメント」</a>を参照してください。 
            </p><p>
              <code class="literal">IGNORE_SERVER_IDS</code> オプションを指定せずに <code class="literal">CHANGE MASTER TO</code> ステートメントを発行した場合、既存のリストは保持されます。 無視されるサーバーのリストをクリアするには、このオプションを空のリストとともに使用する必要があります。 
            </p><pre class="programlisting">CHANGE MASTER TO IGNORE_SERVER_IDS = ();
</pre><p>
              <code class="literal">RESET REPLICA | SLAVE ALL</code> により、<code class="literal">IGNORE_SERVER_IDS</code> がクリアされます。
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                <code class="literal">IGNORE_SERVER_IDS</code> で既存のサーバー ID が設定されているチャネルがある場合、<code class="literal">SET GTID_MODE=ON</code> が発行されると、非推奨の警告が発行されます。 GTID ベースのレプリケーションを開始する前に、関係するサーバー上の無視されたすべてのサーバー ID リストを確認してクリアします。 無視された ID がある場合は、<code class="literal">SHOW REPLICA | SLAVE STATUS</code> ステートメントにリストが表示されます。 非推奨の警告が表示された場合でも、空のリストを指定した <code class="literal">IGNORE_SERVER_IDS</code> オプションを含む <code class="literal">CHANGE MASTER TO</code> ステートメントを発行することで、<code class="literal">gtid_mode=ON</code> の設定後にリストをクリアできます。 
              </p></div></dd><dt><span class="term"> <code class="literal">MASTER_AUTO_POSITION</code> </span></dt><dd><p>
              GTID ベースのレプリケーションを使用してレプリカがソースに接続しようとします。 このオプションは、レプリケーション SQL スレッドとレプリケーション I/O スレッドの両方が停止している場合にのみ、<code class="literal">CHANGE MASTER TO</code> で使用できます。 
            </p><p>
              レプリカとソースの両方で GTID が有効になっている必要があります (レプリカでは <code class="literal">GTID_MODE=ON</code>、<code class="literal">ON_PERMISSIVE,</code>または <code class="literal">OFF_PERMISSIVE</code>、ソースでは <code class="literal">GTID_MODE=ON</code>)。 接続には自動配置が使用されるため、<code class="literal">MASTER_LOG_FILE</code> および <code class="literal">MASTER_LOG_POS</code> で表される座標は使用されず、これらのオプションのいずれかまたは両方を <code class="literal">MASTER_AUTO_POSITION = 1</code> とともに使用するとエラーが発生します。 レプリカでマルチソースレプリケーションが有効になっている場合は、適用可能なレプリケーションチャネルごとに <code class="literal">MASTER_AUTO_POSITION = 1</code> オプションを設定する必要があります。 
            </p><p>
              <code class="literal">MASTER_AUTO_POSITION = 1</code> が設定されている場合、レプリカは初期接続ハンドシェイクで、すでに受信、コミット、またはその両方を行ったトランザクションを含む GTID セットを送信します。 ソースは、GTID がレプリカによって送信される GTID セットに含まれていないバイナリログに記録されたすべてのトランザクションを送信することによって応答します。 この交換により、レプリカがまだ記録またはコミットしていない GTID を持つトランザクションのみがソースから送信されるようになります。 ダイヤモンドトポロジの場合と同様に、レプリカが複数のソースからトランザクションを受信する場合、自動スキップ機能によってトランザクションが 2 回適用されないようにします。 レプリカによって送信される GTID セットの計算方法の詳細は、<a class="xref" href="replication.html#replication-gtids-auto-positioning" title="17.1.3.3 GTID 自動配置">セクション17.1.3.3「GTID 自動配置」</a> を参照してください。 
            </p><p>
              ソースによって送信されるべきトランザクションのいずれかがソースバイナリログからパージされているか、別の方法で <code class="literal">gtid_purged</code> システム変数の GTID セットに追加されている場合、ソースはエラー <span class="errorname">ER_MASTER_HAS_PURGED_REQUIRED_GTIDS</span> をレプリカに送信し、レプリケーションは開始しません。 欠落しているパージ済トランザクションの GTID が識別され、警告メッセージ <span class="errorname">ER_FOUND_MISSING_GTIDS</span> のソースエラーログにリストされます。 また、トランザクションの交換中に、レプリカが GTID 内のソース UUID を持つトランザクションを記録またはコミットしたが、ソース自体がそれらをコミットしていないことが判明した場合、ソースはレプリカにエラー <span class="errorname">ER_SLAVE_HAS_MORE_GTIDS_THAN_MASTER</span> を送信し、レプリケーションは開始しません。 これらの状況の処理方法の詳細は、<a class="xref" href="replication.html#replication-gtids-auto-positioning" title="17.1.3.3 GTID 自動配置">セクション17.1.3.3「GTID 自動配置」</a> を参照してください。 
            </p><p>
              レプリケーションが GTID 自動配置を有効にして実行されているかどうかを確認するには、パフォーマンススキーマの <code class="literal">replication_connection_status</code> テーブルまたは <code class="literal">SHOW REPLICA | SLAVE STATUS</code> の出力を確認します。 <code class="literal">MASTER_AUTO_POSITION</code> オプションを再度無効にすると、レプリカはファイルベースレプリケーションに戻ります。その場合は、<code class="literal">MASTER_LOG_FILE</code> または <code class="literal">MASTER_LOG_POS</code> オプションのいずれかまたは両方も指定する必要があります。 
            </p></dd><dt><span class="term"> <code class="literal">MASTER_BIND</code> </span></dt><dd><p>
              複数のネットワークインタフェースを持つレプリカで使用するために、ソースへの接続に選択するレプリカネットワークインタフェースを決定します。 このオプションで構成されたアドレスは、<code class="literal">SHOW REPLICA | SLAVE STATUS</code> からの出力の <code class="literal">Master_Bind</code> カラムに表示されます (存在する場合)。 ソースメタデータリポジトリテーブル <code class="literal">mysql.slave_master_info</code> では、値は <code class="literal">Master_bind</code> カラムとして表示されます。 レプリカを特定のネットワークインタフェースにバインドする機能は、NDB Cluster でもサポートされています。 
            </p></dd><dt><span class="term"> <code class="literal">MASTER_COMPRESSION_ALGORITHMS</code> </span></dt><dd><p>
              レプリケーションソースサーバーへの接続に許可される圧縮アルゴリズムを指定します。 使用可能なアルゴリズムは、<code class="literal">protocol_compression_algorithms</code> システム変数の場合と同じです。 デフォルト値は <code class="literal">uncompressed</code> です。 <code class="literal">MASTER_COMPRESSION_ALGORITHMS</code> は、MySQL 8.0.18 の時点で使用可能です。 
            </p><p>
              <code class="literal">MASTER_COMPRESSION_ALGORITHMS</code> の値は、<code class="literal">slave_compressed_protocol</code> システム変数が無効な場合にのみ適用されます。 <code class="literal">slave_compressed_protocol</code> が有効な場合は、<code class="literal">MASTER_COMPRESSION_ALGORITHMS</code> よりも優先され、ソースとレプリカの両方がそのアルゴリズムをサポートしている場合は、ソースへの接続で <code class="literal">zlib</code> 圧縮が使用されます。 詳細は、<a class="xref" href="programs.html#connection-compression-control" title="4.2.8 接続圧縮制御">セクション4.2.8「接続圧縮制御」</a>を参照してください。 
            </p><p>
              <code class="literal">binlog_transaction_compression</code> システム変数によってアクティブ化されるバイナリログトランザクション圧縮 (MySQL 8.0.20 で使用可能) を使用して帯域幅を節約することもできます。 これを接続圧縮と組み合せて行うと、接続圧縮ではデータを処理する機会は少なくなりますが、ヘッダーと、圧縮されていないイベントおよびトランザクションペイロードは圧縮できます。 バイナリログのトランザクション圧縮の詳細は、<a class="xref" href="server-administration.html#binary-log-transaction-compression" title="5.4.4.5 バイナリログトランザクション圧縮">セクション5.4.4.5「バイナリログトランザクション圧縮」</a> を参照してください。 
            </p></dd><dt><span class="term"> <code class="literal">MASTER_CONNECT_RETRY</code> </span></dt><dd><p>
              ソースへの接続がタイムアウトした後にレプリカが試行する再接続の間隔を指定します。 試行は、<code class="literal">MASTER_RETRY_COUNT</code> オプションによって制限されます。 両方のデフォルト設定が使用されている場合、レプリカは再接続試行 (<code class="literal">MASTER_CONNECT_RETRY=60</code>) の間 60 秒待機し、60 日間 (<code class="literal">MASTER_RETRY_COUNT=86400</code>) 再接続を試行し続けます。 これらの値はソースメタデータリポジトリに記録され、<code class="literal">replication_connection_configuration</code>「パフォーマンススキーマ」テーブルに表示されます。 
            </p></dd><dt><span class="term"> <code class="literal">MASTER_DELAY</code> </span></dt><dd><p>
              レプリカが遅延する必要があるソースからの遅延秒数を指定します。 ソースから受信したイベントは、ソースでの実行より少なくとも <em class="replaceable"><code>interval</code></em> 秒後に実行されません。 デフォルトは 0 です。 <em class="replaceable"><code>interval</code></em> が 0 から 2<sup>31</sup>-1 までの範囲の負ではない整数でない場合は、エラーが発生します。 詳細は、<a class="xref" href="replication.html#replication-delayed" title="17.4.11 遅延レプリケーション">セクション17.4.11「遅延レプリケーション」</a>を参照してください。 <code class="literal">MASTER_DELAY</code> オプションを使用する <code class="literal">CHANGE MASTER TO</code> ステートメントは、レプリケーション SQL スレッドの停止時に実行中のレプリカで実行できます。 
            </p></dd><dt><span class="term"> <code class="literal">MASTER_HEARTBEAT_PERIOD</code> </span></dt><dd><p>
              ハートビート間隔を制御します。これにより、接続がまだ良好な場合に、データが存在しないときに接続タイムアウトが発生しなくなります。 ハートビートシグナルは、その秒数が経過するとレプリカに送信され、ソースバイナリログがイベントで更新されるたびに待機期間がリセットされます。 したがって、ハートビートは、これより長い期間バイナリログファイルに未送信のイベントがない場合にのみ、ソースによって送信されます。 
            </p><p>
              ハートビート間隔 <em class="replaceable"><code>interval</code></em> は、0 から 4294967 秒の範囲の小数値およびミリ秒単位の解像度です。ゼロ以外の最小値は 0.001 です。 <em class="replaceable"><code>interval</code></em> を 0 に設定すると、ハートビートが完全に無効になります。 ハートビート間隔のデフォルトは、<code class="literal">slave_net_timeout</code> システム変数の値の半分です。 ソースメタデータリポジトリに記録され、<code class="literal">replication_connection_configuration</code>「パフォーマンススキーマ」テーブルに表示されます。 <code class="literal">RESET REPLICA | SLAVE</code> を発行すると、ハートビート間隔がデフォルト値にリセットされます。 
            </p><p>
              <code class="literal">slave_net_timeout</code> システム変数は、レプリカがソースからのデータまたはハートビートシグナルのいずれかを待機する秒数を指定します。この秒数を過ぎると、レプリカは接続が切断されたとみなし、読取りを中断して再接続を試行します。 デフォルト値は 60 秒 (1 分) です。 <code class="literal">slave_net_timeout</code> の値またはデフォルト設定を変更しても、明示的に設定されているか、以前に計算されたデフォルトを使用しているかにかかわらず、ハートビート間隔は自動的には変更されないことに注意してください。 <code class="literal">@@GLOBAL.slave_net_timeout</code> を現在のハートビート間隔より小さい値に設定すると、警告が発行されます。 <code class="literal">slave_net_timeout</code> が変更された場合は、接続タイムアウトの前にハートビートシグナルが発生するように、<code class="literal">CHANGE MASTER TO</code> を発行してハートビート間隔を適切な値に調整する必要もあります。 これを行わない場合、ハートビートシグナルは効果がなく、ソースからデータを受信しない場合、レプリカは再接続を繰り返し試行してゾンビダンプスレッドを作成できます。 
            </p></dd><dt><span class="term"> <code class="literal">MASTER_HOST</code> </span></dt><dd><p>
              レプリケーションソースサーバーのホスト名または IP アドレス。 レプリカはこれを使用してソースに接続します。 
            </p><p>
              <code class="literal">MASTER_HOST</code> または <code class="literal">MASTER_PORT</code> を指定した場合、レプリカは、ソースサーバーが以前とは異なることを前提とします (オプション値が現在の値と同じであっても)。) この場合、ソースバイナリログファイルの名前と位置の古い値は適用できなくなるため、ステートメントに <code class="literal">MASTER_LOG_FILE</code> と <code class="literal">MASTER_LOG_POS</code> を指定しないと、<code class="literal">MASTER_LOG_FILE=''</code>と <code class="literal">MASTER_LOG_POS=4</code> は暗黙的に追加されます。 
            </p><p>
              <code class="literal">MASTER_HOST=''</code> を設定する (つまり、その値を明示的に空の文字列に設定する) ことは、<code class="literal">MASTER_HOST</code> をまったく設定しないことと同じでは<span class="emphasis"><em>ありません</em></span>。 <code class="literal">MASTER_HOST</code> を空の文字列に設定しようとすると、エラーで失敗します。 
            </p></dd><dt><span class="term"> <code class="literal">MASTER_LOG_FILE</code>, <code class="literal">MASTER_LOG_POS</code> </span></dt><dd><p>
              バイナリログファイル名、およびレプリケーション I/O スレッドが次回のスレッド起動時にソースバイナリログからの読み取りを開始するそのファイル内の場所。 バイナリログファイルの位置ベースのレプリケーションを使用している場合は、これらのオプションを指定します。 <code class="literal">MASTER_LOG_FILE</code> には、ソースサーバーで使用可能な特定のバイナリログファイル (<code class="literal">MASTER_LOG_FILE='binlog.000145'</code>など) の数値接尾辞が含まれている必要があります。 <code class="literal">MASTER_LOG_POS</code> は、レプリカがそのファイルの読取りを開始する数値位置です。 <code class="literal">MASTER_LOG_POS=4</code> は、バイナリログファイルでイベントの開始を表します。 
            </p><p>
              <code class="literal">MASTER_LOG_FILE</code> または <code class="literal">MASTER_LOG_POS</code> のどちらかを指定する場合は、<code class="literal">RELAY_LOG_FILE</code> や <code class="literal">RELAY_LOG_POS</code> を指定できません。 <code class="literal">MASTER_LOG_FILE</code> または <code class="literal">MASTER_LOG_POS</code> のいずれかを指定する場合は、GTID ベースのレプリケーション用の <code class="literal">MASTER_AUTO_POSITION = 1</code> も指定できません。 
            </p><p>
              <code class="literal">MASTER_LOG_FILE</code> も <code class="literal">MASTER_LOG_POS</code> も指定されていない場合、レプリカは <code class="literal">CHANGE MASTER TO</code> が発行される前の<span class="emphasis"><em>レプリケーション SQL スレッド</em></span>の最後の座標を使用します。 これにより、レプリケーション SQL スレッドがレプリケーション I/O スレッドと比較して遅延していても、レプリケーションの不連続性がなくなります。 
            </p></dd><dt><span class="term"> <code class="literal">MASTER_PASSWORD</code> </span></dt><dd><p>
              レプリケーションソースサーバーへの接続に使用するレプリケーションユーザーアカウントのパスワード。 <code class="literal">MASTER_PASSWORD</code> を指定する場合は、<code class="literal">MASTER_USER</code> も必要です。 
            </p><p>
              <code class="literal">CHANGE MASTER TO</code> ステートメントでレプリケーションユーザーアカウントに使用されるパスワードの長さは、32 文字に制限されています。 32 文字を超えるパスワードを使用しようとすると、<code class="literal">CHANGE MASTER TO</code> で障害が発生します。 
            </p></dd><dt><span class="term"> <code class="literal">MASTER_PORT</code> </span></dt><dd><p>
              レプリカがレプリケーションソースサーバーへの接続に使用する TCP/IP ポート番号。
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                レプリケーションでは、Unix ソケットファイルを使用できません。 TCP/IP を使用してレプリケーションソースサーバーに接続できる必要があります。 
              </p></div><p>
              <code class="literal">MASTER_HOST</code> または <code class="literal">MASTER_PORT</code> を指定した場合、レプリカは、ソースサーバーが以前とは異なることを前提とします (オプション値が現在の値と同じであっても)。) この場合、ソースバイナリログファイルの名前と位置の古い値は適用できなくなるため、ステートメントに <code class="literal">MASTER_LOG_FILE</code> と <code class="literal">MASTER_LOG_POS</code> を指定しないと、<code class="literal">MASTER_LOG_FILE=''</code>と <code class="literal">MASTER_LOG_POS=4</code> は暗黙的に追加されます。 
            </p></dd><dt><span class="term"> <code class="literal">MASTER_PUBLIC_KEY_PATH</code> </span></dt><dd><p>
              ソースが必要とする公開キーのレプリカ側のコピーを含むファイルへのパス名を指定することで、RSA キーペアベースのパスワード交換を有効にします。 ファイルは PEM 形式である必要があります。 このオプションは、<code class="literal">sha256_password</code> または <code class="literal">caching_sha2_password</code> 認証プラグインで認証されるレプリカに適用されます。 (<code class="literal">sha256_password</code> の場合、<code class="literal">MASTER_PUBLIC_KEY_PATH</code> は、MySQL が OpenSSL を使用して構築された場合にのみ使用できます。) <code class="literal">caching_sha2_password</code> プラグイン (MySQL 8.0 のデフォルト) で認証されるレプリケーションユーザーアカウントを使用していて、セキュアな接続を使用していない場合は、このオプションまたは <code class="literal">GET_MASTER_PUBLIC_KEY=1</code> オプションを指定して、RSA 公開キーをレプリカに提供する必要があります。 
            </p></dd><dt><span class="term"> <code class="literal">MASTER_RETRY_COUNT</code> </span></dt><dd><p>
              <code class="literal">slave_net_timeout</code> システム変数によって決定される、ソースへの接続がタイムアウトした後にレプリカが行う再接続の最大試行回数を設定します。 レプリカを再接続する必要がある場合、タイムアウトの直後に最初の再試行が行われます。 試行の間隔は、<code class="literal">MASTER_CONNECT_RETRY</code> オプションで指定します。 両方のデフォルト設定が使用されている場合、レプリカは再接続試行 (<code class="literal">MASTER_CONNECT_RETRY=60</code>) の間 60 秒待機し、60 日間 (<code class="literal">MASTER_RETRY_COUNT=86400</code>) 再接続を試行し続けます。 これらの値はソースメタデータリポジトリに記録され、<code class="literal">replication_connection_configuration</code>「パフォーマンススキーマ」テーブルに表示されます。 <code class="literal">MASTER_RETRY_COUNT</code> は、<code class="option">--master-retry-count</code> サーバーの起動オプションより優先されます。 
            </p></dd><dt><span class="term"> <code class="literal">MASTER_SSL_<em class="replaceable"><code>xxx</code></em></code>, <code class="literal">MASTER_TLS_<em class="replaceable"><code>xxx</code></em></code> </span></dt><dd><p>
              レプリカが暗号化および暗号化を使用してレプリケーション接続を保護する方法を指定します。 これらのオプションは、SSL サポートなしでコンパイルされたレプリカでも変更できます。 これらはソースメタデータリポジトリに保存されますが、レプリカで SSL サポートが有効になっていない場合は無視されます。 <code class="literal">MASTER_SSL_<em class="replaceable"><code>xxx</code></em></code> および <code class="literal">MASTER_TLS_<em class="replaceable"><code>xxx</code></em></code> オプションは、<a class="xref" href="programs.html#encrypted-connection-options" title="暗号化接続のコマンドオプション">暗号化接続のコマンドオプション</a> で説明されている <code class="literal">--ssl-<em class="replaceable"><code>xxx</code></em></code> および <code class="literal">--tls-<em class="replaceable"><code>xxx</code></em></code> クライアントオプションと同じ機能を実行します。 2 つのオプションセット間の対応、および <code class="literal">MASTER_SSL_<em class="replaceable"><code>xxx</code></em></code> オプションと <code class="literal">MASTER_TLS_<em class="replaceable"><code>xxx</code></em></code> オプションを使用したセキュアな接続の設定については、<a class="xref" href="replication.html#replication-solutions-encrypted-connections" title="17.3.1 暗号化接続を使用するためのレプリケーションの設定">セクション17.3.1「暗号化接続を使用するためのレプリケーションの設定」</a> を参照してください。 
            </p></dd><dt><span class="term"> <code class="literal">MASTER_USER</code> </span></dt><dd><p>
              レプリケーションソースサーバーへの接続に使用するレプリケーションユーザーアカウントのユーザー名。
            </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
                <code class="literal">caching_sha2_password</code> プラグインで認証するレプリケーションユーザーアカウントを使用してソースに接続するには、<a class="xref" href="replication.html#replication-solutions-encrypted-connections" title="17.3.1 暗号化接続を使用するためのレプリケーションの設定">セクション17.3.1「暗号化接続を使用するためのレプリケーションの設定」</a> の説明に従ってセキュアな接続を設定するか、RSA キーペアを使用したパスワード交換をサポートするように暗号化されていない接続を有効にする必要があります。 <code class="literal">caching_sha2_password</code> 認証プラグインは、MySQL 8.0 から作成された新規ユーザーのデフォルトです (詳細は、<a class="xref" href="security.html#caching-sha2-pluggable-authentication" title="6.4.1.2 SHA-2 プラガブル認証のキャッシュ">セクション6.4.1.2「SHA-2 プラガブル認証のキャッシュ」</a> を参照)。 レプリケーション用に作成または使用するユーザーアカウントがこの認証プラグインを使用しており、セキュアな接続を使用していない場合は、正常に接続するために RSA キーペアベースのパスワード交換を有効にする必要があります。 これは、<code class="literal">MASTER_PUBLIC_KEY_PATH</code> オプションまたはこのステートメントの <code class="literal">GET_MASTER_PUBLIC_KEY=1</code> オプションを使用して実行できます。 
              </p></div><p>
              <code class="literal">MASTER_USER=''</code>を指定して空のユーザー名を設定することはできますが、レプリケーションチャネルは空のユーザー名で開始できません。 MySQL 8.0.21 より前のリリースでは、セキュリティ上の目的で以前に使用した資格証明をレプリケーションメタデータリポジトリからクリアする必要がある場合にのみ、空の <code class="literal">MASTER_USER</code> ユーザー名を設定します。 これらのリリースでは、リポジトリから空のユーザー名が読み取られた場合 (グループレプリケーションチャネルの自動再起動時など)、デフォルトのユーザー名を置換できるバグのため、後でチャネルを使用しないでください。 MySQL 8.0.21 からは、レプリケーションチャネルを開始する <code class="literal">START REPLICA | SLAVE</code> ステートメントまたは <code class="literal">START GROUP_REPLICATION</code> ステートメントを使用して常にユーザー資格証明を指定する場合、空の <code class="literal">MASTER_USER</code> ユーザー名を設定し、後でチャネルを使用できます。 このアプローチでは、レプリケーションチャネルを再起動するためにオペレータの介入が常に必要ですが、ユーザー資格証明はレプリケーションメタデータリポジトリに記録されません。 
            </p><p>
              実行中の <code class="literal">CHANGE MASTER TO</code> ステートメントのテキスト (<code class="literal">MASTER_USER</code> と <code class="literal">MASTER_PASSWORD</code> の値を含む) は、並列 <code class="literal">SHOW PROCESSLIST</code> ステートメントの出力で確認できます。 (<code class="literal">START REPLICA | SLAVE</code> ステートメントの完全なテキストは、<code class="literal">SHOW PROCESSLIST</code> にも表示されます。) 
            </p></dd><dt><span class="term"> <code class="literal">MASTER_ZSTD_COMPRESSION_LEVEL</code> </span></dt><dd><p>
              <code class="literal">zstd</code> 圧縮アルゴリズムを使用するレプリケーションソースサーバーへの接続に使用する圧縮レベル。 許可されるレベルは 1 から 22 で、大きい値は圧縮レベルの増加を示します。 デフォルトの <code class="literal">zstd</code> 圧縮レベルは 3 です。 圧縮レベルの設定は、<code class="literal">zstd</code> 圧縮を使用しない接続には影響しません。 <code class="literal">MASTER_ZSTD_COMPRESSION_LEVEL</code> は、MySQL 8.0.18 の時点で使用可能です。 詳細は、<a class="xref" href="programs.html#connection-compression-control" title="4.2.8 接続圧縮制御">セクション4.2.8「接続圧縮制御」</a>を参照してください。 
            </p></dd><dt><span class="term"> <code class="literal">NETWORK_NAMESPACE</code> </span></dt><dd><p>
              レプリケーションソースサーバーへの TCP/IP 接続に使用するネットワークネームスペース。 このオプションを省略すると、レプリカからの接続にはデフォルト (グローバル) 名前空間が使用されます。 ネットワークネームスペースのサポートを実装していないプラットフォームでは、レプリカがソースに接続しようとすると障害が発生します。 ネットワークネームスペースの詳細は、<a class="xref" href="server-administration.html#network-namespace-support" title="5.1.14 ネットワークネームスペースのサポート">セクション5.1.14「ネットワークネームスペースのサポート」</a> を参照してください。 <code class="literal">NETWORK_NAMESPACE</code> は、MySQL 8.0.22 の時点で使用可能です。 
            </p></dd><dt><span class="term"> <code class="literal">PRIVILEGE_CHECKS_USER</code> </span></dt><dd><p>
              指定されたチャネルのセキュリティコンテキストを提供するユーザーアカウントを指定します。 <code class="literal">NULL</code>(デフォルト) は、セキュリティコンテキストが使用されないことを意味します。 <code class="literal">PRIVILEGE_CHECKS_USER</code> は、MySQL 8.0.18 の時点で使用可能です。 
            </p><p>
              ユーザーアカウントのユーザー名とホスト名は、<a class="xref" href="security.html#account-names" title="6.2.4 アカウント名の指定">セクション6.2.4「アカウント名の指定」</a> で説明されている構文に従う必要があり、ユーザーは匿名ユーザー (ユーザー名が空白) または <code class="literal">CURRENT_USER</code> であってはなりません。 アカウントには、<code class="literal">REPLICATION_APPLIER</code> 権限と、チャネルでレプリケートされたトランザクションを実行するために必要な権限が必要です。 アカウントに必要な権限の詳細は、<a class="xref" href="replication.html#replication-privilege-checks" title="17.3.3 レプリケーション権限チェック">セクション17.3.3「レプリケーション権限チェック」</a> を参照してください。 レプリケーションチャネルを再起動すると、その時点から権限チェックが適用されます。 チャネルを指定せず、他のチャネルが存在しない場合は、ステートメントがデフォルトチャネルに適用されます。 
            </p><p>
              <code class="literal">PRIVILEGE_CHECKS_USER</code> が設定されており、これを強制するように <code class="literal">REQUIRE_ROW_FORMAT</code> を設定できる場合は、行ベースのバイナリロギングを使用することを強くお勧めします。 たとえば、実行中のレプリカでチャネル <code class="literal">channel_1</code> に対する権限チェックを開始するには、次のステートメントを発行します: 
            </p><pre class="programlisting">mysql&gt; STOP REPLICA | SLAVE FOR CHANNEL 'channel_1';
mysql&gt; CHANGE MASTER TO
         PRIVILEGE_CHECKS_USER = '<em class="replaceable"><code>priv_repl</code></em>'@'<em class="replaceable"><code>%.example.com</code></em>',
         REQUIRE_ROW_FORMAT = 1,
         FOR CHANNEL 'channel_1';
mysql&gt; START REPLICA | SLAVE FOR CHANNEL 'channel_1';
</pre></dd><dt><span class="term"> <code class="literal">RELAY_LOG_FILE</code>, <code class="literal">RELAY_LOG_POS</code> </span></dt><dd><p>
              次回のスレッド起動時にレプリケーション SQL スレッドがレプリカリレーログからの読取りを開始するリレーログファイル名およびそのファイル内の場所。 <code class="literal">MASTER_LOG_FILE</code> または <code class="literal">MASTER_LOG_POS</code> を使用している場合、これらのオプションは使用できません。 
            </p><p>
              <code class="literal">RELAY_LOG_FILE</code> では、絶対パスまたは相対パスのいずれかを使用でき、<code class="literal">MASTER_LOG_FILE</code> と同じベース名を使用します。 <code class="literal">RELAY_LOG_FILE</code>、<code class="literal">RELAY_LOG_POS</code> またはその両方のオプションを使用する <code class="literal">CHANGE MASTER TO</code> ステートメントは、レプリケーション SQL スレッドの停止時に実行中のレプリカで実行できます。 少なくともいずれかのレプリケーション SQL スレッドとレプリケーション I/O スレッドが実行されている場合、リレーログは保持されます。 両方のスレッドが停止すると、<code class="literal">RELAY_LOG_FILE</code> または <code class="literal">RELAY_LOG_POS</code> のいずれかが指定されていないかぎり、すべてのリレーログファイルが削除されます。 Group Replication applier チャネル (<code class="literal">group_replication_applier</code>) には I/O スレッドがなく、SQL スレッドのみがあることに注意してください。 このチャネルでは、SQL スレッドの停止時にリレーログは保持されません。 
            </p></dd><dt><span class="term"> <code class="literal">REQUIRE_ROW_FORMAT</code> </span></dt><dd><p>
              レプリケーションチャネルによる行ベースのレプリケーションイベントの処理のみを許可します。 このオプションにより、レプリケーションアプライアンスは一時テーブルの作成や <code class="literal">LOAD DATA INFILE</code> リクエストの実行などのアクションを実行できなくなり、チャネルのセキュリティが向上します。 グループレプリケーションチャネルは <code class="literal">REQUIRE_ROW_FORMAT</code> セットで自動的に作成され、これらのチャネルのオプションは変更できません。 詳細は、<a class="xref" href="replication.html#replication-privilege-checks" title="17.3.3 レプリケーション権限チェック">セクション17.3.3「レプリケーション権限チェック」</a>を参照してください。 <code class="literal">REQUIRE_ROW_FORMAT</code> は、MySQL 8.0.19 の時点で使用可能です。 
            </p></dd><dt><span class="term"> <code class="literal">REQUIRE_TABLE_PRIMARY_KEY_CHECK</code> </span></dt><dd><p>
              レプリカが主キーチェック用に独自のポリシーを選択できるようにします。 レプリケーションチャネルのオプションが <code class="literal">ON</code> に設定されている場合、レプリカはレプリケーション操作で常に <code class="literal">sql_require_primary_key</code> システム変数に値 <code class="literal">ON</code> を使用し、主キーが必要です。 このオプションが <code class="literal">OFF</code> に設定されている場合、レプリカはレプリケーション操作で <code class="literal">sql_require_primary_key</code> システム変数に常に値 <code class="literal">OFF</code> を使用するため、ソースで必要な場合でも主キーは必要ありません。 <code class="literal">REQUIRE_TABLE_PRIMARY_KEY_CHECK</code> オプションが <code class="literal">STREAM</code>(デフォルト) に設定されている場合、レプリカは各トランザクションのソースからレプリケートされた値を使用します。 <code class="literal">REQUIRE_TABLE_PRIMARY_KEY_CHECK</code> は、MySQL 8.0.20 の時点で使用可能です。 
            </p><p>
              マルチソースレプリケーションの場合、<code class="literal">REQUIRE_TABLE_PRIMARY_KEY_CHECK</code> を <code class="literal">ON</code> または <code class="literal">OFF</code> に設定すると、レプリカは異なるソースのレプリケーションチャネル間で動作を正規化し、<code class="literal">sql_require_primary_key</code> システム変数の一貫性のある設定を維持できます。 <code class="literal">ON</code> を使用すると、複数のソースが同じテーブルセットを更新する場合に、主キーの偶発的な損失から保護されます。 <code class="literal">OFF</code> を使用すると、主キーを操作できるソースを、操作できないソースと連携させることができます。 
            </p><p>
              <code class="literal">PRIVILEGE_CHECKS_USER</code> が設定されている場合、<code class="literal">REQUIRE_TABLE_PRIMARY_KEY_CHECK</code> を <code class="literal">ON</code> または <code class="literal">OFF</code> に設定することは、制限付きセッション変数を設定するためのセッション管理レベルの権限がユーザーアカウントに必要ないことを意味します。これは、<code class="literal">sql_require_primary_key</code> の値を各トランザクションのソース設定と一致するように変更するために必要です。 詳細は、<a class="xref" href="replication.html#replication-privilege-checks" title="17.3.3 レプリケーション権限チェック">セクション17.3.3「レプリケーション権限チェック」</a>を参照してください。 
            </p></dd><dt><span class="term"> <code class="literal">SOURCE_CONNECTION_AUTO_FAILOVER</code> </span></dt><dd><p>
              1 つ以上の代替レプリケーションサーバーが使用可能な場合 (レプリケートされたデータを共有する複数の MySQL サーバーまたはサーバーグループが存在する場合)、レプリケーションチャネルの非同期接続フェイルオーバーメカニズムをアクティブ化します。 <code class="literal">SOURCE_CONNECTION_AUTO_FAILOVER</code> は、MySQL 8.0.22 の時点で使用可能です。 非同期接続フェイルオーバーメカニズムは、<code class="literal">MASTER_CONNECT_RETRY</code> および <code class="literal">MASTER_RETRY_COUNT</code> によって制御されている再接続試行を使い果たした後に引き継ぎます。 <code class="literal">asynchronous_connection_failover_add_source</code> および <code class="literal">asynchronous_connection_failover_delete_source</code> UDF を使用して管理する、指定されたソースリストから選択された代替ソースにレプリカを再接続します。 サーバーの管理対象グループを追加および削除するには、かわりに <code class="literal">asynchronous_connection_failover_add_managed</code> および <code class="literal">asynchronous_connection_failover_delete_managed</code> UDF を使用します。 詳細は、<a class="xref" href="replication.html#replication-asynchronous-connection-failover" title="17.4.9 非同期接続フェイルオーバーによるソースの切替え">セクション17.4.9「非同期接続フェイルオーバーによるソースの切替え」</a>を参照してください。 
            </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    GTID 自動配置が使用中 (<code class="literal">MASTER_AUTO_POSITION = 1</code>) の場合にのみ、<code class="literal">SOURCE_CONNECTION_AUTO_FAILOVER = 1</code> を設定できます。
                  </p></li><li class="listitem"><p>
                    <code class="literal">SOURCE_CONNECTION_AUTO_FAILOVER = 1</code> を設定する場合、一時的なネットワークの停止が原因で接続障害が発生した場合に、<code class="literal">MASTER_RETRY_COUNT</code> および <code class="literal">MASTER_CONNECT_RETRY</code> を、同じソースでの数回の再試行のみを許可する最小数に設定します。 そうしないと、非同期接続フェイルオーバーメカニズムをすぐにアクティブ化できません。 適切な値は <code class="literal">MASTER_RETRY_COUNT=3</code> と <code class="literal">MASTER_CONNECT_RETRY=10</code> です。これにより、レプリカは 10 秒間隔で接続を 3 回再試行します。 
                  </p></li><li class="listitem"><p>
                    <code class="literal">SOURCE_CONNECTION_AUTO_FAILOVER = 1</code> を設定する場合、レプリケーションメタデータリポジトリには、レプリケーションチャネルのソースリスト上のすべてのサーバーへの接続に使用できるレプリケーションユーザーアカウントの資格証明が含まれている必要があります。 これらの資格証明は、<code class="literal">MASTER_USER</code> および <code class="literal">MASTER_PASSWORD</code> オプションを指定した <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントを使用して設定できます。 詳細は、<a class="xref" href="replication.html#replication-asynchronous-connection-failover" title="17.4.9 非同期接続フェイルオーバーによるソースの切替え">セクション17.4.9「非同期接続フェイルオーバーによるソースの切替え」</a>を参照してください。 
                  </p></li></ol></div></div></dd></dl></div><p>
        次の表は、文字列値のオプションに許可される最大長を示しています。
      </p><div class="informaltable"><table summary="The maximum permissible length for CHANGE MASTER TO string-valued options."><col style="width: 50%"><col style="width: 50%"><thead><tr>
            <th>オプション</th>
            <th>最大長</th>
          </tr></thead><tbody><tr>
            <td><code class="literal">MASTER_HOST</code></td>
            <td>255 (MySQL 8.0.17 より前の 60)</td>
          </tr><tr>
            <td><code class="literal">MASTER_USER</code></td>
            <td>96</td>
          </tr><tr>
            <td><code class="literal">MASTER_PASSWORD</code></td>
            <td>32</td>
          </tr><tr>
            <td><code class="literal">MASTER_LOG_FILE</code></td>
            <td>511</td>
          </tr><tr>
            <td><code class="literal">RELAY_LOG_FILE</code></td>
            <td>511</td>
          </tr><tr>
            <td><code class="literal">MASTER_SSL_CA</code></td>
            <td>511</td>
          </tr><tr>
            <td><code class="literal">MASTER_SSL_CAPATH</code></td>
            <td>511</td>
          </tr><tr>
            <td><code class="literal">MASTER_SSL_CERT</code></td>
            <td>511</td>
          </tr><tr>
            <td><code class="literal">MASTER_SSL_CRL</code></td>
            <td>511</td>
          </tr><tr>
            <td><code class="literal">MASTER_SSL_CRLPATH</code></td>
            <td>511</td>
          </tr><tr>
            <td><code class="literal">MASTER_SSL_KEY</code></td>
            <td>511</td>
          </tr><tr>
            <td><code class="literal">MASTER_SSL_CIPHER</code></td>
            <td>511</td>
          </tr><tr>
            <td><code class="literal">MASTER_TLS_VERSION</code></td>
            <td>511</td>
          </tr><tr>
            <td><code class="literal">MASTER_TLS_CIPHERSUITES</code></td>
            <td>4000</td>
          </tr><tr>
            <td><code class="literal">MASTER_PUBLIC_KEY_PATH</code></td>
            <td>511</td>
          </tr><tr>
            <td><code class="literal">MASTER_COMPRESSION_ALGORITHMS</code></td>
            <td>99</td>
          </tr><tr>
            <td><code class="literal">NETWORK_NAMESPACE</code></td>
            <td>64</td>
          </tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="change-replication-filter"></a>13.4.2.2 CHANGE REPLICATION FILTER ステートメント</h4></div></div></div><a class="indexterm" name="idm45826995215440"></a><pre class="programlisting">CHANGE REPLICATION FILTER <em class="replaceable"><code>filter</code></em>[, <em class="replaceable"><code>filter</code></em>]
	[, ...] [FOR CHANNEL <em class="replaceable"><code>channel</code></em>]

<em class="replaceable"><code>filter</code></em>: {
    REPLICATE_DO_DB = (<em class="replaceable"><code>db_list</code></em>)
  | REPLICATE_IGNORE_DB = (<em class="replaceable"><code>db_list</code></em>)
  | REPLICATE_DO_TABLE = (<em class="replaceable"><code>tbl_list</code></em>)
  | REPLICATE_IGNORE_TABLE = (<em class="replaceable"><code>tbl_list</code></em>)
  | REPLICATE_WILD_DO_TABLE = (<em class="replaceable"><code>wild_tbl_list</code></em>)
  | REPLICATE_WILD_IGNORE_TABLE = (<em class="replaceable"><code>wild_tbl_list</code></em>)
  | REPLICATE_REWRITE_DB = (<em class="replaceable"><code>db_pair_list</code></em>)
}

<em class="replaceable"><code>db_list</code></em>:
    <em class="replaceable"><code>db_name</code></em>[, <em class="replaceable"><code>db_name</code></em>][, ...]

<em class="replaceable"><code>tbl_list</code></em>:
    <em class="replaceable"><code>db_name.table_name</code></em>[, <em class="replaceable"><code>db_name.table_name</code></em>][, ...]
<em class="replaceable"><code>wild_tbl_list</code></em>:
    '<em class="replaceable"><code>db_pattern.table_pattern</code></em>'[, '<em class="replaceable"><code>db_pattern.table_pattern</code></em>'][, ...]

<em class="replaceable"><code>db_pair_list</code></em>:
    (<em class="replaceable"><code>db_pair</code></em>)[, (<em class="replaceable"><code>db_pair</code></em>)][, ...]

<em class="replaceable"><code>db_pair</code></em>:
    <em class="replaceable"><code>from_db</code></em>, <em class="replaceable"><code>to_db</code></em>
</pre><p>
        <code class="literal">CHANGE REPLICATION FILTER</code> は、<code class="option">--replicate-do-db</code> や <code class="option">--replicate-wild-ignore-table</code> などのレプリケーションフィルタリングオプションを使用してレプリカ <span class="command"><strong>mysqld</strong></span> を起動するのと同じ方法で、レプリカに 1 つ以上のレプリケーションフィルタリングルールを設定します。 サーバーオプションとは異なり、このステートメントを有効にするためにサーバーを再起動する必要はなく、まず <code class="literal">STOP REPLICA | SLAVE SQL_THREAD</code> を使用してレプリケーション SQL スレッドを停止します (その後、<code class="literal">START REPLICA | SLAVE SQL_THREAD</code> を使用して再起動します)。 <code class="literal">CHANGE REPLICATION FILTER</code> には、<code class="literal">REPLICATION_SLAVE_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。 <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を使用すると、レプリケーションフィルタをマルチソースレプリカなどのレプリケーションチャネルに固有にできます。 特定の <code class="literal">FOR CHANNEL</code> 句なしで適用されたフィルタはグローバルフィルタとみなされ、すべてのレプリケーションチャネルに適用されます。 
      </p><p>
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            グループレプリケーション用に構成された MySQL サーバーインスタンスでは、グローバルレプリケーションフィルタを設定できません。これは、一部のサーバーでトランザクションをフィルタすると、グループが一貫性のある状態で承諾に到達できなくなるためです。 グループメンバーがグループ外のソースへのレプリカとしても機能する場合など、グループレプリケーションに直接関与しないレプリケーションチャネルにチャネル固有のレプリケーションフィルタを設定できます。 <code class="literal">group_replication_applier</code> または <code class="literal">group_replication_recovery</code> チャネルでは設定できません。 
          </p></div><p>
      </p><p>
        次のリストに、<code class="literal">CHANGE REPLICATION FILTER</code> のオプションと、それらが <code class="option">--replicate-*</code> サーバーのオプションとどのように関連しているかを示します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">REPLICATE_DO_DB</code>: データベース名に基づいた更新を含めます。 <code class="option">--replicate-do-db</code> と同等です。 
          </p></li><li class="listitem"><p>
            <code class="literal">REPLICATE_IGNORE_DB</code>: データベース名に基づいて更新を除外します。 <code class="option">--replicate-ignore-db</code> と同等です。 
          </p></li><li class="listitem"><p>
            <code class="literal">REPLICATE_DO_TABLE</code>: テーブル名に基づく更新を含めます。 <code class="option">--replicate-do-table</code> と同等です。 
          </p></li><li class="listitem"><p>
            <code class="literal">REPLICATE_IGNORE_TABLE</code>: テーブル名に基づいて更新を除外します。 <code class="option">--replicate-ignore-table</code> と同等です。 
          </p></li><li class="listitem"><p>
            <code class="literal">REPLICATE_WILD_DO_TABLE</code>: ワイルドカードパターンマッチングテーブル名に基づく更新を含めます。 <code class="option">--replicate-wild-do-table</code> と同等です。 
          </p></li><li class="listitem"><p>
            <code class="literal">REPLICATE_WILD_IGNORE_TABLE</code>: ワイルドカードパターンマッチングテーブル名に基づいて更新を除外します。 <code class="option">--replicate-wild-ignore-table</code> と同等です。 
          </p></li><li class="listitem"><p>
            <code class="literal">REPLICATE_REWRITE_DB</code>: レプリカ上の新しい名前をソース上の指定されたデータベースに置き換えた後、レプリカで更新を実行します。 <code class="option">--replicate-rewrite-db</code> と同等です。 
          </p></li></ul></div><p>
        <code class="literal">REPLICATE_DO_DB</code> および <code class="literal">REPLICATE_IGNORE_DB</code> フィルタの正確な影響は、ステートメントベースレプリケーションと行ベースレプリケーションのどちらが有効かによって異なります。 詳しくは<a class="xref" href="replication.html#replication-rules" title="17.2.5 サーバーがレプリケーションフィルタリングルールをどのように評価するか">セクション17.2.5「サーバーがレプリケーションフィルタリングルールをどのように評価するか」</a>,をご覧ください。 
      </p><p>
        次に示すように、ルールをカンマで区切ることで、単一の <code class="literal">CHANGE REPLICATION FILTER</code> ステートメントに複数のレプリケーションフィルタリングルールを作成できます:
      </p><pre class="programlisting">CHANGE REPLICATION FILTER
    REPLICATE_DO_DB = (d1), REPLICATE_IGNORE_DB = (d2);
</pre><p>
        前述のステートメントを発行することは、<code class="option">--replicate-do-db=d1</code> <code class="option">--replicate-ignore-db=d2</code> オプションを指定してレプリカ <span class="command"><strong>mysqld</strong></span> を起動することと同じです。
      </p><p>
        複数のレプリケーションチャネルを使用して異なるソースからのトランザクションを処理するマルチソースレプリカでは、<code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を使用してレプリケーションチャネルにレプリケーションフィルタを設定します:
      </p><pre class="programlisting">CHANGE REPLICATION FILTER REPLICATE_DO_DB = (d1) FOR CHANNEL channel_1;</pre><p>
        これにより、チャネル固有のレプリケーションフィルタを作成して、選択したデータをソースから除外できます。 <code class="literal">FOR CHANNEL</code> 句が指定されている場合、レプリケーションフィルタステートメントはそのレプリケーションチャネルで動作し、指定されたレプリケーションフィルタと同じフィルタタイプを持つ既存のレプリケーションフィルタを削除して、指定されたフィルタに置き換えます。 ステートメントに明示的にリストされていないフィルタタイプは変更されません。 構成されていないレプリケーションチャネルに対して発行された場合、ステートメントは <span class="errortext">ER_SLAVE_CONFIGURATION</span> エラーで失敗します。 グループレプリケーションチャネルに対して発行すると、ステートメントは <span class="errortext">ER_SLAVE_CHANNEL_OPERATION_NOT_ALLOWED</span> エラーで失敗します。 
      </p><p>
        複数のレプリケーションチャネルが構成されているレプリカでは、<code class="literal">FOR CHANNEL</code> 句を指定せずに <code class="literal">CHANGE REPLICATION FILTER</code> を発行すると、構成されているすべてのレプリケーションチャネルおよびグローバルレプリケーションフィルタに対してレプリケーションフィルタが構成されます。 すべてのフィルタタイプについて、フィルタタイプがステートメントにリストされている場合、そのタイプの既存のフィルタルールは、最後に発行されたステートメントで指定されたフィルタルールに置き換えられます。それ以外の場合は、フィルタタイプの古い値が保持されます。 詳細は、<a class="xref" href="replication.html#replication-rules-channel-based-filters" title="17.2.5.4 レプリケーションチャネルベースのフィルタ">セクション17.2.5.4「レプリケーションチャネルベースのフィルタ」</a> を参照してください。 
      </p><p>
        同じフィルタリングルールが複数回指定されている場合、実際には <span class="emphasis"><em>last</em></span> のそのようなルールのみが使用されます。 たとえば、最初のステートメントの最初の <code class="literal">REPLICATE_DO_DB</code> ルールは無視されるため、ここに示す 2 つのステートメントはまったく同じ効果があります: 
      </p><pre class="programlisting">CHANGE REPLICATION FILTER
    REPLICATE_DO_DB = (db1, db2), REPLICATE_DO_DB = (db3, db4);

CHANGE REPLICATION FILTER
    REPLICATE_DO_DB = (db3, db4);
</pre><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注意</div><p>
          この動作は、同じオプションを複数回指定すると複数のフィルタルールが作成される <code class="option">--replicate-*</code> フィルタオプションとは異なります。
        </p></div><p>
        特殊文字を含まないテーブルおよびデータベースの名前は引用符で囲む必要はありません。 <code class="literal">REPLICATION_WILD_TABLE</code> および <code class="literal">REPLICATION_WILD_IGNORE_TABLE</code> で使用される値は文字列式で、(特殊な) ワイルドカード文字が含まれている可能性があるため、引用符で囲む必要があります。 これを次のステートメントの例に示します: 
      </p><pre class="programlisting">CHANGE REPLICATION FILTER
    REPLICATE_WILD_DO_TABLE = ('db1.old%');

CHANGE REPLICATION FILTER
    REPLICATE_WILD_IGNORE_TABLE = ('db1.new%', 'db2.new%');
</pre><p>
        <code class="literal">REPLICATE_REWRITE_DB</code> で使用される値は、データベース名の<span class="emphasis"><em>ペア</em></span>を表します。このような値はそれぞれカッコで囲む必要があります。 次のステートメントは、ソースのデータベース <code class="literal">db1</code> で発生したステートメントをレプリカのデータベース <code class="literal">db2</code> にリライトします: 
      </p><pre class="programlisting">CHANGE REPLICATION FILTER REPLICATE_REWRITE_DB = ((db1, db2));
</pre><p>
        前述のステートメントには、データベース名のペアを囲むカッコと、リスト全体を囲むカッコの 2 つのセットが含まれています。 これは、データベース <code class="literal">dbA</code> を <code class="literal">dbB</code> にリライトし、データベース <code class="literal">dbC</code> を <code class="literal">dbD</code> にリライトするという 2 つの <code class="literal">rewrite-db</code> ルールを作成する次の例では、より簡単に見られます: 
      </p><pre class="programlisting">CHANGE REPLICATION FILTER
  REPLICATE_REWRITE_DB = ((dbA, dbB), (dbC, dbD));
</pre><p>
        <code class="literal">CHANGE REPLICATION FILTER</code> ステートメントでは、ステートメントの影響を受けるフィルタタイプおよびレプリケーションチャネルのレプリケーションフィルタリングルールのみが置換され、他のルールおよびチャネルは変更されません。 特定のタイプのすべてのフィルタの設定を解除する場合は、次の例に示すように、フィルタ値を明示的に空のリストに設定します。これにより、既存のすべての <code class="literal">REPLICATE_DO_DB</code> および <code class="literal">REPLICATE_IGNORE_DB</code> ルールが削除されます: 
      </p><pre class="programlisting">CHANGE REPLICATION FILTER
    REPLICATE_DO_DB = (), REPLICATE_IGNORE_DB = ();
</pre><p>
        この方法でフィルタを空に設定すると、既存のすべてのルールが削除され、新しいルールは作成されず、mysqld の起動時にコマンド行または構成ファイルで <code class="option">--replicate-*</code> オプションを使用して設定されたルールは復元されません。
      </p><p>
        <code class="literal">RESET REPLICA | SLAVE ALL</code> ステートメントは、ステートメントによって削除されたチャネルに設定されたチャネル固有のレプリケーションフィルタを削除します。 削除されたチャネルが再作成されると、レプリカに指定されたグローバルレプリケーションフィルタがそれらにコピーされ、チャネル固有のレプリケーションフィルタは適用されません。 
      </p><p>
        詳細は、<a class="xref" href="replication.html#replication-rules" title="17.2.5 サーバーがレプリケーションフィルタリングルールをどのように評価するか">セクション17.2.5「サーバーがレプリケーションフィルタリングルールをどのように評価するか」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="change-replication-source-to"></a>13.4.2.3 CHANGE REPLICATION SOURCE TO ステートメント</h4></div></div></div><a class="indexterm" name="idm45826995112640"></a><pre class="programlisting">CHANGE REPLICATION SOURCE TO <em class="replaceable"><code>option</code></em> [, <em class="replaceable"><code>option</code></em>] ... [ <em class="replaceable"><code>channel_option</code></em> ]

<em class="replaceable"><code>option</code></em>: {
    SOURCE_BIND = '<em class="replaceable"><code>interface_name</code></em>'
  | SOURCE_HOST = '<em class="replaceable"><code>host_name</code></em>'
  | SOURCE_USER = '<em class="replaceable"><code>user_name</code></em>'
  | SOURCE_PASSWORD = '<em class="replaceable"><code>password</code></em>'
  | SOURCE_PORT = <em class="replaceable"><code>port_num</code></em>
  | PRIVILEGE_CHECKS_USER = {'<em class="replaceable"><code>account</code></em>' | NULL}
  | REQUIRE_ROW_FORMAT = {0|1}
  | REQUIRE_TABLE_PRIMARY_KEY_CHECK = {STREAM | ON | OFF}
  | ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS = {OFF | LOCAL | <em class="replaceable"><code>uuid</code></em>}
  | SOURCE_LOG_FILE = '<em class="replaceable"><code>source_log_name</code></em>'
  | SOURCE_LOG_POS = <em class="replaceable"><code>source_log_pos</code></em>
  | SOURCE_AUTO_POSITION = {0|1}
  | RELAY_LOG_FILE = '<em class="replaceable"><code>relay_log_name</code></em>'
  | RELAY_LOG_POS = <em class="replaceable"><code>relay_log_pos</code></em>
  | SOURCE_HEARTBEAT_PERIOD = <em class="replaceable"><code>interval</code></em>
  | SOURCE_CONNECT_RETRY = <em class="replaceable"><code>interval</code></em>
  | SOURCE_RETRY_COUNT = <em class="replaceable"><code>count</code></em>
  | SOURCE_CONNECTION_AUTO_FAILOVER = {0|1}
  | SOURCE_DELAY = <em class="replaceable"><code>interval</code></em>
  | SOURCE_COMPRESSION_ALGORITHMS = '<em class="replaceable"><code>value</code></em>'
  | SOURCE_ZSTD_COMPRESSION_LEVEL = <em class="replaceable"><code>level</code></em>
  | SOURCE_SSL = {0|1}
  | SOURCE_SSL_CA = '<em class="replaceable"><code>ca_file_name</code></em>'
  | SOURCE_SSL_CAPATH = '<em class="replaceable"><code>ca_directory_name</code></em>'
  | SOURCE_SSL_CERT = '<em class="replaceable"><code>cert_file_name</code></em>'
  | SOURCE_SSL_CRL = '<em class="replaceable"><code>crl_file_name</code></em>'
  | SOURCE_SSL_CRLPATH = '<em class="replaceable"><code>crl_directory_name</code></em>'
  | SOURCE_SSL_KEY = '<em class="replaceable"><code>key_file_name</code></em>'
  | SOURCE_SSL_CIPHER = '<em class="replaceable"><code>cipher_list</code></em>'
  | SOURCE_SSL_VERIFY_SERVER_CERT = {0|1}
  | SOURCE_TLS_VERSION = '<em class="replaceable"><code>protocol_list</code></em>'
  | SOURCE_TLS_CIPHERSUITES = '<em class="replaceable"><code>ciphersuite_list</code></em>'
  | SOURCE_PUBLIC_KEY_PATH = '<em class="replaceable"><code>key_file_name</code></em>'
  | GET_SOURCE_PUBLIC_KEY = {0|1}
  | NETWORK_NAMESPACE = '<em class="replaceable"><code>namespace</code></em>'
  | IGNORE_SERVER_IDS = (<em class="replaceable"><code>server_id_list</code></em>)
}

<em class="replaceable"><code>channel_option</code></em>:
    FOR CHANNEL <em class="replaceable"><code>channel</code></em>

<em class="replaceable"><code>server_id_list</code></em>:
    [<em class="replaceable"><code>server_id</code></em> [, <em class="replaceable"><code>server_id</code></em>] ... ]
</pre><p>
        <code class="literal">CHANGE REPLICATION SOURCE TO</code> は、レプリカサーバーがソースへの接続およびソースからのデータの読取りに使用するパラメータを変更します。 また、レプリケーションメタデータリポジトリの内容も更新されます (<a class="xref" href="replication.html#replica-logs" title="17.2.4 リレーログおよびレプリケーションメタデータリポジトリ">セクション17.2.4「リレーログおよびレプリケーションメタデータリポジトリ」</a> を参照)。 MySQL 8.0.23 から、<code class="literal">CHANGE MASTER TO</code> のかわりに <code class="literal">CHANGE REPLICATION SOURCE TO</code> を使用します。これは、そのリリースから非推奨になりました。 MySQL 8.0.23 より前のリリースでは、<code class="literal">CHANGE MASTER TO</code> を使用します。 
      </p><p>
        レプリケーション SQL スレッドおよびレプリケーション I/O スレッドの状態に応じて、最初に停止せずに、実行中のレプリカに対して <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントを発行できます。 このような使用を制御するルールは、このセクションの後半で説明します。 <code class="literal">CHANGE REPLICATION SOURCE TO</code> には、<code class="literal">REPLICATION_SLAVE_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。 
      </p><p>
        マルチスレッドのレプリカを使用する場合 (つまり、<code class="literal">slave_parallel_workers</code> が 0 より大きい場合)、レプリカを停止すると、レプリカが意図的に停止されたかどうかに関係なく、リレーログから実行された一連のトランザクションで<span class="quote">「<span class="quote">「ギャップ」</span>」</span>が発生する可能性があります。 このようなギャップが存在する場合、<code class="literal">CHANGE REPLICATION SOURCE TO</code> の発行は失敗します。 この状況の解決策は、ギャップを確実に閉じる <code class="literal">START REPLICA UNTIL SQL_AFTER_MTS_GAPS</code> を発行することです。 
      </p><p>
        オプションの <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を使用すると、ステートメントが適用されるレプリケーションチャネルの名前を指定できます。 <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を指定すると、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントが特定のレプリケーションチャネルに適用され、新しいチャネルの追加または既存のチャネルの変更に使用されます。 たとえば、<code class="literal">channel2</code> という新しいチャネルを追加するには、次のようにします: 
      </p><pre class="programlisting">CHANGE REPLICATION SOURCE TO SOURCE_HOST=host1, SOURCE_PORT=3002 FOR CHANNEL 'channel2'</pre><p>
        句が指定されておらず、追加のチャネルが存在しない場合、ステートメントはデフォルトチャネルに適用されます。
      </p><p>
        複数のレプリケーションチャネルを使用する場合、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントで <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を使用してチャネルを指定しないと、エラーが発生します。 詳しくは<a class="xref" href="replication.html#replication-channels" title="17.2.2 レプリケーションチャネル">セクション17.2.2「レプリケーションチャネル」</a>をご覧ください。 
      </p><p>
        <code class="literal">SOURCE_HOST</code> およびその他の <code class="literal">CHANGE REPLICATION SOURCE TO</code> オプションに使用される値では、改行 (<code class="literal">\n</code> または <code class="literal">0x0A</code>) 文字がチェックされます。 このような文字がこれらの値に存在すると、<code class="literal">ER_MASTER_INFO</code> でステートメントが失敗します。 
      </p><p>
        <code class="literal">CHANGE REPLICATION SOURCE TO</code> を起動すると、<code class="literal">SOURCE_HOST</code>, <code class="literal">SOURCE_PORT</code>, <code class="literal">SOURCE_LOG_FILE</code> および <code class="literal">SOURCE_LOG_POS</code> の以前の値が、実行前のレプリカ状態に関するその他の情報とともにエラーログに書き込まれます。
      </p><p>
        <code class="literal">CHANGE REPLICATION SOURCE TO</code> では、進行中のトランザクションが暗黙的にコミットされます。 <a class="xref" href="sql-statements.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。 
      </p><p>
        <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントの一部のオプションでは、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (およびその後の <code class="literal">START REPLICA</code> ステートメント) を発行する前に、<code class="literal">STOP REPLICA</code> ステートメントを発行する必要があります。 場合によっては、レプリケーション SQL スレッドまたはレプリケーション I/O スレッドのどちらか一方のみを停止する必要があります: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            SQL スレッドが停止すると、レプリケーション I/O スレッドが実行されている場合でも、<code class="literal">RELAY_LOG_FILE</code>、<code class="literal">RELAY_LOG_POS</code> および <code class="literal">SOURCE_DELAY</code> オプションの任意の組合せを使用して <code class="literal">CHANGE REPLICATION SOURCE TO</code> を実行できます。 I/O スレッドの実行中は、このステートメントでほかのオプションを使用できません。 
          </p></li><li class="listitem"><p>
            I/O スレッドが停止すると、SQL スレッドが実行されている場合でも、このステートメント (任意の組合せで) <span class="emphasis"><em>except</em></span> <code class="literal">RELAY_LOG_FILE</code>, <code class="literal">RELAY_LOG_POS</code>, <code class="literal">SOURCE_DELAY</code> または <code class="literal">SOURCE_AUTO_POSITION = 1</code> のオプションを使用して <code class="literal">CHANGE REPLICATION SOURCE TO</code> を実行できます。
          </p></li><li class="listitem"><p>
            <code class="literal">SOURCE_AUTO_POSITION = 1</code> または <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> を使用する <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントを発行する前に、SQL スレッドと I/O スレッドの両方を停止する必要があります。
          </p></li></ul></div><p>
        <code class="literal">SHOW REPLICA STATUS</code> を使用して、レプリケーション SQL スレッドおよびレプリケーション I/O スレッドの現在の状態を確認できます。 Group Replication applier チャネル (<code class="literal">group_replication_applier</code>) には I/O スレッドがなく、SQL スレッドのみがあることに注意してください。 
      </p><p>
        詳細は、<a class="xref" href="replication.html#replication-solutions-switch" title="17.4.8 フェイルオーバー中のソースの切替え">セクション17.4.8「フェイルオーバー中のソースの切替え」</a>を参照してください。
      </p><p>
        ステートメントベースレプリケーションおよび一時テーブルを使用している場合は、<code class="literal">STOP REPLICA</code> ステートメントのあとの <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントがレプリカ上の一時テーブルの背後に残る可能性があります。 これが発生するたびに警告 (<code class="literal">ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO</code>) が発行されるようになりました。 このような場合は、このような <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントを実行する前に、<code class="literal">Slave_open_temp_tables</code> システムステータス変数の値が 0 であることを確認することで回避できます。 
      </p><p>
        <code class="literal">CHANGE REPLICATION SOURCE TO</code> は、ソースのスナップショットがあり、スナップショットの時刻に対応するソースバイナリログ座標を記録している場合にレプリカを設定する際に役立ちます。 スナップショットをレプリカにロードしてソースと同期した後、レプリカで <code class="literal">CHANGE REPLICATION SOURCE TO SOURCE_LOG_FILE='<em class="replaceable"><code>log_name</code></em>', SOURCE_LOG_POS=<em class="replaceable"><code>log_pos</code></em></code> を実行して、レプリカがソースバイナリログの読取りを開始する座標を指定できます。 
      </p><p>
        次の例では、レプリカが使用するソースサーバーを変更し、レプリカが読取りを開始するソースバイナリログ座標を確立します:
      </p><pre class="programlisting">CHANGE REPLICATION SOURCE TO
  SOURCE_HOST='source2.example.com',
  SOURCE_USER='replication',
  SOURCE_PASSWORD='<em class="replaceable"><code>password</code></em>',
  SOURCE_PORT=3306,
  SOURCE_LOG_FILE='source2-bin.001',
  SOURCE_LOG_POS=4,
  SOURCE_CONNECT_RETRY=10;
</pre><p>
        次の例は、使用される頻度の低い操作を示しています。 これは、なんらかの理由で再実行するリレーログファイルがレプリカに存在する場合に使用されます。 これを行うには、ソースにアクセスできる必要はありません。 <code class="literal">CHANGE REPLICATION SOURCE TO</code> のみを使用し、SQL スレッド (<code class="literal">START REPLICA SQL_THREAD</code>) を起動する必要があります: 
      </p><pre class="programlisting">CHANGE REPLICATION SOURCE TO
  RELAY_LOG_FILE='replica-relay-bin.006',
  RELAY_LOG_POS=4025;
</pre><p>
        <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントで指定しないオプションは、次の説明に示す場合を除き、その値を保持します。 そのため、ほとんどの場合、変更されないオプションを指定する必要はありません。 
      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"> <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> </span></dt><dd><p>
              レプリケーションチャネルが GTID を持たないレプリケートされたトランザクションに GTID を割り当て、GTID ベースのレプリケーションを使用しないソースから使用するレプリカへのレプリケーションを有効にします。 マルチソースレプリカの場合、<code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> を使用するチャネルと使用しないチャネルを混在させることができます。 デフォルトは <code class="literal">OFF</code> で、この機能は使用されません。 
            </p><p>
              <code class="literal">LOCAL</code> は、レプリカ独自の UUID (<code class="literal">server_uuid</code> 設定) を含む GTID を割り当てます。<code class="literal"><em class="replaceable"><code>uuid</code></em></code> は、レプリケーションソースサーバーの <code class="literal">server_uuid</code> 設定など、指定された UUID を含む GTID を割り当てます。 非ローカル UUID を使用すると、レプリカで発生したトランザクションと、ソースで発生したトランザクション、およびマルチソースレプリカの場合は異なるソースで発生したトランザクションを区別できます。 選択した UUID は、レプリカ自体での使用にのみ意味があります。 ソースによって送信されたトランザクションのいずれかに GTID がすでにある場合、その GTID は保持されます。 
            </p><p>
              Group Replication に固有のチャネルでは <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> を使用できませんが、Group Replication グループメンバーであるサーバーインスタンス上の別のソースの非同期レプリケーションチャネルでは使用できます。 その場合、GTID を作成するための UUID として Group Replication グループ名を指定しないでください。 
            </p><p>
              <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> を <code class="literal">LOCAL</code> または <code class="literal"><em class="replaceable"><code>uuid</code></em></code> に設定するには、レプリカに <code class="literal">gtid_mode=ON</code> が設定されている必要があり、後で変更することはできません。 このオプションは、バイナリログファイルの位置ベースのレプリケーションを持つソースで使用されるため、チャネルに <code class="literal">MASTER_AUTO_POSITION=1</code> を設定することはできません。 このオプションを設定する前に、レプリケーション SQL スレッドとレプリケーション I/O スレッドの両方を停止する必要があります。 
            </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
                フェイルオーバーが必要な場合、どのチャネルでも <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> を使用して設定されたレプリカを昇格させてレプリケーションサーバーを置き換えることはできず、レプリカから作成されたバックアップを使用してレプリケーションサーバーをリストアすることはできません。 同じ制限が、任意のチャネルで <code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS</code> を使用する他のレプリカの置換またはリストアにも適用されます。 
              </p></div><p>
              その他の制限および詳細は、<a class="xref" href="replication.html#replication-gtids-assign-anon" title="17.1.3.6 GTID のないソースから GTID のあるレプリカへのレプリケーション">セクション17.1.3.6「GTID のないソースから GTID のあるレプリカへのレプリケーション」</a> を参照してください。
            </p></dd><dt><span class="term"> <code class="literal">GET_SOURCE_PUBLIC_KEY</code> </span></dt><dd><p>
              ソースから公開キーをリクエストすることで、RSA キーペアベースのパスワード交換を有効にします。 このオプションは、<code class="literal">caching_sha2_password</code> 認証プラグインで認証されるレプリカに適用されます。 このプラグインを使用して認証されるアカウントによる接続の場合、ソースはリクエストされないかぎり公開キーを送信しないため、クライアントでリクエストまたは指定する必要があります。 <code class="literal">SOURCE_PUBLIC_KEY_PATH</code> が指定され、有効な公開キーファイルが指定されている場合は、<code class="literal">GET_SOURCE_PUBLIC_KEY</code> よりも優先されます。 <code class="literal">caching_sha2_password</code> プラグイン (MySQL 8.0 のデフォルト) で認証されるレプリケーションユーザーアカウントを使用していて、セキュアな接続を使用していない場合は、このオプションまたは <code class="literal">SOURCE_PUBLIC_KEY_PATH</code> オプションを指定して、RSA 公開キーをレプリカに提供する必要があります。 
            </p></dd><dt><span class="term"> <code class="literal">IGNORE_SERVER_IDS</code> </span></dt><dd><p>
              レプリカが指定されたサーバーから発生したイベントを無視するようにします。 このオプションは、0 個以上のサーバー ID のコンマ区切りリストを取ります。 サーバーからのログローテーションおよび削除イベントは無視されず、リレーログに記録されます。 
            </p><p>
              循環レプリケーションでは、発信元のサーバーは通常、独自のイベントのターミネータとして機能するため、これらのイベントが複数回適用されることはありません。 そのため、このオプションは、循環内のいずれかのサーバーが削除されたときの循環レプリケーションで役立ちます。 1、2、3、および 4 のサーバー ID を持つ 4 台のサーバーを含む循環レプリケーションセットアップが存在するとき、サーバー 3 に障害が発生したとします。 サーバー 2 からサーバー 4 へのレプリケーションを開始してギャップを埋める場合、サーバー 4 で発行する <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントに <code class="literal">IGNORE_SERVER_IDS = (3)</code> を含めて、サーバー 3 の代わりにサーバー 2 をソースとして使用するように指示できます。 それにより、サーバー 4 は、使用されなくなっているサーバーで発信されたすべてのステートメントを無視し、伝播しなくなります。 
            </p><p>
              <code class="literal">IGNORE_SERVER_IDS</code> にサーバーの独自の ID が含まれているときに、<code class="option">--replicate-same-server-id</code> オプションが有効な状態でそのサーバーが起動された場合は、エラーが発生します。
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                レプリケーションにグローバルトランザクション識別子 (GTID) が使用されている場合、すでに適用されているトランザクションは自動的に無視されるため、<code class="literal">IGNORE_SERVER_IDS</code> 関数は必須ではなく、非推奨です。 サーバーに <code class="literal">gtid_mode=ON</code> が設定されている場合、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントに <code class="literal">IGNORE_SERVER_IDS</code> オプションを含めると、非推奨の警告が発行されます。 
              </p></div><p>
              ソースメタデータリポジトリおよび <code class="literal">SHOW REPLICA STATUS</code> の出力では、現在無視されているサーバーのリストが提供されます。 詳細は、<a class="xref" href="replication.html#replica-logs-status" title="17.2.4.2 レプリケーションメタデータリポジトリ">セクション17.2.4.2「レプリケーションメタデータリポジトリ」</a>および<a class="xref" href="sql-statements.html#show-replica-status" title="13.7.7.35 SHOW REPLICA | SLAVE STATUS ステートメント">セクション13.7.7.35「SHOW REPLICA | SLAVE STATUS ステートメント」</a>を参照してください。 
            </p><p>
              <code class="literal">IGNORE_SERVER_IDS</code> オプションを指定せずに <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントを発行した場合、既存のリストは保持されます。 無視されるサーバーのリストをクリアするには、このオプションを空のリストとともに使用する必要があります。 
            </p><pre class="programlisting">CHANGE REPLICATION SOURCE TO IGNORE_SERVER_IDS = ();
</pre><p>
              <code class="literal">RESET REPLICA ALL</code> により、<code class="literal">IGNORE_SERVER_IDS</code> がクリアされます。
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                <code class="literal">IGNORE_SERVER_IDS</code> で既存のサーバー ID が設定されているチャネルがある場合、<code class="literal">SET GTID_MODE=ON</code> が発行されると、非推奨の警告が発行されます。 GTID ベースのレプリケーションを開始する前に、関係するサーバー上の無視されたすべてのサーバー ID リストを確認してクリアします。 無視された ID がある場合は、<code class="literal">SHOW REPLICA STATUS</code> ステートメントにリストが表示されます。 非推奨の警告が表示された場合でも、空のリストを指定した <code class="literal">IGNORE_SERVER_IDS</code> オプションを含む <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントを発行することで、<code class="literal">gtid_mode=ON</code> の設定後にリストをクリアできます。 
              </p></div></dd><dt><span class="term"> <code class="literal">NETWORK_NAMESPACE</code> </span></dt><dd><p>
              レプリケーションソースサーバーへの TCP/IP 接続に使用するネットワークネームスペース。 このオプションを省略すると、レプリカからの接続にはデフォルト (グローバル) 名前空間が使用されます。 ネットワークネームスペースのサポートを実装していないプラットフォームでは、レプリカがソースに接続しようとすると障害が発生します。 ネットワークネームスペースの詳細は、<a class="xref" href="server-administration.html#network-namespace-support" title="5.1.14 ネットワークネームスペースのサポート">セクション5.1.14「ネットワークネームスペースのサポート」</a> を参照してください。 <code class="literal">NETWORK_NAMESPACE</code> は、MySQL 8.0.22 の時点で使用可能です。 
            </p></dd><dt><span class="term"> <code class="literal">PRIVILEGE_CHECKS_USER</code> </span></dt><dd><p>
              指定されたチャネルのセキュリティコンテキストを提供するユーザーアカウントを指定します。 <code class="literal">NULL</code>(デフォルト) は、セキュリティコンテキストが使用されないことを意味します。 <code class="literal">PRIVILEGE_CHECKS_USER</code> は、MySQL 8.0.18 の時点で使用可能です。 
            </p><p>
              ユーザーアカウントのユーザー名とホスト名は、<a class="xref" href="security.html#account-names" title="6.2.4 アカウント名の指定">セクション6.2.4「アカウント名の指定」</a> で説明されている構文に従う必要があり、ユーザーは匿名ユーザー (ユーザー名が空白) または <code class="literal">CURRENT_USER</code> であってはなりません。 アカウントには、<code class="literal">REPLICATION_APPLIER</code> 権限と、チャネルでレプリケートされたトランザクションを実行するために必要な権限が必要です。 アカウントに必要な権限の詳細は、<a class="xref" href="replication.html#replication-privilege-checks" title="17.3.3 レプリケーション権限チェック">セクション17.3.3「レプリケーション権限チェック」</a> を参照してください。 レプリケーションチャネルを再起動すると、その時点から権限チェックが適用されます。 チャネルを指定せず、他のチャネルが存在しない場合は、ステートメントがデフォルトチャネルに適用されます。 
            </p><p>
              <code class="literal">PRIVILEGE_CHECKS_USER</code> が設定されており、これを強制するように <code class="literal">REQUIRE_ROW_FORMAT</code> を設定できる場合は、行ベースのバイナリロギングを使用することを強くお勧めします。 たとえば、実行中のレプリカでチャネル <code class="literal">channel_1</code> に対する権限チェックを開始するには、次のステートメントを発行します: 
            </p><pre class="programlisting">mysql&gt; STOP REPLICA FOR CHANNEL 'channel_1';
mysql&gt; CHANGE REPLICATION SOURCE TO
         PRIVILEGE_CHECKS_USER = '<em class="replaceable"><code>priv_repl</code></em>'@'<em class="replaceable"><code>%.example.com</code></em>',
         REQUIRE_ROW_FORMAT = 1,
         FOR CHANNEL 'channel_1';
mysql&gt; START REPLICA FOR CHANNEL 'channel_1';
</pre></dd><dt><span class="term"> <code class="literal">RELAY_LOG_FILE</code>, <code class="literal">RELAY_LOG_POS</code> </span></dt><dd><p>
              次回のスレッド起動時にレプリケーション SQL スレッドがレプリカリレーログからの読取りを開始するリレーログファイル名およびそのファイル内の場所。 <code class="literal">SOURCE_LOG_FILE</code> または <code class="literal">SOURCE_LOG_POS</code> を使用している場合、これらのオプションは使用できません。 
            </p><p>
              <code class="literal">RELAY_LOG_FILE</code> では、絶対パスまたは相対パスのいずれかを使用でき、<code class="literal">SOURCE_LOG_FILE</code> と同じベース名を使用します。 <code class="literal">RELAY_LOG_FILE</code>、<code class="literal">RELAY_LOG_POS</code> またはその両方のオプションを使用する <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントは、レプリケーション SQL スレッドの停止時に実行中のレプリカで実行できます。 少なくともいずれかのレプリケーション SQL スレッドとレプリケーション I/O スレッドが実行されている場合、リレーログは保持されます。 両方のスレッドが停止すると、<code class="literal">RELAY_LOG_FILE</code> または <code class="literal">RELAY_LOG_POS</code> のいずれかが指定されていないかぎり、すべてのリレーログファイルが削除されます。 Group Replication applier チャネル (<code class="literal">group_replication_applier</code>) には I/O スレッドがなく、SQL スレッドのみがあることに注意してください。 このチャネルでは、SQL スレッドの停止時にリレーログは保持されません。 
            </p></dd><dt><span class="term"> <code class="literal">REQUIRE_ROW_FORMAT</code> </span></dt><dd><p>
              レプリケーションチャネルによる行ベースのレプリケーションイベントの処理のみを許可します。 このオプションにより、レプリケーションアプライアンスは一時テーブルの作成や <code class="literal">LOAD DATA INFILE</code> リクエストの実行などのアクションを実行できなくなり、チャネルのセキュリティが向上します。 グループレプリケーションチャネルは <code class="literal">REQUIRE_ROW_FORMAT</code> セットで自動的に作成され、これらのチャネルのオプションは変更できません。 詳細は、<a class="xref" href="replication.html#replication-privilege-checks" title="17.3.3 レプリケーション権限チェック">セクション17.3.3「レプリケーション権限チェック」</a>を参照してください。 <code class="literal">REQUIRE_ROW_FORMAT</code> は、MySQL 8.0.19 の時点で使用可能です。 
            </p></dd><dt><span class="term"> <code class="literal">REQUIRE_TABLE_PRIMARY_KEY_CHECK</code> </span></dt><dd><p>
              レプリカが主キーチェック用に独自のポリシーを選択できるようにします。 レプリケーションチャネルのオプションが <code class="literal">ON</code> に設定されている場合、レプリカはレプリケーション操作で常に <code class="literal">sql_require_primary_key</code> システム変数に値 <code class="literal">ON</code> を使用し、主キーが必要です。 このオプションが <code class="literal">OFF</code> に設定されている場合、レプリカはレプリケーション操作で <code class="literal">sql_require_primary_key</code> システム変数に常に値 <code class="literal">OFF</code> を使用するため、ソースで必要な場合でも主キーは必要ありません。 <code class="literal">REQUIRE_TABLE_PRIMARY_KEY_CHECK</code> オプションが <code class="literal">STREAM</code>(デフォルト) に設定されている場合、レプリカは各トランザクションのソースからレプリケートされた値を使用します。 <code class="literal">REQUIRE_TABLE_PRIMARY_KEY_CHECK</code> は、MySQL 8.0.20 の時点で使用可能です。 
            </p><p>
              マルチソースレプリケーションの場合、<code class="literal">REQUIRE_TABLE_PRIMARY_KEY_CHECK</code> を <code class="literal">ON</code> または <code class="literal">OFF</code> に設定すると、レプリカは異なるソースのレプリケーションチャネル間で動作を正規化し、<code class="literal">sql_require_primary_key</code> システム変数の一貫性のある設定を維持できます。 <code class="literal">ON</code> を使用すると、複数のソースが同じテーブルセットを更新する場合に、主キーの偶発的な損失から保護されます。 <code class="literal">OFF</code> を使用すると、主キーを操作できるソースを、操作できないソースと連携させることができます。 
            </p><p>
              <code class="literal">PRIVILEGE_CHECKS_USER</code> が設定されている場合、<code class="literal">REQUIRE_TABLE_PRIMARY_KEY_CHECK</code> を <code class="literal">ON</code> または <code class="literal">OFF</code> に設定することは、制限付きセッション変数を設定するためのセッション管理レベルの権限がユーザーアカウントに必要ないことを意味します。これは、<code class="literal">sql_require_primary_key</code> の値を各トランザクションのソース設定と一致するように変更するために必要です。 詳細は、<a class="xref" href="replication.html#replication-privilege-checks" title="17.3.3 レプリケーション権限チェック">セクション17.3.3「レプリケーション権限チェック」</a>を参照してください。 
            </p></dd><dt><span class="term"> <code class="literal">SOURCE_AUTO_POSITION</code> </span></dt><dd><p>
              GTID ベースのレプリケーションを使用してレプリカがソースに接続しようとします。 このオプションは、レプリケーション SQL スレッドとレプリケーション I/O スレッドの両方が停止している場合にのみ、<code class="literal">CHANGE REPLICATION SOURCE TO</code> で使用できます。 
            </p><p>
              レプリカとソースの両方で GTID が有効になっている必要があります (レプリカでは <code class="literal">GTID_MODE=ON</code>、<code class="literal">ON_PERMISSIVE,</code>または <code class="literal">OFF_PERMISSIVE</code>、ソースでは <code class="literal">GTID_MODE=ON</code>)。 接続には自動配置が使用されるため、<code class="literal">SOURCE_LOG_FILE</code> および <code class="literal">SOURCE_LOG_POS</code> で表される座標は使用されず、これらのオプションのいずれかまたは両方を <code class="literal">SOURCE_AUTO_POSITION = 1</code> とともに使用するとエラーが発生します。 レプリカでマルチソースレプリケーションが有効になっている場合は、適用可能なレプリケーションチャネルごとに <code class="literal">SOURCE_AUTO_POSITION = 1</code> オプションを設定する必要があります。 
            </p><p>
              <code class="literal">SOURCE_AUTO_POSITION = 1</code> が設定されている場合、レプリカは初期接続ハンドシェイクで、すでに受信、コミット、またはその両方を行ったトランザクションを含む GTID セットを送信します。 ソースは、GTID がレプリカによって送信される GTID セットに含まれていないバイナリログに記録されたすべてのトランザクションを送信することによって応答します。 この交換により、レプリカがまだ記録またはコミットしていない GTID を持つトランザクションのみがソースから送信されるようになります。 ダイヤモンドトポロジの場合と同様に、レプリカが複数のソースからトランザクションを受信する場合、自動スキップ機能によってトランザクションが 2 回適用されないようにします。 レプリカによって送信される GTID セットの計算方法の詳細は、<a class="xref" href="replication.html#replication-gtids-auto-positioning" title="17.1.3.3 GTID 自動配置">セクション17.1.3.3「GTID 自動配置」</a> を参照してください。 
            </p><p>
              ソースによって送信されるべきトランザクションのいずれかがソースバイナリログからパージされているか、別の方法で <code class="literal">gtid_purged</code> システム変数の GTID セットに追加されている場合、ソースはエラー <span class="errorname">ER_MASTER_HAS_PURGED_REQUIRED_GTIDS</span> をレプリカに送信し、レプリケーションは開始しません。 欠落しているパージ済トランザクションの GTID が識別され、警告メッセージ <span class="errorname">ER_FOUND_MISSING_GTIDS</span> のソースエラーログにリストされます。 また、トランザクションの交換中に、レプリカが GTID 内のソース UUID を持つトランザクションを記録またはコミットしたが、ソース自体がそれらをコミットしていないことが判明した場合、ソースはレプリカにエラー <span class="errorname">ER_SLAVE_HAS_MORE_GTIDS_THAN_MASTER</span> を送信し、レプリケーションは開始しません。 これらの状況の処理方法の詳細は、<a class="xref" href="replication.html#replication-gtids-auto-positioning" title="17.1.3.3 GTID 自動配置">セクション17.1.3.3「GTID 自動配置」</a> を参照してください。 
            </p><p>
              レプリケーションが GTID 自動配置を有効にして実行されているかどうかを確認するには、パフォーマンススキーマの <code class="literal">replication_connection_status</code> テーブルまたは <code class="literal">SHOW REPLICA STATUS</code> の出力を確認します。 <code class="literal">SOURCE_AUTO_POSITION</code> オプションを再度無効にすると、レプリカはファイルベースレプリケーションに戻ります。その場合は、<code class="literal">SOURCE_LOG_FILE</code> または <code class="literal">SOURCE_LOG_POS</code> オプションのいずれかまたは両方も指定する必要があります。 
            </p></dd><dt><span class="term"> <code class="literal">SOURCE_BIND</code> </span></dt><dd><p>
              複数のネットワークインタフェースを持つレプリカで使用するために、ソースへの接続に選択するレプリカネットワークインタフェースを決定します。 このオプションで構成されたアドレスは、<code class="literal">SHOW REPLICA STATUS</code> からの出力の <code class="literal">Source_Bind</code> カラムに表示されます (存在する場合)。 ソースメタデータリポジトリテーブル <code class="literal">mysql.slave_master_info</code> では、値は <code class="literal">Source_bind</code> カラムとして表示されます。 レプリカを特定のネットワークインタフェースにバインドする機能は、NDB Cluster でもサポートされています。 
            </p></dd><dt><span class="term"> <code class="literal">SOURCE_COMPRESSION_ALGORITHMS</code> </span></dt><dd><p>
              レプリケーションソースサーバーへの接続に許可される圧縮アルゴリズムを指定します。 使用可能なアルゴリズムは、<code class="literal">protocol_compression_algorithms</code> システム変数の場合と同じです。 デフォルト値は <code class="literal">uncompressed</code> です。 <code class="literal">SOURCE_COMPRESSION_ALGORITHMS</code> は、MySQL 8.0.18 の時点で使用可能です。 
            </p><p>
              <code class="literal">SOURCE_COMPRESSION_ALGORITHMS</code> の値は、<code class="literal">slave_compressed_protocol</code> システム変数が無効な場合にのみ適用されます。 <code class="literal">slave_compressed_protocol</code> が有効な場合は、<code class="literal">SOURCE_COMPRESSION_ALGORITHMS</code> よりも優先され、ソースとレプリカの両方がそのアルゴリズムをサポートしている場合は、ソースへの接続で <code class="literal">zlib</code> 圧縮が使用されます。 詳細は、<a class="xref" href="programs.html#connection-compression-control" title="4.2.8 接続圧縮制御">セクション4.2.8「接続圧縮制御」</a>を参照してください。 
            </p><p>
              <code class="literal">binlog_transaction_compression</code> システム変数によってアクティブ化されるバイナリログトランザクション圧縮 (MySQL 8.0.20 で使用可能) を使用して帯域幅を節約することもできます。 これを接続圧縮と組み合せて行うと、接続圧縮ではデータを処理する機会は少なくなりますが、ヘッダーと、圧縮されていないイベントおよびトランザクションペイロードは圧縮できます。 バイナリログのトランザクション圧縮の詳細は、<a class="xref" href="server-administration.html#binary-log-transaction-compression" title="5.4.4.5 バイナリログトランザクション圧縮">セクション5.4.4.5「バイナリログトランザクション圧縮」</a> を参照してください。 
            </p></dd><dt><span class="term"> <code class="literal">SOURCE_CONNECT_RETRY</code> </span></dt><dd><p>
              ソースへの接続がタイムアウトした後にレプリカが試行する再接続の間隔を指定します。 試行は、<code class="literal">SOURCE_RETRY_COUNT</code> オプションによって制限されます。 両方のデフォルト設定が使用されている場合、レプリカは再接続試行 (<code class="literal">SOURCE_CONNECT_RETRY=60</code>) の間 60 秒待機し、60 日間 (<code class="literal">SOURCE_RETRY_COUNT=86400</code>) 再接続を試行し続けます。 これらの値はソースメタデータリポジトリに記録され、<code class="literal">replication_connection_configuration</code>「パフォーマンススキーマ」テーブルに表示されます。 
            </p></dd><dt><span class="term"> <code class="literal">SOURCE_CONNECTION_AUTO_FAILOVER</code> </span></dt><dd><p>
              1 つ以上の代替レプリケーションサーバーが使用可能な場合 (レプリケートされたデータを共有する複数の MySQL サーバーまたはサーバーグループが存在する場合)、レプリケーションチャネルの非同期接続フェイルオーバーメカニズムをアクティブ化します。 <code class="literal">SOURCE_CONNECTION_AUTO_FAILOVER</code> は、MySQL 8.0.22 の時点で使用可能です。 非同期接続フェイルオーバーメカニズムは、<code class="literal">SOURCE_CONNECT_RETRY</code> および <code class="literal">SOURCE_RETRY_COUNT</code> によって制御されている再接続試行を使い果たした後に引き継ぎます。 <code class="literal">asynchronous_connection_failover_add_source</code> および <code class="literal">asynchronous_connection_failover_delete_source</code> UDF を使用して管理する、指定されたソースリストから選択された代替ソースにレプリカを再接続します。 サーバーの管理対象グループを追加および削除するには、かわりに <code class="literal">asynchronous_connection_failover_add_managed</code> および <code class="literal">asynchronous_connection_failover_delete_managed</code> UDF を使用します。 詳細は、<a class="xref" href="replication.html#replication-asynchronous-connection-failover" title="17.4.9 非同期接続フェイルオーバーによるソースの切替え">セクション17.4.9「非同期接続フェイルオーバーによるソースの切替え」</a>を参照してください。 
            </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    GTID 自動配置が使用中 (<code class="literal">SOURCE_AUTO_POSITION = 1</code>) の場合にのみ、<code class="literal">SOURCE_CONNECTION_AUTO_FAILOVER = 1</code> を設定できます。
                  </p></li><li class="listitem"><p>
                    <code class="literal">SOURCE_CONNECTION_AUTO_FAILOVER = 1</code> を設定する場合、一時的なネットワークの停止によって接続障害が発生した場合に備えて、<code class="literal">SOURCE_RETRY_COUNT</code> および <code class="literal">SOURCE_CONNECT_RETRY</code> を同じソースでの再試行回数を最小限に抑えるように設定します。 そうしないと、非同期接続フェイルオーバーメカニズムをすぐにアクティブ化できません。 適切な値は <code class="literal">SOURCE_RETRY_COUNT=3</code> と <code class="literal">SOURCE_CONNECT_RETRY=10</code> です。これにより、レプリカは 10 秒間隔で接続を 3 回再試行します。 
                  </p></li><li class="listitem"><p>
                    <code class="literal">SOURCE_CONNECTION_AUTO_FAILOVER = 1</code> を設定する場合、レプリケーションメタデータリポジトリには、レプリケーションチャネルのソースリスト上のすべてのサーバーへの接続に使用できるレプリケーションユーザーアカウントの資格証明が含まれている必要があります。 アカウントには、「パフォーマンススキーマ」テーブルに対する <code class="literal">SELECT</code> 権限も必要です。 これらの資格証明は、<code class="literal">SOURCE_USER</code> および <code class="literal">SOURCE_PASSWORD</code> オプションを指定した <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントを使用して設定できます。 詳細は、<a class="xref" href="replication.html#replication-asynchronous-connection-failover" title="17.4.9 非同期接続フェイルオーバーによるソースの切替え">セクション17.4.9「非同期接続フェイルオーバーによるソースの切替え」</a>を参照してください。 
                  </p></li></ol></div></div></dd><dt><span class="term"> <code class="literal">SOURCE_DELAY</code> </span></dt><dd><p>
              レプリカが遅延する必要があるソースからの遅延秒数を指定します。 ソースから受信したイベントは、ソースでの実行より少なくとも <em class="replaceable"><code>interval</code></em> 秒後に実行されません。 デフォルトは 0 です。 <em class="replaceable"><code>interval</code></em> が 0 から 2<sup>31</sup>-1 までの範囲の負ではない整数でない場合は、エラーが発生します。 詳細は、<a class="xref" href="replication.html#replication-delayed" title="17.4.11 遅延レプリケーション">セクション17.4.11「遅延レプリケーション」</a>を参照してください。 <code class="literal">SOURCE_DELAY</code> オプションを使用する <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントは、レプリケーション SQL スレッドの停止時に実行中のレプリカで実行できます。 
            </p></dd><dt><span class="term"> <code class="literal">SOURCE_HEARTBEAT_PERIOD</code> </span></dt><dd><p>
              ハートビート間隔を制御します。これにより、接続がまだ良好な場合に、データが存在しないときに接続タイムアウトが発生しなくなります。 ハートビートシグナルは、その秒数が経過するとレプリカに送信され、ソースバイナリログがイベントで更新されるたびに待機期間がリセットされます。 したがって、ハートビートは、これより長い期間バイナリログファイルに未送信のイベントがない場合にのみ、ソースによって送信されます。 
            </p><p>
              ハートビート間隔 <em class="replaceable"><code>interval</code></em> は、0 から 4294967 秒の範囲の小数値およびミリ秒単位の解像度です。ゼロ以外の最小値は 0.001 です。 <em class="replaceable"><code>interval</code></em> を 0 に設定すると、ハートビートが完全に無効になります。 ハートビート間隔のデフォルトは、<code class="literal">slave_net_timeout</code> システム変数の値の半分です。 ソースメタデータリポジトリに記録され、<code class="literal">replication_connection_configuration</code>「パフォーマンススキーマ」テーブルに表示されます。 <code class="literal">RESET REPLICA</code> を発行すると、ハートビート間隔がデフォルト値にリセットされます。 
            </p><p>
              <code class="literal">slave_net_timeout</code> システム変数は、レプリカがソースからのデータまたはハートビートシグナルのいずれかを待機する秒数を指定します。この秒数を過ぎると、レプリカは接続が切断されたとみなし、読取りを中断して再接続を試行します。 デフォルト値は 60 秒 (1 分) です。 <code class="literal">slave_net_timeout</code> の値またはデフォルト設定を変更しても、明示的に設定されているか、以前に計算されたデフォルトを使用しているかにかかわらず、ハートビート間隔は自動的には変更されないことに注意してください。 <code class="literal">@@GLOBAL.slave_net_timeout</code> を現在のハートビート間隔より小さい値に設定すると、警告が発行されます。 <code class="literal">slave_net_timeout</code> が変更された場合は、接続タイムアウトの前にハートビートシグナルが発生するように、<code class="literal">CHANGE REPLICATION SOURCE TO</code> を発行してハートビート間隔を適切な値に調整する必要もあります。 これを行わない場合、ハートビートシグナルは効果がなく、ソースからデータを受信しない場合、レプリカは再接続を繰り返し試行してゾンビダンプスレッドを作成できます。 
            </p></dd><dt><span class="term"> <code class="literal">SOURCE_HOST</code> </span></dt><dd><p>
              レプリケーションソースサーバーのホスト名または IP アドレス。 レプリカはこれを使用してソースに接続します。 
            </p><p>
              <code class="literal">SOURCE_HOST</code> または <code class="literal">SOURCE_PORT</code> を指定した場合、レプリカは、ソースサーバーが以前とは異なることを前提とします (オプション値が現在の値と同じであっても)。) この場合、ソースバイナリログファイルの名前と位置の古い値は適用できなくなるため、ステートメントに <code class="literal">SOURCE_LOG_FILE</code> と <code class="literal">SOURCE_LOG_POS</code> を指定しないと、<code class="literal">SOURCE_LOG_FILE=''</code>と <code class="literal">SOURCE_LOG_POS=4</code> は暗黙的に追加されます。 
            </p><p>
              <code class="literal">SOURCE_HOST=''</code>を設定する (つまり、その値を明示的に空の文字列に設定する) ことは、<code class="literal">SOURCE_HOST</code> をまったく設定しないこととは異なります。 <code class="literal">SOURCE_HOST</code> を空の文字列に設定しようとすると、エラーで失敗します。 
            </p></dd><dt><span class="term"> <code class="literal">SOURCE_LOG_FILE</code>, <code class="literal">SOURCE_LOG_POS</code> </span></dt><dd><p>
              バイナリログファイル名、およびレプリケーション I/O スレッドが次回のスレッド起動時にソースバイナリログからの読み取りを開始するそのファイル内の場所。 バイナリログファイルの位置ベースのレプリケーションを使用している場合は、これらのオプションを指定します。 <code class="literal">SOURCE_LOG_FILE</code> には、ソースサーバーで使用可能な特定のバイナリログファイル (<code class="literal">SOURCE_LOG_FILE='binlog.000145'</code>など) の数値接尾辞が含まれている必要があります。 <code class="literal">SOURCE_LOG_POS</code> は、レプリカがそのファイルの読取りを開始する数値位置です。 <code class="literal">SOURCE_LOG_POS=4</code> は、バイナリログファイルでイベントの開始を表します。 
            </p><p>
              <code class="literal">SOURCE_LOG_FILE</code> または <code class="literal">SOURCE_LOG_POS</code> のいずれかを指定する場合、<code class="literal">RELAY_LOG_FILE</code> または <code class="literal">RELAY_LOG_POS</code> は指定できません。 <code class="literal">SOURCE_LOG_FILE</code> または <code class="literal">SOURCE_LOG_POS</code> のいずれかを指定する場合は、GTID ベースのレプリケーション用の <code class="literal">SOURCE_AUTO_POSITION = 1</code> も指定できません。 
            </p><p>
              <code class="literal">SOURCE_LOG_FILE</code> も <code class="literal">SOURCE_LOG_POS</code> も指定されていない場合、レプリカは <code class="literal">CHANGE REPLICATION SOURCE TO</code> が発行される前の<span class="emphasis"><em>レプリケーション SQL スレッド</em></span>の最後の座標を使用します。 これにより、レプリケーション SQL スレッドがレプリケーション I/O スレッドと比較して遅延していても、レプリケーションの不連続性がなくなります。 
            </p></dd><dt><span class="term"> <code class="literal">SOURCE_PASSWORD</code> </span></dt><dd><p>
              レプリケーションソースサーバーへの接続に使用するレプリケーションユーザーアカウントのパスワード。 <code class="literal">SOURCE_PASSWORD</code> を指定する場合は、<code class="literal">SOURCE_USER</code> も必要です。 
            </p><p>
              <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントでレプリケーションユーザーアカウントに使用されるパスワードの長さは、32 文字に制限されています。 32 文字を超えるパスワードを使用しようとすると、<code class="literal">CHANGE REPLICATION SOURCE TO</code> で障害が発生します。 
            </p></dd><dt><span class="term"> <code class="literal">SOURCE_PORT</code> </span></dt><dd><p>
              レプリカがレプリケーションソースサーバーへの接続に使用する TCP/IP ポート番号。
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                レプリケーションでは、Unix ソケットファイルを使用できません。 TCP/IP を使用してレプリケーションソースサーバーに接続できる必要があります。 
              </p></div><p>
              <code class="literal">SOURCE_HOST</code> または <code class="literal">SOURCE_PORT</code> を指定した場合、レプリカは、ソースサーバーが以前とは異なることを前提とします (オプション値が現在の値と同じであっても)。) この場合、ソースバイナリログファイルの名前と位置の古い値は適用できなくなるため、ステートメントに <code class="literal">SOURCE_LOG_FILE</code> と <code class="literal">SOURCE_LOG_POS</code> を指定しないと、<code class="literal">SOURCE_LOG_FILE=''</code>と <code class="literal">SOURCE_LOG_POS=4</code> は暗黙的に追加されます。 
            </p></dd><dt><span class="term"> <code class="literal">SOURCE_PUBLIC_KEY_PATH</code> </span></dt><dd><p>
              ソースが必要とする公開キーのレプリカ側のコピーを含むファイルへのパス名を指定することで、RSA キーペアベースのパスワード交換を有効にします。 ファイルは PEM 形式である必要があります。 このオプションは、<code class="literal">sha256_password</code> または <code class="literal">caching_sha2_password</code> 認証プラグインで認証されるレプリカに適用されます。 (<code class="literal">sha256_password</code> の場合、<code class="literal">SOURCE_PUBLIC_KEY_PATH</code> は、MySQL が OpenSSL を使用して構築された場合にのみ使用できます。) <code class="literal">caching_sha2_password</code> プラグイン (MySQL 8.0 のデフォルト) で認証されるレプリケーションユーザーアカウントを使用していて、セキュアな接続を使用していない場合は、このオプションまたは <code class="literal">GET_SOURCE_PUBLIC_KEY=1</code> オプションを指定して、RSA 公開キーをレプリカに提供する必要があります。 
            </p></dd><dt><span class="term"> <code class="literal">SOURCE_RETRY_COUNT</code> </span></dt><dd><p>
              <code class="literal">slave_net_timeout</code> システム変数によって決定される、ソースへの接続がタイムアウトした後にレプリカが行う再接続の最大試行回数を設定します。 レプリカを再接続する必要がある場合、タイムアウトの直後に最初の再試行が行われます。 試行の間隔は、<code class="literal">SOURCE_CONNECT_RETRY</code> オプションで指定します。 両方のデフォルト設定が使用されている場合、レプリカは再接続試行 (<code class="literal">SOURCE_CONNECT_RETRY=60</code>) の間 60 秒待機し、60 日間 (<code class="literal">SOURCE_RETRY_COUNT=86400</code>) 再接続を試行し続けます。 これらの値はソースメタデータリポジトリに記録され、<code class="literal">replication_connection_configuration</code>「パフォーマンススキーマ」テーブルに表示されます。 <code class="literal">SOURCE_RETRY_COUNT</code> は、<code class="option">--master-retry-count</code> サーバーの起動オプションより優先されます。 
            </p></dd><dt><span class="term"> <code class="literal">SOURCE_SSL_<em class="replaceable"><code>xxx</code></em></code>, <code class="literal">SOURCE_TLS_<em class="replaceable"><code>xxx</code></em></code> </span></dt><dd><p>
              レプリカが暗号化および暗号化を使用してレプリケーション接続を保護する方法を指定します。 これらのオプションは、SSL サポートなしでコンパイルされたレプリカでも変更できます。 これらはソースメタデータリポジトリに保存されますが、レプリカで SSL サポートが有効になっていない場合は無視されます。 <code class="literal">SOURCE_SSL_<em class="replaceable"><code>xxx</code></em></code> および <code class="literal">SOURCE_TLS_<em class="replaceable"><code>xxx</code></em></code> オプションは、<a class="xref" href="programs.html#encrypted-connection-options" title="暗号化接続のコマンドオプション">暗号化接続のコマンドオプション</a> で説明されている <code class="literal">--ssl-<em class="replaceable"><code>xxx</code></em></code> および <code class="literal">--tls-<em class="replaceable"><code>xxx</code></em></code> クライアントオプションと同じ機能を実行します。 2 つのオプションセット間の対応、および <code class="literal">SOURCE_SSL_<em class="replaceable"><code>xxx</code></em></code> オプションと <code class="literal">SOURCE_TLS_<em class="replaceable"><code>xxx</code></em></code> オプションを使用したセキュアな接続の設定については、<a class="xref" href="replication.html#replication-solutions-encrypted-connections" title="17.3.1 暗号化接続を使用するためのレプリケーションの設定">セクション17.3.1「暗号化接続を使用するためのレプリケーションの設定」</a> を参照してください。 
            </p></dd><dt><span class="term"> <code class="literal">SOURCE_USER</code> </span></dt><dd><p>
              レプリケーションソースサーバーへの接続に使用するレプリケーションユーザーアカウントのユーザー名。
            </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
                <code class="literal">caching_sha2_password</code> プラグインで認証するレプリケーションユーザーアカウントを使用してソースに接続するには、<a class="xref" href="replication.html#replication-solutions-encrypted-connections" title="17.3.1 暗号化接続を使用するためのレプリケーションの設定">セクション17.3.1「暗号化接続を使用するためのレプリケーションの設定」</a> の説明に従ってセキュアな接続を設定するか、RSA キーペアを使用したパスワード交換をサポートするように暗号化されていない接続を有効にする必要があります。 <code class="literal">caching_sha2_password</code> 認証プラグインは、MySQL 8.0 から作成された新規ユーザーのデフォルトです (詳細は、<a class="xref" href="security.html#caching-sha2-pluggable-authentication" title="6.4.1.2 SHA-2 プラガブル認証のキャッシュ">セクション6.4.1.2「SHA-2 プラガブル認証のキャッシュ」</a> を参照)。 レプリケーション用に作成または使用するユーザーアカウントがこの認証プラグインを使用しており、セキュアな接続を使用していない場合は、正常に接続するために RSA キーペアベースのパスワード交換を有効にする必要があります。 これは、<code class="literal">SOURCE_PUBLIC_KEY_PATH</code> オプションまたはこのステートメントの <code class="literal">GET_SOURCE_PUBLIC_KEY=1</code> オプションを使用して実行できます。 
              </p></div><p>
              <code class="literal">SOURCE_USER=''</code>を指定して空のユーザー名を設定することはできますが、レプリケーションチャネルは空のユーザー名で開始できません。 MySQL 8.0.21 より前のリリースでは、セキュリティ上の目的で以前に使用した資格証明をレプリケーションメタデータリポジトリからクリアする必要がある場合にのみ、空の <code class="literal">SOURCE_USER</code> ユーザー名を設定します。 これらのリリースでは、リポジトリから空のユーザー名が読み取られた場合 (グループレプリケーションチャネルの自動再起動時など)、デフォルトのユーザー名を置換できるバグのため、後でチャネルを使用しないでください。 MySQL 8.0.21 からは、レプリケーションチャネルを開始する <code class="literal">START REPLICA</code> ステートメントまたは <code class="literal">START GROUP_REPLICATION</code> ステートメントを使用して常にユーザー資格証明を指定する場合、空の <code class="literal">SOURCE_USER</code> ユーザー名を設定し、後でチャネルを使用できます。 このアプローチでは、レプリケーションチャネルを再起動するためにオペレータの介入が常に必要ですが、ユーザー資格証明はレプリケーションメタデータリポジトリに記録されません。 
            </p><p>
              <code class="literal">SOURCE_USER</code> および <code class="literal">SOURCE_PASSWORD</code> の値を含む実行中の <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントのテキストは、同時 <code class="literal">SHOW PROCESSLIST</code> ステートメントの出力に表示されます。 (<code class="literal">START REPLICA</code> ステートメントの完全なテキストは、<code class="literal">SHOW PROCESSLIST</code> にも表示されます。) 
            </p></dd><dt><span class="term"> <code class="literal">SOURCE_ZSTD_COMPRESSION_LEVEL</code> </span></dt><dd><p>
              <code class="literal">zstd</code> 圧縮アルゴリズムを使用するレプリケーションソースサーバーへの接続に使用する圧縮レベル。 許可されるレベルは 1 から 22 で、大きい値は圧縮レベルの増加を示します。 デフォルトの <code class="literal">zstd</code> 圧縮レベルは 3 です。 圧縮レベルの設定は、<code class="literal">zstd</code> 圧縮を使用しない接続には影響しません。 <code class="literal">SOURCE_ZSTD_COMPRESSION_LEVEL</code> は、MySQL 8.0.18 の時点で使用可能です。 詳細は、<a class="xref" href="programs.html#connection-compression-control" title="4.2.8 接続圧縮制御">セクション4.2.8「接続圧縮制御」</a>を参照してください。 
            </p></dd></dl></div><p>
        次の表は、文字列値のオプションに許可される最大長を示しています。
      </p><div class="informaltable"><table summary="The maximum permissible length for CHANGE REPLICATION SOURCE TO string-valued options."><col style="width: 50%"><col style="width: 50%"><thead><tr>
            <th>オプション</th>
            <th>最大長</th>
          </tr></thead><tbody><tr>
            <td><code class="literal">SOURCE_HOST</code></td>
            <td>255</td>
          </tr><tr>
            <td><code class="literal">SOURCE_USER</code></td>
            <td>96</td>
          </tr><tr>
            <td><code class="literal">SOURCE_PASSWORD</code></td>
            <td>32</td>
          </tr><tr>
            <td><code class="literal">SOURCE_LOG_FILE</code></td>
            <td>511</td>
          </tr><tr>
            <td><code class="literal">RELAY_LOG_FILE</code></td>
            <td>511</td>
          </tr><tr>
            <td><code class="literal">SOURCE_SSL_CA</code></td>
            <td>511</td>
          </tr><tr>
            <td><code class="literal">SOURCE_SSL_CAPATH</code></td>
            <td>511</td>
          </tr><tr>
            <td><code class="literal">SOURCE_SSL_CERT</code></td>
            <td>511</td>
          </tr><tr>
            <td><code class="literal">SOURCE_SSL_CRL</code></td>
            <td>511</td>
          </tr><tr>
            <td><code class="literal">SOURCE_SSL_CRLPATH</code></td>
            <td>511</td>
          </tr><tr>
            <td><code class="literal">SOURCE_SSL_KEY</code></td>
            <td>511</td>
          </tr><tr>
            <td><code class="literal">SOURCE_SSL_CIPHER</code></td>
            <td>511</td>
          </tr><tr>
            <td><code class="literal">SOURCE_TLS_VERSION</code></td>
            <td>511</td>
          </tr><tr>
            <td><code class="literal">SOURCE_TLS_CIPHERSUITES</code></td>
            <td>4000</td>
          </tr><tr>
            <td><code class="literal">SOURCE_PUBLIC_KEY_PATH</code></td>
            <td>511</td>
          </tr><tr>
            <td><code class="literal">SOURCE_COMPRESSION_ALGORITHMS</code></td>
            <td>99</td>
          </tr><tr>
            <td><code class="literal">NETWORK_NAMESPACE</code></td>
            <td>64</td>
          </tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="master-pos-wait"></a>13.4.2.4 MASTER_POS_WAIT() ステートメント</h4></div></div></div><a class="indexterm" name="idm45826994633104"></a><pre class="programlisting">SELECT MASTER_POS_WAIT('<em class="replaceable"><code>source_log_file</code></em>', <em class="replaceable"><code>source_log_pos</code></em> [, <em class="replaceable"><code>timeout</code></em>][, <em class="replaceable"><code>channel</code></em>])
</pre><p>
        これはステートメントではなく、実際には関数です。 これは、レプリカがソースバイナリログ内の指定された位置までイベントを読み取って実行したことを確認するために使用されます。 完全な説明については、<a class="xref" href="functions.html#miscellaneous-functions" title="12.24 その他の関数">セクション12.24「その他の関数」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="reset-replica"></a>13.4.2.5 RESET REPLICA | SLAVE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826994626112"></a><a class="indexterm" name="idm45826994624800"></a><pre class="programlisting">RESET {REPLICA | SLAVE} [ALL] [<em class="replaceable"><code>channel_option</code></em>]

<em class="replaceable"><code>channel_option</code></em>:
    FOR CHANNEL <em class="replaceable"><code>channel</code></em>
</pre><p>
        <code class="literal">RESET REPLICA | SLAVE</code> では、レプリカはソースバイナリログ内の位置を忘れます。 MySQL 8.0.22 から、<code class="literal">RESET SLAVE</code> のかわりに <code class="literal">RESET REPLICA</code> を使用します。これは、そのリリースから非推奨になりました。 MySQL 8.0.22 より前のリリースでは、<code class="literal">RESET SLAVE</code> を使用します。 
      </p><p>
        このステートメントはクリーンスタートに使用されます。レプリケーションメタデータリポジトリをクリアし、すべてのリレーログファイルを削除して、新しいリレーログファイルを開始します。 また、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23 から) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 より前) の <code class="literal">SOURCE_DELAY</code> | <code class="literal">MASTER_DELAY</code> オプションで指定されたレプリケーション遅延を 0 にリセットします。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          レプリケーション SQL スレッドによって完全に実行されていない場合でも、リレーログファイルはすべて削除されます。 (<code class="literal">STOP REPLICA | SLAVE</code> ステートメントを発行した場合、またはレプリカの負荷が高い場合、これはレプリカに存在する可能性があります。) 
        </p></div><p>
        GTID が使用されている (<code class="literal">gtid_mode</code> が <code class="literal">ON</code>) サーバーの場合、<code class="literal">RESET REPLICA | SLAVE</code> を発行しても GTID 実行履歴には影響しません。 このステートメントでは、<code class="literal">gtid_executed</code>、<code class="literal">gtid_purged</code> または <code class="literal">mysql.gtid_executed</code> テーブルの値は変更されません。 GTID 実行履歴をリセットする必要がある場合は、GTID 対応サーバーがバイナリロギングが無効になっているレプリカであっても、<code class="literal">RESET MASTER</code> を使用します。 
      </p><p>
        <code class="literal">RESET REPLICA | SLAVE</code> には、<code class="literal">RELOAD</code> 権限が必要です。
      </p><p>
        <code class="literal">RESET REPLICA | SLAVE</code> を使用するには、レプリケーション SQL スレッドおよびレプリケーション I/O スレッドを停止する必要があるため、実行中のレプリカでは、<code class="literal">RESET REPLICA | SLAVE</code> を発行する前に <code class="literal">STOP REPLICA | SLAVE</code> を使用します。 グループレプリケーショングループメンバーで <code class="literal">RESET REPLICA | SLAVE</code> を使用するには、メンバーステータスが <code class="literal">OFFLINE</code> である必要があります。つまり、プラグインはロードされますが、メンバーは現在どのグループにも属していません。 グループメンバーは、<code class="literal">STOP GROUP REPLICATION</code> ステートメントを使用してオフラインにできます。 
      </p><p>
        オプションの <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を使用すると、ステートメントが適用されるレプリケーションチャネルの名前を指定できます。 <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を指定すると、<code class="literal">RESET REPLICA | SLAVE</code> ステートメントが特定のレプリケーションチャネルに適用されます。 <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を <code class="literal">ALL</code> オプションと組み合せると、指定したチャネルが削除されます。 チャネルが指定されておらず、追加のチャネルが存在しない場合、ステートメントはデフォルトチャネルに適用されます。 複数のレプリケーションチャネルが存在する場合に <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句なしで <code class="literal">RESET REPLICA | SLAVE ALL</code> ステートメントを発行すると、<span class="emphasis"><em>all</em></span> レプリケーションチャネルが削除され、デフォルトチャネルのみが再作成されます。 詳しくは<a class="xref" href="replication.html#replication-channels" title="17.2.2 レプリケーションチャネル">セクション17.2.2「レプリケーションチャネル」</a>をご覧ください。 
      </p><p>
        <code class="literal">RESET REPLICA | SLAVE</code> では、ソースホスト名とポート、レプリケーションユーザーアカウントとそのパスワード、<code class="literal">PRIVILEGE_CHECKS_USER</code> アカウント、<code class="literal">REQUIRE_ROW_FORMAT</code> オプション、<code class="literal">REQUIRE_TABLE_PRIMARY_KEY_CHECK</code> オプション、<code class="literal">ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS </code>オプションなどのレプリケーション接続パラメータは変更されません。 レプリケーション接続パラメータを変更する場合は、サーバーの起動後に <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23 の場合) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 の場合) を使用します。 すべてのレプリケーション接続パラメータを削除する場合は、<code class="literal">RESET REPLICA | SLAVE ALL</code> を使用します。 <code class="literal">RESET REPLICA | SLAVE ALL</code> では、<code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> によって設定された <code class="literal">IGNORE_SERVER_IDS</code> リストもクリアされます。 <code class="literal">RESET REPLICA | SLAVE ALL</code> を使用している場合、インスタンスをレプリカとして再度使用するには、サーバーの起動後に <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントを発行して、新しい接続パラメータを指定する必要があります。 
      </p><p>
        <code class="literal">RESET REPLICA | SLAVE</code> を発行した後、<code class="literal">START REPLICA | SLAVE</code> を発行する前に予期しないサーバーの終了または意図的な再起動が発生した場合、レプリケーション接続パラメータの保存は、レプリケーションメタデータに使用されるリポジトリによって異なります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">master_info_repository=TABLE</code> および <code class="literal">relay_log_info_repository=TABLE</code> がサーバーに設定されている場合 (MySQL 8.0 からのデフォルト設定)、レプリケーション接続パラメータは、<code class="literal">InnoDB</code> テーブル <code class="literal">mysql.slave_master_info</code> および <code class="literal">mysql.slave_relay_log_info</code> のクラッシュセーフ <code class="literal">RESET REPLICA | SLAVE</code> 操作の一部として保持されます。 これらはメモリーにも保持されます。 <code class="literal">RESET REPLICA | SLAVE</code> の発行後、<code class="literal">START REPLICA | SLAVE</code> の発行前に予期しないサーバーの終了または意図的な再起動が発生した場合、レプリケーション接続パラメータがテーブルから取得され、チャネルに再適用されます。 この状況は、接続メタデータリポジトリの場合は MySQL 8.0.13 から、アプライヤメタデータリポジトリの場合は MySQL 8.0.19 から適用されます。 
          </p></li><li class="listitem"><p>
            MySQL 8.0 から非推奨になった <code class="literal">master_info_repository=FILE</code> および <code class="literal">relay_log_info_repository=FILE</code> がサーバーに設定されている場合、または MySQL Server リリースが前述のリリースより前の場合、レプリケーション接続パラメータはメモリーにのみ保持されます。 予期しないサーバーの終了または故意の再起動が原因で、<code class="literal">RESET REPLICA | SLAVE</code> の発行直後にレプリカ <span class="command"><strong>mysqld</strong></span> が再起動された場合、接続パラメータは失われます。 その場合は、<code class="literal">START REPLICA | SLAVE</code> を発行する前に、サーバーが接続パラメータの再指定を開始した後で、(MySQL 8.0.23 から) <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントまたは <code class="literal">CHANGE MASTER TO</code> ステートメントを発行する必要があります。 
          </p></li></ul></div><p>
        <code class="literal">RESET REPLICA | SLAVE</code> では、ステートメントの影響を受けるチャネルのレプリケーションフィルタ設定 (<code class="option">--replicate-ignore-table</code> など) は変更されません。 ただし、<code class="literal">RESET REPLICA | SLAVE ALL</code> では、ステートメントによって削除されたチャネルに設定されたレプリケーションフィルタが削除されます。 削除されたチャネルが再作成されると、レプリカに指定されたグローバルレプリケーションフィルタがそれらにコピーされ、チャネル固有のレプリケーションフィルタは適用されません。 詳細は、<a class="xref" href="replication.html#replication-rules-channel-based-filters" title="17.2.5.4 レプリケーションチャネルベースのフィルタ">セクション17.2.5.4「レプリケーションチャネルベースのフィルタ」</a> を参照してください。 
      </p><p>
        <code class="literal">RESET REPLICA | SLAVE</code> では、進行中のトランザクションが暗黙的にコミットされます。 <a class="xref" href="sql-statements.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。 
      </p><p>
        レプリケーション SQL スレッドが停止時に一時テーブルのレプリケート中で、<code class="literal">RESET REPLICA | SLAVE</code> が発行された場合、レプリケートされた一時テーブルはレプリカで削除されます。
      </p><p>
        <code class="literal">RESET REPLICA | SLAVE</code> はハートビート期間または <code class="literal">SSL_VERIFY_SERVER_CERT</code> をリセットしません。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          NDB Cluster レプリカ SQL ノードで使用すると、<code class="literal">RESET REPLICA | SLAVE</code> は <code class="literal">mysql.ndb_apply_status</code> テーブルをクリアします。 このステートメントを使用する場合、<code class="literal">ndb_apply_status</code> は <code class="literal">NDB</code> ストレージエンジンを使用するため、クラスタに接続されているすべての SQL ノードによって共有されることに注意してください。 
        </p><p>
          この動作をオーバーライドするには、<code class="literal">RESET REPLICA | SLAVE</code> を実行する前に <code class="literal">SET</code> <code class="literal">GLOBAL @@</code> <code class="literal">ndb_clear_apply_status=OFF</code> を発行します。このような場合、レプリカは <code class="literal">ndb_apply_status</code> テーブルをパージしません。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="reset-slave"></a>13.4.2.6 RESET SLAVE | REPLICA ステートメント</h4></div></div></div><a class="indexterm" name="idm45826994525488"></a><a class="indexterm" name="idm45826994524176"></a><pre class="programlisting">RESET {SLAVE | REPLICA} [ALL] [<em class="replaceable"><code>channel_option</code></em>]

<em class="replaceable"><code>channel_option</code></em>:
    FOR CHANNEL <em class="replaceable"><code>channel</code></em>
</pre><p>
        レプリカがソースバイナリログ内の位置を忘れられるようにします。 MySQL 8.0.22 からは、<code class="literal">RESET SLAVE</code> は非推奨であり、かわりにエイリアス <code class="literal">RESET REPLICA</code> を使用する必要があります。 MySQL 8.0.22 より前のリリースでは、<code class="literal">RESET SLAVE</code> を使用します。 ステートメントは以前と同様に機能し、ステートメントおよびその出力に使用される用語のみが変更されています。 どちらのバージョンのステートメントも、使用時に同じステータス変数を更新します。 ステートメントの説明は、<code class="literal">RESET REPLICA</code> のドキュメントを参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="start-replica"></a>13.4.2.7 START REPLICA | SLAVE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826994510528"></a><pre class="programlisting">START {REPLICA | SLAVE} [<em class="replaceable"><code>thread_types</code></em>] [<em class="replaceable"><code>until_option</code></em>] [<em class="replaceable"><code>connection_options</code></em>] [<em class="replaceable"><code>channel_option</code></em>]

<em class="replaceable"><code>thread_types</code></em>:
    [<em class="replaceable"><code>thread_type</code></em> [, <em class="replaceable"><code>thread_type</code></em>] ... ]

<em class="replaceable"><code>thread_type</code></em>:
    IO_THREAD | SQL_THREAD

<em class="replaceable"><code>until_option</code></em>:
    UNTIL {   {SQL_BEFORE_GTIDS | SQL_AFTER_GTIDS} = <em class="replaceable"><code>gtid_set</code></em>
          |   MASTER_LOG_FILE = '<em class="replaceable"><code>log_name</code></em>', MASTER_LOG_POS = <em class="replaceable"><code>log_pos</code></em>
          |   SOURCE_LOG_FILE = '<em class="replaceable"><code>log_name</code></em>', SOURCE_LOG_POS = <em class="replaceable"><code>log_pos</code></em>
          |   RELAY_LOG_FILE = '<em class="replaceable"><code>log_name</code></em>', RELAY_LOG_POS = <em class="replaceable"><code>log_pos</code></em>
          |   SQL_AFTER_MTS_GAPS  }

<em class="replaceable"><code>connection_options</code></em>:
    [USER='<em class="replaceable"><code>user_name</code></em>'] [PASSWORD='<em class="replaceable"><code>user_pass</code></em>'] [DEFAULT_AUTH='<em class="replaceable"><code>plugin_name</code></em>'] [PLUGIN_DIR='<em class="replaceable"><code>plugin_dir</code></em>']


<em class="replaceable"><code>channel_option</code></em>:
    FOR CHANNEL <em class="replaceable"><code>channel</code></em>

<em class="replaceable"><code>gtid_set</code></em>:
    <em class="replaceable"><code>uuid_set</code></em> [, <em class="replaceable"><code>uuid_set</code></em>] ...
    | ''

<em class="replaceable"><code>uuid_set</code></em>:
    <em class="replaceable"><code>uuid</code></em>:<em class="replaceable"><code>interval</code></em>[:<em class="replaceable"><code>interval</code></em>]...

<em class="replaceable"><code>uuid</code></em>:
    <em class="replaceable"><code>hhhhhhhh</code></em>-<em class="replaceable"><code>hhhh</code></em>-<em class="replaceable"><code>hhhh</code></em>-<em class="replaceable"><code>hhhh</code></em>-<em class="replaceable"><code>hhhhhhhhhhhh</code></em>

<em class="replaceable"><code>h</code></em>:
    [0-9,A-F]

<em class="replaceable"><code>interval</code></em>:
    <em class="replaceable"><code>n</code></em>[-<em class="replaceable"><code>n</code></em>]

    (<em class="replaceable"><code>n</code></em> &gt;= 1)
</pre><p>
        <code class="literal">START REPLICA | SLAVE</code> は、レプリケーションスレッドの一方または両方を起動します。 MySQL 8.0.22 から、<code class="literal">START SLAVE</code> のかわりに <code class="literal">START REPLICA</code> を使用します。これは、そのリリースから非推奨になりました。 MySQL 8.0.22 より前のリリースでは、<code class="literal">START SLAVE</code> を使用します。 
      </p><p>
        <em class="replaceable"><code>thread_type</code></em> オプションを指定しない <code class="literal">START REPLICA | SLAVE</code> は、両方のレプリケーションスレッドを起動します。 レプリケーション I/O スレッドは、ソースサーバーからイベントを読み取り、リレーログに格納します。 レプリケーション SQL スレッドは、リレーログからイベントを読み取り、それらを実行します。 <code class="literal">START REPLICA | SLAVE</code> には、<code class="literal">REPLICATION_SLAVE_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。 
      </p><p>
        <code class="literal">START REPLICA | SLAVE</code> がレプリケーションスレッドの起動に成功すると、エラーなしで返されます。 ただし、その場合でも、レプリケーションスレッドが起動してから後で停止する可能性があります (たとえば、ソースへの接続やバイナリログの読取りなどの問題が管理されないため)。 <code class="literal">START REPLICA | SLAVE</code> では、これについての警告は表示されません。 レプリカエラーログでレプリケーションスレッドによって生成されたエラーメッセージを確認するか、<code class="literal">SHOW REPLICA | SLAVE STATUS</code> で正常に実行されていることを確認する必要があります。 
      </p><p>
        <code class="literal">START REPLICA | SLAVE</code> では、進行中のトランザクションが暗黙的にコミットされます。 <a class="xref" href="sql-statements.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。 
      </p><p>
        このステートメントを発行する前に、<code class="literal">gtid_next</code> を <code class="literal">AUTOMATIC</code> に設定する必要があります。
      </p><p>
        オプションの <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を使用すると、ステートメントが適用されるレプリケーションチャネルの名前を指定できます。 <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を指定すると、<code class="literal">START REPLICA | SLAVE</code> ステートメントが特定のレプリケーションチャネルに適用されます。 句が指定されておらず、追加のチャネルが存在しない場合、ステートメントはデフォルトチャネルに適用されます。 複数のチャネルを使用するときに <code class="literal">START REPLICA | SLAVE</code> ステートメントにチャネルが定義されていない場合、このステートメントはすべてのチャネルに対して指定されたスレッドを開始します。 このステートメントは <code class="literal">group_replication_recovery</code> チャネルでは許可されていません。 詳しくは<a class="xref" href="replication.html#replication-channels" title="17.2.2 レプリケーションチャネル">セクション17.2.2「レプリケーションチャネル」</a>をご覧ください。 
      </p><p>
        どちらのスレッドを開始するかを指定するために、このステートメントに <code class="literal">IO_THREAD</code> および <code class="literal">SQL_THREAD</code> オプションを追加できます。 Group Replication applier チャネル (<code class="literal">group_replication_applier</code>) には I/O スレッドがなく、SQL スレッドのみがあることに注意してください。 このチャネルの起動時に <code class="literal">IO_THREAD</code> または <code class="literal">SQL_THREAD</code> オプションを指定しても利点はありません。 
      </p><p>
        <code class="literal">START REPLICA | SLAVE</code> では、次のリストに示すように、<code class="literal">USER</code>, <code class="literal">PASSWORD</code>, <code class="literal">DEFAULT_AUTH</code> および <code class="literal">PLUGIN_DIR</code> オプションを使用したプラガブルユーザーパスワード認証がサポートされます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">USER</code>: ユーザー名。 <code class="literal">PASSWORD</code> が使用されている場合は、空または NULL 文字列に設定したり、未設定のままにしたりすることはできません。 
          </p></li><li class="listitem"><p>
            <code class="literal">PASSWORD</code>: パスワード。
          </p></li><li class="listitem"><p>
            <code class="literal">DEFAULT_AUTH</code>: プラグインの名前。デフォルトは MySQL ネイティブ認証です。
          </p></li><li class="listitem"><p>
            <code class="literal">PLUGIN_DIR</code>: プラグインの場所。
          </p></li></ul></div><p>
        <code class="literal">IO_THREAD</code> オプションも指定されていないかぎり、<code class="literal">USER</code>, <code class="literal">PASSWORD</code>, <code class="literal">DEFAULT_AUTH</code> または <code class="literal">PLUGIN_DIR</code> のいずれかを指定する場合は、<code class="literal">SQL_THREAD</code> オプションを使用できません。
      </p><p>
        詳細は、<a class="xref" href="security.html#pluggable-authentication" title="6.2.17 プラガブル認証">セクション6.2.17「プラガブル認証」</a>を参照してください。
      </p><p>
        これらのいずれかのオプションとともにセキュアでない接続が使用されている場合、サーバーは次の警告を発行します: <span class="errortext">Sending passwords in plain text without SSL/TLS is extremely insecure</span>
      </p><p>
        <code class="literal">START REPLICA | SLAVE ... UNTIL</code> では、グローバルトランザクション識別子 (GTID) で使用するための追加オプションが 2 つサポートされています (<a class="xref" href="replication.html#replication-gtids" title="17.1.3 グローバルトランザクション識別子を使用したレプリケーション">セクション17.1.3「グローバルトランザクション識別子を使用したレプリケーション」</a> を参照)。 これらの各オプションは、引数として 1 つ以上のグローバルトランザクション識別子のセット <em class="replaceable"><code>gtid_set</code></em> を受け取ります (詳細は、<a class="xref" href="replication.html#replication-gtids-concepts-gtid-sets" title="GTID セット">GTID セット</a>を参照してください)。 
      </p><p>
        <em class="replaceable"><code>thread_type</code></em> が指定されていない場合、<code class="literal">START REPLICA | SLAVE UNTIL SQL_BEFORE_GTIDS</code> は GTID が <em class="replaceable"><code>gtid_set</code></em> にリストされている <span class="emphasis"><em>first</em></span> トランザクションに到達するまで、レプリケーション SQL スレッドにトランザクションを処理させます。 <code class="literal">START REPLICA | SLAVE UNTIL SQL_AFTER_GTIDS</code> では、<em class="replaceable"><code>gtid_set</code></em> の <em class="replaceable"><code>last</code></em> トランザクションが両方のスレッドによって処理されるまで、レプリケーションスレッドがすべてのトランザクションを処理します。 つまり、<code class="literal">START REPLICA | SLAVE UNTIL SQL_BEFORE_GTIDS</code> は、レプリケーション SQL スレッドが <em class="replaceable"><code>gtid_set</code></em> の最初の GTID に到達する前に発生したすべてのトランザクションを処理し、<code class="literal">START REPLICA | SLAVE UNTIL SQL_AFTER_GTIDS</code> は GTID がセットに含まれていないトランザクションが検出されるまで、レプリケーションスレッドがすべてのトランザクション (GTID が <em class="replaceable"><code>gtid_set</code></em> で見つかったトランザクションを含む) を処理します。 <code class="literal">SQL_BEFORE_GTIDS</code> と <code class="literal">SQL_AFTER_GTIDS</code> はそれぞれ、<code class="literal">SQL_THREAD</code> および <code class="literal">IO_THREAD</code> オプションをサポートしますが、<code class="literal">IO_THREAD</code> を一緒に使用しても現在は何の効果もありません。 
      </p><p>
        たとえば、<code class="literal">START REPLICA | SLAVE SQL_THREAD UNTIL SQL_BEFORE_GTIDS = 3E11FA47-71CA-11E1-9E33-C80AA9429562:11-56</code> では、順序番号 11 のトランザクションが見つかるまで、<code class="literal">server_uuid</code> が <code class="literal">3E11FA47-71CA-11E1-9E33-C80AA9429562</code> であるソースから発生したすべてのトランザクションがレプリケーション SQL スレッドによって処理され、このトランザクションは処理されずに停止されます。 つまり、シーケンス番号 10 を持つトランザクションまでのすべてのトランザクションが処理されます。 一方、<code class="literal">START REPLICA | SLAVE SQL_THREAD UNTIL SQL_AFTER_GTIDS = 3E11FA47-71CA-11E1-9E33-C80AA9429562:11-56</code> を実行すると、レプリケーション SQL スレッドは、順序番号 11 から 56 を持つすべてのトランザクションを含め、ソースから指定されたすべてのトランザクションを取得し、追加のトランザクションを処理せずに停止します。つまり、順序番号 56 を持つトランザクションは、レプリケーション SQL スレッドによって最後にフェッチされたトランザクションになります。 
      </p><p>
        マルチスレッドレプリカを使用する場合


        <code class="literal">slave_preserve_commit_order=0</code> が設定されていると、次の場合にリレーログから実行された一連のトランザクションにギャップが生じる可能性があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            コーディネータスレッドの強制終了
          </p></li><li class="listitem"><p>
            アプライヤスレッドでエラーが発生した後
          </p></li><li class="listitem"><p>
            <span class="command"><strong>mysqld</strong></span> が予期せず停止
          </p></li></ul></div><p>
        マルチスレッドレプリカワーカースレッドをリレーログにギャップがなくなるまでのみ実行してから停止するには、<code class="literal">START REPLICA | SLAVE UNTIL SQL_AFTER_MTS_GAPS</code> ステートメントを使用します。 このステートメントは <code class="literal">SQL_THREAD</code> オプションを受け取ることができますが、ステートメントの効果は変更されないままです。 レプリケーション I/O スレッドには影響しません (<code class="literal">IO_THREAD</code> オプションとともに使用することはできません)。 
      </p><p>
        リレーログから実行されるトランザクションのシーケンスにギャップがあるマルチスレッドレプリカで <code class="literal">START REPLICA | SLAVE</code> を発行すると、警告が生成されます。 このような状況で解決するには、<code class="literal">START REPLICA | SLAVE UNTIL SQL_AFTER_MTS_GAPS</code> を使用してから、<code class="literal">RESET REPLICA | SLAVE</code> を発行して残りのリレーログを削除します。 詳しくは<a class="xref" href="replication.html#replication-features-transaction-inconsistencies" title="17.5.1.34 レプリケーションとトランザクションの非一貫性">セクション17.5.1.34「レプリケーションとトランザクションの非一貫性」</a>をご覧ください。 
      </p><p>
        失敗したマルチスレッドレプリカをシングルスレッドモードに変更するには、次に示す順序で次の一連のステートメントを発行します:
      </p><pre class="programlisting">START {REPLICA | SLAVE} UNTIL SQL_AFTER_MTS_GAPS;

SET @@GLOBAL.slave_parallel_workers = 0;

START {REPLICA | SLAVE} SQL_THREAD;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">SHOW PROCESSLIST</code> の出力では、実行中の <code class="literal">START REPLICA | SLAVE</code> ステートメントのテキスト全体 (使用されている <code class="literal">USER</code> または <code class="literal">PASSWORD</code> の値を含む) を表示できます。 これは、実行中の <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントのテキスト (<code class="literal">SOURCE_USER</code> | <code class="literal">MASTER_USER</code> または <code class="literal">SOURCE_PASSWORD</code> | <code class="literal">MASTER_PASSWORD</code> に使用する値を含む) にも当てはまります。 
        </p></div><p>
        レプリケーション I/O スレッドとレプリケーション SQL スレッドの両方が起動した後、<code class="literal">START REPLICA | SLAVE</code> はユーザーに確認を送信します。 ただし、レプリケーション I/O スレッドがまだ接続されていない可能性があります。 このため、<code class="literal">START REPLICA | SLAVE</code> が成功すると <code class="literal">SHOW REPLICA | SLAVE STATUS</code> に <code class="literal">Replica_SQL_Running=Yes</code> が表示されますが、<code class="literal">Replica_IO_Running=Yes</code> は保証されません (I/O スレッドが<span class="emphasis"><em>および接続済</em></span>を実行している場合のみ <code class="literal">Replica_IO_Running=Yes</code> であるため)。 詳細は、<a class="xref" href="sql-statements.html#show-replica-status" title="13.7.7.35 SHOW REPLICA | SLAVE STATUS ステートメント">セクション13.7.7.35「SHOW REPLICA | SLAVE STATUS ステートメント」</a>および<a class="xref" href="replication.html#replication-administration-status" title="17.1.7.1 レプリケーションステータスの確認">セクション17.1.7.1「レプリケーションステータスの確認」</a>を参照してください。 
      </p><p>
        レプリケーション SQL スレッドがソースバイナリログまたはレプリカリレーログ内の特定のポイントに到達するまでレプリカを起動して実行するように指定するために、<code class="literal">UNTIL</code> 句 (前述の文法では <em class="replaceable"><code>until_option</code></em>) を追加できます。 次のいずれかのオプションのペアを使用して、位置を指定します: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            バイナリログ用の <code class="literal">MASTER_LOG_POS</code> および <code class="literal">MASTER_LOG_FILE</code> (MySQL 8.0.22 へ)。
          </p></li><li class="listitem"><p>
            バイナリログ用の <code class="literal">SOURCE_LOG_POS</code> および <code class="literal">SOURCE_LOG_FILE</code> (MySQL 8.0.23 から)。
          </p></li><li class="listitem"><p>
            リレーログ用の <code class="literal">RELAY_LOG_POS</code> および <code class="literal">RELAY_LOG_FILE</code>。
          </p></li></ul></div><p>
        圧縮トランザクションペイロードの場合、位置は圧縮された <code class="literal">Transaction_payload_event</code> に基づいている必要があります。 SQL スレッドは、指定されたポイントに達すると停止します。 このステートメントで <code class="literal">SQL_THREAD</code> オプションが指定されている場合、このオプションは SQL スレッドのみを開始します。 それ以外の場合は、両方のレプリケーションスレッドを起動します。 SQL スレッドが実行中である場合、<code class="literal">UNTIL</code> 句は無視され、警告が発行されます。 <code class="literal">UNTIL</code> 句を <code class="literal">IO_THREAD</code> オプションとともに使用することはできません。 
      </p><p>
        このセクションで前述したように、<code class="literal">START REPLICA | SLAVE UNTIL</code> では、<code class="literal">SQL_BEFORE_GTIDS</code> または <code class="literal">SQL_AFTER_GTIDS</code> のいずれかのオプションを使用して、特定の GTID または GTID のセットに対して相対的な停止ポイントを指定することもできます。 これらのオプションのいずれかを使用している場合は、<code class="literal">SQL_THREAD</code> または <code class="literal">IO_THREAD</code>、あるいはこれらの両方を指定できます。また、どちらも指定しないことも可能です。 <code class="literal">SQL_THREAD</code> のみを指定した場合、レプリケーション SQL スレッドのみがステートメントの影響を受けます。<code class="literal">IO_THREAD</code> のみを使用した場合、レプリケーション I/O スレッドのみが影響を受けます。 <code class="literal">SQL_THREAD</code> と <code class="literal">IO_THREAD</code> の両方が使用されている場合、またはそのどちらも使用されていない場合は、SQL スレッドと I/O スレッドの両方がこのステートメントの影響を受けます。 
      </p><p>
        <code class="literal">UNTIL</code> 句では、次のいずれかを指定する必要があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ログファイル名とそのファイル内の位置<span class="emphasis"><em>の両方</em></span>
          </p></li><li class="listitem"><p>
            <code class="literal">SQL_BEFORE_GTIDS</code> または <code class="literal">SQL_AFTER_GTIDS</code> の<span class="emphasis"><em>いずれか</em></span>
          </p></li><li class="listitem"><p>
            <code class="literal">SQL_AFTER_MTS_GAPS</code>
          </p></li></ul></div><p>
        ソースとリレーログオプションを混在させないでください。 ログファイルオプションと GTID オプションを混在させないでください。 
      </p><p>
        <code class="literal">UNTIL</code> 句は、<code class="literal">SQL_AFTER_MTS_GAPS</code> も使用している場合を除き、マルチスレッドレプリカではサポートされません。 <code class="literal">UNTIL</code> が <code class="literal">SQL_AFTER_MTS_GAPS</code> のないマルチスレッドレプリカで使用されている場合、レプリカは、<code class="literal">UNTIL</code> 句で指定されたポイントに達するまで、レプリケーションのためにシングルスレッド (順次) モードで動作します。 
      </p><p>
        <code class="literal">UNTIL</code> 条件は、後続の <code class="literal">STOP REPLICA | SLAVE</code> ステートメント、<code class="literal">UNTIL</code> 句を含まない <code class="literal">START REPLICA | SLAVE</code> ステートメント、またはサーバーの再起動によってリセットされます。
      </p><p>
        ログファイルと位置を指定する場合、このステートメントの影響を受けるのは SQL スレッドのみですが、<code class="literal">START REPLICA | SLAVE ... UNTIL</code> で <code class="literal">IO_THREAD</code> オプションを使用できます。 このような場合、<code class="literal">IO_THREAD</code> オプションは無視されます。 GTID オプション (<code class="literal">SQL_BEFORE_GTIDS</code> および <code class="literal">SQL_AFTER_GTIDS</code>) のいずれかを使用する場合、前述の制限は適用されません。GTID オプションでは、このセクションで前述した <code class="literal">SQL_THREAD</code> と <code class="literal">IO_THREAD</code> の両方がサポートされます。 
      </p><p>
        <code class="literal">UNTIL</code> 句は、レプリケーションをデバッグしたり、レプリカがイベントをレプリケートしないようにする直前までレプリケーションを続行させる場合に役立ちます。 たとえば、ソースで無関係な <code class="literal">DROP TABLE</code> ステートメントが実行された場合、<code class="literal">UNTIL</code> を使用してレプリカにその時点まで実行するが、それ以上実行しないように指示できます。 イベントの内容を確認するには、ソースバイナリログまたはレプリカリレーログとともに <span class="command"><strong>mysqlbinlog</strong></span> を使用するか、<code class="literal">SHOW BINLOG EVENTS</code> ステートメントを使用します。 
      </p><p>
        <code class="literal">UNTIL</code> を使用してレプリカプロセスのレプリケートされたクエリーをセクションに含める場合は、レプリカサーバーの起動時に SQL スレッドが実行されないように、<code class="option">--skip-slave-start</code> オプションを指定してレプリカを起動することをお薦めします。 このオプションはおそらく、予期しないサーバーの再起動によって忘れてしまうことがないように、コマンド行ではなく、オプションファイルで使用することが最善です。 
      </p><p>
        <code class="literal">SHOW REPLICA | SLAVE STATUS</code> ステートメントには、<code class="literal">UNTIL</code> 条件の現在の値を表示する出力フィールドが含まれます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="start-slave"></a>13.4.2.8 START SLAVE | REPLICA ステートメント</h4></div></div></div><a class="indexterm" name="idm45826994326336"></a><pre class="programlisting">START {SLAVE | REPLICA} [<em class="replaceable"><code>thread_types</code></em>] [<em class="replaceable"><code>until_option</code></em>] [<em class="replaceable"><code>connection_options</code></em>] [<em class="replaceable"><code>channel_option</code></em>]

<em class="replaceable"><code>thread_types</code></em>:
    [<em class="replaceable"><code>thread_type</code></em> [, <em class="replaceable"><code>thread_type</code></em>] ... ]

<em class="replaceable"><code>thread_type</code></em>:
    IO_THREAD | SQL_THREAD

<em class="replaceable"><code>until_option</code></em>:
    UNTIL {   {SQL_BEFORE_GTIDS | SQL_AFTER_GTIDS} = <em class="replaceable"><code>gtid_set</code></em>
          |   MASTER_LOG_FILE = '<em class="replaceable"><code>log_name</code></em>', MASTER_LOG_POS = <em class="replaceable"><code>log_pos</code></em>
          |   SOURCE_LOG_FILE = '<em class="replaceable"><code>log_name</code></em>', SOURCE_LOG_POS = <em class="replaceable"><code>log_pos</code></em>
          |   RELAY_LOG_FILE = '<em class="replaceable"><code>log_name</code></em>', RELAY_LOG_POS = <em class="replaceable"><code>log_pos</code></em>
          |   SQL_AFTER_MTS_GAPS  }

<em class="replaceable"><code>connection_options</code></em>:
    [USER='<em class="replaceable"><code>user_name</code></em>'] [PASSWORD='<em class="replaceable"><code>user_pass</code></em>'] [DEFAULT_AUTH='<em class="replaceable"><code>plugin_name</code></em>'] [PLUGIN_DIR='<em class="replaceable"><code>plugin_dir</code></em>']


<em class="replaceable"><code>channel_option</code></em>:
    FOR CHANNEL <em class="replaceable"><code>channel</code></em>

<em class="replaceable"><code>gtid_set</code></em>:
    <em class="replaceable"><code>uuid_set</code></em> [, <em class="replaceable"><code>uuid_set</code></em>] ...
    | ''

<em class="replaceable"><code>uuid_set</code></em>:
    <em class="replaceable"><code>uuid</code></em>:<em class="replaceable"><code>interval</code></em>[:<em class="replaceable"><code>interval</code></em>]...

<em class="replaceable"><code>uuid</code></em>:
    <em class="replaceable"><code>hhhhhhhh</code></em>-<em class="replaceable"><code>hhhh</code></em>-<em class="replaceable"><code>hhhh</code></em>-<em class="replaceable"><code>hhhh</code></em>-<em class="replaceable"><code>hhhhhhhhhhhh</code></em>

<em class="replaceable"><code>h</code></em>:
    [0-9,A-F]

<em class="replaceable"><code>interval</code></em>:
    <em class="replaceable"><code>n</code></em>[-<em class="replaceable"><code>n</code></em>]

    (<em class="replaceable"><code>n</code></em> &gt;= 1)
</pre><p>
        レプリケーションスレッドを起動します。 MySQL 8.0.22 からは、<code class="literal">START SLAVE</code> は非推奨であり、かわりにエイリアス <code class="literal">START REPLICA</code> を使用する必要があります。 ステートメントは以前と同様に機能し、ステートメントおよびその出力に使用される用語のみが変更されています。 どちらのバージョンのステートメントも、使用時に同じステータス変数を更新します。 ステートメントの説明は、<code class="literal">START REPLICA</code> のドキュメントを参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="stop-replica"></a>13.4.2.9 STOP REPLICA | SLAVE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826994297264"></a><pre class="programlisting">STOP {REPLICA | SLAVE} [<em class="replaceable"><code>thread_types</code></em>] [<em class="replaceable"><code>channel_option</code></em>]

<em class="replaceable"><code>thread_types</code></em>:
    [<em class="replaceable"><code>thread_type</code></em> [, <em class="replaceable"><code>thread_type</code></em>] ... ]

<em class="replaceable"><code>thread_type</code></em>: IO_THREAD | SQL_THREAD

<em class="replaceable"><code>channel_option</code></em>:
    FOR CHANNEL <em class="replaceable"><code>channel</code></em>

</pre><p>
        レプリケーションスレッドを停止します。 MySQL 8.0.22 から、<code class="literal">STOP SLAVE</code> のかわりに <code class="literal">STOP REPLICA</code> を使用します。これは非推奨になりました。 MySQL 8.0.22 より前のリリースでは、<code class="literal">STOP SLAVE</code> を使用します。 
      </p><p>
        <code class="literal">STOP REPLICA | SLAVE</code> には、<code class="literal">REPLICATION_SLAVE_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。 推奨されるベストプラクティスは、レプリカサーバーを停止する前にレプリカで <code class="literal">STOP REPLICA | SLAVE</code> を実行することです (詳細は、<a class="xref" href="server-administration.html#server-shutdown" title="5.1.19 サーバーの停止プロセス">セクション5.1.19「サーバーの停止プロセス」</a> を参照してください)。 
      </p><p>
        <code class="literal">START REPLICA | SLAVE</code> と同様に、このステートメントを <code class="literal">IO_THREAD</code> および <code class="literal">SQL_THREAD</code> オプションとともに使用して、停止するレプリケーションスレッドの名前を指定できます。 グループレプリケーションアプライヤチャネル (<code class="literal">group_replication_applier</code>) にはレプリケーション I/O スレッドがなく、レプリケーション SQL スレッドのみがあることに注意してください。 したがって、<code class="literal">SQL_THREAD</code> オプションを使用すると、このチャネルは完全に停止します。 
      </p><p>
        <code class="literal">STOP REPLICA | SLAVE</code> では、進行中のトランザクションが暗黙的にコミットされます。 <a class="xref" href="sql-statements.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。 
      </p><p>
        このステートメントを発行する前に、<code class="literal">gtid_next</code> を <code class="literal">AUTOMATIC</code> に設定する必要があります。
      </p><p>
        <code class="literal">rpl_stop_slave_timeout</code> システム変数を設定することで、<code class="literal">STOP REPLICA | SLAVE</code> がタイムアウトするまでの待機時間を制御できます。 これを使用すると、レプリカへの異なるクライアント接続を使用する <code class="literal">STOP REPLICA | SLAVE</code> と他の SQL ステートメントの間のデッドロックを回避できます。 タイムアウト値に達すると、発行元クライアントはエラーメッセージを返して待機を停止しますが、<code class="literal">STOP REPLICA | SLAVE</code> 命令は有効なままです。 レプリケーションスレッドがビジー状態でなくなると、<code class="literal">STOP REPLICA | SLAVE</code> ステートメントが実行され、レプリカが停止します。 
      </p><p>
        一部の <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントは、レプリケーションスレッドの状態に応じて、レプリカの実行中に許可されます。 ただし、このような場合、<code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントを実行する前の <code class="literal">STOP REPLICA | SLAVE</code> の使用は引き続きサポートされています。 詳細は、<a class="xref" href="sql-statements.html#change-replication-source-to" title="13.4.2.3 CHANGE REPLICATION SOURCE TO ステートメント">セクション13.4.2.3「CHANGE REPLICATION SOURCE TO ステートメント」</a>、<a class="xref" href="sql-statements.html#change-master-to" title="13.4.2.1 CHANGE MASTER TO ステートメント">セクション13.4.2.1「CHANGE MASTER TO ステートメント」</a> および <a class="xref" href="replication.html#replication-solutions-switch" title="17.4.8 フェイルオーバー中のソースの切替え">セクション17.4.8「フェイルオーバー中のソースの切替え」</a> を参照してください。 
      </p><p>
        オプションの <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を使用すると、ステートメントが適用されるレプリケーションチャネルの名前を指定できます。 <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を指定すると、<code class="literal">STOP REPLICA | SLAVE</code> ステートメントが特定のレプリケーションチャネルに適用されます。 チャネルが指定されておらず、追加のチャネルが存在しない場合、ステートメントはデフォルトチャネルに適用されます。 複数のチャネルを使用しているときに <code class="literal">STOP REPLICA | SLAVE</code> ステートメントがチャネルを指定しない場合、このステートメントはすべてのチャネルの指定されたスレッドを停止します。 このステートメントは、<code class="literal">group_replication_recovery</code> チャネルでは使用できません。 詳しくは<a class="xref" href="replication.html#replication-channels" title="17.2.2 レプリケーションチャネル">セクション17.2.2「レプリケーションチャネル」</a>をご覧ください。 
      </p><p>
        レプリカがマルチスレッド化されている場合 (<code class="literal">slave_parallel_workers</code> はゼロ以外の値)、リレーログから実行された一連のトランザクションのギャップはワーカースレッドの停止の一環として閉じられます。 <code class="literal">STOP REPLICA | SLAVE</code> ステートメントの実行中にレプリカが予期せず (ワーカースレッドのエラーや <code class="literal">KILL</code> を発行する別のスレッドが原因など) 停止した場合、リレーログから実行されたトランザクションの順序に一貫性がなくなる可能性があります。 詳しくは<a class="xref" href="replication.html#replication-features-transaction-inconsistencies" title="17.5.1.34 レプリケーションとトランザクションの非一貫性">セクション17.5.1.34「レプリケーションとトランザクションの非一貫性」</a>,をご覧ください。 
      </p><p>
        ソースが行ベースのバイナリロギング形式を使用している場合、非トランザクションストレージエンジンを使用するテーブルをレプリケートするときは、レプリカサーバーをシャットダウンする前に、レプリカで <code class="literal">STOP REPLICA | SLAVE</code> または <code class="literal">STOP REPLICA | SLAVE SQL_THREAD</code> を実行するようにしてください。 現在のレプリケーションイベントグループが 1 つ以上の非トランザクションテーブルを変更した場合、レプリケーション SQL スレッドに対して <code class="literal">KILL QUERY</code> または <code class="literal">KILL CONNECTION</code> ステートメントを発行しないかぎり、<code class="literal">STOP REPLICA | SLAVE</code> はイベントグループが完了するまで最大 60 秒待機します。 タイムアウト後もイベントグループが不完全なままである場合は、エラーメッセージが記録されます。 
      </p><p>
        ソースがステートメントベースのバイナリロギング形式を使用している場合、開いている一時テーブルがある間にソースを変更することは安全でない可能性があります。 これは、一時テーブルのステートメントベースレプリケーションが推奨されない理由の 1 つです。 レプリカに一時テーブルがあるかどうかは、<code class="literal">Slave_open_temp_tables</code> の値で確認できます。ステートメントベースレプリケーションを使用する場合は、<code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> を実行する前にこの値を 0 にする必要があります。 レプリカで開いている一時テーブルがある場合、<code class="literal">STOP REPLICA | SLAVE</code> の発行後に <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントを発行すると、<code class="literal">ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO</code> 警告が表示されます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="stop-slave"></a>13.4.2.10 STOP SLAVE | REPLICA ステートメント</h4></div></div></div><a class="indexterm" name="idm45826994228304"></a><pre class="programlisting">STOP {SLAVE | REPLICA} [<em class="replaceable"><code>thread_types</code></em>] [<em class="replaceable"><code>channel_option</code></em>]

<em class="replaceable"><code>thread_types</code></em>:
    [<em class="replaceable"><code>thread_type</code></em> [, <em class="replaceable"><code>thread_type</code></em>] ... ]

<em class="replaceable"><code>thread_type</code></em>: IO_THREAD | SQL_THREAD

<em class="replaceable"><code>channel_option</code></em>:
    FOR CHANNEL <em class="replaceable"><code>channel</code></em>

</pre><p>
        レプリケーションスレッドを停止します。 MySQL 8.0.22 からは、<code class="literal">STOP SLAVE</code> は非推奨であり、かわりにエイリアス <code class="literal">STOP REPLICA</code> を使用する必要があります。 ステートメントは以前と同様に機能し、ステートメントおよびその出力に使用される用語のみが変更されています。 どちらのバージョンのステートメントも、使用時に同じステータス変数を更新します。 ステートメントの説明は、<code class="literal">STOP REPLICA</code> のドキュメントを参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-functions-source-list"></a>13.4.2.11 ソースリストを構成する関数</h4></div></div></div><p>
        標準ソースからレプリカレプリケーションの場合は MySQL 8.0.22 から、Group Replication の場合は MySQL 8.0.23 から使用可能な次の機能を使用すると、レプリケーションチャネルのソースリストに対してレプリケーションソースサーバーを追加および削除できます。 非同期接続フェイルオーバーメカニズムは、レプリカからソースへの既存の接続が失敗した後、適切なリストから新しいソースへの非同期 (ソースからレプリカへの) レプリケーション接続を自動的に確立します。 MySQL 8.0.23 からは、現在接続されているソースの重み付け優先度がグループ内で最も高い場合にも接続が変更されます。 管理対象グループの一部として定義されている Group Replication ソースサーバーの場合、現在接続されているソースがグループから離れているか、その大部分ではなくなった場合、接続は別のグループメンバーにもフェイルオーバーされます。 メカニズムの詳細は、<a class="xref" href="replication.html#replication-asynchronous-connection-failover" title="17.4.9 非同期接続フェイルオーバーによるソースの切替え">セクション17.4.9「非同期接続フェイルオーバーによるソースの切替え」</a> を参照してください。 
      </p><p>
        ソースリストは <code class="literal">mysql.replication_asynchronous_connection_failover</code> および <code class="literal">mysql.replication_asynchronous_connection_failover_managed</code> テーブルに格納され、「パフォーマンススキーマ」テーブル <code class="literal">replication_asynchronous_connection_failover</code> で表示できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="function_asynchronous-connection-failover-add-source"></a>
            <code class="literal">asynchronous_connection_failover_add_source()</code>
          </p><a class="indexterm" name="idm45826994205216"></a><a class="indexterm" name="idm45826994204064"></a><p>
            レプリケーションソースサーバーの構成情報をレプリケーションチャネルのソースリストに追加します。
          </p><p>
            構文:
          </p><pre class="programlisting">asynchronous_connection_failover_add_source(<em class="replaceable"><code>channel</code></em>, <em class="replaceable"><code>host</code></em>, <em class="replaceable"><code>port</code></em>, <em class="replaceable"><code>network_namespace</code></em>, <em class="replaceable"><code>weight</code></em>)</pre><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <em class="replaceable"><code>channel</code></em>: このレプリケーションソースサーバーがソースリストの一部であるレプリケーションチャネル。
              </p></li><li class="listitem"><p>
                <em class="replaceable"><code>host</code></em>: このレプリケーションソースサーバーのホスト名。
              </p></li><li class="listitem"><p>
                <em class="replaceable"><code>port</code></em>: このレプリケーションソースサーバーのポート番号。
              </p></li><li class="listitem"><p>
                <em class="replaceable"><code>network_namespace</code></em>: このレプリケーションソースサーバーのネットワークネームスペース。 このパラメータは将来の使用のために予約されているため、空の文字列を指定してください。 
              </p></li><li class="listitem"><p>
                <em class="replaceable"><code>weight</code></em>: レプリケーションチャネルソースリスト内のこのレプリケーションソースサーバーの優先度。 優先度は 1 から 100 で、100 が最高、50 がデフォルトです。 非同期接続フェイルオーバーメカニズムがアクティブ化されると、チャネルのソースリストにリストされている代替ソースの中で優先度が最も高いソースが最初の接続試行に選択されます。 この試行が機能しない場合、レプリカはリストされているすべてのソースを優先度の降順で試行し、優先度の最も高いソースから再開します。 複数のソースの優先度が同じ場合、レプリカはそれらをランダムに順序付けします。 MySQL 8.0.23 では、現在接続されているソースがグループ内で最も重み付けされていない場合、非同期接続フェイルオーバーメカニズムがアクティブ化されます。 
              </p></li></ul></div><p>
            戻り値:
          </p><p>
            成功したかどうかなど、操作の結果を含む文字列。
          </p><p>
            例:
          </p><pre class="programlisting"><strong class="userinput"><code>SELECT asynchronous_connection_failover_add_source('channel2', '127.0.0.1', 3310, '', 80);</code></strong>
+-------------------------------------------------------------------------------------------------+
| asynchronous_connection_failover_add_source('channel2', '127.0.0.1', 3310, '', 80)              |
+-------------------------------------------------------------------------------------------------+
| Source configuration details successfully inserted.                                             |
+-------------------------------------------------------------------------------------------------+
</pre><p>
            詳細は、<a class="xref" href="replication.html#replication-asynchronous-connection-failover" title="17.4.9 非同期接続フェイルオーバーによるソースの切替え">セクション17.4.9「非同期接続フェイルオーバーによるソースの切替え」</a>を参照してください。
          </p></li><li class="listitem"><p><a name="function_asynchronous-connection-failover-delete-source"></a>
            <code class="literal">asynchronous_connection_failover_delete_source()</code>
          </p><a class="indexterm" name="idm45826994180832"></a><a class="indexterm" name="idm45826994179680"></a><p>
            レプリケーションチャネルのソースリストからレプリケーションソースサーバーの構成情報を削除します。
          </p><p>
            構文:
          </p><pre class="programlisting">asynchronous_connection_failover_delete_source(<em class="replaceable"><code>channel</code></em>, <em class="replaceable"><code>host</code></em>, <em class="replaceable"><code>port</code></em>, <em class="replaceable"><code>network_namespace</code></em>)</pre><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <em class="replaceable"><code>channel</code></em>: このレプリケーションソースサーバーがソースリストの一部であったレプリケーションチャネル。
              </p></li><li class="listitem"><p>
                <em class="replaceable"><code>host</code></em>: このレプリケーションソースサーバーのホスト名。
              </p></li><li class="listitem"><p>
                <em class="replaceable"><code>port</code></em>: このレプリケーションソースサーバーのポート番号。
              </p></li><li class="listitem"><p>
                <em class="replaceable"><code>network_namespace</code></em>: このレプリケーションソースサーバーのネットワークネームスペース。 このパラメータは将来の使用のために予約されているため、空の文字列を指定してください。 
              </p></li></ul></div><p>
            戻り値:
          </p><p>
            成功したかどうかなど、操作の結果を含む文字列。
          </p><p>
            例:
          </p><pre class="programlisting"><strong class="userinput"><code>SELECT asynchronous_connection_failover_delete_source('channel2', '127.0.0.1', 3310, '');</code></strong>
+------------------------------------------------------------------------------------------------+
| asynchronous_connection_failover_delete_source('channel2', '127.0.0.1', 3310, '')              |
+------------------------------------------------------------------------------------------------+
| Source configuration details successfully deleted.                                             |
+------------------------------------------------------------------------------------------------+
</pre><p>
            詳細は、<a class="xref" href="replication.html#replication-asynchronous-connection-failover" title="17.4.9 非同期接続フェイルオーバーによるソースの切替え">セクション17.4.9「非同期接続フェイルオーバーによるソースの切替え」</a>を参照してください。
          </p></li><li class="listitem"><p><a name="function_asynchronous-connection-failover-add-managed"></a>
            <code class="literal">asynchronous_connection_failover_add_managed()</code>
          </p><a class="indexterm" name="idm45826994159872"></a><a class="indexterm" name="idm45826994158720"></a><p>
            管理対象グループ (Group Replication グループメンバー) の一部であるレプリケーションソースサーバーの構成情報を、レプリケーションチャネルのソースリストに追加します。 追加する必要があるグループメンバーは 1 つだけです。 レプリカは、現在のグループメンバーシップから残りを自動的に追加し、メンバーシップの変更に応じてソースリストを更新します。 
          </p><p>
            構文:
          </p><pre class="programlisting">asynchronous_connection_failover_add_managed(<em class="replaceable"><code>channel</code></em>, <em class="replaceable"><code>managed_type</code></em>, <em class="replaceable"><code>managed_name</code></em>, <em class="replaceable"><code>host</code></em>, <em class="replaceable"><code>port</code></em>, <em class="replaceable"><code>network_namespace</code></em>, <em class="replaceable"><code>primary_weight</code></em>, <em class="replaceable"><code>secondary_weight</code></em>)</pre><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <em class="replaceable"><code>channel</code></em>: このレプリケーションソースサーバーがソースリストの一部であるレプリケーションチャネル。
              </p></li><li class="listitem"><p>
                <em class="replaceable"><code>managed_type</code></em>: 非同期接続フェイルオーバーメカニズムがこのサーバーに提供する必要がある管理対象サービスのタイプ。 現在受け入れられている値は <code class="literal">GroupReplication</code> のみです。 
              </p></li><li class="listitem"><p>
                <em class="replaceable"><code>managed_name</code></em>: サーバーが属する管理対象グループの識別子。 <code class="literal">GroupReplication</code> 管理サービスの場合、identifier は <code class="literal">group_replication_group_name</code> システム変数の値です。 
              </p></li><li class="listitem"><p>
                <em class="replaceable"><code>host</code></em>: このレプリケーションソースサーバーのホスト名。
              </p></li><li class="listitem"><p>
                <em class="replaceable"><code>port</code></em>: このレプリケーションソースサーバーのポート番号。
              </p></li><li class="listitem"><p>
                <em class="replaceable"><code>network_namespace</code></em>: このレプリケーションソースサーバーのネットワークネームスペース。 このパラメータは将来の使用のために予約されているため、空の文字列を指定してください。 
              </p></li><li class="listitem"><p>
                <em class="replaceable"><code>primary_weight</code></em>: 管理対象グループのプライマリとして機能している場合の、レプリケーションチャネルソースリスト内のこのレプリケーションソースサーバーの優先度。 重みは 1～100 で、100 が最高です。 プライマリの場合、80 が適切な重みです。 非同期接続フェイルオーバーメカニズムは、現在接続されているソースがグループ内で最も重み付けされていない場合にアクティブになります。 プライマリに高い重みを与え、セカンダリに低い重みを与えるように管理対象グループを設定した場合、プライマリが変更されると、その重みが増加し、レプリカは接続を介して変更されます。 
              </p></li><li class="listitem"><p>
                <em class="replaceable"><code>secondary_weight</code></em>: このレプリケーションソースサーバーが管理対象グループのセカンダリとして機能している場合の、レプリケーションチャネルソースリスト内での優先度。 重みは 1～100 で、100 が最高です。 セカンダリの場合、60 が適切な重みです。 
              </p></li></ul></div><p>
            戻り値:
          </p><p>
            成功したかどうかなど、操作の結果を含む文字列。
          </p><p>
            例:
          </p><pre class="programlisting"><strong class="userinput"><code>SELECT asynchronous_connection_failover_add_managed('channel2', 'GroupReplication', 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa', '127.0.0.1', 3310, '', 80, 60);</code></strong>
+----------------------------------------------------------------------------------------------------------------------------------------------------+
| asynchronous_connection_failover_add_source('channel2', 'GroupReplication', 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa', '127.0.0.1', 3310, '', 80, 60) |
+----------------------------------------------------------------------------------------------------------------------------------------------------+
| Source managed configuration details successfully inserted.                                                                                        |
+----------------------------------------------------------------------------------------------------------------------------------------------------+
</pre><p>
            詳細は、<a class="xref" href="replication.html#replication-asynchronous-connection-failover" title="17.4.9 非同期接続フェイルオーバーによるソースの切替え">セクション17.4.9「非同期接続フェイルオーバーによるソースの切替え」</a>を参照してください。
          </p></li><li class="listitem"><p><a name="function_asynchronous-connection-failover-delete-managed"></a>
            <code class="literal">asynchronous_connection_failover_delete_managed()</code>
          </p><a class="indexterm" name="idm45826994127232"></a><a class="indexterm" name="idm45826994126080"></a><p>
            レプリケーションチャネルのソースリストから管理対象グループ全体を削除します。 この UDF を使用すると、管理対象グループで定義されたすべてのレプリケーションソースサーバーがチャネルソースリストから削除されます。 
          </p><p>
            構文:
          </p><pre class="programlisting">asynchronous_connection_failover_delete_managed(<em class="replaceable"><code>channel</code></em>, <em class="replaceable"><code>managed_name</code></em>)</pre><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <em class="replaceable"><code>channel</code></em>: このレプリケーションソースサーバーがソースリストの一部であったレプリケーションチャネル。
              </p></li><li class="listitem"><p>
                <em class="replaceable"><code>managed_name</code></em>: サーバーが属する管理対象グループの識別子。 <code class="literal">GroupReplication</code> 管理サービスの場合、identifier は <code class="literal">group_replication_group_name</code> システム変数の値です。 
              </p></li></ul></div><p>
            戻り値:
          </p><p>
            成功したかどうかなど、操作の結果を含む文字列。
          </p><p>
            例:
          </p><pre class="programlisting"><strong class="userinput"><code>SELECT asynchronous_connection_failover_delete_managed('channel2', 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa');</code></strong>
+-----------------------------------------------------------------------------------------------------+
| asynchronous_connection_failover_delete_managed('channel2', 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa') |
+-----------------------------------------------------------------------------------------------------+
| Source managed configuration details successfully deleted.                                          |
+-----------------------------------------------------------------------------------------------------+
</pre><p>
            詳細は、<a class="xref" href="replication.html#replication-asynchronous-connection-failover" title="17.4.9 非同期接続フェイルオーバーによるソースの切替え">セクション17.4.9「非同期接続フェイルオーバーによるソースの切替え」</a>を参照してください。
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-statements-group"></a>13.4.3 グループレプリケーションを制御するための SQL ステートメント</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#start-group-replication">13.4.3.1 START GROUP_REPLICATION ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#stop-group-replication">13.4.3.2 STOP GROUP_REPLICATION ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#group-replication-functions-for-new-primary">13.4.3.3 グループレプリケーションプライマリを構成する機能</a></span></dt><dt><span class="section"><a href="sql-statements.html#group-replication-functions-for-mode">13.4.3.4 グループレプリケーションモードを構成する関数</a></span></dt><dt><span class="section"><a href="sql-statements.html#group-replication-functions-for-maximum-consensus">13.4.3.5 グループの最大コンセンサスインスタンスを検査および構成する関数</a></span></dt><dt><span class="section"><a href="sql-statements.html#group-replication-functions-for-communication-protocol">13.4.3.6 グループレプリケーション通信プロトコルのバージョンを検査および設定する関数</a></span></dt></dl></div><a class="indexterm" name="idm45826994108480"></a><a class="indexterm" name="idm45826994106304"></a><a class="indexterm" name="idm45826994104240"></a><p>
      このセクションでは、グループレプリケーションの制御に使用されるステートメントについて説明します。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="start-group-replication"></a>13.4.3.1 START GROUP_REPLICATION ステートメント</h4></div></div></div><a class="indexterm" name="idm45826994100304"></a><pre class="programlisting">  START GROUP_REPLICATION
          [USER='<em class="replaceable"><code>user_name</code></em>']
          [, PASSWORD='<em class="replaceable"><code>user_pass</code></em>']
          [, DEFAULT_AUTH='<em class="replaceable"><code>plugin_name</code></em>']
</pre><p>
        グループレプリケーションを開始します。 このステートメントには、<code class="literal">GROUP_REPLICATION_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。 <code class="literal">super_read_only=ON</code> が設定されており、メンバーがプライマリとして参加する必要がある場合、グループレプリケーションが正常に開始されると、<code class="literal">super_read_only</code> は <code class="literal">OFF</code> に設定されます。 
      </p><p>
        MySQL 8.0.21 から、次のように <code class="literal">USER</code>、<code class="literal">PASSWORD</code> および <code class="literal">DEFAULT_AUTH</code> オプションを使用して、<code class="literal">START GROUP_REPLICATION</code> ステートメントで分散リカバリのユーザー資格証明を指定できます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">USER</code>: 分散リカバリのレプリケーションユーザー。 このアカウントを設定する手順は、<a class="xref" href="group-replication.html#group-replication-user-credentials" title="18.2.1.3 分散リカバリのユーザー資格証明">セクション18.2.1.3「分散リカバリのユーザー資格証明」</a> を参照してください。 <code class="literal">PASSWORD</code> が指定されている場合、空または null の文字列を指定したり、<code class="literal">USER</code> オプションを省略することはできません。 
          </p></li><li class="listitem"><p>
            <code class="literal">PASSWORD</code>: レプリケーションユーザーアカウントのパスワード。 パスワードは暗号化できませんが、クエリーログでマスクされます。 
          </p></li><li class="listitem"><p>
            <code class="literal">DEFAULT_AUTH</code>: レプリケーションユーザーアカウントに使用される認証プラグインの名前。 このオプションを指定しない場合、MySQL ネイティブ認証 (<code class="literal">mysql_native_password</code> プラグイン) が想定されます。 このオプションはサーバーへのヒントとして機能し、分散リカバリのドナーは、そのサーバー上のユーザーアカウントに別のプラグインが関連付けられている場合、それをオーバーライドします。 MySQL 8 でユーザーアカウントを作成するときにデフォルトで使用される認証プラグインは、キャッシュ SHA-2 認証プラグイン (<code class="literal">caching_sha2_password</code>) です。 認証プラグインの詳細は、<a class="xref" href="security.html#pluggable-authentication" title="6.2.17 プラガブル認証">セクション6.2.17「プラガブル認証」</a> を参照してください。 
          </p></li></ul></div><p>
        これらの資格証明は、<code class="literal">group_replication_recovery</code> チャネルでの分散リカバリに使用されます。 <code class="literal">START GROUP_REPLICATION</code> でユーザー資格証明を指定すると、資格証明はメモリーにのみ保存され、<code class="literal">STOP GROUP_REPLICATION</code> ステートメントまたはサーバーの停止によって削除されます。 資格証明を再度指定するには、<code class="literal">START GROUP_REPLICATION</code> ステートメントを発行する必要があります。 したがって、この方法は、<code class="literal">group_replication_start_on_boot</code> システム変数で指定されているように、サーバー起動時に Group Replication を自動的に起動する方法とは互換性がありません。 
      </p><p>
        <code class="literal">START GROUP_REPLICATION</code> で指定されたユーザー資格証明は、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 より前) を使用して <code class="literal">group_replication_recovery</code> チャネルに設定されたユーザー資格証明よりも優先されます。 これらのステートメントを使用して設定されたユーザー資格証明はレプリケーションメタデータリポジトリに格納され、<code class="literal">group_replication_start_on_boot</code> システム変数が <code class="literal">ON</code> に設定されている場合の自動起動など、ユーザー資格証明なしで <code class="literal">START GROUP_REPLICATION</code> が指定されている場合に使用されます。 <code class="literal">START GROUP_REPLICATION</code> でユーザー資格証明を指定するセキュリティ上の利点を得るには、<a class="xref" href="group-replication.html#group-replication-distributed-recovery-securing" title="18.5.3 分散リカバリ接続の保護">セクション18.5.3「分散リカバリ接続の保護」</a> の手順に従って、<code class="literal">group_replication_start_on_boot</code> が <code class="literal">OFF</code> (デフォルトは <code class="literal">ON</code>) に設定されていることを確認し、<code class="literal">group_replication_recovery</code> チャネルに以前に設定されたユーザー資格証明をクリアします。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="stop-group-replication"></a>13.4.3.2 STOP GROUP_REPLICATION ステートメント</h4></div></div></div><a class="indexterm" name="idm45826994056688"></a><pre class="programlisting">STOP GROUP_REPLICATION</pre><p>
        グループレプリケーションを停止します。 このステートメントには、<code class="literal">GROUP_REPLICATION_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。 <code class="literal">STOP GROUP_REPLICATION</code> を発行するとすぐに、メンバーは <code class="literal">super_read_only=ON</code> に設定され、グループレプリケーションの停止中にメンバーへの書込みができなくなります。 メンバーで実行されている他のレプリケーションチャネルも停止されます。 このメンバーでグループレプリケーションを開始するときに <code class="literal">START GROUP_REPLICATION</code> ステートメントで指定したユーザー資格証明はメモリーから削除されるため、グループレプリケーションを再度開始するときに指定する必要があります。 
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          このステートメントは、グループからサーバーインスタンスを削除するため、特に注意して使用してください。つまり、グループレプリケーションの一貫性保証メカニズムによって保護されなくなります。 完全に安全にするには、失効した読取りの可能性を回避するために、このステートメントを発行する前にアプリケーションがインスタンスに接続できないようにします。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-functions-for-new-primary"></a>13.4.3.3 グループレプリケーションプライマリを構成する機能</h4></div></div></div><p>
        次の関数を使用すると、単一プライマリレプリケーショングループのどのメンバーがプライマリであるかを構成できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="function_group-replication-set-as-primary"></a>
            <code class="literal">group_replication_set_as_primary()</code>
          </p><a class="indexterm" name="idm45826994041744"></a><a class="indexterm" name="idm45826994040624"></a><p>
            グループの特定のメンバーを新しいプライマリとして指名し、選択プロセスを上書きします。 新しいプライマリにするメンバーの <code class="literal">server_uuid</code> である <em class="replaceable"><code>member_uuid</code></em> を渡します。 単一プライマリモードで実行されているレプリケーショングループのメンバーに対して発行する必要があります。 
          </p><p>
            構文:
          </p><pre class="programlisting">STRING group_replication_set_as_primary(<em class="replaceable"><code>member_uuid</code></em>)</pre><p>
            戻り値:
          </p><p>
            成功したかどうかなど、操作の結果を含む文字列。
          </p><p>
            例:
          </p><pre class="programlisting">SELECT group_replication_set_as_primary(<em class="replaceable"><code>member_uuid</code></em>)</pre><p>
            詳細は、<a class="xref" href="group-replication.html#group-replication-changing-primary-member" title="18.4.1.1 グループプライマリメンバーの変更">セクション18.4.1.1「グループプライマリメンバーの変更」</a>を参照してください
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-functions-for-mode"></a>13.4.3.4 グループレプリケーションモードを構成する関数</h4></div></div></div><p>
        次の関数を使用すると、レプリケーショングループが実行されているモード (単一プライマリモードまたはマルチプライマリモード) を制御できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="function_group-replication-switch-to-single-primary-mode"></a>
            <code class="literal">group_replication_switch_to_single_primary_mode()</code>
          </p><a class="indexterm" name="idm45826994024240"></a><a class="indexterm" name="idm45826994023088"></a><p>
            グループレプリケーションを停止せずに、マルチプライマリモードで実行されているグループを単一プライマリモードに変更します。 マルチプライマリモードで実行されているレプリケーショングループのメンバーに対して発行する必要があります。 シングルプライマリモードに変更すると、シングルプライマリモード (<code class="literal">group_replication_enforce_update_everywhere_checks=OFF</code>) での必要に応じて、すべてのグループメンバーで厳密な整合性チェックも無効になります。 
          </p><p>
            構文:
          </p><pre class="programlisting">STRING group_replication_switch_to_single_primary_mode([<em class="replaceable"><code>str</code></em>])</pre><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <em class="replaceable"><code>str</code></em>: 新しい単一のプライマリになるグループのメンバーの UUID を含む文字列。 グループの他のメンバーはセカンダリになります。 
              </p></li></ul></div><p>
            戻り値:
          </p><p>
            成功したかどうかなど、操作の結果を含む文字列。
          </p><p>
            例:
          </p><pre class="programlisting"><strong class="userinput"><code>SELECT group_replication_switch_to_single_primary_mode(<em class="replaceable"><code>member_uuid</code></em>);</code></strong>
</pre><p>
            詳細は、<a class="xref" href="group-replication.html#group-replication-changing-group-mode" title="18.4.1.2 グループモードの変更">セクション18.4.1.2「グループモードの変更」</a>を参照してください
          </p></li><li class="listitem"><p><a name="function_group-replication-switch-to-multi-primary-mode"></a>
            <code class="literal">group_replication_switch_to_multi_primary_mode()</code>
          </p><a class="indexterm" name="idm45826994007488"></a><a class="indexterm" name="idm45826994006336"></a><p>
            シングルプライマリモードで実行されているグループをマルチプライマリモードに変更します。 単一プライマリモードで実行されているレプリケーショングループのメンバーに対して発行する必要があります。 
          </p><p>
            構文:
          </p><pre class="programlisting">STRING group_replication_switch_to_multi_primary_mode()</pre><p>
            この関数にはパラメータがありません。
          </p><p>
            戻り値:
          </p><p>
            成功したかどうかなど、操作の結果を含む文字列。
          </p><p>
            例:
          </p><pre class="programlisting">SELECT group_replication_switch_to_multi_primary_mode()</pre><p>
            グループに属するすべてのメンバーがプライマリになります。
          </p><p>
            詳細は、<a class="xref" href="group-replication.html#group-replication-changing-group-mode" title="18.4.1.2 グループモードの変更">セクション18.4.1.2「グループモードの変更」</a>を参照してください
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-functions-for-maximum-consensus"></a>13.4.3.5 グループの最大コンセンサスインスタンスを検査および構成する関数</h4></div></div></div><p>
        次の機能を使用すると、グループがパラレルに実行できるコンセンサスインスタンスの最大数を検査および構成できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="function_group-replication-get-write-concurrency"></a>
            <code class="literal">group_replication_get_write_concurrency()</code>
          </p><a class="indexterm" name="idm45826993992096"></a><a class="indexterm" name="idm45826993990944"></a><p>
            グループがパラレルに実行できるコンセンサスインスタンスの最大数を確認します。
          </p><p>
            構文:
          </p><pre class="programlisting">INT group_replication_get_write_concurrency()
</pre><p>
            この関数にはパラメータがありません。
          </p><p>
            戻り値:
          </p><p>
            グループに現在設定されているコンセンサスインスタンスの最大数。
          </p><p>
            例:
          </p><pre class="programlisting">SELECT group_replication_get_write_concurrency()</pre><p>
            詳細は、<a class="xref" href="group-replication.html#group-replication-group-write-consensus" title="18.4.1.3 グループレプリケーショングループ書込みコンセンサスの使用">セクション18.4.1.3「グループレプリケーショングループ書込みコンセンサスの使用」</a>を参照してください。
          </p></li><li class="listitem"><p><a name="function_group-replication-set-write-concurrency"></a>
            <code class="literal">group_replication_set_write_concurrency()</code>
          </p><a class="indexterm" name="idm45826993979968"></a><a class="indexterm" name="idm45826993978816"></a><p>
            グループがパラレルに実行できるコンセンサスインスタンスの最大数を構成します。 この UDF を使用するには、<code class="literal">GROUP_REPLICATION_ADMIN</code> 権限が必要です。 
          </p><p>
            構文:
          </p><pre class="programlisting">STRING group_replication_set_write_concurrency(<em class="replaceable"><code>instances</code></em>)
</pre><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <em class="replaceable"><code>members</code></em>: グループがパラレルに実行できるコンセンサスインスタンスの最大数を設定します。 デフォルト値は 10 で、有効な値は 10 から 200 の範囲の整数です。 
              </p></li></ul></div><p>
            戻り値:
          </p><p>
            文字列としての結果のエラー。
          </p><p>
            例:
          </p><pre class="programlisting"><strong class="userinput"><code>SELECT group_replication_set_write_concurrency(<em class="replaceable"><code>instances</code></em>);</code></strong>
</pre><p>
            詳細は、<a class="xref" href="group-replication.html#group-replication-group-write-consensus" title="18.4.1.3 グループレプリケーショングループ書込みコンセンサスの使用">セクション18.4.1.3「グループレプリケーショングループ書込みコンセンサスの使用」</a>を参照してください。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-replication-functions-for-communication-protocol"></a>13.4.3.6 グループレプリケーション通信プロトコルのバージョンを検査および設定する関数</h4></div></div></div><p>
        次の機能を使用すると、レプリケーショングループで使用されるグループレプリケーション通信プロトコルのバージョンを検査および構成できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="function_group-replication-get-communication-protocol"></a>
            <code class="literal">group_replication_get_communication_protocol()</code>
          </p><a class="indexterm" name="idm45826993961104"></a><a class="indexterm" name="idm45826993959952"></a><p>
            グループで現在使用されている Group Replication 通信プロトコルのバージョンを調べます。
          </p><p>
            構文:
          </p><pre class="programlisting">STRING group_replication_get_communication_protocol()
</pre><p>
            この関数にはパラメータがありません。
          </p><p>
            戻り値:
          </p><p>
            このグループに参加し、グループ通信プロトコルを使用できる最も古い MySQL Server バージョン。 MySQL 5.7.14 のバージョンではメッセージを圧縮でき、MySQL 8.0.16 のバージョンではメッセージを断片化することもできます。 <code class="literal">group_replication_get_communication_protocol()</code> UDF は、グループがサポートする MySQL の最小バージョンを返します。これは、<code class="literal">group_replication_set_communication_protocol()</code> UDF に渡されたバージョン番号、および UDF を使用するメンバーにインストールされている MySQL Server バージョンとは異なる場合があります。 
          </p><p>
            このサーバーインスタンスがレプリケーショングループに属していないためにプロトコルを検査できない場合は、文字列としてエラーが返されます。
          </p><p>
            例:
          </p><pre class="programlisting"><strong class="userinput"><code>SELECT group_replication_get_communication_protocol();</code></strong>
+------------------------------------------------+
| group_replication_get_communication_protocol() |
+------------------------------------------------+
| 8.0.16                                         |
+------------------------------------------------+
</pre><p>
            詳細は、<a class="xref" href="group-replication.html#group-replication-communication-protocol" title="18.4.1.4 グループ通信プロトコルバージョンの設定">セクション18.4.1.4「グループ通信プロトコルバージョンの設定」</a>を参照してください。
          </p></li><li class="listitem"><p><a name="function_group-replication-set-communication-protocol"></a>
            <code class="literal">group_replication_set_communication_protocol()</code>
          </p><a class="indexterm" name="idm45826993944272"></a><a class="indexterm" name="idm45826993943120"></a><p>
            グループの Group Replication 通信プロトコルバージョンをダウングレードして、以前のリリースのメンバーがグループに参加できるようにするか、すべてのメンバーで MySQL Server をアップグレードした後に Group Replication 通信プロトコルバージョンをアップグレードします。 この UDF を使用するには <code class="literal">GROUP_REPLICATION_ADMIN</code> 権限が必要です。また、ステートメントを発行するときは、大部分を失うことなく、既存のすべてのグループメンバーがオンラインである必要があります。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              MySQL InnoDB クラスタの場合、AdminAPI 操作を使用してクラスタトポロジが変更されるたびに、通信プロトコルバージョンが自動的に管理されます。 InnoDB クラスタに対してこれらの UDF を自分で使用する必要はありません。 
            </p></div><p>
            構文:
          </p><pre class="programlisting">STRING group_replication_set_communication_protocol(<em class="replaceable"><code>version</code></em>)
</pre><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <em class="replaceable"><code>version</code></em>: ダウングレードの場合は、インストールされているサーバーバージョンが最も古い見込みグループメンバーの MySQL Server バージョンを指定します。 この場合、可能であれば、このコマンドによってグループはそのサーバーバージョンと互換性のある通信プロトコルにフォールバックされます。 指定できるサーバーの最小バージョンは MySQL 5.7.14 です。 アップグレードの場合は、既存のグループメンバーがアップグレードされた新しい MySQL Server バージョンを指定します。 
              </p></li></ul></div><p>
            戻り値:
          </p><p>
            成功したかどうかなど、操作の結果を含む文字列。
          </p><p>
            例:
          </p><pre class="programlisting"><strong class="userinput"><code>SELECT group_replication_set_communication_protocol("5.7.25");</code></strong>
</pre><p>
            詳細は、<a class="xref" href="group-replication.html#group-replication-communication-protocol" title="18.4.1.4 グループ通信プロトコルバージョンの設定">セクション18.4.1.4「グループ通信プロトコルバージョンの設定」</a>を参照してください。
          </p></li></ul></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sql-prepared-statements"></a>13.5 プリペアドステートメント</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#prepare">13.5.1 PREPARE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#execute">13.5.2 EXECUTE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#deallocate-prepare">13.5.3 DEALLOCATE PREPARE ステートメント</a></span></dt></dl></div><a class="indexterm" name="idm45826993925248"></a><a class="indexterm" name="idm45826993923760"></a><a class="indexterm" name="idm45826993922784"></a><a class="indexterm" name="idm45826993921696"></a><p>
    MySQL 8.0 は、サーバー側の準備済みステートメントをサポートしています。 このサポートは、効率的なクライアント/サーバーバイナリプロトコルを利用します。 パラメータ値のためのプレースホルダを含む準備済みステートメントの使用には、次の利点があります。 
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        ステートメントを実行のたびに解析するためのオーバーヘッドが少なくなります。 通常、データベースアプリケーションは、クエリーや削除の場合の <code class="literal">WHERE</code>、更新の場合の <code class="literal">SET</code>、挿入の場合の <code class="literal">VALUES</code> などの句でリテラルまたは変数値しか変更されていない、ほぼ同一の大量のステートメントを処理します。 
      </p></li><li class="listitem"><p>
        SQL インジェクション攻撃からの保護。 パラメータ値には、エスケープされていない SQL 引用符および区切り文字を含めることができます。 
      </p></li></ul></div><p>
    次の各セクションでは、プリペアドステートメントの特性の概要について説明します:
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#prepared-statements-in-applications" title="アプリケーションプログラムでの準備済みステートメント">アプリケーションプログラムでの準備済みステートメント</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#prepared-statements-in-scripts" title="SQL スクリプトでの準備済みステートメント">SQL スクリプトでの準備済みステートメント</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#prepared-statement-types" title="PREPARE、EXECUTE、および DEALLOCATE PREPARE ステートメント">PREPARE、EXECUTE、および DEALLOCATE PREPARE ステートメント</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#prepared-statements-permitted" title="プリペアドステートメントで許可される SQL 構文">プリペアドステートメントで許可される SQL 構文</a></p></li></ul></div><h3><a name="prepared-statements-in-applications"></a>アプリケーションプログラムでの準備済みステートメント</h3><p>
    サーバー側のプリペアドステートメントは、<a class="ulink" href="https://dev.mysql.com/doc/c-api/8.0/en/" target="_top">MySQL C API client library</a> for C プログラム、<a class="ulink" href="https://dev.mysql.com/doc/connector-j/8.0/en/" target="_top">MySQL Connector/J</a> for Java プログラム、<a class="ulink" href="https://dev.mysql.com/doc/connector-net/en/" target="_top">MySQL Connector/NET</a> for .NET テクノロジを使用するプログラムなど、クライアントプログラミングインタフェースを介して使用できます。 たとえば、C API は、その準備済みステートメント API を構成する一連の関数呼び出しを提供しています。 <a class="ulink" href="https://dev.mysql.com/doc/c-api/8.0/en/c-api-prepared-statement-interface.html" target="_top">C API Prepared Statement Interface</a>を参照してください。 他の言語インタフェースでは、PHP 5.0 以上で使用可能な<a class="ulink" href="http://php.net/mysqli" target="_top">「<code class="literal">mysqli</code> 拡張機能」</a>などの C クライアントライブラリにリンクすることで、バイナリプロトコルを使用するプリペアドステートメントをサポートできます。 
  </p><h3><a name="prepared-statements-in-scripts"></a>SQL スクリプトでの準備済みステートメント</h3><p>
    準備済みステートメントへの代替 SQL インタフェースを使用できます。 このインタフェースは、準備済みステートメント API 経由でのバイナリプロトコルの使用ほど効率的ではありませんが、SQL レベルで直接使用できるためプログラミングが必要ありません。 
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        使用できるプログラミングインタフェースが存在しない場合でも使用できます。
      </p></li><li class="listitem"><p>
        <span class="command"><strong>mysql</strong></span> クライアントプログラムなどの、サーバーに SQL ステートメントを送信して実行させることのできる任意のプログラムから使用できます。
      </p></li><li class="listitem"><p>
        これは、クライアントが古いバージョンのクライアントライブラリを使用している場合でも使用できます。
      </p></li></ul></div><p>
    準備済みステートメントのための SQL 構文は、次のような状況で使用されるように考慮されています。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        準備済みステートメントのコーディングの前に、それがアプリケーションでどのように動作するかをテストする場合。
      </p></li><li class="listitem"><p>
        サポートしているプログラミング API にアクセスできないときに準備済みステートメントを使用する場合。
      </p></li><li class="listitem"><p>
        準備済みステートメントに関するアプリケーションの問題を対話的にトラブルシューティングする場合。
      </p></li><li class="listitem"><p>
        バグレポートを提出できるように、準備済みステートメントに関する問題を再現するテストケースを作成する場合。
      </p></li></ul></div><h3><a name="prepared-statement-types"></a>PREPARE、EXECUTE、および DEALLOCATE PREPARE ステートメント</h3><p>
    準備済みステートメントのための SQL 構文は、次の 3 つの SQL ステートメントに基づいています。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">PREPARE</code> は、ステートメントを実行のために準備します (<a class="xref" href="sql-statements.html#prepare" title="13.5.1 PREPARE ステートメント">セクション13.5.1「PREPARE ステートメント」</a>を参照してください)。
      </p></li><li class="listitem"><p>
        <code class="literal">EXECUTE</code> は、準備済みステートメントを実行します (<a class="xref" href="sql-statements.html#execute" title="13.5.2 EXECUTE ステートメント">セクション13.5.2「EXECUTE ステートメント」</a>を参照してください)。
      </p></li><li class="listitem"><p>
        <code class="literal">DEALLOCATE PREPARE</code> は、準備済みステートメントを解放します (<a class="xref" href="sql-statements.html#deallocate-prepare" title="13.5.3 DEALLOCATE PREPARE ステートメント">セクション13.5.3「DEALLOCATE PREPARE ステートメント」</a>を参照してください)。
      </p></li></ul></div><p>
    次の例は、2 辺の長さが与えられた三角形の斜辺を計算するステートメントを準備するための 2 つの同等の方法を示しています。
  </p><p>
    最初の例は、文字列リテラルを使用してステートメントのテキストを指定することによって準備済みステートメントを作成する方法を示しています。
  </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>PREPARE stmt1 FROM 'SELECT SQRT(POW(?,2) + POW(?,2)) AS hypotenuse';</code></strong>
mysql&gt; <strong class="userinput"><code>SET @a = 3;</code></strong>
mysql&gt; <strong class="userinput"><code>SET @b = 4;</code></strong>
mysql&gt; <strong class="userinput"><code>EXECUTE stmt1 USING @a, @b;</code></strong>
+------------+
| hypotenuse |
+------------+
|          5 |
+------------+
mysql&gt; <strong class="userinput"><code>DEALLOCATE PREPARE stmt1;</code></strong>
</pre><p>
    2 番目の例も同様ですが、ステートメントのテキストをユーザー変数として指定します。
  </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET @s = 'SELECT SQRT(POW(?,2) + POW(?,2)) AS hypotenuse';</code></strong>
mysql&gt; <strong class="userinput"><code>PREPARE stmt2 FROM @s;</code></strong>
mysql&gt; <strong class="userinput"><code>SET @a = 6;</code></strong>
mysql&gt; <strong class="userinput"><code>SET @b = 8;</code></strong>
mysql&gt; <strong class="userinput"><code>EXECUTE stmt2 USING @a, @b;</code></strong>
+------------+
| hypotenuse |
+------------+
|         10 |
+------------+
mysql&gt; <strong class="userinput"><code>DEALLOCATE PREPARE stmt2;</code></strong>
</pre><p>
    次の追加の例は、クエリーを実行する対象となるテーブルの名前をユーザー変数として格納することによって、実行時にそのテーブルを選択する方法を示しています。
  </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (a INT NOT NULL);</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES (4), (8), (11), (32), (80);</code></strong>

mysql&gt; <strong class="userinput"><code>SET @table = 't1';</code></strong>
mysql&gt; <strong class="userinput"><code>SET @s = CONCAT('SELECT * FROM ', @table);</code></strong>

mysql&gt; <strong class="userinput"><code>PREPARE stmt3 FROM @s;</code></strong>
mysql&gt; <strong class="userinput"><code>EXECUTE stmt3;</code></strong>
+----+
| a  |
+----+
|  4 |
|  8 |
| 11 |
| 32 |
| 80 |
+----+

mysql&gt; <strong class="userinput"><code>DEALLOCATE PREPARE stmt3;</code></strong>
</pre><p>
    準備済みステートメントは、そのステートメントが作成されたセッションに固有です。 以前に作成された準備済みステートメントを解放せずにセッションを終了した場合、そのステートメントはサーバーによって自動的に解放されます。 
  </p><p>
    準備済みステートメントはまた、セッションに対してグローバルでもあります。 ストアドルーチン内で準備済みステートメントを作成した場合、そのステートメントはストアドルーチンが終了しても解放されません。 
  </p><p>
    同時に作成される準備済みステートメントが多くなりすぎないようにするには、<code class="literal">max_prepared_stmt_count</code> システム変数を設定します。 準備済みステートメントの使用を回避するには、この値を 0 に設定します。 
  </p><h3><a name="prepared-statements-permitted"></a>プリペアドステートメントで許可される SQL 構文</h3><p>
    次の SQL ステートメントは、準備済みステートメントとして使用できます。
  </p><pre class="programlisting">ALTER TABLE
ALTER USER
ANALYZE TABLE
CACHE INDEX
CALL
CHANGE MASTER
CHECKSUM {TABLE | TABLES}
COMMIT
{CREATE | DROP} INDEX
{CREATE | RENAME | DROP} DATABASE
{CREATE | DROP} TABLE
{CREATE | RENAME | DROP} USER
{CREATE | DROP} VIEW
DELETE
DO
FLUSH {TABLE | TABLES | TABLES WITH READ LOCK | HOSTS | PRIVILEGES
  | LOGS | STATUS | MASTER | SLAVE | USER_RESOURCES}
GRANT
INSERT
INSTALL PLUGIN
KILL
LOAD INDEX INTO CACHE
OPTIMIZE TABLE
RENAME TABLE
REPAIR TABLE
REPLACE
RESET {MASTER | SLAVE}
REVOKE
SELECT
SET
SHOW BINLOG EVENTS
SHOW CREATE {PROCEDURE | FUNCTION | EVENT | TABLE | VIEW}
SHOW {MASTER | BINARY} LOGS
SHOW {MASTER | SLAVE} STATUS
SLAVE {START | STOP}
TRUNCATE TABLE
UNINSTALL PLUGIN
UPDATE
</pre><p>
    その他のステートメントはサポートされていません。
  </p><p>
    診断ステートメントを準備できないことを示す SQL 標準に準拠するために、MySQL では準備済のステートメントとして次のものはサポートされていません:
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">SHOW WARNINGS</code>, <code class="literal">SHOW COUNT(*) WARNINGS</code>
      </p></li><li class="listitem"><p>
        <code class="literal">SHOW ERRORS</code>, <code class="literal">SHOW COUNT(*) ERRORS</code>
      </p></li><li class="listitem"><p>
        <code class="literal">warning_count</code> または <code class="literal">error_count</code> システム変数への参照を含むステートメント。
      </p></li></ul></div><p>
    通常、SQL 準備済みステートメントで許可されていないステートメントは、ストアドプログラムでも許可されません。 例外については、<a class="xref" href="stored-objects.html#stored-program-restrictions" title="25.8 ストアドプログラムの制約">セクション25.8「ストアドプログラムの制約」</a>に示されています。 
  </p><p>
    プリペアドステートメントによって参照されているテーブルやビューのメタデータの変更が検出され、それが次に実行されるときに、ステートメントが自動再準備されます。 詳細については、<a class="xref" href="optimization.html#statement-caching" title="8.10.3 プリペアドステートメントおよびストアドプログラムのキャッシュ">セクション8.10.3「プリペアドステートメントおよびストアドプログラムのキャッシュ」</a>を参照してください。 
  </p><p>
    準備済みステートメントを使用する場合は、<code class="literal">LIMIT</code> 句の引数にプレースホルダを使用できます。 <a class="xref" href="sql-statements.html#select" title="13.2.10 SELECT ステートメント">セクション13.2.10「SELECT ステートメント」</a>を参照してください。 
  </p><p>
    <code class="literal">PREPARE</code> および <code class="literal">EXECUTE</code> とともに使用される準備済み <code class="literal">CALL</code> ステートメントでは、<code class="literal">OUT</code> および <code class="literal">INOUT</code> パラメータに対するプレースホルダのサポートが MySQL 8.0 から使用できます。 例および以前のバージョンでの回避方法については、<a class="xref" href="sql-statements.html#call" title="13.2.1 CALL ステートメント">セクション13.2.1「CALL ステートメント」</a>を参照してください。 <code class="literal">IN</code> パラメータには、バージョンには関係なくプレースホルダを使用できます。 
  </p><p>
    準備済みステートメントのための SQL 構文は、ネストされた方法では使用できません。 つまり、<code class="literal">PREPARE</code> に渡されるステートメント自体を、<code class="literal">PREPARE</code>、<code class="literal">EXECUTE</code>、または <code class="literal">DEALLOCATE PREPARE</code> ステートメントにすることはできません。 
  </p><p>
    準備済みステートメントのための SQL 構文は、準備済みステートメント API 呼び出しの使用とは異なります。 たとえば、<code class="literal">mysql_stmt_prepare()</code> C API 関数を使用して、<code class="literal">PREPARE</code>、<code class="literal">EXECUTE</code>、または <code class="literal">DEALLOCATE PREPARE</code> ステートメントを準備することはできません。 
  </p><p>
    準備済みステートメントのための SQL 構文はストアドプロシージャー内で使用できますが、ストアドファンクションまたはトリガー内では使用できません。 ただし、<code class="literal">PREPARE</code> と <code class="literal">EXECUTE</code> で準備および実行される動的なステートメントにはカーソルを使用できません。 カーソルのステートメントはカーソル作成時にチェックされるため、そのステートメントを動的にすることはできません。 
  </p><p>
    準備済みステートメントのための SQL 構文は、マルチステートメント (つまり、<code class="literal">;</code>文字で区切られた 1 つの文字列内の複数のステートメント) をサポートしていません。
  </p><p>
    <code class="literal">CALL</code> SQL ステートメントを使用して、準備済みステートメントを含むストアドプロシージャーを実行する C プログラムを記述するには、<code class="literal">CLIENT_MULTI_RESULTS</code> フラグが有効になっている必要があります。 これは、各 <code class="literal">CALL</code> によって、プロシージャー内で実行されるステートメントによって返される可能性のある結果セットに加えて、呼び出しステータスを示すための結果が返されるためです。 
  </p><p>
    <code class="literal">CLIENT_MULTI_RESULTS</code> は、<code class="literal">mysql_real_connect()</code> を呼び出すときに、<code class="literal">CLIENT_MULTI_RESULTS</code> フラグ自体を渡すことによって明示的に、または <code class="literal">CLIENT_MULTI_STATEMENTS</code> を渡すことによって暗黙的に有効にする (これによって <code class="literal">CLIENT_MULTI_RESULTS</code> も有効になります) ことができます。 詳細は、<a class="xref" href="sql-statements.html#call" title="13.2.1 CALL ステートメント">セクション13.2.1「CALL ステートメント」</a>を参照してください。 
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="prepare"></a>13.5.1 PREPARE ステートメント</h3></div></div></div><a class="indexterm" name="idm45826993806208"></a><a class="indexterm" name="idm45826993804752"></a><pre class="programlisting">PREPARE <em class="replaceable"><code>stmt_name</code></em> FROM <em class="replaceable"><code>preparable_stmt</code></em>
</pre><p>
      <code class="literal">PREPARE</code> ステートメントは SQL ステートメントを準備し、それに名前 <em class="replaceable"><code>stmt_name</code></em> を割り当てます。この名前は、あとでそのステートメントを参照するために使用されます。 この準備済みステートメントは <code class="literal">EXECUTE</code> で実行され、<code class="literal">DEALLOCATE PREPARE</code> で解放されます。 例については、<a class="xref" href="sql-statements.html#sql-prepared-statements" title="13.5 プリペアドステートメント">セクション13.5「プリペアドステートメント」</a>を参照してください。 
    </p><p>
      ステートメント名では大/小文字は区別されません。<em class="replaceable"><code>preparable_stmt</code></em> は、SQL ステートメントのテキストを含む文字列リテラルまたはユーザー変数です。 このテキストは複数のステートメントではなく、1 つのステートメントを表している必要があります。 このステートメント内では、<code class="literal">?</code> 文字を、あとでクエリーを実行するときに、そのクエリーのどこにデータ値をバインドするかを示すパラメータマーカーとして使用できます。 文字列値にバインドしようとしている場合でも、<code class="literal">?</code> 文字を引用符で囲んではいけません。 パラメータマーカーは、SQL キーワードや識別子などではなく、データ値を指定するべき場所にしか使用できません。 
    </p><p>
      指定された名前を持つ準備済みステートメントがすでに存在する場合、そのステートメントは、新しいステートメントが準備される前に暗黙的に解放されます。 つまり、新しいステートメントにエラーが含まれていて準備できない場合は、エラーが返され、指定された名前を持つステートメントは存在しなくなります。 
    </p><p>
      準備済みステートメントのスコープは、そのステートメントが作成されたセッションです。これには、次のいくつかの注意点があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          あるセッションで作成された準備済みステートメントを別のセッションで使用することはできません。
        </p></li><li class="listitem"><p>
          セッションが (正常または異常にかかわらず) 終了すると、その準備済みステートメントは存在しなくなります。 自動再接続が有効になっていると、クライアントには接続が失われたことが通知されません。 このため、クライアントは自動再接続を無効にすることが必要になる場合があります。 <a class="ulink" href="https://dev.mysql.com/doc/c-api/8.0/en/c-api-auto-reconnect.html" target="_top">Automatic Reconnection Control</a>を参照してください。 
        </p></li><li class="listitem"><p>
          ストアドプログラム内で作成された準備済みステートメントは、そのプログラムが実行を完了したあとも引き続き存在し、あとでそのプログラムの外部で実行できます。
        </p></li><li class="listitem"><p>
          ストアドプログラムのコンテキストで準備されたステートメントは、ストアドプロシージャーやストアドファンクションのパラメータまたはローカル変数を参照できません。これらは、そのプログラムが終了するとスコープから外れ、このステートメントがあとでプログラムの外部で実行されたときに使用できなくなるためです。 回避方法として、代わりに、同様にセッションスコープを持つユーザー定義変数を参照します。<a class="xref" href="language-structure.html#user-variables" title="9.4 ユーザー定義変数">セクション9.4「ユーザー定義変数」</a>を参照してください。 
        </p></li></ul></div><p>
      MySQL 8.0.22 以降、プリペアドステートメントで使用されるパラメータのタイプは、そのステートメントが最初に準備されたときに決定され、このプリペアドステートメントに対して <code class="literal">EXECUTE</code> が起動されるたびに保持されます (このセクションで後述するようにステートメントが再準備されないかぎり)。 パラメータタイプを決定するためのルールを次に示します: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          バイナリ算術演算子のオペランドであるパラメータは、他のオペランドと同じデータ型を持ちます。
        </p></li><li class="listitem"><p>
          バイナリ算術演算子の両方のオペランドがパラメータの場合、パラメータの型は演算子のコンテキストによって決定されます。
        </p></li><li class="listitem"><p>
          パラメータが単項算術演算子のオペランドである場合、パラメータタイプは演算子のコンテキストによって決定されます。
        </p></li><li class="listitem"><p>
          算術演算子に型決定コンテキストがない場合、関係するパラメータの導出型は <code class="literal">DOUBLE PRECISION</code> です。 これは、たとえば、パラメータが <code class="literal">SELECT</code> リストの最上位ノードである場合や、比較演算子の一部である場合に発生することがあります。 
        </p></li><li class="listitem"><p>
          文字列演算子のオペランドであるパラメータは、他のオペランドの集計型と同じ導出型を持ちます。 演算子のすべてのオペランドがパラメータの場合、導出タイプは <code class="literal">VARCHAR</code> で、その照合は <code class="literal">collation_connection</code> の値によって決定されます。 
        </p></li><li class="listitem"><p>
          時間演算子のオペランドであるパラメータは、演算子が <code class="literal">DATETIME</code> を返す場合は <code class="literal">DATETIME</code> 型、演算子が <code class="literal">TIME</code> を返す場合は <code class="literal">TIME</code>、演算子が <code class="literal">DATE</code> を返す場合は <code class="literal">DATE</code> 型になります。
        </p></li><li class="listitem"><p>
          バイナリ比較演算子のオペランドであるパラメータは、比較の他のオペランドと同じ導出型を持ちます。
        </p></li><li class="listitem"><p>
          <code class="literal">BETWEEN</code> などの 3 項比較演算子のオペランドであるパラメータは、他のオペランドの集計型と同じ導出型を持ちます。
        </p></li><li class="listitem"><p>
          比較演算子のすべてのオペランドがパラメータの場合、各オペランドの導出タイプは <code class="literal">VARCHAR</code> で、照合は <code class="literal">collation_connection</code> の値によって決定されます。
        </p></li><li class="listitem"><p>
          <code class="literal">CASE</code>, <code class="literal">COALESCE</code>, <code class="literal">IF</code>, <code class="literal">IFNULL</code> または <code class="literal">NULLIF</code> の出力オペランドであるパラメータは、演算子の集計型と同じ導出型を持ちます。
        </p></li><li class="listitem"><p>
          <code class="literal">CASE</code>, <code class="literal">COALESCE</code>, <code class="literal">IF</code>, <code class="literal">IFNULL</code> または <code class="literal">NULLIF</code> のすべての出力オペランドがパラメータであるか、すべて <code class="literal">NULL</code> である場合、パラメータのタイプは演算子のコンテキストによって決定されます。
        </p></li><li class="listitem"><p>
          パラメータが <code class="literal">CASE</code>, <code class="literal">COALESCE()</code>, <code class="literal">IF</code> または <code class="literal">IFNULL</code> のオペランドであり、型決定コンテキストがない場合、関連する各パラメータの導出型は <code class="literal">VARCHAR</code> であり、その照合は <code class="literal">collation_connection</code> の値によって決定されます。
        </p></li><li class="listitem"><p>
          <code class="literal">CAST()</code> のオペランドであるパラメータの型は、<code class="literal">CAST()</code> で指定されたものと同じです。
        </p></li><li class="listitem"><p>
          パラメータが <code class="literal">INSERT</code> ステートメントの一部ではない <code class="literal">SELECT</code> リストの直接のメンバーである場合、パラメータの導出タイプは <code class="literal">VARCHAR</code> であり、その照合は <code class="literal">collation_connection</code> の値によって決定されます。
        </p></li><li class="listitem"><p>
          パラメータが <code class="literal">INSERT</code> ステートメントの一部である <code class="literal">SELECT</code> リストの直接のメンバーである場合、パラメータの導出型は、パラメータが挿入される対応するカラムの型になります。
        </p></li><li class="listitem"><p>
          パラメータが <code class="literal">UPDATE</code> ステートメントの <code class="literal">SET</code> 句または <code class="literal">INSERT</code> ステートメントの <code class="literal">ON DUPLICATE KEY UPDATE</code> 句で割当てのソースとして使用される場合、パラメータの導出タイプは、<code class="literal">SET</code> 句または <code class="literal">ON DUPLICATE KEY UPDATE</code> 句によって更新される対応するカラムのタイプになります。
        </p></li><li class="listitem"><p>
          パラメータが関数の引数である場合、派生型は関数の戻り型によって異なります。
        </p></li></ul></div><p>
      実際のタイプと導出タイプの一部の組合せでは、ステートメントの自動再準備がトリガーされ、以前のバージョンの MySQL との互換性が確保されます。 次のいずれかの条件に該当する場合、再準備は行われません: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">NULL</code> は、実際のパラメータ値として使用されます。
        </p></li><li class="listitem"><p>
          パラメータは、<code class="literal">CAST()</code> のオペランドです。 (かわりに、派生型へのキャストが試行され、キャストが失敗した場合は例外が発生します。) 
        </p></li><li class="listitem"><p>
          パラメータは文字列です。 (この場合、暗黙的な <code class="literal">CAST(? AS <em class="replaceable"><code>derived_type</code></em>)</code> が実行されます。) 
        </p></li><li class="listitem"><p>
          パラメータの導出タイプと実際のタイプはどちらも <code class="literal">INTEGER</code> であり、同じ符号を持ちます。
        </p></li><li class="listitem"><p>
          パラメータ導出タイプは <code class="literal">DECIMAL</code> で、その実際のタイプは <code class="literal">DECIMAL</code> または <code class="literal">INTEGER</code> のいずれかです。
        </p></li><li class="listitem"><p>
          導出型は <code class="literal">DOUBLE</code> で、実際の型は任意の数値型です。
        </p></li><li class="listitem"><p>
          導出型と実際の型はどちらも文字列型です。
        </p></li><li class="listitem"><p>
          導出された型が temporal で、実際の型が temporal の場合。 <span class="emphasis"><em>例外</em></span>: 導出タイプは <code class="literal">TIME</code> で、実際のタイプは <code class="literal">TIME</code> ではありません。導出タイプは <code class="literal">DATE</code> で、実際のタイプは <code class="literal">DATE</code> ではありません。 
        </p></li><li class="listitem"><p>
          導出型は時間的で、実際の型は数値です。
        </p></li></ul></div><p>
      前述以外の場合は、ステートメントが再準備され、導出されたパラメータタイプのかわりに実際のパラメータタイプが使用されます。
    </p><p>
      これらのルールは、プリペアドステートメントで参照されるユーザー変数にも適用されます。
    </p><p>
      最初の実行後にステートメントを実行するために、プリペアドステートメント内の特定のパラメータまたはユーザー変数に異なるデータ型を使用すると、ステートメントが再準備されます。 これは効率的ではありません。また、パラメータ (または変数) の実際の型が異なる可能性があるため、準備されたステートメントの後続の実行と結果に一貫性がなくなる可能性があります。 このような理由から、プリペアドステートメントを再実行する場合は、特定のパラメータに同じデータ型を使用することをお薦めします。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="execute"></a>13.5.2 EXECUTE ステートメント</h3></div></div></div><a class="indexterm" name="idm45826993690944"></a><a class="indexterm" name="idm45826993689488"></a><pre class="programlisting">EXECUTE <em class="replaceable"><code>stmt_name</code></em>
    [USING @<em class="replaceable"><code>var_name</code></em> [, @<em class="replaceable"><code>var_name</code></em>] ...]
</pre><p>
      <code class="literal">PREPARE</code> でステートメントを準備したあと、準備済みステートメント名を参照する <code class="literal">EXECUTE</code> ステートメントでそのステートメントを実行します。 準備済みステートメントにパラメータマーカーが含まれている場合は、そのパラメータにバインドされる値を含むユーザー変数をリストした <code class="literal">USING</code> 句を指定する必要があります。 パラメータ値はユーザー変数でのみ提供することができ、<code class="literal">USING</code> 句では、このステートメント内のパラメータマーカーの数とまったく同じ数の変数を指定する必要があります。 
    </p><p>
      特定の準備済みステートメントを複数回実行できます。それには、各ステートメントに異なる変数を渡すか、または各実行の前にその変数を異なる値に設定します。
    </p><p>
      例については、<a class="xref" href="sql-statements.html#sql-prepared-statements" title="13.5 プリペアドステートメント">セクション13.5「プリペアドステートメント」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="deallocate-prepare"></a>13.5.3 DEALLOCATE PREPARE ステートメント</h3></div></div></div><a class="indexterm" name="idm45826993674000"></a><a class="indexterm" name="idm45826993672544"></a><a class="indexterm" name="idm45826993671312"></a><pre class="programlisting">{DEALLOCATE | DROP} PREPARE <em class="replaceable"><code>stmt_name</code></em>
</pre><p>
      <code class="literal">PREPARE</code> で生成された準備済みステートメントを解放するには、その準備済みステートメント名を参照する <code class="literal">DEALLOCATE PREPARE</code> ステートメントを使用します。 準備済みステートメントを解放したあとにそのステートメントを実行しようとすると、エラーが発生します。 多すぎる準備済みステートメントが作成され、<code class="literal">DEALLOCATE PREPARE</code> ステートメントまたはセッションの終了のどちらによっても解放されない場合は、<code class="literal">max_prepared_stmt_count</code> システム変数によって上限が適用されることがあります。 
    </p><p>
      例については、<a class="xref" href="sql-statements.html#sql-prepared-statements" title="13.5 プリペアドステートメント">セクション13.5「プリペアドステートメント」</a>を参照してください。
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sql-compound-statements"></a>13.6 複合ステートメントの構文</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#begin-end">13.6.1 BEGIN ... END 複合ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#statement-labels">13.6.2 ステートメントラベル</a></span></dt><dt><span class="section"><a href="sql-statements.html#declare">13.6.3 DECLARE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#stored-program-variables">13.6.4 ストアドプログラム内の変数</a></span></dt><dt><span class="section"><a href="sql-statements.html#flow-control-statements">13.6.5 フロー制御ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#cursors">13.6.6 カーソル</a></span></dt><dt><span class="section"><a href="sql-statements.html#condition-handling">13.6.7 条件の処理</a></span></dt><dt><span class="section"><a href="sql-statements.html#condition-handling-restrictions">13.6.8 条件処理の制約</a></span></dt></dl></div><a class="indexterm" name="idm45826993656432"></a><a class="indexterm" name="idm45826993654976"></a><a class="indexterm" name="idm45826993652944"></a><a class="indexterm" name="idm45826993651568"></a><p>
    このセクションでは、<code class="literal">BEGIN ... END</code> 複合ステートメントや、ストアドプログラム (ストアドプロシージャーとストアドファンクション、トリガー、およびイベント) の本体で使用できるその他のステートメントの構文について説明します。 これらのオブジェクトは、あとで呼び出すためにサーバー上に格納されている SQL コードに対して定義されます (<a class="xref" href="stored-objects.html" title="第 25 章 ストアドオブジェクト">第25章「<i>ストアドオブジェクト</i>」</a>を参照してください)。 
  </p><p>
    複合ステートメントとは、ほかのブロック、つまり、変数、条件ハンドラ、およびカーソルの宣言、ループや条件付きテストなどのフロー制御構造構文を含めることのできるブロックのことです。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="begin-end"></a>13.6.1 BEGIN ... END 複合ステートメント</h3></div></div></div><a class="indexterm" name="idm45826993643584"></a><a class="indexterm" name="idm45826993642272"></a><pre class="programlisting">[<em class="replaceable"><code>begin_label</code></em>:] BEGIN
    [<em class="replaceable"><code>statement_list</code></em>]
END [<em class="replaceable"><code>end_label</code></em>]
</pre><p>
      <code class="literal">BEGIN ... END</code> 構文は、ストアドプログラム (ストアドプロシージャーとストアドファンクション、トリガー、およびイベント) 内に指定できる複合ステートメントを記述するために使用されます。 複合ステートメントには、<code class="literal">BEGIN</code> および <code class="literal">END</code> キーワードで囲まれた複数のステートメントを含めることができます。<em class="replaceable"><code>statement_list</code></em> は、それぞれがセミコロン (<code class="literal">;</code>) ステートメント区切り文字で終了する 1 つ以上のステートメントのリストを表します。 <em class="replaceable"><code>statement_list</code></em> 自体がオプションであるため、空の複合ステートメント (<code class="literal">BEGIN END</code>) は正当です。 
    </p><p>
      <code class="literal">BEGIN ... END</code> ブロックはネストできます。
    </p><p>
      複数のステートメントを使用するには、クライアントが <code class="literal">;</code> ステートメント区切り文字を含むステートメント文字列を送信できる必要があります。 <span class="command"><strong>mysql</strong></span> コマンド行クライアントでは、これは <code class="literal">delimiter</code> コマンドで処理されます。 ステートメント終了の区切り文字 <code class="literal">;</code> を (たとえば、<code class="literal">//</code> に) 変更すると、プログラム本体での <code class="literal">;</code> の使用が許可されます。 例については、<a class="xref" href="stored-objects.html#stored-programs-defining" title="25.1 ストアドプログラムの定義">セクション25.1「ストアドプログラムの定義」</a>を参照してください。 
    </p><p>
      <code class="literal">BEGIN ... END</code> ブロックにはラベルを付けることができます。 <a class="xref" href="sql-statements.html#statement-labels" title="13.6.2 ステートメントラベル">セクション13.6.2「ステートメントラベル」</a>を参照してください。 
    </p><p>
      オプションの <code class="literal">[NOT] ATOMIC</code> 句はサポートされていません。 つまり、この命令ブロックの先頭でトランザクションセーブポイントは設定されず、このコンテキストで使用されている <code class="literal">BEGIN</code> 句は現在のトランザクションに影響を与えません。 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        すべてのストアドプログラム内で、パーサーは、<code class="literal">BEGIN [WORK]</code> を <code class="literal">BEGIN ... END</code> ブロックの開始として扱います。 このコンテキストでトランザクションを開始するには、代わりに <code class="literal">START TRANSACTION</code> を使用します。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="statement-labels"></a>13.6.2 ステートメントラベル</h3></div></div></div><a class="indexterm" name="idm45826993609904"></a><a class="indexterm" name="idm45826993607760"></a><a class="indexterm" name="idm45826993605728"></a><a class="indexterm" name="idm45826993603696"></a><a class="indexterm" name="idm45826993601664"></a><pre class="programlisting">[<em class="replaceable"><code>begin_label</code></em>:] BEGIN
    [<em class="replaceable"><code>statement_list</code></em>]
END [<em class="replaceable"><code>end_label</code></em>]

[<em class="replaceable"><code>begin_label</code></em>:] LOOP
    <em class="replaceable"><code>statement_list</code></em>
END LOOP [<em class="replaceable"><code>end_label</code></em>]

[<em class="replaceable"><code>begin_label</code></em>:] REPEAT
    <em class="replaceable"><code>statement_list</code></em>
UNTIL <em class="replaceable"><code>search_condition</code></em>
END REPEAT [<em class="replaceable"><code>end_label</code></em>]

[<em class="replaceable"><code>begin_label</code></em>:] WHILE <em class="replaceable"><code>search_condition</code></em> DO
    <em class="replaceable"><code>statement_list</code></em>
END WHILE [<em class="replaceable"><code>end_label</code></em>]
</pre><p>
      <code class="literal">BEGIN ... END</code> ブロックや、<code class="literal">LOOP</code>、<code class="literal">REPEAT</code>、および <code class="literal">WHILE</code> ステートメントに対してラベルが許可されます。 これらのステートメントに使用されるラベルは、次のルールに従います。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <em class="replaceable"><code>begin_label</code></em> のあとにコロンを付ける必要があります。
        </p></li><li class="listitem"><p>
          <em class="replaceable"><code>begin_label</code></em> は、<em class="replaceable"><code>end_label</code></em> なしでも指定できます。 <em class="replaceable"><code>end_label</code></em> が存在する場合、それは <em class="replaceable"><code>begin_label</code></em> と同じである必要があります。 
        </p></li><li class="listitem"><p>
          <em class="replaceable"><code>end_label</code></em> は、<em class="replaceable"><code>begin_label</code></em> なしでは指定できません。
        </p></li><li class="listitem"><p>
          同じネストレベルにあるラベルは異なっている必要があります。
        </p></li><li class="listitem"><p>
          ラベルは最大 16 文字の長さで指定できます。
        </p></li></ul></div><p>
      ラベルが付けられた構造構文内でラベルを参照するには、<code class="literal">ITERATE</code> または <code class="literal">LEAVE</code> ステートメントを使用します。 次の例では、これらのステートメントを使用して繰り返しを続行するか、またはループを終了します。 
    </p><pre class="programlisting">CREATE PROCEDURE doiterate(p1 INT)
BEGIN
  label1: LOOP
    SET p1 = p1 + 1;
    IF p1 &lt; 10 THEN ITERATE label1; END IF;
    LEAVE label1;
  END LOOP label1;
END;
</pre><p>
      ブロックラベルのスコープには、そのブロック内で宣言されているハンドラのコードは含まれません。 詳細は、<a class="xref" href="sql-statements.html#declare-handler" title="13.6.7.2 DECLARE ... HANDLER ステートメント">セクション13.6.7.2「DECLARE ... HANDLER ステートメント」</a>を参照してください。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="declare"></a>13.6.3 DECLARE ステートメント</h3></div></div></div><a class="indexterm" name="idm45826993570240"></a><p>
      <code class="literal">DECLARE</code> ステートメントは、プログラムにローカルな、次のさまざまな項目を定義するために使用されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ローカル変数。 <a class="xref" href="sql-statements.html#stored-program-variables" title="13.6.4 ストアドプログラム内の変数">セクション13.6.4「ストアドプログラム内の変数」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          条件とハンドラ。 <a class="xref" href="sql-statements.html#condition-handling" title="13.6.7 条件の処理">セクション13.6.7「条件の処理」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          カーソル。 <a class="xref" href="sql-statements.html#cursors" title="13.6.6 カーソル">セクション13.6.6「カーソル」</a>を参照してください。 
        </p></li></ul></div><p>
      <code class="literal">DECLARE</code> は、<code class="literal">BEGIN ... END</code> 複合ステートメントの内部でのみ許可され、ほかのどのステートメントよりも前の、その複合ステートメントの先頭に存在する必要があります。
    </p><p>
      宣言は、特定の順序に従う必要があります。 カーソル宣言は、ハンドラ宣言の前に指定する必要があります。 変数および条件宣言は、カーソルまたはハンドラ宣言の前に指定する必要があります。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="stored-program-variables"></a>13.6.4 ストアドプログラム内の変数</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#declare-local-variable">13.6.4.1 ローカル変数 DECLARE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#local-variable-scope">13.6.4.2 ローカル変数のスコープと解決</a></span></dt></dl></div><p>
      システム変数とユーザー定義変数は、ストアドプログラムのコンテキストの外部で使用できるのと同様に、ストアドプログラム内で使用できます。 さらに、ストアドプログラムは <code class="literal">DECLARE</code> を使用してローカル変数を定義でき、またストアドルーチン (プロシージャーおよびファンクション) は、そのルーチンとその呼び出し元の間で値を通信するパラメータを受け取るように宣言できます。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="xref" href="sql-statements.html#declare-local-variable" title="13.6.4.1 ローカル変数 DECLARE ステートメント">セクション13.6.4.1「ローカル変数 DECLARE ステートメント」</a>で説明されているように、ローカル変数を宣言するには、<code class="literal">DECLARE</code> ステートメントを使用します。
        </p></li><li class="listitem"><p>
          変数は、<code class="literal">SET</code> ステートメントを使用して直接設定できます。 <a class="xref" href="sql-statements.html#set-variable" title="13.7.6.1 変数代入の SET 構文">セクション13.7.6.1「変数代入の SET 構文」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          クエリーからの結果は、<code class="literal">SELECT ... INTO <em class="replaceable"><code>var_list</code></em></code> を使用するか、またはカーソルを開き、<code class="literal">FETCH ... INTO <em class="replaceable"><code>var_list</code></em></code> を使用することによってローカル変数に取得できます。 <a class="xref" href="sql-statements.html#select-into" title="13.2.10.1 SELECT ... INTO ステートメント">セクション13.2.10.1「SELECT ... INTO ステートメント」</a>および<a class="xref" href="sql-statements.html#cursors" title="13.6.6 カーソル">セクション13.6.6「カーソル」</a>を参照してください。 
        </p></li></ul></div><p>
      ローカル変数のスコープ、および MySQL があいまいな名前を解決する方法については、<a class="xref" href="sql-statements.html#local-variable-scope" title="13.6.4.2 ローカル変数のスコープと解決">セクション13.6.4.2「ローカル変数のスコープと解決」</a>を参照してください。
    </p><p>
      ストアドプロシージャーやストアドファンクションのパラメータまたはストアドプログラムのローカル変数に (たとえば、<code class="literal">SET <em class="replaceable"><code>var_name</code></em> = DEFAULT</code> ステートメントを使用して) 値 <code class="literal">DEFAULT</code> を割り当てることは許可されません。 MySQL 8.0 では、これにより構文エラーが発生します。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="declare-local-variable"></a>13.6.4.1 ローカル変数 DECLARE ステートメント</h4></div></div></div><pre class="programlisting">DECLARE <em class="replaceable"><code>var_name</code></em> [, <em class="replaceable"><code>var_name</code></em>] ... <em class="replaceable"><code>type</code></em> [DEFAULT <em class="replaceable"><code>value</code></em>]
</pre><p>
        このステートメントは、ストアドプログラム内のローカル変数を宣言します。 変数のデフォルト値を指定するには、<code class="literal">DEFAULT</code> 句を含めます。 この値は式として指定できます。定数である必要はありません。 <code class="literal">DEFAULT</code> 句がない場合、初期値は <code class="literal">NULL</code> になります。 
      </p><p>
        ローカル変数は、データ型やオーバーフローチェックに関して、ストアドルーチンパラメータと同様に処理されます。 <a class="xref" href="sql-statements.html#create-procedure" title="13.1.17 CREATE PROCEDURE ステートメントおよび CREATE FUNCTION ステートメント">セクション13.1.17「CREATE PROCEDURE ステートメントおよび CREATE FUNCTION ステートメント」</a>を参照してください。 
      </p><p>
        変数宣言は、カーソルまたはハンドラ宣言の前に指定する必要があります。
      </p><p>
        ローカル変数名では、大/小文字は区別されません。 <a class="xref" href="language-structure.html#identifiers" title="9.2 スキーマオブジェクト名">セクション9.2「スキーマオブジェクト名」</a>で説明されているように、許可される文字や引用符のルールはほかの識別子の場合と同じです。 
      </p><p>
        ローカル変数のスコープは、それが宣言されている <code class="literal">BEGIN ... END</code> ブロックです。 この変数は、同じ名前を持つ変数を宣言しているブロックを除き、宣言しているブロック内でネストされたブロック内で参照できます。 
      </p><p>
        変数宣言の例は、<a class="xref" href="sql-statements.html#local-variable-scope" title="13.6.4.2 ローカル変数のスコープと解決">セクション13.6.4.2「ローカル変数のスコープと解決」</a> を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="local-variable-scope"></a>13.6.4.2 ローカル変数のスコープと解決</h4></div></div></div><p>
        ローカル変数のスコープは、それが宣言されている <code class="literal">BEGIN ... END</code> ブロックです。 この変数は、同じ名前を持つ変数を宣言しているブロックを除き、宣言しているブロック内でネストされたブロック内で参照できます。 
      </p><p>
        ローカル変数はストアドプログラムの実行中にのみスコープ内にあるので、これらの参照は、ストアドプログラム内で作成された準備済みステートメントでは許可されていません。 準備済みステートメントのスコープは現在のセッションであり、ストアドプログラムではないので、ステートメントはプログラムの終了後に実行でき、この時点で変数はスコープ内に存在しなくなります。 たとえば、<code class="literal">SELECT ... INTO <em class="replaceable"><code>local_var</code></em></code> は準備済みステートメントとして使用できません。 この制約は、ストアドプロシージャーおよびストアドファンクションのパラメータにも適用されます。 <a class="xref" href="sql-statements.html#prepare" title="13.5.1 PREPARE ステートメント">セクション13.5.1「PREPARE ステートメント」</a>を参照してください。 
      </p><p>
        ローカル変数にテーブルカラムと同じ名前を付けてはいけません。 <code class="literal">SELECT ... INTO</code> ステートメントなどの SQL ステートメントに、カラムおよび同じ名前を持つ宣言されたローカル変数への参照が含まれている場合、MySQL は現在、その参照を変数の名前として解釈します。 次のプロシージャー定義を考えてみます。 
      </p><pre class="programlisting">CREATE PROCEDURE sp1 (x VARCHAR(5))
BEGIN
  DECLARE xname VARCHAR(5) DEFAULT 'bob';
  DECLARE newname VARCHAR(5);
  DECLARE xid INT;

  SELECT xname, id INTO newname, xid
    FROM table1 WHERE xname = xname;
  SELECT newname;
END;
</pre><p>
        MySQL は、<code class="literal">SELECT</code> ステートメント内の <code class="literal">xname</code> を、<code class="literal">xname</code> <span class="emphasis"><em>カラム</em></span>ではなく <code class="literal">xname</code> <span class="emphasis"><em>変数</em></span>への参照として解釈します。 その結果、プロシージャー <code class="literal">sp1()</code> が呼び出されると、<code class="literal">table1.xname</code> カラムの値には関係なく、<code class="literal">newname</code> 変数は値 <code class="literal">'bob'</code> を返します。 
      </p><p>
        同様に、次のプロシージャー内のカーソル定義には、<code class="literal">xname</code> を参照する <code class="literal">SELECT</code> ステートメントが含まれています。 MySQL はこれをカラム参照ではなく、その名前の変数への参照として解釈します。 
      </p><pre class="programlisting">CREATE PROCEDURE sp2 (x VARCHAR(5))
BEGIN
  DECLARE xname VARCHAR(5) DEFAULT 'bob';
  DECLARE newname VARCHAR(5);
  DECLARE xid INT;
  DECLARE done TINYINT DEFAULT 0;
  DECLARE cur1 CURSOR FOR SELECT xname, id FROM table1;
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

  OPEN cur1;
  read_loop: LOOP
    FETCH FROM cur1 INTO newname, xid;
    IF done THEN LEAVE read_loop; END IF;
    SELECT newname;
  END LOOP;
  CLOSE cur1;
END;
</pre><p>
        <a class="xref" href="stored-objects.html#stored-program-restrictions" title="25.8 ストアドプログラムの制約">セクション25.8「ストアドプログラムの制約」</a>も参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="flow-control-statements"></a>13.6.5 フロー制御ステートメント</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#case">13.6.5.1 CASE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#if">13.6.5.2 IF ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#iterate">13.6.5.3 ITERATE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#leave">13.6.5.4 LEAVE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#loop">13.6.5.5 LOOP ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#repeat">13.6.5.6 REPEAT ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#return">13.6.5.7 RETURN ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#while">13.6.5.8 WHILE ステートメント</a></span></dt></dl></div><p>
      MySQL は、ストアドプログラム内のフロー制御のために、<code class="literal">IF</code>、<code class="literal">CASE</code>、<code class="literal">ITERATE</code>、<code class="literal">LEAVE</code> <code class="literal">LOOP</code>、<code class="literal">WHILE</code>、および <code class="literal">REPEAT</code> 構造構文をサポートしています。 また、ストアドファンクション内の <code class="literal">RETURN</code> もサポートしています。 
    </p><p>
      これらの構造構文の多くには、次の各セクションの文法仕様に示されているその他のステートメントが含まれています。 このような構造構文はネストできます。 たとえば、<code class="literal">IF</code> ステートメントには、それ自体に <code class="literal">CASE</code> ステートメントを含む <code class="literal">WHILE</code> ループが含まれている可能性があります。 
    </p><p>
      MySQL は、<code class="literal">FOR</code> ループをサポートしていません。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="case"></a>13.6.5.1 CASE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826993481968"></a><pre class="programlisting">CASE <em class="replaceable"><code>case_value</code></em>
    WHEN <em class="replaceable"><code>when_value</code></em> THEN <em class="replaceable"><code>statement_list</code></em>
    [WHEN <em class="replaceable"><code>when_value</code></em> THEN <em class="replaceable"><code>statement_list</code></em>] ...
    [ELSE <em class="replaceable"><code>statement_list</code></em>]
END CASE
</pre><p>
        または:
      </p><pre class="programlisting">CASE
    WHEN <em class="replaceable"><code>search_condition</code></em> THEN <em class="replaceable"><code>statement_list</code></em>
    [WHEN <em class="replaceable"><code>search_condition</code></em> THEN <em class="replaceable"><code>statement_list</code></em>] ...
    [ELSE <em class="replaceable"><code>statement_list</code></em>]
END CASE
</pre><p>
        ストアドプログラムの <code class="literal">CASE</code> ステートメントは、複雑な条件構造構文を実装します。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          ここで説明する <code class="literal">CASE</code> <span class="emphasis"><em>statement</em></span> とは異なる <code class="literal">CASE</code> <span class="emphasis"><em>operator</em></span> もあります。 <a class="xref" href="functions.html#flow-control-functions" title="12.5 フロー制御関数">セクション12.5「フロー制御関数」</a>を参照してください。 <code class="literal">CASE</code> ステートメントは <code class="literal">ELSE NULL</code> 句を持つことができず、<code class="literal">END</code> でなく、<code class="literal">END CASE</code> で終了します。 
        </p></div><p>
        最初の構文の場合、<em class="replaceable"><code>case_value</code></em> は式です。 この値は、各 <code class="literal">WHEN</code> 句内の <em class="replaceable"><code>when_value</code></em> 式のいずれかに等しくなるまで、それらの式と比較されます。 等しい <em class="replaceable"><code>when_value</code></em> が見つかると、対応する <code class="literal">THEN</code> 句の <em class="replaceable"><code>statement_list</code></em> が実行されます。 どの <em class="replaceable"><code>when_value</code></em> も等しくない場合は、<code class="literal">ELSE</code> 句の <em class="replaceable"><code>statement_list</code></em> が実行されます (この句が存在する場合)。 
      </p><p>
        <code class="literal">NULL = NULL</code> は false であるため、この構文を <code class="literal">NULL</code> と等しいかどうかのテストに使用することはできません。 <a class="xref" href="tutorial.html#working-with-null" title="3.3.4.6 NULL 値の操作">セクション3.3.4.6「NULL 値の操作」</a>を参照してください。 
      </p><p>
        2 番目の構文の場合、各 <code class="literal">WHEN</code> 句の <em class="replaceable"><code>search_condition</code></em> 式のいずれかが true になるまでそれらの式が評価され、いずれかが true になった時点で、それに対応する <code class="literal">THEN</code> 句の <em class="replaceable"><code>statement_list</code></em> が実行されます。 どの <em class="replaceable"><code>search_condition</code></em> も等しくない場合は、<code class="literal">ELSE</code> 句の <em class="replaceable"><code>statement_list</code></em> が実行されます (この句が存在する場合)。 
      </p><p>
        どの <em class="replaceable"><code>when_value</code></em> も <em class="replaceable"><code>search_condition</code></em> もテストされた値に一致せず、かつ <code class="literal">CASE</code> ステートメントに <code class="literal">ELSE</code> 句が含まれていない場合は、<span class="errortext">Case not found for CASE statement</span>エラーになります。
      </p><p>
        各 <em class="replaceable"><code>statement_list</code></em> は、1 つ以上の SQL ステートメントで構成されます。空の <em class="replaceable"><code>statement_list</code></em> は許可されません。
      </p><p>
        どの <code class="literal">WHEN</code> 句でも値が一致しない状況を処理するには、次の例に示すように、空の <code class="literal">BEGIN ... END</code> ブロックを含む <code class="literal">ELSE</code> を使用します。 (ここの <code class="literal">ELSE</code> 句で使用されているインデントは透明性のみを目的にしており、それ以外の意味はありません。)  
      </p><pre class="programlisting">DELIMITER |

CREATE PROCEDURE p()
  BEGIN
    DECLARE v INT DEFAULT 1;

    CASE v
      WHEN 2 THEN SELECT v;
      WHEN 3 THEN SELECT 0;
      ELSE
        BEGIN
        END;
    END CASE;
  END;
  |
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="if"></a>13.6.5.2 IF ステートメント</h4></div></div></div><a class="indexterm" name="idm45826993435168"></a><pre class="programlisting">IF <em class="replaceable"><code>search_condition</code></em> THEN <em class="replaceable"><code>statement_list</code></em>
    [ELSEIF <em class="replaceable"><code>search_condition</code></em> THEN <em class="replaceable"><code>statement_list</code></em>] ...
    [ELSE <em class="replaceable"><code>statement_list</code></em>]
END IF
</pre><p>
        ストアドプログラムの <code class="literal">IF</code> ステートメントは、基本的な条件構造構文を実装します。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          ここで説明されている <code class="literal">IF</code> <span class="emphasis"><em>ステートメント</em></span>とは異なる <code class="literal">IF()</code> <span class="emphasis"><em>関数</em></span>も存在します。 <a class="xref" href="functions.html#flow-control-functions" title="12.5 フロー制御関数">セクション12.5「フロー制御関数」</a>を参照してください。 <code class="literal">IF</code> ステートメントは <code class="literal">THEN</code>、<code class="literal">ELSE</code>、および <code class="literal">ELSEIF</code> 句を含むことができ、<code class="literal">END IF</code> で終了します。 
        </p></div><p>
        特定の <em class="replaceable"><code>search_condition</code></em> が true と評価された場合、対応する <code class="literal">THEN</code> 句または <code class="literal">ELSEIF</code> 句 <em class="replaceable"><code>statement_list</code></em> が実行されます。 どの <em class="replaceable"><code>search_condition</code></em> も一致しない場合は、<code class="literal">ELSE</code> 句の <em class="replaceable"><code>statement_list</code></em> が実行されます。 
      </p><p>
        各 <em class="replaceable"><code>statement_list</code></em> は、1 つ以上の SQL ステートメントで構成されます。空の <em class="replaceable"><code>statement_list</code></em> は許可されません。
      </p><p>
        <code class="literal">IF ... END IF</code> ブロックは、次の例に示すように、ストアドプログラム内で使用されるその他のすべてのフロー制御ブロックと同様にセミコロンで終了する必要があります。
      </p><pre class="programlisting">DELIMITER //

CREATE FUNCTION SimpleCompare(n INT, m INT)
  RETURNS VARCHAR(20)

  BEGIN
    DECLARE s VARCHAR(20);

    IF n &gt; m THEN SET s = '&gt;';
    ELSEIF n = m THEN SET s = '=';
    ELSE SET s = '&lt;';
    END IF;

    SET s = CONCAT(n, ' ', s, ' ', m);

    RETURN s;
  END //

DELIMITER ;
</pre><p>
        ほかのフロー制御構造構文と同様に、<code class="literal">IF ... END IF</code> ブロックは、ほかのフロー制御構造構文 (ほかの <code class="literal">IF</code> ステートメントを含む) 内にネストできます。 各 <code class="literal">IF</code> は、独自の <code class="literal">END IF</code> とそれに続くセミコロンで終了する必要があります。 次に示すように、インデントを使用して、ネストされたフロー制御ブロックを人間が読みやすくすることができます (ただし、これが MySQL に必要なわけではありません)。 
      </p><pre class="programlisting">DELIMITER //

CREATE FUNCTION VerboseCompare (n INT, m INT)
  RETURNS VARCHAR(50)

  BEGIN
    DECLARE s VARCHAR(50);

    IF n = m THEN SET s = 'equals';
    ELSE
      IF n &gt; m THEN SET s = 'greater';
      ELSE SET s = 'less';
      END IF;

      SET s = CONCAT('is ', s, ' than');
    END IF;

    SET s = CONCAT(n, ' ', s, ' ', m, '.');

    RETURN s;
  END //

DELIMITER ;
</pre><p>
        この例では、内側の <code class="literal">IF</code> は <code class="literal">n</code> が <code class="literal">m</code> に等しくない場合にのみ評価されます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="iterate"></a>13.6.5.3 ITERATE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826993397424"></a><pre class="programlisting">ITERATE <em class="replaceable"><code>label</code></em>
</pre><p>
        <code class="literal">ITERATE</code> は、<code class="literal">LOOP</code>、<code class="literal">REPEAT</code>、および <code class="literal">WHILE</code> ステートメント内にのみ指定できます。 <code class="literal">ITERATE</code> は、<span class="quote">「<span class="quote">ループをふたたび開始する</span>」</span>ことを示します。 
      </p><p>
        例については、<a class="xref" href="sql-statements.html#loop" title="13.6.5.5 LOOP ステートメント">セクション13.6.5.5「LOOP ステートメント」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="leave"></a>13.6.5.4 LEAVE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826993383104"></a><pre class="programlisting">LEAVE <em class="replaceable"><code>label</code></em>
</pre><p>
        このステートメントは、特定のラベルを持つフロー制御構造構文を終了するために使用されます。 そのラベルがもっとも外側のストアドプログラムブロックのものである場合、<code class="literal">LEAVE</code> はプログラムを終了します。 
      </p><p>
        <code class="literal">LEAVE</code> は、<code class="literal">BEGIN ... END</code> またはループ構造構文 (<code class="literal">LOOP</code>、<code class="literal">REPEAT</code>、<code class="literal">WHILE</code>) 内で使用できます。
      </p><p>
        例については、<a class="xref" href="sql-statements.html#loop" title="13.6.5.5 LOOP ステートメント">セクション13.6.5.5「LOOP ステートメント」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="loop"></a>13.6.5.5 LOOP ステートメント</h4></div></div></div><a class="indexterm" name="idm45826993367232"></a><pre class="programlisting">[<em class="replaceable"><code>begin_label</code></em>:] LOOP
    <em class="replaceable"><code>statement_list</code></em>
END LOOP [<em class="replaceable"><code>end_label</code></em>]
</pre><p>
        <code class="literal">LOOP</code> は単純なループ構造構文を実装し、それぞれがセミコロン (<code class="literal">;</code>) ステートメント区切り文字で終了する 1 つ以上のステートメントで構成されたステートメントリストの繰り返し実行を可能にします。 ループ内の各ステートメントは、そのループが終了するまで繰り返されます。 通常、これは <code class="literal">LEAVE</code> ステートメントで実行されます。 ストアドファンクション内では、<code class="literal">RETURN</code> も使用できます。これにより、そのストアドファンクションが完全に終了します。 
      </p><p>
        ループ終了ステートメントが含まれていない場合は、無限ループが発生します。
      </p><p>
        <code class="literal">LOOP</code> ステートメントにはラベルを付けることができます。 ラベルの使用に関連したルールについては、<a class="xref" href="sql-statements.html#statement-labels" title="13.6.2 ステートメントラベル">セクション13.6.2「ステートメントラベル」</a>を参照してください。 
      </p><p>
        例:
      </p><pre class="programlisting">CREATE PROCEDURE doiterate(p1 INT)
BEGIN
  label1: LOOP
    SET p1 = p1 + 1;
    IF p1 &lt; 10 THEN
      ITERATE label1;
    END IF;
    LEAVE label1;
  END LOOP label1;
  SET @x = p1;
END;
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="repeat"></a>13.6.5.6 REPEAT ステートメント</h4></div></div></div><a class="indexterm" name="idm45826993348208"></a><a class="indexterm" name="idm45826993346896"></a><pre class="programlisting">[<em class="replaceable"><code>begin_label</code></em>:] REPEAT
    <em class="replaceable"><code>statement_list</code></em>
UNTIL <em class="replaceable"><code>search_condition</code></em>
END REPEAT [<em class="replaceable"><code>end_label</code></em>]
</pre><p>
        <code class="literal">REPEAT</code> ステートメント内のステートメントリストは、<em class="replaceable"><code>search_condition</code></em> 式が true になるまで繰り返されます。 そのため、<code class="literal">REPEAT</code> は常に、少なくとも 1 回はループに入ります。<em class="replaceable"><code>statement_list</code></em> は、それぞれがセミコロン (<code class="literal">;</code>) ステートメント区切り文字で終了する 1 つ以上のステートメントで構成されます。 
      </p><p>
        <code class="literal">REPEAT</code> ステートメントにはラベルを付けることができます。 ラベルの使用に関連したルールについては、<a class="xref" href="sql-statements.html#statement-labels" title="13.6.2 ステートメントラベル">セクション13.6.2「ステートメントラベル」</a>を参照してください。 
      </p><p>
        例:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>delimiter //</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE PROCEDURE dorepeat(p1 INT)</code></strong>
       <strong class="userinput"><code>BEGIN</code></strong>
         <strong class="userinput"><code>SET @x = 0;</code></strong>
         <strong class="userinput"><code>REPEAT</code></strong>
           <strong class="userinput"><code>SET @x = @x + 1;</code></strong>
         <strong class="userinput"><code>UNTIL @x &gt; p1 END REPEAT;</code></strong>
       <strong class="userinput"><code>END</code></strong>
       <strong class="userinput"><code>//</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>CALL dorepeat(1000)//</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @x//</code></strong>
+------+
| @x   |
+------+
| 1001 |
+------+
1 row in set (0.00 sec)
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="return"></a>13.6.5.7 RETURN ステートメント</h4></div></div></div><a class="indexterm" name="idm45826993321200"></a><pre class="programlisting">RETURN <em class="replaceable"><code>expr</code></em>
</pre><p>
        <code class="literal">RETURN</code> ステートメントはストアドファンクションの実行を終了し、そのストアドファンクションの呼び出し元に値 <em class="replaceable"><code>expr</code></em> を返します。 ストアドファンクション内には、少なくとも 1 つの <code class="literal">RETURN</code> ステートメントが存在する必要があります。 そのストアドファンクションに複数の終了ポイントがある場合は、複数存在してもかまいません。 
      </p><p>
        このステートメントは、ストアドプロシージャー、トリガー、またはイベントでは使用されません。 <code class="literal">LEAVE</code> ステートメントを使用すると、これらのタイプのストアドプログラムを終了できます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="while"></a>13.6.5.8 WHILE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826993308576"></a><pre class="programlisting">[<em class="replaceable"><code>begin_label</code></em>:] WHILE <em class="replaceable"><code>search_condition</code></em> DO
    <em class="replaceable"><code>statement_list</code></em>
END WHILE [<em class="replaceable"><code>end_label</code></em>]
</pre><p>
        <code class="literal">WHILE</code> ステートメント内のステートメントリストは、<em class="replaceable"><code>search_condition</code></em> 式が true であるかぎり繰り返されます。<em class="replaceable"><code>statement_list</code></em> は、それぞれがセミコロン (<code class="literal">;</code>) ステートメント区切り文字で終了する 1 つ以上の SQL ステートメントで構成されます。
      </p><p>
        <code class="literal">WHILE</code> ステートメントにはラベルを付けることができます。 ラベルの使用に関連したルールについては、<a class="xref" href="sql-statements.html#statement-labels" title="13.6.2 ステートメントラベル">セクション13.6.2「ステートメントラベル」</a>を参照してください。 
      </p><p>
        例:
      </p><pre class="programlisting">CREATE PROCEDURE dowhile()
BEGIN
  DECLARE v1 INT DEFAULT 5;

  WHILE v1 &gt; 0 DO
    ...
    SET v1 = v1 - 1;
  END WHILE;
END;
</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="cursors"></a>13.6.6 カーソル</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#close">13.6.6.1 カーソル CLOSE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#declare-cursor">13.6.6.2 カーソル DECLARE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#fetch">13.6.6.3 カーソル FETCH ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#open">13.6.6.4 カーソル OPEN ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#cursor-restrictions">13.6.6.5 サーバー側のカーソルの制約</a></span></dt></dl></div><a class="indexterm" name="idm45826993291824"></a><p>
      MySQL は、ストアドプログラム内部のカーソルをサポートします。 その構文は、組み込み SQL の場合と同様です。 カーソルには次のプロパティーがあります。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          Asensitive: サーバーは、結果テーブルのコピーを作成する場合としない場合があります
        </p></li><li class="listitem"><p>
          読み取り専用: 更新できません
        </p></li><li class="listitem"><p>
          スクロール不可: 1 方向にしかトラバースできず、行をスキップできません
        </p></li></ul></div><p>
      カーソル宣言は、ハンドラ宣言の前で、かつ変数および条件宣言のあとに指定する必要があります。
    </p><p>
      例:
    </p><pre class="programlisting">CREATE PROCEDURE curdemo()
BEGIN
  DECLARE done INT DEFAULT FALSE;
  DECLARE a CHAR(16);
  DECLARE b, c INT;
  DECLARE cur1 CURSOR FOR SELECT id,data FROM test.t1;
  DECLARE cur2 CURSOR FOR SELECT i FROM test.t2;
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

  OPEN cur1;
  OPEN cur2;

  read_loop: LOOP
    FETCH cur1 INTO a, b;
    FETCH cur2 INTO c;
    IF done THEN
      LEAVE read_loop;
    END IF;
    IF b &lt; c THEN
      INSERT INTO test.t3 VALUES (a,b);
    ELSE
      INSERT INTO test.t3 VALUES (a,c);
    END IF;
  END LOOP;

  CLOSE cur1;
  CLOSE cur2;
END;
</pre><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="close"></a>13.6.6.1 カーソル CLOSE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826993282144"></a><pre class="programlisting">CLOSE <em class="replaceable"><code>cursor_name</code></em>
</pre><p>
        このステートメントは、以前に開かれたカーソルを閉じます。 例については、<a class="xref" href="sql-statements.html#cursors" title="13.6.6 カーソル">セクション13.6.6「カーソル」</a>を参照してください。 
      </p><p>
        カーソルが開いていない場合は、エラーが発生します。
      </p><p>
        明示的に閉じられない場合は、そのカーソルが宣言された <code class="literal">BEGIN ... END</code> ブロックの最後に閉じられます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="declare-cursor"></a>13.6.6.2 カーソル DECLARE ステートメント</h4></div></div></div><pre class="programlisting">DECLARE <em class="replaceable"><code>cursor_name</code></em> CURSOR FOR <em class="replaceable"><code>select_statement</code></em>
</pre><p>
        このステートメントはカーソルを宣言し、そのカーソルによってトラバースされる行を取得する <code class="literal">SELECT</code> ステートメントに関連付けます。 行をあとでフェッチするには、<code class="literal">FETCH</code> ステートメントを使用します。 <code class="literal">SELECT</code> ステートメントによって取得されるカラムの数が、<code class="literal">FETCH</code> ステートメントで指定された出力変数の数に一致している必要があります。 
      </p><p>
        <code class="literal">SELECT</code> ステートメントに <code class="literal">INTO</code> 句を含めることはできません。
      </p><p>
        カーソル宣言は、ハンドラ宣言の前で、かつ変数および条件宣言のあとに指定する必要があります。
      </p><p>
        ストアドプログラムには複数のカーソル宣言を含めることができますが、特定のブロック内で宣言された各カーソルが一意の名前を持っている必要があります。 例については、<a class="xref" href="sql-statements.html#cursors" title="13.6.6 カーソル">セクション13.6.6「カーソル」</a>を参照してください。 
      </p><p>
        <code class="literal">SHOW</code> ステートメントで入手できる情報については、多くの場合、<code class="literal">INFORMATION_SCHEMA</code> テーブルでカーソルを使用することによって同等の情報を取得できます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="fetch"></a>13.6.6.3 カーソル FETCH ステートメント</h4></div></div></div><a class="indexterm" name="idm45826993252928"></a><pre class="programlisting">FETCH [[NEXT] FROM] <em class="replaceable"><code>cursor_name</code></em> INTO <em class="replaceable"><code>var_name</code></em> [, <em class="replaceable"><code>var_name</code></em>] ...
</pre><p>
        このステートメントは、指定されたカーソル (これは開いている必要があります) に関連付けられた <code class="literal">SELECT</code> ステートメントの次の行をフェッチし、そのカーソルのポインタを進めます。 行が存在する場合は、フェッチされたカラムが指定された変数に格納されます。 <code class="literal">SELECT</code> ステートメントによって取得されるカラムの数が、<code class="literal">FETCH</code> ステートメントで指定された出力変数の数に一致している必要があります。 
      </p><p>
        それ以上の行を取得できない場合は、SQLSTATE 値 <code class="literal">'02000'</code> で「データなし」状況が発生します。 この状況を検出するには、その状況 (または、<code class="literal">NOT FOUND</code> 状況) のハンドラを設定できます。 例については、<a class="xref" href="sql-statements.html#cursors" title="13.6.6 カーソル">セクション13.6.6「カーソル」</a>を参照してください。 
      </p><p>
        <code class="literal">SELECT</code> や別の <code class="literal">FETCH</code> などの別の操作でも、同じ条件を発生させることでハンドラが実行される場合があることに注意してください。 条件が発生した操作を区別する必要がある場合は、独自のハンドラに関連付けることができるように、操作を独自の <code class="literal">BEGIN ... END</code> ブロック内に配置します。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="open"></a>13.6.6.4 カーソル OPEN ステートメント</h4></div></div></div><a class="indexterm" name="idm45826993233824"></a><pre class="programlisting">OPEN <em class="replaceable"><code>cursor_name</code></em>
</pre><p>
        このステートメントは、以前に宣言されたカーソルを開きます。 例については、<a class="xref" href="sql-statements.html#cursors" title="13.6.6 カーソル">セクション13.6.6「カーソル」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="cursor-restrictions"></a>13.6.6.5 サーバー側のカーソルの制約</h4></div></div></div><a class="indexterm" name="idm45826993225440"></a><a class="indexterm" name="idm45826993223296"></a><p>
        サーバー側のカーソルは、<code class="literal">mysql_stmt_attr_set()</code> 関数を使用して C API に実装されます。 ストアドルーチンのカーソルにも同じ実装が使用されます。 サーバー側のカーソルによって、サーバー側で結果セットを生成できるようになりますが、クライアントが要求する行を除いてクライアントに転送することはできません。 たとえば、クライアントがクエリーを実行するが、最初の行のみが必要な場合、残りの行は転送されません。 
      </p><p>
        MySQL では、サーバー側のカーソルは内部一時テーブルに実体化されます。 最初これは <code class="literal">MEMORY</code> テーブルですが、そのサイズが <code class="literal">max_heap_table_size</code> および <code class="literal">tmp_table_size</code> システム変数の最小値を超えると、<code class="literal">MyISAM</code> テーブルに変換されます。 カーソルの結果セットを保持するために作成された内部一時テーブルには、内部一時テーブルの他の使用と同じ制限が適用されます。 <a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4 MySQL での内部一時テーブルの使用">セクション8.4.4「MySQL での内部一時テーブルの使用」</a>を参照してください。 この実装の制限の 1 つには、大きな結果セットの場合に、カーソルによる行の取得に時間がかかることがあるというものがあります。 
      </p><p>
        カーソルは読み取り専用です。カーソルを使用して行を更新できません。
      </p><p>
        <code class="literal">UPDATE WHERE CURRENT OF</code> および <code class="literal">DELETE WHERE CURRENT OF</code> は、更新可能なカーソルがサポートされていないため実装されません。
      </p><p>
        カーソルは保持不可能です (コミット後、開いたままにはできません)。
      </p><p>
        カーソルは非センシティブです。
      </p><p>
        カーソルはスクロール不可です。
      </p><p>
        カーソルには名前が付けられません。 ステートメントハンドラがカーソル ID として機能します。 
      </p><p>
        準備済みステートメントごとに、カーソルを 1 つだけ開いておくことができます。 複数のカーソルが必要な場合は、複数のステートメントを準備する必要があります。 
      </p><p>
        結果セットを生成するステートメントで、準備モードでサポートされていないものにはカーソルを使用できません。 このようなステートメントには、<code class="literal">CHECK TABLE</code>、<code class="literal">HANDLER READ</code>、<code class="literal">SHOW BINLOG EVENTS</code> などがあります。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="condition-handling"></a>13.6.7 条件の処理</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#declare-condition">13.6.7.1 DECLARE ... CONDITION ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#declare-handler">13.6.7.2 DECLARE ... HANDLER ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#get-diagnostics">13.6.7.3 GET DIAGNOSTICS ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#resignal">13.6.7.4 RESIGNAL ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#signal">13.6.7.5 SIGNAL ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#handler-scope">13.6.7.6 ハンドラのスコープに関するルール</a></span></dt><dt><span class="section"><a href="sql-statements.html#diagnostics-area">13.6.7.7 MySQL の診断領域</a></span></dt><dt><span class="section"><a href="sql-statements.html#conditions-and-parameters">13.6.7.8 条件の処理と OUT または INOUT パラメータ</a></span></dt></dl></div><p>
      条件は、現在のプログラムブロックの終了や実行の続行などの、特殊な処理が必要なストアドプログラムの実行中に発生する可能性があります。 警告や例外などの一般的な条件、または特定のエラーコードなどの具体的な条件に対してハンドラを定義できます。 具体的な条件には名前を割り当てることができるため、ハンドラではその名前で参照できます。 
    </p><p>
      条件に名前を付けるには、<code class="literal">DECLARE ... CONDITION</code> ステートメントを使用します。 ハンドラを宣言するには、<code class="literal">DECLARE ... HANDLER</code> ステートメントを使用します。 <a class="xref" href="sql-statements.html#declare-condition" title="13.6.7.1 DECLARE ... CONDITION ステートメント">セクション13.6.7.1「DECLARE ... CONDITION ステートメント」</a>および<a class="xref" href="sql-statements.html#declare-handler" title="13.6.7.2 DECLARE ... HANDLER ステートメント">セクション13.6.7.2「DECLARE ... HANDLER ステートメント」</a>を参照してください。 条件が発生したときにサーバーがハンドラを選択する方法については、<a class="xref" href="sql-statements.html#handler-scope" title="13.6.7.6 ハンドラのスコープに関するルール">セクション13.6.7.6「ハンドラのスコープに関するルール」</a>を参照してください。 
    </p><p>
      条件を発生させるには、<code class="literal">SIGNAL</code> ステートメントを使用します。 条件ハンドラ内で条件情報を変更するには、<code class="literal">RESIGNAL</code> を使用します。 <a class="xref" href="sql-statements.html#declare-condition" title="13.6.7.1 DECLARE ... CONDITION ステートメント">セクション13.6.7.1「DECLARE ... CONDITION ステートメント」</a>および<a class="xref" href="sql-statements.html#declare-handler" title="13.6.7.2 DECLARE ... HANDLER ステートメント">セクション13.6.7.2「DECLARE ... HANDLER ステートメント」</a>を参照してください。 
    </p><p>
      診断領域から情報を取得するには、<code class="literal">GET DIAGNOSTICS</code> ステートメントを使用します (<a class="xref" href="sql-statements.html#get-diagnostics" title="13.6.7.3 GET DIAGNOSTICS ステートメント">セクション13.6.7.3「GET DIAGNOSTICS ステートメント」</a>を参照してください)。 診断領域については、<a class="xref" href="sql-statements.html#diagnostics-area" title="13.6.7.7 MySQL の診断領域">セクション13.6.7.7「MySQL の診断領域」</a>を参照してください。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="declare-condition"></a>13.6.7.1 DECLARE ... CONDITION ステートメント</h4></div></div></div><a class="indexterm" name="idm45826993187600"></a><pre class="programlisting">DECLARE <em class="replaceable"><code>condition_name</code></em> CONDITION FOR <em class="replaceable"><code>condition_value</code></em>

<em class="replaceable"><code>condition_value</code></em>: {
    <em class="replaceable"><code>mysql_error_code</code></em>
  | SQLSTATE [VALUE] <em class="replaceable"><code>sqlstate_value</code></em>
}
</pre><p>
        <code class="literal">DECLARE ... CONDITION</code> ステートメントは名前付きエラー条件を宣言し、特定の処理が必要な条件に名前を関連付けます。 この名前は、以降の <code class="literal">DECLARE ... HANDLER</code> ステートメントで参照できます (<a class="xref" href="sql-statements.html#declare-handler" title="13.6.7.2 DECLARE ... HANDLER ステートメント">セクション13.6.7.2「DECLARE ... HANDLER ステートメント」</a>を参照してください)。 
      </p><p>
        条件宣言は、カーソルまたはハンドラ宣言の前に指定する必要があります。
      </p><p>
        <em class="replaceable"><code>condition_value</code></em> for <code class="literal">DECLARE ... CONDITION</code> は、条件名に関連付ける特定の条件または条件のクラスを示します。 次の形式を使用できます: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <em class="replaceable"><code>mysql_error_code</code></em>: MySQL エラーコードを示す整数リテラル。
          </p><p>
            MySQL エラーコード 0 はエラー条件ではなく成功を示すため、使用しないでください。 MySQL エラーコードのリストは、<a class="ulink" href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html" target="_top">Server Error Message Reference</a> を参照してください。 
          </p></li><li class="listitem"><p>
            SQLSTATE [VALUE] <em class="replaceable"><code>sqlstate_value</code></em>: SQLSTATE 値を示す 5 文字の文字列リテラル。
          </p><p>
            <code class="literal">'00'</code>で始まる SQLSTATE 値は、エラー条件ではなく成功を示すため、使用しないでください。 SQLSTATE 値のリストについては、<a class="ulink" href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html" target="_top">Server Error Message Reference</a> を参照してください。 
          </p></li></ul></div><p>
        <code class="literal">SIGNAL</code> で参照されるか、または <code class="literal">RESIGNAL</code> ステートメントで使用される条件名は MySQL エラーコードではなく、SQLSTATE 値に関連付けられている必要があります。
      </p><p>
        条件に名前を使用すると、ストアドプログラムのコードの明確化に役立つ場合があります。 たとえば、このハンドラは存在しないテーブルの削除の試行に適用されますが、1051 が<span class="quote">「<span class="quote">不明なテーブル</span>」</span>の MySQL エラーコードであることがわかっている場合にのみわかります: 
      </p><pre class="programlisting">DECLARE CONTINUE HANDLER FOR 1051
  BEGIN
    -- body of handler
  END;
</pre><p>
        条件の名前を宣言することによって、このハンドラの目的がより簡単にわかるようになります。
      </p><pre class="programlisting">DECLARE no_such_table CONDITION FOR 1051;
DECLARE CONTINUE HANDLER FOR no_such_table
  BEGIN
    -- body of handler
  END;
</pre><p>
        これは、同じ条件の、MySQL エラーコードではなく、対応する SQLSTATE 値に基づく名前付き条件です。
      </p><pre class="programlisting">DECLARE no_such_table CONDITION FOR SQLSTATE '42S02';
DECLARE CONTINUE HANDLER FOR no_such_table
  BEGIN
    -- body of handler
  END;
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="declare-handler"></a>13.6.7.2 DECLARE ... HANDLER ステートメント</h4></div></div></div><a class="indexterm" name="idm45826993156368"></a><pre class="programlisting">DECLARE <em class="replaceable"><code>handler_action</code></em> HANDLER
    FOR <em class="replaceable"><code>condition_value</code></em> [, <em class="replaceable"><code>condition_value</code></em>] ...
    <em class="replaceable"><code>statement</code></em>

<em class="replaceable"><code>handler_action</code></em>: {
    CONTINUE
  | EXIT
  | UNDO
}

<em class="replaceable"><code>condition_value</code></em>: {
    <em class="replaceable"><code>mysql_error_code</code></em>
  | SQLSTATE [VALUE] <em class="replaceable"><code>sqlstate_value</code></em>
  | <em class="replaceable"><code>condition_name</code></em>
  | SQLWARNING
  | NOT FOUND
  | SQLEXCEPTION
}
</pre><p>
        <code class="literal">DECLARE ... HANDLER</code> ステートメントは、1 つ以上の条件を処理するハンドラを指定します。 これらの条件のいずれかが発生した場合は、指定された <em class="replaceable"><code>statement</code></em> が実行されます。<em class="replaceable"><code>statement</code></em> は <code class="literal">SET <em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>value</code></em></code> などの単純なステートメントでも、<code class="literal">BEGIN</code> と <code class="literal">END</code> を使用して記述された複合ステートメントでもかまいません (<a class="xref" href="sql-statements.html#begin-end" title="13.6.1 BEGIN ... END 複合ステートメント">セクション13.6.1「BEGIN ... END 複合ステートメント」</a>を参照してください)。 
      </p><p>
        ハンドラ宣言は、変数または条件宣言のあとに指定する必要があります。
      </p><p>
        <em class="replaceable"><code>handler_action</code></em> 値は、ハンドラステートメントの実行後にハンドラがどのようなアクションを実行するかを示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CONTINUE</code>: 現在のプログラムの実行が続行されます。
          </p></li><li class="listitem"><p>
            <code class="literal">EXIT</code>: このハンドラが宣言されている <code class="literal">BEGIN ... END</code> 複合ステートメントの実行が終了します。 これは、この条件が内側のブロックで発生した場合にも当てはまります。 
          </p></li><li class="listitem"><p>
            <code class="literal">UNDO</code>: サポートされていません。
          </p></li></ul></div><p>
        <em class="replaceable"><code>condition_value</code></em> for <code class="literal">DECLARE ... HANDLER</code> は、ハンドラをアクティブ化する特定の条件または条件のクラスを示します。 次の形式を使用できます: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <em class="replaceable"><code>mysql_error_code</code></em> : MySQL エラーコードを示す整数リテラル (<span class="quote">「<span class="quote">不明なテーブル</span>」</span>を指定する 1051 など) :
          </p><pre class="programlisting">DECLARE CONTINUE HANDLER FOR 1051
  BEGIN
    -- body of handler
  END;
</pre><p>
            MySQL エラーコード 0 はエラー条件ではなく成功を示すため、使用しないでください。 MySQL エラーコードのリストは、<a class="ulink" href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html" target="_top">Server Error Message Reference</a> を参照してください。 
          </p></li><li class="listitem"><p>
            SQLSTATE [VALUE] <em class="replaceable"><code>sqlstate_value</code></em> : SQLSTATE 値を示す 5 文字の文字列リテラル (<span class="quote">「<span class="quote">不明なテーブル</span>」</span>を指定する<code class="literal">'42S01'</code>など) :
          </p><pre class="programlisting">DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02'
  BEGIN
    -- body of handler
  END;
</pre><p>
            <code class="literal">'00'</code>で始まる SQLSTATE 値は、エラー条件ではなく成功を示すため、使用しないでください。 SQLSTATE 値のリストについては、<a class="ulink" href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html" target="_top">Server Error Message Reference</a> を参照してください。 
          </p></li><li class="listitem"><p>
            <em class="replaceable"><code>condition_name</code></em>: <code class="literal">DECLARE ... CONDITION</code> で以前に指定された条件名。 条件名は MySQL エラーコードまたは SQLSTATE 値に関連付けることができます。 <a class="xref" href="sql-statements.html#declare-condition" title="13.6.7.1 DECLARE ... CONDITION ステートメント">セクション13.6.7.1「DECLARE ... CONDITION ステートメント」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">SQLWARNING</code>: <code class="literal">'01'</code>で始まる SQLSTATE 値のクラスの短縮形。
          </p><pre class="programlisting">DECLARE CONTINUE HANDLER FOR SQLWARNING
  BEGIN
    -- body of handler
  END;
</pre></li><li class="listitem"><p>
            <code class="literal">NOT FOUND</code>: <code class="literal">'02'</code>で始まる SQLSTATE 値のクラスの短縮形。 これは、カーソルのコンテキストに関係しており、カーソルがデータセットの最後に達したときの動作を制御するために使用します。 それ以上の行を取得できない場合は、SQLSTATE 値 <code class="literal">'02000'</code> で「データなし」状況が発生します。 この条件を検出するには、その条件または <code class="literal">NOT FOUND</code> 条件のハンドラを設定します。 
          </p><pre class="programlisting">DECLARE CONTINUE HANDLER FOR NOT FOUND
  BEGIN
    -- body of handler
  END;
</pre><p>
            別の例については、<a class="xref" href="sql-statements.html#cursors" title="13.6.6 カーソル">セクション13.6.6「カーソル」</a> を参照してください。 <code class="literal">NOT FOUND</code> 条件は、行を取得しない <code class="literal">SELECT ... INTO <em class="replaceable"><code>var_list</code></em></code> ステートメントにも発生します。 
          </p></li><li class="listitem"><p>
            <code class="literal">SQLEXCEPTION</code>: <code class="literal">'00'</code>、<code class="literal">'01'</code>または<code class="literal">'02'</code>で始まらない SQLSTATE 値のクラスの短縮形。
          </p><pre class="programlisting">DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
  BEGIN
    -- body of handler
  END;
</pre></li></ul></div><p>
        条件が発生したときにサーバーがハンドラを選択する方法については、<a class="xref" href="sql-statements.html#handler-scope" title="13.6.7.6 ハンドラのスコープに関するルール">セクション13.6.7.6「ハンドラのスコープに関するルール」</a>を参照してください。
      </p><p>
        対応するハンドラが宣言されていない条件が発生した場合、実行されるアクションはその条件のクラスによって異なります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">SQLEXCEPTION</code> 条件の場合は、<code class="literal">EXIT</code> ハンドラが存在するかのように、ストアドプログラムはその条件を発生させたステートメントで終了します。 そのプログラムが別のストアドプログラムから呼び出されていた場合は、呼び出し元プログラムが、独自のハンドラに適用されるハンドラ選択ルールを使用してその条件を処理します。 
          </p></li><li class="listitem"><p>
            <code class="literal">SQLWARNING</code> 条件の場合は、<code class="literal">CONTINUE</code> ハンドラが存在するかのように、プログラムは実行を続行します。
          </p></li><li class="listitem"><p>
            <code class="literal">NOT FOUND</code> 条件では、その条件が正常に発生した場合、アクションは <code class="literal">CONTINUE</code> です。 <code class="literal">SIGNAL</code> または <code class="literal">RESIGNAL</code> によって発生した場合、アクションは <code class="literal">EXIT</code> です。 
          </p></li></ul></div><p>
        次の例では、重複キーエラーに対して発生する <code class="literal">SQLSTATE '23000'</code> のハンドラを使用します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE test.t (s1 INT, PRIMARY KEY (s1));</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>delimiter //</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE PROCEDURE handlerdemo ()</code></strong>
       <strong class="userinput"><code>BEGIN</code></strong>
         <strong class="userinput"><code>DECLARE CONTINUE HANDLER FOR SQLSTATE '23000' SET @x2 = 1;</code></strong>
         <strong class="userinput"><code>SET @x = 1;</code></strong>
         <strong class="userinput"><code>INSERT INTO test.t VALUES (1);</code></strong>
         <strong class="userinput"><code>SET @x = 2;</code></strong>
         <strong class="userinput"><code>INSERT INTO test.t VALUES (1);</code></strong>
         <strong class="userinput"><code>SET @x = 3;</code></strong>
       <strong class="userinput"><code>END;</code></strong>
       <strong class="userinput"><code>//</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>CALL handlerdemo()//</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @x//</code></strong>
    +------+
    | @x   |
    +------+
    | 3    |
    +------+
    1 row in set (0.00 sec)
</pre><p>
        このプロシージャーの実行後、<code class="literal">@x</code> が <code class="literal">3</code> になっていることを確認してください。これは、エラーが発生したあと、プロシージャーの最後まで実行が続行されたことを示しています。 <code class="literal">DECLARE ... HANDLER</code> ステートメントが存在しなかったとすると、<code class="literal">PRIMARY KEY</code> 制約のために 2 番目の <code class="literal">INSERT</code> が失敗したあとに MySQL はデフォルトのアクション (<code class="literal">EXIT</code>) を実行するため、<code class="literal">SELECT @x</code> は <code class="literal">2</code> を返していました。 
      </p><p>
        条件を無視するには、その条件の <code class="literal">CONTINUE</code> ハンドラを宣言し、それを空のブロックに関連付けます。 例: 
      </p><pre class="programlisting">DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN END;
</pre><p>
        ブロックラベルのスコープには、そのブロック内で宣言されているハンドラのコードは含まれません。 そのため、ハンドラに関連付けられたステートメントは、<code class="literal">ITERATE</code> または <code class="literal">LEAVE</code> を使用して、そのハンドラ宣言を囲むブロックのラベルを参照することができません。 <code class="literal">REPEAT</code> ブロックに <code class="literal">retry</code> のラベルが含まれている次の例を考えてみます。 
      </p><pre class="programlisting">CREATE PROCEDURE p ()
BEGIN
  DECLARE i INT DEFAULT 3;
  retry:
    REPEAT
      BEGIN
        DECLARE CONTINUE HANDLER FOR SQLWARNING
          BEGIN
            ITERATE retry;    # illegal
          END;
        IF i &lt; 0 THEN
          LEAVE retry;        # legal
        END IF;
        SET i = i - 1;
      END;
    UNTIL FALSE END REPEAT;
END;
</pre><p>
        <code class="literal">retry</code> ラベルは、そのブロック内の <code class="literal">IF</code> ステートメントのスコープ内にあります。 <code class="literal">CONTINUE</code> ハンドラのスコープ内にはないため、そこでの参照は無効であり、エラーが発生します。 
      </p><pre class="programlisting">ERROR 1308 (42000): LEAVE with no matching label: retry
</pre><p>
        ハンドラ内の外側のラベルへの参照を回避するには、次の方法のいずれかを使用します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            このブロックを離れるには、<code class="literal">EXIT</code> ハンドラを使用します。 ブロックのクリーンアップが必要ない場合は、<code class="literal">BEGIN ... END</code> ハンドラ本体を空にすることができます。 
          </p><pre class="programlisting">DECLARE EXIT HANDLER FOR SQLWARNING BEGIN END;
</pre><p>
            そうでない場合は、ハンドラ本体内にクリーンアップステートメントを配置します。
          </p><pre class="programlisting">DECLARE EXIT HANDLER FOR SQLWARNING
  BEGIN
    <em class="replaceable"><code>block cleanup statements</code></em>
  END;
</pre></li><li class="listitem"><p>
            実行を続行するには、<code class="literal">CONTINUE</code> ハンドラ内に、囲んでいるブロック内でチェックすることによってそのハンドラが呼び出されたかどうかを判定できるステータス変数を設定します。 次の例では、この目的のために変数 <code class="literal">done</code> を使用します。 
          </p><pre class="programlisting">CREATE PROCEDURE p ()
BEGIN
  DECLARE i INT DEFAULT 3;
  DECLARE done INT DEFAULT FALSE;
  retry:
    REPEAT
      BEGIN
        DECLARE CONTINUE HANDLER FOR SQLWARNING
          BEGIN
            SET done = TRUE;
          END;
        IF done OR i &lt; 0 THEN
          LEAVE retry;
        END IF;
        SET i = i - 1;
      END;
    UNTIL FALSE END REPEAT;
END;
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="get-diagnostics"></a>13.6.7.3 GET DIAGNOSTICS ステートメント</h4></div></div></div><a class="indexterm" name="idm45826993039584"></a><pre class="programlisting">GET [CURRENT | STACKED] DIAGNOSTICS {
    <em class="replaceable"><code>statement_information_item</code></em>
    [, <em class="replaceable"><code>statement_information_item</code></em>] ...
  | CONDITION <em class="replaceable"><code>condition_number</code></em>
    <em class="replaceable"><code>condition_information_item</code></em>
    [, <em class="replaceable"><code>condition_information_item</code></em>] ...
}

<em class="replaceable"><code>statement_information_item</code></em>:
    <em class="replaceable"><code>target</code></em> = <em class="replaceable"><code>statement_information_item_name</code></em>

<em class="replaceable"><code>condition_information_item</code></em>:
    <em class="replaceable"><code>target</code></em> = <em class="replaceable"><code>condition_information_item_name</code></em>

<em class="replaceable"><code>statement_information_item_name</code></em>: {
    NUMBER
  | ROW_COUNT
}

<em class="replaceable"><code>condition_information_item_name</code></em>: {
    CLASS_ORIGIN
  | SUBCLASS_ORIGIN
  | RETURNED_SQLSTATE
  | MESSAGE_TEXT
  | MYSQL_ERRNO
  | CONSTRAINT_CATALOG
  | CONSTRAINT_SCHEMA
  | CONSTRAINT_NAME
  | CATALOG_NAME
  | SCHEMA_NAME
  | TABLE_NAME
  | COLUMN_NAME
  | CURSOR_NAME
}

<em class="replaceable"><code>condition_number</code></em>, <em class="replaceable"><code>target</code></em>:
    (see following discussion)
</pre><p>
        SQL ステートメントは、診断領域を移入する診断情報を生成します。 <code class="literal">GET DIAGNOSTICS</code> ステートメントを使用すると、アプリケーションでこの情報を検査できます。 (<code class="literal">SHOW WARNINGS</code> または <code class="literal">SHOW ERRORS</code> を使用して、条件またはエラーを確認することもできます。)  
      </p><p>
        <code class="literal">GET DIAGNOSTICS</code> を実行するために特殊な権限は必要ありません。
      </p><p>
        キーワード <code class="literal">CURRENT</code> は、現在の診断領域から情報を取得することを示します。 キーワード <code class="literal">STACKED</code> は、現在のコンテキストが条件ハンドラである場合にのみ使用可能な 2 番目の診断領域から情報を取得することを意味します。 どちらのキーワードも指定しない場合、デフォルトでは現在の診断領域が使用されます。 
      </p><p>
        <code class="literal">GET DIAGNOSTICS</code> ステートメントは通常、ストアドプログラム内のハンドラで使用されます。 これは、任意の SQL ステートメントの実行をチェックするためにハンドラコンテキストの外部で <code class="literal">GET [CURRENT] DIAGNOSTICS</code> が許可されている MySQL 拡張機能です。 たとえば、<span class="command"><strong>mysql</strong></span> クライアントプログラムを呼び出す場合は、プロンプトで次のステートメントを入力できます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>DROP TABLE test.no_such_table;</code></strong>
ERROR 1051 (42S02): Unknown table 'test.no_such_table'
mysql&gt; <strong class="userinput"><code>GET DIAGNOSTICS CONDITION 1</code></strong>
         <strong class="userinput"><code>@p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT @p1, @p2;</code></strong>
+-------+------------------------------------+
| @p1   | @p2                                |
+-------+------------------------------------+
| 42S02 | Unknown table 'test.no_such_table' |
+-------+------------------------------------+
</pre><p>
        この拡張機能は、現在の診断領域にのみ適用されます。 <code class="literal">GET STACKED DIAGNOSTICS</code> は現在のコンテキストが条件ハンドラである場合にのみ許可されるため、2 番目の診断領域には適用されません。 そうでない場合は、<code class="literal">GET STACKED DIAGNOSTICS when handler not active</code> エラーが発生します。 
      </p><p>
        診断領域については、<a class="xref" href="sql-statements.html#diagnostics-area" title="13.6.7.7 MySQL の診断領域">セクション13.6.7.7「MySQL の診断領域」</a>を参照してください。 簡単に言うと、ここには次の 2 種類の情報が含まれています。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            発生した条件の数や、影響を受けた行数などのステートメント情報。
          </p></li><li class="listitem"><p>
            エラーコードやメッセージなどの条件情報。 ステートメントが複数の条件を発生させた場合、診断領域のこの部分には条件ごとの条件領域が含まれています。 ステートメントがどの条件も発生させない場合、診断領域のこの部分は空です。 
          </p></li></ul></div><p>
        3 つの条件を生成するステートメントの場合、診断領域には、次のようなステートメント情報と条件情報が含まれています。
      </p><pre class="programlisting">Statement information:
  row count
  ... other statement information items ...
Condition area list:
  Condition area 1:
    error code for condition 1
    error message for condition 1
    ... other condition information items ...
  Condition area 2:
    error code for condition 2:
    error message for condition 2
    ... other condition information items ...
  Condition area 3:
    error code for condition 3
    error message for condition 3
    ... other condition information items ...
</pre><p>
        <code class="literal">GET DIAGNOSTICS</code> はステートメントまたは条件情報のどちらかを取得できますが、同じステートメントで両方を取得することはできません。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ステートメント情報を取得するには、目的のステートメント項目をターゲット変数に取得します。 <code class="literal">GET DIAGNOSTICS</code> の次の例では、使用可能な条件の数と影響を受けた行数をユーザー変数 <code class="literal">@p1</code> と <code class="literal">@p2</code> に割り当てます。 
          </p><pre class="programlisting">GET DIAGNOSTICS @p1 = NUMBER, @p2 = ROW_COUNT;
</pre></li><li class="listitem"><p>
            条件情報を取得するには、条件番号を指定し、目的の条件項目をターゲット変数に取得します。 <code class="literal">GET DIAGNOSTICS</code> の次の例では、SQLSTATE 値とエラーメッセージをユーザー変数 <code class="literal">@p3</code> と <code class="literal">@p4</code> に割り当てます。 
          </p><pre class="programlisting">GET DIAGNOSTICS CONDITION 1
  @p3 = RETURNED_SQLSTATE, @p4 = MESSAGE_TEXT;
</pre></li></ul></div><p>
        取得リストには、カンマで区切られた 1 つ以上の <code class="literal"><em class="replaceable"><code>target</code></em> = <em class="replaceable"><code>item_name</code></em></code> 代入を指定します。 各代入では、ターゲット変数と、このステートメントがステートメントまたは条件情報のどちらを取得するかに応じて <em class="replaceable"><code>statement_information_item_name</code></em> または <em class="replaceable"><code>condition_information_item_name</code></em> 指示子のどちらかを指定します。 
      </p><p>
        項目情報を格納するための有効な <em class="replaceable"><code>target</code></em> 指示子は、ストアドプロシージャーやストアドファンクションのパラメータ、<code class="literal">DECLARE</code> で宣言されたストアドプログラムのローカル変数、ユーザー定義変数のいずれかです。
      </p><p>
        有効な <em class="replaceable"><code>condition_number</code></em> 指示子は、ストアドプロシージャーやストアドファンクションのパラメータ、<code class="literal">DECLARE</code> で宣言されたストアドプログラムのローカル変数、ユーザー定義変数、システム変数、リテラルのいずれかです。 文字リテラルには、<em class="replaceable"><code>_charset</code></em> イントロデューサを含めることができます。 条件番号が 1 から、情報が含まれている条件領域の数までの範囲にない場合は、警告が発生します。 この場合、この警告は、診断領域にその領域をクリアすることなく追加されます。 
      </p><p>
        条件が発生した場合、MySQL は、<code class="literal">GET DIAGNOSTICS</code> で認識されるすべての条件アイテムを移入しません。 例: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>GET DIAGNOSTICS CONDITION 1</code></strong>
         <strong class="userinput"><code>@p5 = SCHEMA_NAME, @p6 = TABLE_NAME;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT @p5, @p6;</code></strong>
+------+------+
| @p5  | @p6  |
+------+------+
|      |      |
+------+------+
</pre><p>
        標準 SQL では、複数の条件が存在する場合、最初の条件は前の SQL ステートメントに対して返された <code class="literal">SQLSTATE</code> 値に関連しています。 MySQL では、これが保証されません。 メインのエラーを取得するために、次のように行うことはできません。 
      </p><pre class="programlisting">GET DIAGNOSTICS CONDITION 1 @errno = MYSQL_ERRNO;
</pre><p>
        代わりに、まず条件数を取得し、次にそれを使用してどの条件番号を検査するかを指定します。
      </p><pre class="programlisting">GET DIAGNOSTICS @cno = NUMBER;
GET DIAGNOSTICS CONDITION @cno @errno = MYSQL_ERRNO;
</pre><p>
        許可されるステートメント情報と条件情報の項目、および条件が発生したときにどの項目が移入されるかについては、<a class="xref" href="sql-statements.html#diagnostics-area-information-items" title="診断領域の情報項目">診断領域の情報項目</a>を参照してください。
      </p><p>
        ストアドプロシージャーのコンテキストで <code class="literal">GET DIAGNOSTICS</code> と例外ハンドラを使用して、挿入操作の結果を評価する例を次に示します。 挿入が成功した場合、このプロシージャーは <code class="literal">GET DIAGNOSTICS</code> を使用して、影響を受けた行数を取得します。 これは、現在の診断領域がクリアされていないかぎり、<code class="literal">GET DIAGNOSTICS</code> を複数回使用してステートメントに関する情報を取得できることを示しています。 
      </p><pre class="programlisting">CREATE PROCEDURE do_insert(value INT)
BEGIN
  -- Declare variables to hold diagnostics area information
  DECLARE code CHAR(5) DEFAULT '00000';
  DECLARE msg TEXT;
  DECLARE nrows INT;
  DECLARE result TEXT;
  -- Declare exception handler for failed insert
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS CONDITION 1
        code = RETURNED_SQLSTATE, msg = MESSAGE_TEXT;
    END;

  -- Perform the insert
  INSERT INTO t1 (int_col) VALUES(value);
  -- Check whether the insert was successful
  IF code = '00000' THEN
    GET DIAGNOSTICS nrows = ROW_COUNT;
    SET result = CONCAT('insert succeeded, row count = ',nrows);
  ELSE
    SET result = CONCAT('insert failed, error = ',code,', message = ',msg);
  END IF;
  -- Say what happened
  SELECT result;
END;
</pre><p>
        <code class="literal">t1.int_col</code> が、<code class="literal">NOT NULL</code> として宣言された整数カラムであるとします。 このプロシージャーは、<code class="literal">NULL</code> 以外の値と <code class="literal">NULL</code> 値を挿入するために呼び出されると、それぞれ次の結果を生成します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CALL do_insert(1);</code></strong>
+---------------------------------+
| result                          |
+---------------------------------+
| insert succeeded, row count = 1 |
+---------------------------------+

mysql&gt; <strong class="userinput"><code>CALL do_insert(NULL);</code></strong>
+-------------------------------------------------------------------------+
| result                                                                  |
+-------------------------------------------------------------------------+
| insert failed, error = 23000, message = Column 'int_col' cannot be null |
+-------------------------------------------------------------------------+
</pre><p>
        条件ハンドラがアクティブ化されると、診断領域スタックへのプッシュが発生します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            最初の (現在の) 診断領域が 2 番目の (スタックされた) 診断領域になり、新しい現在の診断領域がそのコピーとして作成されます。
          </p></li><li class="listitem"><p>
            ハンドラ内で <code class="literal">GET [CURRENT] DIAGNOSTICS</code> および <code class="literal">GET STACKED DIAGNOSTICS</code> を使用して、現在の診断領域およびスタック診断領域の内容にアクセスできます。
          </p></li><li class="listitem"><p>
            最初は、両方の診断領域が同じ結果を返すため、ハンドラをアクティブ化した条件に関する情報を現在の診断領域から取得できます。<span class="emphasis"><em>次の期間</em></span>は、ハンドラ内で現在の診断領域を変更するステートメントを実行しません。
          </p></li><li class="listitem"><p>
            ただし、ハンドラ内で実行されるステートメントは、現在の診断領域を変更し、通常の規則に従ってその内容をクリアおよび設定できます (<a class="xref" href="sql-statements.html#diagnostics-area-populating" title="診断領域のクリアおよび移入方法">診断領域のクリアおよび移入方法</a> を参照)。
          </p><p>
            ハンドラのアクティブ化条件に関する情報を取得する信頼性の高い方法は、スタック診断領域を使用することです。スタック診断領域は、<code class="literal">RESIGNAL</code> 以外のハンドラ内で実行されているステートメントでは変更できません。 現在の診断領域が設定およびクリアされるタイミングの詳細は、<a class="xref" href="sql-statements.html#diagnostics-area" title="13.6.7.7 MySQL の診断領域">セクション13.6.7.7「MySQL の診断領域」</a> を参照してください。 
          </p></li></ul></div><p>
        次の例は、ハンドラステートメントによって現在の診断領域が変更された後でも、ハンドラ内で <code class="literal">GET STACKED DIAGNOSTICS</code> を使用して処理された例外に関する情報を取得する方法を示しています。
      </p><p>
        ストアドプロシージャ <code class="literal">p()</code> 内で、<code class="literal">TEXT NOT NULL</code> カラムを含むテーブルに 2 つの値を挿入しようとしました。 最初の値は <code class="literal">NULL</code> 以外の文字列で、次の値は <code class="literal">NULL</code> です。 このカラムでは <code class="literal">NULL</code> 値が禁止されているため、最初の挿入は成功しますが、次の挿入によって例外が発生します。 このプロシージャには、空の文字列の挿入に <code class="literal">NULL</code> の挿入をマップする例外ハンドラが含まれています: 
      </p><pre class="programlisting">DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (c1 TEXT NOT NULL);
DROP PROCEDURE IF EXISTS p;
delimiter //
CREATE PROCEDURE p ()
BEGIN
  -- Declare variables to hold diagnostics area information
  DECLARE errcount INT;
  DECLARE errno INT;
  DECLARE msg TEXT;
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    -- Here the current DA is nonempty because no prior statements
    -- executing within the handler have cleared it
    GET CURRENT DIAGNOSTICS CONDITION 1
      errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;
    SELECT 'current DA before mapped insert' AS op, errno, msg;
    GET STACKED DIAGNOSTICS CONDITION 1
      errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;
    SELECT 'stacked DA before mapped insert' AS op, errno, msg;

    -- Map attempted NULL insert to empty string insert
    INSERT INTO t1 (c1) VALUES('');

    -- Here the current DA should be empty (if the INSERT succeeded),
    -- so check whether there are conditions before attempting to
    -- obtain condition information
    GET CURRENT DIAGNOSTICS errcount = NUMBER;
    IF errcount = 0
    THEN
      SELECT 'mapped insert succeeded, current DA is empty' AS op;
    ELSE
      GET CURRENT DIAGNOSTICS CONDITION 1
        errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;
      SELECT 'current DA after mapped insert' AS op, errno, msg;
    END IF ;
    GET STACKED DIAGNOSTICS CONDITION 1
      errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;
    SELECT 'stacked DA after mapped insert' AS op, errno, msg;
  END;
  INSERT INTO t1 (c1) VALUES('string 1');
  INSERT INTO t1 (c1) VALUES(NULL);
END;
//
delimiter ;
CALL p();
SELECT * FROM t1;
</pre><p>
        ハンドラがアクティブになると、現在の診断領域のコピーが診断領域スタックにプッシュされます。 ハンドラは最初に現在の診断領域とスタック診断領域の内容を表示します。これらはどちらも最初は同じです: 
      </p><pre class="programlisting">+---------------------------------+-------+----------------------------+
| op                              | errno | msg                        |
+---------------------------------+-------+----------------------------+
| current DA before mapped insert |  1048 | Column 'c1' cannot be null |
+---------------------------------+-------+----------------------------+

+---------------------------------+-------+----------------------------+
| op                              | errno | msg                        |
+---------------------------------+-------+----------------------------+
| stacked DA before mapped insert |  1048 | Column 'c1' cannot be null |
+---------------------------------+-------+----------------------------+
</pre><p>
        <code class="literal">GET DIAGNOSTICS</code> ステートメントのあとに実行されるステートメントは、現在の診断領域をリセットできます。ステートメントは、現在の診断領域をリセットできます。 たとえば、ハンドラは <code class="literal">NULL</code> 挿入を空の文字列挿入にマップし、結果を表示します。 新しい挿入は成功し、現在の診断領域はクリアされますが、スタックされた診断領域は変更されず、ハンドラをアクティブ化した条件に関する情報が引き続き含まれます: 
      </p><pre class="programlisting">+----------------------------------------------+
| op                                           |
+----------------------------------------------+
| mapped insert succeeded, current DA is empty |
+----------------------------------------------+

+--------------------------------+-------+----------------------------+
| op                             | errno | msg                        |
+--------------------------------+-------+----------------------------+
| stacked DA after mapped insert |  1048 | Column 'c1' cannot be null |
+--------------------------------+-------+----------------------------+
</pre><p>
        条件ハンドラが終了すると、その現在の診断領域がスタックからポップされ、スタックされた診断領域がストアドプロシージャの現在の診断領域になります。
      </p><p>
        プロシージャが戻ると、テーブルには 2 つの行が含まれます。 空の行は、空の文字列の挿入にマップされた <code class="literal">NULL</code> を挿入しようとした結果です: 
      </p><pre class="programlisting">+----------+
| c1       |
+----------+
| string 1 |
|          |
+----------+
</pre><p>
        前述の例では、現在の診断領域とスタック診断領域から情報を取得する条件ハンドラ内の最初の 2 つの <code class="literal">GET DIAGNOSTICS</code> ステートメントが同じ値を返します。 これは、現在の診断領域をリセットするステートメントがハンドラ内で以前に実行された場合には当てはまりません。 <code class="literal">p()</code> が、前ではなくハンドラ定義内に <code class="literal">DECLARE</code> ステートメントを配置するようにリライトされるとします: 
      </p><pre class="programlisting">CREATE PROCEDURE p ()
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    -- Declare variables to hold diagnostics area information
    DECLARE errcount INT;
    DECLARE errno INT;
    DECLARE msg TEXT;
    GET CURRENT DIAGNOSTICS CONDITION 1
      errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;
    SELECT 'current DA before mapped insert' AS op, errno, msg;
    GET STACKED DIAGNOSTICS CONDITION 1
      errno = MYSQL_ERRNO, msg = MESSAGE_TEXT;
    SELECT 'stacked DA before mapped insert' AS op, errno, msg;
...
</pre><p>
        この場合、結果はバージョンに依存します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL 5.7.2 より前では、<code class="literal">DECLARE</code> は現在の診断領域を変更しないため、最初の 2 つの <code class="literal">GET DIAGNOSTICS</code> ステートメントは <code class="literal">p()</code> の元のバージョンと同じ結果を返します。
          </p><p>
            MySQL 5.7.2 では、すべての非診断ステートメントが SQL 標準に従って診断領域に移入されるように作業が行われました。 <code class="literal">DECLARE</code> はこれらのいずれかであるため、5.7.2 以上では、ハンドラの先頭で実行されている <code class="literal">DECLARE</code> ステートメントによって現在の診断領域がクリアされ、<code class="literal">GET DIAGNOSTICS</code> ステートメントによって異なる結果が生成されます: 
          </p><pre class="programlisting">+---------------------------------+-------+------+
| op                              | errno | msg  |
+---------------------------------+-------+------+
| current DA before mapped insert |  NULL | NULL |
+---------------------------------+-------+------+

+---------------------------------+-------+----------------------------+
| op                              | errno | msg                        |
+---------------------------------+-------+----------------------------+
| stacked DA before mapped insert |  1048 | Column 'c1' cannot be null |
+---------------------------------+-------+----------------------------+
</pre></li></ul></div><p>
        ハンドラをアクティブ化した条件に関する情報を取得するときに条件ハンドラ内でこの問題を回避するには、現在の診断領域ではなく、スタック診断領域にアクセスしてください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="resignal"></a>13.6.7.4 RESIGNAL ステートメント</h4></div></div></div><a class="indexterm" name="idm45826992904672"></a><pre class="programlisting">RESIGNAL [<em class="replaceable"><code>condition_value</code></em>]
    [SET <em class="replaceable"><code>signal_information_item</code></em>
    [, <em class="replaceable"><code>signal_information_item</code></em>] ...]

<em class="replaceable"><code>condition_value</code></em>: {
    SQLSTATE [VALUE] <em class="replaceable"><code>sqlstate_value</code></em>
  | <em class="replaceable"><code>condition_name</code></em>
}

<em class="replaceable"><code>signal_information_item</code></em>:
    <em class="replaceable"><code>condition_information_item_name</code></em> = <em class="replaceable"><code>simple_value_specification</code></em>

<em class="replaceable"><code>condition_information_item_name</code></em>: {
    CLASS_ORIGIN
  | SUBCLASS_ORIGIN
  | MESSAGE_TEXT
  | MYSQL_ERRNO
  | CONSTRAINT_CATALOG
  | CONSTRAINT_SCHEMA
  | CONSTRAINT_NAME
  | CATALOG_NAME
  | SCHEMA_NAME
  | TABLE_NAME
  | COLUMN_NAME
  | CURSOR_NAME
}

<em class="replaceable"><code>condition_name</code></em>, <em class="replaceable"><code>simple_value_specification</code></em>:
    (see following discussion)
</pre><p>
        <code class="literal">RESIGNAL</code> は、ストアドプロシージャーやストアドファンクションの内部にある複合ステートメント内の条件ハンドラ、トリガー、またはイベントの実行中に使用可能なエラー条件情報を渡します。 <code class="literal">RESIGNAL</code> は、その情報の一部またはすべてを、渡す前に変更する可能性があります。 <code class="literal">RESIGNAL</code> は <code class="literal">SIGNAL</code> に関連していますが、<code class="literal">SIGNAL</code> のように条件を発信する代わりに、<code class="literal">RESIGNAL</code> は既存の条件情報を (おそらく、変更してから) 中継します。 
      </p><p>
        <code class="literal">RESIGNAL</code> は、エラーを処理することと、エラー情報を返すことの両方を可能にします。 それ以外の場合は、ハンドラ内の SQL ステートメントを実行することによって、そのハンドラのアクティブ化を発生させた情報が破棄されます。 <code class="literal">RESIGNAL</code> は、指定されたハンドラが状況の一部を処理できる場合はプロシージャーの一部を短くしてから、条件を<span class="quote">「<span class="quote">遡って</span>」</span>別のハンドラに渡すことができます。 
      </p><p>
        <code class="literal">RESIGNAL</code> ステートメントの実行に必要な権限はありません。
      </p><p>
        <code class="literal">RESIGNAL</code> のすべての形式で、現在のコンテキストが条件ハンドラである必要があります。 そうでない場合、<code class="literal">RESIGNAL</code> は不正であり、<code class="literal">RESIGNAL when handler not active</code> エラーが発生します。 
      </p><p>
        診断領域から情報を取得するには、<code class="literal">GET DIAGNOSTICS</code> ステートメントを使用します (<a class="xref" href="sql-statements.html#get-diagnostics" title="13.6.7.3 GET DIAGNOSTICS ステートメント">セクション13.6.7.3「GET DIAGNOSTICS ステートメント」</a>を参照してください)。 診断領域については、<a class="xref" href="sql-statements.html#diagnostics-area" title="13.6.7.7 MySQL の診断領域">セクション13.6.7.7「MySQL の診断領域」</a>を参照してください。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#resignal-overview" title="RESIGNAL の概要">RESIGNAL の概要</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#resignal-alone" title="RESIGNAL のみ">RESIGNAL のみ</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#resignal-with-new-signal" title="新しいシグナル情報を含む RESIGNAL">新しいシグナル情報を含む RESIGNAL</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#resignal-with-condition" title="条件値とオプションの新しいシグナル情報を含む RESIGNAL">条件値とオプションの新しいシグナル情報を含む RESIGNAL</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#resignal-handler" title="RESIGNAL には条件ハンドラのコンテキストが必要">RESIGNAL には条件ハンドラのコンテキストが必要</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="resignal-overview"></a>RESIGNAL の概要</h5></div></div></div><p>
          <code class="literal">RESIGNAL</code> に対する <em class="replaceable"><code>condition_value</code></em> と <em class="replaceable"><code>signal_information_item</code></em> の定義やルールは、<code class="literal">SIGNAL</code> に対するものと同じです。 たとえば、<em class="replaceable"><code>condition_value</code></em> を <code class="literal">SQLSTATE</code> 値にすることができ、この値は、エラー、警告、または<span class="quote">「<span class="quote">見つからない</span>」</span>を示す場合があります。 詳細は、<a class="xref" href="sql-statements.html#signal" title="13.6.7.5 SIGNAL ステートメント">セクション13.6.7.5「SIGNAL ステートメント」</a>を参照してください。 
        </p><p>
          <code class="literal">RESIGNAL</code> ステートメントは、どちらもオプションである <em class="replaceable"><code>condition_value</code></em> と <code class="literal">SET</code> 句を受け取ります。 このため、次のいくつかの使用法が考えられます。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">RESIGNAL</code> のみ:
            </p><pre class="programlisting">RESIGNAL;
</pre></li><li class="listitem"><p>
              新しいシグナル情報を含む <code class="literal">RESIGNAL</code>:
            </p><pre class="programlisting">RESIGNAL SET <em class="replaceable"><code>signal_information_item</code></em> [, <em class="replaceable"><code>signal_information_item</code></em>] ...;
</pre></li><li class="listitem"><p>
              条件値と場合によっては新しいシグナル情報を含む <code class="literal">RESIGNAL</code>:
            </p><pre class="programlisting">RESIGNAL <em class="replaceable"><code>condition_value</code></em>
    [SET <em class="replaceable"><code>signal_information_item</code></em> [, <em class="replaceable"><code>signal_information_item</code></em>] ...];
</pre></li></ul></div><p>
          これらのユースケースはすべて、診断および条件領域の変更を発生させます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              診断領域には 1 つ以上の条件領域が含まれています。
            </p></li><li class="listitem"><p>
              条件領域には、<code class="literal">SQLSTATE</code> 値、<code class="literal">MYSQL_ERRNO</code>、<code class="literal">MESSAGE_TEXT</code> などの条件情報項目が含まれています。
            </p></li></ul></div><p>
          診断領域のスタックがあります。 ハンドラは制御を取得すると、診断領域をスタックの最上部にプッシュするため、ハンドラの実行中に次の 2 つの診断領域があります: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              最初の (現在の) 診断領域。最後の診断領域のコピーとして開始されますが、ハンドラ内の現在の診断領域を変更する最初のステートメントによって上書きされます。
            </p></li><li class="listitem"><p>
              ハンドラが制御を取得する前に設定された条件領域を持つ最後の (スタックされた) 診断領域。
            </p></li></ul></div><p>
          診断領域内の条件領域の最大数は、<code class="literal">max_error_count</code> システム変数の値によって決定されます。 <a class="xref" href="sql-statements.html#diagnostics-area-system-variables" title="診断領域関連のシステム変数">診断領域関連のシステム変数</a>を参照してください。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="resignal-alone"></a>RESIGNAL のみ</h5></div></div></div><p>
          単純な <code class="literal">RESIGNAL</code> のみとは、<span class="quote">「<span class="quote">エラーを変更せずに渡す</span>」</span>ことを示します。 これは最後の診断領域をリストアし、それを現在の診断領域にします。 つまり、診断領域スタックを<span class="quote">「<span class="quote">ポップします</span>」</span>。 
        </p><p>
          条件をキャッチする条件ハンドラ内での <code class="literal">RESIGNAL</code> のみの 1 つの使用法として、ほかのいくつかのアクションを実行したあと、元の条件情報 (ハンドラに入る前に存在していた情報) を変更せずに渡す方法があります。
        </p><p>
          例:
        </p><pre class="programlisting">DROP TABLE IF EXISTS xx;
delimiter //
CREATE PROCEDURE p ()
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SET @error_count = @error_count + 1;
    IF @a = 0 THEN RESIGNAL; END IF;
  END;
  DROP TABLE xx;
END//
delimiter ;
SET @error_count = 0;
SET @a = 0;
CALL p();
</pre><p>
          <code class="literal">DROP TABLE xx</code> ステートメントが失敗したとします。 診断領域スタックは次のようになります。 
        </p><pre class="programlisting">DA 1. ERROR 1051 (42S02): Unknown table 'xx'
</pre><p>
          次に、実行が <code class="literal">EXIT</code> ハンドラに入ります。 このハンドラは最初に、診断領域をスタックの先頭にプッシュします。これで、診断領域スタックは次のようになります。 
        </p><pre class="programlisting">DA 1. ERROR 1051 (42S02): Unknown table 'xx'
DA 2. ERROR 1051 (42S02): Unknown table 'xx'
</pre><p>
          この時点で、最初の (現在の) 診断領域と 2 番目の (スタックされた) 診断領域の内容は同じです。 最初の診断領域は、そのあとにハンドラ内で実行されるステートメントによって変更される可能性があります。 
        </p><p>
          通常、プロシージャーステートメントは最初の診断領域をクリアします。 <code class="literal">BEGIN</code> は例外です。これはクリアせず、何も行いません。 <code class="literal">SET</code> は例外ではありません。これはクリアし、操作を実行して、<span class="quote">「<span class="quote">成功</span>」</span>の結果を生成します。 これで、診断領域スタックは次のようになります。 
        </p><pre class="programlisting">DA 1. ERROR 0000 (00000): Successful operation
DA 2. ERROR 1051 (42S02): Unknown table 'xx'
</pre><p>
          この時点で、<code class="literal">@a = 0</code> の場合、<code class="literal">RESIGNAL</code> は診断領域スタックをポップします。これで、診断領域スタックは次のようになります。
        </p><pre class="programlisting">DA 1. ERROR 1051 (42S02): Unknown table 'xx'
</pre><p>
          そして、これが呼び出し元に表示される内容です。
        </p><p>
          <code class="literal">@a</code> が 0 でない場合、このハンドラは単純に終了します。つまり、現在の診断領域はそれ以上使用されなくなる (<span class="quote">「<span class="quote">処理済み</span>」</span>になった) ため、破棄することが可能になり、スタックされた診断領域がふたたび現在の診断領域になります。 診断領域スタックは次のようになります。 
        </p><pre class="programlisting">DA 1. ERROR 0000 (00000): Successful operation
</pre><p>
          詳細を調べると複雑に見えますが、最終結果はきわめて有効です。ハンドラは、そのハンドラのアクティブ化を発生させた条件に関する情報を破棄することなく実行できます。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="resignal-with-new-signal"></a>新しいシグナル情報を含む RESIGNAL</h5></div></div></div><p>
          <code class="literal">SET</code> 句を含む <code class="literal">RESIGNAL</code> は新しいシグナル情報を指定するため、このステートメントは、<span class="quote">「<span class="quote">エラーを変更してから渡す</span>」</span>ことを示します。
        </p><pre class="programlisting">RESIGNAL SET <em class="replaceable"><code>signal_information_item</code></em> [, <em class="replaceable"><code>signal_information_item</code></em>] ...;
</pre><p>
          <code class="literal">RESIGNAL</code> のみと同様に、アイデアは、元の情報が出力されるように診断領域スタックをポップすることです。 <code class="literal">RESIGNAL</code> のみとは異なり、<code class="literal">SET</code> 句で指定されたものはすべて変更されます。 
        </p><p>
          例:
        </p><pre class="programlisting">DROP TABLE IF EXISTS xx;
delimiter //
CREATE PROCEDURE p ()
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SET @error_count = @error_count + 1;
    IF @a = 0 THEN RESIGNAL SET MYSQL_ERRNO = 5; END IF;
  END;
  DROP TABLE xx;
END//
delimiter ;
SET @error_count = 0;
SET @a = 0;
CALL p();
</pre><p>
          前の説明から、<code class="literal">RESIGNAL</code> のみによって、診断領域スタックが次のようになることを思い出してください。
        </p><pre class="programlisting">DA 1. ERROR 1051 (42S02): Unknown table 'xx'
</pre><p>
          <code class="literal">RESIGNAL SET MYSQL_ERRNO = 5</code> ステートメントでは、代わりに、スタックが次のようになります。これが呼び出し元に表示される内容です。
        </p><pre class="programlisting">DA 1. ERROR 5 (42S02): Unknown table 'xx'
</pre><p>
          つまり、エラー番号だけが変更され、ほかは何も変更されません。
        </p><p>
          <code class="literal">RESIGNAL</code> ステートメントはシグナル情報項目のいずれかまたはすべてを変更できるため、診断領域の最初の条件領域がまったく異なっているように見えます。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="resignal-with-condition"></a>条件値とオプションの新しいシグナル情報を含む RESIGNAL</h5></div></div></div><p>
          条件値を含む <code class="literal">RESIGNAL</code> は、<span class="quote">「<span class="quote">条件を現在の診断領域にプッシュする</span>」</span>ことを示します。 <code class="literal">SET</code> 句が存在する場合は、エラー情報も変更されます。 
        </p><pre class="programlisting">RESIGNAL <em class="replaceable"><code>condition_value</code></em>
    [SET <em class="replaceable"><code>signal_information_item</code></em> [, <em class="replaceable"><code>signal_information_item</code></em>] ...];
</pre><p>
          この形式の <code class="literal">RESIGNAL</code> は最後の診断領域をリストアし、それを現在の診断領域にします。 つまり、診断領域スタックを<span class="quote">「<span class="quote">ポップします</span>」</span>。これは、単純な <code class="literal">RESIGNAL</code> のみが行う動作と同じです。 ただし、条件値またはシグナル情報に応じて、診断領域も変更されます。 
        </p><p>
          例:
        </p><pre class="programlisting">DROP TABLE IF EXISTS xx;
delimiter //
CREATE PROCEDURE p ()
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SET @error_count = @error_count + 1;
    IF @a = 0 THEN RESIGNAL SQLSTATE '45000' SET MYSQL_ERRNO=5; END IF;
  END;
  DROP TABLE xx;
END//
delimiter ;
SET @error_count = 0;
SET @a = 0;
SET @@max_error_count = 2;
CALL p();
SHOW ERRORS;
</pre><p>
          これは前の例に似ていて、その効果も同じですが、<code class="literal">RESIGNAL</code> が発生した場合は、現在の条件領域が最後には異なっているように見える点が異なります。 (この条件が既存の条件を置き換えるのではなく、それに追加される理由は、条件値が使用されているためです。)  
        </p><p>
          この <code class="literal">RESIGNAL</code> ステートメントには条件値 (<code class="literal">SQLSTATE '45000'</code>) が含まれているため、新しい条件領域が追加され、診断領域スタックは次のようになります。
        </p><pre class="programlisting">DA 1. (condition 2) ERROR 1051 (42S02): Unknown table 'xx'
      (condition 1) ERROR 5 (45000) Unknown table 'xx'
</pre><p>
          この例での <code class="literal">CALL p()</code> と <code class="literal">SHOW ERRORS</code> の結果は次のとおりです。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CALL p();</code></strong>
ERROR 5 (45000): Unknown table 'xx'
mysql&gt; <strong class="userinput"><code>SHOW ERRORS;</code></strong>
+-------+------+----------------------------------+
| Level | Code | Message                          |
+-------+------+----------------------------------+
| Error | 1051 | Unknown table 'xx'               |
| Error |    5 | Unknown table 'xx'               |
+-------+------+----------------------------------+
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="resignal-handler"></a>RESIGNAL には条件ハンドラのコンテキストが必要</h5></div></div></div><p>
          <code class="literal">RESIGNAL</code> のすべての形式で、現在のコンテキストが条件ハンドラである必要があります。 そうでない場合、<code class="literal">RESIGNAL</code> は不正であり、<code class="literal">RESIGNAL when handler not active</code> エラーが発生します。 例: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE PROCEDURE p () RESIGNAL;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>CALL p();</code></strong>
ERROR 1645 (0K000): RESIGNAL when handler not active
</pre><p>
          さらに難しい例を次に示します。
        </p><pre class="programlisting">delimiter //
CREATE FUNCTION f () RETURNS INT
BEGIN
  RESIGNAL;
  RETURN 5;
END//
CREATE PROCEDURE p ()
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @a=f();
  SIGNAL SQLSTATE '55555';
END//
delimiter ;
CALL p();
</pre><p>
          <code class="literal">RESIGNAL</code> がストアドファンクション <code class="literal">f()</code> 内に現れています。 <code class="literal">f()</code> 自体は <code class="literal">EXIT</code> ハンドラのコンテキスト内で呼び出されますが、<code class="literal">f()</code> 内での実行は独自のコンテキストを持ち、それはハンドラのコンテキストではありません。 そのため、<code class="literal">f()</code> 内での <code class="literal">RESIGNAL</code> によって、<span class="quote">「<span class="quote">handler not active</span>」</span> エラーが発生します。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="signal"></a>13.6.7.5 SIGNAL ステートメント</h4></div></div></div><a class="indexterm" name="idm45826992753440"></a><pre class="programlisting">SIGNAL <em class="replaceable"><code>condition_value</code></em>
    [SET <em class="replaceable"><code>signal_information_item</code></em>
    [, <em class="replaceable"><code>signal_information_item</code></em>] ...]

<em class="replaceable"><code>condition_value</code></em>: {
    SQLSTATE [VALUE] <em class="replaceable"><code>sqlstate_value</code></em>
  | <em class="replaceable"><code>condition_name</code></em>
}

<em class="replaceable"><code>signal_information_item</code></em>:
    <em class="replaceable"><code>condition_information_item_name</code></em> = <em class="replaceable"><code>simple_value_specification</code></em>

<em class="replaceable"><code>condition_information_item_name</code></em>: {
    CLASS_ORIGIN
  | SUBCLASS_ORIGIN
  | MESSAGE_TEXT
  | MYSQL_ERRNO
  | CONSTRAINT_CATALOG
  | CONSTRAINT_SCHEMA
  | CONSTRAINT_NAME
  | CATALOG_NAME
  | SCHEMA_NAME
  | TABLE_NAME
  | COLUMN_NAME
  | CURSOR_NAME
}

<em class="replaceable"><code>condition_name</code></em>, <em class="replaceable"><code>simple_value_specification</code></em>:
    (see following discussion)
</pre><p>
        <code class="literal">SIGNAL</code> は、エラー<span class="quote">「<span class="quote">を返す</span>」</span>ための方法です。 <code class="literal">SIGNAL</code> は、ハンドラ、アプリケーションの外側の部分、またはクライアントにエラー情報を提供します。 また、エラーの特性 (エラー番号、<code class="literal">SQLSTATE</code> 値、メッセージ) に対する制御も提供します。 <code class="literal">SIGNAL</code> を使用しない場合は、存在しないテーブルを意図的に参照してルーチンがエラーを返すようにする、などの回避方法に頼る必要があります。 
      </p><p>
        <code class="literal">SIGNAL</code> ステートメントの実行に必要な権限はありません。
      </p><p>
        診断領域から情報を取得するには、<code class="literal">GET DIAGNOSTICS</code> ステートメントを使用します (<a class="xref" href="sql-statements.html#get-diagnostics" title="13.6.7.3 GET DIAGNOSTICS ステートメント">セクション13.6.7.3「GET DIAGNOSTICS ステートメント」</a>を参照してください)。 診断領域については、<a class="xref" href="sql-statements.html#diagnostics-area" title="13.6.7.7 MySQL の診断領域">セクション13.6.7.7「MySQL の診断領域」</a>を参照してください。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#signal-overview" title="SIGNAL の概要">SIGNAL の概要</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#signal-condition-information-items" title="シグナルの条件情報項目">シグナルの条件情報項目</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#signal-effects" title="ハンドラ、カーソル、およびステートメントに対するシグナルの影響">ハンドラ、カーソル、およびステートメントに対するシグナルの影響</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="signal-overview"></a>SIGNAL の概要</h5></div></div></div><p>
          <code class="literal">SIGNAL</code> ステートメント内の <em class="replaceable"><code>condition_value</code></em> は、返されるエラー値を示します。 これは、<code class="literal">SQLSTATE</code> 値 (5 文字の文字列リテラル) か、または以前に <code class="literal">DECLARE ... CONDITION</code> で定義された名前付き条件を参照する <em class="replaceable"><code>condition_name</code></em> にすることができます (<a class="xref" href="sql-statements.html#declare-condition" title="13.6.7.1 DECLARE ... CONDITION ステートメント">セクション13.6.7.1「DECLARE ... CONDITION ステートメント」</a>を参照してください)。 
        </p><p>
          <code class="literal">SQLSTATE</code> 値は、エラー、警告、または<span class="quote">「<span class="quote">見つからない</span>」</span>を示す場合があります。 <a class="xref" href="sql-statements.html#signal-condition-information-items" title="シグナルの条件情報項目">シグナルの条件情報項目</a>で説明されているように、この値の最初の 2 文字はそのエラークラスを示します。 一部のシグナル値はステートメントを終了させます。<a class="xref" href="sql-statements.html#signal-effects" title="ハンドラ、カーソル、およびステートメントに対するシグナルの影響">ハンドラ、カーソル、およびステートメントに対するシグナルの影響</a>を参照してください。 
        </p><p>
          <code class="literal">'00'</code> は成功を示し、エラーの通知には有効でないため、<code class="literal">SIGNAL</code> ステートメントの <code class="literal">SQLSTATE</code> 値をこのような値で始めるべきではありません。 これは、<code class="literal">SQLSTATE</code> 値が <code class="literal">SIGNAL</code> ステートメントで直接、またはこのステートメントで参照されている名前付き条件のどちらで指定されている場合にも当てはまります。 この値が無効である場合は、<code class="literal">Bad SQLSTATE</code> エラーが発生します。 
        </p><p>
          一般的な <code class="literal">SQLSTATE</code> 値を通知するには、<code class="literal">'45000'</code> を使用します。これは、<span class="quote">「<span class="quote">未処理のユーザー定義の例外</span>」</span>を示します。
        </p><p>
          <code class="literal">SIGNAL</code> ステートメントには、オプションで、複数のシグナル項目を含む <code class="literal">SET</code> 句が <em class="replaceable"><code>condition_information_item_name</code></em> = <em class="replaceable"><code>simple_value_specification</code></em> 割当てのリストにカンマで区切られて含まれます。
        </p><p>
          各 <em class="replaceable"><code>condition_information_item_name</code></em> は、<code class="literal">SET</code> 句内で 1 回だけ指定できます。 そうでない場合は、<code class="literal">Duplicate condition information item</code> エラーが発生します。 
        </p><p>
          有効な <em class="replaceable"><code>simple_value_specification</code></em> 指示子は、ストアドプロシージャーやストアドファンクションのパラメータ、<code class="literal">DECLARE</code> で宣言されたストアドプログラムのローカル変数、ユーザー定義変数、システム変数、またはリテラルを使用して指定できます。 文字リテラルには、<em class="replaceable"><code>_charset</code></em> イントロデューサを含めることができます。 
        </p><p>
          許可される <em class="replaceable"><code>condition_information_item_name</code></em> 値については、<a class="xref" href="sql-statements.html#signal-condition-information-items" title="シグナルの条件情報項目">シグナルの条件情報項目</a>を参照してください。
        </p><p>
          次のプロシージャーは、その入力パラメータである <code class="literal">pval</code> の値に応じて、エラーまたは警告を通知します。
        </p><pre class="programlisting">CREATE PROCEDURE p (pval INT)
BEGIN
  DECLARE specialty CONDITION FOR SQLSTATE '45000';
  IF pval = 0 THEN
    SIGNAL SQLSTATE '01000';
  ELSEIF pval = 1 THEN
    SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = 'An error occurred';
  ELSEIF pval = 2 THEN
    SIGNAL specialty
      SET MESSAGE_TEXT = 'An error occurred';
  ELSE
    SIGNAL SQLSTATE '01000'
      SET MESSAGE_TEXT = 'A warning occurred', MYSQL_ERRNO = 1000;
    SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = 'An error occurred', MYSQL_ERRNO = 1001;
  END IF;
END;
</pre><p>
          <code class="literal">pval</code> が 0 である場合、<code class="literal">'01'</code> で始まる <code class="literal">SQLSTATE</code> 値は警告クラス内のシグナルであるため、<code class="literal">p()</code> は警告を通知します。 この警告はプロシージャーを終了させず、そのプロシージャーから戻ったあとに <code class="literal">SHOW WARNINGS</code> で確認できます。 
        </p><p>
          <code class="literal">pval</code> が 1 である場合、<code class="literal">p()</code> はエラーを通知し、<code class="literal">MESSAGE_TEXT</code> 条件情報項目を設定します。 このエラーはプロシージャーを終了させ、そのテキストがエラー情報とともに返されます。 
        </p><p>
          <code class="literal">pval</code> が 2 である場合、この場合は名前付き条件を使用して <code class="literal">SQLSTATE</code> 値が指定されているにもかかわらず、同じエラーが通知されます。
        </p><p>
          <code class="literal">pval</code> がその他の任意の値である場合、<code class="literal">p()</code> は最初に警告を通知し、メッセージテキストとエラー番号の条件情報項目を設定します。 この警告はプロシージャーを終了させないため、実行が続行され、そのあと <code class="literal">p()</code> はエラーを通知します。 このエラーはプロシージャーを終了させます。 警告によって設定されたメッセージテキストとエラー番号は、エラーによって設定された値によって置き換えられ、それがエラー情報とともに返されます。 
        </p><p>
          <code class="literal">SIGNAL</code> は通常、ストアドプログラム内で使用されますが、これはハンドラのコンテキストの外部で許可される MySQL 拡張です。 たとえば、<span class="command"><strong>mysql</strong></span> クライアントプログラムを呼び出す場合は、プロンプトで次のステートメントのいずれかを入力できます。 
        </p><pre class="programlisting">SIGNAL SQLSTATE '77777';

CREATE TRIGGER t_bi BEFORE INSERT ON t
  FOR EACH ROW SIGNAL SQLSTATE '77777';

CREATE EVENT e ON SCHEDULE EVERY 1 SECOND
  DO SIGNAL SQLSTATE '77777';
</pre><p>
          <code class="literal">SIGNAL</code> は、次のルールに従って実行されます。
        </p><p>
          <code class="literal">SIGNAL</code> ステートメントが特定の <code class="literal">SQLSTATE</code> 値を示している場合、その値は、指定された条件を通知するために使用されます。 例: 
        </p><pre class="programlisting">CREATE PROCEDURE p (divisor INT)
BEGIN
  IF divisor = 0 THEN
    SIGNAL SQLSTATE '22012';
  END IF;
END;
</pre><p>
          <code class="literal">SIGNAL</code> ステートメントが名前付き条件を使用している場合、その条件は <code class="literal">SIGNAL</code> ステートメントに適用される何らかのスコープ内で宣言される必要があり、また MySQL エラー番号ではなく <code class="literal">SQLSTATE</code> 値を使用して定義される必要があります。 例: 
        </p><pre class="programlisting">CREATE PROCEDURE p (divisor INT)
BEGIN
  DECLARE divide_by_zero CONDITION FOR SQLSTATE '22012';
  IF divisor = 0 THEN
    SIGNAL divide_by_zero;
  END IF;
END;
</pre><p>
          その名前付き条件が <code class="literal">SIGNAL</code> ステートメントのスコープ内に存在しない場合は、<code class="literal">Undefined CONDITION</code> エラーが発生します。
        </p><p>
          <code class="literal">SIGNAL</code> が、<code class="literal">SQLSTATE</code> 値ではなく MySQL エラー番号で定義された名前付き条件を参照している場合は、<code class="literal">SIGNAL/RESIGNAL can only use a CONDITION defined with SQLSTATE</code> エラーが発生します。 次のステートメントを発行すると、名前付き条件が MySQL エラー番号に関連付けられているため、そのエラーが発生します。 
        </p><pre class="programlisting">DECLARE no_such_table CONDITION FOR 1051;
SIGNAL no_such_table;
</pre><p>
          特定の名前を持つ条件が異なるスコープで複数回宣言されている場合は、もっともローカルなスコープを持つ宣言が適用されます。 次のプロシージャーを考えてみます。 
        </p><pre class="programlisting">CREATE PROCEDURE p (divisor INT)
BEGIN
  DECLARE my_error CONDITION FOR SQLSTATE '45000';
  IF divisor = 0 THEN
    BEGIN
      DECLARE my_error CONDITION FOR SQLSTATE '22012';
      SIGNAL my_error;
    END;
  END IF;
  SIGNAL my_error;
END;
</pre><p>
          <code class="literal">divisor</code> が 0 である場合は、最初の <code class="literal">SIGNAL</code> ステートメントが実行されます。 もっとも内側の <code class="literal">my_error</code> 条件宣言が適用され、<code class="literal">SQLSTATE</code> <code class="literal">'22012'</code> が発生します。 
        </p><p>
          <code class="literal">divisor</code> が 0 でない場合は、2 番目の <code class="literal">SIGNAL</code> ステートメントが実行されます。 もっとも外側の <code class="literal">my_error</code> 条件宣言が適用され、<code class="literal">SQLSTATE</code> <code class="literal">'45000'</code> が発生します。 
        </p><p>
          条件が発生したときにサーバーがハンドラを選択する方法については、<a class="xref" href="sql-statements.html#handler-scope" title="13.6.7.6 ハンドラのスコープに関するルール">セクション13.6.7.6「ハンドラのスコープに関するルール」</a>を参照してください。
        </p><p>
          シグナルが例外ハンドラ内で発生する場合があります。
        </p><pre class="programlisting">CREATE PROCEDURE p ()
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SIGNAL SQLSTATE VALUE '99999'
      SET MESSAGE_TEXT = 'An error occurred';
  END;
  DROP TABLE no_such_table;
END;
</pre><p>
          <code class="literal">CALL p()</code> が <code class="literal">DROP TABLE</code> ステートメントに達します。 <code class="literal">no_such_table</code> という名前のテーブルが存在しないため、エラーハンドラがアクティブ化されます。 エラーハンドラは元のエラー (<span class="quote">「<span class="quote">このようなテーブルがない</span>」</span>) を破棄し、<code class="literal">SQLSTATE</code> <code class="literal">'99999'</code> の新しいエラーとメッセージ <code class="literal">An error occurred</code> を作成します。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="signal-condition-information-items"></a>シグナルの条件情報項目</h5></div></div></div><p>
          次の表は、<code class="literal">SIGNAL</code> (または <code class="literal">RESIGNAL</code>) ステートメントで設定できる診断領域条件情報項目の名前を一覧表示しています。 MySQL 拡張である <code class="literal">MYSQL_ERRNO</code> を除き、すべての項目が標準 SQL です。 これらの項目の詳細は、<a class="xref" href="sql-statements.html#diagnostics-area" title="13.6.7.7 MySQL の診断領域">セクション13.6.7.7「MySQL の診断領域」</a>を参照してください。 
        </p><pre class="programlisting">Item Name             Definition
---------             ----------
CLASS_ORIGIN          VARCHAR(64)
SUBCLASS_ORIGIN       VARCHAR(64)
CONSTRAINT_CATALOG    VARCHAR(64)
CONSTRAINT_SCHEMA     VARCHAR(64)
CONSTRAINT_NAME       VARCHAR(64)
CATALOG_NAME          VARCHAR(64)
SCHEMA_NAME           VARCHAR(64)
TABLE_NAME            VARCHAR(64)
COLUMN_NAME           VARCHAR(64)
CURSOR_NAME           VARCHAR(64)
MESSAGE_TEXT          VARCHAR(128)
MYSQL_ERRNO           SMALLINT UNSIGNED
</pre><p>
          文字項目の文字セットは UTF-8 です。
        </p><p>
          <code class="literal">SIGNAL</code> ステートメント内で条件情報項目に <code class="literal">NULL</code> を割り当てることはできません。
        </p><p>
          <code class="literal">SIGNAL</code> ステートメントは直接にか、または <code class="literal">SQLSTATE</code> 値で定義された名前付き条件を参照することによって間接的にかにかかわらず、常に <code class="literal">SQLSTATE</code> 値を指定します。 <code class="literal">SQLSTATE</code> 値の最初の 2 文字はそのクラスであり、このクラスによって、その条件情報項目のデフォルト値が決定されます。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              クラス = <code class="literal">'00'</code> (成功)
            </p><p>
              不正です。 <code class="literal">'00'</code> で始まる <code class="literal">SQLSTATE</code> 値は成功を示すため、<code class="literal">SIGNAL</code> には有効でありません。 
            </p></li><li class="listitem"><p>
              クラス = <code class="literal">'01'</code> (警告)
            </p><pre class="programlisting">MESSAGE_TEXT = 'Unhandled user-defined warning condition';
MYSQL_ERRNO = <code class="literal">ER_SIGNAL_WARN</code>
</pre></li><li class="listitem"><p>
              クラス = <code class="literal">'02'</code> (見つからない)
            </p><pre class="programlisting">MESSAGE_TEXT = 'Unhandled user-defined not found condition';
MYSQL_ERRNO = <code class="literal">ER_SIGNAL_NOT_FOUND</code>
</pre></li><li class="listitem"><p>
              クラス &gt; <code class="literal">'02'</code> (例外)
            </p><pre class="programlisting">MESSAGE_TEXT = 'Unhandled user-defined exception condition';
MYSQL_ERRNO = <code class="literal">ER_SIGNAL_EXCEPTION</code>
</pre></li></ul></div><p>
          正当なクラスの場合は、その他の条件情報項目が次のように設定されます。
        </p><pre class="programlisting">CLASS_ORIGIN = SUBCLASS_ORIGIN = '';
CONSTRAINT_CATALOG = CONSTRAINT_SCHEMA = CONSTRAINT_NAME = '';
CATALOG_NAME = SCHEMA_NAME = TABLE_NAME = COLUMN_NAME = '';
CURSOR_NAME = '';
</pre><p>
          <code class="literal">SIGNAL</code> が実行されたあとにアクセスできるエラー値は、<code class="literal">SIGNAL</code> ステートメントによって発生した <code class="literal">SQLSTATE</code> 値と、<code class="literal">MESSAGE_TEXT</code> および <code class="literal">MYSQL_ERRNO</code> 項目です。 これらの値は、次の C API から取得できます。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">mysql_sqlstate()</code> は、<code class="literal">SQLSTATE</code> 値を返します。
            </p></li><li class="listitem"><p>
              <code class="literal">mysql_errno()</code> は、<code class="literal">MYSQL_ERRNO</code> 値を返します。
            </p></li><li class="listitem"><p>
              <code class="literal">mysql_error()</code> は、<code class="literal">MESSAGE_TEXT</code> 値を返します。
            </p></li></ul></div><p>
          SQL レベルでは、<code class="literal">SHOW WARNINGS</code> および <code class="literal">SHOW ERRORS</code> からの出力に、<code class="literal">Code</code> および <code class="literal">Message</code> カラムの <code class="literal">MYSQL_ERRNO</code> および <code class="literal">MESSAGE_TEXT</code> の値が示されます。
        </p><p>
          診断領域から情報を取得するには、<code class="literal">GET DIAGNOSTICS</code> ステートメントを使用します (<a class="xref" href="sql-statements.html#get-diagnostics" title="13.6.7.3 GET DIAGNOSTICS ステートメント">セクション13.6.7.3「GET DIAGNOSTICS ステートメント」</a>を参照してください)。 診断領域については、<a class="xref" href="sql-statements.html#diagnostics-area" title="13.6.7.7 MySQL の診断領域">セクション13.6.7.7「MySQL の診断領域」</a>を参照してください。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="signal-effects"></a>ハンドラ、カーソル、およびステートメントに対するシグナルの影響</h5></div></div></div><p>
          ステートメントの実行に対するシグナルの影響は、そのシグナルのクラスによって異なります。 このクラスによって、エラーの重大性が決定されます。 MySQL は、<code class="literal">sql_mode</code> システム変数の値を無視します。特に、厳密な SQL モードは問題になりません。 MySQL は <code class="literal">IGNORE</code> も無視します。<code class="literal">SIGNAL</code> の目的はユーザーが生成したエラーを明示的に発生させることであるため、シグナルが無視されることはありません。 
        </p><p>
          次の説明で、<span class="quote">「<span class="quote">未処理</span>」</span>は、通知された <code class="literal">SQLSTATE</code> 値に対するハンドラが <code class="literal">DECLARE ... HANDLER</code> で定義されていないことを示します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              クラス = <code class="literal">'00'</code> (成功)
            </p><p>
              不正です。 <code class="literal">'00'</code> で始まる <code class="literal">SQLSTATE</code> 値は成功を示すため、<code class="literal">SIGNAL</code> には有効でありません。 
            </p></li><li class="listitem"><p>
              クラス = <code class="literal">'01'</code> (警告)
            </p><p>
              <code class="literal">warning_count</code> システム変数の値が増やされます。 <code class="literal">SHOW WARNINGS</code> がシグナルを示します。 <code class="literal">SQLWARNING</code> ハンドラがシグナルをキャッチします。 
            </p><p>
              ストアドファンクションから警告を返すことはできません。関数を戻す <code class="literal">RETURN</code> ステートメントによって診断領域がクリアされるためです。 したがって、このステートメントはそこに存在する可能性のある警告をすべてクリアします (さらに、<code class="literal">warning_count</code> を 0 にリセットします)。 
            </p></li><li class="listitem"><p>
              クラス = <code class="literal">'02'</code> (見つからない)
            </p><p>
              <code class="literal">NOT FOUND</code> ハンドラがシグナルをキャッチします。 カーソルには影響しません。 ストアドファンクションでシグナルが処理されない場合、ステートメントは終了します。 
            </p></li><li class="listitem"><p>
              クラス &gt; <code class="literal">'02'</code> (例外)
            </p><p>
              <code class="literal">SQLEXCEPTION</code> ハンドラがシグナルをキャッチします。 ストアドファンクションでシグナルが処理されない場合、ステートメントは終了します。 
            </p></li><li class="listitem"><p>
              クラス = <code class="literal">'40'</code>
            </p><p>
              通常の例外として処理されます。
            </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="handler-scope"></a>13.6.7.6 ハンドラのスコープに関するルール</h4></div></div></div><p>
        ストアドプログラムには、そのプログラム内で特定の条件が発生したときに呼び出されるハンドラを含めることができます。 各ハンドラの適用性は、プログラム定義の中でのそのハンドラの場所や、そのハンドラが処理する 1 つまたは複数の条件によって異なります。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">BEGIN ... END</code> ブロック内で宣言されたハンドラは、そのブロック内でハンドラ宣言のあとにある SQL ステートメントのスコープ内にしかありません。 そのハンドラ自体が条件を発生させた場合は、そのハンドラも、そのブロック内で宣言されているほかのどのハンドラもその条件を処理できません。 次の例では、ハンドラ <code class="literal">H1</code> と <code class="literal">H2</code> は、ステートメント <em class="replaceable"><code>stmt1</code></em> および <em class="replaceable"><code>stmt2</code></em> によって発生した条件のスコープ内にあります。 ただし、<code class="literal">H1</code> も <code class="literal">H2</code> も、<code class="literal">H1</code> または <code class="literal">H2</code> の本体で発生した条件のスコープ内にはありません。 
          </p><pre class="programlisting">BEGIN -- outer block
  DECLARE EXIT HANDLER FOR ...;  -- handler H1
  DECLARE EXIT HANDLER FOR ...;  -- handler H2
  <em class="replaceable"><code>stmt1</code></em>;
  <em class="replaceable"><code>stmt2</code></em>;
END;
</pre></li><li class="listitem"><p>
            ハンドラは、それが宣言されているブロックのスコープ内にしかなく、そのブロックの外部で発生した条件に対してアクティブ化することはできません。 次の例では、ハンドラ <code class="literal">H1</code> は内側のブロックにある <em class="replaceable"><code>stmt1</code></em> のスコープ内にありますが、外側のブロックにある <em class="replaceable"><code>stmt2</code></em> のスコープ内にはありません。 
          </p><pre class="programlisting">BEGIN -- outer block
  BEGIN -- inner block
    DECLARE EXIT HANDLER FOR ...;  -- handler H1
    <em class="replaceable"><code>stmt1</code></em>;
  END;
  <em class="replaceable"><code>stmt2</code></em>;
END;
</pre></li><li class="listitem"><p>
            ハンドラは、特定のハンドラまたは一般的なハンドラのどちらかです。 特定のハンドラとは、MySQL エラーコード、<code class="literal">SQLSTATE</code> 値、または条件名を処理するためのものです。 一般的なハンドラとは、<code class="literal">SQLWARNING</code>、<code class="literal">SQLEXCEPTION</code>、または <code class="literal">NOT FOUND</code> クラス内の条件を処理するためのものです。 あとで説明されているように、条件の特定性は条件の優先順位に関連しています。 
          </p></li></ul></div><p>
        複数のハンドラを異なるスコープ内で、かつ異なる特定性で宣言できます。 たとえば、外側のブロックには特定の MySQL エラーコードハンドラが、また内側のブロックには一般的な <code class="literal">SQLWARNING</code> ハンドラが存在する可能性があります。 あるいは、特定の MySQL エラーコードのハンドラと、一般的な <code class="literal">SQLWARNING</code> クラスのハンドラが同じブロック内に存在することもあります。 
      </p><p>
        あるハンドラがアクティブ化されるかどうかは、それ自体のスコープや条件値だけでなく、ほかにどのようなハンドラが存在するかによっても異なります。 ストアドプログラム内で条件が発生すると、サーバーは、適用可能なハンドラを現在のスコープ (現在の <code class="literal">BEGIN ... END</code> ブロック) 内で検索します。 適用可能なハンドラが存在しない場合は、連続した包含する各スコープ (ブロック) 内のハンドラに関して外側に検索を続行します。 特定のスコープで適用可能なハンドラを 1 つ以上見つけると、サーバーは、次の条件の優先順位に基づいてそれらのハンドラから選択します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL エラーコードハンドラは、<code class="literal">SQLSTATE</code> 値ハンドラより優先されます。
          </p></li><li class="listitem"><p>
            <code class="literal">SQLSTATE</code> 値ハンドラは、一般的な <code class="literal">SQLWARNING</code>、<code class="literal">SQLEXCEPTION</code>、または <code class="literal">NOT FOUND</code> ハンドラより優先されます。
          </p></li><li class="listitem"><p>
            <code class="literal">SQLEXCEPTION</code> ハンドラは、<code class="literal">SQLWARNING</code> ハンドラより優先されます。
          </p></li><li class="listitem"><p>
            同じ優先順位を持つ適用可能なハンドラが複数存在する可能性があります。 たとえば、ステートメントが、それぞれに対してエラー固有のハンドラが存在する、異なるエラーコードを持つ複数の警告を生成する可能性があります。 この場合、サーバーがアクティブ化するハンドラの選択は非決定的であり、条件が発生する状況に応じて変わる可能性があります。 
          </p></li></ul></div><p>
        ハンドラ選択ルールの 1 つの側面として、複数の適用可能なハンドラが異なるスコープ内に存在する場合は、もっともローカルなスコープを持つハンドラが外側のスコープにあるハンドラより (それが、より具体的な条件のハンドラであっても) 優先される点があります。
      </p><p>
        ある条件が発生したときに適切なハンドラが存在しない場合、実行されるアクションはその条件のクラスによって異なります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">SQLEXCEPTION</code> 条件の場合は、<code class="literal">EXIT</code> ハンドラが存在するかのように、ストアドプログラムはその条件を発生させたステートメントで終了します。 そのプログラムが別のストアドプログラムから呼び出されていた場合は、呼び出し元プログラムが、独自のハンドラに適用されるハンドラ選択ルールを使用してその条件を処理します。 
          </p></li><li class="listitem"><p>
            <code class="literal">SQLWARNING</code> 条件の場合は、<code class="literal">CONTINUE</code> ハンドラが存在するかのように、プログラムは実行を続行します。
          </p></li><li class="listitem"><p>
            <code class="literal">NOT FOUND</code> 条件では、その条件が正常に発生した場合、アクションは <code class="literal">CONTINUE</code> です。 <code class="literal">SIGNAL</code> または <code class="literal">RESIGNAL</code> によって発生した場合、アクションは <code class="literal">EXIT</code> です。 
          </p></li></ul></div><p>
        次の例は、MySQL によってハンドラ選択ルールがどのように適用されるかを示しています。
      </p><p>
        次のプロシージャーには 2 つのハンドラが含まれています。つまり、存在しないテーブルを削除しようとする試みに対して発生する特定の <code class="literal">SQLSTATE</code> 値 (<code class="literal">'42S02'</code>) 用に 1 つと、一般的な <code class="literal">SQLEXCEPTION</code> クラス用に 1 つです。
      </p><pre class="programlisting">CREATE PROCEDURE p1()
BEGIN
  DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02'
    SELECT 'SQLSTATE handler was activated' AS msg;
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    SELECT 'SQLEXCEPTION handler was activated' AS msg;

  DROP TABLE test.t;
END;
</pre><p>
        両方のハンドラが同じブロック内で宣言され、同じスコープを持っています。 ただし、<code class="literal">SQLSTATE</code> ハンドラは <code class="literal">SQLEXCEPTION</code> ハンドラより優先されるため、テーブル <code class="literal">t</code> が存在しない場合、<code class="literal">DROP TABLE</code> ステートメントは <code class="literal">SQLSTATE</code> ハンドラをアクティブ化する条件を発生させます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CALL p1();</code></strong>
+--------------------------------+
| msg                            |
+--------------------------------+
| SQLSTATE handler was activated |
+--------------------------------+
</pre><p>
        次のプロシージャーにも、同じ 2 つのハンドラが含まれています。 ただし、今回は、<code class="literal">DROP TABLE</code> ステートメントと <code class="literal">SQLEXCEPTION</code> ハンドラが <code class="literal">SQLSTATE</code> ハンドラに対して内側のブロック内にあります。 
      </p><pre class="programlisting">CREATE PROCEDURE p2()
BEGIN -- outer block
    DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02'
      SELECT 'SQLSTATE handler was activated' AS msg;
  BEGIN -- inner block
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
      SELECT 'SQLEXCEPTION handler was activated' AS msg;

    DROP TABLE test.t; -- occurs within inner block
  END;
END;
</pre><p>
        この場合は、条件が発生した場所に対してよりローカルなハンドラが優先されます。 <code class="literal">SQLSTATE</code> ハンドラより一般的であるにもかかわらず、<code class="literal">SQLEXCEPTION</code> ハンドラがアクティブ化されます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CALL p2();</code></strong>
+------------------------------------+
| msg                                |
+------------------------------------+
| SQLEXCEPTION handler was activated |
+------------------------------------+
</pre><p>
        次のプロシージャーでは、ハンドラの 1 つが、<code class="literal">DROP TABLE</code> ステートメントのスコープに対して内側のブロック内で宣言されています。
      </p><pre class="programlisting">CREATE PROCEDURE p3()
BEGIN -- outer block
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    SELECT 'SQLEXCEPTION handler was activated' AS msg;
  BEGIN -- inner block
    DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02'
      SELECT 'SQLSTATE handler was activated' AS msg;
  END;

  DROP TABLE test.t; -- occurs within outer block
END;
</pre><p>
        もう一方のハンドラが <code class="literal">DROP TABLE</code> によって発生した条件のスコープ内にないため、<code class="literal">SQLEXCEPTION</code> ハンドラのみが適用されます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CALL p3();</code></strong>
+------------------------------------+
| msg                                |
+------------------------------------+
| SQLEXCEPTION handler was activated |
+------------------------------------+
</pre><p>
        次のプロシージャーでは、両方のハンドラが、<code class="literal">DROP TABLE</code> ステートメントのスコープに対して内側のブロック内で宣言されています。
      </p><pre class="programlisting">CREATE PROCEDURE p4()
BEGIN -- outer block
  BEGIN -- inner block
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
      SELECT 'SQLEXCEPTION handler was activated' AS msg;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02'
      SELECT 'SQLSTATE handler was activated' AS msg;
  END;

  DROP TABLE test.t; -- occurs within outer block
END;
</pre><p>
        <code class="literal">DROP TABLE</code> のスコープ内にないため、どちらのハンドラも適用されません。 このステートメントによって発生した条件は未処理になり、プロシージャーをエラーで終了させます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CALL p4();</code></strong>
ERROR 1051 (42S02): Unknown table 'test.t'
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="diagnostics-area"></a>13.6.7.7 MySQL の診断領域</h4></div></div></div><p>
        SQL ステートメントは、診断領域を移入する診断情報を生成します。 標準 SQL には、ネスト化された実行のコンテキストごとの診断領域を含んだ、診断領域スタックがあります。 標準 SQL はまた、条件ハンドラの実行中に 2 番目の診断領域を参照するための <code class="literal">GET STACKED DIAGNOSTICS</code> 構文もサポートしています。 
      </p><p>
        次の説明では、MySQL の診断領域の構造、MySQL で認識される情報項目、ステートメントが診断領域をクリアおよび設定する方法、およびスタックに対して診断領域をプッシュおよびポップする方法について説明します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#diagnostics-area-structure" title="診断領域の構造">診断領域の構造</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#diagnostics-area-information-items" title="診断領域の情報項目">診断領域の情報項目</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#diagnostics-area-populating" title="診断領域のクリアおよび移入方法">診断領域のクリアおよび移入方法</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#diagnostics-area-stack" title="診断領域スタックの動作">診断領域スタックの動作</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#diagnostics-area-system-variables" title="診断領域関連のシステム変数">診断領域関連のシステム変数</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="diagnostics-area-structure"></a>診断領域の構造</h5></div></div></div><p>
          診断領域には、次の 2 種類の情報が含まれています。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              発生した条件の数や、影響を受けた行数などのステートメント情報。
            </p></li><li class="listitem"><p>
              エラーコードやメッセージなどの条件情報。 ステートメントが複数の条件を発生させた場合、診断領域のこの部分には条件ごとの条件領域が含まれています。 ステートメントがどの条件も発生させない場合、診断領域のこの部分は空です。 
            </p></li></ul></div><p>
          3 つの条件を生成するステートメントの場合、診断領域には、次のようなステートメント情報と条件情報が含まれています。
        </p><pre class="programlisting">Statement information:
  row count
  ... other statement information items ...
Condition area list:
  Condition area 1:
    error code for condition 1
    error message for condition 1
    ... other condition information items ...
  Condition area 2:
    error code for condition 2:
    error message for condition 2
    ... other condition information items ...
  Condition area 3:
    error code for condition 3
    error message for condition 3
    ... other condition information items ...
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="diagnostics-area-information-items"></a>診断領域の情報項目</h5></div></div></div><p>
          診断領域には、ステートメント情報と条件情報項目が含まれています。 数値項目は整数です。 文字項目の文字セットは UTF-8 です。 どの項目も <code class="literal">NULL</code> にはできません。 診断領域を移入するステートメントによってステートメントまたは条件項目が設定されていない場合、その値は、項目のデータ型に応じて 0 または空の文字列になります。 
        </p><p>
          診断領域のステートメント情報の部分には、次の項目が含まれています。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">NUMBER</code>: 情報が含まれている条件領域の数を示す整数。
            </p></li><li class="listitem"><p>
              <code class="literal">ROW_COUNT</code>: このステートメントによって影響を受けた行数を示す整数。 <code class="literal">ROW_COUNT</code> には、<code class="literal">ROW_COUNT()</code> 関数と同じ値が含まれています (<a class="xref" href="functions.html#information-functions" title="12.16 情報関数">セクション12.16「情報関数」</a>を参照してください)。 
            </p></li></ul></div><p>
          診断領域の条件情報の部分には、条件ごとの条件領域が含まれています。 条件領域には、1 から <code class="literal">NUMBER</code> ステートメント条件項目の値の番号が付けられています。 <code class="literal">NUMBER</code> が 0 である場合、条件領域は存在しません。 
        </p><p>
          各条件領域には、次のリスト内の項目が含まれています。 MySQL 拡張である <code class="literal">MYSQL_ERRNO</code> を除き、すべての項目が標準 SQL です。 これらの定義は、シグナル以外によって (つまり、<code class="literal">SIGNAL</code> または <code class="literal">RESIGNAL</code> ステートメントによって) 生成された条件に適用されます。 シグナル以外の条件の場合、MySQL は、常に空であるとは示されていない条件項目のみを移入します。 条件領域に対するシグナルの影響については、あとで説明されています。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">CLASS_ORIGIN</code> <code class="literal">RETURNED_SQLSTATE</code> 値のクラスを含む文字列。 <code class="literal">RETURNED_SQLSTATE</code> 値が SQL 標準のドキュメント ISO 9075-2 (セクション 24.1、SQLSTATE) で定義されているクラス値で始まる場合、<code class="literal">CLASS_ORIGIN</code> は <code class="literal">'ISO 9075'</code> です。 それ以外の場合、<code class="literal">CLASS_ORIGIN</code> は <code class="literal">'MySQL'</code> です。 
            </p></li><li class="listitem"><p>
              <code class="literal">SUBCLASS_ORIGIN</code>: <code class="literal">RETURNED_SQLSTATE</code> 値のサブクラスを含む文字列。 <code class="literal">CLASS_ORIGIN</code> が <code class="literal">'ISO 9075'</code> であるか、または <code class="literal">RETURNED_SQLSTATE</code> が <code class="literal">'000'</code> で終わる場合、<code class="literal">SUBCLASS_ORIGIN</code> は <code class="literal">'ISO 9075'</code> です。 それ以外の場合、<code class="literal">SUBCLASS_ORIGIN</code> は <code class="literal">'MySQL'</code> です。 
            </p></li><li class="listitem"><p>
              <code class="literal">RETURNED_SQLSTATE</code>: この条件の <code class="literal">SQLSTATE</code> 値を示す文字列。
            </p></li><li class="listitem"><p>
              <code class="literal">MESSAGE_TEXT</code>: この条件のエラーメッセージを示す文字列。
            </p></li><li class="listitem"><p>
              <code class="literal">MYSQL_ERRNO</code>: この条件の MySQL エラーコードを示す整数。
            </p></li><li class="listitem"><p>
              <code class="literal">CONSTRAINT_CATALOG</code>、<code class="literal">CONSTRAINT_SCHEMA</code>、<code class="literal">CONSTRAINT_NAME</code>: 違反した制約のカタログ、スキーマ、および名前を示す文字列。 これらは常に空です。 
            </p></li><li class="listitem"><p>
              <code class="literal">CATALOG_NAME</code>、<code class="literal">SCHEMA_NAME</code>、<code class="literal">TABLE_NAME</code>、<code class="literal">COLUMN_NAME</code>: この条件に関連したカタログ、スキーマ、テーブル、およびカラムを示す文字列。 これらは常に空です。 
            </p></li><li class="listitem"><p>
              <code class="literal">CURSOR_NAME</code>: カーソル名を示す文字列。 これは常に空です。 
            </p></li></ul></div><p>
          <code class="literal">RETURNED_SQLSTATE</code>、<code class="literal">MESSAGE_TEXT</code>、および <code class="literal">MYSQL_ERRNO</code> 値の特定のエラーについては、<a class="ulink" href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html" target="_top">Server Error Message Reference</a>を参照してください。
        </p><p>
          <code class="literal">SIGNAL</code> (または <code class="literal">RESIGNAL</code>) ステートメントが診断領域を移入する場合、その <code class="literal">SET</code> 句は、<code class="literal">RETURNED_SQLSTATE</code> を除く任意の条件情報項目に、その項目のデータ型に対して正当な任意の値を割り当てることができます。 <code class="literal">SIGNAL</code> はまた、<code class="literal">RETURNED_SQLSTATE</code> 値も設定しますが、その <code class="literal">SET</code> 句で直接設定するわけではありません。 その値は、<code class="literal">SIGNAL</code> ステートメントの <code class="literal">SQLSTATE</code> 引数から取得されます。 
        </p><p>
          <code class="literal">SIGNAL</code> は、ステートメント情報項目も設定します。 <code class="literal">NUMBER</code> を 1 に設定します。 エラーの場合は <code class="literal">ROW_COUNT</code> を−1 に設定し、それ以外の場合は 0 に設定します。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="diagnostics-area-populating"></a>診断領域のクリアおよび移入方法</h5></div></div></div><p>
          診断以外の SQL ステートメントは診断領域に自動的に移入され、その内容は <code class="literal">SIGNAL</code> および <code class="literal">RESIGNAL</code> ステートメントを使用して明示的に設定できます。 診断領域は、特定の項目を抽出するために <code class="literal">GET DIAGNOSTICS</code> を使用して、あるいは条件またはエラーを確認するために <code class="literal">SHOW WARNINGS</code> または <code class="literal">SHOW ERRORS</code> を使用して検査できます。 
        </p><p>
          SQL ステートメントは、次のように診断領域をクリアおよび設定します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              解析後にサーバーがステートメントの実行を開始すると、非診断ステートメントの診断領域がクリアされます。 診断ステートメントは診断領域をクリアしません。 次のステートメントは診断です: 
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">GET DIAGNOSTICS</code>
                </p></li><li class="listitem"><p>
                  <code class="literal">SHOW ERRORS</code>
                </p></li><li class="listitem"><p>
                  <code class="literal">SHOW WARNINGS</code>
                </p></li></ul></div></li><li class="listitem"><p>
              ステートメントが条件を発生させた場合は、以前のステートメントに属する条件の診断領域がクリアされます。 例外として、<code class="literal">GET DIAGNOSTICS</code> および <code class="literal">RESIGNAL</code> によって発生した条件は、診断領域にその領域をクリアすることなく追加されます。 
            </p></li></ul></div><p>
          そのため、通常は実行開始時に診断領域をクリアしないステートメントであっても、そのステートメントが条件を発生させた場合は診断領域をクリアします。
        </p><p>
          次の例は、診断領域に対するさまざまなステートメントの影響を、<code class="literal">SHOW WARNINGS</code> を使用して、そこに格納されている条件に関する情報を表示することによって示しています。
        </p><p>
          次の <code class="literal">DROP TABLE</code> ステートメントは、診断領域をクリアし、条件が発生すると診断領域に移入します:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>DROP TABLE IF EXISTS test.no_such_table;</code></strong>
Query OK, 0 rows affected, 1 warning (0.01 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+-------+------+------------------------------------+
| Level | Code | Message                            |
+-------+------+------------------------------------+
| Note  | 1051 | Unknown table 'test.no_such_table' |
+-------+------+------------------------------------+
1 row in set (0.00 sec)
</pre><p>
          次の <code class="literal">SET</code> ステートメントはエラーを生成するため、診断領域をクリアして移入します。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET @x = @@x;</code></strong>
ERROR 1193 (HY000): Unknown system variable 'x'

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+-------+------+-----------------------------+
| Level | Code | Message                     |
+-------+------+-----------------------------+
| Error | 1193 | Unknown system variable 'x' |
+-------+------+-----------------------------+
1 row in set (0.00 sec)
</pre><p>
          前の <code class="literal">SET</code> ステートメントは 1 つの条件を生成したため、1 がこの時点での <code class="literal">GET DIAGNOSTICS</code> の唯一の有効な条件番号です。 次のステートメントは 2 の条件番号を使用しています。これにより、診断領域にその領域をクリアすることなく追加される警告が生成されます。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>GET DIAGNOSTICS CONDITION 2 @p = MESSAGE_TEXT;</code></strong>
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+-------+------+------------------------------+
| Level | Code | Message                      |
+-------+------+------------------------------+
| Error | 1193 | Unknown system variable 'xx' |
| Error | 1753 | Invalid condition number     |
+-------+------+------------------------------+
2 rows in set (0.00 sec)
</pre><p>
          これで、診断領域には 2 つの条件が存在するようになったため、同じ <code class="literal">GET DIAGNOSTICS</code> ステートメントが成功します。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>GET DIAGNOSTICS CONDITION 2 @p = MESSAGE_TEXT;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @p;</code></strong>
+--------------------------+
| @p                       |
+--------------------------+
| Invalid condition number |
+--------------------------+
1 row in set (0.01 sec)
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="diagnostics-area-stack"></a>診断領域スタックの動作</h5></div></div></div><p>
          診断領域スタックへのプッシュが発生すると、最初の (現在の) 診断領域が 2 番目の (スタックされた) 診断領域になり、新しい現在の診断領域がそのコピーとして作成されます。 診断領域は、次の状況でスタックにプッシュされ、スタックからポップされます: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              ストアドプログラムの実行
            </p><p>
              プログラムが実行される前にプッシュが発生し、その後ポップが発生します。 ハンドラの実行中にストアドプログラムが終了した場合、ポップする診断領域が複数存在する可能性があります。これは、適切なハンドラがない例外またはハンドラ内の <code class="literal">RETURN</code> が原因で発生します。 
            </p><p>
              ポップされた診断領域の警告またはエラーの状態は、トリガーの場合はエラーのみが追加されることを除き、現在の診断領域に追加されます。 ストアドプログラムが終了すると、呼び出し元の現在の診断領域にこれらの状態が表示されます。 
            </p></li><li class="listitem"><p>
              ストアドプログラム内での条件ハンドラの実行
            </p><p>
              条件ハンドラのアクティブ化の結果としてプッシュが発生した場合、スタック診断領域はプッシュ前にストアドプログラム内で最新だった領域です。 新しい非現在の診断領域は、ハンドラの現在の診断領域です。 ハンドラ内で <code class="literal">GET [CURRENT] DIAGNOSTICS</code> および <code class="literal">GET STACKED DIAGNOSTICS</code> を使用して、現在 (ハンドラ) およびスタック (ストアドプログラム) の診断領域の内容にアクセスできます。 最初は同じ結果が返されますが、ハンドラ内で実行されているステートメントは現在の診断領域を変更し、通常の規則に従ってその内容をクリアおよび設定します (<a class="xref" href="sql-statements.html#diagnostics-area-populating" title="診断領域のクリアおよび移入方法">診断領域のクリアおよび移入方法</a> を参照)。 スタック診断領域は、<code class="literal">RESIGNAL</code> を除くハンドラ内で実行されているステートメントでは変更できません。 
            </p><p>
              ハンドラが正常に実行されると、現在の (ハンドラ) 診断領域がポップされ、スタック (ストアドプログラム) 診断領域が再度現在の診断領域になります。 ハンドラの実行中にハンドラ診断領域に追加された条件は、現在の診断領域に追加されます。 
            </p></li><li class="listitem"><p>
              <code class="literal">RESIGNAL</code> の実行
            </p><p>
              <code class="literal">RESIGNAL</code> ステートメントは、ストアドプログラム内の複合ステートメント内で条件ハンドラの実行中に使用可能なエラー条件情報を渡します。 <code class="literal">RESIGNAL</code> は、情報の一部またはすべてを変更してから渡すことができ、<a class="xref" href="sql-statements.html#resignal" title="13.6.7.4 RESIGNAL ステートメント">セクション13.6.7.4「RESIGNAL ステートメント」</a> の説明に従って診断スタックを変更します。 
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="diagnostics-area-system-variables"></a>診断領域関連のシステム変数</h5></div></div></div><p>
          特定のシステム変数が診断領域のいくつかの側面を制御するか、またはそれに関連しています。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">max_error_count</code> は、診断領域内の条件領域の数を制御します。 これより多い条件が発生した場合、MySQL は、超過した条件に関する情報を暗黙のうちに破棄します。 (<code class="literal">RESIGNAL</code> によって追加された条件は、常に追加されます。空きを作るために、古い条件が必要に応じて破棄されます。) 
            </p></li><li class="listitem"><p>
              <code class="literal">warning_count</code> は、発生した条件の数を示します。 これには、エラー、警告、および注意が含まれます。 通常、<code class="literal">NUMBER</code> と <code class="literal">warning_count</code> は同じです。 ただし、生成された条件の数が <code class="literal">max_error_count</code> を超えると、診断領域にはそれ以上の条件が格納されないため、<code class="literal">warning_count</code> の値が引き続き増えるのに対して、<code class="literal">NUMBER</code> は <code class="literal">max_error_count</code> に上限が設定されたままになります。 
            </p></li><li class="listitem"><p>
              <code class="literal">error_count</code> は、発生したエラーの数を示します。 この値には<span class="quote">「<span class="quote">見つからない</span>」</span>と例外条件が含まれますが、警告と注意は除外されます。 <code class="literal">warning_count</code> と同様に、その値は <code class="literal">max_error_count</code> を超えることができます。 
            </p></li><li class="listitem"><p>
              <code class="literal">sql_notes</code> システム変数が 0 に設定されている場合、注意は格納されず、<code class="literal">warning_count</code> も増分しません。
            </p></li></ul></div><p>
          例: <code class="literal">max_error_count</code> が 10 である場合、診断領域には最大 10 個の条件領域を含めることができます。 ステートメントが 20 個の条件を発生させ、そのうちの 12 個がエラーであるとします。 その場合、診断領域には最初の 10 個の条件が含まれ、<code class="literal">NUMBER</code> は 10、<code class="literal">warning_count</code> は 20、<code class="literal">error_count</code> は 12 です。 
        </p><p>
          <code class="literal">max_error_count</code> の値を変更しても、次に診断領域を変更しようとするまでは何の効果もありません。 診断領域に 10 個の条件領域が含まれているときに <code class="literal">max_error_count</code> が 5 に設定された場合、その診断領域のサイズまたは内容への即座の影響は何もありません。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="conditions-and-parameters"></a>13.6.7.8 条件の処理と OUT または INOUT パラメータ</h4></div></div></div><a class="indexterm" name="idm45826992306224"></a><a class="indexterm" name="idm45826992304096"></a><a class="indexterm" name="idm45826992302016"></a><a class="indexterm" name="idm45826992299952"></a><p>
        ストアドプロシージャが未処理の例外で終了した場合、<code class="literal">OUT</code> および <code class="literal">INOUT</code> パラメータの変更された値はコール元に伝播されません。
      </p><p>
        <code class="literal">RESIGNAL</code> ステートメントを含む <code class="literal">CONTINUE</code> または <code class="literal">EXIT</code> ハンドラによって例外が処理される場合、<code class="literal">RESIGNAL</code> を実行すると診断領域スタックがポップされ、例外 (ハンドラへの入力前に存在していた情報) が通知されます。 例外がエラーの場合、<code class="literal">OUT</code> および <code class="literal">INOUT</code> パラメータの値はコール元に伝播されません。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="condition-handling-restrictions"></a>13.6.8 条件処理の制約</h3></div></div></div><a class="indexterm" name="idm45826992288512"></a><a class="indexterm" name="idm45826992286368"></a><p>
      <code class="literal">SIGNAL</code>、<code class="literal">RESIGNAL</code>、および <code class="literal">GET DIAGNOSTICS</code> は準備済みのステートメントとして許可されていません。 たとえば、次のステートメントは無効です。 
    </p><pre class="programlisting">PREPARE stmt1 FROM 'SIGNAL SQLSTATE "02000"';
</pre><p>
      クラス <code class="literal">'04'</code> の <code class="literal">SQLSTATE</code> 値は特別扱いされません。 ほかの例外と同じように扱われます。 
    </p><p>
      標準 SQL では、最初の条件は、以前の SQL ステートメントに対して返される <code class="literal">SQLSTATE</code> 値に関連します。 MySQL ではこれは保証されていないので、メインエラーを取得するために、次のようにはできません。 
    </p><pre class="programlisting">GET DIAGNOSTICS CONDITION 1 @errno = MYSQL_ERRNO;
</pre><p>
      代わりに次のようにします。
    </p><pre class="programlisting">GET DIAGNOSTICS @cno = NUMBER;
GET DIAGNOSTICS CONDITION @cno @errno = MYSQL_ERRNO;
</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sql-server-administration-statements"></a>13.7 データベース管理ステートメント</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#account-management-statements">13.7.1 アカウント管理ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#resource-group-statements">13.7.2 リソースグループ管理ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#table-maintenance-statements">13.7.3 テーブル保守ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#component-statements">13.7.4 コンポーネント、プラグインおよびユーザー定義関数のステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#clone">13.7.5 CLONE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#set-statement">13.7.6 SET ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show">13.7.7 SHOW ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#other-administrative-statements">13.7.8 その他の管理ステートメント</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="account-management-statements"></a>13.7.1 アカウント管理ステートメント</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#alter-user">13.7.1.1 ALTER USER ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-role">13.7.1.2 CREATE ROLE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-user">13.7.1.3 CREATE USER ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-role">13.7.1.4 DROP ROLE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-user">13.7.1.5 DROP USER ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#grant">13.7.1.6 GRANT ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#rename-user">13.7.1.7 RENAME USER ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#revoke">13.7.1.8 REVOKE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#set-default-role">13.7.1.9 SET DEFAULT ROLE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#set-password">13.7.1.10 SET PASSWORD ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#set-role">13.7.1.11 SET ROLE ステートメント</a></span></dt></dl></div><p>
      MySQL アカウント情報は、<code class="literal">mysql</code> システムスキーマのテーブルに格納されます。 このデータベースとアクセス制御システムについては、<a class="xref" href="server-administration.html" title="第 5 章 MySQL サーバーの管理">第5章「<i>MySQL サーバーの管理</i>」</a>で広範囲にわたって説明されています。詳細は、この章を参照するようにしてください。 
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        一部の MySQL リリースでは、新しい権限または機能を追加するために付与テーブルに変更が導入されています。 新しい機能を確実に利用できるようにするには、MySQL をアップグレードするたびに付与テーブルを現在の構造に更新します。 <a class="xref" href="installing.html#upgrading" title="2.11 MySQL のアップグレード">セクション2.11「MySQL のアップグレード」</a>を参照してください。 
      </p></div><p>
      <code class="literal">read_only</code> システム変数が有効になっている場合、account-management ステートメントには、他の必要な権限に加えて、<code class="literal">CONNECTION_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。 これは、<code class="literal">mysql</code> システムスキーマのテーブルを変更するためです。 
    </p><p>
      アカウント管理ステートメントはアトミックであり、クラッシュセーフです。 詳細は、<a class="xref" href="sql-statements.html#atomic-ddl" title="13.1.1 アトミックデータ定義ステートメントのサポート">セクション13.1.1「アトミックデータ定義ステートメントのサポート」</a>を参照してください。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="alter-user"></a>13.7.1.1 ALTER USER ステートメント</h4></div></div></div><a class="indexterm" name="idm45826992258016"></a><a class="indexterm" name="idm45826992256528"></a><a class="indexterm" name="idm45826992254464"></a><pre class="programlisting">ALTER USER [IF EXISTS]
    <em class="replaceable"><code>user</code></em> [<em class="replaceable"><code>auth_option</code></em>] [, <em class="replaceable"><code>user</code></em> [<em class="replaceable"><code>auth_option</code></em>]] ...
    [REQUIRE {NONE | <em class="replaceable"><code>tls_option</code></em> [[AND] <em class="replaceable"><code>tls_option</code></em>] ...}]
    [WITH <em class="replaceable"><code>resource_option</code></em> [<em class="replaceable"><code>resource_option</code></em>] ...]
    [<em class="replaceable"><code>password_option</code></em> | <em class="replaceable"><code>lock_option</code></em>] ...
    [COMMENT '<em class="replaceable"><code>comment_string</code></em>' | ATTRIBUTE '<em class="replaceable"><code>json_object</code></em>']

ALTER USER [IF EXISTS] USER() <em class="replaceable"><code>user_func_auth_option</code></em>

ALTER USER [IF EXISTS]
    <em class="replaceable"><code>user</code></em> DEFAULT ROLE
    {NONE | ALL | <em class="replaceable"><code>role</code></em> [, <em class="replaceable"><code>role</code></em> ] ...}

<em class="replaceable"><code>user</code></em>:
    (see <a class="xref" href="security.html#account-names" title="6.2.4 アカウント名の指定">セクション6.2.4「アカウント名の指定」</a>)

<em class="replaceable"><code>auth_option</code></em>: {
    IDENTIFIED BY '<em class="replaceable"><code>auth_string</code></em>'
        [REPLACE '<em class="replaceable"><code>current_auth_string</code></em>']
        [RETAIN CURRENT PASSWORD]
  | IDENTIFIED BY RANDOM PASSWORD
        [REPLACE '<em class="replaceable"><code>current_auth_string</code></em>']
        [RETAIN CURRENT PASSWORD]
  | IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em>
  | IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em> BY '<em class="replaceable"><code>auth_string</code></em>'
        [REPLACE '<em class="replaceable"><code>current_auth_string</code></em>']
        [RETAIN CURRENT PASSWORD]
  | IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em> BY RANDOM PASSWORD
        [REPLACE '<em class="replaceable"><code>current_auth_string</code></em>']
        [RETAIN CURRENT PASSWORD]
  | IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em> AS '<em class="replaceable"><code>auth_string</code></em>'
  | DISCARD OLD PASSWORD
}

<em class="replaceable"><code>user_func_auth_option</code></em>: {
    IDENTIFIED BY '<em class="replaceable"><code>auth_string</code></em>'
        [REPLACE '<em class="replaceable"><code>current_auth_string</code></em>']
        [RETAIN CURRENT PASSWORD]
  | DISCARD OLD PASSWORD
}

<em class="replaceable"><code>tls_option</code></em>: {
   SSL
 | X509
 | CIPHER '<em class="replaceable"><code>cipher</code></em>'
 | ISSUER '<em class="replaceable"><code>issuer</code></em>'
 | SUBJECT '<em class="replaceable"><code>subject</code></em>'
}

<em class="replaceable"><code>resource_option</code></em>: {
    MAX_QUERIES_PER_HOUR <em class="replaceable"><code>count</code></em>
  | MAX_UPDATES_PER_HOUR <em class="replaceable"><code>count</code></em>
  | MAX_CONNECTIONS_PER_HOUR <em class="replaceable"><code>count</code></em>
  | MAX_USER_CONNECTIONS <em class="replaceable"><code>count</code></em>
}

<em class="replaceable"><code>password_option</code></em>: {
    PASSWORD EXPIRE [DEFAULT | NEVER | INTERVAL <em class="replaceable"><code>N</code></em> DAY]
  | PASSWORD HISTORY {DEFAULT | <em class="replaceable"><code>N</code></em>}
  | PASSWORD REUSE INTERVAL {DEFAULT | <em class="replaceable"><code>N</code></em> DAY}
  | PASSWORD REQUIRE CURRENT [DEFAULT | OPTIONAL]
  | FAILED_LOGIN_ATTEMPTS <em class="replaceable"><code>N</code></em>
  | PASSWORD_LOCK_TIME {<em class="replaceable"><code>N</code></em> | UNBOUNDED}
}

<em class="replaceable"><code>lock_option</code></em>: {
    ACCOUNT LOCK
  | ACCOUNT UNLOCK
}
</pre><p>
        <code class="literal">ALTER USER</code> ステートメントによって、MySQL アカウントが変更されます。 既存のアカウントの認証、ロール、SSL/TLS、リソース制限およびパスワード管理プロパティを変更できます。 また、アカウントのロックおよびロック解除にも使用できます。 
      </p><p>
        ほとんどの場合、<code class="literal">ALTER USER</code> には <code class="literal">mysql</code> システムスキーマに対するグローバル <code class="literal">CREATE USER</code> 権限または <code class="literal">UPDATE</code> 権限が必要です。 例外は次のとおりです: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            匿名以外のアカウントを使用してサーバーに接続したクライアントはすべて、そのアカウントのパスワードを変更できます。 (特に、自分のパスワードを変更できます。) サーバーが認証したアカウントを確認するには、<code class="literal">CURRENT_USER()</code> 関数を呼び出します: 
          </p><pre class="programlisting">SELECT CURRENT_USER();
</pre></li><li class="listitem"><p>
            <code class="literal">DEFAULT ROLE</code> 構文の場合、<code class="literal">ALTER USER</code> には次の権限が必要です:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                別のユーザーのデフォルトロールを設定するには、<code class="literal">mysql.default_roles</code> システムテーブルに対するグローバル <code class="literal">CREATE USER</code> 権限または <code class="literal">UPDATE</code> 権限が必要です。
              </p></li><li class="listitem"><p>
                自分のデフォルトロールを設定する場合、デフォルトとして必要なロールが付与されているかぎり、特別な権限は必要ありません。
              </p></li></ul></div></li><li class="listitem"><p>
            セカンダリパスワードを変更するステートメントには、次の権限が必要です:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                自分のアカウントに適用される <code class="literal">ALTER USER</code> ステートメントに <code class="literal">RETAIN CURRENT PASSWORD</code> または <code class="literal">DISCARD OLD PASSWORD</code> 句を使用するには、<code class="literal">APPLICATION_PASSWORD_ADMIN</code> 権限が必要です。 ほとんどのユーザーは 1 つのパスワードのみを必要とするため、自分のセカンダリパスワードを操作するには権限が必要です。 
              </p></li><li class="listitem"><p>
                アカウントがすべてのアカウントのセカンダリパスワードの操作を許可される場合は、<code class="literal">APPLICATION_PASSWORD_ADMIN</code> ではなく <code class="literal">CREATE USER</code> 権限が必要です。
              </p></li></ul></div></li></ul></div><p>
        <code class="literal">read_only</code> システム変数が有効になっている場合、<code class="literal">ALTER USER</code> にはさらに <code class="literal">CONNECTION_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。
      </p><p>
        デフォルトでは、存在しないユーザーを変更しようとすると、エラーが発生します。 <code class="literal">IF EXISTS</code> 句を指定すると、ステートメントは、存在しない指定ユーザーごとに、エラーではなく、警告を生成します。 
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          状況によっては、<code class="literal">ALTER USER</code> はサーバーログまたはクライアント側の <code class="filename">~/.mysql_history</code> などの履歴ファイルに記録される場合があります。つまり、クリアテキストパスワードは、その情報への読取りアクセス権を持つすべてのユーザーが読み取ることができます。 これがサーバーログで発生する条件およびこれを制御する方法については、<a class="xref" href="security.html#password-logging" title="6.1.2.3 パスワードおよびロギング">セクション6.1.2.3「パスワードおよびロギング」</a>を参照してください。 クライアント側のロギングに関する同様の情報については、<a class="xref" href="programs.html#mysql-logging" title="4.5.1.3 mysql クライアントロギング">セクション4.5.1.3「mysql クライアントロギング」</a>を参照してください。 
        </p></div><p>
        次のトピックで説明するように、<code class="literal">ALTER USER</code> ステートメントにはいくつかの側面があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#alter-user-overview" title="ALTER USER の概要">ALTER USER の概要</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#alter-user-authentication" title="ALTER USER 認証オプション">ALTER USER 認証オプション</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#alter-user-role" title="ALTER USER ロールのオプション">ALTER USER ロールのオプション</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#alter-user-tls" title="ALTER USER SSL/TLS オプション">ALTER USER SSL/TLS オプション</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#alter-user-resource-limits" title="ALTER USER リソース制限オプション">ALTER USER リソース制限オプション</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#alter-user-password-management" title="ALTER USER のパスワード管理オプション">ALTER USER のパスワード管理オプション</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#alter-user-account-locking" title="ALTER USER アカウントロックオプション">ALTER USER アカウントロックオプション</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#alter-user-binary-logging" title="ALTER USER バイナリロギング">ALTER USER バイナリロギング</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="alter-user-overview"></a>ALTER USER の概要</h5></div></div></div><p>
          影響を受けるアカウントごとに、<code class="literal">ALTER USER</code> は <code class="literal">mysql.user</code> システムテーブルの対応する行を変更して、ステートメントで指定されたプロパティを反映します。 未指定のプロパティは現在の値を保持します。 
        </p><p>
          各アカウント名には、<a class="xref" href="security.html#account-names" title="6.2.4 アカウント名の指定">セクション6.2.4「アカウント名の指定」</a>で説明されている形式が使用されます。 アカウント名のホスト名部分は、省略すると<code class="literal">'%'</code>にデフォルト設定されます。 <code class="literal">CURRENT_USER</code> または <code class="literal">CURRENT_USER()</code> を指定して、現在のセッションに関連付けられているアカウントを参照することもできます。 
        </p><p>
          一方の構文の場合のみ、<code class="literal">USER()</code> 関数でアカウントを指定できます:
        </p><pre class="programlisting">ALTER USER USER() IDENTIFIED BY '<em class="replaceable"><code>auth_string</code></em>';
</pre><p>
          この構文を使用すると、アカウントに文字どおりの名前を付けずに自分のパスワードを変更できます。 (構文では、<a class="xref" href="sql-statements.html#alter-user-authentication" title="ALTER USER 認証オプション">ALTER USER 認証オプション</a> で説明されている <code class="literal">REPLACE</code>、<code class="literal">RETAIN CURRENT PASSWORD</code> および <code class="literal">DISCARD OLD PASSWORD</code> 句もサポートされています。) 
        </p><p>
          MySQL 8.0.21 以降では、<a class="xref" href="sql-statements.html#create-user" title="13.7.1.3 CREATE USER ステートメント">セクション13.7.1.3「CREATE USER ステートメント」</a> で説明されているように、ユーザーコメントおよびユーザー属性がサポートされます。 これらは、それぞれ <code class="literal">COMMENT</code> および <code class="literal">ATTRIBUTE</code> オプションを使用して、<code class="literal">ALTER USER</code> を使用して変更できます。 同じ <code class="literal">ALTER USER</code> ステートメントで両方のオプションを指定することはできません。指定しようとすると構文エラーが発生します。 
        </p><p>
          ユーザーコメントおよびユーザー属性は、JSON オブジェクトとして <code class="literal">INFORMATION_SCHEMA.USER_ATTRIBUTES</code> テーブルに格納されます。この説明で後述するように、ユーザーコメントは、このテーブルの ATTRIBUTE カラムの <code class="literal">comment</code> キーの値として格納されます。 <code class="literal">COMMENT</code> テキストは任意の任意の引用符付きテキストで、既存のユーザーコメントを置換できます。 <code class="literal">ATTRIBUTE</code> 値は、JSON オブジェクトの有効な文字列表現である必要があります。 これは、<code class="literal">JSON_MERGE_PATCH()</code> 関数が既存のユーザー属性および新しいユーザー属性で使用されているかのように、既存のユーザー属性とマージされます。再使用されるキーについては、次に示すように、新しい値によって古い値が上書きされます: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.USER_ATTRIBUTES</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE USER='bill' AND HOST='localhost';</code></strong>
+------+-----------+----------------+
| USER | HOST      | ATTRIBUTE      |
+------+-----------+----------------+
| bill | localhost | {"foo": "bar"} |
+------+-----------+----------------+
1 row in set (0.11 sec)

mysql&gt; <strong class="userinput"><code>ALTER USER 'bill'@'localhost' ATTRIBUTE '{"baz": "faz", "foo": "moo"}';</code></strong>
Query OK, 0 rows affected (0.22 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.USER_ATTRIBUTES</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE USER='bill' AND HOST='localhost';</code></strong>
+------+-----------+------------------------------+
| USER | HOST      | ATTRIBUTE                    |
+------+-----------+------------------------------+
| bill | localhost | {"baz": "faz", "foo": "moo"} |
+------+-----------+------------------------------+
1 row in set (0.00 sec)
</pre><p>
          ユーザー属性からキーとその値を削除するには、次のように、キーを JSON <code class="literal">null</code> に設定します (小文字で引用符で囲まれていない必要があります):
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER USER 'bill'@'localhost' ATTRIBUTE '{"foo": null}';</code></strong>
Query OK, 0 rows affected (0.08 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.USER_ATTRIBUTES</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE USER='bill' AND HOST='localhost';</code></strong>
+------+-----------+----------------+
| USER | HOST      | ATTRIBUTE      |
+------+-----------+----------------+
| bill | localhost | {"baz": "faz"} |
+------+-----------+----------------+
1 row in set (0.00 sec)
</pre><p>
          既存のユーザーコメントを空の文字列に設定するには、<code class="literal">ALTER USER ... COMMENT ''</code>を使用します。 これにより、<code class="literal">USER_ATTRIBUTES</code> テーブルに空の <code class="literal">comment</code> 値が残されます。ユーザーコメントを完全に削除するには、カラムキーの値を JSON <code class="literal">null</code> に設定して <code class="literal">ALTER USER ... ATTRIBUTE ...</code> を使用します (小文字では引用符で囲まれていません)。 これは、次の一連の SQL ステートメントで示されています: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER USER 'bill'@'localhost' COMMENT 'Something about Bill';</code></strong>
Query OK, 0 rows affected (0.06 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.USER_ATTRIBUTES</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE USER='bill' AND HOST='localhost';</code></strong>
+------+-----------+---------------------------------------------------+
| USER | HOST      | ATTRIBUTE                                         |
+------+-----------+---------------------------------------------------+
| bill | localhost | {"baz": "faz", "comment": "Something about Bill"} |
+------+-----------+---------------------------------------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>ALTER USER 'bill'@'localhost' COMMENT '';</code></strong>
Query OK, 0 rows affected (0.09 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.USER_ATTRIBUTES</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE USER='bill' AND HOST='localhost';</code></strong>
+------+-----------+-------------------------------+
| USER | HOST      | ATTRIBUTE                     |
+------+-----------+-------------------------------+
| bill | localhost | {"baz": "faz", "comment": ""} |
+------+-----------+-------------------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>ALTER USER 'bill'@'localhost' ATTRIBUTE '{"comment": null}';</code></strong>
Query OK, 0 rows affected (0.07 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.USER_ATTRIBUTES</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE USER='bill' AND HOST='localhost';</code></strong>
+------+-----------+----------------+
| USER | HOST      | ATTRIBUTE      |
+------+-----------+----------------+
| bill | localhost | {"baz": "faz"} |
+------+-----------+----------------+
1 row in set (0.00 sec)
</pre><p>
          <em class="replaceable"><code>auth_option</code></em> 値が <em class="replaceable"><code>user</code></em> 値に従うことを許可する <code class="literal">ALTER USER</code> 構文の場合、<em class="replaceable"><code>auth_option</code></em> は、アカウント認証プラグイン、資格証明 (パスワードなど) またはその両方を指定して、アカウントがどのように認証されるかを示します。 各 <em class="replaceable"><code>auth_option</code></em> 値は、直前に指定されたアカウントに<span class="emphasis"><em>のみ</em></span>を適用します。 
        </p><p>
          <em class="replaceable"><code>user</code></em> 仕様に従って、ステートメントに SSL/TLS、リソース制限、パスワード管理およびロックプロパティのオプションを含めることができます。 このようなオプションはすべて、ステートメントに対する <span class="emphasis"><em>global</em></span> であり、ステートメントで指定された <span class="emphasis"><em>all</em></span> アカウントに適用されます。 
        </p><p>
          例: アカウントパスワードを変更して期限切れにします。 そのため、ユーザーは指定されたパスワードで接続し、次の接続時に新しいパスワードを選択する必要があります: 
        </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost'
  IDENTIFIED BY '<em class="replaceable"><code>new_password</code></em>' PASSWORD EXPIRE;
</pre><p>
          例: <code class="literal">caching_sha2_password</code> 認証プラグインと指定されたパスワードを使用するようにアカウントを変更します。 180 日ごとに新しいパスワードを選択し、ログイン失敗トラッキングを有効にする必要があります。これにより、次の 3 つのパスワードが連続して正しくないと、一時的なアカウントのロックが 2 日間発生します: 
        </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost'
  IDENTIFIED WITH caching_sha2_password BY '<em class="replaceable"><code>new_password</code></em>'
  PASSWORD EXPIRE INTERVAL 180 DAY
  FAILED_LOGIN_ATTEMPTS 3 PASSWORD_LOCK_TIME 2;
</pre><p>
          例: アカウントのロックまたはロック解除:
        </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost' ACCOUNT LOCK;
ALTER USER 'jeffrey'@'localhost' ACCOUNT UNLOCK;
</pre><p>
          例: SSL を使用して接続し、1 時間あたり 20 の接続を確立するためのアカウントが必要です:
        </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost'
  REQUIRE SSL WITH MAX_CONNECTIONS_PER_HOUR 20;
</pre><p>
          例: アカウントごとのプロパティおよびグローバルプロパティを指定して、複数のアカウントを変更します:
        </p><pre class="programlisting">ALTER USER
  'jeffrey'@'localhost'
    IDENTIFIED BY '<em class="replaceable"><code>jeffrey_new_password</code></em>',
  'jeanne'@'localhost',
  'josh'@'localhost'
    IDENTIFIED BY '<em class="replaceable"><code>josh_new_password</code></em>'
    REPLACE '<em class="replaceable"><code>josh_current_password</code></em>'
    RETAIN CURRENT PASSWORD
  REQUIRE SSL WITH MAX_USER_CONNECTIONS 2
  PASSWORD HISTORY 5;
</pre><p>
          <code class="literal">jeffrey</code> に続く <code class="literal">IDENTIFIED BY</code> 値は直前のアカウントにのみ適用されるため、パスワードは <code class="literal">jeffrey</code> の<code class="literal">'<em class="replaceable"><code>jeffrey_new_password</code></em>'</code>にのみ変更されます。 <code class="literal">jeanne</code> の場合、アカウントごとの値はありません (そのため、パスワードは変更されません)。 <code class="literal">josh</code> の場合、<code class="literal">IDENTIFIED BY</code> は新しいパスワード (<code class="literal">'<em class="replaceable"><code>josh_new_password</code></em>'</code>) を確立し、<code class="literal">ALTER USER</code> ステートメントを発行するユーザーが現在のパスワード (<code class="literal">'<em class="replaceable"><code>josh_current_password</code></em>'</code>) を知っていることを確認するために <code class="literal">REPLACE</code> が指定され、現在のパスワードもアカウントセカンダリパスワードとして保持されます。 (その結果、<code class="literal">josh</code> はプライマリパスワードまたはセカンダリパスワードのいずれかを使用して接続できます。) 
        </p><p>
          残りのプロパティは、ステートメントで指定されたすべてのアカウントにグローバルに適用されるため、両方のアカウントについて次のようになります:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              SSL を使用するには接続が必要です。
            </p></li><li class="listitem"><p>
              アカウントは、最大 2 つの同時接続に使用できます。
            </p></li><li class="listitem"><p>
              パスワードの変更では、最新の 5 つのパスワードを再利用できません。
            </p></li></ul></div><p>
          例: アカウントにプライマリパスワードのみを残して、<code class="literal">josh</code> のセカンダリパスワードを破棄します:
        </p><pre class="programlisting">ALTER USER 'josh'@'localhost' DISCARD OLD PASSWORD;
</pre><p>
          特定のタイプのオプションがない場合、アカウントはその点で変更されません。 たとえば、ロックオプションを指定しない場合、アカウントのロック状態は変更されません。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="alter-user-authentication"></a>ALTER USER 認証オプション</h5></div></div></div><p>
          アカウント名の後に、アカウント認証プラグインまたは資格証明 (あるいはその両方) を指定する <em class="replaceable"><code>auth_option</code></em> 認証オプションを続けることができます。 また、置換するアカウントの現在のパスワードを指定する password-verification 句や、アカウントにセカンダリパスワードがあるかどうかを管理する句も含めることができます。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            ランダムパスワード生成、パスワード検証およびセカンダリパスワードの句は、資格証明を MySQL に内部的に格納する認証プラグインを使用するアカウントにのみ適用されます。 MySQL の外部にある資格証明システムに対して認証を実行するプラグインを使用するアカウントの場合、パスワード管理もそのシステムに対して外部で処理する必要があります。 内部資格証明記憶域の詳細は、<a class="xref" href="security.html#password-management" title="6.2.15 パスワード管理">セクション6.2.15「パスワード管理」</a> を参照してください。 
          </p></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <em class="replaceable"><code>auth_plugin</code></em> は、認証プラグインに名前を付けます。 プラグイン名は、引用符で囲まれた文字列リテラルまたは引用符で囲まれていない名前です。 プラグイン名は、<code class="literal">mysql.user</code> システムテーブルの <code class="literal">plugin</code> カラムに格納されます。 
            </p><p>
              認証プラグインを指定しない <em class="replaceable"><code>auth_option</code></em> 構文の場合、デフォルトのプラグインは <code class="literal">default_authentication_plugin</code> システム変数の値で示されます。 各プラグインの説明については、<a class="xref" href="security.html#authentication-plugins" title="6.4.1 認証プラグイン">セクション6.4.1「認証プラグイン」</a> を参照してください。 
            </p></li><li class="listitem"><p>
              内部的に格納される資格証明は、<code class="literal">mysql.user</code> システムテーブルに格納されます。 <code class="literal">'<em class="replaceable"><code>auth_string</code></em>'</code>値または <code class="literal">RANDOM PASSWORD</code> は、アカウント資格証明をクリアテキスト (暗号化されていない) 文字列として指定するか、アカウントに関連付けられた認証プラグインで想定される形式でハッシュします: 
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">BY '<em class="replaceable"><code>auth_string</code></em>'</code>を使用する構文の場合、文字列はクリアテキストであり、ハッシュ化のために認証プラグインに渡されます。 プラグインによって返される結果は、<code class="literal">mysql.user</code> テーブルに格納されます。 プラグインは、指定された値を使用できます。この場合、ハッシュは発生しません。 
                </p></li><li class="listitem"><p>
                  <code class="literal">BY RANDOM PASSWORD</code> を使用する構文の場合、MySQL はランダムパスワードをクリアテキストとして生成し、ハッシュ化のために認証プラグインに渡します。 プラグインによって返される結果は、<code class="literal">mysql.user</code> テーブルに格納されます。 プラグインは、指定された値を使用できます。この場合、ハッシュは発生しません。 
                </p><p>
                  ランダムに生成されたパスワードは、MySQL 8.0.18 で使用でき、<a class="xref" href="security.html#random-password-generation" title="ランダムパスワード生成">ランダムパスワード生成</a> で説明されている特性があります。
                </p></li><li class="listitem"><p>
                  <code class="literal">AS '<em class="replaceable"><code>auth_string</code></em>'</code>を使用する構文の場合、文字列はすでに認証プラグインに必要な形式であるとみなされ、<code class="literal">mysql.user</code> テーブルにそのまま格納されます。 プラグインにハッシュ値が必要な場合、その値はプラグインに適した形式ですでにハッシュされている必要があります。そうでない場合、プラグインはこの値を使用できず、クライアント接続の正しい認証は行われません。 
                </p><p>
                  MySQL 8.0.17 の時点では、ハッシュ文字列は文字列リテラルまたは 16 進数値のいずれかになります。 後者は、<code class="literal">print_identified_with_as_hex</code> システム変数が有効になっている場合に、印刷不可能な文字を含むパスワードハッシュに対して <code class="literal">SHOW CREATE USER</code> によって表示される値のタイプに対応します。 
                </p></li><li class="listitem"><p>
                  認証プラグインが認証文字列のハッシュを実行しない場合、<code class="literal">BY '<em class="replaceable"><code>auth_string</code></em>'</code>句と <code class="literal">AS '<em class="replaceable"><code>auth_string</code></em>'</code>句は同じ効果を持ちます: 認証文字列は、<code class="literal">mysql.user</code> システムテーブルにそのまま格納されます。
                </p></li></ul></div></li><li class="listitem"><p>
              <code class="literal">REPLACE '<em class="replaceable"><code>current_auth_string</code></em>'</code>句はパスワード検証を実行し、MySQL 8.0.13 の時点で使用できます。 指定された場合: 
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">REPLACE</code> は、置換するアカウントの現在のパスワードをクリアテキスト (暗号化されていない) 文字列として指定します。
                </p></li><li class="listitem"><p>
                  変更しようとしているユーザーが実際に現在のパスワードを認識していることを確認するために、現在のパスワードを指定するためにのパスワード変更が必要な場合は、句を指定する必要があります。
                </p></li><li class="listitem"><p>
                  アカウントのパスワードが変更される可能性があるが、現在のパスワードを指定する必要がない場合、句はオプションです。
                </p></li><li class="listitem"><p>
                  句が指定されているが、句がオプションであっても現在のパスワードと一致しない場合、ステートメントは失敗します。
                </p></li><li class="listitem"><p>
                  <code class="literal">REPLACE</code> は、現在のユーザーのアカウントパスワードを変更する場合にのみ指定できます。
                </p></li></ul></div><p>
              現在のパスワードを指定したパスワード検証の詳細は、<a class="xref" href="security.html#password-management" title="6.2.15 パスワード管理">セクション6.2.15「パスワード管理」</a> を参照してください。
            </p></li><li class="listitem"><p>
              <code class="literal">RETAIN CURRENT PASSWORD</code> 句および <code class="literal">DISCARD OLD PASSWORD</code> 句はデュアルパスワード機能を実装し、MySQL 8.0.14 の時点で使用できます。 どちらもオプションですが、指定した場合は次の効果があります: 
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">RETAIN CURRENT PASSWORD</code> は、アカウントの現在のパスワードをセカンダリパスワードとして保持し、既存のセカンダリパスワードを置き換えます。 新しいパスワードはプライマリパスワードになりますが、クライアントはアカウントを使用して、プライマリパスワードまたはセカンダリパスワードのいずれかを使用してサーバーに接続できます。 (例外: <code class="literal">ALTER USER</code> ステートメントで指定された新しいパスワードが空の場合、<code class="literal">RETAIN CURRENT PASSWORD</code> が指定されていても、セカンダリパスワードも空になります。) 
                </p></li><li class="listitem"><p>
                  プライマリパスワードが空のアカウントに <code class="literal">RETAIN CURRENT PASSWORD</code> を指定すると、ステートメントは失敗します。
                </p></li><li class="listitem"><p>
                  アカウントにセカンダリパスワードがあり、<code class="literal">RETAIN CURRENT PASSWORD</code> を指定せずにプライマリパスワードを変更した場合、セカンダリパスワードは変更されません。
                </p></li><li class="listitem"><p>
                  アカウントに割り当てられた認証プラグインを変更すると、セカンダリパスワードは破棄されます。 認証プラグインを変更し、<code class="literal">RETAIN CURRENT PASSWORD</code> も指定すると、ステートメントは失敗します。 
                </p></li><li class="listitem"><p>
                  セカンダリパスワードが存在する場合、<code class="literal">DISCARD OLD PASSWORD</code> はセカンダリパスワードを破棄します。 アカウントはプライマリパスワードのみを保持し、クライアントはプライマリパスワードのみを使用してサーバーに接続するためにアカウントを使用できます。 
                </p></li></ul></div><p>
              デュアルパスワードの使用の詳細は、<a class="xref" href="security.html#password-management" title="6.2.15 パスワード管理">セクション6.2.15「パスワード管理」</a> を参照してください。
            </p></li></ul></div><p>
          <code class="literal">ALTER USER</code> では、次の <em class="replaceable"><code>auth_option</code></em> 構文が許可されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">IDENTIFIED BY '<em class="replaceable"><code>auth_string</code></em>' [REPLACE '<em class="replaceable"><code>current_auth_string</code></em>'] [RETAIN CURRENT PASSWORD]</code>
            </p><p>
              アカウント認証プラグインをデフォルトプラグインに設定し、ハッシュ化のためにクリアテキストの<code class="literal">'<em class="replaceable"><code>auth_string</code></em>'</code>値をプラグインに渡し、その結果を <code class="literal">mysql.user</code> システムテーブルのアカウント行に格納します。
            </p><p>
              このセクションで前述したように、<code class="literal">REPLACE</code> 句を指定すると、アカウントの現在のパスワードが指定されます。
            </p><p>
              <code class="literal">RETAIN CURRENT PASSWORD</code> 句を指定すると、このセクションで前述したように、アカウントの現在のパスワードがセカンダリパスワードとして保持されます。
            </p></li><li class="listitem"><p>
              <code class="literal">IDENTIFIED BY RANDOM PASSWORD [REPLACE '<em class="replaceable"><code>current_auth_string</code></em>'] [RETAIN CURRENT PASSWORD]</code>
            </p><p>
              アカウント認証プラグインをデフォルトのプラグインに設定し、ランダムなパスワードを生成して、ハッシュ可能なプラグインにクリアテキストのパスワード値を渡し、その結果を <code class="literal">mysql.user</code> システムテーブルのアカウント行に格納します。 このステートメントは、ステートメントを実行しているユーザーまたはアプリケーションが使用できるように、クリアテキストのパスワードも結果セットに返します。 ランダムに生成されるパスワードの結果セットおよび特性の詳細は、<a class="xref" href="security.html#random-password-generation" title="ランダムパスワード生成">ランダムパスワード生成</a> を参照してください。 
            </p><p>
              このセクションで前述したように、<code class="literal">REPLACE</code> 句を指定すると、アカウントの現在のパスワードが指定されます。
            </p><p>
              <code class="literal">RETAIN CURRENT PASSWORD</code> 句を指定すると、このセクションで前述したように、アカウントの現在のパスワードがセカンダリパスワードとして保持されます。
            </p></li><li class="listitem"><p>
              <code class="literal">IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em></code>
            </p><p>
              アカウント認証プラグインを <em class="replaceable"><code>auth_plugin</code></em> に設定し、資格証明を空の文字列にクリアし (資格証明は新しい認証プラグインではなく古い認証プラグインに関連付けられます)、その結果を <code class="literal">mysql.user</code> システムテーブルのアカウント行に格納します。
            </p><p>
              また、パスワードは期限切れとマークされます。 ユーザーは、次に接続するときに新しいものを選択する必要があります。 
            </p></li><li class="listitem"><p>
              <code class="literal">IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em> BY '<em class="replaceable"><code>auth_string</code></em>' [REPLACE '<em class="replaceable"><code>current_auth_string</code></em>'] [RETAIN CURRENT PASSWORD]</code>
            </p><p>
              アカウント認証プラグインを <em class="replaceable"><code>auth_plugin</code></em> に設定し、ハッシュ化のためにクリアテキストの<code class="literal">'<em class="replaceable"><code>auth_string</code></em>'</code>値をプラグインに渡し、その結果を <code class="literal">mysql.user</code> システムテーブルのアカウント行に格納します。
            </p><p>
              このセクションで前述したように、<code class="literal">REPLACE</code> 句を指定すると、アカウントの現在のパスワードが指定されます。
            </p><p>
              <code class="literal">RETAIN CURRENT PASSWORD</code> 句を指定すると、このセクションで前述したように、アカウントの現在のパスワードがセカンダリパスワードとして保持されます。
            </p></li><li class="listitem"><p>
              <code class="literal">IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em> BY RANDOM PASSWORD [REPLACE '<em class="replaceable"><code>current_auth_string</code></em>'] [RETAIN CURRENT PASSWORD]</code>
            </p><p>
              アカウント認証プラグインを <em class="replaceable"><code>auth_plugin</code></em> に設定し、ランダムパスワードを生成し、ハッシュ化のためにクリアテキストパスワード値をプラグインに渡し、その結果を <code class="literal">mysql.user</code> システムテーブルのアカウント行に格納します。 このステートメントは、ステートメントを実行しているユーザーまたはアプリケーションが使用できるように、クリアテキストのパスワードも結果セットに返します。 ランダムに生成されるパスワードの結果セットおよび特性の詳細は、<a class="xref" href="security.html#random-password-generation" title="ランダムパスワード生成">ランダムパスワード生成</a> を参照してください。 
            </p><p>
              このセクションで前述したように、<code class="literal">REPLACE</code> 句を指定すると、アカウントの現在のパスワードが指定されます。
            </p><p>
              <code class="literal">RETAIN CURRENT PASSWORD</code> 句を指定すると、このセクションで前述したように、アカウントの現在のパスワードがセカンダリパスワードとして保持されます。
            </p></li><li class="listitem"><p>
              <code class="literal">IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em> AS '<em class="replaceable"><code>auth_string</code></em>'</code>
            </p><p>
              アカウント認証プラグインを <em class="replaceable"><code>auth_plugin</code></em> に設定し、<code class="literal">'<em class="replaceable"><code>auth_string</code></em>'</code>値を <code class="literal">mysql.user</code> アカウント行にそのまま格納します。 プラグインにハッシュ文字列が必要な場合、文字列はプラグインに必要な形式ですでにハッシュされているとみなされます。 
            </p></li><li class="listitem"><p>
              <code class="literal">DISCARD OLD PASSWORD</code>
            </p><p>
              このセクションで前述したように、アカウントセカンダリパスワードがある場合は破棄します。
            </p></li></ul></div><p>
          例: パスワードをクリアテキストで指定します。デフォルトのプラグインが使用されます:
        </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost'
  IDENTIFIED BY '<em class="replaceable"><code>password</code></em>';
</pre><p>
          例: 認証プラグインをクリアテキストのパスワード値とともに指定します:
        </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost'
  IDENTIFIED WITH mysql_native_password
             BY '<em class="replaceable"><code>password</code></em>';
</pre><p>
          例: 前述の例と同様ですが、変更を行ったユーザーがそのパスワードを知っているアカウント要件を満たすために、現在のパスワードをクリアテキスト値として指定します:
        </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost'
  IDENTIFIED WITH mysql_native_password
             BY '<em class="replaceable"><code>password</code></em>'
             REPLACE '<em class="replaceable"><code>current_password</code></em>';
</pre><p>
          <code class="literal">REPLACE</code> は現在のユーザーパスワードの変更のみを許可されているため、現在のユーザーが <code class="literal">jeffrey</code> でないかぎり、前述のステートメントは失敗します。
        </p><p>
          例: 新しいプライマリパスワードを設定し、既存のパスワードをセカンダリパスワードとして保持します:
        </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost'
  IDENTIFIED BY '<em class="replaceable"><code>new_password</code></em>'
  RETAIN CURRENT PASSWORD;
</pre><p>
          例: セカンダリパスワードを破棄し、アカウントにプライマリパスワードのみを残します:
        </p><pre class="programlisting">ALTER USER 'jeffery'@'localhost' DISCARD OLD PASSWORD;
</pre><p>
          例: ハッシュされたパスワード値とともに認証プラグインを指定します:
        </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost'
  IDENTIFIED WITH mysql_native_password
             AS '*6C8989366EAF75BB670AD8EA7A7FC1176A95CEF4';
</pre><p>
          パスワードと認証プラグインの設定の詳細は、<a class="xref" href="security.html#assigning-passwords" title="6.2.14 アカウントパスワードの割り当て">セクション6.2.14「アカウントパスワードの割り当て」</a>および<a class="xref" href="security.html#pluggable-authentication" title="6.2.17 プラガブル認証">セクション6.2.17「プラガブル認証」</a>を参照してください。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="alter-user-role"></a>ALTER USER ロールのオプション</h5></div></div></div><a class="indexterm" name="idm45826991960112"></a><p>
          <code class="literal">ALTER USER ... DEFAULT ROLE</code> では、ユーザーがサーバーに接続して認証するとき、またはユーザーがセッション中に <code class="literal">SET ROLE DEFAULT</code> ステートメントを実行するときにアクティブになるロールを定義します。
        </p><p>
          <code class="literal">ALTER USER ... DEFAULT ROLE</code> は、<code class="literal">SET DEFAULT ROLE</code> の代替構文です (<a class="xref" href="sql-statements.html#set-default-role" title="13.7.1.9 SET DEFAULT ROLE ステートメント">セクション13.7.1.9「SET DEFAULT ROLE ステートメント」</a> を参照)。 ただし、<code class="literal">ALTER USER</code> では単一のユーザーに対してのみデフォルトを設定できますが、<code class="literal">SET DEFAULT ROLE</code> では複数のユーザーに対してデフォルトを設定できます。 一方、<code class="literal">ALTER USER</code> ステートメントのユーザー名として <code class="literal">CURRENT_USER</code> を指定できますが、<code class="literal">SET DEFAULT ROLE</code> のユーザー名は指定できません。 
        </p><p>
          各ユーザーアカウント名には、前述の形式が使用されます。
        </p><p>
          各ロール名は、<a class="xref" href="security.html#role-names" title="6.2.5 ロール名の指定">セクション6.2.5「ロール名の指定」</a> で説明されている形式を使用します。 例: 
        </p><pre class="programlisting">ALTER USER 'joe'@'10.0.0.1' DEFAULT ROLE administrator, developer;
</pre><p>
          ロール名のホスト名部分は、省略すると<code class="literal">'%'</code>にデフォルト設定されます。
        </p><p>
          <code class="literal">DEFAULT ROLE</code> キーワードに続く句では、次の値が許可されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">NONE</code>: デフォルトを <code class="literal">NONE</code> (ロールなし) に設定します。
            </p></li><li class="listitem"><p>
              <code class="literal">ALL</code>: アカウントに付与されているすべてのロールにデフォルトを設定します。
            </p></li><li class="listitem"><p>
              <code class="literal"><em class="replaceable"><code>role</code></em> [, <em class="replaceable"><code>role</code></em> ] ...</code>: デフォルトを名前付きロールに設定します。このロールは、<code class="literal">ALTER USER ... DEFAULT ROLE</code> の実行時に存在し、アカウントに付与される必要があります。
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="alter-user-tls"></a>ALTER USER SSL/TLS オプション</h5></div></div></div><a class="indexterm" name="idm45826991931328"></a><a class="indexterm" name="idm45826991929280"></a><a class="indexterm" name="idm45826991927200"></a><p>
          MySQL では、ユーザー名と資格証明に基づく通常の認証に加えて、X.509 証明書属性をチェックできます。 MySQL での SSL/TLS の使用に関する背景情報は、<a class="xref" href="security.html#encrypted-connections" title="6.3 暗号化された接続の使用">セクション6.3「暗号化された接続の使用」</a> を参照してください。 
        </p><p>
          MySQL アカウントの SSL/TLS 関連オプションを指定するには、1 つ以上の <em class="replaceable"><code>tls_option</code></em> 値を指定する <code class="literal">REQUIRE</code> 句を使用します。
        </p><p>
          <code class="literal">REQUIRE</code> オプションの順序は関係ありませんが、オプションを 2 回指定することはできません。 <code class="literal">AND</code> キーワードは、<code class="literal">REQUIRE</code> オプション間のオプションです。 
        </p><p>
          <code class="literal">ALTER USER</code> では、次の <em class="replaceable"><code>tls_option</code></em> 値が許可されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">NONE</code>
            </p><p>
              ステートメントで指定されたすべてのアカウントに SSL または X.509 要件がないことを示します。 ユーザー名とパスワードが有効であれば、暗号化されていない接続が許可されます。 クライアントに適切な証明書および鍵ファイルがある場合は、クライアントオプションで暗号化された接続を使用できます。 
            </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost' REQUIRE NONE;
</pre><p>
              クライアントは、デフォルトでセキュアな接続を確立しようとします。 <code class="literal">REQUIRE NONE</code> を持つクライアントでは、セキュアな接続を確立できない場合、接続試行は暗号化されていない接続にフォールバックされます。 暗号化された接続を要求するには、クライアントは <code class="option">--ssl-mode=REQUIRED</code> オプションのみを指定する必要があります。セキュアな接続を確立できない場合、接続の試行は失敗します。 
            </p></li><li class="listitem"><p>
              <code class="literal">SSL</code>
            </p><p>
              ステートメントで指定されたすべてのアカウントに対して暗号化された接続のみを許可するようにサーバーに指示します。
            </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost' REQUIRE SSL;
</pre><p>
              クライアントは、デフォルトでセキュアな接続を確立しようとします。 <code class="literal">REQUIRE SSL</code> を持つアカウントでは、セキュアな接続を確立できない場合、接続の試行は失敗します。 
            </p></li><li class="listitem"><p>
              <code class="literal">X509</code>
            </p><p>
              ステートメントで指定されたすべてのアカウントについて、クライアントは有効な証明書を提示する必要がありますが、正確な証明書、発行者およびサブジェクトは関係ありません。 唯一の要件は、いずれかの CA 証明書でその署名を検証できるべきであるということです。 X.509 証明書の使用は常に暗号化を意味するため、この場合は <code class="literal">SSL</code> オプションは必要ありません。 
            </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost' REQUIRE X509;
</pre><p>
              <code class="literal">REQUIRE X509</code> のアカウントの場合、クライアントは接続する <code class="option">--ssl-key</code> および <code class="option">--ssl-cert</code> オプションを指定する必要があります。 (サーバーによって提供される公開証明書を検証できるように、<code class="option">--ssl-ca</code> も指定することをお薦めしますが、必須ではありません。) これらの <code class="literal">REQUIRE</code> オプションは <code class="literal">X509</code> の要件を意味するため、これは <code class="literal">ISSUER</code> および <code class="literal">SUBJECT</code> にも当てはまります。 
            </p></li><li class="listitem"><p>
              <code class="literal">ISSUER '<em class="replaceable"><code>issuer</code></em>'</code>
            </p><p>
              ステートメントで指定されたすべてのアカウントについて、CA <code class="literal">'<em class="replaceable"><code>issuer</code></em>'</code>によって発行された有効な X.509 証明書をクライアントが提示する必要があります。 クライアントが有効だが発行者が異なる証明書を提示した場合、サーバーは接続を拒否します。 X.509 証明書の使用は常に暗号化を意味するため、この場合は <code class="literal">SSL</code> オプションは必要ありません。 
            </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost'
  REQUIRE ISSUER '/C=SE/ST=Stockholm/L=Stockholm/
    O=MySQL/CN=CA/emailAddress=ca@example.com';
</pre><p>
              <code class="literal">ISSUER</code> には <code class="literal">X509</code> の要件があるため、クライアントは接続するために <code class="option">--ssl-key</code> および <code class="option">--ssl-cert</code> オプションを指定する必要があります。 (サーバーによって提供される公開証明書を検証できるように、<code class="option">--ssl-ca</code> も指定することをお薦めしますが、必須ではありません。) 
            </p></li><li class="listitem"><p>
              <code class="literal">SUBJECT '<em class="replaceable"><code>subject</code></em>'</code>
            </p><p>
              ステートメントで指定されたすべてのアカウントについて、クライアントがサブジェクト <em class="replaceable"><code>subject</code></em> を含む有効な X.509 証明書を提示する必要があります。 クライアントが有効だがサブジェクトが異なる証明書を提示した場合、サーバーは接続を拒否します。 X.509 証明書の使用は常に暗号化を意味するため、この場合は <code class="literal">SSL</code> オプションは必要ありません。 
            </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost'
  REQUIRE SUBJECT '/C=SE/ST=Stockholm/L=Stockholm/
    O=MySQL demo client certificate/
    CN=client/emailAddress=client@example.com';
</pre><p>
              MySQL では、<code class="literal">'<em class="replaceable"><code>subject</code></em>'</code>値と証明書の値との単純な文字列比較が行われるため、大文字と小文字およびコンポーネントの順序は、証明書に存在するものとまったく同じにする必要があります。
            </p><p>
              <code class="literal">SUBJECT</code> には <code class="literal">X509</code> の要件があるため、クライアントは接続するために <code class="option">--ssl-key</code> および <code class="option">--ssl-cert</code> オプションを指定する必要があります。 (サーバーによって提供される公開証明書を検証できるように、<code class="option">--ssl-ca</code> も指定することをお薦めしますが、必須ではありません。) 
            </p></li><li class="listitem"><p>
              <code class="literal">CIPHER '<em class="replaceable"><code>cipher</code></em>'</code>
            </p><p>
              ステートメントで指定されたすべてのアカウントには、接続を暗号化するための特定の暗号メソッドが必要です。 このオプションは、十分な強度の暗号およびキー長が使用されるようにするために必要です。 短い暗号化キーを使用する古いアルゴリズムを使用すると、暗号化が弱くなる可能性があります。 
            </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost'
  REQUIRE CIPHER 'EDH-RSA-DES-CBC3-SHA';
</pre></li></ul></div><p>
          <code class="literal">SUBJECT</code>、<code class="literal">ISSUER</code> および <code class="literal">CIPHER</code> オプションは、<code class="literal">REQUIRE</code> 句で組み合せることができます:
        </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost'
  REQUIRE SUBJECT '/C=SE/ST=Stockholm/L=Stockholm/
    O=MySQL demo client certificate/
    CN=client/emailAddress=client@example.com'
  AND ISSUER '/C=SE/ST=Stockholm/L=Stockholm/
    O=MySQL/CN=CA/emailAddress=ca@example.com'
  AND CIPHER 'EDH-RSA-DES-CBC3-SHA';
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="alter-user-resource-limits"></a>ALTER USER リソース制限オプション</h5></div></div></div><a class="indexterm" name="idm45826991862096"></a><a class="indexterm" name="idm45826991859952"></a><p>
          <a class="xref" href="security.html#user-resources" title="6.2.20 アカウントリソース制限の設定">セクション6.2.20「アカウントリソース制限の設定」</a> で説明されているように、アカウントによるサーバーリソースの使用に制限を設定できます。 そのためには、1 つ以上の <em class="replaceable"><code>resource_option</code></em> 値を指定する <code class="literal">WITH</code> 句を使用します。 
        </p><p>
          <code class="literal">WITH</code> オプションの順序は重要ではありませんが、特定のリソース制限が複数回指定された場合は、最後のインスタンスが優先されます。
        </p><p>
          <code class="literal">ALTER USER</code> では、次の <em class="replaceable"><code>resource_option</code></em> 値が許可されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">MAX_QUERIES_PER_HOUR <em class="replaceable"><code>count</code></em></code>, <code class="literal">MAX_UPDATES_PER_HOUR <em class="replaceable"><code>count</code></em></code>, <code class="literal">MAX_CONNECTIONS_PER_HOUR <em class="replaceable"><code>count</code></em></code>
            </p><p>
              ステートメントで指定されたすべてのアカウントについて、これらのオプションは、特定の 1 時間の間に各アカウントに許可されるクエリー、更新、およびサーバーへの接続の数を制限します。 <em class="replaceable"><code>count</code></em> が <code class="literal">0</code> (デフォルト) である場合、これは、このアカウントに対する制限が存在しないことを示します。 
            </p></li><li class="listitem"><p>
              <code class="literal">MAX_USER_CONNECTIONS <em class="replaceable"><code>count</code></em></code>
            </p><p>
              ステートメントで指定されたすべてのアカウントについて、各アカウントによるサーバーへの同時接続の最大数を制限します。 0 以外の <em class="replaceable"><code>count</code></em> は、このアカウントに対する制限を明示的に指定します。 <em class="replaceable"><code>count</code></em> が <code class="literal">0</code> (デフォルト) である場合、サーバーは、<code class="literal">max_user_connections</code> システム変数のグローバル値からこのアカウントの同時接続の数を決定します。 <code class="literal">max_user_connections</code> もゼロである場合は、アカウントに制限がありません。 
            </p></li></ul></div><p>
          例:
        </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost'
  WITH MAX_QUERIES_PER_HOUR 500 MAX_UPDATES_PER_HOUR 100;
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="alter-user-password-management"></a>ALTER USER のパスワード管理オプション</h5></div></div></div><p>
          <code class="literal">ALTER USER</code> では、パスワード管理用にいくつかの <em class="replaceable"><code>password_option</code></em> 値がサポートされています:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              パスワードの有効期限オプション: アカウントパスワードを手動で期限切れにし、そのパスワード有効期限ポリシーを設定できます。 ポリシーオプションによってパスワードが期限切れになることはありません。 代わりに、最新のアカウントパスワード変更の日時から評価されるパスワード有効期限に基づいて、サーバーがアカウントに自動期限切れを適用する方法を決定します。 
            </p></li><li class="listitem"><p>
              パスワード再利用オプション: パスワードの再利用は、パスワード変更の数、経過時間、またはその両方に基づいて制限できます。
            </p></li><li class="listitem"><p>
              パスワード検証必須オプション: 変更しようとしているユーザーが実際に現在のパスワードを認識していることを確認するために、アカウントパスワードの変更を試行する際に現在のパスワードを指定する必要があるかどうかを指定できます。
            </p></li><li class="listitem"><p>
              不正解 - パスワード失敗 - ログイントラッキングオプション: サーバーが失敗したログイン試行を追跡し、連続して正しくないパスワードが多すぎるアカウントを一時的にロックするようにすることができます。 必要な失敗数とロック時間は構成可能です。 
            </p></li></ul></div><p>
          このセクションでは、パスワード管理オプションの構文について説明します。 パスワード管理のポリシーの確立の詳細は、<a class="xref" href="security.html#password-management" title="6.2.15 パスワード管理">セクション6.2.15「パスワード管理」</a> を参照してください。 
        </p><p>
          特定のタイプの複数のパスワード管理オプションが指定されている場合は、最後のオプションが優先されます。 たとえば、<code class="literal">PASSWORD EXPIRE DEFAULT PASSWORD EXPIRE NEVER</code> は <code class="literal">PASSWORD EXPIRE NEVER</code> と同じです。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            失敗したログイン追跡に関連するオプションを除き、パスワード管理オプションは、資格証明を MySQL に内部的に格納する認証プラグインを使用するアカウントにのみ適用されます。 MySQL の外部にある資格証明システムに対して認証を実行するプラグインを使用するアカウントの場合、パスワード管理もそのシステムに対して外部で処理する必要があります。 内部資格証明記憶域の詳細は、<a class="xref" href="security.html#password-management" title="6.2.15 パスワード管理">セクション6.2.15「パスワード管理」</a> を参照してください。 
          </p></div><p>
          アカウントパスワードが手動で期限切れになった場合、または自動期限切れポリシーに従ってパスワードの有効期間が許可された存続期間を超えたとみなされた場合、クライアントには期限切れのパスワードがあります。 この場合、サーバーはクライアントを切断するか、クライアントに許可されている操作を制限します (<a class="xref" href="security.html#expired-password-handling" title="6.2.16 期限切れパスワードのサーバー処理">セクション6.2.16「期限切れパスワードのサーバー処理」</a> を参照)。 制限付きクライアントによって実行される操作は、ユーザーが新しいアカウントパスワードを確立するまでエラーになります。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            期限切れのパスワードは、現在の値に設定することで <span class="quote">「<span class="quote">reset</span>」</span> で使用できますが、適切なポリシーとして、別のパスワードを選択することをお薦めします。 DBA は、適切なパスワード再利用ポリシーを確立することで、非キューを強制できます。 <a class="xref" href="security.html#password-reuse-policy" title="パスワード再利用ポリシー">パスワード再利用ポリシー</a>を参照してください。 
          </p></div><p>
          <code class="literal">ALTER USER</code> では、パスワードの有効期限を制御するために次の <em class="replaceable"><code>password_option</code></em> 値が許可されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">PASSWORD EXPIRE</code>
            </p><p>
              ステートメントで指定されたすべてのアカウントのパスワードをすぐに期限切れとしてマークします。
            </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost' PASSWORD EXPIRE;
</pre></li><li class="listitem"><p>
              <code class="literal">PASSWORD EXPIRE DEFAULT</code>
            </p><p>
              <code class="literal">default_password_lifetime</code> システム変数で指定されたグローバル有効期限ポリシーが適用されるように、ステートメントで指定されたすべてのアカウントを設定します。
            </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost' PASSWORD EXPIRE DEFAULT;
</pre></li><li class="listitem"><p>
              <code class="literal">PASSWORD EXPIRE NEVER</code>
            </p><p>
              この有効期限オプションは、ステートメントで指定されたすべてのアカウントのグローバルポリシーをオーバーライドします。 それぞれについて、パスワードの有効期限が切れないようにパスワードの有効期限を無効にします。 
            </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost' PASSWORD EXPIRE NEVER;
</pre></li><li class="listitem"><p>
              <code class="literal">PASSWORD EXPIRE INTERVAL <em class="replaceable"><code>N</code></em> DAY</code>
            </p><p>
              この有効期限オプションは、ステートメントで指定されたすべてのアカウントのグローバルポリシーをオーバーライドします。 それぞれについて、パスワードの存続期間が <em class="replaceable"><code>N</code></em> 日に設定されます。 次のステートメントでは、180 日ごとにパスワードを変更する必要があります: 
            </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost' PASSWORD EXPIRE INTERVAL 180 DAY;
</pre></li></ul></div><p>
          <code class="literal">ALTER USER</code> では、必要な最小パスワード変更数に基づいて以前のパスワードの再利用を制御するために、次の <em class="replaceable"><code>password_option</code></em> 値が許可されています:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">PASSWORD HISTORY DEFAULT</code>
            </p><p>
              <code class="literal">password_history</code> システム変数で指定された変更数の前にパスワードの再利用を禁止するために、パスワード履歴の長さに関するグローバルポリシーが適用されるように、ステートメントで指定されたすべてのアカウントを設定します。
            </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost' PASSWORD HISTORY DEFAULT;
</pre></li><li class="listitem"><p>
              <code class="literal">PASSWORD HISTORY <em class="replaceable"><code>N</code></em></code>
            </p><p>
              この履歴長オプションは、ステートメントで指定されたすべてのアカウントのグローバルポリシーをオーバーライドします。 それぞれについて、最近選択した <em class="replaceable"><code>N</code></em> パスワードの再利用を禁止するために、パスワード履歴の長さを <em class="replaceable"><code>N</code></em> パスワードに設定します。 次のステートメントは、以前の 6 つのパスワードの再利用を禁止します: 
            </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost' PASSWORD HISTORY 6;
</pre></li></ul></div><p>
          <code class="literal">ALTER USER</code> では、経過時間に基づいて以前のパスワードの再利用を制御するために、次の <em class="replaceable"><code>password_option</code></em> 値が許可されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">PASSWORD REUSE INTERVAL DEFAULT</code>
            </p><p>
              経過時間に関するグローバルポリシーが適用され、<code class="literal">password_reuse_interval</code> システム変数で指定された日数よりも新しいパスワードの再利用が禁止されるように、アカウントで指定されたすべてのステートメントを設定します。
            </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost' PASSWORD REUSE INTERVAL DEFAULT;
</pre></li><li class="listitem"><p>
              <code class="literal">PASSWORD REUSE INTERVAL <em class="replaceable"><code>N</code></em> DAY</code>
            </p><p>
              この time-elapsed オプションは、ステートメントで指定されたすべてのアカウントのグローバルポリシーをオーバーライドします。 それぞれについて、パスワードの再利用間隔を <em class="replaceable"><code>N</code></em> 日に設定して、その日数より新しいパスワードの再利用を禁止します。 次のステートメントは、360 日間のパスワードの再利用を禁止します: 
            </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost' PASSWORD REUSE INTERVAL 360 DAY;
</pre></li></ul></div><p>
          <code class="literal">ALTER USER</code> では、アカウントパスワードの変更の試行で現在のパスワードを指定する必要があるかどうかを制御するために、変更しようとしているユーザーが実際に現在のパスワードを知っていることを確認するために、次の <em class="replaceable"><code>password_option</code></em> 値を許可しています:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">PASSWORD REQUIRE CURRENT</code>
            </p><p>
              この検証オプションは、ステートメントで指定されたすべてのアカウントのグローバルポリシーをオーバーライドします。 それぞれについて、パスワードの変更で現在のパスワードを指定する必要があります。 
            </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost' PASSWORD REQUIRE CURRENT;
</pre></li><li class="listitem"><p>
              <code class="literal">PASSWORD REQUIRE CURRENT OPTIONAL</code>
            </p><p>
              この検証オプションは、ステートメントで指定されたすべてのアカウントのグローバルポリシーをオーバーライドします。 それぞれについて、パスワードを変更して現在のパスワードを指定する必要はありません。 (現在のパスワードを指定する必要はありますが、指定する必要はありません。) 
            </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost' PASSWORD REQUIRE CURRENT OPTIONAL;
</pre></li><li class="listitem"><p>
              <code class="literal">PASSWORD REQUIRE CURRENT DEFAULT</code>
            </p><p>
              <code class="literal">password_require_current</code> システム変数で指定されたパスワード検証に関するグローバルポリシーが適用されるように、アカウントで指定されたすべてのステートメントを設定します。
            </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost' PASSWORD REQUIRE CURRENT DEFAULT;
</pre></li></ul></div><p>
          MySQL 8.0.19 の時点で、<code class="literal">ALTER USER</code> は、失敗したログイン追跡を制御するために次の <em class="replaceable"><code>password_option</code></em> 値を許可します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">FAILED_LOGIN_ATTEMPTS <em class="replaceable"><code>N</code></em></code>
            </p><p>
              不正なパスワードを指定するアカウントログイン試行を追跡するかどうか。 <em class="replaceable"><code>N</code></em> は 0 から 32767 の数値である必要があります。 値 0 を指定すると、失敗したログイントラッキングが無効になります。 0 より大きい値は、パスワードが何回連続して失敗したために一時アカウントがロックされるかを示します (<code class="literal">PASSWORD_LOCK_TIME</code> もゼロ以外の場合)。 
            </p></li><li class="listitem"><p>
              <code class="literal">PASSWORD_LOCK_TIME {<em class="replaceable"><code>N</code></em> | UNBOUNDED}</code>
            </p><p>
              連続して何度もログインを試行した後にアカウントをロックする期間。パスワードが正しくありません。 <em class="replaceable"><code>N</code></em> は、0 から 32767 の数値、または <code class="literal">UNBOUNDED</code> である必要があります。 値 0 を指定すると、一時アカウントロックが無効になります。 0 より大きい値は、アカウントをロックする期間を日数で示します。 値が <code class="literal">UNBOUNDED</code> の場合、アカウントのロック期間は無制限になります。ロックされると、アカウントはロック解除されるまでロック状態のままになります。 ロック解除が発生する条件の詳細は、<a class="xref" href="security.html#failed-login-tracking" title="失敗したログイントラッキングと一時アカウントロック">失敗したログイントラッキングと一時アカウントロック</a> を参照してください。 
            </p></li></ul></div><p>
          ログイン失敗トラッキングと一時ロックを実行するには、アカウントの <code class="literal">FAILED_LOGIN_ATTEMPTS</code> オプションと <code class="literal">PASSWORD_LOCK_TIME</code> オプションの両方をゼロ以外にする必要があります。 次のステートメントは、パスワードが 4 回連続して失敗した後も 2 日間ロックされたままになるようにアカウントを変更します: 
        </p><pre class="programlisting">ALTER USER 'jeffrey'@'localhost'
  FAILED_LOGIN_ATTEMPTS 4 PASSWORD_LOCK_TIME 2;
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="alter-user-account-locking"></a>ALTER USER アカウントロックオプション</h5></div></div></div><a class="indexterm" name="idm45826991744848"></a><p>
          MySQL では、アカウントのロック状態を指定する <code class="literal">ACCOUNT LOCK</code> および <code class="literal">ACCOUNT UNLOCK</code> オプションを使用したアカウントのロックおよびロック解除がサポートされています。 詳細は、<a class="xref" href="security.html#account-locking" title="6.2.19 アカウントロック">セクション6.2.19「アカウントロック」</a>を参照してください。 
        </p><p>
          複数の account-locking オプションが指定されている場合は、最後のオプションが優先されます。
        </p><p>
          MySQL 8.0.19 の時点では、ログインの失敗回数が多すぎるために一時的にロックされているステートメントで指定されたアカウントは、<code class="literal">ALTER USER ... UNLOCK</code> によってロック解除されます。 <a class="xref" href="security.html#password-management" title="6.2.15 パスワード管理">セクション6.2.15「パスワード管理」</a>を参照してください。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="alter-user-binary-logging"></a>ALTER USER バイナリロギング</h5></div></div></div><a class="indexterm" name="idm45826991735312"></a><p>
          <code class="literal">ALTER USER</code> は、成功した場合はバイナリログに書き込まれますが、失敗した場合は書き込まれません。その場合、ロールバックが発生し、変更は行われません。 バイナリログに書き込まれるステートメントには、指定されたすべてのユーザーが含まれます。 <code class="literal">IF EXISTS</code> 句が指定されている場合、これには存在せず、変更されなかったユーザーも含まれます。 
        </p><p>
          元のステートメントがユーザーの資格を変更した場合、バイナリログに書き込まれるステートメントは、そのユーザーに適用可能な認証プラグインを次のように指定します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              元のステートメントで指定されたプラグイン (指定されている場合)。
            </p></li><li class="listitem"><p>
              それ以外の場合は、ユーザーアカウントに関連付けられたプラグイン (ユーザーが存在する場合)、またはデフォルトの認証プラグイン (ユーザーが存在しない場合)。 (バイナリログに書き込まれたステートメントがユーザーの特定の認証プラグインを指定する必要がある場合は、それを元のステートメントに含めます。) 
            </p></li></ul></div><p>
          サーバーは、バイナリログに書き込まれたステートメント内の任意のユーザーのデフォルトの認証プラグインを追加すると、それらのユーザーを指定する警告をエラーログに書き込みます。
        </p><p>
          元のステートメントで <code class="literal">FAILED_LOGIN_ATTEMPTS</code> または <code class="literal">PASSWORD_LOCK_TIME</code> オプションが指定されている場合、バイナリログに書き込まれるステートメントにはそのオプションが含まれます。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="create-role"></a>13.7.1.2 CREATE ROLE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826991722240"></a><a class="indexterm" name="idm45826991720752"></a><a class="indexterm" name="idm45826991718720"></a><pre class="programlisting">CREATE ROLE [IF NOT EXISTS] <em class="replaceable"><code>role</code></em> [, <em class="replaceable"><code>role</code></em> ] ...
</pre><p>
        <code class="literal">CREATE ROLE</code> では、権限の名前付きコレクションである 1 つ以上のロールが作成されます。 このステートメントを使用するには、グローバル <code class="literal">CREATE ROLE</code> または <code class="literal">CREATE USER</code> 権限が必要です。 <code class="literal">read_only</code> システム変数が有効になっている場合、<code class="literal">CREATE ROLE</code> にはさらに <code class="literal">CONNECTION_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。 
      </p><p>
        作成されたロールはロックされ、パスワードがなく、デフォルトの認証プラグインが割り当てられます。 (これらのロール属性は、後で <code class="literal">ALTER USER</code> ステートメントを使用して、グローバル <code class="literal">CREATE USER</code> 権限を持つユーザーが変更できます。) 
      </p><p>
        <code class="literal">CREATE ROLE</code> は、すべての名前付きロールに対して成功するか、ロールバックされ、エラーが発生しても効果はありません。 デフォルトでは、すでに存在するロールを作成しようとするとエラーが発生します。 <code class="literal">IF NOT EXISTS</code> 句が指定されている場合、ステートメントは、エラーではなく、すでに存在する名前付きロールごとに警告を生成します。 
      </p><p>
        ステートメントが成功した場合はバイナリログに書き込まれますが、失敗した場合は書き込まれず、ロールバックが発生して変更は行われません。 バイナリログに書き込まれるステートメントには、すべての名前付き役割が含まれます。 <code class="literal">IF NOT EXISTS</code> 句が指定されている場合は、すでに存在していて作成されていないロールも含まれます。 
      </p><p>
        各ロール名は、<a class="xref" href="security.html#role-names" title="6.2.5 ロール名の指定">セクション6.2.5「ロール名の指定」</a> で説明されている形式を使用します。 例: 
      </p><pre class="programlisting">CREATE ROLE 'administrator', 'developer';
CREATE ROLE 'webapp'@'localhost';
</pre><p>
        ロール名のホスト名部分は、省略すると<code class="literal">'%'</code>にデフォルト設定されます。
      </p><p>
        ロールの使用例は、<a class="xref" href="security.html#roles" title="6.2.10 ロールの使用">セクション6.2.10「ロールの使用」</a> を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="create-user"></a>13.7.1.3 CREATE USER ステートメント</h4></div></div></div><a class="indexterm" name="idm45826991690976"></a><a class="indexterm" name="idm45826991689488"></a><a class="indexterm" name="idm45826991687424"></a><pre class="programlisting">CREATE USER [IF NOT EXISTS]
    <em class="replaceable"><code>user</code></em> [<em class="replaceable"><code>auth_option</code></em>] [, <em class="replaceable"><code>user</code></em> [<em class="replaceable"><code>auth_option</code></em>]] ...
    DEFAULT ROLE <em class="replaceable"><code>role</code></em> [, <em class="replaceable"><code>role</code></em> ] ...
    [REQUIRE {NONE | <em class="replaceable"><code>tls_option</code></em> [[AND] <em class="replaceable"><code>tls_option</code></em>] ...}]
    [WITH <em class="replaceable"><code>resource_option</code></em> [<em class="replaceable"><code>resource_option</code></em>] ...]
    [<em class="replaceable"><code>password_option</code></em> | <em class="replaceable"><code>lock_option</code></em>] ...
    [COMMENT '<em class="replaceable"><code>comment_string</code></em>' | ATTRIBUTE '<em class="replaceable"><code>json_object</code></em>']

<em class="replaceable"><code>user</code></em>:
    (see <a class="xref" href="security.html#account-names" title="6.2.4 アカウント名の指定">セクション6.2.4「アカウント名の指定」</a>)

<em class="replaceable"><code>auth_option</code></em>: {
    IDENTIFIED BY '<em class="replaceable"><code>auth_string</code></em>'
  | IDENTIFIED BY RANDOM PASSWORD
  | IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em>
  | IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em> BY '<em class="replaceable"><code>auth_string</code></em>'
  | IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em> BY RANDOM PASSWORD
  | IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em> AS '<em class="replaceable"><code>auth_string</code></em>'
}

<em class="replaceable"><code>tls_option</code></em>: {
   SSL
 | X509
 | CIPHER '<em class="replaceable"><code>cipher</code></em>'
 | ISSUER '<em class="replaceable"><code>issuer</code></em>'
 | SUBJECT '<em class="replaceable"><code>subject</code></em>'
}

<em class="replaceable"><code>resource_option</code></em>: {
    MAX_QUERIES_PER_HOUR <em class="replaceable"><code>count</code></em>
  | MAX_UPDATES_PER_HOUR <em class="replaceable"><code>count</code></em>
  | MAX_CONNECTIONS_PER_HOUR <em class="replaceable"><code>count</code></em>
  | MAX_USER_CONNECTIONS <em class="replaceable"><code>count</code></em>
}

<em class="replaceable"><code>password_option</code></em>: {
    PASSWORD EXPIRE [DEFAULT | NEVER | INTERVAL <em class="replaceable"><code>N</code></em> DAY]
  | PASSWORD HISTORY {DEFAULT | <em class="replaceable"><code>N</code></em>}
  | PASSWORD REUSE INTERVAL {DEFAULT | <em class="replaceable"><code>N</code></em> DAY}
  | PASSWORD REQUIRE CURRENT [DEFAULT | OPTIONAL]
  | FAILED_LOGIN_ATTEMPTS <em class="replaceable"><code>N</code></em>
  | PASSWORD_LOCK_TIME {<em class="replaceable"><code>N</code></em> | UNBOUNDED}
}

<em class="replaceable"><code>lock_option</code></em>: {
    ACCOUNT LOCK
  | ACCOUNT UNLOCK
}
</pre><p>
        <code class="literal">CREATE USER</code> ステートメントは、新しい MySQL アカウントを作成します。 これにより、認証、ロール、SSL/TLS、リソース制限およびパスワード管理プロパティを新しいアカウントに対して確立できます。 また、アカウントを最初にロックするかロック解除するかも制御します。 
      </p><p>
        <code class="literal">CREATE USER</code> を使用するには、<code class="literal">mysql</code> システムスキーマに対するグローバル <code class="literal">CREATE USER</code> 権限または <code class="literal">INSERT</code> 権限が必要です。 <code class="literal">read_only</code> システム変数が有効になっている場合、<code class="literal">CREATE USER</code> にはさらに <code class="literal">CONNECTION_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。 
      </p><p>
        MySQL 8.0.22 では、作成するアカウントの名前がストアドオブジェクトの <code class="literal">DEFINER</code> 属性として指定されている場合、<code class="literal">CREATE USER</code> はエラーで失敗します。 (つまり、アカウントを作成すると、アカウントが現在孤立しているストアドオブジェクトを採用する場合、ステートメントは失敗します。) 操作を実行するには、<code class="literal">SET_USER_ID</code> 権限が必要です。この場合、ステートメントはエラーで失敗するのではなく、警告付きで成功します。 <code class="literal">SET_USER_ID</code> がない場合、ユーザー作成操作を実行するには、孤立したオブジェクトを削除し、アカウントを作成してその権限を付与してから、削除したオブジェクトを再作成します。 特定のアカウントを <code class="literal">DEFINER</code> 属性として指定するオブジェクトの識別方法などの追加情報は、<a class="xref" href="stored-objects.html#stored-objects-security-orphan-objects" title="孤立したストアドオブジェクト">孤立したストアドオブジェクト</a> を参照してください。 
      </p><p>
        <code class="literal">CREATE USER</code> は、指定されたすべてのユーザーに対して成功するか、ロールバックされ、エラーが発生しても効果はありません。 デフォルトでは、すでに存在するユーザーを作成しようとするとエラーが発生します。 <code class="literal">IF NOT EXISTS</code> 句が指定されている場合、ステートメントは、エラーではなく、すでに存在する名前付きユーザーごとに警告を生成します。 
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          状況によっては、<code class="literal">CREATE USER</code> がサーバーログ、またはクライアント側にある <code class="filename">~/.mysql_history</code> などの履歴ファイル内に記録されることがあります。つまり、平文のパスワードが、その情報に対する読み取りアクセス権を持つ任意のユーザーによって読み取られる可能性があります。 これがサーバーログで発生する条件およびこれを制御する方法については、<a class="xref" href="security.html#password-logging" title="6.1.2.3 パスワードおよびロギング">セクション6.1.2.3「パスワードおよびロギング」</a>を参照してください。 クライアント側のロギングに関する同様の情報については、<a class="xref" href="programs.html#mysql-logging" title="4.5.1.3 mysql クライアントロギング">セクション4.5.1.3「mysql クライアントロギング」</a>を参照してください。 
        </p></div><p>
        次のトピックで説明するように、<code class="literal">CREATE USER</code> ステートメントにはいくつかの側面があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#create-user-overview" title="CREATE USER の概要">CREATE USER の概要</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-user-authentication" title="CREATE USER 認証オプション">CREATE USER 認証オプション</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-user-role" title="CREATE USER ロールのオプション">CREATE USER ロールのオプション</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-user-tls" title="CREATE USER SSL/TLS オプション">CREATE USER SSL/TLS オプション</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-user-resource-limits" title="CREATE USER リソース制限オプション">CREATE USER リソース制限オプション</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-user-password-management" title="CREATE USER のパスワード管理オプション">CREATE USER のパスワード管理オプション</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-user-account-locking" title="CREATE USER アカウントロックオプション">CREATE USER アカウントロックオプション</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#create-user-binary-logging" title="CREATE USER バイナリロギング">CREATE USER バイナリロギング</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="create-user-overview"></a>CREATE USER の概要</h5></div></div></div><p>
          <code class="literal">CREATE USER</code> では、アカウントごとに <code class="literal">mysql.user</code> システムテーブルに新しい行が作成されます。 アカウント行には、ステートメントで指定されたプロパティが反映されます。 未指定のプロパティはデフォルト値に設定されます: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              認証: <code class="literal">default_authentication_plugin</code> システム変数で定義された認証プラグインと空の資格証明
            </p></li><li class="listitem"><p>
              デフォルトロール: <code class="literal">NONE</code>
            </p></li><li class="listitem"><p>
              SSL/TLS: <code class="literal">NONE</code>
            </p></li><li class="listitem"><p>
              リソース制限: 無制限
            </p></li><li class="listitem"><p>
              パスワード管理: <code class="literal">PASSWORD EXPIRE DEFAULT PASSWORD HISTORY DEFAULT PASSWORD REUSE INTERVAL DEFAULT PASSWORD REQUIRE CURRENT DEFAULT</code>。ログイン失敗トラッキングおよび一時アカウントロックは無効です
            </p></li><li class="listitem"><p>
              アカウントのロック: <code class="literal">ACCOUNT UNLOCK</code>
            </p></li></ul></div><p>
          最初に作成されたアカウントには権限がなく、<code class="literal">NONE</code> のデフォルトロールがあります。 権限またはロールを割り当てるには、<code class="literal">GRANT</code> ステートメントを使用します。 
        </p><p>
          各アカウント名には、<a class="xref" href="security.html#account-names" title="6.2.4 アカウント名の指定">セクション6.2.4「アカウント名の指定」</a>で説明されている形式が使用されます。 例: 
        </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY '<em class="replaceable"><code>password</code></em>';
</pre><p>
          アカウント名のホスト名部分は、省略すると<code class="literal">'%'</code>にデフォルト設定されます。
        </p><p>
          アカウントを指定する各 <em class="replaceable"><code>user</code></em> 値の後に、アカウントの認証方法を示すオプションの <em class="replaceable"><code>auth_option</code></em> 値を続けることができます。 これらの値を使用すると、アカウント認証プラグインおよび資格証明 (パスワードなど) を指定できます。 各 <em class="replaceable"><code>auth_option</code></em> 値は、直前に指定されたアカウントに<span class="emphasis"><em>のみ</em></span>を適用します。 
        </p><p>
          <em class="replaceable"><code>user</code></em> 仕様に従って、ステートメントに SSL/TLS、リソース制限、パスワード管理およびロックプロパティのオプションを含めることができます。 このようなオプションはすべて、ステートメントに対する <span class="emphasis"><em>global</em></span> であり、ステートメントで指定された <span class="emphasis"><em>all</em></span> アカウントに適用されます。 
        </p><p>
          例: デフォルトの認証プラグインと指定されたパスワードを使用するアカウントを作成します。 ユーザーがサーバーへの最初の接続時に新しいパスワードを選択する必要があるように、パスワードを期限切れとしてマークします: 
        </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost'
  IDENTIFIED BY '<em class="replaceable"><code>new_password</code></em>' PASSWORD EXPIRE;
</pre><p>
          例: <code class="literal">caching_sha2_password</code> 認証プラグインと指定されたパスワードを使用するアカウントを作成します。 180 日ごとに新しいパスワードを選択し、ログイン失敗トラッキングを有効にする必要があります。これにより、次の 3 つのパスワードが連続して正しくないと、一時的なアカウントのロックが 2 日間発生します: 
        </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost'
  IDENTIFIED WITH caching_sha2_password BY '<em class="replaceable"><code>new_password</code></em>'
  PASSWORD EXPIRE INTERVAL 180 DAY
  FAILED_LOGIN_ATTEMPTS 3 PASSWORD_LOCK_TIME 2;
</pre><p>
          例: アカウントごとのプロパティとグローバルプロパティを指定して、複数のアカウントを作成します:
        </p><pre class="programlisting">CREATE USER
  'jeffrey'@'localhost' IDENTIFIED WITH mysql_native_password
                                   BY '<em class="replaceable"><code>new_password1</code></em>',
  'jeanne'@'localhost' IDENTIFIED WITH caching_sha2_password
                                  BY '<em class="replaceable"><code>new_password2</code></em>'
  REQUIRE X509 WITH MAX_QUERIES_PER_HOUR 60
  PASSWORD HISTORY 5
  ACCOUNT LOCK;
</pre><p>
          各 <em class="replaceable"><code>auth_option</code></em> 値 (この場合は <code class="literal">IDENTIFIED WITH ... BY</code>) は、直前に指定されたアカウントにのみ適用されるため、各アカウントはすぐ後の認証プラグインおよびパスワードを使用します。
        </p><p>
          残りのプロパティは、ステートメントで指定されたすべてのアカウントにグローバルに適用されるため、両方のアカウントについて次のようになります:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              有効な X.509 証明書を使用して接続する必要があります。
            </p></li><li class="listitem"><p>
              1 時間あたり最大 60 個のクエリーが許可されます。
            </p></li><li class="listitem"><p>
              パスワードの変更では、最新の 5 つのパスワードを再利用できません。
            </p></li><li class="listitem"><p>
              アカウントは最初にロックされるため、実質的にはプレースホルダであり、管理者がロックを解除するまで使用できません。
            </p></li></ul></div><p>
          MySQL 8.0.21 以降では、ここで説明するように、オプションでユーザーコメントまたはユーザー属性を持つユーザーを作成できます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <span class="bold"><strong>ユーザーコメント</strong></span>
            </p><p>
              ユーザーコメントを設定するには、<code class="literal">CREATE USER</code> ステートメントに <code class="literal">COMMENT '<em class="replaceable"><code>user_comment</code></em>'</code>を追加します。ここで、<em class="replaceable"><code>user_comment</code></em> はユーザーコメントのテキストです。
            </p><p>
              例 (他のオプションは省略):
            </p><pre class="programlisting">CREATE USER 'jon'@'localhost' COMMENT 'Some information about Jon';
</pre></li><li class="listitem"><p>
              <span class="bold"><strong>ユーザー属性</strong></span>
            </p><p>
              ユーザー属性は、1 つ以上のキーと値のペアで構成される JSON オブジェクトで、<code class="literal">ATTRIBUTE '<em class="replaceable"><code>json_object</code></em>'</code>を <code class="literal">CREATE USER</code> の一部として含めることによって設定されます。<em class="replaceable"><code>json_object</code></em> は有効な JSON オブジェクトである必要があります。
            </p><p>
              例 (他のオプションは省略):
            </p><pre class="programlisting">CREATE USER 'jim'@'localhost'
    ATTRIBUTE '{"fname": "James", "lname": "Scott", "phone": "123-456-7890"}';
</pre></li></ul></div><p>
          ユーザーコメントとユーザー属性は、<code class="literal">INFORMATION_SCHEMA.USER_ATTRIBUTES</code> テーブルの <code class="literal">ATTRIBUTE</code> カラムにまとめて格納されます。 このクエリーでは、ユーザー <code class="literal">jin@localhost</code> を作成するために示したステートメントによって挿入された次のテーブルの行が表示されます: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.USER_ATTRIBUTES</code></strong>
    -&gt;    <strong class="userinput"><code>WHERE USER = 'jim' AND HOST = 'localhost'\G</code></strong>
*************************** 1. row ***************************
     USER: jim
     HOST: localhost
ATTRIBUTE: {"fname": "James", "lname": "Scott", "phone": "123-456-7890"}
1 row in set (0.00 sec)
</pre><p>
          実際の <code class="literal">COMMENT</code> オプションは、キーとして <code class="literal">comment</code> のみを持ち、その値がオプションに指定された引数であるユーザー属性を設定するためのショートカットを提供します。 これを確認するには、<code class="literal">CREATE USER 'jon'@'localhost' COMMENT 'Some information about Jon'</code>ステートメントを実行し、<code class="literal">USER_ATTRIBUTES</code> テーブルに挿入される行を確認します: 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE USER 'jon'@'localhost' COMMENT 'Some information about Jon';</code></strong>
Query OK, 0 rows affected (0.06 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.USER_ATTRIBUTES</code></strong>
    -&gt;    <strong class="userinput"><code>WHERE USER = 'jon' AND HOST = 'localhost';</code></strong>
+------+-----------+-------------------------------------------+
| USER | HOST      | ATTRIBUTE                                 |
+------+-----------+-------------------------------------------+
| jon  | localhost | {"comment": "Some information about Jon"} |
+------+-----------+-------------------------------------------+
1 row in set (0.00 sec)
</pre><p>
          <code class="literal">COMMENT</code> と <code class="literal">ATTRIBUTE</code> を同じ <code class="literal">CREATE USER</code> ステートメントで一緒に使用することはできません。使用しようとすると、構文エラーが発生します。 ユーザー属性の設定と同時にユーザーコメントを設定するには、次のように <code class="literal">ATTRIBUTE</code> を使用して、その引数に <code class="literal">comment</code> キーを持つ値を含めます: 
        </p><pre class="programlisting">mysql&gt; CREATE USER 'bill'@'localhost'
    -&gt;        ATTRIBUTE '{"fname":"William", "lname":"Schmidt",
    -&gt;        "comment":"Website developer"}';
Query OK, 0 rows affected (0.16 sec)
</pre><p>
          <code class="literal">ATTRIBUTE</code> 行のコンテンツは JSON オブジェクトであるため、次に示すように、適切な MySQL JSON 関数または演算子を使用して操作できます:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT</code></strong>
    -&gt;   <strong class="userinput"><code>USER AS User,</code></strong>
    -&gt;   <strong class="userinput"><code>HOST AS Host,</code></strong>
    -&gt;   <strong class="userinput"><code>CONCAT(ATTRIBUTE-&gt;&gt;"$.fname"," ",ATTRIBUTE-&gt;&gt;"$.lname") AS 'Full Name',</code></strong>
    -&gt;   <strong class="userinput"><code>ATTRIBUTE-&gt;&gt;"$.comment" AS Comment</code></strong>
    -&gt; <strong class="userinput"><code>FROM INFORMATION_SCHEMA.USER_ATTRIBUTES</code></strong>
    -&gt; <strong class="userinput"><code>WHERE USER='bill' AND HOST='localhost';</code></strong>
+------+-----------+-----------------+-------------------+
| User | Host      | Full Name       | Comment           |
+------+-----------+-----------------+-------------------+
| bill | localhost | William Schmidt | Website developer |
+------+-----------+-----------------+-------------------+
1 row in set (0.00 sec)
</pre><p>
          既存のユーザーのユーザーコメントまたはユーザー属性を設定または変更するには、<code class="literal">ALTER USER</code> ステートメントで <code class="literal">COMMENT</code> または <code class="literal">ATTRIBUTE</code> オプションを使用できます。
        </p><p>
          ユーザーコメントとユーザー属性は単一の <code class="literal">JSON</code> カラムに内部的にまとめて格納されるため、これにより、最大結合サイズの上限が設定されます。詳細は、<a class="xref" href="data-types.html#data-types-storage-reqs-json" title="JSON 記憶域の要件">JSON 記憶域の要件</a> を参照してください。
        </p><p>
          詳細および例は、情報スキーマ <code class="literal">USER_ATTRIBUTES</code> テーブルの説明も参照してください。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="create-user-authentication"></a>CREATE USER 認証オプション</h5></div></div></div><p>
          アカウント名の後に、アカウント認証プラグインまたは資格証明 (あるいはその両方) を指定する <em class="replaceable"><code>auth_option</code></em> 認証オプションを続けることができます。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            ランダムパスワード生成の句は、資格証明を MySQL に内部的に格納する認証プラグインを使用するアカウントにのみ適用されます。 MySQL の外部にある資格証明システムに対して認証を実行するプラグインを使用するアカウントの場合、パスワード管理もそのシステムに対して外部で処理する必要があります。 内部資格証明記憶域の詳細は、<a class="xref" href="security.html#password-management" title="6.2.15 パスワード管理">セクション6.2.15「パスワード管理」</a> を参照してください。 
          </p></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <em class="replaceable"><code>auth_plugin</code></em> は、認証プラグインに名前を付けます。 プラグイン名は、引用符で囲まれた文字列リテラルまたは引用符で囲まれていない名前です。 プラグイン名は、<code class="literal">mysql.user</code> システムテーブルの <code class="literal">plugin</code> カラムに格納されます。 
            </p><p>
              認証プラグインを指定しない <em class="replaceable"><code>auth_option</code></em> 構文の場合、デフォルトのプラグインは <code class="literal">default_authentication_plugin</code> システム変数の値で示されます。 各プラグインの説明については、<a class="xref" href="security.html#authentication-plugins" title="6.4.1 認証プラグイン">セクション6.4.1「認証プラグイン」</a> を参照してください。 
            </p></li><li class="listitem"><p>
              内部的に格納される資格証明は、<code class="literal">mysql.user</code> システムテーブルに格納されます。 <code class="literal">'<em class="replaceable"><code>auth_string</code></em>'</code>値または <code class="literal">RANDOM PASSWORD</code> は、アカウント資格証明をクリアテキスト (暗号化されていない) 文字列として指定するか、アカウントに関連付けられた認証プラグインで想定される形式でハッシュします: 
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">BY '<em class="replaceable"><code>auth_string</code></em>'</code>を使用する構文の場合、文字列はクリアテキストであり、ハッシュ化のために認証プラグインに渡されます。 プラグインによって返される結果は、<code class="literal">mysql.user</code> テーブルに格納されます。 プラグインは、指定された値を使用できます。この場合、ハッシュは発生しません。 
                </p></li><li class="listitem"><p>
                  <code class="literal">BY RANDOM PASSWORD</code> を使用する構文の場合、MySQL はランダムパスワードをクリアテキストとして生成し、ハッシュ化のために認証プラグインに渡します。 プラグインによって返される結果は、<code class="literal">mysql.user</code> テーブルに格納されます。 プラグインは、指定された値を使用できます。この場合、ハッシュは発生しません。 
                </p><p>
                  ランダムに生成されたパスワードは、MySQL 8.0.18 で使用でき、<a class="xref" href="security.html#random-password-generation" title="ランダムパスワード生成">ランダムパスワード生成</a> で説明されている特性があります。
                </p></li><li class="listitem"><p>
                  <code class="literal">AS '<em class="replaceable"><code>auth_string</code></em>'</code>を使用する構文の場合、文字列はすでに認証プラグインに必要な形式であるとみなされ、<code class="literal">mysql.user</code> テーブルにそのまま格納されます。 プラグインにハッシュ値が必要な場合、その値はプラグインに適した形式ですでにハッシュされている必要があります。そうでない場合、プラグインはこの値を使用できず、クライアント接続の正しい認証は行われません。 
                </p><p>
                  MySQL 8.0.17 の時点では、ハッシュ文字列は文字列リテラルまたは 16 進数値のいずれかになります。 後者は、<code class="literal">print_identified_with_as_hex</code> システム変数が有効になっている場合に、印刷不可能な文字を含むパスワードハッシュに対して <code class="literal">SHOW CREATE USER</code> によって表示される値のタイプに対応します。 
                </p></li><li class="listitem"><p>
                  認証プラグインが認証文字列のハッシュを実行しない場合、<code class="literal">BY '<em class="replaceable"><code>auth_string</code></em>'</code>句と <code class="literal">AS '<em class="replaceable"><code>auth_string</code></em>'</code>句は同じ効果を持ちます: 認証文字列は、<code class="literal">mysql.user</code> システムテーブルにそのまま格納されます。
                </p></li></ul></div></li></ul></div><p>
          <code class="literal">CREATE USER</code> では、次の <em class="replaceable"><code>auth_option</code></em> 構文が許可されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">IDENTIFIED BY '<em class="replaceable"><code>auth_string</code></em>'</code>
            </p><p>
              アカウント認証プラグインをデフォルトプラグインに設定し、ハッシュ化のためにクリアテキストの<code class="literal">'<em class="replaceable"><code>auth_string</code></em>'</code>値をプラグインに渡し、その結果を <code class="literal">mysql.user</code> システムテーブルのアカウント行に格納します。
            </p></li><li class="listitem"><p>
              <code class="literal">IDENTIFIED BY RANDOM PASSWORD</code>
            </p><p>
              アカウント認証プラグインをデフォルトのプラグインに設定し、ランダムなパスワードを生成して、ハッシュ可能なプラグインにクリアテキストのパスワード値を渡し、その結果を <code class="literal">mysql.user</code> システムテーブルのアカウント行に格納します。 このステートメントは、ステートメントを実行しているユーザーまたはアプリケーションが使用できるように、クリアテキストのパスワードも結果セットに返します。 ランダムに生成されるパスワードの結果セットおよび特性の詳細は、<a class="xref" href="security.html#random-password-generation" title="ランダムパスワード生成">ランダムパスワード生成</a> を参照してください。 
            </p></li><li class="listitem"><p>
              <code class="literal">IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em></code>
            </p><p>
              アカウント認証プラグインを <em class="replaceable"><code>auth_plugin</code></em> に設定し、資格証明を空の文字列にクリアして、その結果を <code class="literal">mysql.user</code> システムテーブルのアカウント行に格納します。
            </p></li><li class="listitem"><p>
              <code class="literal">IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em> BY '<em class="replaceable"><code>auth_string</code></em>'</code>
            </p><p>
              アカウント認証プラグインを <em class="replaceable"><code>auth_plugin</code></em> に設定し、ハッシュ化のためにクリアテキストの<code class="literal">'<em class="replaceable"><code>auth_string</code></em>'</code>値をプラグインに渡し、その結果を <code class="literal">mysql.user</code> システムテーブルのアカウント行に格納します。
            </p></li><li class="listitem"><p>
              <code class="literal">IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em> BY RANDOM PASSWORD</code>
            </p><p>
              アカウント認証プラグインを <em class="replaceable"><code>auth_plugin</code></em> に設定し、ランダムパスワードを生成し、ハッシュ化のためにクリアテキストパスワード値をプラグインに渡し、その結果を <code class="literal">mysql.user</code> システムテーブルのアカウント行に格納します。 このステートメントは、ステートメントを実行しているユーザーまたはアプリケーションが使用できるように、クリアテキストのパスワードも結果セットに返します。 ランダムに生成されるパスワードの結果セットおよび特性の詳細は、<a class="xref" href="security.html#random-password-generation" title="ランダムパスワード生成">ランダムパスワード生成</a> を参照してください。 
            </p></li><li class="listitem"><p>
              <code class="literal">IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em> AS '<em class="replaceable"><code>auth_string</code></em>'</code>
            </p><p>
              アカウント認証プラグインを <em class="replaceable"><code>auth_plugin</code></em> に設定し、<code class="literal">'<em class="replaceable"><code>auth_string</code></em>'</code>値を <code class="literal">mysql.user</code> アカウント行にそのまま格納します。 プラグインにハッシュ文字列が必要な場合、文字列はプラグインに必要な形式ですでにハッシュされているとみなされます。 
            </p></li></ul></div><p>
          例: パスワードをクリアテキストで指定します。デフォルトのプラグインが使用されます:
        </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost'
  IDENTIFIED BY '<em class="replaceable"><code>password</code></em>';
</pre><p>
          例: 認証プラグインをクリアテキストのパスワード値とともに指定します:
        </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost'
  IDENTIFIED WITH mysql_native_password BY '<em class="replaceable"><code>password</code></em>';
</pre><p>
          いずれの場合も、アカウント行に格納されるパスワード値は、アカウントに関連付けられた認証プラグインによってハッシュされたあとのクリアテキスト値<code class="literal">'<em class="replaceable"><code>password</code></em>'</code>です。
        </p><p>
          パスワードと認証プラグインの設定の詳細は、<a class="xref" href="security.html#assigning-passwords" title="6.2.14 アカウントパスワードの割り当て">セクション6.2.14「アカウントパスワードの割り当て」</a>および<a class="xref" href="security.html#pluggable-authentication" title="6.2.17 プラガブル認証">セクション6.2.17「プラガブル認証」</a>を参照してください。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="create-user-role"></a>CREATE USER ロールのオプション</h5></div></div></div><a class="indexterm" name="idm45826991464560"></a><p>
          <code class="literal">DEFAULT ROLE</code> 句は、ユーザーがサーバーに接続して認証したとき、またはセッション中にユーザーが <code class="literal">SET ROLE DEFAULT</code> ステートメントを実行したときにアクティブになるロールを定義します。
        </p><p>
          各ロール名は、<a class="xref" href="security.html#role-names" title="6.2.5 ロール名の指定">セクション6.2.5「ロール名の指定」</a> で説明されている形式を使用します。 例: 
        </p><pre class="programlisting">CREATE USER 'joe'@'10.0.0.1' DEFAULT ROLE administrator, developer;
</pre><p>
          ロール名のホスト名部分は、省略すると<code class="literal">'%'</code>にデフォルト設定されます。
        </p><p>
          <code class="literal">DEFAULT ROLE</code> 句では、カンマ区切りのロール名のリストを使用できます。 これらのロールは、<code class="literal">CREATE USER</code> の実行時に存在する必要はありません。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="create-user-tls"></a>CREATE USER SSL/TLS オプション</h5></div></div></div><a class="indexterm" name="idm45826991452784"></a><a class="indexterm" name="idm45826991450560"></a><a class="indexterm" name="idm45826991448416"></a><p>
          MySQL では、ユーザー名と資格証明に基づく通常の認証に加えて、X.509 証明書属性をチェックできます。 MySQL での SSL/TLS の使用に関する背景情報は、<a class="xref" href="security.html#encrypted-connections" title="6.3 暗号化された接続の使用">セクション6.3「暗号化された接続の使用」</a> を参照してください。 
        </p><p>
          MySQL アカウントの SSL/TLS 関連オプションを指定するには、1 つ以上の <em class="replaceable"><code>tls_option</code></em> 値を指定する <code class="literal">REQUIRE</code> 句を使用します。
        </p><p>
          <code class="literal">REQUIRE</code> オプションの順序は関係ありませんが、オプションを 2 回指定することはできません。 <code class="literal">AND</code> キーワードは、<code class="literal">REQUIRE</code> オプション間のオプションです。 
        </p><p>
          <code class="literal">CREATE USER</code> では、次の <em class="replaceable"><code>tls_option</code></em> 値が許可されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">NONE</code>
            </p><p>
              ステートメントで指定されたすべてのアカウントに SSL または X.509 要件がないことを示します。 ユーザー名とパスワードが有効であれば、暗号化されていない接続が許可されます。 クライアントに適切な証明書および鍵ファイルがある場合は、クライアントオプションで暗号化された接続を使用できます。 
            </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost' REQUIRE NONE;
</pre><p>
              クライアントは、デフォルトでセキュアな接続を確立しようとします。 <code class="literal">REQUIRE NONE</code> を持つクライアントでは、セキュアな接続を確立できない場合、接続試行は暗号化されていない接続にフォールバックされます。 暗号化された接続を要求するには、クライアントは <code class="option">--ssl-mode=REQUIRED</code> オプションのみを指定する必要があります。セキュアな接続を確立できない場合、接続の試行は失敗します。 
            </p><p>
              SSL 関連の <code class="literal">REQUIRE</code> オプションが指定されていない場合、<code class="literal">NONE</code> がデフォルトです。
            </p></li><li class="listitem"><p>
              <code class="literal">SSL</code>
            </p><p>
              ステートメントで指定されたすべてのアカウントに対して暗号化された接続のみを許可するようにサーバーに指示します。
            </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost' REQUIRE SSL;
</pre><p>
              クライアントは、デフォルトでセキュアな接続を確立しようとします。 <code class="literal">REQUIRE SSL</code> を持つアカウントでは、セキュアな接続を確立できない場合、接続の試行は失敗します。 
            </p></li><li class="listitem"><p>
              <code class="literal">X509</code>
            </p><p>
              ステートメントで指定されたすべてのアカウントについて、クライアントは有効な証明書を提示する必要がありますが、正確な証明書、発行者およびサブジェクトは関係ありません。 唯一の要件は、いずれかの CA 証明書でその署名を検証できるべきであるということです。 X.509 証明書の使用は常に暗号化を意味するため、この場合は <code class="literal">SSL</code> オプションは必要ありません。 
            </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost' REQUIRE X509;
</pre><p>
              <code class="literal">REQUIRE X509</code> のアカウントの場合、クライアントは接続する <code class="option">--ssl-key</code> および <code class="option">--ssl-cert</code> オプションを指定する必要があります。 (サーバーによって提供される公開証明書を検証できるように、<code class="option">--ssl-ca</code> も指定することをお薦めしますが、必須ではありません。) これらの <code class="literal">REQUIRE</code> オプションは <code class="literal">X509</code> の要件を意味するため、これは <code class="literal">ISSUER</code> および <code class="literal">SUBJECT</code> にも当てはまります。 
            </p></li><li class="listitem"><p>
              <code class="literal">ISSUER '<em class="replaceable"><code>issuer</code></em>'</code>
            </p><p>
              ステートメントで指定されたすべてのアカウントについて、CA <code class="literal">'<em class="replaceable"><code>issuer</code></em>'</code>によって発行された有効な X.509 証明書をクライアントが提示する必要があります。 クライアントが有効だが発行者が異なる証明書を提示した場合、サーバーは接続を拒否します。 X.509 証明書の使用は常に暗号化を意味するため、この場合は <code class="literal">SSL</code> オプションは必要ありません。 
            </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost'
  REQUIRE ISSUER '/C=SE/ST=Stockholm/L=Stockholm/
    O=MySQL/CN=CA/emailAddress=ca@example.com';
</pre><p>
              <code class="literal">ISSUER</code> には <code class="literal">X509</code> の要件があるため、クライアントは接続するために <code class="option">--ssl-key</code> および <code class="option">--ssl-cert</code> オプションを指定する必要があります。 (サーバーによって提供される公開証明書を検証できるように、<code class="option">--ssl-ca</code> も指定することをお薦めしますが、必須ではありません。) 
            </p></li><li class="listitem"><p>
              <code class="literal">SUBJECT '<em class="replaceable"><code>subject</code></em>'</code>
            </p><p>
              ステートメントで指定されたすべてのアカウントについて、クライアントがサブジェクト <em class="replaceable"><code>subject</code></em> を含む有効な X.509 証明書を提示する必要があります。 クライアントが有効だがサブジェクトが異なる証明書を提示した場合、サーバーは接続を拒否します。 X.509 証明書の使用は常に暗号化を意味するため、この場合は <code class="literal">SSL</code> オプションは必要ありません。 
            </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost'
  REQUIRE SUBJECT '/C=SE/ST=Stockholm/L=Stockholm/
    O=MySQL demo client certificate/
    CN=client/emailAddress=client@example.com';
</pre><p>
              MySQL では、<code class="literal">'<em class="replaceable"><code>subject</code></em>'</code>値と証明書の値との単純な文字列比較が行われるため、大文字と小文字およびコンポーネントの順序は、証明書に存在するものとまったく同じにする必要があります。
            </p><p>
              <code class="literal">SUBJECT</code> には <code class="literal">X509</code> の要件があるため、クライアントは接続するために <code class="option">--ssl-key</code> および <code class="option">--ssl-cert</code> オプションを指定する必要があります。 (サーバーによって提供される公開証明書を検証できるように、<code class="option">--ssl-ca</code> も指定することをお薦めしますが、必須ではありません。) 
            </p></li><li class="listitem"><p>
              <code class="literal">CIPHER '<em class="replaceable"><code>cipher</code></em>'</code>
            </p><p>
              ステートメントで指定されたすべてのアカウントには、接続を暗号化するための特定の暗号メソッドが必要です。 このオプションは、十分な強度の暗号およびキー長が使用されるようにするために必要です。 短い暗号化キーを使用する古いアルゴリズムを使用すると、暗号化が弱くなる可能性があります。 
            </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost'
  REQUIRE CIPHER 'EDH-RSA-DES-CBC3-SHA';
</pre></li></ul></div><p>
          <code class="literal">SUBJECT</code>、<code class="literal">ISSUER</code> および <code class="literal">CIPHER</code> オプションは、<code class="literal">REQUIRE</code> 句で組み合せることができます:
        </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost'
  REQUIRE SUBJECT '/C=SE/ST=Stockholm/L=Stockholm/
    O=MySQL demo client certificate/
    CN=client/emailAddress=client@example.com'
  AND ISSUER '/C=SE/ST=Stockholm/L=Stockholm/
    O=MySQL/CN=CA/emailAddress=ca@example.com'
  AND CIPHER 'EDH-RSA-DES-CBC3-SHA';
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="create-user-resource-limits"></a>CREATE USER リソース制限オプション</h5></div></div></div><a class="indexterm" name="idm45826991381296"></a><a class="indexterm" name="idm45826991379152"></a><p>
          <a class="xref" href="security.html#user-resources" title="6.2.20 アカウントリソース制限の設定">セクション6.2.20「アカウントリソース制限の設定」</a> で説明されているように、アカウントによるサーバーリソースの使用に制限を設定できます。 そのためには、1 つ以上の <em class="replaceable"><code>resource_option</code></em> 値を指定する <code class="literal">WITH</code> 句を使用します。 
        </p><p>
          <code class="literal">WITH</code> オプションの順序は重要ではありませんが、特定のリソース制限が複数回指定された場合は、最後のインスタンスが優先されます。
        </p><p>
          <code class="literal">CREATE USER</code> では、次の <em class="replaceable"><code>resource_option</code></em> 値が許可されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">MAX_QUERIES_PER_HOUR <em class="replaceable"><code>count</code></em></code>, <code class="literal">MAX_UPDATES_PER_HOUR <em class="replaceable"><code>count</code></em></code>, <code class="literal">MAX_CONNECTIONS_PER_HOUR <em class="replaceable"><code>count</code></em></code>
            </p><p>
              ステートメントで指定されたすべてのアカウントについて、これらのオプションは、特定の 1 時間の間に各アカウントに許可されるクエリー、更新、およびサーバーへの接続の数を制限します。 <em class="replaceable"><code>count</code></em> が <code class="literal">0</code> (デフォルト) である場合、これは、このアカウントに対する制限が存在しないことを示します。 
            </p></li><li class="listitem"><p>
              <code class="literal">MAX_USER_CONNECTIONS <em class="replaceable"><code>count</code></em></code>
            </p><p>
              ステートメントで指定されたすべてのアカウントについて、各アカウントによるサーバーへの同時接続の最大数を制限します。 0 以外の <em class="replaceable"><code>count</code></em> は、このアカウントに対する制限を明示的に指定します。 <em class="replaceable"><code>count</code></em> が <code class="literal">0</code> (デフォルト) である場合、サーバーは、<code class="literal">max_user_connections</code> システム変数のグローバル値からこのアカウントの同時接続の数を決定します。 <code class="literal">max_user_connections</code> もゼロである場合は、アカウントに制限がありません。 
            </p></li></ul></div><p>
          例:
        </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost'
  WITH MAX_QUERIES_PER_HOUR 500 MAX_UPDATES_PER_HOUR 100;
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="create-user-password-management"></a>CREATE USER のパスワード管理オプション</h5></div></div></div><p>
          <code class="literal">CREATE USER</code> では、パスワード管理用にいくつかの <em class="replaceable"><code>password_option</code></em> 値がサポートされています:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              パスワードの有効期限オプション: アカウントパスワードを手動で期限切れにし、そのパスワード有効期限ポリシーを設定できます。 ポリシーオプションによってパスワードが期限切れになることはありません。 代わりに、最新のアカウントパスワード変更の日時から評価されるパスワード有効期限に基づいて、サーバーがアカウントに自動期限切れを適用する方法を決定します。 
            </p></li><li class="listitem"><p>
              パスワード再利用オプション: パスワードの再利用は、パスワード変更の数、経過時間、またはその両方に基づいて制限できます。
            </p></li><li class="listitem"><p>
              パスワード検証必須オプション: 変更しようとしているユーザーが実際に現在のパスワードを認識していることを確認するために、アカウントパスワードの変更を試行する際に現在のパスワードを指定する必要があるかどうかを指定できます。
            </p></li><li class="listitem"><p>
              不正解 - パスワード失敗 - ログイントラッキングオプション: サーバーが失敗したログイン試行を追跡し、連続して正しくないパスワードが多すぎるアカウントを一時的にロックするようにすることができます。 必要な失敗数とロック時間は構成可能です。 
            </p></li></ul></div><p>
          このセクションでは、パスワード管理オプションの構文について説明します。 パスワード管理のポリシーの確立の詳細は、<a class="xref" href="security.html#password-management" title="6.2.15 パスワード管理">セクション6.2.15「パスワード管理」</a> を参照してください。 
        </p><p>
          特定のタイプの複数のパスワード管理オプションが指定されている場合は、最後のオプションが優先されます。 たとえば、<code class="literal">PASSWORD EXPIRE DEFAULT PASSWORD EXPIRE NEVER</code> は <code class="literal">PASSWORD EXPIRE NEVER</code> と同じです。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            失敗したログイン追跡に関連するオプションを除き、パスワード管理オプションは、資格証明を MySQL に内部的に格納する認証プラグインを使用するアカウントにのみ適用されます。 MySQL の外部にある資格証明システムに対して認証を実行するプラグインを使用するアカウントの場合、パスワード管理もそのシステムに対して外部で処理する必要があります。 内部資格証明記憶域の詳細は、<a class="xref" href="security.html#password-management" title="6.2.15 パスワード管理">セクション6.2.15「パスワード管理」</a> を参照してください。 
          </p></div><p>
          アカウントパスワードが手動で期限切れになった場合、または自動期限切れポリシーに従ってパスワードの有効期間が許可された存続期間を超えたとみなされた場合、クライアントには期限切れのパスワードがあります。 この場合、サーバーはクライアントを切断するか、クライアントに許可されている操作を制限します (<a class="xref" href="security.html#expired-password-handling" title="6.2.16 期限切れパスワードのサーバー処理">セクション6.2.16「期限切れパスワードのサーバー処理」</a> を参照)。 制限付きクライアントによって実行される操作は、ユーザーが新しいアカウントパスワードを確立するまでエラーになります。 
        </p><p>
          <code class="literal">CREATE USER</code> では、パスワードの有効期限を制御するために次の <em class="replaceable"><code>password_option</code></em> 値が許可されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">PASSWORD EXPIRE</code>
            </p><p>
              ステートメントで指定されたすべてのアカウントのパスワードをすぐに期限切れとしてマークします。
            </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost' PASSWORD EXPIRE;
</pre></li><li class="listitem"><p>
              <code class="literal">PASSWORD EXPIRE DEFAULT</code>
            </p><p>
              <code class="literal">default_password_lifetime</code> システム変数で指定されたグローバル有効期限ポリシーが適用されるように、ステートメントで指定されたすべてのアカウントを設定します。
            </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost' PASSWORD EXPIRE DEFAULT;
</pre></li><li class="listitem"><p>
              <code class="literal">PASSWORD EXPIRE NEVER</code>
            </p><p>
              この有効期限オプションは、ステートメントで指定されたすべてのアカウントのグローバルポリシーをオーバーライドします。 それぞれについて、パスワードの有効期限が切れないようにパスワードの有効期限を無効にします。 
            </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost' PASSWORD EXPIRE NEVER;
</pre></li><li class="listitem"><p>
              <code class="literal">PASSWORD EXPIRE INTERVAL <em class="replaceable"><code>N</code></em> DAY</code>
            </p><p>
              この有効期限オプションは、ステートメントで指定されたすべてのアカウントのグローバルポリシーをオーバーライドします。 それぞれについて、パスワードの存続期間が <em class="replaceable"><code>N</code></em> 日に設定されます。 次のステートメントでは、180 日ごとにパスワードを変更する必要があります: 
            </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost' PASSWORD EXPIRE INTERVAL 180 DAY;
</pre></li></ul></div><p>
          <code class="literal">CREATE USER</code> では、必要な最小パスワード変更数に基づいて以前のパスワードの再利用を制御するために、次の <em class="replaceable"><code>password_option</code></em> 値が許可されています:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">PASSWORD HISTORY DEFAULT</code>
            </p><p>
              <code class="literal">password_history</code> システム変数で指定された変更数の前にパスワードの再利用を禁止するために、パスワード履歴の長さに関するグローバルポリシーが適用されるように、ステートメントで指定されたすべてのアカウントを設定します。
            </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost' PASSWORD HISTORY DEFAULT;
</pre></li><li class="listitem"><p>
              <code class="literal">PASSWORD HISTORY <em class="replaceable"><code>N</code></em></code>
            </p><p>
              この履歴長オプションは、ステートメントで指定されたすべてのアカウントのグローバルポリシーをオーバーライドします。 それぞれについて、最近選択した <em class="replaceable"><code>N</code></em> パスワードの再利用を禁止するために、パスワード履歴の長さを <em class="replaceable"><code>N</code></em> パスワードに設定します。 次のステートメントは、以前の 6 つのパスワードの再利用を禁止します: 
            </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost' PASSWORD HISTORY 6;
</pre></li></ul></div><p>
          <code class="literal">CREATE USER</code> では、経過時間に基づいて以前のパスワードの再利用を制御するために、次の <em class="replaceable"><code>password_option</code></em> 値が許可されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">PASSWORD REUSE INTERVAL DEFAULT</code>
            </p><p>
              経過時間に関するグローバルポリシーが適用され、<code class="literal">password_reuse_interval</code> システム変数で指定された日数よりも新しいパスワードの再利用が禁止されるように、アカウントで指定されたすべてのステートメントを設定します。
            </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost' PASSWORD REUSE INTERVAL DEFAULT;
</pre></li><li class="listitem"><p>
              <code class="literal">PASSWORD REUSE INTERVAL <em class="replaceable"><code>N</code></em> DAY</code>
            </p><p>
              この time-elapsed オプションは、ステートメントで指定されたすべてのアカウントのグローバルポリシーをオーバーライドします。 それぞれについて、パスワードの再利用間隔を <em class="replaceable"><code>N</code></em> 日に設定して、その日数より新しいパスワードの再利用を禁止します。 次のステートメントは、360 日間のパスワードの再利用を禁止します: 
            </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost' PASSWORD REUSE INTERVAL 360 DAY;
</pre></li></ul></div><p>
          <code class="literal">CREATE USER</code> では、アカウントパスワードの変更の試行で現在のパスワードを指定する必要があるかどうかを制御するために、変更しようとしているユーザーが実際に現在のパスワードを知っていることを確認するために、次の <em class="replaceable"><code>password_option</code></em> 値を許可しています:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">PASSWORD REQUIRE CURRENT</code>
            </p><p>
              この検証オプションは、ステートメントで指定されたすべてのアカウントのグローバルポリシーをオーバーライドします。 それぞれについて、パスワードの変更で現在のパスワードを指定する必要があります。 
            </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost' PASSWORD REQUIRE CURRENT;
</pre></li><li class="listitem"><p>
              <code class="literal">PASSWORD REQUIRE CURRENT OPTIONAL</code>
            </p><p>
              この検証オプションは、ステートメントで指定されたすべてのアカウントのグローバルポリシーをオーバーライドします。 それぞれについて、パスワードを変更して現在のパスワードを指定する必要はありません。 (現在のパスワードを指定する必要はありますが、指定する必要はありません。) 
            </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost' PASSWORD REQUIRE CURRENT OPTIONAL;
</pre></li><li class="listitem"><p>
              <code class="literal">PASSWORD REQUIRE CURRENT DEFAULT</code>
            </p><p>
              <code class="literal">password_require_current</code> システム変数で指定されたパスワード検証に関するグローバルポリシーが適用されるように、アカウントで指定されたすべてのステートメントを設定します。
            </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost' PASSWORD REQUIRE CURRENT DEFAULT;
</pre></li></ul></div><p>
          MySQL 8.0.19 の時点で、<code class="literal">CREATE USER</code> は、失敗したログイン追跡を制御するために次の <em class="replaceable"><code>password_option</code></em> 値を許可します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">FAILED_LOGIN_ATTEMPTS <em class="replaceable"><code>N</code></em></code>
            </p><p>
              不正なパスワードを指定するアカウントログイン試行を追跡するかどうか。 <em class="replaceable"><code>N</code></em> は 0 から 32767 の数値である必要があります。 値 0 を指定すると、失敗したログイントラッキングが無効になります。 0 より大きい値は、パスワードが何回連続して失敗したために一時アカウントがロックされるかを示します (<code class="literal">PASSWORD_LOCK_TIME</code> もゼロ以外の場合)。 
            </p></li><li class="listitem"><p>
              <code class="literal">PASSWORD_LOCK_TIME {<em class="replaceable"><code>N</code></em> | UNBOUNDED}</code>
            </p><p>
              連続して何度もログインを試行した後にアカウントをロックする期間。パスワードが正しくありません。 <em class="replaceable"><code>N</code></em> は、0 から 32767 の数値、または <code class="literal">UNBOUNDED</code> である必要があります。 値 0 を指定すると、一時アカウントロックが無効になります。 0 より大きい値は、アカウントをロックする期間を日数で示します。 値が <code class="literal">UNBOUNDED</code> の場合、アカウントのロック期間は無制限になります。ロックされると、アカウントはロック解除されるまでロック状態のままになります。 ロック解除が発生する条件の詳細は、<a class="xref" href="security.html#failed-login-tracking" title="失敗したログイントラッキングと一時アカウントロック">失敗したログイントラッキングと一時アカウントロック</a> を参照してください。 
            </p></li></ul></div><p>
          ログイン失敗トラッキングと一時ロックを実行するには、アカウントの <code class="literal">FAILED_LOGIN_ATTEMPTS</code> オプションと <code class="literal">PASSWORD_LOCK_TIME</code> オプションの両方をゼロ以外にする必要があります。 次のステートメントは、パスワードが 4 回連続して失敗した後も 2 日間ロックされたままになるアカウントを作成します: 
        </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost'
  FAILED_LOGIN_ATTEMPTS 4 PASSWORD_LOCK_TIME 2;
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="create-user-account-locking"></a>CREATE USER アカウントロックオプション</h5></div></div></div><a class="indexterm" name="idm45826991266720"></a><p>
          MySQL では、アカウントのロック状態を指定する <code class="literal">ACCOUNT LOCK</code> および <code class="literal">ACCOUNT UNLOCK</code> オプションを使用したアカウントのロックおよびロック解除がサポートされています。 詳細は、<a class="xref" href="security.html#account-locking" title="6.2.19 アカウントロック">セクション6.2.19「アカウントロック」</a>を参照してください。 
        </p><p>
          複数の account-locking オプションが指定されている場合は、最後のオプションが優先されます。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="create-user-binary-logging"></a>CREATE USER バイナリロギング</h5></div></div></div><a class="indexterm" name="idm45826991259872"></a><p>
          <code class="literal">CREATE USER</code> は、成功した場合はバイナリログに書き込まれますが、失敗した場合は書き込まれません。その場合、ロールバックが発生し、変更は行われません。 バイナリログに書き込まれるステートメントには、指定されたすべてのユーザーが含まれます。 <code class="literal">IF NOT EXISTS</code> 句が指定されている場合は、すでに存在していて作成されていないユーザーも含まれます。 
        </p><p>
          バイナリログに書き込まれるステートメントは、次のように決定される各ユーザーの認証プラグインを指定します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              元のステートメントで指定されたプラグイン (指定されている場合)。
            </p></li><li class="listitem"><p>
              それ以外の場合は、デフォルトの認証プラグイン。 特に、ユーザー <code class="literal">u1</code> がすでに存在し、デフォルト以外の認証プラグインを使用している場合、<code class="literal">CREATE USER IF NOT EXISTS u1</code> のバイナリログに書き込まれるステートメントはデフォルトの認証プラグインに名前を付けます。 (バイナリログに書き込まれたステートメントがユーザーのデフォルト以外の認証プラグインを指定する必要がある場合は、それを元のステートメントに含めます。) 
            </p></li></ul></div><p>
          サーバーは、バイナリログに書き込まれたステートメント内に存在しないユーザーのデフォルトの認証プラグインを追加すると、それらのユーザーを指定する警告をエラーログに書き込みます。
        </p><p>
          元のステートメントで <code class="literal">FAILED_LOGIN_ATTEMPTS</code> または <code class="literal">PASSWORD_LOCK_TIME</code> オプションが指定されている場合、バイナリログに書き込まれるステートメントにはそのオプションが含まれます。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="drop-role"></a>13.7.1.4 DROP ROLE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826991245152"></a><a class="indexterm" name="idm45826991243664"></a><a class="indexterm" name="idm45826991241632"></a><pre class="programlisting">DROP ROLE [IF EXISTS] <em class="replaceable"><code>role</code></em> [, <em class="replaceable"><code>role</code></em> ] ...
</pre><p>
        <code class="literal">DROP ROLE</code> により、1 つ以上のロール (権限の名前付きコレクション) が削除されます。 このステートメントを使用するには、グローバル <code class="literal">DROP ROLE</code> または <code class="literal">CREATE USER</code> 権限が必要です。 <code class="literal">read_only</code> システム変数が有効になっている場合、<code class="literal">DROP ROLE</code> にはさらに <code class="literal">CONNECTION_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。 
      </p><p>
        MySQL 8.0.16 では、<code class="literal">CREATE USER</code> 権限を持つユーザーはこのステートメントを使用して、ロックまたはロック解除されたアカウントを削除できます。 <code class="literal">DROP ROLE</code> 権限を持つユーザーは、このステートメントを使用して、ロックされているアカウントのみを削除できます (ロック解除されたアカウントは、ロールとしてではなく、サーバーへのログインに使用される可能性が高いユーザーアカウントです)。 
      </p><p>
        <code class="literal">mandatory_roles</code> システム変数値で指定されたロールは削除できません。
      </p><p>
        <code class="literal">DROP ROLE</code> は、すべての名前付きロールに対して成功するか、ロールバックされ、エラーが発生しても効果はありません。 デフォルトでは、存在しないロールを削除しようとすると、エラーが発生します。 <code class="literal">IF EXISTS</code> 句を指定すると、ステートメントは、存在しない名前付きロールごとにエラーではなく警告を生成します。 
      </p><p>
        ステートメントが成功した場合はバイナリログに書き込まれますが、失敗した場合は書き込まれず、ロールバックが発生して変更は行われません。 バイナリログに書き込まれるステートメントには、すべての名前付き役割が含まれます。 <code class="literal">IF EXISTS</code> 句が指定されている場合は、存在せず、削除されなかったロールも含まれます。 
      </p><p>
        各ロール名は、<a class="xref" href="security.html#role-names" title="6.2.5 ロール名の指定">セクション6.2.5「ロール名の指定」</a> で説明されている形式を使用します。 例: 
      </p><pre class="programlisting">DROP ROLE 'administrator', 'developer';
DROP ROLE 'webapp'@'localhost';
</pre><p>
        ロール名のホスト名部分は、省略すると<code class="literal">'%'</code>にデフォルト設定されます。
      </p><p>
        削除されたロールは、そのロールが付与されたユーザーアカウント (またはロール) から自動的に取り消されます。 このようなアカウントの現在のセッション内では、調整された権限は、次に実行されるステートメントから適用されます。 
      </p><p>
        ロールの使用例は、<a class="xref" href="security.html#roles" title="6.2.10 ロールの使用">セクション6.2.10「ロールの使用」</a> を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="drop-user"></a>13.7.1.5 DROP USER ステートメント</h4></div></div></div><a class="indexterm" name="idm45826991211040"></a><a class="indexterm" name="idm45826991209552"></a><a class="indexterm" name="idm45826991207520"></a><a class="indexterm" name="idm45826991205488"></a><a class="indexterm" name="idm45826991203568"></a><a class="indexterm" name="idm45826991201408"></a><a class="indexterm" name="idm45826991199488"></a><a class="indexterm" name="idm45826991197328"></a><a class="indexterm" name="idm45826991195408"></a><pre class="programlisting">DROP USER [IF EXISTS] <em class="replaceable"><code>user</code></em> [, <em class="replaceable"><code>user</code></em>] ...
</pre><p>
        <code class="literal">DROP USER</code> ステートメントは、1 つ以上の MySQL アカウントとその権限を削除します。 これにより、そのアカウントの権限行がすべての付与テーブルから削除されます。 
      </p><p>
        <code class="literal">mandatory_roles</code> システム変数値で指定されたロールは削除できません。
      </p><p>
        <code class="literal">DROP USER</code> を使用するには、<code class="literal">mysql</code> システムスキーマに対するグローバル <code class="literal">CREATE USER</code> 権限または <code class="literal">DELETE</code> 権限が必要です。 <code class="literal">read_only</code> システム変数が有効になっている場合、<code class="literal">DROP USER</code> にはさらに <code class="literal">CONNECTION_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。 
      </p><p>
        MySQL 8.0.22 では、削除するアカウントの名前がストアドオブジェクトの <code class="literal">DEFINER</code> 属性として指定されている場合、<code class="literal">DROP USER</code> はエラーで失敗します。 (つまり、アカウントを削除すると、格納されたオブジェクトが孤立する場合、ステートメントは失敗します。) 操作を実行するには、<code class="literal">SET_USER_ID</code> 権限が必要です。この場合、ステートメントはエラーで失敗するのではなく、警告付きで成功します。 特定のアカウントを <code class="literal">DEFINER</code> 属性として指定するオブジェクトの識別方法などの追加情報は、<a class="xref" href="stored-objects.html#stored-objects-security-orphan-objects" title="孤立したストアドオブジェクト">孤立したストアドオブジェクト</a> を参照してください。 
      </p><p>
        <code class="literal">DROP USER</code> は、指定されたすべてのユーザーに対して成功するか、ロールバックされ、エラーが発生しても効果はありません。 デフォルトでは、存在しないユーザーを削除しようとすると、エラーが発生します。 <code class="literal">IF EXISTS</code> 句を指定すると、ステートメントは、存在しない指定ユーザーごとに、エラーではなく、警告を生成します。 
      </p><p>
        ステートメントが成功した場合はバイナリログに書き込まれますが、失敗した場合は書き込まれず、ロールバックが発生して変更は行われません。 バイナリログに書き込まれるステートメントには、指定されたすべてのユーザーが含まれます。 <code class="literal">IF EXISTS</code> 句が指定されている場合、これには存在せず、削除されなかったユーザーも含まれます。 
      </p><p>
        各アカウント名には、<a class="xref" href="security.html#account-names" title="6.2.4 アカウント名の指定">セクション6.2.4「アカウント名の指定」</a>で説明されている形式が使用されます。 例: 
      </p><pre class="programlisting">DROP USER 'jeffrey'@'localhost';
</pre><p>
        アカウント名のホスト名部分は、省略すると<code class="literal">'%'</code>にデフォルト設定されます。
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          <code class="literal">DROP USER</code> は、開かれたどのユーザーセッションも自動的には閉じません。 さらに、開かれたセッションを持つユーザーが削除されても、このステートメントはそのユーザーのセッションが閉じられるまで有効になりません。 セッションがクローズされると、ユーザーは削除され、次回のログイン試行は失敗します。 <span class="emphasis"><em>これは意図的なものです</em></span>。 
        </p></div><p>
        <code class="literal">DROP USER</code> は、古いユーザーが作成したどのデータベースまたはそれらのデータベース内のどのオブジェクトも自動的には削除したり、無効にしたりしません。 これには、<code class="literal">DEFINER</code> 属性に削除されたユーザーが指定されているストアドプログラムまたはビューが含まれます。 このようなオブジェクトにアクセスしようとすると、それが定義者のセキュリティーコンテキストで実行された場合は、エラーが生成される可能性があります。 (セキュリティーコンテキストについては、<a class="xref" href="stored-objects.html#stored-objects-security" title="25.6 ストアドオブジェクトのアクセス制御">セクション25.6「ストアドオブジェクトのアクセス制御」</a>を参照してください。)  
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="grant"></a>13.7.1.6 GRANT ステートメント</h4></div></div></div><a class="indexterm" name="idm45826991154960"></a><a class="indexterm" name="idm45826991153488"></a><a class="indexterm" name="idm45826991152528"></a><a class="indexterm" name="idm45826991150384"></a><a class="indexterm" name="idm45826991149024"></a><a class="indexterm" name="idm45826991147104"></a><a class="indexterm" name="idm45826991144960"></a><pre class="programlisting">GRANT
    <em class="replaceable"><code>priv_type</code></em> [(<em class="replaceable"><code>column_list</code></em>)]
      [, <em class="replaceable"><code>priv_type</code></em> [(<em class="replaceable"><code>column_list</code></em>)]] ...
    ON [<em class="replaceable"><code>object_type</code></em>] <em class="replaceable"><code>priv_level</code></em>
    TO <em class="replaceable"><code>user_or_role</code></em> [, <em class="replaceable"><code>user_or_role</code></em>] ...
    [WITH GRANT OPTION]
    [AS <em class="replaceable"><code>user</code></em>
        [WITH ROLE
            DEFAULT
          | NONE
          | ALL
          | ALL EXCEPT <em class="replaceable"><code>role</code></em> [, <em class="replaceable"><code>role</code></em> ] ...
          | <em class="replaceable"><code>role</code></em> [, <em class="replaceable"><code>role</code></em> ] ...
        ]
    ]
}

GRANT PROXY ON <em class="replaceable"><code>user_or_role</code></em>
    TO <em class="replaceable"><code>user_or_role</code></em> [, <em class="replaceable"><code>user_or_role</code></em>] ...
    [WITH GRANT OPTION]

GRANT <em class="replaceable"><code>role</code></em> [, <em class="replaceable"><code>role</code></em>] ...
    TO <em class="replaceable"><code>user_or_role</code></em> [, <em class="replaceable"><code>user_or_role</code></em>] ...
    [WITH ADMIN OPTION]

<em class="replaceable"><code>object_type</code></em>: {
    TABLE
  | FUNCTION
  | PROCEDURE
}

<em class="replaceable"><code>priv_level</code></em>: {
    *
  | *.*
  | <em class="replaceable"><code>db_name</code></em>.*
  | <em class="replaceable"><code>db_name.tbl_name</code></em>
  | <em class="replaceable"><code>tbl_name</code></em>
  | <em class="replaceable"><code>db_name</code></em>.<em class="replaceable"><code>routine_name</code></em>
}

<em class="replaceable"><code>user_or_role</code></em>: {
    <em class="replaceable"><code>user</code></em> (see <a class="xref" href="security.html#account-names" title="6.2.4 アカウント名の指定">セクション6.2.4「アカウント名の指定」</a>)
  | <em class="replaceable"><code>role</code></em> (see <a class="xref" href="security.html#role-names" title="6.2.5 ロール名の指定">セクション6.2.5「ロール名の指定」</a>)
}
</pre><p>
        <code class="literal">GRANT</code> ステートメントは、MySQL のユーザーアカウントおよびロールに権限およびロールを割り当てます。 次のトピックで説明するように、<code class="literal">GRANT</code> ステートメントにはいくつかの側面があります: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#grant-overview" title="GRANT の一般概要">GRANT の一般概要</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#grant-quoting" title="オブジェクト見積ガイドライン">オブジェクト見積ガイドライン</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#grant-accounts" title="アカウント名">アカウント名</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#grant-privileges" title="MySQL によってサポートされる権限">MySQL によってサポートされる権限</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#grant-global-privileges" title="グローバル権限">グローバル権限</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#grant-database-privileges" title="データベース権限">データベース権限</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#grant-table-privileges" title="テーブル権限">テーブル権限</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#grant-column-privileges" title="カラム権限">カラム権限</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#grant-routine-privileges" title="ストアドルーチン権限">ストアドルーチン権限</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#grant-proxy-privileges" title="プロキシユーザー権限">プロキシユーザー権限</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#grant-roles" title="ロールの付与">ロールの付与</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#grant-as" title="AS 句および権限の制限事項"><code class="literal">AS</code> 句および権限の制限事項</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#grant-other-characteristics" title="その他のアカウント特性">その他のアカウント特性</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#grant-mysql-vs-standard-sql" title="MySQL バージョンと標準 SQL バージョンの GRANT">MySQL バージョンと標準 SQL バージョンの GRANT</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="grant-overview"></a>GRANT の一般概要</h5></div></div></div><p>
          <code class="literal">GRANT</code> ステートメントを使用すると、システム管理者は、ユーザーアカウントおよびロールに付与できる権限およびロールを付与できます。 次の構文制限が適用されます: 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">GRANT</code> では、権限とロールの両方の付与を同じステートメントに混在させることはできません。 特定の <code class="literal">GRANT</code> ステートメントでは、権限またはロールのいずれかを付与する必要があります。 
            </p></li><li class="listitem"><p>
              <code class="literal">ON</code> 句は、ステートメントによって権限が付与されるかロールが付与されるかを区別します:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">ON</code> では、ステートメントによって権限が付与されます。
                </p></li><li class="listitem"><p>
                  <code class="literal">ON</code> がない場合、ステートメントはロールを付与します。
                </p></li><li class="listitem"><p>
                  権限とロールの両方をアカウントに割り当てることはできますが、付与する内容に適した構文を持つ個別の <code class="literal">GRANT</code> ステートメントを使用する必要があります。
                </p></li></ul></div></li></ul></div><p>
          ロールの詳細は、<a class="xref" href="security.html#roles" title="6.2.10 ロールの使用">セクション6.2.10「ロールの使用」</a> を参照してください。
        </p><p>
          <code class="literal">GRANT</code> で権限を付与するには、<code class="literal">GRANT OPTION</code> 権限および付与する権限が必要です。 (または、<code class="literal">mysql</code> システムスキーマ内の付与テーブルに対する <code class="literal">UPDATE</code> 権限を持っている場合は、任意のアカウントに任意の権限を付与できます。) <code class="literal">read_only</code> システム変数が有効になっている場合、<code class="literal">GRANT</code> にはさらに <code class="literal">CONNECTION_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。 
        </p><p>
          <code class="literal">GRANT</code> は、指定されたすべてのユーザーおよびロールに対して成功するか、ロールバックされ、エラーが発生しても効果はありません。 ステートメントは、指定されたすべてのユーザーおよび役割で成功した場合にのみバイナリログに書き込まれます。 
        </p><p>
          <code class="literal">REVOKE</code> ステートメントは <code class="literal">GRANT</code> に関連しており、管理者がアカウントの権限を削除できるようにします。 <a class="xref" href="sql-statements.html#revoke" title="13.7.1.8 REVOKE ステートメント">セクション13.7.1.8「REVOKE ステートメント」</a>を参照してください。 
        </p><p>
          各アカウント名には、<a class="xref" href="security.html#account-names" title="6.2.4 アカウント名の指定">セクション6.2.4「アカウント名の指定」</a>で説明されている形式が使用されます。 各ロール名は、<a class="xref" href="security.html#role-names" title="6.2.5 ロール名の指定">セクション6.2.5「ロール名の指定」</a> で説明されている形式を使用します。 例: 
        </p><pre class="programlisting">GRANT ALL ON db1.* TO 'jeffrey'@'localhost';
GRANT 'role1', 'role2' TO 'user1'@'localhost', 'user2'@'localhost';
GRANT SELECT ON world.* TO 'role3';
</pre><p>
          アカウント名またはロール名のホスト名部分は、省略すると<code class="literal">'%'</code>にデフォルト設定されます。
        </p><p>
          通常、データベース管理者は最初に <code class="literal">CREATE USER</code> を使用してアカウントを作成し、その非権限特性 (パスワード、セキュアな接続を使用するかどうか、サーバーリソースへのアクセス制限など) を定義してから、<code class="literal">GRANT</code> を使用してその権限を定義します。 <code class="literal">ALTER USER</code> を使用して、既存のアカウントの非権限特性を変更できます。 例: 
        </p><pre class="programlisting">CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY '<em class="replaceable"><code>password</code></em>';
GRANT ALL ON db1.* TO 'jeffrey'@'localhost';
GRANT SELECT ON db2.invoice TO 'jeffrey'@'localhost';
ALTER USER 'jeffrey'@'localhost' WITH MAX_QUERIES_PER_HOUR 90;
</pre><p>
          正常に実行されると、<code class="literal">GRANT</code> は <span class="command"><strong>mysql</strong></span> プログラムから <code class="literal">Query OK, 0 rows affected</code> で応答します。 この操作によってどのような権限が付与されたかを判定するには、<code class="literal">SHOW GRANTS</code> を使用します。 <a class="xref" href="sql-statements.html#show-grants" title="13.7.7.21 SHOW GRANTS ステートメント">セクション13.7.7.21「SHOW GRANTS ステートメント」</a>を参照してください。 
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
            状況によっては、<code class="literal">GRANT</code> がサーバーログ、またはクライアント側にある <code class="filename">~/.mysql_history</code> などの履歴ファイル内に記録されることがあります。つまり、平文のパスワードが、その情報に対する読み取りアクセス権を持つ任意のユーザーによって読み取られる可能性があります。 これがサーバーログで発生する条件およびこれを制御する方法については、<a class="xref" href="security.html#password-logging" title="6.1.2.3 パスワードおよびロギング">セクション6.1.2.3「パスワードおよびロギング」</a>を参照してください。 クライアント側のロギングに関する同様の情報については、<a class="xref" href="programs.html#mysql-logging" title="4.5.1.3 mysql クライアントロギング">セクション4.5.1.3「mysql クライアントロギング」</a>を参照してください。 
          </p></div><p>
          <code class="literal">GRANT</code> では、255 文字までのホスト名 (MySQL 8.0.17 より前の 60 文字) がサポートされます。 ユーザー名には、最大 32 文字を指定できます。 データベース、テーブル、カラム、およびルーチン名には、最大 64 文字を指定できます。 
        </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
            <span class="emphasis"><em>Do は、<code class="literal">mysql.user</code> システムテーブルを変更しても、ユーザー名に許可されている長さを変更しようとしません。 これを行うと、予期しない動作が発生し、ユーザーが MySQL server</em></span> にログインできなくなることもあります。 <a class="xref" href="installing.html#upgrading" title="2.11 MySQL のアップグレード">セクション2.11「MySQL のアップグレード」</a> で説明されている手順以外の方法で、<code class="literal">mysql</code> システムスキーマ内のテーブルの構造を変更しないでください。 
          </p></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="grant-quoting"></a>オブジェクト見積ガイドライン</h5></div></div></div><a class="indexterm" name="idm45826991050000"></a><p>
          多くの場合、引用符はオプションですが、<code class="literal">GRANT</code> ステートメント内のいくつかのオブジェクトは引用の対象となります: アカウント名、ロール名、データベース名、テーブル名、カラム名およびルーチン名。 たとえば、アカウント名の <em class="replaceable"><code>user_name</code></em> または <em class="replaceable"><code>host_name</code></em> の値が引用符で囲まれていない識別子として有効な場合、引用符で囲む必要はありません。 ただし、特殊文字 (<code class="literal">-</code> など) を含む <em class="replaceable"><code>user_name</code></em> 文字列、または <code class="literal">%</code> などの特殊文字やワイルドカード文字を含む <em class="replaceable"><code>host_name</code></em> 文字列 (<code class="literal">'test-user'@'%.com'</code>など) を指定するには、引用符が必要です。 ユーザー名とホスト名は個別に引用符で囲みます。 
        </p><p>
          引用符で囲まれた値を指定するには:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              データベース名、テーブル名、カラム名およびルーチン名を識別子として引用符で囲みます。
            </p></li><li class="listitem"><p>
              ユーザー名とホスト名は識別子または文字列として引用符で囲みます。
            </p></li><li class="listitem"><p>
              パスワードは文字列として引用符で囲みます。
            </p></li></ul></div><p>
          文字列および識別子として引用符で囲む方法のガイドラインについては、<a class="xref" href="language-structure.html#string-literals" title="9.1.1 文字列リテラル">セクション9.1.1「文字列リテラル」</a>および<a class="xref" href="language-structure.html#identifiers" title="9.2 スキーマオブジェクト名">セクション9.2「スキーマオブジェクト名」</a>を参照してください。
        </p><p>
          <code class="literal">_</code>および <code class="literal">%</code> のワイルドカードは、データベースレベル (<code class="literal">GRANT ... ON <em class="replaceable"><code>db_name</code></em>.*</code>) で権限を付与する <code class="literal">GRANT</code> ステートメントでデータベース名を指定する場合に使用できます。 つまり、たとえば、<code class="literal">_</code>文字をデータベース名の一部として使用するには、<code class="literal">GRANT</code> ステートメントで<code class="literal">\_</code>として指定し、ワイルドカードパターンに一致する追加のデータベース (<code class="literal">GRANT ... ON `foo\_bar`.* TO ...</code> など) にユーザーがアクセスできないようにします。 
        </p><p>
          データベース名を使用してデータベースレベルで権限を付与せず、テーブルやルーチン (<code class="literal">GRANT ... ON <em class="replaceable"><code>db_name</code></em>.<em class="replaceable"><code>tbl_name</code></em></code> など) などの他のオブジェクトに権限を付与する修飾子として使用すると、ワイルドカード文字は通常の文字として扱われます。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="grant-accounts"></a>アカウント名</h5></div></div></div><p>
          <code class="literal">GRANT</code> ステートメントの <em class="replaceable"><code>user</code></em> 値は、そのステートメントが適用される MySQL アカウントを示します。 任意のホストからのユーザーへの権限の付与に対応するために、MySQL では、<code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'<em class="replaceable"><code>host_name</code></em>'</code>形式での <em class="replaceable"><code>user</code></em> 値の指定がサポートされています。 
        </p><p>
          ホスト名には、ワイルドカードを指定できます。 たとえば、<code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'%.example.com'</code>は <code class="literal">example.com</code> ドメイン内の任意のホストの <em class="replaceable"><code>user_name</code></em> に適用され、<code class="literal">' <em class="replaceable"><code>user_name</code></em> '@'198.51.100.%'</code>は <code class="literal">198.51.100</code> クラス C サブネット内の任意のホストの <em class="replaceable"><code>user_name</code></em> に適用されます。 
        </p><p>
          単純な形式の<code class="literal">'<em class="replaceable"><code>user_name</code></em>'</code>は、<code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'%'</code>のシノニムです。
        </p><p>
          <span class="emphasis"><em>MySQL は、ユーザー名でのワイルドカードをサポートしていません</em></span>。 匿名ユーザーを参照するには、<code class="literal">GRANT</code> ステートメントで空のユーザー名を含むアカウントを指定します。 
        </p><pre class="programlisting">GRANT ALL ON test.* TO ''@'localhost' ...;
</pre><p>
          この場合、匿名ユーザーの正しいパスワードを使用してローカルホストから接続するユーザーは、匿名ユーザーアカウントに関連付けられた権限を使用してアクセスを許可されます。
        </p><p>
          アカウント名内のユーザー名とホスト名の値の詳細は、<a class="xref" href="security.html#account-names" title="6.2.4 アカウント名の指定">セクション6.2.4「アカウント名の指定」</a>を参照してください。
        </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
            ローカル匿名ユーザーに MySQL サーバーへの接続を許可する場合は、<code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'localhost'</code>としてすべてのローカルユーザーにも権限を付与する必要があります。 それ以外の場合は、指定されたユーザーがローカルマシンから MySQL サーバーにログインしようとすると、<code class="literal">mysql.user</code> システムテーブルの <code class="literal">localhost</code> の匿名ユーザーアカウントが使用されます。 詳細は、<a class="xref" href="security.html#connection-access" title="6.2.6 アクセス制御、ステージ 1: 接続の検証">セクション6.2.6「アクセス制御、ステージ 1: 接続の検証」</a>を参照してください。 
          </p><p>
            この問題が適用されるかどうかを判断するには、匿名ユーザーをリストする次のクエリーを実行します:
          </p><pre class="programlisting">SELECT Host, User FROM mysql.user WHERE User='';
</pre><p>
            今説明した問題を回避するには、次のステートメントを使用して、ローカルの匿名ユーザーアカウントを削除します。
          </p><pre class="programlisting">DROP USER ''@'localhost';
</pre></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="grant-privileges"></a>MySQL によってサポートされる権限</h5></div></div></div><p>
          次のテーブルに、<code class="literal">GRANT</code> および <code class="literal">REVOKE</code> ステートメントに指定できる静的および動的な <em class="replaceable"><code>priv_type</code></em> 権限タイプと、各権限を付与できるレベルをまとめます。 各権限の詳細は、<a class="xref" href="security.html#privileges-provided" title="6.2.2 MySQL で提供される権限">セクション6.2.2「MySQL で提供される権限」</a> を参照してください。 静的権限と動的権限の違いの詳細は、<a class="xref" href="security.html#static-dynamic-privileges" title="静的権限と動的権限">静的権限と動的権限</a> を参照してください。 
        </p><div class="table"><a name="idm45826990991616"></a><p class="title"><b>表 13.11 GRANT および REVOKE に許可される静的権限</b></p><div class="table-contents"><table><col style="width: 30%"><col style="width: 70%"><thead><tr>
              <th>権限</th>
              <th>意味と付与可能なレベル</th>
            </tr></thead><tbody><tr>
              <td><code class="literal">ALL [PRIVILEGES]</code></td>
              <td><code class="literal">GRANT OPTION</code> および <code class="literal">PROXY</code> を除くすべての権限を指定されたアクセスレベルで付与します。</td>
            </tr><tr>
              <td><code class="literal">ALTER</code></td>
              <td><code class="literal">ALTER TABLE</code> の使用を有効にします。 レベル: グローバル、データベース、テーブル。 </td>
            </tr><tr>
              <td><code class="literal">ALTER ROUTINE</code></td>
              <td>ストアドルーチンの変更または削除を有効にします。 レベル: Global, database, routine. </td>
            </tr><tr>
              <td><code class="literal">CREATE</code></td>
              <td>データベースおよびテーブルの作成を有効にします。 レベル: グローバル、データベース、テーブル。 </td>
            </tr><tr>
              <td><code class="literal">CREATE ROLE</code></td>
              <td>ロール作成を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">CREATE ROUTINE</code></td>
              <td>ストアドルーチンの作成を有効にします。 レベル: グローバル、データベース。 </td>
            </tr><tr>
              <td><code class="literal">CREATE TABLESPACE</code></td>
              <td>テーブルスペースおよびログファイルグループの作成、変更、または削除を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">CREATE TEMPORARY TABLES</code></td>
              <td><code class="literal">CREATE TEMPORARY TABLE</code> の使用を有効にします。 レベル: グローバル、データベース。 </td>
            </tr><tr>
              <td><code class="literal">CREATE USER</code></td>
              <td><code class="literal">CREATE USER</code>、<code class="literal">DROP USER</code>、<code class="literal">RENAME USER</code>、および <code class="literal">REVOKE ALL PRIVILEGES</code> の使用を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">CREATE VIEW</code></td>
              <td>ビューの作成または変更を有効にします。 レベル: グローバル、データベース、テーブル。 </td>
            </tr><tr>
              <td><code class="literal">DELETE</code></td>
              <td><code class="literal">DELETE</code> の使用を有効にします。 レベル: グローバル、データベース、テーブル。 </td>
            </tr><tr>
              <td><code class="literal">DROP</code></td>
              <td>データベース、テーブル、およびビューの削除を有効にします。 レベル: グローバル、データベース、テーブル。 </td>
            </tr><tr>
              <td><code class="literal">DROP ROLE</code></td>
              <td>ロールの削除を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">EVENT</code></td>
              <td>イベントスケジューラでのイベントの使用を有効にします。 レベル: グローバル、データベース。 </td>
            </tr><tr>
              <td><code class="literal">EXECUTE</code></td>
              <td>ユーザーがストアドルーチンを実行できるようにします。 レベル: Global, database, routine. </td>
            </tr><tr>
              <td><code class="literal">FILE</code></td>
              <td>ユーザーがサーバーにファイルを読み取らせたり書き込ませたりできるようにします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">GRANT OPTION</code></td>
              <td>権限のほかのアカウントへの付与、またはほかのアカウントからの削除を有効にします。 レベル: Global, database, table, routine, proxy. </td>
            </tr><tr>
              <td><code class="literal">INDEX</code></td>
              <td>インデックスの作成または削除を有効にします。 レベル: グローバル、データベース、テーブル。 </td>
            </tr><tr>
              <td><code class="literal">INSERT</code></td>
              <td><code class="literal">INSERT</code> の使用を有効にします。 レベル: グローバル、データベース、テーブル、カラム。 </td>
            </tr><tr>
              <td><code class="literal">LOCK TABLES</code></td>
              <td>ユーザーが <code class="literal">SELECT</code> 権限を持っているテーブルに対する <code class="literal">LOCK TABLES</code> の使用を有効にします。 レベル: グローバル、データベース。 </td>
            </tr><tr>
              <td><code class="literal">PROCESS</code></td>
              <td>ユーザーが <code class="literal">SHOW PROCESSLIST</code> を使用してすべてのプロセスを表示できるようにします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">PROXY</code></td>
              <td>ユーザーのプロキシ設定を有効にします。 レベル: ユーザーからユーザーへ。 </td>
            </tr><tr>
              <td><code class="literal">REFERENCES</code></td>
              <td>外部キーの作成を有効にします。 レベル: グローバル、データベース、テーブル、カラム。 </td>
            </tr><tr>
              <td><code class="literal">RELOAD</code></td>
              <td><code class="literal">FLUSH</code> 操作の使用を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">REPLICATION CLIENT</code></td>
              <td>ユーザーがソースサーバーまたはレプリカサーバーの場所を尋ねることができるようにします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">REPLICATION SLAVE</code></td>
              <td>レプリカがソースからバイナリログイベントを読み取ることを有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">SELECT</code></td>
              <td><code class="literal">SELECT</code> の使用を有効にします。 レベル: グローバル、データベース、テーブル、カラム。 </td>
            </tr><tr>
              <td><code class="literal">SHOW DATABASES</code></td>
              <td><code class="literal">SHOW DATABASES</code> がすべてのデータベースを表示できるようにします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">SHOW VIEW</code></td>
              <td><code class="literal">SHOW CREATE VIEW</code> の使用を有効にします。 レベル: グローバル、データベース、テーブル。 </td>
            </tr><tr>
              <td><code class="literal">SHUTDOWN</code></td>
              <td><span class="command"><strong>mysqladmin shutdown</strong></span> の使用を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">SUPER</code></td>
              <td><code class="literal">CHANGE REPLICATION SOURCE TO</code>, <code class="literal">CHANGE MASTER TO</code>, <code class="literal">KILL</code>, <code class="literal">PURGE BINARY LOGS</code>, <code class="literal">SET GLOBAL</code> や <span class="command"><strong>mysqladmin debug</strong></span> コマンドなどの他の管理操作の使用を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">TRIGGER</code></td>
              <td>トリガー操作を有効にします。 レベル: グローバル、データベース、テーブル。 </td>
            </tr><tr>
              <td><code class="literal">UPDATE</code></td>
              <td><code class="literal">UPDATE</code> の使用を有効にします。 レベル: グローバル、データベース、テーブル、カラム。 </td>
            </tr><tr>
              <td><code class="literal">USAGE</code></td>
              <td><span class="quote">「<span class="quote">権限なし</span>」</span>のシノニムです</td>
            </tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="idm45826990860544"></a><p class="title"><b>表 13.12 GRANT および REVOKE に許可される動的権限</b></p><div class="table-contents"><table><col style="width: 30%"><col style="width: 70%"><thead><tr>
              <th>権限</th>
              <th>意味と付与可能なレベル</th>
            </tr></thead><tbody><tr>
              <td><code class="literal">APPLICATION_PASSWORD_ADMIN</code></td>
              <td>デュアルパスワード管理を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">AUDIT_ADMIN</code></td>
              <td>監査ログ構成を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">BACKUP_ADMIN</code></td>
              <td>バックアップ管理を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">BINLOG_ADMIN</code></td>
              <td>バイナリログ制御を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">BINLOG_ENCRYPTION_ADMIN</code></td>
              <td>バイナリログ暗号化のアクティブ化および非アクティブ化を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">CLONE_ADMIN</code></td>
              <td>クローン管理を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">CONNECTION_ADMIN</code></td>
              <td>接続制限/制限制御を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">ENCRYPTION_KEY_ADMIN</code></td>
              <td><code class="literal">InnoDB</code> キーローテーションを有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">FIREWALL_ADMIN</code></td>
              <td>ファイアウォールルール管理 (任意のユーザー) を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">FIREWALL_USER</code></td>
              <td>ファイアウォールルール管理を有効にします (self )。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">FLUSH_OPTIMIZER_COSTS</code></td>
              <td>オプティマイザコストのリロードを有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">FLUSH_STATUS</code></td>
              <td>ステータスインジケータのフラッシュを有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">FLUSH_TABLES</code></td>
              <td>テーブルのフラッシュを有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">FLUSH_USER_RESOURCES</code></td>
              <td>ユーザーリソースのフラッシュを有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">GROUP_REPLICATION_ADMIN</code></td>
              <td>Group Replication 制御を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">INNODB_REDO_LOG_ENABLE</code></td>
              <td>redo ロギングを有効または無効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">INNODB_REDO_LOG_ARCHIVE</code></td>
              <td>redo ログアーカイブ管理を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">NDB_STORED_USER</code></td>
              <td>SQL ノード間でのユーザーまたは役割の共有を有効にします (NDB Cluster)。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">PERSIST_RO_VARIABLES_ADMIN</code></td>
              <td>読取り専用システム変数の永続化を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">REPLICATION_APPLIER</code></td>
              <td>レプリケーションチャネルの <code class="literal">PRIVILEGE_CHECKS_USER</code> として機能します。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">REPLICATION_SLAVE_ADMIN</code></td>
              <td>通常のレプリケーション制御を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">RESOURCE_GROUP_ADMIN</code></td>
              <td>リソースグループの管理を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">RESOURCE_GROUP_USER</code></td>
              <td>リソースグループの管理を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">ROLE_ADMIN</code></td>
              <td><code class="literal">WITH ADMIN OPTION</code> を使用して、ロールの付与または取消しを可能にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">SESSION_VARIABLES_ADMIN</code></td>
              <td>制限付きセッションシステム変数の設定を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">SET_USER_ID</code></td>
              <td>非自己 <code class="literal">DEFINER</code> 値の設定を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">SHOW_ROUTINE</code></td>
              <td>ストアドルーチン定義へのアクセスを有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">SYSTEM_USER</code></td>
              <td>アカウントをシステムアカウントとして指定します。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">SYSTEM_VARIABLES_ADMIN</code></td>
              <td>グローバルシステム変数の変更または永続化を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">TABLE_ENCRYPTION_ADMIN</code></td>
              <td>デフォルトの暗号化設定のオーバーライドを有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">VERSION_TOKEN_ADMIN</code></td>
              <td>バージョントークン UDF の使用を有効にします。 レベル: グローバル。 </td>
            </tr><tr>
              <td><code class="literal">XA_RECOVER_ADMIN</code></td>
              <td><code class="literal">XA RECOVER</code> の実行を有効にします。 レベル: グローバル。 </td>
            </tr></tbody></table></div></div><br class="table-break"><p>
          トリガーはテーブルに関連付けられます。 トリガーを作成または削除するには、トリガーではなくテーブルに対する <code class="literal">TRIGGER</code> 権限が必要です。 
        </p><p>
          <code class="literal">GRANT</code> ステートメントでは、<code class="literal">ALL [PRIVILEGES]</code> または <code class="literal">PROXY</code> 権限は単独で指定する必要があり、ほかの権限とともに指定することはできません。 <code class="literal">ALL [PRIVILEGES]</code> は、<code class="literal">GRANT OPTION</code> および <code class="literal">PROXY</code> 権限を除き、権限が付与されるレベルで使用可能なすべての権限を表します。 
        </p><p>
          MySQL アカウント情報は、<code class="literal">mysql</code> システムスキーマのテーブルに格納されます。 詳細は、<code class="literal">mysql</code> システムスキーマおよびアクセス制御システムについて詳しく説明している <a class="xref" href="security.html#access-control" title="6.2 アクセス制御とアカウント管理">セクション6.2「アクセス制御とアカウント管理」</a> を参照してください。 
        </p><a class="indexterm" name="idm45826990744912"></a><p>
          付与テーブルに、大文字と小文字が混在したデータベースまたはテーブル名を含む権限行が保持されており、かつ <code class="literal">lower_case_table_names</code> システム変数が 0 以外の値に設定されている場合は、<code class="literal">REVOKE</code> を使用してこれらの権限を取り消すことはできません。 このような場合は、付与テーブルを直接操作する必要があります。 (<code class="literal">lower_case_table_names</code> が設定されている場合、<code class="literal">GRANT</code> はこのような行を作成しませんが、その変数を設定する前にこのような行が作成されている可能性があります。 <code class="literal">lower_case_table_names</code> 設定は、サーバーの起動時にのみ構成できます。) 
        </p><p>
          権限は、<code class="literal">ON</code> 句に使用される構文に応じて、いくつかのレベルで付与できます。 <code class="literal">REVOKE</code> の場合、同じ <code class="literal">ON</code> 構文で削除する権限を指定します。 
        </p><p>
          グローバル、データベース、テーブル、およびルーチンレベルの場合、<code class="literal">GRANT ALL</code> は、付与しようとしているレベルに存在する権限のみを割り当てます。 たとえば、<code class="literal">GRANT ALL ON <em class="replaceable"><code>db_name</code></em>.*</code> はデータベースレベルのステートメントであるため、<code class="literal">FILE</code> などのグローバルのみの権限を付与しません。 <code class="literal">ALL</code> を付与しても、<code class="literal">GRANT OPTION</code> または <code class="literal">PROXY</code> 権限は割り当てられません。 
        </p><p>
          <em class="replaceable"><code>object_type</code></em> 句 (存在する場合) は、それに続くオブジェクトがテーブル、ストアドファンクション、またはストアドプロシージャーであるときは <code class="literal">TABLE</code>、<code class="literal">FUNCTION</code>、または <code class="literal">PROCEDURE</code> として指定するようにしてください。
        </p><p>
          ユーザーがデータベース、テーブル、カラムまたはルーチンに対して保持する権限は、グローバルレベルを含む各権限レベルのアカウント権限の論理 <code class="literal">OR</code> として追加的に形成されます。 下位レベルの権限がないため、上位レベルで付与された権限を拒否できません。 たとえば、次のステートメントは <code class="literal">SELECT</code> および <code class="literal">INSERT</code> 権限をグローバルに付与します: 
        </p><pre class="programlisting">GRANT SELECT, INSERT ON *.* TO u1;
</pre><p>
          グローバルに付与された権限は、これらの下位レベルでは付与されませんが、すべてのデータベース、テーブルおよびカラムに適用されます。
        </p><p>
          MySQL 8.0.16 では、<code class="literal">partial_revokes</code> システム変数が有効になっている場合、特定のデータベースに対して権限を取り消すことで、グローバルレベルで付与された権限を明示的に拒否できます:
        </p><pre class="programlisting">GRANT SELECT, INSERT, UPDATE ON *.* TO u1;
REVOKE INSERT, UPDATE ON db1.* FROM u1;
</pre><p>
          前述のステートメントの結果、<code class="literal">SELECT</code> はすべてのテーブルにグローバルに適用されますが、<code class="literal">INSERT</code> および <code class="literal">UPDATE</code> は <code class="literal">db1</code> のテーブルを除くグローバルに適用されます。 <code class="literal">db1</code> へのアカウントアクセスは読取り専用です。 
        </p><p>
          権限確認手順の詳細については、<a class="xref" href="security.html#request-access" title="6.2.7 アクセス制御、ステージ 2: リクエストの確認">セクション6.2.7「アクセス制御、ステージ 2: リクエストの確認」</a>で説明されています。
        </p><p>
          1 人のユーザーのテーブル、カラム、またはルーチン権限を使用している場合でも、サーバーはすべてのユーザーのテーブル、カラム、およびルーチン権限を検査するため、これにより MySQL が少し遅くなります。 同様に、いずれかのユーザーのクエリー、更新、または接続の数を制限した場合、サーバーはこれらの値をモニターする必要があります。 
        </p><p>
          MySQL では、存在しないデータベースまたはテーブルに対する権限を付与できます。 テーブルの場合は、付与される権限に <code class="literal">CREATE</code> 権限が含まれている必要があります。 <span class="emphasis"><em>この動作は設計によるものであり</em></span>、データベース管理者がユーザーアカウントと、あとで作成されるデータベースまたはテーブルに対する権限を準備できるようにすることを目的にしています。 
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
            <span class="emphasis"><em>MySQL では、データベースまたはテーブルを削除しても、どの権限も自動的には取り消されません</em></span>。 ただし、ルーチンを削除した場合は、そのルーチンに付与されたルーチンレベルの権限がすべて取り消されます。 
          </p></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="grant-global-privileges"></a>グローバル権限</h5></div></div></div><p>
          グローバル権限は管理権限です。つまり、特定のサーバー上のすべてのデータベースに適用されます。 グローバル権限を割り当てるには、<code class="literal">ON *.*</code> 構文を使用します。 
        </p><pre class="programlisting">GRANT ALL ON *.* TO 'someuser'@'somehost';
GRANT SELECT, INSERT ON *.* TO 'someuser'@'somehost';
</pre><p>
          <code class="literal">CREATE TABLESPACE</code>, <code class="literal">CREATE USER</code>, <code class="literal">FILE</code>, <code class="literal">PROCESS</code>, <code class="literal">RELOAD</code>, <code class="literal">REPLICATION CLIENT</code>, <code class="literal">REPLICATION SLAVE</code>, <code class="literal">SHOW DATABASES</code>, <code class="literal">SHUTDOWN</code> および <code class="literal">SUPER</code> の静的権限は管理権限であり、グローバルにのみ付与できます。
        </p><p>
          動的権限はすべてグローバルであり、グローバルにのみ付与できます。
        </p><p>
          その他の権限はグローバルに、またはより具体的なレベルで付与できます。
        </p><p>
          グローバルレベルで付与される <code class="literal">GRANT OPTION</code> の影響は、静的権限と動的権限で異なります:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              静的グローバル権限に付与された <code class="literal">GRANT OPTION</code> は、すべての静的グローバル権限に適用されます。
            </p></li><li class="listitem"><p>
              動的権限に付与された <code class="literal">GRANT OPTION</code> は、その動的権限にのみ適用されます。
            </p></li></ul></div><p>
          グローバルレベルの <code class="literal">GRANT ALL</code> では、すべての静的グローバル権限および現在登録されているすべての動的権限が付与されます。 <code class="literal">GRANT</code> ステートメントの実行後に登録された動的権限は、どのアカウントにも遡及的に付与されません。 
        </p><p>
          MySQL では、グローバル権限は <code class="literal">mysql.user</code> システムテーブルに格納されます。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="grant-database-privileges"></a>データベース権限</h5></div></div></div><p>
          データベース権限は、特定のデータベース内のすべてのオブジェクトに適用されます。 データベースレベルの権限を割り当てるには、<code class="literal">ON <em class="replaceable"><code>db_name</code></em>.*</code> 構文を使用します。 
        </p><pre class="programlisting">GRANT ALL ON mydb.* TO 'someuser'@'somehost';
GRANT SELECT, INSERT ON mydb.* TO 'someuser'@'somehost';
</pre><p>
          (<code class="literal">ON *.*</code> ではなく) <code class="literal">ON *</code> 構文を使用する場合、権限はデフォルトデータベースのデータベースレベルで割り当てられます。 デフォルトデータベースが存在しない場合は、エラーが発生します。 
        </p><p>
          <code class="literal">CREATE</code>, <code class="literal">DROP</code>, <code class="literal">EVENT</code>, <code class="literal">GRANT OPTION</code>, <code class="literal">LOCK TABLES</code> および <code class="literal">REFERENCES</code> 権限は、データベースレベルで指定できます。 また、テーブルまたはルーチン権限もデータベースレベルで指定できます。この場合、これらの権限はデータベース内のすべてのテーブルまたはルーチンに適用されます。 
        </p><p>
          MySQL では、データベース権限は <code class="literal">mysql.db</code> システムテーブルに格納されます。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="grant-table-privileges"></a>テーブル権限</h5></div></div></div><p>
          テーブル権限は、特定のテーブル内のすべてのカラムに適用されます。 テーブルレベルの権限を割り当てるには、<code class="literal">ON <em class="replaceable"><code>db_name.tbl_name</code></em></code> 構文を使用します。 
        </p><pre class="programlisting">GRANT ALL ON mydb.mytbl TO 'someuser'@'somehost';
GRANT SELECT, INSERT ON mydb.mytbl TO 'someuser'@'somehost';
</pre><p>
          <em class="replaceable"><code>db_name.tbl_name</code></em> ではなく <em class="replaceable"><code>tbl_name</code></em> を指定した場合、このステートメントは、デフォルトデータベース内の <em class="replaceable"><code>tbl_name</code></em> に適用されます。 デフォルトデータベースが存在しない場合は、エラーが発生します。 
        </p><p>
          テーブルレベルで許可される <em class="replaceable"><code>priv_type</code></em> 値は、<code class="literal">ALTER</code>, <code class="literal">CREATE VIEW</code>, <code class="literal">CREATE</code>, <code class="literal">DELETE</code>, <code class="literal">DROP</code>, <code class="literal">GRANT OPTION</code>, <code class="literal">INDEX</code>, <code class="literal">INSERT</code>, <code class="literal">REFERENCES</code>, <code class="literal">SELECT</code>, <code class="literal">SHOW VIEW</code>, <code class="literal">TRIGGER</code> および <code class="literal">UPDATE</code> です。
        </p><p>
          テーブルレベルの権限は、実テーブルおよびビューに適用されます。 テーブル名が一致していても、<code class="literal">CREATE TEMPORARY TABLE</code> で作成されたテーブルには適用されません。 <code class="literal">TEMPORARY</code> テーブルの権限の詳細は、<a class="xref" href="sql-statements.html#create-temporary-table" title="13.1.20.2 CREATE TEMPORARY TABLE ステートメント">セクション13.1.20.2「CREATE TEMPORARY TABLE ステートメント」</a> を参照してください。 
        </p><a class="indexterm" name="idm45826990639072"></a><a class="indexterm" name="idm45826990636928"></a><p>
          MySQL では、<code class="literal">mysql.tables_priv</code> システムテーブルにテーブル権限が格納されます。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="grant-column-privileges"></a>カラム権限</h5></div></div></div><p>
          カラム権限は、特定のテーブル内の単一カラムに適用されます。 カラムレベルで付与される各権限のあとに、括弧で囲まれた 1 つまたは複数のカラムを指定する必要があります。 
        </p><pre class="programlisting">GRANT SELECT (col1), INSERT (col1, col2) ON mydb.mytbl TO 'someuser'@'somehost';
</pre><p>
          カラムに許可される <em class="replaceable"><code>priv_type</code></em> 値 (つまり、<em class="replaceable"><code>column_list</code></em> 句を使用する場合) は、<code class="literal">INSERT</code>, <code class="literal">REFERENCES</code>, <code class="literal">SELECT</code> および <code class="literal">UPDATE</code> です。
        </p><p>
          MySQL では、<code class="literal">mysql.columns_priv</code> システムテーブルにカラム権限が格納されます。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="grant-routine-privileges"></a>ストアドルーチン権限</h5></div></div></div><p>
          <code class="literal">ALTER ROUTINE</code>、<code class="literal">CREATE ROUTINE</code>、<code class="literal">EXECUTE</code>、および <code class="literal">GRANT OPTION</code> 権限は、ストアドルーチン (プロシージャーおよびファンクション) に適用されます。 これらの権限は、グローバルおよびデータベースレベルで付与できます。 <code class="literal">CREATE ROUTINE</code> を除き、これらの権限は、個々のルーチンに対してルーチンレベルで付与できます。 
        </p><pre class="programlisting">GRANT CREATE ROUTINE ON mydb.* TO 'someuser'@'somehost';
GRANT EXECUTE ON PROCEDURE mydb.myproc TO 'someuser'@'somehost';
</pre><p>
          ルーチンレベルで許可される <em class="replaceable"><code>priv_type</code></em> 値は、<code class="literal">ALTER ROUTINE</code>、<code class="literal">EXECUTE</code>、および <code class="literal">GRANT OPTION</code> です。 ルーチンを最初に作成するには、グローバルレベルまたはデータベースレベルの権限が必要であるため、<code class="literal">CREATE ROUTINE</code> はルーチンレベルの権限ではありません。 
        </p><p>
          MySQL では、<code class="literal">mysql.procs_priv</code> システムテーブルにルーチンレベルの権限が格納されます。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="grant-proxy-privileges"></a>プロキシユーザー権限</h5></div></div></div><p>
          <code class="literal">PROXY</code> 権限は、あるユーザーを別のユーザーのプロキシにできるようにします。 プロキシユーザーは、プロキシユーザーのアイデンティティを偽装または取得します。つまり、プロキシユーザーの権限を引き継ぎます。 
        </p><pre class="programlisting">GRANT PROXY ON 'localuser'@'localhost' TO 'externaluser'@'somehost';
</pre><p>
          <code class="literal">PROXY</code> が付与されている場合、<code class="literal">GRANT</code> ステートメントで指定されている唯一の権限である必要があり、許可されている <code class="literal">WITH</code> オプションは <code class="literal">WITH GRANT OPTION</code> のみです。
        </p><p>
          プロキシ設定では、プロキシユーザーが、接続時にプロキシ設定されたユーザーの名前をサーバーに返すプラグイン経由で認証すること、およびプロキシユーザーがプロキシ設定されたユーザーに対する <code class="literal">PROXY</code> 権限を持っていることが必要です。 詳細および例については、<a class="xref" href="security.html#proxy-users" title="6.2.18 プロキシユーザー">セクション6.2.18「プロキシユーザー」</a>を参照してください。 
        </p><p>
          MySQL では、<code class="literal">mysql.proxies_priv</code> システムテーブルにプロキシ権限が格納されます。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="grant-roles"></a>ロールの付与</h5></div></div></div><p>
          <code class="literal">ON</code> 句のない <code class="literal">GRANT</code> 構文では、個々の権限ではなくロールが付与されます。 ロールは、権限の名前付きコレクションです。<a class="xref" href="security.html#roles" title="6.2.10 ロールの使用">セクション6.2.10「ロールの使用」</a> を参照してください。 例: 
        </p><pre class="programlisting">GRANT 'role1', 'role2' TO 'user1'@'localhost', 'user2'@'localhost';
</pre><p>
          付与する各ロールと、そのロールが付与される各ユーザーアカウントまたはロールが存在する必要があります。 MySQL 8.0.16 では、匿名ユーザーにロールを付与できません。 
        </p><p>
          ロールを付与しても、ロールは自動的にアクティブになりません。 ロールのアクティブ化および非アクティブ化の詳細は、<a class="xref" href="security.html#roles-activating" title="ロールのアクティブ化">ロールのアクティブ化</a> を参照してください。 
        </p><p>
          ロールを付与するには、次の権限が必要です:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">ROLE_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) を持っている場合は、ユーザーまたはロールに対して任意のロールを付与または取り消すことができます。
            </p></li><li class="listitem"><p>
              <code class="literal">WITH ADMIN OPTION</code> 句を含む <code class="literal">GRANT</code> ステートメントを使用してロールを付与された場合、そのロールを他のユーザーまたはロールに付与したり、他のユーザーまたはロールから取り消すことができます。ただし、後で付与または取消しを行うときにロールがアクティブになっている必要があります。 これには、<code class="literal">WITH ADMIN OPTION</code> 自体を使用する機能が含まれます。 
            </p></li><li class="listitem"><p>
              <code class="literal">SYSTEM_USER</code> 権限を持つロールを付与するには、<code class="literal">SYSTEM_USER</code> 権限が必要です。
            </p></li></ul></div><p>
          <code class="literal">GRANT</code> を使用して循環参照を作成できます。 例: 
        </p><pre class="programlisting">CREATE USER 'u1', 'u2';
CREATE ROLE 'r1', 'r2';

GRANT 'u1' TO 'u1';   -- simple loop: u1 =&gt; u1
GRANT 'r1' TO 'r1';   -- simple loop: r1 =&gt; r1

GRANT 'r2' TO 'u2';
GRANT 'u2' TO 'r2';   -- mixed user/role loop: u2 =&gt; r2 =&gt; u2
</pre><p>
          循環付与参照は許可されますが、ユーザーまたはロールにはすでに権限およびロールがあるため、権限受領者に新しい権限またはロールは追加されません。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="grant-as"></a><code class="literal">AS</code> 句および権限の制限事項</h5></div></div></div><a class="indexterm" name="idm45826990573440"></a><a class="indexterm" name="idm45826990571232"></a><p>
          MySQL 8.0.16 の時点で、<code class="literal">GRANT</code> には、ステートメントの実行に使用する権限コンテキストに関する追加情報を指定する <code class="literal">AS <em class="replaceable"><code>user</code></em> [WITH ROLE]</code>句があります。 この構文は SQL レベルで表示できますが、主な目的は、部分的な取消しによって課される権限付与者権限制限のすべてのノード間で均一なレプリケーションを有効にすることです。これにより、これらの制限がバイナリログに表示されます。 部分取消しの詳細は、<a class="xref" href="security.html#partial-revokes" title="6.2.12 部分取消しを使用した権限の制限">セクション6.2.12「部分取消しを使用した権限の制限」</a> を参照してください。 
        </p><p>
          <code class="literal">AS <em class="replaceable"><code>user</code></em></code> 句が指定されている場合、ステートメントの実行では、<code class="literal">WITH ROLE</code> によって指定されたすべてのロール (存在する場合) を含む、指定されたユーザーに関連付けられた権限の制限が考慮されます。 その結果、ステートメントによって実際に付与される権限は、指定された権限と比較して削減される可能性があります。 
        </p><p>
          <code class="literal">AS <em class="replaceable"><code>user</code></em></code> 句には、次の条件が適用されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">AS</code> は、指定された <em class="replaceable"><code>user</code></em> に権限制限がある場合にのみ有効です (<code class="literal">partial_revokes</code> システム変数が有効になっていることを意味します)。
            </p></li><li class="listitem"><p>
              <code class="literal">WITH ROLE</code> が指定されている場合は、指定されたすべてのロールを指定された <em class="replaceable"><code>user</code></em> に付与する必要があります。
            </p></li><li class="listitem"><p>
              名前付き <em class="replaceable"><code>user</code></em> は、<code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'<em class="replaceable"><code>host_name</code></em>'</code>、<code class="literal">CURRENT_USER</code> または <code class="literal">CURRENT_USER()</code> として指定された MySQL アカウントである必要があります。 現在のセッション内でアクティブなロールとは異なるロールのセットを適用して <code class="literal">GRANT</code> を実行する場合は、現在のユーザーに <code class="literal">WITH ROLE</code> との名前を付けることができます。 
            </p></li><li class="listitem"><p>
              <code class="literal">AS</code> を使用して、<code class="literal">GRANT</code> ステートメントを実行するユーザーが所有していない権限を取得することはできません。 実行中のユーザーには少なくとも付与される権限が必要ですが、<code class="literal">AS</code> 句では付与される権限のみを制限でき、エスカレートはできません。 
            </p></li><li class="listitem"><p>
              付与される権限に関して、<code class="literal">AS</code> では、<code class="literal">GRANT</code> ステートメントを実行するユーザーよりも多くの権限 (制限が少ない) を持つユーザー/ロールの組合せを指定できません。 <code class="literal">AS</code> ユーザー/ロールの組合せは、実行中のユーザーよりも多くの権限を持つことが許可されていますが、これらの追加の権限がステートメントで付与されていない場合のみです。 
            </p></li><li class="listitem"><p>
              <code class="literal">AS</code> は、グローバル権限 (<code class="literal">ON *.*</code>) の付与でのみサポートされています。
            </p></li><li class="listitem"><p>
              <code class="literal">AS</code> は、<code class="literal">PROXY</code> 権限付与ではサポートされていません。
            </p></li></ul></div><p>
          次の例に、<code class="literal">AS</code> 句の影響を示します。 いくつかのグローバル権限およびそれらの権限の制限を持つユーザー <code class="literal">u1</code> を作成します: 
        </p><pre class="programlisting">CREATE USER u1;
GRANT SELECT, INSERT, UPDATE, DELETE ON *.* TO u1;
REVOKE INSERT, UPDATE ON schema1.* FROM u1;
REVOKE SELECT ON schema2.* FROM u1;
</pre><p>
          また、権限制限の一部を引き上げてロールを <code class="literal">u1</code> に付与するロール <code class="literal">r1</code> を作成します:
        </p><pre class="programlisting">CREATE ROLE r1;
GRANT INSERT ON schema1.* TO r1;
GRANT SELECT ON schema2.* TO r1;
GRANT r1 TO u1;
</pre><p>
          権限制限のないアカウントを使用して、複数のユーザーに同じグローバル権限のセットを付与しますが、それぞれに <code class="literal">AS</code> 句によって課される異なる制限があり、実際に付与されている権限を確認します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              ここでの <code class="literal">GRANT</code> ステートメントには <code class="literal">AS</code> 句がないため、付与される権限は指定したものとまったく同じです:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE USER u2;</code></strong>
mysql&gt; <strong class="userinput"><code>GRANT SELECT, INSERT, UPDATE ON *.* TO u2;</code></strong>
mysql&gt; <strong class="userinput"><code>SHOW GRANTS FOR u2;</code></strong>
+-------------------------------------------------+
| Grants for u2@%                                 |
+-------------------------------------------------+
| GRANT SELECT, INSERT, UPDATE ON *.* TO `u2`@`%` |
+-------------------------------------------------+
</pre></li><li class="listitem"><p>
              ここでの <code class="literal">GRANT</code> ステートメントには <code class="literal">AS</code> 句があるため、付与される権限は指定された権限ですが、<code class="literal">u1</code> からの制限が適用されます:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE USER u3;</code></strong>
mysql&gt; <strong class="userinput"><code>GRANT SELECT, INSERT, UPDATE ON *.* TO u3 AS u1;</code></strong>
mysql&gt; <strong class="userinput"><code>SHOW GRANTS FOR u3;</code></strong>
+----------------------------------------------------+
| Grants for u3@%                                    |
+----------------------------------------------------+
| GRANT SELECT, INSERT, UPDATE ON *.* TO `u3`@`%`    |
| REVOKE INSERT, UPDATE ON `schema1`.* FROM `u3`@`%` |
| REVOKE SELECT ON `schema2`.* FROM `u3`@`%`         |
+----------------------------------------------------+
</pre><p>
              前述のように、<code class="literal">AS</code> 句で追加できるのは権限制限のみで、権限をエスカレートすることはできません。 したがって、<code class="literal">u1</code> には <code class="literal">DELETE</code> 権限がありますが、このステートメントでは <code class="literal">DELETE</code> の付与が指定されていないため、付与された権限には含まれません。 
            </p></li><li class="listitem"><p>
              ここで <code class="literal">GRANT</code> ステートメントの <code class="literal">AS</code> 句を使用すると、<code class="literal">u1</code> に対して <code class="literal">r1</code> ロールがアクティブになります。 そのロールにより、<code class="literal">u1</code> の制限の一部が解除されます。 したがって、付与される権限にはいくつかの制限がありますが、前の <code class="literal">GRANT</code> ステートメントと同じ数ではありません: 
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE USER u4;</code></strong>
mysql&gt; <strong class="userinput"><code>GRANT SELECT, INSERT, UPDATE ON *.* TO u4 AS u1 WITH ROLE r1;</code></strong>
mysql&gt; <strong class="userinput"><code>SHOW GRANTS FOR u4;</code></strong>
+-------------------------------------------------+
| Grants for u4@%                                 |
+-------------------------------------------------+
| GRANT SELECT, INSERT, UPDATE ON *.* TO `u4`@`%` |
| REVOKE UPDATE ON `schema1`.* FROM `u4`@`%`      |
+-------------------------------------------------+
</pre></li></ul></div><p>
          <code class="literal">GRANT</code> ステートメントに <code class="literal">AS <em class="replaceable"><code>user</code></em></code> 句が含まれている場合、そのステートメントを実行するユーザーに対する権限制限は無視されます (<code class="literal">AS</code> 句がない場合と同様に適用されません)。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="grant-other-characteristics"></a>その他のアカウント特性</h5></div></div></div><p>
          オプションの <code class="literal">WITH</code> 句を使用すると、ユーザーは他のユーザーに権限を付与できます。 <code class="literal">WITH GRANT OPTION</code> 句は、ユーザーが、そのユーザーの持つ指定された権限レベルにある任意の権限をほかのユーザーに与えることができるようにします。 
        </p><p>
          他の方法で権限を変更せずに <code class="literal">GRANT OPTION</code> 権限をアカウントに付与するには、次の手順を実行します:
        </p><pre class="programlisting">GRANT USAGE ON *.* TO 'someuser'@'somehost' WITH GRANT OPTION;
</pre><p>
          異なる権限を持つ 2 人のユーザーが権限を組み合せることができる可能性があるため、<code class="literal">GRANT OPTION</code> 権限を付与するユーザーには注意してください。
        </p><p>
          自分が保持していない権限を別のユーザーに付与することはできません。<code class="literal">GRANT OPTION</code> 権限を使用して割り当てることができるのは、自分が保持している権限だけです。
        </p><p>
          あるユーザーに特定の権限レベルにある <code class="literal">GRANT OPTION</code> 権限を付与すると、そのユーザーがそのレベルに保持している (または、将来与えられる可能性のある) すべての権限も、そのユーザーからほかのユーザーに付与される場合があることに注意してください。 あるユーザーに、データベースに対する <code class="literal">INSERT</code> 権限を付与するとします。 次に、そのデータベースに対する <code class="literal">SELECT</code> 権限を付与し、<code class="literal">WITH GRANT OPTION</code> を指定した場合、そのユーザーはほかのユーザーに <code class="literal">SELECT</code> 権限だけでなく、<code class="literal">INSERT</code> 権限も与えることができます。 そのあと、そのユーザーにデータベースに対する <code class="literal">UPDATE</code> 権限を付与すると、そのユーザーは <code class="literal">INSERT</code>、<code class="literal">SELECT</code>、および <code class="literal">UPDATE</code> を付与できます。 
        </p><p>
          非管理ユーザーの場合は、<code class="literal">ALTER</code> 権限をグローバルまたは <code class="literal">mysql</code> システムスキーマに付与しないでください。 それを行うと、そのユーザーはテーブルの名前を変更することによって権限システムの破壊を試みることができます。 
        </p><p>
          特定の権限に関連付けられたセキュリティーリスクの詳細は、<a class="xref" href="security.html#privileges-provided" title="6.2.2 MySQL で提供される権限">セクション6.2.2「MySQL で提供される権限」</a>を参照してください。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="grant-mysql-vs-standard-sql"></a>MySQL バージョンと標準 SQL バージョンの GRANT</h5></div></div></div><a class="indexterm" name="idm45826990469536"></a><p>
          MySQL バージョンと標準 SQL バージョンの <code class="literal">GRANT</code> の最大の違いは次のとおりです。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              MySQL は、権限をユーザー名だけではなく、ホスト名とユーザー名の組み合わせに関連付けます。
            </p></li><li class="listitem"><p>
              標準 SQL はグローバルまたはデータベースレベルの権限を持たず、また MySQL がサポートするすべての権限タイプをサポートしているわけでもありません。
            </p></li><li class="listitem"><p>
              MySQL は、標準 SQL の <code class="literal">UNDER</code> 権限をサポートしていません。
            </p></li><li class="listitem"><p>
              標準 SQL の権限は、階層的な方法で構造化されています。 ユーザーを削除した場合は、そのユーザーに付与されていたすべての権限が取り消されます。 これはまた、<code class="literal">DROP USER</code> を使用した場合の MySQL にも当てはまります。 <a class="xref" href="sql-statements.html#drop-user" title="13.7.1.5 DROP USER ステートメント">セクション13.7.1.5「DROP USER ステートメント」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              標準 SQL では、テーブルを削除すると、そのテーブルに対するすべての権限が取り消されます。 標準 SQL では、権限を取り消すと、その権限に基づいて付与されていたすべての権限も取り消されます。 MySQL では、<code class="literal">DROP USER</code> ステートメントまたは <code class="literal">REVOKE</code> ステートメントを使用して権限を削除できます。 
            </p></li><li class="listitem"><p>
              MySQL では、テーブル内の一部のカラムに対してのみ <code class="literal">INSERT</code> 権限を持つことができます。 この場合、<code class="literal">INSERT</code> 権限を持っているカラムの値のみを挿入するのであれば、そのテーブルに対して引き続き <code class="literal">INSERT</code> ステートメントを実行できます。 厳密な SQL モードが有効になっていない場合、省略されたカラムはその暗黙のデフォルト値に設定されます。 厳密モードでは、省略されたカラムのいずれかにデフォルト値がない場合、このステートメントは拒否されます。 (標準 SQL では、すべてのカラムに対する <code class="literal">INSERT</code> 権限が必要です。) 厳密な SQL モードおよび暗黙的なデフォルト値の詳細は、<a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a> および <a class="xref" href="data-types.html#data-type-defaults" title="11.6 データ型デフォルト値">セクション11.6「データ型デフォルト値」</a> を参照してください。 
            </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="rename-user"></a>13.7.1.7 RENAME USER ステートメント</h4></div></div></div><a class="indexterm" name="idm45826990445840"></a><a class="indexterm" name="idm45826990444352"></a><a class="indexterm" name="idm45826990442288"></a><pre class="programlisting">RENAME USER <em class="replaceable"><code>old_user</code></em> TO <em class="replaceable"><code>new_user</code></em>
    [, <em class="replaceable"><code>old_user</code></em> TO <em class="replaceable"><code>new_user</code></em>] ...
</pre><p>
        <code class="literal">RENAME USER</code> ステートメントは、既存の MySQL アカウントの名前を変更します。 存在しない古いアカウント、またはすでに存在する新しいアカウントに対しては、エラーが発生します。 
      </p><p>
        <code class="literal">RENAME USER</code> を使用するには、<code class="literal">mysql</code> システムスキーマに対するグローバル <code class="literal">CREATE USER</code> 権限または <code class="literal">UPDATE</code> 権限が必要です。 <code class="literal">read_only</code> システム変数が有効になっている場合、<code class="literal">RENAME USER</code> にはさらに <code class="literal">CONNECTION_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。 
      </p><p>
        MySQL 8.0.22 では、名前を変更するアカウントがストアドオブジェクトの <code class="literal">DEFINER</code> 属性として指定されている場合、<code class="literal">RENAME USER</code> はエラーで失敗します。 (つまり、アカウントの名前を変更すると、格納されているオブジェクトが孤立する場合、ステートメントは失敗します。) 操作を実行するには、<code class="literal">SET_USER_ID</code> 権限が必要です。この場合、ステートメントはエラーで失敗するのではなく、警告付きで成功します。 特定のアカウントを <code class="literal">DEFINER</code> 属性として指定するオブジェクトの識別方法などの追加情報は、<a class="xref" href="stored-objects.html#stored-objects-security-orphan-objects" title="孤立したストアドオブジェクト">孤立したストアドオブジェクト</a> を参照してください。 
      </p><p>
        各アカウント名には、<a class="xref" href="security.html#account-names" title="6.2.4 アカウント名の指定">セクション6.2.4「アカウント名の指定」</a>で説明されている形式が使用されます。 例: 
      </p><pre class="programlisting">RENAME USER 'jeffrey'@'localhost' TO 'jeff'@'127.0.0.1';
</pre><p>
        アカウント名のホスト名部分は、省略すると<code class="literal">'%'</code>にデフォルト設定されます。
      </p><p>
        <code class="literal">RENAME USER</code> により、古いユーザーによって保持されていた権限は新しいユーザーによって保持される権限になります。 ただし、<code class="literal">RENAME USER</code> は、古いユーザーが作成したどのデータベースまたはそれらのデータベース内のどのオブジェクトも自動的には削除したり、無効にしたりしません。 これには、<code class="literal">DEFINER</code> 属性に古いユーザーが指定されているストアドプログラムまたはビューが含まれます。 このようなオブジェクトにアクセスしようとすると、それが定義者のセキュリティーコンテキストで実行された場合は、エラーが生成される可能性があります。 (セキュリティーコンテキストについては、<a class="xref" href="stored-objects.html#stored-objects-security" title="25.6 ストアドオブジェクトのアクセス制御">セクション25.6「ストアドオブジェクトのアクセス制御」</a>を参照してください。)  
      </p><p>
        権限の変更は、<a class="xref" href="security.html#privilege-changes" title="6.2.13 権限変更が有効化される時期">セクション6.2.13「権限変更が有効化される時期」</a>に示されているように有効になります。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="revoke"></a>13.7.1.8 REVOKE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826990408336"></a><a class="indexterm" name="idm45826990406848"></a><a class="indexterm" name="idm45826990405936"></a><a class="indexterm" name="idm45826990403792"></a><a class="indexterm" name="idm45826990402432"></a><a class="indexterm" name="idm45826990400512"></a><a class="indexterm" name="idm45826990398368"></a><pre class="programlisting">REVOKE
    <em class="replaceable"><code>priv_type</code></em> [(<em class="replaceable"><code>column_list</code></em>)]
      [, <em class="replaceable"><code>priv_type</code></em> [(<em class="replaceable"><code>column_list</code></em>)]] ...
    ON [<em class="replaceable"><code>object_type</code></em>] <em class="replaceable"><code>priv_level</code></em>
    FROM <em class="replaceable"><code>user_or_role</code></em> [, <em class="replaceable"><code>user_or_role</code></em>] ...

REVOKE ALL [PRIVILEGES], GRANT OPTION
    FROM <em class="replaceable"><code>user_or_role</code></em> [, <em class="replaceable"><code>user_or_role</code></em>] ...

REVOKE PROXY ON <em class="replaceable"><code>user_or_role</code></em>
    FROM <em class="replaceable"><code>user_or_role</code></em> [, <em class="replaceable"><code>user_or_role</code></em>] ...

REVOKE <em class="replaceable"><code>role</code></em> [, <em class="replaceable"><code>role</code></em> ] ...
    FROM <em class="replaceable"><code>user_or_role</code></em> [, <em class="replaceable"><code>user_or_role</code></em> ] ...

<em class="replaceable"><code>user_or_role</code></em>: {
    <em class="replaceable"><code>user</code></em> (see <a class="xref" href="security.html#account-names" title="6.2.4 アカウント名の指定">セクション6.2.4「アカウント名の指定」</a>)
  | <em class="replaceable"><code>role</code></em> (see <a class="xref" href="security.html#role-names" title="6.2.5 ロール名の指定">セクション6.2.5「ロール名の指定」</a>.
}
</pre><p>
        <code class="literal">REVOKE</code> ステートメントを使用すると、システム管理者は、ユーザーアカウントおよびロールから取り消すことができる権限およびロールを取り消すことができます。
      </p><p>
        権限が存在するレベル、許可される <em class="replaceable"><code>priv_type</code></em>、<em class="replaceable"><code>priv_level</code></em> および <em class="replaceable"><code>object_type</code></em> の値、およびユーザーとパスワードを指定する構文の詳細は、<a class="xref" href="sql-statements.html#grant" title="13.7.1.6 GRANT ステートメント">セクション13.7.1.6「GRANT ステートメント」</a> を参照してください。
      </p><p>
        ロールの詳細は、<a class="xref" href="security.html#roles" title="6.2.10 ロールの使用">セクション6.2.10「ロールの使用」</a> を参照してください。
      </p><p>
        <code class="literal">read_only</code> システム変数が有効になっている場合、<code class="literal">REVOKE</code> には、次の説明で説明する他の必要な権限に加えて、<code class="literal">CONNECTION_ADMIN</code> または権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。
      </p><p>
        <code class="literal">REVOKE</code> は、指定されたすべてのユーザーおよびロールに対して成功するか、ロールバックされ、エラーが発生しても効果はありません。 ステートメントは、指定されたすべてのユーザーおよび役割で成功した場合にのみバイナリログに書き込まれます。 
      </p><p>
        各アカウント名には、<a class="xref" href="security.html#account-names" title="6.2.4 アカウント名の指定">セクション6.2.4「アカウント名の指定」</a>で説明されている形式が使用されます。 各ロール名は、<a class="xref" href="security.html#role-names" title="6.2.5 ロール名の指定">セクション6.2.5「ロール名の指定」</a> で説明されている形式を使用します。 例: 
      </p><pre class="programlisting">REVOKE INSERT ON *.* FROM 'jeffrey'@'localhost';
REVOKE 'role1', 'role2' FROM 'user1'@'localhost', 'user2'@'localhost';
REVOKE SELECT ON world.* FROM 'role3';
</pre><p>
        アカウント名またはロール名のホスト名部分は、省略すると<code class="literal">'%'</code>にデフォルト設定されます。
      </p><p>
        最初の <code class="literal">REVOKE</code> 構文を使用するには、<code class="literal">GRANT OPTION</code> 権限が必要であり、かつ取り消そうとしている権限を持っている必要があります。
      </p><p>
        すべての権限を取り消すには、2 番目の構文を使用します。この構文では、指定したユーザーまたはロールのすべてのグローバル、データベース、テーブル、カラムおよびルーチン権限が削除されます:
      </p><pre class="programlisting">REVOKE ALL PRIVILEGES, GRANT OPTION
  FROM <em class="replaceable"><code>user_or_role</code></em> [, <em class="replaceable"><code>user_or_role</code></em>] ...
</pre><p>
        <code class="literal">REVOKE ALL PRIVILEGES, GRANT OPTION</code> はロールを取り消しません。
      </p><p>
        この <code class="literal">REVOKE</code> 構文を使用するには、<code class="literal">mysql</code> システムスキーマに対するグローバル <code class="literal">CREATE USER</code> 権限または <code class="literal">UPDATE</code> 権限が必要です。
      </p><p>
        <code class="literal">REVOKE</code> キーワードの後に 1 つ以上のロール名が続く構文では、ロールを取り消す 1 つ以上のユーザーまたはロールを示す <code class="literal">FROM</code> 句を使用します。
      </p><p>
        <code class="literal">mandatory_roles</code> システム変数値で指定されたロールは取り消すことができません。
      </p><p>
        取り消されたロールは、取り消されたすべてのユーザーアカウントに即時に影響し、アカウントの現在のセッション内で、次に実行されるステートメントの権限が調整されます。
      </p><p>
        ロールを取り消すと、ロール自体が取り消され、ロールが表す権限は取り消されません。 アカウントに特定の権限を含むロールが付与され、その権限が明示的に付与されているか、その権限を含む別のロールが付与されているとします。 この場合、最初のロールが取り消されても、アカウントにはその権限があります。 たとえば、アカウントにそれぞれ <code class="literal">SELECT</code> を含む 2 つのロールが付与されている場合、そのアカウントはいずれかのロールが取り消された後も選択できます。 
      </p><p>
        <code class="literal">REVOKE ALL ON *.*</code> (グローバルレベル) は、付与されたすべての静的グローバル権限および付与されたすべての動的権限を取り消します。
      </p><p>
        権限およびロールを取り消すユーザーアカウントおよびロールは存在する必要がありますが、取り消す権限およびロールは現在付与されている必要はありません。
      </p><p>
        サーバーに付与されているが既知ではない取り消された権限は、警告付きで取り消されます。 この状況は、動的権限に対して発生する可能性があります。 たとえば、動的権限は、それを登録するコンポーネントがインストールされている間に付与できますが、その後そのコンポーネントがアンインストールされると、権限を所有しているアカウントはまだその権限を所有しており、取り消すことができます。 
      </p><p>
        <code class="literal">REVOKE</code> では権限は削除されますが、<code class="literal">mysql.user</code> システムテーブルから行は削除されません。 ユーザーアカウント全体を削除するには、<code class="literal">DROP USER</code> を使用します。 <a class="xref" href="sql-statements.html#drop-user" title="13.7.1.5 DROP USER ステートメント">セクション13.7.1.5「DROP USER ステートメント」</a>を参照してください。 
      </p><p>
        付与テーブルに、大文字と小文字が混在したデータベースまたはテーブル名を含む権限行が保持されており、かつ <code class="literal">lower_case_table_names</code> システム変数が 0 以外の値に設定されている場合は、<code class="literal">REVOKE</code> を使用してこれらの権限を取り消すことはできません。 このような場合は、付与テーブルを直接操作する必要があります。 (<code class="literal">lower_case_table_names</code> が設定されている場合、<code class="literal">GRANT</code> はこのような行を作成しませんが、変数を設定する前にこのような行が作成されている可能性があります。 <code class="literal">lower_case_table_names</code> 設定は、サーバーの初期化時にのみ構成できます。) 
      </p><p>
        <span class="command"><strong>mysql</strong></span> プログラムから正常に実行された場合、<code class="literal">REVOKE</code> は <code class="literal">Query OK, 0 rows affected</code> で応答します。 操作後に残っている権限を確認するには、<code class="literal">SHOW GRANTS</code> を使用します。 <a class="xref" href="sql-statements.html#show-grants" title="13.7.7.21 SHOW GRANTS ステートメント">セクション13.7.7.21「SHOW GRANTS ステートメント」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="set-default-role"></a>13.7.1.9 SET DEFAULT ROLE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826990327392"></a><a class="indexterm" name="idm45826990325888"></a><a class="indexterm" name="idm45826990324224"></a><pre class="programlisting">SET DEFAULT ROLE
    {NONE | ALL | <em class="replaceable"><code>role</code></em> [, <em class="replaceable"><code>role</code></em> ] ...}
    TO <em class="replaceable"><code>user</code></em> [, <em class="replaceable"><code>user</code></em> ] ...
</pre><p>
        このステートメントは、<code class="literal">TO</code> キーワードの直後に指定された <em class="replaceable"><code>user</code></em> ごとに、ユーザーがサーバーに接続して認証したとき、またはユーザーがセッション中に <code class="literal">SET ROLE DEFAULT</code> ステートメントを実行したときにアクティブになる役割を定義します。
      </p><p>
        <code class="literal">SET DEFAULT ROLE</code> は、<code class="literal">ALTER USER ... DEFAULT ROLE</code> の代替構文です (<a class="xref" href="sql-statements.html#alter-user" title="13.7.1.1 ALTER USER ステートメント">セクション13.7.1.1「ALTER USER ステートメント」</a> を参照)。 ただし、<code class="literal">ALTER USER</code> では単一のユーザーに対してのみデフォルトを設定できますが、<code class="literal">SET DEFAULT ROLE</code> では複数のユーザーに対してデフォルトを設定できます。 一方、<code class="literal">ALTER USER</code> ステートメントのユーザー名として <code class="literal">CURRENT_USER</code> を指定できますが、<code class="literal">SET DEFAULT ROLE</code> のユーザー名は指定できません。 
      </p><p>
        <code class="literal">SET DEFAULT ROLE</code> には、次の権限が必要です:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            別のユーザーのデフォルトロールを設定するには、<code class="literal">mysql.default_roles</code> システムテーブルに対するグローバル <code class="literal">CREATE USER</code> 権限または <code class="literal">UPDATE</code> 権限が必要です。
          </p></li><li class="listitem"><p>
            自分のデフォルトロールを設定する場合、デフォルトとして必要なロールが付与されているかぎり、特別な権限は必要ありません。
          </p></li></ul></div><p>
        各ロール名は、<a class="xref" href="security.html#role-names" title="6.2.5 ロール名の指定">セクション6.2.5「ロール名の指定」</a> で説明されている形式を使用します。 例: 
      </p><pre class="programlisting">SET DEFAULT ROLE administrator, developer TO 'joe'@'10.0.0.1';
</pre><p>
        ロール名のホスト名部分は、省略すると<code class="literal">'%'</code>にデフォルト設定されます。
      </p><p>
        <code class="literal">DEFAULT ROLE</code> キーワードに続く句では、次の値が許可されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">NONE</code>: デフォルトを <code class="literal">NONE</code> (ロールなし) に設定します。
          </p></li><li class="listitem"><p>
            <code class="literal">ALL</code>: アカウントに付与されているすべてのロールにデフォルトを設定します。
          </p></li><li class="listitem"><p>
            <code class="literal"><em class="replaceable"><code>role</code></em> [, <em class="replaceable"><code>role</code></em> ] ...</code>: デフォルトを名前付きロールに設定します。このロールは、<code class="literal">SET DEFAULT ROLE</code> の実行時に存在し、アカウントに付与される必要があります。
          </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">SET DEFAULT ROLE</code> と <code class="literal">SET ROLE DEFAULT</code> は異なるステートメントです:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">SET DEFAULT ROLE</code> では、アカウントセッション内でデフォルトでアクティブ化するアカウントロールを定義します。
            </p></li><li class="listitem"><p>
              <code class="literal">SET ROLE DEFAULT</code> は、現在のセッション内のアクティブロールを現在のアカウントのデフォルトロールに設定します。
            </p></li></ul></div></div><p>
        ロールの使用例は、<a class="xref" href="security.html#roles" title="6.2.10 ロールの使用">セクション6.2.10「ロールの使用」</a> を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="set-password"></a>13.7.1.10 SET PASSWORD ステートメント</h4></div></div></div><a class="indexterm" name="idm45826990275456"></a><a class="indexterm" name="idm45826990273968"></a><a class="indexterm" name="idm45826990271936"></a><pre class="programlisting">SET PASSWORD [FOR <em class="replaceable"><code>user</code></em>] <em class="replaceable"><code>auth_option</code></em>
    [REPLACE '<em class="replaceable"><code>current_auth_string</code></em>']
    [RETAIN CURRENT PASSWORD]

<em class="replaceable"><code>auth_option</code></em>: {
    = '<em class="replaceable"><code>auth_string</code></em>'
  | TO RANDOM
}
</pre><p>
        <code class="literal">SET PASSWORD</code> ステートメントは、MySQL ユーザーアカウントにパスワードを割り当てます。 パスワードは、ステートメントで明示的に指定するか、MySQL によってランダムに生成されます。 このステートメントには、置換するアカウントの現在のパスワードを指定する password-verification 句と、アカウントにセカンダリパスワードがあるかどうかを管理する句を含めることもできます。<code class="literal">'<em class="replaceable"><code>auth_string</code></em>'</code>および<code class="literal">'<em class="replaceable"><code>current_auth_string</code></em>'</code>はそれぞれクリアテキスト (暗号化されていない) パスワードを表します。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">SET PASSWORD</code> を使用してパスワードを割り当てるのではなく、<code class="literal">ALTER USER</code> はアカウントの変更 (パスワードの割当てを含む) に優先ステートメントです。 例: 
        </p><pre class="programlisting">ALTER USER <em class="replaceable"><code>user</code></em> IDENTIFIED BY '<em class="replaceable"><code>auth_string</code></em>';
</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          ランダムパスワード生成、パスワード検証およびセカンダリパスワードの句は、資格証明を MySQL に内部的に格納する認証プラグインを使用するアカウントにのみ適用されます。 MySQL の外部にある資格証明システムに対して認証を実行するプラグインを使用するアカウントの場合、パスワード管理もそのシステムに対して外部で処理する必要があります。 内部資格証明記憶域の詳細は、<a class="xref" href="security.html#password-management" title="6.2.15 パスワード管理">セクション6.2.15「パスワード管理」</a> を参照してください。 
        </p></div><p>
        <code class="literal">REPLACE '<em class="replaceable"><code>current_auth_string</code></em>'</code>句はパスワード検証を実行し、MySQL 8.0.13 の時点で使用できます。 指定された場合: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">REPLACE</code> は、置換するアカウントの現在のパスワードをクリアテキスト (暗号化されていない) 文字列として指定します。
          </p></li><li class="listitem"><p>
            現在のパスワードを指定するためにアカウントのパスワード変更が必要な場合は、変更しようとしているユーザーが実際に現在のパスワードを知っていることを確認するために、句を指定する必要があります。
          </p></li><li class="listitem"><p>
            アカウントのパスワードが変更される可能性があるが、現在のパスワードを指定する必要がない場合、句はオプションです。
          </p></li><li class="listitem"><p>
            句が指定されているが、句がオプションであっても現在のパスワードと一致しない場合、ステートメントは失敗します。
          </p></li><li class="listitem"><p>
            <code class="literal">REPLACE</code> は、現在のユーザーのアカウントパスワードを変更する場合にのみ指定できます。
          </p></li></ul></div><p>
        現在のパスワードを指定したパスワード検証の詳細は、<a class="xref" href="security.html#password-management" title="6.2.15 パスワード管理">セクション6.2.15「パスワード管理」</a> を参照してください。
      </p><p>
        <code class="literal">RETAIN CURRENT PASSWORD</code> 句はデュアルパスワード機能を実装し、MySQL 8.0.14 の時点で使用できます。 指定された場合: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">RETAIN CURRENT PASSWORD</code> は、アカウントの現在のパスワードをセカンダリパスワードとして保持し、既存のセカンダリパスワードを置き換えます。 新しいパスワードはプライマリパスワードになりますが、クライアントはアカウントを使用して、プライマリパスワードまたはセカンダリパスワードのいずれかを使用してサーバーに接続できます。 (例外: <code class="literal">SET PASSWORD</code> ステートメントで指定された新しいパスワードが空の場合、<code class="literal">RETAIN CURRENT PASSWORD</code> が指定されていても、セカンダリパスワードも空になります。) 
          </p></li><li class="listitem"><p>
            プライマリパスワードが空のアカウントに <code class="literal">RETAIN CURRENT PASSWORD</code> を指定すると、ステートメントは失敗します。
          </p></li><li class="listitem"><p>
            アカウントにセカンダリパスワードがあり、<code class="literal">RETAIN CURRENT PASSWORD</code> を指定せずにプライマリパスワードを変更した場合、セカンダリパスワードは変更されません。
          </p></li></ul></div><p>
        デュアルパスワードの使用の詳細は、<a class="xref" href="security.html#password-management" title="6.2.15 パスワード管理">セクション6.2.15「パスワード管理」</a> を参照してください。
      </p><p>
        <code class="literal">SET PASSWORD</code> では、次の <em class="replaceable"><code>auth_option</code></em> 構文が許可されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">= '<em class="replaceable"><code>auth_string</code></em>'</code>
          </p><p>
            アカウントに指定されたリテラルパスワードを割り当てます。
          </p></li><li class="listitem"><p>
            <code class="literal">TO RANDOM</code>
          </p><p>
            MySQL によってランダムに生成されたパスワードをアカウントに割り当てます。 このステートメントは、ステートメントを実行しているユーザーまたはアプリケーションが使用できるように、クリアテキストのパスワードも結果セットに返します。 
          </p><p>
            ランダムに生成されるパスワードの結果セットおよび特性の詳細は、<a class="xref" href="security.html#random-password-generation" title="ランダムパスワード生成">ランダムパスワード生成</a> を参照してください。
          </p><p>
            ランダムパスワード生成は、MySQL 8.0.18 の時点で使用できます。
          </p></li></ul></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          状況によっては、<code class="literal">SET PASSWORD</code> がサーバーログ、またはクライアント側にある <code class="filename">~/.mysql_history</code> などの履歴ファイル内に記録されることがあります。つまり、平文のパスワードが、その情報に対する読み取りアクセス権を持つ任意のユーザーによって読み取られる可能性があります。 これがサーバーログで発生する条件およびこれを制御する方法については、<a class="xref" href="security.html#password-logging" title="6.1.2.3 パスワードおよびロギング">セクション6.1.2.3「パスワードおよびロギング」</a>を参照してください。 クライアント側のロギングに関する同様の情報については、<a class="xref" href="programs.html#mysql-logging" title="4.5.1.3 mysql クライアントロギング">セクション4.5.1.3「mysql クライアントロギング」</a>を参照してください。 
        </p></div><p>
        <code class="literal">SET PASSWORD</code> は、ユーザーアカウントを明示的に指定する <code class="literal">FOR</code> 句の有無にかかわらず使用できます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            このステートメントでは、<code class="literal">FOR <em class="replaceable"><code>user</code></em></code> 句を使用して、存在する必要がある指定アカウントのパスワードを設定します:
          </p><pre class="programlisting">SET PASSWORD FOR 'jeffrey'@'localhost' = '<em class="replaceable"><code>auth_string</code></em>';
</pre></li><li class="listitem"><p>
            <code class="literal">FOR <em class="replaceable"><code>user</code></em></code> 句を指定しない場合、ステートメントは現在のユーザーのパスワードを設定します:
          </p><pre class="programlisting">SET PASSWORD = '<em class="replaceable"><code>auth_string</code></em>';
</pre><p>
            匿名以外のアカウントを使用してサーバーに接続したクライアントはすべて、そのアカウントのパスワードを変更できます。 (特に、自分のパスワードを変更できます。) サーバーが認証したアカウントを確認するには、<code class="literal">CURRENT_USER()</code> 関数を呼び出します: 
          </p><pre class="programlisting">SELECT CURRENT_USER();
</pre></li></ul></div><p>
        <code class="literal">FOR <em class="replaceable"><code>user</code></em></code> 句が指定されている場合、このアカウント名には、<a class="xref" href="security.html#account-names" title="6.2.4 アカウント名の指定">セクション6.2.4「アカウント名の指定」</a>で説明されている形式が使用されます。 例: 
      </p><pre class="programlisting">SET PASSWORD FOR 'bob'@'%.example.org' = '<em class="replaceable"><code>auth_string</code></em>';
</pre><p>
        アカウント名のホスト名部分は、省略すると<code class="literal">'%'</code>にデフォルト設定されます。
      </p><p>
        <code class="literal">SET PASSWORD</code> は、この文字列をクリアテキスト文字列として解釈し、アカウントに関連付けられた認証プラグインに渡して、プラグインによって返された結果を <code class="literal">mysql.user</code> システムテーブルのアカウント行に格納します。 (プラグインには、期待される暗号化形式に値をハッシュする機会が与えられます。 プラグインは、指定された値を使用できます。この場合、ハッシュは発生しません。) 
      </p><p>
        (<code class="literal">FOR</code> 句を使用して) 名前付きアカウントのパスワードを設定するには、<code class="literal">mysql</code> システムスキーマに対する <code class="literal">UPDATE</code> 権限が必要です。 (<code class="literal">FOR</code> 句のない匿名以外のアカウントの場合) 自分のパスワードを設定する場合、特別な権限は必要ありません。 
      </p><p>
        セカンダリパスワードを変更するステートメントには、次の権限が必要です:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            自分のアカウントに適用される <code class="literal">SET PASSWORD</code> ステートメントに <code class="literal">RETAIN CURRENT PASSWORD</code> 句を使用するには、<code class="literal">APPLICATION_PASSWORD_ADMIN</code> 権限が必要です。 ほとんどのユーザーは 1 つのパスワードのみを必要とするため、自分のセカンダリパスワードを操作するには権限が必要です。 
          </p></li><li class="listitem"><p>
            アカウントがすべてのアカウントのセカンダリパスワードの操作を許可される場合は、<code class="literal">APPLICATION_PASSWORD_ADMIN</code> ではなく <code class="literal">CREATE USER</code> 権限を付与する必要があります。
          </p></li></ul></div><p>
        <code class="literal">read_only</code> システム変数が有効になっている場合、<code class="literal">SET PASSWORD</code> には、他の必要な権限に加えて、<code class="literal">CONNECTION_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。
      </p><p>
        パスワードと認証プラグインの設定の詳細は、<a class="xref" href="security.html#assigning-passwords" title="6.2.14 アカウントパスワードの割り当て">セクション6.2.14「アカウントパスワードの割り当て」</a>および<a class="xref" href="security.html#pluggable-authentication" title="6.2.17 プラガブル認証">セクション6.2.17「プラガブル認証」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="set-role"></a>13.7.1.11 SET ROLE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826990176512"></a><a class="indexterm" name="idm45826990175024"></a><a class="indexterm" name="idm45826990172992"></a><pre class="programlisting">SET ROLE {
    DEFAULT
  | NONE
  | ALL
  | ALL EXCEPT <em class="replaceable"><code>role</code></em> [, <em class="replaceable"><code>role</code></em> ] ...
  | <em class="replaceable"><code>role</code></em> [, <em class="replaceable"><code>role</code></em> ] ...
}
</pre><p>
        <code class="literal">SET ROLE</code> では、付与されたロールのうちアクティブなロールを指定することで、現行セッション内の現行ユーザーの有効な権限が変更されます。 付与されるロールには、ユーザーに明示的に付与されるロールと、<code class="literal">mandatory_roles</code> システム変数値で指定されるロールが含まれます。 
      </p><p>
        例:
      </p><pre class="programlisting">SET ROLE DEFAULT;
SET ROLE 'role1', 'role2';
SET ROLE ALL;
SET ROLE ALL EXCEPT 'role1', 'role2';
</pre><p>
        各ロール名は、<a class="xref" href="security.html#role-names" title="6.2.5 ロール名の指定">セクション6.2.5「ロール名の指定」</a> で説明されている形式を使用します。 ロール名のホスト名部分は、省略すると<code class="literal">'%'</code>にデフォルト設定されます。 
      </p><p>
        ユーザーに (ロールを介してではなく) 直接付与された権限は、アクティブなロールに対する変更の影響を受けません。
      </p><p>
        このステートメントは、次の役割指定子を許可します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">DEFAULT</code>: アカウントのデフォルトロールをアクティブ化します。 デフォルトのロールは、<code class="literal">SET DEFAULT ROLE</code> で指定されたロールです。 
          </p><p>
            ユーザーがサーバーに接続して正常に認証されると、サーバーはデフォルトロールとしてアクティブ化するロールを決定します。 <code class="literal">activate_all_roles_on_login</code> システム変数が有効な場合、サーバーは付与されたすべてのロールをアクティブ化します。 それ以外の場合、サーバーは <code class="literal">SET ROLE DEFAULT</code> を暗黙的に実行します。 サーバーは、アクティブ化できるデフォルトのロールのみをアクティブ化します。 サーバーは、アクティブ化できないデフォルトロールのエラーログに警告を書き込みますが、クライアントは警告を受け取りません。 
          </p><p>
            ユーザーがセッション中に <code class="literal">SET ROLE DEFAULT</code> を実行する場合、デフォルトロールをアクティブ化できないと (存在しない場合やユーザーに付与されていない場合など)、エラーが発生します。 この場合、現在アクティブなロールは変更されません。 
          </p></li><li class="listitem"><p>
            <code class="literal">NONE</code>: アクティブなロールを <code class="literal">NONE</code> に設定します (アクティブなロールはありません)。
          </p></li><li class="listitem"><p>
            <code class="literal">ALL</code>: アカウントに付与されているすべてのロールをアクティブ化します。
          </p></li><li class="listitem"><p>
            <code class="literal">ALL EXCEPT <em class="replaceable"><code>role</code></em> [, <em class="replaceable"><code>role</code></em> ] ...</code>: 指定されたロールを除く、アカウントに付与されているすべてのロールをアクティブ化します。 指定したロールが存在しているか、アカウントに付与されている必要はありません。 
          </p></li><li class="listitem"><p>
            <code class="literal"><em class="replaceable"><code>role</code></em> [, <em class="replaceable"><code>role</code></em> ] ...</code>: アカウントに付与する必要がある名前付きロールをアクティブ化します。
          </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">SET DEFAULT ROLE</code> と <code class="literal">SET ROLE DEFAULT</code> は異なるステートメントです:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">SET DEFAULT ROLE</code> では、アカウントセッション内でデフォルトでアクティブ化するアカウントロールを定義します。
            </p></li><li class="listitem"><p>
              <code class="literal">SET ROLE DEFAULT</code> は、現在のセッション内のアクティブロールを現在のアカウントのデフォルトロールに設定します。
            </p></li></ul></div></div><p>
        ロールの使用例は、<a class="xref" href="security.html#roles" title="6.2.10 ロールの使用">セクション6.2.10「ロールの使用」</a> を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="resource-group-statements"></a>13.7.2 リソースグループ管理ステートメント</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#alter-resource-group">13.7.2.1 ALTER RESOURCE GROUP ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#create-resource-group">13.7.2.2 CREATE RESOURCE GROUP ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-resource-group">13.7.2.3 DROP RESOURCE GROUP ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#set-resource-group">13.7.2.4 SET RESOURCE GROUP ステートメント</a></span></dt></dl></div><a class="indexterm" name="idm45826990128880"></a><p>
      MySQL では、リソースグループの作成および管理がサポートされており、グループで使用可能なリソースに従ってスレッドが実行されるように、サーバー内で実行されているスレッドを特定のグループに割り当てることができます。 このセクションでは、リソースグループ管理に使用できる SQL ステートメントについて説明します。 リソースグループ機能の一般的な説明については、<a class="xref" href="server-administration.html#resource-groups" title="5.1.16 リソースグループ">セクション5.1.16「リソースグループ」</a> を参照してください。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="alter-resource-group"></a>13.7.2.1 ALTER RESOURCE GROUP ステートメント</h4></div></div></div><a class="indexterm" name="idm45826990124096"></a><pre class="programlisting">ALTER RESOURCE GROUP <em class="replaceable"><code>group_name</code></em>
    [VCPU [=] <em class="replaceable"><code>vcpu_spec</code></em> [, <em class="replaceable"><code>vcpu_spec</code></em>] ...]
    [THREAD_PRIORITY [=] <em class="replaceable"><code>N</code></em>]
    [ENABLE|DISABLE [FORCE]]

<em class="replaceable"><code>vcpu_spec</code></em>: {<em class="replaceable"><code>N</code></em> | <em class="replaceable"><code>M</code></em> - <em class="replaceable"><code>N</code></em>}
</pre><p>
        <code class="literal">ALTER RESOURCE GROUP</code> は、リソースグループの管理に使用されます (<a class="xref" href="server-administration.html#resource-groups" title="5.1.16 リソースグループ">セクション5.1.16「リソースグループ」</a> を参照)。 このステートメントは、既存のリソースグループの変更可能な属性を変更します。 <code class="literal">RESOURCE_GROUP_ADMIN</code> 権限が必要です。 
      </p><p>
        <em class="replaceable"><code>group_name</code></em> は、変更するリソースグループを識別します。 グループが存在しない場合は、エラーが発生します。 
      </p><p>
        CPU アフィニティ、優先度、およびグループが有効かどうかの属性は、<code class="literal">ALTER RESOURCE GROUP</code> で変更できます。 これらの属性は、<code class="literal">CREATE RESOURCE GROUP</code> の場合と同じ方法で指定します (<a class="xref" href="sql-statements.html#create-resource-group" title="13.7.2.2 CREATE RESOURCE GROUP ステートメント">セクション13.7.2.2「CREATE RESOURCE GROUP ステートメント」</a> を参照)。 指定された属性のみが変更されます。 未指定の属性は現在の値を保持します。 
      </p><p>
        <code class="literal">FORCE</code> 修飾子は、<code class="literal">DISABLE</code> で使用されます。 リソースグループにスレッドが割り当てられている場合のステートメントの動作を決定します: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">FORCE</code> が指定されていない場合、グループ内の既存のスレッドは終了するまで実行され続けますが、新しいスレッドをグループに割り当てることはできません。
          </p></li><li class="listitem"><p>
            <code class="literal">FORCE</code> が指定されている場合、グループ内の既存のスレッドはそれぞれのデフォルトグループ (<code class="literal">SYS_default</code> へのシステムスレッド、<code class="literal">USR_default</code> へのユーザースレッド) に移動されます。
          </p></li></ul></div><p>
        name および type 属性はグループの作成時に設定され、<code class="literal">ALTER RESOURCE GROUP</code> で変更することはできません。
      </p><p>
        例:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            グループ CPU アフィニティを変更します:
          </p><pre class="programlisting">ALTER RESOURCE GROUP rg1 VCPU = 0-63;
</pre></li><li class="listitem"><p>
            グループスレッドの優先度を変更します:
          </p><pre class="programlisting">ALTER RESOURCE GROUP rg2 THREAD_PRIORITY = 5;
</pre></li><li class="listitem"><p>
            グループを無効にし、そのグループに割り当てられているスレッドをデフォルトグループに移動します:
          </p><pre class="programlisting">ALTER RESOURCE GROUP rg3 DISABLE FORCE;
</pre></li></ul></div><p>
        リソースグループ管理は、リソースグループが発生したサーバーに対してローカルです。 <code class="literal">ALTER RESOURCE GROUP</code> ステートメントはバイナリログに書き込まれず、レプリケートされません。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="create-resource-group"></a>13.7.2.2 CREATE RESOURCE GROUP ステートメント</h4></div></div></div><a class="indexterm" name="idm45826990087536"></a><pre class="programlisting">CREATE RESOURCE GROUP <em class="replaceable"><code>group_name</code></em>
    TYPE = {SYSTEM|USER}
    [VCPU [=] <em class="replaceable"><code>vcpu_spec</code></em> [, <em class="replaceable"><code>vcpu_spec</code></em>] ...]
    [THREAD_PRIORITY [=] <em class="replaceable"><code>N</code></em>]
    [ENABLE|DISABLE]

<em class="replaceable"><code>vcpu_spec</code></em>: {<em class="replaceable"><code>N</code></em> | <em class="replaceable"><code>M</code></em> - <em class="replaceable"><code>N</code></em>}
</pre><p>
        <code class="literal">CREATE RESOURCE GROUP</code> は、リソースグループの管理に使用されます (<a class="xref" href="server-administration.html#resource-groups" title="5.1.16 リソースグループ">セクション5.1.16「リソースグループ」</a> を参照)。 このステートメントは、新しいリソースグループを作成し、その初期属性値を割り当てます。 <code class="literal">RESOURCE_GROUP_ADMIN</code> 権限が必要です。 
      </p><p>
        <em class="replaceable"><code>group_name</code></em> は、作成するリソースグループを識別します。 グループがすでに存在する場合は、エラーが発生します。 
      </p><p>
        <code class="literal">TYPE</code> 属性は必須です。 システムリソースグループの場合は <code class="literal">SYSTEM</code>、ユーザーリソースグループの場合は <code class="literal">USER</code> である必要があります。 グループタイプは、後で説明するように、許可される <code class="literal">THREAD_PRIORITY</code> 値に影響します。 
      </p><p>
        <code class="literal">VCPU</code> 属性は、CPU アフィニティ、つまりグループが使用できる仮想 CPU のセットを示します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">VCPU</code> が指定されていない場合、リソースグループは CPU アフィニティーを持たず、使用可能なすべての CPU を使用できます。
          </p></li><li class="listitem"><p>
            <code class="literal">VCPU</code> が指定されている場合、属性値はカンマ区切りの CPU 番号または範囲のリストです:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                各数値は、0 から CPU の数 -1 までの範囲の整数である必要があります。 たとえば、64 個の CPU を持つシステムでは、0 から 63 の範囲の数値を指定できます。 
              </p></li><li class="listitem"><p>
                範囲は <em class="replaceable"><code>M</code></em> <em class="replaceable"><code>N</code></em> の形式で指定します。ここで、<em class="replaceable"><code>M</code></em> は <em class="replaceable"><code>N</code></em> 以下で、両方の数値は CPU 範囲内にあります。
              </p></li><li class="listitem"><p>
                CPU 番号が許容範囲外の整数であるか、整数でない場合は、エラーが発生します。
              </p></li></ul></div></li></ul></div><p>
        <code class="literal">VCPU</code> 指定子の例 (これらはすべて同等です):
      </p><pre class="programlisting">VCPU = 0,1,2,3,9,10
VCPU = 0-3,9-10
VCPU = 9,10,0-3
VCPU = 0,10,1,9,3,2
</pre><p>
        <code class="literal">THREAD_PRIORITY</code> 属性は、グループに割り当てられたスレッドの優先度を示します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">THREAD_PRIORITY</code> が指定されていない場合、デフォルトの優先度は 0 です。
          </p></li><li class="listitem"><p>
            <code class="literal">THREAD_PRIORITY</code> が指定されている場合、属性値は -20 (最高優先度) から 19 (最低優先度) の範囲内である必要があります。 システムリソースグループの優先順位は -20 から 0 の範囲内である必要があります。 ユーザーリソースグループの優先順位は、0 から 19 の範囲内である必要があります。 システムグループとユーザーグループに異なる範囲を使用すると、ユーザースレッドの優先度がシステムスレッドより高くなることはありません。 
          </p></li></ul></div><p>
        <code class="literal">ENABLE</code> および <code class="literal">DISABLE</code> は、リソースグループを最初に有効または無効にすることを指定します。 どちらも指定しない場合、グループはデフォルトで有効になります。 無効化されたグループにスレッドを割り当てることはできません。 
      </p><p>
        例:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            単一の CPU と最も低い優先度を持つ有効なユーザーグループを作成します:
          </p><pre class="programlisting">CREATE RESOURCE GROUP rg1
  TYPE = USER
  VCPU = 0
  THREAD_PRIORITY = 19;
</pre></li><li class="listitem"><p>
            CPU アフィニティがなく (すべての CPU を使用できる)、優先度が最も高い無効なシステムグループを作成します:
          </p><pre class="programlisting">CREATE RESOURCE GROUP rg2
  TYPE = SYSTEM
  THREAD_PRIORITY = -20
  DISABLE;
</pre></li></ul></div><p>
        リソースグループ管理は、リソースグループが発生したサーバーに対してローカルです。 <code class="literal">CREATE RESOURCE GROUP</code> ステートメントはバイナリログに書き込まれず、レプリケートされません。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="drop-resource-group"></a>13.7.2.3 DROP RESOURCE GROUP ステートメント</h4></div></div></div><a class="indexterm" name="idm45826990041392"></a><pre class="programlisting">DROP RESOURCE GROUP <em class="replaceable"><code>group_name</code></em> [FORCE]
</pre><p>
        <code class="literal">DROP RESOURCE GROUP</code> は、リソースグループの管理に使用されます (<a class="xref" href="server-administration.html#resource-groups" title="5.1.16 リソースグループ">セクション5.1.16「リソースグループ」</a> を参照)。 このステートメントは、リソースグループを削除します。 <code class="literal">RESOURCE_GROUP_ADMIN</code> 権限が必要です。 
      </p><p>
        <em class="replaceable"><code>group_name</code></em> は、削除するリソースグループを識別します。 グループが存在しない場合は、エラーが発生します。 
      </p><p>
        <code class="literal">FORCE</code> 修飾子は、リソースグループにスレッドが割り当てられている場合のステートメントの動作を決定します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">FORCE</code> が指定されておらず、スレッドがグループに割り当てられている場合は、エラーが発生します。
          </p></li><li class="listitem"><p>
            <code class="literal">FORCE</code> が指定されている場合、グループ内の既存のスレッドはそれぞれのデフォルトグループ (<code class="literal">SYS_default</code> へのシステムスレッド、<code class="literal">USR_default</code> へのユーザースレッド) に移動されます。
          </p></li></ul></div><p>
        例:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            グループを削除します。グループにスレッドが含まれている場合は失敗します:
          </p><pre class="programlisting">DROP RESOURCE GROUP rg1;
</pre></li><li class="listitem"><p>
            グループを削除し、既存のスレッドをデフォルトグループに移動します:
          </p><pre class="programlisting">DROP RESOURCE GROUP rg2 FORCE;
</pre></li></ul></div><p>
        リソースグループ管理は、リソースグループが発生したサーバーに対してローカルです。 <code class="literal">DROP RESOURCE GROUP</code> ステートメントはバイナリログに書き込まれず、レプリケートされません。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="set-resource-group"></a>13.7.2.4 SET RESOURCE GROUP ステートメント</h4></div></div></div><a class="indexterm" name="idm45826990015936"></a><pre class="programlisting">SET RESOURCE GROUP <em class="replaceable"><code>group_name</code></em>
    [FOR <em class="replaceable"><code>thread_id</code></em> [, <em class="replaceable"><code>thread_id</code></em>] ...]
</pre><p>
        <code class="literal">SET RESOURCE GROUP</code> は、リソースグループの管理に使用されます (<a class="xref" href="server-administration.html#resource-groups" title="5.1.16 リソースグループ">セクション5.1.16「リソースグループ」</a> を参照)。 このステートメントは、スレッドをリソースグループに割り当てます。 <code class="literal">RESOURCE_GROUP_ADMIN</code> または <code class="literal">RESOURCE_GROUP_USER</code> 権限が必要です。 
      </p><p>
        <em class="replaceable"><code>group_name</code></em> は、割り当てるリソースグループを識別します。 <em class="replaceable"><code>thread_id</code></em> 値は、グループに割り当てるスレッドを示します。 スレッド ID は、パフォーマンススキーマ <code class="literal">threads</code> テーブルから決定できます。 リソースグループまたは名前付きスレッド ID が存在しない場合は、エラーが発生します。 
      </p><p>
        <code class="literal">FOR</code> 句を指定しない場合、ステートメントはセッションの現在のスレッドをリソースグループに割り当てます。
      </p><p>
        スレッド ID を指定する <code class="literal">FOR</code> 句を使用して、ステートメントはこれらのスレッドをリソースグループに割り当てます。
      </p><p>
        システムスレッドをユーザーリソースグループに割り当てようとするか、ユーザースレッドをシステムリソースグループに割り当てようとすると、警告が発生します。
      </p><p>
        例:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            現在のセッションスレッドをグループに割り当てます:
          </p><pre class="programlisting">SET RESOURCE GROUP rg1;
</pre></li><li class="listitem"><p>
            名前付きスレッドをグループに割り当てます:
          </p><pre class="programlisting">SET RESOURCE GROUP rg2 FOR 14, 78, 4;
</pre></li></ul></div><p>
        リソースグループ管理は、リソースグループが発生したサーバーに対してローカルです。 <code class="literal">SET RESOURCE GROUP</code> ステートメントはバイナリログに書き込まれず、レプリケートされません。 
      </p><p>
        <code class="literal">SET RESOURCE GROUP</code> のかわりに、個々のステートメントをリソースグループに割り当てる <code class="literal">RESOURCE_GROUP</code> オプティマイザヒントがあります。 <a class="xref" href="optimization.html#optimizer-hints" title="8.9.3 オプティマイザヒント">セクション8.9.3「オプティマイザヒント」</a>を参照してください。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="table-maintenance-statements"></a>13.7.3 テーブル保守ステートメント</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#analyze-table">13.7.3.1 ANALYZE TABLE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#check-table">13.7.3.2 CHECK TABLE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#checksum-table">13.7.3.3 CHECKSUM TABLE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#optimize-table">13.7.3.4 OPTIMIZE TABLE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#repair-table">13.7.3.5 REPAIR TABLE ステートメント</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="analyze-table"></a>13.7.3.1 ANALYZE TABLE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826989984704"></a><pre class="programlisting">ANALYZE [NO_WRITE_TO_BINLOG | LOCAL]
    TABLE <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ...

ANALYZE [NO_WRITE_TO_BINLOG | LOCAL]
    TABLE <em class="replaceable"><code>tbl_name</code></em>
    UPDATE HISTOGRAM ON <em class="replaceable"><code>col_name</code></em> [, <em class="replaceable"><code>col_name</code></em>] ...
        [WITH <em class="replaceable"><code>N</code></em> BUCKETS]

ANALYZE [NO_WRITE_TO_BINLOG | LOCAL]
    TABLE <em class="replaceable"><code>tbl_name</code></em>
    DROP HISTOGRAM ON <em class="replaceable"><code>col_name</code></em> [, <em class="replaceable"><code>col_name</code></em>] ...
</pre><p>
        <code class="literal">ANALYZE TABLE</code> では、テーブル統計が生成されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            どちらの <code class="literal">HISTOGRAM</code> 句も指定しない <code class="literal">ANALYZE TABLE</code> では、キー分散分析が実行され、指定したテーブルの分散が格納されます。 <code class="literal">MyISAM</code> テーブルの場合、キー配布分析用の <code class="literal">ANALYZE TABLE</code> は <span class="command"><strong>myisamchk --analyze</strong></span> の使用と同等です。 
          </p></li><li class="listitem"><p>
            <code class="literal">ANALYZE TABLE</code> で <code class="literal">UPDATE HISTOGRAM</code> 句を使用すると、指定したテーブルのカラムのヒストグラム統計が生成され、データディクショナリに格納されます。 この構文に使用できるテーブル名は 1 つだけです。 
          </p></li><li class="listitem"><p>
            <code class="literal">ANALYZE TABLE</code> で <code class="literal">DROP HISTOGRAM</code> 句を使用すると、指定したテーブルのカラムのヒストグラム統計がデータディクショナリから削除されます。 この構文に使用できるテーブル名は 1 つだけです。 
          </p></li></ul></div><p>
        このステートメントには、このテーブルに対する <code class="literal">SELECT</code> および <code class="literal">INSERT</code> 権限が必要です。
      </p><p>
        <code class="literal">ANALYZE TABLE</code> は、<code class="literal">InnoDB</code>、<code class="literal">NDB</code> および <code class="literal">MyISAM</code> テーブルで動作します。 ビューでは機能しません。 
      </p><p>
        <code class="literal">innodb_read_only</code> システム変数が有効になっている場合、<code class="literal">InnoDB</code> を使用するデータディクショナリの統計テーブルを更新できないため、<code class="literal">ANALYZE TABLE</code> が失敗することがあります。 キー分散を更新する <code class="literal">ANALYZE TABLE</code> 操作では、操作によってテーブル自体が更新された場合でも (<code class="literal">MyISAM</code> テーブルの場合など)、障害が発生する可能性があります。 更新された分散統計を取得するには、<code class="literal">information_schema_stats_expiry=0</code> を設定します。 
      </p><p>
        <code class="literal">ANALYZE TABLE</code> はパーティションテーブルでサポートされており、<code class="literal">ALTER TABLE ... ANALYZE PARTITION</code> を使用して 1 つ以上のパーティションを分析できます。詳細は、<a class="xref" href="sql-statements.html#alter-table" title="13.1.9 ALTER TABLE ステートメント">セクション13.1.9「ALTER TABLE ステートメント」</a> および <a class="xref" href="partitioning.html#partitioning-maintenance" title="24.3.4 パーティションの保守">セクション24.3.4「パーティションの保守」</a> を参照してください。
      </p><p>
        分析中、そのテーブルは <code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> に対する読み取りロックでロックされます。
      </p><p>
        <code class="literal">ANALYZE TABLE</code> は、フラッシュロックを必要とするテーブル定義キャッシュからテーブルを削除します。 長時間実行されているステートメントまたはトランザクションがまだテーブルを使用している場合、後続のステートメントおよびトランザクションは、フラッシュロックが解放される前にこれらの操作が終了するまで待機する必要があります。 通常、<code class="literal">ANALYZE TABLE</code> 自体は迅速に終了するため、同じテーブルを含む遅延トランザクションまたは遅延ステートメントが残りのフラッシュロックによるものであることは明らかではない場合があります。 
      </p><p>
        デフォルトでは、<code class="literal">ANALYZE TABLE</code> ステートメントはレプリカにレプリケートされるようにバイナリログに書き込まれます。 ロギングを抑制するには、オプションの <code class="literal">NO_WRITE_TO_BINLOG</code> キーワード、またはそのエイリアス <code class="literal">LOCAL</code> を指定します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#analyze-table-output" title="ANALYZE TABLE の出力">ANALYZE TABLE の出力</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#analyze-table-key-distribution-analysis" title="キー分布分析">キー分布分析</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#analyze-table-histogram-statistics-analysis" title="ヒストグラム統計分析">ヒストグラム統計分析</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#analyze-table-other-considerations" title="その他の考慮事項">その他の考慮事項</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="analyze-table-output"></a>ANALYZE TABLE の出力</h5></div></div></div><p>
          <code class="literal">ANALYZE TABLE</code> は、次のテーブルに示すカラムを含む結果セットを返します。
        </p><div class="informaltable"><table summary="Columns of the ANALYZE TABLE result set."><col style="width: 15%"><col style="width: 60%"><thead><tr>
              <th>カラム</th>
              <th>値</th>
            </tr></thead><tbody><tr>
              <td><code class="literal">Table</code></td>
              <td>テーブル名</td>
            </tr><tr>
              <td><code class="literal">Op</code></td>
              <td><code class="literal">analyze</code> または <code class="literal">histogram</code></td>
            </tr><tr>
              <td><code class="literal">Msg_type</code></td>
              <td><code class="literal">status</code>、<code class="literal">error</code>、<code class="literal">info</code>、<code class="literal">note</code>、または <code class="literal">warning</code></td>
            </tr><tr>
              <td><code class="literal">Msg_text</code></td>
              <td>情報メッセージ</td>
            </tr></tbody></table></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="analyze-table-key-distribution-analysis"></a>キー分布分析</h5></div></div></div><p>
          どちらの <code class="literal">HISTOGRAM</code> 句も指定しない <code class="literal">ANALYZE TABLE</code> では、キー分散分析が実行され、テーブルの分散が格納されます。 既存のヒストグラム統計は影響を受けません。 
        </p><p>
          前回のキー分散分析以降にテーブルが変更されていない場合、テーブルは再度分析されません。
        </p><p>
          MySQL では、格納されたキーの分散を使用して、定数以外の結合でテーブルを結合する順序を決定します。 さらに、クエリー内の特定のテーブルにどのインデックスを使用するかを決定する場合は、キー分布を使用できます。 
        </p><p>
          格納されているキー分散カーディナリティを確認するには、<code class="literal">SHOW INDEX</code> ステートメントまたは <code class="literal">INFORMATION_SCHEMA</code> <code class="literal">STATISTICS</code> テーブルを使用します。 <a class="xref" href="sql-statements.html#show-index" title="13.7.7.22 SHOW INDEX ステートメント">セクション13.7.7.22「SHOW INDEX ステートメント」</a>および<a class="xref" href="information-schema.html#information-schema-statistics-table" title="26.34 INFORMATION_SCHEMA STATISTICS テーブル">セクション26.34「INFORMATION_SCHEMA STATISTICS テーブル」</a>を参照してください。 
        </p><p>
          <code class="literal">InnoDB</code> テーブルの場合、<code class="literal">ANALYZE TABLE</code> は、各インデックスツリーでランダムな除算を実行し、それに応じてインデックスカーディナリティの見積りを更新することで、インデックスカーディナリティを決定します。 これらは単なる見積もりであるため、<code class="literal">ANALYZE TABLE</code> を繰り返し実行すると、別の数値が生成される可能性があります。 これによって <code class="literal">ANALYZE TABLE</code> の <code class="literal">InnoDB</code> テーブル上での速度は速くなりますが、すべての行が考慮されているわけではないため、100% 正確とは言えません。 
        </p><p>
          <a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="15.8.10.1 永続的オプティマイザ統計のパラメータの構成">セクション15.8.10.1「永続的オプティマイザ統計のパラメータの構成」</a> で説明されているように、<code class="literal">innodb_stats_persistent</code> を有効にすることで、<code class="literal">ANALYZE TABLE</code> によって収集された <a class="link" href="glossary.html#glos_statistics" title="統計">statistics</a> をより正確かつ安定させることができます。 <code class="literal">innodb_stats_persistent</code> が有効になっている場合、統計は定期的に再計算されないため (サーバーの再起動後など)、インデックスカラムデータに対する大きな変更後に <code class="literal">ANALYZE TABLE</code> を実行することが重要です。 
        </p><p>
          <code class="literal">innodb_stats_persistent</code> が有効になっている場合は、<code class="literal">innodb_stats_persistent_sample_pages</code> システム変数を変更することで、ランダムな除算の数を変更できます。 <code class="literal">innodb_stats_persistent</code> が無効になっている場合は、かわりに <code class="literal">innodb_stats_transient_sample_pages</code> を変更します。 
        </p><p>
          <code class="literal">InnoDB</code> でのキー配布分析の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="15.8.10.1 永続的オプティマイザ統計のパラメータの構成">セクション15.8.10.1「永続的オプティマイザ統計のパラメータの構成」</a> および <a class="xref" href="innodb-storage-engine.html#innodb-analyze-table-complexity" title="15.8.10.3 InnoDB テーブルに対する ANALYZE TABLE の複雑さの推定">セクション15.8.10.3「InnoDB テーブルに対する ANALYZE TABLE の複雑さの推定」</a> を参照してください。
        </p><p>
          MySQL では、結合の最適化にインデックスカーディナリティの見積りが使用されます。 結合が適切な方法で最適化されていない場合は、<code class="literal">ANALYZE TABLE</code> を実行してみてください。 <code class="literal">ANALYZE TABLE</code> では特定のテーブルに十分な値が生成されない場合は、特定のインデックスの使用を強制するクエリーとともに <code class="literal">FORCE INDEX</code> を使用するか、または MySQL でテーブルスキャンよりもインデックス検索が優先されるように <code class="literal">max_seeks_for_key</code> システム変数を設定してください。 <a class="xref" href="error-handling.html#optimizer-issues" title="B.3.5 オプティマイザ関連の問題">セクションB.3.5「オプティマイザ関連の問題」</a>を参照してください。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="analyze-table-histogram-statistics-analysis"></a>ヒストグラム統計分析</h5></div></div></div><p>
          <code class="literal">ANALYZE TABLE</code> で <code class="literal">HISTOGRAM</code> 句を使用すると、テーブルのカラム値のヒストグラム統計を管理できます。 ヒストグラム統計の詳細は、<a class="xref" href="optimization.html#optimizer-statistics" title="8.9.6 オプティマイザ統計">セクション8.9.6「オプティマイザ統計」</a> を参照してください。 
        </p><p>
          次のヒストグラム操作を使用できます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">ANALYZE TABLE</code> で <code class="literal">UPDATE HISTOGRAM</code> 句を使用すると、指定したテーブルのカラムのヒストグラム統計が生成され、データディクショナリに格納されます。 この構文に使用できるテーブル名は 1 つだけです。 
            </p><p>
              オプションの <code class="literal">WITH <em class="replaceable"><code>N</code></em> BUCKETS</code> 句では、ヒストグラムのバケット数を指定します。 <em class="replaceable"><code>N</code></em> の値は、1 から 1024 の範囲の整数である必要があります。 この句を省略すると、バケットの数は 100 になります。 
            </p></li><li class="listitem"><p>
              <code class="literal">ANALYZE TABLE</code> で <code class="literal">DROP HISTOGRAM</code> 句を使用すると、指定したテーブルのカラムのヒストグラム統計がデータディクショナリから削除されます。 この構文に使用できるテーブル名は 1 つだけです。 
            </p></li></ul></div><p>
          ストアドヒストグラム管理ステートメントは、名前付きのカラムにのみ影響します。 これらのステートメントを考慮してください。 
        </p><pre class="programlisting">ANALYZE TABLE t UPDATE HISTOGRAM ON c1, c2, c3 WITH 10 BUCKETS;
ANALYZE TABLE t UPDATE HISTOGRAM ON c1, c3 WITH 10 BUCKETS;
ANALYZE TABLE t DROP HISTOGRAM ON c2;
</pre><p>
          最初のステートメントは、<code class="literal">c1</code>、<code class="literal">c2</code> および <code class="literal">c3</code> カラムのヒストグラムを更新し、それらのカラムの既存のヒストグラムを置き換えます。 2 番目のステートメントは、<code class="literal">c1</code> および <code class="literal">c3</code> のヒストグラムを更新し、<code class="literal">c2</code> ヒストグラムは影響を受けません。 3 番目のステートメントは、<code class="literal">c2</code> のヒストグラムを削除し、<code class="literal">c1</code> および <code class="literal">c3</code> のヒストグラムは影響を受けません。 
        </p><p>
          ヒストグラム生成は、暗号化されたテーブル (統計内のデータの公開を回避するため) または <code class="literal">TEMPORARY</code> テーブルではサポートされていません。
        </p><p>
          ヒストグラム生成は、ジオメトリタイプ (空間データ) および <code class="literal">JSON</code> を除くすべてのデータ型のカラムに適用されます。
        </p><p>
          ヒストグラムは、格納されたカラムおよび仮想生成されたカラムに対して生成できます。
        </p><p>
          ヒストグラムは、単一カラムの一意インデックスでカバーされるカラムに対しては生成できません。
        </p><p>
          ヒストグラム管理ステートメントは、リクエストされた操作をできるだけ多く実行しようとし、残りの診断メッセージをレポートします。 たとえば、<code class="literal">UPDATE HISTOGRAM</code> ステートメントで複数のカラムを指定したが、その一部が存在しないか、サポートされていないデータ型を持つ場合、他のカラムに対してヒストグラムが生成され、無効なカラムに対してメッセージが生成されます。 
        </p><p>
          ヒストグラムは、次の DDL ステートメントの影響を受けます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">DROP TABLE</code> では、削除されたテーブルのカラムのヒストグラムが削除されます。
            </p></li><li class="listitem"><p>
              <code class="literal">DROP DATABASE</code> では、データベース内のすべてのテーブルが削除されるため、ステートメントは削除されたデータベース内のすべてのテーブルのヒストグラムを削除します。
            </p></li><li class="listitem"><p>
              <code class="literal">RENAME TABLE</code> ではヒストグラムは削除されません。 かわりに、名前を変更したテーブルが新しいテーブル名に関連付けられるようにヒストグラムの名前を変更します。 
            </p></li><li class="listitem"><p>
              カラムを削除または変更する <code class="literal">ALTER TABLE</code> ステートメントは、そのカラムのヒストグラムを削除します。
            </p></li><li class="listitem"><p>
              <code class="literal">ALTER TABLE ... CONVERT TO CHARACTER SET</code> では、文字セットの変更の影響を受けるため、文字カラムのヒストグラムは削除されます。 非文字カラムのヒストグラムは影響を受けません。 
            </p></li></ul></div><p>
          <code class="literal">histogram_generation_max_mem_size</code> システム変数は、ヒストグラム生成に使用できるメモリーの最大量を制御します。 グローバル値とセッション値は、実行時に設定できます。 
        </p><p>
          グローバル <code class="literal">histogram_generation_max_mem_size</code> 値を変更するには、グローバルシステム変数を設定するのに十分な権限が必要です。 セッションの <code class="literal">histogram_generation_max_mem_size</code> 値を変更するには、制限付きセッションシステム変数を設定するのに十分な権限が必要です。 <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 
        </p><p>
          ヒストグラム生成のためにメモリーに読み込まれるデータの推定量が <code class="literal">histogram_generation_max_mem_size</code> で定義されている制限を超える場合、MySQL はデータをすべてメモリーに読み取るのではなくサンプリングします。 サンプリングは、テーブル全体に均等に分散されます。 MySQL では、ページレベルのサンプリング方法である <code class="literal">SYSTEM</code> サンプリングを使用します。 
        </p><p>
          <code class="literal">INFORMATION_SCHEMA.COLUMN_STATISTICS</code> テーブルの <code class="literal">HISTOGRAM</code> カラムの <code class="literal">sampling-rate</code> 値をクエリーして、ヒストグラムを作成するためにサンプリングされたデータの割合を判断できます。 <code class="literal">sampling-rate</code> は、0.0 と 1.0 の間の数値です。 値 1 は、すべてのデータが読み取られたことを意味します (サンプリングなし)。 
        </p><p>
          次の例では、サンプリングを示します。 この例では、データ量が <code class="literal">histogram_generation_max_mem_size</code> の制限を超えていることを確認するために、<code class="literal">employees</code> テーブルの <code class="literal">birth_date</code> カラムのヒストグラム統計を生成する前に、制限は低い値 (2000000 バイト) に設定されます。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET histogram_generation_max_mem_size = 2000000;</code></strong>

mysql&gt; <strong class="userinput"><code>USE employees;</code></strong>

mysql&gt; <strong class="userinput"><code>ANALYZE TABLE employees UPDATE HISTOGRAM ON birth_date WITH 16 BUCKETS\G</code></strong>
*************************** 1. row ***************************
   Table: employees.employees
      Op: histogram
Msg_type: status
Msg_text: Histogram statistics created for column 'birth_date'.

mysql&gt; <strong class="userinput"><code>SELECT HISTOGRAM-&gt;&gt;'$."sampling-rate"'</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.COLUMN_STATISTICS</code></strong>
       <strong class="userinput"><code>WHERE TABLE_NAME = "employees"</code></strong>
       <strong class="userinput"><code>AND COLUMN_NAME = "birth_date";</code></strong>
+---------------------------------+
| HISTOGRAM-&gt;&gt;'$."sampling-rate"' |
+---------------------------------+
| 0.0491431208869665              |
+---------------------------------+
</pre><p>
          <code class="literal">sampling-rate</code> 値が 0.0491431208869665 の場合、<code class="literal">birth_date</code> カラムのデータの約 4.9% がヒストグラム統計を生成するためにメモリーに読み取られたことを意味します。
        </p><p>
          MySQL 8.0.19 の時点で、<code class="literal">InnoDB</code> ストレージエンジンは、<code class="literal">InnoDB</code> テーブルに格納されているデータに対して独自のサンプリング実装を提供します。 ストレージエンジンが独自のサンプリング実装を提供しない場合に MySQL で使用されるデフォルトのサンプリング実装では、大規模なテーブルに対してコストがかかる全テーブルスキャンが必要です。 <code class="literal">InnoDB</code> サンプリング実装では、全テーブルスキャンを回避することでサンプリングパフォーマンスが向上します。 
        </p><p>
          <code class="literal">sampled_pages_read</code> および <code class="literal">sampled_pages_skipped</code> <code class="literal">INNODB_METRICS</code> カウンタを使用して、<code class="literal">InnoDB</code> データページのサンプリングを監視できます。 (<code class="literal">INNODB_METRICS</code> カウンタの一般的な使用方法については、<a class="xref" href="information-schema.html#information-schema-innodb-metrics-table" title="26.51.22 INFORMATION_SCHEMA INNODB_METRICS テーブル">セクション26.51.22「INFORMATION_SCHEMA INNODB_METRICS テーブル」</a> を参照してください。) 
        </p><p>
          次の例は、ヒストグラム統計を生成する前にカウンタを有効にする必要があるサンプリングカウンタの使用方法を示しています。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_monitor_enable = 'sampled%';</code></strong>

mysql&gt; <strong class="userinput"><code>USE employees;</code></strong>

mysql&gt; <strong class="userinput"><code>ANALYZE TABLE employees UPDATE HISTOGRAM ON birth_date WITH 16 BUCKETS\G</code></strong>
*************************** 1. row ***************************
   Table: employees.employees
      Op: histogram
Msg_type: status
Msg_text: Histogram statistics created for column 'birth_date'.

mysql&gt; <strong class="userinput"><code>USE INFORMATION_SCHEMA;</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT NAME, COUNT FROM INNODB_METRICS WHERE NAME LIKE 'sampled%'\G</code></strong>
*************************** 1. row ***************************
 NAME: sampled_pages_read
COUNT: 43
*************************** 2. row ***************************
 NAME: sampled_pages_skipped
COUNT: 843
</pre><p>
          この式は、サンプリングカウンタデータに基づいてサンプリングレートを概算します:
        </p><pre class="programlisting">sampling rate = sampled_page_read/(sampled_pages_read + sampled_pages_skipped)
</pre><p>
          サンプリングカウンタデータに基づくサンプリングレートは、<code class="literal">INFORMATION_SCHEMA.COLUMN_STATISTICS</code> テーブルの <code class="literal">HISTOGRAM</code> カラムの <code class="literal">sampling-rate</code> 値とほぼ同じです。
        </p><p>
          ヒストグラム生成のために実行されるメモリー割り当てについては、パフォーマンススキーマ <code class="literal">memory/sql/histograms</code> インストゥルメントをモニターしてください。 <a class="xref" href="performance-schema.html#performance-schema-memory-summary-tables" title="27.12.18.10 メモリーサマリーテーブル">セクション27.12.18.10「メモリーサマリーテーブル」</a>を参照してください。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="analyze-table-other-considerations"></a>その他の考慮事項</h5></div></div></div><p>
          <code class="literal">ANALYZE TABLE</code> は、<code class="literal">INFORMATION_SCHEMA.INNODB_TABLESTATS</code> テーブルからテーブル統計をクリアし、<code class="literal">STATS_INITIALIZED</code> カラムを <code class="literal">Uninitialized</code> に設定します。 統計は、次回テーブルにアクセスしたときに再度収集されます。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="check-table"></a>13.7.3.2 CHECK TABLE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826989777392"></a><pre class="programlisting">CHECK TABLE <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ... [<em class="replaceable"><code>option</code></em>] ...

<em class="replaceable"><code>option</code></em>: {
    FOR UPGRADE
  | QUICK
  | FAST
  | MEDIUM
  | EXTENDED
  | CHANGED
}
</pre><p>
        <code class="literal">CHECK TABLE</code> は、1 つまたは複数のテーブルをエラーがないかどうかチェックします。 <code class="literal">CHECK TABLE</code> はまた、ビューをチェックして、そのビュー定義で参照されているテーブルが存在しなくなっているなどの問題がないかどうかを調べることもできます。 
      </p><p>
        テーブルをチェックするには、それに対する何らかの権限が必要です。
      </p><p>
        <code class="literal">CHECK TABLE</code> は、<code class="literal">InnoDB</code>、<code class="literal">MyISAM</code>、<code class="literal">ARCHIVE</code>、および <code class="literal">CSV</code> テーブルに対して機能します。
      </p><p>
        <code class="literal">InnoDB</code> テーブルで <code class="literal">CHECK TABLE</code> を実行する前に、<a class="xref" href="sql-statements.html#check-table-innodb" title="InnoDB テーブルに対する CHECK TABLE の使用上のノート">InnoDB テーブルに対する CHECK TABLE の使用上のノート</a> を参照してください。
      </p><p>
        <code class="literal">CHECK TABLE</code> はパーティションテーブルでサポートされており、<code class="literal">ALTER TABLE ... CHECK PARTITION</code> を使用して 1 つ以上のパーティションをチェックできます。詳細は、<a class="xref" href="sql-statements.html#alter-table" title="13.1.9 ALTER TABLE ステートメント">セクション13.1.9「ALTER TABLE ステートメント」</a> および <a class="xref" href="partitioning.html#partitioning-maintenance" title="24.3.4 パーティションの保守">セクション24.3.4「パーティションの保守」</a> を参照してください。
      </p><p>
        <code class="literal">CHECK TABLE</code> は、インデックス付けされていない仮想生成カラムを無視します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#check-table-output" title="CHECK TABLE の出力">CHECK TABLE の出力</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#check-table-version-compatibility" title="バージョン互換性のチェック">バージョン互換性のチェック</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#check-table-data-consistency" title="データ一貫性のチェック">データ一貫性のチェック</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#check-table-innodb" title="InnoDB テーブルに対する CHECK TABLE の使用上のノート">InnoDB テーブルに対する CHECK TABLE の使用上のノート</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#check-table-myisam" title="MyISAM テーブルに対する CHECK TABLE の使用上のノート">MyISAM テーブルに対する CHECK TABLE の使用上のノート</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="check-table-output"></a>CHECK TABLE の出力</h5></div></div></div><p>
          <code class="literal">CHECK TABLE</code> は、次のテーブルに示すカラムを含む結果セットを返します。
        </p><div class="informaltable"><table summary="Columns of the CHECK TABLE result set."><col style="width: 15%"><col style="width: 60%"><thead><tr>
              <th>カラム</th>
              <th>値</th>
            </tr></thead><tbody><tr>
              <td><code class="literal">Table</code></td>
              <td>テーブル名</td>
            </tr><tr>
              <td><code class="literal">Op</code></td>
              <td>常に <code class="literal">check</code></td>
            </tr><tr>
              <td><code class="literal">Msg_type</code></td>
              <td><code class="literal">status</code>、<code class="literal">error</code>、<code class="literal">info</code>、<code class="literal">note</code>、または <code class="literal">warning</code></td>
            </tr><tr>
              <td><code class="literal">Msg_text</code></td>
              <td>情報メッセージ</td>
            </tr></tbody></table></div><p>
          このステートメントによって、チェックされたテーブルごとに多くの情報行が生成される場合があります。 最後の行には <code class="literal">status</code> の <code class="literal">Msg_type</code> 値が含まれ、<code class="literal">Msg_text</code> は通常 <code class="literal">OK</code> になります。 <code class="literal">Table is already up to date</code> は、そのテーブルのストレージエンジンがテーブルのチェックは必要ないと判断したことを示します。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="check-table-version-compatibility"></a>バージョン互換性のチェック</h5></div></div></div><p>
          <code class="literal">FOR UPGRADE</code> オプションは、指定されたテーブルが現在のバージョンの MySQL と互換性があるかどうかをチェックします。 <code class="literal">FOR UPGRADE</code> を指定すると、サーバーは各テーブルをチェックして、テーブルの作成後にそのテーブルのいずれかのデータ型またはインデックスで互換性のない変更が発生しているかどうかを判定します。 発生していない場合は、チェックが成功します。 それ以外で、非互換性の可能性がある場合、サーバーはそのテーブルに対して完全なチェックを実行します (これには、ある程度時間がかかることがあります)。 
        </p><p>
          データ型のストレージフォーマットが変更されたか、またはそのソート順序が変更されたために非互換性が発生する可能性があります。 弊社の目的はそれらの変更を避けることですが、各リリースの間の非適合性よりもさらに深刻な問題を修正するために必要である場合もあります。 
        </p><p>
          <code class="literal">FOR UPGRADE</code> は、次の非互換性を検出します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> テーブルの <code class="literal">TEXT</code> カラム内の最後の領域のインデックス順序が MySQL 4.1 と 5.0 の間で変更されました。
            </p></li><li class="listitem"><p>
              新しい <code class="literal">DECIMAL</code> データ型のストレージ方法が MySQL 5.0.3 と 5.0.5 の間で変更されました。
            </p></li><li class="listitem"><p>
              文字セットまたは照合順序に対して、テーブルインデックスの再構築が必要な変更が加えられる場合があります。 このような変更の詳細は、<a class="xref" href="installing.html#upgrading-from-previous-series" title="2.11.4 MySQL 8.0 での変更">セクション2.11.4「MySQL 8.0 での変更」</a> を参照してください。 テーブルの再構築の詳細は、<a class="xref" href="installing.html#rebuilding-tables" title="2.11.13 テーブルまたはインデックスの再作成または修復">セクション2.11.13「テーブルまたはインデックスの再作成または修復」</a> を参照してください。 
            </p></li><li class="listitem"><p>
              MySQL 8.0 では、古いバージョンの MySQL で許可されている 2 桁の <code class="literal">YEAR(2)</code> データ型はサポートされていません。 <code class="literal">YEAR(2)</code> カラムを含むテーブルの場合、<code class="literal">CHECK TABLE</code> では、2 桁の <code class="literal">YEAR(2)</code> カラムを 4 桁の <code class="literal">YEAR</code> カラムに変換する <code class="literal">REPAIR TABLE</code> をお薦めします。 
            </p></li><li class="listitem"><p>
              トリガー作成時間が保持されます。
            </p></li><li class="listitem"><p>
              5.6.4 より前の形式 (<code class="literal">TIME</code>、<code class="literal">DATETIME</code> および <code class="literal">TIMESTAMP</code> カラムで小数秒精度をサポートしていない) の古い時間的カラムが含まれており、<code class="literal">avoid_temporal_upgrade</code> システム変数が無効になっている場合、テーブルは再構築が必要であると報告されます。 これは、MySQL のアップグレード手順で古い時間的カラムを含むテーブルを検出してアップグレードするのに役立ちます。 <code class="literal">avoid_temporal_upgrade</code> が有効な場合、<code class="literal">FOR UPGRADE</code> はテーブルに存在する古い時間的カラムを無視するため、アップグレード手順はそれらをアップグレードしません。 
            </p><p>
              このような時間的カラムを含み、再構築が必要なテーブルをチェックするには、<code class="literal">CHECK TABLE ... FOR UPGRADE</code> を実行する前に <code class="literal">avoid_temporal_upgrade</code> を無効にします。
            </p></li><li class="listitem"><p>
              非ネイティブパーティション化は MySQL 8.0 で削除されるため、非ネイティブパーティション化を使用するテーブルに対して警告が発行されます。 <a class="xref" href="partitioning.html" title="第 24 章 パーティション化">第24章「<i>パーティション化</i>」</a>を参照してください。 
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="check-table-data-consistency"></a>データ一貫性のチェック</h5></div></div></div><p>
          次のテーブルに、指定できるその他のチェックオプションを示します。 これらのオプションはストレージエンジンに渡されますが、これらのオプションは使用することも無視することもできます。 
        </p><div class="informaltable"><table summary="Other CHECK TABLE options."><col style="width: 15%"><col style="width: 85%"><thead><tr>
              <th>型</th>
              <th>意味</th>
            </tr></thead><tbody><tr>
              <td><code class="literal">QUICK</code></td>
              <td>正しくないリンクをチェックするための行のスキャンを行いません。 <code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> テーブルとビューに適用されます。 </td>
            </tr><tr>
              <td><code class="literal">FAST</code></td>
              <td>正しく閉じられていないテーブルのみを検査します。 <code class="literal">InnoDB</code> では無視されます。<code class="literal">MyISAM</code> のテーブルおよびビューにのみ適用されます。 </td>
            </tr><tr>
              <td><code class="literal">CHANGED</code></td>
              <td>最後のチェック以降に変更されたか、または正しく閉じられていないテーブルのみをチェックします。 <code class="literal">InnoDB</code> では無視されます。<code class="literal">MyISAM</code> のテーブルおよびビューにのみ適用されます。 </td>
            </tr><tr>
              <td><code class="literal">MEDIUM</code></td>
              <td>削除されたリンクが有効であることを検証するために行をスキャンします。 また、行のキーチェックサムも計算し、キーの計算されたチェックサムを使用してこれを検証します。 <code class="literal">InnoDB</code> では無視されます。<code class="literal">MyISAM</code> のテーブルおよびビューにのみ適用されます。 </td>
            </tr><tr>
              <td><code class="literal">EXTENDED</code></td>
              <td>行ごとにすべてのキーの完全なキールックアップを実行します。 これにより、テーブルの 100% の整合性が保証されますが、長い時間がかかります。 <code class="literal">InnoDB</code> では無視されます。<code class="literal">MyISAM</code> のテーブルおよびビューにのみ適用されます。 </td>
            </tr></tbody></table></div><p>
          チェックオプションは、次の例のように組み合わせることができます。この例では、テーブルが正しく閉じられたかどうかを判定するために、そのテーブルに対してすばやいチェックを実行します。
        </p><pre class="programlisting">CHECK TABLE test_table FAST QUICK;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">CHECK TABLE</code> で、<span class="quote">「<span class="quote">「破損」</span>」</span>または<span class="quote">「<span class="quote">「正しく閉じられていません」</span>」</span>としてマークされているテーブルに問題が検出されない場合、<code class="literal">CHECK TABLE</code> によってマークが削除されることがあります。
          </p></div><p>
          テーブルが破損している場合、データ部分ではなくインデックスに問題がある可能性があります。 前のチェックタイプはすべて、インデックスを徹底的にチェックするため、ほとんどのエラーが見つかるはずです。 
        </p><p>
          正常であると想定しているテーブルをチェックするには、チェックオプションまたは <code class="literal">QUICK</code> オプションを使用しません。 後者は、急いでおり、かつ <code class="literal">QUICK</code> でデータファイル内のエラーが見つからないという非常に小さなリスクを負える場合に使用するようにしてください。 (ほとんどの場合、通常の使用状況では、MySQL でデータファイル内のどのようなエラーも見つかります。 見つかった場合、そのテーブルは<span class="quote">「<span class="quote">破損している</span>」</span>としてマークされ、修復されるまで使用できなくなります。)  
        </p><p>
          <code class="literal">FAST</code> および <code class="literal">CHANGED</code> は主に、テーブルを定期的にチェックするためにスクリプトから使用されます (たとえば、<span class="command"><strong>cron</strong></span> から実行されます)。 ほとんどの場合、<code class="literal">FAST</code> は <code class="literal">CHANGED</code> より優先されます。 (優先されない唯一の場合は、<code class="literal">MyISAM</code> コード内にバグが見つかったのではないかと疑われるときです。)  
        </p><p>
          <code class="literal">EXTENDED</code> は、通常のチェックを実行した後にのみ使用されますが、MySQL が行を更新しようとするか、キーで行を検索しようとすると、引き続きテーブルからエラーが発生します。 通常のチェックが成功した場合、これはめったに発生しません。 
        </p><p>
          <code class="literal">CHECK TABLE ... EXTENDED</code> を使用すると、クエリーオプティマイザによって生成される実行計画に影響する可能性があります。
        </p><p>
          <code class="literal">CHECK TABLE</code> によってレポートされる次のいくつかの問題は、自動的には修正できません。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">Found row where the auto_increment column has the value 0</code>。
            </p><p>
              これは、<code class="literal">AUTO_INCREMENT</code> インデックスカラムに値 0 が含まれている行がテーブル内に存在することを示します。 (<code class="literal">AUTO_INCREMENT</code> カラムが 0 である行は、<code class="literal">UPDATE</code> ステートメントを使用してそのカラムを明示的に 0 に設定することによって作成できます。)  
            </p><p>
              これは、それ自体エラーではありませんが、そのテーブルをダンプしてリストアするか、またはそのテーブルに対して <code class="literal">ALTER TABLE</code> を実行しようとした場合に問題が発生する可能性があります。 この場合、<code class="literal">AUTO_INCREMENT</code> カラムはその <code class="literal">AUTO_INCREMENT</code> カラムのルールに従って値を変更するため、重複キーエラーなどの問題が発生する可能性があります。 
            </p><p>
              警告を取り除くには、<code class="literal">UPDATE</code> ステートメントを実行してカラムを 0 以外の値に設定します。
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="check-table-innodb"></a>InnoDB テーブルに対する CHECK TABLE の使用上のノート</h5></div></div></div><p>
          次の注意事項は、<code class="literal">InnoDB</code> テーブルに適用されます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">CHECK TABLE</code> で破損したページが検出された場合、サーバーはエラー伝播を防ぐために終了します (Bug #10132)。 セカンダリインデックスで破損が発生しても、テーブルデータが読み取り可能な場合は、<code class="literal">CHECK TABLE</code> を実行するとサーバーが終了する可能性があります。 
            </p></li><li class="listitem"><p>
              <code class="literal">CHECK TABLE</code> でクラスタインデックスに破損した <code class="literal">DB_TRX_ID</code> または <code class="literal">DB_ROLL_PTR</code> フィールドが検出されると、<code class="literal">InnoDB</code> が無効な undo ログレコードにアクセスし、<a class="link" href="glossary.html#glos_mvcc" title="MVCC">MVCC</a> 関連のサーバーが終了する可能性があります。
            </p></li><li class="listitem"><p>
              <code class="literal">CHECK TABLE</code> では、<code class="literal">InnoDB</code> のテーブルまたはインデックスでエラーが発生した場合、エラーがレポートされ、通常はインデックスがマークされ、場合によってはテーブルに破損のマークが付けられ、インデックスまたはテーブルをさらに使用できなくなります。 このようなエラーには、セカンダリインデックス内のエントリの数が正しくないか、リンクが正しくないなどがあります。 
            </p></li><li class="listitem"><p>
              <code class="literal">CHECK TABLE</code> は、セカンダリインデックスで不正な数のエントリを検出した場合、エラーを報告しますが、サーバーの終了やファイルへのアクセスの防止は行いません。
            </p></li><li class="listitem"><p>
              <code class="literal">CHECK TABLE</code> はインデックスページの構造を調査してから、各キーエントリを調査します。 キーポインタをクラスタ化されたレコードに対して検証したり、<code class="literal">BLOB</code> ポインタのパスに従ったりはしません。 
            </p></li><li class="listitem"><p>
              <code class="literal">InnoDB</code> テーブルが独自の <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル"><code class="filename">.ibd</code> file</a> に格納されている場合、<code class="literal">.ibd</code> ファイルの最初の 3 つの <a class="link" href="glossary.html#glos_page" title="ページ">pages</a> には、テーブルまたはインデックスデータではなくヘッダー情報が含まれます。 <code class="literal">CHECK TABLE</code> ステートメントでは、ヘッダーデータにのみ影響する非一貫性は検出されません。 <code class="literal">InnoDB</code> <code class="literal">.ibd</code> ファイルの内容全体を検証するには、<span class="command"><strong>innochecksum</strong></span> コマンドを使用します。 
            </p></li><li class="listitem"><p>
              大規模な <code class="literal">InnoDB</code> テーブルで <code class="literal">CHECK TABLE</code> を実行する場合、<code class="literal">CHECK TABLE</code> の実行中に他のスレッドがブロックされることがあります。 タイムアウトを回避するために、<code class="literal">CHECK TABLE</code> 操作の場合は、セマフォー待機のしきい値 (600 秒) が 2 時間 (7200 秒) 延長されます。 <code class="literal">InnoDB</code> は、240 秒以上のセマフォ待機を検出すると、エラーログへの <code class="literal">InnoDB</code> モニター出力の出力を開始します。 ロックリクエストがセマフォ待機しきい値を超えると、<code class="literal">InnoDB</code> はプロセスを中断します。 セマフォ待機タイムアウトの可能性を完全に回避するには、<code class="literal">CHECK TABLE</code> のかわりに <code class="literal">CHECK TABLE QUICK</code> を実行します。 
            </p></li><li class="listitem"><p>
              <code class="literal">InnoDB</code> <code class="literal">SPATIAL</code> インデックスの <code class="literal">CHECK TABLE</code> 機能には、R ツリーの妥当性チェックと、R ツリーの行数がクラスタインデックスと一致することを確認するチェックが含まれます。
            </p></li><li class="listitem"><p>
              <code class="literal">CHECK TABLE</code> では、<code class="literal">InnoDB</code> でサポートされている仮想生成カラムのセカンダリインデックスがサポートされます。
            </p></li><li class="listitem"><p>
              MySQL 8.0.14 では、<code class="literal">InnoDB</code> はクラスタ化されたパラレルインデックス読取りをサポートしているため、<code class="literal">CHECK TABLE</code> のパフォーマンスを向上させることができます。 <code class="literal">InnoDB</code> は、<code class="literal">CHECK TABLE</code> 操作中にクラスタ化されたインデックスを 2 回読み取ります。 2 番目の読取りはパラレルで実行できます。 パラレルクラスタインデックス読取りを実行するには、<code class="literal">innodb_parallel_read_threads</code> セッション変数を 1 より大きい値に設定する必要があります。 デフォルト値は 4 です。 パラレルクラスタインデックス読取りの実行に使用されるスレッドの実際の数は、<code class="literal">innodb_parallel_read_threads</code> 設定またはスキャンするインデックスサブツリーの数 (いずれか小さい方) によって決まります。 
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="check-table-myisam"></a>MyISAM テーブルに対する CHECK TABLE の使用上のノート</h5></div></div></div><p>
          <code class="literal">MyISAM</code> テーブルには、次のノートが適用されます:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">CHECK TABLE</code> は、<code class="literal">MyISAM</code> テーブルの主要な統計を更新します。
            </p></li><li class="listitem"><p>
              <code class="literal">CHECK TABLE</code> 出力で <code class="literal">OK</code> または <code class="literal">Table is already up to date</code> が返されない場合は、通常、テーブルの修復を実行する必要があります。 <a class="xref" href="backup-and-recovery.html#myisam-table-maintenance" title="7.6 MyISAM テーブルの保守とクラッシュリカバリ">セクション7.6「MyISAM テーブルの保守とクラッシュリカバリ」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              <code class="literal">QUICK</code>、<code class="literal">MEDIUM</code> または <code class="literal">EXTENDED</code> のいずれの <code class="literal">CHECK TABLE</code> オプションも指定されていない場合、動的書式 <code class="literal">MyISAM</code> テーブルのデフォルトのチェックタイプは <code class="literal">MEDIUM</code> です。 これにより、そのテーブルに対して <span class="command"><strong>myisamchk --medium-check <em class="replaceable"><code>tbl_name</code></em></strong></span> を実行したのと同じ結果が得られます。 また、<code class="literal">CHANGED</code> または <code class="literal">FAST</code> が指定されていないかぎり、静的フォーマットの <code class="literal">MyISAM</code> テーブルに対するデフォルトのチェックタイプも <code class="literal">MEDIUM</code> です。 指定されている場合、デフォルトは <code class="literal">QUICK</code> です。 <code class="literal">CHANGED</code> および <code class="literal">FAST</code> の場合、行はめったに破損しないため、行スキャンはスキップされます。 
            </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="checksum-table"></a>13.7.3.3 CHECKSUM TABLE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826989548272"></a><pre class="programlisting">CHECKSUM TABLE <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ... [QUICK | EXTENDED]
</pre><p>
        <code class="literal">CHECKSUM TABLE</code> は、テーブルの内容に対する<a class="link" href="glossary.html#glos_checksum" title="チェックサム">チェックサム</a>をレポートします。 このステートメントを使用すると、その内容が、バックアップ、ロールバック、またはデータを元の既知の状態に戻すことを目的としたその他の操作の前後で同じであることを検証できます。 
      </p><p>
        このステートメントには、このテーブルに対する <code class="literal">SELECT</code> 権限が必要です。
      </p><p>
        このステートメントはビューではサポートされていません。 ビューに対して <code class="literal">CHECKSUM TABLE</code> を実行すると、<code class="literal">Checksum</code> 値は常に <code class="literal">NULL</code> になり、警告が返されます。 
      </p><p>
        存在しないテーブルに対しては、<code class="literal">CHECKSUM TABLE</code> は <code class="literal">NULL</code> を返し、警告を生成します。
      </p><p>
        チェックサム操作中、そのテーブルは <code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> に対する読み取りロックでロックされます。
      </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="checksum-table-performance-considerations"></a>パフォーマンスに関する考慮事項</h5></div></div></div><p>
          デフォルトでは、テーブル全体が 1 行ごとに読み取られ、チェックサムが計算されます。 大きなテーブルでは長い時間がかかる可能性があるため、この操作は、状況に応じてのみ実行されます。 この 1 行ごとの計算は、<code class="literal">InnoDB</code> や <code class="literal">MyISAM</code> 以外のその他のすべてのストレージエンジン、および <code class="literal">CHECKSUM=1</code> 句で作成されていない <code class="literal">MyISAM</code> テーブルの場合に <code class="literal">EXTENDED</code> 句で得られるものと同じです。 
        </p><p>
          <code class="literal">CHECKSUM=1</code> 句を使用して作成された <code class="literal">MyISAM</code> テーブルの場合、<code class="literal">CHECKSUM TABLE</code> または <code class="literal">CHECKSUM TABLE ... QUICK</code> は、非常に高速に返すことができる<span class="quote">「<span class="quote">「ライブ」</span>」</span>テーブルチェックサムを返します。 テーブルがこれらのすべての条件を満たさない場合、<code class="literal">QUICK</code> による方法は <code class="literal">NULL</code> を返します。 <code class="literal">QUICK</code> メソッドは、<code class="literal">InnoDB</code> テーブルではサポートされません。 <code class="literal">CHECKSUM</code> 句の構文については、<a class="xref" href="sql-statements.html#create-table" title="13.1.20 CREATE TABLE ステートメント">セクション13.1.20「CREATE TABLE ステートメント」</a>を参照してください。 
        </p><p>
          チェックサム値は、テーブル行フォーマットによって異なります。 行フォーマットが変更された場合は、チェックサムも変更されます。 たとえば、MySQL より前の MySQL 5.6.5 で <code class="literal">TIME</code>、<code class="literal">DATETIME</code>、<code class="literal">TIMESTAMP</code> などの時間型の記憶域形式が変更されたため、5.5 テーブルが MySQL 5.6 にアップグレードされると、チェックサム値が変更される可能性があります。 
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
            2 つのテーブルのチェックサムが異なる場合は、それらのテーブルが何らかの点で異なることがほぼ確実です。 ただし、<code class="literal">CHECKSUM TABLE</code> によって使用されるハッシュ関数は衝突がないことは保証されないため、同一でない 2 つのテーブルが同じチェックサムを生成する可能性が若干あります。 
          </p></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="optimize-table"></a>13.7.3.4 OPTIMIZE TABLE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826989506544"></a><a class="indexterm" name="idm45826989505040"></a><a class="indexterm" name="idm45826989503008"></a><pre class="programlisting">OPTIMIZE [NO_WRITE_TO_BINLOG | LOCAL]
    TABLE <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ...
</pre><p>
        <code class="literal">OPTIMIZE TABLE</code> では、テーブルデータおよび関連するインデックスデータの物理記憶域が再編成され、記憶領域が削減され、テーブルへのアクセス時の I/O の効率が向上します。 各テーブルに加えられる正確な変更は、そのテーブルによって使用されている<a class="link" href="glossary.html#glos_storage_engine" title="ストレージエンジン">ストレージエンジン</a>によって異なります。 
      </p><p>
        <code class="literal">OPTIMIZE TABLE</code> は、テーブルのタイプに応じて次の場合に使用します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">innodb_file_per_table</code> オプションが有効な状態で作成されたために独自の <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibd ファイル </a> を含む <code class="literal">InnoDB</code> テーブルに対して大量の挿入、更新、または削除操作を行なったあと。 テーブルとインデックスが再編成されるため、ディスク領域をオペレーティングシステムによる使用のために再利用できます。 
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> テーブル内の <code class="literal">FULLTEXT</code> インデックスの一部であるカラムに対して大量の挿入、更新、または削除操作を行なったあと。 最初に、構成オプション <code class="literal">innodb_optimize_fulltext_only=1</code> を設定します。 インデックスの保守期間を妥当な時間に維持するために、検索インデックスで更新するワード数を指定する <code class="literal">innodb_ft_num_word_optimize</code> オプションを設定し、検索インデックスが完全に更新されるまで <code class="literal">OPTIMIZE TABLE</code> ステートメントのシーケンスを実行します。 
          </p></li><li class="listitem"><p>
            <code class="literal">MyISAM</code> または <code class="literal">ARCHIVE</code> テーブルの大きな部分を削除するか、あるいは可変長行を含む <code class="literal">MyISAM</code> または <code class="literal">ARCHIVE</code> テーブル (<code class="literal">VARCHAR</code>、<code class="literal">VARBINARY</code>、<code class="literal">BLOB</code>、または <code class="literal">TEXT</code> カラムを含むテーブル) に多くの変更を行なったあと。 削除された行はリンクリスト内に保持され、以降の <code class="literal">INSERT</code> 操作は古い行の位置を再利用します。 <code class="literal">OPTIMIZE TABLE</code> を使用すると、未使用領域を再利用したり、データファイルをデフラグしたりできます。 テーブルを大幅に変更したあとは、このステートメントにより、そのテーブルを使用するステートメントのパフォーマンスを (場合によっては大幅に) 向上させることができます。 
          </p></li></ul></div><p>
        このステートメントには、このテーブルに対する <code class="literal">SELECT</code> および <code class="literal">INSERT</code> 権限が必要です。
      </p><p>
        <code class="literal">OPTIMIZE TABLE</code> は、<code class="literal">InnoDB</code>、<code class="literal">MyISAM</code>、および <code class="literal">ARCHIVE</code> テーブルに対して機能します。 <code class="literal">OPTIMIZE TABLE</code> は、インメモリー <code class="literal">NDB</code> テーブルの動的なカラムに対してもサポートされます。 インメモリーテーブルの固定幅カラムに対しては機能せず、「ディスクデータ」テーブルに対しても機能しません。 「NDB Cluster」テーブルの <code class="literal">OPTIMIZE</code> のパフォーマンスは、<code class="literal">OPTIMIZE TABLE</code> による行のバッチ処理間の待機時間を制御する <code class="option">--ndb-optimization-delay</code> を使用してチューニングできます。 詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-limitations-resolved" title="23.1.7.11 前 NDB Cluster 8.0 で解決される NDB Cluster の問題">セクション23.1.7.11「前 NDB Cluster 8.0 で解決される NDB Cluster の問題」</a>を参照してください。 
      </p><p>
        「NDB Cluster の場合」テーブルの <code class="literal">OPTIMIZE TABLE</code> は、<code class="literal">OPTIMIZE</code> 操作を実行している SQL スレッドを強制終了することで中断できます。
      </p><p>
        デフォルトでは、<code class="literal">OPTIMIZE TABLE</code> はその他のストレージエンジンを使用して作成されたテーブルに対しては機能<span class="emphasis"><em>せず</em></span>、このサポートがないことを示す結果を返します。 <code class="option">--skip-new</code> オプションを使用して <span class="command"><strong>mysqld</strong></span> を起動することによって、その他のストレージエンジンに対して <code class="literal">OPTIMIZE TABLE</code> を機能させることができます。 この場合、<code class="literal">OPTIMIZE TABLE</code> は単に <code class="literal">ALTER TABLE</code> にマップされます。 
      </p><p>
        このステートメントはビューでは機能しません。
      </p><p>
        <code class="literal">OPTIMIZE TABLE</code> は、パーティションテーブルでサポートされています。 このステートメントのパーティション化されたテーブルでの使用やテーブルパーティションについては、<a class="xref" href="partitioning.html#partitioning-maintenance" title="24.3.4 パーティションの保守">セクション24.3.4「パーティションの保守」</a>を参照してください。 
      </p><p>
        デフォルトでは、<code class="literal">OPTIMIZE TABLE</code> ステートメントはレプリカにレプリケートされるようにバイナリログに書き込まれます。 ロギングを抑制するには、オプションの <code class="literal">NO_WRITE_TO_BINLOG</code> キーワード、またはそのエイリアス <code class="literal">LOCAL</code> を指定します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#optimize-table-output" title="OPTIMIZE TABLE の出力">OPTIMIZE TABLE の出力</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#optimize-table-innodb-details" title="InnoDB の詳細">InnoDB の詳細</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#optimize-table-myisam-details" title="MyISAM の詳細">MyISAM の詳細</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#optimize-table-other-considerations" title="その他の考慮事項">その他の考慮事項</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="optimize-table-output"></a>OPTIMIZE TABLE の出力</h5></div></div></div><p>
          <code class="literal">OPTIMIZE TABLE</code> は、次のテーブルに示すカラムを含む結果セットを返します。
        </p><div class="informaltable"><table summary="Columns of the OPTIMIZE TABLE result set."><col style="width: 15%"><col style="width: 60%"><thead><tr>
              <th>カラム</th>
              <th>値</th>
            </tr></thead><tbody><tr>
              <td><code class="literal">Table</code></td>
              <td>テーブル名</td>
            </tr><tr>
              <td><code class="literal">Op</code></td>
              <td>常に <code class="literal">optimize</code></td>
            </tr><tr>
              <td><code class="literal">Msg_type</code></td>
              <td><code class="literal">status</code>、<code class="literal">error</code>、<code class="literal">info</code>、<code class="literal">note</code>、または <code class="literal">warning</code></td>
            </tr><tr>
              <td><code class="literal">Msg_text</code></td>
              <td>情報メッセージ</td>
            </tr></tbody></table></div><p>
          <code class="literal">OPTIMIZE TABLE</code> テーブルは、古いファイルから新しく作成されたファイルへのテーブル統計のコピー中に発生したすべてのエラーをキャッチしてスローします。 たとえば、<code class="filename">.MYD</code> または <code class="filename">.MYI</code> ファイルの所有者のユーザー ID が <span class="command"><strong>mysqld</strong></span> プロセスのユーザー ID と異なる場合、<code class="literal">OPTIMIZE TABLE</code> では、<code class="literal">root</code> ユーザーが <span class="command"><strong>mysqld</strong></span> を起動しないかぎり、「ファイルの所有権を変更できません」というエラーが生成されます。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="optimize-table-innodb-details"></a>InnoDB の詳細</h5></div></div></div><p>
          <code class="literal">InnoDB</code> テーブルの場合、<code class="literal">OPTIMIZE TABLE</code> は <code class="literal">ALTER TABLE ... FORCE</code> にマップされます。これは、インデックス統計を更新し、クラスタ化されたインデックス内の未使用領域を解放するためにテーブルを再構築します。 これは、次に示すように、<code class="literal">InnoDB</code> テーブルに対して実行したときに <code class="literal">OPTIMIZE TABLE</code> の出力に表示されます。 
        </p><pre class="programlisting">mysql&gt; OPTIMIZE TABLE foo;
+----------+----------+----------+-------------------------------------------------------------------+
| Table    | Op       | Msg_type | Msg_text                                                          |
+----------+----------+----------+-------------------------------------------------------------------+
| test.foo | optimize | note     | Table does not support optimize, doing recreate + analyze instead |
| test.foo | optimize | status   | OK                                                                |
+----------+----------+----------+-------------------------------------------------------------------+
</pre><p>
          <code class="literal">OPTIMIZE TABLE</code> では、通常のパーティション化された <code class="literal">InnoDB</code> テーブルに <a class="link" href="innodb-storage-engine.html#innodb-online-ddl" title="15.12 InnoDB とオンライン DDL">online DDL</a> が使用されるため、同時 DML 操作の停止時間が短縮されます。 <code class="literal">OPTIMIZE TABLE</code> によってトリガーされたテーブルの再構築が適切に完了します。 排他テーブルロックは、操作の準備フェーズおよびコミットフェーズでのみ短時間実行されます。 準備フェーズでは、メタデータが更新され、中間テーブルが作成されます。 コミットフェーズでは、テーブルメタデータの変更がコミットされます。 
        </p><p>
          <code class="literal">OPTIMIZE TABLE</code> では、次の条件下でテーブルのコピー方法を使用してテーブルを再構築します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">old_alter_table</code> システム変数が有効な場合。
            </p></li><li class="listitem"><p>
              <code class="option">--skip-new</code> オプションを使用してサーバーを起動したとき。
            </p></li></ul></div><p>
          <a class="link" href="innodb-storage-engine.html#innodb-online-ddl" title="15.12 InnoDB とオンライン DDL">online DDL</a> を使用する <code class="literal">OPTIMIZE TABLE</code> は、<code class="literal">FULLTEXT</code> インデックスを含む <code class="literal">InnoDB</code> テーブルではサポートされていません。 かわりにテーブルのコピー方法が使用されます。 
        </p><p>
          <code class="literal">InnoDB</code> は、ページの割当て方法を使用してデータを格納し、レガシーストレージエンジン (<code class="literal">MyISAM</code> など) と同様に断片化の影響を受けません。 最適化を実行するかどうかを検討する場合は、サーバーが処理すると予想されるトランザクションのワークロードを考慮してください: 

          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                ある程度の断片化は予測されます。 <code class="literal">InnoDB</code> は、ページを分割しなくても更新できる余地を残すために、<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>を 93% までしかいっぱいにしません。 
              </p></li><li class="listitem"><p>
                削除操作によってギャップが残され、ページの空きが目的より多くなることがあります。これにより、テーブルを最適化する価値が生まれる可能性があります。
              </p></li><li class="listitem"><p>
                行を更新すると通常、十分な領域が使用可能であれば、データ型と行フォーマットに応じて同じページ内のデータが書き換えられます。 <a class="xref" href="innodb-storage-engine.html#innodb-compression-internals" title="15.9.1.5 InnoDB テーブルでの圧縮の動作">セクション15.9.1.5「InnoDB テーブルでの圧縮の動作」</a>および<a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="15.10 InnoDB の行フォーマット">セクション15.10「InnoDB の行フォーマット」</a>を参照してください。 
              </p></li><li class="listitem"><p>
                <code class="literal">InnoDB</code> はその <a class="link" href="glossary.html#glos_mvcc" title="MVCC">MVCC</a> メカニズムのために同じデータの複数のバージョンを保持するため、並列性の高いワークロードでは、時間の経過とともにインデックス内にギャップが残される可能性があります。 <a class="xref" href="innodb-storage-engine.html#innodb-multi-versioning" title="15.3 InnoDB マルチバージョン">セクション15.3「InnoDB マルチバージョン」</a>を参照してください。 
              </p></li></ul></div><p>
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="optimize-table-myisam-details"></a>MyISAM の詳細</h5></div></div></div><p>
          <code class="literal">MyISAM</code> テーブルの場合、<code class="literal">OPTIMIZE TABLE</code> は次のように機能します。
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              テーブルが行を削除または分割した場合は、そのテーブルを修復します。
            </p></li><li class="listitem"><p>
              インデックスページがソートされていない場合は、それをソートします。
            </p></li><li class="listitem"><p>
              テーブルの統計が最新でない (そのため、インデックスのソートによって修復を実行できない) 場合は、それを更新します。
            </p></li></ol></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="optimize-table-other-considerations"></a>その他の考慮事項</h5></div></div></div><p>
          <code class="literal">OPTIMIZE TABLE</code> は、通常のパーティション化された <code class="literal">InnoDB</code> テーブルに対してオンラインで実行されます。 それ以外の場合は、<code class="literal">OPTIMIZE TABLE</code> の実行中に MySQL <a class="link" href="glossary.html#glos_table_lock" title="テーブルロック">locks the table</a> が実行されます。 
        </p><p>
          <code class="literal">OPTIMIZE TABLE</code> は、<code class="literal">POINT</code> カラム上の空間インデックスなどの R ツリーインデックスをソートしません。 (Bug #23578) 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="repair-table"></a>13.7.3.5 REPAIR TABLE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826989355232"></a><pre class="programlisting">REPAIR [NO_WRITE_TO_BINLOG | LOCAL]
    TABLE <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ...
    [QUICK] [EXTENDED] [USE_FRM]
</pre><p>
        <code class="literal">REPAIR TABLE</code> は、特定のストレージエンジンに対してのみ、破損している可能性のあるテーブルを修復します。
      </p><p>
        このステートメントには、このテーブルに対する <code class="literal">SELECT</code> および <code class="literal">INSERT</code> 権限が必要です。
      </p><p>
        通常、<code class="literal">REPAIR TABLE</code> を実行する必要はありませんが、災害が発生した場合は、このステートメントを使用すると <code class="literal">MyISAM</code> テーブルからすべてのデータをリストアできる可能性があります。 テーブルが頻繁に破損する場合は、その原因を見つけることにより、<code class="literal">REPAIR TABLE</code> を使用する必要がなくなるようにしてください。 <a class="xref" href="error-handling.html#crashing" title="B.3.3.3 MySQL が繰り返しクラッシュする場合の対処方法">セクションB.3.3.3「MySQL が繰り返しクラッシュする場合の対処方法」</a>および<a class="xref" href="storage-engines.html#myisam-table-problems" title="16.2.4 MyISAM テーブルの問題点">セクション16.2.4「MyISAM テーブルの問題点」</a>を参照してください。 
      </p><p>
        <code class="literal">REPAIR TABLE</code> はテーブルをチェックして、アップグレードが必要かどうかを確認します。 アップグレードが必要な場合は、<code class="literal">CHECK TABLE ... FOR UPGRADE</code> と同じルールに従ってアップグレードを実行します。 詳細は、<a class="xref" href="sql-statements.html#check-table" title="13.7.3.2 CHECK TABLE ステートメント">セクション13.7.3.2「CHECK TABLE ステートメント」</a>を参照してください。 
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              テーブルの修復操作を実行する前に、そのテーブルのバックアップを作成してください。状況によっては、この操作のためにデータ損失が発生することがあります。 考えられる原因としては、ファイルシステムのエラーなどがありますがこれに限りません。 <a class="xref" href="backup-and-recovery.html" title="第 7 章 バックアップとリカバリ">第7章「<i>バックアップとリカバリ</i>」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              <code class="literal">REPAIR TABLE</code> 操作中にサーバーが終了した場合は、再起動後、テーブルに対して別の <code class="literal">REPAIR TABLE</code> ステートメントをすぐに実行してから、ほかの操作を実行することが不可欠です。 最悪の場合は、データファイルに関する情報のない新しいクリーンなインデックスファイルが生成されており、実行する次の操作によってデータファイルが上書きされる可能性があります。 この状況はめったに発生しませんが、最初にバックアップを作成することの価値を強調している、可能性のあるシナリオです。 
            </p></li><li class="listitem"><p>
              ソース上のテーブルが破損し、そのテーブルで <code class="literal">REPAIR TABLE</code> を実行した場合、元のテーブルに対する変更はレプリカに伝播されません。
            </p></li></ul></div></div><a class="indexterm" name="idm45826989327824"></a><a class="indexterm" name="idm45826989325584"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#repair-table-support" title="REPAIR TABLE ストレージエンジンおよびパーティショニングサポート">REPAIR TABLE ストレージエンジンおよびパーティショニングサポート</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#repair-table-options" title="REPAIR TABLE のオプション">REPAIR TABLE のオプション</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#repair-table-output" title="REPAIR TABLE の出力">REPAIR TABLE の出力</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#repair-table-table-repair-considerations" title="テーブルの修復に関する考慮事項">テーブルの修復に関する考慮事項</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="repair-table-support"></a>REPAIR TABLE ストレージエンジンおよびパーティショニングサポート</h5></div></div></div><a class="indexterm" name="idm45826989317376"></a><a class="indexterm" name="idm45826989315136"></a><p>
          <code class="literal">REPAIR TABLE</code> は、<code class="literal">MyISAM</code>、<code class="literal">ARCHIVE</code> および <code class="literal">CSV</code> テーブルに対して機能します。 <code class="literal">MyISAM</code> テーブルの場合、デフォルトでは <span class="command"><strong>myisamchk --recover <em class="replaceable"><code>tbl_name</code></em></strong></span> と同じ効果があります。 このステートメントはビューでは機能しません。 
        </p><p>
          <code class="literal">REPAIR TABLE</code> は、パーティション化されたテーブルに対してサポートされています。 ただし、パーティション化されたテーブルに対して、このステートメントで <code class="literal">USE_FRM</code> オプションを使用することはできません。 
        </p><p>
          <code class="literal">ALTER TABLE ... REPAIR PARTITION</code> を使用すると、1 つ以上のパーティションを修復できます。詳細は、<a class="xref" href="sql-statements.html#alter-table" title="13.1.9 ALTER TABLE ステートメント">セクション13.1.9「ALTER TABLE ステートメント」</a>および<a class="xref" href="partitioning.html#partitioning-maintenance" title="24.3.4 パーティションの保守">セクション24.3.4「パーティションの保守」</a>を参照してください。
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="repair-table-options"></a>REPAIR TABLE のオプション</h5></div></div></div><a class="indexterm" name="idm45826989299952"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">NO_WRITE_TO_BINLOG</code> または <code class="literal">LOCAL</code>
            </p><p>
              デフォルトでは、<code class="literal">REPAIR TABLE</code> ステートメントはレプリカにレプリケートされるようにバイナリログに書き込まれます。 ロギングを抑制するには、オプションの <code class="literal">NO_WRITE_TO_BINLOG</code> キーワード、またはそのエイリアス <code class="literal">LOCAL</code> を指定します。 
            </p></li><li class="listitem"><p>
              <code class="literal">QUICK</code>
            </p><p>
              <code class="literal">QUICK</code> オプションを使用した場合、<code class="literal">REPAIR TABLE</code> はデータファイルではなく、インデックスファイルのみを修復しようとします。 このタイプの修復は、<span class="command"><strong>myisamchk --recover --quick</strong></span> によって実行される修復と同様です。 
            </p></li><li class="listitem"><p>
              <code class="literal">EXTENDED</code>
            </p><p>
              <code class="literal">EXTENDED</code> オプションを使用した場合、MySQL はソートしながら 1 回につき 1 つのインデックスを作成する代わりに、1 行ごとにインデックスを作成します。 このタイプの修復は、<span class="command"><strong>myisamchk --safe-recover</strong></span> によって実行される修復と同様です。 
            </p></li><li class="listitem"><p>
              <code class="literal">USE_FRM</code>
            </p><p>
              <code class="literal">USE_FRM</code> オプションは、<code class="filename">.MYI</code> インデックスファイルがない場合や、そのヘッダーが破損している場合に使用できます。 このオプションは、<code class="filename">.MYI</code> ファイルヘッダーの情報を信頼せず、データディクショナリの情報を使用して再作成するように MySQL に指示します。 この種類の修復は、<span class="command"><strong>myisamchk</strong></span> では実行できません。 
            </p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注意</div><p>
                通常の <code class="literal">REPAIR</code> モードを使用できない場合は、<code class="literal">USE_FRM</code> オプション<span class="emphasis"><em>のみ</em></span>を使用します。 サーバーに <code class="filename">.MYI</code> ファイルを無視するよう指示すると、<code class="filename">.MYI</code> に格納されている重要なテーブルメタデータが修復プロセスから使用できなくなるため、有害な結果を招く場合があります。 
              </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                    現在の <code class="literal">AUTO_INCREMENT</code> 値は失われます。
                  </p></li><li class="listitem"><p>
                    テーブル内の削除されたレコードへのリンクは失われます。つまり、削除されたレコードの空き領域はその後も占有されません。
                  </p></li><li class="listitem"><p>
                    <code class="filename">.MYI</code> ヘッダーは、テーブルが圧縮されているかどうかを示します。 サーバーがこの情報を無視すると、テーブルが圧縮されていることがわからないため、修復によってテーブルの内容の変更または損失が発生する場合があります。 つまり、圧縮テーブルでは <code class="literal">USE_FRM</code> を使用しないようにしてください。 いずれにしても、これは必須ではありません。圧縮テーブルは読み取り専用であるため、破損することはありません。 
                  </p></li></ul></div><p>
                現在実行しているものとは異なるバージョンの MySQL サーバーで作成されたテーブルに <code class="literal">USE_FRM</code> を使用する場合、<code class="literal">REPAIR TABLE</code> はテーブルの修復を試行しません。 この場合、<code class="literal">REPAIR TABLE</code> によって返される結果セットには、<code class="literal">Msg_type</code> 値が <code class="literal">error</code> で、<code class="literal">Msg_text</code> 値が <code class="literal">Failed repairing incompatible .FRM file</code> である行が含まれています。 
              </p><p>
                <code class="literal">USE_FRM</code> が使用されている場合、<code class="literal">REPAIR TABLE</code> はテーブルをチェックして、アップグレードが必要かどうかを確認しません。
              </p></div></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="repair-table-output"></a>REPAIR TABLE の出力</h5></div></div></div><a class="indexterm" name="idm45826989256752"></a><p>
          <code class="literal">REPAIR TABLE</code> は、次のテーブルに示すカラムを含む結果セットを返します。
        </p><div class="informaltable"><table summary="Columns of the REPAIR TABLE result set."><col style="width: 15%"><col style="width: 60%"><thead><tr>
              <th>カラム</th>
              <th>値</th>
            </tr></thead><tbody><tr>
              <td><code class="literal">Table</code></td>
              <td>テーブル名</td>
            </tr><tr>
              <td><code class="literal">Op</code></td>
              <td>常に <code class="literal">repair</code></td>
            </tr><tr>
              <td><code class="literal">Msg_type</code></td>
              <td><code class="literal">status</code>、<code class="literal">error</code>、<code class="literal">info</code>、<code class="literal">note</code>、または <code class="literal">warning</code></td>
            </tr><tr>
              <td><code class="literal">Msg_text</code></td>
              <td>情報メッセージ</td>
            </tr></tbody></table></div><p>
          <code class="literal">REPAIR TABLE</code> ステートメントによって、修復されたテーブルごとに多数の情報行が生成される可能性があります。 最後の行には <code class="literal">status</code> の <code class="literal">Msg_type</code> 値が含まれ、<code class="literal">Msg_test</code> は通常 <code class="literal">OK</code> になります。 <code class="literal">MyISAM</code> テーブルの場合、<code class="literal">OK</code> が取得されない場合は、<span class="command"><strong>myisamchk --safe-recover</strong></span> を使用して修復する必要があります。 (<code class="literal">REPAIR TABLE</code> は、<span class="command"><strong>myisamchk</strong></span> のすべてのオプションを実装しているわけではありません。 <span class="command"><strong>myisamchk --safe-recover</strong></span> では、<code class="option">--max-record-length</code> など、<code class="literal">REPAIR TABLE</code> でサポートされていないオプションを使用することもできます。) 
        </p><p>
          <code class="literal">REPAIR TABLE</code> テーブルは、古い破損したファイルから新しく作成されたファイルへのテーブル統計のコピー中に発生したすべてのエラーをキャッチしてスローします。 たとえば、<code class="filename">.MYD</code> または <code class="filename">.MYI</code> ファイルの所有者のユーザー ID が <span class="command"><strong>mysqld</strong></span> プロセスのユーザー ID と異なる場合、<code class="literal">REPAIR TABLE</code> では、<code class="literal">root</code> ユーザーが <span class="command"><strong>mysqld</strong></span> を起動しないかぎり、「ファイルの所有権を変更できません」というエラーが生成されます。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="repair-table-table-repair-considerations"></a>テーブルの修復に関する考慮事項</h5></div></div></div><p>
          <code class="literal">REPAIR TABLE</code> では、5.6.4 より前の形式 (<code class="literal">TIME</code>、<code class="literal">DATETIME</code> および <code class="literal">TIMESTAMP</code> カラムで小数秒精度をサポートしていない) の古い時間的カラムが含まれており、<code class="literal">avoid_temporal_upgrade</code> システム変数が無効になっている場合、テーブルがアップグレードされます。 <code class="literal">avoid_temporal_upgrade</code> が有効な場合、<code class="literal">REPAIR TABLE</code> はテーブルに存在する古い時間的カラムを無視し、それらをアップグレードしません。 
        </p><p>
          このような時間的カラムを含むテーブルをアップグレードするには、<code class="literal">REPAIR TABLE</code> を実行する前に <code class="literal">avoid_temporal_upgrade</code> を無効にします。
        </p><p>
          特定のシステム変数を設定することによって、<code class="literal">REPAIR TABLE</code> のパフォーマンスを向上させることができる可能性があります。 <a class="xref" href="optimization.html#repair-table-optimization" title="8.6.3 REPAIR TABLE ステートメントの最適化">セクション8.6.3「REPAIR TABLE ステートメントの最適化」</a>を参照してください。 
        </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="component-statements"></a>13.7.4 コンポーネント、プラグインおよびユーザー定義関数のステートメント</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#create-function-loadable">13.7.4.1 ユーザー定義関数用の CREATE FUNCTION ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#drop-function-loadable">13.7.4.2 ユーザー定義関数に対する DROP FUNCTION ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#install-component">13.7.4.3 INSTALL COMPONENT ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#install-plugin">13.7.4.4 INSTALL PLUGIN ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#uninstall-component">13.7.4.5 UNINSTALL COMPONENT ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#uninstall-plugin">13.7.4.6 UNINSTALL PLUGIN ステートメント</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="create-function-loadable"></a>13.7.4.1 ユーザー定義関数用の CREATE FUNCTION ステートメント</h4></div></div></div><a class="indexterm" name="idm45826989197760"></a><a class="indexterm" name="idm45826989196272"></a><a class="indexterm" name="idm45826989194352"></a><a class="indexterm" name="idm45826989192208"></a><a class="indexterm" name="idm45826989190144"></a><a class="indexterm" name="idm45826989189232"></a><pre class="programlisting">CREATE [AGGREGATE] FUNCTION <em class="replaceable"><code>function_name</code></em>
    RETURNS {STRING|INTEGER|REAL|DECIMAL}
    SONAME <em class="replaceable"><code>shared_library_name</code></em>
</pre><p>
        このステートメントは、<em class="replaceable"><code>function_name</code></em> という名前のユーザー定義関数 (UDF) をロードします。 (<code class="literal">CREATE FUNCTION</code> は、ストアドファンクションの作成にも使用されます。<a class="xref" href="sql-statements.html#create-procedure" title="13.1.17 CREATE PROCEDURE ステートメントおよび CREATE FUNCTION ステートメント">セクション13.1.17「CREATE PROCEDURE ステートメントおよび CREATE FUNCTION ステートメント」</a> を参照してください。) 
      </p><p>
        ユーザー定義関数は、<code class="literal">ABS()</code> や <code class="literal">CONCAT()</code> などのネイティブ (組込み) MySQL 関数のように機能する新しい関数を使用して MySQL を拡張する方法です。 <a class="ulink" href="https://dev.mysql.com/doc/extending-mysql/8.0/en/adding-loadable-function.html" target="_top">Adding a Loadable Function</a>を参照してください。 
      </p><p>
        <em class="replaceable"><code>function_name</code></em> は、この関数を呼び出すために SQL ステートメントで使用される名前です。 <code class="literal">RETURNS</code> 句は、この関数の戻り値の型を示します。 <code class="literal">DECIMAL</code> は <code class="literal">RETURNS</code> のあとの正当な値ですが、現在 <code class="literal">DECIMAL</code> 関数は文字列値を返すため、<code class="literal">STRING</code> 関数のように記述してください。 
      </p><p>
        <code class="literal">AGGREGATE</code> キーワード (指定されている場合) は、UDF が集計 (グループ) 関数であることを示します。 集計 UDF は、<code class="literal">SUM()</code> や <code class="literal">COUNT()</code> などのネイティブ MySQL 集計関数とまったく同じように機能します。 
      </p><p>
        <em class="replaceable"><code>shared_library_name</code></em> は、関数を実装するコードを含む共有ライブラリファイルのベース名です。 このファイルは、プラグインディレクトリに存在する必要があります。 このディレクトリは、<code class="literal">plugin_dir</code> システム変数の値から取得できます。 詳細は、<a class="xref" href="server-administration.html#function-loading" title="5.7.1 ユーザー定義関数のインストールおよびアンインストール">セクション5.7.1「ユーザー定義関数のインストールおよびアンインストール」</a>を参照してください。 
      </p><p>
        <code class="literal">CREATE FUNCTION</code> では、関数を登録するために <code class="literal">mysql.func</code> システムテーブルに行が追加されるため、<code class="literal">mysql</code> システムスキーマに対する <code class="literal">INSERT</code> 権限が必要です。
      </p><p>
        <code class="literal">CREATE FUNCTION</code> は、インストールされている UDF に関する実行時情報を提供するパフォーマンススキーマ <code class="literal">user_defined_functions</code> テーブルにもこの関数を追加します。 <a class="xref" href="performance-schema.html#performance-schema-user-defined-functions-table" title="27.12.19.12 user_defined_functions テーブル">セクション27.12.19.12「user_defined_functions テーブル」</a>を参照してください。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">mysql.func</code> システムテーブルと同様に、パフォーマンススキーマ <code class="literal">user_defined_functions</code> テーブルには、<code class="literal">CREATE FUNCTION</code> を使用してインストールされた UDF が一覧表示されます。 <code class="literal">mysql.func</code> テーブルとは異なり、<code class="literal">user_defined_functions</code> テーブルには、サーバーコンポーネントまたはプラグインによって自動的にインストールされる UDF もリストされます。 この違いにより、どの UDF がインストールされているかを <code class="literal">mysql.func</code> より <code class="literal">user_defined_functions</code> で確認することをお薦めします。 
        </p></div><p>
        通常の起動シーケンスでは、サーバーは <code class="literal">mysql.func</code> テーブルに登録されている UDF をロードします。 <code class="option">--skip-grant-tables</code> オプションを使用してサーバーを起動した場合、テーブルに登録されている UDF はロードされず、使用できません。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          UDF に関連付けられた共有ライブラリをアップグレードするには、<code class="literal">DROP FUNCTION</code> ステートメントを発行し、共有ライブラリをアップグレードしたあと、<code class="literal">CREATE FUNCTION</code> ステートメントを発行します。 最初に共有ライブラリをアップグレードしてから <code class="literal">DROP FUNCTION</code> を使用すると、サーバーが予期せず停止する可能性があります。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="drop-function-loadable"></a>13.7.4.2 ユーザー定義関数に対する DROP FUNCTION ステートメント</h4></div></div></div><a class="indexterm" name="idm45826989139296"></a><a class="indexterm" name="idm45826989137808"></a><a class="indexterm" name="idm45826989135888"></a><a class="indexterm" name="idm45826989133744"></a><a class="indexterm" name="idm45826989131680"></a><a class="indexterm" name="idm45826989130768"></a><pre class="programlisting">DROP FUNCTION [IF EXISTS] <em class="replaceable"><code>function_name</code></em>
</pre><p>
        このステートメントは、<em class="replaceable"><code>function_name</code></em> という名前のユーザー定義関数 (UDF) を削除します。 (<code class="literal">DROP FUNCTION</code> は、ストアドファンクションの削除にも使用されます。<a class="xref" href="sql-statements.html#drop-procedure" title="13.1.29 DROP PROCEDURE および DROP FUNCTION ステートメント">セクション13.1.29「DROP PROCEDURE および DROP FUNCTION ステートメント」</a> を参照してください。) 
      </p><p>
        <code class="literal">DROP FUNCTION</code> は、<code class="literal">CREATE FUNCTION</code> を補完したものです。 関数を登録する <code class="literal">mysql.func</code> システムテーブルから行が削除されるため、<code class="literal">mysql</code> システムスキーマに対する <code class="literal">DELETE</code> 権限が必要です。 
      </p><p>
        <code class="literal">DROP FUNCTION</code> は、インストールされている UDF に関する実行時情報を提供するパフォーマンススキーマ <code class="literal">user_defined_functions</code> テーブルからも関数を削除します。 <a class="xref" href="performance-schema.html#performance-schema-user-defined-functions-table" title="27.12.19.12 user_defined_functions テーブル">セクション27.12.19.12「user_defined_functions テーブル」</a>を参照してください。 
      </p><p>
        通常の起動シーケンスでは、サーバーは <code class="literal">mysql.func</code> テーブルに登録されている UDF をロードします。 <code class="literal">DROP FUNCTION</code> は削除された関数の <code class="literal">mysql.func</code> 行を削除するため、サーバーはその後の再起動時に関数をロードしません。 
      </p><p>
        <code class="literal">DROP FUNCTION</code> を使用して、<code class="literal">CREATE FUNCTION</code> を使用するのではなく、コンポーネントまたはプラグインによって自動的にインストールされる UDF を削除することはできません。 このような UDF は、UDF をインストールしたコンポーネントまたはプラグインがアンインストールされると、自動的に削除されます。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          UDF に関連付けられた共有ライブラリをアップグレードするには、<code class="literal">DROP FUNCTION</code> ステートメントを発行し、共有ライブラリをアップグレードしたあと、<code class="literal">CREATE FUNCTION</code> ステートメントを発行します。 最初に共有ライブラリをアップグレードしてから <code class="literal">DROP FUNCTION</code> を使用すると、サーバーが予期せず停止する可能性があります。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="install-component"></a>13.7.4.3 INSTALL COMPONENT ステートメント</h4></div></div></div><a class="indexterm" name="idm45826989097840"></a><a class="indexterm" name="idm45826989096304"></a><a class="indexterm" name="idm45826989094896"></a><pre class="programlisting">INSTALL COMPONENT <em class="replaceable"><code>component_name</code></em> [, <em class="replaceable"><code>component_name</code></em> ] ...
</pre><p>
        このステートメントは、すぐにアクティブになる 1 つ以上のコンポーネントをインストールします。 コンポーネントは、サーバーおよびその他のコンポーネントで使用可能なサービスを提供します。<a class="xref" href="server-administration.html#components" title="5.5 MySQL のコンポーネント">セクション5.5「MySQL のコンポーネント」</a> を参照してください。 <code class="literal">INSTALL COMPONENT</code> では、コンポーネントを登録するために <code class="literal">mysql.component</code> システムテーブルに行が追加されるため、そのテーブルに対する <code class="literal">INSERT</code> 権限が必要です。 
      </p><p>
        例:
      </p><pre class="programlisting">INSTALL COMPONENT 'file://component1', 'file://component2';
</pre><p>
        コンポーネント名は、<code class="literal">file://</code>で始まり、<code class="literal">plugin_dir</code> システム変数で指定されたディレクトリにある、コンポーネントを実装するファイルのベース名を示す URN です。 コンポーネント名には、<code class="filename">.so</code> や <code class="filename">.dll</code> などのプラットフォーム依存のファイル名接尾辞は含まれません。 (コンポーネント名の解釈自体がサービスによって実行され、コンポーネントインフラストラクチャによってデフォルトのサービス実装を代替実装に置き換えることができるため、これらのネーミング詳細は変更される可能性があります。) 
      </p><p>
        エラーが発生した場合、ステートメントは失敗し、効果はありません。 たとえば、コンポーネント名が間違っている場合、名前付きコンポーネントが存在しないかすでにインストールされている場合、またはコンポーネントの初期化が失敗した場合に発生します。 
      </p><p>
        ローダーサービスはコンポーネントのロードを処理します。これには、レジストリとして機能する <code class="literal">mysql.component</code> システムテーブルへのインストール済コンポーネントの追加が含まれます。 その後のサーバーの再起動では、<code class="literal">mysql.component</code> にリストされているコンポーネントは、起動シーケンス中にローダーサービスによってロードされます。 これは、サーバーが <code class="option">--skip-grant-tables</code> オプションを使用して起動された場合でも発生します。 
      </p><p>
        コンポーネントがレジストリに存在しないサービスに依存しており、依存するサービスを提供するコンポーネントもインストールせずにコンポーネントをインストールしようとすると、エラーが発生します:
      </p><pre class="programlisting">ERROR 3527 (HY000): Cannot satisfy dependency for service 'component_a'
required by component 'component_b'.
</pre><p>
        この問題を回避するには、すべてのコンポーネントを同じステートメントでインストールするか、依存先のコンポーネントをインストールした後に依存コンポーネントをインストールします。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="install-plugin"></a>13.7.4.4 INSTALL PLUGIN ステートメント</h4></div></div></div><a class="indexterm" name="idm45826989067504"></a><a class="indexterm" name="idm45826989065968"></a><a class="indexterm" name="idm45826989064592"></a><pre class="programlisting">INSTALL PLUGIN <em class="replaceable"><code>plugin_name</code></em> SONAME '<em class="replaceable"><code>shared_library_name</code></em>'
</pre><p>
        このステートメントは、サーバープラグインをインストールします。 プラグインを登録するために <code class="literal">mysql.plugin</code> システムテーブルに行が追加されるため、このテーブルに対する <code class="literal">INSERT</code> 権限が必要です。 
      </p><p>
        <em class="replaceable"><code>plugin_name</code></em> は、ライブラリファイルに含まれているプラグインディスクリプタ構造で定義されているプラグインの名前です (<a class="ulink" href="https://dev.mysql.com/doc/extending-mysql/8.0/en/plugin-data-structures.html" target="_top">Plugin Data Structures</a>を参照してください)。 プラグイン名では大文字と小文字は区別されません。 プラグイン名は C ソースファイル、シェルコマンド行、M4 および Bourne シェルスクリプト、SQL 環境などで使用されるため、最大化の互換性のために、プラグイン名は ASCII 文字、数字、およびアンダースコアに制限するようにしてください。 
      </p><p>
        <em class="replaceable"><code>shared_library_name</code></em> は、プラグインコードを含む共有ライブラリの名前です。 この名前には、ファイル名拡張子が含まれています (<code class="filename">libmyplugin.so</code>、<code class="filename">libmyplugin.dll</code>、<code class="filename">libmyplugin.dylib</code> など)。 
      </p><p>
        共有ライブラリは、プラグインディレクトリ (<code class="literal">plugin_dir</code> システム変数で指定されているディレクトリ) 内に存在する必要があります。 このライブラリは、サブディレクトリ内ではなく、プラグインディレクトリ自体に存在する必要があります。 デフォルトでは、<code class="literal">plugin_dir</code> は <code class="literal">pkglibdir</code> 構成変数で指定されているディレクトリの下にある <code class="filename">plugin</code> ディレクトリですが、サーバーの起動時に <code class="literal">plugin_dir</code> の値を設定することによって変更できます。 たとえば、<code class="filename">my.cnf</code> ファイル内でその値を設定します。 
      </p><pre class="programlisting">[mysqld]
plugin_dir=<em class="replaceable"><code>/path/to/plugin/directory</code></em>
</pre><p>
        <code class="literal">plugin_dir</code> の値が相対パス名である場合は、MySQL ベースディレクトリ (<code class="literal">basedir</code> システム変数の値) を基準にしていると見なされます。
      </p><p>
        <code class="literal">INSTALL PLUGIN</code> は、プラグインを使用可能にするために、そのプラグインコードをロードして初期化します。 プラグインは、使用可能になる前にそのプラグインが実行する必要のあるすべての設定を処理するその初期化関数を実行することによって初期化されます。 サーバーがシャットダウンすると、ロードされるプラグインごとに初期化解除関数が実行されるため、プラグインは最終的なクリーンアップを実行できます。 
      </p><p>
        また、<code class="literal">INSTALL PLUGIN</code> は、プラグイン名とライブラリファイル名を示す行を <code class="literal">mysql.plugin</code> システムテーブルに追加して、プラグインを登録します。 通常の起動シーケンスでは、サーバーは <code class="literal">mysql.plugin</code> に登録されているプラグインをロードして初期化します。 つまり、プラグインはサーバーが起動するたびにではなく、1 回だけ <code class="literal">INSTALL PLUGIN</code> によってインストールされます。 サーバーが <code class="option">--skip-grant-tables</code> オプションで起動された場合、<code class="literal">mysql.plugin</code> テーブルに登録されているプラグインはロードされず、使用できません。 
      </p><p>
        プラグインライブラリには、複数のプラグインを含めることができます。 各プラグインをインストールするには、個別の <code class="literal">INSTALL PLUGIN</code> ステートメントを使用します。 各ステートメントは異なるプラグインを指定しますが、そのすべてが同じライブラリ名を指定します。 
      </p><p>
        <code class="literal">INSTALL PLUGIN</code> を指定すると、サーバーは、サーバーの起動中と同様にオプション (<code class="filename">my.cnf</code>) ファイルを読み取ります。 これにより、プラグインは、これらのファイルからすべての関連オプションを取得できるようになります。 プラグインをロードする前でも、オプションファイルにプラグインオプションを追加できます (<code class="literal">loose</code> プリフィクスが使用されている場合)。 また、プラグインをアンインストールしたり、<code class="filename">my.cnf</code> を編集したり、プラグインを再度インストールしたりすることもできます。 プラグインをこの方法で再起動すると、サーバーを再起動することなく新しいオプション値を指定できます。 
      </p><p>
        サーバーの起動時に個々のプラグインロードを制御するオプションについては、<a class="xref" href="server-administration.html#plugin-loading" title="5.6.1 プラグインのインストールおよびアンインストール">セクション5.6.1「プラグインのインストールおよびアンインストール」</a>を参照してください。 サーバーにシステムテーブルを読み取らないよう指示する <code class="option">--skip-grant-tables</code> オプションが指定されたとき、1 回のサーバー起動時にプラグインをロードする必要がある場合は、<code class="option">--plugin-load</code> オプションを使用します。 <a class="xref" href="server-administration.html#server-options" title="5.1.7 サーバーコマンドオプション">セクション5.1.7「サーバーコマンドオプション」</a>を参照してください。 
      </p><p>
        プラグインを削除するには、<code class="literal">UNINSTALL PLUGIN</code> ステートメントを使用します。
      </p><p>
        プラグインのロードについての追加情報は、<a class="xref" href="server-administration.html#plugin-loading" title="5.6.1 プラグインのインストールおよびアンインストール">セクション5.6.1「プラグインのインストールおよびアンインストール」</a>を参照してください。
      </p><p>
        インストールされているプラグインを確認するには、<code class="literal">SHOW PLUGINS</code> ステートメントを使用するか、<code class="literal">INFORMATION_SCHEMA</code> に <code class="literal">PLUGINS</code> テーブルをクエリーします。
      </p><p>
        プラグインライブラリを再コンパイルするとき、それを再インストールする必要がある場合は、次の方法のいずれかを使用できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">UNINSTALL PLUGIN</code> を使用してライブラリ内のすべてのプラグインをアンインストールし、新しいプラグインライブラリファイルをプラグインディレクトリにインストールしてから、<code class="literal">INSTALL PLUGIN</code> を使用してすべてのプラグインをライブラリにインストールします。 この手順には、サーバーを停止することなく使用できるという利点があります。 ただし、プラグインライブラリに多数のプラグインが含まれている場合は、多数の <code class="literal">INSTALL PLUGIN</code> および <code class="literal">UNINSTALL PLUGIN</code> ステートメントを発行する必要があります。 
          </p></li><li class="listitem"><p>
            サーバーを停止し、新しいプラグインライブラリファイルをプラグインディレクトリにインストールしてから、サーバーを再起動します。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="uninstall-component"></a>13.7.4.5 UNINSTALL COMPONENT ステートメント</h4></div></div></div><a class="indexterm" name="idm45826989002352"></a><a class="indexterm" name="idm45826989000800"></a><a class="indexterm" name="idm45826988999392"></a><pre class="programlisting">UNINSTALL COMPONENT <em class="replaceable"><code>component_name</code></em> [, <em class="replaceable"><code>component_name</code></em> ] ...
</pre><p>
        このステートメントは、1 つ以上のコンポーネントを非アクティブ化およびアンインストールします。 コンポーネントは、サーバーおよびその他のコンポーネントで使用可能なサービスを提供します。<a class="xref" href="server-administration.html#components" title="5.5 MySQL のコンポーネント">セクション5.5「MySQL のコンポーネント」</a> を参照してください。 <code class="literal">UNINSTALL COMPONENT</code> は、<code class="literal">INSTALL COMPONENT</code> を補完したものです。 コンポーネントを登録するテーブルから行が削除されるため、<code class="literal">mysql.component</code> システムテーブルに対する <code class="literal">DELETE</code> 権限が必要です。 
      </p><p>
        例:
      </p><pre class="programlisting">UNINSTALL COMPONENT 'file://component1', 'file://component2';
</pre><p>
        コンポーネントのネーミングの詳細は、<a class="xref" href="sql-statements.html#install-component" title="13.7.4.3 INSTALL COMPONENT ステートメント">セクション13.7.4.3「INSTALL COMPONENT ステートメント」</a> を参照してください。
      </p><p>
        エラーが発生した場合、ステートメントは失敗し、効果はありません。 たとえば、コンポーネント名が誤っている場合、名前付きコンポーネントがインストールされていない場合、または他のインストール済コンポーネントが依存しているためアンインストールできない場合に発生します。 
      </p><p>
        ローダーサービスはコンポーネントのアンロードを処理します。これには、レジストリとして機能する <code class="literal">mysql.component</code> システムテーブルからのアンインストールされたコンポーネントの削除が含まれます。 その結果、アンロードされたコンポーネントは、後続のサーバー再起動のために起動シーケンス中にロードされません。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="uninstall-plugin"></a>13.7.4.6 UNINSTALL PLUGIN ステートメント</h4></div></div></div><a class="indexterm" name="idm45826988979360"></a><a class="indexterm" name="idm45826988977856"></a><a class="indexterm" name="idm45826988976448"></a><pre class="programlisting">UNINSTALL PLUGIN <em class="replaceable"><code>plugin_name</code></em>
</pre><p>
        このステートメントは、インストールされているサーバープラグインを削除します。 <code class="literal">UNINSTALL PLUGIN</code> は、<code class="literal">INSTALL PLUGIN</code> を補完したものです。 プラグインを登録するテーブルから行が削除されるため、<code class="literal">mysql.plugin</code> システムテーブルに対する <code class="literal">DELETE</code> 権限が必要です。 
      </p><p>
        <em class="replaceable"><code>plugin_name</code></em> は、<code class="literal">mysql.plugin</code> テーブルにリストされている何らかのプラグインの名前である必要があります。 サーバーはプラグイン初期化解除関数を実行し、プラグインの行を <code class="literal">mysql.plugin</code> システムテーブルから削除するため、その後のサーバーの再起動でプラグインがロードおよび初期化されることはありません。 <code class="literal">UNINSTALL PLUGIN</code> は、プラグイン共有ライブラリファイルを削除しません。 
      </p><p>
        プラグインを使用しているテーブルが開いている場合は、そのプラグインをアンインストールできません。
      </p><p>
        プラグインの削除は、関連付けられたテーブルの使用に影響を与えます。 たとえば、全文パーサープラグインがテーブル上の <code class="literal">FULLTEXT</code> インデックスに関連付けられている場合は、そのプラグインをアンインストールするとそのテーブルが使用できなくなります。 そのテーブルにアクセスしようとすると、エラーが発生します。 そのテーブルを開くこともできないため、そのプラグインが使用されているインデックスを削除できません。 つまり、テーブルの内容が必要であるかぎり、プラグインのアンインストールは慎重に行う必要があります。 あとで再インストールする予定のないプラグインをアンインストールしており、テーブルの内容が必要である場合は、あとでそのテーブルをリロードできるように、そのテーブルを <span class="command"><strong>mysqldump</strong></span> でダンプし、ダンプされた <code class="literal">CREATE TABLE</code> ステートメントから <code class="literal">WITH PARSER</code> 句を削除するようにしてください。 テーブルの内容が必要でない場合は、そのテーブルに関連付けられたいずれかのプラグインがない場合でも <code class="literal">DROP TABLE</code> を使用できます。 
      </p><p>
        プラグインのロードについての追加情報は、<a class="xref" href="server-administration.html#plugin-loading" title="5.6.1 プラグインのインストールおよびアンインストール">セクション5.6.1「プラグインのインストールおよびアンインストール」</a>を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="clone"></a>13.7.5 CLONE ステートメント</h3></div></div></div><a class="indexterm" name="idm45826988950560"></a><pre class="programlisting">CLONE <em class="replaceable"><code>clone_action</code></em>

<em class="replaceable"><code>clone_action</code></em>: {
    LOCAL DATA DIRECTORY [=] '<em class="replaceable"><code>clone_dir</code></em>';
  | INSTANCE FROM '<em class="replaceable"><code>user</code></em>'@'<em class="replaceable"><code>host</code></em>':<em class="replaceable"><code>port</code></em>
    IDENTIFIED BY '<em class="replaceable"><code>password</code></em>'
    [DATA DIRECTORY [=] '<em class="replaceable"><code>clone_dir</code></em>']
    [REQUIRE [NO] SSL]
}
</pre><p>
      <code class="literal">CLONE</code> ステートメントは、ローカルまたはリモートの MySQL サーバーインスタンスからデータをクローニングするために使用されます。 <code class="literal">CLONE</code> 構文を使用するには、クローンプラグインをインストールする必要があります。 <a class="xref" href="server-administration.html#clone-plugin" title="5.6.7 クローンプラグイン">セクション5.6.7「クローンプラグイン」</a>を参照してください。 
    </p><p>
      <code class="literal">CLONE LOCAL DATA DIRECTORY</code> 構文は、ローカルの MySQL データディレクトリから、MySQL サーバーインスタンスが実行されているのと同じサーバーまたはノード上のディレクトリにデータをクローニングします。 <code class="literal">'clone_dir'</code>ディレクトリは、データのクローニング先のローカルディレクトリのフルパスです。 絶対パスが必要です。 指定されたディレクトリは存在してはいけませんが、指定されたパスは存在するパスである必要があります。 MySQL サーバーには、指定されたディレクトリを作成するために必要な書込みアクセス権が必要です。 詳細は、<a class="xref" href="server-administration.html#clone-plugin-local" title="5.6.7.2 ローカルでのデータのクローニング">セクション5.6.7.2「ローカルでのデータのクローニング」</a>を参照してください。 
    </p><p>
      <code class="literal">CLONE INSTANCE</code> 構文は、リモート MySQL サーバーインスタンス (ドナー) からデータをクローニングし、クローニング操作が開始された MySQL インスタンス (受信者) に転送します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal"><em class="replaceable"><code>user</code></em></code> は、ドナー MySQL サーバーインスタンス上のクローンユーザーです。
        </p></li><li class="listitem"><p>
          <code class="literal"><em class="replaceable"><code>host</code></em></code> は、ドナー MySQL サーバーインスタンスの <code class="literal">hostname</code> アドレスです。 インターネットプロトコルバージョン 6 (IPv6) アドレス形式はサポートされていません。 かわりに、IPv6 アドレスのエイリアスを使用できます。 IPv4 アドレスはそのまま使用できます。 
        </p></li><li class="listitem"><p>
          <code class="literal"><em class="replaceable"><code>port</code></em></code> は、ドナー MySQL サーバーインスタンスの <code class="literal">port</code> 番号です。 (<code class="literal">mysqlx_port</code> で指定された X プロトコル ポートはサポートされていません。 MySQL Router を介したドナー MySQL サーバーインスタンスへの接続もサポートされていません。) 
        </p></li><li class="listitem"><p>
          <code class="literal">IDENTIFIED BY '<em class="replaceable"><code>password</code></em>'</code>は、ドナー MySQL サーバーインスタンス上のクローンユーザーのパスワードを指定します。
        </p></li><li class="listitem"><p>
          <code class="literal">DATA DIRECTORY [=] '<em class="replaceable"><code>clone_dir</code></em>'</code>は、クローニングするデータの受信者上のディレクトリを指定するために使用するオプションの句です。 このオプションは、受信者データディレクトリ内の既存のデータを削除しない場合に使用します。 絶対パスが必要であり、ディレクトリが存在していない必要があります。 MySQL サーバーには、ディレクトリの作成に必要な書込みアクセス権が必要です。 
        </p><p>
          オプションの <code class="literal">DATA DIRECTORY [=] '<em class="replaceable"><code>clone_dir</code></em>'</code>句を使用しない場合、クローニング操作では、受信者データディレクトリ内の既存のデータが削除され、クローニングされたデータに置き換えられ、その後サーバーが自動的に再起動されます。
        </p></li><li class="listitem"><p>
          <code class="literal">[REQUIRE [NO] SSL]</code>は、クローニングされたデータをネットワーク経由で転送するときに、暗号化された接続を使用するかどうかを明示的に指定します。 明示的な指定が満たされない場合は、エラーが返されます。 SSL 句が指定されていない場合、クローンはデフォルトで暗号化された接続を確立しようとし、セキュアな接続試行が失敗した場合はセキュアでない接続にフォールバックします。 暗号化データをクローニングする場合は、この句が指定されているかどうかに関係なく、セキュアな接続が必要です。 詳細は、<a class="xref" href="server-administration.html#clone-plugin-remote-ssl" title="クローニング用の暗号化された接続の構成">クローニング用の暗号化された接続の構成</a>を参照してください。 
        </p></li></ul></div><p>
      リモート MySQL サーバーインスタンスからのデータのクローニングの詳細は、<a class="xref" href="server-administration.html#clone-plugin-remote" title="5.6.7.3 リモートデータのクローニング">セクション5.6.7.3「リモートデータのクローニング」</a> を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="set-statement"></a>13.7.6 SET ステートメント</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#set-variable">13.7.6.1 変数代入の SET 構文</a></span></dt><dt><span class="section"><a href="sql-statements.html#set-character-set">13.7.6.2 SET CHARACTER SET ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#set-names">13.7.6.3 SET NAMES ステートメント</a></span></dt></dl></div><p>
      <code class="literal">SET</code> ステートメントには複数の形式があります。 特定のサーバー機能に関連付けられていないフォームの説明は、このセクションのサブセクションにあります: 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SET <em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>value</code></em></code> では、サーバーまたはクライアントの操作に影響する変数に値を割り当てることができます。 <a class="xref" href="sql-statements.html#set-variable" title="13.7.6.1 変数代入の SET 構文">セクション13.7.6.1「変数代入の SET 構文」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">SET CHARACTER SET</code> および <code class="literal">SET NAMES</code> は、サーバーへの現在の接続に関連付けられている文字セットおよび照合変数に値を割り当てます。 <a class="xref" href="sql-statements.html#set-character-set" title="13.7.6.2 SET CHARACTER SET ステートメント">セクション13.7.6.2「SET CHARACTER SET ステートメント」</a>および<a class="xref" href="sql-statements.html#set-names" title="13.7.6.3 SET NAMES ステートメント">セクション13.7.6.3「SET NAMES ステートメント」</a>を参照してください。 
        </p></li></ul></div><p>
      他のフォームの説明は他の場所に表示され、実装に役立つ機能に関連する他のステートメントとともにグループ化されます:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SET DEFAULT ROLE</code> および <code class="literal">SET ROLE</code> は、ユーザーアカウントのデフォルトロールおよび現在のロールを設定します。 <a class="xref" href="sql-statements.html#set-default-role" title="13.7.1.9 SET DEFAULT ROLE ステートメント">セクション13.7.1.9「SET DEFAULT ROLE ステートメント」</a>および<a class="xref" href="sql-statements.html#set-role" title="13.7.1.11 SET ROLE ステートメント">セクション13.7.1.11「SET ROLE ステートメント」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">SET PASSWORD</code> は、アカウントのパスワードを割り当てます。 <a class="xref" href="sql-statements.html#set-password" title="13.7.1.10 SET PASSWORD ステートメント">セクション13.7.1.10「SET PASSWORD ステートメント」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">SET RESOURCE GROUP</code> は、スレッドをリソースグループに割り当てます。 <a class="xref" href="sql-statements.html#set-resource-group" title="13.7.2.4 SET RESOURCE GROUP ステートメント">セクション13.7.2.4「SET RESOURCE GROUP ステートメント」</a>を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">SET TRANSACTION ISOLATION LEVEL</code> は、トランザクション処理の分離レベルを設定します。 <a class="xref" href="sql-statements.html#set-transaction" title="13.3.7 SET TRANSACTION ステートメント">セクション13.3.7「SET TRANSACTION ステートメント」</a>を参照してください。 
        </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="set-variable"></a>13.7.6.1 変数代入の SET 構文</h4></div></div></div><a class="indexterm" name="idm45826988884048"></a><a class="indexterm" name="idm45826988881872"></a><a class="indexterm" name="idm45826988879792"></a><a class="indexterm" name="idm45826988877712"></a><a class="indexterm" name="idm45826988875632"></a><a class="indexterm" name="idm45826988873552"></a><a class="indexterm" name="idm45826988872112"></a><pre class="programlisting">SET <em class="replaceable"><code>variable</code></em> = <em class="replaceable"><code>expr</code></em> [, <em class="replaceable"><code>variable</code></em> = <em class="replaceable"><code>expr</code></em>] ...

<em class="replaceable"><code>variable</code></em>: {
    <em class="replaceable"><code>user_var_name</code></em>
  | <em class="replaceable"><code>param_name</code></em>
  | <em class="replaceable"><code>local_var_name</code></em>
  | {GLOBAL | @@GLOBAL.} <em class="replaceable"><code>system_var_name</code></em>
  | {PERSIST | @@PERSIST.} <em class="replaceable"><code>system_var_name</code></em>
  | {PERSIST_ONLY | @@PERSIST_ONLY.} <em class="replaceable"><code>system_var_name</code></em>
  | [SESSION | @@SESSION. | @@] <em class="replaceable"><code>system_var_name</code></em>
}
</pre><p>
        変数割当ての <code class="literal">SET</code> 構文を使用すると、サーバーまたはクライアントの操作に影響する様々なタイプの変数に値を割り当てることができます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ユーザー定義変数。 <a class="xref" href="language-structure.html#user-variables" title="9.4 ユーザー定義変数">セクション9.4「ユーザー定義変数」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            ストアドプロシージャーやストアドファンクションのパラメータ、およびストアドプログラムのローカル変数。 <a class="xref" href="sql-statements.html#stored-program-variables" title="13.6.4 ストアドプログラム内の変数">セクション13.6.4「ストアドプログラム内の変数」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            システム変数。 <a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>を参照してください。 システム変数はまた、<a class="xref" href="server-administration.html#using-system-variables" title="5.1.9 システム変数の使用">セクション5.1.9「システム変数の使用」</a>で説明されているように、サーバーの起動時にも設定できます。 
          </p></li></ul></div><p>
        変数値を割り当てる <code class="literal">SET</code> ステートメントはバイナリログに書き込まれないため、レプリケーションシナリオでは、変数値を実行するホストにのみ影響します。 すべてのレプリケーションホストに影響を与えるには、各ホストでステートメントを実行します。 
      </p><p>
        次の各セクションでは、変数を設定するための <code class="literal">SET</code> 構文について説明します。 <code class="literal">=</code> 代入演算子を使用しますが、この目的で<code class="literal">:=</code> 代入演算子も許可されています。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#set-variable-user-variables" title="ユーザー定義変数の割当て">ユーザー定義変数の割当て</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#set-variable-parameters-local-variables" title="パラメータおよびローカル変数の割当て">パラメータおよびローカル変数の割当て</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#set-variable-system-variables" title="システム変数の割当て">システム変数の割当て</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#set-variable-error-handling" title="SET エラー処理">SET エラー処理</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#set-variable-multiple-assignments" title="複数変数の割当て">複数変数の割当て</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#variable-references-in-expressions" title="式でのシステム変数参照">式でのシステム変数参照</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="set-variable-user-variables"></a>ユーザー定義変数の割当て</h5></div></div></div><p>
          ユーザー定義変数はセッション内でローカルに作成され、そのセッションのコンテキスト内にのみ存在します。<a class="xref" href="language-structure.html#user-variables" title="9.4 ユーザー定義変数">セクション9.4「ユーザー定義変数」</a> を参照してください。
        </p><p>
          ユーザー定義変数は<code class="literal">@<em class="replaceable"><code>var_name</code></em></code> として書き込まれ、次のように式の値が割り当てられます:
        </p><pre class="programlisting">SET @<em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>expr</code></em>;
</pre><p>
          例:
        </p><pre class="programlisting">SET @name = 43;
SET @total_tax = (SELECT SUM(tax) FROM taxable_transactions);
</pre><p>
          これらのステートメントで示されているように、<em class="replaceable"><code>expr</code></em> では単純 (リテラル値) から複雑 (スカラーサブクエリーによって返される値) までの範囲を指定できます。
        </p><p>
          パフォーマンススキーマ <code class="literal">user_variables_by_thread</code> テーブルには、ユーザー定義変数に関する情報が含まれています。 <a class="xref" href="performance-schema.html#performance-schema-user-variable-tables" title="27.12.10 パフォーマンススキーマのユーザー定義変数テーブル">セクション27.12.10「パフォーマンススキーマのユーザー定義変数テーブル」</a>を参照してください。 
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="set-variable-parameters-local-variables"></a>パラメータおよびローカル変数の割当て</h5></div></div></div><p>
          <code class="literal">SET</code> は、定義されているストアドオブジェクトのコンテキストで、パラメータおよびローカル変数に適用されます。 次の手順では、<code class="literal">increment</code> プロシージャパラメータおよび <code class="literal">counter</code> ローカル変数を使用します: 
        </p><pre class="programlisting">CREATE PROCEDURE p(increment INT)
BEGIN
  DECLARE counter INT DEFAULT 0;
  WHILE counter &lt; 10 DO
    -- ... do work ...
    SET counter = counter + increment;
  END WHILE;
END;
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="set-variable-system-variables"></a>システム変数の割当て</h5></div></div></div><p>
          MySQL サーバーは、その操作を構成するシステム変数を保持します。 システム変数には、サーバー操作全体に影響するグローバル値、現在のセッションに影響するセッション値、またはその両方を指定できます。 多くのシステム変数は動的であり、<code class="literal">SET</code> ステートメントを使用して実行時に変更し、現在のサーバーインスタンスの操作に影響を与えることができます。 <code class="literal">SET</code> を使用して、特定のシステム変数をデータディレクトリ内の <code class="filename">mysqld-auto.cnf</code> ファイルに永続化し、後続の起動のためのサーバー操作に影響を与えることもできます。 
        </p><p>
          セッションシステム変数を変更しても、変数を別の値に変更するか、セッションが終了するまで、その値はセッション内で有効なままです。 この変更は、他のセッションには影響しません。 
        </p><p>
          グローバルシステム変数を変更した場合、値は記憶され、変数を別の値に変更するかサーバーが終了するまで、新しいセッションのセッション値の初期化に使用されます。 変更は、グローバル値にアクセスするすべてのクライアントに表示されます。 ただし、変更は、変更後に接続するクライアントの対応するセッション値にのみ影響します。 グローバル変数の変更は、現在のクライアントセッションのセッション値には影響しません (グローバル値の変更が発生したセッションにも影響しません)。 
        </p><p>
          グローバルシステム変数設定をサーバーの再起動後も適用されるように永続化するには、データディレクトリ内の <code class="filename">mysqld-auto.cnf</code> ファイルに永続化します。 <code class="filename">my.cnf</code> オプションファイルを手動で変更して永続的な構成変更を行うこともできますが、これは面倒であり、手動で入力した設定のエラーは後で検出されない可能性があります。 構文エラーのある設定は成功せず、サーバー構成を変更しないため、システム変数を永続化する <code class="literal">SET</code> ステートメントはより便利であり、不正な設定が発生する可能性を回避します。 システム変数および <code class="filename">mysqld-auto.cnf</code> ファイルの永続化の詳細は、<a class="xref" href="server-administration.html#persisted-system-variables" title="5.1.9.3 永続化されるシステム変数">セクション5.1.9.3「永続化されるシステム変数」</a> を参照してください。 
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            グローバルシステム変数値を設定または永続化するには、常に特別な権限が必要です。 通常、セッションシステム変数の値を設定するには特別な権限は必要なく、例外がありますが、すべてのユーザーが設定できます。 詳細は、<a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。 
          </p></div><p>
          次の説明では、システム変数を設定および永続化するための構文オプションについて説明します:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              グローバルシステム変数に値を割り当てるには、変数名の前に <code class="literal">GLOBAL</code> キーワードまたは<code class="literal">@@GLOBAL.</code> 修飾子を付けます:
            </p><pre class="programlisting">SET GLOBAL max_connections = 1000;
SET @@GLOBAL.max_connections = 1000;
</pre></li><li class="listitem"><p>
              セッションシステム変数に値を割り当てるには、変数名の前に <code class="literal">SESSION</code> または <code class="literal">LOCAL</code> キーワード、<code class="literal">@@SESSION.</code>、<code class="literal">@@LOCAL.</code> または<code class="literal">@@</code>修飾子、あるいはキーワードなしまたは修飾子なしを付けます:
            </p><pre class="programlisting">SET SESSION sql_mode = 'TRADITIONAL';
SET LOCAL sql_mode = 'TRADITIONAL';
SET @@SESSION.sql_mode = 'TRADITIONAL';
SET @@LOCAL.sql_mode = 'TRADITIONAL';
SET @@sql_mode = 'TRADITIONAL';
SET sql_mode = 'TRADITIONAL';
</pre><p>
              クライアントは自分のセッション変数を変更できますが、ほかのどのクライアントのセッション変数も変更できません。
            </p></li><li class="listitem"><p>
              グローバルシステム変数をデータディレクトリ内の <code class="filename">mysqld-auto.cnf</code> オプションファイルに永続化するには、変数名の前に <code class="literal">PERSIST</code> キーワードまたは<code class="literal">@@PERSIST.</code> 修飾子を付けます:
            </p><pre class="programlisting">SET PERSIST max_connections = 1000;
SET @@PERSIST.max_connections = 1000;
</pre><p>
              この <code class="literal">SET</code> 構文を使用すると、サーバーの再起動後も保持される構成を実行時に変更できます。 <code class="literal">SET GLOBAL</code> と同様に、<code class="literal">SET PERSIST</code> はグローバル変数のランタイム値を設定しますが、変数設定も <code class="filename">mysqld-auto.cnf</code> ファイルに書き込みます (既存の変数設定がある場合は置き換えます)。 
            </p></li><li class="listitem"><p>
              グローバル変数のランタイム値を設定せずにグローバルシステム変数を <code class="filename">mysqld-auto.cnf</code> ファイルに永続化するには、変数名の前に <code class="literal">PERSIST_ONLY</code> キーワードまたは<code class="literal">@@PERSIST_ONLY.</code> 修飾子を付けます:
            </p><pre class="programlisting">SET PERSIST_ONLY back_log = 100;
SET @@PERSIST_ONLY.back_log = 100;
</pre><p>
              <code class="literal">PERSIST</code> と同様に、<code class="literal">PERSIST_ONLY</code> は変数設定を <code class="filename">mysqld-auto.cnf</code> に書き込みます。 ただし、<code class="literal">PERSIST</code> とは異なり、<code class="literal">PERSIST_ONLY</code> はグローバル変数のランタイム値を変更しません。 これにより、<code class="literal">PERSIST_ONLY</code> は、サーバーの起動時にのみ設定できる読取り専用システム変数の構成に適しています。 
            </p></li></ul></div><p>
          グローバルシステム変数値をコンパイル済の MySQL デフォルト値に設定するか、セッションシステム変数を現在対応するグローバル値に設定するには、変数を値 <code class="literal">DEFAULT</code> に設定します。 たとえば、次の 2 つのステートメントは、<code class="literal">max_join_size</code> のセッション値を現在のグローバル値に設定する場合と同じです: 
        </p><pre class="programlisting">SET @@SESSION.max_join_size = DEFAULT;
SET @@SESSION.max_join_size = @@GLOBAL.max_join_size;
</pre><p>
          <code class="literal">SET</code> を使用してグローバルシステム変数を <code class="literal">DEFAULT</code> の値またはリテラルのデフォルト値に永続化すると、変数のデフォルト値が割り当てられ、変数の設定が <code class="filename">mysqld-auto.cnf</code> に追加されます。 ファイルから変数を削除するには、<code class="literal">RESET PERSIST</code> を使用します。 
        </p><p>
          一部のシステム変数は永続化できないか、永続的に制限されています。 <a class="xref" href="server-administration.html#nonpersistible-system-variables" title="5.1.9.4 永続的で永続的に制限されないシステム変数">セクション5.1.9.4「永続的で永続的に制限されないシステム変数」</a>を参照してください。 
        </p><p>
          プラグインによって実装されたシステム変数は、<code class="literal">SET</code> ステートメントの実行時にプラグインがインストールされた場合に永続化できます。 永続化されたプラグイン変数の割り当ては、プラグインがまだインストールされている場合、それ以降のサーバーの再起動で有効になります。 プラグインがインストールされなくなった場合、サーバーが <code class="filename">mysqld-auto.cnf</code> ファイルを読み取るときにプラグイン変数は存在しなくなります。 この場合、サーバーはエラーログに警告を書き込み、続行します: 
        </p><pre class="programlisting">currently unknown variable '<em class="replaceable"><code>var_name</code></em>'
was read from the persisted config file
</pre><p>
          システム変数の名前と値を表示するには:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">SHOW VARIABLES</code> ステートメントを使用します。<a class="xref" href="sql-statements.html#show-variables" title="13.7.7.41 SHOW VARIABLES ステートメント">セクション13.7.7.41「SHOW VARIABLES ステートメント」</a> を参照してください。
            </p></li><li class="listitem"><p>
              「複数のパフォーマンススキーマ」テーブルは、システム変数情報を提供します。 <a class="xref" href="performance-schema.html#performance-schema-system-variable-tables" title="27.12.14 パフォーマンススキーマシステム変数テーブル">セクション27.12.14「パフォーマンススキーマシステム変数テーブル」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              パフォーマンススキーマ <code class="literal">variables_info</code> テーブルには、各システム変数が最後に設定された時期とユーザーを示す情報が含まれています。 <a class="xref" href="performance-schema.html#performance-schema-variables-info-table" title="27.12.14.2 パフォーマンススキーマ variables_info テーブル">セクション27.12.14.2「パフォーマンススキーマ variables_info テーブル」</a>を参照してください。 
            </p></li><li class="listitem"><p>
              パフォーマンススキーマ <code class="literal">persisted_variables</code> テーブルは、<code class="filename">mysqld-auto.cnf</code> ファイルへの SQL インタフェースを提供し、<code class="literal">SELECT</code> ステートメントを使用して実行時にその内容を検査できるようにします。 <a class="xref" href="performance-schema.html#performance-schema-persisted-variables-table" title="27.12.14.1 パフォーマンススキーマ persisted_variables テーブル">セクション27.12.14.1「パフォーマンススキーマ persisted_variables テーブル」</a>を参照してください。 
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="set-variable-error-handling"></a>SET エラー処理</h5></div></div></div><p>
          <code class="literal">SET</code> ステートメントの変数割当てが失敗した場合、ステートメント全体が失敗し、変数は変更されず、<code class="filename">mysqld-auto.cnf</code> ファイルも変更されません。
        </p><p>
          <code class="literal">SET</code> では、ここで説明する状況下でエラーが発生します。 ほとんどの例は、キーワード構文 (<code class="literal">GLOBAL</code> や <code class="literal">SESSION</code> など) を使用する <code class="literal">SET</code> ステートメントを示していますが、対応する修飾子 (<code class="literal">@@GLOBAL.</code> や<code class="literal">@@SESSION.</code> など) を使用するステートメントにも原則が当てはまります。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">SET</code> (任意のバリアント) を使用した読取り専用変数の設定:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL version = 'abc';</code></strong>
ERROR 1238 (HY000): Variable 'version' is a read only variable
</pre></li><li class="listitem"><p>
              <code class="literal">GLOBAL</code>、<code class="literal">PERSIST</code> または <code class="literal">PERSIST_ONLY</code> を使用して、セッション値のみを持つ変数を設定します:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL sql_log_bin = ON;</code></strong>
ERROR 1228 (HY000): Variable 'sql_log_bin' is a SESSION
variable and can't be used with SET GLOBAL
</pre></li><li class="listitem"><p>
              <code class="literal">SESSION</code> を使用して、グローバル値のみを持つ変数を設定します:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET SESSION max_connections = 1000;</code></strong>
ERROR 1229 (HY000): Variable 'max_connections' is a
GLOBAL variable and should be set with SET GLOBAL
</pre></li><li class="listitem"><p>
              グローバル値のみを持つ変数を設定するための <code class="literal">GLOBAL</code>、<code class="literal">PERSIST</code> または <code class="literal">PERSIST_ONLY</code> の省略:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET max_connections = 1000;</code></strong>
ERROR 1229 (HY000): Variable 'max_connections' is a
GLOBAL variable and should be set with SET GLOBAL
</pre></li><li class="listitem"><p>
              <code class="literal">PERSIST</code> または <code class="literal">PERSIST_ONLY</code> を使用して、永続化できない変数を設定します:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET PERSIST port = 3307;</code></strong>
ERROR 1238 (HY000): Variable 'port' is a read only variable
mysql&gt; <strong class="userinput"><code>SET PERSIST_ONLY port = 3307;</code></strong>
ERROR 1238 (HY000): Variable 'port' is a non persistent read only variable
</pre></li><li class="listitem"><p>
              <code class="literal">@@GLOBAL.</code>, <code class="literal">@@PERSIST.</code>, <code class="literal">@@PERSIST_ONLY.</code>, <code class="literal">@@SESSION.</code> および<code class="literal">@@</code>修飾子は、システム変数にのみ適用されます。 ユーザー定義変数、ストアドプロシージャまたはストアドファンクションのパラメータ、またはストアドプログラムのローカル変数に適用しようとすると、エラーが発生します。 
            </p></li><li class="listitem"><p>
              すべてのシステム変数を <code class="literal">DEFAULT</code> に設定できるわけではありません。 このような場合、<code class="literal">DEFAULT</code> を割り当てるとエラーになります。 
            </p></li><li class="listitem"><p>
              ユーザー定義変数、ストアドプロシージャまたはストアドファンクションのパラメータ、またはストアドプログラムのローカル変数に <code class="literal">DEFAULT</code> を割り当てようとすると、エラーが発生します。
            </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="set-variable-multiple-assignments"></a>複数変数の割当て</h5></div></div></div><p>
          <code class="literal">SET</code> ステートメントは、カンマで区切られた複数の変数割り当てを含むことができます。 次のステートメントは、ユーザー定義変数とシステム変数に値を代入します: 
        </p><pre class="programlisting">SET @x = 1, SESSION sql_mode = '';
</pre><p>
          単一のステートメントで複数のシステム変数を設定した場合、ステートメントの最新の <code class="literal">GLOBAL</code>, <code class="literal">PERSIST</code>, <code class="literal">PERSIST_ONLY</code> または <code class="literal">SESSION</code> キーワードが、キーワードが指定されていない次の割当てに使用されます。
        </p><p>
          複数変数割当ての例:
        </p><pre class="programlisting">SET GLOBAL sort_buffer_size = 1000000, SESSION sort_buffer_size = 1000000;
SET @@GLOBAL.sort_buffer_size = 1000000, @@LOCAL.sort_buffer_size = 1000000;
SET GLOBAL max_connections = 1000, sort_buffer_size = 1000000;
</pre><p>
          <code class="literal">@@GLOBAL.</code>, <code class="literal">@@PERSIST.</code>, <code class="literal">@@PERSIST_ONLY.</code>, <code class="literal">@@SESSION.</code> および<code class="literal">@@</code>修飾子は、直後のシステム変数にのみ適用され、残りのシステム変数には適用されません。 次のステートメントは、<code class="literal">sort_buffer_size</code> グローバル値を 50000 に、セッション値を 1000000 に設定します: 
        </p><pre class="programlisting">SET @@GLOBAL.sort_buffer_size = 50000, sort_buffer_size = 1000000;
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="variable-references-in-expressions"></a>式でのシステム変数参照</h5></div></div></div><p>
          式でシステム変数の値を参照するには、いずれかの<code class="literal">@@</code>-modifiers を使用します (式では許可されていない<code class="literal">@@PERSIST.</code> および<code class="literal">@@PERSIST_ONLY.</code> を除く)。 たとえば、次のような <code class="literal">SELECT</code> ステートメントでシステム変数値を取得できます: 
        </p><pre class="programlisting">SELECT @@GLOBAL.sql_mode, @@SESSION.sql_mode, @@sql_mode;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            式内のシステム変数への参照が<code class="literal">@@<em class="replaceable"><code>var_name</code></em></code> (<code class="literal">@@GLOBAL.</code> または<code class="literal">@@SESSION.</code> ではなく<code class="literal">@@</code>を使用) として存在する場合はセッション値を返し、それ以外の場合はグローバル値を返します。 これは、常にセッション値を参照する <code class="literal">SET @@<em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>expr</code></em></code> とは異なります。 
          </p></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="set-character-set"></a>13.7.6.2 SET CHARACTER SET ステートメント</h4></div></div></div><a class="indexterm" name="idm45826988675056"></a><a class="indexterm" name="idm45826988673552"></a><a class="indexterm" name="idm45826988672144"></a><a class="indexterm" name="idm45826988670176"></a><pre class="programlisting">SET {CHARACTER SET | CHARSET}
    {'<em class="replaceable"><code>charset_name</code></em>' | DEFAULT}
</pre><p>
        このステートメントは、サーバーと現在のクライアントの間で送信されたすべての文字列を、指定されたマッピングにマップします。 <code class="literal">SET CHARACTER SET</code> は、3 つのセッションシステム変数を設定します。<code class="literal">character_set_client</code> と <code class="literal">character_set_results</code> は指定された文字セットに設定され、<code class="literal">character_set_connection</code> は <code class="literal">character_set_database</code> の値に設定されます。 <a class="xref" href="charset.html#charset-connection" title="10.4 接続文字セットおよび照合順序">セクション10.4「接続文字セットおよび照合順序」</a>を参照してください。 
      </p><p>
        <em class="replaceable"><code>charset_name</code></em> は、引用符で囲むことも引用符で囲まないこともできます。
      </p><p>
        デフォルトの文字セットマッピングは、値 <code class="literal">DEFAULT</code> を使用してリストアできます。 このデフォルトは、サーバー構成によって異なります。 
      </p><p>
        一部の文字セットは、クライアントの文字セットとして使用できません。 <code class="literal">SET CHARACTER SET</code> でこれらを使用しようとすると、エラーが発生します。 <a class="xref" href="charset.html#charset-connection-impermissible-client-charset" title="許可されていないクライアント文字セット">許可されていないクライアント文字セット</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="set-names"></a>13.7.6.3 SET NAMES ステートメント</h4></div></div></div><a class="indexterm" name="idm45826988649792"></a><a class="indexterm" name="idm45826988648304"></a><pre class="programlisting">SET NAMES {'<em class="replaceable"><code>charset_name</code></em>'
    [COLLATE '<em class="replaceable"><code>collation_name</code></em>'] | DEFAULT}
</pre><p>
        このステートメントは、<code class="literal">character_set_client</code>、<code class="literal">character_set_connection</code> および <code class="literal">character_set_results</code> の 3 つのセッションシステム変数を特定の文字セットに設定します。 <code class="literal">character_set_connection</code> を <code class="literal">charset_name</code> に設定すると、<code class="literal">collation_connection</code> も <code class="literal">charset_name</code> のデフォルトの照合順序に設定されます。 <a class="xref" href="charset.html#charset-connection" title="10.4 接続文字セットおよび照合順序">セクション10.4「接続文字セットおよび照合順序」</a>を参照してください。 
      </p><p>
        オプションの <code class="literal">COLLATE</code> 句を使用すると、照合順序を明示的に指定できます。 指定する場合、照合順序は <em class="replaceable"><code>charset_name</code></em> で許可されている照合順序のいずれかである必要があります。 
      </p><p>
        <em class="replaceable"><code>charset_name</code></em> および <em class="replaceable"><code>collation_name</code></em> は、引用符で囲むことも引用符で囲まないこともできます。
      </p><p>
        デフォルトのマッピングは、<code class="literal">DEFAULT</code> の値を使用してリストアできます。 このデフォルトは、サーバー構成によって異なります。 
      </p><p>
        一部の文字セットは、クライアントの文字セットとして使用できません。 <code class="literal">SET NAMES</code> でこれらを使用しようとすると、エラーが発生します。 <a class="xref" href="charset.html#charset-connection-impermissible-client-charset" title="許可されていないクライアント文字セット">許可されていないクライアント文字セット</a>を参照してください。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="show"></a>13.7.7 SHOW ステートメント</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#show-binary-logs">13.7.7.1 SHOW BINARY LOGS ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-binlog-events">13.7.7.2 SHOW BINLOG EVENTS ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-character-set">13.7.7.3 SHOW CHARACTER SET ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-collation">13.7.7.4 SHOW COLLATION ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-columns">13.7.7.5 SHOW COLUMNS ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-create-database">13.7.7.6 SHOW CREATE DATABASE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-create-event">13.7.7.7 SHOW CREATE EVENT ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-create-function">13.7.7.8 SHOW CREATE FUNCTION ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-create-procedure">13.7.7.9 SHOW CREATE PROCEDURE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-create-table">13.7.7.10 SHOW CREATE TABLE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-create-trigger">13.7.7.11 SHOW CREATE TRIGGER ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-create-user">13.7.7.12 SHOW CREATE USER ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-create-view">13.7.7.13 SHOW CREATE VIEW ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-databases">13.7.7.14 SHOW DATABASES ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-engine">13.7.7.15 SHOW ENGINE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-engines">13.7.7.16 SHOW ENGINES ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-errors">13.7.7.17 SHOW ERRORS ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-events">13.7.7.18 SHOW EVENTS ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-function-code">13.7.7.19 SHOW FUNCTION CODE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-function-status">13.7.7.20 SHOW FUNCTION STATUS ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-grants">13.7.7.21 SHOW GRANTS ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-index">13.7.7.22 SHOW INDEX ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-master-status">13.7.7.23 SHOW MASTER STATUS ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-open-tables">13.7.7.24 SHOW OPEN TABLES ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-plugins">13.7.7.25 SHOW PLUGINS ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-privileges">13.7.7.26 SHOW PRIVILEGES ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-procedure-code">13.7.7.27 SHOW PROCEDURE CODE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-procedure-status">13.7.7.28 SHOW PROCEDURE STATUS ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-processlist">13.7.7.29 SHOW PROCESSLIST ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-profile">13.7.7.30 SHOW PROFILE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-profiles">13.7.7.31 SHOW PROFILES ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-relaylog-events">13.7.7.32 SHOW RELAYLOG EVENTS ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-replicas">13.7.7.33 SHOW REPLICAS | SHOW SLAVE HOSTS ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-slave-hosts">13.7.7.34 SHOW SLAVE HOSTS | SHOW REPLICAS ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-replica-status">13.7.7.35 SHOW REPLICA | SLAVE STATUS ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-slave-status">13.7.7.36 SHOW SLAVE | REPLICA STATUS ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-status">13.7.7.37 SHOW STATUS ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-table-status">13.7.7.38 SHOW TABLE STATUS ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-tables">13.7.7.39 SHOW TABLES ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-triggers">13.7.7.40 SHOW TRIGGERS ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-variables">13.7.7.41 SHOW VARIABLES ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#show-warnings">13.7.7.42 SHOW WARNINGS ステートメント</a></span></dt></dl></div><a class="indexterm" name="idm45826988623952"></a><a class="indexterm" name="idm45826988620592"></a><a class="indexterm" name="idm45826988618416"></a><a class="indexterm" name="idm45826988616992"></a><a class="indexterm" name="idm45826988615552"></a><a class="indexterm" name="idm45826988614112"></a><a class="indexterm" name="idm45826988612688"></a><a class="indexterm" name="idm45826988611280"></a><a class="indexterm" name="idm45826988609840"></a><a class="indexterm" name="idm45826988608416"></a><a class="indexterm" name="idm45826988606976"></a><a class="indexterm" name="idm45826988605536"></a><a class="indexterm" name="idm45826988604096"></a><a class="indexterm" name="idm45826988602672"></a><a class="indexterm" name="idm45826988601232"></a><a class="indexterm" name="idm45826988599808"></a><a class="indexterm" name="idm45826988598384"></a><a class="indexterm" name="idm45826988596976"></a><a class="indexterm" name="idm45826988595568"></a><a class="indexterm" name="idm45826988594160"></a><a class="indexterm" name="idm45826988592752"></a><a class="indexterm" name="idm45826988591344"></a><a class="indexterm" name="idm45826988589904"></a><a class="indexterm" name="idm45826988588464"></a><a class="indexterm" name="idm45826988587056"></a><a class="indexterm" name="idm45826988585648"></a><a class="indexterm" name="idm45826988584240"></a><a class="indexterm" name="idm45826988582816"></a><a class="indexterm" name="idm45826988581376"></a><a class="indexterm" name="idm45826988579952"></a><a class="indexterm" name="idm45826988578544"></a><a class="indexterm" name="idm45826988577120"></a><a class="indexterm" name="idm45826988575680"></a><a class="indexterm" name="idm45826988574240"></a><a class="indexterm" name="idm45826988572816"></a><a class="indexterm" name="idm45826988571408"></a><a class="indexterm" name="idm45826988570000"></a><a class="indexterm" name="idm45826988568560"></a><a class="indexterm" name="idm45826988567088"></a><a class="indexterm" name="idm45826988565632"></a><a class="indexterm" name="idm45826988564224"></a><a class="indexterm" name="idm45826988562816"></a><a class="indexterm" name="idm45826988561392"></a><a class="indexterm" name="idm45826988559984"></a><a class="indexterm" name="idm45826988558560"></a><p>
      <code class="literal">SHOW</code> には、データベース、テーブル、カラムに関する情報、またはサーバーに関するステータス情報を提供するための多くの形式があります。 このセクションでは、次のものについて説明します。 
    </p><pre class="programlisting">SHOW {BINARY | MASTER} LOGS
SHOW BINLOG EVENTS [IN '<em class="replaceable"><code>log_name</code></em>'] [FROM <em class="replaceable"><code>pos</code></em>] [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]
SHOW CHARACTER SET [<em class="replaceable"><code>like_or_where</code></em>]
SHOW COLLATION [<em class="replaceable"><code>like_or_where</code></em>]
SHOW [FULL] COLUMNS FROM <em class="replaceable"><code>tbl_name</code></em> [FROM <em class="replaceable"><code>db_name</code></em>] [<em class="replaceable"><code>like_or_where</code></em>]
SHOW CREATE DATABASE <em class="replaceable"><code>db_name</code></em>
SHOW CREATE EVENT <em class="replaceable"><code>event_name</code></em>
SHOW CREATE FUNCTION <em class="replaceable"><code>func_name</code></em>
SHOW CREATE PROCEDURE <em class="replaceable"><code>proc_name</code></em>
SHOW CREATE TABLE <em class="replaceable"><code>tbl_name</code></em>
SHOW CREATE TRIGGER <em class="replaceable"><code>trigger_name</code></em>
SHOW CREATE VIEW <em class="replaceable"><code>view_name</code></em>
SHOW DATABASES [<em class="replaceable"><code>like_or_where</code></em>]
SHOW ENGINE <em class="replaceable"><code>engine_name</code></em> {STATUS | MUTEX}
SHOW [STORAGE] ENGINES
SHOW ERRORS [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]
SHOW EVENTS
SHOW FUNCTION CODE <em class="replaceable"><code>func_name</code></em>
SHOW FUNCTION STATUS [<em class="replaceable"><code>like_or_where</code></em>]
SHOW GRANTS FOR <em class="replaceable"><code>user</code></em>
SHOW INDEX FROM <em class="replaceable"><code>tbl_name</code></em> [FROM <em class="replaceable"><code>db_name</code></em>]
SHOW MASTER STATUS
SHOW OPEN TABLES [FROM <em class="replaceable"><code>db_name</code></em>] [<em class="replaceable"><code>like_or_where</code></em>]
SHOW PLUGINS
SHOW PROCEDURE CODE <em class="replaceable"><code>proc_name</code></em>
SHOW PROCEDURE STATUS [<em class="replaceable"><code>like_or_where</code></em>]
SHOW PRIVILEGES
SHOW [FULL] PROCESSLIST
SHOW PROFILE [<em class="replaceable"><code>types</code></em>] [FOR QUERY <em class="replaceable"><code>n</code></em>] [OFFSET <em class="replaceable"><code>n</code></em>] [LIMIT <em class="replaceable"><code>n</code></em>]
SHOW PROFILES
SHOW RELAYLOG EVENTS [IN '<em class="replaceable"><code>log_name</code></em>'] [FROM <em class="replaceable"><code>pos</code></em>] [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]
SHOW {REPLICAS | SLAVE HOSTS}
SHOW {REPLICA | SLAVE} STATUS [FOR CHANNEL <em class="replaceable"><code>channel</code></em>]
SHOW [GLOBAL | SESSION] STATUS [<em class="replaceable"><code>like_or_where</code></em>]
SHOW TABLE STATUS [FROM <em class="replaceable"><code>db_name</code></em>] [<em class="replaceable"><code>like_or_where</code></em>]
SHOW [FULL] TABLES [FROM <em class="replaceable"><code>db_name</code></em>] [<em class="replaceable"><code>like_or_where</code></em>]
SHOW TRIGGERS [FROM <em class="replaceable"><code>db_name</code></em>] [<em class="replaceable"><code>like_or_where</code></em>]
SHOW [GLOBAL | SESSION] VARIABLES [<em class="replaceable"><code>like_or_where</code></em>]
SHOW WARNINGS [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]

<em class="replaceable"><code>like_or_where</code></em>: {
    LIKE '<em class="replaceable"><code>pattern</code></em>'
  | WHERE <em class="replaceable"><code>expr</code></em>
}
</pre><p>
      特定の <code class="literal">SHOW</code> ステートメントの構文に <code class="literal">LIKE '<em class="replaceable"><code>pattern</code></em>'</code>部分が含まれている場合、<code class="literal">'<em class="replaceable"><code>pattern</code></em>'</code>は SQL <code class="literal">%</code> および<code class="literal">_</code>ワイルドカード文字を含むことができる文字列です。 このパターンは、ステートメント出力を一致する値に制限するために役立ちます。 
    </p><p>
      いくつかの <code class="literal">SHOW</code> ステートメントは、どの行を表示するかをより柔軟に指定できる <code class="literal">WHERE</code> 句も受け入れます。 <a class="xref" href="information-schema.html#extended-show" title="26.55 SHOW ステートメントの拡張">セクション26.55「SHOW ステートメントの拡張」</a>を参照してください。 
    </p><p>
      多くの MySQL API (PHP など) では、<code class="literal">SHOW</code> ステートメントから返された結果を <code class="literal">SELECT</code> からの結果セットのように処理できます。詳細は、<a class="xref" href="connectors-apis.html" title="第 29 章 Connector および API">第29章「<i>Connector および API</i>」</a>または API のドキュメントを参照してください。 さらに、SQL では、<code class="literal">INFORMATION_SCHEMA</code> データベース内のテーブルに対するクエリーからの結果を操作できます。これは、<code class="literal">SHOW</code> ステートメントからの結果では簡単にはできません。 <a class="xref" href="information-schema.html" title="第 26 章 INFORMATION_SCHEMA テーブル">第26章「<i>INFORMATION_SCHEMA テーブル</i>」</a>を参照してください。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-binary-logs"></a>13.7.7.1 SHOW BINARY LOGS ステートメント</h4></div></div></div><a class="indexterm" name="idm45826988512720"></a><a class="indexterm" name="idm45826988511216"></a><pre class="programlisting">SHOW BINARY LOGS
SHOW MASTER LOGS
</pre><p>
        サーバー上のバイナリログファイルを一覧表示します。 このステートメントは、どのログをパージできるかを決定する方法を示す、<a class="xref" href="sql-statements.html#purge-binary-logs" title="13.4.1.1 PURGE BINARY LOGS ステートメント">セクション13.4.1.1「PURGE BINARY LOGS ステートメント」</a>で説明されている手順の一部として使用されます。 <code class="literal">SHOW BINARY LOGS</code> には、<code class="literal">REPLICATION CLIENT</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。 
      </p><p>
        暗号化バイナリログファイルには、ファイルの暗号化と復号化に必要な情報を格納する 512 バイトファイルヘッダーがあります。 これは、<code class="literal">SHOW BINARY LOGS</code> によって表示されるファイルサイズに含まれます。 <code class="literal">Encrypted</code> カラムには、バイナリログファイルが暗号化されているかどうかが表示されます。 <code class="literal">binlog_encryption=ON</code> がサーバーに設定されている場合、バイナリログの暗号化はアクティブです。 サーバーの実行中にバイナリログ暗号化がアクティブ化または非アクティブ化された場合、既存のバイナリログファイルは暗号化または復号化されません。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW BINARY LOGS;</code></strong>
+---------------+-----------+-----------+
| Log_name      | File_size | Encrypted |
+---------------+-----------+-----------+
| binlog.000015 |    724935 |       Yes |
| binlog.000016 |    733481 |       Yes |
+---------------+-----------+-----------+
</pre><p>
        <code class="literal">SHOW MASTER LOGS</code> は <code class="literal">SHOW BINARY LOGS</code> と同等です。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-binlog-events"></a>13.7.7.2 SHOW BINLOG EVENTS ステートメント</h4></div></div></div><a class="indexterm" name="idm45826988490608"></a><pre class="programlisting">SHOW BINLOG EVENTS
   [IN '<em class="replaceable"><code>log_name</code></em>']
   [FROM <em class="replaceable"><code>pos</code></em>]
   [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]
</pre><p>
        バイナリログ内のイベントを表示します。 <code class="literal">'<em class="replaceable"><code>log_name</code></em>'</code> を指定しない場合は、最初のバイナリログが表示されます。 <code class="literal">SHOW BINLOG EVENTS</code> には、<code class="literal">REPLICATION SLAVE</code> 権限が必要です。 
      </p><p>
        <code class="literal">LIMIT</code> 句の構文は、<code class="literal">SELECT</code> ステートメントの場合と同じです。 <a class="xref" href="sql-statements.html#select" title="13.2.10 SELECT ステートメント">セクション13.2.10「SELECT ステートメント」</a>を参照してください。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">SHOW BINLOG EVENTS</code> を <code class="literal">LIMIT</code> 句なしで発行すると、サーバーはクライアントに (サーバーによって実行された、データを変更するすべてのステートメントを含む) バイナリログの完全な内容を返すため、時間とリソースを大量に消費するプロセスが開始される可能性があります。 あとの調査や分析のためにバイナリログをテキストファイルに保存するには、<code class="literal">SHOW BINLOG EVENTS</code> の代わりに <span class="command"><strong>mysqlbinlog</strong></span> ユーティリティーを使用してください。 <a class="xref" href="programs.html#mysqlbinlog" title="4.6.8 mysqlbinlog — バイナリログファイルを処理するためのユーティリティー">セクション4.6.8「mysqlbinlog — バイナリログファイルを処理するためのユーティリティー」</a>を参照してください。 
        </p></div><p>
        <code class="literal">SHOW BINLOG EVENTS</code> では、バイナリログのイベントごとに次のフィールドが表示されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Log_name</code>
          </p><p>
            リストされるファイルの名前。
          </p></li><li class="listitem"><p>
            <code class="literal">Pos</code>
          </p><p>
            イベントが発生する位置。
          </p></li><li class="listitem"><p>
            <code class="literal">Event_type</code>
          </p><p>
            イベントタイプを説明する識別子。
          </p></li><li class="listitem"><p>
            <code class="literal">Server_id</code>
          </p><p>
            イベントが発生したサーバーのサーバー ID。
          </p></li><li class="listitem"><p>
            <code class="literal">End_log_pos</code>
          </p><p>
            次のイベントが開始される位置。これは、<code class="literal">Pos</code> にイベントのサイズを加えたものです。
          </p></li><li class="listitem"><p>
            <code class="literal">Info</code>
          </p><p>
            イベントタイプの詳細情報。 この情報の形式は、イベントタイプによって異なります。 
          </p></li></ul></div><p>
        圧縮されたトランザクションペイロードの場合、<code class="literal">Transaction_payload_event</code> は最初に単一のユニットとして印刷されてから解凍され、その内部の各イベントが印刷されます。
      </p><p>
        <code class="literal">SHOW BINLOG EVENTS</code> からの出力には、ユーザーおよびシステム変数の設定に関連した一部のイベントが含まれていません。 バイナリログ内のイベントを完全に取得するには、<span class="command"><strong>mysqlbinlog</strong></span> を使用します。 
      </p><p>
        <code class="literal">SHOW BINLOG EVENTS</code> は、リレーログファイルを操作<span class="emphasis"><em>しません</em></span>。 この目的には、<code class="literal">SHOW RELAYLOG EVENTS</code> を使用できます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-character-set"></a>13.7.7.3 SHOW CHARACTER SET ステートメント</h4></div></div></div><a class="indexterm" name="idm45826988448432"></a><pre class="programlisting">SHOW CHARACTER SET
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        <code class="literal">SHOW CHARACTER SET</code> ステートメントは使用可能な文字セットをすべて表示します。 <code class="literal">LIKE</code> 句 (存在する場合) は、どの文字セット名と照合するかを示します。 <a class="xref" href="information-schema.html#extended-show" title="26.55 SHOW ステートメントの拡張">セクション26.55「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。 例: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CHARACTER SET LIKE 'latin%';</code></strong>
+---------+-----------------------------+-------------------+--------+
| Charset | Description                 | Default collation | Maxlen |
+---------+-----------------------------+-------------------+--------+
| latin1  | cp1252 West European        | latin1_swedish_ci |      1 |
| latin2  | ISO 8859-2 Central European | latin2_general_ci |      1 |
| latin5  | ISO 8859-9 Turkish          | latin5_turkish_ci |      1 |
| latin7  | ISO 8859-13 Baltic          | latin7_general_ci |      1 |
+---------+-----------------------------+-------------------+--------+
</pre><p>
        <code class="literal">SHOW CHARACTER SET</code> 出力には、次のカラムがあります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Charset</code>
          </p><p>
            文字セット名。
          </p></li><li class="listitem"><p>
            <code class="literal">説明</code>
          </p><p>
            文字セットの説明。
          </p></li><li class="listitem"><p>
            <code class="literal">Default collation</code>
          </p><p>
            文字セットのデフォルトの照合順序。
          </p></li><li class="listitem"><p>
            <code class="literal">Maxlen</code>
          </p><p>
            1 文字の格納に必要な最大バイト数。
          </p></li></ul></div><p>
        <code class="literal">filename</code> 文字セットは、内部でのみ使用されます。そのため、<code class="literal">SHOW CHARACTER SET</code> では表示されません。
      </p><p>
        文字セット情報は、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">CHARACTER_SETS</code> テーブルからも入手できます。 <a class="xref" href="information-schema.html#information-schema-character-sets-table" title="26.4 INFORMATION_SCHEMA CHARACTER_SETS テーブル">セクション26.4「INFORMATION_SCHEMA CHARACTER_SETS テーブル」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-collation"></a>13.7.7.4 SHOW COLLATION ステートメント</h4></div></div></div><a class="indexterm" name="idm45826988419424"></a><pre class="programlisting">SHOW COLLATION
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        このステートメントは、サーバーによってサポートされる照合順序を一覧表示します。 デフォルトでは、<code class="literal">SHOW COLLATION</code> からの出力には、使用可能なすべての照合順序が含まれます。 <code class="literal">LIKE</code> 句 (存在する場合) は、どの照合順序名と照合するかを示します。 <a class="xref" href="information-schema.html#extended-show" title="26.55 SHOW ステートメントの拡張">セクション26.55「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。 例: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW COLLATION WHERE Charset = 'latin1';</code></strong>
+-------------------+---------+----+---------+----------+---------+
| Collation         | Charset | Id | Default | Compiled | Sortlen |
+-------------------+---------+----+---------+----------+---------+
| latin1_german1_ci | latin1  |  5 |         | Yes      |       1 |
| latin1_swedish_ci | latin1  |  8 | Yes     | Yes      |       1 |
| latin1_danish_ci  | latin1  | 15 |         | Yes      |       1 |
| latin1_german2_ci | latin1  | 31 |         | Yes      |       2 |
| latin1_bin        | latin1  | 47 |         | Yes      |       1 |
| latin1_general_ci | latin1  | 48 |         | Yes      |       1 |
| latin1_general_cs | latin1  | 49 |         | Yes      |       1 |
| latin1_spanish_ci | latin1  | 94 |         | Yes      |       1 |
+-------------------+---------+----+---------+----------+---------+
</pre><p>
        <code class="literal">SHOW COLLATION</code> 出力には、次のカラムがあります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Collation</code>
          </p><p>
            照合名。
          </p></li><li class="listitem"><p>
            <code class="literal">Charset</code>
          </p><p>
            照合順序が関連付けられる文字セットの名前。
          </p></li><li class="listitem"><p>
            <code class="literal">Id</code>
          </p><p>
            照合 ID。
          </p></li><li class="listitem"><p>
            <code class="literal">Default</code>
          </p><p>
            照合順序がその文字セットのデフォルトであるかどうか。
          </p></li><li class="listitem"><p>
            <code class="literal">Compiled</code>
          </p><p>
            文字セットがサーバーにコンパイルされるかどうか。
          </p></li><li class="listitem"><p>
            <code class="literal">Sortlen</code>
          </p><p>
            これは、文字セットで表される文字列のソートに必要なメモリー量に関連します。
          </p></li></ul></div><p>
        各文字セットのデフォルトの照合順序を表示するには、次のステートメントを使用します。 <code class="literal">Default</code> は予約語であるため、それを識別子として使用するには、次のように引用符で囲む必要があります。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW COLLATION WHERE `Default` = 'Yes';</code></strong>
+---------------------+----------+----+---------+----------+---------+
| Collation           | Charset  | Id | Default | Compiled | Sortlen |
+---------------------+----------+----+---------+----------+---------+
| big5_chinese_ci     | big5     |  1 | Yes     | Yes      |       1 |
| dec8_swedish_ci     | dec8     |  3 | Yes     | Yes      |       1 |
| cp850_general_ci    | cp850    |  4 | Yes     | Yes      |       1 |
| hp8_english_ci      | hp8      |  6 | Yes     | Yes      |       1 |
| koi8r_general_ci    | koi8r    |  7 | Yes     | Yes      |       1 |
| latin1_swedish_ci   | latin1   |  8 | Yes     | Yes      |       1 |
...
</pre><p>
        照合情報は、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">COLLATIONS</code> テーブルからも入手できます。 <a class="xref" href="information-schema.html#information-schema-collations-table" title="26.6 INFORMATION_SCHEMA COLLATIONS テーブル">セクション26.6「INFORMATION_SCHEMA COLLATIONS テーブル」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-columns"></a>13.7.7.5 SHOW COLUMNS ステートメント</h4></div></div></div><a class="indexterm" name="idm45826988384880"></a><a class="indexterm" name="idm45826988381520"></a><a class="indexterm" name="idm45826988380000"></a><pre class="programlisting">SHOW [EXTENDED] [FULL] {COLUMNS | FIELDS}
    {FROM | IN} <em class="replaceable"><code>tbl_name</code></em>
    [{FROM | IN} <em class="replaceable"><code>db_name</code></em>]
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        <code class="literal">SHOW COLUMNS</code> は、特定のテーブル内のカラムに関する情報を表示します。 これはビューに対しても機能します。 <code class="literal">SHOW COLUMNS</code> は、ユーザーが何らかの権限を持っているカラムの情報のみを表示します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW COLUMNS FROM City;</code></strong>
+-------------+----------+------+-----+---------+----------------+
| Field       | Type     | Null | Key | Default | Extra          |
+-------------+----------+------+-----+---------+----------------+
| ID          | int(11)  | NO   | PRI | NULL    | auto_increment |
| Name        | char(35) | NO   |     |         |                |
| CountryCode | char(3)  | NO   | MUL |         |                |
| District    | char(20) | NO   |     |         |                |
| Population  | int(11)  | NO   |     | 0       |                |
+-------------+----------+------+-----+---------+----------------+
</pre><p>
        <code class="literal"><em class="replaceable"><code>tbl_name</code></em> FROM <em class="replaceable"><code>db_name</code></em></code> 構文のかわりに、<em class="replaceable"><code>db_name.tbl_name</code></em> を使用することもできます。 次の 2 つのステートメントは同等です。 
      </p><pre class="programlisting">SHOW COLUMNS FROM mytable FROM mydb;
SHOW COLUMNS FROM mydb.mytable;
</pre><p>
        オプションの <code class="literal">EXTENDED</code> キーワードを使用すると、MySQL が内部的に使用し、ユーザーがアクセスできない非表示カラムに関する情報が出力に含まれます。
      </p><p>
        オプションの <code class="literal">FULL</code> キーワードを指定すると、出力には、カラムの照合およびコメントに加えて、各カラムに付与されている権限が含まれます。
      </p><p>
        <code class="literal">LIKE</code> 句 (存在する場合) は、どのカラム名と照合するかを示します。 <a class="xref" href="information-schema.html#extended-show" title="26.55 SHOW ステートメントの拡張">セクション26.55「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。 
      </p><p>
        テーブルの作成または変更時に MySQL によってデータ型が変更される場合があるため、データ型は <code class="literal">CREATE TABLE</code> ステートメントに基づくものとは異なる場合があります。 この状態が発生する条件は、<a class="xref" href="sql-statements.html#silent-column-changes" title="13.1.20.7 暗黙のカラム指定の変更">セクション13.1.20.7「暗黙のカラム指定の変更」</a>で説明されています。 
      </p><p>
        <code class="literal">SHOW COLUMNS</code> は、テーブルカラムごとに次の値を表示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Field</code>
          </p><p>
            カラムの名前。
          </p></li><li class="listitem"><p>
            <code class="literal">Type</code>
          </p><p>
            カラムのデータ型。
          </p></li><li class="listitem"><p>
            <code class="literal">Collation</code>
          </p><p>
            非バイナリ文字列カラムの照合順序、またはほかのカラムの場合は <code class="literal">NULL</code>。 この値は、<code class="literal">FULL</code> キーワードを使用した場合にのみ表示されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">Null</code>
          </p><p>
            カラムの NULL 値可能性。 この値は、<code class="literal">NULL</code> 値をカラムに格納できる場合は <code class="literal">YES</code> で、格納できない場合は <code class="literal">NO</code> です。 
          </p></li><li class="listitem"><p>
            <code class="literal">Key</code>
          </p><p>
            カラムがインデックス付けされているかどうか:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">Key</code> が空の場合、このカラムはインデックス設定されていないか、またはマルチカラム内のセカンダリカラム (一意でないインデックス) としてのみインデックス設定されているかのどちらかです。
              </p></li><li class="listitem"><p>
                <code class="literal">Key</code> が <code class="literal">PRI</code> の場合、このカラムは <code class="literal">PRIMARY KEY</code> であるか、またはマルチカラム <code class="literal">PRIMARY KEY</code> 内のいずれかのカラムです。
              </p></li><li class="listitem"><p>
                <code class="literal">Key</code> が <code class="literal">UNI</code> の場合、このカラムは <code class="literal">UNIQUE</code> インデックスの最初のカラムです。 (<code class="literal">UNIQUE</code> インデックスは複数の <code class="literal">NULL</code> 値を許可しますが、そのカラムが <code class="literal">NULL</code> を許可するかどうかは <code class="literal">Null</code> フィールドをチェックすることによってわかります。)  
              </p></li><li class="listitem"><p>
                <code class="literal">Key</code> が <code class="literal">MUL</code> の場合、このカラムは、特定の値がカラム内に複数回現れることが許可されている一意でないインデックスの最初のカラムです。
              </p></li></ul></div><p>
            テーブルの特定のカラムに複数の <code class="literal">Key</code> 値が適用される場合、<code class="literal">Key</code> には、もっとも優先度の高い値が <code class="literal">PRI</code>、<code class="literal">UNI</code>、<code class="literal">MUL</code> の順序で表示されます。
          </p><p>
            <code class="literal">UNIQUE</code> インデックスは、<code class="literal">NULL</code> 値を含むことができず、かつテーブル内に <code class="literal">PRIMARY KEY</code> が存在しない場合は <code class="literal">PRI</code> として表示される可能性があります。 <code class="literal">UNIQUE</code> インデックスは、複数のカラムが複合 <code class="literal">UNIQUE</code> インデックスを形成している場合は <code class="literal">MUL</code> として表示される可能性があります。このカラムの組み合わせは一意であるにもかかわらず、各カラムには引き続き、特定の値が複数回現れることがあります。 
          </p></li><li class="listitem"><p>
            <code class="literal">Default</code>
          </p><p>
            カラムのデフォルト値。 これは、カラムのデフォルトが明示的に <code class="literal">NULL</code> に設定されている場合、またはカラム定義に <code class="literal">DEFAULT</code> 句が含まれていない場合の <code class="literal">NULL</code> です。 
          </p></li><li class="listitem"><p>
            <code class="literal">Extra</code>
          </p><p>
            特定のカラムについて使用可能な追加情報。 次の場合、値は空ではありません: 
          </p><a class="indexterm" name="idm45826988307792"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">AUTO_INCREMENT</code> 属性を持つカラムの <code class="literal">auto_increment</code>。
              </p></li><li class="listitem"><p>
                <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> 属性を持つ <code class="literal">on update CURRENT_TIMESTAMP</code> for <code class="literal">TIMESTAMP</code> または <code class="literal">DATETIME</code> のカラム。
              </p></li><li class="listitem"><p>
                生成されたカラムの <code class="literal">VIRTUAL GENERATED</code> または <code class="literal">VIRTUAL STORED</code>。
              </p></li><li class="listitem"><p>
                式のデフォルト値を持つカラムの <code class="literal">DEFAULT_GENERATED</code>。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">権限</code>
          </p><p>
            カラムに対して持っている権限。 この値は、<code class="literal">FULL</code> キーワードを使用した場合にのみ表示されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">Comment</code>
          </p><p>
            カラム定義に含まれるコメント。 この値は、<code class="literal">FULL</code> キーワードを使用した場合にのみ表示されます。 
          </p></li></ul></div><p>
        テーブルのカラム情報は、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">COLUMNS</code> テーブルからも入手できます。 <a class="xref" href="information-schema.html#information-schema-columns-table" title="26.8 INFORMATION_SCHEMA COLUMNS テーブル">セクション26.8「INFORMATION_SCHEMA COLUMNS テーブル」</a>を参照してください。 非表示カラムに関する拡張情報は、<code class="literal">SHOW EXTENDED COLUMNS</code> のみを使用して使用できます。<code class="literal">COLUMNS</code> テーブルからは取得できません。 
      </p><p>
        <span class="command"><strong>mysqlshow <em class="replaceable"><code>db_name</code></em> <em class="replaceable"><code>tbl_name</code></em></strong></span> コマンドを使用してテーブルのカラムをリストできます。
      </p><p>
        <code class="literal">DESCRIBE</code> ステートメントは、<code class="literal">SHOW COLUMNS</code> と同様の情報を提供します。 <a class="xref" href="sql-statements.html#describe" title="13.8.1 DESCRIBE ステートメント">セクション13.8.1「DESCRIBE ステートメント」</a>を参照してください。 
      </p><p>
        また、<code class="literal">SHOW CREATE TABLE</code>、<code class="literal">SHOW TABLE STATUS</code>、および <code class="literal">SHOW INDEX</code> ステートメントでは、テーブルに関する情報も提供されます。 <a class="xref" href="sql-statements.html#show" title="13.7.7 SHOW ステートメント">セクション13.7.7「SHOW ステートメント」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-create-database"></a>13.7.7.6 SHOW CREATE DATABASE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826988272848"></a><a class="indexterm" name="idm45826988271328"></a><pre class="programlisting">SHOW CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] <em class="replaceable"><code>db_name</code></em>
</pre><p>
        指定されたデータベースを作成する <code class="literal">CREATE DATABASE</code> ステートメントを表示します。 <code class="literal">SHOW</code> ステートメントに <code class="literal">IF NOT EXISTS</code> 句が含まれている場合は、このような句が出力にも含まれます。 <code class="literal">SHOW CREATE SCHEMA</code> は <code class="literal">SHOW CREATE DATABASE</code> のシノニムです。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE DATABASE test\G</code></strong>
*************************** 1. row ***************************
       Database: test
Create Database: CREATE DATABASE `test` /*!40100 DEFAULT CHARACTER SET utf8mb4
                 COLLATE utf8mb4_0900_ai_ci */ /*!80014 DEFAULT ENCRYPTION='N' */

mysql&gt; <strong class="userinput"><code>SHOW CREATE SCHEMA test\G</code></strong>
*************************** 1. row ***************************
       Database: test
Create Database: CREATE DATABASE `test` /*!40100 DEFAULT CHARACTER SET utf8mb4
                 COLLATE utf8mb4_0900_ai_ci */ /*!80014 DEFAULT ENCRYPTION='N' */
</pre><p>
        <code class="literal">SHOW CREATE DATABASE</code> は、<code class="literal">sql_quote_show_create</code> オプションの値に従って、テーブル名とカラム名を引用符で囲みます。 <a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-create-event"></a>13.7.7.7 SHOW CREATE EVENT ステートメント</h4></div></div></div><pre class="programlisting">SHOW CREATE EVENT <em class="replaceable"><code>event_name</code></em>
</pre><p>
        このステートメントは、特定のイベントを再作成するために必要な <code class="literal">CREATE EVENT</code> ステートメントを表示します。 これには、このイベントが示される元のデータベースに対する <code class="literal">EVENT</code> 権限が必要です。 例 (<a class="xref" href="sql-statements.html#show-events" title="13.7.7.18 SHOW EVENTS ステートメント">セクション13.7.7.18「SHOW EVENTS ステートメント」</a>で定義され、あとで変更された同じイベント <code class="literal">e_daily</code> を使用しています): 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE EVENT myschema.e_daily\G</code></strong>
*************************** 1. row ***************************
               Event: e_daily
            sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,
                      NO_ZERO_IN_DATE,NO_ZERO_DATE,
                      ERROR_FOR_DIVISION_BY_ZERO,
                      NO_ENGINE_SUBSTITUTION
           time_zone: SYSTEM
        Create Event: CREATE DEFINER=`jon`@`ghidora` EVENT `e_daily`
                        ON SCHEDULE EVERY 1 DAY
                        STARTS CURRENT_TIMESTAMP + INTERVAL 6 HOUR
                        ON COMPLETION NOT PRESERVE
                        ENABLE
                        COMMENT 'Saves total number of sessions then
                                clears the table each day'
                        DO BEGIN
                          INSERT INTO site_activity.totals (time, total)
                            SELECT CURRENT_TIMESTAMP, COUNT(*)
                              FROM site_activity.sessions;
                          DELETE FROM site_activity.sessions;
                        END
character_set_client: utf8mb4
collation_connection: utf8mb4_0900_ai_ci
  Database Collation: utf8mb4_0900_ai_ci
</pre><p>
        <code class="literal">character_set_client</code> は、このイベントが作成されたときの <code class="literal">character_set_client</code> システム変数のセッション値です。<code class="literal">collation_connection</code> は、このイベントが作成されたときの <code class="literal">collation_connection</code> システム変数のセッション値です。 <code class="literal">Database Collation</code> は、このイベントが関連付けられているデータベースの照合順序です。 
      </p><p>
        出力には、イベントが作成されたステータスではなく、イベント (<code class="literal">ENABLE</code>) の現在のステータスが反映されます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-create-function"></a>13.7.7.8 SHOW CREATE FUNCTION ステートメント</h4></div></div></div><a class="indexterm" name="idm45826988229168"></a><pre class="programlisting">SHOW CREATE FUNCTION <em class="replaceable"><code>func_name</code></em>
</pre><p>
        このステートメントは、ストアドファンクションである点を除き、<code class="literal">SHOW CREATE PROCEDURE</code> と同じです。 <a class="xref" href="sql-statements.html#show-create-procedure" title="13.7.7.9 SHOW CREATE PROCEDURE ステートメント">セクション13.7.7.9「SHOW CREATE PROCEDURE ステートメント」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-create-procedure"></a>13.7.7.9 SHOW CREATE PROCEDURE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826988219792"></a><pre class="programlisting">SHOW CREATE PROCEDURE <em class="replaceable"><code>proc_name</code></em>
</pre><p>
        このステートメントは、MySQL 拡張です。 これは、指定されたストアドプロシージャーを再作成するために使用できる正確な文字列を返します。 同様のステートメントである <code class="literal">SHOW CREATE FUNCTION</code> は、ストアドファンクションに関する情報を表示します (<a class="xref" href="sql-statements.html#show-create-function" title="13.7.7.8 SHOW CREATE FUNCTION ステートメント">セクション13.7.7.8「SHOW CREATE FUNCTION ステートメント」</a>を参照してください)。 
      </p><p>
        いずれかのステートメントを使用するには、ルーチン <code class="literal">DEFINER</code> として指定されたユーザー、<code class="literal">SHOW_ROUTINE</code> 権限、グローバルレベルでの <code class="literal">SELECT</code> 権限、またはルーチンを含むスコープで付与された <code class="literal">CREATE ROUTINE</code>、<code class="literal">ALTER ROUTINE</code> または <code class="literal">EXECUTE</code> 権限を持っている必要があります。 <code class="literal">CREATE ROUTINE</code>、<code class="literal">ALTER ROUTINE</code> または <code class="literal">EXECUTE</code> のみがある場合、<code class="literal">Create Procedure</code> または <code class="literal">Create Function</code> フィールドに表示される値は <code class="literal">NULL</code> です。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE PROCEDURE test.citycount\G</code></strong>
*************************** 1. row ***************************
           Procedure: citycount
            sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,
                      NO_ZERO_IN_DATE,NO_ZERO_DATE,
                      ERROR_FOR_DIVISION_BY_ZERO,
                      NO_ENGINE_SUBSTITUTION
    Create Procedure: CREATE DEFINER=`me`@`localhost`
                      PROCEDURE `citycount`(IN country CHAR(3), OUT cities INT)
                      BEGIN
                        SELECT COUNT(*) INTO cities FROM world.city
                        WHERE CountryCode = country;
                      END
character_set_client: utf8mb4
collation_connection: utf8mb4_0900_ai_ci
  Database Collation: utf8mb4_0900_ai_ci

mysql&gt; <strong class="userinput"><code>SHOW CREATE FUNCTION test.hello\G</code></strong>
*************************** 1. row ***************************
            Function: hello
            sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,
                      NO_ZERO_IN_DATE,NO_ZERO_DATE,
                      ERROR_FOR_DIVISION_BY_ZERO,
                      NO_ENGINE_SUBSTITUTION
     Create Function: CREATE DEFINER=`me`@`localhost`
                      FUNCTION `hello`(s CHAR(20))
                      RETURNS char(50) CHARSET utf8mb4
                      DETERMINISTIC
                      RETURN CONCAT('Hello, ',s,'!')
character_set_client: utf8mb4
collation_connection: utf8mb4_0900_ai_ci
  Database Collation: utf8mb4_0900_ai_ci
</pre><p>
        <code class="literal">character_set_client</code> は、このルーチンが作成されたときの <code class="literal">character_set_client</code> システム変数のセッション値です。<code class="literal">collation_connection</code> は、このルーチンが作成されたときの <code class="literal">collation_connection</code> システム変数のセッション値です。 <code class="literal">Database Collation</code> は、このルーチンが関連付けられているデータベースの照合順序です。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-create-table"></a>13.7.7.10 SHOW CREATE TABLE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826988188144"></a><pre class="programlisting">SHOW CREATE TABLE <em class="replaceable"><code>tbl_name</code></em>
</pre><p>
        指定されたテーブルを作成する <code class="literal">CREATE TABLE</code> ステートメントを表示します。 このステートメントを使用するには、そのテーブルに対する何らかの権限が必要です。 また、このステートメントはビューでも機能します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t\G</code></strong>
*************************** 1. row ***************************
       Table: t
Create Table: CREATE TABLE `t` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `s` char(60) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4</pre><a class="indexterm" name="idm45826988177424"></a><p>
        MySQL 8.0.16 では、MySQL によって <code class="literal">CHECK</code> 制約が実装され、<code class="literal">SHOW CREATE TABLE</code> によって表示されます。 すべての <code class="literal">CHECK</code> 制約がテーブル制約として表示されます。 つまり、カラム定義の一部として最初に指定された <code class="literal">CHECK</code> 制約は、カラム定義の一部ではなく別の句として表示されます。 例: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
         <strong class="userinput"><code>i1 INT CHECK (i1 &lt;&gt; 0),      -- column constraint</code></strong>
         <strong class="userinput"><code>i2 INT,</code></strong>
         <strong class="userinput"><code>CHECK (i2 &gt; i1),             -- table constraint</code></strong>
         <strong class="userinput"><code>CHECK (i2 &lt;&gt; 0) NOT ENFORCED -- table constraint, not enforced</code></strong>
       <strong class="userinput"><code>);</code></strong>

mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t1\G</code></strong>
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `i1` int(11) DEFAULT NULL,
  `i2` int(11) DEFAULT NULL,
  CONSTRAINT `t1_chk_1` CHECK ((`i1` &lt;&gt; 0)),
  CONSTRAINT `t1_chk_2` CHECK ((`i2` &gt; `i1`)),
  CONSTRAINT `t1_chk_3` CHECK ((`i2` &lt;&gt; 0)) /*!80016 NOT ENFORCED */
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
</pre><p>
        <code class="literal">SHOW CREATE TABLE</code> は、<code class="literal">sql_quote_show_create</code> オプションの値に従って、テーブル名とカラム名を引用符で囲みます。 <a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>を参照してください。 
      </p><p>
        テーブルのストレージエンジンを変更する場合、新しいストレージエンジンに適用できないテーブルオプションはテーブル定義に保持され、必要に応じて、以前に定義されたオプションを持つテーブルを元のストレージエンジンに戻すことができます。 たとえば、ストレージエンジンを InnoDB から MyISAM に変更する場合、<code class="literal">ROW_FORMAT=COMPACT</code> などの InnoDB 固有のオプションは保持されます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT PRIMARY KEY) ROW_FORMAT=COMPACT ENGINE=InnoDB;</code></strong>
mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 ENGINE=MyISAM;</code></strong>
mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t1\G</code></strong>
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `c1` int NOT NULL,
  PRIMARY KEY (`c1`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=COMPACT
</pre><p>
        <a class="link" href="glossary.html#glos_strict_mode" title="厳密モード">strict mode</a> を無効にしてテーブルを作成する場合、指定した行フォーマットがサポートされていないと、ストレージエンジンのデフォルトの行フォーマットが使用されます。 テーブルの実際の行形式は、<code class="literal">SHOW TABLE STATUS</code> に応じて <code class="literal">Row_format</code> カラムにレポートされます。 <code class="literal">SHOW CREATE TABLE</code> には、<code class="literal">CREATE TABLE</code> ステートメントで指定された行形式が表示されます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-create-trigger"></a>13.7.7.11 SHOW CREATE TRIGGER ステートメント</h4></div></div></div><a class="indexterm" name="idm45826988148624"></a><pre class="programlisting">SHOW CREATE TRIGGER <em class="replaceable"><code>trigger_name</code></em>
</pre><p>
        このステートメントは、指定されたトリガーを作成する <code class="literal">CREATE TRIGGER</code> ステートメントを表示します。 このステートメントには、トリガーに関連付けられたテーブルに対する <code class="literal">TRIGGER</code> 権限が必要です。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TRIGGER ins_sum\G</code></strong>
*************************** 1. row ***************************
               Trigger: ins_sum
              sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,
                        NO_ZERO_IN_DATE,NO_ZERO_DATE,
                        ERROR_FOR_DIVISION_BY_ZERO,
                        NO_ENGINE_SUBSTITUTION
SQL Original Statement: CREATE DEFINER=`me`@`localhost` TRIGGER `ins_sum`
                        BEFORE INSERT ON `account`
                        FOR EACH ROW SET @sum = @sum + NEW.amount
  character_set_client: utf8mb4
  collation_connection: utf8mb4_0900_ai_ci
    Database Collation: utf8mb4_0900_ai_ci
               Created: 2018-08-08 10:10:12.61
</pre><p>
        <code class="literal">SHOW CREATE TRIGGER</code> 出力には、次のカラムがあります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Trigger</code>: トリガー名。
          </p></li><li class="listitem"><p>
            <code class="literal">sql_mode</code>: このトリガーが実行されるときに有効な SQL モード。
          </p></li><li class="listitem"><p>
            <code class="literal">SQL Original Statement</code>: このトリガーを定義する <code class="literal">CREATE TRIGGER</code> ステートメント。
          </p></li><li class="listitem"><p>
            <code class="literal">character_set_client</code>: このトリガーが作成されたときの <code class="literal">character_set_client</code> システム変数のセッション値。
          </p></li><li class="listitem"><p>
            <code class="literal">collation_connection</code>: このトリガーが作成されたときの <code class="literal">collation_connection</code> システム変数のセッション値。
          </p></li><li class="listitem"><p>
            <code class="literal">Database Collation</code>: このトリガーが関連付けられているデータベースの照合順序。
          </p></li><li class="listitem"><p>
            <code class="literal">Created</code>: トリガーが作成された日時。 これは、トリガーの <code class="literal">TIMESTAMP(2)</code> 値 (小数部は数百秒) です。 
          </p></li></ul></div><p>
        トリガー情報は、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">TRIGGERS</code> テーブルからも入手できます。 <a class="xref" href="information-schema.html#information-schema-triggers-table" title="26.45 INFORMATION_SCHEMA TRIGGERS テーブル">セクション26.45「INFORMATION_SCHEMA TRIGGERS テーブル」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-create-user"></a>13.7.7.12 SHOW CREATE USER ステートメント</h4></div></div></div><a class="indexterm" name="idm45826988116912"></a><pre class="programlisting">SHOW CREATE USER <em class="replaceable"><code>user</code></em>
</pre><p>
        このステートメントは、指定されたユーザーを作成する <code class="literal">CREATE USER</code> ステートメントを示します。 ユーザーが存在しない場合は、エラーが発生します。 このステートメントには、<code class="literal">mysql</code> システムスキーマに対する <code class="literal">SELECT</code> 権限が必要です (現在のユーザーの情報を表示する場合を除く)。 現在のユーザーの場合、<code class="literal">IDENTIFIED AS</code> 句でパスワードハッシュを表示するには、<code class="literal">mysql.user</code> システムテーブルに対する <code class="literal">SELECT</code> 権限が必要です。それ以外の場合、ハッシュは <code class="literal">&lt;secret&gt;</code> として表示されます。 
      </p><p>
        アカウントに名前を付けるには、<a class="xref" href="security.html#account-names" title="6.2.4 アカウント名の指定">セクション6.2.4「アカウント名の指定」</a> で説明されている形式を使用します。 アカウント名のホスト名部分は、省略すると<code class="literal">'%'</code>にデフォルト設定されます。 <code class="literal">CURRENT_USER</code> または <code class="literal">CURRENT_USER()</code> を指定して、現在のセッションに関連付けられているアカウントを参照することもできます。 
      </p><p>
        <code class="literal">SHOW CREATE USER</code> からの出力の <code class="literal">IDENTIFIED WITH</code> 句に表示されるパスワードハッシュ値には、端末表示やその他の環境に悪影響を与える印刷不可能な文字が含まれている可能性があります。 <code class="literal">print_identified_with_as_hex</code> システム変数 (MySQL 8.0.17 で使用可能) を有効にすると、<code class="literal">SHOW CREATE USER</code> では、このようなハッシュ値が通常の文字列リテラルとしてではなく 16 進数文字列として表示されます。 印刷できない文字を含まないハッシュ値は、この変数が有効になっていても、通常の文字列リテラルとして表示されます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE USER 'u1'@'localhost' IDENTIFIED BY 'secret';</code></strong>
mysql&gt; <strong class="userinput"><code>SET print_identified_with_as_hex = ON;</code></strong>
mysql&gt; <strong class="userinput"><code>SHOW CREATE USER 'u1'@'localhost'\G</code></strong>
*************************** 1. row ***************************
CREATE USER for u1@localhost: CREATE USER 'u1'@'localhost'
IDENTIFIED WITH 'caching_sha2_password'
AS 0x244124303035240C7745603626313D613C4C10633E0A104B1E14135A544A7871567245614F4872344643546336546F624F6C7861326932752F45622F4F473273597557627139
REQUIRE NONE PASSWORD EXPIRE DEFAULT ACCOUNT UNLOCK
PASSWORD HISTORY DEFAULT PASSWORD REUSE INTERVAL DEFAULT
PASSWORD REQUIRE CURRENT DEFAULT
</pre><p>
        アカウントに付与されている権限を表示するには、<code class="literal">SHOW GRANTS</code> ステートメントを使用します。 <a class="xref" href="sql-statements.html#show-grants" title="13.7.7.21 SHOW GRANTS ステートメント">セクション13.7.7.21「SHOW GRANTS ステートメント」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-create-view"></a>13.7.7.13 SHOW CREATE VIEW ステートメント</h4></div></div></div><a class="indexterm" name="idm45826988087168"></a><pre class="programlisting">SHOW CREATE VIEW <em class="replaceable"><code>view_name</code></em>
</pre><p>
        このステートメントは、指定されたビューを作成する <code class="literal">CREATE VIEW</code> ステートメントを表示します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE VIEW v\G</code></strong>
*************************** 1. row ***************************
                View: v
         Create View: CREATE ALGORITHM=UNDEFINED
                      DEFINER=`bob`@`localhost`
                      SQL SECURITY DEFINER VIEW
                      `v` AS select 1 AS `a`,2 AS `b`
character_set_client: utf8mb4
collation_connection: utf8mb4_0900_ai_ci
</pre><p>
        <code class="literal">character_set_client</code> は、このビューが作成されたときの <code class="literal">character_set_client</code> システム変数のセッション値です。<code class="literal">collation_connection</code> は、このビューが作成されたときの <code class="literal">collation_connection</code> システム変数のセッション値です。
      </p><p>
        <code class="literal">SHOW CREATE VIEW</code> を使用するには、該当するビューに対する <code class="literal">SHOW VIEW</code> 権限および <code class="literal">SELECT</code> 権限が必要です。
      </p><p>
        ビュー情報は、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">VIEWS</code> テーブルからも参照できます。 <a class="xref" href="information-schema.html#information-schema-views-table" title="26.48 INFORMATION_SCHEMA VIEWS テーブル">セクション26.48「INFORMATION_SCHEMA VIEWS テーブル」</a>を参照してください。 
      </p><p>
        MySQL では、異なる <code class="literal">sql_mode</code> 設定を使用すると、サポートする SQL 構文のタイプをサーバーに指示できます。 たとえば、<code class="literal">ANSI</code> SQL モードを使用すると、クエリーで、MySQL で標準 SQL 連結演算子の二重バー (<code class="literal">||</code>) が正しく解釈されます。 その後、項目を連結するビューを作成した場合、<code class="literal">sql_mode</code> 設定を <code class="literal">ANSI</code> とは別の値に変更すると、そのビューが無効になるという懸念がある場合があります。 ただし、そのようなことはありません。 MySQL は、記述方法には関係なく、常にビュー定義を正規の形式で同じ方法で格納します。 サーバーが二重バーの連結演算子を <code class="literal">CONCAT()</code> 関数にどのように変更するかを示す例を次に示します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET sql_mode = 'ANSI';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE VIEW test.v AS SELECT 'a' || 'b' as col1;</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>SHOW CREATE VIEW test.v\G</code></strong>
*************************** 1. row ***************************
                View: v
         Create View: CREATE VIEW "v" AS select concat('a','b') AS "col1"
...
1 row in set (0.00 sec)
</pre><p>
        ビュー定義を正規の形式で格納する利点は、後で <code class="literal">sql_mode</code> の値を変更してもビューの結果に影響しないことです。 ただし、<code class="literal">SELECT</code> の前にあるコメントが、サーバーによって定義から取り除かれるというその他の影響があります。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-databases"></a>13.7.7.14 SHOW DATABASES ステートメント</h4></div></div></div><a class="indexterm" name="idm45826988052544"></a><a class="indexterm" name="idm45826988051040"></a><pre class="programlisting">SHOW {DATABASES | SCHEMAS}
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        <code class="literal">SHOW DATABASES</code> は、MySQL サーバーホスト上のデータベースを一覧表示します。 <code class="literal">SHOW SCHEMAS</code> は <code class="literal">SHOW DATABASES</code> のシノニムです。 <code class="literal">LIKE</code> 句 (存在する場合) は、どのデータベース名と照合するかを示します。 <a class="xref" href="information-schema.html#extended-show" title="26.55 SHOW ステートメントの拡張">セクション26.55「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。 
      </p><p>
        グローバルな <code class="literal">SHOW DATABASES</code> 権限を持っていないかぎり、何らかの種類の権限を持っているデータベースしか表示できません。 このリストはまた、<span class="command"><strong>mysqlshow</strong></span> コマンドを使用して取得することもできます。 
      </p><p>
        サーバーが <code class="option">--skip-show-database</code> オプションで起動された場合は、<code class="literal">SHOW DATABASES</code> 権限を持っていないかぎり、このステートメントをまったく使用できません。
      </p><p>
        MySQL はデータベースをデータディレクトリ内のディレクトリとして実装するため、このステートメントは単純に、その場所にあるディレクトリを一覧表示します。 ただし、実際のデータベースには対応しないディレクトリの名前が出力に含まれる可能性があります。 
      </p><p>
        データベース情報は、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">SCHEMATA</code> テーブルからも入手できます。 <a class="xref" href="information-schema.html#information-schema-schemata-table" title="26.31 INFORMATION_SCHEMA SCHEMATA テーブル">セクション26.31「INFORMATION_SCHEMA SCHEMATA テーブル」</a>を参照してください。 
      </p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注意</div><p>
          静的グローバル権限はすべてのデータベースに対する権限とみなされるため、静的グローバル権限を使用すると、ユーザーは、部分的な取消しによってデータベースレベルで制限されているデータベースを除き、<code class="literal">SHOW DATABASES</code> を使用するか、<code class="literal">INFORMATION_SCHEMA</code> の <code class="literal">SCHEMATA</code> テーブルを調べることで、すべてのデータベース名を表示できます。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-engine"></a>13.7.7.15 SHOW ENGINE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826988023120"></a><a class="indexterm" name="idm45826988021632"></a><pre class="programlisting">SHOW ENGINE <em class="replaceable"><code>engine_name</code></em> {STATUS | MUTEX}
</pre><p>
        <code class="literal">SHOW ENGINE</code> は、ストレージエンジンに関する動作情報を表示します。 これには <code class="literal">PROCESS</code> 権限が必要です。 このステートメントは、次のバリアントがあります。 
      </p><pre class="programlisting">SHOW ENGINE INNODB STATUS
SHOW ENGINE INNODB MUTEX
SHOW ENGINE PERFORMANCE_SCHEMA STATUS
</pre><p>
        <code class="literal">SHOW ENGINE INNODB STATUS</code> は、<code class="literal">InnoDB</code> ストレージエンジンの状態に関する <code class="literal">InnoDB</code> 標準モニターからの広範囲にわたる情報を表示します。 <code class="literal">InnoDB</code> の処理に関する情報を提供する標準モニターやその他の <code class="literal">InnoDB</code> モニターについては、<a class="xref" href="innodb-storage-engine.html#innodb-monitors" title="15.17 InnoDB モニター">セクション15.17「InnoDB モニター」</a>を参照してください。 
      </p><p>
        <code class="literal">SHOW ENGINE INNODB MUTEX</code> は、<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_mutex" title="相互排他ロック">相互排他ロック</a>および<a class="link" href="glossary.html#glos_rw_lock" title="rw ロック (読み書きロック)">読み書きロック</a>の統計を表示します。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">InnoDB</code> mutex および rwlocks は、<a class="link" href="performance-schema.html" title="第 27 章 MySQL パフォーマンススキーマ">Performance Schema</a> テーブルを使用してモニターすることもできます。 <a class="xref" href="innodb-storage-engine.html#monitor-innodb-mutex-waits-performance-schema" title="15.16.2 パフォーマンススキーマを使用した InnoDB Mutex 待機のモニタリング">セクション15.16.2「パフォーマンススキーマを使用した InnoDB Mutex 待機のモニタリング」</a>を参照してください。 
        </p></div><p>
        相互排他統計収集は、次のオプションを使用して動的に構成されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            mutex 統計の収集を有効にするには、次のコマンドを実行します:
          </p><pre class="programlisting">SET GLOBAL innodb_monitor_enable='latch';</pre></li><li class="listitem"><p>
            mutex 統計をリセットするには、次のコマンドを実行します:
          </p><pre class="programlisting">SET GLOBAL innodb_monitor_reset='latch';</pre></li><li class="listitem"><p>
            mutex 統計の収集を無効にするには、次のコマンドを実行します:
          </p><pre class="programlisting">SET GLOBAL innodb_monitor_disable='latch';</pre></li></ul></div><p>
        <code class="literal">SHOW ENGINE INNODB MUTEX</code> の mutex 統計の収集は、<code class="literal">innodb_monitor_enable='all'</code>を設定して有効にすることも、<code class="literal">innodb_monitor_disable='all'</code>を設定して無効にすることもできます。
      </p><p>
        <code class="literal">SHOW ENGINE INNODB MUTEX</code> 出力には、次のカラムがあります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Type</code>
          </p><p>
            常に <code class="literal">InnoDB</code> です。
          </p></li><li class="listitem"><p>
            <code class="literal">Name</code>
          </p><p>
            mutex の場合、<code class="literal">Name</code> フィールドには mutex 名のみがレポートされます。 rwlocks の場合、<code class="literal">Name</code> フィールドは rwlock が実装されているソースファイルと rwlock が作成されたファイル内の行番号を報告します。 この行番号は、使用している MySQL のバージョンに固有です。 
          </p></li><li class="listitem"><p>
            <code class="literal">Status</code>
          </p><p>
            相互排他ロックのステータス。 このフィールドには、スピン、待機、およびコールの数が報告されます。 <code class="literal">InnoDB</code> の外部で実装される低レベルのオペレーティングシステム相互排他ロックの統計はレポートされません。 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">spins</code> はスピンの数を示します。
              </p></li><li class="listitem"><p>
                <code class="literal">waits</code> は相互排他ロック待機の数を示します。
              </p></li><li class="listitem"><p>
                <code class="literal">calls</code> は、mutex がリクエストされた回数を示します。
              </p></li></ul></div></li></ul></div><p>
        バッファプールが大きいシステムでは出力量が過度に多いため、<code class="literal">SHOW ENGINE INNODB MUTEX</code> では各バッファプールブロックの mutex および rw ロックはリストされません。 ただし、<code class="literal">SHOW ENGINE INNODB MUTEX</code> はバッファープールブロック相互排他ロックおよび rw-lock の集約 <code class="literal">BUF_BLOCK_MUTEX</code> スピン、待機、および呼び出しの値を出力します。 <code class="literal">SHOW ENGINE INNODB MUTEX</code> はまた、待機されなかった (<code class="literal">os_waits=0</code>) 相互排他ロックまたは読み書きロックも一覧表示しません。 そのため、<code class="literal">SHOW ENGINE INNODB MUTEX</code> は、OS レベルの<a class="link" href="glossary.html#glos_wait" title="待機">待機</a>を少なくとも 1 回は発生させた、バッファープールの外部の相互排他ロックと読み書きロックに関する情報のみを表示します。 
      </p><p>
        <code class="literal">SHOW ENGINE PERFORMANCE_SCHEMA STATUS</code> を使用して、パフォーマンススキーマコードの内部操作を検査します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW ENGINE PERFORMANCE_SCHEMA STATUS\G</code></strong>
...
*************************** 3. row ***************************
  Type: performance_schema
  Name: events_waits_history.size
Status: 76
*************************** 4. row ***************************
  Type: performance_schema
  Name: events_waits_history.count
Status: 10000
*************************** 5. row ***************************
  Type: performance_schema
  Name: events_waits_history.memory
Status: 760000
...
*************************** 57. row ***************************
  Type: performance_schema
  Name: performance_schema.memory
Status: 26459600
...
</pre><p>
        このステートメントは、さまざまなパフォーマンススキーマオプションがメモリー要件に与える効果について、DBA が理解できるようにすることを目的としています。
      </p><p>
        <code class="literal">Name</code> 値は、それぞれ、内部バッファーとバッファー属性を指定する 2 つの部分で構成されます。 バッファー名は、次のように解釈します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブルとして公開されていない内部バッファーは括弧内に指定されます。 例: <code class="literal">(pfs_cond_class).size</code>、<code class="literal">(pfs_mutex_class).memory</code>。 
          </p></li><li class="listitem"><p>
            <code class="literal">performance_schema</code> データベース内のテーブルとして公開されている内部バッファーは、そのテーブル名で (括弧なしで) 指定されます。 例: <code class="literal">events_waits_history.size</code>、<code class="literal">mutex_instances.count</code>。 
          </p></li><li class="listitem"><p>
            全体としてのパフォーマンススキーマに適用される値は、<code class="literal">performance_schema</code> で始まります。 例: <code class="literal">performance_schema.memory</code>。 
          </p></li></ul></div><p>
        バッファー属性には、次の意味があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">size</code> は、テーブル内の行のサイズなど、実装で使用される内部レコードのサイズです。<code class="literal">size</code> の値は変更できません。
          </p></li><li class="listitem"><p>
            <code class="literal">count</code> は、テーブルの行数などの内部レコードの数です。<code class="literal">count</code> の値は、パフォーマンススキーマの構成オプションを使用して変更できます。
          </p></li><li class="listitem"><p>
            テーブルの場合、<code class="literal"><em class="replaceable"><code>tbl_name</code></em>.memory</code> は <code class="literal">size</code> および <code class="literal">count</code> の製品です。 全体としてのパフォーマンススキーマの場合、<code class="literal">performance_schema.memory</code> は、使用されているすべてのメモリーの合計 (ほかのすべての <code class="literal">memory</code> 値の合計) です。 
          </p></li></ul></div><p>
        場合によっては、パフォーマンススキーマの構成パラメータと <code class="literal">SHOW ENGINE</code> 値の間に直接の関係が存在します。 たとえば、<code class="literal">events_waits_history_long.count</code> は <code class="literal">performance_schema_events_waits_history_long_size</code> に対応します。 その他の場合、この関係はより複雑です。 たとえば、<code class="literal">events_waits_history.count</code> は、<code class="literal">performance_schema_events_waits_history_size</code> (スレッド当たりの行数) に <code class="literal">performance_schema_max_thread_instances</code> (スレッド数) を掛けた値に対応します。 
      </p><p><a name="show-engine-ndb-status"></a><b>SHOW ENGINE NDB STATUS. </b>
          サーバーで <code class="literal">NDB</code> ストレージエンジンが有効になっている場合、<code class="literal">SHOW ENGINE NDB STATUS</code> は、接続されているデータノードの数、クラスタの接続文字列、クラスタバイナリログのエポックや、クラスタに接続したときに MySQL Server によって作成されたさまざまなクラスタ API オブジェクトの数などのクラスタステータス情報を表示します。 このステートメントからのサンプル出力を次に示します。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW ENGINE NDB STATUS;</code></strong>
+------------+-----------------------+--------------------------------------------------+
| Type       | Name                  | Status                                           |
+------------+-----------------------+--------------------------------------------------+
| ndbcluster | connection            | cluster_node_id=7,
  connected_host=198.51.100.103, connected_port=1186, number_of_data_nodes=4,
  number_of_ready_data_nodes=3, connect_count=0                                         |
| ndbcluster | NdbTransaction        | created=6, free=0, sizeof=212                    |
| ndbcluster | NdbOperation          | created=8, free=8, sizeof=660                    |
| ndbcluster | NdbIndexScanOperation | created=1, free=1, sizeof=744                    |
| ndbcluster | NdbIndexOperation     | created=0, free=0, sizeof=664                    |
| ndbcluster | NdbRecAttr            | created=1285, free=1285, sizeof=60               |
| ndbcluster | NdbApiSignal          | created=16, free=16, sizeof=136                  |
| ndbcluster | NdbLabel              | created=0, free=0, sizeof=196                    |
| ndbcluster | NdbBranch             | created=0, free=0, sizeof=24                     |
| ndbcluster | NdbSubroutine         | created=0, free=0, sizeof=68                     |
| ndbcluster | NdbCall               | created=0, free=0, sizeof=16                     |
| ndbcluster | NdbBlob               | created=1, free=1, sizeof=264                    |
| ndbcluster | NdbReceiver           | created=4, free=0, sizeof=68                     |
| ndbcluster | binlog                | latest_epoch=155467, latest_trans_epoch=148126,
  latest_received_binlog_epoch=0, latest_handled_binlog_epoch=0,
  latest_applied_binlog_epoch=0                                                         |
+------------+-----------------------+--------------------------------------------------+
</pre><p>
        これらの各行の <code class="literal">Status</code> カラムには、クラスタへの MySQL サーバー接続とクラスタバイナリログステータスに関する情報がそれぞれ表示されます。 <code class="literal">Status</code> 情報は、カンマで区切られた一連の名前と値のペアの形式をしています。 
      </p><p>
        <code class="literal">connection</code> の行の <code class="literal">Status</code> カラムには、次のテーブルで説明する名前と値のペアが含まれます。
      </p><div class="informaltable"><table summary="Name and value pairs found in the connection row Status column in the output of the SHOW ENGINE NDB STATUS statement."><col style="width: 40%"><col style="width: 60%"><thead><tr>
            <th>名前</th>
            <th>値</th>
          </tr></thead><tbody><tr>
            <td><code class="literal">cluster_node_id</code></td>
            <td>クラスタ内の MySQL サーバーのノード ID</td>
          </tr><tr>
            <td><code class="literal">connected_host</code></td>
            <td>MySQL サーバーが接続されているクラスタ管理サーバーのホスト名または IP アドレス</td>
          </tr><tr>
            <td><code class="literal">connected_port</code></td>
            <td>MySQL サーバーが管理サーバー (<code class="literal">connected_host</code>) に接続するために使用するポート</td>
          </tr><tr>
            <td><code class="literal">number_of_data_nodes</code></td>
            <td>クラスタのために構成されているデータノードの数 (つまり、そのクラスタの <code class="filename">config.ini</code> ファイル内の <code class="literal">[ndbd]</code> セクションの数)</td>
          </tr><tr>
            <td><code class="literal">number_of_ready_data_nodes</code></td>
            <td>実際に実行されているクラスタ内のデータノードの数</td>
          </tr><tr>
            <td><code class="literal">connect_count</code></td>
            <td>この <span class="command"><strong>mysqld</strong></span> がクラスタデータノードに接続または再接続した回数</td>
          </tr></tbody></table></div><p>
        <code class="literal">binlog</code> 行の <code class="literal">Status</code> カラムには、NDB Cluster レプリケーションに関する情報が含まれています。 そこに含まれている名前と値のペアについて、次の表で説明します。 
      </p><div class="informaltable"><table summary="Name and value pairs found in the binlog row Status column in the output of the SHOW ENGINE NDB STATUS statement."><col style="width: 40%"><col style="width: 60%"><thead><tr>
            <th>名前</th>
            <th>値</th>
          </tr></thead><tbody><tr>
            <td><code class="literal">latest_epoch</code></td>
            <td>この MySQL サーバー上で直近で実行された最新のエポック (つまり、このサーバー上で実行された最新のトランザクションのシーケンス番号)</td>
          </tr><tr>
            <td><code class="literal">latest_trans_epoch</code></td>
            <td>クラスタのデータノードによって処理された最新のエポック</td>
          </tr><tr>
            <td><code class="literal">latest_received_binlog_epoch</code></td>
            <td>バイナリログスレッドによって受信された最新のエポック</td>
          </tr><tr>
            <td><code class="literal">latest_handled_binlog_epoch</code></td>
            <td>(バイナリログへの書き込みのために) バイナリログスレッドによって処理された最新のエポック</td>
          </tr><tr>
            <td><code class="literal">latest_applied_binlog_epoch</code></td>
            <td>実際にバイナリログに書き込まれた最新のエポック</td>
          </tr></tbody></table></div><p>
        詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-replication" title="23.6 NDB Cluster レプリケーション">セクション23.6「NDB Cluster レプリケーション」</a>を参照してください。
      </p><p>
        クラスタのモニタリングにもっとも役立つ可能性のある <code class="literal">SHOW ENGINE NDB STATUS</code> の出力の残りの行を、次に <code class="literal">Name</code> で一覧表示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">NdbTransaction</code>: 作成された <code class="literal">NdbTransaction</code> オブジェクトの数とサイズ。 <code class="literal">NdbTransaction</code> は、<code class="literal">NDB</code> テーブル上で (<code class="literal">CREATE TABLE</code> や <code class="literal">ALTER TABLE</code> などの) テーブルスキーマ操作が実行されるたびに作成されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">NdbOperation</code>: 作成された <code class="literal">NdbOperation</code> オブジェクトの数とサイズ。
          </p></li><li class="listitem"><p>
            <code class="literal">NdbIndexScanOperation</code>: 作成された <code class="literal">NdbIndexScanOperation</code> オブジェクトの数とサイズ。
          </p></li><li class="listitem"><p>
            <code class="literal">NdbIndexOperation</code>: 作成された <code class="literal">NdbIndexOperation</code> オブジェクトの数とサイズ。
          </p></li><li class="listitem"><p>
            <code class="literal">NdbRecAttr</code>: 作成された <code class="literal">NdbRecAttr</code> オブジェクトの数とサイズ。 一般に、これらのいずれかは、SQL ノードによってデータ操作ステートメントが実行されるたびに作成されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">NdbBlob</code>: 作成された <code class="literal">NdbBlob</code> オブジェクトの数とサイズ。 <code class="literal">NdbBlob</code> は、<code class="literal">NDB</code> テーブル内の <code class="literal">BLOB</code> カラムに関連する新しい操作が実行されるたびに作成されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">NdbReceiver</code>: 作成されたすべての <code class="literal">NdbReceiver</code> オブジェクトの数とサイズ。 <code class="literal">created</code> カラム内の数は、MySQL サーバーが接続されているクラスタ内のデータノードの数と同じです。 
          </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          現在のセッション中に、このステートメントが実行されている SQL ノードにアクセスしている MySQL クライアントによって <code class="literal">NDB</code> テーブルに関連する操作が実行されていない場合、<code class="literal">SHOW ENGINE NDB STATUS</code> は空の結果を返します。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-engines"></a>13.7.7.16 SHOW ENGINES ステートメント</h4></div></div></div><a class="indexterm" name="idm45826987842192"></a><a class="indexterm" name="idm45826987840704"></a><pre class="programlisting">SHOW [STORAGE] ENGINES
</pre><p>
        <code class="literal">SHOW ENGINES</code> は、サーバーのストレージエンジンに関するステータス情報を表示します。 これは、ストレージエンジンがサポートされているかどうかをチェックしたり、デフォルトのエンジンが何であるかを確認したりするために特に役立ちます。 
      </p><p>
        MySQL ストレージエンジンについては、<a class="xref" href="innodb-storage-engine.html" title="第 15 章 InnoDB ストレージエンジン">第15章「<i>InnoDB ストレージエンジン</i>」</a> および <a class="xref" href="storage-engines.html" title="第 16 章 代替ストレージエンジン">第16章「<i>代替ストレージエンジン</i>」</a> を参照してください。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW ENGINES\G</code></strong>
*************************** 1. row ***************************
      Engine: ARCHIVE
     Support: YES
     Comment: Archive storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 2. row ***************************
      Engine: BLACKHOLE
     Support: YES
     Comment: /dev/null storage engine (anything you write to it disappears)
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 3. row ***************************
      Engine: MRG_MYISAM
     Support: YES
     Comment: Collection of identical MyISAM tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 4. row ***************************
      Engine: FEDERATED
     Support: NO
     Comment: Federated MySQL storage engine
Transactions: NULL
          XA: NULL
  Savepoints: NULL
*************************** 5. row ***************************
      Engine: MyISAM
     Support: YES
     Comment: MyISAM storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 6. row ***************************
      Engine: PERFORMANCE_SCHEMA
     Support: YES
     Comment: Performance Schema
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 7. row ***************************
      Engine: InnoDB
     Support: DEFAULT
     Comment: Supports transactions, row-level locking, and foreign keys
Transactions: YES
          XA: YES
  Savepoints: YES
*************************** 8. row ***************************
      Engine: MEMORY
     Support: YES
     Comment: Hash based, stored in memory, useful for temporary tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 9. row ***************************
      Engine: CSV
     Support: YES
     Comment: CSV storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
</pre><p>
        <code class="literal">SHOW ENGINES</code> からの出力は、使用されている MySQL バージョンやその他の要因によって異なる可能性があります。
      </p><p>
        <code class="literal">SHOW ENGINES</code> 出力には、次のカラムがあります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Engine</code>
          </p><p>
            ストレージエンジンの名前。
          </p></li><li class="listitem"><p>
            <code class="literal">Support</code>
          </p><p>
            次のテーブルに示すストレージエンジンのサーバーレベルのサポート。
          </p><div class="informaltable"><table summary="Values for the Support column in the output of the SHOW ENGINES statement."><col style="width: 15%"><col style="width: 85%"><thead><tr>
                <th>値</th>
                <th>意味</th>
              </tr></thead><tbody><tr>
                <td><code class="literal">行う</code></td>
                <td>このエンジンはサポートされており、アクティブです</td>
              </tr><tr>
                <td><code class="literal">DEFAULT</code></td>
                <td><code class="literal">YES</code> と同様であることに加え、これがデフォルトのエンジンです</td>
              </tr><tr>
                <td><code class="literal">NO</code></td>
                <td>このエンジンはサポートされていません</td>
              </tr><tr>
                <td><code class="literal">DISABLED</code></td>
                <td>このエンジンはサポートされていますが、無効になっています</td>
              </tr></tbody></table></div><p>
            <code class="literal">NO</code> の値は、サーバーがこのエンジンに対するサポートなしでコンパイルされたことを示すため、実行時にこのエンジンを有効にすることはできません。
          </p><p>
            <code class="literal">DISABLED</code> の値は、サーバーがこのエンジンを無効にするオプションを使用して起動されたか、またはこのエンジンを有効にするために必要な一部のオプションが指定されなかったために発生します。 後者の場合、エラーログにはオプションが無効になっている理由が含まれている必要があります。 <a class="xref" href="server-administration.html#error-log" title="5.4.2 エラーログ">セクション5.4.2「エラーログ」</a> を参照してください。 
          </p><p>
            ストレージエンジンに対する <code class="literal">DISABLED</code> はまた、サーバーがそれをサポートするようにコンパイルされたが、<code class="option">--skip-<em class="replaceable"><code>engine_name</code></em></code> オプションで起動された場合にも表示される可能性があります。 <code class="literal">NDB</code> ストレージエンジンの場合、<code class="literal">DISABLED</code> はサーバーが NDB Cluster をサポートしてコンパイルされたが、<code class="option">--ndbcluster</code> オプションで起動されなかったことを意味します。 
          </p><p>
            すべての MySQL サーバーで <code class="literal">MyISAM</code> テーブルがサポートされます。 <code class="literal">MyISAM</code> を無効にすることはできません。 
          </p></li><li class="listitem"><p>
            <code class="literal">Comment</code>
          </p><p>
            ストレージエンジンの簡単な説明。
          </p></li><li class="listitem"><p>
            <code class="literal">トランザクション</code>
          </p><p>
            ストレージエンジンがトランザクションをサポートするかどうか。
          </p></li><li class="listitem"><p>
            <code class="literal">XA</code>
          </p><p>
            ストレージエンジンが XA トランザクションをサポートするかどうか。
          </p></li><li class="listitem"><p>
            <code class="literal">Savepoints</code>
          </p><p>
            ストレージエンジンがセーブポイントをサポートするかどうか。
          </p></li></ul></div><p>
        ストレージエンジンの情報は、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">ENGINES</code> テーブルからも入手できます。 <a class="xref" href="information-schema.html#information-schema-engines-table" title="26.13 INFORMATION_SCHEMA ENGINES テーブル">セクション26.13「INFORMATION_SCHEMA ENGINES テーブル」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-errors"></a>13.7.7.17 SHOW ERRORS ステートメント</h4></div></div></div><a class="indexterm" name="idm45826987780160"></a><a class="indexterm" name="idm45826987778672"></a><pre class="programlisting">SHOW ERRORS [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]
SHOW COUNT(*) ERRORS
</pre><p>
        <code class="literal">SHOW ERRORS</code> は <code class="literal">SHOW WARNINGS</code> に似た診断ステートメントですが、エラー、警告、および注意ではなく、エラーに関する情報のみを表示する点が異なります。
      </p><p>
        <code class="literal">LIMIT</code> 句の構文は、<code class="literal">SELECT</code> ステートメントの場合と同じです。 <a class="xref" href="sql-statements.html#select" title="13.2.10 SELECT ステートメント">セクション13.2.10「SELECT ステートメント」</a>を参照してください。 
      </p><p>
        <code class="literal">SHOW COUNT(*) ERRORS</code> ステートメントは、エラーの数を表示します。 この数はまた、<code class="literal">error_count</code> 変数からも取得できます。 
      </p><pre class="programlisting">SHOW COUNT(*) ERRORS;
SELECT @@error_count;
</pre><p>
        <code class="literal">SHOW ERRORS</code> および <code class="literal">error_count</code> は、警告や注意ではなく、エラーにのみ適用されます。 その他の点では、<code class="literal">SHOW WARNINGS</code> および <code class="literal">warning_count</code> と同様です。 特に、<code class="literal">SHOW ERRORS</code> が <code class="literal">max_error_count</code> 個を超えるメッセージに関する情報を表示できないのに対して、<code class="literal">error_count</code> は、エラーの数が <code class="literal">max_error_count</code> を超えた場合は <code class="literal">max_error_count</code> の値を超えることができます。 
      </p><p>
        詳細は、<a class="xref" href="sql-statements.html#show-warnings" title="13.7.7.42 SHOW WARNINGS ステートメント">セクション13.7.7.42「SHOW WARNINGS ステートメント」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-events"></a>13.7.7.18 SHOW EVENTS ステートメント</h4></div></div></div><a class="indexterm" name="idm45826987751360"></a><pre class="programlisting">SHOW EVENTS
    [{FROM | IN} <em class="replaceable"><code>schema_name</code></em>]
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        このステートメントは、<a class="xref" href="stored-objects.html#event-scheduler" title="25.4 イベントスケジューラの使用">セクション25.4「イベントスケジューラの使用」</a> で説明されているイベントマネージャイベントに関する情報を表示します。 これには、これらのイベントが示される元のデータベースに対する <code class="literal">EVENT</code> 権限が必要です。 
      </p><p>
        <code class="literal">SHOW EVENTS</code> は、そのもっとも単純な形式では、現在のスキーマ内のすべてのイベントを一覧表示します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT CURRENT_USER(), SCHEMA();</code></strong>
+----------------+----------+
| CURRENT_USER() | SCHEMA() |
+----------------+----------+
| jon@ghidora    | myschema |
+----------------+----------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW EVENTS\G</code></strong>
*************************** 1. row ***************************
                  Db: myschema
                Name: e_daily
             Definer: jon@ghidora
           Time zone: SYSTEM
                Type: RECURRING
          Execute at: NULL
      Interval value: 1
      Interval field: DAY
              Starts: 2018-08-08 11:06:34
                Ends: NULL
              Status: ENABLED
          Originator: 1
character_set_client: utf8mb4
collation_connection: utf8mb4_0900_ai_ci
  Database Collation: utf8mb4_0900_ai_ci
</pre><p>
        特定のスキーマのイベントを表示するには、<code class="literal">FROM</code> 句を使用します。 たとえば、<code class="literal">test</code> スキーマのイベントを表示するには、次のステートメントを使用します。 
      </p><pre class="programlisting">SHOW EVENTS FROM test;
</pre><p>
        <code class="literal">LIKE</code> 句 (存在する場合) は、どのイベント名と照合するかを示します。 <a class="xref" href="information-schema.html#extended-show" title="26.55 SHOW ステートメントの拡張">セクション26.55「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。 
      </p><p>
        <code class="literal">SHOW EVENTS</code> 出力には、次のカラムがあります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Db</code>
          </p><p>
            イベントが属するスキーマ (データベース) の名前。
          </p></li><li class="listitem"><p>
            <code class="literal">Name</code>
          </p><p>
            イベントの名前。
          </p></li><li class="listitem"><p>
            <code class="literal">Definer</code>
          </p><p>
            イベントを作成したユーザーのアカウント (<code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'<em class="replaceable"><code>host_name</code></em>'</code>形式)。
          </p></li><li class="listitem"><p>
            <code class="literal">Time zone</code>
          </p><p>
            イベントのタイムゾーン。イベントのスケジュールに使用され、イベントの実行時にイベント内で有効なタイムゾーンです。 デフォルト値は <code class="literal">SYSTEM</code> です。 
          </p></li><li class="listitem"><p>
            <code class="literal">Type</code>
          </p><p>
            イベントの繰返しタイプ。<code class="literal">ONE TIME</code> (一時) または <code class="literal">RECURRING</code> (繰返し)。
          </p></li><li class="listitem"><p>
            <code class="literal">Execute At</code>
          </p><p>
            ワンタイムイベントの場合、これは、イベントの作成に使用される <code class="literal">CREATE EVENT</code> ステートメントの <code class="literal">AT</code> 句、またはイベントを変更した最後の <code class="literal">ALTER EVENT</code> ステートメントで指定された <code class="literal">DATETIME</code> 値です。 このカラムに表示された値は、イベントの <code class="literal">AT</code> 句に含まれた、<code class="literal">INTERVAL</code> 値の加算または減算に影響します。 たとえば、イベントが <code class="literal">ON SCHEDULE AT CURRENT_TIMESTAMP + '1:6' DAY_HOUR</code> を使用して作成され、イベントが 2018-02-09 の 14:05:30 に作成された場合、カラムに表示される値は <code class="literal">'2018-02-10 20:05:30'</code> になります。 イベントのタイミングが <code class="literal">AT</code> 句ではなく <code class="literal">EVERY</code> 句で決定される場合 (つまり、イベントが繰り返しである場合)、このカラムの値は <code class="literal">NULL</code> になります。 
          </p></li><li class="listitem"><p>
            <code class="literal">Interval Value</code>
          </p><p>
            繰返しイベントの場合、イベント実行間で待機する間隔の数。 一時的なイベントの場合、このカラムの値は常に <code class="literal">NULL</code> です。 
          </p></li><li class="listitem"><p>
            <code class="literal">Interval Field</code>
          </p><p>
            繰返しイベントが繰り返される前に待機する間隔に使用される時間単位。 一時的なイベントの場合、このカラムの値は常に <code class="literal">NULL</code> です。 
          </p></li><li class="listitem"><p>
            <code class="literal">Starts</code>
          </p><p>
            繰返しイベントの開始日時。 これは <code class="literal">DATETIME</code> 値として表示され、このイベントの開始日付と開始時間が定義されていない場合は <code class="literal">NULL</code> です。 一時的なイベントの場合、このカラムは常に <code class="literal">NULL</code> です。 定義に <code class="literal">STARTS</code> 句が含まれる繰返しイベントの場合、このカラムには対応する <code class="literal">DATETIME</code> 値が含まれます。 <code class="literal">Execute At</code> カラムと同様に、この値は使用される式を解決します。 イベントのタイミングに影響する <code class="literal">STARTS</code> 句がない場合、このカラムは <code class="literal">NULL</code> です 
          </p></li><li class="listitem"><p>
            <code class="literal">Ends</code>
          </p><p>
            定義に <code class="literal">ENDS</code> 句が含まれる繰返しイベントの場合、このカラムには対応する <code class="literal">DATETIME</code> 値が含まれます。 <code class="literal">Execute At</code> カラムと同様に、この値は使用される式を解決します。 イベントのタイミングに影響する <code class="literal">ENDS</code> 句がない場合、このカラムは <code class="literal">NULL</code> です。 
          </p></li><li class="listitem"><p>
            <code class="literal">Status</code>
          </p><p>
            イベントステータス。 <code class="literal">ENABLED</code>、<code class="literal">DISABLED</code>、<code class="literal">SLAVESIDE_DISABLED</code> のいずれか。 <code class="literal">SLAVESIDE_DISABLED</code> は、イベントの作成が、レプリケーションソースとして機能する別の MySQL サーバーで発生し、レプリカとして機能している現在の MySQL サーバーにレプリケートされたが、そのイベントがレプリカで現在実行されていないことを示します。 詳細は、<a class="xref" href="replication.html#replication-features-invoked" title="17.5.1.16 呼び出される機能のレプリケーション">セクション17.5.1.16「呼び出される機能のレプリケーション」</a> の情報を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">Originator</code>
          </p><p>
            イベントが作成された MySQL サーバーのサーバー ID。レプリケーションで使用されます。 この値は、ソースサーバーで実行された場合、<code class="literal">ALTER EVENT</code> によって、そのステートメントが発生したサーバーのサーバー ID に更新されることがあります。 デフォルト値は 0 です。 
          </p></li><li class="listitem"><p>
            <code class="literal">character_set_client</code>
          </p><p>
            イベント作成時の <code class="literal">character_set_client</code> システム変数のセッション値。
          </p></li><li class="listitem"><p>
            <code class="literal">collation_connection</code>
          </p><p>
            イベント作成時の <code class="literal">collation_connection</code> システム変数のセッション値。
          </p></li><li class="listitem"><p>
            <code class="literal">Database Collation</code>
          </p><p>
            イベントが関連付けられているデータベースの照合。
          </p></li></ul></div><p>
        <code class="literal">SLAVESIDE_DISABLED</code> および <code class="literal">Originator</code> カラムの詳細は、<a class="xref" href="replication.html#replication-features-invoked" title="17.5.1.16 呼び出される機能のレプリケーション">セクション17.5.1.16「呼び出される機能のレプリケーション」</a> を参照してください。
      </p><p>
        <code class="literal">SHOW EVENTS</code> によって表示される時間は、<a class="xref" href="stored-objects.html#events-metadata" title="25.4.4 イベントメタデータ">セクション25.4.4「イベントメタデータ」</a>で説明されているように、このイベントのタイムゾーンで示されます。
      </p><p>
        イベント情報は、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">EVENTS</code> テーブルからも入手できます。 <a class="xref" href="information-schema.html#information-schema-events-table" title="26.14 INFORMATION_SCHEMA EVENTS テーブル">セクション26.14「INFORMATION_SCHEMA EVENTS テーブル」</a>を参照してください。 
      </p><p>
        イベントのアクションステートメントは、<code class="literal">SHOW EVENTS</code> の出力には表示されません。 <code class="literal">SHOW CREATE EVENT</code> または <code class="literal">INFORMATION_SCHEMA</code> <code class="literal">EVENTS</code> テーブルを使用します。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-function-code"></a>13.7.7.19 SHOW FUNCTION CODE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826987650848"></a><pre class="programlisting">SHOW FUNCTION CODE <em class="replaceable"><code>func_name</code></em>
</pre><p>
        このステートメントは、ストアドファンクションである点を除き、<code class="literal">SHOW PROCEDURE CODE</code> と同じです。 <a class="xref" href="sql-statements.html#show-procedure-code" title="13.7.7.27 SHOW PROCEDURE CODE ステートメント">セクション13.7.7.27「SHOW PROCEDURE CODE ステートメント」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-function-status"></a>13.7.7.20 SHOW FUNCTION STATUS ステートメント</h4></div></div></div><a class="indexterm" name="idm45826987641424"></a><pre class="programlisting">SHOW FUNCTION STATUS
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        このステートメントは、ストアドファンクションである点を除き、<code class="literal">SHOW PROCEDURE STATUS</code> と同じです。 <a class="xref" href="sql-statements.html#show-procedure-status" title="13.7.7.28 SHOW PROCEDURE STATUS ステートメント">セクション13.7.7.28「SHOW PROCEDURE STATUS ステートメント」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-grants"></a>13.7.7.21 SHOW GRANTS ステートメント</h4></div></div></div><a class="indexterm" name="idm45826987631600"></a><a class="indexterm" name="idm45826987629856"></a><a class="indexterm" name="idm45826987628080"></a><pre class="programlisting">SHOW GRANTS
    [FOR <em class="replaceable"><code>user_or_role</code></em>
        [USING <em class="replaceable"><code>role</code></em> [, <em class="replaceable"><code>role</code></em>] ...]]

<em class="replaceable"><code>user_or_role</code></em>: {
    <em class="replaceable"><code>user</code></em> (see <a class="xref" href="security.html#account-names" title="6.2.4 アカウント名の指定">セクション6.2.4「アカウント名の指定」</a>)
  | <em class="replaceable"><code>role</code></em> (see <a class="xref" href="security.html#role-names" title="6.2.5 ロール名の指定">セクション6.2.5「ロール名の指定」</a>.
}
</pre><p>
        このステートメントは、MySQL ユーザーアカウントまたはロールに割り当てられている権限およびロールを、権限およびロールの割当てを複製するために実行する必要がある <code class="literal">GRANT</code> ステートメントの形式で表示します。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL アカウントの非権限情報を表示するには、<code class="literal">SHOW CREATE USER</code> ステートメントを使用します。 <a class="xref" href="sql-statements.html#show-create-user" title="13.7.7.12 SHOW CREATE USER ステートメント">セクション13.7.7.12「SHOW CREATE USER ステートメント」</a>を参照してください。 
        </p></div><p>
        <code class="literal">SHOW GRANTS</code> には、<code class="literal">mysql</code> システムスキーマに対する <code class="literal">SELECT</code> 権限が必要ですが、現行ユーザーの権限およびロールは表示されません。
      </p><p>
        <code class="literal">SHOW GRANTS</code> のアカウントまたはロールに名前を付けるには、<code class="literal">GRANT</code> ステートメントと同じ形式 (<code class="literal">'jeffrey'@'localhost'</code>など) を使用します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW GRANTS FOR 'jeffrey'@'localhost';</code></strong>
+------------------------------------------------------------------+
| Grants for jeffrey@localhost                                     |
+------------------------------------------------------------------+
| GRANT USAGE ON *.* TO `jeffrey`@`localhost`                      |
| GRANT SELECT, INSERT, UPDATE ON `db1`.* TO `jeffrey`@`localhost` |
+------------------------------------------------------------------+
</pre><p>
        ホスト部分を省略すると、デフォルトで<code class="literal">'%'</code>に設定されます。 アカウント名およびロール名の指定の詳細は、<a class="xref" href="security.html#account-names" title="6.2.4 アカウント名の指定">セクション6.2.4「アカウント名の指定」</a> および <a class="xref" href="security.html#role-names" title="6.2.5 ロール名の指定">セクション6.2.5「ロール名の指定」</a> を参照してください。 
      </p><p>
        現在のユーザー (サーバーへの接続に使用しているアカウント) に付与されている権限を表示するには、次のいずれかのステートメントを使用できます:
      </p><pre class="programlisting">SHOW GRANTS;
SHOW GRANTS FOR CURRENT_USER;
SHOW GRANTS FOR CURRENT_USER();
</pre><a class="indexterm" name="idm45826987601408"></a><a class="indexterm" name="idm45826987599632"></a><a class="indexterm" name="idm45826987598160"></a><a class="indexterm" name="idm45826987596496"></a><p>
        実行者権限ではなく定義者権限で実行されるストアドプロシージャ内など、定義者コンテキストで <code class="literal">SHOW GRANTS FOR CURRENT_USER</code> (または同等の構文) が使用されている場合、表示される権限は実行者ではなく定義者の権限付与です。
      </p><p>
        以前のシリーズと比較した MySQL 8.0 では、<code class="literal">SHOW GRANTS</code> のグローバル権限出力に <code class="literal">ALL PRIVILEGES</code> が表示されなくなりました。これは、グローバルレベルの <code class="literal">ALL PRIVILEGES</code> の意味が、定義されている動的権限によって異なるためです。 かわりに、<code class="literal">SHOW GRANTS</code> では、付与されている各グローバル権限が明示的にリストされます: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW GRANTS FOR 'root'@'localhost';</code></strong>
+---------------------------------------------------------------------+
| Grants for root@localhost                                           |
+---------------------------------------------------------------------+
| GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, RELOAD,         |
| SHUTDOWN, PROCESS, FILE, REFERENCES, INDEX, ALTER, SHOW DATABASES,  |
| SUPER, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, REPLICATION   |
| SLAVE, REPLICATION CLIENT, CREATE VIEW, SHOW VIEW, CREATE ROUTINE,  |
| ALTER ROUTINE, CREATE USER, EVENT, TRIGGER, CREATE TABLESPACE,      |
| CREATE ROLE, DROP ROLE ON *.* TO `root`@`localhost` WITH GRANT      |
| OPTION                                                              |
| GRANT PROXY ON ''@'' TO 'root'@'localhost' WITH GRANT OPTION        |
+---------------------------------------------------------------------+
</pre><p>
        <code class="literal">SHOW GRANTS</code> 出力を処理するアプリケーションは、それに応じて調整する必要があります。
      </p><p>
        グローバルレベルでは、<code class="literal">GRANT OPTION</code> は付与されているすべての静的グローバル権限に適用されますが (いずれかに付与されている場合)、付与されている動的権限に個別に適用されます。 <code class="literal">SHOW GRANTS</code> では、グローバル権限は次のように表示されます: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            付与されているすべての静的権限 (存在する場合) をリストする行 (該当する場合は <code class="literal">WITH GRANT OPTION</code> を含む)。
          </p></li><li class="listitem"><p>
            <code class="literal">GRANT OPTION</code> が付与されているすべての付与された動的権限 (<code class="literal">WITH GRANT OPTION</code> を含む) がリストされた行。
          </p></li><li class="listitem"><p>
            <code class="literal">GRANT OPTION</code> が付与されていない、付与されているすべての動的権限が <code class="literal">WITH GRANT OPTION</code> なしでリストされた行。
          </p></li></ul></div><p>
        オプションの <code class="literal">USING</code> 句を使用すると、<code class="literal">SHOW GRANTS</code> でユーザーのロールに関連付けられている権限を調べることができます。 <code class="literal">USING</code> 句で指定された各ロールをユーザーに付与する必要があります。 
      </p><p>
        次のように、ユーザー <code class="literal">u1</code> に <code class="literal">r1</code> および <code class="literal">r2</code> のロールが割り当てられているとします:
      </p><pre class="programlisting">CREATE ROLE 'r1', 'r2';
GRANT SELECT ON db1.* TO 'r1';
GRANT INSERT, UPDATE, DELETE ON db1.* TO 'r2';
CREATE USER 'u1'@'localhost' IDENTIFIED BY 'u1pass';
GRANT 'r1', 'r2' TO 'u1'@'localhost';
</pre><p>
        <code class="literal">USING</code> を使用しない <code class="literal">SHOW GRANTS</code> には、付与されたロールが表示されます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW GRANTS FOR 'u1'@'localhost';</code></strong>
+---------------------------------------------+
| Grants for u1@localhost                     |
+---------------------------------------------+
| GRANT USAGE ON *.* TO `u1`@`localhost`      |
| GRANT `r1`@`%`,`r2`@`%` TO `u1`@`localhost` |
+---------------------------------------------+
</pre><p>
        <code class="literal">USING</code> 句を追加すると、その句で指定された各ロールに関連付けられた権限もステートメントに表示されます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW GRANTS FOR 'u1'@'localhost' USING 'r1';</code></strong>
+---------------------------------------------+
| Grants for u1@localhost                     |
+---------------------------------------------+
| GRANT USAGE ON *.* TO `u1`@`localhost`      |
| GRANT SELECT ON `db1`.* TO `u1`@`localhost` |
| GRANT `r1`@`%`,`r2`@`%` TO `u1`@`localhost` |
+---------------------------------------------+
mysql&gt; <strong class="userinput"><code>SHOW GRANTS FOR 'u1'@'localhost' USING 'r2';</code></strong>
+-------------------------------------------------------------+
| Grants for u1@localhost                                     |
+-------------------------------------------------------------+
| GRANT USAGE ON *.* TO `u1`@`localhost`                      |
| GRANT INSERT, UPDATE, DELETE ON `db1`.* TO `u1`@`localhost` |
| GRANT `r1`@`%`,`r2`@`%` TO `u1`@`localhost`                 |
+-------------------------------------------------------------+
mysql&gt; <strong class="userinput"><code>SHOW GRANTS FOR 'u1'@'localhost' USING 'r1', 'r2';</code></strong>
+---------------------------------------------------------------------+
| Grants for u1@localhost                                             |
+---------------------------------------------------------------------+
| GRANT USAGE ON *.* TO `u1`@`localhost`                              |
| GRANT SELECT, INSERT, UPDATE, DELETE ON `db1`.* TO `u1`@`localhost` |
| GRANT `r1`@`%`,`r2`@`%` TO `u1`@`localhost`                         |
+---------------------------------------------------------------------+
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          アカウントに付与された権限は常に有効ですが、ロールは有効ではありません。 アカウントのアクティブロールは、<code class="literal">activate_all_roles_on_login</code> システム変数の値、アカウントのデフォルトロール、および <code class="literal">SET ROLE</code> がセッション内で実行されたかどうかによって、セッション間で異なる場合があります。 
        </p></div><p>
        MySQL 8.0.16 以上では、グローバル権限を特定のスキーマに適用できないように制限できるように、グローバル権限の部分的な取消しがサポートされています (<a class="xref" href="security.html#partial-revokes" title="6.2.12 部分取消しを使用した権限の制限">セクション6.2.12「部分取消しを使用した権限の制限」</a> を参照)。 特定のスキーマに対して取り消されたグローバルスキーマ権限を示すために、<code class="literal">SHOW GRANTS</code> 出力には <code class="literal">REVOKE</code> ステートメントが含まれています: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET PERSIST partial_revokes = ON;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE USER u1;</code></strong>
mysql&gt; <strong class="userinput"><code>GRANT SELECT, INSERT, DELETE ON *.* TO u1;</code></strong>
mysql&gt; <strong class="userinput"><code>REVOKE SELECT, INSERT ON mysql.* FROM u1;</code></strong>
mysql&gt; <strong class="userinput"><code>REVOKE DELETE ON world.* FROM u1;</code></strong>
mysql&gt; <strong class="userinput"><code>SHOW GRANTS FOR u1;</code></strong>
+--------------------------------------------------+
| Grants for u1@%                                  |
+--------------------------------------------------+
| GRANT SELECT, INSERT, DELETE ON *.* TO `u1`@`%`  |
| REVOKE SELECT, INSERT ON `mysql`.* FROM `u1`@`%` |
| REVOKE DELETE ON `world`.* FROM `u1`@`%`         |
+--------------------------------------------------+
</pre><p>
        <code class="literal">SHOW GRANTS</code> では、指定されたアカウントで使用できるが、別のアカウントに付与されている権限は表示されません。 たとえば、匿名アカウントが存在する場合、名前付きアカウントはその権限を使用できますが、<code class="literal">SHOW GRANTS</code> では表示されません。 
      </p><p>
        <code class="literal">SHOW GRANTS</code> では、<code class="literal">mandatory_roles</code> システム変数値で指定された必須ロールが次のように表示されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">FOR</code> 句を指定しない <code class="literal">SHOW GRANTS</code> では、現行ユーザーの権限が表示され、必須ロールが含まれます。
          </p></li><li class="listitem"><p>
            <code class="literal">SHOW GRANTS FOR <em class="replaceable"><code>user</code></em></code> には、指定したユーザーの権限が表示され、必須ロールは含まれません。
          </p></li></ul></div><p>
        この動作は、<code class="literal">SHOW GRANTS FOR <em class="replaceable"><code>user</code></em></code> の出力を使用して、指定されたユーザーに明示的に付与される権限を決定するアプリケーションの利点です。 その出力に必須ロールが含まれていたため、ユーザーに明示的に付与されたロールを必須ロールと区別することは困難です。 
      </p><p>
        現行ユーザーの場合、アプリケーションでは、<code class="literal">SHOW GRANTS</code> または <code class="literal">SHOW GRANTS FOR CURRENT_USER</code> をそれぞれ使用して、必須ロールの有無にかかわらず権限を決定できます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-index"></a>13.7.7.22 SHOW INDEX ステートメント</h4></div></div></div><a class="indexterm" name="idm45826987523504"></a><a class="indexterm" name="idm45826987520656"></a><a class="indexterm" name="idm45826987519248"></a><pre class="programlisting">SHOW [EXTENDED] {INDEX | INDEXES | KEYS}
    {FROM | IN} <em class="replaceable"><code>tbl_name</code></em>
    [{FROM | IN} <em class="replaceable"><code>db_name</code></em>]
    [WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        <code class="literal">SHOW INDEX</code> は、テーブルインデックス情報を返します。 この形式は、ODBC での <code class="literal">SQLStatistics</code> 呼び出しの形式に似ています。 このステートメントには、このテーブル内のいずれかのカラムに対する何らかの権限が必要です。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW INDEX FROM City\G</code></strong>
*************************** 1. row ***************************
        Table: city
   Non_unique: 0
     Key_name: PRIMARY
 Seq_in_index: 1
  Column_name: ID
    Collation: A
  Cardinality: 4188
     Sub_part: NULL
       Packed: NULL
         Null:
   Index_type: BTREE
      Comment:
Index_comment:
      Visible: YES
   Expression: NULL
*************************** 2. row ***************************
        Table: city
   Non_unique: 1
     Key_name: CountryCode
 Seq_in_index: 1
  Column_name: CountryCode
    Collation: A
  Cardinality: 232
     Sub_part: NULL
       Packed: NULL
         Null:
   Index_type: BTREE
      Comment:
Index_comment:
      Visible: YES
   Expression: NULL
</pre><p>
        <code class="literal"><em class="replaceable"><code>tbl_name</code></em> FROM <em class="replaceable"><code>db_name</code></em></code> 構文のかわりに、<em class="replaceable"><code>db_name</code></em> を使用することもできます。<em class="replaceable"><code>tbl_name</code></em>。 次の 2 つのステートメントは同等です。 
      </p><pre class="programlisting">SHOW INDEX FROM mytable FROM mydb;
SHOW INDEX FROM mydb.mytable;
</pre><p>
        オプションの <code class="literal">EXTENDED</code> キーワードを指定すると、MySQL が内部的に使用し、ユーザーがアクセスできない非表示インデックスに関する情報が出力に含まれます。
      </p><p>
        <a class="xref" href="information-schema.html#extended-show" title="26.55 SHOW ステートメントの拡張">セクション26.55「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。
      </p><p>
        <code class="literal">SHOW INDEX</code> は、次のフィールドを返します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Table</code>
          </p><p>
            テーブルの名前。
          </p></li><li class="listitem"><p>
            <code class="literal">Non_unique</code>
          </p><p>
            このインデックスが重複を含むことができない場合は 0、できる場合は 1。
          </p></li><li class="listitem"><p>
            <code class="literal">Key_name</code>
          </p><p>
            インデックスの名前。 このインデックスが主キーである場合、その名前は常に <code class="literal">PRIMARY</code> です。 
          </p></li><li class="listitem"><p>
            <code class="literal">Seq_in_index</code>
          </p><p>
            インデックス内のカラムシーケンス番号であり、1 から始まります。
          </p></li><li class="listitem"><p>
            <code class="literal">Column_name</code>
          </p><p>
            カラム名。 <code class="literal">Expression</code> カラムの説明も参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">Collation</code>
          </p><a class="indexterm" name="idm45826987485664"></a><p>
            インデックス内でのカラムのソート方法。 これには、<code class="literal">A</code> (昇順)、<code class="literal">D</code> (降順) または <code class="literal">NULL</code> (ソートなし) の値を指定できます。 
          </p></li><li class="listitem"><p>
            <code class="literal">Cardinality</code>
          </p><a class="indexterm" name="idm45826987478912"></a><a class="indexterm" name="idm45826987476048"></a><p>
            このインデックス内の一意の値の数の推定値。 この数を更新するには、<code class="literal">ANALYZE TABLE</code> または (<code class="literal">MyISAM</code> テーブルの場合は)<span class="command"><strong>myisamchk -a</strong></span> を実行します。 
          </p><p>
            <code class="literal">Cardinality</code> は整数として格納された統計に基づいてカウントされるため、この値は、小さなテーブルの場合でも必ずしも正確であるとはかぎりません。 カーディナリティーが高いほど、MySQL が結合を実行するときにこのインデックスを使用する可能性は高くなります。 
          </p></li><li class="listitem"><p>
            <code class="literal">Sub_part</code>
          </p><p>
            インデックス接頭辞。 つまり、カラムが部分的にのみインデックス付けされている場合はインデックス付けされた文字の数で、カラム全体がインデックス付けされている場合は <code class="literal">NULL</code> です。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              接頭辞 <span class="emphasis"><em>limits</em></span> はバイト単位で測定されます。 ただし、<code class="literal">CREATE TABLE</code>、<code class="literal">ALTER TABLE</code> および <code class="literal">CREATE INDEX</code> ステートメントのインデックス指定の接頭辞 <span class="emphasis"><em>lengths</em></span> は、非バイナリ文字列型 (<code class="literal">CHAR</code>, <code class="literal">VARCHAR</code>, <code class="literal">TEXT</code>) の場合は文字数として解釈され、バイナリ文字列型 (<code class="literal">BINARY</code>, <code class="literal">VARBINARY</code>, <code class="literal">BLOB</code>) の場合はバイト数として解釈されます。 マルチバイト文字セットを使用する非バイナリ文字列カラムに接頭辞の長さを指定する場合は、これを考慮してください。 
            </p></div><p>
            インデックス接頭辞の詳細は、<a class="xref" href="optimization.html#column-indexes" title="8.3.5 カラムインデックス">セクション8.3.5「カラムインデックス」</a> および <a class="xref" href="sql-statements.html#create-index" title="13.1.15 CREATE INDEX ステートメント">セクション13.1.15「CREATE INDEX ステートメント」</a> を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">Packed</code>
          </p><p>
            キーがパックされる方法を示します。 パックされない場合は <code class="literal">NULL</code>。 
          </p></li><li class="listitem"><p>
            <code class="literal">Null</code>
          </p><p>
            このカラムに <code class="literal">NULL</code> 値を含めることができる場合は <code class="literal">YES</code> が、できない場合は <code class="literal">''</code> が含まれます。
          </p></li><li class="listitem"><p>
            <code class="literal">Index_type</code>
          </p><p>
            使用されるインデックス方法 (<code class="literal">BTREE</code>、<code class="literal">FULLTEXT</code>、<code class="literal">HASH</code>、<code class="literal">RTREE</code>)。
          </p></li><li class="listitem"><p>
            <code class="literal">Comment</code>
          </p><p>
            各カラムで説明されていないこのインデックスに関する情報 (このインデックスが無効になっている場合の <code class="literal">disabled</code> など)。
          </p></li><li class="listitem"><p>
            <code class="literal">Index_comment</code>
          </p><p>
            このインデックスが作成されたときに <code class="literal">COMMENT</code> 属性でインデックスに対して提供された任意のコメント。
          </p></li><li class="listitem"><p>
            <code class="literal">Visible</code>
          </p><p>
            オプティマイザがインデックスを参照できるかどうか。 <a class="xref" href="optimization.html#invisible-indexes" title="8.3.12 不可視のインデックス">セクション8.3.12「不可視のインデックス」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">式</code>
          </p><p>
            MySQL 8.0.13 以上では、<code class="literal">Column_name</code> カラムと <code class="literal">Expression</code> カラムの両方に影響する機能キー部分 (<a class="xref" href="sql-statements.html#create-index-functional-key-parts" title="機能キー部品">機能キー部品</a> を参照) がサポートされています:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                機能しないキー部分の場合、<code class="literal">Column_name</code> はキー部分でインデックス付けされたカラムを示し、<code class="literal">Expression</code> は <code class="literal">NULL</code> です。
              </p></li><li class="listitem"><p>
                関数キー部分の場合、<code class="literal">Column_name</code> カラムは <code class="literal">NULL</code> で、<code class="literal">Expression</code> はキー部分の式を示します。
              </p></li></ul></div></li></ul></div><p>
        テーブルインデックスに関する情報は、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">STATISTICS</code> テーブルからも入手できます。 <a class="xref" href="information-schema.html#information-schema-statistics-table" title="26.34 INFORMATION_SCHEMA STATISTICS テーブル">セクション26.34「INFORMATION_SCHEMA STATISTICS テーブル」</a>を参照してください。 非表示インデックスに関する拡張情報は、<code class="literal">SHOW EXTENDED INDEX</code> のみを使用して使用できます。<code class="literal">STATISTICS</code> テーブルからは取得できません。 
      </p><p>
        <span class="command"><strong>mysqlshow -k <em class="replaceable"><code>db_name</code></em> <em class="replaceable"><code>tbl_name</code></em></strong></span> コマンドを使用してテーブルのインデックスをリストできます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-master-status"></a>13.7.7.23 SHOW MASTER STATUS ステートメント</h4></div></div></div><a class="indexterm" name="idm45826987412400"></a><pre class="programlisting">SHOW MASTER STATUS
</pre><p>
        このステートメントは、ソースサーバーのバイナリログファイルに関するステータス情報を提供します。 <code class="literal">REPLICATION CLIENT</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。 
      </p><p>
        例:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW MASTER STATUS\G</code></strong>
*************************** 1. row ***************************
             File: source-bin.000002
         Position: 1307
     Binlog_Do_DB: test
 Binlog_Ignore_DB: manual, mysql
Executed_Gtid_Set: 3E11FA47-71CA-11E1-9E33-C80AA9429562:1-5
1 row in set (0.00 sec)
</pre><p>
        グローバルトランザクション ID が使用されている場合、<code class="literal">Executed_Gtid_Set</code> には、ソースで実行されたトランザクションの GTID のセットが表示されます。 これは、このサーバーの <code class="literal">gtid_executed</code> システム変数の値、およびこのサーバーの <code class="literal">SHOW REPLICA | SLAVE STATUS</code> の出力における <code class="literal">Executed_Gtid_Set</code> の値と同じです。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-open-tables"></a>13.7.7.24 SHOW OPEN TABLES ステートメント</h4></div></div></div><a class="indexterm" name="idm45826987396000"></a><a class="indexterm" name="idm45826987393152"></a><pre class="programlisting">SHOW OPEN TABLES
    [{FROM | IN} <em class="replaceable"><code>db_name</code></em>]
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        <code class="literal">SHOW OPEN TABLES</code> は、現在テーブルキャッシュ内で開いている <code class="literal">TEMPORARY</code> 以外のテーブルを一覧表示します。 <a class="xref" href="optimization.html#table-cache" title="8.4.3.1 MySQL でのテーブルのオープンとクローズの方法">セクション8.4.3.1「MySQL でのテーブルのオープンとクローズの方法」</a>を参照してください。 <code class="literal">FROM</code> 句 (存在する場合) は、表示されるテーブルを <em class="replaceable"><code>db_name</code></em> データベース内に存在するテーブルに制限します。 <code class="literal">LIKE</code> 句 (存在する場合) は、どのテーブル名と照合するかを示します。 <a class="xref" href="information-schema.html#extended-show" title="26.55 SHOW ステートメントの拡張">セクション26.55「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。 
      </p><p>
        <code class="literal">SHOW OPEN TABLES</code> 出力には、次のカラムがあります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Database</code>
          </p><p>
            このテーブルを含むデータベース。
          </p></li><li class="listitem"><p>
            <code class="literal">Table</code>
          </p><p>
            テーブル名
          </p></li><li class="listitem"><p>
            <code class="literal">In_use</code>
          </p><p>
            このテーブルのために存在するテーブルロックまたはロック要求の数。 たとえば、あるクライアントが <code class="literal">LOCK TABLE t1 WRITE</code> を使用してテーブルのロックを取得した場合、<code class="literal">In_use</code> は 1 です。 テーブルがロックされている間に別のクライアントが <code class="literal">LOCK TABLE t1 WRITE</code> を発行すると、クライアントはブロックされ、ロックを待機しますが、ロックリクエストによって <code class="literal">In_use</code> は 2 になります。 このカウントが 0 の場合、このテーブルは開いていますが、現在使用されていません。 <code class="literal">In_use</code> はまた、<code class="literal">HANDLER ... OPEN</code> ステートメントによって増加し、<code class="literal">HANDLER ... CLOSE</code> ステートメントによって減少します。 
          </p></li><li class="listitem"><p>
            <code class="literal">Name_locked</code>
          </p><p>
            テーブル名がロックされているかどうか。 名前のロックは、テーブルの削除や名前の変更などの操作に使用されます。 
          </p></li></ul></div><p>
        テーブルに対する権限を持っていない場合、そのテーブルは <code class="literal">SHOW OPEN TABLES</code> の出力に表示されません。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-plugins"></a>13.7.7.25 SHOW PLUGINS ステートメント</h4></div></div></div><a class="indexterm" name="idm45826987359360"></a><pre class="programlisting">SHOW PLUGINS
</pre><p>
        <code class="literal">SHOW PLUGINS</code> は、サーバープラグインについての情報を表示します。
      </p><p>
        <code class="literal">SHOW PLUGINS</code> の出力の例:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW PLUGINS\G</code></strong>
*************************** 1. row ***************************
   Name: binlog
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 2. row ***************************
   Name: CSV
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 3. row ***************************
   Name: MEMORY
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 4. row ***************************
   Name: MyISAM
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
...
</pre><p>
        <code class="literal">SHOW PLUGINS</code> 出力には、次のカラムがあります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Name</code>
          </p><p>
            <code class="literal">INSTALL PLUGIN</code> や <code class="literal">UNINSTALL PLUGIN</code> などのステートメントでプラグインを参照するために使用される名前。
          </p></li><li class="listitem"><p>
            <code class="literal">Status</code>
          </p><p>
            プラグインステータス (<code class="literal">ACTIVE</code>, <code class="literal">INACTIVE</code>, <code class="literal">DISABLED</code>, <code class="literal">DELETING</code> のいずれか、または <code class="literal">DELETED</code>)。
          </p></li><li class="listitem"><p>
            <code class="literal">Type</code>
          </p><p>
            プラグインのタイプ (<code class="literal">STORAGE ENGINE</code>、<code class="literal">INFORMATION_SCHEMA</code>、<code class="literal">AUTHENTICATION</code> など)。
          </p></li><li class="listitem"><p>
            <code class="literal">Library</code>
          </p><p>
            プラグイン共有ライブラリファイルの名前。 これは、<code class="literal">INSTALL PLUGIN</code> や <code class="literal">UNINSTALL PLUGIN</code> などのステートメントでプラグインファイルを参照するために使用される名前です。 このファイルは、<code class="literal">plugin_dir</code> システム変数によって指名されたディレクトリに置かれます。 ライブラリ名が <code class="literal">NULL</code> である場合、プラグインはコンパイルされますが、<code class="literal">UNINSTALL PLUGIN</code> でアンインストールできません。 
          </p></li><li class="listitem"><p>
            <code class="literal">License</code>
          </p><p>
            プラグインのライセンス方法 (<code class="literal">GPL</code> など)。
          </p></li></ul></div><p>
        <code class="literal">INSTALL PLUGIN</code> とともにインストールされたプラグインの場合、<code class="literal">Name</code> および <code class="literal">Library</code> の値も <code class="literal">mysql.plugin</code> システムテーブルに登録されます。
      </p><p>
        <code class="literal">SHOW PLUGINS</code> によって表示される情報の基礎を形成するプラグインのデータ構造については、<a class="ulink" href="https://dev.mysql.com/doc/extending-mysql/8.0/en/plugin-api.html" target="_top">The MySQL Plugin API</a>を参照してください。
      </p><p>
        プラグイン情報は、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">.PLUGINS</code> テーブルからも入手できます。 <a class="xref" href="information-schema.html#information-schema-plugins-table" title="26.22 INFORMATION_SCHEMA PLUGINS テーブル">セクション26.22「INFORMATION_SCHEMA PLUGINS テーブル」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-privileges"></a>13.7.7.26 SHOW PRIVILEGES ステートメント</h4></div></div></div><a class="indexterm" name="idm45826987313136"></a><pre class="programlisting">SHOW PRIVILEGES
</pre><p>
        <code class="literal">SHOW PRIVILEGES</code> は、MySQL サーバーがサポートするシステム権限のリストを表示します。 表示される権限には、すべての静的権限と、現在登録されているすべての動的権限が含まれます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW PRIVILEGES\G</code></strong>
*************************** 1. row ***************************
Privilege: Alter
  Context: Tables
  Comment: To alter the table
*************************** 2. row ***************************
Privilege: Alter routine
  Context: Functions,Procedures
  Comment: To alter or drop stored functions/procedures
*************************** 3. row ***************************
Privilege: Create
  Context: Databases,Tables,Indexes
  Comment: To create new databases and tables
*************************** 4. row ***************************
Privilege: Create routine
  Context: Databases
  Comment: To use CREATE FUNCTION/PROCEDURE
*************************** 5. row ***************************
Privilege: Create temporary tables
  Context: Databases
  Comment: To use CREATE TEMPORARY TABLE
...
</pre><p>
        特定のユーザーに属する権限は、<code class="literal">SHOW GRANTS</code> ステートメントによって表示されます。 詳細は、<a class="xref" href="sql-statements.html#show-grants" title="13.7.7.21 SHOW GRANTS ステートメント">セクション13.7.7.21「SHOW GRANTS ステートメント」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-procedure-code"></a>13.7.7.27 SHOW PROCEDURE CODE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826987298928"></a><pre class="programlisting">SHOW PROCEDURE CODE <em class="replaceable"><code>proc_name</code></em>
</pre><p>
        このステートメントは、デバッグサポート付きで構築されたサーバーでのみ使用可能な MySQL 拡張です。 これは、指定されたストアドプロシージャーの内部実装の表現を表示します。 同様のステートメントである <code class="literal">SHOW FUNCTION CODE</code> は、ストアドファンクションに関する情報を表示します (<a class="xref" href="sql-statements.html#show-function-code" title="13.7.7.19 SHOW FUNCTION CODE ステートメント">セクション13.7.7.19「SHOW FUNCTION CODE ステートメント」</a>を参照してください)。 
      </p><p>
        いずれかのステートメントを使用するには、ルーチン <code class="literal">DEFINER</code> として指定されたユーザーであるか、<code class="literal">SHOW_ROUTINE</code> 権限を持っているか、グローバルレベルの <code class="literal">SELECT</code> 権限を持っている必要があります。
      </p><p>
        指定されたルーチンが使用可能な場合、各ステートメントは結果セットを生成します。 結果セット内の各行は、このルーチン内の 1 つの<span class="quote">「<span class="quote">命令</span>」</span>に対応します。 最初のカラムは、0 で始まる順序番号である <code class="literal">Pos</code> です。 2 番目のカラムは <code class="literal">Instruction</code> であり、SQL ステートメント (通常は、元のソースから変更されています)、またはストアドルーチンのハンドラに対してのみ意味を持つディレクティブが含まれています。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>DELIMITER //</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE PROCEDURE p1 ()</code></strong>
       <strong class="userinput"><code>BEGIN</code></strong>
         <strong class="userinput"><code>DECLARE fanta INT DEFAULT 55;</code></strong>
         <strong class="userinput"><code>DROP TABLE t2;</code></strong>
         <strong class="userinput"><code>LOOP</code></strong>
           <strong class="userinput"><code>INSERT INTO t3 VALUES (fanta);</code></strong>
           <strong class="userinput"><code>END LOOP;</code></strong>
         <strong class="userinput"><code>END//</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>SHOW PROCEDURE CODE p1//</code></strong>
+-----+----------------------------------------+
| Pos | Instruction                            |
+-----+----------------------------------------+
|   0 | set fanta@0 55                         |
|   1 | stmt 9 "DROP TABLE t2"                 |
|   2 | stmt 5 "INSERT INTO t3 VALUES (fanta)" |
|   3 | jump 2                                 |
+-----+----------------------------------------+
4 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE FUNCTION test.hello (s CHAR(20))</code></strong>
       <strong class="userinput"><code>RETURNS CHAR(50) DETERMINISTIC</code></strong>
       <strong class="userinput"><code>RETURN CONCAT('Hello, ',s,'!');</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW FUNCTION CODE test.hello;</code></strong>
+-----+---------------------------------------+
| Pos | Instruction                           |
+-----+---------------------------------------+
|   0 | freturn 254 concat('Hello, ',s@0,'!') |
+-----+---------------------------------------+
1 row in set (0.00 sec)
</pre><p>
        この例では、実行不可能な <code class="literal">BEGIN</code> および <code class="literal">END</code> ステートメントが消えており、<code class="literal">DECLARE <em class="replaceable"><code>variable_name</code></em></code> ステートメントでは、実行可能ファイルの部分 (デフォルトが割り当てられている部分) のみが表示されています。 ソースから取得されたステートメントごとに、コードワード <code class="literal">stmt</code> とそれに続くタイプ (<code class="literal">DROP</code> を示す 9、<code class="literal">INSERT</code> を示す 5 など) が存在します。 最終行には、<code class="literal">GOTO instruction #2</code> を示す命令 <code class="literal">jump 2</code> が含まれています。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-procedure-status"></a>13.7.7.28 SHOW PROCEDURE STATUS ステートメント</h4></div></div></div><a class="indexterm" name="idm45826987262144"></a><pre class="programlisting">SHOW PROCEDURE STATUS
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        このステートメントは、MySQL 拡張です。 これは、ストアドプロシージャーの特性 (データベース、名前、型、作成者、作成日と変更日、文字セット情報など) を返します。 同様のステートメントである <code class="literal">SHOW FUNCTION STATUS</code> は、ストアドファンクションに関する情報を表示します (<a class="xref" href="sql-statements.html#show-function-status" title="13.7.7.20 SHOW FUNCTION STATUS ステートメント">セクション13.7.7.20「SHOW FUNCTION STATUS ステートメント」</a>を参照してください)。 
      </p><p>
        いずれかのステートメントを使用するには、ルーチン <code class="literal">DEFINER</code> として指定されたユーザー、<code class="literal">SHOW_ROUTINE</code> 権限、グローバルレベルでの <code class="literal">SELECT</code> 権限、またはルーチンを含むスコープで付与された <code class="literal">CREATE ROUTINE</code>、<code class="literal">ALTER ROUTINE</code> または <code class="literal">EXECUTE</code> 権限を持っている必要があります。
      </p><p>
        <code class="literal">LIKE</code> 句 (存在する場合) は、どのプロシージャーまたは関数名と照合するかを示します。 <a class="xref" href="information-schema.html#extended-show" title="26.55 SHOW ステートメントの拡張">セクション26.55「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW PROCEDURE STATUS LIKE 'sp1'\G</code></strong>
*************************** 1. row ***************************
                  Db: test
                Name: sp1
                Type: PROCEDURE
             Definer: testuser@localhost
            Modified: 2018-08-08 13:54:11
             Created: 2018-08-08 13:54:11
       Security_type: DEFINER
             Comment:
character_set_client: utf8mb4
collation_connection: utf8mb4_0900_ai_ci
  Database Collation: utf8mb4_0900_ai_ci

mysql&gt; <strong class="userinput"><code>SHOW FUNCTION STATUS LIKE 'hello'\G</code></strong>
*************************** 1. row ***************************
                  Db: test
                Name: hello
                Type: FUNCTION
             Definer: testuser@localhost
            Modified: 2020-03-10 11:10:03
             Created: 2020-03-10 11:10:03
       Security_type: DEFINER
             Comment:
character_set_client: utf8mb4
collation_connection: utf8mb4_0900_ai_ci
  Database Collation: utf8mb4_0900_ai_ci
</pre><p>
        <code class="literal">character_set_client</code> は、このルーチンが作成されたときの <code class="literal">character_set_client</code> システム変数のセッション値です。<code class="literal">collation_connection</code> は、このルーチンが作成されたときの <code class="literal">collation_connection</code> システム変数のセッション値です。 <code class="literal">Database Collation</code> は、このルーチンが関連付けられているデータベースの照合順序です。 
      </p><p>
        ストアドルーチン情報は、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">PARAMETERS</code> および <code class="literal">ROUTINES</code> テーブルからも入手できます。 <a class="xref" href="information-schema.html#information-schema-parameters-table" title="26.20 INFORMATION_SCHEMA PARAMETERS テーブル">セクション26.20「INFORMATION_SCHEMA PARAMETERS テーブル」</a>および<a class="xref" href="information-schema.html#information-schema-routines-table" title="26.30 INFORMATION_SCHEMA ROUTINES テーブル">セクション26.30「INFORMATION_SCHEMA ROUTINES テーブル」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-processlist"></a>13.7.7.29 SHOW PROCESSLIST ステートメント</h4></div></div></div><a class="indexterm" name="idm45826987227888"></a><a class="indexterm" name="idm45826987226832"></a><a class="indexterm" name="idm45826987225744"></a><a class="indexterm" name="idm45826987224208"></a><a class="indexterm" name="idm45826987222176"></a><a class="indexterm" name="idm45826987220512"></a><pre class="programlisting">SHOW [FULL] PROCESSLIST
</pre><p>
        MySQL プロセスリストには、サーバー内で実行されているスレッドのセットによって現在実行されている操作が示されます。 <code class="literal">SHOW PROCESSLIST</code> ステートメントは、プロセス情報のソースです。 このステートメントと他のソースの比較については、<a class="xref" href="optimization.html#processlist-sources" title="プロセス情報のソース">プロセス情報のソース</a> を参照してください。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL 8.0.22 の時点では、<code class="literal">SHOW PROCESSLIST</code> の代替実装はパフォーマンススキーマ <code class="literal">processlist</code> テーブルに基づいて使用できます。これは、デフォルトの <code class="literal">SHOW PROCESSLIST</code> 実装とは異なり、mutex を必要とせず、パフォーマンス特性が向上します。 詳細は、<a class="xref" href="performance-schema.html#performance-schema-processlist-table" title="27.12.19.9 processlist テーブル">セクション27.12.19.9「processlist テーブル」</a>を参照してください。 
        </p></div><p>
        <code class="literal">PROCESS</code> 権限を持っている場合は、他のユーザーに属するスレッドも含めて、すべてのスレッドを表示できます。 それ以外の場合 (<code class="literal">PROCESS</code> 権限なし)、非匿名ユーザーは自分のスレッドに関する情報にはアクセスできますが、他のユーザーのスレッドにはアクセスできず、匿名ユーザーはスレッド情報にアクセスできません。 
      </p><p>
        <code class="literal">FULL</code> キーワードを指定しない場合、<code class="literal">SHOW PROCESSLIST</code> では、<code class="literal">Info</code> フィールドに各ステートメントの最初の 100 文字のみが表示されます。
      </p><p>
        <code class="literal">SHOW PROCESSLIST</code> ステートメントは、<span class="quote">「<span class="quote">接続が多すぎます</span>」</span>というエラーメッセージが表示されるために、何が発生しているかを突き止めたい場合に非常に役立ちます。 MySQL では、管理者が常にシステムに接続してチェックできるように、<code class="literal">CONNECTION_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) を持つアカウントで使用される追加接続が予約されています (この権限をすべてのユーザーに付与していないことを前提としています)。 
      </p><p>
        スレッドは、<code class="literal">KILL</code> ステートメントを使用して強制終了できます。 <a class="xref" href="sql-statements.html#kill" title="13.7.8.4 KILL ステートメント">セクション13.7.8.4「KILL ステートメント」</a>を参照してください。 
      </p><p>
        <code class="literal">SHOW PROCESSLIST</code> 出力の例:
      </p><pre class="programlisting">mysql&gt; SHOW FULL PROCESSLIST\G
*************************** 1. row ***************************
     Id: 1
   User: system user
   Host:
     db: NULL
Command: Connect
   Time: 1030455
  State: Waiting for master to send event
   Info: NULL
*************************** 2. row ***************************
     Id: 2
   User: system user
   Host:
     db: NULL
Command: Connect
   Time: 1004
  State: Has read all relay log; waiting for the slave
         I/O thread to update it
   Info: NULL
*************************** 3. row ***************************
     Id: 3112
   User: replikator
   Host: artemis:2204
     db: NULL
Command: Binlog Dump
   Time: 2144
  State: Has sent all binlog to slave; waiting for binlog to be updated
   Info: NULL
*************************** 4. row ***************************
     Id: 3113
   User: replikator
   Host: iconnect2:45781
     db: NULL
Command: Binlog Dump
   Time: 2086
  State: Has sent all binlog to slave; waiting for binlog to be updated
   Info: NULL
*************************** 5. row ***************************
     Id: 3123
   User: stefan
   Host: localhost
     db: apollon
Command: Query
   Time: 0
  State: NULL
   Info: SHOW FULL PROCESSLIST
</pre><p>
        <code class="literal">SHOW PROCESSLIST</code> 出力には、次のカラムがあります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="processlist_id"></a>
            <code class="literal">Id</code>
          </p><p>
            接続識別子。 これは、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">PROCESSLIST</code> テーブルの <code class="literal">ID</code> カラムに表示される値と同じで、パフォーマンススキーマ <code class="literal">threads</code> テーブルの <code class="literal">PROCESSLIST_ID</code> カラムに表示され、スレッド内で <code class="literal">CONNECTION_ID()</code> 関数によって返されます。 
          </p></li><li class="listitem"><p><a name="processlist_user"></a>
            <code class="literal">User</code>
          </p><p>
            このステートメントを発行した MySQL ユーザー。 <code class="literal">system user</code> の値は、遅延行ハンドラスレッド、レプリカホストで使用される I/O または SQL スレッドなど、タスクを内部的に処理するためにサーバーによって起動される非クライアントスレッドを指します。 <code class="literal">system user</code> の場合、<code class="literal">Host</code> カラムにホストが指定されていません。<code class="literal">unauthenticated user</code> は、クライアント接続に関連付けられたが、クライアントユーザーの認証がまだ行われていないスレッドを参照します。<code class="literal">event_scheduler</code> は、スケジュールされたイベントをモニターするスレッドを指します (<a class="xref" href="stored-objects.html#event-scheduler" title="25.4 イベントスケジューラの使用">セクション25.4「イベントスケジューラの使用」</a> を参照)。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">system user</code> の <code class="literal">User</code> 値は、<code class="literal">SYSTEM_USER</code> 権限とは異なります。 前者は内部スレッドを指定します。 後者は、システムユーザーと通常のユーザーアカウントカテゴリを区別します (<a class="xref" href="security.html#account-categories" title="6.2.11 アカウントカテゴリ">セクション6.2.11「アカウントカテゴリ」</a> を参照)。 
            </p></div></li><li class="listitem"><p><a name="processlist_host"></a>
            <code class="literal">Host</code>
          </p><p>
            ステートメントを発行するクライアントのホスト名 (ホストがない <code class="literal">system user</code> を除く)。 TCP/IP 接続のホスト名は、<code class="literal"><em class="replaceable"><code>host_name</code></em>:<em class="replaceable"><code>client_port</code></em></code> 形式でレポートされるため、どのクライアントが何を実行しているかを簡単に判別できます。 
          </p></li><li class="listitem"><p><a name="processlist_db"></a>
            <code class="literal">db</code>
          </p><p>
            スレッドのデフォルトデータベース。選択されていない場合は <code class="literal">NULL</code>。
          </p></li><li class="listitem"><p><a name="processlist_command"></a>
            <code class="literal">コマンド</code>
          </p><p>
            スレッドがクライアントのかわりに実行しているコマンドのタイプ。セッションがアイドル状態の場合は <code class="literal">Sleep</code>。 スレッドコマンドの説明については、<a class="xref" href="optimization.html#thread-information" title="8.14 サーバースレッド (プロセス) 情報の確認">セクション8.14「サーバースレッド (プロセス) 情報の確認」</a>を参照してください。 このカラムの値は、クライアント/サーバープロトコルの <code class="literal">COM_<em class="replaceable"><code>xxx</code></em></code> コマンドと <code class="literal">Com_<em class="replaceable"><code>xxx</code></em></code> ステータス変数に対応します。 <a class="xref" href="server-administration.html#server-status-variables" title="5.1.10 サーバーステータス変数">セクション5.1.10「サーバーステータス変数」</a>を参照してください。 
          </p></li><li class="listitem"><p><a name="processlist_time"></a>
            <code class="literal">時間</code>
          </p><p>
            スレッドが現在の状態になってからの秒数。 レプリカ SQL スレッドの場合、この値は、最後にレプリケートされたイベントのタイムスタンプとレプリカホストのリアルタイムの間の秒数です。 <a class="xref" href="replication.html#replication-implementation-details" title="17.2.3 レプリケーションスレッド">セクション17.2.3「レプリケーションスレッド」</a>を参照してください。 
          </p></li><li class="listitem"><p><a name="processlist_state"></a>
            <code class="literal">State</code>
          </p><p>
            スレッドが行なっていることを示すアクション、イベント、または状態。 <code class="literal">State</code> の値の詳細は、<a class="xref" href="optimization.html#thread-information" title="8.14 サーバースレッド (プロセス) 情報の確認">セクション8.14「サーバースレッド (プロセス) 情報の確認」</a> を参照してください。 
          </p><p>
            ほとんどの状態がきわめてすばやい操作に対応します。 スレッドの状態が何秒間も特定の状態にとどまっている場合は、調査が必要な問題が発生している可能性があります。 
          </p></li><li class="listitem"><p><a name="processlist_info"></a>
            <code class="literal">Info</code>
          </p><p>
            スレッドが実行しているステートメント。ステートメントを実行していない場合は <code class="literal">NULL</code>。 このステートメントは、サーバーに送信されるステートメント、またはこのステートメントがほかのステートメントを実行する場合は、もっとも内側のステートメントである可能性があります。 たとえば、<code class="literal">CALL</code> ステートメントが、<code class="literal">SELECT</code> ステートメントを実行しているストアドプロシージャーを実行する場合、<code class="literal">Info</code> 値はその <code class="literal">SELECT</code> ステートメントを示します。 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-profile"></a>13.7.7.30 SHOW PROFILE ステートメント</h4></div></div></div><a class="indexterm" name="idm45826987135168"></a><a class="indexterm" name="idm45826987133680"></a><pre class="programlisting">SHOW PROFILE [<em class="replaceable"><code>type</code></em> [, <em class="replaceable"><code>type</code></em>] ... ]
    [FOR QUERY <em class="replaceable"><code>n</code></em>]
    [LIMIT <em class="replaceable"><code>row_count</code></em> [OFFSET <em class="replaceable"><code>offset</code></em>]]

<em class="replaceable"><code>type</code></em>: {
    ALL
  | BLOCK IO
  | CONTEXT SWITCHES
  | CPU
  | IPC
  | MEMORY
  | PAGE FAULTS
  | SOURCE
  | SWAPS
}
</pre><p>
        <code class="literal">SHOW PROFILE</code> および <code class="literal">SHOW PROFILES</code> ステートメントは、現在のセッションの過程で実行されたステートメントのリソース使用状況を示すプロファイリング情報を表示します。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">SHOW PROFILE</code> および <code class="literal">SHOW PROFILES</code> ステートメントは非推奨になりました。将来の MySQL リリースで削除される予定です。 かわりに <a class="link" href="performance-schema.html" title="第 27 章 MySQL パフォーマンススキーマ">Performance Schema</a> を使用します。<a class="xref" href="performance-schema.html#performance-schema-query-profiling" title="27.19.1 パフォーマンススキーマを使用したクエリープロファイリング">セクション27.19.1「パフォーマンススキーマを使用したクエリープロファイリング」</a> を参照してください。 
        </p></div><p>
        プロファイリングを制御するには、<code class="literal">profiling</code> セッション変数を使用します。この変数のデフォルト値は 0 (<code class="literal">OFF</code>) です。 <code class="literal">profiling</code> を 1 または <code class="literal">ON</code> に設定してプロファイリングを有効にします: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET profiling = 1;</code></strong>
</pre><p>
        <code class="literal">SHOW PROFILES</code> は、サーバーに送信された最新のステートメントのリストを表示します。 このリストのサイズは、<code class="literal">profiling_history_size</code> セッション変数によって制御されます。このデフォルト値は 15 です。 最大値は 100 です。 この値を 0 に設定すると、実質的にプロファイリングが無効になります。 
      </p><p>
        <code class="literal">SHOW PROFILE</code> および <code class="literal">SHOW PROFILES</code> を除くすべてのステートメントがプロファイルされるため、これらのステートメントはプロファイルリストに表示されません。 不正な形式のステートメントはプロファイルされます。 たとえば、<code class="literal">SHOW PROFILING</code> は不正なステートメントであり、実行しようとすると構文エラーが発生しますが、プロファイリングリストには表示されます。 
      </p><p>
        <code class="literal">SHOW PROFILE</code> は、1 つのステートメントに関する詳細情報を表示します。 <code class="literal">FOR QUERY <em class="replaceable"><code>n</code></em></code> 句を指定しない場合、出力は、直近で実行されたステートメントに関連したものになります。 <code class="literal">FOR QUERY <em class="replaceable"><code>n</code></em></code> が含まれている場合、<code class="literal">SHOW PROFILE</code> は、ステートメント <em class="replaceable"><code>n</code></em> に関する情報を表示します。 <em class="replaceable"><code>n</code></em> の値は、<code class="literal">SHOW PROFILES</code> によって表示される <code class="literal">Query_ID</code> 値に対応します。 
      </p><p>
        <code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em></code> 句を指定すると、出力を <em class="replaceable"><code>row_count</code></em> 行に制限できます。 <code class="literal">LIMIT</code> が指定されている場合は、<code class="literal">OFFSET <em class="replaceable"><code>offset</code></em></code> を追加することで、行セット全体が <em class="replaceable"><code>offset</code></em> 行分オフセットされた状態で出力を開始できます。 
      </p><p>
        デフォルトでは、<code class="literal">SHOW PROFILE</code> は <code class="literal">Status</code> および <code class="literal">Duration</code> カラムを表示します。 この <code class="literal">Status</code> 値は <code class="literal">SHOW PROCESSLIST</code> によって表示される <code class="literal">State</code> 値に似ていますが、一部のステータス値では、この 2 つのステートメントの解釈にわずかな違いがいくつか存在する可能性があります (<a class="xref" href="optimization.html#thread-information" title="8.14 サーバースレッド (プロセス) 情報の確認">セクション8.14「サーバースレッド (プロセス) 情報の確認」</a>を参照してください)。 
      </p><p>
        オプションの <em class="replaceable"><code>type</code></em> 値を指定すると、次のその他の特定のタイプの情報を表示できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">ALL</code> は、すべての情報を表示します
          </p></li><li class="listitem"><p>
            <code class="literal">BLOCK IO</code> は、ブロック入力および出力操作の数を表示します
          </p></li><li class="listitem"><p>
            <code class="literal">CONTEXT SWITCHES</code> は、自発的および非自発的コンテキストスイッチの数を表示します
          </p></li><li class="listitem"><p>
            <code class="literal">CPU</code> は、ユーザーとシステムの CPU 使用時間を表示します
          </p></li><li class="listitem"><p>
            <code class="literal">IPC</code> は、送受信されたメッセージの数を表示します
          </p></li><li class="listitem"><p>
            <code class="literal">MEMORY</code> は現在、実装されていません
          </p></li><li class="listitem"><p>
            <code class="literal">PAGE FAULTS</code> は、メジャーおよびマイナーページフォルトの数を表示します
          </p></li><li class="listitem"><p>
            <code class="literal">SOURCE</code> は、ソースコードの関数の名前を、その関数が含まれているファイルの名前および行番号とともに表示します
          </p></li><li class="listitem"><p>
            <code class="literal">SWAPS</code> は、スワップ数を表示します
          </p></li></ul></div><p>
        プロファイリングは、セッション単位で有効になります。 セッションが終了すると、そのプロファイリング情報は失われます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@profiling;</code></strong>
+-------------+
| @@profiling |
+-------------+
|           0 |
+-------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SET profiling = 1;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>DROP TABLE IF EXISTS t1;</code></strong>
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE T1 (id INT);</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>SHOW PROFILES;</code></strong>
+----------+----------+--------------------------+
| Query_ID | Duration | Query                    |
+----------+----------+--------------------------+
|        0 | 0.000088 | SET PROFILING = 1        |
|        1 | 0.000136 | DROP TABLE IF EXISTS t1  |
|        2 | 0.011947 | CREATE TABLE t1 (id INT) |
+----------+----------+--------------------------+
3 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW PROFILE;</code></strong>
+----------------------+----------+
| Status               | Duration |
+----------------------+----------+
| checking permissions | 0.000040 |
| creating table       | 0.000056 |
| After create         | 0.011363 |
| query end            | 0.000375 |
| freeing items        | 0.000089 |
| logging slow query   | 0.000019 |
| cleaning up          | 0.000005 |
+----------------------+----------+
7 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW PROFILE FOR QUERY 1;</code></strong>
+--------------------+----------+
| Status             | Duration |
+--------------------+----------+
| query end          | 0.000107 |
| freeing items      | 0.000008 |
| logging slow query | 0.000015 |
| cleaning up        | 0.000006 |
+--------------------+----------+
4 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW PROFILE CPU FOR QUERY 2;</code></strong>
+----------------------+----------+----------+------------+
| Status               | Duration | CPU_user | CPU_system |
+----------------------+----------+----------+------------+
| checking permissions | 0.000040 | 0.000038 |   0.000002 |
| creating table       | 0.000056 | 0.000028 |   0.000028 |
| After create         | 0.011363 | 0.000217 |   0.001571 |
| query end            | 0.000375 | 0.000013 |   0.000028 |
| freeing items        | 0.000089 | 0.000010 |   0.000014 |
| logging slow query   | 0.000019 | 0.000009 |   0.000010 |
| cleaning up          | 0.000005 | 0.000003 |   0.000002 |
+----------------------+----------+----------+------------+
7 rows in set (0.00 sec)
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          一部のアーキテクチャーでは、プロファイリングが部分的にしか機能しません。 <code class="literal">getrusage()</code> システムコールに依存する値の場合、このシステムコールをサポートしていない Windows などのシステムでは <code class="literal">NULL</code> が返されます。 さらに、プロファイリングはスレッド単位ではなく、プロセス単位です。 つまり、サーバー内の、ユーザー独自のスレッド以外のスレッド上のアクティビティーが、ユーザーに表示されるタイミング情報に影響を与える可能性があります。 
        </p></div><p>
        プロファイリング情報は、<code class="literal">INFORMATION_SCHEMA</code> の <code class="literal">PROFILING</code> テーブルからも入手できます。 <a class="xref" href="information-schema.html#information-schema-profiling-table" title="26.24 INFORMATION_SCHEMA PROFILING テーブル">セクション26.24「INFORMATION_SCHEMA PROFILING テーブル」</a>を参照してください。 たとえば、次のクエリーは同等です: 
      </p><pre class="programlisting">SHOW PROFILE FOR QUERY 2;

SELECT STATE, FORMAT(DURATION, 6) AS DURATION
FROM INFORMATION_SCHEMA.PROFILING
WHERE QUERY_ID = 2 ORDER BY SEQ;
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-profiles"></a>13.7.7.31 SHOW PROFILES ステートメント</h4></div></div></div><a class="indexterm" name="idm45826987050112"></a><pre class="programlisting">SHOW PROFILES
</pre><p>
        <code class="literal">SHOW PROFILES</code> ステートメントは、<code class="literal">SHOW PROFILE</code> とともに、現在のセッションの過程で実行されたステートメントのリソース使用状況を示すプロファイリング情報を表示します。 詳細は、<a class="xref" href="sql-statements.html#show-profile" title="13.7.7.30 SHOW PROFILE ステートメント">セクション13.7.7.30「SHOW PROFILE ステートメント」</a>を参照してください。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">SHOW PROFILE</code> および <code class="literal">SHOW PROFILES</code> ステートメントは非推奨になりました。将来の MySQL リリースで削除される予定です。 かわりに <a class="link" href="performance-schema.html" title="第 27 章 MySQL パフォーマンススキーマ">Performance Schema</a> を使用します。<a class="xref" href="performance-schema.html#performance-schema-query-profiling" title="27.19.1 パフォーマンススキーマを使用したクエリープロファイリング">セクション27.19.1「パフォーマンススキーマを使用したクエリープロファイリング」</a> を参照してください。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-relaylog-events"></a>13.7.7.32 SHOW RELAYLOG EVENTS ステートメント</h4></div></div></div><a class="indexterm" name="idm45826987035440"></a><pre class="programlisting">SHOW RELAYLOG EVENTS
    [IN '<em class="replaceable"><code>log_name</code></em>']
    [FROM <em class="replaceable"><code>pos</code></em>]
    [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]
    [<em class="replaceable"><code>channel_option</code></em>]

<em class="replaceable"><code>channel_option</code></em>:
    FOR CHANNEL <em class="replaceable"><code>channel</code></em>
</pre><p>
        レプリカのリレーログ内のイベントを表示します。 <code class="literal">'<em class="replaceable"><code>log_name</code></em>'</code> を指定しない場合は、最初のリレーログが表示されます。 このステートメントはソースには影響しません。 <code class="literal">SHOW RELAYLOG EVENTS</code> には、<code class="literal">REPLICATION SLAVE</code> 権限が必要です。 
      </p><p>
        <code class="literal">LIMIT</code> 句の構文は、<code class="literal">SELECT</code> ステートメントの場合と同じです。 <a class="xref" href="sql-statements.html#select" title="13.2.10 SELECT ステートメント">セクション13.2.10「SELECT ステートメント」</a>を参照してください。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">LIMIT</code> 句を指定せずに <code class="literal">SHOW RELAYLOG EVENTS</code> を発行すると、リレーログの完全な内容 (レプリカによって受信されたデータを変更するすべてのステートメントを含む) がサーバーからクライアントに返されるため、非常に時間のかかるリソース消費プロセスが開始される可能性があります。
        </p></div><p>
        オプションの <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を使用すると、ステートメントが適用されるレプリケーションチャネルの名前を指定できます。 <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を指定すると、特定のレプリケーションチャネルにステートメントが適用されます。 チャネルが指定されておらず、追加のチャネルが存在しない場合、ステートメントはデフォルトチャネルに適用されます。 
      </p><p>
        複数のレプリケーションチャネルを使用する場合、<code class="literal">SHOW RELAYLOG EVENTS</code> ステートメントに <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を使用して定義されたチャネルがないと、エラーが生成されます。 詳しくは<a class="xref" href="replication.html#replication-channels" title="17.2.2 レプリケーションチャネル">セクション17.2.2「レプリケーションチャネル」</a>をご覧ください。 
      </p><p>
        <code class="literal">SHOW RELAYLOG EVENTS</code> では、リレーログ内のイベントごとに次のフィールドが表示されます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Log_name</code>
          </p><p>
            リストされるファイルの名前。
          </p></li><li class="listitem"><p>
            <code class="literal">Pos</code>
          </p><p>
            イベントが発生する位置。
          </p></li><li class="listitem"><p>
            <code class="literal">Event_type</code>
          </p><p>
            イベントタイプを説明する識別子。
          </p></li><li class="listitem"><p>
            <code class="literal">Server_id</code>
          </p><p>
            イベントが発生したサーバーのサーバー ID。
          </p></li><li class="listitem"><p>
            <code class="literal">End_log_pos</code>
          </p><p>
            ソースバイナリログ内のこのイベントの <code class="literal">End_log_pos</code> の値。
          </p></li><li class="listitem"><p>
            <code class="literal">Info</code>
          </p><p>
            イベントタイプの詳細情報。 この情報の形式は、イベントタイプによって異なります。 
          </p></li></ul></div><p>
        圧縮されたトランザクションペイロードの場合、<code class="literal">Transaction_payload_event</code> は最初に単一のユニットとして印刷されてから解凍され、その内部の各イベントが印刷されます。
      </p><p>
        <code class="literal">SHOW RELAYLOG EVENTS</code> からの出力には、ユーザーおよびシステム変数の設定に関連した一部のイベントが含まれていません。 リレーログ内のイベントを完全に取得するには、<span class="command"><strong>mysqlbinlog</strong></span> を使用します。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-replicas"></a>13.7.7.33 SHOW REPLICAS | SHOW SLAVE HOSTS ステートメント</h4></div></div></div><a class="indexterm" name="idm45826986990496"></a><pre class="programlisting">{SHOW REPLICAS | SHOW SLAVE HOSTS}
</pre><p>
        ソースに現在登録されているレプリカのリストを表示します。 MySQL 8.0.22 から、<code class="literal">SHOW SLAVE HOSTS</code> のかわりに <code class="literal">SHOW REPLICAS</code> を使用します。これは、そのリリースから非推奨になりました。 MySQL 8.0.22 より前のリリースでは、<code class="literal">SHOW SLAVE HOSTS</code> を使用します。 <code class="literal">SHOW REPLICAS | SHOW SLAVE HOSTS</code> には、<code class="literal">REPLICATION SLAVE</code> 権限が必要です。 
      </p><p>
        <code class="literal">SHOW REPLICAS | SHOW SLAVE HOSTS</code> は、レプリケーションソースとして機能するサーバーで実行する必要があります。 このステートメントは、レプリカとして接続されているサーバーまたは接続されているサーバーに関する情報を、次に示すように、1 つの複製サーバーに対応する結果の各行とともに表示します: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW REPLICAS</code></strong>;
+------------+-----------+------+-----------+--------------------------------------+
| Server_id  | Host      | Port | Source_id | Replica_UUID                         |
+------------+-----------+------+-----------+--------------------------------------+
|         10 | iconnect2 | 3306 |         3 | 14cb6624-7f93-11e0-b2c0-c80aa9429562 |
|         21 | athena    | 3306 |         3 | 07af4990-f41f-11df-a566-7ac56fdaf645 |
+------------+-----------+------+-----------+--------------------------------------+
</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Server_id</code> : レプリカサーバーオプションファイルまたは <code class="option">--server-id=<em class="replaceable"><code>value</code></em></code> を使用したコマンドラインで構成された、レプリカサーバーの一意のサーバー ID。
          </p></li><li class="listitem"><p>
            <code class="literal">Host</code>: <code class="option">--report-host</code> オプションを使用してレプリカに指定されたレプリカサーバーのホスト名。 これは、オペレーティングシステムで構成されているマシン名とは異なる場合があります。 
          </p></li><li class="listitem"><p>
            <code class="literal">User</code>: <code class="option">--report-user</code> オプションを使用してレプリカに指定されたレプリカサーバーのユーザー名。 ステートメントの出力にこのカラムが含まれるのは、ソースサーバーが <code class="option">--show-slave-auth-info</code> オプションで起動された場合のみです。 
          </p></li><li class="listitem"><p>
            <code class="literal">Password</code>: <code class="option">--report-password</code> オプションを使用してレプリカに指定されたレプリカサーバーのパスワード。 ステートメントの出力にこのカラムが含まれるのは、ソースサーバーが <code class="option">--show-slave-auth-info</code> オプションで起動された場合のみです。 
          </p></li><li class="listitem"><p>
            <code class="literal">Port</code>: レプリカで <code class="option">--report-port</code> オプションを使用して指定された、レプリカサーバーがリスニングしているソース上のポート。
          </p><p>
            このカラムのゼロは、レプリカポート (<code class="option">--report-port</code>) が設定されていないことを意味します。
          </p></li><li class="listitem"><p>
            <code class="literal">Source_id</code>: レプリカサーバーのレプリケート元のソースサーバーの一意のサーバー ID。 これは、<code class="literal">SHOW REPLICAS | SHOW SLAVE HOSTS</code> が実行されるサーバーのサーバー ID であるため、結果の各行に同じ値がリストされます。 
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm45826986956656"></a> <code class="literal">Replica_UUID</code> : レプリカで生成され、レプリカ <code class="filename">auto.cnf</code> ファイルで検出された、このレプリカのグローバルに一意の ID。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-slave-hosts"></a>13.7.7.34 SHOW SLAVE HOSTS | SHOW REPLICAS ステートメント</h4></div></div></div><a class="indexterm" name="idm45826986950704"></a><pre class="programlisting">{SHOW SLAVE HOSTS | SHOW REPLICAS}
</pre><p>
        ソースに現在登録されているレプリカのリストを表示します。 MySQL 8.0.22 からは、<code class="literal">SHOW SLAVE HOSTS</code> は非推奨であり、かわりにエイリアス <code class="literal">SHOW REPLICAS</code> を使用する必要があります。 ステートメントは以前と同様に機能し、ステートメントおよびその出力に使用される用語のみが変更されています。 どちらのバージョンのステートメントも、使用時に同じステータス変数を更新します。 ステートメントの説明は、<code class="literal">SHOW REPLICAS</code> のドキュメントを参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-replica-status"></a>13.7.7.35 SHOW REPLICA | SLAVE STATUS ステートメント</h4></div></div></div><a class="indexterm" name="idm45826986939744"></a><pre class="programlisting">SHOW {REPLICA | SLAVE} STATUS [FOR CHANNEL <em class="replaceable"><code>channel</code></em>]
</pre><p>
        このステートメントは、レプリカスレッドの必須パラメータに関するステータス情報を提供します。 MySQL 8.0.22 から、<code class="literal">SHOW SLAVE STATUS</code> のかわりに <code class="literal">SHOW REPLICA STATUS</code> を使用します。これは、そのリリースから非推奨になりました。 MySQL 8.0.22 より前のリリースでは、<code class="literal">SHOW SLAVE STATUS</code> を使用します。 このステートメントには、<code class="literal">REPLICATION CLIENT</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。 
      </p><p>
        <code class="literal">SHOW REPLICA | SLAVE STATUS</code> は非ブロッキングです。 <code class="literal">STOP REPLICA | SLAVE</code> と同時に実行すると、<code class="literal">SHOW REPLICA | SLAVE STATUS</code> は、<code class="literal">STOP REPLICA | SLAVE</code> がレプリケーション SQL スレッドまたはレプリケーション I/O スレッド (あるいはその両方) の停止を完了するのを待たずに戻ります。 これにより、最新のデータが返されるようにするよりも、<code class="literal">SHOW REPLICA | SLAVE STATUS</code> から即時レスポンスを取得するモニタリングおよびその他のアプリケーションでの使用が重要になります。 
      </p><p>
        <span class="command"><strong>mysql</strong></span> クライアントを使用してこのステートメントを発行する場合は、セミコロンの代わりに <code class="literal">\G</code> ステートメントターミネータを使用すると、より読みやすい縦のレイアウトが得られます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW REPLICA STATUS\G</code></strong>
*************************** 1. row ***************************
             Replica_IO_State: Waiting for source to send event
                  Source_Host: localhost
                  Source_User: repl
                  Source_Port: 13000
                Connect_Retry: 60
              Source_Log_File: source-bin.000002
          Read_Source_Log_Pos: 1307
               Relay_Log_File: replica-relay-bin.000003
                Relay_Log_Pos: 1508
        Relay_Source_Log_File: source-bin.000002
           Replica_IO_Running: Yes
          Replica_SQL_Running: Yes
              Replicate_Do_DB:
          Replicate_Ignore_DB:
           Replicate_Do_Table:
       Replicate_Ignore_Table:
      Replicate_Wild_Do_Table:
  Replicate_Wild_Ignore_Table:
                   Last_Errno: 0
                   Last_Error:
                 Skip_Counter: 0
          Exec_Source_Log_Pos: 1307
              Relay_Log_Space: 1858
              Until_Condition: None
               Until_Log_File:
                Until_Log_Pos: 0
           Source_SSL_Allowed: No
           Source_SSL_CA_File:
           Source_SSL_CA_Path:
              Source_SSL_Cert:
            Source_SSL_Cipher:
               Source_SSL_Key:
        Seconds_Behind_Source: 0
Source_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error:
               Last_SQL_Errno: 0
               Last_SQL_Error:
  Replicate_Ignore_Server_Ids:
             Source_Server_Id: 1
                  Source_UUID: 3e11fa47-71ca-11e1-9e33-c80aa9429562
             Source_Info_File:
                    SQL_Delay: 0
          SQL_Remaining_Delay: NULL
    Replica_SQL_Running_State: Reading event from the relay log
           Source_Retry_Count: 10
                  Source_Bind:
      Last_IO_Error_Timestamp:
     Last_SQL_Error_Timestamp:
               Source_SSL_Crl:
           Source_SSL_Crlpath:
           Retrieved_Gtid_Set: 3e11fa47-71ca-11e1-9e33-c80aa9429562:1-5
            Executed_Gtid_Set: 3e11fa47-71ca-11e1-9e33-c80aa9429562:1-5
                Auto_Position: 1
         Replicate_Rewrite_DB:
                 Channel_name:
           Source_TLS_Version: TLSv1.2
       Source_public_key_path: public_key.pem
        Get_source_public_key: 0
            Network_Namespace:
</pre><p>
        パフォーマンススキーマは、レプリケーション情報を公開するテーブルを提供します。 これは、<code class="literal">SHOW REPLICA | SLAVE STATUS</code> ステートメントから使用できる情報に似ていますが、テーブル形式で表されます。 詳細は、<a class="xref" href="performance-schema.html#performance-schema-replication-tables" title="27.12.11 パフォーマンススキーマレプリケーションテーブル">セクション27.12.11「パフォーマンススキーマレプリケーションテーブル」</a>を参照してください。 
      </p><p>
        次のリストでは、<code class="literal">SHOW REPLICA | SLAVE STATUS</code> によって返されるフィールドについて説明します。 これらの意味の解釈の詳細は、<a class="xref" href="replication.html#replication-administration-status" title="17.1.7.1 レプリケーションステータスの確認">セクション17.1.7.1「レプリケーションステータスの確認」</a>を参照してください。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Replica_IO_State</code>
          </p><p>
            レプリカ I/O スレッドの <code class="literal">SHOW PROCESSLIST</code> 出力の <code class="literal">State</code> フィールドのコピー。 これは、スレッドが何をしているかを示します: ソースへの接続、ソースからのイベントの待機、ソースへの再接続などを試行します。 可能性のある状態のリストについては、<a class="xref" href="optimization.html#replica-io-thread-states" title="8.14.5 レプリケーション I/O スレッドの状態">セクション8.14.5「レプリケーション I/O スレッドの状態」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">Source_Host</code>
          </p><p>
            レプリカが接続されているソースホスト。
          </p></li><li class="listitem"><p>
            <code class="literal">Source_User</code>
          </p><p>
            ソースへの接続に使用されるアカウントのユーザー名。
          </p></li><li class="listitem"><p>
            <code class="literal">Source_Port</code>
          </p><p>
            ソースへの接続に使用されるポート。
          </p></li><li class="listitem"><p>
            <code class="literal">Connect_Retry</code>
          </p><p>
            接続再試行の間の秒数 (デフォルトは 60)。 これは、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23 の場合) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 の場合) で設定できます。 
          </p></li><li class="listitem"><p>
            <code class="literal">Source_Log_File</code>
          </p><p>
            I/O スレッドが現在読み取っているソースバイナリログファイルの名前。
          </p></li><li class="listitem"><p>
            <code class="literal">Read_Source_Log_Pos</code>
          </p><p>
            I/O スレッドが読み取った現在のソースバイナリログファイル内の位置。
          </p></li><li class="listitem"><p>
            <code class="literal">Relay_Log_File</code>
          </p><p>
            SQL スレッドが現在読み取って実行している元のリレーログファイルの名前。
          </p></li><li class="listitem"><p>
            <code class="literal">Relay_Log_Pos</code>
          </p><p>
            現在のリレーログファイル内の SQL スレッドが最後に読み取って実行した位置。
          </p></li><li class="listitem"><p>
            <code class="literal">Relay_Source_Log_File</code>
          </p><p>
            SQL スレッドによって実行された最新のイベントを含むソースバイナリログファイルの名前。
          </p></li><li class="listitem"><p>
            <code class="literal">Replica_IO_Running</code>
          </p><p>
            レプリケーション I/O スレッドが開始され、ソースに正常に接続されたかどうか。 内部的には、このスレッドの状態は次の 3 つの値のいずれかによって表されます。 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>MYSQL_REPLICA_NOT_RUN. </b>
                  レプリケーション I/O スレッドが実行されていません。 この状態では、<code class="literal">Replica_IO_Running</code> は <code class="literal">No</code> です。 
                </p></li><li class="listitem"><p><b>MYSQL_REPLICA_RUN_NOT_CONNECT. </b>
                  レプリケーション I/O スレッドは実行中ですが、レプリケーションソースに接続されていません。 この状態では、<code class="literal">Replica_IO_Running</code> は <code class="literal">Connecting</code> です。 
                </p></li><li class="listitem"><p><b>MYSQL_REPLICA_RUN_CONNECT. </b>
                  レプリケーション I/O スレッドは実行中で、レプリケーションソースに接続されています。 この状態では、<code class="literal">Replica_IO_Running</code> は <code class="literal">Yes</code> です。 
                </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">Replica_SQL_Running</code>
          </p><p>
            レプリケーション SQL スレッドが開始されているかどうか。
          </p></li><li class="listitem"><p>
            <code class="literal">Replicate_Do_DB</code>、<code class="literal">Replicate_Ignore_DB</code>
          </p><p>
            <code class="option">--replicate-do-db</code> および <code class="option">--replicate-ignore-db</code> オプションまたは <code class="literal">CHANGE REPLICATION FILTER</code> ステートメントで指定されたデータベースの名前。 <code class="literal">FOR CHANNEL</code> 句が使用された場合は、チャネル固有のレプリケーションフィルタが表示されます。 それ以外の場合は、すべてのレプリケーションチャネルのレプリケーションフィルタが表示されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">Replicate_Do_Table</code>、<code class="literal">Replicate_Ignore_Table</code>、<code class="literal">Replicate_Wild_Do_Table</code>、<code class="literal">Replicate_Wild_Ignore_Table</code>
          </p><p>
            <code class="option">--replicate-do-table</code>, <code class="option">--replicate-ignore-table</code>, <code class="option">--replicate-wild-do-table</code> オプション、<code class="option">--replicate-wild-ignore-table</code> オプションまたは <code class="literal">CHANGE REPLICATION FILTER</code> ステートメントで指定されたテーブルの名前。 <code class="literal">FOR CHANNEL</code> 句が使用された場合は、チャネル固有のレプリケーションフィルタが表示されます。 それ以外の場合は、すべてのレプリケーションチャネルのレプリケーションフィルタが表示されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">Last_Errno</code>、<code class="literal">Last_Error</code>
          </p><p>
            これらのカラムは、<code class="literal">Last_SQL_Errno</code> および <code class="literal">Last_SQL_Error</code> のエイリアスです。
          </p><p>
            <code class="literal">RESET MASTER</code> または <code class="literal">RESET REPLICA | SLAVE</code> を発行すると、これらのカラムに表示される値がリセットされます。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              レプリケーション SQL スレッドは、エラーを受信すると、最初にエラーを報告してから SQL スレッドを停止します。 これは、<code class="literal">Replica_SQL_Running</code> に <code class="literal">Yes</code> が表示されている場合でも、<code class="literal">SHOW REPLICA | SLAVE STATUS</code> で <code class="literal">Last_SQL_Errno</code> にゼロ以外の値が表示される短い期間があることを意味します。 
            </p></div></li><li class="listitem"><p>
            <code class="literal">Skip_Counter</code>
          </p><p>
            <code class="literal">sql_slave_skip_counter</code> システム変数の現在の値。 <a class="ulink" href="https://dev.mysql.com/doc/refman/5.6/en/set-global-sql-slave-skip-counter.html" target="_top">SET GLOBAL sql_slave_skip_counter Statement</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">Exec_Source_Log_Pos</code>
          </p><p>
            レプリケーション SQL スレッドが読み取って実行した現在のソースバイナリログファイル内の位置で、次に処理されるトランザクションまたはイベントの開始をマークします。 この値は、新しいレプリカがこの時点から読み取るように、既存のレプリカから新しいレプリカを開始するときに、(MySQL 8.0.23 の) <code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメントの <code class="literal">SOURCE_LOG_POS</code> オプションまたは (MySQL 8.0.23 の前の) <code class="literal">CHANGE MASTER TO</code> ステートメントの <code class="literal">MASTER_LOG_POS</code> オプションとともに使用できます。 ソースバイナリログ内の (<code class="literal">Relay_Source_Log_File</code>、<code class="literal">Exec_Source_Log_Pos</code>) によって指定された座標は、リレーログ内の (<code class="literal">Relay_Log_File</code>、<code class="literal">Relay_Log_Pos</code>) によって指定された座標に対応します。 
          </p><p>
            実行されたリレーログからのトランザクションの順序に一貫性がないと、この値が<span class="quote">「<span class="quote">「最低水位標」</span>」</span>になる可能性があります。 つまり、位置の前に表示されるトランザクションはコミットされていることが保証されますが、位置の後のトランザクションはコミットされているかどうかは保証されません。 これらのギャップを修正する必要がある場合は、<code class="literal">START REPLICA | SLAVE UNTIL SQL_AFTER_MTS_GAPS</code> を使用します。 詳しくは<a class="xref" href="replication.html#replication-features-transaction-inconsistencies" title="17.5.1.34 レプリケーションとトランザクションの非一貫性">セクション17.5.1.34「レプリケーションとトランザクションの非一貫性」</a>をご覧ください。 
          </p></li><li class="listitem"><p>
            <code class="literal">Relay_Log_Space</code>
          </p><p>
            既存のすべてのリレーログファイルの合計サイズ。
          </p></li><li class="listitem"><p>
            <code class="literal">Until_Condition</code>、<code class="literal">Until_Log_File</code>、<code class="literal">Until_Log_Pos</code>
          </p><p>
            <code class="literal">START REPLICA | SLAVE</code> ステートメントの <code class="literal">UNTIL</code> 句で指定された値。
          </p><p>
            <code class="literal">Until_Condition</code> の値は次のとおりです。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">UNTIL</code> 句が指定されなかった場合は <code class="literal">None</code>
              </p></li><li class="listitem"><p>
                レプリカがソースバイナリログ内の指定された位置まで読み取っている場合は <code class="literal">Source</code>。
              </p></li><li class="listitem"><p>
                レプリカがリレーログ内の指定された位置まで読み取っている場合は <code class="literal">Relay</code>。
              </p></li><li class="listitem"><p>
                <code class="literal">gtid_set</code> に GTID がリストされている最初のトランザクションに到達するまで、レプリケーション SQL スレッドがトランザクションを処理している場合は <code class="literal">SQL_BEFORE_GTIDS</code>。
              </p></li><li class="listitem"><p>
                <code class="literal">gtid_set</code> の最後のトランザクションが両方のスレッドによって処理されるまで、レプリケーションスレッドがすべてのトランザクションを処理している場合は <code class="literal">SQL_AFTER_GTIDS</code>。
              </p></li><li class="listitem"><p>
                マルチスレッドレプリカ SQL スレッドがリレーログにギャップがなくなるまで実行されている場合は <code class="literal">SQL_AFTER_MTS_GAPS</code>。
              </p></li></ul></div><p>
            <code class="literal">Until_Log_File</code> および <code class="literal">Until_Log_Pos</code> は、レプリケーション SQL スレッドが実行を停止する座標を定義するログファイルの名前と位置を示します。
          </p><p>
            <code class="literal">UNTIL</code> 句の詳細は、<a class="xref" href="sql-statements.html#start-slave" title="13.4.2.8 START SLAVE | REPLICA ステートメント">セクション13.4.2.8「START SLAVE | REPLICA ステートメント」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">Source_SSL_Allowed</code>, <code class="literal">Source_SSL_CA_File</code>, <code class="literal">Source_SSL_CA_Path</code>, <code class="literal">Source_SSL_Cert</code>, <code class="literal">Source_SSL_Cipher</code>, <code class="literal">Source_SSL_CRL_File</code>, <code class="literal">Source_SSL_CRL_Path</code>, <code class="literal">Source_SSL_Key</code>, <code class="literal">Source_SSL_Verify_Server_Cert</code>
          </p><p>
            これらのフィールドには、レプリカがソースに接続するために使用する SSL パラメータが表示されます (存在する場合)。
          </p><p>
            <code class="literal">Source_SSL_Allowed</code> には次の値があります:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                ソースへの SSL 接続が許可されている場合は <code class="literal">Yes</code>。
              </p></li><li class="listitem"><p>
                ソースへの SSL 接続が許可されていない場合は <code class="literal">No</code>。
              </p></li><li class="listitem"><p>
                SSL 接続が許可されているが、レプリカサーバーで SSL サポートが有効になっていない場合は <code class="literal">Ignored</code>。
              </p></li></ul></div><p>
            その他の SSL 関連フィールドの値は、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23 の場合) の <code class="literal">SOURCE_SSL_*</code> オプションまたは <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 の場合) の <code class="literal">MASTER_SSL_*</code> オプションの値に対応します。 <a class="xref" href="sql-statements.html#change-master-to" title="13.4.2.1 CHANGE MASTER TO ステートメント">セクション13.4.2.1「CHANGE MASTER TO ステートメント」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">Seconds_Behind_Source</code>
          </p><p>
            このフィールドは、レプリカがどのように <span class="quote">「<span class="quote">late</span>」</span> であるかを示します:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                レプリカが更新をアクティブに処理している場合、このフィールドには、レプリカの現在のタイムスタンプと、レプリカで現在処理されているイベントのソースに記録されている元のタイムスタンプの差異が表示されます。
              </p></li><li class="listitem"><p>
                レプリカで現在処理されているイベントがない場合、この値は 0 です。
              </p></li></ul></div><p>
            基本的に、このフィールドはレプリケーション SQL スレッドとレプリケーション I/O スレッドの間の時間差を秒単位で測定します。 ソースとレプリカ間のネットワーク接続が高速である場合、レプリケーション I/O スレッドはソースに非常に近いため、このフィールドはレプリケーション SQL スレッドがソースと比較される遅延の概算値になります。 ネットワークが低速の場合、これは適切な概算ではありません。レプリケーション SQL スレッドは、多くの場合、低速なレプリケーション I/O スレッドで捕捉される可能性があるため、レプリケーション I/O スレッドがソースと比較して遅延している場合でも、<code class="literal">Seconds_Behind_Source</code> は多くの場合 0 の値を表示します。 つまり、<span class="emphasis"><em>このカラムは高速ネットワークの場合にのみ有効です</em></span>。 
          </p><p>
            この時間差計算は、レプリカ I/O スレッドの起動時に計算された差がそれ以降も一定である場合に、ソースとレプリカのクロック時間が同一でない場合でも機能します。 NTP の更新を含むすべての変更により、<code class="literal">Seconds_Behind_Source</code> の計算の信頼性が低下する可能性のあるクロックスキューが発生する可能性があります。 
          </p><p>
            MySQL 8.0 では、レプリケーション SQL スレッドが実行されていない場合、または SQL スレッドがすべてのリレーログを消費し、レプリケーション I/O スレッドが実行されていない場合、このフィールドは <code class="literal">NULL</code> (未定義または不明) になります。 (旧バージョンの MySQL では、レプリケーション SQL スレッドまたはレプリケーション I/O スレッドが実行されていなかったか、ソースに接続されていなかった場合、このフィールドは <code class="literal">NULL</code> でした。) レプリケーション I/O スレッドは実行されているが、リレーログがいっぱいになった場合、<code class="literal">Seconds_Behind_Source</code> は 0 に設定されます。 
          </p><p>
            <code class="literal">Seconds_Behind_Source</code> の値は、イベントに格納されているタイムスタンプに基づき、レプリケーションによって保持されます。 つまり、ソース M1 自体が M0 のレプリカである場合、M0 バイナリログから発生した M1 バイナリログのすべてのイベントには、そのイベントの M0 タイムスタンプが設定されます。 これにより、MySQL は <code class="literal">TIMESTAMP</code> を正常にレプリケートできます。 ただし、<code class="literal">Seconds_Behind_Source</code> の問題は、M1 がクライアントから直接更新を受信した場合、M1 からの最後のイベントが M0 から発生し、場合によっては M1 での直接更新の結果であるため、<code class="literal">Seconds_Behind_Source</code> 値がランダムに変動することです。 
          </p><p>
            マルチスレッドのレプリカを使用する場合、この値は <code class="literal">Exec_Source_Log_Pos</code> に基づいているため、最後にコミットされたトランザクションの位置が反映されない可能性があることに注意してください。
          </p></li><li class="listitem"><p>
            <code class="literal">Last_IO_Errno</code>、<code class="literal">Last_IO_Error</code>
          </p><p>
            レプリケーション I/O スレッドの停止の原因となった最新のエラーのエラー番号およびエラーメッセージ。 0 のエラー番号および空の文字列のメッセージは、<span class="quote">「<span class="quote">エラーなし</span>」</span>を示します。 <code class="literal">Last_IO_Error</code> 値が空でない場合、エラー値はレプリカエラーログにも表示されます。 
          </p><p>
            I/O エラー情報には、最新の I/O スレッドエラーが発生した日時を示すタイムスタンプが含まれます。 このタイムスタンプは <em class="replaceable"><code>YYMMDD hh:mm:ss</code></em> の形式を使用し、<code class="literal">Last_IO_Error_Timestamp</code> カラムに表示されます。 
          </p><p>
            <code class="literal">RESET MASTER</code> または <code class="literal">RESET REPLICA | SLAVE</code> を発行すると、これらのカラムに表示される値がリセットされます。
          </p></li><li class="listitem"><p>
            <code class="literal">Last_SQL_Errno</code>、<code class="literal">Last_SQL_Error</code>
          </p><p>
            レプリケーション SQL スレッドの停止の原因となった最新のエラーのエラー番号およびエラーメッセージ。 0 のエラー番号および空の文字列のメッセージは、<span class="quote">「<span class="quote">エラーなし</span>」</span>を示します。 <code class="literal">Last_SQL_Error</code> 値が空でない場合、エラー値はレプリカエラーログにも表示されます。 
          </p><p>
            レプリカがマルチスレッド化されている場合、レプリケーション SQL スレッドはワーカースレッドのコーディネータです。 この場合、<code class="literal">Last_SQL_Error</code> フィールドには、パフォーマンススキーマ <code class="literal">replication_applier_status_by_coordinator</code> テーブルの <code class="literal">Last_Error_Message</code> カラムに表示される内容が正確に表示されます。 このフィールド値は、各ワーカースレッドステータスを示す <code class="literal">replication_applier_status_by_worker</code> テーブルに表示される他のワーカースレッドでさらに障害が発生する可能性があることを示すように変更されます。 そのテーブルが使用できない場合は、レプリカエラーログを使用できます。 ログまたは <code class="literal">replication_applier_status_by_worker</code> テーブルを使用して、<code class="literal">SHOW REPLICA | SLAVE STATUS</code> またはコーディネータテーブルに表示される障害の詳細を確認する必要もあります。 
          </p><p>
            SQL エラー情報には、最新の SQL スレッドエラーが発生した日時を示すタイムスタンプが含まれます。 このタイムスタンプは <em class="replaceable"><code>YYMMDD hh:mm:ss</code></em> の形式を使用し、<code class="literal">Last_SQL_Error_Timestamp</code> カラムに表示されます。 
          </p><p>
            <code class="literal">RESET MASTER</code> または <code class="literal">RESET REPLICA | SLAVE</code> を発行すると、これらのカラムに表示される値がリセットされます。
          </p><p>
            MySQL 8.0 では、<code class="literal">Last_SQL_Errno</code> および <code class="literal">Last_SQL_Error</code> カラムに表示されるすべてのエラーコードおよびメッセージは、<a class="ulink" href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html" target="_top">Server Error Message Reference</a> にリストされているエラー値に対応しています。 これは、以前のバージョンでは常に当てはまるわけではありませんでした。 (Bug #11760365、Bug #52768) 
          </p></li><li class="listitem"><p>
            <code class="literal">Replicate_Ignore_Server_Ids</code>
          </p><p>
            レプリカがこれらのサーバーからのイベントを無視するように、<code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントの <code class="literal">IGNORE_SERVER_IDS</code> オプションを使用して指定されたサーバー ID。 このオプションは、いずれかのサーバーが削除されたときに循環またはその他のマルチソースレプリケーション設定で使用されます。 この方法でサーバー ID が設定されている場合は、1 つ以上の数値のカンマ区切りリストが表示されます。 サーバー ID が設定されていない場合、このフィールドは空白です。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">slave_master_info</code> テーブルの <code class="literal">Ignored_server_ids</code> 値には、無視されるサーバー ID も空白区切りリストとして表示され、無視されるサーバー ID の合計数が先頭に付きます。 たとえば、サーバー ID が 2、6 または 9 のソースを無視するようレプリカに指示するために、<code class="literal">IGNORE_SERVER_IDS = (2,6,9)</code> オプションを含む <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントが発行された場合、その情報は次のように表示されます: 
            </p><pre class="programlisting">	Replicate_Ignore_Server_Ids: 2, 6, 9
</pre><pre class="programlisting">	Ignored_server_ids: 3, 2, 6, 9
</pre></div><p>
            <code class="literal">Replicate_Ignore_Server_Ids</code> のフィルタリングは SQL スレッドではなく、I/O スレッドによって実行されます。つまり、フィルタで除外されるイベントはリレーログに書き込まれません。 これは、SQL スレッドに適用される <code class="option">--replicate-do-table</code> などのサーバーオプションによって実行されるフィルタリングアクションとは異なります。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              MySQL 8.0 から、<code class="literal">IGNORE_SERVER_IDS</code> で既存のサーバー ID が設定されているチャネルがある場合に <code class="literal">SET GTID_MODE=ON</code> が発行されると、非推奨の警告が発行されます。 GTID ベースのレプリケーションを開始する前に、<code class="literal">SHOW REPLICA | SLAVE STATUS</code> を使用して、関係するサーバー上の無視されたすべてのサーバー ID リストを確認してクリアします。 リストをクリアするには、空のリストで <code class="literal">IGNORE_SERVER_IDS</code> オプションを含む <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> ステートメントを発行します。 
            </p></div></li><li class="listitem"><p>
            <code class="literal">Source_Server_Id</code>
          </p><p>
            ソースからの <code class="literal">server_id</code> 値。
          </p></li><li class="listitem"><p>
            <code class="literal">Source_UUID</code>
          </p><p>
            ソースからの <code class="literal">server_uuid</code> 値。
          </p></li><li class="listitem"><p>
            <code class="literal">Source_Info_File</code>
          </p><p>
            <code class="filename">master.info</code> ファイルの場所。その使用は非推奨になりました。 デフォルトでは、MySQL 8.0 から、レプリカ接続メタデータリポジトリのかわりにテーブルが使用されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">SQL_Delay</code>
          </p><p>
            レプリカがソースを遅らせる必要がある秒数。
          </p></li><li class="listitem"><p>
            <code class="literal">SQL_Remaining_Delay</code>
          </p><p>
            <code class="literal">Replica_SQL_Running_State</code> が <code class="literal">Waiting until MASTER_DELAY seconds after source executed event</code> の場合、このフィールドには残りの遅延秒数が含まれます。 ほかのときは、このフィールドは <code class="literal">NULL</code> です。 
          </p></li><li class="listitem"><p>
            <code class="literal">Replica_SQL_Running_State</code>
          </p><p>
            SQL スレッドの状態 (<code class="literal">Replica_IO_State</code> に類似)。 この値は、<code class="literal">SHOW PROCESSLIST</code> で表示される SQL スレッドの <code class="literal">State</code> 値と同じです。<a class="xref" href="optimization.html#replica-sql-thread-states" title="8.14.6 レプリケーション SQL スレッドの状態">セクション8.14.6「レプリケーション SQL スレッドの状態」</a> には、考えられる状態のリストが表示されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">Source_Retry_Count</code>
          </p><p>
            接続が失われた場合にレプリカがソースへの再接続を試行できる回数。 This value can be set using the <code class="literal">SOURCE_RETRY_COUNT</code> | <code class="literal">MASTER_RETRY_COUNT</code> option of the <code class="literal">CHANGE REPLICATION SOURCE TO</code> statement (from MySQL 8.0.23) or <code class="literal">CHANGE MASTER TO</code> statement (before MySQL 8.0.23), or the older <code class="option">--master-retry-count</code> server option (still supported for backward compatibility). 
          </p></li><li class="listitem"><p>
            <code class="literal">Source_Bind</code>
          </p><p>
            レプリカがバインドされているネットワークインタフェース (ある場合)。 これは、<code class="literal">CHANGE REPLICATION SOURCE TO</code> ステートメント (MySQL 8.0.23) または <code class="literal">CHANGE MASTER TO</code> ステートメント (MySQL 8.0.23 より前) の <code class="literal">SOURCE_BIND</code> | <code class="literal">MASTER_BIND</code> オプションを使用して設定します。 
          </p></li><li class="listitem"><p>
            <code class="literal">Last_IO_Error_Timestamp</code>
          </p><p>
            最新の I/O エラーがいつ発生したかを示す <em class="replaceable"><code>YYMMDD hh:mm:ss</code></em> 形式のタイムスタンプ。
          </p></li><li class="listitem"><p>
            <code class="literal">Last_SQL_Error_Timestamp</code>
          </p><p>
            最新の SQL エラーがいつ発生したかを示す <em class="replaceable"><code>YYMMDD hh:mm:ss</code></em> 形式のタイムスタンプ。
          </p></li><li class="listitem"><p>
            <code class="literal">Retrieved_Gtid_Set</code>
          </p><p>
            このレプリカによって受信されたすべてのトランザクションに対応するグローバルトランザクション ID のセット。 GTID が使用されていない場合は空です。 詳しくは<a class="xref" href="replication.html#replication-gtids-concepts-gtid-sets" title="GTID セット">GTID セット</a>をご覧ください。 
          </p><p>
            これは、リレーログ内に存在するか、またはこれまでに存在したすべての GTID のセットです。 各 GTID は、<code class="literal">Gtid_log_event</code> が受信されるとすぐに追加されます。 そのため、このセットには、部分的に転送されたトランザクションの GTID も含まれる場合があります。 
          </p><p>
            <code class="literal">RESET REPLICA | SLAVE</code> または <code class="literal">CHANGE REPLICATION SOURCE TO</code> | <code class="literal">CHANGE MASTER TO</code> の実行、あるいは <code class="option">--relay-log-recovery</code> オプションの影響が原因ですべてのリレーログが失われると、そのセットはクリアされます。 <code class="literal">relay_log_purge = 1</code> のときは、最新のリレーログが常に保持されるため、このセットはクリアされません。 
          </p></li><li class="listitem"><p>
            <code class="literal">Executed_Gtid_Set</code>
          </p><p>
            バイナリログに書き込まれたグローバルトランザクション ID のセット。 これは、このサーバー上のグローバル <code class="literal">gtid_executed</code> システム変数の値、およびこのサーバー上の <code class="literal">SHOW MASTER STATUS</code> の出力における <code class="literal">Executed_Gtid_Set</code> の値と同じです。 GTID が使用されていない場合は空です。 詳しくは<a class="xref" href="replication.html#replication-gtids-concepts-gtid-sets" title="GTID セット">GTID セット</a>をご覧ください。 
          </p></li><li class="listitem"><p>
            <code class="literal">Auto_Position</code>
          </p><p>
            GTID 自動位置決めがチャネルに使用されている場合は 1、それ以外の場合は 0。
          </p></li><li class="listitem"><p>
            <code class="literal">Replicate_Rewrite_DB</code>
          </p><p>
            <code class="literal">Replicate_Rewrite_DB</code> 値には、指定されたレプリケーションフィルタリングルールが表示されます。 たとえば、次のレプリケーションフィルタルールが設定されているとします: 
          </p><pre class="programlisting">CHANGE REPLICATION FILTER REPLICATE_REWRITE_DB=((db1,db2), (db3,db4));</pre><p>
            <code class="literal">Replicate_Rewrite_DB</code> 値は次のように表示されます:
          </p><pre class="programlisting">Replicate_Rewrite_DB: (db1,db2),(db3,db4)</pre><p>
            詳細は、<a class="xref" href="sql-statements.html#change-replication-filter" title="13.4.2.2 CHANGE REPLICATION FILTER ステートメント">セクション13.4.2.2「CHANGE REPLICATION FILTER ステートメント」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">Channel_name</code>
          </p><p>
            表示されるレプリケーションチャネル。 常にデフォルトのレプリケーションチャネルがあり、さらにレプリケーションチャネルを追加できます。 詳しくは<a class="xref" href="replication.html#replication-channels" title="17.2.2 レプリケーションチャネル">セクション17.2.2「レプリケーションチャネル」</a>をご覧ください。 
          </p></li><li class="listitem"><p>
            <code class="literal">Master_TLS_Version</code>
          </p><p>
            ソースで使用される TLS バージョン。 TLS バージョン情報については、<a class="xref" href="security.html#encrypted-connection-protocols-ciphers" title="6.3.2 暗号化された接続 TLS プロトコルおよび暗号">セクション6.3.2「暗号化された接続 TLS プロトコルおよび暗号」</a> を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">Source_public_key_path</code>
          </p><p>
            RSA キーペアベースのパスワード交換のソースに必要な公開キーのレプリカ側コピーを含むファイルへのパス名。 ファイルは PEM 形式である必要があります。 このカラムは、<code class="literal">sha256_password</code> または <code class="literal">caching_sha2_password</code> 認証プラグインで認証されるレプリカに適用されます。 
          </p><p>
            <code class="literal">Source_public_key_path</code> が指定され、有効な公開キーファイルが指定されている場合は、<code class="literal">Get_source_public_key</code> よりも優先されます。
          </p></li><li class="listitem"><p>
            <code class="literal">Get_source_public_key</code>
          </p><p>
            RSA キーペアベースのパスワード交換に必要な公開キーをソースからリクエストするかどうか。 このカラムは、<code class="literal">caching_sha2_password</code> 認証プラグインで認証されるレプリカに適用されます。 そのプラグインの場合、ソースは要求されないかぎり公開鍵を送信しません。 
          </p><p>
            <code class="literal">Source_public_key_path</code> が指定され、有効な公開キーファイルが指定されている場合は、<code class="literal">Get_source_public_key</code> よりも優先されます。
          </p></li><li class="listitem"><p>
            <code class="literal">Network_Namespace</code>
          </p><p>
            ネットワークネームスペース名。接続でデフォルト (グローバル) ネームスペースを使用する場合は空です。 ネットワークネームスペースの詳細は、<a class="xref" href="server-administration.html#network-namespace-support" title="5.1.14 ネットワークネームスペースのサポート">セクション5.1.14「ネットワークネームスペースのサポート」</a> を参照してください。 このカラムは、MySQL 8.0.22 で追加されました。 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-slave-status"></a>13.7.7.36 SHOW SLAVE | REPLICA STATUS ステートメント</h4></div></div></div><a class="indexterm" name="idm45826986618096"></a><pre class="programlisting">SHOW {SLAVE | REPLICA} STATUS [FOR CHANNEL <em class="replaceable"><code>channel</code></em>]
</pre><p>
        このステートメントは、レプリカスレッドの必須パラメータに関するステータス情報を提供します。 MySQL 8.0.22 からは、<code class="literal">SHOW SLAVE STATUS</code> は非推奨であり、かわりにエイリアス <code class="literal">SHOW REPLICA STATUS</code> を使用する必要があります。 ステートメントは以前と同様に機能し、ステートメントおよびその出力に使用される用語のみが変更されています。 どちらのバージョンのステートメントも、使用時に同じステータス変数を更新します。 ステートメントの説明は、<code class="literal">SHOW REPLICA STATUS</code> のドキュメントを参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-status"></a>13.7.7.37 SHOW STATUS ステートメント</h4></div></div></div><a class="indexterm" name="idm45826986606640"></a><a class="indexterm" name="idm45826986605152"></a><a class="indexterm" name="idm45826986603792"></a><pre class="programlisting">SHOW [GLOBAL | SESSION] STATUS
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><a class="indexterm" name="idm45826986598272"></a><p>
        <code class="literal">SHOW STATUS</code> は、サーバーのステータス情報を提供します (<a class="xref" href="server-administration.html#server-status-variables" title="5.1.10 サーバーステータス変数">セクション5.1.10「サーバーステータス変数」</a> を参照)。 このステートメントにはどの権限も必要ありません。 これには、サーバーに接続できることのみが必要です。 
      </p><p>
        ステータス変数情報は、次のソースからも入手できます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            パフォーマンススキーマ tables. <a class="xref" href="performance-schema.html#performance-schema-status-variable-tables" title="27.12.15 パフォーマンススキーマのステータス変数のテーブル">セクション27.12.15「パフォーマンススキーマのステータス変数のテーブル」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <span class="command"><strong>mysqladmin extended-status</strong></span> コマンド。 <a class="xref" href="programs.html#mysqladmin" title="4.5.2 mysqladmin — A MySQL Server 管理プログラム">セクション4.5.2「mysqladmin — A MySQL Server 管理プログラム」</a>を参照してください。 
          </p></li></ul></div><p>
        <code class="literal">SHOW STATUS</code> の場合、<code class="literal">LIKE</code> 句 (存在する場合) は一致させる変数名を示します。 <a class="xref" href="information-schema.html#extended-show" title="26.55 SHOW ステートメントの拡張">セクション26.55「SHOW ステートメントの拡張」</a> で説明されているように、より一般的な条件を使用して行を選択するために <code class="literal">WHERE</code> 句を指定できます。 
      </p><p>
        <code class="literal">SHOW STATUS</code> は、オプションの <code class="literal">GLOBAL</code> または <code class="literal">SESSION</code> 変数スコープ修飾子を受け入れます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">GLOBAL</code> 修飾子を使用すると、ステートメントはグローバルステータス値を表示します。 グローバルステータス変数は、サーバー自体の一部の側面 (<code class="literal">Aborted_connects</code> など) のステータス、または MySQL へのすべての接続の集計ステータス (<code class="literal">Bytes_received</code> や <code class="literal">Bytes_sent</code> など) を表す場合があります。 変数にグローバル値がない場合は、セッション値が表示されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">SESSION</code> 修飾子を使用すると、ステートメントは現在の接続のステータス変数値を表示します。 変数にセッション値がない場合は、グローバル値が表示されます。 <code class="literal">LOCAL</code> は <code class="literal">SESSION</code> のシノニムです。 
          </p></li><li class="listitem"><p>
            修飾子が存在しない場合、デフォルトは <code class="literal">SESSION</code> です。
          </p></li></ul></div><p>
        各ステータス変数のスコープは、<a class="xref" href="server-administration.html#server-status-variables" title="5.1.10 サーバーステータス変数">セクション5.1.10「サーバーステータス変数」</a>に示されています。
      </p><p>
        <code class="literal">SHOW STATUS</code> ステートメントを呼び出すたびに内部一時テーブルが使用され、グローバルの <code class="literal">Created_tmp_tables</code> 値が増加します。
      </p><p>
        部分的な出力を次に示します。 名前と値のリストは、サーバーによって異なる場合があります。 各変数の意味は、<a class="xref" href="server-administration.html#server-status-variables" title="5.1.10 サーバーステータス変数">セクション5.1.10「サーバーステータス変数」</a>に示されています。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS;</code></strong>
+--------------------------+------------+
| Variable_name            | Value      |
+--------------------------+------------+
| Aborted_clients          | 0          |
| Aborted_connects         | 0          |
| Bytes_received           | 155372598  |
| Bytes_sent               | 1176560426 |
| Connections              | 30023      |
| Created_tmp_disk_tables  | 0          |
| Created_tmp_tables       | 8340       |
| Created_tmp_files        | 60         |
...
| Open_tables              | 1          |
| Open_files               | 2          |
| Open_streams             | 0          |
| Opened_tables            | 44600      |
| Questions                | 2026873    |
...
| Table_locks_immediate    | 1920382    |
| Table_locks_waited       | 0          |
| Threads_cached           | 0          |
| Threads_created          | 30022      |
| Threads_connected        | 1          |
| Threads_running          | 1          |
| Uptime                   | 80380      |
+--------------------------+------------+
</pre><p>
        <code class="literal">LIKE</code> 句を指定すると、このステートメントは、そのパターンに一致する名前を持つ変数の行のみを表示します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'Key%';</code></strong>
+--------------------+----------+
| Variable_name      | Value    |
+--------------------+----------+
| Key_blocks_used    | 14955    |
| Key_read_requests  | 96854827 |
| Key_reads          | 162040   |
| Key_write_requests | 7589728  |
| Key_writes         | 3813196  |
+--------------------+----------+
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-table-status"></a>13.7.7.38 SHOW TABLE STATUS ステートメント</h4></div></div></div><a class="indexterm" name="idm45826986558736"></a><a class="indexterm" name="idm45826986557232"></a><a class="indexterm" name="idm45826986555168"></a><a class="indexterm" name="idm45826986553104"></a><pre class="programlisting">SHOW TABLE STATUS
    [{FROM | IN} <em class="replaceable"><code>db_name</code></em>]
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        <code class="literal">SHOW TABLE STATUS</code> は <code class="literal">SHOW TABLES</code> のように機能しますが、<code class="literal">TEMPORARY</code> 以外の各テーブルに関する多くの情報を提供します。 このリストはまた、<span class="command"><strong>mysqlshow --status <em class="replaceable"><code>db_name</code></em></strong></span> コマンドを使用して取得することもできます。 <code class="literal">LIKE</code> 句 (存在する場合) は、どのテーブル名と照合するかを示します。 <a class="xref" href="information-schema.html#extended-show" title="26.55 SHOW ステートメントの拡張">セクション26.55「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。 
      </p><p>
        このステートメントはまた、ビューに関する情報も表示します。
      </p><p>
        <code class="literal">SHOW TABLE STATUS</code> 出力には、次のカラムがあります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Name</code>
          </p><p>
            テーブルの名前。
          </p></li><li class="listitem"><p>
            <code class="literal">Engine</code>
          </p><p>
            このテーブルのストレージエンジン。 <a class="xref" href="innodb-storage-engine.html" title="第 15 章 InnoDB ストレージエンジン">第15章「<i>InnoDB ストレージエンジン</i>」</a>および<a class="xref" href="storage-engines.html" title="第 16 章 代替ストレージエンジン">第16章「<i>代替ストレージエンジン</i>」</a>を参照してください。 
          </p><p>
            パーティション化されたテーブルの場合、<code class="literal">Engine</code> には、すべてのパーティションで使用されるストレージエンジンの名前が表示されます。
          </p></li><li class="listitem"><p>
            <code class="literal">バージョン</code>
          </p><p>
            このカラムは未使用です。 MySQL 8.0 で <code class="filename">.frm</code> ファイルを削除すると、このカラムには、MySQL 5.7 で最後に使用された <code class="filename">.frm</code> ファイルバージョンである <code class="literal">10</code> のハードコードされた値がレポートされるようになりました。 
          </p></li><li class="listitem"><p>
            <code class="literal">Row_format</code>
          </p><p>
            行ストレージフォーマット (<code class="literal">Fixed</code>、<code class="literal">Dynamic</code>、<code class="literal">Compressed</code>、<code class="literal">Redundant</code>、<code class="literal">Compact</code>)。 <code class="literal">MyISAM</code> テーブルの場合、<code class="literal">Dynamic</code> は、<span class="command"><strong>myisamchk -dvv</strong></span> が <code class="literal">Packed</code> としてレポートする内容に対応します。 
          </p></li><li class="listitem"><p>
            <code class="literal">Rows</code>
          </p><p>
            行数。 <code class="literal">MyISAM</code> などの一部のストレージエンジンは、正確な数を格納します。 <code class="literal">InnoDB</code> などのほかのストレージエンジンの場合、この値は概算であり、実際の値と 40% から 50% まで異なる可能性があります。 このような場合、正確な数を取得するには <code class="literal">SELECT COUNT(*)</code> を使用します。 
          </p><p>
            <code class="literal">INFORMATION_SCHEMA</code> テーブルの場合、<code class="literal">Rows</code> 値は <code class="literal">NULL</code> です。
          </p><p>
            <code class="literal">InnoDB</code> テーブルの場合、行カウントは SQL 最適化で使用される単なる概算です。 (<code class="literal">InnoDB</code> テーブルがパーティション化されている場合も、これは当てはまります。) 
          </p></li><li class="listitem"><p>
            <code class="literal">Avg_row_length</code>
          </p><p>
            平均行長。
          </p></li><li class="listitem"><p>
            <code class="literal">Data_length</code>
          </p><p>
            <code class="literal">MyISAM</code> の場合、<code class="literal">Data_length</code> はデータファイルの長さ (バイト単位) です。
          </p><p>
            <code class="literal">InnoDB</code> の場合、<code class="literal">Data_length</code> は、クラスタ化されたインデックスに割り当てられるおおよその容量 (バイト単位) です。 具体的には、クラスタ化されたインデックスサイズ (ページ単位) に <code class="literal">InnoDB</code> ページサイズを乗算したものです。 
          </p><p>
            その他のストレージエンジンについては、このセクションの最後にある注を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">Max_data_length</code>
          </p><p>
            <code class="literal">MyISAM</code> の場合、<code class="literal">Max_data_length</code> はデータファイルの最大長です。 これは、このテーブル内に格納できるデータの合計バイト数です (使用されるデータポインタサイズが指定された場合)。 
          </p><p>
            <code class="literal">InnoDB</code> では未使用です。
          </p><p>
            その他のストレージエンジンについては、このセクションの最後にある注を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">Index_length</code>
          </p><p>
            <code class="literal">MyISAM</code> の場合、<code class="literal">Index_length</code> はインデックスファイルの長さ (バイト単位) です。
          </p><p>
            <code class="literal">InnoDB</code> の場合、<code class="literal">Index_length</code> は、クラスタ化されていないインデックスに割り当てられる領域の概算量 (バイト単位) です。 具体的には、クラスタ化されていないインデックスサイズの合計 (ページ数) に <code class="literal">InnoDB</code> ページサイズを乗算した値です。 
          </p><p>
            その他のストレージエンジンについては、このセクションの最後にある注を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">Data_free</code>
          </p><p>
            割り当てられているが、使用されていないバイト数。
          </p><p>
            <code class="literal">InnoDB</code> テーブルは、このテーブルが属するテーブルスペースの空き領域をレポートします。 共有テーブルスペース内に存在するテーブルの場合、これはその共有テーブルスペースの空き領域です。 複数のテーブルスペースを使用していて、このテーブルに独自のテーブルスペースがある場合は、そのテーブルのみの空き領域になります。 空き領域とは、完全な空きエクステントから安全上のマージンを引いたバイト数を示します。 空き領域が 0 として表示されている場合でも、新しいエクステントを割り当てる必要がないかぎり、行を挿入できる可能性があります。 
          </p><p>
            NDB Cluster の場合、<code class="literal">Data_free</code> は、ディスク上の「ディスクデータ」テーブルまたはフラグメント用にディスクに割り当てられたが使用されていない領域を表示します。 (メモリー内データリソース使用率は、<code class="literal">Data_length</code> カラムによってレポートされます。) 
          </p><p>
            パーティション化されたテーブルの場合、この値は推定値にすぎず、絶対的に正しいとはかぎりません。 このような場合にこの情報を取得するより正確な方法は、次の例に示すように、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">PARTITIONS</code> テーブルをクエリーすることです: 
          </p><pre class="programlisting">SELECT SUM(DATA_FREE)
    FROM  INFORMATION_SCHEMA.PARTITIONS
    WHERE TABLE_SCHEMA = 'mydb'
    AND   TABLE_NAME   = 'mytable';
</pre><p>
            詳細は、<a class="xref" href="information-schema.html#information-schema-partitions-table" title="26.21 INFORMATION_SCHEMA PARTITIONS テーブル">セクション26.21「INFORMATION_SCHEMA PARTITIONS テーブル」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">Auto_increment</code>
          </p><p>
            次の <code class="literal">AUTO_INCREMENT</code> 値。
          </p></li><li class="listitem"><p>
            <code class="literal">Create_time</code>
          </p><p>
            いつテーブルが作成されたか。
          </p></li><li class="listitem"><p>
            <code class="literal">Update_time</code>
          </p><p>
            いつデータファイルが最後に更新されたか。 一部のストレージエンジンでは、この値は <code class="literal">NULL</code> です。 たとえば、<code class="literal">InnoDB</code> はその<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>内に複数のテーブルを格納するため、データファイルのタイムスタンプは適用されません。 各 <code class="literal">InnoDB</code> テーブルが個別の <code class="literal">.ibd</code> ファイル内に存在する <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> モードの場合でも、<a class="link" href="glossary.html#glos_change_buffering" title="変更バッファリング">変更バッファリング</a>によってデータファイルへの書き込みが遅延される可能性があるため、ファイルの変更時間は最後の挿入、更新、または削除の時間とは異なります。 <code class="literal">MyISAM</code> の場合、データファイルのタイムスタンプが使用されますが、Windows ではタイムスタンプは更新によって更新されないため、値は正確ではありません。 
          </p><p>
            <code class="literal">Update_time</code> には、パーティション化されていない <code class="literal">InnoDB</code> テーブルに対して最後に実行された <code class="literal">UPDATE</code>、<code class="literal">INSERT</code> または <code class="literal">DELETE</code> のタイムスタンプ値が表示されます。 MVCC の場合、タイムスタンプ値は最終更新時間とみなされる <code class="literal">COMMIT</code> 時間を反映します。 タイムスタンプは、サーバーの再起動時、またはテーブルが <code class="literal">InnoDB</code> データディクショナリキャッシュから削除されたときに永続化されません。 
          </p></li><li class="listitem"><p>
            <code class="literal">Check_time</code>
          </p><p>
            いつテーブルが最後にチェックされたか。 すべてのストレージエンジンがこの時間を更新するわけではありません。この場合、値は常に <code class="literal">NULL</code> です。 
          </p><p>
            パーティション化された <code class="literal">InnoDB</code> テーブルの場合、<code class="literal">Check_time</code> は常に <code class="literal">NULL</code> です。
          </p></li><li class="listitem"><p>
            <code class="literal">Collation</code>
          </p><p>
            テーブルのデフォルトの照合。 出力にはテーブルのデフォルトの文字セットは明示的にリストされませんが、照合順序名は文字セット名で始まります。 
          </p></li><li class="listitem"><p>
            <code class="literal">Checksum</code>
          </p><p>
            ライブチェックサム値 (存在する場合)。
          </p></li><li class="listitem"><p>
            <code class="literal">Create_options</code>
          </p><p>
            <code class="literal">CREATE TABLE</code> で使用される追加のオプション。
          </p><p>
            <code class="literal">Create_options</code> には、パーティションテーブルの <code class="literal">partitioned</code> が表示されます。
          </p><p>
            MySQL 8.0.16 より前の <code class="literal">Create_options</code> では、file-per-table テーブルスペースに作成されたテーブルに指定された <code class="literal">ENCRYPTION</code> 句が表示されます。 MySQL 8.0.16 では、テーブルが暗号化されている場合、または指定された暗号化がスキーマ暗号化と異なる場合、file-per-table テーブルスペースの暗号化句が表示されます。 暗号化句は、一般テーブルスペースに作成されたテーブルには表示されません。 暗号化された file-per-table および一般的なテーブルスペースを識別するには、<code class="literal">INNODB_TABLESPACES</code> <code class="literal">ENCRYPTION</code> カラムをクエリーします。 
          </p><p>
            <a class="link" href="glossary.html#glos_strict_mode" title="厳密モード">strict mode</a> を無効にしてテーブルを作成する場合、指定した行フォーマットがサポートされていないと、ストレージエンジンのデフォルトの行フォーマットが使用されます。 テーブルの実際の行形式は、<code class="literal">Row_format</code> カラムにレポートされます。 <code class="literal">Create_options</code> には、<code class="literal">CREATE TABLE</code> ステートメントで指定された行形式が表示されます。 
          </p><p>
            テーブルのストレージエンジンを変更する場合、新しいストレージエンジンに適用できないテーブルオプションはテーブル定義に保持され、必要に応じて、以前に定義されたオプションを持つテーブルを元のストレージエンジンに戻すことができます。 <code class="literal">Create_options</code> には、保持されているオプションが表示される場合があります。 
          </p></li><li class="listitem"><p>
            <code class="literal">Comment</code>
          </p><p>
            このテーブルを作成するときに使用されたコメント (または、MySQL がテーブル情報にアクセスできなかった理由に関する情報)。
          </p></li></ul></div><h5><a name="idm45826986422000"></a>メモ</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">InnoDB</code> テーブルの場合、<code class="literal">SHOW TABLE STATUS</code> では、テーブルで予約されている物理サイズを除き、正確な統計は提供されません。 行カウントは、単に SQL 最適化で使用される概算見積もりです。 
          </p></li><li class="listitem"><p>
            <code class="literal">NDB</code> テーブルの場合、このステートメントの出力は <code class="literal">Avg_row_length</code> および <code class="literal">Data_length</code> カラムの適切な値を示しますが、例外として <code class="literal">BLOB</code> カラムは考慮に入れられません。
          </p></li><li class="listitem"><p>
            <code class="literal">NDB</code> テーブルの場合、<code class="literal">Data_length</code> にはメインメモリーに格納されているデータのみが含まれます。<code class="literal">Max_data_length</code> および <code class="literal">Data_free</code> カラムはディスクデータに適用されます。
          </p></li><li class="listitem"><p>
            「NDB Cluster ディスクデータの場合」テーブル、<code class="literal">Max_data_length</code> には、「ディスクデータ」テーブルまたはフラグメントのディスク部分に割り当てられた領域が表示されます。 (メモリー内データリソース使用率は、<code class="literal">Data_length</code> カラムによってレポートされます。) 
          </p></li><li class="listitem"><p>
            <code class="literal">MEMORY</code> テーブルの場合、<code class="literal">Data_length</code>、<code class="literal">Max_data_length</code>、および <code class="literal">Index_length</code> 値はほぼ、割り当てられているメモリーの実際の量を表します。 割り当てアルゴリズムは、割り当て操作の数を減らすために、大量のメモリーを確保します。 
          </p></li><li class="listitem"><p>
            ビューの場合、<code class="literal">Name</code> がビュー名を示し、<code class="literal">Create_time</code> が作成時間を示し、<code class="literal">Comment</code> が <code class="literal">VIEW</code> を示すことを除き、<code class="literal">SHOW TABLE STATUS</code> によって表示されるほとんどのカラムは 0 または <code class="literal">NULL</code> です。
          </p></li></ul></div><p>
        テーブル情報は、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">TABLES</code> テーブルからも入手できます。 <a class="xref" href="information-schema.html#information-schema-tables-table" title="26.38 INFORMATION_SCHEMA TABLES テーブル">セクション26.38「INFORMATION_SCHEMA TABLES テーブル」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-tables"></a>13.7.7.39 SHOW TABLES ステートメント</h4></div></div></div><a class="indexterm" name="idm45826986392336"></a><a class="indexterm" name="idm45826986388976"></a><pre class="programlisting">SHOW [EXTENDED] [FULL] TABLES
    [{FROM | IN} <em class="replaceable"><code>db_name</code></em>]
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        <code class="literal">SHOW TABLES</code> は、特定のデータベース内の <code class="literal">TEMPORARY</code> 以外のテーブルを一覧表示します。 このリストはまた、<span class="command"><strong>mysqlshow <em class="replaceable"><code>db_name</code></em></strong></span> コマンドを使用して取得することもできます。 <code class="literal">LIKE</code> 句 (存在する場合) は、どのテーブル名と照合するかを示します。 <a class="xref" href="information-schema.html#extended-show" title="26.55 SHOW ステートメントの拡張">セクション26.55「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。 
      </p><p>
        <code class="literal">LIKE</code> 句によって実行される照合は、<code class="literal">lower_case_table_names</code> システム変数の設定に依存します。
      </p><p>
        オプションの <code class="literal">EXTENDED</code> 修飾子を使用すると、失敗した <code class="literal">ALTER TABLE</code> ステートメントによって作成された非表示のテーブルが <code class="literal">SHOW TABLES</code> にリストされます。 これらの一時テーブルは、<code class="literal">#sql</code> で始まる名前を持ち、<code class="literal">DROP TABLE</code> を使用して削除できます。 
      </p><p>
        このステートメントはまた、このデータベース内のビューもすべて一覧表示します。 オプションの <code class="literal">FULL</code> 修飾子を使用すると、<code class="literal">SHOW TABLES</code> では、テーブルの場合は <code class="literal">BASE TABLE</code>、ビューの場合は <code class="literal">VIEW</code>、<code class="literal">INFORMATION_SCHEMA</code> テーブルの場合は <code class="literal">SYSTEM VIEW</code> の値を含む 2 番目の出力カラムが表示されます。 
      </p><p>
        ベーステーブルまたはビューに対する権限を持っていない場合、そのテーブルまたはビューは <code class="literal">SHOW TABLES</code> または <span class="command"><strong>mysqlshow db_name</strong></span> の出力に表示されません。
      </p><p>
        テーブル情報は、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">TABLES</code> テーブルからも入手できます。 <a class="xref" href="information-schema.html#information-schema-tables-table" title="26.38 INFORMATION_SCHEMA TABLES テーブル">セクション26.38「INFORMATION_SCHEMA TABLES テーブル」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-triggers"></a>13.7.7.40 SHOW TRIGGERS ステートメント</h4></div></div></div><a class="indexterm" name="idm45826986356448"></a><a class="indexterm" name="idm45826986355024"></a><a class="indexterm" name="idm45826986353664"></a><pre class="programlisting">SHOW TRIGGERS
    [{FROM | IN} <em class="replaceable"><code>db_name</code></em>]
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        <code class="literal">SHOW TRIGGERS</code> は、データベース (<code class="literal">FROM</code> 句が指定されていないかぎり、デフォルトデータベース) 内のテーブルに対して現在定義されているトリガーを一覧表示します。 このステートメントは、ユーザーが <code class="literal">TRIGGER</code> 権限を持っているデータベースとテーブルに対してのみ結果を返します。 <code class="literal">LIKE</code> 句が存在する場合は、一致させるテーブル名 (トリガー名ではない) を指定し、そのテーブルのトリガーをステートメントに表示させます。 <a class="xref" href="information-schema.html#extended-show" title="26.55 SHOW ステートメントの拡張">セクション26.55「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。 
      </p><p>
        <a class="xref" href="stored-objects.html#triggers" title="25.3 トリガーの使用">セクション25.3「トリガーの使用」</a> で定義された <code class="literal">ins_sum</code> トリガーの場合、<code class="literal">SHOW TRIGGERS</code> の出力は次のようになります:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW TRIGGERS LIKE 'acc%'\G</code></strong>
*************************** 1. row ***************************
             Trigger: ins_sum
               Event: INSERT
               Table: account
           Statement: SET @sum = @sum + NEW.amount
              Timing: BEFORE
             Created: 2018-08-08 10:10:12.61
            sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,
                      NO_ZERO_IN_DATE,NO_ZERO_DATE,
                      ERROR_FOR_DIVISION_BY_ZERO,
                      NO_ENGINE_SUBSTITUTION
             Definer: me@localhost
character_set_client: utf8mb4
collation_connection: utf8mb4_0900_ai_ci
  Database Collation: utf8mb4_0900_ai_ci
</pre><p>
        <code class="literal">SHOW TRIGGERS</code> 出力には、次のカラムがあります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Trigger</code>
          </p><p>
            トリガーの名前。
          </p></li><li class="listitem"><p>
            <code class="literal">イベント</code>
          </p><p>
            トリガーイベント。 これは、トリガーが有効になる、関連付けられたテーブルに対する操作の種類です。 値は、<code class="literal">INSERT</code> (行が挿入された場合)、<code class="literal">DELETE</code> (行が削除された場合) または <code class="literal">UPDATE</code> (行が変更された場合) です。 
          </p></li><li class="listitem"><p>
            <code class="literal">Table</code>
          </p><p>
            トリガーが定義されているテーブル。
          </p></li><li class="listitem"><p>
            <code class="literal">ステートメント</code>
          </p><p>
            トリガー本体 (トリガーがアクティブ化されたときに実行されるステートメント)。
          </p></li><li class="listitem"><p>
            <code class="literal">Timing</code>
          </p><p>
            トリガーを起動するイベントの前または後にトリガーをアクティブ化するかどうか。 値は <code class="literal">BEFORE</code> または <code class="literal">AFTER</code> です。 
          </p></li><li class="listitem"><p>
            <code class="literal">Created</code>
          </p><p>
            トリガーが作成された日時。 これは、トリガーの <code class="literal">TIMESTAMP(2)</code> 値 (小数部は数百秒) です。 
          </p></li><li class="listitem"><p>
            <code class="literal">sql_mode</code>
          </p><p>
            トリガーの作成時およびトリガーの実行時に有効な SQL モード。 指定可能な値については、<a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">Definer</code>
          </p><p>
            トリガーを作成したユーザーのアカウント (<code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'<em class="replaceable"><code>host_name</code></em>'</code>形式)。
          </p></li><li class="listitem"><p>
            <code class="literal">character_set_client</code>
          </p><p>
            トリガー作成時の <code class="literal">character_set_client</code> システム変数のセッション値。
          </p></li><li class="listitem"><p>
            <code class="literal">collation_connection</code>
          </p><p>
            トリガー作成時の <code class="literal">collation_connection</code> システム変数のセッション値。
          </p></li><li class="listitem"><p>
            <code class="literal">Database Collation</code>
          </p><p>
            トリガーが関連付けられているデータベースの照合。
          </p></li></ul></div><p>
        トリガー情報は、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">TRIGGERS</code> テーブルからも入手できます。 <a class="xref" href="information-schema.html#information-schema-triggers-table" title="26.45 INFORMATION_SCHEMA TRIGGERS テーブル">セクション26.45「INFORMATION_SCHEMA TRIGGERS テーブル」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-variables"></a>13.7.7.41 SHOW VARIABLES ステートメント</h4></div></div></div><a class="indexterm" name="idm45826986297040"></a><a class="indexterm" name="idm45826986295536"></a><a class="indexterm" name="idm45826986294176"></a><a class="indexterm" name="idm45826986292816"></a><a class="indexterm" name="idm45826986290896"></a><pre class="programlisting">SHOW [GLOBAL | SESSION] VARIABLES
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><a class="indexterm" name="idm45826986285264"></a><p>
        <code class="literal">SHOW VARIABLES</code> には、MySQL システム変数の値が表示されます (<a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a> を参照)。 このステートメントにはどの権限も必要ありません。 これには、サーバーに接続できることのみが必要です。 
      </p><p>
        システム変数情報は、次のソースからも入手できます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            パフォーマンススキーマ tables. <a class="xref" href="performance-schema.html#performance-schema-system-variable-tables" title="27.12.14 パフォーマンススキーマシステム変数テーブル">セクション27.12.14「パフォーマンススキーマシステム変数テーブル」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <span class="command"><strong>mysqladmin variables</strong></span> コマンド。 <a class="xref" href="programs.html#mysqladmin" title="4.5.2 mysqladmin — A MySQL Server 管理プログラム">セクション4.5.2「mysqladmin — A MySQL Server 管理プログラム」</a>を参照してください。 
          </p></li></ul></div><p>
        <code class="literal">SHOW VARIABLES</code> の場合、<code class="literal">LIKE</code> 句 (存在する場合) は一致させる変数名を示します。 <a class="xref" href="information-schema.html#extended-show" title="26.55 SHOW ステートメントの拡張">セクション26.55「SHOW ステートメントの拡張」</a> で説明されているように、より一般的な条件を使用して行を選択するために <code class="literal">WHERE</code> 句を指定できます。 
      </p><p>
        <code class="literal">SHOW VARIABLES</code> は、オプションの <code class="literal">GLOBAL</code> または <code class="literal">SESSION</code> 変数スコープ修飾子を受け入れます:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">GLOBAL</code> 修飾子を使用すると、ステートメントはグローバルシステム変数値を表示します。 これらは、MySQL への新規接続に対応するセッション変数の初期化に使用される値です。 変数にグローバル値がない場合、値は表示されません。 
          </p></li><li class="listitem"><p>
            <code class="literal">SESSION</code> 修飾子を使用すると、ステートメントは現在の接続で有効なシステム変数値を表示します。 変数にセッション値がない場合は、グローバル値が表示されます。 <code class="literal">LOCAL</code> は <code class="literal">SESSION</code> のシノニムです。 
          </p></li><li class="listitem"><p>
            修飾子が存在しない場合、デフォルトは <code class="literal">SESSION</code> です。
          </p></li></ul></div><p>
        各システム変数のスコープは、<a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a> にリストされています。
      </p><p>
        <code class="literal">SHOW VARIABLES</code> は、バージョンに依存する表示幅の制限に従います。 完全には表示されない非常に長い値を持つ変数の場合、回避策として <code class="literal">SELECT</code> を使用します。 例: 
      </p><pre class="programlisting">SELECT @@GLOBAL.innodb_data_file_path;
</pre><p>
        ほとんどのシステム変数は、サーバーの起動時に設定できます (<code class="literal">version_comment</code> などの読取り専用変数は例外です)。 多くは、<code class="literal">SET</code> ステートメントを使用して実行時に変更できます。 <a class="xref" href="server-administration.html#using-system-variables" title="5.1.9 システム変数の使用">セクション5.1.9「システム変数の使用」</a>および<a class="xref" href="sql-statements.html#set-variable" title="13.7.6.1 変数代入の SET 構文">セクション13.7.6.1「変数代入の SET 構文」</a>を参照してください。 
      </p><p>
        部分的な出力を次に示します。 名前と値のリストは、サーバーによって異なる場合があります。<a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a> では、各変数の意味について説明し、<a class="xref" href="server-administration.html#server-configuration" title="5.1.1 サーバーの構成">セクション5.1.1「サーバーの構成」</a> では、それらのチューニングに関する情報を提供します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW VARIABLES;</code></strong>
+--------------------------------------------+------------------------------+
| Variable_name                              | Value                        |
+--------------------------------------------+------------------------------+
| activate_all_roles_on_login                | OFF                          |
| auto_generate_certs                        | ON                           |
| auto_increment_increment                   | 1                            |
| auto_increment_offset                      | 1                            |
| autocommit                                 | ON                           |
| automatic_sp_privileges                    | ON                           |
| avoid_temporal_upgrade                     | OFF                          |
| back_log                                   | 151                          |
| basedir                                    | /usr/                        |
| big_tables                                 | OFF                          |
| bind_address                               | *                            |
| binlog_cache_size                          | 32768                        |
| binlog_checksum                            | CRC32                        |
| binlog_direct_non_transactional_updates    | OFF                          |
| binlog_error_action                        | ABORT_SERVER                 |
| binlog_expire_logs_seconds                 | 2592000                      |
| binlog_format                              | ROW                          |
| binlog_group_commit_sync_delay             | 0                            |
| binlog_group_commit_sync_no_delay_count    | 0                            |
| binlog_gtid_simple_recovery                | ON                           |
| binlog_max_flush_queue_time                | 0                            |
| binlog_order_commits                       | ON                           |
| binlog_row_image                           | FULL                         |
| binlog_row_metadata                        | MINIMAL                      |
| binlog_row_value_options                   |                              |
| binlog_rows_query_log_events               | OFF                          |
| binlog_stmt_cache_size                     | 32768                        |
| binlog_transaction_dependency_history_size | 25000                        |
| binlog_transaction_dependency_tracking     | COMMIT_ORDER                 |
| block_encryption_mode                      | aes-128-ecb                  |
| bulk_insert_buffer_size                    | 8388608                      |

...

| max_allowed_packet                         | 67108864                     |
| max_binlog_cache_size                      | 18446744073709547520         |
| max_binlog_size                            | 1073741824                   |
| max_binlog_stmt_cache_size                 | 18446744073709547520         |
| max_connect_errors                         | 100                          |
| max_connections                            | 151                          |
| max_delayed_threads                        | 20                           |
| max_digest_length                          | 1024                         |
| max_error_count                            | 1024                         |
| max_execution_time                         | 0                            |
| max_heap_table_size                        | 16777216                     |
| max_insert_delayed_threads                 | 20                           |
| max_join_size                              | 18446744073709551615         |

...

| thread_handling                            | one-thread-per-connection    |
| thread_stack                               | 286720                       |
| time_zone                                  | SYSTEM                       |
| timestamp                                  | 1530906638.765316            |
| tls_version                                | TLSv1,TLSv1.1,TLSv1.2        |
| tmp_table_size                             | 16777216                     |
| tmpdir                                     | /tmp                         |
| transaction_alloc_block_size               | 8192                         |
| transaction_allow_batching                 | OFF                          |
| transaction_isolation                      | REPEATABLE-READ              |
| transaction_prealloc_size                  | 4096                         |
| transaction_read_only                      | OFF                          |
| transaction_write_set_extraction           | XXHASH64                     |
| unique_checks                              | ON                           |
| updatable_views_with_limit                 | YES                          |
| version                                    | 8.0.12                       |
| version_comment                            | MySQL Community Server - GPL |
| version_compile_machine                    | x86_64                       |
| version_compile_os                         | Linux                        |
| version_compile_zlib                       | 1.2.11                       |
| wait_timeout                               | 28800                        |
| warning_count                              | 0                            |
| windowing_use_high_precision               | ON                           |
+--------------------------------------------+------------------------------+
</pre><p>
        <code class="literal">LIKE</code> 句を指定すると、このステートメントは、そのパターンに一致する名前を持つ変数の行のみを表示します。 特定の変数の行を取得するには、<code class="literal">LIKE</code> 句を次に示すように使用します。 
      </p><pre class="programlisting">SHOW VARIABLES LIKE 'max_join_size';
SHOW SESSION VARIABLES LIKE 'max_join_size';
</pre><p>
        名前がパターンと一致する変数のリストを取得するには、<code class="literal">LIKE</code> 句の中で <code class="literal">%</code> のワイルドカード文字を使用します。
      </p><pre class="programlisting">SHOW VARIABLES LIKE '%size%';
SHOW GLOBAL VARIABLES LIKE '%size%';
</pre><p>
        ワイルドカード文字は、照合されるパターン内のどの場所でも利用できます。 厳密に言えば、<code class="literal">_</code>は単一の文字と一致するワイルドカードであるため、文字どおりに一致するように<code class="literal">\_</code>としてエスケープする必要があります。 実際には、これはほとんど必要ありません。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-warnings"></a>13.7.7.42 SHOW WARNINGS ステートメント</h4></div></div></div><a class="indexterm" name="idm45826986223664"></a><a class="indexterm" name="idm45826986222176"></a><pre class="programlisting">SHOW WARNINGS [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]
SHOW COUNT(*) WARNINGS
</pre><p>
        <code class="literal">SHOW WARNINGS</code> は、現在のセッションでのステートメントの実行の結果として得られた条件 (エラー、警告、および注意) に関する情報を表示する診断ステートメントです。 <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、<code class="literal">LOAD DATA</code> などの DML ステートメント、および <code class="literal">CREATE TABLE</code> や <code class="literal">ALTER TABLE</code> などの DDL ステートメントに対して警告が生成されます。 
      </p><p>
        <code class="literal">LIMIT</code> 句の構文は、<code class="literal">SELECT</code> ステートメントの場合と同じです。 <a class="xref" href="sql-statements.html#select" title="13.2.10 SELECT ステートメント">セクション13.2.10「SELECT ステートメント」</a>を参照してください。 
      </p><p>
        <code class="literal">SHOW WARNINGS</code> は、<code class="literal">EXPLAIN</code> によって生成された拡張情報を表示するために、<code class="literal">EXPLAIN</code> の後にも使用されます。 <a class="xref" href="optimization.html#explain-extended" title="8.8.3 拡張 EXPLAIN 出力形式">セクション8.8.3「拡張 EXPLAIN 出力形式」</a>を参照してください。 
      </p><p>
        <code class="literal">SHOW WARNINGS</code> では、現行のセッションで最新の非診断ステートメントを実行した結果の条件に関する情報が表示されます。 解析中に最新のステートメントでエラーが発生した場合、<code class="literal">SHOW WARNINGS</code> では、ステートメントのタイプ (診断または非診断) に関係なく、結果の条件が表示されます。 
      </p><p>
        <code class="literal">SHOW COUNT(*) WARNINGS</code> 診断ステートメントは、エラー、警告、および注意の総数を表示します。 この数はまた、<code class="literal">warning_count</code> システム変数からも取得できます。 
      </p><pre class="programlisting">SHOW COUNT(*) WARNINGS;
SELECT @@warning_count;
</pre><p>
        これらのステートメントの違いは、最初のステートメントがメッセージリストをクリアしない診断ステートメントであることです。 もう一方は <code class="literal">SELECT</code> ステートメントであるため、非診断とみなされ、メッセージリストはクリアされます。 
      </p><p>
        関連する診断ステートメント <code class="literal">SHOW ERRORS</code> はエラー状態のみ (警告と注意は除外されます) を表示し、<code class="literal">SHOW COUNT(*) ERRORS</code> ステートメントはエラーの総数を表示します。 <a class="xref" href="sql-statements.html#show-errors" title="13.7.7.17 SHOW ERRORS ステートメント">セクション13.7.7.17「SHOW ERRORS ステートメント」</a>を参照してください。 <code class="literal">GET DIAGNOSTICS</code> を使用すると、個々の条件に関する情報を検査できます。 <a class="xref" href="sql-statements.html#get-diagnostics" title="13.6.7.3 GET DIAGNOSTICS ステートメント">セクション13.6.7.3「GET DIAGNOSTICS ステートメント」</a>を参照してください。 
      </p><p>
        次に、<code class="literal">INSERT</code> のデータ変換の警告を示す簡単な例を示します。 この例では、厳密な SQL モードが無効であることを前提としています。 厳密モードを有効にすると、警告がエラーになり、<code class="literal">INSERT</code> が終了します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (a TINYINT NOT NULL, b CHAR(4));</code></strong>
Query OK, 0 rows affected (0.05 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES(10,'mysql'), (NULL,'test'), (300,'xyz');</code></strong>
Query OK, 3 rows affected, 3 warnings (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 3

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Warning
   Code: 1265
Message: Data truncated for column 'b' at row 1
*************************** 2. row ***************************
  Level: Warning
   Code: 1048
Message: Column 'a' cannot be null
*************************** 3. row ***************************
  Level: Warning
   Code: 1264
Message: Out of range value for column 'a' at row 3
3 rows in set (0.00 sec)
</pre><p>
        <code class="literal">max_error_count</code> システム変数は、サーバーが情報を格納する対象となるエラー、警告、および注意メッセージの最大数、したがって <code class="literal">SHOW WARNINGS</code> が表示するメッセージの数を制御します。 サーバーが格納できるメッセージの数を変更するには、<code class="literal">max_error_count</code> の値を変更します。 
      </p><p>
        <code class="literal">max_error_count</code> は、カウントされるメッセージの数ではなく、格納されるメッセージの数のみを制御します。 生成されたメッセージの数が <code class="literal">max_error_count</code> を超えた場合でも、<code class="literal">warning_count</code> の値は <code class="literal">max_error_count</code> によって制限されません。 この点について次の例で説明します。 この <code class="literal">ALTER TABLE</code> ステートメントは、3 つの警告メッセージを生成します (この例では、変換の問題が 1 つ発生したあとにエラーが発生しないように、厳密な SQL モードが無効になっています)。 <code class="literal">max_error_count</code> が 1 に設定されたため、格納されて表示されたメッセージは 1 つだけですが、<code class="literal">warning_count</code> の値で示されているように 3 つすべてがカウントされています。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'max_error_count';</code></strong>
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| max_error_count | 1024  |
+-----------------+-------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SET max_error_count=1, sql_mode = '';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 MODIFY b CHAR;</code></strong>
Query OK, 3 rows affected, 3 warnings (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 3

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+---------+------+----------------------------------------+
| Level   | Code | Message                                |
+---------+------+----------------------------------------+
| Warning | 1263 | Data truncated for column 'b' at row 1 |
+---------+------+----------------------------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @@warning_count;</code></strong>
+-----------------+
| @@warning_count |
+-----------------+
|               3 |
+-----------------+
1 row in set (0.01 sec)
</pre><p>
        メッセージの格納を無効にするには、<code class="literal">max_error_count</code> を 0 に設定します。 この場合、<code class="literal">warning_count</code> は引き続き、発生した警告の数を示しますが、メッセージは格納されないため表示できません。 
      </p><p>
        <code class="literal">sql_notes</code> システム変数は、注意メッセージで <code class="literal">warning_count</code> が増分されるかどうか、またサーバーがそれらを格納するかどうかを制御します。 デフォルトでは、<code class="literal">sql_notes</code> は 1 ですが、0 に設定されている場合は、注意で <code class="literal">warning_count</code> が増分されず、またサーバーはそれらを格納しません。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET sql_notes = 1;</code></strong>
mysql&gt; <strong class="userinput"><code>DROP TABLE IF EXISTS test.no_such_table;</code></strong>
Query OK, 0 rows affected, 1 warning (0.00 sec)
mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+-------+------+------------------------------------+
| Level | Code | Message                            |
+-------+------+------------------------------------+
| Note  | 1051 | Unknown table 'test.no_such_table' |
+-------+------+------------------------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SET sql_notes = 0;</code></strong>
mysql&gt; <strong class="userinput"><code>DROP TABLE IF EXISTS test.no_such_table;</code></strong>
Query OK, 0 rows affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
Empty set (0.00 sec)
</pre><p>
        MySQL サーバーは、各クライアントに、そのクライアントによって実行された最新のステートメントの結果として得られたエラー、警告、および注意の総数を示す数を送信します。 C API からは、この値は <code class="literal">mysql_warning_count()</code> を呼び出すことによって取得できます。 <a class="ulink" href="https://dev.mysql.com/doc/c-api/8.0/en/mysql-warning-count.html" target="_top">mysql_warning_count()</a>を参照してください。 
      </p><p>
        <span class="command"><strong>mysql</strong></span> クライアントでは、<code class="literal">warnings</code> コマンドと <code class="literal">nowarning</code> コマンド、またはそれらのショートカット<code class="literal">\W</code> と<code class="literal">\w</code> をそれぞれ使用して、自動警告表示を有効または無効にできます (<a class="xref" href="programs.html#mysql-commands" title="4.5.1.2 mysql クライアントコマンド">セクション4.5.1.2「mysql クライアントコマンド」</a> を参照)。 例: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>\W</code></strong>
Show warnings enabled.
mysql&gt; <strong class="userinput"><code>SELECT 1/0;</code></strong>
+------+
| 1/0  |
+------+
| NULL |
+------+
1 row in set, 1 warning (0.03 sec)

Warning (Code 1365): Division by 0
mysql&gt; <strong class="userinput"><code>\w</code></strong>
Show warnings disabled.
</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="other-administrative-statements"></a>13.7.8 その他の管理ステートメント</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#binlog">13.7.8.1 BINLOG ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#cache-index">13.7.8.2 CACHE INDEX ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#flush">13.7.8.3 FLUSH ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#kill">13.7.8.4 KILL ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#load-index">13.7.8.5 LOAD INDEX INTO CACHE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#reset">13.7.8.6 RESET ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#reset-persist">13.7.8.7 RESET PERSIST ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#restart">13.7.8.8 RESTART ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#shutdown">13.7.8.9 SHUTDOWN ステートメント</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="binlog"></a>13.7.8.1 BINLOG ステートメント</h4></div></div></div><a class="indexterm" name="idm45826986134096"></a><pre class="programlisting">BINLOG '<em class="replaceable"><code>str</code></em>'
</pre><p>
        <code class="literal">BINLOG</code> は、内部で使用されるステートメントです。 これは、バイナリログファイル内の特定のイベントの印刷可能な表現として <span class="command"><strong>mysqlbinlog</strong></span> プログラムによって生成されます。 (<a class="xref" href="programs.html#mysqlbinlog" title="4.6.8 mysqlbinlog — バイナリログファイルを処理するためのユーティリティー">セクション4.6.8「mysqlbinlog — バイナリログファイルを処理するためのユーティリティー」</a>を参照してください。) <code class="literal">'<em class="replaceable"><code>str</code></em>'</code> 値は、サーバーが、対応するイベントによって示されているデータ変更を判定するためにデコードする、base 64 でエンコードされた文字列です。 
      </p><p>
        <span class="command"><strong>mysqlbinlog</strong></span> 出力の適用時に <code class="literal">BINLOG</code> ステートメントを実行するには、ユーザーアカウントに <code class="literal">BINLOG_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) または <code class="literal">REPLICATION_APPLIER</code> 権限と、各ログイベントを実行するための適切な権限が必要です。
      </p><p>
        このステートメントは、フォーマット記述イベントと行イベントのみを実行できます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="cache-index"></a>13.7.8.2 CACHE INDEX ステートメント</h4></div></div></div><a class="indexterm" name="idm45826986116480"></a><a class="indexterm" name="idm45826986114992"></a><a class="indexterm" name="idm45826986112928"></a><pre class="programlisting">CACHE INDEX {
      <em class="replaceable"><code>tbl_index_list</code></em> [, <em class="replaceable"><code>tbl_index_list</code></em>] ...
    | <em class="replaceable"><code>tbl_name</code></em> PARTITION (<em class="replaceable"><code>partition_list</code></em>)
  }
  IN <em class="replaceable"><code>key_cache_name</code></em>

<em class="replaceable"><code>tbl_index_list</code></em>:
  <em class="replaceable"><code>tbl_name</code></em> [{INDEX|KEY} (<em class="replaceable"><code>index_name</code></em>[, <em class="replaceable"><code>index_name</code></em>] ...)]

<em class="replaceable"><code>partition_list</code></em>: {
    <em class="replaceable"><code>partition_name</code></em>[, <em class="replaceable"><code>partition_name</code></em>] ...
  | ALL
}
</pre><p>
        <code class="literal">CACHE INDEX</code> ステートメントは、テーブルインデックスを特定のキーキャッシュに割り当てます。 パーティション化された <code class="literal">MyISAM</code> テーブルを含む <code class="literal">MyISAM</code> テーブルにのみ適用されます。 インデックスが割り当てられたら、これらのインデックスを、必要に応じて <code class="literal">LOAD INDEX INTO CACHE</code> でキャッシュにプリロードできます。 
      </p><p>
        次のステートメントは、テーブル <code class="literal">t1</code>、<code class="literal">t2</code>、および <code class="literal">t3</code> のインデックスを <code class="literal">hot_cache</code> という名前のキーキャッシュに割り当てます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CACHE INDEX t1, t2, t3 IN hot_cache;</code></strong>
+---------+--------------------+----------+----------+
| Table   | Op                 | Msg_type | Msg_text |
+---------+--------------------+----------+----------+
| test.t1 | assign_to_keycache | status   | OK       |
| test.t2 | assign_to_keycache | status   | OK       |
| test.t3 | assign_to_keycache | status   | OK       |
+---------+--------------------+----------+----------+
</pre><p>
        <code class="literal">CACHE INDEX</code> の構文では、テーブルの特定のインデックスのみをキャッシュに割り当てるように指定できます。 ただし、実装ではすべてのテーブルインデックスがキャッシュに割り当てられるため、テーブル名以外を指定する理由はありません。 
      </p><p>
        <code class="literal">CACHE INDEX</code> ステートメントで参照されるキーキャッシュは、パラメータ設定ステートメントを使用して、またはサーバーのパラメータ設定でそのサイズを設定することによって作成できます。 例: 
      </p><pre class="programlisting">SET GLOBAL keycache1.key_buffer_size=128*1024;
</pre><p>
        キーキャッシュパラメータには、構造化システム変数のメンバーとしてアクセスします。 <a class="xref" href="server-administration.html#structured-system-variables" title="5.1.9.5 構造化システム変数">セクション5.1.9.5「構造化システム変数」</a>を参照してください。 
      </p><p>
        インデックスを割り当てる前に、キーキャッシュが存在している必要があります。存在していない場合は、エラーが発生します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CACHE INDEX t1 IN non_existent_cache;</code></strong>
ERROR 1284 (HY000): Unknown key cache 'non_existent_cache'
</pre><p>
        デフォルトで、テーブルインデックスは、サーバー起動時に作成されるメイン (デフォルト) キーキャッシュに割り当てられます。 キーキャッシュが破棄されると、それに割り当てられたすべてのインデックスはデフォルトのキーキャッシュに再割り当てされます。 
      </p><p>
        インデックスの割り当ては、サーバーにグローバルに影響を与えます。あるクライアントがインデックスを特定のキャッシュに割り当てると、どのクライアントがクエリーを発行したかには関係なく、このキャッシュはそのインデックスに関連するすべてのクエリーに使用されます。
      </p><p>
        <code class="literal">CACHE INDEX</code> は、パーティション化された <code class="literal">MyISAM</code> テーブルでサポートされています。 1 つ、複数、またはすべてのパーティションの 1 つ以上のインデックスを特定のキーキャッシュに割り当てることができます。 たとえば、次のステートメントを実行できます。 
      </p><pre class="programlisting">CREATE TABLE pt (c1 INT, c2 VARCHAR(50), INDEX i(c1))
    ENGINE=MyISAM
    PARTITION BY HASH(c1)
    PARTITIONS 4;

SET GLOBAL kc_fast.key_buffer_size = 128 * 1024;
SET GLOBAL kc_slow.key_buffer_size = 128 * 1024;

CACHE INDEX pt PARTITION (p0) IN kc_fast;
CACHE INDEX pt PARTITION (p1, p3) IN kc_slow;
</pre><p>
        前の一連のステートメントは、次のアクションを実行します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            4 つのパーティションを含むパーティション化されたテーブルを作成します。これらのパーティションには、自動的に <code class="literal">p0</code>、...、<code class="literal">p3</code> という名前が付けられます。このテーブルには、カラム <code class="literal">c1</code> 上に <code class="literal">i</code> という名前のインデックスが含まれています。
          </p></li><li class="listitem"><p>
            <code class="literal">kc_fast</code> と <code class="literal">kc_slow</code> という名前の 2 つのキーキャッシュを作成します。
          </p></li><li class="listitem"><p>
            パーティション <code class="literal">p0</code> のインデックスを <code class="literal">kc_fast</code> キーキャッシュに、パーティション <code class="literal">p1</code> と <code class="literal">p3</code> のインデックスを <code class="literal">kc_slow</code> キーキャッシュに割り当てます。残りのパーティション (<code class="literal">p2</code>) のインデックスは、サーバーのデフォルトのキーキャッシュを使用します。
          </p></li></ul></div><p>
        かわりに、テーブル <code class="literal">pt</code> のすべてのパーティションのインデックスを <code class="literal">kc_all</code> という名前の単一のキーキャッシュに割り当てる場合は、次のいずれかのステートメントを使用できます:
      </p><pre class="programlisting">CACHE INDEX pt PARTITION (ALL) IN kc_all;

CACHE INDEX pt IN kc_all;
</pre><p>
        ここで示した 2 つのステートメントは同等であり、どちらか一方を発行してもまったく同じ効果があります。 つまり、パーティションテーブルのすべてのパーティションのインデックスを同じキーキャッシュに割り当てる場合、<code class="literal">PARTITION (ALL)</code> 句はオプションです。 
      </p><p>
        複数のパーティションのインデックスをキーキャッシュに割り当てる場合、パーティションは連続している必要はなく、それらの名前を特定の順序でリストする必要はありません。 キーキャッシュに明示的に割り当てられていないパーティションのインデックスは、サーバーのデフォルトのキーキャッシュを自動的に使用します。 
      </p><p>
        インデックスのプリロードは、パーティション化された <code class="literal">MyISAM</code> テーブルでもサポートされています。 詳細は、<a class="xref" href="sql-statements.html#load-index" title="13.7.8.5 LOAD INDEX INTO CACHE ステートメント">セクション13.7.8.5「LOAD INDEX INTO CACHE ステートメント」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="flush"></a>13.7.8.3 FLUSH ステートメント</h4></div></div></div><a class="indexterm" name="idm45826986054288"></a><a class="indexterm" name="idm45826986052816"></a><a class="indexterm" name="idm45826986051840"></a><a class="indexterm" name="idm45826986049696"></a><pre class="programlisting">FLUSH [NO_WRITE_TO_BINLOG | LOCAL] {
    <em class="replaceable"><code>flush_option</code></em> [, <em class="replaceable"><code>flush_option</code></em>] ...
  | <em class="replaceable"><code>tables_option</code></em>
}

<em class="replaceable"><code>flush_option</code></em>: {
    BINARY LOGS
  | ENGINE LOGS
  | ERROR LOGS
  | GENERAL LOGS
  | HOSTS
  | LOGS
  | PRIVILEGES
  | OPTIMIZER_COSTS
  | RELAY LOGS [FOR CHANNEL <em class="replaceable"><code>channel</code></em>]
  | SLOW LOGS
  | STATUS
  | USER_RESOURCES
}

<em class="replaceable"><code>tables_option</code></em>: {
    TABLES
  | TABLES <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ...
  | TABLES WITH READ LOCK
  | TABLES <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ... WITH READ LOCK
  | TABLES <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ... FOR EXPORT
}
</pre><p>
        <code class="literal">FLUSH</code> ステートメントには、さまざまな内部キャッシュをクリアまたはリロードしたり、テーブルをフラッシュしたり、ロックを取得したりするいくつかのバリアント形式があります。 各 <code class="literal">FLUSH</code> 操作には、その説明に示されている権限が必要です。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          ストアドファンクションまたはトリガー内で <code class="literal">FLUSH</code> ステートメントを発行することはできません。 ただし、ストアドプロシージャーでは、それがストアドファンクションまたはトリガーから呼び出されないかぎり、<code class="literal">FLUSH</code> を使用できます。 <a class="xref" href="stored-objects.html#stored-program-restrictions" title="25.8 ストアドプログラムの制約">セクション25.8「ストアドプログラムの制約」</a>を参照してください。 
        </p></div><p>
        デフォルトでは、<code class="literal">FLUSH</code> ステートメントはレプリカにレプリケートされるようにバイナリログに書き込まれます。 ロギングを抑制するには、オプションの <code class="literal">NO_WRITE_TO_BINLOG</code> キーワード、またはそのエイリアス <code class="literal">LOCAL</code> を指定します。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          レプリカにレプリケートすると問題が発生するため、<code class="literal">FLUSH LOGS</code>, <code class="literal">FLUSH BINARY LOGS</code>, <code class="literal">FLUSH TABLES WITH READ LOCK</code> (テーブルリストの有無にかかわらず)、および <code class="literal">FLUSH TABLES <em class="replaceable"><code>tbl_name</code></em> ... FOR EXPORT</code> はバイナリログに書き込まれません。
        </p></div><p>
        <code class="literal">FLUSH</code> ステートメントは暗黙的なコミットを発生させます。 <a class="xref" href="sql-statements.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。 
      </p><p>
        <span class="command"><strong>mysqladmin</strong></span> ユーティリティーは、<code class="literal">flush-hosts</code>、<code class="literal">flush-logs</code>、<code class="literal">flush-privileges</code>、<code class="literal">flush-status</code>、<code class="literal">flush-tables</code> などのコマンドを使用して、いくつかのフラッシュ操作へのコマンド行インタフェースを提供します。 <a class="xref" href="programs.html#mysqladmin" title="4.5.2 mysqladmin — A MySQL Server 管理プログラム">セクション4.5.2「mysqladmin — A MySQL Server 管理プログラム」</a>を参照してください。 
      </p><a class="indexterm" name="idm45826986014544"></a><a class="indexterm" name="idm45826986012384"></a><p>
        <code class="literal">SIGHUP</code> または <code class="literal">SIGUSR1</code> シグナルをサーバーに送信すると、<code class="literal">FLUSH</code> ステートメントのさまざまな形式に似たフラッシュ操作がいくつか発生します。 シグナルは、<code class="literal">root</code> システムアカウントまたはサーバープロセスを所有するシステムアカウントによって送信できます。 これにより、サーバーに接続せずにフラッシュ操作を実行できるようになり、その操作に十分な権限を持つ MySQL アカウントが必要になります。 <a class="xref" href="programs.html#unix-signal-response" title="4.10 MySQL での Unix シグナル処理">セクション4.10「MySQL での Unix シグナル処理」</a>を参照してください。 
      </p><p>
        <code class="literal">RESET</code> ステートメントは、<code class="literal">FLUSH</code> に似ています。 レプリケーションでの <code class="literal">RESET</code> の使用の詳細は、<a class="xref" href="sql-statements.html#reset" title="13.7.8.6 RESET ステートメント">セクション13.7.8.6「RESET ステートメント」</a> を参照してください。 
      </p><p>
        次のリストに、許可される <code class="literal">FLUSH</code> ステートメントの <em class="replaceable"><code>flush_option</code></em> 値を示します。 許可される <em class="replaceable"><code>tables_option</code></em> 値の説明は、<a class="xref" href="sql-statements.html#flush-tables-variants" title="FLUSH TABLES 構文">FLUSH TABLES 構文</a> を参照してください。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="flush-binary-logs"></a>
            <code class="literal">FLUSH BINARY LOGS</code>
          </p><p>
            サーバーが書き込んでいるバイナリログファイルを閉じてから再度開きます。 バイナリロギングが有効になっている場合は、バイナリログファイルのシーケンス番号が、前のファイルを基準にして 1 増分されます。 
          </p><p>
            この操作には、<code class="literal">RELOAD</code> 権限が必要です。
          </p></li><li class="listitem"><p><a name="flush-engine-logs"></a>
            <code class="literal">FLUSH ENGINE LOGS</code>
          </p><p>
            インストールされているストレージエンジンのフラッシュ可能なログを閉じて再度開きます。 これにより、<code class="literal">InnoDB</code> はログをディスクにフラッシュします。 
          </p><p>
            この操作には、<code class="literal">RELOAD</code> 権限が必要です。
          </p></li><li class="listitem"><p><a name="flush-error-logs"></a>
            <code class="literal">FLUSH ERROR LOGS</code>
          </p><p>
            サーバーが書き込んでいるエラーログファイルを閉じて再度開きます。
          </p><p>
            この操作には、<code class="literal">RELOAD</code> 権限が必要です。
          </p></li><li class="listitem"><p><a name="flush-general-logs"></a>
            <code class="literal">FLUSH GENERAL LOGS</code>
          </p><p>
            サーバーが書き込んでいる一般クエリーログファイルを閉じて再度開きます。
          </p><p>
            この操作には、<code class="literal">RELOAD</code> 権限が必要です。
          </p><p>
            この操作は、一般クエリーログに使用されるテーブルには影響しません (<a class="xref" href="server-administration.html#log-destinations" title="5.4.1 一般クエリーログおよびスロークエリーログの出力先の選択">セクション5.4.1「一般クエリーログおよびスロークエリーログの出力先の選択」</a> を参照)。
          </p></li><li class="listitem"><p><a name="flush-hosts"></a>
            <code class="literal">FLUSH HOSTS</code>
          </p><p>
            キャッシュの内容を公開するホストキャッシュとパフォーマンススキーマ <code class="literal">host_cache</code> テーブルを空にし、ブロックされたホストをブロック解除します。
          </p><p>
            この操作には、<code class="literal">RELOAD</code> 権限が必要です。
          </p><p>
            ホストキャッシュのフラッシュが推奨または望ましい理由については、<a class="xref" href="server-administration.html#host-cache" title="5.1.12.3 DNS ルックアップとホストキャッシュ">セクション5.1.12.3「DNS ルックアップとホストキャッシュ」</a> を参照してください。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">FLUSH HOSTS</code> は、MySQL 8.0.23 では非推奨です。将来の MySQL リリースでは削除される予定です。 代わりに、パフォーマンススキーマ <code class="literal">host_cache</code> テーブルを切り捨てます: 
            </p><pre class="programlisting">TRUNCATE TABLE performance_schema.host_cache;
</pre><p>
              <code class="literal">TRUNCATE TABLE</code> 操作には、<code class="literal">RELOAD</code> 権限ではなく、テーブルに対する <code class="literal">DROP</code> 権限が必要です。
            </p></div></li><li class="listitem"><p><a name="flush-logs"></a>
            <code class="literal">FLUSH LOGS</code>
          </p><p>
            サーバーが書き込んでいるログファイルを閉じて再度開きます。
          </p><p>
            この操作には、<code class="literal">RELOAD</code> 権限が必要です。
          </p><p>
            この操作の効果は、次の操作を組み合せた効果と同等です:
          </p><pre class="programlisting">FLUSH BINARY LOGS
FLUSH ENGINE LOGS
FLUSH ERROR LOGS
FLUSH GENERAL LOGS
FLUSH RELAY LOGS
FLUSH SLOW LOGS
</pre></li><li class="listitem"><p><a name="flush-optimizer-costs"></a>
            <code class="literal">FLUSH OPTIMIZER_COSTS</code>
          </p><p>
            コストモデルテーブルに格納されている現在のコスト見積りの使用をオプティマイザが開始するように、コストモデルテーブルを再読取りします。
          </p><p>
            この操作には、<code class="literal">FLUSH_OPTIMIZER_COSTS</code> または <code class="literal">RELOAD</code> 権限が必要です。
          </p><p>
            サーバーは、認識できないコストモデルテーブルエントリについて、エラーログに警告を書き込みます。 これらのテーブルの詳細は、<a class="xref" href="optimization.html#cost-model" title="8.9.5 オプティマイザコストモデル">セクション8.9.5「オプティマイザコストモデル」</a> を参照してください。 この操作は、フラッシュ後に開始されるセッションにのみ影響します。 既存のセッションでは、開始時の現行のコスト見積りが引き続き使用されます。 
          </p></li><li class="listitem"><p><a name="flush-privileges"></a>
            <code class="literal">FLUSH PRIVILEGES</code>
          </p><p>
            <code class="literal">mysql</code> システムスキーマの付与テーブルから権限を再度読み取ります。 この操作の一環として、サーバーは動的権限割当てを含む <code class="literal">global_grants</code> テーブルを読み取り、そこで見つかった未登録の権限を登録します。 
          </p><p>
            この操作には、<code class="literal">RELOAD</code> 権限が必要です。
          </p><p>
            MySQL 権限システムを無効にするためにサーバーの起動時に <code class="option">--skip-grant-tables</code> オプションが指定された場合、<code class="literal">FLUSH PRIVILEGES</code> は実行時に権限システムを有効にする方法を提供します。
          </p><p>
            失敗したログイントラッキングをリセットし (またはサーバーが <code class="option">--skip-grant-tables</code> で起動された場合は有効にします)、一時的にロックされたアカウントのロックを解除します。 <a class="xref" href="security.html#password-management" title="6.2.15 パスワード管理">セクション6.2.15「パスワード管理」</a>を参照してください。 
          </p><p>
            <code class="literal">GRANT</code>, <code class="literal">CREATE USER</code>, <code class="literal">CREATE SERVER</code> および <code class="literal">INSTALL PLUGIN</code> ステートメントの結果としてサーバーによってキャッシュされたメモリーを解放します。 このメモリーは、対応する <code class="literal">REVOKE</code>, <code class="literal">DROP USER</code>, <code class="literal">DROP SERVER</code> ステートメントおよび <code class="literal">UNINSTALL PLUGIN</code> ステートメントによって解放されないため、キャッシュを引き起こすステートメントの多くのインスタンスを実行するサーバーでは、<code class="literal">FLUSH PRIVILEGES</code> で解放されないかぎり、キャッシュされたメモリーの使用量が増加します。 
          </p><p>
            <code class="literal">caching_sha2_password</code> 認証プラグインで使用されるインメモリーキャッシュをクリアします。 <a class="xref" href="security.html#caching-sha2-pluggable-authentication-cache-operation" title="SHA-2 プラガブル認証のキャッシュ操作">SHA-2 プラガブル認証のキャッシュ操作</a>を参照してください。 
          </p></li><li class="listitem"><p><a name="flush-relay-logs"></a>
            <code class="literal">FLUSH RELAY LOGS [FOR CHANNEL <em class="replaceable"><code>channel</code></em>]</code>
          </p><p>
            サーバーが書き込んでいるリレーログファイルを閉じてから再度開きます。 リレーロギングが有効になっている場合、リレーログファイルのシーケンス番号は、前のファイルを基準にして 1 ずつ増分されます。 
          </p><p>
            この操作には、<code class="literal">RELOAD</code> 権限が必要です。
          </p><p>
            <code class="literal">FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> 句を使用すると、操作を適用するレプリケーションチャネルの名前を指定できます。 <code class="literal">FLUSH RELAY LOGS FOR CHANNEL <em class="replaceable"><code>channel</code></em></code> を実行して、特定のレプリケーションチャネルのリレーログをフラッシュします。 チャネルが指定されておらず、追加のレプリケーションチャネルが存在しない場合、操作はデフォルトチャネルに適用されます。 チャネルが指定されておらず、複数のレプリケーションチャネルが存在する場合、操作はすべてのレプリケーションチャネルに適用されます。 詳細は、<a class="xref" href="replication.html#replication-channels" title="17.2.2 レプリケーションチャネル">セクション17.2.2「レプリケーションチャネル」</a>を参照してください。 
          </p></li><li class="listitem"><p><a name="flush-slow-logs"></a>
            <code class="literal">FLUSH SLOW LOGS</code>
          </p><p>
            サーバーが書き込んでいるスロークエリーログファイルを閉じてから再度開きます。
          </p><p>
            この操作には、<code class="literal">RELOAD</code> 権限が必要です。
          </p><p>
            この操作は、スロークエリーログに使用されるテーブルには影響しません (<a class="xref" href="server-administration.html#log-destinations" title="5.4.1 一般クエリーログおよびスロークエリーログの出力先の選択">セクション5.4.1「一般クエリーログおよびスロークエリーログの出力先の選択」</a> を参照)。
          </p></li><li class="listitem"><p><a name="flush-status"></a>
            <code class="literal">FLUSH STATUS</code>
          </p><p>
            ステータスインジケータをフラッシュします。
          </p><p>
            この操作には、<code class="literal">FLUSH_STATUS</code> または <code class="literal">RELOAD</code> 権限が必要です。
          </p><p>
            この操作により、すべてのアクティブセッションのセッションステータスがグローバルステータス変数に追加され、すべてのアクティブセッションのステータスがリセットされ、切断されたセッションから集計されたアカウント、ホストおよびユーザーステータス値がリセットされます。 <a class="xref" href="performance-schema.html#performance-schema-status-variable-tables" title="27.12.15 パフォーマンススキーマのステータス変数のテーブル">セクション27.12.15「パフォーマンススキーマのステータス変数のテーブル」</a>を参照してください。 この情報は、クエリーのデバッグ時に使用できます。 <a class="xref" href="introduction.html#bug-reports" title="1.6 質問またはバグをレポートする方法">セクション1.6「質問またはバグをレポートする方法」</a>を参照してください。 
          </p></li><li class="listitem"><p><a name="flush-user-resources"></a>
            <code class="literal">FLUSH USER_RESOURCES</code>
          </p><p>
            時間当たりのすべてのユーザーリソースインジケータをゼロにリセットします。
          </p><p>
            この操作には、<code class="literal">FLUSH_USER_RESOURCES</code> または <code class="literal">RELOAD</code> 権限が必要です。
          </p><p>
            リソースインジケータをリセットすると、毎時の接続、クエリーまたは更新の制限に達したクライアントは、アクティビティをすぐに再開できます。 <code class="literal">FLUSH USER_RESOURCES</code> は、<code class="literal">max_user_connections</code> システム変数によって制御される同時接続の最大数の制限には適用されません。 <a class="xref" href="security.html#user-resources" title="6.2.20 アカウントリソース制限の設定">セクション6.2.20「アカウントリソース制限の設定」</a>を参照してください。 
          </p></li></ul></div><h5><a name="flush-tables-variants"></a>FLUSH TABLES 構文</h5><p>
        <code class="literal">FLUSH TABLES</code> はテーブルをフラッシュし、使用されているバリアントに応じてロックを取得します。 <code class="literal">FLUSH</code> ステートメントで使用される <code class="literal">TABLES</code> バリアントは、使用される唯一のオプションである必要があります。 <code class="literal">FLUSH TABLE</code> は、<code class="literal">FLUSH TABLES</code> のシノニムです。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          ここでは、テーブルを閉じることによってフラッシュされることを示す説明は、テーブルの内容をディスクにフラッシュし、開いたままにする <code class="literal">InnoDB</code> には異なる方法で適用されます。 これにより、他のアクティビティによって変更されないかぎり、テーブルが開いている間もテーブルファイルをコピーできます。 
        </p></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="flush-tables"></a>
            <code class="literal">FLUSH TABLES</code>
          </p><p>
            オープンしているすべてのテーブルをクローズし、使用中のすべてのテーブルを強制的にクローズし、プリペアドステートメントキャッシュをフラッシュします。
          </p><p>
            この操作には、<code class="literal">FLUSH_TABLES</code> または <code class="literal">RELOAD</code> 権限が必要です。
          </p><p>
            プリペアドステートメントキャッシュの詳細は、<a class="xref" href="optimization.html#statement-caching" title="8.10.3 プリペアドステートメントおよびストアドプログラムのキャッシュ">セクション8.10.3「プリペアドステートメントおよびストアドプログラムのキャッシュ」</a> を参照してください。
          </p><p>
            アクティブな <code class="literal">LOCK TABLES ... READ</code> がある場合、<code class="literal">FLUSH TABLES</code> は許可されません。 テーブルをフラッシュしてロックするには、代わりに <code class="literal">FLUSH TABLES <em class="replaceable"><code>tbl_name</code></em> ... WITH READ LOCK</code> を使用します。 
          </p></li><li class="listitem"><p><a name="flush-tables-with-list"></a>
            <code class="literal">FLUSH TABLES <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ...</code>
          </p><p>
            カンマ区切りのテーブル名のリストでは、サーバーが名前付きのテーブルのみをフラッシュする点を除き、この操作は名前のない <code class="literal">FLUSH TABLES</code> に似ています。 指定したテーブルが存在しない場合、エラーは発生しません。 
          </p><p>
            この操作には、<code class="literal">FLUSH_TABLES</code> または <code class="literal">RELOAD</code> 権限が必要です。
          </p></li><li class="listitem"><p><a name="flush-tables-with-read-lock"></a>
            <code class="literal">FLUSH TABLES WITH READ LOCK</code>
          </p><p>
            開かれているすべてのテーブルを閉じ、グローバルな読み取りロックを保持しているすべてのデータベースのすべてのテーブルをロックします。
          </p><p>
            この操作には、<code class="literal">FLUSH_TABLES</code> または <code class="literal">RELOAD</code> 権限が必要です。
          </p><p>
            この操作は、時間内にスナップショットを取得できる Veritas や ZFS などのファイルシステムがある場合に、バックアップを取得するための非常に便利な方法です。 このロックを解放するには、<code class="literal">UNLOCK TABLES</code> を使用します。 
          </p><p>
            <code class="literal">FLUSH TABLES WITH READ LOCK</code> は、テーブルロックではなくグローバル読取りロックを取得するため、テーブルロックおよび暗黙的コミットに関して <code class="literal">LOCK TABLES</code> および <code class="literal">UNLOCK TABLES</code> と同じ動作を受けません:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">UNLOCK TABLES</code> は、現在 <code class="literal">LOCK TABLES</code> でロックされているテーブルがある場合にのみ、アクティブなトランザクションをすべて暗黙的にコミットします。 <code class="literal">FLUSH TABLES WITH READ LOCK</code> はテーブルロックを取得しないため、このステートメントに続く <code class="literal">UNLOCK TABLES</code> に対してコミットは発生しません。 
              </p></li><li class="listitem"><p>
                トランザクションを開始すると、ユーザーが <code class="literal">UNLOCK TABLES</code> を実行したかのように、<code class="literal">LOCK TABLES</code> によって取得されたテーブルロックが解放されます。 トランザクションを開始しても、<code class="literal">FLUSH TABLES WITH READ LOCK</code> によって取得されたグローバルな読み取りロックは解放されません。 
              </p></li></ul></div><p>
            <code class="literal">FLUSH TABLES WITH READ LOCK</code> では、サーバーがログテーブルに行を挿入することは妨げられません (<a class="xref" href="server-administration.html#log-destinations" title="5.4.1 一般クエリーログおよびスロークエリーログの出力先の選択">セクション5.4.1「一般クエリーログおよびスロークエリーログの出力先の選択」</a>を参照してください)。
          </p></li><li class="listitem"><p><a name="flush-tables-with-read-lock-with-list"></a>
            <code class="literal">FLUSH TABLES <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ... WITH READ LOCK</code>
          </p><p>
            指定されたテーブルの読取りロックをフラッシュおよび取得します。
          </p><p>
            この操作には、<code class="literal">FLUSH_TABLES</code> または <code class="literal">RELOAD</code> 権限が必要です。 テーブルロックを取得するため、各テーブルに対する <code class="literal">LOCK TABLES</code> 権限も必要です。 
          </p><p>
            この操作では、最初にテーブルの排他的メタデータロックが取得されるため、これらのテーブルが開いているトランザクションが完了するまで待機します。 次に、操作によってテーブルキャッシュからテーブルがフラッシュされ、テーブルが再オープンされ、テーブルロック (<code class="literal">LOCK TABLES ... READ</code> など) が取得され、メタデータロックが排他から共有にダウングレードされます。 操作によってロックが取得され、メタデータロックがダウングレードされた後、他のセッションはテーブルの読取りはできますが、変更はできません。 
          </p><p>
            この操作は、既存の実テーブル (<code class="literal">TEMPORARY) </code>以外のテーブル) にのみ適用されます。 名前がベーステーブルを参照している場合は、そのテーブルが使用されます。 <code class="literal">TEMPORARY</code> テーブルを参照している場合、その名前は無視されます。 名前がビューに適用される場合は、<code class="literal">ER_WRONG_OBJECT</code> エラーが発生します。 それ以外の場合は、<code class="literal">ER_NO_SUCH_TABLE</code> エラーが発生します。 
          </p><p>
            ロックを解放するには <code class="literal">UNLOCK TABLES</code> を、ロックを解放し、ほかのロックを取得するには <code class="literal">LOCK TABLES</code> を、またはロックを解放し、新しいトランザクションを開始するには <code class="literal">START TRANSACTION</code> を使用します。
          </p><p>
            この <code class="literal">FLUSH TABLES</code> バリアントを使用すると、単一の操作でテーブルをフラッシュおよびロックできます。 これにより、アクティブな <code class="literal">LOCK TABLES ... READ</code> がある場合に <code class="literal">FLUSH TABLES</code> が許可されないという制限の回避策が提供されます。 
          </p><p>
            この操作では暗黙的な <code class="literal">UNLOCK TABLES</code> は実行されないため、アクティブな <code class="literal">LOCK TABLES</code> がある間に操作を実行するか、最初に取得したロックを解放せずに再度使用すると、エラーが発生します。
          </p><p>
            フラッシュされたテーブルが <code class="literal">HANDLER</code> で開かれた場合、そのハンドラは暗黙的にフラッシュされ、その位置を失います。
          </p></li><li class="listitem"><p><a name="flush-tables-for-export-with-list"></a>
            <code class="literal">FLUSH TABLES <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ... FOR EXPORT</code>
          </p><p>
            この <code class="literal">FLUSH TABLES</code> バリアントは、<code class="literal">InnoDB</code> テーブルに適用されます。 これにより、指定されたテーブルへの変更がディスクにフラッシュされ、サーバーの実行中にバイナリテーブルのコピーを作成できるようになります。 
          </p><p>
            この操作には、<code class="literal">FLUSH_TABLES</code> または <code class="literal">RELOAD</code> 権限が必要です。 エクスポートの準備としてテーブルのロックを取得するため、テーブルごとに <code class="literal">LOCK TABLES</code> および <code class="literal">SELECT</code> 権限も必要です。 
          </p><p>
            この操作は次のように機能します:
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                指定されたテーブルに対する共有メタデータロックを取得します。 他のセッションに、それらのテーブルを変更したアクティブなトランザクションがあるか、それらのテーブルのロックを保持しているかぎり、操作はブロックされます。 ロックが取得されると、読取り専用操作の続行を許可しながら、テーブルの更新を試行するトランザクションがブロックされます。 
              </p></li><li class="listitem"><p>
                これらのテーブルのすべてのストレージエンジンが <code class="literal">FOR EXPORT</code> をサポートしているかどうかをチェックします。 存在しない場合は、<code class="literal">ER_ILLEGAL_HA</code> エラーが発生し、操作は失敗します。 
              </p></li><li class="listitem"><p>
                この操作は、各テーブルのストレージエンジンに、テーブルをエクスポートできるように通知します。 そのストレージエンジンは、保留中の変更がすべてディスクに書き込まれるようにする必要があります。 
              </p></li><li class="listitem"><p>
                この操作によってセッションがロックテーブルモードになり、以前に取得したメタデータロックが <code class="literal">FOR EXPORT</code> 操作の完了時に解放されなくなります。
              </p></li></ol></div><p>
            この操作は、既存の (<code class="literal">TEMPORARY</code> 以外の) 実テーブルにのみ適用されます。 名前がベーステーブルを参照している場合は、そのテーブルが使用されます。 <code class="literal">TEMPORARY</code> テーブルを参照している場合、その名前は無視されます。 名前がビューに適用される場合は、<code class="literal">ER_WRONG_OBJECT</code> エラーが発生します。 それ以外の場合は、<code class="literal">ER_NO_SUCH_TABLE</code> エラーが発生します。 
          </p><p>
            <code class="literal">InnoDB</code> は、独自の <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル"><code class="filename">.ibd</code> file</a> ファイル (<code class="literal">innodb_file_per_table</code> 設定を有効にして作成されたテーブル) を持つテーブルに対して <code class="literal">FOR EXPORT</code> をサポートしています。 <code class="literal">InnoDB</code> では、<code class="literal">FOR EXPORT</code> 操作によって変更がディスクにフラッシュされたことが通知されます。 これにより、<code class="filename">.ibd</code> ファイルはトランザクションの一貫性があり、サーバーの実行中にコピーできるため、<code class="literal">FOR EXPORT</code> 操作が有効な間にテーブルの内容のバイナリコピーを作成できます。 <code class="literal">FOR EXPORT</code> は、<code class="literal">InnoDB</code> システムテーブルスペースファイル、または <code class="literal">FULLTEXT</code> インデックスを持つ <code class="literal">InnoDB</code> テーブルには適用されません。 
          </p><p>
            <code class="literal">FLUSH TABLES ...FOR EXPORT</code> は、パーティション化された <code class="literal">InnoDB</code> テーブルでサポートされています。
          </p><p>
            <code class="literal">FOR EXPORT</code> から通知されると、<code class="literal">InnoDB</code> は、通常はメモリー内か、またはテーブルスペースファイルの外部にある個別のディスクバッファーに保持される特定の種類のデータをディスクに書き込みます。 <code class="literal">InnoDB</code> はまた、テーブルごとに、そのテーブルと同じデータベースディレクトリ内に <code class="filename"><em class="replaceable"><code>table_name</code></em>.cfg</code> という名前のファイルも生成します。 <code class="filename">.cfg</code> ファイルには、あとでテーブルスペースファイルを同じサーバーまたは別のサーバーに再インポートするために必要なメタデータが含まれています。 
          </p><p>
            <code class="literal">FOR EXPORT</code> 操作が完了すると、<code class="literal">InnoDB</code> はすべての <a class="link" href="glossary.html#glos_dirty_page" title="ダーティーページ">dirty pages</a> をテーブルデータファイルにフラッシュしました。 <a class="link" href="glossary.html#glos_change_buffer" title="変更バッファー">変更バッファー</a>のエントリはすべて、フラッシュの前にマージされます。 この時点で、テーブルはロックされ、静止します。これらのテーブルはディスク上でトランザクション的に一貫性のある状態にあるため、<code class="filename">.ibd</code> テーブルスペースファイルを対応する <code class="filename">.cfg</code> ファイルとともにコピーすることによって、これらのテーブルの整合性のあるスナップショットを取得できます。 
          </p><p>
            コピーされたテーブルデータを MySQL インスタンスに再インポートする手順については、<a class="xref" href="innodb-storage-engine.html#innodb-table-import" title="15.6.1.3 InnoDB テーブルのインポート">セクション15.6.1.3「InnoDB テーブルのインポート」</a>を参照してください。
          </p><p>
            テーブルの処理を完了したあと、ロックを解放するには <code class="literal">UNLOCK TABLES</code> を、ロックを解放し、ほかのロックを取得するには <code class="literal">LOCK TABLES</code> を、またはロックを解放し、新しいトランザクションを開始するには <code class="literal">START TRANSACTION</code> を使用します。
          </p><p>
            セッション内で次のいずれかのステートメントが有効になっている間は、<code class="literal">FLUSH TABLES ... FOR EXPORT</code> を使用しようとするとエラーが生成されます。
          </p><pre class="programlisting">FLUSH TABLES ... WITH READ LOCK
FLUSH TABLES ... FOR EXPORT
LOCK TABLES ... READ
LOCK TABLES ... WRITE
</pre><p>
            セッション内で <code class="literal">FLUSH TABLES ... FOR EXPORT</code> が有効になっている間は、次のいずれかのステートメントを使用しようとするとエラーが生成されます。
          </p><pre class="programlisting">FLUSH TABLES WITH READ LOCK
FLUSH TABLES ... WITH READ LOCK
FLUSH TABLES ... FOR EXPORT
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="kill"></a>13.7.8.4 KILL ステートメント</h4></div></div></div><a class="indexterm" name="idm45826985747088"></a><a class="indexterm" name="idm45826985745616"></a><pre class="programlisting">KILL [CONNECTION | QUERY] <em class="replaceable"><code>processlist_id</code></em>
</pre><p>
        <span class="command"><strong>mysqld</strong></span> への各接続は、個別のスレッドで実行されます。 スレッドは、<code class="literal">KILL <em class="replaceable"><code>processlist_id</code></em></code> ステートメントで強制終了できます。 
      </p><p>
        スレッドプロセッスリスト識別子は、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">PROCESSLIST</code> テーブルの <code class="literal">ID</code> カラム、<code class="literal">SHOW PROCESSLIST</code> 出力の <code class="literal">Id</code> カラム、およびパフォーマンススキーマ <code class="literal">threads</code> テーブルの <code class="literal">PROCESSLIST_ID</code> カラムから決定できます。 現在のスレッドの値は、<code class="literal">CONNECTION_ID()</code> 関数によって返されます。 
      </p><p>
        <code class="literal">KILL</code> では、オプションの <code class="literal">CONNECTION</code> または <code class="literal">QUERY</code> 修飾子が許可されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">KILL CONNECTION</code> は修飾子のない <code class="literal">KILL</code> と同じです: 接続が実行されているステートメントを終了すると、指定された <em class="replaceable"><code>processlist_id</code></em> に関連付けられている接続が終了します。
          </p></li><li class="listitem"><p>
            <code class="literal">KILL QUERY</code> は、接続が現在実行されているステートメントを終了しますが、接続自体はそのままになります。
          </p></li></ul></div><p>
        強制終了できるスレッドを表示できるかどうかは、<code class="literal">PROCESS</code> 権限によって異なります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">PROCESS</code> がない場合は、自分のスレッドのみを表示できます。
          </p></li><li class="listitem"><p>
            <code class="literal">PROCESS</code> では、すべてのスレッドを表示できます。
          </p></li></ul></div><p>
        スレッドおよびステートメントを強制終了できるかどうかは、<code class="literal">CONNECTION_ADMIN</code> 権限および非推奨の <code class="literal">SUPER</code> 権限によって異なります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CONNECTION_ADMIN</code> または <code class="literal">SUPER</code> がない場合は、独自のスレッドおよびステートメントのみを強制終了できます。
          </p></li><li class="listitem"><p>
            <code class="literal">CONNECTION_ADMIN</code> または <code class="literal">SUPER</code> を使用すると、<code class="literal">SYSTEM_USER</code> 権限で実行されているスレッドまたはステートメントに影響を与える場合を除き、すべてのスレッドおよびステートメントを強制終了できます。独自のセッションには、<code class="literal">SYSTEM_USER</code> 権限も必要です。
          </p></li></ul></div><p>
        <span class="command"><strong>mysqladmin processlist</strong></span> および <span class="command"><strong>mysqladmin kill</strong></span> コマンドを使用して、スレッドを検査および強制終了することもできます。
      </p><p>
        <code class="literal">KILL</code> を使用すると、そのスレッドのスレッド固有の強制終了フラグが設定されます。 強制終了フラグは次の一定の間隔でしかチェックされないため、ほとんどの場合、スレッドが終了するまでにある程度時間がかかることがあります。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">SELECT</code> 操作中、<code class="literal">ORDER BY</code> および <code class="literal">GROUP BY</code> ループでは、このフラグは行ブロックの読み取りのあとにチェックされます。 強制終了フラグが設定されている場合、このステートメントは中止されます。 
          </p></li><li class="listitem"><p>
            テーブルのコピーを作成する <code class="literal">ALTER TABLE</code> 操作では、元のテーブルから読み取られたいくつかのコピーされた行について、強制終了フラグが定期的にチェックされます。 強制終了フラグが設定されていた場合、このステートメントは中止され、一時テーブルが削除されます。 
          </p><p>
            <code class="literal">KILL</code> ステートメントは確認を待機せずに戻りますが、強制終了フラグチェックにより、妥当な時間内に操作が中断されます。 必要なクリーンアップを実行する操作を中止するには、時間もかかります。 
          </p></li><li class="listitem"><p>
            <code class="literal">UPDATE</code> または <code class="literal">DELETE</code> 操作中、強制終了フラグは、ブロックが読み取られるたび、および行が更新または削除されるたびにチェックされます。 強制終了フラグが設定されている場合、このステートメントは中止されます。 トランザクションを使用していない場合、変更はロールバックされません。 
          </p></li><li class="listitem"><p>
            <code class="literal">GET_LOCK()</code> は中止され、<code class="literal">NULL</code> を返します。
          </p></li><li class="listitem"><p>
            このスレッドがテーブルロックハンドラ内にある場合 (状態: <code class="literal">Locked</code>)、そのテーブルロックはすばやく中止されます。
          </p></li><li class="listitem"><p>
            このスレッドが書き込みコールでディスクの空き容量を待機している場合、その書き込みは<span class="quote">「<span class="quote">ディスク領域不足</span>」</span>というエラーメッセージで中止されます。
          </p></li><li class="listitem"><p>
            <code class="literal">EXPLAIN ANALYZE</code> は異常終了し、出力の最初の行を出力します。 これは、MySQL 8.0.20 以降で機能します。 
          </p></li></ul></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          <code class="literal">MyISAM</code> テーブルに対する <code class="literal">REPAIR TABLE</code> または <code class="literal">OPTIMIZE TABLE</code> 操作を強制終了すると、テーブルが破損して使用できなくなります。 このようなテーブルに対する読み取りまたは書き込みはすべて、そのテーブルをふたたび最適化または修復するまで失敗します (割り込みはなし)。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="load-index"></a>13.7.8.5 LOAD INDEX INTO CACHE ステートメント</h4></div></div></div><pre class="programlisting">LOAD INDEX INTO CACHE
  <em class="replaceable"><code>tbl_index_list</code></em> [, <em class="replaceable"><code>tbl_index_list</code></em>] ...

<em class="replaceable"><code>tbl_index_list</code></em>:
  <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_list</code></em>)]
    [{INDEX|KEY} (<em class="replaceable"><code>index_name</code></em>[, <em class="replaceable"><code>index_name</code></em>] ...)]
    [IGNORE LEAVES]

<em class="replaceable"><code>partition_list</code></em>: {
    <em class="replaceable"><code>partition_name</code></em>[, <em class="replaceable"><code>partition_name</code></em>] ...
  | ALL
}
</pre><p>
        <code class="literal">LOAD INDEX INTO CACHE</code> ステートメントは、明示的な <code class="literal">CACHE INDEX</code> ステートメントによって割り当てられたキーキャッシュ、またはそれ以外の場合はデフォルトのキーキャッシュにテーブルインデックスをプリロードします。
      </p><p>
        <code class="literal">LOAD INDEX INTO CACHE</code> は、パーティション化された <code class="literal">MyISAM</code> テーブルを含む <code class="literal">MyISAM</code> テーブルにのみ適用されます。 また、パーティションテーブルのインデックスは、1 つ、複数またはすべてのパーティションに対して事前ロードできます。 
      </p><p>
        <code class="literal">IGNORE LEAVES</code> 修飾子によって、インデックスの非リーフノードのブロックのみがプリロードされます。
      </p><p>
        <code class="literal">IGNORE LEAVES</code> は、パーティション化された <code class="literal">MyISAM</code> テーブルに対してもサポートされます。
      </p><p>
        次のステートメントは、テーブル <code class="literal">t1</code> と <code class="literal">t2</code> のインデックスのノード (インデックスブロック) をプリロードします。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>LOAD INDEX INTO CACHE t1, t2 IGNORE LEAVES;</code></strong>
+---------+--------------+----------+----------+
| Table   | Op           | Msg_type | Msg_text |
+---------+--------------+----------+----------+
| test.t1 | preload_keys | status   | OK       |
| test.t2 | preload_keys | status   | OK       |
+---------+--------------+----------+----------+
</pre><p>
        このステートメントは、<code class="literal">t1</code> からすべてのインデックスブロックをプリロードします。 <code class="literal">t2</code> からは、非リーフノードのブロックのみをプリロードします。 
      </p><p>
        <code class="literal">LOAD INDEX INTO CACHE</code> の構文では、テーブルの特定のインデックスのみをプリロードするように指定できます。 ただし、実装ではすべてのテーブルインデックスがキャッシュに事前ロードされるため、テーブル名以外は指定する必要はありません。 
      </p><p>
        パーティション化された <code class="literal">MyISAM</code> テーブルの特定のパーティションでインデックスを事前ロードできます。 たとえば、次の 2 つのステートメントでは、最初が、パーティション化されたテーブル <code class="literal">pt</code> のパーティション <code class="literal">p0</code> のインデックスをプリロードするのに対して、2 番目は同じテーブルのパーティション <code class="literal">p1</code> と <code class="literal">p3</code> のインデックスをプリロードします。 
      </p><pre class="programlisting">LOAD INDEX INTO CACHE pt PARTITION (p0);
LOAD INDEX INTO CACHE pt PARTITION (p1, p3);
</pre><p>
        テーブル <code class="literal">pt</code> のすべてのパーティションのインデックスを事前ロードするには、次のいずれかのステートメントを使用します:
      </p><pre class="programlisting">LOAD INDEX INTO CACHE pt PARTITION (ALL);

LOAD INDEX INTO CACHE pt;
</pre><p>
        ここで示した 2 つのステートメントは同等であり、どちらか一方を発行してもまったく同じ効果があります。 つまり、パーティションテーブルのすべてのパーティションのインデックスを事前ロードする場合、<code class="literal">PARTITION (ALL)</code> 句はオプションです。 
      </p><p>
        複数のパーティションのインデックスを事前ロードする場合、パーティションは連続している必要はなく、パーティション名を特定の順序でリストする必要はありません。
      </p><p>
        <code class="literal">LOAD INDEX INTO CACHE ... IGNORE LEAVES</code> は、テーブル内のすべてのインデックスのブロックサイズが同じでないかぎり失敗します。 テーブルのインデックスブロックサイズを決定するには、<span class="command"><strong>myisamchk -dv</strong></span> を使用して <code class="literal">Blocksize</code> カラムを確認します。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="reset"></a>13.7.8.6 RESET ステートメント</h4></div></div></div><a class="indexterm" name="idm45826985632192"></a><a class="indexterm" name="idm45826985630704"></a><pre class="programlisting">RESET <em class="replaceable"><code>reset_option</code></em> [, <em class="replaceable"><code>reset_option</code></em>] ...

<em class="replaceable"><code>reset_option</code></em>: {
    MASTER
  | REPLICA
  | SLAVE
}
</pre><p>
        <code class="literal">RESET</code> ステートメントは、さまざまなサーバー操作の状態をクリアするために使用されます。 <code class="literal">RESET</code> を実行するには、<code class="literal">RELOAD</code> 権限が必要です。 
      </p><p>
        永続的なグローバルシステム変数を削除する <code class="literal">RESET PERSIST</code> ステートメントの詳細は、<a class="xref" href="sql-statements.html#reset-persist" title="13.7.8.7 RESET PERSIST ステートメント">セクション13.7.8.7「RESET PERSIST ステートメント」</a> を参照してください。
      </p><p>
        <code class="literal">RESET</code> は、<code class="literal">FLUSH</code> ステートメントのより強力なバージョンとして機能します。 <a class="xref" href="sql-statements.html#flush" title="13.7.8.3 FLUSH ステートメント">セクション13.7.8.3「FLUSH ステートメント」</a>を参照してください。 
      </p><p>
        <code class="literal">RESET</code> ステートメントは暗黙的なコミットを発生させます。 <a class="xref" href="sql-statements.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。 
      </p><p>
        次のリストに、許可される <code class="literal">RESET</code> ステートメントの <em class="replaceable"><code>reset_option</code></em> 値を示します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">RESET MASTER</code>
          </p><p>
            インデックスファイルにリストされているすべてのバイナリログを削除し、バイナリログインデックスファイルを空にリセットして、新しいバイナリログファイルを作成します。
          </p></li><li class="listitem"><p>
            <code class="literal">RESET REPLICA | SLAVE</code>
          </p><p>
            レプリカがソースバイナリログ内のレプリケーション位置を忘れられるようにします。 また、既存のリレーログファイルをすべて削除し、新しいリレーログファイルを開始することによってリレーログもリセットします。 MySQL 8.0.22 の <code class="literal">RESET SLAVE</code> のかわりに <code class="literal">RESET REPLICA</code> を使用します。 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="reset-persist"></a>13.7.8.7 RESET PERSIST ステートメント</h4></div></div></div><a class="indexterm" name="idm45826985601984"></a><a class="indexterm" name="idm45826985600496"></a><a class="indexterm" name="idm45826985599056"></a><pre class="programlisting">RESET PERSIST [[IF EXISTS] <em class="replaceable"><code>system_var_name</code></em>]
</pre><p>
        <code class="literal">RESET PERSIST</code> は、永続化されたグローバルシステム変数設定をデータディレクトリの <code class="filename">mysqld-auto.cnf</code> オプションファイルから削除します。 永続化されたシステム変数を削除すると、その変数はサーバーの起動時に <code class="filename">mysqld-auto.cnf</code> から初期化されなくなります。 システム変数および <code class="filename">mysqld-auto.cnf</code> ファイルの永続化の詳細は、<a class="xref" href="server-administration.html#persisted-system-variables" title="5.1.9.3 永続化されるシステム変数">セクション5.1.9.3「永続化されるシステム変数」</a> を参照してください。 
      </p><p>
        <code class="literal">RESET PERSIST</code> に必要な権限は、削除するシステム変数のタイプによって異なります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            動的システム変数の場合、このステートメントには <code class="literal">SYSTEM_VARIABLES_ADMIN</code> 権限 (または非推奨の <code class="literal">SUPER</code> 権限) が必要です。
          </p></li><li class="listitem"><p>
            読取り専用システム変数の場合、このステートメントには <code class="literal">SYSTEM_VARIABLES_ADMIN</code> および <code class="literal">PERSIST_RO_VARIABLES_ADMIN</code> 権限が必要です。
          </p></li></ul></div><p>
        <a class="xref" href="server-administration.html#system-variable-privileges" title="5.1.9.1 システム変数権限">セクション5.1.9.1「システム変数権限」</a>を参照してください。
      </p><p>
        変数名と <code class="literal">IF EXISTS</code> 句が存在するかどうかに応じて、<code class="literal">RESET PERSIST</code> ステートメントの形式は次のようになります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="filename">mysqld-auto.cnf</code> からすべての永続変数を削除するには、システム変数に名前を付けずに <code class="literal">RESET PERSIST</code> を使用します:
          </p><pre class="programlisting">RESET PERSIST;
</pre><p>
            <code class="filename">mysqld-auto.cnf</code> に両方の種類の変数が含まれている場合は、動的システム変数と読取り専用システム変数の両方を削除する権限が必要です。
          </p></li><li class="listitem"><p>
            <code class="filename">mysqld-auto.cnf</code> から特定の永続変数を削除するには、ステートメントで名前を付けます:
          </p><pre class="programlisting">RESET PERSIST <em class="replaceable"><code>system_var_name</code></em>;
</pre><p>
            これには、プラグインが現在インストールされていない場合でも、プラグインシステム変数が含まれます。 変数がファイルに存在しない場合は、エラーが発生します。 
          </p></li><li class="listitem"><p>
            <code class="filename">mysqld-auto.cnf</code> から特定の永続変数を削除し、ファイルに変数が存在しない場合にエラーではなく警告を生成するには、前の構文に <code class="literal">IF EXISTS</code> 句を追加します:
          </p><pre class="programlisting">RESET PERSIST IF EXISTS <em class="replaceable"><code>system_var_name</code></em>;
</pre></li></ul></div><p>
        <code class="literal">RESET PERSIST</code> は、<code class="literal">persisted_globals_load</code> システム変数の値の影響を受けません。
      </p><p>
        テーブルの内容は <code class="filename">mysqld-auto.cnf</code> ファイルの内容に対応しているため、<code class="literal">RESET PERSIST</code> はパフォーマンススキーマ <code class="literal">persisted_variables</code> テーブルの内容に影響します。 一方、<code class="literal">RESET PERSIST</code> は変数値を変更しないため、サーバーが再起動されるまでパフォーマンススキーマ <code class="literal">variables_info</code> テーブルの内容には影響しません。 
      </p><p>
        ほかのサーバー操作の状態をクリアする <code class="literal">RESET</code> ステートメントのバリアントについては、<a class="xref" href="sql-statements.html#reset" title="13.7.8.6 RESET ステートメント">セクション13.7.8.6「RESET ステートメント」</a> を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="restart"></a>13.7.8.8 RESTART ステートメント</h4></div></div></div><a class="indexterm" name="idm45826985551328"></a><pre class="programlisting">RESTART
</pre><p>
        このステートメントは、MySQL サーバーを停止して再起動します。 <code class="literal">SHUTDOWN</code> 権限が必要です。 
      </p><p>
        <code class="literal">RESTART</code> の使用例としては、サーバーホスト上の MySQL サーバーを再起動するためのコマンドラインアクセスが不可能な場合や便利な場合があります。 たとえば、<code class="literal">SET PERSIST_ONLY</code> を実行時に使用して、サーバーの起動時にのみ設定できるシステム変数に構成変更を加えることができますが、これらの変更を有効にするには、サーバーを再起動する必要があります。 <code class="literal">RESTART</code> ステートメントは、サーバーホストでのコマンド行アクセスを必要とせずに、クライアントセッション内からこれを実行する方法を提供します。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">RESTART</code> ステートメントの実行後、クライアントは現在の接続が失われることを期待できます。 自動再接続が有効な場合、サーバーの再起動後に接続が再確立されます。 それ以外の場合は、接続を手動で再確立する必要があります。 
        </p></div><p>
        <code class="literal">RESTART</code> 操作が成功するには、再起動のために実行されたサーバーの停止を検出するための監視プロセスが使用可能な環境で <span class="command"><strong>mysqld</strong></span> が実行されている必要があります:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            モニタリングプロセスが存在する場合、<code class="literal">RESTART</code> は、モニタリングプロセスが新しい <span class="command"><strong>mysqld</strong></span> インスタンスを起動する必要があると判断できるように <span class="command"><strong>mysqld</strong></span> を終了させます。
          </p></li><li class="listitem"><p>
            監視プロセスが存在しない場合、<code class="literal">RESTART</code> はエラーで失敗します。
          </p></li></ul></div><p>
        これらのプラットフォームは、<code class="literal">RESTART</code> ステートメントに必要な監視サポートを提供します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            Windows (<span class="command"><strong>mysqld</strong></span> が Windows サービスまたはスタンドアロンとして起動された場合)。(<span class="command"><strong>mysqld</strong></span> がフォークし、一方のプロセスが他方のプロセスのモニターとして機能し、サーバーとして機能します。)
          </p></li><li class="listitem"><p>
            systemd または <span class="command"><strong>mysqld_safe</strong></span> を使用して <span class="command"><strong>mysqld</strong></span> を管理する Unix および Unix に似たシステム。
          </p></li></ul></div><p>
        <span class="command"><strong>mysqld</strong></span> で <code class="literal">RESTART</code> ステートメントが有効になるように監視環境を構成するには:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <span class="command"><strong>mysqld</strong></span> を起動する前に、<code class="literal">MYSQLD_PARENT_PID</code> 環境変数を、<span class="command"><strong>mysqld</strong></span> を起動するプロセスのプロセス ID の値に設定します。
          </p></li><li class="listitem"><p>
            <code class="literal">RESTART</code> ステートメントを使用して <span class="command"><strong>mysqld</strong></span> が停止を実行すると、終了コード 16 が返されます。
          </p></li><li class="listitem"><p>
            モニタリングプロセスは、16 の終了コードを検出すると、<span class="command"><strong>mysqld</strong></span> を再起動します。 それ以外の場合は終了します。 
          </p></li></ol></div><p>
        <span class="command"><strong>bash</strong></span> Shell に実装されている最小限の例を次に示します:
      </p><pre class="programlisting">#!/bin/bash

export MYSQLD_PARENT_PID=$$

export MYSQLD_RESTART_EXIT=16

while true ; do
  bin/mysqld <em class="replaceable"><code>mysqld options here</code></em>
  if [ $? -ne $MYSQLD_RESTART_EXIT ]; then
    break
  fi
done
</pre><p>
        Windows では、<code class="literal">RESTART</code> の実装に使用されるフォーキングにより、デバッグを困難にするためにアタッチするサーバープロセスを決定できます。 これを軽減するために、<code class="option">--gdb</code> でサーバーを起動すると、デバッグ環境を設定するために実行されるその他のアクションに加えて、フォーキングが抑制されます。 デバッグ以外の設定では、モニタープロセスの強制を抑制する唯一の目的で <code class="option">--no-monitor</code> を使用できます。 <code class="option">--gdb</code> または <code class="option">--no-monitor</code> を使用して起動されたサーバーの場合、<code class="literal">RESTART</code> を実行すると、サーバーは再起動せずに単に終了します。 
      </p><p>
        <code class="literal">Com_restart</code> ステータス変数は、<code class="literal">RESTART</code> ステートメントの数を追跡します。 ステータス変数はサーバーの起動ごとに初期化され、再起動後も保持されないため、<code class="literal">Com_restart</code> の値は通常ゼロですが、<code class="literal">RESTART</code> ステートメントが実行されたが失敗した場合はゼロ以外にすることができます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="shutdown"></a>13.7.8.9 SHUTDOWN ステートメント</h4></div></div></div><a class="indexterm" name="idm45826985495216"></a><pre class="programlisting">SHUTDOWN
</pre><p>
        このステートメントは、MySQL サーバーを停止します。 <code class="literal">SHUTDOWN</code> 権限が必要です。 
      </p><p>
        <code class="literal">SHUTDOWN</code> には、<span class="command"><strong>mysqladmin shutdown</strong></span> コマンドまたは <code class="literal">mysql_shutdown()</code> C API 関数を使用して使用可能な同じ機能に対する SQL レベルのインタフェースが用意されています。
      </p><p>
        <code class="literal">Com_shutdown</code> ステータス変数は、<code class="literal">SHUTDOWN</code> ステートメントの数を追跡します。 ステータス変数はサーバーの起動ごとに初期化され、再起動後も保持されないため、<code class="literal">Com_shutdown</code> の値は通常ゼロですが、<code class="literal">SHUTDOWN</code> ステートメントが実行されたが失敗した場合はゼロ以外にすることができます。 
      </p><a class="indexterm" name="idm45826985480112"></a><p>
        サーバーを停止する別の方法は、サーバーに <code class="literal">SIGTERM</code> シグナルを送信することです。これは、<code class="literal">root</code> またはサーバープロセスを所有するアカウントによって実行できます。 <code class="literal">SIGTERM</code> を使用すると、サーバーに接続せずにサーバーの停止を実行できます。 <a class="xref" href="programs.html#unix-signal-response" title="4.10 MySQL での Unix シグナル処理">セクション4.10「MySQL での Unix シグナル処理」</a>を参照してください。 
      </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sql-utility-statements"></a>13.8 ユーティリティステートメント</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-statements.html#describe">13.8.1 DESCRIBE ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#explain">13.8.2 EXPLAIN ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#help">13.8.3 HELP ステートメント</a></span></dt><dt><span class="section"><a href="sql-statements.html#use">13.8.4 USE ステートメント</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="describe"></a>13.8.1 DESCRIBE ステートメント</h3></div></div></div><a class="indexterm" name="idm45826985470880"></a><a class="indexterm" name="idm45826985469568"></a><p>
      <code class="literal">DESCRIBE</code> ステートメントと <code class="literal">EXPLAIN</code> ステートメントはシノニムであり、テーブル構造またはクエリー実行計画に関する情報を取得するために使用されます。 詳細は、<a class="xref" href="sql-statements.html#show-columns" title="13.7.7.5 SHOW COLUMNS ステートメント">セクション13.7.7.5「SHOW COLUMNS ステートメント」</a>および<a class="xref" href="sql-statements.html#explain" title="13.8.2 EXPLAIN ステートメント">セクション13.8.2「EXPLAIN ステートメント」</a>を参照してください。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="explain"></a>13.8.2 EXPLAIN ステートメント</h3></div></div></div><a class="indexterm" name="idm45826985462816"></a><a class="indexterm" name="idm45826985461504"></a><pre class="programlisting">{EXPLAIN | DESCRIBE | DESC}
    <em class="replaceable"><code>tbl_name</code></em> [<em class="replaceable"><code>col_name</code></em> | <em class="replaceable"><code>wild</code></em>]

{EXPLAIN | DESCRIBE | DESC}
    [<em class="replaceable"><code>explain_type</code></em>]
    {<em class="replaceable"><code>explainable_stmt</code></em> | FOR CONNECTION <em class="replaceable"><code>connection_id</code></em>}

{EXPLAIN | DESCRIBE | DESC} ANALYZE [FORMAT = TREE] <em class="replaceable"><code>select_statement</code></em>

<em class="replaceable"><code>explain_type</code></em>: {
    FORMAT = <em class="replaceable"><code>format_name</code></em>
}

<em class="replaceable"><code>format_name</code></em>: {
    TRADITIONAL
  | JSON
  | TREE
}

<em class="replaceable"><code>explainable_stmt</code></em>: {
    SELECT statement
  | TABLE statement
  | DELETE statement
  | INSERT statement
  | REPLACE statement
  | UPDATE statement
}
</pre><p>
      <code class="literal">DESCRIBE</code> ステートメントと <code class="literal">EXPLAIN</code> ステートメントはシノニムです。 実際には、<code class="literal">DESCRIBE</code> キーワードがテーブル構造に関する情報を取得するためにより頻繁に使用されるのに対して、<code class="literal">EXPLAIN</code> は、クエリー実行計画 (つまり、MySQL がクエリーをどのように実行するかの説明) を取得するために使用されます。 
    </p><p>
      次の説明では、<code class="literal">DESCRIBE</code> および <code class="literal">EXPLAIN</code> キーワードをそのような用途に従って使用しますが、MySQL パーサーはこれらを完全にシノニムとして処理します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="sql-statements.html#explain-table-structure" title="テーブル構造に関する情報の取得">テーブル構造に関する情報の取得</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#explain-execution-plan" title="実行計画に関する情報の取得">実行計画に関する情報の取得</a></p></li><li class="listitem"><p><a class="xref" href="sql-statements.html#explain-analyze" title="EXPLAIN ANALYZE による情報の取得">EXPLAIN ANALYZE による情報の取得</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="explain-table-structure"></a>テーブル構造に関する情報の取得</h4></div></div></div><p>
        <code class="literal">DESCRIBE</code> は、テーブル内のカラムに関する情報を提供します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>DESCRIBE City;</code></strong>
+------------+----------+------+-----+---------+----------------+
| Field      | Type     | Null | Key | Default | Extra          |
+------------+----------+------+-----+---------+----------------+
| Id         | int(11)  | NO   | PRI | NULL    | auto_increment |
| Name       | char(35) | NO   |     |         |                |
| Country    | char(3)  | NO   | UNI |         |                |
| District   | char(20) | YES  | MUL |         |                |
| Population | int(11)  | NO   |     | 0       |                |
+------------+----------+------+-----+---------+----------------+
</pre><p>
        <code class="literal">DESCRIBE</code> は <code class="literal">SHOW COLUMNS</code> のショートカットです。 これらのステートメントはまた、ビューに関する情報も表示します。 <code class="literal">SHOW COLUMNS</code> の説明では、出力カラムに関してより多くの情報が提供されます。 <a class="xref" href="sql-statements.html#show-columns" title="13.7.7.5 SHOW COLUMNS ステートメント">セクション13.7.7.5「SHOW COLUMNS ステートメント」</a>を参照してください。 
      </p><p>
        デフォルトでは、<code class="literal">DESCRIBE</code> は、そのテーブル内のすべてのカラムに関する情報を表示します。<em class="replaceable"><code>col_name</code></em> (指定されている場合) は、そのテーブル内のカラムの名前です。 この場合、このステートメントは、指定されたカラムの情報のみを表示します。<em class="replaceable"><code>wild</code></em> (指定されている場合) は、パターン文字列です。 SQL <code class="literal">%</code> および<code class="literal">_</code>ワイルドカード文字を含めることができます。 この場合、このステートメントは、その文字列に一致する名前を持つカラムの出力のみを表示します。 スペースやその他の特殊文字が含まれていないかぎり、この文字列を引用符で囲む必要はありません。 
      </p><a class="indexterm" name="idm45826985422720"></a><a class="indexterm" name="idm45826985421232"></a><p>
        <code class="literal">DESCRIBE</code> ステートメントは、Oracle との互換性のために提供されています。
      </p><p>
        また、<code class="literal">SHOW CREATE TABLE</code>、<code class="literal">SHOW TABLE STATUS</code>、および <code class="literal">SHOW INDEX</code> ステートメントでは、テーブルに関する情報も提供されます。 <a class="xref" href="sql-statements.html#show" title="13.7.7 SHOW ステートメント">セクション13.7.7「SHOW ステートメント」</a>を参照してください。 
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="explain-execution-plan"></a>実行計画に関する情報の取得</h4></div></div></div><p>
        <code class="literal">EXPLAIN</code> ステートメントは、MySQL がステートメントをどのように実行するかに関する情報を提供します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">EXPLAIN</code> は、<code class="literal">SELECT</code>, <code class="literal">DELETE</code>, <code class="literal">INSERT</code>, <code class="literal">REPLACE</code> および <code class="literal">UPDATE</code> ステートメントで動作します。 MySQL 8.0.19 以降では、<code class="literal">TABLE</code> ステートメントでも動作します。 
          </p></li><li class="listitem"><p>
            説明可能なステートメントで <code class="literal">EXPLAIN</code> を使用すると、MySQL は、オプティマイザからのステートメント実行プランに関する情報を表示します。 つまり、MySQL はテーブルがどのように、どんな順番で結合されているかに関する情報を含む、ステートメントを処理する方法を説明します。 <code class="literal">EXPLAIN</code> を使用して、実行プラン情報を取得することについては、<a class="xref" href="optimization.html#explain-output" title="8.8.2 EXPLAIN 出力フォーマット">セクション8.8.2「EXPLAIN 出力フォーマット」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">EXPLAIN</code> を説明可能なステートメントではなく <code class="literal">FOR CONNECTION <em class="replaceable"><code>connection_id</code></em></code> とともに使用すると、名前付き接続で実行されているステートメントの実行計画が表示されます。 <a class="xref" href="optimization.html#explain-for-connection" title="8.8.4 名前付き接続の実行計画情報の取得">セクション8.8.4「名前付き接続の実行計画情報の取得」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            説明可能なステートメントの場合、<code class="literal">EXPLAIN</code> は、<code class="literal">SHOW WARNINGS</code> を使用して表示できる追加の実行計画情報を生成します。 <a class="xref" href="optimization.html#explain-extended" title="8.8.3 拡張 EXPLAIN 出力形式">セクション8.8.3「拡張 EXPLAIN 出力形式」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">EXPLAIN</code> は、パーティションテーブルを含むクエリーの調査に役立ちます。 <a class="xref" href="partitioning.html#partitioning-info" title="24.3.5 パーティションに関する情報を取得する">セクション24.3.5「パーティションに関する情報を取得する」</a>を参照してください。 
          </p></li><li class="listitem"><p>
            <code class="literal">FORMAT</code> オプションを使用して、出力形式を選択できます。 <code class="literal">TRADITIONAL</code> は表形式で出力を表示します。 <code class="literal">FORMAT</code> オプションが存在しない場合、これはデフォルトです。 <code class="literal">JSON</code> フォーマットは JSON フォーマットで情報を表示します。 MySQL 8.0.16 以降では、<code class="literal">TREE</code> は <code class="literal">TRADITIONAL</code> 形式よりも正確なクエリー処理の説明を含むツリーのような出力を提供します。これは、ハッシュ結合の使用方法を示す唯一の形式 (<a class="xref" href="optimization.html#hash-joins" title="8.2.1.4 ハッシュ結合の最適化">セクション8.2.1.4「ハッシュ結合の最適化」</a> を参照) であり、<code class="literal">EXPLAIN ANALYZE</code> に常に使用されます。 
          </p></li></ul></div><p>
        <code class="literal">EXPLAIN</code> では、説明されているステートメントの実行に必要な権限と同じ権限が必要です。 また、<code class="literal">EXPLAIN</code> には、説明されているビューに対する <code class="literal">SHOW VIEW</code> 権限も必要です。 指定した接続が別のユーザーに属している場合、<code class="literal">EXPLAIN ... FOR CONNECTION</code> には <code class="literal">PROCESS</code> 権限も必要です。 
      </p><a class="indexterm" name="idm45826985373392"></a><p>
        <code class="literal">EXPLAIN</code> を使用すると、インデックスを使用して行を検索することでステートメントがより高速に実行されるように、テーブルにインデックスを追加する場所を確認できます。 また、<code class="literal">EXPLAIN</code> を使用して、オプティマイザがテーブルを最適な順序で結合しているかどうかを確認することもできます。 <code class="literal">SELECT</code> ステートメントでテーブルが指定されている順序に対応する結合順序を使用するように、オプティマイザにヒントを提供するには、ステートメントを <code class="literal">SELECT</code> だけでなく、<code class="literal">SELECT STRAIGHT_JOIN</code> で始めます。 (<a class="xref" href="sql-statements.html#select" title="13.2.10 SELECT ステートメント">セクション13.2.10「SELECT ステートメント」</a>を参照してください。) 
      </p><p>
        オプティマイザトレースは、<code class="literal">EXPLAIN</code> のトレースを補完する情報を提供する場合があります。 ただし、オプティマイザのトレース形式と内容はバージョン間で変更される可能性があります。 詳細については、「<a class="ulink" href="https://dev.mysql.com/doc/internals/en/optimizer-tracing.html" target="_top">MySQL Internals: Tracing the Optimizer</a>」を参照してください。 
      </p><p>
        インデックスが使われるはずであると思うタイミングでそれらが使われていない問題がある場合、<code class="literal">ANALYZE TABLE</code> を実行して、オプティマイザが行う選択に影響する可能性があるキーのカーディナリティーなどのテーブル統計を更新します。 <a class="xref" href="sql-statements.html#analyze-table" title="13.7.3.1 ANALYZE TABLE ステートメント">セクション13.7.3.1「ANALYZE TABLE ステートメント」</a>を参照してください。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL Workbench には、<code class="literal">EXPLAIN</code> 出力を視覚的に表現する Visual Explain 機能があります。 <a class="ulink" href="https://dev.mysql.com/doc/workbench/en/wb-tutorial-visual-explain-dbt3.html" target="_top">Tutorial: Using Explain to Improve Query Performance</a>を参照してください。 
        </p></div></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="explain-analyze"></a>EXPLAIN ANALYZE による情報の取得</h4></div></div></div><p>
        MySQL 8.0.18 では、<code class="literal">EXPLAIN ANALYZE</code> が導入されています。この <code class="literal">EXPLAIN ANALYZE</code> は、ステートメントを実行し、タイミングおよび追加のイテレータベースの情報とともに、オプティマイザの期待が実際の実行とどのように一致したかに関する <code class="literal">EXPLAIN</code> 出力を生成します。 イテレータごとに、次の情報が表示されます: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            推定実行コスト
          </p><p>
            (一部のイテレータはコストモデルで考慮されないため、見積りには含まれません。)
          </p></li><li class="listitem"><p>
            戻された行の推定数
          </p></li><li class="listitem"><p>
            最初の行を返す時間
          </p></li><li class="listitem"><p>
            すべての行 (実際のコスト) を返す時間 (ミリ秒)
          </p><p>
            (複数のループがある場合、この図はループ当たりの平均時間を示しています。)
          </p></li><li class="listitem"><p>
            イテレータによって返された行数
          </p></li><li class="listitem"><p>
            ループ数
          </p></li></ul></div><p>
        クエリー実行情報は、ノードがイテレータを表す <code class="literal">TREE</code> 出力形式を使用して表示されます。 <code class="literal">EXPLAIN ANALYZE</code> では、常に <code class="literal">TREE</code> 出力形式が使用されます。 MySQL 8.0.21 以降では、これはオプションで <code class="literal">FORMAT=TREE</code> を使用して明示的に指定できます。<code class="literal">TREE</code> 以外の形式はサポートされません。 
      </p><p>
        <code class="literal">EXPLAIN ANALYZE</code> は、<code class="literal">SELECT</code> ステートメント、複数テーブルの <code class="literal">UPDATE</code> ステートメントおよび <code class="literal">DELETE</code> ステートメントとともに使用できます。 MySQL 8.0.19 以降では、<code class="literal">TABLE</code> ステートメントでも使用できます。 
      </p><p>
        MySQL 8.0.20 以降、<code class="literal">KILL QUERY</code> または <span class="keycap"><strong>CTRL-C</strong></span> を使用してこのステートメントを終了できます。
      </p><p>
        <code class="literal">EXPLAIN ANALYZE</code> は、<code class="literal">FOR CONNECTION</code> では使用できません。
      </p><p>
        出力例:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN ANALYZE SELECT * FROM t1 JOIN t2 ON (t1.c1 = t2.c2)\G</code></strong>
*************************** 1. row ***************************
EXPLAIN: -&gt; Inner hash join (t2.c2 = t1.c1)  (cost=4.70 rows=6)
(actual time=0.032..0.035 rows=6 loops=1)
    -&gt; Table scan on t2  (cost=0.06 rows=6)
(actual time=0.003..0.005 rows=6 loops=1)
    -&gt; Hash
        -&gt; Table scan on t1  (cost=0.85 rows=6)
(actual time=0.018..0.022 rows=6 loops=1)

mysql&gt; EXPLAIN ANALYZE SELECT * FROM t3 WHERE i &gt; 8\G
*************************** 1. row ***************************
EXPLAIN: -&gt; Filter: (t3.i &gt; 8)  (cost=1.75 rows=5)
(actual time=0.019..0.021 rows=6 loops=1)
    -&gt; Table scan on t3  (cost=1.75 rows=15)
(actual time=0.017..0.019 rows=15 loops=1)

mysql&gt; EXPLAIN ANALYZE SELECT * FROM t3 WHERE pk &gt; 17\G
*************************** 1. row ***************************
EXPLAIN: -&gt; Filter: (t3.pk &gt; 17)  (cost=1.26 rows=5)
(actual time=0.013..0.016 rows=5 loops=1)
    -&gt; Index range scan on t3 using PRIMARY  (cost=1.26 rows=5)
(actual time=0.012..0.014 rows=5 loops=1)
</pre><p>
        出力例で使用されるテーブルは、次に示すステートメントによって作成されています:
      </p><pre class="programlisting">CREATE TABLE t1 (
    c1 INTEGER DEFAULT NULL,
    c2 INTEGER DEFAULT NULL
);

CREATE TABLE t2 (
    c1 INTEGER DEFAULT NULL,
    c2 INTEGER DEFAULT NULL
);

CREATE TABLE t3 (
    pk INTEGER NOT NULL PRIMARY KEY,
    i INTEGER DEFAULT NULL
);
</pre><p>
        このステートメントの出力で <code class="literal">actual time</code> に表示される値は、ミリ秒単位で表されます。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="help"></a>13.8.3 HELP ステートメント</h3></div></div></div><a class="indexterm" name="idm45826985321776"></a><pre class="programlisting">HELP '<em class="replaceable"><code>search_string</code></em>'
</pre><p>
      <code class="literal">HELP</code> ステートメントは、『 MySQL リファレンスマニュアル』からオンライン情報を返します。 これが正しく動作するには、<code class="literal">mysql</code> データベース内のヘルプテーブルがヘルプトピック情報で初期化されている必要があります (<a class="xref" href="server-administration.html#server-side-help-support" title="5.1.17 サーバー側ヘルプのサポート">セクション5.1.17「サーバー側ヘルプのサポート」</a>を参照してください)。 
    </p><p>
      <code class="literal">HELP</code> ステートメントは、ヘルプテーブル内の指定された検索文字列を検索し、その検索の結果を表示します。 検索文字列では大文字と小文字は区別されません。 
    </p><p>
      検索文字列には、ワイルドカード文字 <code class="literal">%</code> および<code class="literal">_</code>を含めることができます。 これらは <code class="literal">LIKE</code> 演算子で実行されるパターンマッチング演算と同じ意味を持ちます。 たとえば、<code class="literal">HELP 'rep%'</code> は <code class="literal">rep</code> で始まるトピックのリストを返します。 
    </p><p>
      HELP ステートメントは、次のいくつかの種類の検索文字列を理解します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          もっとも一般的なレベルでは、トップレベルのヘルプカテゴリのリストを取得するには <code class="literal">contents</code> を使用します。
        </p><pre class="programlisting">HELP 'contents'
</pre></li><li class="listitem"><p>
          <code class="literal">Data Types</code> などの、特定のヘルプカテゴリ内のトピックのリストを取得するには、そのカテゴリ名を使用します。
        </p><pre class="programlisting">HELP 'data types'
</pre></li><li class="listitem"><p>
          <code class="literal">ASCII()</code> 関数や <code class="literal">CREATE TABLE</code> ステートメントなどの、特定のヘルプトピックに関するヘルプを表示するには、関連する 1 つまたは複数のキーワードを使用します。
        </p><pre class="programlisting">HELP 'ascii'
HELP 'create table'
</pre></li></ul></div><p>
      つまり、検索文字列はカテゴリ、多数のトピック、または 1 つのトピックに一致します。 特定の検索文字列がアイテムのリストを返すか、単一のヘルプトピックのヘルプ情報を返すかを事前に判断することはできません。 ただし、結果セット内の行数やカラム数を検査することによって、<code class="literal">HELP</code> がどのような種類の応答を返したかがわかります。 
    </p><p>
      次の説明は、結果セットの可能性のある形式を示しています。 この例のステートメントの出力は、<span class="command"><strong>mysql</strong></span> クライアントの使用時に表示される使い慣れた <span class="quote">「<span class="quote">tabular</span>」</span> または <span class="quote">「<span class="quote">vertical</span>」</span> 形式を使用して表示されますが、<span class="command"><strong>mysql</strong></span> 自体は <code class="literal">HELP</code> 結果セットを別の方法で再フォーマットすることに注意してください。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          空の結果セット
        </p><p>
          検索文字列に一致するものが見つかりませんでした。
        </p></li><li class="listitem"><p>
          3 つのカラムを含む単一行が含まれた結果セット
        </p><p>
          これは、検索文字列が 1 つのヘルプトピックに一致したことを示します。 この結果には 3 つのカラムが含まれています。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">name</code>: トピック名。
            </p></li><li class="listitem"><p>
              <code class="literal">description</code>: トピックの説明的なヘルプテキスト。
            </p></li><li class="listitem"><p>
              <code class="literal">example</code>: 使用例または例。 このカラムはブランクである可能性があります。 
            </p></li></ul></div><p>
          例: <code class="literal">HELP 'replace'</code>
        </p><p>
          生成される結果:
        </p><pre class="programlisting">name: REPLACE
description: Syntax:
REPLACE(str,from_str,to_str)

Returns the string str with all occurrences of the string from_str
replaced by the string to_str. REPLACE() performs a case-sensitive
match when searching for from_str.
example: mysql&gt; SELECT REPLACE('www.mysql.com', 'w', 'Ww');
        -&gt; 'WwWwWw.mysql.com'
</pre></li><li class="listitem"><p>
          2 つのカラムを含む複数の行が含まれた結果セット
        </p><p>
          これは、検索文字列が多数のヘルプトピックに一致したことを示します。 この結果セットは、ヘルプトピック名を示します。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">name</code>: ヘルプトピック名。
            </p></li><li class="listitem"><p>
              <code class="literal">is_it_category</code>: この名前がヘルプカテゴリを表す場合は <code class="literal">Y</code>、それ以外の場合は <code class="literal">N</code>。 それ以外の場合、<code class="literal">name</code> 値は、<code class="literal">HELP</code> ステートメントへの引数として指定されると、指定された項目の説明が含まれた単一行の結果セットを生成するはずです。 
            </p></li></ul></div><p>
          例: <code class="literal">HELP 'status'</code>
        </p><p>
          生成される結果:
        </p><pre class="programlisting">+-----------------------+----------------+
| name                  | is_it_category |
+-----------------------+----------------+
| SHOW                  | N              |
| SHOW ENGINE           | N              |
| SHOW MASTER STATUS    | N              |
| SHOW PROCEDURE STATUS | N              |
| SHOW SLAVE STATUS     | N              |
| SHOW STATUS           | N              |
| SHOW TABLE STATUS     | N              |
+-----------------------+----------------+
</pre></li><li class="listitem"><p>
          3 つのカラムを含む複数の行が含まれた結果セット
        </p><p>
          これは、検索文字列がカテゴリに一致したことを示します。 この結果セットには、カテゴリエントリが含まれています。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">source_category_name</code>: ヘルプカテゴリ名。
            </p></li><li class="listitem"><p>
              <code class="literal">name</code>: カテゴリまたはトピック名
            </p></li><li class="listitem"><p>
              <code class="literal">is_it_category</code>: この名前がヘルプカテゴリを表す場合は <code class="literal">Y</code>、それ以外の場合は <code class="literal">N</code>。 それ以外の場合、<code class="literal">name</code> 値は、<code class="literal">HELP</code> ステートメントへの引数として指定されると、指定された項目の説明が含まれた単一行の結果セットを生成するはずです。 
            </p></li></ul></div><p>
          例: <code class="literal">HELP 'functions'</code>
        </p><p>
          生成される結果:
        </p><pre class="programlisting">+----------------------+-------------------------+----------------+
| source_category_name | name                    | is_it_category |
+----------------------+-------------------------+----------------+
| Functions            | CREATE FUNCTION         | N              |
| Functions            | DROP FUNCTION           | N              |
| Functions            | Bit Functions           | Y              |
| Functions            | Comparison operators    | Y              |
| Functions            | Control flow functions  | Y              |
| Functions            | Date and Time Functions | Y              |
| Functions            | Encryption Functions    | Y              |
| Functions            | Information Functions   | Y              |
| Functions            | Logical operators       | Y              |
| Functions            | Miscellaneous Functions | Y              |
| Functions            | Numeric Functions       | Y              |
| Functions            | String Functions        | Y              |
+----------------------+-------------------------+----------------+
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="use"></a>13.8.4 USE ステートメント</h3></div></div></div><a class="indexterm" name="idm45826985250480"></a><a class="indexterm" name="idm45826985249232"></a><pre class="programlisting">USE <em class="replaceable"><code>db_name</code></em>
</pre><p>
      <code class="literal">USE</code> ステートメントは、指定されたデータベースを後続のステートメントのデフォルト (現行) データベースとして使用するように MySQL に指示します。 このステートメントには、データベースまたはその中のオブジェクトに対するなんらかの権限が必要です。 
    </p><p>
      指定したデータベースは、セッションの終了または別の <code class="literal">USE</code> ステートメントが発行されるまでデフォルトのままです:
    </p><pre class="programlisting">USE db1;
SELECT COUNT(*) FROM mytable;   # selects from db1.mytable
USE db2;
SELECT COUNT(*) FROM mytable;   # selects from db2.mytable
</pre><p>
      データベース名は単一行で指定する必要があります。 データベース名の改行はサポートされていません。 
    </p><p>
      <code class="literal">USE</code> ステートメントを使用して特定のデータベースをデフォルトにしても、他のデータベースのテーブルへのアクセスは禁止されません。 次の例では、<code class="literal">db1</code> データベースの <code class="literal">author</code> テーブルと、<code class="literal">db2</code> データベースの <code class="literal">editor</code> テーブルにアクセスします。 
    </p><pre class="programlisting">USE db1;
SELECT author_name,editor_name FROM author,db2.editor
  WHERE author.editor_id = db2.editor.editor_id;
</pre></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="functions.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="data-dictionary.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第 12 章 関数と演算子 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第 14 章 MySQL データディクショナリ</td></tr></table></div><div class="copyright-footer"></div></body></html>
