<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第 16 章 代替ストレージエンジン</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="MySQL 8.0 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 8.0 リファレンスマニュアル"><link rel="prev" href="innodb-storage-engine.html" title="第 15 章 InnoDB ストレージエンジン"><link rel="next" href="replication.html" title="第 17 章 レプリケーション"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 16 章 代替ストレージエンジン</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="innodb-storage-engine.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="replication.html">次へ</a></td></tr></table><hr></div><div class="status-header"><p class="alert">このページは機械翻訳したものです。</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="storage-engines"></a>第 16 章 代替ストレージエンジン</h1></div></div></div><div class="toc"><p><b>目次</b></p><dl class="toc"><dt><span class="section"><a href="storage-engines.html#storage-engine-setting">16.1 ストレージエンジンの設定</a></span></dt><dt><span class="section"><a href="storage-engines.html#myisam-storage-engine">16.2 MyISAM ストレージエンジン</a></span></dt><dd><dl><dt><span class="section"><a href="storage-engines.html#myisam-start">16.2.1 MyISAM 起動オプション</a></span></dt><dt><span class="section"><a href="storage-engines.html#key-space">16.2.2 キーに必要な容量</a></span></dt><dt><span class="section"><a href="storage-engines.html#myisam-table-formats">16.2.3 MyISAM テーブルのストレージフォーマット</a></span></dt><dt><span class="section"><a href="storage-engines.html#myisam-table-problems">16.2.4 MyISAM テーブルの問題点</a></span></dt></dl></dd><dt><span class="section"><a href="storage-engines.html#memory-storage-engine">16.3 MEMORY ストレージエンジン</a></span></dt><dt><span class="section"><a href="storage-engines.html#csv-storage-engine">16.4 CSV ストレージエンジン</a></span></dt><dd><dl><dt><span class="section"><a href="storage-engines.html#se-csv-repair">16.4.1 CSV テーブルの修復と確認</a></span></dt><dt><span class="section"><a href="storage-engines.html#se-csv-limitations">16.4.2 CSV の制限</a></span></dt></dl></dd><dt><span class="section"><a href="storage-engines.html#archive-storage-engine">16.5 ARCHIVE ストレージエンジン</a></span></dt><dt><span class="section"><a href="storage-engines.html#blackhole-storage-engine">16.6 BLACKHOLE ストレージエンジン</a></span></dt><dt><span class="section"><a href="storage-engines.html#merge-storage-engine">16.7 MERGE ストレージエンジン</a></span></dt><dd><dl><dt><span class="section"><a href="storage-engines.html#merge-table-advantages">16.7.1 MERGE テーブルの長所と短所</a></span></dt><dt><span class="section"><a href="storage-engines.html#merge-table-problems">16.7.2 MERGE テーブルの問題点</a></span></dt></dl></dd><dt><span class="section"><a href="storage-engines.html#federated-storage-engine">16.8 FEDERATED ストレージエンジン</a></span></dt><dd><dl><dt><span class="section"><a href="storage-engines.html#federated-description">16.8.1 FEDERATED ストレージエンジンの概要</a></span></dt><dt><span class="section"><a href="storage-engines.html#federated-create">16.8.2 FEDERATED テーブルの作成方法</a></span></dt><dt><span class="section"><a href="storage-engines.html#federated-usagenotes">16.8.3 FEDERATED ストレージエンジンの注記とヒント</a></span></dt><dt><span class="section"><a href="storage-engines.html#federated-storage-engine-resources">16.8.4 FEDERATED ストレージエンジンのリソース</a></span></dt></dl></dd><dt><span class="section"><a href="storage-engines.html#example-storage-engine">16.9 EXAMPLE ストレージエンジン</a></span></dt><dt><span class="section"><a href="storage-engines.html#storage-engines-other">16.10 ほかのストレージエンジン</a></span></dt><dt><span class="section"><a href="storage-engines.html#pluggable-storage-overview">16.11 MySQL ストレージエンジンアーキテクチャーの概要</a></span></dt><dd><dl><dt><span class="section"><a href="storage-engines.html#pluggable-storage">16.11.1 プラガブルストレージエンジンのアーキテクチャー</a></span></dt><dt><span class="section"><a href="storage-engines.html#pluggable-storage-common-layer">16.11.2 共通データベースサーバーレイヤー</a></span></dt></dl></dd></dl></div><a class="indexterm" name="idm45568055497696"></a><a class="indexterm" name="idm45568055495584"></a><a class="indexterm" name="idm45568055493520"></a><a class="indexterm" name="idm45568055491488"></a><a class="indexterm" name="idm45568055490080"></a><a class="indexterm" name="idm45568055488672"></a><a class="indexterm" name="idm45568055487264"></a><a class="indexterm" name="idm45568055485856"></a><a class="indexterm" name="idm45568055484448"></a><a class="indexterm" name="idm45568055483040"></a><a class="indexterm" name="idm45568055481632"></a><a class="indexterm" name="idm45568055480224"></a><a class="indexterm" name="idm45568055478816"></a><a class="indexterm" name="idm45568055477392"></a><p>
    ストレージエンジンは、さまざまなテーブル型に対する SQL 操作を処理する MySQL コンポーネントです。 <code class="literal">InnoDB</code> はデフォルトでもっとも汎用のストレージエンジンであり、Oracle は、特別なユースケースを除くテーブルについては、このエンジンの使用を推奨します。 (デフォルトでは、MySQL 8.0 の <code class="literal">CREATE TABLE</code> ステートメントは <code class="literal">InnoDB</code> テーブルを作成します。) 
  </p><p>
    MySQL Server は、ストレージエンジンが、動作中の MySQL サーバーにロードされたり、MySQL サーバーからアンロードされたりできる、プラガブルストレージエンジンアーキテクチャーを採用しています。
  </p><p>
    ご使用のサーバーがサポートするストレージエンジンを調べるには、<code class="literal">SHOW ENGINES</code> ステートメントを使用します。 <code class="literal">サポート</code>カラムの値は、エンジンを使用できるかどうかを示します。 <code class="literal">YES</code>、<code class="literal">NO</code>、または <code class="literal">DEFAULT</code> の値は、エンジンが「使用可能」、「使用可能でない」、または「デフォルトのストレージエンジンとして使用可能であり、現在設定されている」を表しています。 
  </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW ENGINES\G</code></strong>
*************************** 1. row ***************************
      Engine: PERFORMANCE_SCHEMA
     Support: YES
     Comment: Performance Schema
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 2. row ***************************
      Engine: InnoDB
     Support: DEFAULT
     Comment: Supports transactions, row-level locking, and foreign keys
Transactions: YES
          XA: YES
  Savepoints: YES
*************************** 3. row ***************************
      Engine: MRG_MYISAM
     Support: YES
     Comment: Collection of identical MyISAM tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 4. row ***************************
      Engine: BLACKHOLE
     Support: YES
     Comment: /dev/null storage engine (anything you write to it disappears)
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 5. row ***************************
      Engine: MyISAM
     Support: YES
     Comment: MyISAM storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
...
</pre><p>
    この章では、特別な目的の MySQL ストレージエンジンのユースケースについて説明します。 <a class="xref" href="innodb-storage-engine.html" title="第 15 章 InnoDB ストレージエンジン">第15章「<i>InnoDB ストレージエンジン</i>」</a>および <a class="xref" href="mysql-cluster.html" title="第 23 章 MySQL NDB Cluster 8.0">第23章「<i>MySQL NDB Cluster 8.0</i>」</a>で説明するデフォルトの <code class="literal">InnoDB</code> ストレージエンジンまたは <code class="literal">NDB</code> ストレージエンジンについては説明しません。 上級ユーザーの場合は、プラガブルストレージエンジンアーキテクチャの説明も含まれています (<a class="xref" href="storage-engines.html#pluggable-storage-overview" title="16.11 MySQL ストレージエンジンアーキテクチャーの概要">セクション16.11「MySQL ストレージエンジンアーキテクチャーの概要」</a> を参照)。 
  </p><p>
    商用 MySQL Server バイナリで提供される機能の詳細は、MySQL web サイトの<a class="ulink" href="https://www.mysql.com/products/" target="_top">「<em class="citetitle">MySQL エディション</em>」</a>を参照してください。 使用可能なストレージエンジンは、使用している MySQL のエディションによって異なります。 
  </p><p>
    MySQL ストレージエンジンに関するよくある質問の回答については、<a class="xref" href="faqs.html#faqs-storage-engines" title="A.2 MySQL 8.0 FAQ: ストレージエンジン">セクションA.2「MySQL 8.0 FAQ: ストレージエンジン」</a>を参照してください。
  </p><h2><a name="idm45568055453712"></a>MySQL 8.0 がサポートするストレージエンジン</h2><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="link" href="innodb-storage-engine.html" title="第 15 章 InnoDB ストレージエンジン"><code class="literal">InnoDB</code></a>: MySQL 8.0 のデフォルトのストレージエンジン。 <code class="literal">InnoDB</code> はトランザクションセーフな (ACID に準拠した) MySQL 用のストレージエンジンであり、ユーザーデータを保護するためのコミット、ロールバック、およびクラッシュリカバリ機能を備えています。 <code class="literal">InnoDB</code> の行レベルロック (より粒度の粗いロックへのエスカレーションは行わない) と Oracle スタイルの一貫性非ロック読み取りにより、マルチユーザーの並列性とパフォーマンスが向上します。 <code class="literal">InnoDB</code> では、主キーに基づいた一般的なクエリーの入出力を低減するため、クラスタ化されたインデックス内にユーザーデータが格納されます。 <code class="literal">InnoDB</code> ではデータの整合性を維持できるように、<code class="literal">FOREIGN KEY</code> 参照整合性制約もサポートされています。 <code class="literal">InnoDB</code> の詳細については、<a class="xref" href="innodb-storage-engine.html" title="第 15 章 InnoDB ストレージエンジン">第15章「<i>InnoDB ストレージエンジン</i>」</a>を参照してください。 
      </p></li><li class="listitem"><p>
        <a class="link" href="storage-engines.html#myisam-storage-engine" title="16.2 MyISAM ストレージエンジン"><code class="literal">MyISAM</code></a>: これらのテーブルのフットプリントは小さくなります。 <a class="link" href="glossary.html#glos_table_lock" title="テーブルロック">テーブルレベルのロック</a> では、読み取り/書き込みの作業負荷でのパフォーマンスが抑えられるため、Web およびデータウェアハウス構成の読み取り専用または読み取りが大半の作業負荷の場合に使用されるのが一般的です。 
      </p></li><li class="listitem"><p>
        <a class="link" href="storage-engines.html#memory-storage-engine" title="16.3 MEMORY ストレージエンジン"><code class="literal">メモリー</code></a>: すべてのデータを RAM に格納します (重要でないデータの短時間での検索が必要な環境で高速にアクセスするため)。 このエンジンは以前は <code class="literal">HEAP</code> エンジンとして知られていました。 このユースケースは減少しています。バッファープールのメモリー領域を持つ <code class="literal">InnoDB</code> は、ほとんどのデータまたはすべてのデータをメモリーに保持する汎用的で永続的な方法を提供し、<code class="literal">NDBCLUSTER</code> は大規模な分散データセットでキー値の高速な検索ができます。 
      </p></li><li class="listitem"><p>
        <a class="link" href="storage-engines.html#csv-storage-engine" title="16.4 CSV ストレージエンジン"><code class="literal">CSV</code></a>: このテーブルは、カンマ区切り値を持つ実際のテキストファイルです。 CSV テーブルにより、CSV フォーマットでデータをインポートしたりダンプしたりして、同じフォーマットを読み込んだり書き込んだりするスクリプトおよびアプリケーションとデータを交換できます。 CSV テーブルはインデックス化されないため、通常の操作時はデータを <code class="literal">InnoDB</code> テーブルに保持し、インポートまたはエクスポートの段階でのみ CSV テーブルを使用するのが一般的です。 
      </p></li><li class="listitem"><p>
        <a class="link" href="storage-engines.html#archive-storage-engine" title="16.5 ARCHIVE ストレージエンジン"><code class="literal">アーカイブ</code></a>: これらのインデックス化されていないコンパクトなテーブルは、ほとんど参照されない大量の履歴情報、アーカイブされた情報、またはセキュリティー監査情報を格納したり、検索したりするためのテーブルです。
      </p></li><li class="listitem"><p>
        <a class="link" href="storage-engines.html#blackhole-storage-engine" title="16.6 BLACKHOLE ストレージエンジン"><code class="literal">Blackhole</code></a>: Blackhole ストレージエンジンはデータを受け付けますが、Unix <code class="literal">/dev/null</code> デバイスと同じように、格納しません。 クエリーは常に空のセットを返します。 これらのテーブルは、DML ステートメントがレプリカサーバーに送信されるレプリケーション構成で使用できますが、ソースサーバーはデータの独自のコピーを保持しません。 
      </p></li><li class="listitem"><p>
        <code class="literal">NDB</code> (<code class="literal">NDBCLUSTER</code> とも呼ばれる): このクラスタデータベースエンジンは、可能なかぎり高いアップタイムと可用性を必要とするアプリケーションに特に適しています。
      </p></li><li class="listitem"><p>
        <a class="link" href="storage-engines.html#merge-storage-engine" title="16.7 MERGE ストレージエンジン"><code class="literal">マージ</code></a>: MySQL DBA または開発者は、一連のまったく同じ <code class="literal">MyISAM</code> テーブルを論理的にグループ分けして、それらを 1 つのオブジェクトとして参照します。 データウェアハウスなどの VLDB 環境に適しています。 
      </p></li><li class="listitem"><p>
        <a class="link" href="storage-engines.html#federated-storage-engine" title="16.8 FEDERATED ストレージエンジン"><code class="literal">Federated</code></a>: 多くの物理サーバーから 1 つの論理サーバーを作成するために別々の MySQL サーバーをリンクする機能を提供します。 分散またはデータマート環境に非常に適しています。 
      </p></li><li class="listitem"><p>
        <a class="link" href="storage-engines.html#example-storage-engine" title="16.9 EXAMPLE ストレージエンジン"><code class="literal">例</code></a>: このエンジンは、新しいストレージエンジンの書き込みを開始する方法を示す MySQL ソースコードの例として機能します。 これは、主に開発者が対象です。 ストレージエンジンは何もしない <span class="quote">「<span class="quote">stub</span>」</span> です。 このエンジンでテーブルを作成できますが、それらにデータを格納したり、それらからデータを取り出したりすることはできません。 
      </p></li></ul></div><p>
    サーバー全体またはスキーマ全体に同じストレージエンジンを使用するという制限はありません。 いずれのテーブルにもストレージエンジンを指定できます。 たとえばアプリケーションでは、<code class="literal">InnoDB</code> テーブルを使用している場合がほとんどであり、データをスプレッドシートにエクスポートするための <code class="literal">CSV</code> テーブルを 1 つ、テンポラリワークスペース用に <code class="literal">MEMORY</code> テーブルをいくつか持っています。 
  </p><p>
    <span class="bold"><strong>ストレージエンジンの選択</strong></span>
  </p><p>
    MySQL が提供するさまざまなストレージエンジンは、異なるユースケースで使用されることを想定して設計されています。 次のテーブルに、MySQL で提供される一部のストレージエンジンの概要と、そのあとのノートを示します。 
  </p><div class="table"><a name="idm45568055407472"></a><p class="title"><b>表 16.1 「ストレージエンジン機能のサマリー」</b></p><div class="table-contents"><table frame="box" rules="all" summary="「ストレージエンジンごとにサポートされる機能のサマリー。」"><col style="width: 10%"><col style="width: 16%"><col style="width: 16%"><col style="width: 16%"><col style="width: 16%"><col style="width: 16%"><thead><tr><th scope="col">機能</th>
<th scope="col">MyISAM</th>
<th scope="col">メモリー</th>
<th scope="col">InnoDB</th>
<th scope="col">アーカイブ</th>
<th scope="col">NDB</th>
</tr></thead><tbody><tr><th scope="row">B ツリーインデックス</th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td>いいえ</td>
<td>いいえ</td>
</tr><tr><th scope="row">MVCC</th>
<td>いいえ</td>
<td>いいえ</td>
<td>はい</td>
<td>いいえ</td>
<td>いいえ</td>
</tr><tr><th scope="row">T ツリーインデックス</th>
<td>いいえ</td>
<td>いいえ</td>
<td>いいえ</td>
<td>いいえ</td>
<td>はい</td>
</tr><tr><th scope="row">インデックスキャッシュ</th>
<td>はい</td>
<td>N/A</td>
<td>はい</td>
<td>いいえ</td>
<td>はい</td>
</tr><tr><th scope="row">クラスタデータベースのサポート</th>
<td>いいえ</td>
<td>いいえ</td>
<td>いいえ</td>
<td>いいえ</td>
<td>はい</td>
</tr><tr><th scope="row">クラスタ化されたインデックス</th>
<td>いいえ</td>
<td>いいえ</td>
<td>はい</td>
<td>いいえ</td>
<td>いいえ</td>
</tr><tr><th scope="row">ストレージの制限</th>
<td>256TB</td>
<td>RAM</td>
<td>64TB</td>
<td>なし</td>
<td>384EB</td>
</tr><tr><th scope="row">データキャッシュ</th>
<td>いいえ</td>
<td>N/A</td>
<td>はい</td>
<td>いいえ</td>
<td>はい</td>
</tr><tr><th scope="row">データディクショナリ向け更新統計</th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td>はい</td>
</tr><tr><th scope="row">トランザクション</th>
<td>いいえ</td>
<td>いいえ</td>
<td>はい</td>
<td>いいえ</td>
<td>はい</td>
</tr><tr><th scope="row">ハッシュインデックス</th>
<td>いいえ</td>
<td>はい</td>
<td>いいえ (note 1)</td>
<td>いいえ</td>
<td>はい</td>
</tr><tr><th scope="row">バックアップ/ポイントインタイムリカバリ (note 2)</th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td>はい</td>
</tr><tr><th scope="row">レプリケーションのサポート (note 2)</th>
<td>はい</td>
<td>制限付き (note 3)</td>
<td>はい</td>
<td>はい</td>
<td>はい</td>
</tr><tr><th scope="row">ロック粒度</th>
<td>Table</td>
<td>Table</td>
<td>行</td>
<td>行</td>
<td>行</td>
</tr><tr><th scope="row">全文検索インデックス</th>
<td>はい</td>
<td>いいえ</td>
<td>はい (note 4)</td>
<td>いいえ</td>
<td>いいえ</td>
</tr><tr><th scope="row">圧縮データ</th>
<td>はい (note 5)</td>
<td>いいえ</td>
<td>はい</td>
<td>はい</td>
<td>いいえ</td>
</tr><tr><th scope="row">地理空間インデックスのサポート</th>
<td>はい</td>
<td>いいえ</td>
<td>はい (note 6)</td>
<td>いいえ</td>
<td>いいえ</td>
</tr><tr><th scope="row">地理空間データ型のサポート</th>
<td>はい</td>
<td>いいえ</td>
<td>はい</td>
<td>はい</td>
<td>はい</td>
</tr><tr><th scope="row">外部キーのサポート</th>
<td>いいえ</td>
<td>いいえ</td>
<td>はい</td>
<td>いいえ</td>
<td>はい (note 7)</td>
</tr><tr><th scope="row">暗号化データ</th>
<td>はい (note 8)</td>
<td>はい (note 8)</td>
<td>はい (note 9)</td>
<td>はい (note 8)</td>
<td>はい (note 8)</td>
</tr></tbody></table></div></div><br class="table-break"><p><span class="bold"><strong>Notes:</strong></span></p><p>1. InnoDB は、アダプティブハッシュインデックス機能に対して、内部的にハッシュインデックスを利用します。</p><p>2. ストレージエンジン内ではなくサーバー内で実装されています。</p><p>3. このセクションの後半の説明を参照してください。</p><p>4. FULLTEXT インデックスに対する InnoDB サポートは、MySQL 5.6 以降で使用できます。</p><p>5. 圧縮された MyISAM テーブルがサポートされているのは、圧縮行フォーマットを使用している場合だけです。 MyISAM で圧縮行フォーマットを使用するテーブルは、読み取り専用です。</p><p>6. InnoDB での地理空間インデックス付けのサポートは、MySQL 5.7 以降で使用できます。</p><p>7. 外部キーのサポートは、MySQL Cluster NDB 7.3 以降で使用できます。</p><p>8. 暗号化機能を介してサーバーに実装されます。</p><p>9. 暗号化機能を介してサーバーに実装されます。MySQL 5.7 以降では、保存データのテーブルスペース暗号化がサポートされます。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="storage-engine-setting"></a>16.1 ストレージエンジンの設定</h2></div></div></div><p>
      新しいテーブルを作成するときに、<code class="literal">ENGINE</code> テーブルオプションを <code class="literal">CREATE TABLE</code> ステートメントに加えることによって、どのストレージエンジンを利用するかを指定できます。
    </p><pre class="programlisting">-- ENGINE=INNODB not needed unless you have set a different
-- default storage engine.
CREATE TABLE t1 (i INT) ENGINE = INNODB;
-- Simple table definitions can be switched from one to another.
CREATE TABLE t2 (i INT) ENGINE = CSV;
CREATE TABLE t3 (i INT) ENGINE = MEMORY;
</pre><p>
      <code class="literal">ENGINE</code> オプションを省略した場合、デフォルトのストレージエンジンが使用されます。 デフォルトのエンジンは MySQL 8.0 の <code class="literal">InnoDB</code> です。 デフォルトのエンジンを指定するには、<code class="literal">--default-storage-engine</code> サーバースタートアップオプションを使用するか、<code class="filename">my.cnf</code> 構成ファイルにある <code class="literal">default-storage-engine</code> オプションを設定するかします。 
    </p><p>
      現在のセッションにデフォルトのストレージエンジンを設定するには、<code class="literal">default_storage_engine</code> 変数を設定します。
    </p><pre class="programlisting">SET default_storage_engine=NDBCLUSTER;
</pre><p>
      <code class="literal">CREATE TEMPORARY TABLE</code> で作成された <code class="literal">TEMPORARY</code> テーブルのストレージエンジンは、起動時または実行時に <code class="literal">default_tmp_storage_engine</code> を設定することによって、永続テーブルのエンジンとは別に設定できます。
    </p><p>
      テーブルを別のストレージエンジンに変換するには、新しいエンジンを指定する <code class="literal">ALTER TABLE</code> ステートメントを使用します。
    </p><pre class="programlisting">ALTER TABLE t ENGINE = InnoDB;
</pre><p>
      <a class="xref" href="sql-statements.html#create-table" title="13.1.20 CREATE TABLE ステートメント">セクション13.1.20「CREATE TABLE ステートメント」</a>および<a class="xref" href="sql-statements.html#alter-table" title="13.1.9 ALTER TABLE ステートメント">セクション13.1.9「ALTER TABLE ステートメント」</a>を参照してください。
    </p><p>
      コンパイルされていないストレージエンジン、またはコンパイルされているが無効化されたストレージエンジンを使用する場合、MySQL はその代わりに、デフォルトのストレージエンジンを使用してテーブルを作成します。 たとえば、レプリケーション設定では、おそらくソースサーバーは安全性を最大化するために <code class="literal">InnoDB</code> テーブルを使用しますが、レプリカサーバーは永続性または同時実行性を犠牲にして速度を高めるために他のストレージエンジンを使用します。 
    </p><p>
      デフォルトでは、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> がデフォルトのストレージエンジンを使用できない場合は、常に警告が生成されます。 目的のエンジンが使用できない場合に、混乱を起こす意図しない動作をしないようにするには、<code class="literal">NO_ENGINE_SUBSTITUTION</code> SQL モードを有効にします。 目的のエンジンが使用できない場合、この設定によって、警告の代わりにエラーが起こり、テーブルが作成されたり変更されたりしません。 <a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a>を参照してください。 
    </p><p>
      MySQL では、ストレージエンジンに応じて、テーブルのインデックスおよびデータを他の 1 つ以上のファイルに格納できます。 テーブルおよびカラムの定義は、MySQL データディクショナリに格納されます。 個々のストレージエンジンは、それらが管理するテーブルに必要なファイルをさらに作成します。 テーブル名に特殊文字が含まれている場合は、<a class="xref" href="language-structure.html#identifier-mapping" title="9.2.4 識別子とファイル名のマッピング">セクション9.2.4「識別子とファイル名のマッピング」</a>で説明されているように、その文字のエンコードされたバージョンがテーブルファイルの名前に含まれます。 
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="myisam-storage-engine"></a>16.2 MyISAM ストレージエンジン</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="storage-engines.html#myisam-start">16.2.1 MyISAM 起動オプション</a></span></dt><dt><span class="section"><a href="storage-engines.html#key-space">16.2.2 キーに必要な容量</a></span></dt><dt><span class="section"><a href="storage-engines.html#myisam-table-formats">16.2.3 MyISAM テーブルのストレージフォーマット</a></span></dt><dt><span class="section"><a href="storage-engines.html#myisam-table-problems">16.2.4 MyISAM テーブルの問題点</a></span></dt></dl></div><a class="indexterm" name="idm45568055238208"></a><a class="indexterm" name="idm45568055236720"></a><p>
    <code class="literal">MyISAM</code> は古い (そしてすでに使用できない) <code class="literal">ISAM</code> ストレージエンジンに基づいていますが、多くの役に立つ拡張機能を持っています。
  </p><div class="table"><a name="idm45568055232560"></a><p class="title"><b>表 16.2 「MyISAM ストレージエンジンの機能」</b></p><div class="table-contents"><table frame="box" rules="all" summary="「MyISAM ストレージエンジンでサポートされる機能。」"><col style="width: 60%"><col style="width: 40%"><thead><tr><th>機能</th>
<th>Support</th>
</tr></thead><tbody><tr><td><span class="bold"><strong>B ツリーインデックス</strong></span></td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>MVCC</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>T ツリーインデックス</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>インデックスキャッシュ</strong></span></td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>クラスタデータベースのサポート</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>クラスタ化されたインデックス</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>ストレージの制限</strong></span></td>
<td>256TB</td>
</tr><tr><td><span class="bold"><strong>データキャッシュ</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>データディクショナリ向け更新統計</strong></span></td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>トランザクション</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>ハッシュインデックス</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>バックアップ/ポイントインタイムリカバリ</strong></span> (ストレージエンジン内ではなくサーバー内で実装されています。)</td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>レプリケーションのサポート</strong></span> (ストレージエンジン内ではなくサーバー内で実装されています。)</td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>ロック粒度</strong></span></td>
<td>Table</td>
</tr><tr><td><span class="bold"><strong>全文検索インデックス</strong></span></td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>圧縮データ</strong></span></td>
<td>はい (圧縮された MyISAM テーブルがサポートされているのは、圧縮行フォーマットを使用している場合だけです。 MyISAM で圧縮行フォーマットを使用するテーブルは、読み取り専用です。)</td>
</tr><tr><td><span class="bold"><strong>地理空間インデックスのサポート</strong></span></td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>地理空間データ型のサポート</strong></span></td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>外部キーのサポート</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>暗号化データ</strong></span></td>
<td>はい (暗号化機能を介してサーバーに実装されます。)</td>
</tr></tbody></table></div></div><br class="table-break"><p>
    各 <code class="literal">MyISAM</code> テーブルは、ディスク上の 2 つのファイルに格納されます。 そのファイル名はテーブル名で始まり、ファイルタイプを示す拡張子が付きます。 データファイルには <code class="filename">.MYD</code> (<code class="literal">MYData</code>) 拡張子が付きます。 インデックスファイルには <code class="filename">.MYI</code> (<code class="literal">MYIndex</code>) 拡張子が付きます。 テーブル定義は、MySQL データディクショナリに格納されます。 
  </p><p>
    <code class="literal">MyISAM</code> テーブルが必要であることを明示的に指定するには、<code class="literal">ENGINE</code> テーブルオプションで指定します。
  </p><pre class="programlisting">CREATE TABLE t (i INT) ENGINE = MYISAM;
</pre><p>
    MySQL 8.0 では通常、<code class="literal">InnoDB</code> がデフォルトエンジンであるため、<code class="literal">ENGINE</code> を使用して <code class="literal">MyISAM</code> ストレージエンジンを指定する必要があります。
  </p><p>
    <span class="command"><strong>mysqlcheck</strong></span> クライアントか <span class="command"><strong>myisamchk</strong></span> ユーティリティーで <code class="literal">MyISAM</code> テーブルをチェックしたり修正したりできます。 容量を節約するために <span class="command"><strong>myisampack</strong></span>を使って <code class="literal">MyISAM</code> テーブルを圧縮することもできます。 <a class="xref" href="programs.html#mysqlcheck" title="4.5.3 mysqlcheck — テーブル保守プログラム">セクション4.5.3「mysqlcheck — テーブル保守プログラム」</a>、<a class="xref" href="programs.html#myisamchk" title="4.6.4 myisamchk — MyISAM テーブルメンテナンスユーティリティー">セクション4.6.4「myisamchk — MyISAM テーブルメンテナンスユーティリティー」</a>、および<a class="xref" href="programs.html#myisampack" title="4.6.6 myisampack — 圧縮された読み取り専用の MyISAM テーブルの生成">セクション4.6.6「myisampack — 圧縮された読み取り専用の MyISAM テーブルの生成」</a>を参照してください。 
  </p><p>
    MySQL 8.0 では、<code class="literal">MyISAM</code> ストレージエンジンはパーティション分割をサポートしていません。 <span class="emphasis"><em>「以前のバージョンの MySQL で作成されたパーティション <code class="literal">MyISAM</code> テーブルは、MySQL 8.0 では使用できません」</em></span>。 詳細は、<a class="xref" href="partitioning.html#partitioning-limitations-storage-engines" title="24.6.2 ストレージエンジンに関連するパーティショニング制限">セクション24.6.2「ストレージエンジンに関連するパーティショニング制限」</a>を参照してください。 このようなテーブルを MySQL 8.0 で使用できるようにアップグレードする方法の詳細は、<a class="xref" href="installing.html#upgrading-from-previous-series" title="2.11.4 MySQL 8.0 での変更">セクション2.11.4「MySQL 8.0 での変更」</a> を参照してください。 
  </p><p>
    <code class="literal">MyISAM</code> テーブルには次のような特徴があります。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        すべてのデータ値は、下位バイトから順に格納されます。 これにより、データマシンとオペレーティングシステムは依存しなくなります。 バイナリポータビリティーのための唯一の要件は、2 の補数の符号付き整数と IEEE 浮動小数点フォーマットを使用することです。 これらの要件は主流のマシンで幅広く使用されています。 バイナリポータビリティーは、組み込みシステムには適用されない可能性があります。特別のプロセッサを使用している場合があるためです。 
      </p><p>
        下位バイトから順にデータを格納するため、大きな速度低下はありません。通常、テーブル行のバイトは整列しておらず、順番に未整列のバイトを読み込む処理は逆の順番に読み込む処理より時間がかかりません。 また、カラム値をフェッチするサーバーのコードは、ほかのコードに比べて速度は重視されません。 
      </p></li><li class="listitem"><p>
        インデックスを効率良く圧縮ができるため、すべての数値キー値は上位バイトから順に格納されます。
      </p></li><li class="listitem"><p>
        大きなファイル (最大 63 ビットのファイル長) は、大きなファイルをサポートするファイルシステムとオペレーティングシステムでサポートされます。
      </p></li><li class="listitem"><p>
        <code class="literal">MyISAM</code> テーブルの行数は、(2<sup>32</sup>)<sup>2</sup> (1.844E+19) の制限があります。
      </p></li><li class="listitem"><p>
        1 つの <code class="literal">MyISAM</code> テーブルの最大インデックス数は 64 です。
      </p><p>
        1 つのインデックスの最大カラム数は 16 です。
      </p></li><li class="listitem"><p>
        最大キー長は 1000 バイトです。 これは、ソースを変更して再コンパイルしても変えることができます。 キーが 250 バイトより長いと、キーのブロックサイズはデフォルト値の 1024 バイトより大きい値が使用されます。 
      </p></li><li class="listitem"><p>
        ソートされた順番で行が挿入されたとき (<code class="literal">AUTO_INCREMENT</code> カラムを使用しているときと同様に)、上位のノードが 1 つのキーだけを含むように、インデックスツリーが分割されます。 これにより、インデックスツリーの領域の利用率が向上します。 
      </p></li><li class="listitem"><p>
        テーブルごとに 1 つの <code class="literal">AUTO_INCREMENT</code> カラムの内部処理がサポートされます。 <code class="literal">MyISAM</code> は <code class="literal">INSERT</code> 操作と <code class="literal">UPDATE</code> 操作でこのカラムを自動的に更新します。 これにより、<code class="literal">AUTO_INCREMENT</code> カラムは速くなります (少なくとも 10 %)。 シーケンスの一番上の値は、削除されると、再利用されません。 (<code class="literal">AUTO_INCREMENT</code> カラムがマルチカラムインデックスの最後のカラムとして定義された場合、シーケンスの最上部から削除された値が再利用されます。) <code class="literal">AUTO_INCREMENT</code> 値は <code class="literal">ALTER TABLE</code> や <span class="command"><strong>myisamchk</strong></span> でリセットできます。 
      </p></li><li class="listitem"><p>
        動的サイズの行は、削除を更新および挿入と併用すると、フラグメント化がかなり減少します。 これは、削除された隣接ブロックを自動的に結合し、次のブロックが削除されたときにブロックを拡張することで行われます。 
      </p></li><li class="listitem"><p>
        <code class="literal">MyISAM</code> は同時挿入をサポートしています。テーブルのデータファイルの途中に空きブロックがなければ、ほかのスレッドがテーブルから読み取るのと同時に新しい行をそれに <code class="literal">INSERT</code> できます。 行を削除した結果として、または動的長の行を現在の内容より多くのデータで更新した結果として、空きブロックが発生する可能性があります。 すべての空きブロックが完全に使用されると (埋まると)、その後の挿入はふたたび並列になります。 <a class="xref" href="optimization.html#concurrent-inserts" title="8.11.3 同時挿入">セクション8.11.3「同時挿入」</a>を参照してください。 
      </p></li><li class="listitem"><p>
        データファイルとインデックスファイルを異なる物理デバイス上の異なるディレクトリに置き、<code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> テーブルオプションを <code class="literal">CREATE TABLE</code> に付けて速度を上げることができます。 <a class="xref" href="sql-statements.html#create-table" title="13.1.20 CREATE TABLE ステートメント">セクション13.1.20「CREATE TABLE ステートメント」</a>を参照してください。 
      </p></li><li class="listitem"><p>
        <code class="literal">BLOB</code> と <code class="literal">TEXT</code> カラムはインデックスを付けることができます。
      </p></li><li class="listitem"><p>
        インデックスを付けたカラムでは <code class="literal">NULL</code> 値が許可されます。 これには、キー当たり 0 - 1 バイトが必要です。 
      </p></li><li class="listitem"><p>
        文字カラムごとに異なる文字セットを持つことができます。 <a class="xref" href="charset.html" title="第 10 章 文字セット、照合順序、Unicode">第10章「<i>文字セット、照合順序、Unicode</i>」</a>を参照してください。 
      </p></li><li class="listitem"><p>
        <code class="literal">MyISAM</code> インデックスファイルの中に、テーブルが正しく閉じられたかどうかを表すフラグがあります。 <code class="literal">myisam_recover_options</code> システム変数を設定して <span class="command"><strong>mysqld</strong></span> を起動すると、<code class="literal">MyISAM</code> テーブルはオープン時に自動的にチェックされ、テーブルが正しくクローズされなかった場合は修復されます。 
      </p></li><li class="listitem"><p>
        <span class="command"><strong>myisamchk</strong></span> は <code class="option">--update-state</code> オプションを付けて実行したかどうかをテーブルにマークします。<span class="command"><strong>myisamchk --fast</strong></span> はこのマークがないテーブルだけを確認します。
      </p></li><li class="listitem"><p>
        <span class="command"><strong>myisamchk --analyze</strong></span> はキー全体に対してするのと同様に、キーの一部分に対する統計データを格納します。
      </p></li><li class="listitem"><p>
        <span class="command"><strong>myisampack</strong></span> は <code class="literal">BLOB</code> と <code class="literal">VARCHAR</code> カラムを圧縮できます。
      </p></li></ul></div><p>
    <code class="literal">MyISAM</code> は次のような機能もサポートしています。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        真の <code class="literal">VARCHAR</code> 型をサポートしています。<code class="literal">VARCHAR</code> カラムは 1 バイトか 2 バイトで格納される長さから始まります。
      </p></li><li class="listitem"><p>
        <code class="literal">VARCHAR</code> カラムを持つテーブルの行の長さは固定でも動的でもかまいません。
      </p></li><li class="listitem"><p>
        テーブル内の <code class="literal">VARCHAR</code> と <code class="literal">CHAR</code> カラムの長さの合計は、最大で 64K バイトになる場合があります。
      </p></li><li class="listitem"><p>
        任意の長さの <code class="literal">UNIQUE</code> 制約。
      </p></li></ul></div><h3><a name="idm45568055090192"></a>追加のリソース</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">MyISAM</code> ストレージエンジンに特化したフォーラムは <a class="ulink" href="https://forums.mysql.com/list.php?21" target="_top">https://forums.mysql.com/list.php?21</a>で参照できます。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="myisam-start"></a>16.2.1 MyISAM 起動オプション</h3></div></div></div><p>
      <code class="literal">MyISAM</code> テーブルの振る舞いを変えるために、次の <span class="command"><strong>mysqld</strong></span> オプションを使用できます。 追加情報については <a class="xref" href="server-administration.html#server-options" title="5.1.7 サーバーコマンドオプション">セクション5.1.7「サーバーコマンドオプション」</a>を参照してください。 
    </p><div class="table"><a name="idm45568055082960"></a><p class="title"><b>表 16.3 「MyISAM オプションおよび変数リファレンス」</b></p><div class="table-contents"><table frame="box" rules="all" summary="「MyISAM コマンドラインオプションおよびシステム変数のリファレンス。」"><col style="width: 20%"><col style="width: 15%"><col style="width: 15%"><col style="width: 15%"><col style="width: 15%"><col style="width: 15%"><col style="width: 15%"><thead><tr><th scope="col">名前</th>
<th scope="col">コマンド行</th>
<th scope="col">オプションファイル</th>
<th scope="col">システム変数</th>
<th scope="col">ステータス変数</th>
<th scope="col">変数スコープ</th>
<th scope="col">動的</th>
</tr></thead><tbody><tr><th scope="row"><a class="link" href="server-administration.html#sysvar_bulk_insert_buffer_size">bulk_insert_buffer_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>両方</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#sysvar_concurrent_insert">concurrent_insert</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#sysvar_delay_key_write">delay_key_write</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#sysvar_have_rtree_keys">have_rtree_keys</a></th>
<td></td>
<td></td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#sysvar_key_buffer_size">key_buffer_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#option_mysqld_log-isam">log-isam</a></th>
<td>はい</td>
<td>はい</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#option_mysqld_myisam-block-size">myisam-block-size</a></th>
<td>はい</td>
<td>はい</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#sysvar_myisam_data_pointer_size">myisam_data_pointer_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#sysvar_myisam_max_sort_file_size">myisam_max_sort_file_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#sysvar_myisam_mmap_size">myisam_mmap_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#sysvar_myisam_recover_options">myisam_recover_options</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>いいえ</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#sysvar_myisam_repair_threads">myisam_repair_threads</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>両方</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#sysvar_myisam_sort_buffer_size">myisam_sort_buffer_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>両方</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#sysvar_myisam_stats_method">myisam_stats_method</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>両方</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#sysvar_myisam_use_mmap">myisam_use_mmap</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>グローバル</td>
<td>はい</td>
</tr><tr><th scope="row"><a class="link" href="server-administration.html#sysvar_tmp_table_size">tmp_table_size</a></th>
<td>はい</td>
<td>はい</td>
<td>はい</td>
<td></td>
<td>両方</td>
<td>はい</td>
</tr></tbody></table></div></div><br class="table-break"><p>
      次のシステム変数は <code class="literal">MyISAM</code> テーブルの振る舞いに影響を与えます。 追加情報については <a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>を参照してください。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">bulk_insert_buffer_size</code>
        </p><a class="indexterm" name="idm45568054950096"></a><a class="indexterm" name="idm45568054948544"></a><p>
          大量挿入の最適化に使用されるツリーキャッシュのサイズです。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            これは、<span class="emphasis"><em>スレッド当たりの</em></span>制限値です。
          </p></div></li><li class="listitem"><p>
          <code class="option">delay_key_write=ALL</code>
        </p><a class="indexterm" name="idm45568054943232"></a><a class="indexterm" name="idm45568054941696"></a><p>
          <code class="literal">MyISAM</code> テーブルへの書き込みの間にキーバッファーをフラッシュしないでください。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            これを行う場合、<code class="literal">MyISAM</code> テーブルの使用中に別のプログラムから (別の MySQL サーバーから、<span class="command"><strong>myisamchk</strong></span> を使用して、など)、このテーブルにアクセスしないでください。 そのようにすると、インデックスが破損するおそれがあります。 <code class="option">--external-locking</code> を利用しても、このリスクは回避されません。 
          </p></div></li><li class="listitem"><p>
          <code class="literal">myisam_max_sort_file_size</code>
        </p><a class="indexterm" name="idm45568054933040"></a><a class="indexterm" name="idm45568054931472"></a><p>
          <code class="literal">MyISAM</code> インデックスの再作成時 (<code class="literal">REPAIR TABLE</code>、<code class="literal">ALTER TABLE</code> または <code class="literal">LOAD DATA</code>) に MySQL で使用できる一時ファイルの最大サイズ。 ファイルサイズがこの値より大きい場合、さらに低速なキーキャッシュを代わりに使用してインデックスが作成されます。 値はバイト単位で指定されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">myisam_recover_options=<em class="replaceable"><code>mode</code></em></code>
        </p><a class="indexterm" name="idm45568054922784"></a><a class="indexterm" name="idm45568054921232"></a><p>
          クラッシュした <code class="literal">MyISAM</code> テーブルの自動リカバリにモードを設定します。
        </p></li><li class="listitem"><p>
          <code class="literal">myisam_sort_buffer_size</code>
        </p><a class="indexterm" name="idm45568054916240"></a><a class="indexterm" name="idm45568054914688"></a><p>
          テーブルのリカバリ時に使用されるバッファーのサイズを設定します。
        </p></li></ul></div><p>
      <code class="literal">myisam_recover_options</code> システム変数を設定して <span class="command"><strong>mysqld</strong></span> を起動すると、自動リカバリがアクティブ化されます。 この場合、サーバーが <code class="literal">MyISAM</code> テーブルを開いたときに、テーブルにクラッシュのマークが付いているかどうかや、テーブルのオープンカウント変数が 0 でないかどうか、そして外部ロックが使用不可能な状態でサーバーを作動させているかどうかを確認します。 これらの条件のいずれかが true である場合、次のことが起こります。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          サーバーは、テーブルにエラーがあるかどうかを確認します。
        </p></li><li class="listitem"><p>
          サーバーがエラーを検出した場合、迅速なテーブル修復を行います (データファイルのソートは行いますが、再作成は行いません)。
        </p></li><li class="listitem"><p>
          データファイルの中にエラーがあるために (たとえば、重複キーエラーなど) 修復が失敗した場合、サーバーは再試行して、今度はデータファイルを再作成します。
        </p></li><li class="listitem"><p>
          それでも修復が失敗した場合、サーバーはもう一度古い修復オプション方式で試行します (ソートをせずに行ごとに書き込みます)。 この方法は、どのタイプのエラーも修復できるはずであり、ディスク容量の要件は低くなっています。 
        </p></li></ul></div><p>
      リカバリで以前に完了したステートメントのすべての行をリカバリできず、<code class="literal">myisam_recover_options</code> システム変数の値に <code class="literal">FORCE</code> を指定しなかった場合、自動修復はエラーログにエラーメッセージとともに中断されます:
    </p><pre class="programlisting">Error: Couldn't repair table: test.g00pages
</pre><p>
      <code class="literal">FORCE</code> を指定すると、代わりにこのような警告が書かれます。
    </p><pre class="programlisting">Warning: Found 344 of 354 rows when repairing ./test/g00pages
</pre><p>
      自動リカバリ値に <code class="literal">BACKUP</code> が含まれている場合、リカバリプロセスでは、<code class="filename"><em class="replaceable"><code>tbl_name-datetime</code></em>.BAK</code> という形式の名前のファイルが作成されます。 これらのファイルを自動的にデータベースディレクトリからバックアップメディアに移動する <span class="command"><strong>cron</strong></span> スクリプトを持つことをお勧めします。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="key-space"></a>16.2.2 キーに必要な容量</h3></div></div></div><a class="indexterm" name="idm45568054892256"></a><p>
      <code class="literal">MyISAM</code> テーブルは B ツリーインデックスを使用します。 インデックスファイルのサイズは、キーを <code class="literal">(key_length+4)/0.67</code> と計算し、すべてのキーに対してその値を合計して概算できます。 これは、すべてのキーがソート順に挿入され、テーブル内のキーが圧縮されていなときの最悪なケースです。 
    </p><p>
      文字列のインデックスはスペース圧縮されています。 最初のインデックス部が文字列の場合、プリフィクスも圧縮されています。 文字列カラムに含まれる後続の空白が長い場合、またはそのカラムが <code class="literal">VARCHAR</code> カラムであるために、必ずしもその長さがフルに使用されることがない場合は、スペース圧縮によってインデックスファイルが最悪の数値よりも小さくなります。 プリフィクスの圧縮は文字列から始まるキーで使用されます。 多くの文字列が同一のプリフィクスで始まる場合、プリフィクスの圧縮が役に立ちます。 
    </p><p>
      <code class="literal">MyISAM</code> テーブルでは、テーブルの作成時に <code class="literal">PACK_KEYS=1</code> テーブルオプションを指定することで、数値のプリフィクスを圧縮することもできます。 数値は上位バイトから順に格納されるため、同一のプリフィクスを持つ整数キーが多数あるときに役立ちます。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="myisam-table-formats"></a>16.2.3 MyISAM テーブルのストレージフォーマット</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="storage-engines.html#static-format">16.2.3.1 静的 (固定長) テーブルの特長</a></span></dt><dt><span class="section"><a href="storage-engines.html#dynamic-format">16.2.3.2 動的テーブルの特徴</a></span></dt><dt><span class="section"><a href="storage-engines.html#compressed-format">16.2.3.3 圧縮テーブルの特徴</a></span></dt></dl></div><p>
      <code class="literal">MyISAM</code> は 3 つの異なるストレージフォーマットをサポートします。 使用するカラムの型によって、固定フォーマットと動的フォーマットの 2 つが自動的に選択されます。 3 つ目は圧縮フォーマットで、<span class="command"><strong>myisampack</strong></span> ユーティリティーを使用した場合にのみ作成できます (<a class="xref" href="programs.html#myisampack" title="4.6.6 myisampack — 圧縮された読み取り専用の MyISAM テーブルの生成">セクション4.6.6「myisampack — 圧縮された読み取り専用の MyISAM テーブルの生成」</a>を参照してください)。 
    </p><p>
      <code class="literal">BLOB</code> または <code class="literal">TEXT</code> カラムを持たないテーブルに対して、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> を使用する場合、<code class="literal">ROW_FORMAT</code> テーブルオプションで、テーブルフォーマットを強制的に <code class="literal">FIXED</code> または <code class="literal">DYNAMIC</code> にできます。
    </p><p>
      <code class="literal">ROW_FORMAT</code> についての情報は、<a class="xref" href="sql-statements.html#create-table" title="13.1.20 CREATE TABLE ステートメント">セクション13.1.20「CREATE TABLE ステートメント」</a>を参照してください。
    </p><p>
      <span class="command"><strong>myisamchk</strong></span> <code class="option">--unpack</code> を使用して、圧縮された <code class="literal">MyISAM</code> テーブルを解凍 (解凍) できます。詳細は、<a class="xref" href="programs.html#myisamchk" title="4.6.4 myisamchk — MyISAM テーブルメンテナンスユーティリティー">セクション4.6.4「myisamchk — MyISAM テーブルメンテナンスユーティリティー」</a> を参照してください。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="static-format"></a>16.2.3.1 静的 (固定長) テーブルの特長</h4></div></div></div><p>
        <code class="literal">MyISAM</code> テーブルでは、静的フォーマットがデフォルトです。 テーブルに可変長のカラムが含まれない場合に使用されます (<code class="literal">VARCHAR</code>、<code class="literal">VARBINARY</code>、<code class="literal">BLOB</code>、または <code class="literal">TEXT</code>)。 各行は固定バイト数で格納されます。 
      </p><p>
        3 つの <code class="literal">MyISAM</code> ストレージフォーマットの中で、静的フォーマットが一番シンプルで安全です (一番破損しにくい)。 またこれは、ディスク上でデータファイルの中の行が容易に検出できるという理由で、オンディスクフォーマットの中でもっとも高速です。インデックスの中の行数に基づいて行を検索するには、行数に行長を掛けて行の位置を計算します。 また、テーブルをスキャンするときに、ディスクの読み込み操作ごとに一定の行数を読み込むことが容易です。 
      </p><p>
        MySQL サーバーが固定フォーマットの <code class="literal">MyISAM</code> ファイルに書き込んでいる最中にコンピュータがクラッシュした場合、その安全性が証明されます。 この場合、<span class="command"><strong>myisamchk</strong></span> はそれぞれの行がどこで始まりどこで終わるかを簡単に判断できるため、通常、一部が書き込まれた行を除くすべての行を再利用できます。 <code class="literal">MyISAM</code> テーブルのインデックスは、データ行に基づいていつでも再構築できます。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          固定長の行形式は、<code class="literal">BLOB</code> または <code class="literal">TEXT</code> カラムを持たないテーブルでのみ使用できます。 明示的な <code class="literal">ROW_FORMAT</code> 句を使用してこのようなカラムを含むテーブルを作成しても、エラーや警告は発生せず、書式指定は無視されます。 
        </p></div><p>
        静的フォーマットのテーブルには、次の特徴があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CHAR</code> および <code class="literal">VARCHAR</code> カラムには、特定のカラム幅にスペースが埋め込まれます (しかし、カラムの型は変わりません)。 <code class="literal">BINARY</code> および <code class="literal">VARBINARY</code> カラムには、カラム幅に <code class="literal">0x00</code> バイトが埋め込まれます。 
          </p></li><li class="listitem"><p>
            <code class="literal">NULL</code> カラムの値が <code class="literal">NULL</code> であるかどうかを記録するには、行に追加の領域が必要です。 各 <code class="literal">NULL</code> カラムは 1 ビット余分に占め、もっとも近いバイトまで丸められます。 
          </p></li><li class="listitem"><p>
            非常に高速です。
          </p></li><li class="listitem"><p>
            キャッシュが容易です。
          </p></li><li class="listitem"><p>
            行が固定位置にあるため、クラッシュしたあとも再構築が容易です。
          </p></li><li class="listitem"><p>
            大量の行を削除して、空きディスク容量をオペレーティングシステムに戻す場合を除いて、再編成の必要はありません。 これを行うには、<code class="literal">OPTIMIZE TABLE</code> または <span class="command"><strong>myisamchk -r</strong></span> を使用します。 
          </p></li><li class="listitem"><p>
            通常は、動的フォーマットテーブルよりも多くのディスク容量を必要とします。
          </p></li><li class="listitem"><p>
            静的サイズの行に必要な行の長さ (バイト単位) は、次の式を使用して計算されます:
          </p><pre class="programlisting">row length = 1
             + (<em class="replaceable"><code>sum of column lengths</code></em>)
             + (<em class="replaceable"><code>number of NULL columns</code></em> + <em class="replaceable"><code>delete_flag</code></em> + 7)/8
             + (<em class="replaceable"><code>number of variable-length columns</code></em>)
</pre><p>
            <em class="replaceable"><code>delete_flag</code></em> は静的行フォーマットのテーブルに対しては 1 です。 静的テーブルは、行が削除されているかどうかを示すフラグとして、行レコード内の 1 ビットを使用します。このフラグは動的行ヘッダーに格納されるので、動的テーブルの場合、<em class="replaceable"><code>delete_flag</code></em> は 0 です。 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-format"></a>16.2.3.2 動的テーブルの特徴</h4></div></div></div><a class="indexterm" name="idm45568054825584"></a><a class="indexterm" name="idm45568054824112"></a><p>
        <code class="literal">MyISAM</code> テーブルが可変長カラムを含んでいる場合 (<code class="literal">VARCHAR</code>、<code class="literal">VARBINARY</code>、<code class="literal">BLOB</code>、または <code class="literal">TEXT</code>)、またはテーブルが <code class="literal">ROW_FORMAT=DYNAMIC</code> テーブルオプションで作成された場合は、動的ストレージフォーマットが使用されます。
      </p><p>
        動的フォーマットは、それぞれの行に行の長さを示すヘッダーがあるため、静的フォーマットよりも少し複雑です。 更新の結果として行が長くなった場合、行がフラグメント化される可能性があります (非連続的な断片で格納されます)。 
      </p><a class="indexterm" name="idm45568054814976"></a><p>
        <code class="literal">OPTIMIZE TABLE</code> または <span class="command"><strong>myisamchk -r</strong></span> を使用して、テーブルをデフラグできます。 可変長カラムも含んだテーブルで、固定長カラムに頻繁にアクセスしたり変更したりする場合、可変長カラムを他のテーブルに移動して、フラグメンテーションを回避する方法が良い場合があります。 
      </p><p>
        動的フォーマットのテーブルには、次の特徴があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            長さが 4 未満のカラムを除くすべての文字列カラムは動的です。
          </p></li><li class="listitem"><p>
            それぞれの行の先頭には、どのカラムが空の文字列 (文字列カラムの場合) またはゼロ (数値カラムの場合) を含むかを示すビットマップが付いています。 これには、<code class="literal">NULL</code> 値を含むカラムは含まれません。 後続スペースを削除したあとに文字列カラムの長さがゼロであったり、数値カラムの値がゼロであったりした場合、ビットマップの中でマークが付きますが、ディスクには保存されません。 空ではない文字列は、長さバイトに文字列コンテンツを加えて保存されます。 
          </p></li><li class="listitem"><p>
            <code class="literal">NULL</code> カラムの値が <code class="literal">NULL</code> であるかどうかを記録するには、行に追加の領域が必要です。 各 <code class="literal">NULL</code> カラムは 1 ビット余分に占め、もっとも近いバイトまで丸められます。 
          </p></li><li class="listitem"><p>
            通常、固定長テーブルに比べると、必要なディスク容量がかなり少なくなります。
          </p></li><li class="listitem"><p>
            それぞれの行は、必要とする容量だけを使用します。 ただし、行がさらに大きくなると、必要な数の断片に分割され、行のフラグメンテーションが起こることになります。 たとえば、行の長さを延長する情報を使って行を更新すると、その行はフラグメント化されます。 このような場合、パフォーマンスを上げるために、ときどき <code class="literal">OPTIMIZE TABLE</code> または <span class="command"><strong>myisamchk -r</strong></span> を実行しなければいけないかもしれません。 <span class="command"><strong>myisamchk -ei</strong></span> を使用して、テーブルの統計を取得します。 
          </p></li><li class="listitem"><p>
            行がいくつもの断片にフラグメント化されている場合や、リンク (フラグメント) が失われている場合があるため、クラッシュ後の再構築は、静的フォーマットテーブルよりも難しくなります。
          </p></li><li class="listitem"><p>
            動的サイズの行の予想される行長は、次の式で計算されます。
          </p><pre class="programlisting">3
+ (<em class="replaceable"><code>number of columns</code></em> + 7) / 8
+ (<em class="replaceable"><code>number of char columns</code></em>)
+ (<em class="replaceable"><code>packed size of numeric columns</code></em>)
+ (<em class="replaceable"><code>length of strings</code></em>)
+ (<em class="replaceable"><code>number of NULL columns</code></em> + 7) / 8
</pre><p>
            それぞれのリンクには 6 バイトのペナルティーがあります。 更新によって行が拡大される場合は、必ず動的行がリンクされます。 新しいリンクはそれぞれ少なくとも 20 バイトであるため、おそらく次の拡張は同じリンクになります。 そうでない場合、別のリンクが作成されます。 <span class="command"><strong>myisamchk -ed</strong></span> を利用してリンク数を確認できます。 <code class="literal">OPTIMIZE TABLE</code> または <span class="command"><strong>myisamchk -r</strong></span> を使用すると、すべてのリンクを削除できます。 
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="compressed-format"></a>16.2.3.3 圧縮テーブルの特徴</h4></div></div></div><a class="indexterm" name="idm45568054786704"></a><a class="indexterm" name="idm45568054784560"></a><a class="indexterm" name="idm45568054783200"></a><a class="indexterm" name="idm45568054781152"></a><p>
        圧縮ストレージフォーマットは、<span class="command"><strong>myisampack</strong></span> ツールで生成される読み取り専用のフォーマットです。 圧縮テーブルは <span class="command"><strong>myisamchk</strong></span> を使って解凍できます。 
      </p><p>
        圧縮テーブルには次のような特徴があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            圧縮テーブルに必要なディスク容量はごくわずかです。 これによりディスクの使用量は最少になるため、低速のディスクを使用する場合に役立ちます (CD-ROM など)。 
          </p></li><li class="listitem"><p>
            それぞれの行は個々に圧縮されるため、アクセスのオーバーヘッドはごくわずかです。 行のヘッダーに必要なバイト数は、テーブル中の一番大きい行によって異なりますが、1 - 3 バイトです。 各カラムは別々に圧縮されます。 カラムごとに異なる Huffman ツリーがあるのが一般的です。 圧縮タイプのいくつかは次のとおりです。 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                サフィクススペース圧縮。
              </p></li><li class="listitem"><p>
                プリフィクススペース圧縮。
              </p></li><li class="listitem"><p>
                値が 0 の数値は 1 ビットで格納されます。
              </p></li><li class="listitem"><p>
                値の範囲が小さい整数カラムは、可能なかぎり小さな型を使って格納されます。 たとえば、<code class="literal">BIGINT</code> カラム (8 バイト) のすべての値が <code class="literal">-128</code> から <code class="literal">127</code> の範囲内にある場合は、このカラムを <code class="literal">TINYINT</code> カラム (1 バイト) として格納できます。 
              </p></li><li class="listitem"><p>
                カラムの可能値が少ない場合は、データの型を <code class="literal">ENUM</code>に変換します。
              </p></li><li class="listitem"><p>
                カラムに、上記の圧縮型を組み合わせて使用してもかまいません。
              </p></li></ul></div></li><li class="listitem"><p>
            固定長または動的長の行を使用できます。
          </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          圧縮テーブルは読み取り専用なので、テーブルの行を更新したり、行を追加したりはできませんが、DDL (データ定義言語) 操作は有効です。 たとえば、<code class="literal">DROP</code> を使用してテーブルを削除しても、<code class="literal">TRUNCATE TABLE</code> を使用してテーブルを空にしてもかまいません。 
        </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="myisam-table-problems"></a>16.2.4 MyISAM テーブルの問題点</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="storage-engines.html#corrupted-myisam-tables">16.2.4.1 MyISAM テーブルの破損</a></span></dt><dt><span class="section"><a href="storage-engines.html#myisam-table-close">16.2.4.2 適切に閉じられなかったテーブルの問題</a></span></dt></dl></div><p>
      MySQL がデータの格納に使用するファイルフォーマットは幅広い検査を受けていますが、データベーステーブルの破損を招きかねない状況は常に存在します。 次に、これがどのようにして起こるのか、またどのように対処すればよいのかについて説明します。 
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="corrupted-myisam-tables"></a>16.2.4.1 MyISAM テーブルの破損</h4></div></div></div><p>
        <code class="literal">MyISAM</code> のテーブルフォーマットは、きわめて信頼性の高いフォーマットです (SQL ステートメントが行うテーブルに対するすべての変更は、そのステートメントが戻る前に書き込まれます) が、それでも次の状況が発生した場合、テーブルが破損するおそれがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="command"><strong>mysqld</strong></span> プロセスは、書き込みの最中に強制終了されます。
          </p></li><li class="listitem"><p>
            コンピュータが予期せずシャットダウンされます (たとえば、コンピューターの電源が切られた場合など)。
          </p></li><li class="listitem"><p>
            ハードウェア障害。
          </p></li><li class="listitem"><p>
            サーバーが修正中のテーブルを、外部プログラム (<span class="command"><strong>myisamchk</strong></span>など) を使用して同時に修正しています。
          </p></li><li class="listitem"><p>
            MySQL または <code class="literal">MyISAM</code> コードのソフトウェアバグです。
          </p></li></ul></div><p>
        テーブルが破損した場合の典型的な兆候は、次のとおりです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブルからデータを選択するときに、次のエラーが表示されます。
          </p><pre class="programlisting">Incorrect key file for table: '...'. Try to repair it
</pre></li><li class="listitem"><p>
            クエリーが、テーブル内で行を検出しない、または不完全な結果を返します。
          </p></li></ul></div><p>
        <code class="literal">MyISAM</code> テーブルのヘルスを <code class="literal">CHECK TABLE</code> ステートメントを利用して確認でき、破損した <code class="literal">MyISAM</code> テーブルを <code class="literal">REPAIR TABLE</code> を利用して修復できます。 <span class="command"><strong>mysqld</strong></span> が動作していない場合は、<span class="command"><strong>myisamchk</strong></span> コマンドを利用してテーブルを確認したり修復したりすることもできます。 <a class="xref" href="sql-statements.html#check-table" title="13.7.3.2 CHECK TABLE ステートメント">セクション13.7.3.2「CHECK TABLE ステートメント」</a>、<a class="xref" href="sql-statements.html#repair-table" title="13.7.3.5 REPAIR TABLE ステートメント">セクション13.7.3.5「REPAIR TABLE ステートメント」</a>、および<a class="xref" href="programs.html#myisamchk" title="4.6.4 myisamchk — MyISAM テーブルメンテナンスユーティリティー">セクション4.6.4「myisamchk — MyISAM テーブルメンテナンスユーティリティー」</a>を参照してください。 
      </p><p>
        テーブルが頻繁に破損する場合は、その原因を突き止めるようにしてください。 最も重要なことは、予期しないサーバー終了の結果としてテーブルが破損したかどうかです。 エラーログの最新の <code class="literal">restarted mysqld</code> メッセージを探すと、簡単に検証できます。 このようなメッセージがある場合、テーブルの破損はサーバーのダウンによる可能性が高くなります。 そうでなければ、破損は通常作業の最中に起きた可能性があります。 これはバグです。 問題点を明らかにする再現可能なテストケースを作成するべきです。 <a class="xref" href="error-handling.html#crashing" title="B.3.3.3 MySQL が繰り返しクラッシュする場合の対処方法">セクションB.3.3.3「MySQL が繰り返しクラッシュする場合の対処方法」</a>および<a class="xref" href="server-administration.html#debugging-mysql" title="5.9 MySQL のデバッグ">セクション5.9「MySQL のデバッグ」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="myisam-table-close"></a>16.2.4.2 適切に閉じられなかったテーブルの問題</h4></div></div></div><p>
        各 <code class="literal">MyISAM</code> インデックスファイル (<code class="filename">.MYI</code> ファイル) には、テーブルが適切に閉じられたかどうかをチェックするために使用できるカウンタがヘッダーの中にあります。 <code class="literal">CHECK TABLE</code> または <span class="command"><strong>myisamchk</strong></span> から次のような警告が表示された場合、このカウンタの同期が取れていないことを示しています。 
      </p><pre class="programlisting">clients are using or haven't closed the table properly
</pre><p>
        この警告は、必ずしもテーブルが破損されたという意味ではありませんが、少なくともテーブルを確認したほうがよいでしょう。
      </p><p>
        カウンターは次のように機能します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL でテーブルが最初に更新されるときに、インデックスファイルのヘッダー内にあるカウンタが増えます。
          </p></li><li class="listitem"><p>
            その後の更新ではカウンタは変更されません。
          </p></li><li class="listitem"><p>
            テーブルの最後のインスタンスが閉じられるとき (<code class="literal">FLUSH TABLES</code> 操作が行われたため、またはテーブルキャッシュの中に場所がないため) に、それまでにテーブルが更新されていると、カウンタの値が減少します。
          </p></li><li class="listitem"><p>
            テーブルを修復するか、チェックして問題がなかった場合は、カウンタがゼロにリセットされます。
          </p></li><li class="listitem"><p>
            テーブルを検査する可能性のあるほかのプロセスとの相互作用の問題を回避するため、カウンタがゼロである場合は、テーブルを閉じる際にカウンタの値は減りません。
          </p></li></ul></div><p>
        つまり、カウンタが不正確になる可能性があるのは、次のような場合だけです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">MyISAM</code> テーブルのコピーが、最初に <code class="literal">LOCK TABLES</code> と <code class="literal">FLUSH TABLES</code> を発行しないで行われる。
          </p></li><li class="listitem"><p>
            MySQL が更新されてから閉じられるまでの間にクラッシュした。 (MySQL は常に各ステートメントの間のすべてに対して書込みを発行するため、テーブルは問題ない可能性があります。) 
          </p></li><li class="listitem"><p>
            <span class="command"><strong>mysqld</strong></span> と同時に使用した <span class="command"><strong>myisamchk --recover</strong></span> か <span class="command"><strong>myisamchk --update-state</strong></span> によって、テーブルが修正された。
          </p></li><li class="listitem"><p>
            別のサーバーによって使用されている最中に、複数の <span class="command"><strong>mysqld</strong></span> サーバーがテーブルを使用し、1 つのサーバーが <code class="literal">REPAIR TABLE</code> または <code class="literal">CHECK TABLE</code> をテーブルで実行した。 このセットアップでは、ほかのサーバーから警告を受ける可能性がありますが、<code class="literal">CHECK TABLE</code> の使用が安全です。 しかし、あるサーバーがデータファイルを新しいファイルに置き換えた場合、別のサーバーには通知されないため、<code class="literal">REPAIR TABLE</code> は避けるべきです。 
          </p><p>
            一般的に、複数のサーバー間でデータディレクトリを共有することは推奨されません。 追加情報については、<a class="xref" href="server-administration.html#multiple-servers" title="5.8 1 つのマシン上での複数の MySQL インスタンスの実行">セクション5.8「1 つのマシン上での複数の MySQL インスタンスの実行」</a>を参照してください。 
          </p></li></ul></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="memory-storage-engine"></a>16.3 MEMORY ストレージエンジン</h2></div></div></div><a class="indexterm" name="idm45568054697312"></a><a class="indexterm" name="idm45568054695824"></a><a class="indexterm" name="idm45568054694416"></a><a class="indexterm" name="idm45568054692496"></a><p>
    <code class="literal">MEMORY</code> ストレージエンジン (従来は <code class="literal">HEAP</code> と呼ばれていました) は、メモリーに格納された内容で特定用途のテーブルを作成します。 データは、クラッシュ、ハードウェア問題、または電源停止に弱いため、これらのテーブルは、一時的な作業領域またはほかのテーブルから抽出されたデータの読み取り専用キャッシュとして使用されるだけです。 
  </p><div class="table"><a name="idm45568054687872"></a><p class="title"><b>表 16.4 「MEMORY ストレージエンジンの機能」</b></p><div class="table-contents"><table frame="box" rules="all" summary="「MEMORY ストレージエンジンでサポートされる機能。」"><col style="width: 60%"><col style="width: 40%"><thead><tr><th>機能</th>
<th>Support</th>
</tr></thead><tbody><tr><td><span class="bold"><strong>B ツリーインデックス</strong></span></td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>MVCC</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>T ツリーインデックス</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>インデックスキャッシュ</strong></span></td>
<td>N/A</td>
</tr><tr><td><span class="bold"><strong>クラスタデータベースのサポート</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>クラスタ化されたインデックス</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>ストレージの制限</strong></span></td>
<td>RAM</td>
</tr><tr><td><span class="bold"><strong>データキャッシュ</strong></span></td>
<td>N/A</td>
</tr><tr><td><span class="bold"><strong>データディクショナリ向け更新統計</strong></span></td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>トランザクション</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>ハッシュインデックス</strong></span></td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>バックアップ/ポイントインタイムリカバリ</strong></span> (ストレージエンジン内ではなくサーバー内で実装されています。)</td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>レプリケーションのサポート</strong></span> (ストレージエンジン内ではなくサーバー内で実装されています。)</td>
<td>制限付き (このセクションの後半の説明を参照してください。)</td>
</tr><tr><td><span class="bold"><strong>ロック粒度</strong></span></td>
<td>Table</td>
</tr><tr><td><span class="bold"><strong>全文検索インデックス</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>圧縮データ</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>地理空間インデックスのサポート</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>地理空間データ型のサポート</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>外部キーのサポート</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>暗号化データ</strong></span></td>
<td>はい (暗号化機能を介してサーバーに実装されます。)</td>
</tr></tbody></table></div></div><br class="table-break"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="storage-engines.html#memory-storage-engine-compared-cluster" title="MEMORY または NDB Cluster を使用する場合">MEMORY または NDB Cluster を使用する場合</a></p></li><li class="listitem"><p><a class="xref" href="storage-engines.html#memory-storage-engine-partitioning" title="パーティション化">パーティション化</a></p></li><li class="listitem"><p><a class="xref" href="storage-engines.html#memory-storage-engine-performance-characteristics" title="パフォーマンスの特徴">パフォーマンスの特徴</a></p></li><li class="listitem"><p><a class="xref" href="storage-engines.html#memory-storage-engine-characteristics-of-memory-tables" title="MEMORY テーブルの特性">MEMORY テーブルの特性</a></p></li><li class="listitem"><p><a class="xref" href="storage-engines.html#memory-storage-engine-ddl-operations-for-memory-tables" title="MEMORY テーブルへの DDL 操作">MEMORY テーブルへの DDL 操作</a></p></li><li class="listitem"><p><a class="xref" href="storage-engines.html#memory-storage-engine-indexes" title="インデックス">インデックス</a></p></li><li class="listitem"><p><a class="xref" href="storage-engines.html#memory-storage-engine-user-created-and-temporary-tables" title="ユーザー作成の一時テーブル">ユーザー作成の一時テーブル</a></p></li><li class="listitem"><p><a class="xref" href="storage-engines.html#memory-storage-engine-loading-data" title="データのロード">データのロード</a></p></li><li class="listitem"><p><a class="xref" href="storage-engines.html#memory-tables-replication" title="MEMORY テーブルとレプリケーション">MEMORY テーブルとレプリケーション</a></p></li><li class="listitem"><p><a class="xref" href="storage-engines.html#memory-storage-engine-managing-memory-use" title="メモリー使用量の管理">メモリー使用量の管理</a></p></li><li class="listitem"><p><a class="xref" href="storage-engines.html#memory-storage-engine-additional-resources" title="追加のリソース">追加のリソース</a></p></li></ul></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="memory-storage-engine-compared-cluster"></a>MEMORY または NDB Cluster を使用する場合</h3></div></div></div><p>
      重要で可用性の高い、または頻繁に更新されるデータのために <code class="literal">MEMORY</code> ストレージエンジンを使用するアプリケーションを配備する開発者は、NDB Cluster の方がよいかどうかを考慮するようにしてください。 <code class="literal">MEMORY</code> エンジンの典型的なユースケースには、次の特徴があります。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          セッション管理やキャッシングなどの一時的で重要でないデータに関連する操作。 MySQL サーバーが停止または再起動したときに、<code class="literal">MEMORY</code> テーブルのデータは失われます。 
        </p></li><li class="listitem"><p>
          高速アクセスおよび低待機時間のためのインメモリー保存。 データボリュームはメモリー内に完全に収まり、オペレーティングシステムによる仮想メモリーページのスワップアウトはありません。 
        </p></li><li class="listitem"><p>
          読み取り専用または読み取りが大半のデータのアクセスパターン (更新が制限されています)。
        </p></li></ul></div><p>
      NDB Cluster は、より高いパフォーマンスレベルの <code class="literal">MEMORY</code> エンジンと同じ機能を提供し、<code class="literal">MEMORY</code> では使用できない追加機能を提供します:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          クライアント間で競合の少ない行レベルロックとマルチスレッド操作。
        </p></li><li class="listitem"><p>
          書き込みを含むステートメント混在時の拡張性。
        </p></li><li class="listitem"><p>
          データ持続性のためのディスクバックアップ式操作 (オプション)。
        </p></li><li class="listitem"><p>
          単一障害点がない、シェアードナッシングアーキテクチャーと複数ホスト操作。99.999% の可用性を実現できます。
        </p></li><li class="listitem"><p>
          ノードをまたがる自動データ分散。アプリケーションの開発者はカスタムの共有またはパーティション化ソリューションを作る必要がありません。
        </p></li><li class="listitem"><p>
          可変長データ型 (<code class="literal">MEMORY</code> がサポートしない <code class="literal">BLOB</code> および <code class="literal">TEXT</code> を含みます) をサポートします。
        </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="memory-storage-engine-partitioning"></a>パーティション化</h3></div></div></div><p>
      <code class="literal">MEMORY</code> テーブルはパーティション化できません。
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="memory-storage-engine-performance-characteristics"></a>パフォーマンスの特徴</h3></div></div></div><p>
      <code class="literal">MEMORY</code> のパフォーマンスは、更新処理時のシングルスレッド実行とテーブルロックオーバーヘッドが原因の競合によって抑制されます。 このため、負荷が増えたときに拡張性が制限されます (特に、書き込みを含むステートメント混在時)。 
    </p><p>
      <code class="literal">MEMORY</code> テーブルのインメモリー処理にかかわらず、それらは、汎用目的クエリーのために、または読み取り/書き込み負荷では、必ずしもビジーサーバーの <code class="literal">InnoDB</code> テーブルより高速である必要はありません。 特に、更新実行に関与するテーブルロックは、複数セッションからの <code class="literal">MEMORY</code> テーブルの並列使用の速度を低下させる可能性があります。 
    </p><p>
      <code class="literal">MEMORY</code> テーブルで実行されるクエリーの種類によっては、デフォルトのハッシュデータ構造 (一意キーで 1 つの値を検索する場合)、または汎用目的の B ツリーデータ構造 (等号、不等号、未満または「- を超える」などの範囲演算子などを含むすべての種類のクエリーの場合) のいずれかとしてインデックスを作成する場合があります。 次のセクションでは、両方の種類のインデックスを作成するための構文について説明します。 パフォーマンス面でよくある問題は、B ツリーインデックスがより効率的な作業負荷で、デフォルトのハッシュインデックスを使用していることです。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="memory-storage-engine-characteristics-of-memory-tables"></a>MEMORY テーブルの特性</h3></div></div></div><p>
      <code class="literal">MEMORY</code> ストレージエンジンは、ディスク上にファイルを作成しません。 テーブル定義は、MySQL データディクショナリに格納されます。 
    </p><p>
      <code class="literal">MEMORY</code> テーブルには次のような特徴があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">MEMORY</code> テーブルの領域は小さなブロックに割り当てられます。 テーブルは、挿入に 100% 動的ハッシュを使用します。 オーバーフロー領域や余分なキー領域は必要ありません。 フリーリスト用の余分な領域は必要ありません。 削除された行はリンクリストに置かれ、新しいデータをテーブルに挿入するときに再利用されます。 <code class="literal">MEMORY</code> テーブルでは、ハッシュテーブルで一般的に削除 + 挿入に関連付けられる問題も起こりません。 
        </p></li><li class="listitem"><p>
          <code class="literal">MEMORY</code> テーブルは固定長の行ストレージフォーマットを使用します。 <code class="literal">VARCHAR</code> などの可変長型は、固定長を使用して格納されます。 
        </p></li><li class="listitem"><p>
          <code class="literal">MEMORY</code> テーブルは <code class="literal">BLOB</code> または <code class="literal">TEXT</code> カラムを含むことができません。
        </p></li><li class="listitem"><p>
          <code class="literal">MEMORY</code> は <code class="literal">AUTO_INCREMENT</code> カラムのサポートを含みます。
        </p></li><li class="listitem"><p>
          <code class="literal">TEMPORARY</code> <code class="literal">MEMORY</code> でないテーブルは、ほかの <code class="literal">TEMPORARY</code> でないテーブルと同様に、すべてのクライアントで共有されます。
        </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="memory-storage-engine-ddl-operations-for-memory-tables"></a>MEMORY テーブルへの DDL 操作</h3></div></div></div><p>
      <code class="literal">MEMORY</code> テーブルを作成するには、<code class="literal">CREATE TABLE</code> ステートメントで <code class="literal">ENGINE=MEMORY</code> 句を指定します。
    </p><pre class="programlisting">CREATE TABLE t (i INT) ENGINE = MEMORY;
</pre><p>
      エンジンの名前が表すように、<code class="literal">MEMORY</code> テーブルはメモリーに格納されます。 デフォルトではハッシュインデックスを使用するため、単一値の検索には非常に高速であり、一時テーブルの作成には非常に役立ちます。 ただし、サーバーがシャットダウンすると、<code class="literal">MEMORY</code> テーブルに格納されたすべての行が失われます。 定義は MySQL データディクショナリに格納されますが、サーバーの再起動時には空であるため、テーブル自体は引き続き存在します。 
    </p><p>
      この例は、<code class="literal">MEMORY</code> テーブルをどのように作成、使用、および削除できるかを示しています。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE test ENGINE=MEMORY</code></strong>
           <strong class="userinput"><code>SELECT ip,SUM(downloads) AS down</code></strong>
           <strong class="userinput"><code>FROM log_table GROUP BY ip;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT COUNT(ip),AVG(down) FROM test;</code></strong>
mysql&gt; <strong class="userinput"><code>DROP TABLE test;</code></strong>
</pre><p>
      <code class="literal">MEMORY</code> テーブルの最大サイズは <code class="literal">max_heap_table_size</code> システム変数によって制限されます (デフォルト値は 16M バイト)。 <code class="literal">MEMORY</code> テーブルに異なるサイズ制限を適用するには、この変数値を変更します。 <code class="literal">CREATE TABLE</code>、それに続く <code class="literal">ALTER TABLE</code> または <code class="literal">TRUNCATE TABLE</code> の実質的な値は、テーブルの有効期限に使用される値です。 サーバーを再起動しても、既存の <code class="literal">MEMORY</code> テーブルの最大サイズがグローバルの <code class="literal">max_heap_table_size</code> 値に設定されます。 各テーブルのサイズをこのセクションの後半で説明するように設定できます。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="memory-storage-engine-indexes"></a>インデックス</h3></div></div></div><p>
      <code class="literal">MEMORY</code> ストレージエンジンは <code class="literal">HASH</code> と <code class="literal">BTREE</code> の両方のインデックスをサポートしています。 ここに示すように <code class="literal">USING</code> 句を追加することによりどちらであるかを指定できます。 
    </p><pre class="programlisting">CREATE TABLE lookup
    (id INT, INDEX USING HASH (id))
    ENGINE = MEMORY;
CREATE TABLE lookup
    (id INT, INDEX USING BTREE (id))
    ENGINE = MEMORY;
</pre><p>
      B ツリーとハッシュインデックスの一般的な特徴については、<a class="xref" href="optimization.html#mysql-indexes" title="8.3.1 MySQL のインデックスの使用の仕組み">セクション8.3.1「MySQL のインデックスの使用の仕組み」</a>を参照してください。
    </p><p>
      <code class="literal">MEMORY</code> テーブルでは、テーブル当たり最大で 64 個のインデックス、インデックス当たり 16 個のカラム、3072 バイトの最大キー長を持つことができます。
    </p><p>
      <code class="literal">MEMORY</code> テーブルのハッシュインデックスでキーの重複の程度が高いと (同じ値を含むインデックスエントリが多い)、キー値に影響を与えるテーブルへの更新処理とすべての削除処理の速度が大きく低下します。 この低下の程度は重複の程度に比例します (または、インデックスカーディナリティーに反比例します)。 <code class="literal">BTREE</code> インデックスを使用することで、この問題を回避できます。 
    </p><p>
      <code class="literal">MEMORY</code> テーブルには、非一意キーを持つことができます。 (これは、ハッシュインデックスの実装ではまれな特徴です。) 
    </p><p>
      インデックスが付けられたカラムに <code class="literal">NULL</code> 値を含むことができます。
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="memory-storage-engine-user-created-and-temporary-tables"></a>ユーザー作成の一時テーブル</h3></div></div></div><p>
      <code class="literal">MEMORY</code> テーブルの内容はメモリーに格納されます。これは <code class="literal">MEMORY</code> テーブルが、クエリーの処理中にその場でサーバーが作成する内部一時テーブルと共有する特性です。 ただし、2 つのタイプのテーブルには違いがあり、<code class="literal">MEMORY</code> テーブルはストレージ変換の影響を受けませんが、内部一時テーブルは次のような影響があります。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          内部一時テーブルが大きくなりすぎると、<a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4 MySQL での内部一時テーブルの使用">セクション8.4.4「MySQL での内部一時テーブルの使用」</a>で説明したように、サーバーは自動的にオンディスクストレージに変換します。
        </p></li><li class="listitem"><p>
          ユーザー作成の <code class="literal">MEMORY</code> テーブルは、決してディスクテーブルに変換されません。
        </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="memory-storage-engine-loading-data"></a>データのロード</h3></div></div></div><p>
      MySQL サーバーの起動時に <code class="literal">MEMORY</code> テーブルに移入するには、<code class="literal">init_file</code> システム変数を使用できます。 たとえば、<code class="literal">INSERT INTO ... SELECT</code> や <code class="literal">LOAD DATA</code> などのステートメントをファイルに挿入して永続データソースからテーブルをロードし、<code class="literal">init_file</code> を使用してファイルに名前を付けることができます。 <a class="xref" href="server-administration.html#server-system-variables" title="5.1.8 サーバーシステム変数">セクション5.1.8「サーバーシステム変数」</a>および<a class="xref" href="sql-statements.html#load-data" title="13.2.7 LOAD DATA ステートメント">セクション13.2.7「LOAD DATA ステートメント」</a>を参照してください。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="memory-tables-replication"></a>MEMORY テーブルとレプリケーション</h3></div></div></div><p>
      レプリケーションソースサーバーが停止して再起動すると、その <code class="literal">MEMORY</code> テーブルは空になります。 この効果をレプリカにレプリケートするには、ソースが起動後に最初に特定の <code class="literal">MEMORY</code> テーブルを使用するときに、そのテーブルの <code class="literal">DELETE</code> ステートメントまたは (MySQL 8.0.22 から) <code class="literal">TRUNCATE TABLE</code> ステートメントをバイナリログに書き込むことによってテーブルを空にする必要があることをレプリカに通知するイベントをログに記録します。 レプリカサーバーを停止して再起動すると、その <code class="literal">MEMORY</code> テーブルも空になり、<code class="literal">DELETE</code> または (MySQL 8.0.22 から) <code class="literal">TRUNCATE TABLE</code> ステートメントが独自のバイナリログに書き込まれ、ダウンストリームレプリカに渡されます。 
    </p><p>
      レプリケーショントポロジで <code class="literal">MEMORY</code> テーブルを使用する場合、状況によっては、ソースのテーブルとレプリカのテーブルが異なることがあります。 失効した読取りまたはエラーを防ぐためのこれらの各状況の処理の詳細は、<a class="xref" href="replication.html#replication-features-memory" title="17.5.1.21 レプリケーションと MEMORY テーブル">セクション17.5.1.21「レプリケーションと MEMORY テーブル」</a> を参照してください。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="memory-storage-engine-managing-memory-use"></a>メモリー使用量の管理</h3></div></div></div><p>
      サーバーには、同時に使用されるすべての <code class="literal">MEMORY</code> テーブルを保持するための十分なメモリーが必要です。
    </p><p>
      <code class="literal">MEMORY</code> テーブルから各行を削除しても、メモリーは再利用されません。 テーブル全体が削除された場合にのみ、メモリーが再利用されます。 削除された行に以前に使用されたメモリーは同じテーブル内の新しい行に再利用されます。 <code class="literal">MEMORY</code> テーブルの内容が必要でなくなったときに、それが使用していたすべてのメモリーを解放するには、<code class="literal">DELETE</code> または <code class="literal">TRUNCATE TABLE</code> を実行してすべての行を削除するか、<code class="literal">DROP TABLE</code> を使用してテーブルを完全に削除します。 削除された行が使用していたメモリーを解放するには、<code class="literal">ALTER TABLE ENGINE=MEMORY</code> を使用してテーブルを強制的に再作成します。 
    </p><p>
      <code class="literal">MEMORY</code> テーブルで 1 つの行に必要なメモリーは、次の式で計算されます。
    </p><pre class="programlisting">SUM_OVER_ALL_BTREE_KEYS(<em class="replaceable"><code>max_length_of_key</code></em> + sizeof(char*) * 4)
+ SUM_OVER_ALL_HASH_KEYS(sizeof(char*) * 2)
+ ALIGN(<em class="replaceable"><code>length_of_row</code></em>+1, sizeof(char*))
</pre><p>
      <code class="literal">ALIGN()</code> は行の長さを <code class="literal">char</code> ポインタサイズのちょうど倍数にするための切り上げ係数を表します。<code class="literal">sizeof(char*)</code> は 32 ビットマシンでは 4、64 ビットマシンでは 8 です。
    </p><p>
      前に述べたように、<code class="literal">max_heap_table_size</code> システム変数は <code class="literal">MEMORY</code> テーブルの最大サイズの制限値を設定します。 各テーブルの最大サイズを制御するには、各テーブルを作成する前に、この変数のセッション値を設定します。 (すべてのクライアントが作成した <code class="literal">MEMORY</code> テーブルに、グローバル <code class="literal">max_heap_table_size</code> 値を使用するのでなければ、この値を変更しないでください。) 次は、2 つの <code class="literal">MEMORY</code> テーブル (最大サイズがそれぞれ 1M バイトと 2M バイト) を作成する例です。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET max_heap_table_size = 1024*1024;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (id INT, UNIQUE(id)) ENGINE = MEMORY;</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>SET max_heap_table_size = 1024*1024*2;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (id INT, UNIQUE(id)) ENGINE = MEMORY;</code></strong>
Query OK, 0 rows affected (0.00 sec)
</pre><p>
      両方のテーブルは、サーバーが再起動した場合、サーバーのグローバル <code class="literal">max_heap_table_size</code> 値に戻ります。
    </p><p>
      <code class="literal">MEMORY</code> テーブルに対して <code class="literal">CREATE TABLE</code> ステートメントの <code class="literal">MAX_ROWS</code> テーブルオプションを指定して、テーブルに格納する予定の行数に関するヒントを提供することもできます。 これによって <code class="literal">max_heap_table_size</code> 値 (引き続き最大テーブルサイズの制約として機能) を超えてテーブルが拡大できなくなります。 <code class="literal">MAX_ROWS</code> を使用できるだけの最大限の柔軟性を得るには、少なくとも各 <code class="literal">MEMORY</code> テーブルが拡大できる値程度に <code class="literal">max_heap_table_size</code> を設定してください。 
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="memory-storage-engine-additional-resources"></a>追加のリソース</h3></div></div></div><p>
      <code class="literal">MEMORY</code> ストレージエンジンに特化したフォーラムは、<a class="ulink" href="https://forums.mysql.com/list.php?92" target="_top">https://forums.mysql.com/list.php?92</a>で参照できます。
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="csv-storage-engine"></a>16.4 CSV ストレージエンジン</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="storage-engines.html#se-csv-repair">16.4.1 CSV テーブルの修復と確認</a></span></dt><dt><span class="section"><a href="storage-engines.html#se-csv-limitations">16.4.2 CSV の制限</a></span></dt></dl></div><a class="indexterm" name="idm45568054462912"></a><a class="indexterm" name="idm45568054461424"></a><p>
    <code class="literal">CSV</code> ストレージエンジンは、カンマ区切り値形式を使用してデータをテキストファイルに保存します。
  </p><p>
    <code class="literal">CSV</code> ストレージエンジンは、常に MySQL サーバーにコンパイルされます。
  </p><p>
    <code class="literal">CSV</code> エンジンのソースを調べるには、MySQL ソース配布の <code class="filename">storage/csv</code> ディレクトリを検索します。
  </p><p>
    <code class="literal">CSV</code> テーブルを作成すると、サーバーは、名前がテーブル名で始まり <code class="filename">.CSV</code> 拡張子を持つプレーンテキストデータファイルを作成します。 データをテーブルに保存するとき、ストレージエンジンはデータファイルにカンマ区切り値形式で保存します。 
  </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE test (i INT NOT NULL, c CHAR(10) NOT NULL)</code></strong>
       <strong class="userinput"><code>ENGINE = CSV;</code></strong>
Query OK, 0 rows affected (0.06 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO test VALUES(1,'record one'),(2,'record two');</code></strong>
Query OK, 2 rows affected (0.05 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM test;</code></strong>
+---+------------+
| i | c          |
+---+------------+
| 1 | record one |
| 2 | record two |
+---+------------+
2 rows in set (0.00 sec)
</pre><p>
    <code class="literal">CSV</code> テーブルを作成すると、テーブルの状態およびテーブルに存在する行数を格納する対応するメタファイルも作成されます。 このファイルの名前は <code class="filename">CSM</code> 拡張子のついたテーブル名と同じです。 
  </p><p>
    前のステートメントの実行で作成されたデータベースディレクトリにある <code class="filename">test.CSV</code> ファイルを調べると、その内容は次のようであるはずです。
  </p><pre class="programlisting">"1","record one"
"2","record two"
</pre><p>
    この形式は、Microsoft Excel などのスプレッドシートアプリケーションによって読取りおよび書込みが可能です。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="se-csv-repair"></a>16.4.1 CSV テーブルの修復と確認</h3></div></div></div><p>
      <code class="literal">CSV</code> ストレージエンジンは、破損した <code class="literal">CSV</code> テーブルを検証し、可能な場合は修復するための <code class="literal">CHECK TABLE</code> および <code class="literal">REPAIR TABLE</code> ステートメントをサポートしています。
    </p><p>
      <code class="literal">CHECK TABLE</code> ステートメントを実行すると、正しいフィールドセパレータ、エスケープされたフィールド (一致する引用符または欠落している引用符)、テーブル定義と比較した正しいフィールド数および対応する <code class="literal">CSV</code> メタファイルの存在を検索することで、<code class="literal">CSV</code> ファイルの妥当性がチェックされます。 最初に検出された無効な行が原因でエラーが発生します。 有効なテーブルをチェックすると、次に示すような出力が生成されます: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CHECK TABLE csvtest;</code></strong>
+--------------+-------+----------+----------+
| Table        | Op    | Msg_type | Msg_text |
+--------------+-------+----------+----------+
| test.csvtest | check | status   | OK       |
+--------------+-------+----------+----------+
</pre><p>
      破損したテーブルをチェックすると、次のようなフォルトが返されます
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CHECK TABLE csvtest;</code></strong>
+--------------+-------+----------+----------+
| Table        | Op    | Msg_type | Msg_text |
+--------------+-------+----------+----------+
| test.csvtest | check | error    | Corrupt  |
+--------------+-------+----------+----------+
</pre><p>
      テーブルを修復するには、<code class="literal">REPAIR TABLE</code> を使用します。これにより、既存の <code class="literal">CSV</code> データから可能なかぎり多くの有効な行がコピーされ、既存の <code class="literal">CSV</code> ファイルがリカバリされた行で置換されます。 破損したデータ以降のすべての行は失われます。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>REPAIR TABLE csvtest;</code></strong>
+--------------+--------+----------+----------+
| Table        | Op     | Msg_type | Msg_text |
+--------------+--------+----------+----------+
| test.csvtest | repair | status   | OK       |
+--------------+--------+----------+----------+
</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
        修復中、破損した最初の行までの <code class="literal">CSV</code> ファイルの行のみが新しいテーブルにコピーされます。 破損した最初の行からテーブルの最後までのほかのすべての行は、有効な行であっても削除されます。 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="se-csv-limitations"></a>16.4.2 CSV の制限</h3></div></div></div><p>
      <code class="literal">CSV</code> ストレージエンジンはインデックスをサポートしていません。
    </p><p>
      <code class="literal">CSV</code> ストレージエンジンはパーティション分割をサポートしていません。
    </p><p>
      <code class="literal">CSV</code> ストレージエンジンを使用して作成したすべてのテーブルには、すべてのカラムに <code class="literal">NOT NULL</code> 属性が必要です。
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="archive-storage-engine"></a>16.5 ARCHIVE ストレージエンジン</h2></div></div></div><a class="indexterm" name="idm45568054414928"></a><a class="indexterm" name="idm45568054413440"></a><p>
    <code class="literal">ARCHIVE</code> ストレージエンジンは、非常に小さなフットプリントに大量のインデックス化されていないデータを格納する、特別な目的のテーブルを作成します。
  </p><div class="table"><a name="idm45568054409776"></a><p class="title"><b>表 16.5 「ARCHIVE ストレージエンジンの機能」</b></p><div class="table-contents"><table frame="box" rules="all" summary="「ARCHIVE ストレージエンジンでサポートされる機能。」"><col style="width: 60%"><col style="width: 40%"><thead><tr><th>機能</th>
<th>Support</th>
</tr></thead><tbody><tr><td><span class="bold"><strong>B ツリーインデックス</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>MVCC</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>T ツリーインデックス</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>インデックスキャッシュ</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>クラスタデータベースのサポート</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>クラスタ化されたインデックス</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>ストレージの制限</strong></span></td>
<td>なし</td>
</tr><tr><td><span class="bold"><strong>データキャッシュ</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>データディクショナリ向け更新統計</strong></span></td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>トランザクション</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>ハッシュインデックス</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>バックアップ/ポイントインタイムリカバリ</strong></span> (ストレージエンジン内ではなくサーバー内で実装されています。)</td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>レプリケーションのサポート</strong></span> (ストレージエンジン内ではなくサーバー内で実装されています。)</td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>ロック粒度</strong></span></td>
<td>行</td>
</tr><tr><td><span class="bold"><strong>全文検索インデックス</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>圧縮データ</strong></span></td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>地理空間インデックスのサポート</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>地理空間データ型のサポート</strong></span></td>
<td>はい</td>
</tr><tr><td><span class="bold"><strong>外部キーのサポート</strong></span></td>
<td>いいえ</td>
</tr><tr><td><span class="bold"><strong>暗号化データ</strong></span></td>
<td>はい (暗号化機能を介してサーバーに実装されます。)</td>
</tr></tbody></table></div></div><br class="table-break"><p>
    <code class="literal">ARCHIVE</code> ストレージエンジンは MySQL バイナリ配布に含まれています。 ソースから MySQL を構築する場合にこのストレージエンジンを有効にするには、<span class="command"><strong>CMake</strong></span> を <code class="option">-DWITH_ARCHIVE_STORAGE_ENGINE</code> オプションで呼び出します。 
  </p><p>
    <code class="literal">ARCHIVE</code> エンジンのソースを調べるには、MySQL ソース配布の <code class="filename">storage/archive</code> ディレクトリを検索します。
  </p><p>
    <code class="literal">ARCHIVE</code> ストレージエンジンが <code class="literal">SHOW ENGINES</code> ステートメントで使用できるかどうかを確認できます。
  </p><p>
    <code class="literal">ARCHIVE</code> テーブルを作成すると、ストレージエンジンはテーブル名で始まる名前のファイルを作成します。 データファイルの拡張子は <code class="filename">.ARZ</code> です。 最適化操作中に <code class="filename">.ARN</code> ファイルが現れる場合があります。 
  </p><p>
    <code class="literal">ARCHIVE</code> エンジンでは、<code class="literal">INSERT</code>、<code class="literal">REPLACE</code> および <code class="literal">SELECT</code> はサポートされますが、<code class="literal">DELETE</code> または <code class="literal">UPDATE</code> はサポートされません。 <code class="literal">ORDER BY</code> 操作、<code class="literal">BLOB</code> カラムおよび空間データ型はサポートされています (<a class="xref" href="data-types.html#spatial-type-overview" title="11.4.1 空間データ型">セクション11.4.1「空間データ型」</a> を参照)。 地理空間参照システムはサポートされていません。 <code class="literal">ARCHIVE</code> エンジンは低レベルロックを使用します。 
  </p><p>
    <code class="literal">ARCHIVE</code> エンジンは <code class="literal">AUTO_INCREMENT</code> カラム属性をサポートしています。 <code class="literal">AUTO_INCREMENT</code> カラムには、一意のインデックスまたは一意でないインデックスのどちらかを付けることができます。 ほかのカラムにインデックスを作成しようとすると、エラーになります。 <code class="literal">ARCHIVE</code> エンジンは、それぞれ、新しいテーブルの最初のシーケンス値を指定したり、既存テーブルのシーケンス値をリセットしたりする <code class="literal">CREATE TABLE</code> ステートメントの <code class="literal">AUTO_INCREMENT</code> テーブルオプションもサポートしています。 
  </p><p>
    <code class="literal">ARCHIVE</code> は、現在の最大カラム値未満の値を <code class="literal">AUTO_INCREMENT</code> カラムに挿入する機能をサポートしていません。 そのようにしようとすると、<code class="literal">ER_DUP_KEY</code> エラーになります。 
  </p><p>
    <code class="literal">ARCHIVE</code> エンジンは <code class="literal">BLOB</code> カラムが要求されない場合はそれらを無視して、読み取り中にそれらを通り過ぎてスキャンします。
  </p><p>
    <code class="literal">ARCHIVE</code> ストレージエンジンはパーティション分割をサポートしていません。
  </p><p>
    <span class="bold"><strong>ストレージ:</strong></span> 行は挿入されるときに圧縮されます。 <code class="literal">ARCHIVE</code> エンジンは <code class="literal">zlib</code> ロスレスデータ圧縮を使用します (<a class="ulink" href="http://www.zlib.net/" target="_top">http://www.zlib.net/</a>を参照してください)。 <code class="literal">OPTIMIZE TABLE</code> を使用してテーブルを解析したり、より小さいフォーマットにテーブルを圧縮したりできます (<code class="literal">OPTIMIZE TABLE</code> を利用する理由については、このセクションの後半を参照して下さい)。 このエンジンは <code class="literal">CHECK TABLE</code>もサポートしています。 使用される挿入のタイプはいくつかあります。 
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">INSERT</code> ステートメントは行を圧縮バッファーに単純に入れ、バッファーは必要に応じてフラッシュします。 バッファーへの挿入はロックで保護されています。 <code class="literal">SELECT</code> はフラッシュを強制的に実行します。 
      </p></li><li class="listitem"><p>
        大量挿入は、ほかの挿入が同時に発生した場合を除いて (その場合は部分的に可視になります)、完了後にのみ可視になります。 <code class="literal">SELECT</code> は、ロード中に通常の挿入が発生した場合を除いて、大量挿入をフラッシュすることはありません。 
      </p></li></ul></div><p>
    <span class="bold"><strong>取り出し</strong></span>: 取り出しの際、要求によって行が圧縮解除され、行キャッシュはありません。 <code class="literal">SELECT</code> 操作によって完全なテーブルスキャンが実行されます。<code class="literal">SELECT</code> が発生すると、現在使用できる行数を検出し、その行数を読み取ります。 <code class="literal">SELECT</code> は一貫性読み取りとして実行されます。 バルク挿入のみを使用しないかぎり、挿入中に多くの <code class="literal">SELECT</code> ステートメントが圧縮を妨げる可能性があることに注意してください。 圧縮品質を高めるために、<code class="literal">OPTIMIZE TABLE</code> または <code class="literal">REPAIR TABLE</code> を使用できます。 <code class="literal">SHOW TABLE STATUS</code> によって報告される <code class="literal">ARCHIVE</code> テーブルの行数は常に正確です。 <a class="xref" href="sql-statements.html#optimize-table" title="13.7.3.4 OPTIMIZE TABLE ステートメント">セクション13.7.3.4「OPTIMIZE TABLE ステートメント」</a>、<a class="xref" href="sql-statements.html#repair-table" title="13.7.3.5 REPAIR TABLE ステートメント">セクション13.7.3.5「REPAIR TABLE ステートメント」</a>、および<a class="xref" href="sql-statements.html#show-table-status" title="13.7.7.38 SHOW TABLE STATUS ステートメント">セクション13.7.7.38「SHOW TABLE STATUS ステートメント」</a>を参照してください。 
  </p><h3><a name="idm45568054295680"></a>追加のリソース</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">ARCHIVE</code> ストレージエンジンに特化したフォーラムは <a class="ulink" href="https://forums.mysql.com/list.php?112" target="_top">https://forums.mysql.com/list.php?112</a> で参照できます。
      </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="blackhole-storage-engine"></a>16.6 BLACKHOLE ストレージエンジン</h2></div></div></div><a class="indexterm" name="idm45568054291152"></a><a class="indexterm" name="idm45568054289664"></a><p>
    <code class="literal">BLACKHOLE</code> ストレージエンジンは、データを受け取るけれども破棄して格納しない<span class="quote">「<span class="quote">ブラックホール</span>」</span>として機能します。 検索は、常に空の結果を返します。 
  </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE test(i INT, c CHAR(10)) ENGINE = BLACKHOLE;</code></strong>
Query OK, 0 rows affected (0.03 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO test VALUES(1,'record one'),(2,'record two');</code></strong>
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM test;</code></strong>
Empty set (0.00 sec)
</pre><p>
    ソースから MySQL を構築する場合に <code class="literal">BLACKHOLE</code> ストレージエンジンを有効にするには、<span class="command"><strong>CMake</strong></span> を <code class="option">-DWITH_BLACKHOLE_STORAGE_ENGINE</code> オプションで呼び出します。
  </p><p>
    <code class="literal">BLACKHOLE</code> エンジンのソースを調べるには、MySQL ソース配布の <code class="filename">sql</code> ディレクトリを検索します。
  </p><p>
    <code class="literal">BLACKHOLE</code> テーブルを作成すると、サーバーはグローバルデータディクショナリにテーブル定義を作成します。 テーブルに関連付けられたファイルがありません。 
  </p><p>
    <code class="literal">BLACKHOLE</code> ストレージエンジンはすべての種類のインデックスをサポートしています。 すなわち、テーブル定義にインデックス宣言を含めることができます。 
  </p><p>
    <code class="literal">BLACKHOLE</code> ストレージエンジンはパーティション分割をサポートしていません。
  </p><p>
    <code class="literal">BLACKHOLE</code> ストレージエンジンが <code class="literal">SHOW ENGINES</code> ステートメントで使用できるかどうかを確認できます。
  </p><p>
    <code class="literal">BLACKHOLE</code> テーブルへの挿入にはデータは格納されませんが、ステートメントベースのバイナリロギングが有効になっている場合は、SQL ステートメントがログに記録され、複製サーバーに複製されます。 これは、繰り返しまたはフィルタメカニズムとして役立つ場合があります。 
  </p><p>
    アプリケーションでレプリカ側のフィルタリングルールが必要だが、最初にすべてのバイナリログデータをレプリカに転送すると、トラフィックが多すぎるとします。 このような場合は、レプリケーションソースサーバー上で、デフォルトのストレージエンジンが <code class="literal">BLACKHOLE</code> である<span class="quote">「<span class="quote">「ダミー」</span>」</span>レプリカプロセスを次のように設定できます: 
  </p><div class="figure"><a name="idm45568054266928"></a><p class="title"><b>図 16.1 フィルタリングに BLACKHOLE を使用したレプリケーション</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/blackhole-1.png" width="575" height="300" alt="レプリケーションソースサーバーは、ソース mysqld プロセスとダミー mysqld プロセスを使用します。 複製では、mysqld プロセスはダミーの mysqld プロセスから複製します。"></div></div></div><br class="figure-break"><p>
    ソースはバイナリログに書き込みます。 <span class="quote">「<span class="quote">「ダミー」</span>」</span> <span class="command"><strong>mysqld</strong></span> プロセスはレプリカとして機能し、<code class="literal">replicate-do-*</code> ルールと <code class="literal">replicate-ignore-*</code> ルールの目的の組合せを適用して、独自のフィルタ処理された新しいバイナリログを書き込みます。 <a class="xref" href="replication.html#replication-options" title="17.1.6 レプリケーションおよびバイナリロギングのオプションと変数">セクション17.1.6「レプリケーションおよびバイナリロギングのオプションと変数」</a>を参照してください。 このフィルタ処理されたログはレプリカに提供されます。 
  </p><p>
    ダミープロセスは実際にはデータを格納しないため、レプリケーションソースサーバーで追加の <span class="command"><strong>mysqld</strong></span> プロセスを実行することで発生する処理オーバーヘッドはほとんどありません。 このタイプの設定は、追加のレプリカを使用して繰り返すことができます。 
  </p><p>
    <code class="literal">BLACKHOLE</code> テーブルの <code class="literal">INSERT</code> トリガーは期待どおりに機能します。 しかし、実際には <code class="literal">BLACKHOLE</code> テーブルはデータを格納しないため、<code class="literal">UPDATE</code> および <code class="literal">DELETE</code> トリガーは有効ではありません。トリガー定義の <code class="literal">FOR EACH ROW</code> 句は、行がないために適用されません。 
  </p><p>
    <code class="literal">BLACKHOLE</code> ストレージエンジンのその他の利用方法は、次のとおりです。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        ダンプファイル構文の検証。
      </p></li><li class="listitem"><p>
        バイナリロギングのオーバーヘッドを測定 (バイナリロギングが有効である場合と有効でない場合のパフォーマンスを <code class="literal">BLACKHOLE</code> を利用して比較することで)。
      </p></li><li class="listitem"><p>
        <code class="literal">BLACKHOLE</code> は本質的には <span class="quote">「<span class="quote">no-op</span>」</span>ストレージエンジンであるため、ストレージエンジン自体には関係ないパフォーマンスボトルネックの検出に使用される場合があります。
      </p></li></ul></div><p>
    コミットされたトランザクションはバイナリログに書き込まれ、ロールバックされたトランザクションは書き込まれないという意味で、<code class="literal">BLACKHOLE</code> エンジンはトランザクション対応です。
  </p><p>
    <span class="bold"><strong>Blackhole エンジンと自動インクリメントカラム</strong></span>
  </p><p>
    <code class="literal">BLACKHOLE</code> エンジンは no-op エンジンです。 <code class="literal">BLACKHOLE</code> を使用してテーブルに対して実行される操作は影響を受けません。 これは、自動増分される主キーカラムの動作を考慮する際に注意する必要があります。 エンジンはフィールド値を自動的に増分せず、自動増分フィールドの状態を保持しません。 これは、レプリケーションで重要な意味を持ちます。 
  </p><p>
    次の 3 つの条件がすべて適用される次のレプリケーションシナリオを検討します。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        ソースサーバーには、主キーである自動増分フィールドを持つブラックホールテーブルがあります。
      </p></li><li class="listitem"><p>
        レプリカには同じテーブルが存在しますが、MyISAM エンジンを使用します。
      </p></li><li class="listitem"><p>
        ソーステーブルへの挿入は、<code class="literal">INSERT</code> ステートメント自体で自動増分値を明示的に設定せずに、または <code class="literal">SET INSERT_ID</code> ステートメントを使用して実行されます。
      </p></li></ol></div><p>
    このシナリオでは、主キーカラムで重複エントリエラーが発生してレプリケーションが失敗します。
  </p><p>
    ステートメントベースのレプリケーションでは、コンテキストイベントの <code class="literal">INSERT_ID</code> の値は常に同じです。 したがって、主キーカラムの値が重複する行を挿入しようとすると、レプリケーションは失敗します。 
  </p><p>
    行ベースのレプリケーションでは、エンジンが戻す行の値は、各挿入で常に同じです。 この結果、レプリカは主キーカラムに同じ値を使用して 2 つの挿入ログエントリをリプレイしようとするため、レプリケーションは失敗します。 
  </p><p>
    <span class="bold"><strong>カラムのフィルタリング</strong></span>
  </p><p>
    行ベースのレプリケーション (<code class="literal">binlog_format=ROW</code>) を使用する場合、<a class="xref" href="replication.html#replication-features-differing-tables" title="17.5.1.9 ソースとレプリカで異なるテーブル定義を使用したレプリケーション">セクション17.5.1.9「ソースとレプリカで異なるテーブル定義を使用したレプリケーション」</a> のセクションで説明されているように、最後のカラムがテーブルから欠落しているレプリカがサポートされます。
  </p><p>
    このフィルタリングはレプリカ側で機能します。つまり、カラムはフィルタで除外される前にレプリカにコピーされます。 カラムをレプリカにコピーすることは望ましくないケースが 2 つ以上あります: 
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        データが機密である場合、レプリカサーバーはそのデータにアクセスできません。
      </p></li><li class="listitem"><p>
        ソースに多数のレプリカがある場合、レプリカに送信する前にフィルタリングすると、ネットワークトラフィックが削減される可能性があります。
      </p></li></ol></div><p>
    ソースカラムのフィルタリングは、<code class="literal">BLACKHOLE</code> エンジンを使用して実行できます。 これは、ソーステーブルのフィルタリングの実現方法と同様の方法で実行されます - <code class="literal">BLACKHOLE</code> エンジンおよび <code class="option">--replicate-do-table</code> または <code class="option">--replicate-ignore-table</code> オプションを使用します。 
  </p><p>
    ソースの設定は次のとおりです:
  </p><pre class="programlisting">CREATE TABLE t1 (public_col_1, ..., public_col_N,
                 secret_col_1, ..., secret_col_M) ENGINE=MyISAM;
</pre><p>
    信頼できるレプリカの設定は次のとおりです:
  </p><pre class="programlisting">CREATE TABLE t1 (public_col_1, ..., public_col_N) ENGINE=BLACKHOLE;
</pre><p>
    信頼できないレプリカの設定は次のとおりです:
  </p><pre class="programlisting">CREATE TABLE t1 (public_col_1, ..., public_col_N) ENGINE=MyISAM;</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="merge-storage-engine"></a>16.7 MERGE ストレージエンジン</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="storage-engines.html#merge-table-advantages">16.7.1 MERGE テーブルの長所と短所</a></span></dt><dt><span class="section"><a href="storage-engines.html#merge-table-problems">16.7.2 MERGE テーブルの問題点</a></span></dt></dl></div><a class="indexterm" name="idm45568054209392"></a><a class="indexterm" name="idm45568054207904"></a><a class="indexterm" name="idm45568054205984"></a><a class="indexterm" name="idm45568054203840"></a><a class="indexterm" name="idm45568054201792"></a><p>
    <code class="literal">MRG_MyISAM</code> エンジンとしても知られている <code class="literal">MERGE</code> ストレージエンジンは、1 つのテーブルとして使用できる同一の <code class="literal">MyISAM</code> テーブルの集まりです。 <span class="quote">「<span class="quote">「同一」</span>」</span>は、すべてのテーブルのカラムデータ型とインデックス情報が同一であることを意味します。 カラムが異なる順序でリストされている <code class="literal">MyISAM</code> テーブル、対応するカラムにまったく同じデータ型がない <code class="literal">MyISAM</code> テーブル、またはインデックスが異なる順序である <code class="literal">MyISAM</code> テーブルはマージできません。 しかし、<code class="literal">MyISAM</code> テーブルのすべてまたはいずれかを <span class="command"><strong>myisampack</strong></span> で圧縮できます。 <a class="xref" href="programs.html#myisampack" title="4.6.6 myisampack — 圧縮された読み取り専用の MyISAM テーブルの生成">セクション4.6.6「myisampack — 圧縮された読み取り専用の MyISAM テーブルの生成」</a>を参照してください。 次のようなテーブルの違いは関係ありません: 
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        対応するカラムおよびインデックスの名前は異なる場合があります。
      </p></li><li class="listitem"><p>
        テーブル、カラムおよびインデックスのコメントは異なる場合があります。
      </p></li><li class="listitem"><p>
        <code class="literal">AVG_ROW_LENGTH</code>、<code class="literal">MAX_ROWS</code>、<code class="literal">PACK_KEYS</code> などのテーブルオプションは異なる場合があります。
      </p></li></ul></div><p>
    <code class="literal">MERGE</code> テーブルのかわりにパーティションテーブルを使用すると、単一のテーブルのパーティションを別々のファイルに格納し、一部の操作をより効率的に実行できます。 詳細については、<a class="xref" href="partitioning.html" title="第 24 章 パーティション化">第24章「<i>パーティション化</i>」</a>を参照してください。 
  </p><p>
    <code class="literal">MERGE</code> テーブルを作成すると、MySQL によって、基礎となる <code class="literal">MyISAM</code> テーブルの名前を含む <code class="filename">.MRG</code> ファイルがディスク上に作成されます。 <code class="literal">MERGE</code> テーブルのテーブル形式は、MySQL データディクショナリに格納されます。 基礎となるテーブルは、<code class="literal">MERGE</code> テーブルと同じデータベース内にある必要はありません。 
  </p><p>
    <code class="literal">MERGE</code> テーブルでは、<code class="literal">SELECT</code>、<code class="literal">DELETE</code>、<code class="literal">UPDATE</code>、および <code class="literal">INSERT</code> を使用できます。 <code class="literal">MERGE</code> テーブルにマッピングする <code class="literal">MyISAM</code> テーブルに対して <code class="literal">SELECT</code>、<code class="literal">DELETE</code>、および <code class="literal">UPDATE</code> 権限が必要です。 
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
      <code class="literal">MERGE</code> テーブルの利用は、次のセキュリティーに関する問題を引き起こします。ユーザーが <code class="literal">MyISAM</code> テーブル <em class="replaceable"><code>t</code></em> に対するアクセス権限を持っていると、そのユーザーは <em class="replaceable"><code>t</code></em> にアクセスできる <code class="literal">MERGE</code> テーブル <em class="replaceable"><code>m</code></em> を作成できます。 しかし、<em class="replaceable"><code>t</code></em> に対するユーザーの権限があとで破棄された場合、ユーザーは <em class="replaceable"><code>m</code></em> を介してアクセスすることで <em class="replaceable"><code>t</code></em> にアクセスを続けることができます。 
    </p></div><p>
    <code class="literal">DROP TABLE</code> を <code class="literal">MERGE</code> テーブルに使用すると、<code class="literal">MERGE</code> 指定だけが削除されます。 基礎テーブルは影響を受けません。 
  </p><p>
    <code class="literal">MERGE</code> テーブルを作成するには、どの <code class="literal">MyISAM</code> テーブルを使用するかを示す <code class="literal">UNION=(<em class="replaceable"><code>list-of-tables</code></em>)</code> オプションを指定する必要があります。 オプションとして、<code class="literal">INSERT_METHOD</code> オプションを指定して <code class="literal">MERGE</code> テーブルへの挿入方法を制御できます。 <code class="literal">FIRST</code> または <code class="literal">LAST</code> の値を使用すると、それぞれ最初のまたは最後の基礎テーブルで挿入が実行されることになります。 <code class="literal">INSERT_METHOD</code> オプションを指定しないか、または値 <code class="literal">NO</code> 付きでこのオプションを指定すると、<code class="literal">MERGE</code> テーブルへの挿入は許可されず、挿入の試みはエラーとなります。 
  </p><p>
    次の例は、<code class="literal">MERGE</code> テーブルの作成方法を紹介しています。
  </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
    -&gt;    <strong class="userinput"><code>a INT NOT NULL AUTO_INCREMENT PRIMARY KEY,</code></strong>
    -&gt;    <strong class="userinput"><code>message CHAR(20)) ENGINE=MyISAM;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (</code></strong>
    -&gt;    <strong class="userinput"><code>a INT NOT NULL AUTO_INCREMENT PRIMARY KEY,</code></strong>
    -&gt;    <strong class="userinput"><code>message CHAR(20)) ENGINE=MyISAM;</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t1 (message) VALUES ('Testing'),('table'),('t1');</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t2 (message) VALUES ('Testing'),('table'),('t2');</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE total (</code></strong>
    -&gt;    <strong class="userinput"><code>a INT NOT NULL AUTO_INCREMENT,</code></strong>
    -&gt;    <strong class="userinput"><code>message CHAR(20), INDEX(a))</code></strong>
    -&gt;    <strong class="userinput"><code>ENGINE=MERGE UNION=(t1,t2) INSERT_METHOD=LAST;</code></strong>
</pre><p>
    カラム <code class="literal">a</code> は、基礎となる <code class="literal">MyISAM</code> テーブルでは <code class="literal">PRIMARY KEY</code> としてインデックス付けされますが、<code class="literal">MERGE</code> テーブルではインデックス付けされません。 <code class="literal">MERGE</code> テーブルは基礎テーブルセットに一意性を適用できないため、インデックスは設定されますが、<code class="literal">PRIMARY KEY</code> としては設定されません。 (同様に、基礎テーブルで <code class="literal">UNIQUE</code> インデックスを持つカラムには、<code class="literal">MERGE</code> テーブルでインデックスが付けられますが、<code class="literal">UNIQUE</code> インデックスとしては付けられないはずです。) 
  </p><p>
    <code class="literal">MERGE</code> テーブルを作成したあと、このテーブルを使用して、テーブルのグループにまとめて操作を行うクエリーを発行できます。
  </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM total;</code></strong>
+---+---------+
| a | message |
+---+---------+
| 1 | Testing |
| 2 | table   |
| 3 | t1      |
| 1 | Testing |
| 2 | table   |
| 3 | t2      |
+---+---------+
</pre><p>
    <code class="literal">MERGE</code> テーブルを <code class="literal">MyISAM</code> テーブルの別のコレクションに対して再マッピングするには、次のいずれかの方法を利用できます。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">MERGE</code> テーブルを <code class="literal">DROP</code> して、再作成する。
      </p></li><li class="listitem"><p>
        基礎テーブルのリストを変更するために、<code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> UNION=(...)</code> を利用する。
      </p><p>
        <code class="literal">ALTER TABLE ... UNION=()</code> (つまり、空の <code class="literal">UNION</code> 句) を使用してすべての基礎テーブルを削除することもできます。 ただしこの場合、テーブルは実質的には空であり、新しい行を取得する基礎テーブルがないために挿入は失敗します。 このようなテーブルは、新しい <code class="literal">MERGE</code> テーブルを <code class="literal">CREATE TABLE ... LIKE</code> で作成するためのテンプレートとして役立つ場合があります。 
      </p></li></ul></div><p>
    基礎テーブルの定義とインデックスは、<code class="literal">MERGE</code> テーブルの定義と厳密に一致する必要があります。 一致がチェックされるのは、<code class="literal">MERGE</code> テーブルが作成されたときではなく、<code class="literal">MERGE</code> テーブルの一部のテーブルが開いたときです。 いずれのテーブルも一致チェックに失敗した場合、テーブルのオープンをトリガーした操作は失敗します。 すなわち、<code class="literal">MERGE</code> 内のテーブルの定義を変更すると、<code class="literal">MERGE</code> テーブルがアクセスされたときに失敗の原因となる可能性があります。 それぞれのテーブルに適用される一致チェックは次のとおりです。 
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        基礎テーブルと <code class="literal">MERGE</code> テーブルのカラム数は同じでなければいけません。
      </p></li><li class="listitem"><p>
        基礎テーブルと <code class="literal">MERGE</code> テーブルのカラムの順番は一致する必要があります。
      </p></li><li class="listitem"><p>
        また、親の <code class="literal">MERGE</code> テーブル内の対応する各カラムの指定と基礎テーブルの指定を比較して、次のチェック内容を満たす必要があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
            基礎テーブルと <code class="literal">MERGE</code> テーブルのカラムの型は一致する必要がある。
          </p></li><li class="listitem"><p>
            基礎テーブルと <code class="literal">MERGE</code> テーブルのカラムの長さは一致する必要がある。
          </p></li><li class="listitem"><p>
            基礎テーブルと <code class="literal">MERGE</code> テーブルのカラムは <code class="literal">NULL</code> でもかまわない。
          </p></li></ul></div></li><li class="listitem"><p>
        基礎テーブルは、少なくとも <code class="literal">MERGE</code> テーブルと同じ数のインデックスを持つ必要がある。 基礎テーブルのインデックスの数は <code class="literal">MERGE</code> テーブルより多くてもかまわないが、少なくすることはできない。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          同じカラムのインデックスは、<code class="literal">MERGE</code> テーブルと基礎 <code class="literal">MyISAM</code> テーブルの両方でまったく同じ順番でなければならないという、既知の問題が存在します。 バグ #33653 を参照してください。 
        </p></div><p>
        各インデックスは次のチェック内容を満たす必要があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
            基礎テーブルと <code class="literal">MERGE</code> テーブルのインデックスの型は一致する必要がある。
          </p></li><li class="listitem"><p>
            基礎テーブルと <code class="literal">MERGE</code> テーブルのインデックス定義でのインデックス部の数 (すなわち、複合インデックス内に複数のカラム) は一致する必要があります。
          </p></li><li class="listitem"><p>
            各インデックス部について。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                インデックス部の長さは同じでなければいけない。
              </p></li><li class="listitem"><p>
                インデックス部の型は同じでなければいけない。
              </p></li><li class="listitem"><p>
                インデックス部の言語は同じでなければいけない。
              </p></li><li class="listitem"><p>
                インデックス部が <code class="literal">NULL</code> でかまわないかどうかをチェックする。
              </p></li></ul></div></li></ul></div></li></ul></div><p>
    <code class="literal">MERGE</code> テーブルが基礎テーブルの問題のために、開いたり使用したりできない場合、<code class="literal">CHECK TABLE</code> は問題の原因となったテーブルに関する情報を表示します。
  </p><h3><a name="idm45568054078336"></a>追加のリソース</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">MERGE</code> ストレージエンジンに特化したフォーラムは、<a class="ulink" href="https://forums.mysql.com/list.php?93" target="_top">https://forums.mysql.com/list.php?93</a>で参照できます。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="merge-table-advantages"></a>16.7.1 MERGE テーブルの長所と短所</h3></div></div></div><p>
      <code class="literal">MERGE</code> テーブルは、次のような問題を解決するのに役立つことがあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ログテーブルセットを簡単に管理する。 たとえば、異なる月のデータを別々のテーブルに入力し、<span class="command"><strong>myisampack</strong></span> を利用してそれらの一部を圧縮してから、1 つのものとして利用するために <code class="literal">MERGE</code> テーブルを作成できます。 
        </p></li><li class="listitem"><p>
          スピードを上げる。 大きな読み取り専用テーブルを同じ基準で分割し、個々のテーブルを異なるディスクに置くことができます。 このように構成された <code class="literal">MERGE</code> テーブルは、1 つの大きなテーブルを使用するよりも、速度がかなり速くなる可能性があります。 
        </p></li><li class="listitem"><p>
          より効率的に検索を行う。 検索する対象が正確にわかっている場合、あるクエリーで基礎テーブルの 1つだけを検索し、別のクエリーで <code class="literal">MERGE</code> テーブルを使用できます。 重複するテーブルセットを使用する、多数の異なる <code class="literal">MERGE</code> テーブルを持つこともできます。 
        </p></li><li class="listitem"><p>
          より効率的な修復を行う。 1 つの大きなテーブルを修復するよりも、<code class="literal">MERGE</code> テーブルにマッピングされた個々の小さいテーブルを修復する方が簡単です。 
        </p></li><li class="listitem"><p>
          多くのテーブルを瞬時に 1 つのテーブルとしてマッピングする。 <code class="literal">MERGE</code> テーブルは個々のテーブルのインデックスを利用するので、それ自体のインデックスを保守する必要はありません。 その結果、<code class="literal">MERGE</code> テーブルコレクションは、作成や再マッピングを<span class="emphasis"><em>非常に</em></span>速く行うことができます。 (<code class="literal">MERGE</code> テーブルを作成するときは、インデックスが作成されない場合でも、インデックスの定義を指定する必要があります。) 
        </p></li><li class="listitem"><p>
          テーブルセットがあり、それらからオンデマンドで大きなテーブルを作成する場合は、代わりにそれらからオンデマンドで <code class="literal">MERGE</code> テーブルを作成できます。 この方が、速度がかなり速くなり、多くのディスク容量が節約されます。 
        </p></li><li class="listitem"><p>
          オペレーティングシステムのファイルサイズ制限を超える。 個々の <code class="literal">MyISAM</code> テーブルはこの制限に制約されますが、<code class="literal">MyISAM</code> テーブルのコレクションは制約されません。 
        </p></li><li class="listitem"><p>
          <code class="literal">MyISAM</code> テーブルにマッピングする <code class="literal">MERGE</code> テーブルを定義することで、その単一テーブルのエイリアスやシノニムを作成できます。 これを行なっても、特に顕著なパフォーマンス面の影響はないはずです (個々の読み取りのためにいくつかの間接呼び出しや <code class="literal">memcpy()</code> 呼び出しがあるだけです)。 
        </p></li></ul></div><p>
      <code class="literal">MERGE</code> テーブルの短所は次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">MERGE</code> テーブルに対して、同一の <code class="literal">MyISAM</code> テーブルしか使用できません。
        </p></li><li class="listitem"><p>
          <code class="literal">MyISAM</code> 機能のいくつかは <code class="literal">MERGE</code> テーブルでは使用できません。 たとえば、<code class="literal">MERGE</code> テーブルに <code class="literal">FULLTEXT</code> インデックスを作成できません。 (基礎 <code class="literal">MyISAM</code> テーブルに <code class="literal">FULLTEXT</code> インデックスを作成できますが、<code class="literal">MERGE</code> テーブルを全文検索で検索できません。) 
        </p></li><li class="listitem"><p>
          <code class="literal">MERGE</code> テーブルが非一時的である場合、すべての基礎 <code class="literal">MyISAM</code> テーブルは非一時的である必要があります。 <code class="literal">MERGE</code> テーブルが一時的である場合、<code class="literal">MyISAM</code> テーブルは一時的なテーブルと非一時的なテーブルが混在してもかまいません。 
        </p></li><li class="listitem"><p>
          <code class="literal">MERGE</code> テーブルは <code class="literal">MyISAM</code> テーブルより多くのファイルディスクリプタを使用します。 10 個のクライアントが、10 個のテーブルにマッピングする <code class="literal">MERGE</code> テーブルを使用する場合、サーバーは (10 × 10) + 10 個のファイルディスクリプタを使用します。(10 個のクライアントに対してそれぞれ 10 個のデータファイルディスクリプタに加えて、クライアント間で共有される 10 個のインデックスファイルディスクリプタです。) 
        </p></li><li class="listitem"><p>
          インデックスの読み取りは低下します。 インデックスを読み取るときに、<code class="literal">MERGE</code> ストレージエンジンはすべての基礎テーブルに読み取りを発行して、渡されたインデックス値に厳密に一致するかをチェックする必要があります。 次のインデックス値を読み取るために、<code class="literal">MERGE</code> ストレージエンジンは読み取りバッファーを検索して次の値を探す必要があります。 1 つのインデックスバッファーが使い果たされていた場合にのみ、ストレージエンジンは次のインデックスブロックを読み取る必要があります。 これで、<code class="literal">MERGE</code> インデックスは <code class="literal">eq_ref</code> 検索をかなり遅くしますが、<code class="literal">ref</code> 検索ではそれほど低下しません。 <code class="literal">eq_ref</code> および <code class="literal">ref</code> の詳細情報については、<a class="xref" href="sql-statements.html#explain" title="13.8.2 EXPLAIN ステートメント">セクション13.8.2「EXPLAIN ステートメント」</a>を参照してください。 
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="merge-table-problems"></a>16.7.2 MERGE テーブルの問題点</h3></div></div></div><p>
      <code class="literal">MERGE</code> テーブルの既知の問題点は次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          5.1.23 バージョンより前の MySQL Server では、MyISAM の非一時的な子供のテーブルを持つ一時的なマージテーブルを作成できました。
        </p><p>
          バージョン 5.1.23 からは、MERGE の子供は親のテーブルを介してロックされました。 親が一時的であった場合、親がロックされなかったため、子供もロックされませんでした。 MyISAM テーブルを同時に使用すると、テーブルが破損しました。 
        </p></li><li class="listitem"><p>
          <code class="literal">ALTER TABLE</code> を使用して <code class="literal">MERGE</code> テーブルを別のストレージエンジンに変えると、基礎テーブルへのマッピングが失われます。 その代わり、変更されたテーブルに基礎 <code class="literal">MyISAM</code> テーブルの行がコピーされ、そのときに、指定されたストレージエンジンを使用します。 
        </p></li><li class="listitem"><p>
          <code class="literal">MERGE</code> テーブルの <code class="literal">INSERT_METHOD</code> テーブルオプションは、<code class="literal">MERGE</code> テーブルへの挿入にどの基礎 <code class="literal">MyISAM</code> テーブルを使用するかを示します。 ただし、その <code class="literal">MyISAM</code> テーブルに <code class="literal">AUTO_INCREMENT</code> テーブルオプションを使用しても、1 つ以上の行が <code class="literal">MyISAM</code> テーブルに直接挿入されるまで、<code class="literal">MERGE</code> テーブルへの挿入は有効になりません。 
        </p></li><li class="listitem"><p>
          <code class="literal">MERGE</code> テーブルは、テーブル全体に一意制約を保持できません。 <code class="literal">INSERT</code> を実行すると、データは最初または最後の <code class="literal">MyISAM</code> テーブル (<code class="literal">INSERT_METHOD</code> オプションで指定されます) に入ります。 MySQL は一意のキー値が <code class="literal">MyISAM</code> テーブル内で一意のままであることを保証しますが、コレクション内のすべての基礎テーブルには保証しません。 
        </p></li><li class="listitem"><p>
          <code class="literal">MERGE</code> エンジンは基本テーブルセットに一意性を適用できないため、<code class="literal">REPLACE</code> は期待どおりに機能しません。 次の 2 つの重要な事実があります。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">REPLACE</code> は、書き込もうとする基礎テーブルでのみ一意キー違反を検出できます (<code class="literal">INSERT_METHOD</code> オプションで指定されます)。 これは <code class="literal">MERGE</code> テーブル自体の違反とは異なります。 
            </p></li><li class="listitem"><p>
              <code class="literal">REPLACE</code> は、一意キー違反を検出すると、書込み先の基礎となるテーブル (つまり、<code class="literal">INSERT_METHOD</code> オプションで決定された最初または最後のテーブル) の対応する行のみを変更します。
            </p></li></ul></div><p>
          <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> についても同様な考慮が適用されます。
        </p></li><li class="listitem"><p>
          <code class="literal">MERGE</code> テーブルはパーティション化をサポートしていません。 つまり、<code class="literal">MERGE</code> テーブルも、<code class="literal">MERGE</code> テーブルの基礎 <code class="literal">MyISAM</code> テーブルもパーティション化できません。 
        </p></li><li class="listitem"><p>
          開いた <code class="literal">MERGE</code> テーブルにマッピングされたどのテーブルにも、<code class="literal">ANALYZE TABLE</code>、<code class="literal">REPAIR TABLE</code>、<code class="literal">OPTIMIZE TABLE</code>、<code class="literal">ALTER TABLE</code>、<code class="literal">DROP TABLE</code>、<code class="literal">DELETE</code> (<code class="literal">WHERE</code> 句なし)、または <code class="literal">TRUNCATE TABLE</code> を使用すべきではありません。 そうする場合、<code class="literal">MERGE</code> テーブルは引き続き元のテーブルを参照しているため、予期しない結果となる可能性があります。 この問題に対処するには、名前付きの操作を行う前に <code class="literal">FLUSH TABLES</code> ステートメントを発行することで、確実に <code class="literal">MERGE</code> テーブルが開いたままにならないようにします。 
        </p><p>
          予期しない結果には、<code class="literal">MERGE</code> テーブルに対する操作でテーブルの破損が報告される可能性があります。 基礎 <code class="literal">MyISAM</code> テーブルで名前付き操作のあとにこれが発生した場合、破損メッセージは偽りです。 これに対処するには、<code class="literal">MyISAM</code> テーブルを変更したあとで <code class="literal">FLUSH TABLES</code> ステートメントを発行します。 
        </p></li><li class="listitem"><p>
          <code class="literal">MERGE</code> ストレージエンジンのテーブルマッピングは MySQL の上位レイヤーから隠れているので、<code class="literal">MERGE</code> テーブルによって使用されているテーブルでの <code class="literal">DROP TABLE</code> は Windows では機能しません。 Windows では開いているファイルの削除を許可しないため、最初にすべての <code class="literal">MERGE</code> テーブルをフラッシュするか (<code class="literal">FLUSH TABLES</code> を使用します)、テーブルを削除する前に <code class="literal">MERGE</code> テーブルを削除する必要があります。 
        </p></li><li class="listitem"><p>
          <code class="literal">MyISAM</code> テーブルと <code class="literal">MERGE</code> テーブルの定義は、テーブルにアクセスするときにチェックされます (たとえば、<code class="literal">SELECT</code> または <code class="literal">INSERT</code> ステートメントの一部として)。 このチェックは、テーブルの定義と親の <code class="literal">MERGE</code> テーブルの定義が、カラムの順番、タイプ、サイズ、および関連するインデックスを比較することで一致することを保証します。 テーブル間で違いがある場合、エラーが戻され、ステートメントは失敗します。 これらのチェックはテーブルが開かれたときに行われるため、カラムの変更、カラムの順序付け、エンジンの変更など、単一のテーブルの定義を変更すると、ステートメントが失敗します。 
        </p></li><li class="listitem"><p>
          <code class="literal">MERGE</code> テーブルと、その基礎テーブルのインデックスの順番は同一でなければいけません。 <code class="literal">ALTER TABLE</code> を使用して、<code class="literal">MERGE</code> テーブル内で使用されるテーブルに <code class="literal">UNIQUE</code> インデックスを追加し、次に <code class="literal">ALTER TABLE</code> を使用して <code class="literal">MERGE</code> テーブル上に一意でないインデックスを追加した場合、基礎テーブル内に一意でないインデックスがすでに存在していると、それらのテーブルのインデックス順序は異なります。 (これが発生するのは、重複キーをすばやく検出できるように <code class="literal">ALTER TABLE</code> が一意でないインデックスの前に <code class="literal">UNIQUE</code> インデックスを配置するためです。) その結果、このようなインデックスを持つテーブルに対するクエリーは予想外の結果をもたらす可能性があります。 
        </p></li><li class="listitem"><p>
          <span class="errortext">ERROR 1017 (HY000): Can't find file: '<em class="replaceable"><code>tbl_name</code></em>.MRG' (errno: 2)</span>エラーメッセージが表示された場合、一般的に、いくつかの基礎テーブルが <code class="literal">MyISAM</code> ストレージエンジンを使用していないことを表しています。 これらのテーブルがすべて <code class="literal">MyISAM</code> であることを確認してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">MERGE</code> テーブルの行の最大値は 2<sup>64</sup> です (~1.844E+19 で、<code class="literal">MyISAM</code> テーブルの場合と同じ)。 複数の <code class="literal">MyISAM</code> テーブルを、この数よりも多くの行を含む単一の <code class="literal">MERGE</code> テーブルにマージできません。 
        </p></li><li class="listitem"><p>
          親の <code class="literal">MERGE</code> テーブルを持つ、異なる行フォーマットの基礎 <code class="literal">MyISAM</code> テーブルを使用すると、現在失敗することが知られています。 バグ #32364 を参照してください。 
        </p></li><li class="listitem"><p>
          <code class="literal">LOCK TABLES</code> が実施されているときは、非一時的な <code class="literal">MERGE</code> テーブルの結合リストを変更できません。 次は動作<span class="emphasis"><em>しません</em></span>。 
        </p><pre class="programlisting">CREATE TABLE m1 ... ENGINE=MRG_MYISAM ...;
LOCK TABLES t1 WRITE, t2 WRITE, m1 WRITE;
ALTER TABLE m1 ... UNION=(t1,t2) ...;
</pre><p>
          ただし、一時的な <code class="literal">MERGE</code> テーブルではこれを行うことができます。
        </p></li><li class="listitem"><p>
          一時的な <code class="literal">MERGE</code> としても、非一時的な <code class="literal">MERGE</code> テーブルとしても、<code class="literal">CREATE ... SELECT</code> で <code class="literal">MERGE</code> テーブルを作成できません。 例: 
        </p><pre class="programlisting">CREATE TABLE m1 ... ENGINE=MRG_MYISAM ... SELECT ...;</pre><p>
          これを試みると、<em class="replaceable"><code>tbl_name</code></em> は <code class="literal">BASE TABLE</code> ではないというエラーとなります。
        </p></li><li class="listitem"><p>
          あるケースでは、<code class="literal">MERGE</code> と基礎テーブル間で <code class="literal">PACK_KEYS</code> テーブルオプション値が異なると、基礎テーブルに <code class="literal">CHAR</code> または <code class="literal">BINARY</code> カラムが含まれている場合、予期しない結果になります。 回避策として、<code class="literal">ALTER TABLE</code> を使用して、関係するすべてのテーブルの <code class="literal">PACK_KEYS</code> 値が同じであることを保証します。 (Bug #50646) 
        </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="federated-storage-engine"></a>16.8 FEDERATED ストレージエンジン</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="storage-engines.html#federated-description">16.8.1 FEDERATED ストレージエンジンの概要</a></span></dt><dt><span class="section"><a href="storage-engines.html#federated-create">16.8.2 FEDERATED テーブルの作成方法</a></span></dt><dt><span class="section"><a href="storage-engines.html#federated-usagenotes">16.8.3 FEDERATED ストレージエンジンの注記とヒント</a></span></dt><dt><span class="section"><a href="storage-engines.html#federated-storage-engine-resources">16.8.4 FEDERATED ストレージエンジンのリソース</a></span></dt></dl></div><a class="indexterm" name="idm45568053917520"></a><a class="indexterm" name="idm45568053916032"></a><p>
    <code class="literal">FEDERATED</code> ストレージエンジンを使用すると、レプリケーションまたはクラスタの技術を使用しないで、リモートの MySQL データベースのデータにアクセスできます。 ローカルの <code class="literal">FEDERATED</code> テーブルにクエリーを発行すると、リモート (連合) テーブルからデータを自動的に取得します。 データはローカルテーブルに格納されません。 
  </p><p>
    ソースから MySQL を構築する場合に <code class="literal">FEDERATED</code> ストレージエンジンを含めるには、<span class="command"><strong>CMake</strong></span> を <code class="option">-DWITH_FEDERATED_STORAGE_ENGINE</code> オプションで呼び出します。
  </p><p>
    <code class="literal">FEDERATED</code> ストレージエンジンは、デフォルトでは動作中のサーバーで有効になっていません。<code class="literal">FEDERATED</code> を有効にするには、<code class="option">--federated</code> オプションを使用して MySQL サーバーバイナリを起動する必要があります。
  </p><p>
    <code class="literal">FEDERATED</code> エンジンのソースを調べるには、MySQL ソース配布の <code class="filename">storage/federated</code> ディレクトリを検索します。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="federated-description"></a>16.8.1 FEDERATED ストレージエンジンの概要</h3></div></div></div><p>
      標準のストレージエンジン (<code class="literal">MyISAM</code>、<code class="literal">CSV</code>、<code class="literal">InnoDB</code> など) のいずれかを使用してテーブルを作成すると、そのテーブルはテーブルの定義と関連データで構成されます。 <code class="literal">FEDERATED</code> テーブルを作成すると、テーブル定義は同じですが、データの物理ストレージはリモートサーバーで処理されます。 
    </p><p>
      <code class="literal">FEDERATED</code> テーブルは 2 つの要素で構成されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          データベーステーブルを含む<span class="emphasis"><em>リモートサーバー</em></span>。これは、(MySQL データディクショナリに格納されている) テーブル定義と関連するテーブルで構成されます。 リモートテーブルのテーブルタイプは、<code class="literal">MyISAM</code> や <code class="literal">InnoDB</code> を含む、リモート <code class="literal">mysqld</code> サーバーがサポートするいずれのタイプであってもかまいません。 
        </p></li><li class="listitem"><p>
          データベーステーブルを持つ <span class="emphasis"><em>ローカルサーバー</em></span>。テーブルの定義は、リモートサーバー上の対応するテーブルの定義に一致します。 テーブル定義はデータディクショナリに格納されます。 ローカルサーバーにデータファイルがありません。 その代わり、テーブル定義にはリモートテーブルをポイントする接続文字列が含まれています。 
        </p></li></ul></div><p>
      ローカルサーバーで <code class="literal">FEDERATED</code> テーブルにクエリーやステートメントを実行すると、一般的にローカルデータファイルの情報を挿入、更新、または削除する操作は、実行するために代わりにリモートサーバーに送られ、そこでリモートサーバーのデータファイルを更新したり、リモートサーバーから一致する行を戻したりします。
    </p><p>
      <code class="literal">FEDERATED</code> テーブルのセットアップの基本的な構造は <a class="xref" href="storage-engines.html#figure-se-federated-structure" title="図 16.2 FEDERATED テーブルの構造">図16.2「FEDERATED テーブルの構造」</a>で示します。
    </p><div class="figure"><a name="figure-se-federated-structure"></a><p class="title"><b>図 16.2 FEDERATED テーブルの構造</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/se-federated-structure.png" width="475" height="269" alt="内容は周囲のテキストで説明されています。"></div></div></div><br class="figure-break"><p>
      <code class="literal">FEDERATED</code> テーブルを参照する SQL ステートメントをクライアントが発行する場合、ローカルサーバー (SQL ステートメントが実行される場所) とリモートサーバー (データが物理的に格納される場所) の間の情報の流れは次のとおりです。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          ストレージエンジンは <code class="literal">FEDERATED</code> テーブルが持つ各カラムを調べて、リモートテーブルを参照する適当な SQL ステートメントを構築します。
        </p></li><li class="listitem"><p>
          ステートメントは MySQL クライアント API を使用してリモートサーバーに送られます。
        </p></li><li class="listitem"><p>
          リモートサーバーはステートメントを処理し、ローカルサーバーはステートメントが作成した結果 (影響を受けた行の数や結果セット) を取得します。
        </p></li><li class="listitem"><p>
          ステートメントが結果セットを作成する場合、各カラムは <code class="literal">FEDERATED</code> エンジンが求める内部ストレージエンジン形式に変換され、元のステートメントを発行したクライアントに結果を表示するために使用できます。
        </p></li></ol></div><p>
      ローカルサーバーは、MySQL クライアントの C API 関数を使用してリモートサーバーと通信します。 <code class="literal">mysql_real_query()</code> を呼び出して、ステートメントを送信します。 結果セットを読み取るために、<code class="literal">mysql_store_result()</code> を使用し、<code class="literal">mysql_fetch_row()</code> を使用して 1 つずつ行をフェッチします。 
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="federated-create"></a>16.8.2 FEDERATED テーブルの作成方法</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="storage-engines.html#federated-create-connection">16.8.2.1 CONNECTION を使用した FEDERATED テーブルの作成</a></span></dt><dt><span class="section"><a href="storage-engines.html#federated-create-server">16.8.2.2 CREATE SERVER を使用した FEDERATED テーブルの作成</a></span></dt></dl></div><p>
      <code class="literal">FEDERATED</code> テーブルを作成するときは、次の手順に従うようにしてください。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          リモートサーバーにテーブルを作成します。 または、<code class="literal">SHOW CREATE TABLE</code> ステートメントを使用するなどして、既存テーブルのテーブル定義のメモを取ります。 
        </p></li><li class="listitem"><p>
          同一のテーブル定義でローカルサーバーにデーブルを作成しますが、ローカルテーブルをリモートテーブルにリンクする接続情報を追加してください。
        </p></li></ol></div><p>
      たとえば、リモートサーバーに次のテーブルを作成できます。
    </p><pre class="programlisting">CREATE TABLE test_table (
    id     INT(20) NOT NULL AUTO_INCREMENT,
    name   VARCHAR(32) NOT NULL DEFAULT '',
    other  INT(20) NOT NULL DEFAULT '0',
    PRIMARY KEY  (id),
    INDEX name (name),
    INDEX other_key (other)
)
ENGINE=MyISAM
DEFAULT CHARSET=utf8mb4;
</pre><p>
      リモートテーブルにフェデレートされるローカルテーブルを作成するには、2 つのオプションを使用できます。 ローカルテーブルを作成し、<code class="literal">CONNECTION</code> を使用してリモートテーブルへの接続に使用される接続文字列 (サーバー名、ログイン、パスワードを含みます) を指定するか、<code class="literal">CREATE SERVER</code> ステートメントを使用してすでに作成された既存の接続を使用できます。 
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        ローカルテーブルを作成する場合、リモートテーブルに同一のフィールド定義を持つ<span class="emphasis"><em>必要があります</em></span>。
      </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        インデックスをホストのテーブルに追加することで、<code class="literal">FEDERATED</code> テーブルのパフォーマンスを向上できます。 最適化は、リモートサーバーに送信されるクエリーに <code class="literal">WHERE</code> 句の内容が含まれ、リモートサーバーに送信されてからローカルで実行されるために行われます。 これにより、そうしないとローカル処理のためにサーバーからテーブル全体を要求することになるネットワークトラフィックが削減されます。 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="federated-create-connection"></a>16.8.2.1 CONNECTION を使用した FEDERATED テーブルの作成</h4></div></div></div><p>
        最初の方法を使用するには、<code class="literal">CREATE TABLE</code> ステートメントのエンジンタイプの後ろに <code class="literal">CONNECTION</code> 文字列を指定する必要があります。 例: 
      </p><pre class="programlisting">CREATE TABLE federated_table (
    id     INT(20) NOT NULL AUTO_INCREMENT,
    name   VARCHAR(32) NOT NULL DEFAULT '',
    other  INT(20) NOT NULL DEFAULT '0',
    PRIMARY KEY  (id),
    INDEX name (name),
    INDEX other_key (other)
)
ENGINE=FEDERATED
DEFAULT CHARSET=utf8mb4
CONNECTION='mysql://fed_user@remote_host:9306/federated/test_table';
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">CONNECTION</code> は MySQL の以前のバージョンで使われた <code class="literal">COMMENT</code> を置き換えるものです。
        </p></div><p>
        <code class="literal">CONNECTION</code> 文字列には、データが物理的に存在するテーブルを含むリモートサーバーへの接続に必要な情報が含まれます。 接続文字列には、サーバー名、ログイン資格証明、ポート番号、およびデータベース/テーブル情報を指定します。 この例では、リモートテーブルはサーバー <code class="literal">remote_host</code> 上にあり、ポート 9306 を使用します。 名前とポート番号は、リモートテーブルとして使用するリモート MySQL サーバーのホスト名 (または IP アドレス) とポート番号に一致するべきです。 
      </p><p>
        接続文字列の書式は次のとおりです。
      </p><pre class="programlisting"><em class="replaceable"><code>scheme</code></em>://<em class="replaceable"><code>user_name</code></em>[:<em class="replaceable"><code>password</code></em>]@<em class="replaceable"><code>host_name</code></em>[:<em class="replaceable"><code>port_num</code></em>]/<em class="replaceable"><code>db_name</code></em>/<em class="replaceable"><code>tbl_name</code></em>
</pre><p>
        ここでは:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <em class="replaceable"><code>scheme</code></em>: 認識された接続プロトコル。 この時点では、<code class="literal">mysql</code> だけが <em class="replaceable"><code>scheme</code></em> 値としてサポートされています。 
          </p></li><li class="listitem"><p>
            <em class="replaceable"><code>user_name</code></em>: 接続のためのユーザー名。 このユーザーは、リモートサーバー上に作成されている必要があり、リモートテーブルで必要なアクション (<code class="literal">SELECT</code>、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code> など) を実行するのに適した権限を持つ必要があります。 
          </p></li><li class="listitem"><p>
            <em class="replaceable"><code>password</code></em>: (オプション) <em class="replaceable"><code>user_name</code></em> に対応するパスワード。
          </p></li><li class="listitem"><p>
            <em class="replaceable"><code>host_name</code></em>: リモートサーバーのホスト名または IP アドレス。
          </p></li><li class="listitem"><p>
            <em class="replaceable"><code>port_num</code></em>: (オプション) リモートサーバーのポート番号。 デフォルトは 3306 です。 
          </p></li><li class="listitem"><p>
            <em class="replaceable"><code>db_name</code></em>: リモートテーブルを保持するデータベースの名前。
          </p></li><li class="listitem"><p>
            <em class="replaceable"><code>tbl_name</code></em>: リモートテーブルの名前。 ローカルテーブルとリモートテーブルの名前が一致する必要はありません。 
          </p></li></ul></div><p>
        接続文字列の例は次のとおりです。
      </p><pre class="programlisting">CONNECTION='mysql://username:password@hostname:port/database/tablename'
CONNECTION='mysql://username@hostname/database/tablename'
CONNECTION='mysql://username:password@hostname/database/tablename'
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="federated-create-server"></a>16.8.2.2 CREATE SERVER を使用した FEDERATED テーブルの作成</h4></div></div></div><p>
        多くの <code class="literal">FEDERATED</code> テーブルを同じサーバーに作成する場合、または <code class="literal">FEDERATED</code> テーブルの作成プロセスを単純化する必要がある場合、<code class="literal">CREATE SERVER</code> ステートメントを使用してサーバー接続パラメータを定義できます (<code class="literal">CONNECTION</code> 文字列の場合と同様)。
      </p><p>
        <code class="literal">CREATE SERVER</code> ステートメントの書式は次のとおりです。
      </p><pre class="programlisting">CREATE SERVER
<em class="replaceable"><code>server_name</code></em>
FOREIGN DATA WRAPPER <em class="replaceable"><code>wrapper_name</code></em>
OPTIONS (<em class="replaceable"><code>option</code></em> [, <em class="replaceable"><code>option</code></em>] ...)</pre><p>
        <em class="replaceable"><code>server_name</code></em> は <code class="literal">FEDERATED</code> テーブルを作成するときに接続文字列で使用されます。
      </p><p>
        たとえば <code class="literal">CONNECTION</code> 文字列と同一のサーバー接続を作成するには、次のとおりです。
      </p><pre class="programlisting">CONNECTION='mysql://fed_user@remote_host:9306/federated/test_table';</pre><p>
        次のステートメントを使用することになります。
      </p><pre class="programlisting">CREATE SERVER fedlink
FOREIGN DATA WRAPPER mysql
OPTIONS (USER 'fed_user', HOST 'remote_host', PORT 9306, DATABASE 'federated');</pre><p>
        この接続を使用する <code class="literal">FEDERATED</code> テーブルを作成するには、<code class="literal">CONNECTION</code> キーワードも使用しますが、<code class="literal">CREATE SERVER</code> ステートメントで使用した名前を指定します。
      </p><pre class="programlisting">CREATE TABLE test_table (
    id     INT(20) NOT NULL AUTO_INCREMENT,
    name   VARCHAR(32) NOT NULL DEFAULT '',
    other  INT(20) NOT NULL DEFAULT '0',
    PRIMARY KEY  (id),
    INDEX name (name),
    INDEX other_key (other)
)
ENGINE=FEDERATED
DEFAULT CHARSET=utf8mb4
CONNECTION='fedlink/test_table';</pre><p>
        この例の接続名には、接続の名前 (<code class="literal">fedlink</code>) とリンクするテーブルの名前 (<code class="literal">test_table</code>) が含まれます (区切りはスラッシュ)。 テーブル名なしで接続名だけを指定した場合、代わりにローカルテーブルのテーブル名が使用されます。 
      </p><p>
        <code class="literal">CREATE SERVER</code> の詳細情報については、<a class="xref" href="sql-statements.html#create-server" title="13.1.18 CREATE SERVER ステートメント">セクション13.1.18「CREATE SERVER ステートメント」</a>を参照してください。
      </p><p>
        <code class="literal">CREATE SERVER</code> ステートメントは、<code class="literal">CONNECTION</code> 文字列と同じ引数を受け入れます。 <code class="literal">CREATE SERVER</code> ステートメントは <code class="literal">mysql.servers</code> テーブルの中の行を更新します。 接続文字列のパラメータ間の通信、<code class="literal">CREATE SERVER</code> ステートメントのオプション、および <code class="literal">mysql.servers</code> テーブルのカラムに関する情報については、次の表を参照してください。 参考までに、<code class="literal">CONNECTION</code> 文字列の書式は次のとおりです。 
      </p><pre class="programlisting"><em class="replaceable"><code>scheme</code></em>://<em class="replaceable"><code>user_name</code></em>[:<em class="replaceable"><code>password</code></em>]@<em class="replaceable"><code>host_name</code></em>[:<em class="replaceable"><code>port_num</code></em>]/<em class="replaceable"><code>db_name</code></em>/<em class="replaceable"><code>tbl_name</code></em>
</pre><div class="informaltable"><table summary="The correspondence between parameters in a connection string, options in the CREATE SERVER statement, and the columns in the mysql.servers table."><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><thead><tr>
            <th scope="col">説明</th>
            <th scope="col"><code class="literal">CONNECTION</code> 文字列</th>
            <th scope="col"><code class="literal">CREATE SERVER</code> オプション</th>
            <th scope="col"><code class="literal">mysql.servers</code> カラム</th>
          </tr></thead><tbody><tr>
            <th scope="row">接続スキーム</th>
            <td><em class="replaceable"><code>scheme</code></em></td>
            <td><code class="literal">wrapper_name</code></td>
            <td><code class="literal">Wrapper</code></td>
          </tr><tr>
            <th scope="row">リモートユーザー</th>
            <td><em class="replaceable"><code>user_name</code></em></td>
            <td><code class="literal">USER</code></td>
            <td><code class="literal">Username</code></td>
          </tr><tr>
            <th scope="row">リモートパスワード</th>
            <td><em class="replaceable"><code>password</code></em></td>
            <td><code class="literal">PASSWORD</code></td>
            <td><code class="literal">Password</code></td>
          </tr><tr>
            <th scope="row">リモートホスト</th>
            <td><em class="replaceable"><code>host_name</code></em></td>
            <td><code class="literal">HOST</code></td>
            <td><code class="literal">Host</code></td>
          </tr><tr>
            <th scope="row">リモートポート</th>
            <td><em class="replaceable"><code>port_num</code></em></td>
            <td><code class="literal">PORT</code></td>
            <td><code class="literal">Port</code></td>
          </tr><tr>
            <th scope="row">リモートデータベース</th>
            <td><em class="replaceable"><code>db_name</code></em></td>
            <td><code class="literal">DATABASE</code></td>
            <td><code class="literal">Db</code></td>
          </tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="federated-usagenotes"></a>16.8.3 FEDERATED ストレージエンジンの注記とヒント</h3></div></div></div><p>
      <code class="literal">FEDERATED</code> ストレージエンジンを使用するときは、次の点に注意することをお勧めします。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">FEDERATED</code> テーブルは他のレプリカにレプリケートできますが、レプリカサーバーが <code class="literal">CONNECTION</code> 文字列 (または <code class="literal">mysql.servers</code> テーブルの行) に定義されているユーザー/パスワードの組合せを使用してリモートサーバーに接続できることを確認する必要があります。
        </p></li></ul></div><p>
      次の項目は、<code class="literal">FEDERATED</code> ストレージエンジンがサポートしている機能とサポートしていない機能を示します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          リモートサーバーは MySQL サーバーでなくてはいけません。
        </p></li><li class="listitem"><p>
          <code class="literal">FEDERATED</code> テーブルがポイントするリモートテーブルは、<code class="literal">FEDERATED</code> テーブルを介してそのテーブルにアクセスを試みる前に、存在<span class="emphasis"><em>している必要があります</em></span>。
        </p></li><li class="listitem"><p>
          ある <code class="literal">FEDERATED</code> テーブルがほかのテーブルをポイントすることは可能ですが、ループを作らないように注意する必要があります。
        </p></li><li class="listitem"><p>
          <code class="literal">FEDERATED</code> テーブルは通常の意味でインデックスをサポートしていません。テーブルデータへのアクセスはリモートで処理されるため、実際にはインデックスを使用するリモートテーブルです。 つまり、インデックスを使用できないために全テーブルスキャンが必要なクエリーの場合、サーバーはリモートテーブルからすべての行をフェッチし、ローカルでフィルタします。 これは、この <code class="literal">SELECT</code> ステートメントで使用される <code class="literal">WHERE</code> または <code class="literal">LIMIT</code> に関係なく発生します。これらの句は、戻される行にローカルに適用されます。 
        </p><p>
          したがって、インデックスの使用に失敗したクエリーは、パフォーマンスおよびネットワークオーバーロードの低下を引き起こす可能性があります。 また、返される行はメモリーに格納する必要があるため、このようなクエリーによってローカルサーバーのスワッピングやハングアップが発生することもあります。 
        </p></li><li class="listitem"><p>
          同等の <code class="literal">MyISAM</code> やほかのテーブルからのインデックス定義がサポートされていない可能性があるため、<code class="literal">FEDERATED</code> テーブルを作成するときは注意を払うようにしてください。 たとえば、テーブルが <code class="literal">VARCHAR</code>、<code class="literal">TEXT</code> または <code class="literal">BLOB</code> カラムでインデックス接頭辞を使用している場合、<code class="literal">FEDERATED</code> テーブルの作成は失敗します。 <code class="literal">MyISAM</code> を使用した次の定義は有効です: 
        </p><pre class="programlisting">CREATE TABLE `T1`(`A` VARCHAR(100),UNIQUE KEY(`A`(30))) ENGINE=MYISAM;</pre><p>
          この例のキー接頭辞は <code class="literal">FEDERATED</code> エンジンと互換性がなく、同等のステートメントが失敗します:
        </p><pre class="programlisting">CREATE TABLE `T1`(`A` VARCHAR(100),UNIQUE KEY(`A`(30))) ENGINE=FEDERATED
  CONNECTION='MYSQL://127.0.0.1:3306/TEST/T1';</pre><p>
          可能であれば、これらのインデックスの問題を回避するため、リモートサーバーとローカルサーバーの両方にテーブルを作成する場合、カラムとインデックスの定義を分けるようにしてください。
        </p></li><li class="listitem"><p>
          内部的に、実装は <code class="literal">SELECT</code>、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> を使用しますが、<code class="literal">HANDLER</code> は使用しません。
        </p></li><li class="listitem"><p>
          <code class="literal">FEDERATED</code> ストレージエンジンは、<code class="literal">SELECT</code>、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、<code class="literal">DELETE</code>、<code class="literal">TRUNCATE TABLE</code>、およびインデックスをサポートしています。 <code class="literal">DROP TABLE</code> を除いて、<code class="literal">ALTER TABLE</code> や、テーブルの構造に直接影響を与えるデータ定義言語ステートメントをサポートしていません。 現在の実装は、プリペアドステートメントを使用しません。 
        </p></li><li class="listitem"><p>
          <code class="literal">FEDERATED</code> は <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> ステートメントを受け入れますが、重複キー違反が起こった場合、ステートメントはエラーで失敗します。
        </p></li><li class="listitem"><p>
          トランザクションはサポートされていません。
        </p></li><li class="listitem"><p>
          <code class="literal">FEDERATED</code> は、複数の行がバッチでリモートテーブルに送信されるように一括挿入処理を実行するため、パフォーマンスが向上します。 また、リモートテーブルがトランザクション対応の場合、エラーが発生したときにリモートストレージエンジンはステートメントロールバックを適切に実行できます。 この機能には次の制限があります。 
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              挿入のサイズは、サーバー間の最大パケットサイズを超えることはできません。 挿入がこのサイズを超えた場合、複数のパケットに分割され、ロールバック問題が発生する可能性があります。 
            </p></li><li class="listitem"><p>
              大量挿入処理は <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> では起こりません。
            </p></li></ul></div></li><li class="listitem"><p>
          <code class="literal">FEDERATED</code> エンジンは、リモートテーブルが変わったかどうかを知る方法がありません。 その理由は、このテーブルが、データベースシステム以外の何かによって決して書き込まれることのないデータファイルのように動作する必要があるためです。 リモートデータベースに変更が加えられた場合に、ローカルテーブルのデータの完全性が損なわれる可能性があります。 
        </p></li><li class="listitem"><p>
          <code class="literal">CONNECTION</code> 文字列を使用する場合、パスワードに '@' 文字を使用できません。 <code class="literal">CREATE SERVER</code> ステートメントを使用してサーバー接続を作成することで、この制限を回避できます。 
        </p></li><li class="listitem"><p>
          <code class="literal">insert_id</code> および <code class="literal">timestamp</code> オプションはデータプロバイダには伝達されません。
        </p></li><li class="listitem"><p>
          <code class="literal">FEDERATED</code> テーブルに対して発行された <code class="literal">DROP TABLE</code> ステートメントは、ローカルテーブルだけを削除し、リモートテーブルは削除しません。
        </p></li><li class="listitem"><p>
          <code class="literal">FEDERATED</code> テーブルはクエリーキャッシュでは機能しません。
        </p></li><li class="listitem"><p>
          ユーザー定義のパーティション化は、<code class="literal">FEDERATED</code> テーブルではサポートされていません。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="federated-storage-engine-resources"></a>16.8.4 FEDERATED ストレージエンジンのリソース</h3></div></div></div><p>
      次の追加リソースは、<code class="literal">FEDERATED</code> ストレージエンジンで利用できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">FEDERATED</code> ストレージエンジンに特化したフォーラムは <a class="ulink" href="https://forums.mysql.com/list.php?105" target="_top">https://forums.mysql.com/list.php?105</a> で参照できます。
        </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-storage-engine"></a>16.9 EXAMPLE ストレージエンジン</h2></div></div></div><a class="indexterm" name="idm45568053664128"></a><a class="indexterm" name="idm45568053662640"></a><p>
    <code class="literal">EXAMPLE</code> ストレージエンジンは、何もしないスタブエンジンです。 その目的は、新しいストレージエンジンの書き込みを開始する方法を示す MySQL ソースコードの例として機能することです。 このため、主に開発者を対象としています。 
  </p><p>
    ソースから MySQL を構築する場合に <code class="literal">EXAMPLE</code> ストレージエンジンを有効にするには、<span class="command"><strong>CMake</strong></span> を <code class="option">-DWITH_EXAMPLE_STORAGE_ENGINE</code> オプションで呼び出します。
  </p><p>
    <code class="literal">EXAMPLE</code> エンジンのソースを調べるには、MySQL ソース配布の <code class="filename">storage/example</code> ディレクトリを検索します。
  </p><p>
    <code class="literal">EXAMPLE</code> テーブルを作成する場合、ファイルは作成されません。 データをテーブルに格納できません。 検索は空の結果を返します。 
  </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE test (i INT) ENGINE = EXAMPLE;</code></strong>
Query OK, 0 rows affected (0.78 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO test VALUES(1),(2),(3);</code></strong>
ERROR 1031 (HY000): Table storage engine for 'test' doesn't »
                    have this option

mysql&gt; <strong class="userinput"><code>SELECT * FROM test;</code></strong>
Empty set (0.31 sec)
</pre><p>
    <code class="literal">EXAMPLE</code> ストレージエンジンはインデックスをサポートしていません。
  </p><p>
    <code class="literal">EXAMPLE</code> ストレージエンジンはパーティション分割をサポートしていません。
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="storage-engines-other"></a>16.10 ほかのストレージエンジン</h2></div></div></div><p>
      ストレージエンジンは、カスタムストレージエンジンのインタフェースを使用したサードパーティーおよびコミュニティーメンバーの別のストレージエンジンを使用できる場合があります。
    </p><p>
      サードパーティーのエンジンは MySQL によってサポートされていません。 これらのエンジンに関する詳細情報、ドキュメント、インストールガイド、バグレポート、ヘルプや支援については、そのエンジンの開発者に直接問い合わせてください。 
    </p><p>
      プラガブルストレージエンジンアーキテクチャーで使用できるお客様のストレージエンジンの開発に関する詳細については、「<a class="ulink" href="https://dev.mysql.com/doc/internals/en/custom-engine.html" target="_top">MySQL Internals: Writing a Custom Storage Engine</a>」を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pluggable-storage-overview"></a>16.11 MySQL ストレージエンジンアーキテクチャーの概要</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="storage-engines.html#pluggable-storage">16.11.1 プラガブルストレージエンジンのアーキテクチャー</a></span></dt><dt><span class="section"><a href="storage-engines.html#pluggable-storage-common-layer">16.11.2 共通データベースサーバーレイヤー</a></span></dt></dl></div><p>
      MySQL プラガブルストレージエンジンアーキテクチャーを採用すると、データベースの専門家は、特定のアプリケーションニーズに特化したストレージエンジンを選択でき、さらにアプリケーションの特定のコーディング要件を管理する必要が完全になくなります。 MySQL サーバーのアーキテクチャーにより、アプリケーションプログラマと DBA はストレージレベルのすべての実装詳細から解放され、一貫した容易なアプリケーションモデルと API が得られます。 したがって、異なるストレージエンジンの機能には違いがありますが、アプリケーションはその違いから解放されます。 
    </p><p>
      MySQL プラガブルストレージエンジンのアーキテクチャは、<a class="xref" href="storage-engines.html#mysql-architecture-diagram" title="図 16.3 プラガブルストレージエンジンを使用した MySQL アーキテクチャ">図16.3「プラガブルストレージエンジンを使用した MySQL アーキテクチャ」</a> に示されています。
    </p><div class="figure"><a name="mysql-architecture-diagram"></a><p class="title"><b>図 16.3 プラガブルストレージエンジンを使用した MySQL アーキテクチャ</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/mysql-architecture.png" width="700" height="427" alt="コネクタ、インタフェース、プラガブルなストレージエンジン、ファイルとログを含むファイルシステムを示す MySQL アーキテクチャー図。"></div></div></div><br class="figure-break"><p>
      プラガブルストレージエンジンのアーキテクチャーは、すべての基になるストレージエンジンに共通の管理およびサポートサービスの標準セットを提供します。 ストレージエンジン自身は、物理サーバーレベルで保守される基になるデータに対してアクションを実際に実行するデータベースサーバーのコンポーネントです。 
    </p><p>
      この効率的なモジュール形式のアーキテクチャーは、データウェアハウス、トランザクション処理、高可用性状況など、特別なアプリケーションニーズを特に対象にしたい人、またどれか 1 つのストレージエンジンに依存しないインタフェースとサービスのセットを利用するメリットを享受したい人にとって、大きなメリットが得られます。
    </p><p>
      アプリケーションプログラマと DBA は、コネクタ API およびストレージエンジンの上位にあるサービスレイヤーを介して MySQL データベースと対話します。 アプリケーションの変更によって、基になるストレージエンジンの変更を求める要件が発生した場合、または新しいニーズをサポートするために 1 つ以上のストレージエンジンが追加された場合、これをうまく行うためにコーディングやプロセスを大幅に変更する必要はありません。 MySQL サーバーのアーキテクチャーは、ストレージエンジンに適用される、一貫して使いやすい API を提供することで、ストレージエンジンの内在する複雑さからアプリケーションを解放します。 
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="pluggable-storage"></a>16.11.1 プラガブルストレージエンジンのアーキテクチャー</h3></div></div></div><p>
        MySQL Server は、ストレージエンジンが、動作中の MySQL サーバーにロードされたり、MySQL サーバーからアンロードされたりできる、プラガブルストレージエンジンアーキテクチャーを採用しています。
      </p><p>
        <span class="bold"><strong>ストレージエンジンのプラグイン</strong></span>
      </p><p>
        ストレージエンジンを使用する前に、<code class="literal">INSTALL PLUGIN</code> ステートメントを利用してストレージエンジンのプラグイン共用ライブラリを MySQL にロードする必要があります。 たとえば、<code class="literal">EXAMPLE</code> エンジンのプラグインの名前が <code class="literal">example</code> で、共有ライブラリの名前が <code class="filename">ha_example.so</code> である場合、次のステートメントを使用してロードします。 
      </p><pre class="programlisting">INSTALL PLUGIN example SONAME 'ha_example.so';
</pre><p>
        プラガブルストレージエンジンをインストールするには、プラグインファイルは MySQL プラグインディレクトリにある必要があり、<code class="literal">INSTALL PLUGIN</code> ステートメントを発行するユーザーには、<code class="literal">mysql.plugin</code> テーブルの <code class="literal">INSERT</code> 権限が必要です。
      </p><p>
        共有ライブラリは MySQL サーバーのプラグインディレクトリの中にある必要があり、その場所は <code class="literal">plugin_dir</code>システム変数によって指示されます。
      </p><p>
        <span class="bold"><strong>ストレージエンジンのアンプラグ</strong></span>
      </p><p>
        ストレージエンジンをアンプラグするには、<code class="literal">UNINSTALL PLUGIN</code> ステートメントを利用します。
      </p><pre class="programlisting">UNINSTALL PLUGIN example;
</pre><p>
        既存のテーブルに必要なストレージエンジンを切断すると、それらのテーブルにはアクセスできなくなりますが、ディスクにはまだ存在します (該当する場合)。 ストレージエンジンをアンプラグする前に、そのストレージエンジンを使用しているテーブルがないことを確認してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="pluggable-storage-common-layer"></a>16.11.2 共通データベースサーバーレイヤー</h3></div></div></div><p>
        MySQL プラガブルストレージエンジンは、データベースに対して実データの I/O 操作を行なったり、特定のアプリケーションニーズを対象とする機能セットを有効にしたり適用したりする役割を担う、MySQL データベースサーバーのコンポーネントです。 特定のストレージエンジンを使用する主なメリットは、特定のアプリケーションに必要な機能だけが配布されるため、データベースのオーバーヘッドが小さくなり、データベースパフォーマンスが効率的になり向上します。 これは、MySQL がこのように高パフォーマンスであると以前から知られてきた理由の 1 つであり、業界標準ベンチマークで独占的な地位を占める強力なデータベースに匹敵または対抗できる要因になっています。 
      </p><p>
        技術的に見て、ストレージエンジンを支える独自のインフラストラクチャー要素は何でしょうか。 機能を差別化している主な要素は次のとおりです。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="emphasis"><em>並列性</em></span>: いくつかのアプリケーションは、ほかのアプリケーションよりさらに粒度の細かいロック要件 (低レベルロックなど) を持ちます。 適切なロック方式を選択すると、オーバーヘッドが低減されるため、全体のパフォーマンスが向上します。 また、この分野はマルチバージョンの並列処理制御や<span class="quote">「<span class="quote">スナップショット</span>」</span>の読み込みのような機能もサポートします。 
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>トランザクションサポート</em></span>: 必ずしもすべてのアプリケーションがトランザクションを必要としていませんが、必要な場合、ACID 準拠などの非常に明確な要件があります。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>参照整合性</em></span>: サーバーは DDL 定義の外部キーでリレーショナルデータベースの参照整合性を適用する必要があります。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>物理ストレージ</em></span>: これには、テーブルとインデックスの全体ページサイズやデータの物理ディスクへの格納に使用されるフォーマットのすべてが関係します。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>インデックスサポート</em></span>: アプリケーションシナリオによっては、別のインデックス方式からメリットが得られる傾向があります。 通常、各ストレージエンジンには独自のインデックス方式がありますが、ほぼすべてのエンジンに共通の方式 (B ツリーインデックスなど) もあります。 
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>メモリーキャッシュ</em></span>: 一部のメモリーキャッシュ戦略では、一部のアプリケーションがほかのアプリケーションよりも適切に応答するため、一部のメモリーキャッシュはすべてのストレージエンジン (ユーザー接続に使用されるものなど) に共通ですが、その他のアプリケーションは特定のストレージエンジンが再生されるときにのみ一意に定義されます。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>パフォーマンスエイド</em></span>: これには、並列操作用のマルチ I/O スレッド、スレッド並列処理、データベースチェックポイント、大量の挿入処理などが含まれます。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>その他のターゲット機能</em></span>: これには、地理空間操作、データ操作のセキュリティー面の制限事項、およびその他の類似機能に対するサポートが含まれます。
          </p></li></ul></div><p>
        プラガブルストレージエンジンの各インフラストラクチャーコンポーネントセットは、特定のアプリケーション向けの利点を提供できるように設計されています。 反対に、あるコンポーネント機能セットを回避することは、不必要なオーバーヘッドを削減するのに役立ちます。 特定アプリケーションの要件セットを理解して、適切な MySQL ストレージエンジンを選択することは、当然のことながらシステム全体の効率とパフォーマンスに大きな影響を与える可能性があります。 
      </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="innodb-storage-engine.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="replication.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第 15 章 InnoDB ストレージエンジン </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第 17 章 レプリケーション</td></tr></table></div><div class="copyright-footer"></div></body></html>
