<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第 24 章 パーティション化</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="MySQL 8.0 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 8.0 リファレンスマニュアル"><link rel="prev" href="mysql-cluster.html" title="第 23 章 MySQL NDB Cluster 8.0"><link rel="next" href="stored-objects.html" title="第 25 章 ストアドオブジェクト"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 24 章 パーティション化</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="mysql-cluster.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="stored-objects.html">次へ</a></td></tr></table><hr></div><div class="status-header"><p class="alert">このページは機械翻訳したものです。</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="partitioning"></a>第 24 章 パーティション化</h1></div></div></div><div class="toc"><p><b>目次</b></p><dl class="toc"><dt><span class="section"><a href="partitioning.html#partitioning-overview">24.1 MySQL のパーティショニングの概要</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-types">24.2 パーティショニングタイプ</a></span></dt><dd><dl><dt><span class="section"><a href="partitioning.html#partitioning-range">24.2.1 RANGE パーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-list">24.2.2 LIST パーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-columns">24.2.3 COLUMNS パーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-hash">24.2.4 HASH パーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-key">24.2.5 KEY パーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-subpartitions">24.2.6 サブパーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-handling-nulls">24.2.7 MySQL パーティショニングによる NULL の扱い</a></span></dt></dl></dd><dt><span class="section"><a href="partitioning.html#partitioning-management">24.3 パーティション管理</a></span></dt><dd><dl><dt><span class="section"><a href="partitioning.html#partitioning-management-range-list">24.3.1 RANGE および LIST パーティションの管理</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-management-hash-key">24.3.2 HASH および KEY パーティションの管理</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-management-exchange">24.3.3 パーティションとサブパーティションをテーブルと交換する</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-maintenance">24.3.4 パーティションの保守</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-info">24.3.5 パーティションに関する情報を取得する</a></span></dt></dl></dd><dt><span class="section"><a href="partitioning.html#partitioning-pruning">24.4 パーティションプルーニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-selection">24.5 パーティション選択</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-limitations">24.6 パーティショニングの制約と制限</a></span></dt><dd><dl><dt><span class="section"><a href="partitioning.html#partitioning-limitations-partitioning-keys-unique-keys">24.6.1 パーティショニングキー、主キー、および一意キー</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-limitations-storage-engines">24.6.2 ストレージエンジンに関連するパーティショニング制限</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-limitations-functions">24.6.3 関数に関連するパーティショニング制限</a></span></dt></dl></dd></dl></div><a class="indexterm" name="idm45807911238064"></a><a class="indexterm" name="idm45807911237008"></a><a class="indexterm" name="idm45807911235920"></a><a class="indexterm" name="idm45807911233776"></a><a class="indexterm" name="idm45807911231744"></a><p>
    この章では、<span class="firstterm">ユーザー定義のパーティション化</span>について説明します。
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
      テーブルのパーティション化は、ウィンドウ関数で使用されるパーティション化とは異なります。 ウィンドウ関数の詳細は、<a class="xref" href="functions.html#window-functions" title="12.21 ウィンドウ関数">セクション12.21「ウィンドウ関数」</a> を参照してください。 
    </p></div><p>
    MySQL 8.0 では、パーティション分割のサポートは <code class="literal">InnoDB</code> および <code class="literal">NDB</code> ストレージエンジンによって提供されます。
  </p><p>
    MySQL 8.0 は現在、<code class="literal">MyISAM</code> などの <code class="literal">InnoDB</code> または <code class="literal">NDB</code> 以外のストレージエンジンを使用したテーブルのパーティション化をサポートしていません。 ネイティブパーティション化サポートを提供しないストレージエンジンを使用してパーティションテーブルを作成しようとすると、<span class="errorcode"> ER_CHECK_NOT_IMPLEMENTED </span>で失敗します。 
  </p><p>
    Oracle によって提供される MySQL 8.0 Community バイナリには、<code class="literal">InnoDB</code> および <code class="literal">NDB</code> ストレージエンジンによって提供されるパーティショニングサポートが含まれます。 MySQL Enterprise Edition バイナリで提供されるパーティション分割サポートの詳細は、<a class="xref" href="mysql-enterprise.html" title="第 30 章 MySQL Enterprise Edition">第30章「<i>MySQL Enterprise Edition</i>」</a> を参照してください。 
  </p><p>
    ソースから MySQL 8.0 をコンパイルする場合は、<code class="literal">InnoDB</code> サポートを使用してビルドを構成すれば、<code class="literal">InnoDB</code> テーブルのパーティションサポートを使用してバイナリを作成できます。 詳細は、<a class="xref" href="installing.html#source-installation" title="2.9 ソースから MySQL をインストールする">セクション2.9「ソースから MySQL をインストールする」</a>を参照してください。 
  </p><p>
    <code class="literal">InnoDB</code> によるパーティション化サポートを有効にするために、これ以上行う必要はありません (たとえば、<code class="filename">my.cnf</code> ファイルに特別なエントリは必要ありません)。
  </p><p>
    <code class="literal">InnoDB</code> ストレージエンジンによるパーティション分割サポートを無効にすることはできません。
  </p><p>
    パーティショニングの概要およびパーティショニングの概念については、<a class="xref" href="partitioning.html#partitioning-overview" title="24.1 MySQL のパーティショニングの概要">セクション24.1「MySQL のパーティショニングの概要」</a>を参照してください。
  </p><p>
    サブパーティション化に加えて、いくつかのタイプのパーティション化がサポートされています。<a class="xref" href="partitioning.html#partitioning-types" title="24.2 パーティショニングタイプ">セクション24.2「パーティショニングタイプ」</a> および <a class="xref" href="partitioning.html#partitioning-subpartitions" title="24.2.6 サブパーティショニング">セクション24.2.6「サブパーティショニング」</a> を参照してください。
  </p><p>
    <a class="xref" href="partitioning.html#partitioning-management" title="24.3 パーティション管理">セクション24.3「パーティション管理」</a>では、既存のパーティション化されたテーブルでパーティションを追加、削除および変更する方法について説明しています。
  </p><p>
    <a class="xref" href="partitioning.html#partitioning-maintenance" title="24.3.4 パーティションの保守">セクション24.3.4「パーティションの保守」</a>では、パーティション化されたテーブルで使用するテーブル保守コマンドについて説明しています。
  </p><p>
    <code class="literal">INFORMATION_SCHEMA</code> データベースの <code class="literal">PARTITIONS</code> テーブルには、パーティションおよびパーティション化されたテーブルに関する情報があります。 詳細は、<a class="xref" href="information-schema.html#information-schema-partitions-table" title="26.21 INFORMATION_SCHEMA PARTITIONS テーブル">セクション26.21「INFORMATION_SCHEMA PARTITIONS テーブル」</a>を参照してください。このテーブルに対するクエリーのいくつかの例については、<a class="xref" href="partitioning.html#partitioning-handling-nulls" title="24.2.7 MySQL パーティショニングによる NULL の扱い">セクション24.2.7「MySQL パーティショニングによる NULL の扱い」</a>を参照してください。 
  </p><p>
    MySQL 8.0 のパーティショニングの既知の問題については、<a class="xref" href="partitioning.html#partitioning-limitations" title="24.6 パーティショニングの制約と制限">セクション24.6「パーティショニングの制約と制限」</a>を参照してください。
  </p><p>
    また、パーティション化されたテーブルを使用して作業を行うときに、次のリソースが役に立つことがあります。
  </p><a class="indexterm" name="idm45807911198464"></a><p><b>追加のリソース. </b>
      MySQL のユーザー定義パーティショニングに関するその他の情報ソースには、次のものがあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="ulink" href="https://forums.mysql.com/list.php?106" target="_top">MySQL パーティショニングフォーラム</a>
      </p><p>
        これは、MySQL パーティショニングテクノロジに興味があり実験している人のための公式ディスカッションフォーラムです。 MySQL 開発者などからの発表や更新が掲載されています。 パーティショニングの開発チームおよびドキュメントチームのメンバーによってモニターされています。 
      </p></li><li class="listitem"><p>
        <a class="ulink" href="http://mikaelronstrom.blogspot.com/" target="_top">Mikael Ronström のブログ</a>
      </p><p>
        MySQL Partitioning Architect および Lead Developer Mikael Ronström は、MySQL Partitioning および NDB Cluster での作業に関する記事を頻繁に投稿しています。
      </p></li><li class="listitem"><p>
        <a class="ulink" href="http://www.planetmysql.org/" target="_top">PlanetMySQL</a>
      </p><p>
        MySQL を使用している人が関心を持つと思われる MySQL 関連ブログをまとめた MySQL ニュースサイト。 MySQL パーティショニングを使用している人が更新しているブログへのリンクをここでチェックしたり、自分のブログを追加したりすることをお勧めします。 
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="partitioning-overview"></a>24.1 MySQL のパーティショニングの概要</h2></div></div></div><a class="indexterm" name="idm45807911185984"></a><p>
      このセクションでは、MySQL 8.0 のパーティショニングの概念について説明します。
    </p><p>
      パーティショニングの制約および機能制限については、<a class="xref" href="partitioning.html#partitioning-limitations" title="24.6 パーティショニングの制約と制限">セクション24.6「パーティショニングの制約と制限」</a>を参照してください。
    </p><p>
      SQL 標準では、データ保存の物理的な仕様に関するガイダンスはあまり提供されていません。 SQL 言語自体が、それが動作するスキーマ、テーブル、行、またはカラムの基盤となるデータ構造やメディアと独立して動作するように意図されています。 それにもかかわらず、ほとんどの高度なデータベース管理システムでは、ファイルシステム、ハードウェア、またはその両方について、特定のデータを格納するために使用される物理的な場所を判別する方法が開発されてきました。 MySQL では、<code class="literal">InnoDB</code> ストレージエンジンが長い間テーブルスペースの概念をサポートしており (<a class="xref" href="innodb-storage-engine.html#innodb-tablespace" title="15.6.3 テーブルスペース">セクション15.6.3「テーブルスペース」</a> を参照)、パーティション分割を導入する前でも、異なるデータベースを格納するために異なる物理ディレクトリを使用するように MySQL Server を構成できます (この方法については <a class="xref" href="optimization.html#symbolic-links" title="8.12.2 シンボリックリンクの使用">セクション8.12.2「シンボリックリンクの使用」</a> を参照)。 
    </p><p>
      <span class="firstterm">パーティショニング</span>はこの認識をさらに一歩進めて、必要に応じて多くの部分を設定できるルールに従って、個々のテーブルの部分をファイルシステムに配分できるようにしています。 それにより、テーブルの異なる部分が別個のテーブルとして別個の場所に格納されます。 データを分割するためにユーザーが選択するルールは<span class="firstterm">パーティショニング関数</span>と呼ばれ、MySQL では法、範囲セットまたは値リストに対する単純な照合、内部ハッシュ関数、または線形ハッシュ関数が使用されます。 関数は、ユーザーが指定したパーティショニングタイプに従って選択され、ユーザーが指定した式の値をパラメータとして取ります。 この式には、使用されるパーティショニングのタイプに応じて、カラム値、1 つ以上のカラム値を操作する関数、または 1 つ以上のカラム値のセットを指定できます。 
    </p><p>
      <code class="literal">RANGE</code>、<code class="literal">LIST</code>、および [<code class="literal">LINEAR</code>] <code class="literal">HASH</code> パーティショニングの場合、パーティショニングカラムの値はパーティショニング関数に渡され、特定のレコードを格納すべきパーティションの番号を表す整数値が返されます。 この関数は非定数および非ランダムである必要があります。 クエリーを含めることはできませんが、式が <code class="literal">NULL</code> または次のような整数 <em class="replaceable"><code>intval</code></em> を返すかぎり、MySQL で有効な SQL 式を使用できます。 
    </p><pre class="programlisting">-MAXVALUE &lt;= <em class="replaceable"><code>intval</code></em> &lt;= MAXVALUE
</pre><p>
      (<code class="literal">MAXVALUE</code> は対象となる整数型の上限を表すために使用されます。<code class="literal">-MAXVALUE</code> は下限を表します。)
    </p><p>
      [<code class="literal">LINEAR</code>] <code class="literal">KEY</code>、<code class="literal">RANGE COLUMNS</code>、および <code class="literal">LIST COLUMNS</code> パーティショニングの場合、パーティショニング式は 1 つ以上のカラムのリストから構成されます。
    </p><p>
      [<code class="literal">LINEAR</code>] <code class="literal">KEY</code> パーティショニングの場合、パーティショニング関数は MySQL によって提供されます。
    </p><p>
      許可されるパーティショニングカラムタイプおよびパーティショニング関数については、<a class="xref" href="partitioning.html#partitioning-types" title="24.2 パーティショニングタイプ">セクション24.2「パーティショニングタイプ」</a>、およびパーティショニング構文の説明および追加例を示している<a class="xref" href="sql-statements.html#create-table" title="13.1.20 CREATE TABLE ステートメント">セクション13.1.20「CREATE TABLE ステートメント」</a>を参照してください。 パーティショニング関数の制約については、<a class="xref" href="partitioning.html#partitioning-limitations-functions" title="24.6.3 関数に関連するパーティショニング制限">セクション24.6.3「関数に関連するパーティショニング制限」</a>を参照してください。 
    </p><p>
      これは<span class="firstterm">「水平パーティショニング」</span>と呼ばれます。つまり、テーブル内の異なる行を異なる物理パーティションに割り当てることができます。 MySQL 8.0 では、テーブルの異なるカラムが異なる物理パーティションに割り当てられる<span class="firstterm">垂直パーティション化</span>はサポートされていません。 現時点では、MySQL に垂直パーティション化を導入する計画はありません。 
    </p><p>
      パーティション化されたテーブルを作成するには、それらをサポートするストレージエンジンを使用する必要があります。 MySQL 8.0 では、同じパーティション化されたテーブルのすべてのパーティションが同じストレージエンジンを使用する必要があります。 ただし、同じ MySQL サーバーまたは同じデータベース上の異なるパーティション化されたテーブルに、異なるストレージエンジンを使用することはできます。 
    </p><p>
      MySQL 8.0 では、パーティション分割をサポートするストレージエンジンは <code class="literal">InnoDB</code> と <code class="literal">NDB</code> だけです。 パーティション分割は、それをサポートしていないストレージエンジンでは使用できません。これには、<code class="literal">MyISAM</code>, <code class="literal">MERGE</code>, <code class="literal">CSV</code> および <code class="literal">FEDERATED</code> ストレージエンジンが含まれます。 
    </p><p>
      <code class="literal">KEY</code> または <code class="literal">LINEAR KEY</code> によるパーティショニングは <code class="literal">NDB</code> で使用できますが、ほかのタイプのユーザー定義パーティショニングはこのストレージエンジンを使用するテーブルでサポートされません。 また、ユーザー定義パーティショニングを使用する <code class="literal">NDB</code> テーブルには明示的な主キーが必要であり、テーブルのパーティショニング式で参照されるカラムは主キーの一部である必要があります。 ただし、ユーザーパーティション化された <code class="literal">NDB</code> テーブルを作成または変更するために使用される <code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントの <code class="literal">PARTITION BY KEY</code> 句または <code class="literal">PARTITION BY LINEAR KEY</code> 句にカラムが 1 つもリストされていない場合は、テーブルに明示的な主キーは必要ありません。 詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-limitations-syntax" title="23.1.7.1 NDB Cluster の SQL 構文に準拠していません">セクション23.1.7.1「NDB Cluster の SQL 構文に準拠していません」</a>を参照してください。 
    </p><p>
      パーティション化されたテーブルを作成する場合、デフォルトのストレージエンジンはほかのテーブルを作成する場合と同様に使用されます。この動作をオーバーライドするには、パーティション化されていないテーブルの場合と同様に<code class="literal">[STORAGE] ENGINE</code> オプションを使用するだけで済みます。 ターゲットストレージエンジンは、ネイティブパーティショニングサポートを提供する必要があります。そうしないと、ステートメントは失敗します。 <code class="literal">CREATE TABLE</code> ステートメントでパーティション化オプションを使用する前に、<code class="literal">[STORAGE] ENGINE</code> (およびその他のテーブルオプション) をリストする必要があることに注意してください。 次の例では、ハッシュによって 6 つのパーティションにパーティション化され、(<code class="literal">default_storage_engine</code> の値に関係なく) <code class="literal">InnoDB</code> ストレージエンジンを使用するテーブルを作成する方法を示します: 
    </p><pre class="programlisting">CREATE TABLE ti (id INT, amount DECIMAL(7,2), tr_date DATE)
    ENGINE=INNODB
    PARTITION BY HASH( MONTH(tr_date) )
    PARTITIONS 6;
</pre><p>
      各 <code class="literal">PARTITION</code> 句に <code class="literal">[STORAGE] ENGINE</code> オプションを含めることはできますが、MySQL 8.0 ではこれは効果がありません。
    </p><p>
      特に指定がないかぎり、この説明の残りの例では、<code class="literal">default_storage_engine</code> が <code class="literal">InnoDB</code> であると想定しています。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        パーティショニングはテーブルのすべてのデータおよびインデックスに適用されます。データだけにパーティション化しインデックスは行わないことはできず (その逆も不可)、テーブルの一部のみをパーティション化することもできません。
      </p></div><p>
      各パーティションのデータおよびインデックスを特定のディレクトリに割り当てるには、パーティション化されたテーブルを作成するために使用する <code class="literal">CREATE TABLE</code> ステートメントの <code class="literal">PARTITION</code> 句に <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> オプションを使用します。
    </p><p>
      <code class="literal">InnoDB</code> テーブルの個々のパーティションおよびサブパーティションでは、<code class="literal">DATA DIRECTORY</code> オプションのみがサポートされます。 MySQL 8.0.21 では、<code class="literal">DATA DIRECTORY</code> 句で指定されたディレクトリは <code class="literal">InnoDB</code> で認識されている必要があります。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-create-table-external-data-directory" title="DATA DIRECTORY 句の使用">DATA DIRECTORY 句の使用</a>を参照してください。 
    </p><a class="indexterm" name="idm45807911114512"></a><a class="indexterm" name="idm45807911112368"></a><p>
      テーブルのパーティション化式で使用されるすべてのカラムは、主キーを含め、テーブルに含まれる可能性のあるすべての一意キーの一部である必要があります。 つまり、次の SQL ステートメントで作成されたこのようなテーブルはパーティション化できません: 
    </p><pre class="programlisting">CREATE TABLE tnp (
    id INT NOT NULL AUTO_INCREMENT,
    ref BIGINT NOT NULL,
    name VARCHAR(255),
    PRIMARY KEY pk (id),
    UNIQUE KEY uk (name)
);
</pre><p>
      キー <code class="literal">pk</code> と <code class="literal">uk</code> には共通のカラムがないため、パーティション化式で使用できるカラムはありません。 この状況で考えられる回避策には、<code class="literal">name</code> カラムのテーブル主キーへの追加、<code class="literal">id</code> カラムの <code class="literal">uk</code> への追加、または一意キーの完全な削除が含まれます。 詳しくは<a class="xref" href="partitioning.html#partitioning-limitations-partitioning-keys-unique-keys" title="24.6.1 パーティショニングキー、主キー、および一意キー">セクション24.6.1「パーティショニングキー、主キー、および一意キー」</a>,をご覧ください。 
    </p><p>
      また、<code class="literal">MAX_ROWS</code> および <code class="literal">MIN_ROWS</code> は、各パーティションに格納できる行のそれぞれ最大数および最小数を決定するために使用できます。 これらのオプションの詳細は、<a class="xref" href="partitioning.html#partitioning-management" title="24.3 パーティション管理">セクション24.3「パーティション管理」</a> を参照してください。 
    </p><a class="indexterm" name="idm45807911100032"></a><p>
      <code class="literal">MAX_ROWS</code> オプションは、余分なパーティションを含む「NDB Cluster」テーブルを作成する場合にも役立つため、ハッシュインデックスの記憶域を増やすことができます。 詳細は、<code class="literal">DataMemory</code> データノード構成パラメータのドキュメント、および <a class="xref" href="mysql-cluster.html#mysql-cluster-nodes-groups" title="23.1.2 NDB Cluster ノード、ノードグループ、フラグメントレプリカ、およびパーティション">セクション23.1.2「NDB Cluster ノード、ノードグループ、フラグメントレプリカ、およびパーティション」</a>を参照してください。 
    </p><a class="indexterm" name="idm45807911094656"></a><p>
      パーティショニングのいくつかの利点を次に示します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          パーティショニングを使用すると、単一ディスクまたはファイルシステムパーティションに保持できるデータより多くのデータを 1 つのテーブルに格納できます。
        </p></li><li class="listitem"><p>
          有効性を失っているデータは、多くの場合、そのデータのみが含まれているパーティションを削除することによって、パーティション化されたテーブルから簡単に削除できます。 反対に、新しいデータを追加する処理は、そのデータだけを格納するための 1 つ以上の新しいパーティションを追加することによって、非常に便利になることがあります。 
        </p></li><li class="listitem"><p>
          指定された <code class="literal">WHERE</code> 句を満たすデータを 1 つ以上のパーティションのみに格納できることによって、検索からほかのパーティションが自動的に除外され、一部のクエリーが大幅に最適化されることがあります。 パーティションはパーティション化されたテーブルが作成されたあとに変更できるため、使用頻度の高いクエリー (パーティショニングスキームが最初に設定されたときはあまり使用されていなかった) を改善するためにデータを再編成できます。 一致しないパーティション (およびそれらに含まれている行) を除外するこの機能は、よく<span class="firstterm">パーティションプルーニング</span>と呼ばれます。 詳細は、<a class="xref" href="partitioning.html#partitioning-pruning" title="24.4 パーティションプルーニング">セクション24.4「パーティションプルーニング」</a>を参照してください。 
        </p><p>
          また、MySQL では、クエリーの明示的なパーティション選択もサポートされています。 たとえば、<code class="literal">SELECT * FROM t PARTITION (p0,p1) WHERE c &lt; 5</code> は、パーティション <code class="literal">p0</code> および <code class="literal">p1</code> の <code class="literal">WHERE</code> 条件に一致する行のみを選択します。 この場合、MySQL はテーブル <code class="literal">t</code> のほかのパーティションをチェックしません。これにより、検査するパーティションが事前にわかっているときにクエリー速度が大幅に向上することがあります。 パーティション選択は、データ変更ステートメント (<code class="literal">DELETE</code>、<code class="literal">INSERT</code>、<code class="literal">REPLACE</code>、<code class="literal">UPDATE</code>、<code class="literal">LOAD DATA</code>、および <code class="literal">LOAD XML</code>) でもサポートされます。 詳細および例については、これらのステートメントの説明を参照してください。 
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="partitioning-types"></a>24.2 パーティショニングタイプ</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="partitioning.html#partitioning-range">24.2.1 RANGE パーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-list">24.2.2 LIST パーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-columns">24.2.3 COLUMNS パーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-hash">24.2.4 HASH パーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-key">24.2.5 KEY パーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-subpartitions">24.2.6 サブパーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-handling-nulls">24.2.7 MySQL パーティショニングによる NULL の扱い</a></span></dt></dl></div><a class="indexterm" name="idm45807911071568"></a><p>
      このセクションでは、MySQL 8.0 で使用できるパーティショニングのタイプについて説明します。 これらには、次に一覧したタイプが含まれます。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>RANGE パーティショニング. </b>
            このタイプのパーティショニングは、指定された範囲に含まれるカラム値に基づいて、行をパーティションに割り当てます。 <a class="xref" href="partitioning.html#partitioning-range" title="24.2.1 RANGE パーティショニング">セクション24.2.1「RANGE パーティショニング」</a>を参照してください。 このタイプを拡張した <code class="literal">RANGE COLUMNS</code> については、<a class="xref" href="partitioning.html#partitioning-columns-range" title="24.2.3.1 RANGE COLUMNS パーティショニング">セクション24.2.3.1「RANGE COLUMNS パーティショニング」</a>を参照してください。 
          </p></li><li class="listitem"><p><b>LIST パーティショニング. </b>
            <code class="literal">RANGE</code> によるパーティショニングに似ていますが、別個の値のセットのいずれかに一致するカラムに基づいて、パーティションが選択されます。 <a class="xref" href="partitioning.html#partitioning-list" title="24.2.2 LIST パーティショニング">セクション24.2.2「LIST パーティショニング」</a>を参照してください。 このタイプを拡張した <code class="literal">LIST COLUMNS</code> については、<a class="xref" href="partitioning.html#partitioning-columns-list" title="24.2.3.2 LIST COLUMNS パーティショニング">セクション24.2.3.2「LIST COLUMNS パーティショニング」</a>を参照してください。 
          </p></li><li class="listitem"><p><b>HASH パーティショニング. </b>
            このタイプのパーティショニングでは、テーブルに挿入される行内のカラム値を操作するユーザー定義式によって返される値に基づいて、パーティションが選択されます。 関数は、負ではない整数値を返す MySQL の有効な式で構成できます。 このタイプを拡張した <code class="literal">LINEAR HASH</code> も使用できます。 <a class="xref" href="partitioning.html#partitioning-hash" title="24.2.4 HASH パーティショニング">セクション24.2.4「HASH パーティショニング」</a>を参照してください。 
          </p></li><li class="listitem"><p><b>KEY パーティショニング. </b>
            このタイプのパーティショニングは、<code class="literal">HASH</code> によるパーティショニングに似ていますが、評価される 1 つ以上のカラムのみを指定し、MySQL サーバーが独自のハッシュ関数を提供します。 MySQL によって提供されるハッシュ関数ではカラムデータ型に関係なく整数結果が保証されるため、これらのカラムに整数以外の値が含まれていてもかまいません。 このタイプを拡張した <code class="literal">LINEAR KEY</code> も使用できます。 <a class="xref" href="partitioning.html#partitioning-key" title="24.2.5 KEY パーティショニング">セクション24.2.5「KEY パーティショニング」</a>を参照してください。 
          </p></li></ul></div><a class="indexterm" name="idm45807911050624"></a><a class="indexterm" name="idm45807911048480"></a><p>
      データベースパーティショニングの非常に一般的な使用方法は、日付によってデータを分けることです。 一部のデータベースシステムは、MySQL 8.0 では実装されていない、明示的な日付パーティショニングをサポートしています。 ただし、MySQL で、<code class="literal">DATE</code>、<code class="literal">TIME</code>、または <code class="literal">DATETIME</code> カラムに基づいて、またはそのようなカラムを使用する式に基づいて、パーティショニングスキームを作成することは難しくありません。 
    </p><p>
      <code class="literal">KEY</code> または <code class="literal">LINEAR KEY</code> でパーティショニングする場合は、<code class="literal">DATE</code>、<code class="literal">TIME</code>、または <code class="literal">DATETIME</code> カラムを、カラム値の変更を実行しないパーティショニングカラムとして使用できます。 たとえば、次のテーブル作成ステートメントは MySQL で完全に有効です。 
    </p><pre class="programlisting">CREATE TABLE members (
    firstname VARCHAR(25) NOT NULL,
    lastname VARCHAR(25) NOT NULL,
    username VARCHAR(16) NOT NULL,
    email VARCHAR(35),
    joined DATE NOT NULL
)
PARTITION BY KEY(joined)
PARTITIONS 6;
</pre><p>
      MySQL 8.0 では、<code class="literal">RANGE COLUMNS</code> および <code class="literal">LIST COLUMNS</code> パーティショニングを使用して、<code class="literal">DATE</code> または <code class="literal">DATETIME</code> カラムをパーティショニングカラムとして使用することもできます。
    </p><p>
      他のパーティション化タイプでは、整数値または <code class="literal">NULL</code> を生成するパーティション化式が必要です。 <code class="literal">RANGE</code>、<code class="literal">LIST</code>、<code class="literal">HASH</code>、または <code class="literal">LINEAR HASH</code> による日付ベースパーティショニングを使用する場合は、次のように単純に <code class="literal">DATE</code>、<code class="literal">TIME</code>、または <code class="literal">DATETIME</code> カラムを操作してそのような値を返す関数を使用できます。 
    </p><pre class="programlisting">CREATE TABLE members (
    firstname VARCHAR(25) NOT NULL,
    lastname VARCHAR(25) NOT NULL,
    username VARCHAR(16) NOT NULL,
    email VARCHAR(35),
    joined DATE NOT NULL
)
PARTITION BY RANGE( YEAR(joined) ) (
    PARTITION p0 VALUES LESS THAN (1960),
    PARTITION p1 VALUES LESS THAN (1970),
    PARTITION p2 VALUES LESS THAN (1980),
    PARTITION p3 VALUES LESS THAN (1990),
    PARTITION p4 VALUES LESS THAN MAXVALUE
);
</pre><p>
      日付を使用したパーティショニングの追加例は、この章の次のセクションにあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="xref" href="partitioning.html#partitioning-range" title="24.2.1 RANGE パーティショニング">セクション24.2.1「RANGE パーティショニング」</a>
        </p></li><li class="listitem"><p>
          <a class="xref" href="partitioning.html#partitioning-hash" title="24.2.4 HASH パーティショニング">セクション24.2.4「HASH パーティショニング」</a>
        </p></li><li class="listitem"><p>
          <a class="xref" href="partitioning.html#partitioning-linear-hash" title="24.2.4.1 LINEAR HASH パーティショニング">セクション24.2.4.1「LINEAR HASH パーティショニング」</a>
        </p></li></ul></div><p>
      日付ベースパーティショニングのより複雑な例については、次のセクションを参照してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="xref" href="partitioning.html#partitioning-pruning" title="24.4 パーティションプルーニング">セクション24.4「パーティションプルーニング」</a>
        </p></li><li class="listitem"><p>
          <a class="xref" href="partitioning.html#partitioning-subpartitions" title="24.2.6 サブパーティショニング">セクション24.2.6「サブパーティショニング」</a>
        </p></li></ul></div><p>
      MySQL パーティショニングは、<code class="literal">TO_DAYS()</code>、<code class="literal">YEAR()</code>、および <code class="literal">TO_SECONDS()</code> 関数で使用するために最適化されています。 ただし、整数または <code class="literal">NULL</code> を返すほかの日時関数 (<code class="literal">WEEKDAY()</code>、<code class="literal">DAYOFYEAR()</code>、<code class="literal">MONTH()</code> など) を使用できます。 そのような関数の詳細については、<a class="xref" href="functions.html#date-and-time-functions" title="12.7 日付および時間関数">セクション12.7「日付および時間関数」</a>を参照してください。 
    </p><p>
      使用するパーティショニングのタイプにかかわらず、パーティションには作成時に常に <code class="literal">0</code> から始まる番号が順番に自動的に付けられることを覚えておくことが重要です。 新しい行がパーティション化されたテーブルに挿入されるときは、これらのパーティション番号が正しいパーティションを識別するために使用されます。 たとえば、テーブルで 4 つのパーティションが使用される場合、これらのパーティションには <code class="literal">0</code>、<code class="literal">1</code>、<code class="literal">2</code>、および <code class="literal">3</code> という番号が付けられます。 <code class="literal">RANGE</code> および <code class="literal">LIST</code> パーティショニングタイプの場合は、各パーティション番号のパーティションが定義されている必要があります。 <code class="literal">HASH</code> パーティション化の場合、ユーザー指定の式は <code class="literal">0</code> より大きい整数値に評価される必要があります。 <code class="literal">KEY</code> パーティショニングの場合は、MySQL サーバーが内部で使用しているハッシュ関数によって、この問題が自動的に対処されます。 
    </p><p>
      パーティションの名前は通常、ほかの MySQL 識別子 (テーブル名、データベース名など) を制御するルールに従っています。 ただし、パーティション名では大/小文字が区別されないことに注意してください。 たとえば、次の <code class="literal">CREATE TABLE</code> ステートメントは、示されているように失敗します。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (val INT)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY LIST(val)(</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION mypart VALUES IN (1,3,5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION MyPart VALUES IN (2,4,6)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
ERROR 1488 (HY000): Duplicate partition name mypart
</pre><p>
      失敗は、MySQL がパーティション名 <code class="literal">mypart</code> と <code class="literal">MyPart</code> の違いを認識できないために発生します。
    </p><p>
      テーブルのパーティション番号を指定するときは、先行ゼロなしのゼロ以外の正の整数リテラルとして表現する必要があり、<code class="literal">0.8E+01</code> や <code class="literal">6-2</code> などの式であってはいけません (これが整数値に評価されるとしても)。 小数は許可されません。 
    </p><p>
      次の各セクションでは、各パーティションタイプの作成に使用できる構文に使用可能なすべての形式を必ずしも指定するわけではありません。この詳細は、<a class="xref" href="sql-statements.html#create-table" title="13.1.20 CREATE TABLE ステートメント">セクション13.1.20「CREATE TABLE ステートメント」</a> を参照してください。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-range"></a>24.2.1 RANGE パーティショニング</h3></div></div></div><a class="indexterm" name="idm45807910982080"></a><a class="indexterm" name="idm45807910979936"></a><p>
        範囲によってパーティション化されるテーブルは、各パーティションに含まれる行のパーティショニング式値が指定された範囲に収まるようにパーティション化されます。 範囲は、連続しているけれども重複しないものであるべきで、<code class="literal">VALUES LESS THAN</code> 演算子を使用して定義されます。 次のいくつかの例では、20 のビデオ店で構成されるチェーン (1 から 20 までの番号が付けられている) の従業員レコードを保持する、次のようなテーブルを作成していると想定してください。 
      </p><pre class="programlisting">CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT NOT NULL,
    store_id INT NOT NULL
);
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          ここで使用する <code class="literal">employees</code> テーブルには主キーまたは一意キーがありません。 これらの例はここでの説明のためのもので、実際のテーブルは主キー、一意キー、またはその両方を備えている可能性がきわめて高く、パーティショニングカラムに利用できる選択肢はこれらのキー (ある場合) に使用されるカラムに依存します。 これらの事項については、<a class="xref" href="partitioning.html#partitioning-limitations-partitioning-keys-unique-keys" title="24.6.1 パーティショニングキー、主キー、および一意キー">セクション24.6.1「パーティショニングキー、主キー、および一意キー」</a>を参照してください。 
        </p></div><p>
        このテーブルは、必要に応じていくつかの方法で、範囲によるパーティション化を実行できます。 1 つの方法は、<code class="literal">store_id</code> カラムを使用することです。 たとえば、次のように <code class="literal">PARTITION BY RANGE</code> 句を追加することで、テーブルを 4 つのパーティションに分割することを決定できます。 
      </p><pre class="programlisting">CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT NOT NULL,
    store_id INT NOT NULL
)
PARTITION BY RANGE (store_id) (
    PARTITION p0 VALUES LESS THAN (6),
    PARTITION p1 VALUES LESS THAN (11),
    PARTITION p2 VALUES LESS THAN (16),
    PARTITION p3 VALUES LESS THAN (21)
);
</pre><p>
        このパーティショニングスキームでは、店舗 1 から店舗 5 で働いている従業員に対応するすべての行がパーティション <code class="literal">p0</code> に格納され、店舗 6 から店舗 10 の従業員がパーティション <code class="literal">p1</code> に格納されます (以下同様)。 各パーティションは、最低から最高の順に定義されます。 これは <code class="literal">PARTITION BY RANGE</code> 構文の要件です。これは、C または Java の一連の <code class="literal">if ... elseif ...</code> ステートメントに似ていると考えることができます。 
      </p><p>
        <code class="literal">(72, 'Mitchell', 'Wilson', '1998-06-25', NULL, 13)</code> データを含む新しい行がパーティション <code class="literal">p2</code> に挿入されたことを簡単に判別できますが、チェーンで 21 の <sup>st</sup> ストアが追加されるとどうなりますか。 このスキームでは、<code class="literal">store_id</code> が 20 よりも大きい行に対応するルールがなく、サーバーはどこに置くべきかがわからないため、エラーになります。 これが発生しないようにするには、<span class="quote">「<span class="quote">すべての状況に対応する</span>」</span> <code class="literal">VALUES LESS THAN</code> 句を <code class="literal">CREATE TABLE</code> ステートメントで使用して、明示的に指定されている最大値を超えるすべての値に備えます。 
      </p><pre class="programlisting">CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT NOT NULL,
    store_id INT NOT NULL
)
PARTITION BY RANGE (store_id) (
    PARTITION p0 VALUES LESS THAN (6),
    PARTITION p1 VALUES LESS THAN (11),
    PARTITION p2 VALUES LESS THAN (16),
    <span class="emphasis"><em>PARTITION p3 VALUES LESS THAN MAXVALUE</em></span>
);
</pre><p>
        (この章のその他の例と同様に、デフォルトのストレージエンジンは <code class="literal">InnoDB</code> であると想定しています。)
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          一致する値が見つからないときにエラーを回避するための別の方法は、<code class="literal">INSERT</code> ステートメントの一部として <code class="literal">IGNORE</code> キーワードを使用することです。 例については、<a class="xref" href="partitioning.html#partitioning-list" title="24.2.2 LIST パーティショニング">セクション24.2.2「LIST パーティショニング」</a>を参照してください。 また、<code class="literal">IGNORE</code> の一般的な情報については、<a class="xref" href="sql-statements.html#insert" title="13.2.6 INSERT ステートメント">セクション13.2.6「INSERT ステートメント」</a>を参照してください。 
        </p></div><p>
        <code class="literal">MAXVALUE</code> は、可能な最大整数値よりも確実に大きな整数値を表します (数学用語では、<span class="firstterm">上限</span>です)。 これによって、<code class="literal">store_id</code> カラム値が 16 (定義されている最大値) 以上である行は、パーティション <code class="literal">p3</code> に格納されます。 将来のある時点で、店舗の数が 25、30、またはそれ以上に増加したときは、<code class="literal">ALTER TABLE</code> ステートメントを使用して、店舗 21-25、26-30 などのための新しいパーティションを追加できます (これを行う方法の詳細については、<a class="xref" href="partitioning.html#partitioning-management" title="24.3 パーティション管理">セクション24.3「パーティション管理」</a>を参照してください)。 
      </p><p>
        同様に、従業員ジョブコードに基づいて (つまり、<code class="literal">job_code</code> カラム値の範囲に基づいて) テーブルをパーティション化できます。 たとえば、正規 (インストア) 従業員に 2 桁のジョブコード、オフィスおよびサポート従業員に 3 桁のコード、および管理職に 4 桁のコードが使用されると想定すると、次のステートメントを使用してパーティション化されたテーブルを作成できます。 
      </p><pre class="programlisting">CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT NOT NULL,
    store_id INT NOT NULL
)
PARTITION BY RANGE (job_code) (
    PARTITION p0 VALUES LESS THAN (100),
    PARTITION p1 VALUES LESS THAN (1000),
    PARTITION p2 VALUES LESS THAN (10000)
);
</pre><p>
        この例では、インストア従業員に関連するすべての行はパーティション <code class="literal">p0</code>、オフィスおよびサポートスタッフに関連するものは <code class="literal">p1</code>、および管理職に関連するものはパーティション <code class="literal">p2</code> に格納されます。
      </p><p>
        <code class="literal">VALUES LESS THAN</code> 句に式を使用することもできます。 ただし、MySQL は、<code class="literal">LESS THAN</code> (<code class="literal">&lt;</code>) 比較の一環として式の戻り値を評価できる必要があります。 
      </p><a class="indexterm" name="idm45807910934688"></a><p>
        店舗番号に従ってテーブルデータを分割するのではなく、代わりに 2 つの <code class="literal">DATE</code> カラムのうちの 1 つに基づく式を使用できます。 たとえば、各従業員が会社を退職した年 (つまり、<code class="literal">YEAR(separated)</code> の値) に基づいてパーティション化するとします。 そのようなパーティショニングスキームを実装する <code class="literal">CREATE TABLE</code> ステートメントの例を次に示します。 
      </p><pre class="programlisting">CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY RANGE ( YEAR(separated) ) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1996),
    PARTITION p2 VALUES LESS THAN (2001),
    PARTITION p3 VALUES LESS THAN MAXVALUE
);
</pre><p>
        このスキームでは、1991 年より前に退職したすべての従業員の場合、行はパーティション <code class="literal">p0</code> に格納されます。1991 年から 1995 年までに退職した人は <code class="literal">p1</code>、1996 年から 2000 年までに退職した人は <code class="literal">p2</code>、および 2000 年よりあとに退職した従業員は <code class="literal">p3</code> に格納されます。
      </p><p>
        次の例に示すように、<code class="literal">UNIX_TIMESTAMP()</code> 関数を使用して、<code class="literal">TIMESTAMP</code> カラムの値に基づいて、<code class="literal">RANGE</code> によってテーブルをパーティション化することもできます。
      </p><pre class="programlisting">CREATE TABLE quarterly_report_status (
    report_id INT NOT NULL,
    report_status VARCHAR(20) NOT NULL,
    report_updated TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
)
PARTITION BY RANGE ( UNIX_TIMESTAMP(report_updated) ) (
    PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-01-01 00:00:00') ),
    PARTITION p1 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-04-01 00:00:00') ),
    PARTITION p2 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-07-01 00:00:00') ),
    PARTITION p3 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-10-01 00:00:00') ),
    PARTITION p4 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-01-01 00:00:00') ),
    PARTITION p5 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-04-01 00:00:00') ),
    PARTITION p6 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-07-01 00:00:00') ),
    PARTITION p7 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-10-01 00:00:00') ),
    PARTITION p8 VALUES LESS THAN ( UNIX_TIMESTAMP('2010-01-01 00:00:00') ),
    PARTITION p9 VALUES LESS THAN (MAXVALUE)
);
</pre><p>
        <code class="literal">TIMESTAMP</code> 値を含むほかの式は許可されません (Bug #42849 を参照してください)。 
      </p><p>
        次の条件の 1 つ以上が true のときは、RANGE パーティショニングが特に役立ちます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="quote">「<span class="quote">古い</span>」</span>データを削除したい、またはする必要がある。 前述の <code class="literal">employees</code> テーブルのパーティション化スキームを使用している場合は、<code class="literal">ALTER TABLE employees DROP PARTITION p0;</code>を使用して、1991 年より前に企業の勤務を停止した従業員に関連するすべての行を削除できます。 (詳細は、<a class="xref" href="sql-statements.html#alter-table" title="13.1.9 ALTER TABLE ステートメント">セクション13.1.9「ALTER TABLE ステートメント」</a>および<a class="xref" href="partitioning.html#partitioning-management" title="24.3 パーティション管理">セクション24.3「パーティション管理」</a>を参照してください)。 テーブルに多数の行がある場合、これは <code class="literal">DELETE FROM employees WHERE YEAR(separated) &lt;= 1990;</code> などの <code class="literal">DELETE</code> クエリーを実行するよりもはるかに効率的な場合があります。 
          </p></li><li class="listitem"><p>
            日付または時間値、または何らかのほかの一連値から生じる値が含まれるカラムを使用したい。
          </p></li><li class="listitem"><p>
            テーブルのパーティショニングに使用されるカラムに直接依存するクエリーを頻繁に実行する。 たとえば、<code class="literal">EXPLAIN SELECT COUNT(*) FROM employees WHERE separated BETWEEN '2000-01-01' AND '2000-12-31' GROUP BY store_id;</code>などのクエリーを実行する場合、MySQL では、<code class="literal">WHERE</code> 句を満たすレコードを残りのパーティションに含めることができないため、パーティション <code class="literal">p2</code> のみをスキャンする必要があると迅速に判断できます。 これがどのように実現されるかについての詳細は、<a class="xref" href="partitioning.html#partitioning-pruning" title="24.4 パーティションプルーニング">セクション24.4「パーティションプルーニング」</a>を参照してください。 
          </p></li></ul></div><p>
        このタイプのパーティショニングのバリアントが <code class="literal">RANGE COLUMNS</code> パーティショニングです。 <code class="literal">RANGE COLUMNS</code> によるパーティショニングでは、複数のカラムを使用してパーティショニング範囲を定義できます (パーティション内での行の配置、およびパーティションプルーニングを実行するときに特定のパーティションの包含または除外を判断する際に適用されます)。 詳細は、<a class="xref" href="partitioning.html#partitioning-columns-range" title="24.2.3.1 RANGE COLUMNS パーティショニング">セクション24.2.3.1「RANGE COLUMNS パーティショニング」</a>を参照してください。 
      </p><p><a name="partitioning-time-intervals"></a><b>時間間隔に基づくパーティショニングスキーム. </b>
          MySQL 8.0 で時間の範囲または間隔に基づいてパーティショニングスキームを実装する場合は、2 つの方法があります。
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            次のように、<code class="literal">RANGE</code> によってテーブルをパーティション化し、パーティショニング式に <code class="literal">DATE</code>、<code class="literal">TIME</code>、または <code class="literal">DATETIME</code> カラムを操作して整数値を返す関数を使用します。
          </p><pre class="programlisting">CREATE TABLE members (
    firstname VARCHAR(25) NOT NULL,
    lastname VARCHAR(25) NOT NULL,
    username VARCHAR(16) NOT NULL,
    email VARCHAR(35),
    joined DATE NOT NULL
)
PARTITION BY RANGE( YEAR(joined) ) (
    PARTITION p0 VALUES LESS THAN (1960),
    PARTITION p1 VALUES LESS THAN (1970),
    PARTITION p2 VALUES LESS THAN (1980),
    PARTITION p3 VALUES LESS THAN (1990),
    PARTITION p4 VALUES LESS THAN MAXVALUE
);
</pre><p>
            MySQL 8.0 では、次の例に示すように <code class="literal">UNIX_TIMESTAMP()</code> 関数を使用して、<code class="literal">TIMESTAMP</code> カラムの値に基づいて <code class="literal">RANGE</code> によってテーブルをパーティション化することもできます。
          </p><pre class="programlisting">CREATE TABLE quarterly_report_status (
    report_id INT NOT NULL,
    report_status VARCHAR(20) NOT NULL,
    report_updated TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
)
PARTITION BY RANGE ( UNIX_TIMESTAMP(report_updated) ) (
    PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-01-01 00:00:00') ),
    PARTITION p1 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-04-01 00:00:00') ),
    PARTITION p2 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-07-01 00:00:00') ),
    PARTITION p3 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-10-01 00:00:00') ),
    PARTITION p4 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-01-01 00:00:00') ),
    PARTITION p5 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-04-01 00:00:00') ),
    PARTITION p6 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-07-01 00:00:00') ),
    PARTITION p7 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-10-01 00:00:00') ),
    PARTITION p8 VALUES LESS THAN ( UNIX_TIMESTAMP('2010-01-01 00:00:00') ),
    PARTITION p9 VALUES LESS THAN (MAXVALUE)
);
</pre><p>
            MySQL 8.0 では、<code class="literal">TIMESTAMP</code> 値を含むほかの式は許可されません。 (Bug #42849 を参照してください)。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              MySQL 8.0 では、<code class="literal">LIST</code> によってパーティション化されるテーブルのパーティショニング式として <code class="literal">UNIX_TIMESTAMP(timestamp_column)</code> を使用することもできます。 ただし、このようにするのは通常は実用的ではありません。 
            </p></div></li><li class="listitem"><p>
            <code class="literal">DATE</code> または <code class="literal">DATETIME</code> カラムをパーティショニングカラムとして使用して、<code class="literal">RANGE COLUMNS</code> によってテーブルをパーティション化します。 たとえば、次のように <code class="literal">joined</code> カラムを直接使用して <code class="literal">members</code> テーブルを定義できます。 
          </p><pre class="programlisting">CREATE TABLE members (
    firstname VARCHAR(25) NOT NULL,
    lastname VARCHAR(25) NOT NULL,
    username VARCHAR(16) NOT NULL,
    email VARCHAR(35),
    joined DATE NOT NULL
)
PARTITION BY RANGE COLUMNS(joined) (
    PARTITION p0 VALUES LESS THAN ('1960-01-01'),
    PARTITION p1 VALUES LESS THAN ('1970-01-01'),
    PARTITION p2 VALUES LESS THAN ('1980-01-01'),
    PARTITION p3 VALUES LESS THAN ('1990-01-01'),
    PARTITION p4 VALUES LESS THAN MAXVALUE
);
</pre></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">DATE</code> または <code class="literal">DATETIME</code> 以外の日付または時間型を使用してパーティショニングカラムを使用することは、<code class="literal">RANGE COLUMNS</code> ではサポートされません。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-list"></a>24.2.2 LIST パーティショニング</h3></div></div></div><a class="indexterm" name="idm45807910867360"></a><a class="indexterm" name="idm45807910865216"></a><p>
        MySQL の LIST パーティショニングは、多くの点で RANGE パーティショニングに似ています。 <code class="literal">RANGE</code> によるパーティショニングと同様に、各パーティションを明示的に定義する必要があります。 2 つのタイプのパーティショニングの主な違いは、LIST パーティショニングでは、各パーティションが、連続する値の範囲のセットのいずれかではなく、値リストのセットのいずれかに含まれるカラム値のメンバーシップに基づいて定義および選択されることです。 これを行うには、<code class="literal">PARTITION BY LIST (<em class="replaceable"><code>expr</code></em>)</code> を使用します。ここで、<em class="replaceable"><code>expr</code></em> はカラム値またはカラム値に基づく式で、整数値を返し、<code class="literal">VALUES IN (<em class="replaceable"><code>value_list</code></em>)</code> で各パーティションを定義します。ここで、<em class="replaceable"><code>value_list</code></em> はカンマで区切られた整数のリストです。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL 8.0 では、<code class="literal">LIST</code> によってパーティション化するときに、整数 (および <code class="literal">NULL</code> も可。<a class="xref" href="partitioning.html#partitioning-handling-nulls" title="24.2.7 MySQL パーティショニングによる NULL の扱い">セクション24.2.7「MySQL パーティショニングによる NULL の扱い」</a>を参照してください) のリストに対してのみ照合できます。
        </p><p>
          ただし、<code class="literal">LIST COLUMN</code> パーティショニングを使用するときは、ほかのカラムタイプを値リストで使用できます (これについては、このセクションで後述します)。
        </p></div><p>
        範囲で定義されるパーティションの場合と異なり、リストパーティションは特定の順序で宣言する必要はありません。 構文についての詳細は、<a class="xref" href="sql-statements.html#create-table" title="13.1.20 CREATE TABLE ステートメント">セクション13.1.20「CREATE TABLE ステートメント」</a>を参照してください。 
      </p><p>
        以降の例では、パーティション化するテーブルの基本定義が、次に示す <code class="literal">CREATE TABLE</code> ステートメントによって提供されることを想定します。
      </p><pre class="programlisting">CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
);
</pre><p>
        (これは、<a class="xref" href="partitioning.html#partitioning-range" title="24.2.1 RANGE パーティショニング">セクション24.2.1「RANGE パーティショニング」</a> の例の基礎として使用されるテーブルと同じです。 他のパーティション化の例と同様に、<code class="literal">default_storage_engine</code> は <code class="literal">InnoDB</code> であると想定しています。) 
      </p><p>
        次の表に示すように、20 のビデオ店があり、それらが 4 つのフランチャイズに分類されていると想定します。
      </p><div class="informaltable"><table summary="An example of 20 video stores distributed among 4 regional franchises, as described in the preceding text."><col style="width: 30%"><col style="width: 70%"><thead><tr>
            <th>地域</th>
            <th>店舗 ID 番号</th>
          </tr></thead><tbody><tr>
            <td>北</td>
            <td>3、5、6、9、17</td>
          </tr><tr>
            <td>東</td>
            <td>1、2、10、11、19、20</td>
          </tr><tr>
            <td>西</td>
            <td>4、12、13、14、18</td>
          </tr><tr>
            <td>中央</td>
            <td>7、8、15、16</td>
          </tr></tbody></table></div><p>
        同じ地域に属する店舗の行が同じパーティションに格納されるようにこのテーブルをパーティション化するには、次のような <code class="literal">CREATE TABLE</code> ステートメントを使用できます。
      </p><pre class="programlisting">CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY LIST(store_id) (
    PARTITION pNorth VALUES IN (3,5,6,9,17),
    PARTITION pEast VALUES IN (1,2,10,11,19,20),
    PARTITION pWest VALUES IN (4,12,13,14,18),
    PARTITION pCentral VALUES IN (7,8,15,16)
);
</pre><p>
        これにより、特定の地域に関連する従業員レコードをテーブルで簡単に追加または削除できるようになります。 たとえば、西地域の全店舗が別の会社に売却されたとします。 MySQL 8.0 では、その地域の店舗で働いていた従業員に関連するすべての行をクエリー <code class="literal">ALTER TABLE employees TRUNCATE PARTITION pWest</code> を使用して削除できます。これは、同等の <code class="literal">DELETE</code> ステートメント <code class="literal">DELETE FROM employees WHERE store_id IN (4,12,13,14,18);</code> よりもはるかに効率的に実行できます (<code class="literal">ALTER TABLE employees DROP PARTITION pWest</code> を使用してもこれらのすべての行が削除されますが、テーブルの定義からパーティション <code class="literal">pWest</code> も削除されるため、<code class="literal">ALTER TABLE ... ADD PARTITION</code> ステートメントを使用してテーブルの元のパーティショニングスキームをリストアする必要があります)。 
      </p><p>
        <code class="literal">RANGE</code> パーティショニングと同様に、<code class="literal">LIST</code> パーティショニングとハッシュまたはキーによるパーティショニングを組み合わせることによって、複合パーティショニング (サブパーティショニング) を生成できます。 <a class="xref" href="partitioning.html#partitioning-subpartitions" title="24.2.6 サブパーティショニング">セクション24.2.6「サブパーティショニング」</a>を参照してください。 
      </p><p>
        <code class="literal">RANGE</code> パーティショニングの場合と異なり、<code class="literal">MAXVALUE</code> などの<span class="quote">「<span class="quote">すべての状況に対応する</span>」</span>ものはありません。パーティショニング式で予期されるすべての値を <code class="literal">PARTITION ... VALUES IN (...)</code> 句で指定してください。 一致しないパーティショニングカラム値が含まれている <code class="literal">INSERT</code> ステートメントは、次の例に示すように、エラーで失敗します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE h2 (</code></strong>
    -&gt;   <strong class="userinput"><code>c1 INT,</code></strong>
    -&gt;   <strong class="userinput"><code>c2 INT</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY LIST(c1) (</code></strong>
    -&gt;   <strong class="userinput"><code>PARTITION p0 VALUES IN (1, 4, 7),</code></strong>
    -&gt;   <strong class="userinput"><code>PARTITION p1 VALUES IN (2, 5, 8)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.11 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO h2 VALUES (3, 5);</code></strong>
<span class="errortext">ERROR 1525 (HY000): Table has no partition for value 3</span>
</pre><p>
        単一の <code class="literal">INSERT</code> ステートメントを使用して複数の行を単一の <code class="literal">InnoDB</code> テーブルに挿入する場合、<code class="literal">InnoDB</code> はそのステートメントを単一のトランザクションとみなし、一致しない値があるとステートメントが完全に失敗するため、行は挿入されません。
      </p><p>
        このタイプのエラーは、<code class="literal">IGNORE</code> キーワードを使用することで無視させることができます。 そうした場合、一致しないパーティショニングカラム値が含まれる行は挿入されませんが、一致する値を持つ行は挿入<span class="emphasis"><em>され</em></span>てエラーが報告されません。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>TRUNCATE h2;</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM h2;</code></strong>
Empty set (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT IGNORE INTO h2 VALUES (2, 5), (6, 10), (7, 5), (3, 1), (1, 9);</code></strong>
Query OK, 3 rows affected (0.00 sec)
Records: 5  Duplicates: 2  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM h2;</code></strong>
+------+------+
| c1   | c2   |
+------+------+
|    7 |    5 |
|    1 |    9 |
|    2 |    5 |
+------+------+
3 rows in set (0.00 sec)
</pre><p>
        MySQL 8.0 では、<code class="literal">LIST COLUMNS</code> パーティション化もサポートされています。これは、カラムのパーティション化に整数型以外の型のカラムを使用したり、複数のカラムをパーティション化キーとして使用できる <code class="literal">LIST</code> パーティション化のバリアントです。 詳細は、<a class="xref" href="partitioning.html#partitioning-columns-list" title="24.2.3.2 LIST COLUMNS パーティショニング">セクション24.2.3.2「LIST COLUMNS パーティショニング」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-columns"></a>24.2.3 COLUMNS パーティショニング</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="partitioning.html#partitioning-columns-range">24.2.3.1 RANGE COLUMNS パーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-columns-list">24.2.3.2 LIST COLUMNS パーティショニング</a></span></dt></dl></div><a class="indexterm" name="idm45807910791536"></a><a class="indexterm" name="idm45807910789504"></a><a class="indexterm" name="idm45807910787984"></a><a class="indexterm" name="idm45807910786720"></a><a class="indexterm" name="idm45807910785344"></a><a class="indexterm" name="idm45807910783824"></a><p>
        次の 2 つのセクションでは、<code class="literal">RANGE</code> および <code class="literal">LIST</code> パーティショニングのバリアントである <span class="firstterm"><code class="literal">COLUMNS</code> パーティショニング</span>について説明します。 <code class="literal">COLUMNS</code> パーティショニングでは、パーティショニングキーに複数のカラムを使用できます。 これらのすべてのカラムが、パーティションに行を配置するため、およびパーティションプルーニングでどのパーティションで一致する行をチェックするかを判断するという両方の目的のために考慮されます。 
      </p><p>
        また、<code class="literal">RANGE COLUMNS</code> パーティショニングおよび <code class="literal">LIST COLUMNS</code> パーティショニングの両方が、値範囲またはリストメンバーの定義のために整数以外のカラムの使用をサポートします。 許可されるデータ型を次のリストに示します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            すべての整数型: <code class="literal">TINYINT</code>、<code class="literal">SMALLINT</code>、<code class="literal">MEDIUMINT</code>、<code class="literal">INT</code> (<code class="literal">INTEGER</code>)、および <code class="literal">BIGINT</code> (これは、<code class="literal">RANGE</code> および <code class="literal">LIST</code> によるパーティショニングと同じです)。 
          </p><p>
            ほかの数値データ型 (<code class="literal">DECIMAL</code>、<code class="literal">FLOAT</code> など) はパーティショニングカラムとしてサポートされません。
          </p></li><li class="listitem"><p>
            <code class="literal">DATE</code> および <code class="literal">DATETIME</code>。
          </p><p>
            日付または時間に関連するほかのデータ型を使用するカラムは、パーティショニングカラムとしてサポートされません。
          </p></li><li class="listitem"><p>
            次の文字列型: <code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、<code class="literal">BINARY</code>、および <code class="literal">VARBINARY</code>。
          </p><p>
            <code class="literal">TEXT</code> カラムおよび <code class="literal">BLOB</code> カラムはパーティショニングカラムとしてサポートされません。
          </p></li></ul></div><p>
        次の 2 つのセクションでの <code class="literal">RANGE COLUMNS</code> および <code class="literal">LIST COLUMNS</code> パーティショニングの説明では、MySQL 5.1 以降でサポートされる範囲およびリストに基づくパーティショニングをすでに理解していることを想定しています。これらについての詳細は、<a class="xref" href="partitioning.html#partitioning-range" title="24.2.1 RANGE パーティショニング">セクション24.2.1「RANGE パーティショニング」</a>および<a class="xref" href="partitioning.html#partitioning-list" title="24.2.2 LIST パーティショニング">セクション24.2.2「LIST パーティショニング」</a>をそれぞれ参照してください。
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="partitioning-columns-range"></a>24.2.3.1 RANGE COLUMNS パーティショニング</h4></div></div></div><p>
          RANGE COLUMNS パーティショニングは RANGE パーティショニングに似ていますが、複数のカラム値に基づく範囲を使用してパーティションを定義できます。 また、整数型以外の型のカラムを使用して範囲を定義できます。 
        </p><p>
          <code class="literal">RANGE COLUMNS</code> パーティショニングは、次の点で <code class="literal">RANGE</code> パーティショニングと大きく異なります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">RANGE COLUMNS</code> は式を受け入れません (カラムの名前のみ)。
            </p></li><li class="listitem"><p>
              <code class="literal">RANGE COLUMNS</code> は 1 つ以上のカラムのリストを受け入れます。
            </p><p>
              <code class="literal">RANGE COLUMNS</code> パーティションは、スカラー値の比較ではなく、<span class="firstterm">タプル</span> (カラム値のリスト) の比較に基づきます。 <code class="literal">RANGE COLUMNS</code> パーティションでの行の配置も、タプルの比較に基づきます。これについては、このセクションで後述します。 
            </p></li><li class="listitem"><p>
              <code class="literal">RANGE COLUMNS</code> パーティショニングカラムは整数カラムに制限されません。文字列、<code class="literal">DATE</code>、および <code class="literal">DATETIME</code> カラムもパーティショニングカラムとして使用できます。 (詳細は、<a class="xref" href="partitioning.html#partitioning-columns" title="24.2.3 COLUMNS パーティショニング">セクション24.2.3「COLUMNS パーティショニング」</a>を参照してください。) 
            </p></li></ul></div><p>
          <code class="literal">RANGE COLUMNS</code> によってパーティション化されたテーブルを作成するための基本構文を次に示します。
        </p><pre class="programlisting">CREATE TABLE <em class="replaceable"><code>table_name</code></em>
PARTITIONED BY RANGE COLUMNS(<em class="replaceable"><code>column_list</code></em>) (
    PARTITION <em class="replaceable"><code>partition_name</code></em> VALUES LESS THAN (<em class="replaceable"><code>value_list</code></em>)[,
    PARTITION <em class="replaceable"><code>partition_name</code></em> VALUES LESS THAN (<em class="replaceable"><code>value_list</code></em>)][,
    ...]
)

<em class="replaceable"><code>column_list</code></em>:
    <em class="replaceable"><code>column_name</code></em>[, <em class="replaceable"><code>column_name</code></em>][, ...]

<em class="replaceable"><code>value_list</code></em>:
    <em class="replaceable"><code>value</code></em>[, <em class="replaceable"><code>value</code></em>][, ...]
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            パーティション化されたテーブルを作成するときに使用できる <code class="literal">CREATE TABLE</code> オプションをすべて示しているわけではありません。 詳細は、<a class="xref" href="sql-statements.html#create-table" title="13.1.20 CREATE TABLE ステートメント">セクション13.1.20「CREATE TABLE ステートメント」</a>を参照してください。 
          </p></div><p>
          前述の構文で、<em class="replaceable"><code>column_list</code></em> は 1 つ以上のカラムのリスト (<span class="firstterm">パーティショニングカラムリスト</span>と呼ばれることもあります)、<em class="replaceable"><code>value_list</code></em> は値のリスト (つまり、<span class="firstterm">パーティション定義値リスト</span>です) です。 <em class="replaceable"><code>value_list</code></em> は各パーティション定義に指定する必要があり、各 <em class="replaceable"><code>value_list</code></em> には <em class="replaceable"><code>column_list</code></em> のカラムと同じ数の値が必要です。 一般的に、<code class="literal">COLUMNS</code> 句に <em class="replaceable"><code>N</code></em> 個のカラムを使用する場合は、各 <code class="literal">VALUES LESS THAN</code> 句にも <em class="replaceable"><code>N</code></em> 個の値のリストを指定する必要があります。 
        </p><p>
          パーティショニングカラムリストおよび各パーティションを定義する値リスト内の要素は、同じ順序で指定する必要があります。 また、値リスト内の各要素は、カラムリスト内の対応する要素と同じデータ型である必要があります。 ただし、パーティショニングカラムリストおよび値リスト内のカラム名の順序は、<code class="literal">CREATE TABLE</code> ステートメントの主要部内のテーブルカラム定義の順序と同じである必要はありません。 <code class="literal">RANGE</code> によってパーティション化されるテーブルと同様に、<code class="literal">MAXVALUE</code> を使用して、指定されたカラムに挿入される正当な値より確実に大きな値を表すことができます。 これらの点をすべて説明するために役立つ <code class="literal">CREATE TABLE</code> ステートメントの例を次に示します。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE rcx (</code></strong>
    -&gt;     <strong class="userinput"><code>a INT,</code></strong>
    -&gt;     <strong class="userinput"><code>b INT,</code></strong>
    -&gt;     <strong class="userinput"><code>c CHAR(3),</code></strong>
    -&gt;     <strong class="userinput"><code>d INT</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY RANGE COLUMNS(a,d,c) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (5,10,'ggg'),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (10,20,'mmm'),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (15,30,'sss'),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.15 sec)
</pre><p>
          テーブル <code class="literal">rcx</code> にはカラム <code class="literal">a</code>、<code class="literal">b</code>、<code class="literal">c</code>、および <code class="literal">d</code> が含まれています。 <code class="literal">COLUMNS</code> 句に指定されたパーティショニングカラムリストには、これらのカラムのうちの 3 つが <code class="literal">a</code>、<code class="literal">d</code>、および <code class="literal">c</code> の順に使用されています。 パーティションを定義するために使用される各値リストには、同じ順序で 3 つの値が含まれます。つまり、各値リストタプルの形式は、カラム <code class="literal">a</code>、<code class="literal">d</code>、および <code class="literal">c</code> が (この順序で) 使用するデータ型に対応する、(<code class="literal">INT</code>, <code class="literal">INT</code>, <code class="literal">CHAR(3)</code>) です。 
        </p><p>
          パーティションに行がどのように配置されるかは、挿入される行のタプル (<code class="literal">COLUMNS</code> 句内のカラムリストに一致) と<code class="literal">VALUES LESS THAN</code> 句に使用されるタプル (テーブルのパーティションを定義) を比較することによって判断されます。 スカラー値ではなくタプル (つまり、値のリストまたはセット) を比較するため、<code class="literal">RANGE COLUMNS</code> パーティションで使用される <code class="literal">VALUES LESS THAN</code> のセマンティクスは、単純な <code class="literal">RANGE</code> パーティションの場合とは若干異なります。 <code class="literal">RANGE</code> パーティショニングでは、<code class="literal">VALUES LESS THAN</code> 内の制限値と等しい式値を生成する行は、対応するパーティションに配置されません。ただし、<code class="literal">RANGE COLUMNS</code> パーティショニングを使用するときは、パーティショニングカラムリストの最初の要素が <code class="literal">VALUES LESS THAN</code> 値リスト内の最初の要素と値が等しい行が、対応するパーティションに配置されることがあります。 
        </p><p>
          次のステートメントによって作成されるパーティション化された <code class="literal">RANGE</code> テーブルを検討します。
        </p><pre class="programlisting">CREATE TABLE r1 (
    a INT,
    b INT
)
PARTITION BY RANGE (a)  (
    PARTITION p0 VALUES LESS THAN (5),
    PARTITION p1 VALUES LESS THAN (MAXVALUE)
);
</pre><p>
          各行の <code class="literal">a</code> のカラム値が <code class="literal">5</code> である 3 つの行をこのテーブルに挿入する場合、各行の <code class="literal">a</code> カラム値が 5 以上であるため、3 行がすべてパーティション <code class="literal">p1</code> に格納されます。これは、<code class="literal">INFORMATION_SCHEMA.PARTITIONS</code> テーブルに対して適切なクエリーを実行することによって確認できます。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO r1 VALUES (5,10), (5,11), (5,12);</code></strong>
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME,TABLE_ROWS</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'r1';</code></strong>
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          0 |
| p1             |          3 |
+----------------+------------+
2 rows in set (0.00 sec)
</pre><p>
          ここで、次のように作成される、カラム <code class="literal">a</code> および <code class="literal">b</code> の両方が <code class="literal">COLUMNS</code> 句で参照される、<code class="literal">RANGE COLUMNS</code> パーティショニングを使用する同様のテーブル <code class="literal">rc1</code> を検討します。
        </p><pre class="programlisting">CREATE TABLE rc1 (
    a INT,
    b INT
)
PARTITION BY RANGE COLUMNS(a, b) (
    PARTITION p0 VALUES LESS THAN (5, 12),
    PARTITION p3 VALUES LESS THAN (MAXVALUE, MAXVALUE)
);
</pre><p>
          <code class="literal">r1</code> に挿入したのとまったく同じ行を <code class="literal">rc1</code> に挿入した場合、行の配分はかなり異なります。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO rc1 VALUES (5,10), (5,11), (5,12);</code></strong>
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME,TABLE_ROWS</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'rc1';</code></strong>
+--------------+----------------+------------+
| TABLE_SCHEMA | PARTITION_NAME | TABLE_ROWS |
+--------------+----------------+------------+
| p            | p0             |          2 |
| p            | p1             |          1 |
+--------------+----------------+------------+
2 rows in set (0.00 sec)
</pre><p>
          これは、スカラー値ではなく行を比較しているためです。 挿入された行値と、テーブル <code class="literal">rc1</code> のパーティション <code class="literal">p0</code> を定義するために使用された <code class="literal">VALUES THAN LESS THAN</code> 句の行制限値とを次のように比較できます。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT (5,10) &lt; (5,12), (5,11) &lt; (5,12), (5,12) &lt; (5,12);</code></strong>
+-----------------+-----------------+-----------------+
| (5,10) &lt; (5,12) | (5,11) &lt; (5,12) | (5,12) &lt; (5,12) |
+-----------------+-----------------+-----------------+
|               1 |               1 |               0 |
+-----------------+-----------------+-----------------+
1 row in set (0.00 sec)
</pre><p>
          2 つのタプル <code class="literal">(5,10)</code> および <code class="literal">(5,11)</code> は <code class="literal">(5,12)</code> より小さいと評価されるため、パーティション <code class="literal">p0</code> に格納されています。 5 は 5 以上、12 は 12 以上であるため、<code class="literal">(5,12)</code> は <code class="literal">(5,12)</code> 以上と見なされ、パーティション <code class="literal">p1</code> に格納されています。 
        </p><p>
          前の例の <code class="literal">SELECT</code> ステートメントは、次のように明示的な行コンストラクタを使用して記述することもできました。
        </p><pre class="programlisting">SELECT ROW(5,10) &lt; ROW(5,12), ROW(5,11) &lt; ROW(5,12), ROW(5,12) &lt; ROW(5,12);
</pre><p>
          MySQL で行コンストラクタを使用する方法についての詳細は、<a class="xref" href="sql-statements.html#row-subqueries" title="13.2.11.5 行サブクエリー">セクション13.2.11.5「行サブクエリー」</a>を参照してください。
        </p><p>
          単一パーティショニングカラムのみを使用して <code class="literal">RANGE COLUMNS</code> によってパーティション化されたテーブルの場合、パーティションへの行の格納は <code class="literal">RANGE</code> によってパーティション化された同等のテーブルの場合と同じです。 次の <code class="literal">CREATE TABLE</code> ステートメントでは、1 つのパーティショニングカラムを使用して <code class="literal">RANGE COLUMNS</code> によってパーティション化されるテーブルが作成されます。 
        </p><pre class="programlisting">CREATE TABLE rx (
    a INT,
    b INT
)
PARTITION BY RANGE COLUMNS (a)  (
    PARTITION p0 VALUES LESS THAN (5),
    PARTITION p1 VALUES LESS THAN (MAXVALUE)
);
</pre><p>
          このテーブルに行 <code class="literal">(5,10)</code>、<code class="literal">(5,11)</code>、および <code class="literal">(5,12)</code> を挿入する場合、それらの配置は、前に作成して移入したテーブル <code class="literal">r</code> の場合と同じです。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO rx VALUES (5,10), (5,11), (5,12);</code></strong>
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME,TABLE_ROWS</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'rx';</code></strong>
+--------------+----------------+------------+
| TABLE_SCHEMA | PARTITION_NAME | TABLE_ROWS |
+--------------+----------------+------------+
| p            | p0             |          0 |
| p            | p1             |          3 |
+--------------+----------------+------------+
2 rows in set (0.00 sec)
</pre><p>
          1 つ以上のカラムの制限値が連続するパーティション定義で繰り返される、<code class="literal">RANGE COLUMNS</code> によってパーティション化されるテーブルを作成することもできます。 これを行うには、パーティションを定義するために使用されるカラム値のタプルが厳密にしだいに増加する必要があります。 たとえば、次の各 <code class="literal">CREATE TABLE</code> ステートメントは有効です。 
        </p><pre class="programlisting">CREATE TABLE rc2 (
    a INT,
    b INT
)
PARTITION BY RANGE COLUMNS(a,b) (
    PARTITION p0 VALUES LESS THAN (0,10),
    PARTITION p1 VALUES LESS THAN (10,20),
    PARTITION p2 VALUES LESS THAN (10,30),
    PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE)
 );

CREATE TABLE rc3 (
    a INT,
    b INT
)
PARTITION BY RANGE COLUMNS(a,b) (
    PARTITION p0 VALUES LESS THAN (0,10),
    PARTITION p1 VALUES LESS THAN (10,20),
    PARTITION p2 VALUES LESS THAN (10,30),
    PARTITION p3 VALUES LESS THAN (10,35),
    PARTITION p4 VALUES LESS THAN (20,40),
    PARTITION p5 VALUES LESS THAN (MAXVALUE,MAXVALUE)
 );
</pre><p>
          次のステートメントも成功しますが、カラム <code class="literal">b</code> の制限値がパーティション <code class="literal">p0</code> で 25 およびパーティション <code class="literal">p1</code> で 20、カラム <code class="literal">c</code> の制限値がパーティション <code class="literal">p1</code> で 100 およびパーティション <code class="literal">p2</code> で 50 であるため、一見したところではそうでないように見えるかもしれません。
        </p><pre class="programlisting">CREATE TABLE rc4 (
    a INT,
    b INT,
    c INT
)
PARTITION BY RANGE COLUMNS(a,b,c) (
    PARTITION p0 VALUES LESS THAN (0,25,50),
    PARTITION p1 VALUES LESS THAN (10,20,100),
    PARTITION p2 VALUES LESS THAN (10,30,50)
    PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)
 );
</pre><p>
          <code class="literal">RANGE COLUMNS</code> によってパーティション化されるテーブルを設計するときは、次のように <span class="command"><strong>mysql</strong></span> クライアントを使用して目的のタプルを比較することで、いつでも連続するパーティション定義をテストできます。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT (0,25,50) &lt; (10,20,100), (10,20,100) &lt; (10,30,50);</code></strong>
+-------------------------+--------------------------+
| (0,25,50) &lt; (10,20,100) | (10,20,100) &lt; (10,30,50) |
+-------------------------+--------------------------+
|                       1 |                        1 |
+-------------------------+--------------------------+
1 row in set (0.00 sec)
</pre><p>
          <code class="literal">CREATE TABLE</code> ステートメントに含まれるパーティション定義が、厳密にしだいに増加しない順序である場合は、次の例に示すようにエラーで失敗します。
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE rcf (</code></strong>
    -&gt;     <strong class="userinput"><code>a INT,</code></strong>
    -&gt;     <strong class="userinput"><code>b INT,</code></strong>
    -&gt;     <strong class="userinput"><code>c INT</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY RANGE COLUMNS(a,b,c) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (0,25,50),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (20,20,100),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (10,30,50),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)</code></strong>
    -&gt;  <strong class="userinput"><code>);</code></strong>
<span class="errortext">ERROR 1493 (HY000): VALUES LESS THAN value must be strictly increasing for each partition</span>
</pre><p>
          そのようなエラーが発生するときは、それらのカラムリストの<span class="quote">「<span class="quote">小なり</span>」</span>比較を作成することで、無効なパーティション定義を推定できます。 この場合、問題はパーティション <code class="literal">p2</code> の定義にあります。次に示すように、それを定義するために使用されるタプルが、パーティション <code class="literal">p3</code> を定義するために使用されるタプル以上であるためです。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT (0,25,50) &lt; (20,20,100), (20,20,100) &lt; (10,30,50);</code></strong>
+-------------------------+--------------------------+
| (0,25,50) &lt; (20,20,100) | (20,20,100) &lt; (10,30,50) |
+-------------------------+--------------------------+
|                       1 |                        0 |
+-------------------------+--------------------------+
1 row in set (0.00 sec)
</pre><p>
          <code class="literal">RANGE COLUMNS</code> を使用するときは、複数の <code class="literal">VALUES LESS THAN</code> 句内の同じカラムに <code class="literal">MAXVALUE</code> を指定することもできます。 ただし、それ以外の場合は、連続するパーティション定義内の個々のカラムの制限値はしだいに増加するべきであり、<code class="literal">MAXVALUE</code> をすべてのカラム値の上限として使用するパーティションは 1 つだけ定義するべきであり、このパーティション定義は <code class="literal">PARTITION ... VALUES LESS THAN</code> 句のリストの最後に指定するべきです。 また、複数のパーティション定義の最初のカラムの制限値として <code class="literal">MAXVALUE</code> を使用することはできません。 
        </p><p>
          前述したように、<code class="literal">RANGE COLUMNS</code> パーティショニングでは、整数以外のカラムをパーティショニングカラムとして使用することもできます (これらの完全な一覧については、<a class="xref" href="partitioning.html#partitioning-columns" title="24.2.3 COLUMNS パーティショニング">セクション24.2.3「COLUMNS パーティショニング」</a>を参照してください)。 次のステートメントを使用して作成された <code class="literal">employees</code> という名前のテーブル (パーティション化されていません) を検討します。 
        </p><pre class="programlisting">CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT NOT NULL,
    store_id INT NOT NULL
);
</pre><p>
          <code class="literal">RANGE COLUMNS</code> パーティショニングを使用して、次のように従業員の姓に基づいて各行を 4 つのパーティションのいずれかに格納する、このテーブルのバージョンを作成できます。
        </p><pre class="programlisting">CREATE TABLE employees_by_lname (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT NOT NULL,
    store_id INT NOT NULL
)
PARTITION BY RANGE COLUMNS (lname)  (
    PARTITION p0 VALUES LESS THAN ('g'),
    PARTITION p1 VALUES LESS THAN ('m'),
    PARTITION p2 VALUES LESS THAN ('t'),
    PARTITION p3 VALUES LESS THAN (MAXVALUE)
);
</pre><p>
          または、次の <code class="literal">ALTER TABLE</code> ステートメントを実行することで、前に作成した <code class="literal">employees</code> テーブルをこのスキームを使用してパーティション化できます。
        </p><pre class="programlisting">ALTER TABLE employees PARTITION BY RANGE COLUMNS (lname)  (
    PARTITION p0 VALUES LESS THAN ('g'),
    PARTITION p1 VALUES LESS THAN ('m'),
    PARTITION p2 VALUES LESS THAN ('t'),
    PARTITION p3 VALUES LESS THAN (MAXVALUE)
);
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            文字セットおよび照合順序が異なるとソート順序が異なるため、文字列カラムをパーティショニングカラムとして使用するときに、使用している文字セットおよび照合順序が、指定された行が <code class="literal">RANGE COLUMNS</code> によってパーティション化されるテーブルのどのパーティションに格納されるかに影響することがあります。 また、そのようなテーブルが作成されたあとに指定されたデータベース、テーブル、またはカラムの文字セットまたは照合順序を変更すると、行がどのように配分されるかが変わることがあります。 たとえば、大/小文字を区別する照合を使用する場合、<code class="literal">'and'</code>は<code class="literal">'Andersen'</code>の前にソートしますが、大/小文字を区別しない照合を使用する場合、その逆が当てはまります。 
          </p><p>
            MySQL が文字セットおよび照合順序をどのように扱うかについては、<a class="xref" href="charset.html" title="第 10 章 文字セット、照合順序、Unicode">第10章「<i>文字セット、照合順序、Unicode</i>」</a>を参照してください。
          </p></div><p>
          同様に、<code class="literal">employees</code> テーブルを、各行がいくつかの 10 年間 (その間に対応する従業員が雇用された) ベースのパーティションのいずれかに格納されるように、次のような <code class="literal">ALTER TABLE</code> ステートメントを使用してパーティション化できます。
        </p><pre class="programlisting">ALTER TABLE employees PARTITION BY RANGE COLUMNS (hired)  (
    PARTITION p0 VALUES LESS THAN ('1970-01-01'),
    PARTITION p1 VALUES LESS THAN ('1980-01-01'),
    PARTITION p2 VALUES LESS THAN ('1990-01-01'),
    PARTITION p3 VALUES LESS THAN ('2000-01-01'),
    PARTITION p4 VALUES LESS THAN ('2010-01-01'),
    PARTITION p5 VALUES LESS THAN (MAXVALUE)
);
</pre><p>
          <code class="literal">PARTITION BY RANGE COLUMNS</code> 構文の詳細については、<a class="xref" href="sql-statements.html#create-table" title="13.1.20 CREATE TABLE ステートメント">セクション13.1.20「CREATE TABLE ステートメント」</a>を参照してください。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="partitioning-columns-list"></a>24.2.3.2 LIST COLUMNS パーティショニング</h4></div></div></div><p>
          MySQL 8.0 は <code class="literal">LIST COLUMNS</code> パーティショニングのサポートを提供します。 これは <code class="literal">LIST</code> パーティショニングのバリアントで、複数のカラムをパーティションキーとして使用でき、整数型以外のデータ型のカラムをパーティショニングカラムとして使用できます。文字列型、<code class="literal">DATE</code>、および <code class="literal">DATETIME</code> カラムを使用できます (<code class="literal">COLUMNS</code> パーティショニングカラムに許可されるデータ型の詳細については、<a class="xref" href="partitioning.html#partitioning-columns" title="24.2.3 COLUMNS パーティショニング">セクション24.2.3「COLUMNS パーティショニング」</a>を参照してください)。 
        </p><p>
          ある会社の顧客が 12 の都市に存在し、販売およびマーケティングのために、それらを次の表に示すように 3 つの都市で構成される 4 つの地域に分類すると想定します。
        </p><div class="informaltable"><table summary="The example described in the preceding text of a business with four sales and marketing regions, with each region having three cities."><col style="width: 50%"><col style="width: 50%"><thead><tr>
              <th>地域</th>
              <th>都市</th>
            </tr></thead><tbody><tr>
              <td>1</td>
              <td>Oskarshamn、Högsby、Mönsterås</td>
            </tr><tr>
              <td>2</td>
              <td>Vimmerby、Hultsfred、Västervik</td>
            </tr><tr>
              <td>3</td>
              <td>Nässjö、Eksjö、Vetlanda</td>
            </tr><tr>
              <td>4</td>
              <td>Uppvidinge、Alvesta、Växjo</td>
            </tr></tbody></table></div><p>
          <code class="literal">LIST COLUMNS</code> パーティショニングでは、ここで示すように、顧客が所在する都市の名前に基づいてこれらの地域に対応する 4 つのパーティションのいずれかに行を割り当てる、顧客データのテーブルを作成できます。
        </p><pre class="programlisting">CREATE TABLE customers_1 (
    first_name VARCHAR(25),
    last_name VARCHAR(25),
    street_1 VARCHAR(30),
    street_2 VARCHAR(30),
    city VARCHAR(15),
    renewal DATE
)
PARTITION BY LIST COLUMNS(city) (
    PARTITION pRegion_1 VALUES IN('Oskarshamn', 'Högsby', 'Mönsterås'),
    PARTITION pRegion_2 VALUES IN('Vimmerby', 'Hultsfred', 'Västervik'),
    PARTITION pRegion_3 VALUES IN('Nässjö', 'Eksjö', 'Vetlanda'),
    PARTITION pRegion_4 VALUES IN('Uppvidinge', 'Alvesta', 'Växjo')
);
</pre><p>
          <code class="literal">RANGE COLUMNS</code> によるパーティショニングのように、<code class="literal">COLUMNS()</code> 句で式を使用してカラム値を整数に変換する必要はありません (実際、カラム名ではなく式を使用することは <code class="literal">COLUMNS()</code> では許可されません)。 
        </p><p>
          <code class="literal">DATE</code> および <code class="literal">DATETIME</code> カラムを使用することもでき、次の例では、前に示した <code class="literal">customers_1</code> テーブルと同じ名前およびカラムを使用していますが、<code class="literal">renewal</code> カラムに基づく <code class="literal">LIST COLUMNS</code> パーティショニングを使用して、顧客のアカウントの更新がスケジュールされている 2010 年 2 月の週に応じて、4 つのパーティションのいずれかに行が格納されることを示しています。
        </p><pre class="programlisting">CREATE TABLE customers_2 (
    first_name VARCHAR(25),
    last_name VARCHAR(25),
    street_1 VARCHAR(30),
    street_2 VARCHAR(30),
    city VARCHAR(15),
    renewal DATE
)
PARTITION BY LIST COLUMNS(renewal) (
    PARTITION pWeek_1 VALUES IN('2010-02-01', '2010-02-02', '2010-02-03',
        '2010-02-04', '2010-02-05', '2010-02-06', '2010-02-07'),
    PARTITION pWeek_2 VALUES IN('2010-02-08', '2010-02-09', '2010-02-10',
        '2010-02-11', '2010-02-12', '2010-02-13', '2010-02-14'),
    PARTITION pWeek_3 VALUES IN('2010-02-15', '2010-02-16', '2010-02-17',
        '2010-02-18', '2010-02-19', '2010-02-20', '2010-02-21'),
    PARTITION pWeek_4 VALUES IN('2010-02-22', '2010-02-23', '2010-02-24',
        '2010-02-25', '2010-02-26', '2010-02-27', '2010-02-28')
);
</pre><p>
          これは機能しますが、関係する日付の数が非常に多くなってきた場合に、定義および保守が面倒になります。そのような場合は通常、<code class="literal">RANGE</code> または <code class="literal">RANGE COLUMNS</code> パーティショニングを代わりに使用するほうが現実的です。 この場合、パーティショニングキーとして使用するカラムは <code class="literal">DATE</code> カラムであるため、次に示すように <code class="literal">RANGE COLUMNS</code> パーティショニングを使用します。 
        </p><pre class="programlisting">CREATE TABLE customers_3 (
    first_name VARCHAR(25),
    last_name VARCHAR(25),
    street_1 VARCHAR(30),
    street_2 VARCHAR(30),
    city VARCHAR(15),
    renewal DATE
)
PARTITION BY RANGE COLUMNS(renewal) (
    PARTITION pWeek_1 VALUES LESS THAN('2010-02-09'),
    PARTITION pWeek_2 VALUES LESS THAN('2010-02-15'),
    PARTITION pWeek_3 VALUES LESS THAN('2010-02-22'),
    PARTITION pWeek_4 VALUES LESS THAN('2010-03-01')
);
</pre><p>
          詳細は、<a class="xref" href="partitioning.html#partitioning-columns-range" title="24.2.3.1 RANGE COLUMNS パーティショニング">セクション24.2.3.1「RANGE COLUMNS パーティショニング」</a>を参照してください。
        </p><p>
          また (<code class="literal">RANGE COLUMNS</code> パーティショニングと同様に)、<code class="literal">COLUMNS()</code> 句で複数のカラムを使用できます。
        </p><p>
          <code class="literal">PARTITION BY LIST COLUMNS()</code> 構文についての詳細は、<a class="xref" href="sql-statements.html#create-table" title="13.1.20 CREATE TABLE ステートメント">セクション13.1.20「CREATE TABLE ステートメント」</a>を参照してください。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-hash"></a>24.2.4 HASH パーティショニング</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="partitioning.html#partitioning-linear-hash">24.2.4.1 LINEAR HASH パーティショニング</a></span></dt></dl></div><a class="indexterm" name="idm45807910521248"></a><a class="indexterm" name="idm45807910519104"></a><p>
        <code class="literal">HASH</code> によるパーティショニングは、事前に決められた数のパーティションにデータを均等に配分するために主に使用されます。 レンジパーティション化またはリストパーティション化では、特定のカラム値またはカラム値のセットを格納するパーティションを明示的に指定する必要があります。ハッシュパーティション化では、この決定が行われ、ハッシュされるカラム値およびパーティションテーブルが分割されるパーティションの数に基づいてカラム値または式のみを指定する必要があります。 
      </p><p>
        <code class="literal">HASH</code> パーティショニングを使用してテーブルをパーティション化する場合は、<code class="literal">CREATE TABLE</code> ステートメントに <code class="literal">PARTITION BY HASH (<em class="replaceable"><code>expr</code></em>)</code> 句を付加する必要があります。ここで、<em class="replaceable"><code>expr</code></em> は整数を返す式です。 これは、型が MySQL 整数型のいずれかであるカラムの名前にすることができます。 また、多くの場合、この後に <code class="literal">PARTITIONS <em class="replaceable"><code>num</code></em></code> を使用します。ここで、<em class="replaceable"><code>num</code></em> は、テーブルが分割されるパーティションの数を表す正の整数です。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          わかりやすくするため、次の例のテーブルではキーを使用していません。 テーブルに一意キーがある場合、このテーブルのパーティション化式で使用されるすべてのカラムは、主キーを含むすべての一意キーの一部である必要があります。 詳しくは<a class="xref" href="partitioning.html#partitioning-limitations-partitioning-keys-unique-keys" title="24.6.1 パーティショニングキー、主キー、および一意キー">セクション24.6.1「パーティショニングキー、主キー、および一意キー」</a>,をご覧ください。 
        </p></div><p>
        次のステートメントは、<code class="literal">store_id</code> カラムにハッシュを使用し、4 つのパーティションに分割されるテーブルを作成します:
      </p><pre class="programlisting">CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY HASH(store_id)
PARTITIONS 4;
</pre><p>
        <code class="literal">PARTITIONS</code> 句を含めない場合、パーティションの数はデフォルトで <code class="literal">1</code> になります。<code class="literal">PARTITIONS</code> キーワードを数字なしで使用すると、構文エラーが発生します。
      </p><a class="indexterm" name="idm45807910501648"></a><p>
        整数を返す SQL 式を <em class="replaceable"><code>expr</code></em> に使用することもできます。 たとえば、従業員が雇用された年度に基づいてパーティション化するとします。 これは、次のように行うことができます。 
      </p><pre class="programlisting">CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY HASH( YEAR(hired) )
PARTITIONS 4;
</pre><p>
        <em class="replaceable"><code>expr</code></em> は、定数以外のランダムではない整数値 (つまり、変化するけれども決定論的であるべき) を返す必要があり、<a class="xref" href="partitioning.html#partitioning-limitations" title="24.6 パーティショニングの制約と制限">セクション24.6「パーティショニングの制約と制限」</a>で説明されている禁止された構造体を含んでいてはいけません。 また、この式は行が挿入または更新 (または場合によっては削除) されるたびに評価されるべきです。これは、非常に複雑な式がパフォーマンスの問題を起こすことがあることを意味します (特に、一度に多くの行に影響する操作 (バッチ挿入など) を実行するとき)。 
      </p><p>
        もっとも効率的なハッシュ関数は、単一テーブルカラムに実行され、その値がカラム値に対して比例的に増加または減少するもので、これによってパーティションの範囲を<span class="quote">「<span class="quote">プルーニング</span>」</span>できます。 つまり、式がそのベースのカラムの値に対してより密接に変化するほど、MySQL は式を HASH パーティショニングにより効率的に使用できます。 
      </p><p>
        たとえば、<code class="literal">date_col</code> が <code class="literal">DATE</code> 型のカラムである場合、式 <code class="literal">TO_DAYS(date_col)</code> は <code class="literal">date_col</code> の値に正比例すると表現されます。<code class="literal">date_col</code> の値が変わるたびに、式の値が一定の方法で変化するためです。 <code class="literal">date_col</code> に対する式 <code class="literal">YEAR(date_col)</code> の変化は、<code class="literal">TO_DAYS(date_col)</code> ほど比例的ではありません。<code class="literal">date_col</code> のあらゆる変化に対して <code class="literal">YEAR(date_col)</code> が同等に変化するとはかぎらないためです。 それでも、<code class="literal">YEAR(date_col)</code> はハッシュ関数の良い候補の 1 つです。<code class="literal">date_col</code> の一部と正比例し、<code class="literal">date_col</code> の変化によって <code class="literal">YEAR(date_col)</code> で比例的でない変化が発生することがないためです。 
      </p><p>
        比較のために、型が <code class="literal">INT</code> である <code class="literal">int_col</code> という名前のカラムがあるとします。 式 <code class="literal">POW(5-int_col,3) + 6</code> を検討してみてください。 これは、<code class="literal">int_col</code> の値が変化したときに、式の値に比例的に変化することが保証されないため、ハッシュ関数の良い候選択肢ではありません。 <code class="literal">int_col</code> の値を特定の量で変更すると、式の値に大きく異なる変更が生じる可能性があります。 たとえば、<code class="literal">int_col</code> が <code class="literal">5</code> から <code class="literal">6</code> に変化すると、式の値が <code class="literal">-1</code> に変化しますが、<code class="literal">int_col</code> の値が <code class="literal">6</code> から <code class="literal">7</code> に変化すると、式の値が <code class="literal">-7</code> に変化します。 
      </p><p>
        つまり、カラム値と式の値のグラフが、等式 <code class="literal">y=<em class="replaceable"><code>c</code></em>x</code> (ここで、<em class="replaceable"><code>c</code></em> はゼロでない何らかの定数) によって描かれるような直線に近くなるほど、その式はハッシュにより適切になります。 これは、式が非直線的であるほど、パーティションに対するデータの配分が不均衡になる傾向があることに関係しています。 
      </p><p>
        理論上は、複数のカラム値を使用する式をプルーニングすることもできますが、そのような式のどれが適しているかを判断するのがかなり難しく、時間がかかることがあります。 このため、複数のカラムを含むハッシュ式を使用することはあまり推奨されていません。 
      </p><p>
        <code class="literal">PARTITION BY HASH</code> を使用する場合、ストレージエンジンは式の結果のモジュラスに基づいて、使用する <em class="replaceable"><code>num</code></em> パーティションのパーティションを決定します。 つまり、特定の式 <em class="replaceable"><code>expr</code></em> の場合、レコードが格納されるパーティションはパーティション番号 <em class="replaceable"><code>N</code></em> で、<code class="literal"> <em class="replaceable"><code>N</code></em> = MOD( <em class="replaceable"><code>expr</code></em>, <em class="replaceable"><code>num</code></em>)</code> です。 テーブル <code class="literal">t1</code> が次のように 4 つのパーティションを持つように定義されているとします。 
      </p><pre class="programlisting">CREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATE)
    PARTITION BY HASH( YEAR(col3) )
    PARTITIONS 4;
</pre><p>
        <code class="literal">t1</code> に <code class="literal">col3</code> 値が <code class="literal">'2005-09-15'</code> であるレコードを挿入した場合、それが格納されるパーティションは次のように判断されます。
      </p><pre class="programlisting">MOD(YEAR('2005-09-01'),4)
=  MOD(2005,4)
=  1
</pre><p>
        MySQL 8.0 では、<span class="firstterm">線形ハッシング</span>と呼ばれる <code class="literal">HASH</code> パーティション化のバリアントもサポートされており、パーティションテーブルに挿入される新しい行の配置を決定するためのより複雑なアルゴリズムが採用されています。 このアルゴリズムについては、<a class="xref" href="partitioning.html#partitioning-linear-hash" title="24.2.4.1 LINEAR HASH パーティショニング">セクション24.2.4.1「LINEAR HASH パーティショニング」</a>を参照してください。 
      </p><p>
        ユーザー指定の式は、レコードが挿入または更新されるたびに評価されます。 状況によっては、レコードが削除されるときにも評価されることがあります。 
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="partitioning-linear-hash"></a>24.2.4.1 LINEAR HASH パーティショニング</h4></div></div></div><a class="indexterm" name="idm45807910448880"></a><a class="indexterm" name="idm45807910446720"></a><p>
          MySQL は線形ハッシュもサポートしています。通常のハッシュと異なるところは、線形ハッシュは線形二乗アルゴリズムを使用し、通常のハッシュはハッシュ関数の値の法を使用することです。
        </p><p>
          構文的には、リニアハッシュパーティショニングと通常のハッシュの唯一の違いは、次に示すように、<code class="literal">PARTITION BY</code> 句に <code class="literal">LINEAR</code> キーワードが追加されていることです。
        </p><pre class="programlisting">CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY LINEAR HASH( YEAR(hired) )
PARTITIONS 4;
</pre><p>
          式 <em class="replaceable"><code>expr</code></em> の場合、線形ハッシュが使用されるときにレコードが格納されるパーティションは、<em class="replaceable"><code>num</code></em> パーティションのうちのバーティション番号 <em class="replaceable"><code>N</code></em> です。ここで、<em class="replaceable"><code>N</code></em> は次のアルゴリズムに従って導出されます。
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              <em class="replaceable"><code>num</code></em> よりも大きい次の 2 の累乗を見つけます。 この値を <em class="replaceable"><code>V</code></em> と呼ぶことにします。これは次のように計算できます。 
            </p><pre class="programlisting"><em class="replaceable"><code>V</code></em> = POWER(2, CEILING(LOG(2, <em class="replaceable"><code>num</code></em>)))
</pre><p>
              (<em class="replaceable"><code>num</code></em> が 13 であるとします。 その場合、<code class="literal">LOG(2,13)</code> は 3.7004397181411 です。 <code class="literal">CEILING(3.7004397181411)</code> は 4、<em class="replaceable"><code>V</code></em> = <code class="literal">POWER(2,4)</code> は 16 です。) 
            </p></li><li class="listitem"><p>
              <em class="replaceable"><code>N</code></em> = <em class="replaceable"><code>F</code></em>(<em class="replaceable"><code>column_list</code></em>) &amp; (<em class="replaceable"><code>V</code></em> - 1) を設定します。
            </p></li><li class="listitem"><p>
              <em class="replaceable"><code>N</code></em> &gt;= <em class="replaceable"><code>num</code></em> の間:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                  <em class="replaceable"><code>V</code></em> を <em class="replaceable"><code>V</code></em> / 2 に設定
                </p></li><li class="listitem"><p>
                  <em class="replaceable"><code>N</code></em> = <em class="replaceable"><code>N</code></em> &amp; (<em class="replaceable"><code>V</code></em> - 1) を設定します
                </p></li></ul></div></li></ol></div><p>
          線形ハッシュパーティショニングを使用し、6 個のパーティションを持つテーブル <code class="literal">t1</code> を次のステートメントを使用して作成するとします。
        </p><pre class="programlisting">CREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATE)
    PARTITION BY LINEAR HASH( YEAR(col3) )
    PARTITIONS 6;
</pre><p>
          <code class="literal">col3</code> カラムの値が <code class="literal">'2003-04-14'</code> および <code class="literal">'1998-10-19'</code> である 2 つのレコードを <code class="literal">t1</code> に挿入するとします。 これらの 1 番目のパーティション番号は次のように決定されます。 
        </p><pre class="programlisting"><em class="replaceable"><code>V</code></em> = POWER(2, CEILING( LOG(2,6) )) = 8
<em class="replaceable"><code>N</code></em> = YEAR('2003-04-14') &amp; (8 - 1)
   = 2003 &amp; 7
   = 3

(<span class="emphasis"><em>3 &gt;= 6 is FALSE: record stored in partition #3</em></span>)
</pre><p>
          2 番目のレコードが格納されるパーティションの番号は、次のように計算されます。
        </p><pre class="programlisting"><em class="replaceable"><code>V</code></em> = 8
<em class="replaceable"><code>N</code></em> = YEAR('1998-10-19') &amp; (8 - 1)
  = 1998 &amp; 7
  = 6

(<span class="emphasis"><em>6 &gt;= 6 is TRUE: additional step required</em></span>)

<em class="replaceable"><code>N</code></em> = 6 &amp; ((8 / 2) - 1)
  = 6 &amp; 3
  = 2

(<span class="emphasis"><em>2 &gt;= 6 is FALSE: record stored in partition #2</em></span>)
</pre><p>
          線形ハッシュによるパーティショニングの利点は、パーティションの追加、削除、マージ、および分割の速度が向上することです。これは、非常に大量 (テラバイト) のデータが含まれるテーブルを扱うときに利点になることがあります。 欠点は、通常のハッシュパーティショニングを使用して獲得される配分と比べて、データがパーティションに均等に配分される可能性が低いことです。 
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-key"></a>24.2.5 KEY パーティショニング</h3></div></div></div><a class="indexterm" name="idm45807910406720"></a><a class="indexterm" name="idm45807910404576"></a><p>
        キーによるパーティショニングはハッシュによるパーティショニングと似ていますが、ハッシュパーティショニングはユーザー定義の式を使用し、キーパーティショニング用のハッシュ関数は MySQL サーバーによって提供されます。 NDB Cluster はこの目的のために <code class="literal">MD5()</code> を使用します。ほかのストレージエンジンを使用するテーブルの場合、サーバーは独自の内部ハッシュ関数を使用します。 
      </p><p>
        <code class="literal">CREATE TABLE ... PARTITION BY KEY</code> の構文規則は、ハッシュによってパーティション化されたテーブルを作成する場合のものと似ています。 主な違いを次に示します。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">HASH</code> ではなく <code class="literal">KEY</code> が使用されます。
          </p></li><li class="listitem"><p>
            <code class="literal">KEY</code> は、0 個以上のカラム名のリストのみを取ります。 パーティショニングキーとして使用されるカラムは、テーブルの主キーの一部またはすべてを構成している必要があります (テーブルにそれがある場合)。 パーティショニングキーとしてカラム名を指定しない場合は、テーブルの主キーが使用されます (ある場合)。 たとえば、次の <code class="literal">CREATE TABLE</code> ステートメントは MySQL 8.0 で有効です。 
          </p><pre class="programlisting">CREATE TABLE k1 (
    id INT NOT NULL PRIMARY KEY,
    name VARCHAR(20)
)
PARTITION BY KEY()
PARTITIONS 2;
</pre><p>
            主キーはないけれども一意キーはある場合は、パーティショニングキーに一意キーが使用されます。
          </p><pre class="programlisting">CREATE TABLE k1 (
    id INT NOT NULL,
    name VARCHAR(20),
    UNIQUE KEY (id)
)
PARTITION BY KEY()
PARTITIONS 2;
</pre><p>
            ただし、一意キーカラムが <code class="literal">NOT NULL</code> として定義されていない場合、前のステートメントは失敗します。
          </p><p>
            どちらの場合も、パーティショニングキーは <code class="literal">id</code> カラムです。ただし、<code class="literal">SHOW CREATE TABLE</code> の出力や <code class="literal">INFORMATION_SCHEMA.PARTITIONS</code> テーブルの <code class="literal">PARTITION_EXPRESSION</code> カラムには表示されません。
          </p><p>
            ほかのパーティショニングタイプの場合と異なり、<code class="literal">KEY</code> によるパーティショニングに使用されるカラムは、整数または <code class="literal">NULL</code> 値に制限されません。 たとえば、次の <code class="literal">CREATE TABLE</code> ステートメントは有効です。 
          </p><pre class="programlisting">CREATE TABLE tm1 (
    s1 CHAR(32) PRIMARY KEY
)
PARTITION BY KEY(s1)
PARTITIONS 10;
</pre><p>
            ほかのパーティショニングタイプが指定された場合、前のステートメントは有効で<span class="emphasis"><em>なくなります</em></span> (この場合、<code class="literal">s1</code> はテーブルの主キーであるため、単純に <code class="literal">PARTITION BY KEY()</code> を使用することも有効であり、<code class="literal">PARTITION BY KEY(s1)</code> と同じ効果があります)。 
          </p><p>
            この問題の詳細については、<a class="xref" href="partitioning.html#partitioning-limitations" title="24.6 パーティショニングの制約と制限">セクション24.6「パーティショニングの制約と制限」</a>を参照してください。
          </p><p>
            インデックス接頭辞を持つカラムは、パーティション化キーではサポートされていません。 つまり、<code class="literal">CHAR</code>, <code class="literal">VARCHAR</code>, <code class="literal">BINARY</code> カラムおよび <code class="literal">VARBINARY</code> カラムは、接頭辞を採用していないかぎり、パーティション化キーで使用できます。インデックス定義で <code class="literal">BLOB</code> カラムおよび <code class="literal">TEXT</code> カラムに接頭辞を指定する必要があるため、これら 2 つのタイプのカラムをパーティション化キーで使用することはできません。 MySQL 8.0.21 より前では、パーティション化されたテーブルの作成、変更、またはアップグレード時に、それらがテーブルのパーティショニングキーに含まれていなくても、接頭辞を使用するカラムは許可されていました。MySQL 8.0.21 以降では、この許容される動作は非推奨であり、そのようなカラムが使用されると、サーバーは適切な警告またはエラーを表示します。 詳細および例については、<a class="xref" href="partitioning.html#partitioning-limitations-prefixes" title="カラムインデックス接頭辞はキーパーティション化ではサポートされていません">カラムインデックス接頭辞はキーパーティション化ではサポートされていません</a>を参照してください。 
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">NDB</code> ストレージエンジンを使用するテーブルは、ほかの MySQL ストレージエンジンと同様に、テーブルの主キーをパーティショニングキーとして使用して、<code class="literal">KEY</code> によって暗黙的にパーティション化されます。 「NDB Cluster」テーブルに明示的な主キーがない場合は、<code class="literal">NDB</code> ストレージエンジンによって生成された各「NDB Cluster」テーブルの<span class="quote">「<span class="quote">「非表示」</span>」</span>主キーがパーティション化キーとして使用されます。 
            </p><p>
              <code class="literal">NDB</code> テーブルに明示的なパーティショニングスキームを定義する場合は、テーブルに明示的な主キーが必要であり、パーティショニング式に使用されるカラムがこのキーの一部である必要があります。 ただし、テーブルが<span class="quote">「<span class="quote">空</span>」</span>のパーティショニング式を使用する (つまり、カラム参照なしの <code class="literal">PARTITION BY KEY()</code>) 場合、明示的な主キーは必要ありません。 
            </p><p>
              このパーティショニングは、<span class="command"><strong>ndb_desc</strong></span> ユーティリティー (<code class="option">-p</code> オプション付き) を使用して確認できます。
            </p></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
              キーによってパーティション化されたテーブルの場合は、<code class="literal">ALTER TABLE DROP PRIMARY KEY</code> を実行できません。それを実行すると次のエラーが生成されます: <span class="errortext">ERROR 1466 (HY000): Field in list of fields for partition function not found in table</span>。 これは、<code class="literal">KEY</code> によってパーティション化された「NDB Cluster」テーブルでは問題ではありません。このような場合、テーブルは<span class="quote">「<span class="quote">「非表示」</span>」</span>主キーをテーブルの新しいパーティション化キーとして使用して再編成されます。 <a class="xref" href="mysql-cluster.html" title="第 23 章 MySQL NDB Cluster 8.0">第23章「<i>MySQL NDB Cluster 8.0</i>」</a>を参照してください。 
            </p></div></li></ul></div><a class="indexterm" name="idm45807910352992"></a><a class="indexterm" name="idm45807910350816"></a><p>
        リニアキーによってテーブルをパーティション化することもできます。 次に、単純な例を示します。 
      </p><pre class="programlisting">CREATE TABLE tk (
    col1 INT NOT NULL,
    col2 CHAR(5),
    col3 DATE
)
PARTITION BY LINEAR KEY (col1)
PARTITIONS 3;
</pre><p>
        <code class="literal">LINEAR</code> キーワードは、<code class="literal">KEY</code> パーティション化と <code class="literal">HASH</code> パーティション化で同じ効果を持ち、パーティション番号はモジュロ演算ではなく 2 乗アルゴリズムを使用して導出されます。 このアルゴリズムの説明およびその影響については、<a class="xref" href="partitioning.html#partitioning-linear-hash" title="24.2.4.1 LINEAR HASH パーティショニング">セクション24.2.4.1「LINEAR HASH パーティショニング」</a>を参照してください。 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-subpartitions"></a>24.2.6 サブパーティショニング</h3></div></div></div><a class="indexterm" name="idm45807910342752"></a><a class="indexterm" name="idm45807910341264"></a><p>
        サブパーティショニング (<span class="firstterm">複合パーティショニング</span>とも呼ばれます) は、パーティション化されたテーブルの各パーティションをさらに分割することです。 次の <code class="literal">CREATE TABLE</code> ステートメントを検討します。 
      </p><pre class="programlisting">CREATE TABLE ts (id INT, purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) )
    SUBPARTITION BY HASH( TO_DAYS(purchased) )
    SUBPARTITIONS 2 (
        PARTITION p0 VALUES LESS THAN (1990),
        PARTITION p1 VALUES LESS THAN (2000),
        PARTITION p2 VALUES LESS THAN MAXVALUE
    );
</pre><p>
        テーブル <code class="literal">ts</code> には 3 つの <code class="literal">RANGE</code> パーティションがあります。 これらの各パーティション (<code class="literal">p0</code>、<code class="literal">p1</code>、および <code class="literal">p2</code>) は、さらに 2 つのサブパーティションに分割されます。 実際には、テーブル全体が <code class="literal">3 * 2 = 6</code> パーティションに分割されます。 ただし、<code class="literal">PARTITION BY RANGE</code> 句のアクションによって、これらの最初の 2 つには <code class="literal">purchased</code> カラムで値が 1990 より小さいレコードのみが格納されます。 
      </p><a class="indexterm" name="idm45807910329520"></a><p>
        <code class="literal">RANGE</code> または <code class="literal">LIST</code> でパーティション化されたテーブルをサブパーティション化できます。 サブパーティショニングには、<code class="literal">HASH</code> または <code class="literal">KEY</code> パーティショニングを使用できます。 これは、<span class="firstterm">複合パーティショニング</span>とも呼ばれます。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">SUBPARTITION BY HASH</code> および <code class="literal">SUBPARTITION BY KEY</code> は通常それぞれ、<code class="literal">PARTITION BY HASH</code> および <code class="literal">PARTITION BY KEY</code> と同じ構文規則に従います。 これの例外は、<code class="literal">SUBPARTITION BY KEY</code> は現在 (<code class="literal">PARTITION BY KEY</code> と異なり) デフォルトカラムをサポートしないことで、この目的に使用されるカラムを指定する必要があります (テーブルに明示的な主キーがある場合でも)。 これは既知の問題であり、対処中です。詳細および例については <a class="xref" href="partitioning.html#partitioning-limitations-subpartitions" title="サブパーティションに関する問題">サブパーティションに関する問題</a>を参照してください。 
        </p></div><a class="indexterm" name="idm45807910316976"></a><p>
        <code class="literal">SUBPARTITION</code> 句を使用して個々のサブパーティションのオプションを指定することによって、サブパーティションを明示的に定義することもできます。 たとえば、前の例と同じテーブル <code class="literal">ts</code> をより冗長な形式で作成するには、次のようにします。 
      </p><pre class="programlisting">CREATE TABLE ts (id INT, purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) )
    SUBPARTITION BY HASH( TO_DAYS(purchased) ) (
        PARTITION p0 VALUES LESS THAN (1990) (
            SUBPARTITION s0,
            SUBPARTITION s1
        ),
        PARTITION p1 VALUES LESS THAN (2000) (
            SUBPARTITION s2,
            SUBPARTITION s3
        ),
        PARTITION p2 VALUES LESS THAN MAXVALUE (
            SUBPARTITION s4,
            SUBPARTITION s5
        )
    );
</pre><p>
        構文に関するいくつかの注意事項を次に示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            各パーティションには、同じ数のサブパーティションが必要です。
          </p></li><li class="listitem"><p>
            パーティション化されたテーブルのパーティションに <code class="literal">SUBPARTITION</code> を使用してサブパーティションを明示的に定義する場合は、それらのすべてを定義する必要があります。 つまり、次のステートメントは失敗します: 
          </p><pre class="programlisting">CREATE TABLE ts (id INT, purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) )
    SUBPARTITION BY HASH( TO_DAYS(purchased) ) (
        PARTITION p0 VALUES LESS THAN (1990) (
            SUBPARTITION s0,
            SUBPARTITION s1
        ),
        PARTITION p1 VALUES LESS THAN (2000),
        PARTITION p2 VALUES LESS THAN MAXVALUE (
            SUBPARTITION s2,
            SUBPARTITION s3
        )
    );
</pre><p>
            このステートメントは、<code class="literal">SUBPARTITIONS 2</code> を使用していても失敗します。
          </p></li><li class="listitem"><p>
            各 <code class="literal">SUBPARTITION</code> 句には、(少なくとも) サブパーティションの名前が含まれている必要があります。 それ以外は、サブパーティションに適切なオプションを設定するか、またはそのオプションのデフォルト設定を想定します。 
          </p></li><li class="listitem"><p>
            サブパーティション名はテーブル全体で一意である必要があります。 たとえば、次の <code class="literal">CREATE TABLE</code> ステートメントは有効です。 
          </p><pre class="programlisting">CREATE TABLE ts (id INT, purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) )
    SUBPARTITION BY HASH( TO_DAYS(purchased) ) (
        PARTITION p0 VALUES LESS THAN (1990) (
            SUBPARTITION s0,
            SUBPARTITION s1
        ),
        PARTITION p1 VALUES LESS THAN (2000) (
            SUBPARTITION s2,
            SUBPARTITION s3
        ),
        PARTITION p2 VALUES LESS THAN MAXVALUE (
            SUBPARTITION s4,
            SUBPARTITION s5
        )
    );
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-handling-nulls"></a>24.2.7 MySQL パーティショニングによる NULL の扱い</h3></div></div></div><p>
        MySQL のパーティショニングには、パーティショニング式の値 (カラム値またはユーザー定義式の値にかかわらず) として <code class="literal">NULL</code> を拒否する手段はありません。 式の値として <code class="literal">NULL</code> を使用することは許可されていますが (そうでない場合は整数を返す必要がある)、<code class="literal">NULL</code> は数値でないことを認識することは重要です。 MySQL のパーティショニング実装は、<code class="literal">ORDER BY</code> のように、<code class="literal">NULL</code> でない値より小さい値として <code class="literal">NULL</code> を扱います。 
      </p><p>
        これは、<code class="literal">NULL</code> の扱いは各タイプのパーティショニングで異なり、これに準備していない場合は予期しない動作になる可能性があることを意味します。 このような状況があるので、このセクションでは、各 MySQL パーティショニングタイプが、行をどのパーティションに格納するべきかを判断するときに <code class="literal">NULL</code> 値をどのように扱うかを説明し、それぞれの例を示します。 
      </p><p><b>RANGE パーティショニングでの NULL の扱い. </b>
          パーティションを判断するために使用されるカラム値が <code class="literal">NULL</code> である行を、<code class="literal">RANGE</code> によってパーティション化されたテーブルに挿入した場合、行はもっとも低いパーティションに挿入されます。 <code class="literal">p</code> という名前のデータベースに、次のように作成された 2 つのテーブルがあるとします。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
    -&gt;     <strong class="userinput"><code>c1 INT,</code></strong>
    -&gt;     <strong class="userinput"><code>c2 VARCHAR(20)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY RANGE(c1) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (0),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (10),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN MAXVALUE</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.09 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (</code></strong>
    -&gt;     <strong class="userinput"><code>c1 INT,</code></strong>
    -&gt;     <strong class="userinput"><code>c2 VARCHAR(20)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY RANGE(c1) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (-5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (0),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (10),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN MAXVALUE</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.09 sec)
</pre><p>
        これらの 2 つの <code class="literal">CREATE TABLE</code> ステートメントによって作成されたパーティションについては、次のクエリーを <code class="literal">INFORMATION_SCHEMA</code> データベース内の <code class="literal">PARTITIONS</code> テーブルに対して使用することで確認できます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, PARTITION_NAME, TABLE_ROWS, AVG_ROW_LENGTH, DATA_LENGTH</code></strong>
     &gt;   <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
     &gt;   <strong class="userinput"><code>WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME LIKE 't_';</code></strong>
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| t1         | p0             |          0 |              0 |           0 |
| t1         | p1             |          0 |              0 |           0 |
| t1         | p2             |          0 |              0 |           0 |
| t2         | p0             |          0 |              0 |           0 |
| t2         | p1             |          0 |              0 |           0 |
| t2         | p2             |          0 |              0 |           0 |
| t2         | p3             |          0 |              0 |           0 |
+------------+----------------+------------+----------------+-------------+
7 rows in set (0.00 sec)
</pre><p>
        (このテーブルについての詳細は、<a class="xref" href="information-schema.html#information-schema-partitions-table" title="26.21 INFORMATION_SCHEMA PARTITIONS テーブル">セクション26.21「INFORMATION_SCHEMA PARTITIONS テーブル」</a>を参照してください。) ここで、これらの各テーブルのパーティショニングキーとして使用されるカラムに <code class="literal">NULL</code> が含まれる単一行を移入し、2 つの <code class="literal">SELECT</code> ステートメントを使用してこれらの行が挿入されたことを確認します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES (NULL, 'mothra');</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO t2 VALUES (NULL, 'mothra');</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t1;</code></strong>
+------+--------+
| id   | name   |
+------+--------+
| NULL | mothra |
+------+--------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t2;</code></strong>
+------+--------+
| id   | name   |
+------+--------+
| NULL | mothra |
+------+--------+
1 row in set (0.00 sec)
</pre><p>
        挿入された行を格納するためにどのパーティションが使用されたかについては、前のクエリーを <code class="literal">INFORMATION_SCHEMA.PARTITIONS</code> に対して再実行して出力を検査することで確認できます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, PARTITION_NAME, TABLE_ROWS, AVG_ROW_LENGTH, DATA_LENGTH</code></strong>
     &gt;   <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
     &gt;   <strong class="userinput"><code>WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME LIKE 't_';</code></strong>
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
<span class="emphasis"><em>| t1         | p0             |          1 |             20 |          20 |</em></span>
| t1         | p1             |          0 |              0 |           0 |
| t1         | p2             |          0 |              0 |           0 |
<span class="emphasis"><em>| t2         | p0             |          1 |             20 |          20 |</em></span>
| t2         | p1             |          0 |              0 |           0 |
| t2         | p2             |          0 |              0 |           0 |
| t2         | p3             |          0 |              0 |           0 |
+------------+----------------+------------+----------------+-------------+
7 rows in set (0.01 sec)
</pre><p>
        また、これらのパーティションを削除してから <code class="literal">SELECT</code> ステートメントを再実行することで、これらの行が各テーブルの最小番号のパーティションに格納されたことを示すこともできます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 DROP PARTITION p0;</code></strong>
Query OK, 0 rows affected (0.16 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE t2 DROP PARTITION p0;</code></strong>
Query OK, 0 rows affected (0.16 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t1;</code></strong>
Empty set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t2;</code></strong>
Empty set (0.00 sec)
</pre><p>
        (<code class="literal">ALTER TABLE ... DROP PARTITION</code> の詳細については、<a class="xref" href="sql-statements.html#alter-table" title="13.1.9 ALTER TABLE ステートメント">セクション13.1.9「ALTER TABLE ステートメント」</a>を参照してください。)
      </p><p>
        SQL 関数を使用するパーティショニング式の場合も、<code class="literal">NULL</code> はこのように扱われます。 次のような <code class="literal">CREATE TABLE</code> ステートメントを使用してテーブルを定義するとします。 
      </p><pre class="programlisting">CREATE TABLE tndate (
    id INT,
    dt DATE
)
PARTITION BY RANGE( YEAR(dt) ) (
    PARTITION p0 VALUES LESS THAN (1990),
    PARTITION p1 VALUES LESS THAN (2000),
    PARTITION p2 VALUES LESS THAN MAXVALUE
);
</pre><p>
        ほかの MySQL 関数と同様に、<code class="literal">YEAR(NULL)</code> は <code class="literal">NULL</code> を返します。 <code class="literal">dt</code> カラム値が <code class="literal">NULL</code> である行は、パーティショニング式がほかの値より小さい値に評価されたかのように扱われ、パーティション <code class="literal">p0</code> に挿入されます。 
      </p><p><b>LIST パーティショニングでの NULL の扱い. </b>
          <code class="literal">LIST</code> によってパーティション化されたテーブルで <code class="literal">NULL</code> 値が許可されるのは、<code class="literal">NULL</code> が含まれている値リストを使用していずれかのパーティションが定義されている場合のみです。 これとは逆に、<code class="literal">LIST</code> によってパーティション化されたテーブルが、値リストで <code class="literal">NULL</code> を明示的に使用していない場合は、次の例のようにパーティショニング式で <code class="literal">NULL</code> 値に評価される行を拒否します。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE ts1 (</code></strong>
    -&gt;     <strong class="userinput"><code>c1 INT,</code></strong>
    -&gt;     <strong class="userinput"><code>c2 VARCHAR(20)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY LIST(c1) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES IN (0, 3, 6),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES IN (1, 4, 7),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES IN (2, 5, 8)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO ts1 VALUES (9, 'mothra');</code></strong>
<span class="errortext">ERROR 1504 (HY000): Table has no partition for value 9</span>

mysql&gt; <strong class="userinput"><code>INSERT INTO ts1 VALUES (NULL, 'mothra');</code></strong>
<span class="errortext">ERROR 1504 (HY000): Table has no partition for value NULL</span>
</pre><p>
        <code class="literal">ts1</code> に挿入できるのは、<code class="literal">c1</code> 値が <code class="literal">0</code> 以上 <code class="literal">8</code> 以下の行のみです。 <code class="literal">NULL</code> は、数値 <code class="literal">9</code> と同様にこの範囲を外れます。 <code class="literal">NULL</code> が含まれる値リストを持つテーブル <code class="literal">ts2</code> および<code class="literal">ts3</code> は次のように作成できます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE ts2 (</code></strong>
    -&gt;     <strong class="userinput"><code>c1 INT,</code></strong>
    -&gt;     <strong class="userinput"><code>c2 VARCHAR(20)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY LIST(c1) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES IN (0, 3, 6),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES IN (1, 4, 7),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES IN (2, 5, 8),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p3 VALUES IN (NULL)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE ts3 (</code></strong>
    -&gt;     <strong class="userinput"><code>c1 INT,</code></strong>
    -&gt;     <strong class="userinput"><code>c2 VARCHAR(20)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY LIST(c1) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES IN (0, 3, 6),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES IN (1, 4, 7, NULL),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES IN (2, 5, 8)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.01 sec)
</pre><p>
        パーティショニングの値リストを定義するときに、<code class="literal">NULL</code> をほかの値と同様に扱うことができます (そうすべきです)。 たとえば、<code class="literal">VALUES IN (NULL)</code> および <code class="literal">VALUES IN (1, 4, 7, NULL)</code> は両方とも有効であり、<code class="literal">VALUES IN (1, NULL, 4, 7)</code>、<code class="literal">VALUES IN (NULL, 1, 4, 7)</code> なども同様です。 カラム <code class="literal">c1</code> が <code class="literal">NULL</code> である行をテーブル <code class="literal">ts2</code> および <code class="literal">ts3</code> にそれぞれ挿入できます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO ts2 VALUES (NULL, 'mothra');</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO ts3 VALUES (NULL, 'mothra');</code></strong>
Query OK, 1 row affected (0.00 sec)
</pre><p>
        <code class="literal">INFORMATION_SCHEMA.PARTITIONS</code> に対して適切なクエリーを発行することによって、先ほど挿入した行を格納するためにどのパーティションが使用されたかを確認できます (前の例と同様に、パーティション化されたテーブルが <code class="literal">p</code> データベースに作成されたことを想定しています)。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, PARTITION_NAME, TABLE_ROWS, AVG_ROW_LENGTH, DATA_LENGTH</code></strong>
     &gt;   <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
     &gt;   <strong class="userinput"><code>WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME LIKE 'ts_';</code></strong>
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| ts2        | p0             |          0 |              0 |           0 |
| ts2        | p1             |          0 |              0 |           0 |
| ts2        | p2             |          0 |              0 |           0 |
<span class="emphasis"><em>| ts2        | p3             |          1 |             20 |          20 |</em></span>
| ts3        | p0             |          0 |              0 |           0 |
<span class="emphasis"><em>| ts3        | p1             |          1 |             20 |          20 |</em></span>
| ts3        | p2             |          0 |              0 |           0 |
+------------+----------------+------------+----------------+-------------+
7 rows in set (0.01 sec)
</pre><p>
        このセクションですでに示したように、行を格納するためにどのパーティションが使用されたかについては、それらのパーティションを削除してから <code class="literal">SELECT</code> を実行することで確認できます。
      </p><p><b>HASH および KEY パーティショニングでの NULL の扱い. </b>
          <code class="literal">HASH</code> または <code class="literal">KEY</code> によってパーティション化されたテーブルの場合、<code class="literal">NULL</code> の扱いは少し異なります。 これらの場合、<code class="literal">NULL</code> 値を返すパーティショニング式は、戻り値がゼロであったかのように扱われます。 この動作については、<code class="literal">HASH</code> によってパーティション化されたテーブルを作成して該当する値が含まれるレコードを挿入することで、ファイルシステムにどのような影響があるかを検査することで確認できます。 次のステートメントを使用して作成されたテーブル <code class="literal">th</code> (これも <code class="literal">p</code> データベース内) があるとします。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE th (</code></strong>
    -&gt;     <strong class="userinput"><code>c1 INT,</code></strong>
    -&gt;     <strong class="userinput"><code>c2 VARCHAR(20)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY HASH(c1)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITIONS 2;</code></strong>
Query OK, 0 rows affected (0.00 sec)
</pre><p>
        このテーブルに属するパーティションは、次のクエリーを使用して表示できます。
      </p><pre class="programlisting">mysql&gt; SELECT TABLE_NAME,PARTITION_NAME,TABLE_ROWS,AVG_ROW_LENGTH,DATA_LENGTH
     &gt;   FROM INFORMATION_SCHEMA.PARTITIONS
     &gt;   WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME ='th';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| th         | p0             |          0 |              0 |           0 |
| th         | p1             |          0 |              0 |           0 |
+------------+----------------+------------+----------------+-------------+
2 rows in set (0.00 sec)
</pre><p>
        各パーティションの <code class="literal">TABLE_ROWS</code> は 0 です。 ここで次に示すように、<code class="literal">c1</code> カラム値が <code class="literal">NULL</code> および 0 である 2 つの行を <code class="literal">th</code> に挿入し、それらの行が挿入されたことを確認します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO th VALUES (NULL, 'mothra'), (0, 'gigan');</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM th;</code></strong>
+------+---------+
| c1   | c2      |
+------+---------+
| NULL | mothra  |
+------+---------+
|    0 | gigan   |
+------+---------+
2 rows in set (0.01 sec)
</pre><p>
        任意の整数 <em class="replaceable"><code>N</code></em> について、<code class="literal">NULL MOD <em class="replaceable"><code>N</code></em></code> の値は常に <code class="literal">NULL</code> であることを思い出してください。 <code class="literal">HASH</code> または <code class="literal">KEY</code> によってパーティション化されたテーブルの場合、この結果は正しいパーティションを判別するために <code class="literal">0</code> として扱われます。 <code class="literal">INFORMATION_SCHEMA.PARTITIONS</code> テーブルを再度確認すると、両方の行がパーティション <code class="literal">p0</code> に挿入されたことがわかります。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, PARTITION_NAME, TABLE_ROWS, AVG_ROW_LENGTH, DATA_LENGTH</code></strong>
     &gt;   <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
     &gt;   <strong class="userinput"><code>WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME ='th';</code></strong>
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
<span class="emphasis"><em>| th         | p0             |          2 |             20 |          20 |</em></span>
| th         | p1             |          0 |              0 |           0 |
+------------+----------------+------------+----------------+-------------+
2 rows in set (0.00 sec)
</pre><p>
        テーブルの定義で <code class="literal">PARTITION BY HASH</code> のかわりに <code class="literal">PARTITION BY KEY</code> を使用して最後の例を繰り返すことで、<code class="literal">NULL</code> がこのタイプのパーティション化でも 0 のように処理されることを確認できます。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="partitioning-management"></a>24.3 パーティション管理</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="partitioning.html#partitioning-management-range-list">24.3.1 RANGE および LIST パーティションの管理</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-management-hash-key">24.3.2 HASH および KEY パーティションの管理</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-management-exchange">24.3.3 パーティションとサブパーティションをテーブルと交換する</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-maintenance">24.3.4 パーティションの保守</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-info">24.3.5 パーティションに関する情報を取得する</a></span></dt></dl></div><a class="indexterm" name="idm45807910138224"></a><a class="indexterm" name="idm45807910136768"></a><a class="indexterm" name="idm45807910134736"></a><a class="indexterm" name="idm45807910132704"></a><a class="indexterm" name="idm45807910130656"></a><a class="indexterm" name="idm45807910128592"></a><p>
      SQL ステートメントを使用してパーティションテーブルを変更する方法は多数あります。<code class="literal">ALTER TABLE</code> ステートメントのパーティション化拡張を使用して、既存のパーティションを追加、削除、再定義、マージまたは分割できます。 パーティション化されたテーブルおよびパーティションに関する情報を取得する方法もあります。 以降のセクションでは次のトピックについて説明します。 
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">RANGE</code> または <code class="literal">LIST</code> によってパーティション化されたテーブルのパーティション管理については、<a class="xref" href="partitioning.html#partitioning-management-range-list" title="24.3.1 RANGE および LIST パーティションの管理">セクション24.3.1「RANGE および LIST パーティションの管理」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">HASH</code> および <code class="literal">KEY</code> パーティションの管理については、<a class="xref" href="partitioning.html#partitioning-management-hash-key" title="24.3.2 HASH および KEY パーティションの管理">セクション24.3.2「HASH および KEY パーティションの管理」</a>を参照してください。
        </p></li><li class="listitem"><p>
          パーティション化されたテーブルおよびパーティションに関する情報を取得するために MySQL 8.0 で提供されるメカニズムについては、<a class="xref" href="partitioning.html#partitioning-info" title="24.3.5 パーティションに関する情報を取得する">セクション24.3.5「パーティションに関する情報を取得する」</a>を参照してください。
        </p></li><li class="listitem"><p>
          パーティションの保守操作の実行については、<a class="xref" href="partitioning.html#partitioning-maintenance" title="24.3.4 パーティションの保守">セクション24.3.4「パーティションの保守」</a>を参照してください。
        </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        パーティションテーブルのすべてのパーティションは、同じ数のサブパーティションを持つ必要があります。テーブルの作成後にサブパーティション化を変更することはできません。
      </p></div><p>
      テーブルパーティション化スキームを変更するには、パーティションテーブルを作成するために <code class="literal">CREATE TABLE</code> で使用される構文と同じ構文を持つ <em class="replaceable"><code>partition_options</code></em> オプションとともに <code class="literal">ALTER TABLE</code> ステートメントを使用する必要があります。このオプション (および) は、常に <code class="literal">PARTITION BY</code> キーワードで始まります。 次の <code class="literal">CREATE TABLE</code> ステートメントを使用して、レンジでパーティション化されたテーブルを作成したとします: 
    </p><pre class="programlisting">CREATE TABLE trb3 (id INT, name VARCHAR(50), purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) ) (
        PARTITION p0 VALUES LESS THAN (1990),
        PARTITION p1 VALUES LESS THAN (1995),
        PARTITION p2 VALUES LESS THAN (2000),
        PARTITION p3 VALUES LESS THAN (2005)
    );
</pre><p>
      このテーブルをキーによるパーティション化でパーティション化し直して、キーをベースとする <code class="literal">id</code> カラム値を使用する 2 つのパーティションに分割するために、次のステートメントを使用できます。
    </p><pre class="programlisting">ALTER TABLE trb3 PARTITION BY KEY(id) PARTITIONS 2;
</pre><p>
      これは、テーブルを削除してから <code class="literal">CREATE TABLE trb3 PARTITION BY KEY(id) PARTITIONS 2;</code> を使用して再作成する場合と同じ効果を、テーブルの構造に対して持ちます。
    </p><p>
      <code class="literal">ALTER TABLE ... ENGINE = ...</code> は、テーブルによって使用されるストレージエンジンのみを変更し、テーブルのパーティショニングスキームはそのままにします。 このステートメントは、ターゲットストレージエンジンがパーティショニングサポートを提供している場合にのみ成功します。 <code class="literal">ALTER TABLE ... REMOVE PARTITIONING</code> を使用して、テーブルのパーティション化を削除できます。<a class="xref" href="sql-statements.html#alter-table" title="13.1.9 ALTER TABLE ステートメント">セクション13.1.9「ALTER TABLE ステートメント」</a> を参照してください。 
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        <code class="literal">ALTER TABLE</code> ステートメントに使用できるのは、単一の <code class="literal">PARTITION BY</code>、<code class="literal">ADD PARTITION</code>、<code class="literal">DROP PARTITION</code>、<code class="literal">REORGANIZE PARTITION</code>、または <code class="literal">COALESCE PARTITION</code> 句のみです。 たとえば、パーティションを削除してテーブルの残りのパーティションを再編成する場合は、(<code class="literal">DROP PARTITION</code> を使用してから <code class="literal">REORGANIZE PARTITION</code> を使用して別の <code class="literal">ALTER TABLE</code> ステートメントを使用して) これを行う必要があります。 
      </p></div><p>
      <code class="literal">ALTER TABLE ... TRUNCATE PARTITION</code> を使用して、選択した 1 つ以上のパーティションからすべての行を削除できます。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-management-range-list"></a>24.3.1 RANGE および LIST パーティションの管理</h3></div></div></div><a class="indexterm" name="idm45807910086272"></a><a class="indexterm" name="idm45807910084128"></a><a class="indexterm" name="idm45807910082048"></a><a class="indexterm" name="idm45807910079952"></a><p>
        レンジパーティションとリストパーティションの追加および削除は同様の方法で処理されるため、このセクションでは両方のパーティション化の管理について説明します。 ハッシュまたはキーによってパーティション化されたテーブルの管理については、<a class="xref" href="partitioning.html#partitioning-management-hash-key" title="24.3.2 HASH および KEY パーティションの管理">セクション24.3.2「HASH および KEY パーティションの管理」</a>を参照してください。 
      </p><p>
        <code class="literal">RANGE</code> または <code class="literal">LIST</code> によってパーティション化されたテーブルからパーティションを削除するには、<code class="literal">DROP PARTITION</code> オプションを指定した <code class="literal">ALTER TABLE</code> ステートメントを使用します。 レンジでパーティション化され、次の <code class="literal">CREATE TABLE</code> および <code class="literal">INSERT</code> ステートメントを使用して 10 個のレコードが移入されるテーブルを作成したとします: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE tr (id INT, name VARCHAR(50), purchased DATE)</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION BY RANGE( YEAR(purchased) ) (</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (1990),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (1995),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (2000),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (2005),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p4 VALUES LESS THAN (2010),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p5 VALUES LESS THAN (2015)</code></strong>
    -&gt;     <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.28 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO tr VALUES</code></strong>
    -&gt;     <strong class="userinput"><code>(1, 'desk organiser', '2003-10-15'),</code></strong>
    -&gt;     <strong class="userinput"><code>(2, 'alarm clock', '1997-11-05'),</code></strong>
    -&gt;     <strong class="userinput"><code>(3, 'chair', '2009-03-10'),</code></strong>
    -&gt;     <strong class="userinput"><code>(4, 'bookcase', '1989-01-10'),</code></strong>
    -&gt;     <strong class="userinput"><code>(5, 'exercise bike', '2014-05-09'),</code></strong>
    -&gt;     <strong class="userinput"><code>(6, 'sofa', '1987-06-05'),</code></strong>
    -&gt;     <strong class="userinput"><code>(7, 'espresso maker', '2011-11-22'),</code></strong>
    -&gt;     <strong class="userinput"><code>(8, 'aquarium', '1992-08-04'),</code></strong>
    -&gt;     <strong class="userinput"><code>(9, 'study desk', '2006-09-16'),</code></strong>
    -&gt;     <strong class="userinput"><code>(10, 'lava lamp', '1998-12-25');</code></strong>
Query OK, 10 rows affected (0.05 sec)
Records: 10  Duplicates: 0  Warnings: 0
</pre><p>
        パーティション <code class="literal">p2</code> に挿入されているはずの項目を以下のように確認できます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM tr</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE purchased BETWEEN '1995-01-01' AND '1999-12-31';</code></strong>
+------+-------------+------------+
| id   | name        | purchased  |
+------+-------------+------------+
|    2 | alarm clock | 1997-11-05 |
|   10 | lava lamp   | 1998-12-25 |
+------+-------------+------------+
2 rows in set (0.00 sec)
</pre><p>
        次に示すように、パーティション選択を使用してこの情報を取得することもできます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM tr PARTITION (p2);</code></strong>
+------+-------------+------------+
| id   | name        | purchased  |
+------+-------------+------------+
|    2 | alarm clock | 1997-11-05 |
|   10 | lava lamp   | 1998-12-25 |
+------+-------------+------------+
2 rows in set (0.00 sec)
</pre><p>
        詳しくは<a class="xref" href="partitioning.html#partitioning-selection" title="24.5 パーティション選択">セクション24.5「パーティション選択」</a>,をご覧ください。
      </p><p>
        <code class="literal">p2</code> という名前のパーティションを削除するには、次のコマンドを実行します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE tr DROP PARTITION p2;</code></strong>
Query OK, 0 rows affected (0.03 sec)
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">NDBCLUSTER</code> ストレージエンジンは <code class="literal">ALTER TABLE ... DROP PARTITION</code> をサポートしていません。 ただし、この章で説明されている <code class="literal">ALTER TABLE</code> へのほかのパーティショニング関連拡張はサポートしています。 
        </p></div><p>
        <span class="emphasis"><em>パーティションを削除すると、そのパーティションに格納されていたすべてのデータも削除される</em></span>ことを覚えておくことは非常に重要です。 前の <code class="literal">SELECT</code> クエリーを再実行することで、これが本当であることを確認できます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM tr WHERE purchased</code></strong>
    -&gt; <strong class="userinput"><code>BETWEEN '1995-01-01' AND '1999-12-31';</code></strong>
Empty set (0.00 sec)
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">DROP PARTITION</code> は、ネイティブパーティション化インプレース API でサポートされており、<code class="literal">ALGORITHM={COPY|INPLACE}</code> で使用できます。 <code class="literal">ALGORITHM=INPLACE</code> を使用した <code class="literal">DROP PARTITION</code> は、パーティションに格納されているデータを削除し、パーティションを削除します。 ただし、<code class="literal">ALGORITHM=COPY</code> または <code class="literal">old_alter_table=ON</code> を使用した <code class="literal">DROP PARTITION</code> では、パーティションテーブルが再構築され、削除されたパーティションから互換性のある <code class="literal">PARTITION ... VALUES</code> 定義を持つ別のパーティションへのデータの移動が試行されます。 別のパーティションに移動できないデータは削除されます。 
        </p></div><p>
        このため、テーブルに対して <code class="literal">ALTER TABLE ... DROP PARTITION</code> を実行するには、そのテーブルの <code class="literal">DROP</code> 権限が必要です。
      </p><p>
        テーブル定義およびそのパーティショニングスキームを保持したまま、すべてのパーティションからすべてのデータを削除する場合は、<code class="literal">TRUNCATE TABLE</code> ステートメントを使用してください。 (<a class="xref" href="sql-statements.html#truncate-table" title="13.1.37 TRUNCATE TABLE ステートメント">セクション13.1.37「TRUNCATE TABLE ステートメント」</a>を参照してください。) 
      </p><p>
        データを失うこと<span class="emphasis"><em>なく</em></span>テーブルのパーティショニングを変更する場合は、代わりに <code class="literal">ALTER TABLE ... REORGANIZE PARTITION</code> を使用してください。 <code class="literal">REORGANIZE PARTITION</code> については、後続の説明または<a class="xref" href="sql-statements.html#alter-table" title="13.1.9 ALTER TABLE ステートメント">セクション13.1.9「ALTER TABLE ステートメント」</a>を参照してください。 
      </p><p>
        ここで <code class="literal">SHOW CREATE TABLE</code> ステートメントを実行すると、テーブルのパーティショニング構成がどのように変更されたかを確認できます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE tr\G</code></strong>
*************************** 1. row ***************************
       Table: tr
Create Table: CREATE TABLE `tr` (
  `id` int(11) DEFAULT NULL,
  `name` varchar(50) DEFAULT NULL,
  `purchased` date DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1
/*!50100 PARTITION BY RANGE ( YEAR(purchased))
(PARTITION p0 VALUES LESS THAN (1990) ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (1995) ENGINE = InnoDB,
 PARTITION p3 VALUES LESS THAN (2005) ENGINE = InnoDB,
 PARTITION p4 VALUES LESS THAN (2010) ENGINE = InnoDB,
 PARTITION p5 VALUES LESS THAN (2015) ENGINE = InnoDB) */
1 row in set (0.00 sec)
</pre><p>
        <code class="literal">'1995-01-01'</code>と<code class="literal">'2004-12-31'</code>の間の <code class="literal">purchased</code> カラム値を使用して、変更されたテーブルに新しい行を挿入すると、それらの行はパーティション <code class="literal">p3</code> に格納されます。 このことを次のようにして確認できます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO tr VALUES (11, 'pencil holder', '1995-07-12');</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM tr WHERE purchased</code></strong>
    -&gt; <strong class="userinput"><code>BETWEEN '1995-01-01' AND '2004-12-31';</code></strong>
+------+----------------+------------+
| id   | name           | purchased  |
+------+----------------+------------+
|    1 | desk organiser | 2003-10-15 |
|   11 | pencil holder  | 1995-07-12 |
+------+----------------+------------+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE tr DROP PARTITION p3;</code></strong>
Query OK, 0 rows affected (0.03 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM tr WHERE purchased</code></strong>
    -&gt; <strong class="userinput"><code>BETWEEN '1995-01-01' AND '2004-12-31';</code></strong>
Empty set (0.00 sec)
</pre><p>
        <code class="literal">ALTER TABLE ... DROP PARTITION</code> の結果としてテーブルから削除された行数は、同等の <code class="literal">DELETE</code> クエリーとは異なり、サーバーから報告されません。
      </p><p>
        <code class="literal">LIST</code> パーティションを削除する場合は、<code class="literal">RANGE</code> パーティションの削除に使用するものとまったく同じ <code class="literal">ALTER TABLE ... DROP PARTITION</code> 構文を使用します。 ただし、この操作が持つ影響について、このテーブルをあとで使用する際に重要な違いが 1 つあります。このテーブルには、削除したパーティションを定義する値リストに含まれていた値を持つ行を挿入できなくなります。 (例については、<a class="xref" href="partitioning.html#partitioning-list" title="24.2.2 LIST パーティショニング">セクション24.2.2「LIST パーティショニング」</a>を参照してください)。 
      </p><p>
        すでにパーティション化されたテーブルに新しい範囲またはリストパーティションを追加するには、<code class="literal">ALTER TABLE ... ADD PARTITION</code> ステートメントを使用します。 <code class="literal">RANGE</code> によってパーティション化されたテーブルの場合は、これを使用して、既存のパーティションのリストの最後に新しい範囲を追加できます。 次のように定義された、組織のメンバーシップデータが含まれるパーティション化されたテーブルがあるとします。 
      </p><pre class="programlisting">CREATE TABLE members (
    id INT,
    fname VARCHAR(25),
    lname VARCHAR(25),
    dob DATE
)
PARTITION BY RANGE( YEAR(dob) ) (
    PARTITION p0 VALUES LESS THAN (1980),
    PARTITION p1 VALUES LESS THAN (1990),
    PARTITION p2 VALUES LESS THAN (2000)
);
</pre><p>
        さらに、メンバーの最少年齢は 16 歳であるとします。 カレンダが 2015 年末に近づくにつれて、2000 年 (以降) に生まれたメンバーを入学させる準備が間もなくできていることがわかりました。 次のように <code class="literal">members</code> テーブルを変更することで、2000 年から 2010 年までに生まれた新しいメンバーを受け入れることができます。 
      </p><pre class="programlisting">ALTER TABLE members ADD PARTITION (PARTITION p3 VALUES LESS THAN (2010));
</pre><p>
        範囲によってパーティション化されたテーブルで <code class="literal">ADD PARTITION</code> を使用するときは、パーティションリストの上端にのみ新しいパーティションを追加できます。 この方法で新しいパーティションを既存のパーティションの間または前に追加しようとすると、次のようにエラーになります。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE members</code></strong>
     &gt;     <strong class="userinput"><code>ADD PARTITION (</code></strong>
     &gt;     <strong class="userinput"><code>PARTITION n VALUES LESS THAN (1970));</code></strong>
ERROR 1463 (HY000): VALUES LESS THAN value must be strictly »
   increasing for each partition
</pre><p>
        この問題は、次のように最初のパーティションを 2 つに再編成し、それらの間の範囲を分割することで回避できます。
      </p><pre class="programlisting">ALTER TABLE members
    REORGANIZE PARTITION p0 INTO (
        PARTITION n0 VALUES LESS THAN (1970),
        PARTITION n1 VALUES LESS THAN (1980)
);
</pre><p>
        <code class="literal">SHOW CREATE TABLE</code> を使用することで、<code class="literal">ALTER TABLE</code> ステートメントによって意図した効果が得られたことを確認できます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE members\G</code></strong>
*************************** 1. row ***************************
       Table: members
Create Table: CREATE TABLE `members` (
  `id` int(11) DEFAULT NULL,
  `fname` varchar(25) DEFAULT NULL,
  `lname` varchar(25) DEFAULT NULL,
  `dob` date DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1
/*!50100 PARTITION BY RANGE ( YEAR(dob))
(PARTITION n0 VALUES LESS THAN (1970) ENGINE = InnoDB,
 PARTITION n1 VALUES LESS THAN (1980) ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (1990) ENGINE = InnoDB,
 PARTITION p2 VALUES LESS THAN (2000) ENGINE = InnoDB,
 PARTITION p3 VALUES LESS THAN (2010) ENGINE = InnoDB) */
1 row in set (0.00 sec)
</pre><p>
        <a class="xref" href="sql-statements.html#alter-table-partition-operations" title="13.1.9.1 ALTER TABLE パーティション操作">セクション13.1.9.1「ALTER TABLE パーティション操作」</a>も参照してください。
      </p><p>
        <code class="literal">ALTER TABLE ... ADD PARTITION</code> を使用して、<code class="literal">LIST</code> によってパーティション化されたテーブルに新しいパーティションを追加することもできます。 次の <code class="literal">CREATE TABLE</code> ステートメントを使用してテーブル <code class="literal">tt</code> が定義されているとします。 
      </p><pre class="programlisting">CREATE TABLE tt (
    id INT,
    data INT
)
PARTITION BY LIST(data) (
    PARTITION p0 VALUES IN (5, 10, 15),
    PARTITION p1 VALUES IN (6, 12, 18)
);
</pre><p>
        <code class="literal">data</code> カラム値が <code class="literal">7</code>、<code class="literal">14</code>、および <code class="literal">21</code> である行を格納する新しいパーティションを次のように追加できます。
      </p><pre class="programlisting">ALTER TABLE tt ADD PARTITION (PARTITION p2 VALUES IN (7, 14, 21));
</pre><p>
        既存のパーティションの値リストにすでに含まれている値を含む新しい <code class="literal">LIST</code> パーティションは追加できないことに注意してください。 これを試行すると、次のエラーが発生します: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE tt ADD PARTITION </code></strong>
     &gt;     <strong class="userinput"><code>(PARTITION np VALUES IN (4, 8, 12));</code></strong>
ERROR 1465 (HY000): Multiple definition of same constant »
                    in list partitioning
</pre><p>
        <code class="literal">data</code> カラム値が <code class="literal">12</code> である行がパーティション <code class="literal">p1</code> にすでに割り当てられているため、値リストに <code class="literal">12</code> が含まれる新しいパーティションをテーブル <code class="literal">tt</code> に作成することはできません。 これを実現するために、<code class="literal">p1</code> を削除し、<code class="literal">np</code> を追加してから、定義を変更した新しい <code class="literal">p1</code> を追加できます。 ただし、すでに説明したように、これによって <code class="literal">p1</code> に格納されていたすべてのデータが失われるので、これが実際にやりたいことでないことが多いです。 別の解決策になる可能性があるのが、<code class="literal">CREATE TABLE ... SELECT ...</code> を使用して、新しいパーティショニング付きでテーブルのコピーを作成し、データをそこにコピーしてから、古いテーブルを削除して新しいテーブルを名前変更することですが、これは大量のデータを扱うときに非常に時間がかかる可能性があります。 高可用性が要求される状況では実行できない可能性もあります。 
      </p><p>
        次のように単一 <code class="literal">ALTER TABLE ... ADD PARTITION</code> ステートメントで複数のパーティションを追加できます。
      </p><pre class="programlisting">CREATE TABLE employees (
  id INT NOT NULL,
  fname VARCHAR(50) NOT NULL,
  lname VARCHAR(50) NOT NULL,
  hired DATE NOT NULL
)
PARTITION BY RANGE( YEAR(hired) ) (
  PARTITION p1 VALUES LESS THAN (1991),
  PARTITION p2 VALUES LESS THAN (1996),
  PARTITION p3 VALUES LESS THAN (2001),
  PARTITION p4 VALUES LESS THAN (2005)
);

ALTER TABLE employees ADD PARTITION (
    PARTITION p5 VALUES LESS THAN (2010),
    PARTITION p6 VALUES LESS THAN MAXVALUE
);
</pre><p>
        ありがたいことに、MySQL のパーティショニング実装は、データを失うことなくパーティショニングを再定義する方法を提供しています。 まず、<code class="literal">RANGE</code> パーティショニングを使用するいくつかの簡単な例を見てみましょう。 次のように定義された <code class="literal">members</code> テーブルを思い出してください。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE members\G</code></strong>
*************************** 1. row ***************************
       Table: members
Create Table: CREATE TABLE `members` (
  `id` int(11) DEFAULT NULL,
  `fname` varchar(25) DEFAULT NULL,
  `lname` varchar(25) DEFAULT NULL,
  `dob` date DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1
/*!50100 PARTITION BY RANGE ( YEAR(dob))
(PARTITION n0 VALUES LESS THAN (1970) ENGINE = InnoDB,
 PARTITION n1 VALUES LESS THAN (1980) ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (1990) ENGINE = InnoDB,
 PARTITION p2 VALUES LESS THAN (2000) ENGINE = InnoDB,
 PARTITION p3 VALUES LESS THAN (2010) ENGINE = InnoDB) */
1 row in set (0.00 sec)
</pre><p>
        1960 年より前に生まれたメンバーを表すすべての行を別のパーティションに移動するとします。 すでに説明したように、これは <code class="literal">ALTER TABLE ... ADD PARTITION</code> を使用して行うことはできません。 ただし、<code class="literal">ALTER TABLE</code> への別のパーティション関連拡張を使用して、これを行うことができます。 
      </p><pre class="programlisting">ALTER TABLE members REORGANIZE PARTITION n0 INTO (
    PARTITION s0 VALUES LESS THAN (1960),
    PARTITION s1 VALUES LESS THAN (1970)
);
</pre><p>
        実際には、このコマンドはパーティション <code class="literal">p0</code> を 2 つの新しいパーティション <code class="literal">s0</code> および <code class="literal">s1</code> に分割します。 さらに、<code class="literal">p0</code> に格納されていたデータを 2つの <code class="literal">PARTITION ... VALUES ...</code> 句に示されているルールに従って新しいパーティションに移動する結果、<code class="literal">s0</code> には <code class="literal">YEAR(dob)</code> が 1960 より小さいレコードのみが含まれ、<code class="literal">s1</code> には <code class="literal">YEAR(dob)</code> が 1960 以上で 1970 より小さい行が含まれます。 
      </p><p>
        <code class="literal">REORGANIZE PARTITION</code> 句を使用して、隣接するパーティションをマージすることもできます。 次に示すように、前のステートメントの <code class="literal">members</code> テーブルへの影響を元に戻すことができます: 
      </p><pre class="programlisting">ALTER TABLE members REORGANIZE PARTITION s0,s1 INTO (
    PARTITION p0 VALUES LESS THAN (1970)
);
</pre><p>
        <code class="literal">REORGANIZE PARTITION</code> を使用してパーティションを分割またはマージしてもデータは失われません。 上記のステートメントを実行すると、MySQL はパーティション <code class="literal">s0</code> および <code class="literal">s1</code> に格納されていたすべてのレコードをパーティション <code class="literal">p0</code> に移動します。 
      </p><p>
        <code class="literal">REORGANIZE PARTITION</code> の一般的な構文を次に示します。
      </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em>
    REORGANIZE PARTITION <em class="replaceable"><code>partition_list</code></em>
    INTO (<em class="replaceable"><code>partition_definitions</code></em>);
</pre><p>
        ここで、<em class="replaceable"><code>tbl_name</code></em> はパーティションテーブルの名前で、<em class="replaceable"><code>partition_list</code></em> は変更する既存のパーティションの名前のカンマ区切りリストです。<em class="replaceable"><code>partition_definitions</code></em> は、新しいパーティション定義のカンマ区切りリストで、<code class="literal">CREATE TABLE</code> で使用される <em class="replaceable"><code>partition_definitions</code></em> リストと同じルールに従います。 <code class="literal">REORGANIZE PARTITION</code> を使用している場合、複数のパーティションを 1 つにマージしたり、1 つのパーティションを複数のパーティションに分割したりすることは制限されません。 たとえば、次のように、<code class="literal">members</code> テーブルの 4 つのパーティションをすべて 2 つに再編成できます: 
      </p><pre class="programlisting">ALTER TABLE members REORGANIZE PARTITION p0,p1,p2,p3 INTO (
    PARTITION m0 VALUES LESS THAN (1980),
    PARTITION m1 VALUES LESS THAN (2000)
);
</pre><p>
        <code class="literal">LIST</code> によってパーティション化されたテーブルで <code class="literal">REORGANIZE PARTITION</code> を使用することもできます。 リストによってパーティション化された <code class="literal">tt</code> テーブルに新しいパーティションを追加する操作が、既存のパーティションのいずれかの値リストにすでに存在する値が新しいパーティションに含まれていることが原因で失敗する問題に戻ります。 これは、競合しない値のみが含まれるパーティションを追加してから、新しいパーティションと既存のものを再編成して既存のものに格納されていた値が新しいものに移動するようにすることで、対処できます。 
      </p><pre class="programlisting">ALTER TABLE tt ADD PARTITION (PARTITION np VALUES IN (4, 8));
ALTER TABLE tt REORGANIZE PARTITION p1,np INTO (
    PARTITION p1 VALUES IN (6, 18),
    PARTITION np VALUES in (4, 8, 12)
);
</pre><p>
        <code class="literal">RANGE</code> または <code class="literal">LIST</code> によってパーティション化されたテーブルをパーティション化し直すために <code class="literal">ALTER TABLE ... REORGANIZE PARTITION</code> を使用するときに注意すべき、いくつかの重要点を次に示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            新しいパーティション化スキームの決定に使用される <code class="literal">PARTITION</code> オプションは、<code class="literal">CREATE TABLE</code> ステートメントで使用されるものと同じルールに従います。
          </p><p>
            新しい <code class="literal">RANGE</code> パーティション化スキームには、重複する範囲を含めることはできません。新しい <code class="literal">LIST</code> パーティション化スキームには、重複する値セットを含めることはできません。
          </p></li><li class="listitem"><p>
            <em class="replaceable"><code>partition_definitions</code></em> リストのパーティションの組み合わせは、<em class="replaceable"><code>partition_list</code></em> に指定されたパーティションの組み合わせの範囲または値セット全体と同じであるべきです。
          </p><p>
            たとえば、パーティション <code class="literal">p1</code> と <code class="literal">p2</code> は、このセクションの例として使用される <code class="literal">members</code> テーブルの 1980 年から 1999 年までをカバーします。 これら 2 つのパーティションの再編成では、全体的に同じ年の範囲をカバーする必要があります。 
          </p></li><li class="listitem"><p>
            <code class="literal">RANGE</code> によってパーティション化されたテーブルの場合、再編成できるのは隣接するパーティションのみで、レンジパーティションはスキップできません。
          </p><p>
            たとえば、1970 年より前の年は <code class="literal">p0</code> でカバーされ、1990 年から 1999 年までの年は <code class="literal">p2</code> でカバーされるため、<code class="literal">ALTER TABLE members REORGANIZE PARTITION p0,p2 INTO ...</code> で始まるステートメントを使用して <code class="literal">members</code> テーブルの例を再編成することはできませんでした。そのため、これらは隣接するパーティションではありません。 (この場合、パーティション <code class="literal">p1</code> はスキップできません。) 
          </p></li><li class="listitem"><p>
            <code class="literal">REORGANIZE PARTITION</code> を使用して、テーブルで使用されるパーティション化のタイプを変更することはできません (たとえば、<code class="literal">RANGE</code> パーティションを <code class="literal">HASH</code> パーティションに変更したり、その逆を行うことはできません)。 このステートメントを使用してパーティション化式またはカラムを変更することもできません。 テーブルを削除および再作成せずにこれらのタスクのいずれかを実行するには、次に示すように <code class="literal">ALTER TABLE ... PARTITION BY ...</code> を使用できます: 
          </p><pre class="programlisting">ALTER TABLE members
    PARTITION BY HASH( YEAR(dob) )
    PARTITIONS 8;
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-management-hash-key"></a>24.3.2 HASH および KEY パーティションの管理</h3></div></div></div><a class="indexterm" name="idm45807909885552"></a><a class="indexterm" name="idm45807909883408"></a><a class="indexterm" name="idm45807909881328"></a><a class="indexterm" name="idm45807909879216"></a><p>
        ハッシュまたはキーによってパーティション化されたテーブルは、パーティショニングセットアップで変更に関して互いによく似ていますが、範囲またはリストによってパーティション化されたテーブルとはいくつかの点で異なります。 このため、このセクションではハッシュまたはキーによってパーティション化されたテーブルの変更についてのみ取り上げます。 範囲またはリストによってパーティション化されたテーブルのパーティションを追加および削除することについては、<a class="xref" href="partitioning.html#partitioning-management-range-list" title="24.3.1 RANGE および LIST パーティションの管理">セクション24.3.1「RANGE および LIST パーティションの管理」</a>を参照してください。 
      </p><p>
        <code class="literal">HASH</code> または <code class="literal">KEY</code> によってパーティション化されたテーブルから、<code class="literal">RANGE</code> または <code class="literal">LIST</code> によってパーティション化されたテーブルと同じ方法でパーティションを削除することはできません。 ただし、<code class="literal">ALTER TABLE ... COALESCE PARTITION</code> を使用して <code class="literal">HASH</code> または <code class="literal">KEY</code> パーティションをマージできます。 クライアントに関するデータを含む <code class="literal">clients</code> テーブルが、次に示すように作成された 12 個のパーティションに分割されているとします: 
      </p><pre class="programlisting">CREATE TABLE clients (
    id INT,
    fname VARCHAR(30),
    lname VARCHAR(30),
    signed DATE
)
PARTITION BY HASH( MONTH(signed) )
PARTITIONS 12;
</pre><p>
        パーティション数を 12 から 8 に減らすには、次の <code class="literal">ALTER TABLE</code> ステートメントを実行します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE clients COALESCE PARTITION 4;</code></strong>
Query OK, 0 rows affected (0.02 sec)
</pre><p>
        <code class="literal">COALESCE</code> は、<code class="literal">HASH</code>、<code class="literal">KEY</code>、<code class="literal">LINEAR HASH</code>、または <code class="literal">LINEAR KEY</code> によってパーティション化されたテーブルで同等に適切に動作します。 次の例は前の例と似ていますが、テーブルが <code class="literal">LINEAR KEY</code> によってパーティション化されている点のみが異なります。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE clients_lk (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT,</code></strong>
    -&gt;     <strong class="userinput"><code>fname VARCHAR(30),</code></strong>
    -&gt;     <strong class="userinput"><code>lname VARCHAR(30),</code></strong>
    -&gt;     <strong class="userinput"><code>signed DATE</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY LINEAR KEY(signed)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITIONS 12;</code></strong>
Query OK, 0 rows affected (0.03 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE clients_lk COALESCE PARTITION 4;</code></strong>
Query OK, 0 rows affected (0.06 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
        <code class="literal">COALESCE PARTITION</code> のあとの数値は、残りにマージするパーティションの数です。つまり、テーブルから削除するパーティションの数です。
      </p><p>
        テーブルにあるよりも多くのパーティションを削除しようとすると、次のようなエラーが発生します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE clients COALESCE PARTITION 18;</code></strong>
ERROR 1478 (HY000): Cannot remove all partitions, use DROP TABLE instead
</pre><p>
        <code class="literal">clients</code> テーブルのパーティション数を 12 から 18 に増やすには、次に示すように <code class="literal">ALTER TABLE ... ADD PARTITION</code> を使用します:
      </p><pre class="programlisting">ALTER TABLE clients ADD PARTITION PARTITIONS 6;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-management-exchange"></a>24.3.3 パーティションとサブパーティションをテーブルと交換する</h3></div></div></div><p>
        MySQL 8.0 では、<code class="literal">ALTER TABLE <em class="replaceable"><code>pt</code></em> EXCHANGE PARTITION <em class="replaceable"><code>p</code></em> WITH TABLE <em class="replaceable"><code>nt</code></em></code> を使用して、テーブルパーティションまたはサブパーティションをテーブルと交換できます。ここで、<em class="replaceable"><code>pt</code></em> はパーティション化されたテーブル、<em class="replaceable"><code>p</code></em> はパーティション化されていないテーブル <em class="replaceable"><code>nt</code></em> と交換する <em class="replaceable"><code>pt</code></em> のパーティションまたはサブパーティションです (次の記述が true である場合)。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            テーブル <em class="replaceable"><code>nt</code></em> 自体はパーティション化されていない。
          </p></li><li class="listitem"><p>
            テーブル <em class="replaceable"><code>nt</code></em> は一時テーブルではない。
          </p></li><li class="listitem"><p>
            テーブル <em class="replaceable"><code>pt</code></em> および <em class="replaceable"><code>nt</code></em> の構造はそれ以外の点で同じである。
          </p></li><li class="listitem"><p>
            テーブル <code class="literal">nt</code> は外部キー参照を含まず、ほかのどのテーブルも <code class="literal">nt</code> を参照する外部キーを持たない。
          </p></li><li class="listitem"><p>
            <em class="replaceable"><code>nt</code></em> 内に <em class="replaceable"><code>p</code></em> のパーティション定義の境界の外に存在する行がない。 この条件は、<code class="literal">WITHOUT VALIDATION</code> が使用されている場合は適用されません。 
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> テーブルの場合、両方のテーブルで同じ行形式が使用されます。 <code class="literal">InnoDB</code> テーブルの行形式を確認するには、<code class="literal">INFORMATION_SCHEMA.INNODB_TABLES</code> をクエリーします。 
          </p></li><li class="listitem"><p>
            <code class="literal">nt</code> には、<code class="literal">DATA DIRECTORY</code> オプションを使用するパーティションはありません。 この制限は、MySQL 8.0.14 以降の <code class="literal">InnoDB</code> テーブルではなくなりました。 
          </p></li></ol></div><p>
        <code class="literal">ALTER TABLE</code> ステートメントに通常必要な <code class="literal">ALTER</code>、<code class="literal">INSERT</code>、および <code class="literal">CREATE</code> 権限に加えて、<code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> を実行するための <code class="literal">DROP</code> 権限が必要です。
      </p><p>
        <code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> の次の影響も考慮してください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> を実行しても、パーティション化されたテーブルまたは交換されるテーブルに対するトリガーは呼び出されません。
          </p></li><li class="listitem"><p>
            交換されるテーブル内の <code class="literal">AUTO_INCREMENT</code> カラムがリセットされます。
          </p></li><li class="listitem"><p>
            <code class="literal">IGNORE</code> キーワードは、<code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> と一緒に使用された場合、効果を持つません。
          </p></li></ul></div><p>
        <code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> の構文を次に示します。ここで、<em class="replaceable"><code>pt</code></em> はパーティションテーブル、<em class="replaceable"><code>p</code></em> は交換されるパーティション (またはサブパーティション)、<em class="replaceable"><code>nt</code></em> は <em class="replaceable"><code>p</code></em> と交換される非パーティションテーブルです:
      </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>pt</code></em>
    EXCHANGE PARTITION <em class="replaceable"><code>p</code></em>
    WITH TABLE <em class="replaceable"><code>nt</code></em>;
</pre><p>
        オプションで、<code class="literal">WITH VALIDATION</code> または <code class="literal">WITHOUT VALIDATION</code> を追加できます。 <code class="literal">WITHOUT VALIDATION</code> が指定されている場合、<code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> 操作では、パーティションを非パーティションテーブルと交換するときに行ごとの検証は実行されず、データベース管理者は行がパーティション定義の境界内にあることを確認する責任を負うことができます。 <code class="literal">WITH VALIDATION</code> がデフォルトです。 
      </p><p>
        単一 <code class="literal">ALTER TABLE EXCHANGE PARTITION</code> ステートメントでは、1 つのパーティションまたはサブパーティションのみを 1 つのパーティション化されていないテーブルのみと交換できます。 複数のパーティションまたはサブパーティションを交換するには、複数の <code class="literal">ALTER TABLE EXCHANGE PARTITION</code> ステートメントを使用してください。 <code class="literal">EXCHANGE PARTITION</code> は、ほかの <code class="literal">ALTER TABLE</code> オプションと組み合わせることはできません。 パーティション化されたテーブルによって使用されるパーティショニングおよび (該当する場合) サブパーティショニングには、MySQL 8.0 でサポートされる任意のタイプを選択できます。 
      </p><h4><a name="idm45807909787632"></a>パーティションをパーティション化されていないテーブルと交換する</h4><p>
        次の SQL ステートメントを使用して、パーティション化されたテーブル <code class="literal">e</code> が作成および移入されているとします。
      </p><pre class="programlisting">CREATE TABLE e (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30)
)
    PARTITION BY RANGE (id) (
        PARTITION p0 VALUES LESS THAN (50),
        PARTITION p1 VALUES LESS THAN (100),
        PARTITION p2 VALUES LESS THAN (150),
        PARTITION p3 VALUES LESS THAN (MAXVALUE)
);

INSERT INTO e VALUES
    (1669, "Jim", "Smith"),
    (337, "Mary", "Jones"),
    (16, "Frank", "White"),
    (2005, "Linda", "Black");
</pre><p>
        ここで、<code class="literal">e2</code> という名前の、<code class="literal">e</code> のパーティション化されていないコピーを作成します。 これは、<span class="command"><strong>mysql</strong></span> クライアントを使用して次のように行うことができます。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE e2 LIKE e;</code></strong>
Query OK, 0 rows affected (0.04 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE e2 REMOVE PARTITIONING;</code></strong>
Query OK, 0 rows affected (0.07 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
        テーブル <code class="literal">e</code> のどのパーティションに行が含まれるかは、次のように <code class="literal">INFORMATION_SCHEMA.PARTITIONS</code> テーブルを照会することで確認できます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME, TABLE_ROWS</code></strong>
           <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
           <strong class="userinput"><code>WHERE TABLE_NAME = 'e';</code></strong>
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          1 |
| p1             |          0 |
| p2             |          0 |
| p3             |          3 |
+----------------+------------+
2 rows in set (0.00 sec)
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          パーティション化された <code class="literal">InnoDB</code> テーブルの場合、<code class="literal">INFORMATION_SCHEMA.PARTITIONS</code> テーブルの <code class="literal">TABLE_ROWS</code> カラムに示される行数は、SQL 最適化で使用される見積もり値であり、常に正確とはかぎりません。
        </p></div><p>
        テーブル <code class="literal">e</code> のパーティション <code class="literal">p0</code> をテーブル <code class="literal">e2</code> と交換するには、次に示すように <code class="literal">ALTER TABLE</code> を使用できます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;</code></strong>
Query OK, 0 rows affected (0.04 sec)
</pre><p>
        より正確に言うと、ここで発行したステートメントによって、パーティションで見つかる行がテーブルで見つかるものと交換されます。 これがどのように行われたかは、前のように <code class="literal">INFORMATION_SCHEMA.PARTITIONS</code> テーブルを照会することで観察できます。 パーティション <code class="literal">p0</code> で以前は見つかったテーブル行が存在しなくなっています。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME, TABLE_ROWS</code></strong>
           <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
           <strong class="userinput"><code>WHERE TABLE_NAME = 'e';</code></strong>
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          0 |
| p1             |          0 |
| p2             |          0 |
| p3             |          3 |
+----------------+------------+
4 rows in set (0.00 sec)
</pre><p>
        テーブル <code class="literal">e2</code> を照会すると、<span class="quote">「<span class="quote">見つからない</span>」</span>行がそこで見つかります。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM e2;</code></strong>
+----+-------+-------+
| id | fname | lname |
+----+-------+-------+
| 16 | Frank | White |
+----+-------+-------+
1 row in set (0.00 sec)
</pre><p>
        パーティションと交換されるテーブルは、必ずしも空である必要はありません。 これを示すために、まずテーブル <code class="literal">e</code> に新しい行を挿入し、50 未満の <code class="literal">id</code> カラム値を選択してこの行がパーティション <code class="literal">p0</code> に格納されていることを確認し、<code class="literal">PARTITIONS</code> テーブルをクエリーしてこれを後で検証します: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO e VALUES (41, "Michael", "Green");</code></strong>
Query OK, 1 row affected (0.05 sec)

mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME, TABLE_ROWS</code></strong>
           <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
           <strong class="userinput"><code>WHERE TABLE_NAME = 'e';            </code></strong>
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          1 |
| p1             |          0 |
| p2             |          0 |
| p3             |          3 |
+----------------+------------+
4 rows in set (0.00 sec)
</pre><p>
        ここで、前と同じ <code class="literal">ALTER TABLE</code> ステートメントを使用して、ふたたびパーティション <code class="literal">p0</code> をテーブル <code class="literal">e2</code> と交換します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;</code></strong>
Query OK, 0 rows affected (0.28 sec)
</pre><p>
        次のクエリーの出力は、<code class="literal">ALTER TABLE</code> ステートメントを発行する前に、パーティション <code class="literal">p0</code> に格納されていたテーブル行およびテーブル <code class="literal">e2</code> に格納されていたテーブル行の配置が切り替わったことを示しています。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM e;</code></strong>
+------+-------+-------+
| id   | fname | lname |
+------+-------+-------+
|   16 | Frank | White |
| 1669 | Jim   | Smith |
|  337 | Mary  | Jones |
| 2005 | Linda | Black |
+------+-------+-------+
4 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME, TABLE_ROWS</code></strong>
           <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
           <strong class="userinput"><code>WHERE TABLE_NAME = 'e';</code></strong>
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          1 |
| p1             |          0 |
| p2             |          0 |
| p3             |          3 |
+----------------+------------+
4 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM e2;</code></strong>
+----+---------+-------+
| id | fname   | lname |
+----+---------+-------+
| 41 | Michael | Green |
+----+---------+-------+
1 row in set (0.00 sec)
</pre><h4><a name="idm45807909731296"></a>一致しない行</h4><p>
        <code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> ステートメントを発行する前にパーティション化されていないテーブルで見つかる行は、それらがターゲットパーティションに格納されるために必要な条件を満たしている必要があり、そうでない場合はステートメントが失敗することを覚えておいてください。 これがどのように発生するかを確認するために、まずテーブル<code class="literal">e</code> のパーティション <code class="literal">p0</code> のパーティション定義の境界外の行を、<code class="literal">e2</code> に挿入します。 たとえば、<code class="literal">id</code> カラム値が大きすぎる行を挿入してから、テーブルをパーティションとふたたび交換してみてください。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO e2 VALUES (51, "Ellen", "McDonald");</code></strong>
Query OK, 1 row affected (0.08 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;</code></strong>
<span class="errortext">ERROR 1707 (HY000): Found row that does not match the partition</span>
</pre><p>
        <code class="literal">WITHOUT VALIDATION</code> オプションのみがこの操作の成功を許可します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2 WITHOUT VALIDATION;</code></strong>
Query OK, 0 rows affected (0.02 sec)
</pre><p>
        パーティション定義と一致しない行を含むテーブルとパーティションを交換する場合、データベース管理者は、<code class="literal">REPAIR TABLE</code> または <code class="literal">ALTER TABLE ... REPAIR PARTITION</code> を使用して実行できる不一致の行を修正する必要があります。
      </p><h4><a name="idm45807909716048"></a>行ごとの検証なしでのパーティションの交換</h4><p>
        多数の行を含むテーブルとパーティションを交換するときに時間のかかる検証を回避するために、<code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> ステートメントに <code class="literal">WITHOUT VALIDATION</code> を追加することで、行ごとの検証ステップをスキップできます。
      </p><p>
        次の例では、パーティションを非パーティションテーブルと交換する際の実行時間の違いを、検証ありおよび検証なしで比較します。 パーティションテーブル (テーブル <code class="literal">e</code>) には、それぞれ 100 万行の 2 つのパーティションが含まれます。 テーブル e の p0 の行は削除され、p0 は 100 万行のパーティション化されていないテーブルと交換されます。 <code class="literal">WITH VALIDATION</code> 操作には 0.74 秒かかります。 比較すると、<code class="literal">WITHOUT VALIDATION</code> 操作には 0.01 秒かかります。 
      </p><pre class="programlisting"># Create a partitioned table with 1 million rows in each partition

CREATE TABLE e (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30)
)
    PARTITION BY RANGE (id) (
        PARTITION p0 VALUES LESS THAN (1000001),
        PARTITION p1 VALUES LESS THAN (2000001),
);

mysql&gt; SELECT COUNT(*) FROM e;
| COUNT(*) |
+----------+
|  2000000 |
+----------+
1 row in set (0.27 sec)

# View the rows in each partition

SELECT PARTITION_NAME, TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e';
+----------------+-------------+
| PARTITION_NAME | TABLE_ROWS  |
+----------------+-------------+
| p0             |     1000000 |
| p1             |     1000000 |
+----------------+-------------+
2 rows in set (0.00 sec)

# Create a nonpartitioned table of the same structure and populate it with 1 million rows

CREATE TABLE e2 (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30)
);

mysql&gt; SELECT COUNT(*) FROM e2;
+----------+
| COUNT(*) |
+----------+
|  1000000 |
+----------+
1 row in set (0.24 sec)

# Create another nonpartitioned table of the same structure and populate it with 1 million rows

CREATE TABLE e3 (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30)
);

mysql&gt; SELECT COUNT(*) FROM e3;
+----------+
| COUNT(*) |
+----------+
|  1000000 |
+----------+
1 row in set (0.25 sec)

# Drop the rows from p0 of table e

mysql&gt; DELETE FROM e WHERE id &lt; 1000001;
Query OK, 1000000 rows affected (5.55 sec)

# Confirm that there are no rows in partition p0

mysql&gt; SELECT PARTITION_NAME, TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          0 |
| p1             |    1000000 |
+----------------+------------+
2 rows in set (0.00 sec)

# Exchange partition p0 of table e with the table e2 'WITH VALIDATION'

mysql&gt; ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2 WITH VALIDATION;
Query OK, 0 rows affected (0.74 sec)

# Confirm that the partition was exchanged with table e2

mysql&gt; SELECT PARTITION_NAME, TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |    1000000 |
| p1             |    1000000 |
+----------------+------------+
2 rows in set (0.00 sec)

# Once again, drop the rows from p0 of table e

mysql&gt; DELETE FROM e WHERE id &lt; 1000001;
Query OK, 1000000 rows affected (5.55 sec)

# Confirm that there are no rows in partition p0

mysql&gt; SELECT PARTITION_NAME, TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          0 |
| p1             |    1000000 |
+----------------+------------+
2 rows in set (0.00 sec)

# Exchange partition p0 of table e with the table e3 'WITHOUT VALIDATION'

mysql&gt; ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e3 WITHOUT VALIDATION;
Query OK, 0 rows affected (0.01 sec)

# Confirm that the partition was exchanged with table e3

mysql&gt; SELECT PARTITION_NAME, TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |    1000000 |
| p1             |    1000000 |
+----------------+------------+
2 rows in set (0.00 sec)
      </pre><p>
        パーティション定義と一致しない行を含むテーブルとパーティションを交換する場合、データベース管理者は、<code class="literal">REPAIR TABLE</code> または <code class="literal">ALTER TABLE ... REPAIR PARTITION</code> を使用して実行できる不一致の行を修正する必要があります。
      </p><h4><a name="idm45807909698896"></a>サブパーティションをパーティション化されていないテーブルと交換する</h4><p>
        <code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> ステートメントを使用して、サブパーティション化されたテーブルのサブパーティション (<a class="xref" href="partitioning.html#partitioning-subpartitions" title="24.2.6 サブパーティショニング">セクション24.2.6「サブパーティショニング」</a>を参照してください) をパーティション化されていないテーブルと交換することもできます。 次の例では、まず <code class="literal">RANGE</code> によってパーティション化され、<code class="literal">KEY</code> によってサブパーティション化されたテーブル <code class="literal">es</code> を作成し、テーブル <code class="literal">e</code> と同様にこのテーブルに移入してから、このテーブルの空のパーティション化されていないコピー <code class="literal">es2</code> を作成します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE es (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>fname VARCHAR(30),</code></strong>
    -&gt;     <strong class="userinput"><code>lname VARCHAR(30)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION BY RANGE (id)</code></strong>
    -&gt;     <strong class="userinput"><code>SUBPARTITION BY KEY (lname)</code></strong>
    -&gt;     <strong class="userinput"><code>SUBPARTITIONS 2 (</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (50),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (100),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (150),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (MAXVALUE)</code></strong>
    -&gt;     <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (2.76 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO es VALUES</code></strong>
    -&gt;     <strong class="userinput"><code>(1669, "Jim", "Smith"),</code></strong>
    -&gt;     <strong class="userinput"><code>(337, "Mary", "Jones"),</code></strong>
    -&gt;     <strong class="userinput"><code>(16, "Frank", "White"),</code></strong>
    -&gt;     <strong class="userinput"><code>(2005, "Linda", "Black");</code></strong>
Query OK, 4 rows affected (0.04 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>CREATE TABLE es2 LIKE es;</code></strong>
Query OK, 0 rows affected (1.27 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE es2 REMOVE PARTITIONING;</code></strong>
Query OK, 0 rows affected (0.70 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
        テーブル <code class="literal">es</code> の作成時にサブパーティションに明示的に名前を付けませんでしたが、次に示すように、<code class="literal">INFORMATION_SCHEMA</code> から <code class="literal">PARTITIONS</code> テーブルの <code class="literal">SUBPARTITION_NAME</code> カラムを含めて、生成された名前を取得できます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME, SUBPARTITION_NAME, TABLE_ROWS</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'es';</code></strong>
+----------------+-------------------+------------+
| PARTITION_NAME | SUBPARTITION_NAME | TABLE_ROWS |
+----------------+-------------------+------------+
| p0             | p0sp0             |          1 |
| p0             | p0sp1             |          0 |
| p1             | p1sp0             |          0 |
| p1             | p1sp1             |          0 |
| p2             | p2sp0             |          0 |
| p2             | p2sp1             |          0 |
| p3             | p3sp0             |          3 |
| p3             | p3sp1             |          0 |
+----------------+-------------------+------------+
8 rows in set (0.00 sec)
</pre><p>
        次の <code class="literal">ALTER TABLE</code> ステートメントは、テーブル <code class="literal">es</code> のサブパーティション <code class="literal">p3sp0</code> をパーティション化されていないテーブル <code class="literal">es2</code> と交換します:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE es EXCHANGE PARTITION p3sp0 WITH TABLE es2;</code></strong>
Query OK, 0 rows affected (0.29 sec)
</pre><p>
        次のクエリーを発行することで、それらの行が交換されたことを確認できます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME, SUBPARTITION_NAME, TABLE_ROWS</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'es';</code></strong>
+----------------+-------------------+------------+
| PARTITION_NAME | SUBPARTITION_NAME | TABLE_ROWS |
+----------------+-------------------+------------+
| p0             | p0sp0             |          1 |
| p0             | p0sp1             |          0 |
| p1             | p1sp0             |          0 |
| p1             | p1sp1             |          0 |
| p2             | p2sp0             |          0 |
| p2             | p2sp1             |          0 |
| p3             | p3sp0             |          0 |
| p3             | p3sp1             |          0 |
+----------------+-------------------+------------+
8 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM es2;</code></strong>
+------+-------+-------+
| id   | fname | lname |
+------+-------+-------+
| 1669 | Jim   | Smith |
|  337 | Mary  | Jones |
| 2005 | Linda | Black |
+------+-------+-------+
3 rows in set (0.00 sec)
</pre><p>
        テーブルがサブパーティション化されている場合、次に示すように、パーティション化されていないテーブルと交換できるのは、テーブルのパーティション全体ではなくサブパーティションのみです。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE es EXCHANGE PARTITION p3 WITH TABLE es2;</code></strong>
<span class="errortext">ERROR 1704 (HY000): Subpartitioned table, use subpartition instead of partition</span>
</pre><p>
        テーブル構造は厳密に比較されます。パーティションテーブルと非パーティションテーブルのカラムおよびインデックスの数、順序、名前およびタイプは正確に一致する必要があります。 また、両方のテーブルが同じストレージエンジンを使用している必要があります。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE es3 LIKE e;</code></strong>
Query OK, 0 rows affected (1.31 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE es3 REMOVE PARTITIONING;</code></strong>
Query OK, 0 rows affected (0.53 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE es3\G</code></strong>
*************************** 1. row ***************************
       Table: es3
Create Table: CREATE TABLE `es3` (
  `id` int(11) NOT NULL,
  `fname` varchar(30) DEFAULT NULL,
  `lname` varchar(30) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE es3 ENGINE = MyISAM;</code></strong>
Query OK, 0 rows affected (0.15 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>ALTER TABLE es EXCHANGE PARTITION p3sp0 WITH TABLE es3;</code></strong>
<span class="errortext">ERROR 1497 (HY000): The mix of handlers in the partitions is not allowed in this version of MySQL</span>
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-maintenance"></a>24.3.4 パーティションの保守</h3></div></div></div><a class="indexterm" name="idm45807909643952"></a><a class="indexterm" name="idm45807909641808"></a><a class="indexterm" name="idm45807909639776"></a><a class="indexterm" name="idm45807909637744"></a><a class="indexterm" name="idm45807909635712"></a><a class="indexterm" name="idm45807909633648"></a><a class="indexterm" name="idm45807909631584"></a><a class="indexterm" name="idm45807909629520"></a><p>
        このような目的の SQL ステートメントを使用して、パーティションテーブルに対して多数のテーブルおよびパーティションメンテナンスタスクを実行できます。
      </p><p>
        パーティション化されたテーブルのテーブル保守は、パーティション化されたテーブルでサポートされる <code class="literal">CHECK TABLE</code>、<code class="literal">OPTIMIZE TABLE</code>、<code class="literal">ANALYZE TABLE</code>、および <code class="literal">REPAIR TABLE</code> ステートメントを使用して実現できます。
      </p><p>
        次のリストで説明しているように、<code class="literal">ALTER TABLE</code> へのいくつかの拡張を使用して、1 つ以上のパーティションに対してこのタイプの操作を直接実行できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>パーティションの再構築. </b>
              パーティションを再構築します。これは、パーティションに格納されているすべてのレコードを削除してからそれらを再度挿入することと同じ効果があります。 これはデフラグに役立つことがあります。 
            </p><p>
            例:
          </p><pre class="programlisting">ALTER TABLE t1 REBUILD PARTITION p0, p1;
</pre></li><li class="listitem"><p><b>パーティションの最適化. </b>
              パーティションから多数の行を削除した場合、または可変長行を持つ (つまり、<code class="literal">VARCHAR</code>、<code class="literal">BLOB</code>、または <code class="literal">TEXT</code> カラムを持つ) パーティション化されたテーブルに多くの変更を行なった場合は、<code class="literal">ALTER TABLE ... OPTIMIZE PARTITION</code> を使用して、未使用領域を解放したりパーティションデータファイルをデフラグしたりできます。
            </p><p>
            例:
          </p><pre class="programlisting">ALTER TABLE t1 OPTIMIZE PARTITION p0, p1;
</pre><p>
            指定されたパーティションに <code class="literal">OPTIMIZE PARTITION</code> を使用することは、そのパーティションに <code class="literal">CHECK PARTITION</code>、<code class="literal">ANALYZE PARTITION</code>、および <code class="literal">REPAIR PARTITION</code> を実行することと同等です。
          </p><p>
            <code class="literal">InnoDB</code> を含む一部の MySQL ストレージエンジンは、パーティションごとの最適化をサポートしていません。この場合、<code class="literal">ALTER TABLE ... OPTIMIZE PARTITION</code> はテーブル全体を分析して再構築し、適切な警告が発行されます。 (Bug #11751825、Bug #42822)。この問題を回避するには、代わりに <code class="literal">ALTER TABLE ... REBUILD PARTITION</code> および <code class="literal">ALTER TABLE ... ANALYZE PARTITION</code> を使用してください。 
          </p></li><li class="listitem"><p><b>パーティションの分析. </b>
              これは、パーティションのキー分布を読み取って格納します。
            </p><p>
            例:
          </p><pre class="programlisting">ALTER TABLE t1 ANALYZE PARTITION p3;
</pre></li><li class="listitem"><p><b>パーティションの修復. </b>
              これは、破損したパーティションを修復します。
            </p><p>
            例:
          </p><pre class="programlisting">ALTER TABLE t1 REPAIR PARTITION p0,p1;
</pre><p>
            通常、パーティションに重複キーエラーが含まれている場合、<code class="literal">REPAIR PARTITION</code> は失敗します。 このオプションを指定して <code class="literal">ALTER IGNORE TABLE</code> を使用できます。この場合、重複キーが存在するために移動できないすべての行がパーティションから削除されます (Bug #16900947)。 
          </p></li><li class="listitem"><p><b>パーティションのチェック. </b>
              パーティション化されていないテーブルで <code class="literal">CHECK TABLE</code> を使用できるのとほぼ同様に、パーティションのエラーをチェックできます。
            </p><p>
            例:
          </p><pre class="programlisting">ALTER TABLE trb3 CHECK PARTITION p1;
</pre><p>
            このステートメントは、テーブル <code class="literal">t1</code> のパーティション <code class="literal">p1</code> のデータまたはインデックスが破損しているかどうかを示します。 その場合は、<code class="literal">ALTER TABLE ... REPAIR PARTITION</code> を使用してパーティションを修復してください。 
          </p><p>
            通常、パーティションに重複キーエラーが含まれている場合、<code class="literal">CHECK PARTITION</code> は失敗します。 このオプションを指定して <code class="literal">ALTER IGNORE TABLE</code> を使用すると、重複キー違反が見つかったパーティション内の各行の内容がステートメントによって返されます。 テーブルのパーティション化式のカラムの値のみがレポートされます。 (Bug #16900947) 
          </p></li></ul></div><p>
        上記のリストの各ステートメントでは、パーティション名のリストの代わりにキーワード <code class="literal">ALL</code> もサポートされます。 <code class="literal">ALL</code> を使用すると、テーブル内のすべてのパーティションにステートメントが作用します。 
      </p><p>
        <code class="literal">ALTER TABLE ... TRUNCATE PARTITION</code> を使用してパーティションを切り捨てることもできます。 このステートメントは、<code class="literal">TRUNCATE TABLE</code> がテーブルからすべての行を削除するのとほぼ同様に、1 つ以上のパーティションからすべての行を削除するために使用できます。 
      </p><p>
        <code class="literal">ALTER TABLE ... TRUNCATE PARTITION ALL</code> はテーブル内のすべてのパーティションを切り捨てます。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-info"></a>24.3.5 パーティションに関する情報を取得する</h3></div></div></div><a class="indexterm" name="idm45807909570432"></a><a class="indexterm" name="idm45807909568928"></a><a class="indexterm" name="idm45807909567504"></a><a class="indexterm" name="idm45807909565968"></a><p>
        このセクションでは、既存のパーティションに関する情報を取得する方法 (いくつかの方法が可能) について説明します。 そのような情報を取得する方法には次のものが含まれます。 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">SHOW CREATE TABLE</code> ステートメントを使用して、パーティション化されたテーブルの作成に使用されたパーティショニング句を表示する。
          </p></li><li class="listitem"><p>
            <code class="literal">SHOW TABLE STATUS</code> ステートメントを使用して、テーブルがパーティション化されているかどうかを判別する。
          </p></li><li class="listitem"><p>
            <code class="literal">INFORMATION_SCHEMA.PARTITIONS</code> テーブルを照会する。
          </p></li><li class="listitem"><p>
            ステートメント <code class="literal">EXPLAIN SELECT</code> を使用して、特定の <code class="literal">SELECT</code> で使用されているパーティションを確認します。
          </p></li></ul></div><p>
        MySQL 8.0.16 から、パーティション化されたテーブルに対して挿入、削除、または更新が行われると、バイナリログには、パーティションに関する情報と、行イベントが発生したサブパーティション (存在する場合) に関する情報が記録されます。 関連するテーブルが同じであっても、別のパーティションまたはサブパーティションで行われる変更に対して新しい行イベントが作成されます。 したがって、トランザクションに 3 つのパーティションまたはサブパーティションが含まれる場合は、3 つの行イベントが生成されます。 更新イベントの場合、ビフォアイメージとアフターイメージの両方のパーティション情報が記録されます。 <span class="command"><strong>mysqlbinlog</strong></span> を使用してバイナリログを表示するときに <code class="literal">-v</code> または <code class="literal">--verbose</code> オプションを指定すると、パーティション情報が表示されます。 パーティション情報は、行ベースのロギングが使用中 (<code class="literal">binlog_format=ROW</code>) の場合にのみ記録されます。 
      </p><p>
        この章のほかの場所でも説明しているように、<code class="literal">SHOW CREATE TABLE</code> の出力にはパーティション化されたテーブルの作成に使用された <code class="literal">PARTITION BY</code> 句が含まれます。 例: 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE trb3\G</code></strong>
*************************** 1. row ***************************
       Table: trb3
Create Table: CREATE TABLE `trb3` (
  `id` int(11) DEFAULT NULL,
  `name` varchar(50) DEFAULT NULL,
  `purchased` date DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
/*!50100 PARTITION BY RANGE (YEAR(purchased))
(PARTITION p0 VALUES LESS THAN (1990) ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (1995) ENGINE = InnoDB,
 PARTITION p2 VALUES LESS THAN (2000) ENGINE = InnoDB,
 PARTITION p3 VALUES LESS THAN (2005) ENGINE = InnoDB) */
0 row in set (0.00 sec)
</pre><p>
        パーティション化されたテーブルに対する <code class="literal">SHOW TABLE STATUS</code> の出力は、<code class="literal">Create_options</code> カラムに文字列 <code class="literal">partitioned</code> が含まれることを除いて、パーティション化されていないテーブルの場合と同じです。 <code class="literal">Engine</code> カラムには、テーブルのすべてのパーティションによって使用されるストレージエンジンの名前が含まれます。 (このステートメントについての詳細は、<a class="xref" href="sql-statements.html#show-table-status" title="13.7.7.38 SHOW TABLE STATUS ステートメント">セクション13.7.7.38「SHOW TABLE STATUS ステートメント」</a>を参照してください)。 
      </p><p>
        パーティションに関する情報は、<code class="literal">PARTITIONS</code> テーブルを含む <code class="literal">INFORMATION_SCHEMA</code> からも取得できます。 <a class="xref" href="information-schema.html#information-schema-partitions-table" title="26.21 INFORMATION_SCHEMA PARTITIONS テーブル">セクション26.21「INFORMATION_SCHEMA PARTITIONS テーブル」</a>を参照してください。 
      </p><a class="indexterm" name="idm45807909536000"></a><a class="indexterm" name="idm45807909533856"></a><p>
        <code class="literal">EXPLAIN</code> を使用して、特定の <code class="literal">SELECT</code> クエリーに含まれるパーティションテーブルのパーティションを判別できます。 <code class="literal">EXPLAIN</code> 出力の <code class="literal">partitions</code> カラムには、クエリーによってレコードが照合されるパーティションがリストされます。 
      </p><p>
        テーブル <code class="literal">trb1</code> が作成され、次のように移入されるとします:
      </p><pre class="programlisting">CREATE TABLE trb1 (id INT, name VARCHAR(50), purchased DATE)
    PARTITION BY RANGE(id)
    (
        PARTITION p0 VALUES LESS THAN (3),
        PARTITION p1 VALUES LESS THAN (7),
        PARTITION p2 VALUES LESS THAN (9),
        PARTITION p3 VALUES LESS THAN (11)
    );

INSERT INTO trb1 VALUES
    (1, 'desk organiser', '2003-10-15'),
    (2, 'CD player', '1993-11-05'),
    (3, 'TV set', '1996-03-10'),
    (4, 'bookcase', '1982-01-10'),
    (5, 'exercise bike', '2004-05-09'),
    (6, 'sofa', '1987-06-05'),
    (7, 'popcorn maker', '2001-11-22'),
    (8, 'aquarium', '1992-08-04'),
    (9, 'study desk', '1984-09-16'),
    (10, 'lava lamp', '1998-12-25');
</pre><p>
        <code class="literal">SELECT * FROM trb1;</code> などのクエリーでどのパーティションが使用されるかを次のように確認できます。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM trb1\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: trb1
   partitions: p0,p1,p2,p3
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 10
        Extra: Using filesort
</pre><p>
        この場合、4 つのパーティションがすべて検索されます。 ただし、次のようにパーティショニングキーを使用する制限条件をクエリーに追加すると、一致する値が含まれているパーティションのみがスキャンされることがわかります。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM trb1 WHERE id &lt; 5\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: trb1
   partitions: p0,p1
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 10
        Extra: Using where
</pre><p>
        <code class="literal">EXPLAIN </code> では、使用されるキーおよび使用可能なキーに関する情報も提供されます:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE trb1 ADD PRIMARY KEY (id);</code></strong>
Query OK, 10 rows affected (0.03 sec)
Records: 10  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM trb1 WHERE id &lt; 5\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: trb1
   partitions: p0,p1
         type: range
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 4
          ref: NULL
         rows: 7
        Extra: Using where
</pre><p>
        <code class="literal">EXPLAIN</code> を使用して非パーティションテーブルに対するクエリーを調べる場合、エラーは生成されませんが、<code class="literal">partitions</code> カラムの値は常に <code class="literal">NULL</code> です。
      </p><p>
        <code class="literal">EXPLAIN</code> 出力の <code class="literal">rows</code> カラムには、テーブル内の行の合計数が表示されます。
      </p><p>
        <a class="xref" href="sql-statements.html#explain" title="13.8.2 EXPLAIN ステートメント">セクション13.8.2「EXPLAIN ステートメント」</a>も参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="partitioning-pruning"></a>24.4 パーティションプルーニング</h2></div></div></div><a class="indexterm" name="idm45807909506912"></a><a class="indexterm" name="idm45807909505456"></a><p>
      <span class="firstterm">パーティションプルーニング</span>と呼ばれる最適化は、<span class="quote">「<span class="quote">「一致する値がない可能性があるパーティションをスキャンしません」</span>」</span>と記述できる比較的単純な概念に基づいています。 次のステートメントによってパーティションテーブル <code class="literal">t1</code> が作成されるとします: 
    </p><pre class="programlisting">CREATE TABLE t1 (
    fname VARCHAR(50) NOT NULL,
    lname VARCHAR(50) NOT NULL,
    region_code TINYINT UNSIGNED NOT NULL,
    dob DATE NOT NULL
)
PARTITION BY RANGE( region_code ) (
    PARTITION p0 VALUES LESS THAN (64),
    PARTITION p1 VALUES LESS THAN (128),
    PARTITION p2 VALUES LESS THAN (192),
    PARTITION p3 VALUES LESS THAN MAXVALUE
);
</pre><p>
      次のような <code class="literal">SELECT</code> ステートメントから結果を取得するとします:
    </p><pre class="programlisting">SELECT fname, lname, region_code, dob
    FROM t1
    WHERE region_code &gt; 125 AND region_code &lt; 130;
</pre><p>
      返される必要がある行がパーティション <code class="literal">p0</code> または <code class="literal">p3</code> のいずれにもないことを簡単に確認できます。つまり、一致する行を検索するには、パーティション <code class="literal">p1</code> および <code class="literal">p2</code> でのみ検索が必要です。 検索を制限することで、テーブル内のすべてのパーティションをスキャンするよりも、一致する行の検索にかかる時間と労力を大幅に削減できます。 必要のないパーティションをこのように<span class="quote">「<span class="quote">省く</span>」</span>ことを<span class="firstterm">プルーニング</span>といいます。 オプティマイザがこのクエリーの実行でパーティションプルーニングを使用できるときは、同じカラム定義およびデータが含まれているパーティション化されていないテーブルで同じクエリーを実行するよりも、速度が大幅に向上することがあります。 
    </p><p>
      <code class="literal">WHERE</code> 条件を次の 2 つのケースのいずれかにまとめられるとき、オプティマイザはプルーニングを実行できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal"><em class="replaceable"><code>partition_column</code></em> = <em class="replaceable"><code>constant</code></em></code>
        </p></li><li class="listitem"><p>
          <code class="literal"><em class="replaceable"><code>partition_column</code></em> IN (<em class="replaceable"><code>constant1</code></em>, <em class="replaceable"><code>constant2</code></em>, ..., <em class="replaceable"><code>constantN</code></em>)</code>
        </p></li></ul></div><p>
      最初のケースで、オプティマイザは指定された値についてパーティショニング式を単純に評価し、どのパーティションに値が含まれるかを判別して、このパーティションのみをスキャンします。 多くの場合、この等号を別の算術比較 (<code class="literal">&lt;</code>、<code class="literal">&gt;</code>、<code class="literal">&lt;=</code>、<code class="literal">&gt;=</code>、および <code class="literal">&lt;&gt;</code> を含む) に置き換えることができます。 <code class="literal">WHERE</code> 句で <code class="literal">BETWEEN</code> を使用するクエリーも、パーティションプルーニングの利点を活用できます。 このセクションの後続の例を参照してください。 
    </p><p>
      2 番目のケースで、オプティマイザはリスト内の各値についてパーティショニング式を評価して、一致するパーティションのリストを作成してから、このパーティションリストのパーティションのみをスキャンします。
    </p><p>
      <code class="literal">SELECT</code>、<code class="literal">DELETE</code> および <code class="literal">UPDATE</code> ステートメントでは、パーティションプルーニングがサポートされます。 <code class="literal">INSERT</code> ステートメントは、挿入された行ごとに 1 つのパーティションにのみアクセスします。これは、現在 <code class="literal">EXPLAIN</code> の出力には表示されていませんが、<code class="literal">HASH</code> または <code class="literal">KEY</code> によってパーティション化されたテーブルにも当てはまります。 
    </p><p>
      短い範囲にもプルーニングを適用できます (オプティマイザが同等の値リストに変換できるもの)。 たとえば、前の例では、<code class="literal">WHERE</code> 句を <code class="literal">WHERE region_code IN (126, 127, 128, 129)</code> に変換できます。 次に、オプティマイザは、リスト内の最初の 2 つの値がパーティション <code class="literal">p1</code> にあること、パーティション <code class="literal">p2</code> 内の残りの 2 つの値があること、および他のパーティションに関連する値が含まれていないことを判断できるため、一致する行を検索する必要はありません。 
    </p><p>
      オプティマイザは、<code class="literal">RANGE COLUMNS</code> または <code class="literal">LIST COLUMNS</code> パーティション化を使用するテーブルの複数のカラムに対する前述の型の比較を含む <code class="literal">WHERE</code> 条件のプルーニングも実行できます。
    </p><a class="indexterm" name="idm45807909462080"></a><p>
      このタイプの最適化は、パーティショニング式が同一性や範囲で構成されていてそれを同一性のセットにまとめられるとき、またはパーティショニング式が増減する関係を表すときに適用できます。 パーティショニング式が <code class="literal">YEAR()</code> または <code class="literal">TO_DAYS()</code> 関数を使用するとき、<code class="literal">DATE</code> カラムまたは <code class="literal">DATETIME</code> カラムでパーティション化されるテーブルにプルーニングを適用することもできます。 パーティション化式で <code class="literal">TO_SECONDS()</code> 関数を使用する場合は、このようなテーブルにプルーニングを適用することもできます。 
    </p><p>
      <code class="literal">DATE</code> カラムでパーティション化されたテーブル <code class="literal">t2</code> が、次に示すステートメントを使用して作成されるとします:
    </p><pre class="programlisting">CREATE TABLE t2 (
    fname VARCHAR(50) NOT NULL,
    lname VARCHAR(50) NOT NULL,
    region_code TINYINT UNSIGNED NOT NULL,
    dob DATE NOT NULL
)
PARTITION BY RANGE( YEAR(dob) ) (
    PARTITION d0 VALUES LESS THAN (1970),
    PARTITION d1 VALUES LESS THAN (1975),
    PARTITION d2 VALUES LESS THAN (1980),
    PARTITION d3 VALUES LESS THAN (1985),
    PARTITION d4 VALUES LESS THAN (1990),
    PARTITION d5 VALUES LESS THAN (2000),
    PARTITION d6 VALUES LESS THAN (2005),
    PARTITION d7 VALUES LESS THAN MAXVALUE
);
</pre><p>
      <code class="literal">t2</code> を使用する次のステートメントでは、パーティションプルーニングを使用できます。
    </p><pre class="programlisting">SELECT * FROM t2 WHERE dob = '1982-06-23';

UPDATE t2 SET region_code = 8 WHERE dob BETWEEN '1991-02-15' AND '1997-04-25';

DELETE FROM t2 WHERE dob &gt;= '1984-06-21' AND dob &lt;= '1999-06-21'
</pre><p>
      最後のステートメントの場合、オプティマイザは次のようにも動作できます。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          <span class="emphasis"><em>範囲の下限が含まれるパーティションを見つけます</em></span>。
        </p><p>
          <code class="literal">YEAR('1984-06-21')</code> は値 <code class="literal">1984</code> を返し、それはパーティション <code class="literal">d3</code> に見つかります。
        </p></li><li class="listitem"><p>
          <span class="emphasis"><em>範囲の上限が含まれるパーティションを見つけます</em></span>。
        </p><p>
          <code class="literal">YEAR('1999-06-21')</code> は <code class="literal">1999</code> と評価され、それはパーティション <code class="literal">d5</code> に見つかります。
        </p></li><li class="listitem"><p>
          <span class="emphasis"><em>これらの 2 つのパーティションおよびそれらの間にある可能性のあるパーティションのみをスキャンします</em></span>。
        </p><p>
          この場合、これはパーティション <code class="literal">d3</code>、<code class="literal">d4</code>、および <code class="literal">d5</code> のみがスキャンされることを意味します。 残りのパーティションは安全に無視できます (そして無視されます)。 
        </p></li></ol></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        パーティション化されたテーブルに対するステートメントの <code class="literal">WHERE</code> 条件で参照される無効な <code class="literal">DATE</code> および <code class="literal">DATETIME</code> 値は、<code class="literal">NULL</code> として扱われます。 これは、<code class="literal">SELECT * FROM <em class="replaceable"><code>partitioned_table</code></em> WHERE <em class="replaceable"><code>date_column</code></em> &lt; '2008-12-00'</code> などのクエリーは値を返さないことを意味します (Bug #40972 を参照してください)。 
      </p></div><p>
      ここまで、<code class="literal">RANGE</code> パーティショニングを使用する例のみを見てきましたが、プルーニングはほかのパーティショニングタイプにも適用できます。
    </p><p>
      次に示すテーブル <code class="literal">t3</code> のように、パーティショニング式が増加または減少している <code class="literal">LIST</code> によってパーティション化されたテーブルがあるとします。 (この例では、簡単にするために <code class="literal">region_code</code> カラムが値 1 から 10 まで (両端を含む) に制限されると想定します)。 
    </p><pre class="programlisting">CREATE TABLE t3 (
    fname VARCHAR(50) NOT NULL,
    lname VARCHAR(50) NOT NULL,
    region_code TINYINT UNSIGNED NOT NULL,
    dob DATE NOT NULL
)
PARTITION BY LIST(region_code) (
    PARTITION r0 VALUES IN (1, 3),
    PARTITION r1 VALUES IN (2, 5, 8),
    PARTITION r2 VALUES IN (4, 9),
    PARTITION r3 VALUES IN (6, 7, 10)
);
</pre><p>
      <code class="literal">SELECT * FROM t3 WHERE region_code BETWEEN 1 AND 3</code> などのステートメントの場合、オプティマイザはどのパーティションで値 1、2、および 3 が見つかるかを判別して (<code class="literal">r0</code> および <code class="literal">r1</code>)、残りのもの (<code class="literal">r2</code> および <code class="literal">r3</code>) をスキップします。
    </p><p>
      <code class="literal">HASH</code> または <code class="literal">[LINEAR] KEY</code> によってパーティション化されたテーブルの場合も、パーティショニング式で使用されるカラムに対して <code class="literal">WHERE</code> 句が単純な <code class="literal">=</code> 関係を使用しているときは、パーティションプルーニングを適用できます。 次のように作成されたテーブルがあるとします。 
    </p><pre class="programlisting">CREATE TABLE t4 (
    fname VARCHAR(50) NOT NULL,
    lname VARCHAR(50) NOT NULL,
    region_code TINYINT UNSIGNED NOT NULL,
    dob DATE NOT NULL
)
PARTITION BY KEY(region_code)
PARTITIONS 8;
</pre><p>
      カラム値を定数と比較するステートメントはプルーニングできます。
    </p><pre class="programlisting">UPDATE t4 WHERE region_code = 7;
</pre><p>
      プルーニングは短い範囲にも適用できます。オプティマイザがそのような条件を <code class="literal">IN</code> 関係に変換できるためです。 たとえば、前に定義したものと同じテーブル <code class="literal">t4</code> を使用して、次のようなクエリーをプルーニングできます。 
    </p><pre class="programlisting">SELECT * FROM t4 WHERE region_code &gt; 2 AND region_code &lt; 6;

SELECT * FROM t4 WHERE region_code BETWEEN 3 AND 5;
</pre><p>
      どちらの場合も、<code class="literal">WHERE</code> 句はオプティマイザによって <code class="literal">WHERE region_code IN (3, 4, 5)</code> に変換されます。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        この最適化は、範囲サイズがパーティションの数より小さい場合にのみ使用されます。 次のステートメントがあるとします。 
      </p><pre class="programlisting">DELETE FROM t4 WHERE region_code BETWEEN 4 AND 12;
</pre><p>
        <code class="literal">WHERE</code> 句の範囲は 9 個の値 (4、5、6、7、8、9、10、11、12) ですが、<code class="literal">t4</code> のパーティションは 8 個だけです。 これはこの <code class="literal">DELETE</code> をプルーニングできないことを意味します。 
      </p></div><p>
      <code class="literal">HASH</code> または <code class="literal">[LINEAR] KEY</code> によってパーティション化されたテーブルの場合、プルーニングを使用できるのは整数カラムに対してのみです。 たとえば、<code class="literal">dob</code> は <code class="literal">DATE</code> カラムであるため、次のステートメントにはプルーニングを使用できません。 
    </p><pre class="programlisting">SELECT * FROM t4 WHERE dob &gt;= '2001-04-14' AND dob &lt;= '2005-10-15';
</pre><p>
      ただし、このテーブルが年値を <code class="literal">INT</code> カラムに格納する場合は、<code class="literal">WHERE year_col &gt;= 2001 AND year_col &lt;= 2005</code> を持つクエリーをプルーニングできます。
    </p><p>
      MySQL Cluster で使用される <code class="literal">NDB</code> ストレージエンジンなど、自動パーティション分割を提供するストレージエンジンを使用するテーブルは、明示的にパーティション化されている場合にプルーニングできます。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="partitioning-selection"></a>24.5 パーティション選択</h2></div></div></div><p>
      特定の <code class="literal">WHERE</code> 条件に一致する行のパーティションおよびサブパーティションの明示的な選択がサポートされています。 パーティション選択は、特定のパーティションのみで一致がチェックされる点でパーティションプルーニングと似ていますが、2 つの重要な点で異なります。 
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          チェックされるパーティションは、パーティションプルーニングと異なり (自動)、ステートメントの発行者が指定します。
        </p></li><li class="listitem"><p>
          パーティションプルーニングはクエリーのみに適用されますが、明示的なパーティション選択はクエリーおよびいくつかの DML ステートメントの両方でサポートされます。
        </p></li></ol></div><p>
      明示的なパーティション選択をサポートする SQL ステートメントを次に一覧します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SELECT</code>
        </p></li><li class="listitem"><p>
          <code class="literal">DELETE</code>
        </p></li><li class="listitem"><p>
          <code class="literal">INSERT</code>
        </p></li><li class="listitem"><p>
          <code class="literal">REPLACE</code>
        </p></li><li class="listitem"><p>
          <code class="literal">UPDATE</code>
        </p></li><li class="listitem"><p>
          <code class="literal">LOAD DATA</code>。
        </p></li><li class="listitem"><p>
          <code class="literal">LOAD XML</code>。
        </p></li></ul></div><p>
      このセクションの残りの部分では、上記に一覧したステートメントに一般的に適用される明示的パーティション選択について説明し、いくつかの例を示します。
    </p><p>
      明示的パーティション選択は、<code class="literal">PARTITION</code> オプションを使用して実装されます。 サポートされるすべてのステートメントについて、このオプションは次のような構文を使用します。 
    </p><pre class="programlisting">      PARTITION (<em class="replaceable"><code>partition_names</code></em>)

      <em class="replaceable"><code>partition_names</code></em>:
          <em class="replaceable"><code>partition_name</code></em>, ...
</pre><p>
      このオプションは常に、パーティションが属するテーブルの名前の後ろに続けます。<em class="replaceable"><code>partition_names</code></em> は、使用されるパーティションまたはサブパーティションのカンマ区切りのリストです。 このリスト内の各名前は、指定されたテーブルの既存のパーティションまたはサブパーティションの名前である必要があります。パーティションまたはサブパーティションが見つからない場合、ステートメントは次のエラーで失敗します (<span class="errortext">partition '<em class="replaceable"><code>partition_name</code></em>' doesn't exist</span>)。 <em class="replaceable"><code>partition_names</code></em> に指定するパーティションまたはサブパーティションは、任意の順序でリストでき、重複していてもかまいません。 
    </p><p>
      <code class="literal">PARTITION</code> オプションを使用すると、リストされたパーティションおよびサブパーティションのみで一致する行がチェックされます。 このオプションを <code class="literal">SELECT</code> ステートメントで使用すると、指定したパーティションに属する行を判別できます。 次のようなステートメントを使用して作成および移入された、<code class="literal">employees</code> という名前のパーティション化されたテーブルがあるとします。 
    </p><pre class="programlisting">SET @@SQL_MODE = '';

CREATE TABLE employees  (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    fname VARCHAR(25) NOT NULL,
    lname VARCHAR(25) NOT NULL,
    store_id INT NOT NULL,
    department_id INT NOT NULL
)
    PARTITION BY RANGE(id)  (
        PARTITION p0 VALUES LESS THAN (5),
        PARTITION p1 VALUES LESS THAN (10),
        PARTITION p2 VALUES LESS THAN (15),
        PARTITION p3 VALUES LESS THAN MAXVALUE
);

INSERT INTO employees VALUES
    ('', 'Bob', 'Taylor', 3, 2), ('', 'Frank', 'Williams', 1, 2),
    ('', 'Ellen', 'Johnson', 3, 4), ('', 'Jim', 'Smith', 2, 4),
    ('', 'Mary', 'Jones', 1, 1), ('', 'Linda', 'Black', 2, 3),
    ('', 'Ed', 'Jones', 2, 1), ('', 'June', 'Wilson', 3, 1),
    ('', 'Andy', 'Smith', 1, 3), ('', 'Lou', 'Waters', 2, 4),
    ('', 'Jill', 'Stone', 1, 4), ('', 'Roger', 'White', 3, 2),
    ('', 'Howard', 'Andrews', 1, 2), ('', 'Fred', 'Goldberg', 3, 3),
    ('', 'Barbara', 'Brown', 2, 3), ('', 'Alice', 'Rogers', 2, 2),
    ('', 'Mark', 'Morgan', 3, 3), ('', 'Karen', 'Cole', 3, 2);
</pre><p>
      どの行がパーティション <code class="literal">p1</code> に格納されているかは次のように確認できます。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM employees PARTITION (p1);</code></strong>
+----+-------+--------+----------+---------------+
| id | fname | lname  | store_id | department_id |
+----+-------+--------+----------+---------------+
|  5 | Mary  | Jones  |        1 |             1 |
|  6 | Linda | Black  |        2 |             3 |
|  7 | Ed    | Jones  |        2 |             1 |
|  8 | June  | Wilson |        3 |             1 |
|  9 | Andy  | Smith  |        1 |             3 |
+----+-------+--------+----------+---------------+
5 rows in set (0.00 sec)
</pre><p>
      この結果は、クエリー <code class="literal">SELECT * FROM employees WHERE id BETWEEN 5 AND 9</code> によって取得されるものと同じです。
    </p><p>
      複数のパーティションからの行を取得するには、それらの名前をカンマ区切りのリストとして指定します。 たとえば、<code class="literal">SELECT * FROM employees PARTITION (p1, p2)</code> はパーティション <code class="literal">p1</code> および <code class="literal">p2</code> からのすべての行を返し、残りのパーティションからの行を除外します。 
    </p><p>
      パーティション化されたテーブルに対する有効なクエリーは、<code class="literal">PARTITION</code> オプションを使用して、結果を 1 つ以上の目的のパーティションに制限するように書き直すことができます。 <code class="literal">WHERE</code> 条件、<code class="literal">ORDER BY</code> オプション、<code class="literal">LIMIT</code> オプションなどを使用できます。 集約関数を <code class="literal">HAVING</code> および <code class="literal">GROUP BY</code> オプション付きで使用することもできます。 次の各クエリーは、前に定義した <code class="literal">employees</code> テーブルで実行するときに、有効な結果を生成します。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM employees PARTITION (p0, p2)</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE lname LIKE 'S%';</code></strong>
+----+-------+-------+----------+---------------+
| id | fname | lname | store_id | department_id |
+----+-------+-------+----------+---------------+
|  4 | Jim   | Smith |        2 |             4 |
| 11 | Jill  | Stone |        1 |             4 |
+----+-------+-------+----------+---------------+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT id, CONCAT(fname, ' ', lname) AS name</code></strong>
    -&gt;     <strong class="userinput"><code>FROM employees PARTITION (p0) ORDER BY lname;</code></strong>
+----+----------------+
| id | name           |
+----+----------------+
|  3 | Ellen Johnson  |
|  4 | Jim Smith      |
|  1 | Bob Taylor     |
|  2 | Frank Williams |
+----+----------------+
4 rows in set (0.06 sec)

mysql&gt; <strong class="userinput"><code>SELECT store_id, COUNT(department_id) AS c</code></strong>
    -&gt;     <strong class="userinput"><code>FROM employees PARTITION (p1,p2,p3)</code></strong>
    -&gt;     <strong class="userinput"><code>GROUP BY store_id HAVING c &gt; 4;</code></strong>
+---+----------+
| c | store_id |
+---+----------+
| 5 |        2 |
| 5 |        3 |
+---+----------+
2 rows in set (0.00 sec)
</pre><p>
      パーティション選択を使用するステートメントは、サポートされている任意のパーティション化タイプを使用してテーブルで使用できます。 テーブルが <code class="literal">[LINEAR] HASH</code> または <code class="literal">[LINEAR] KEY</code> パーティショニングを使用して作成されているけれども、パーティションの名前が指定されていない場合は、MySQL はパーティションに <code class="literal">p0</code>、<code class="literal">p1</code>、<code class="literal">p2</code>、...、<code class="literal">p<em class="replaceable"><code>N-1</code></em></code> という名前を自動的に付けます。ここで、<em class="replaceable"><code>N</code></em> はパーティションの数です。 明示的に名前が付けられていないサブパーティションの場合、MySQL は各パーティション <code class="literal">p<em class="replaceable"><code>X</code></em></code> 内のサブパーティションに <code class="literal">p<em class="replaceable"><code>X</code></em>sp0</code>、<code class="literal">p<em class="replaceable"><code>X</code></em>sp1</code>、<code class="literal">p<em class="replaceable"><code>X</code></em>sp2</code>、...、<code class="literal">p<em class="replaceable"><code>X</code></em>sp<em class="replaceable"><code>M-1</code></em></code> という名前を自動的に割り当てます。ここで、<em class="replaceable"><code>M</code></em> はサブパーティションの数です。 このテーブルで <code class="literal">SELECT</code> (または明示的パーティション選択が許可されるほかの SQL ステートメント) を実行するときは、次のようにこれらの生成された名前を <code class="literal">PARTITION</code> オプションで使用できます。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE employees_sub  (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT NOT NULL AUTO_INCREMENT,</code></strong>
    -&gt;     <strong class="userinput"><code>fname VARCHAR(25) NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>lname VARCHAR(25) NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>store_id INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>department_id INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>PRIMARY KEY pk (id, lname)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION BY RANGE(id)</code></strong>
    -&gt;     <strong class="userinput"><code>SUBPARTITION BY KEY (lname)</code></strong>
    -&gt;     <strong class="userinput"><code>SUBPARTITIONS 2 (</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (5),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (10),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (15),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN MAXVALUE</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (1.14 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO employees_sub</code></strong>   # reuse data in employees table
    -&gt;     <strong class="userinput"><code>SELECT * FROM employees;</code></strong>
Query OK, 18 rows affected (0.09 sec)
Records: 18  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT id, CONCAT(fname, ' ', lname) AS name</code></strong>
    -&gt;     <strong class="userinput"><code>FROM employees_sub PARTITION (p2sp1);</code></strong>
+----+---------------+
| id | name          |
+----+---------------+
| 10 | Lou Waters    |
| 14 | Fred Goldberg |
+----+---------------+
2 rows in set (0.00 sec)
</pre><p>
      次のように <code class="literal">PARTITION</code> オプションを <code class="literal">INSERT ... SELECT</code> ステートメントの <code class="literal">SELECT</code> 部分に使用することもできます。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE employees_copy LIKE employees;</code></strong>
Query OK, 0 rows affected (0.28 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO employees_copy</code></strong>
    -&gt;     <strong class="userinput"><code>SELECT * FROM employees PARTITION (p2);</code></strong>
Query OK, 5 rows affected (0.04 sec)
Records: 5  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM employees_copy;</code></strong>
+----+--------+----------+----------+---------------+
| id | fname  | lname    | store_id | department_id |
+----+--------+----------+----------+---------------+
| 10 | Lou    | Waters   |        2 |             4 |
| 11 | Jill   | Stone    |        1 |             4 |
| 12 | Roger  | White    |        3 |             2 |
| 13 | Howard | Andrews  |        1 |             2 |
| 14 | Fred   | Goldberg |        3 |             3 |
+----+--------+----------+----------+---------------+
5 rows in set (0.00 sec)
</pre><p>
      パーティション選択は結合と一緒に使用することもできます。 次のステートメントを使用して 2 つのテーブルを作成して移入するとします。 
    </p><pre class="programlisting">CREATE TABLE stores (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    city VARCHAR(30) NOT NULL
)
    PARTITION BY HASH(id)
    PARTITIONS 2;

INSERT INTO stores VALUES
    ('', 'Nambucca'), ('', 'Uranga'),
    ('', 'Bellingen'), ('', 'Grafton');

CREATE TABLE departments  (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(30) NOT NULL
)
    PARTITION BY KEY(id)
    PARTITIONS 2;

INSERT INTO departments VALUES
    ('', 'Sales'), ('', 'Customer Service'),
    ('', 'Delivery'), ('', 'Accounting');
</pre><p>
      任意またはすべてのテーブルからのパーティション (またはサブパーティション、あるいはその両方) を結合で明示的に選択できます (特定のテーブルからパーティションを選択するために使用される <code class="literal">PARTITION</code> オプションは、テーブルのエイリアスを含む他のすべてのオプションの直前のテーブルの名前に続きます。) たとえば、次のクエリーは都市 Nambucca および Bellingen (<code class="literal">stores</code> テーブルのパーティション <code class="literal">p0</code>) のいずれかの店舗の販売部門または配送部門 (<code class="literal">departments</code> テーブルのパーティション <code class="literal">p1</code>) で働いているすべての従業員の、名前、従業員 ID、部門、および都市を取得します。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT</code></strong>
    -&gt;     <strong class="userinput"><code>e.id AS 'Employee ID', CONCAT(e.fname, ' ', e.lname) AS Name,</code></strong>
    -&gt;     <strong class="userinput"><code>s.city AS City, d.name AS department</code></strong>
    -&gt; <strong class="userinput"><code>FROM employees AS e</code></strong>
    -&gt;     <strong class="userinput"><code>JOIN stores PARTITION (p1) AS s ON e.store_id=s.id</code></strong>
    -&gt;     <strong class="userinput"><code>JOIN departments PARTITION (p0) AS d ON e.department_id=d.id</code></strong>
    -&gt; <strong class="userinput"><code>ORDER BY e.lname;</code></strong>
+-------------+---------------+-----------+------------+
| Employee ID | Name          | City      | department |
+-------------+---------------+-----------+------------+
|          14 | Fred Goldberg | Bellingen | Delivery   |
|           5 | Mary Jones    | Nambucca  | Sales      |
|          17 | Mark Morgan   | Bellingen | Delivery   |
|           9 | Andy Smith    | Nambucca  | Delivery   |
|           8 | June Wilson   | Bellingen | Sales      |
+-------------+---------------+-----------+------------+
5 rows in set (0.00 sec)
</pre><p>
      MySQL での結合の一般情報については、<a class="xref" href="sql-statements.html#join" title="13.2.10.2 JOIN 句">セクション13.2.10.2「JOIN 句」</a>を参照してください。
    </p><p>
      <code class="literal">DELETE</code> ステートメントで <code class="literal">PARTITION</code> オプションを使用すると、オプションにリストされているパーティション (およびサブパーティション (ある場合)) でのみ削除される行がチェックされます。 次のようにほかのパーティションは無視されます。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM employees WHERE fname LIKE 'j%';</code></strong>
+----+-------+--------+----------+---------------+
| id | fname | lname  | store_id | department_id |
+----+-------+--------+----------+---------------+
|  4 | Jim   | Smith  |        2 |             4 |
|  8 | June  | Wilson |        3 |             1 |
| 11 | Jill  | Stone  |        1 |             4 |
+----+-------+--------+----------+---------------+
3 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>DELETE FROM employees PARTITION (p0, p1)</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE fname LIKE 'j%';</code></strong>
Query OK, 2 rows affected (0.09 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM employees WHERE fname LIKE 'j%';</code></strong>
+----+-------+-------+----------+---------------+
| id | fname | lname | store_id | department_id |
+----+-------+-------+----------+---------------+
| 11 | Jill  | Stone |        1 |             4 |
+----+-------+-------+----------+---------------+
1 row in set (0.00 sec)
</pre><p>
      <code class="literal">WHERE</code> 条件と一致するパーティション <code class="literal">p0</code> および <code class="literal">p1</code> 内の 2 つの行のみが削除されました。 <code class="literal">SELECT</code> を 2 回目に実行したときの結果から確認できるように、<code class="literal">WHERE</code> 条件に一致する 1 行がテーブルに残っていますが、別のパーティション (<code class="literal">p2</code>) にあります。 
    </p><p>
      明示的パーティション選択を使用する <code class="literal">UPDATE</code> ステートメントも同様に動作します。次のステートメントを実行することによって確認できるように、<code class="literal">PARTITION</code> オプションによって参照されるパーティション内の行のみが、更新される行を判別するときに考慮されます。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE employees PARTITION (p0) </code></strong>
    -&gt;     <strong class="userinput"><code>SET store_id = 2 WHERE fname = 'Jill';</code></strong>
Query OK, 0 rows affected (0.00 sec)
Rows matched: 0  Changed: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM employees WHERE fname = 'Jill';</code></strong>
+----+-------+-------+----------+---------------+
| id | fname | lname | store_id | department_id |
+----+-------+-------+----------+---------------+
| 11 | Jill  | Stone |        1 |             4 |
+----+-------+-------+----------+---------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>UPDATE employees PARTITION (p2)</code></strong>
    -&gt;     <strong class="userinput"><code>SET store_id = 2 WHERE fname = 'Jill';</code></strong>
Query OK, 1 row affected (0.09 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM employees WHERE fname = 'Jill';</code></strong>
+----+-------+-------+----------+---------------+
| id | fname | lname | store_id | department_id |
+----+-------+-------+----------+---------------+
| 11 | Jill  | Stone |        2 |             4 |
+----+-------+-------+----------+---------------+
1 row in set (0.00 sec)
</pre><p>
      同様に、<code class="literal">DELETE</code> 付きで <code class="literal">PARTITION</code> を使用すると、パーティションリストに指定されたパーティション内の行のみが削除をチェックされます。
    </p><p>
      行を挿入するステートメントの動作は、適切なパーティションが見つからないとステートメントが失敗する点が異なります。 これは、次のように <code class="literal">INSERT</code> および <code class="literal">REPLACE</code> ステートメントの両方に当てはまります。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>INSERT INTO employees PARTITION (p2) VALUES (20, 'Jan', 'Jones', 1, 3);</code></strong>
<span class="errortext">ERROR 1729 (HY000): Found a row not matching the given partition set</span>
mysql&gt; <strong class="userinput"><code>INSERT INTO employees PARTITION (p3) VALUES (20, 'Jan', 'Jones', 1, 3);</code></strong>
Query OK, 1 row affected (0.07 sec)

mysql&gt; REPLACE INTO employees PARTITION (p0) VALUES (20, 'Jan', 'Jones', 3, 2);
<span class="errortext">ERROR 1729 (HY000): Found a row not matching the given partition set</span>

mysql&gt; REPLACE INTO employees PARTITION (p3) VALUES (20, 'Jan', 'Jones', 3, 2);
Query OK, 2 rows affected (0.09 sec)
</pre><p>
      <code class="literal">InnoDB</code> ストレージエンジンを使用するパーティション化されたテーブルに複数の行を書き込むステートメントの場合: <code class="literal">VALUES</code> に続くリスト内のいずれかの行を、<em class="replaceable"><code>partition_names</code></em> リストで指定されたいずれかのパーティションに書き込めない場合、ステートメント全体が失敗し、行は書き込まれません。 これについては、次の例 (<code class="literal">employees</code> テーブルを再使用) の <code class="literal">INSERT</code> ステートメントで示されています。 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE employees</code></strong>
    -&gt;     <strong class="userinput"><code>REORGANIZE PARTITION p3 INTO (</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (20),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p4 VALUES LESS THAN (25),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p5 VALUES LESS THAN MAXVALUE</code></strong>
    -&gt;     <strong class="userinput"><code>);</code></strong>
Query OK, 6 rows affected (2.09 sec)
Records: 6  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE employees\G</code></strong>
*************************** 1. row ***************************
       Table: employees
Create Table: CREATE TABLE `employees` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `fname` varchar(25) NOT NULL,
  `lname` varchar(25) NOT NULL,
  `store_id` int(11) NOT NULL,
  `department_id` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=utf8mb4
/*!50100 PARTITION BY RANGE (id)
(PARTITION p0 VALUES LESS THAN (5) ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (10) ENGINE = InnoDB,
 PARTITION p2 VALUES LESS THAN (15) ENGINE = InnoDB,
 PARTITION p3 VALUES LESS THAN (20) ENGINE = InnoDB,
 PARTITION p4 VALUES LESS THAN (25) ENGINE = InnoDB,
 PARTITION p5 VALUES LESS THAN MAXVALUE ENGINE = InnoDB) */
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO employees PARTITION (p3, p4) VALUES</code></strong>
    -&gt;     <strong class="userinput"><code>(24, 'Tim', 'Greene', 3, 1),  (26, 'Linda', 'Mills', 2, 1);</code></strong>
ERROR 1729 (HY000): Found a row not matching the given partition set

mysql&gt; <strong class="userinput"><code>INSERT INTO employees PARTITION (p3, p4. p5) VALUES</code></strong>
    -&gt;     <strong class="userinput"><code>(24, 'Tim', 'Greene', 3, 1),  (26, 'Linda', 'Mills', 2, 1);</code></strong>
Query OK, 2 rows affected (0.06 sec)
Records: 2  Duplicates: 0  Warnings: 0
</pre><p>
      前述のことは、複数の行を書き込む <code class="literal">INSERT</code> および <code class="literal">REPLACE</code> ステートメントの両方に当てはまります。
    </p><p>
      パーティションの選択は、<code class="literal">NDB</code> などの自動パーティション分割を提供するストレージエンジンを使用するテーブルでは無効になっています。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="partitioning-limitations"></a>24.6 パーティショニングの制約と制限</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="partitioning.html#partitioning-limitations-partitioning-keys-unique-keys">24.6.1 パーティショニングキー、主キー、および一意キー</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-limitations-storage-engines">24.6.2 ストレージエンジンに関連するパーティショニング制限</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-limitations-functions">24.6.3 関数に関連するパーティショニング制限</a></span></dt></dl></div><a class="indexterm" name="idm45807909226560"></a><p>
      このセクションでは、MySQL パーティショニングサポートでの現在の制約と制限について説明します。
    </p><p><b>禁止されている構造体. </b>
        次の構造体はパーティショニング式で許可されません。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ストアドプロシージャー、ストアドファンクション、UDF、またはプラグイン。
        </p></li><li class="listitem"><p>
          宣言された変数またはユーザー変数。
        </p></li></ul></div><p>
      パーティショニング式で許可される SQL 関数のリストについては、<a class="xref" href="partitioning.html#partitioning-limitations-functions" title="24.6.3 関数に関連するパーティショニング制限">セクション24.6.3「関数に関連するパーティショニング制限」</a>を参照してください。
    </p><p><b>算術および論理演算子. </b>
        <a class="indexterm" name="idm45807909217856"></a> <a class="indexterm" name="idm45807909215568"></a> 算術演算子 <code class="literal">+</code>、<code class="literal">-</code>、および <code class="literal">*</code> の使用は、パーティショニング式で許可されます。 ただし、結果は整数値または <code class="literal">NULL</code> である必要があります (この章のほかの場所で説明しているように、<code class="literal">[LINEAR] KEY</code> パーティショニングの場合を除きます。詳細は、<a class="xref" href="partitioning.html#partitioning-types" title="24.2 パーティショニングタイプ">セクション24.2「パーティショニングタイプ」</a>を参照してください)。 
      </p><p>
      <code class="literal">DIV</code> 演算子もサポートされています。<code class="literal">/</code>演算子は使用できません。
    </p><p>
      ビット演算子 <code class="literal">|</code>、<code class="literal">&amp;</code>、<code class="literal">^</code>、<code class="literal">&lt;&lt;</code>、<code class="literal">&gt;&gt;</code>、および <code class="literal">~</code> はパーティショニング式では許可されません。
    </p><p><b>サーバー SQL モード. </b>
        <a class="indexterm" name="idm45807909195536"></a> <a class="indexterm" name="idm45807909193360"></a> ユーザー定義パーティショニングを使用するテーブルは、それらが作成された時点で有効だった SQL モードを保持しません。 このマニュアルの他の場所で説明されているように (<a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a> を参照)、多くの MySQL 関数および演算子の結果は、サーバーの SQL モードに応じて変わる可能性があります。 このため、パーティション化されたテーブルの作成後の任意の時点に SQL モードを変更すると、そのようなテーブルの動作が大きく変わることがあり、データの破損または損失が発生しやすくなることがあります。 これらの理由により、<span class="emphasis"><em>パーティション化されたテーブルを作成したあとにサーバー SQL モードを決して変更しないことが強く推奨されています</em></span>。 
      </p><p>
      パーティション化されたテーブルを使用不可にするサーバー SQL モードでこのような変更を行う場合は、<code class="literal">NO_UNSIGNED_SUBTRACTION</code> モードが有効な場合にのみ正常に実行できる次の <code class="literal">CREATE TABLE</code> ステートメントを検討してください:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@sql_mode;</code></strong>
+------------+
| @@sql_mode |
+------------+
|            |
+------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE tu (c1 BIGINT UNSIGNED)</code></strong>
    -&gt;   <strong class="userinput"><code>PARTITION BY RANGE(c1 - 10) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (-5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (0),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (10),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p4 VALUES LESS THAN (MAXVALUE)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
<span class="errortext">ERROR 1563 (HY000): Partition constant is out of partition function domain</span>

mysql&gt; <strong class="userinput"><code>SET sql_mode='NO_UNSIGNED_SUBTRACTION';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @@sql_mode;</code></strong>
+-------------------------+
| @@sql_mode              |
+-------------------------+
| NO_UNSIGNED_SUBTRACTION |
+-------------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE tu (c1 BIGINT UNSIGNED)</code></strong>
    -&gt;   <strong class="userinput"><code>PARTITION BY RANGE(c1 - 10) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (-5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (0),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (10),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p4 VALUES LESS THAN (MAXVALUE)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.05 sec)
</pre><p>
      <code class="literal">tu</code> を作成したあとに <code class="literal">NO_UNSIGNED_SUBTRACTION</code> サーバー SQL モードを削除すると、このテーブルにアクセスできなくなる可能性があります。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET sql_mode='';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM tu;</code></strong>
<span class="errortext">ERROR 1563 (HY000): Partition constant is out of partition function domain</span>
mysql&gt; <strong class="userinput"><code>INSERT INTO tu VALUES (20);</code></strong>
<span class="errortext">ERROR 1563 (HY000): Partition constant is out of partition function domain</span>
</pre><p>
      <a class="xref" href="server-administration.html#sql-mode" title="5.1.11 サーバー SQL モード">セクション5.1.11「サーバー SQL モード」</a>も参照してください。
    </p><p>
      サーバー SQL モードは、パーティション化されたテーブルのレプリケーションにも影響します。 ソースとレプリカで SQL モードを変えると、パーティション化式が異なる方法で評価される可能性があります。これにより、パーティション間でのデータの分散が特定のテーブルのソースとレプリカコピーで異なる可能性があり、ソースで成功したパーティションテーブルへの挿入がレプリカで失敗する可能性もあります。 最良の結果を得るには、ソースとレプリカで常に同じサーバー SQL モードを使用する必要があります。 
    </p><p><b>パフォーマンス考慮事項. </b>
        パーティション化操作がパフォーマンスに与える影響の一部を次に示します:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="partitioning-limitations-file-system-ops"></a><b>ファイルシステム操作. </b>
            パーティション化および再パーティション化操作 (<code class="literal">PARTITION BY ...</code>、<code class="literal">REORGANIZE PARTITION</code>、<code class="literal">REMOVE PARTITIONING</code> を使用した <code class="literal">ALTER TABLE</code> など) は、実装のためのファイルシステム操作に依存します。 これは、これらの操作の速度が、ファイルシステムのタイプと特性、ディスク速度、スワップ領域、オペレーティングシステムによるファイル処理効率、ファイル処理に関連する MySQL サーバーのオプションと変数などの要因に影響されることを意味します。 特に、<code class="literal">large_files_support</code> が有効になっていて、<code class="literal">open_files_limit</code> が適切に設定されていることを確認してください。 <code class="literal">innodb_file_per_table</code> を有効にすると、<code class="literal">InnoDB</code> テーブルを含むパーティション化および再パーティション化操作がより効率的になります。 
          </p><p>
          <a class="xref" href="partitioning.html#partitioning-limitations-max-partitions" title="パーティションの最大数">パーティションの最大数</a>も参照してください。
        </p></li><li class="listitem"><p><b>テーブルロック. </b>
            通常、テーブルに対してパーティション化操作を実行するプロセスは、テーブルに対する書込みロックを取得します。 そのようなテーブルからの読み取りは比較的影響を受けません。保留中の <code class="literal">INSERT</code> および <code class="literal">UPDATE</code> 操作は、パーティショニング操作が完了するとすぐに実行されます。 この制限に対する <code class="literal">InnoDB</code> 固有の例外については、<a class="xref" href="innodb-storage-engine.html#online-ddl-partitioning" title="パーティション化操作">パーティション化操作</a> を参照してください。 
          </p></li><li class="listitem"><p><b>インデックス、パーティションプルーニング. </b>
            パーティション化されていないテーブルと同様に、インデックスを適切に使用することで、パーティション化されたテーブルに対する照会速度が大幅に向上することがあります。 また、パーティション化されたテーブルおよびこれらのテーブルに対するクエリーを<span class="firstterm">パーティションプルーニング</span>の利点を活用するように設計することで、パフォーマンスが劇的に向上することがあります。 詳細は、<a class="xref" href="partitioning.html#partitioning-pruning" title="24.4 パーティションプルーニング">セクション24.4「パーティションプルーニング」</a>を参照してください。 
          </p><p>
          インデックス条件プッシュダウンは、パーティションテーブルでサポートされています。 <a class="xref" href="optimization.html#index-condition-pushdown-optimization" title="8.2.1.6 インデックスコンディションプッシュダウンの最適化">セクション8.2.1.6「インデックスコンディションプッシュダウンの最適化」</a>を参照してください。 
        </p></li><li class="listitem"><p><b>LOAD DATA のパフォーマンス. </b>
            MySQL 8.0 では、<code class="literal">LOAD DATA</code> はパフォーマンスを向上させるためにバッファリングを使用します。 これを実現するために、バッファーがパーティションごとに 130K バイトメモリーを使用することを認識してください。 
          </p></li></ul></div><p><a name="partitioning-limitations-max-partitions"></a><b>パーティションの最大数. </b><a class="indexterm" name="idm45807909131616"></a><a class="indexterm" name="idm45807909129392"></a>
        <code class="literal">NDB</code> ストレージエンジンを使用しない特定のテーブルで可能なパーティションの最大数は 8192 です。 この数にはサブパーティションが含まれます。 
      </p><p>
      <code class="literal">NDB</code> ストレージエンジンを使用するテーブルのユーザー定義パーティションの最大数は、使用されている NDB Cluster ソフトウェアのバージョン、データノードの数、およびその他の要因に応じて決定されます。 詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-nodes-groups-user-partitioning" title="NDB とユーザー定義のパーティション化">NDB とユーザー定義のパーティション化</a>を参照してください。 
    </p><p>
      多数のパーティション (ただし、最大数より少ない) を持つテーブルを作成するときに、<span class="errortext">Got error ... from storage engine: Out of resources when opening file</span>などのエラーメッセージが表示される場合は、<code class="literal">open_files_limit</code> システム変数の値を増やすことによってこの問題に対処できることがあります。 ただし、これはオペレーティングシステムによって異なるため、すべてのプラットフォームで可能または推奨されるとはかぎりません。詳細は、<a class="xref" href="error-handling.html#not-enough-file-handles" title="B.3.2.16 ファイルが見つからず同様のエラーが発生しました">セクションB.3.2.16「ファイルが見つからず同様のエラーが発生しました」</a>を参照してください。 場合によっては、多数の (数百の) パーティションを使用することがほかの問題のために推奨されないこともあり、より多くのパーティションを使用することが自動的に良い結果となるとはかぎりません。 
    </p><p>
      <a class="xref" href="partitioning.html#partitioning-limitations-file-system-ops" title="ファイルシステム操作">ファイルシステム操作</a>も参照してください。
    </p><p><b>パーティション化された InnoDB テーブルで外部キーがサポートされない. </b><a class="indexterm" name="idm45807909116656"></a>
        <code class="literal">InnoDB</code> ストレージエンジンを使用するパーティション化されたテーブルでは、外部キーはサポートされません。 これは具体的には、次の 2 つの記述が true であることを意味します。 
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          ユーザー定義パーティショニングを使用する <code class="literal">InnoDB</code> テーブルの定義には、外部キー参照を含めることはできません。定義に外部キー参照が含まれる <code class="literal">InnoDB</code> テーブルはパーティション化できません。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> テーブル定義に、ユーザーパーティション化されたテーブルへの外部キー参照を含めることはできません。ユーザー定義パーティショニングを持つ <code class="literal">InnoDB</code> テーブルに、外部キーによって参照されるカラムを含めることはできません。
        </p></li></ol></div><p>
      上記の制約のスコープには、<code class="literal">InnoDB</code> ストレージエンジンを使用するすべてのテーブルが含まれます。 結果のテーブルがこれらの制約に違反する <code class="literal">CREATE TABLE</code> および <code class="literal">ALTER TABLE</code> ステートメントは許可されません。 
    </p><p><b>ALTER TABLE ... ORDER BY. </b>
        パーティション化されたテーブルに <code class="literal">ALTER TABLE ... ORDER BY <em class="replaceable"><code>column</code></em></code> ステートメントを実行すると、各パーティション内でのみ行が並べ替えられます。
      </p><p><b>主キーを変更することによる REPLACE ステートメントへの影響. </b>
        テーブルの主キーを変更することが望ましい場合があります (<a class="xref" href="partitioning.html#partitioning-limitations-partitioning-keys-unique-keys" title="24.6.1 パーティショニングキー、主キー、および一意キー">セクション24.6.1「パーティショニングキー、主キー、および一意キー」</a>を参照してください)。 <code class="literal">REPLACE</code> ステートメントを使用するアプリケーションでこれを行うと、これらのステートメントの結果が大きく変わることがあることを認識してください。 詳細および例については、<a class="xref" href="sql-statements.html#replace" title="13.2.9 REPLACE ステートメント">セクション13.2.9「REPLACE ステートメント」</a>を参照してください。 
      </p><p><b>FULLTEXT インデックス. </b><a class="indexterm" name="idm45807909094656"></a>
        パーティションテーブルでは、<code class="literal">FULLTEXT</code> インデックスまたは検索はサポートされていません。
      </p><p><b>空間カラム. </b>
        <code class="literal">POINT</code>、<code class="literal">GEOMETRY</code> などの空間データ型を持つカラムは、パーティション化されたテーブルで使用できません。
      </p><p><b>一時テーブル. </b><a class="indexterm" name="idm45807909087568"></a>
        一時テーブルはパーティション化できません 
      </p><p><b>ログテーブル. </b>
        ログテーブルをパーティション化することはできません。そのようなテーブルに <code class="literal">ALTER TABLE ... PARTITION BY ...</code> ステートメントを実行すると、エラーで失敗します。
      </p><p><b>パーティショニングキーのデータ型. </b><a class="indexterm" name="idm45807909081264"></a>
        パーティショニングキーは、整数カラム、または整数に解決される式である必要があります。 <code class="literal">ENUM</code> カラムを使用する式は使用できません。 カラムまたは式の値は <code class="literal">NULL</code> でもかまいません。<a class="xref" href="partitioning.html#partitioning-handling-nulls" title="24.2.7 MySQL パーティショニングによる NULL の扱い">セクション24.2.7「MySQL パーティショニングによる NULL の扱い」</a> を参照してください。 
      </p><p>
      この制約には 2 つの例外があります。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          [<code class="literal">LINEAR</code>] <code class="literal">KEY</code> でパーティション化する場合、<code class="literal">TEXT</code> または <code class="literal">BLOB</code> 以外の有効な MySQL データ型のカラムをパーティション化キーとして使用できます。これは、内部キーハッシュ関数がこれらの型から正しいデータ型を生成するためです。 たとえば、次の 2 つの <code class="literal">CREATE TABLE</code> ステートメントは有効です。 
        </p><pre class="programlisting">CREATE TABLE tkc (c1 CHAR)
PARTITION BY KEY(c1)
PARTITIONS 4;

CREATE TABLE tke
    ( c1 ENUM('red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet') )
PARTITION BY LINEAR KEY(c1)
PARTITIONS 6;
</pre></li><li class="listitem"><p>
          <code class="literal">RANGE COLUMNS</code> または <code class="literal">LIST COLUMNS</code> によってパーティショニングするときは、文字列、<code class="literal">DATE</code>、および <code class="literal">DATETIME</code> カラムを使用できます。 たとえば、次の各 <code class="literal">CREATE TABLE</code> ステートメントは有効です。 
        </p><pre class="programlisting">CREATE TABLE rc (c1 INT, c2 DATE)
PARTITION BY RANGE COLUMNS(c2) (
    PARTITION p0 VALUES LESS THAN('1990-01-01'),
    PARTITION p1 VALUES LESS THAN('1995-01-01'),
    PARTITION p2 VALUES LESS THAN('2000-01-01'),
    PARTITION p3 VALUES LESS THAN('2005-01-01'),
    PARTITION p4 VALUES LESS THAN(MAXVALUE)
);

CREATE TABLE lc (c1 INT, c2 CHAR(1))
PARTITION BY LIST COLUMNS(c2) (
    PARTITION p0 VALUES IN('a', 'd', 'g', 'j', 'm', 'p', 's', 'v', 'y'),
    PARTITION p1 VALUES IN('b', 'e', 'h', 'k', 'n', 'q', 't', 'w', 'z'),
    PARTITION p2 VALUES IN('c', 'f', 'i', 'l', 'o', 'r', 'u', 'x', NULL)
);
</pre></li></ol></div><p>
      上記の例外は、<code class="literal">BLOB</code> または <code class="literal">TEXT</code> カラム型には該当しません。
    </p><p><b>サブクエリー. </b><a class="indexterm" name="idm45807909057216"></a>
        パーティショニングキーはサブクエリーにできません (そのサブクエリーが整数値または <code class="literal">NULL</code> に解決される場合でも)。
      </p><a class="indexterm" name="idm45807909053600"></a><a class="indexterm" name="idm45807909051536"></a><p><a name="partitioning-limitations-prefixes"></a><b>カラムインデックス接頭辞はキーパーティション化ではサポートされていません. </b>
        キーでパーティション化されたテーブルを作成する場合、カラム接頭辞を使用するパーティション化キー内のカラムは、テーブルパーティション化関数では使用されません。 3 つの <code class="literal">VARCHAR</code> カラムがあり、主キーが 3 つのカラムすべてを使用し、それらのうちの 2 つに接頭辞を指定する次の <code class="literal">CREATE TABLE</code> ステートメントについて考えてみます: 
      </p><pre class="programlisting">CREATE TABLE t1 (
    a VARCHAR(10000),
    b VARCHAR(25),
    c VARCHAR(10),
    PRIMARY KEY (a(10), b, c(2))
) PARTITION BY KEY() PARTITIONS 2;
</pre><p>
      このステートメントは受け入れられますが、結果のテーブルは、パーティション化キーの接頭辞 (カラム <code class="literal">b</code>) を含まない主キーカラムのみを使用して、次のステートメントを発行したかのように実際に作成されます:
    </p><pre class="programlisting">CREATE TABLE t1 (
    a VARCHAR(10000),
    b VARCHAR(25),
    c VARCHAR(10),
    PRIMARY KEY (a(10), b, c(2))
) PARTITION BY KEY(b) PARTITIONS 2;
</pre><p>
      MySQL 8.0.21 より前は、次に示すように、パーティション化キーに指定されたすべてのカラムで接頭辞が使用された場合を除き、警告は発行されず、それ以外の場合は、ステートメントは失敗しましたが、誤解を招くエラーメッセージが表示されます:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (</code></strong>
    -&gt;     <strong class="userinput"><code>a VARCHAR(10000),</code></strong>
    -&gt;     <strong class="userinput"><code>b VARCHAR(25),</code></strong>
    -&gt;     <strong class="userinput"><code>c VARCHAR(10),</code></strong>
    -&gt;     <strong class="userinput"><code>PRIMARY KEY (a(10), b(5), c(2))</code></strong>
    -&gt; <strong class="userinput"><code>) PARTITION BY KEY() PARTITIONS 2;</code></strong>
<span class="errortext">ERROR 1503 (HY000): A PRIMARY KEY must include all columns in the
table's partitioning function</span>
</pre><p>
      これは、<code class="literal">ALTER TABLE</code> の実行時またはこのようなテーブルのアップグレード時にも発生します。
    </p><p>
      この許容動作は、MySQL 8.0.21 では非推奨です (将来のバージョンの MySQL では削除される可能性があります)。 MySQL 8.0.21 以降では、パーティション化キーに接頭辞を持つカラムを使用すると、次に示すように、そのようなカラムごとに警告が表示されます: 
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
    -&gt;     <strong class="userinput"><code>a VARCHAR(10000),</code></strong>
    -&gt;     <strong class="userinput"><code>b VARCHAR(25),</code></strong>
    -&gt;     <strong class="userinput"><code>c VARCHAR(10),</code></strong>
    -&gt;     <strong class="userinput"><code>PRIMARY KEY (a(10), b, c(2))</code></strong>
    -&gt; <strong class="userinput"><code>) PARTITION BY KEY() PARTITIONS 2;</code></strong>
Query OK, 0 rows affected, 2 warnings (1.25 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Warning
   Code: 1681
Message: Column 'test.t1.a' having prefix key part 'a(10)' is ignored by the
partitioning function. Use of prefixed columns in the PARTITION BY KEY() clause
is deprecated and will be removed in a future release.
*************************** 2. row ***************************
  Level: Warning
   Code: 1681
Message: Column 'test.t1.c' having prefix key part 'c(2)' is ignored by the
partitioning function. Use of prefixed columns in the PARTITION BY KEY() clause
is deprecated and will be removed in a future release.
2 rows in set (0.00 sec)
</pre><p>
      これには、空の <code class="literal">PARTITION BY KEY()</code> 句を使用して、パーティション化関数で使用されるカラムがテーブルの主キーのカラムとして暗黙的に定義される場合が含まれます。
    </p><p>
      MySQL 8.0.21 以降では、パーティション化キーに指定されたすべてのカラムに接頭辞が使用されている場合、使用される <code class="literal">CREATE TABLE</code> ステートメントは失敗し、問題を正しく識別するエラーメッセージが表示されます:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
    -&gt;     <strong class="userinput"><code>a VARCHAR(10000),</code></strong>
    -&gt;     <strong class="userinput"><code>b VARCHAR(25),</code></strong>
    -&gt;     <strong class="userinput"><code>c VARCHAR(10),</code></strong>
    -&gt;     <strong class="userinput"><code>PRIMARY KEY (a(10), b(5), c(2))</code></strong>
    -&gt; <strong class="userinput"><code>) PARTITION BY KEY() PARTITIONS 2;</code></strong>
<span class="errortext">ERROR 1503 (HY000): A PRIMARY KEY must include all columns in the table's
partitioning function (prefixed columns are not considered).</span>
</pre><p>
      キーによるテーブルのパーティション化の一般情報は、<a class="xref" href="partitioning.html#partitioning-key" title="24.2.5 KEY パーティショニング">セクション24.2.5「KEY パーティショニング」</a> を参照してください。
    </p><p><a name="partitioning-limitations-subpartitions"></a><b>サブパーティションに関する問題. </b><a class="indexterm" name="idm45807909013504"></a><a class="indexterm" name="idm45807909011376"></a>
        サブパーティションは <code class="literal">HASH</code> または <code class="literal">KEY</code> パーティショニングを使用する必要があります。 サブパーティション化できるのは <code class="literal">RANGE</code> および <code class="literal">LIST</code> パーティションのみです。<code class="literal">HASH</code> および <code class="literal">KEY</code> パーティションはサブパーティション化できません。 
      </p><p>
      <a class="indexterm" name="idm45807909003888"></a> <code class="literal">SUBPARTITION BY KEY</code> では、<code class="literal">PARTITION BY KEY</code> の場合とは異なり、サブパーティション化カラムを明示的に指定する必要があります。ここでは省略できます (この場合、テーブルの主キーカラムがデフォルトで使用されます)。 次のステートメントによって作成されたテーブルがあるとします。 
    </p><pre class="programlisting">CREATE TABLE ts (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(30)
);
</pre><p>
      次のようなステートメントを使用することで、<code class="literal">KEY</code> によってパーティション化された、同じカラムを持つテーブルを作成できます。
    </p><pre class="programlisting">CREATE TABLE ts (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(30)
)
PARTITION BY KEY()
PARTITIONS 4;
</pre><p>
      前のステートメントは、次のように記述されているかのように扱われます (テーブルの主キーカラムがパーティショニングカラムとして使用されます)。
    </p><pre class="programlisting">CREATE TABLE ts (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(30)
)
PARTITION BY KEY(id)
PARTITIONS 4;
        </pre><p>
      ただし、次のステートメントは、デフォルトカラムをサブパーティショニングカラムとして使用するサブパーティション化されたテーブルを作成しようとするため失敗します。このステートメントが成功するには次のようにカラムを指定する必要があります。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE ts (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,</code></strong>
    -&gt;     <strong class="userinput"><code>name VARCHAR(30)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY RANGE(id)</code></strong>
    -&gt; <strong class="userinput"><code>SUBPARTITION BY KEY()</code></strong>
    -&gt; <strong class="userinput"><code>SUBPARTITIONS 4</code></strong>
    -&gt; <strong class="userinput"><code>(</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (100),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (MAXVALUE)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
<span class="errortext">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that
corresponds to your MySQL server version for the right syntax to use near ')</span>

mysql&gt; <strong class="userinput"><code>CREATE TABLE ts (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,</code></strong>
    -&gt;     <strong class="userinput"><code>name VARCHAR(30)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY RANGE(id)</code></strong>
    -&gt; <strong class="userinput"><code>SUBPARTITION BY KEY(id)</code></strong>
    -&gt; <strong class="userinput"><code>SUBPARTITIONS 4</code></strong>
    -&gt; <strong class="userinput"><code>(</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (100),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (MAXVALUE)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.07 sec)
</pre><p>
      これは既知の問題です (Bug #51470 を参照してください)。
    </p><p><b>DATA DIRECTORY および INDEX DIRECTORY オプション. </b>
        テーブルレベル <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> オプションは無視されます (Bug #32091 を参照してください)。 これらのオプションは、<code class="literal">InnoDB</code> テーブルの個々のパーティションまたはサブパーティションに使用できます。 MySQL 8.0.21 では、<code class="literal">DATA DIRECTORY</code> 句で指定されたディレクトリは <code class="literal">InnoDB</code> で認識されている必要があります。 詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-create-table-external-data-directory" title="DATA DIRECTORY 句の使用">DATA DIRECTORY 句の使用</a>を参照してください。 
      </p><p><b>パーティション化されたテーブルを修復および再構築する. </b>
        ステートメント <code class="literal">CHECK TABLE</code>、<code class="literal">OPTIMIZE TABLE</code>、<code class="literal">ANALYZE TABLE</code>、および <code class="literal">REPAIR TABLE</code> がパーティション化されたテーブルでサポートされます。
      </p><p>
      また、<code class="literal">ALTER TABLE ... REBUILD PARTITION</code> を使用することで、パーティション化されたテーブルの 1 つ以上のパーティションを再構築できます。<code class="literal">ALTER TABLE ... REORGANIZE PARTITION</code> でもパーティションが再構築されます。 これら 2 つのステートメントの詳細については、<a class="xref" href="sql-statements.html#alter-table" title="13.1.9 ALTER TABLE ステートメント">セクション13.1.9「ALTER TABLE ステートメント」</a>を参照してください。 
    </p><p>
      サブパーティションでは、<code class="literal">ANALYZE</code>, <code class="literal">CHECK</code>, <code class="literal">OPTIMIZE</code>, <code class="literal">REPAIR</code> および <code class="literal">TRUNCATE</code> 操作がサポートされています。 <a class="xref" href="sql-statements.html#alter-table-partition-operations" title="13.1.9.1 ALTER TABLE パーティション操作">セクション13.1.9.1「ALTER TABLE パーティション操作」</a>を参照してください。 
    </p><p><b>パーティションおよびサブパーティションのファイル名デリミタ. </b>
        テーブルパーティションおよびサブパーティションファイルの名前には、<code class="literal">#P#</code>や<code class="literal">#SP#</code>などの生成されたデリミタが含まれます。 このようなデリミタの大文字と小文字は異なる場合があるため、依存しないでください。 
      </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-limitations-partitioning-keys-unique-keys"></a>24.6.1 パーティショニングキー、主キー、および一意キー</h3></div></div></div><a class="indexterm" name="idm45807908951248"></a><a class="indexterm" name="idm45807908949792"></a><a class="indexterm" name="idm45807908947696"></a><a class="indexterm" name="idm45807908946272"></a><a class="indexterm" name="idm45807908944176"></a><p>
        このセクションでは、パーティショニングキーと主キーおよび一意キーとの関係について説明します。 この関係を制御するルールは次のように表現できます。パーティション化されたテーブルのパーティショニング式で使用されるすべてのカラムは、テーブルが持つことができるすべての一意キーの一部である必要があります。 
      </p><p>
        つまり、<span class="emphasis"><em>テーブルのすべての一意キーは、テーブルパーティション化式のすべてのカラムを使用する必要があります</em></span>です。 (これには、定義上一意のキーであるため、テーブルの主キーも含まれます。 この点については、このセクションで後述します)。 たとえば、次の各テーブル作成ステートメントは無効です。 
      </p><pre class="programlisting">CREATE TABLE t1 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    UNIQUE KEY (col1, col2)
)
PARTITION BY HASH(col3)
PARTITIONS 4;

CREATE TABLE t2 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    UNIQUE KEY (col1),
    UNIQUE KEY (col3)
)
PARTITION BY HASH(col1 + col3)
PARTITIONS 4;
</pre><p>
        どちらの場合も、記述されたテーブルには、パーティショニング式に使用されているすべてのカラムを含んでいない一意キーが少なくとも 1 つあります。
      </p><p>
        次の各ステートメントは有効で、対応する無効なテーブル作成ステートメントを機能させる 1 つの方法を示しています。
      </p><pre class="programlisting">CREATE TABLE t1 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    UNIQUE KEY (col1, col2, col3)
)
PARTITION BY HASH(col3)
PARTITIONS 4;

CREATE TABLE t2 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    UNIQUE KEY (col1, col3)
)
PARTITION BY HASH(col1 + col3)
PARTITIONS 4;
</pre><p>
        次の例は、そのような場合に生成されるエラーを示しています。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t3 (</code></strong>
    -&gt;     <strong class="userinput"><code>col1 INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>col2 DATE NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>col3 INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>col4 INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>UNIQUE KEY (col1, col2),</code></strong>
    -&gt;     <strong class="userinput"><code>UNIQUE KEY (col3)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY HASH(col1 + col3)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITIONS 4;</code></strong>
<span class="errortext">ERROR 1491 (HY000): A PRIMARY KEY must include all columns in the table's partitioning function</span>
</pre><p>
        この <code class="literal">CREATE TABLE</code> ステートメントは、指定されたパーティショニングキーに <code class="literal">col1</code> および <code class="literal">col3</code> が含まれているけれども、これらのカラムのいずれもテーブルの両方の一意キーの一部でないために、失敗します。 無効なテーブル定義の考えられる解決策の 1 つを次に示します。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t3 (</code></strong>
    -&gt;     <strong class="userinput"><code>col1 INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>col2 DATE NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>col3 INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>col4 INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>UNIQUE KEY (col1, col2, col3),</code></strong>
    -&gt;     <strong class="userinput"><code>UNIQUE KEY (col3)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY HASH(col3)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITIONS 4;</code></strong>
Query OK, 0 rows affected (0.05 sec)
</pre><p>
        この場合、指定されたパーティショニングキー <code class="literal">col3</code> は両方の一意キーの一部であるため、このテーブル作成ステートメントは成功します。
      </p><p>
        次のテーブルは、両方の一意キーに属するカラムをパーティショニングキーに含めることができないため、パーティション化できません。
      </p><pre class="programlisting">CREATE TABLE t4 (
    col1 INT NOT NULL,
    col2 INT NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    UNIQUE KEY (col1, col3),
    UNIQUE KEY (col2, col4)
);
</pre><p>
        すべての主キーは自明で一意キーであるため、この制約にはテーブルの主キーも含まれます (ある場合)。 たとえば、次の 2 つのステートメントは無効です。 
      </p><pre class="programlisting">CREATE TABLE t5 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    PRIMARY KEY(col1, col2)
)
PARTITION BY HASH(col3)
PARTITIONS 4;

CREATE TABLE t6 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    PRIMARY KEY(col1, col3),
    UNIQUE KEY(col2)
)
PARTITION BY HASH( YEAR(col2) )
PARTITIONS 4;
</pre><p>
        どちらの場合も、パーティショニング式で参照されるすべてのカラムが主キーに含まれていません。 ただし、次の 2 つのステートメントは両方とも有効です。 
      </p><pre class="programlisting">CREATE TABLE t7 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    PRIMARY KEY(col1, col2)
)
PARTITION BY HASH(col1 + YEAR(col2))
PARTITIONS 4;

CREATE TABLE t8 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    PRIMARY KEY(col1, col2, col4),
    UNIQUE KEY(col2, col1)
)
PARTITION BY HASH(col1 + YEAR(col2))
PARTITIONS 4;
</pre><p>
        テーブルに一意キーがない場合 (主キーがない場合を含む) はこの制約は適用されず、カラム型がパーティショニングタイプと互換性があるかぎり、パーティショニング式に任意のカラムを使用できます。
      </p><p>
        同じ理由で、テーブルのパーティショニング式で使用されるすべてのカラムが一意キーに含まれている場合を除き、パーティション化されたテーブルにあとから一意キーを追加することはできません。 次のように作成されたパーティション化されたテーブルがあるとします。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t_no_pk (c1 INT, c2 INT)</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION BY RANGE(c1) (</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (10),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (20),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (30),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (40)</code></strong>
    -&gt;     <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.12 sec)
</pre><p>
        次のいずれかの <code class="literal">ALTER TABLE</code> ステートメントを使用することで、<code class="literal">t_no_pk</code> に主キーを追加できます。
      </p><pre class="programlisting">#  possible PK
mysql&gt; <strong class="userinput"><code>ALTER TABLE t_no_pk ADD PRIMARY KEY(c1);</code></strong>
Query OK, 0 rows affected (0.13 sec)
Records: 0  Duplicates: 0  Warnings: 0

# drop this PK
mysql&gt; <strong class="userinput"><code>ALTER TABLE t_no_pk DROP PRIMARY KEY;</code></strong>
Query OK, 0 rows affected (0.10 sec)
Records: 0  Duplicates: 0  Warnings: 0

#  use another possible PK
mysql&gt; <strong class="userinput"><code>ALTER TABLE t_no_pk ADD PRIMARY KEY(c1, c2);</code></strong>
Query OK, 0 rows affected (0.12 sec)
Records: 0  Duplicates: 0  Warnings: 0

# drop this PK
mysql&gt; <strong class="userinput"><code>ALTER TABLE t_no_pk DROP PRIMARY KEY;</code></strong>
Query OK, 0 rows affected (0.09 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
        ただし、次のステートメントは失敗します。<code class="literal">c1</code> は、パーティショニングキーの一部ですが、指定された主キーの一部ではないためです。
      </p><pre class="programlisting">#  fails with error 1503
mysql&gt; <strong class="userinput"><code>ALTER TABLE t_no_pk ADD PRIMARY KEY(c2);</code></strong>
<span class="errortext">ERROR 1503 (HY000): A PRIMARY KEY must include all columns in the table's partitioning function</span>
</pre><p>
        <code class="literal">t_no_pk</code> のパーティショニング式は <code class="literal">c1</code> のみであるため、<code class="literal">c2</code> のみに一意キーを追加しようとすると失敗します。 ただし、<code class="literal">c1</code> および <code class="literal">c2</code> の両方を使用する一意キーは追加できます。 
      </p><p>
        これらのルールは、既存のパーティション化されていないテーブルを <code class="literal">ALTER TABLE ... PARTITION BY</code> を使用してパーティション化するときにも適用されます。 次のように作成されたテーブル <code class="literal">np_pk</code> があるとします。 
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE np_pk (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT NOT NULL AUTO_INCREMENT,</code></strong>
    -&gt;     <strong class="userinput"><code>name VARCHAR(50),</code></strong>
    -&gt;     <strong class="userinput"><code>added DATE,</code></strong>
    -&gt;     <strong class="userinput"><code>PRIMARY KEY (id)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.08 sec)
</pre><p>
        次の <code class="literal">ALTER TABLE</code> ステートメントは、<code class="literal">added</code> カラムがテーブルの一意キーの一部でないため、エラーで失敗します。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE np_pk</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION BY HASH( TO_DAYS(added) )</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITIONS 4;</code></strong>
<span class="errortext">ERROR 1503 (HY000): A PRIMARY KEY must include all columns in the table's partitioning function</span>
</pre><p>
        ただし、次に示すように、パーティショニングカラムに <code class="literal">id</code> カラムを使用する次のステートメントは有効です。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE np_pk</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION BY HASH(id)</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITIONS 4;</code></strong>
Query OK, 0 rows affected (0.11 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
        <code class="literal">np_pk</code> の場合、パーティショニング式の一部として使用できる唯一のカラムは <code class="literal">id</code> です。このテーブルをパーティショニング式でほかのカラムを使用してパーティション化する場合は、目的のカラムを主キーに追加するか、主キーをすべて削除することによって、まずテーブルを変更する必要があります。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-limitations-storage-engines"></a>24.6.2 ストレージエンジンに関連するパーティショニング制限</h3></div></div></div><a class="indexterm" name="idm45807908860608"></a><p>
        MySQL 8.0 では、パーティショニングサポートは実際には MySQL Server によって提供されるのではなく、テーブルストレージエンジンの所有するパーティショニングハンドラまたはネイティブパーティショニングハンドラによって提供されます。 MySQL 8.0 では、<code class="literal">InnoDB</code> ストレージエンジンのみがネイティブのパーティショニングハンドラを提供します。 つまり、パーティション化されたテーブルは、ほかのストレージエンジンを使用して作成できません。 
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL Cluster <code class="literal">NDB</code> ストレージエンジンは、ネイティブパーティショニングサポートも提供しますが、MySQL 8.0 では現在サポートされていません。
        </p></div><p>
        <code class="literal">ALTER TABLE ... OPTIMIZE PARTITION</code> は、<code class="literal">InnoDB</code> を使用するパーティションテーブルでは正しく機能しません。 そのようなテーブルの場合は、代わりに <code class="literal">ALTER TABLE ... REBUILD PARTITION</code> および <code class="literal">ALTER TABLE ... ANALYZE PARTITION</code> を使用してください。 詳細は、<a class="xref" href="sql-statements.html#alter-table-partition-operations" title="13.1.9.1 ALTER TABLE パーティション操作">セクション13.1.9.1「ALTER TABLE パーティション操作」</a>を参照してください。 
      </p><p><a name="partitioning-limitations-ndb"></a><b>ユーザー定義のパーティション分割と NDB ストレージエンジン (NDB Cluster). </b>
          <code class="literal">KEY</code> (<code class="literal">LINEAR KEY</code> を含む) によるパーティショニングは、<code class="literal">NDB</code> ストレージエンジンでサポートされる唯一のパーティショニングタイプです。 「NDB Cluster」の通常の状況では、[<code class="literal">LINEAR</code>] <code class="literal">KEY</code> 以外のパーティション化タイプを使用して「NDB Cluster」テーブルを作成することはできず、作成しようとするとエラーで失敗します。 
        </p><p>
        <span class="emphasis"><em>例外 (本番用ではない)</em></span>: NDB Cluster SQL ノード上の <code class="literal">new</code> システム変数を <code class="literal">ON</code> に設定することで、この制限をオーバーライドできます。 これを行う場合、<code class="literal">[LINEAR] KEY</code> 以外のパーティション化タイプを使用するテーブルは本番でサポートされないことに注意してください。 <span class="emphasis"><em>「このような場合は、<code class="literal">KEY</code> または <code class="literal">LINEAR KEY</code> 以外のパーティション化タイプのテーブルを作成して使用できますが、これは完全にリスクがあります」</em></span>。 
      </p><p>
        <code class="literal">NDB</code> テーブルに定義できるパーティションの最大数は、クラスタ内のデータノードとノードグループの数、使用中の NDB Cluster ソフトウェアのバージョン、およびその他の要因によって異なります。 詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-nodes-groups-user-partitioning" title="NDB とユーザー定義のパーティション化">NDB とユーザー定義のパーティション化</a>を参照してください。 
      </p><p>
        <code class="literal">NDB</code> テーブルのパーティションごとに格納できる固定サイズデータの最大量は 128 TB です。 以前は 16 GB でした。 
      </p><p>
        ユーザーパーティション化された <code class="literal">NDB</code> テーブルが次の 2 つの要件のいずれかまたは両方を満たさなくなる <code class="literal">CREATE TABLE</code> ステートメントおよび <code class="literal">ALTER TABLE</code> ステートメントは許可されず、エラーで失敗します。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            テーブルに明示的な主キーが存在する必要があります。
          </p></li><li class="listitem"><p>
            テーブルのパーティショニング式に指定されたすべてのカラムが主キーの一部である必要があります。
          </p></li></ol></div><p><b>例外. </b>
          ユーザーパーティション化された <code class="literal">NDB</code> テーブルが空のカラムリストを使用して (つまり、<code class="literal">PARTITION BY KEY()</code> または <code class="literal">PARTITION BY LINEAR KEY()</code> を使用して) 作成された場合、明示的な主キーは必要ありません。
        </p><p><b>パーティション化されたテーブルをアップグレードする. </b>
          アップグレードを実行する場合は、<code class="literal">KEY</code> によってパーティション化されたテーブルをダンプしてリロードする必要があります。 <code class="literal">InnoDB</code> 以外のストレージエンジンを使用するパーティション化されたテーブルは、MySQL 5.7 以前から MySQL 8.0 以降にアップグレードできません。<code class="literal">ALTER TABLE ... REMOVE PARTITIONING</code> を使用してこのようなテーブルからパーティション化を削除するか、アップグレード前に <code class="literal">ALTER TABLE ... ENGINE=INNODB</code> を使用して <code class="literal">InnoDB</code> に変換する必要があります。 
        </p><p>
        <code class="literal">MyISAM</code> テーブルの <code class="literal">InnoDB</code> への変換の詳細は、<a class="xref" href="innodb-storage-engine.html#converting-tables-to-innodb" title="15.6.1.5 MyISAM から InnoDB へのテーブルの変換">セクション15.6.1.5「MyISAM から InnoDB へのテーブルの変換」</a> を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-limitations-functions"></a>24.6.3 関数に関連するパーティショニング制限</h3></div></div></div><p>
        このセクションでは特に、パーティショニング式で使用される関数に関連する、MySQL パーティショニングの制限について説明します。
      </p><a class="indexterm" name="idm45807908811552"></a><p>
        パーティション化式で使用できるのは、次のリストに示す MySQL 関数のみです:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">ABS()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">CEILING()</code> (<a class="xref" href="partitioning.html#partitioning-limitations-ceiling-floor" title="CEILING() および FLOOR()">CEILING() および FLOOR()</a>を参照してください)
          </p></li><li class="listitem"><p>
            <code class="literal">DATEDIFF()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">DAY()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">DAYOFMONTH()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">DAYOFWEEK()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">DAYOFYEAR()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">EXTRACT()</code> (<a class="xref" href="partitioning.html#partitioning-limitations-extract" title="WEEK 指定子付きの EXTRACT() 関数">WEEK 指定子付きの EXTRACT() 関数</a>を参照してください)
          </p></li><li class="listitem"><p>
            <code class="literal">FLOOR()</code> (<a class="xref" href="partitioning.html#partitioning-limitations-ceiling-floor" title="CEILING() および FLOOR()">CEILING() および FLOOR()</a>を参照してください)
          </p></li><li class="listitem"><p>
            <code class="literal">HOUR()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">MICROSECOND()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">MINUTE()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">MOD()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">MONTH()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">QUARTER()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">SECOND()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">TIME_TO_SEC()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">TO_DAYS()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">TO_SECONDS()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">UNIX_TIMESTAMP()</code> (<code class="literal">TIMESTAMP</code> カラムを含む)
          </p></li><li class="listitem"><p>
            <code class="literal">WEEKDAY()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">YEAR()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">YEARWEEK()</code>
          </p></li></ul></div><p>
        MySQL 8.0 では、<code class="literal">TO_DAYS()</code>, <code class="literal">TO_SECONDS()</code>, <code class="literal">YEAR()</code> および <code class="literal">UNIX_TIMESTAMP()</code> 関数でパーティションプルーニングがサポートされています。 詳細は、<a class="xref" href="partitioning.html#partitioning-pruning" title="24.4 パーティションプルーニング">セクション24.4「パーティションプルーニング」</a>を参照してください。 
      </p><p><a name="partitioning-limitations-ceiling-floor"></a><b>CEILING() および FLOOR(). </b>
          これらの各関数は、正確な数値型 (<code class="literal">INT</code> 型または <code class="literal">DECIMAL</code> 型のいずれかなど) の引数を渡された場合にのみ整数を返します。 これはたとえば、次の <code class="literal">CREATE TABLE</code> ステートメントがここで示すようにエラーで失敗することを意味します。 
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t (c FLOAT) PARTITION BY LIST( FLOOR(c) )(</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES IN (1,3,5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES IN (2,4,6)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
<span class="errortext">ERROR 1490 (HY000): The PARTITION function returns the wrong type</span>
</pre><p><a name="partitioning-limitations-extract"></a><b>WEEK 指定子付きの EXTRACT() 関数. </b>
          <code class="literal">EXTRACT()</code> 関数によって返される値は、<code class="literal">EXTRACT(WEEK FROM <em class="replaceable"><code>col</code></em>)</code> として使用されるときに、<code class="literal">default_week_format</code> システム変数の値に依存します。 このため、ユニットを <code class="literal">WEEK</code> として指定した場合、<code class="literal">EXTRACT()</code> はパーティション化関数として許可されません。 (Bug #54483) 
        </p><p>
        これらの関数の戻り型についての詳細は、<a class="xref" href="functions.html#mathematical-functions" title="12.6.2 数学関数">セクション12.6.2「数学関数」</a>および<a class="xref" href="data-types.html#numeric-types" title="11.1 数値データ型">セクション11.1「数値データ型」</a>を参照してください。
      </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="mysql-cluster.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="stored-objects.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第 23 章 MySQL NDB Cluster 8.0 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第 25 章 ストアドオブジェクト</td></tr></table></div><div class="copyright-footer"></div></body></html>
